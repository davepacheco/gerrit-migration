#!/usr/bin/env python3
#
# A tool to archive all of https://cr.joyent.us CRs to a local "./archive" dir.
#
# Assumptions:
# - An entry in "~/.ssh/config" equivalent to the following:
#        Host cr
#            User trentm
#            Hostname cr.joyent.us
#            Port 29418
#            ControlMaster no
# - A key that works for `ssh cr gerrit --help`
#
# Usage:
#   ./bin/cr.joyent.us-archive ARCHIVE-DIR
#

import codecs
import json
import os
from pprint import pprint
from subprocess import run, PIPE
import sys
import time


#---- globals/config

if False:
    # Typically good default config values.
    skipRepoRefetch = False
    gerritUser = os.environ['USER']
    hackRepoSkips = []
    cloneTimeoutS = 600
    regenerateAllChanges = True
else:
    # Temporary hack to lighten load on flaky cr.joyent.us.
    skipRepoRefetch = True
    # Temporary hack to avoid 'root'.
    gerritUser = 'trentm'
    # Temporary hack to avoid certain projects/repos for a run.
    hackRepoSkips = [
        'joyent/illumos-joyent'
    ]
    cloneTimeoutS = 600
    # For quicker/reliable re-runs on crashes, for now we'll not regenerate.
    regenerateAllChanges = False

# Projects (repos) to skip because of cloning problems with the cr.joyent.us
# data.
repoSkips = [
    # This fails:
    #   $ git clone trentm@cr.joyent.us:joyent/postgres.git
    #   Cloning into 'postgres'...
    #   remote: Counting objects: 649247, done
    #   fatal: internal server error
    #   remote: internal server error
    #   fatal: early EOF
    #   fatal: index-pack failed
    'joyent/postgres',

    # This hangs:
    #   $ git clone trentm@cr.joyent.us:All-Projects.git
    #   Cloning into 'All-Projects'...
    'All-Projects'
]

#---- support stuff

def clip(s, length):
    if len(s) <= length:
        return s
    else:
        return s[:length - 3] + '...'

def gerritQuery(queryArgv):
    sshArgv = [
        'ssh', '-q', '-o', 'TCPKeepAlive=yes', '-o', 'StrictHostKeyChecking=no',
        '-o', 'UserKnownHostsFile=/dev/null', '-o', 'ConnectTimeout=10',
        'cr', 'gerrit', 'query',
    ] + queryArgv
    res = run(sshArgv, stdout=PIPE, stderr=PIPE, check=True,
        universal_newlines=True)
    return res.stdout

def gerritGetChangeJson(number):
    output = gerritQuery([
        '--format=JSON',
        '--files', '--comments', '--all-reviewers', '--all-approvals',
        '--current-patch-set', '--', 'change:' + number])
    return output.splitlines()[0]

def updateBareRepo(project, tmpDir):
    repoUrl = '{}@cr.joyent.us:{}.git'.format(gerritUser, project)
    repoDir = os.path.join(tmpDir, 'repos', project + '.git')
    if os.path.isdir(repoDir):
        if not skipRepoRefetch:
            print('    "git fetch" in "{}"'.format(repoDir))
            run(['git', 'fetch'], cwd=repoDir,
                check=True, stdout=PIPE, stderr=PIPE, timeout=5)
    else:
        wrkDir = os.path.dirname(repoDir)
        if not os.path.isdir(wrkDir):
            os.makedirs(wrkDir)
        print('    "git clone --mirror {}" in "{}"'.format(repoUrl, wrkDir))
        run(['git', 'clone', '--mirror', repoUrl], cwd=wrkDir,
            check=True, timeout=cloneTimeoutS)
    return repoDir

def gitShow(repoDir, revision):
    # Explicitly do *not* convert this to string. We don't know an appropriate
    # encoding, in general.
    print('    "git show {}" in "{}"'.format(revision, repoDir))
    res = run(['git', 'show', revision], cwd=repoDir,
        check=True, stdout=PIPE, stderr=PIPE, timeout=5)
    return res.stdout

def archiveChange(change, archiveDir, tmpDir):
    if change['project'] in hackRepoSkips:
        print('    HACK: skip project {} for now'.format(change['project']))
        return

    changeDir = os.path.join(archiveDir, change['number'])
    if not os.path.isdir(changeDir):
        os.mkdir(changeDir)

    output = gerritGetChangeJson(change['number'])
    changeInfo = json.loads(output)

    # Gather diffs for patchsets.
    if changeInfo['project'] in repoSkips:
        print('    warning: skip project "{}" repo clone, because it fails'
            .format(changeInfo['project']))
    else:
        if len(changeInfo['patchSets']) == 0:
            return
        print('    clone {}.git in {}'.format(changeInfo['project'], tmpDir))
        repoDir = updateBareRepo(changeInfo['project'], tmpDir)
        for patchSet in changeInfo['patchSets']:
            #pprint(patchSet)
            diff = gitShow(repoDir, patchSet['revision'])
            diffPath = os.path.join(changeDir,
                'patchSet-{}.diff'.format(patchSet['number']))
            print('    write', diffPath)
            with codecs.open(diffPath, 'wb') as f:
                f.write(diff)
        # The "currentPatchSet" is a dupe, but can be convenient to have a
        # well-known name for the latest one.
        diff = gitShow(repoDir, changeInfo['currentPatchSet']['revision'])
        diffPath = os.path.join(changeDir, 'currentPatchSet.diff')
        print('    write', diffPath)
        with codecs.open(diffPath, 'wb') as f:
            f.write(diff)

    # Write the change.json last because it is used as the marker for
    # this dump having completed.
    changePath = os.path.join(changeDir, 'change.json')
    print('    write', changePath)
    with codecs.open(changePath, 'w', 'utf8') as f:
        f.write(output)


#---- mainline

def main(argv):
    if len(argv) < 2:
        print('{}: error: missing ARCHIVE-DIR argument'.format(__file__),
            file=sys.stderr)
        return 1

    archiveDir = sys.argv[1]
    if not os.path.isdir(archiveDir):
        os.makedirs(archiveDir)

    allChangesJson = os.path.join(archiveDir, 'all-changes.json')
    tmpDir = '/var/tmp/cr.joyent.us-archive'

    if regenerateAllChanges:
        # (Re-)generate archive/all-changes.json.
        print("Listing all changes")
        start = 0
        limit = 500
        moreChanges = True
        allChanges = []
        while moreChanges:
            print('  get one page: start={:4d} limit={}'.format(start, limit))
            output = gerritQuery([
                '--format=JSON',
                '--start={}'.format(start),
                '--',
                'age:0s',
                'limit:{}'.format(limit)
            ])
            for line in output.splitlines():
                record = json.loads(line)
                if record.get('type') == 'stats':
                    moreChanges = record['moreChanges']
                    start += limit
                else:
                    allChanges.append(record)

        print('  write', allChangesJson)
        with codecs.open(allChangesJson, 'w', 'utf8') as f:
            for change in allChanges:
                f.write(json.dumps(change) + '\n')
    else:
        # Load archive/all-changes.json from disk. This is typically *not*
        # done.
        allChanges = []
        with codecs.open(allChangesJson, 'r', 'utf8') as f:
            for line in f.readlines():
                allChanges.append(json.loads(line))

    # Update each change
    print('Update all changes')
    for i, change in enumerate(allChanges):
        print(
            '  [{:4d}/{}] https://cr.joyent.us/{} ... '.format(
                i + 1,
                len(allChanges),
                change['number']
            ),
            end=''
        )
        changeJson = os.path.join(archiveDir, change['number'], 'change.json')
        try:
            with codecs.open(changeJson, 'r', 'utf8') as f:
                oldChange = json.load(f)
        except FileNotFoundError:
            oldChange = None
        if oldChange and oldChange['lastUpdated'] == change['lastUpdated']:
            print('up to date')
        else:
            print('need to update')
            archiveChange(change, archiveDir, tmpDir)


if __name__ == '__main__':
    sys.exit(main(sys.argv))
