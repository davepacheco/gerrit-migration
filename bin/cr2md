#!/usr/bin/env python3
#
# A tool to generate a GitHub PR Markdown comment summarizing a CR change.json.
# The idea will be to include this in the migrated PRs.
#
# Usage:
#   ./bin/cr2md CHANGE-JSON
#
# Example:
#   ./bin/cr2md ./archive/1207/change.json
#

import codecs
from datetime import datetime
import json
import re
import sys
from pprint import pprint


#---- globals/config


#---- support stuff

def mdquote(s):
    lines = s.splitlines(True)
    return '> ' + '> '.join(lines)

def squeeze(s):
    '''
    Squeeze some empty lines on some comment patterns:

    - fewer newlines here:
        New commits:

            commit b76d86d278bde597f3d4ad485ee24de7ff4b5dd0

            add returnErrorOnly option to client.get and use that
    '''

    if 'New commits:' in s:
        s = re.compile(r'^New commits:\n *\n', re.M).sub('New commits:  \n', s)
        s = re.compile(r'^(    commit [a-f0-9]+)\n *\n', re.M).sub(r'\1  \n', s)
    return s

def indent(s, indentation):
    return indentation + indentation.join(s.splitlines(True))

#---- mainline

def main(argv):
    if len(argv) < 2:
        print('{}: error: missing CHANGE-JSON argument'.format(__file__),
            file=sys.stderr)
        return 1

    changeJsonPath = sys.argv[1]
    with codecs.open(changeJsonPath, 'r', 'utf8') as f:
        change = json.loads(f.read())
    #pprint(change)

    # Header
    #
    # The first line of this is used by `hub pull-request -F FILE` as the
    # the title of the GitHub PR.
    #
    # The "migrated-from-gerrit" is a search target for being able to list
    # all PRs migrated with this tool.
    md = '''\
{}

{}

This PR was migrated-from-gerrit, <https://cr.joyent.us/#/c/{}/>.
The raw archive of this CR is [here]({}).
See [MANTA-4594](https://smartos.org/bugview/MANTA-4594) for info on Joyent Eng's migration from Gerrit.'''.format(
        change['subject'],
        change['commitMessage'],
        change['number'],
        'https://github.com/joyent/gerrit-migration/tree/master/archive/' + change['number']
    )

    # Try to reconstruct any CR and patch set comments. This is sketchy because:
    # - The "change.json" doesn't have timestamps on the patchSet[*].comments.
    # - "Patch Set 11:\n\n(5 comments)" in a top-level comment does *not*
    #   imply that all 5 of those comments on are patch set 11. Some of them
    #   might be on earlier patch sets.
    #
    # So there is no way to exactly reconstruct what the Gerrit HTML UI shows
    # for discussion from the CR data dump from the API. We'll do our best.
    comments = []
    lastPs = -1
    for i, comment in enumerate(change['comments']):
        match = re.compile(r'^Uploaded patch set (\d+)\.$').search(comment['message'])
        if match:
            # Skip this comment. It is generic and signal-free.
            #
            # However, use this as the signal to show all comments specifically
            # on the preceding patch set. This was we get (a) top-level
            # comments when patchSet N is current, then (b) all comments on
            # code in patchSet N.
            lastPs = int(match.group(1)) - 1
            if lastPs > 0 and 'comments' in change['patchSets'][lastPs - 1]:
                msgBits = []
                for c in change['patchSets'][lastPs - 1]['comments']:
                    #pprint(c, stream=sys.stderr)
                    msgBits.append('###### {}#{} @{}  \n\n{}'.format(
                        c['file'],
                        c['line'],
                        c['reviewer']['username'],
                        mdquote(c['message'])
                    ))
                comments.append(
                    '##### Patch Set {} code comments\n\n'.format(lastPs)
                    + mdquote('\n\n'.join(msgBits))
                )
        elif re.compile(r'^Change has been successfully merged').search(comment['message']):
            # Example:
            #    {'message': 'Change has been successfully merged by David Pacheco',
            #     'reviewer': {'email': 'no-reply@cr.joyent.us', 'name': 'Gerrit Code Review'},
            #     'timestamp': 1472492665}
            comments.append('##### {}\n\n{}'.format(
                datetime.utcfromtimestamp(comment['timestamp']).isoformat(),
                mdquote(squeeze(comment['message']))
            ))
        elif comment['reviewer']['username'] == 'joyent-automation':
            # These are low signal.
            pass
        else:
            comments.append('##### @{} commented at {}\n\n{}'.format(
                comment['reviewer']['username'],
                datetime.utcfromtimestamp(comment['timestamp']).isoformat(),
                mdquote(squeeze(comment['message']))
            ))

    lastPs = len(change['patchSets'])
    if lastPs > 0 and 'comments' in change['patchSets'][lastPs - 1]:
        msgBits = []
        for c in change['patchSets'][lastPs - 1]['comments']:
            #pprint(c, stream=sys.stderr)
            msgBits.append('###### {}#{} @{}  \n\n{}'.format(
                c['file'],
                c['line'],
                c['reviewer']['username'],
                mdquote(c['message'])
            ))
        comments.append(
            '##### Patch Set {} code comments\n\n'.format(lastPs)
            + mdquote('\n\n'.join(msgBits))
        )

    if comments:
        md += '\n\n## CR discussion\n\n' + '\n\n'.join(comments)

    print(md)

if __name__ == '__main__':
    sys.exit(main(sys.argv))
