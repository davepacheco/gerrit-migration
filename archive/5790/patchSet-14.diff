commit 5099754676e1c5d288a6e3e67d3bc043d0084373
Author: Rui Loura <rui@joyent.com>
Date:   2019-04-01T17:48:58+00:00 (6 months ago)
    
    TRITON-764 Remove DAPI logic from vmapi provision workflow

diff --git a/lib/apis/wfapi.js b/lib/apis/wfapi.js
index cc0861a..c07024d 100644
--- a/lib/apis/wfapi.js
+++ b/lib/apis/wfapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -162,6 +162,10 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     params['x-request-id'] = req.getId();
     delete params.uuid;
     params.filteredNetworks = filteredNetworks;
+    params.nics = filteredNetworks.nics;
+    params.server_uuid = req.vm.server_uuid;
+    params.vmTicket = req.vmTicket;
+    params.fabricNatNics = req.fabricNatNics;
 
     setContext(req, params);
 
@@ -170,6 +174,7 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     if (req.params.origin !== undefined)
         params.origin = req.params.origin;
 
+    req.log.debug({params: params}, 'creating provision job');
     self.client.createJob('provision', params, options, function (err, job) {
         if (err) {
             cb(err);
@@ -457,7 +462,7 @@ Wfapi.prototype.createUpdateJob = function (req, payload, cb) {
     params.target = '/update-' + vm_uuid;
     params.vm_uuid = vm_uuid;
     params.image_uuid = req.vm.image_uuid;
-    params.vm_brand = req.vm.brand;
+    params.vm_brand = req.vm.brand; // XXX: is this used?
     params.owner_uuid = req.vm.owner_uuid;
     params.server_uuid = req.vm.server_uuid;
     params.last_modified = req.vm.last_modified;
@@ -499,12 +504,13 @@ Wfapi.prototype.createUpdateJob = function (req, payload, cb) {
  * 'mac' is the MAC address of an already-existing NIC in NAPI (but not on the
  * VM), which will be now created on the VM by the job.
  */
-Wfapi.prototype.createAddNicsJob = function (req, params, cb) {
+Wfapi.prototype.createAddNicsJob = function createAddNicsJob(req, cb) {
     var self = this;
     var vm_uuid = req.vm.uuid;
     var options = { headers: { 'x-request-id': req.getId() } };
     var filteredNetworks = jsprim.deepCopy(req.filteredNetworks);
 
+    var params = {};
     params.task = 'add_nics';
     params.target = '/add-nics-' + vm_uuid;
     params.vm_uuid = vm_uuid;
@@ -516,6 +522,8 @@ Wfapi.prototype.createAddNicsJob = function (req, params, cb) {
     params['x-request-id'] = req.getId();
     params.sdc_nat_pool = req.params.sdc_nat_pool;
     params.filteredNetworks = filteredNetworks;
+    params.fabricNatNics = req.fabricNatNics;
+    params.add_nics = req.add_nics;
 
     setContext(req, params);
 
@@ -532,6 +540,7 @@ Wfapi.prototype.createAddNicsJob = function (req, params, cb) {
         params.wantResolvers = false;
     }
 
+    req.log.debug({params: params}, 'creating add nics job');
     self.client.createJob('add-nics', params, options, function (err, job) {
         if (err) {
             cb(err);
diff --git a/lib/changefeed.js b/lib/changefeed.js
index e5a2b6b..f5b5251 100644
--- a/lib/changefeed.js
+++ b/lib/changefeed.js
@@ -5,13 +5,13 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 
 /*
- * Creates an returns an instance of a mocked changefeed publisher that doesn't
+ * Creates and returns an instance of a mocked changefeed publisher that doesn't
  * publish changes. Not passing any changefeed publisher instance to the Moray
  * persistence layer is not an option, so a "no-op" publisher is useful when
  * writing tests or programs for which publishing changes to any changefeed
@@ -35,4 +35,4 @@ function createNoopCfPublisher() {
 
 module.exports = {
     createNoopCfPublisher: createNoopCfPublisher
-};
\ No newline at end of file
+};
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 050c22d..ddf9301 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -14,11 +14,12 @@
 
 var util = require('util');
 
-var async = require('async');
 var vasync = require('vasync');
 var VError = require('verror');
 var assert = require('assert-plus');
 var restify = require('restify');
+var sdc = require('sdc-clients');
+var jsprim = require('jsprim');
 
 var common = require('../common');
 var errors = require('../errors');
@@ -112,14 +113,17 @@ function renderVms(req, res, next) {
     // request per VM. This is done serially because we can't mess up the
     // original ordering returned by moray
     var vms = [];
-    async.eachSeries(req.vms, function (vm, cb) {
-        renderSingleVm(vm, function (err, newVm) {
-            if (err) {
-                return cb(err);
-            }
-            vms.push(newVm);
-            return cb();
-        });
+    vasync.forEachPipeline({
+        func: function renderOneVm(vm, cb) {
+            renderSingleVm(vm, function onRenderedVm(err, newVm) {
+                if (err) {
+                    return cb(err);
+                }
+                vms.push(newVm);
+                return cb();
+            });
+        },
+        inputs: req.vms
     }, function (err) {
         respond(err, vms);
     });
@@ -128,20 +132,23 @@ function renderVms(req, res, next) {
         var vm = {};
         var uuid = fullVm.uuid;
 
-        async.each(fields, function (field, cb) {
-            if (asyncFields[field]) {
-                asyncFields[field].call(moray, uuid, function (err, obj) {
-                    if (err) {
-                        return cb(err);
-                    }
+        vasync.forEachParallel({
+            func: function populateVmFields(field, cb) {
+                if (asyncFields[field]) {
+                    asyncFields[field].call(moray, uuid, function (err, obj) {
+                        if (err) {
+                            return cb(err);
+                        }
 
-                    vm[field] = obj;
+                        vm[field] = obj;
+                        return cb();
+                    });
+                } else {
+                    vm[field] = fullVm[field];
                     return cb();
-                });
-            } else {
-                vm[field] = fullVm[field];
-                return cb();
-            }
+                }
+            },
+            inputs: fields
         }, function (err) {
             if (err) {
                 return nextVm(err);
@@ -196,7 +203,7 @@ function preFilterVms(req, res, next) {
 function listVms(req, res, next) {
     req.log.trace('ListVms start');
 
-    function checkInternalMetadataSearchAvailable(done) {
+    function checkInternalMetadataSearchAvailable(_, done) {
         var err;
         var INTERNAL_METADATA_SEARCH_DATA_VER = 1;
         var internalMetadataSearchUsed;
@@ -229,7 +236,7 @@ function listVms(req, res, next) {
         done(err);
     }
 
-    function validateParams(done) {
+    function validateParams(_, done) {
         req.log.trace({params: req.params}, 'validating request params');
 
         common.validateListVmsParams(req.params, function validationDone(err) {
@@ -243,7 +250,7 @@ function listVms(req, res, next) {
         });
     }
 
-    function list(done) {
+    function list(_, done) {
         req.log.trace('listing vms');
 
         var params = common.clone(req.params);
@@ -292,13 +299,16 @@ function listVms(req, res, next) {
         });
     }
 
-    async.series([
-        validateParams,
-        checkInternalMetadataSearchAvailable,
-        list
-    ], function allDone(err) {
-        if (err)
-            req.log.debug({err: err});
+    vasync.pipeline({
+        funcs: [
+            validateParams,
+            checkInternalMetadataSearchAvailable,
+            list
+        ]
+    }, function allDone(err) {
+        if (err) {
+            req.log.error({err: err}, 'Error listing VMs');
+        }
         return next(err);
     });
 }
@@ -332,56 +342,18 @@ function getVmProc(req, res, next) {
     });
 }
 
-
 /*
  * GET /vms/:uuid
  */
 function getVm(req, res, next) {
     req.log.trace({ vm_uuid: req.params.uuid }, 'GetVm start');
-    var m = req.vm;
 
-    // if (m.server_uuid && req.params.sync && req.params.sync == 'true') {
     if (req.params.sync && req.params.sync == 'true') {
-        // Skip calling CNAPI when a VM hasn't been allocated to a server
-        if (m.server_uuid !== undefined) {
-            return req.app.cnapi.getVm(m.server_uuid, m.uuid, true, onGetVm);
-        } else {
-            return onGetVm(null, null);
-        }
-
+        _getVmSync(req, next);
+        return;
     } else {
-        return next();
-    }
-
-    // When ?sync=true first call CNAPI
-    function onGetVm(err, vm) {
-        if (err) {
-            return next(err);
-        }
-
-        if (vm) {
-            var newVm = common.translateVm(vm, true);
-            req.app.moray.putVm(newVm.uuid, newVm, req.vm, function (putErr) {
-                if (putErr) {
-                    req.log.error({ err: putErr, uuid: newVm.uuid },
-                        'Error storing VM on moray');
-                    return next(putErr);
-
-                }
-                req.log.debug('VM object %s updated in moray', newVm.uuid);
-                return next();
-            });
-
-        } else {
-            req.app.moray.markAsDestroyed(req.vm, function (markErr, modVm) {
-                if (markErr) {
-                    return next(markErr);
-                }
-
-                req.vm = modVm;
-                return next();
-            });
-        }
+        next();
+        return;
     }
 }
 
@@ -738,62 +710,95 @@ function changeVm(req, res, next) {
 }
 
 
-
 /*
- * Adds NICs to a VM
+ * For an array of MACs, load the corresponding NICs from NAPI so that they can
+ * be added to the zone.
  */
-function addNics(req, res, next) {
-    var params = req.params;
-    var networks = req.filteredNetworks.networks;
-
-    req.log.trace({ vm_uuid: params.uuid }, 'AddNics start');
+function loadNicsByMac(req, cb) {
+    var macs = req.params.macs;
+    var napi = req.app.napi;
 
-    var args;
+    if (!macs) {
+        cb(new VError('No MACs specified'));
+        return;
+    }
 
-    // we must receive either networks or mac as param
-    if (networks.length > 0) {
-        preProvisionNics(req, function onPreProvisionNics(err, results) {
+    function getNicFromMac(mac, next) {
+        napi.getNic(mac, function getNic(err, nic) {
             if (err) {
-                next(err);
-                return;
+                return next(err);
             }
-            args = { networks: params.networks };
-            doAddNics(args);
+
+            req.add_nics.push(nic);
+            addFabricNatNic(req, nic);
+            next();
         });
-    } else {
-        try {
-            common.validateMacs(params);
-        } catch (err) {
-            return next(err);
-        }
 
-        args = { macs: params.macs };
-        doAddNics(args);
     }
 
-    function doAddNics(creationArgs) {
+    vasync.forEachPipeline({
+        func: getNicFromMac,
+        inputs: macs
+    }, function done(err) {
+        if (err) {
+            cb(err);
+        } else {
+            req.log.info({ nics: req.add_nics }, 'NICs allocated');
+            cb();
+        }
+    });
+}
+
+/*
+ * Adds NICs to a VM
+ */
+function addNics(req, res, next) {
+    var params = req.params;
+
+    req.log.trace({ vm_uuid: params.uuid }, 'AddNics start');
+
+    function doAddNics(_, cb) {
         var config = req.app.options;
 
         // When adding a nic if a fabric nat is wanted but hasn't been setup yet
         // we will need to pass in sdc_nat_pool to the workflow job
+        // This is also done in the createVm() code path which sets all the VM
+        // defaults via common.setDefaultValues()
         if (config.overlay && config.overlay.enabled) {
             params.sdc_nat_pool = config.overlay.natPool;
         }
 
-        req.app.wfapi.createAddNicsJob(req, creationArgs, onAddNicsJob);
+        req.app.wfapi.createAddNicsJob(req, function onAddNicsJob(err, juuid) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            handleUpdateVMResponse(req, res, cb, juuid);
+        });
     }
 
-    function onAddNicsJob(err, juuid) {
+    vasync.pipeline({
+        arg: req,
+        funcs: [
+            getNicTagReqs,
+            getNicTags,
+            checkServerNicTags,
+            provisionNics,
+            doAddNics
+    ]}, function addNicsDone(err, results) {
         if (err) {
-            return next(err);
+            cleanupNics(req, function nicCleanupAttempt() {
+                req.log.info({err: err}, 'nics cleaned up, returning error');
+                next(err);
+            });
+            return;
         }
-
-        return handleUpdateVMResponse(req, res, next, juuid);
-    }
+        next(err);
+    });
 }
 
 
-
 /*
  * Updates NICs on a VM
  */
@@ -1364,32 +1369,35 @@ function setPrimaryNic(req, res, next) {
 }
 
 /*
- * Its better to pre-provision NICs up front so that any issues
- * can be reported back to the createVm caller before a workflow job is
- * kicked off.
- *
- * - Keep track of all NICs created in case we hit an error and need to
- *   cleanup.
- * - Keep track of fabric NICs so we can properly backfill the NIC object
- *   with important fields such as cn_uuid as a part of the workflow job.
- * - Save network pool NICs for later creation as we need to get a
- *   list of server NIC tags which happens today as a part of the
- *   workflow. If and when server selection is moved out of workflow, we will
- *   be able to handle network pools here as well.
+ * If this is a nic on a fabric, has no gateway provisioned, and the network
+ * requests an internet NAT, add it.
  */
-function preProvisionNics(req, cb) {
-    var napi = req.app.napi;
-    var inst_uuid = req.params.uuid;
+function addFabricNatNic(req, fNic) {
+    if (fNic && fNic.fabric && fNic.gateway && !fNic.gateway_provisioned &&
+        fNic.ip !== fNic.gateway && fNic.internet_nat) {
+
+        req.fabricNatNics.push(fNic);
+    }
+}
 
+/*
+ * Provisions additional NICs for a zone in NAPI if networks were provided to
+ * the job.
+ *
+ * The networks list can contain a not null ip attribute on each object, which
+ * denotes that we want to allocate that given IP for the correspondent network.
+ */
+function provisionNetNics(req, cb) {
     var filteredNetworks = req.filteredNetworks;
     var networks = filteredNetworks.networks;
+    var napi = req.app.napi;
+    var inst_uuid = req.params.uuid;
     var owner_uuid = req.params.owner_uuid || req.vm.owner_uuid;
     var nics = filteredNetworks.nics;
+    var macs = req.params.macs;
 
-    // Filter out pool networks, which will be handled later in workflow
-    networks = networks.filter(function filterOutPoolNets(net) {
-        return (filteredNetworks.pools.indexOf(net.ipv4_uuid) === -1);
-    });
+    assert.array(networks, 'networks');
+    assert.equal(macs, undefined, 'macs');
 
     networks.forEach(function (net) {
         // Make absolutely sure we're never overriding NAPI's network
@@ -1400,16 +1408,19 @@ function preProvisionNics(req, cb) {
     // Return a new copy for every time we provision a new NIC and avoid
     // accidentally reusing an object
     function nicParams() {
-        // Once server selection has been moved out of workflow we will be able
-        // to use the real cn_uuid here
-        var fakeUuid = '00000000-dead-beef-badd-cafe00000000';
-        return {
+        var nic_params = {
             owner_uuid: owner_uuid,
             belongs_to_uuid: inst_uuid,
             belongs_to_type: 'zone',
             state: 'provisioning',
-            cn_uuid: fakeUuid
+            cn_uuid: req.vm.server_uuid
         };
+
+        if (req.serverNicTags) {
+            nic_params.nic_tags_available = req.serverNicTags;
+        }
+
+        return nic_params;
     }
 
     var antiSpoofParams = [
@@ -1469,6 +1480,7 @@ function preProvisionNics(req, cb) {
                     done(suberr);
                 } else {
                     nics.push(nic);
+                    addFabricNatNic(req, nic);
                     done();
                 }
             });
@@ -1483,13 +1495,44 @@ function preProvisionNics(req, cb) {
             } else {
                 req.log.info({ nics: req.filteredNetworks.nics },
                     'NICs allocated');
+                req.add_nics = req.filteredNetworks.nics;
                 cb();
             }
         });
     });
+
+}
+
+/*
+ * It's better to preprovision NICs up front so that issues like running out of
+ * IP addresses or being unable to provide an explicitly requested IP address
+ * can be reported back to the customer, instead of silently disappearing in
+ * the workflow job's details.
+ *
+ * - Keep track of all NICs created in case we hit an error and need to
+ *   cleanup.
+ * - Keep track of fabric NICs for NAT zone provisioning later.
+ */
+function provisionNics(req, cb) {
+    var networks = req.filteredNetworks.networks;
+    var macs = req.params.macs;
+
+    req.fabricNatNics = [];
+    req.add_nics = [];
+
+    if (macs) {
+        assert.ok(!networks || networks.length === 0);
+        loadNicsByMac(req, cb);
+    } else if (networks && networks.length > 0) {
+        assert.ok(!macs || macs.length == 0);
+        provisionNetNics(req, cb);
+    } else {
+        var paramerr = [ errors.missingParamErr('missing networks or macs') ];
+        cb(new errors.ValidationFailedError('Invalid Parameters', paramerr));
+    }
 }
 
-// Cleanup nics provisioned by preProvisionNics
+// Cleanup pre-provisioned nics
 function cleanupNics(req, cb) {
     var napi = req.app.napi;
     assert.ok(napi, 'napi');
@@ -1529,6 +1572,480 @@ function cleanupNics(req, cb) {
     });
 }
 
+function refreshVmOnError(req, next) {
+    if (!req.vm || !req.vm.uuid) {
+        req.log.warn({vm: req.vm}, 'cannot refresh VM, no UUID provided');
+        next();
+        return;
+    }
+    _getVmSync(req, next);
+}
+
+
+function releaseVMTicket(req, next) {
+    var ticket = req.vmTicket;
+    if (!ticket) {
+        req.log.warn('No vmTicket to release');
+        next();
+        return;
+    }
+
+    // vmapi's custom cnapi client is no good here, but that should be removed
+    // as part of TRITON-1295, and this fixed up accordingly.
+    var cnapi = new sdc.CNAPI({
+        url: req.app.options.cnapi.url,
+        headers: { 'x-request-id': req.getId() }
+    });
+
+    cnapi.waitlistTicketRelease(ticket.uuid, function (err) {
+        if (err) {
+            req.log.warn({err: err, ticket: ticket},
+                'error releasing CNAPI waitlist VM ticket');
+        }
+        next(err);
+    });
+}
+
+/*
+ * Allocate a server for this VM.  Selects a server for the VM. This
+ * function will send VM, image, package and NIC tag requirements to DAPI, and
+ * let it figure out which server best fits the requirements.  Note that if you
+ * pass params['server_uuid'], this function will terminate early, because you
+ * have already specified the server you want to provision.  We still however,
+ * need to get the proper tickets from cnapi for synchronization.
+ *
+ * Here we serialize the compute node designation api (DAPI) portion of the
+ * action via the CNAPI waitlist to ensure that only one allocation happens
+ * at a time. In addition to serializing all the designations via the waitlist,
+ * we will create waitlist tickets for the provision itself.  DAPI will use the
+ * provision tickets to know whether there are in-flight provisions and prevent
+ * multiple concurrent provisions from inadvertently all ending up on the same
+ * compute node.
+ */
+function allocateServer(req, callback) {
+    // vmapi's custom cnapi client is no good here, but that should be removed
+    // as part of TRITON-1295, and this fixed up accordingly.
+    var cnapi = new sdc.CNAPI({
+        url: req.app.options.cnapi.url,
+        headers: { 'x-request-id': req.getId() }
+    });
+
+    var params = req.params;
+
+    function acquireAllocationTicket(_, next) {
+        var newTicket = {
+            scope: 'vm-allocate',
+            id: 'global',
+            expires_at: (new Date(
+                Date.now() + 60 * 1000).toISOString()),
+            action: 'allocate'
+        };
+
+        cnapi.waitlistTicketCreate('default', newTicket, onCreate);
+
+        function onCreate(err, ticket) {
+            if (err) {
+                next(err);
+                return;
+            }
+
+            req.allocationTicket = ticket.queue.filter(function (tick) {
+                return (tick.uuid === ticket.uuid);
+            })[0];
+
+            req.log.info({ ticket: req.allocationTicket },
+                'got allocationTicket');
+            next();
+        }
+    }
+
+    function waitOnAllocationTicket(_, next) {
+        var allocationTicket = req.allocationTicket;
+
+        if (allocationTicket.status === 'active') {
+            return next();
+        }
+
+        cnapi.waitlistTicketWait(allocationTicket.uuid, next);
+    }
+
+    function getAllocation(_, next) {
+        var nicTagReqs = req.nicTagReqs;
+        var pkg = params.package;
+        var img = params.image;
+
+        var cnapi_json = restify.createJsonClient({
+            url: req.app.options.cnapi.url,
+            headers: { 'x-request-id': req.getId() }
+        });
+
+        if (!nicTagReqs) {
+            var nicerr = [ errors.missingParamErr('nictag') ];
+            next(new errors.ValidationFailedError('Invalid Parameters',
+                nicerr));
+            return;
+        }
+
+        if (!img) {
+            var imgerr = [ errors.missingParamErr('image') ];
+            next(new errors.ValidationFailedError('Invalid Parameters',
+                imgerr));
+            return;
+        }
+
+        if (req.vm.server_uuid) {
+            assert.equal(req.vm.server_uuid, params.server_uuid, 'server uuid');
+            req.log.debug({ server_uuid: req.vm.server_uuid },
+                'Server uuid is present, no need to get allocation from DAPI');
+            next();
+            return;
+        }
+
+        /*
+         * In case we're talking to an older DAPI from before heterogeneous
+         * pools were supported, we select the first tag from each list of
+         * alternatives.
+         */
+        var nicTags = nicTagReqs.map(function extractFirstTag(arr) {
+            return arr[0];
+        });
+
+        var payload = {
+            vm: params,
+            image: img,
+            package: pkg,
+            nic_tags: nicTags,
+            nic_tag_requirements: nicTagReqs
+        };
+
+        payload.vm.vm_uuid = params.uuid;
+
+        req.log.info({ dapiPayload: payload }, 'Payload sent to DAPI');
+
+        cnapi_json.post('/allocate', payload,
+            function afterAllocate(err, areq, res, body) {
+
+            if (err) {
+                next(err);
+                return;
+            }
+
+            var server = body.server;
+            var server_uuid = server.uuid;
+            req.vm.server_uuid = server_uuid;
+            params.imgapiPeers = body.imgapiPeers;
+
+            req.server_info = {
+                sysinfo: {
+                    'Network Interfaces': server.sysinfo['Network Interfaces'],
+                    'Virtual Network Interfaces':
+                        server.sysinfo['Virtual Network Interfaces']
+                }
+            };
+
+            req.log.info('VM allocated to Server: ', server_uuid);
+            next();
+        });
+    }
+
+    function putVmInMoray(_, next) {
+        var vmparams = jsprim.deepCopy(params);
+        var vmuuid = vmparams.uuid;
+
+        vmparams.state = 'provisioning';
+        vmparams.create_timestamp = (new Date());
+        vmparams.server_uuid = req.vm.server_uuid;
+
+        var vm = common.translateVm(vmparams);
+        req.app.moray.putVm(vmuuid, vm, {}, function (err) {
+            if (err) {
+                // When provision has been queued and moray fails putobject
+                // we should be able to see the VM show up eventually when
+                // vm-agent sees it.
+                req.log.error({ err: err, vm_uuid: vmuuid },
+                    'Error storing provisioning VM %s in moray', vmuuid);
+            } else {
+                req.log.debug({ vm_uuid: vmuuid },
+                    'Provisioning VM %s added to moray', vmuuid);
+            }
+
+            next();
+        });
+
+    }
+
+    function acquireVMTicket(_, next) {
+        var server_uuid = req.vm.server_uuid;
+        var newTicket = {
+            scope: 'vm',
+            id: params.uuid,
+            expires_at: (new Date(
+                Date.now() + 600 * 1000).toISOString()),
+            action: 'provision'
+        };
+
+        newTicket.extra = {
+            owner_uuid: params.owner_uuid,
+            max_physical_memory: params.max_physical_memory,
+            cpu_cap: params.cpu_cap,
+            quota: params.quota,
+            brand: params.brand,
+            disks: params.disks
+        };
+
+        if (['bhyve', 'kvm'].indexOf(params.brand) !== -1 &&
+            params.image) {
+
+            newTicket.extra.image_size = params.image.image_size;
+        }
+
+        cnapi.waitlistTicketCreate(server_uuid, newTicket, onCreate);
+
+        function onCreate(err, ticket) {
+            if (err) {
+                next(err);
+                return;
+            }
+
+            req.vmTicket = ticket.queue.filter(function (tick) {
+                return (tick.uuid === ticket.uuid);
+            })[0];
+
+            req.log.info({ ticket: req.vmTicket }, 'got vmTicket');
+            next();
+        }
+    }
+
+    function releaseAllocationTicket(_, next) {
+        var allocationTicket = req.allocationTicket;
+
+        assert.object(allocationTicket, 'allocationTicket');
+
+        cnapi.waitlistTicketRelease(req.allocationTicket.uuid,
+            function (err) {
+
+            if (err) {
+                req.log.warn({err: err, ticket: req.allocationTicket},
+                    'error releasing CNAPI waitlist allocation ticket');
+            }
+            next();
+        });
+    }
+
+    function waitForVMTicket(_, next) {
+        var ticket = req.vmTicket;
+
+        if (ticket.status === 'active') {
+            next();
+            return;
+        }
+        cnapi.waitlistTicketWait(ticket.uuid, next);
+    }
+
+    vasync.pipeline({
+        arg: req,
+        funcs: [
+            getNicTagReqs,
+            acquireAllocationTicket,
+            waitOnAllocationTicket,
+            getAllocation,
+            putVmInMoray,
+            acquireVMTicket,
+            releaseAllocationTicket,
+            waitForVMTicket
+    ]}, function allocateServerDone(err, results) {
+        if (err) {
+            vasync.pipeline({
+                arg: req,
+                funcs: [
+                    refreshVmOnError,
+                    releaseVMTicket,
+                    releaseAllocationTicket
+            ]}, function (err2, res2) {
+                // Ignore errors from clean up.
+                callback(err);
+            });
+            return;
+        }
+        delete req.allocationTicket;
+        callback();
+    });
+}
+
+
+/*
+ * Perform the same logic that DAPI performs on the sysinfo payload,
+ * minus the parts about online/offline NICs, since we're either
+ * adding new NICs to a VM or performing a manual server selection.
+ */
+function getNicTags(req, callback) {
+    function extractServerNicTags(err, server) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        var interfaces = server.sysinfo['Network Interfaces'] || {};
+        var vnics = server.sysinfo['Virtual Network Interfaces'] || {};
+        var serverTags = {};
+
+        Object.keys(interfaces).forEach(function extractTags(nicName) {
+            var nic = interfaces[nicName];
+            var nicTags = nic['NIC Names'];
+
+            nicTags.forEach(function (tag) {
+                serverTags[tag] = true;
+            });
+        });
+
+        Object.keys(vnics).forEach(function extractOverlayTags(nicName) {
+            var nic = vnics[nicName];
+            var nicTags = nic['Overlay Nic Tags'] || [];
+
+            for (var i = 0; i < nicTags.length; i++) {
+                serverTags[nicTags[i]] = true;
+            }
+        });
+
+        req.serverNicTags = Object.keys(serverTags);
+
+        callback();
+    }
+
+    if (req.server_info) {
+        extractServerNicTags(null, req.server_info);
+    } else {
+        var cnapi = req.app.cnapi;
+        cnapi.getServer(req.vm.server_uuid, extractServerNicTags);
+    }
+}
+
+
+/*
+ * Checks that the server has the NIC tags for every network or NIC that was
+ * passed to it. While this task is usually done in DAPI when determining where
+ * to place a VM, it also needs to be done when adding a new NIC to a VM, or
+ * when the server_uuid has been manually specified during provisioning.
+ */
+function checkServerNicTags(req, callback) {
+    var macs = req.params.macs;
+    var error;
+
+    function done(err) {
+        if (err) {
+            req.log.error({err: err}, 'Error checking server nictags');
+        }
+        callback(err);
+    }
+
+    if (macs) {
+        /*
+         * If 'macs' was passed, we're dealing with pre-created NICs, so we need
+         * to pull the NICs from NAPI first.
+         */
+        var napi = req.app.napi;
+
+        vasync.forEachPipeline({
+            func: function lookupMAC(mac, next) {
+                napi.getNic(mac, function checkTagOkay(err, nic) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    var nicTag = nic.nic_tag;
+
+                    if (!nicTag) {
+                        error = [ errors.invalidParamErr('nic') ];
+                        next(new errors.ValidationFailedError('NIC ' + mac +
+                            'does not have a nitag', error));
+                        return;
+                    }
+
+                    /*
+                     * This hack is to split the NIC tag off from the vnet_id,
+                     * which fabric NICs have embedded in their nic_tag
+                     * attribute.
+                     */
+                    var overlay = nicTag.match(/^(.+)\/\d+$/);
+                    nicTag = overlay ? overlay[1] : nicTag;
+
+                    if (req.serverNicTags.indexOf(nicTag) === -1) {
+                        error = [ errors.invalidParamErr('server') ];
+                        next(new errors.ValidationFailedError(
+                            'Server does not have NIC tag: ' + nicTag, error));
+                        return;
+                    }
+
+                    next();
+                });
+            },
+            inputs: macs
+        }, done);
+        return;
+    }
+
+    /*
+     * Otherwise we're dealing with networks. The nic_tag requirements for
+     * these networks and pools were already loaded by getNicTags().  We need
+     * to make sure that the specified server satisfies at least one of the
+     * tags required for each network and pool.
+     */
+    var serverTags = {};
+    req.serverNicTags.forEach(function extractServerTag(tag) {
+        serverTags[tag] = true;
+    });
+
+    for (var i = 0; i < req.nicTagReqs.length; i++) {
+        var reqs = req.nicTagReqs[i];
+        var satisfied = false;
+
+        for (var j = 0; j < reqs.length; j++) {
+            if (serverTags[reqs[j]]) {
+                satisfied = true;
+                break;
+            }
+        }
+
+        if (!satisfied) {
+            error = [ errors.invalidParamErr('server') ];
+            done(new errors.ValidationFailedError(
+                'Server must have one of the following NIC tags: ' +
+                reqs.join(', ')));
+            return;
+        }
+    }
+
+    done();
+}
+
+function getNicTagReqs(req, next) {
+    var networks = req.params.networks;
+    var filteredNetworks = req.filteredNetworks;
+
+    if (req.params.macs && !networks) {
+        return next();
+    }
+
+    req.nicTagReqs = [];
+
+    function pushTags(net) {
+        if (net.nic_tags_present) {
+            req.nicTagReqs.push(net.nic_tags_present);
+        } else {
+            req.nicTagReqs.push([ net.nic_tag ]);
+        }
+    }
+
+    filteredNetworks.netInfo.forEach(function (net) {
+        pushTags(net);
+    });
+
+    req.log.info({ nicTagReqs: req.nicTagReqs },
+        'NIC Tag requirements retrieved');
+
+    next();
+}
 
 /*
  * Creates a new vm. This endpoint returns a task id that can be used to
@@ -1539,18 +2056,35 @@ function createVm(req, res, next) {
 
     var sync = req.params.sync;
 
+    // Create the vm object here so that we can store things in it during the
+    // provision process and leave 'params' alone.  This also allows for more
+    // common code in the create and update paths.
+    req.vm = {};
+
     vasync.pipeline({
         arg: req,
         funcs: [
             validateCreateVmParams,
             checkAllNfsVolumesReachable,
-            preProvisionNics
+            allocateServer,
+            getNicTags,
+            checkServerNicTags,
+            provisionNics
         ]
-    }, function (err, results) {
+    }, function createVmDone(err, results) {
         if (err) {
-            return cleanupNics(req, function nicCleanupAttempt() {
+            vasync.pipeline({
+                arg: req,
+                funcs: [
+                    cleanupNics,
+                    refreshVmOnError,
+                    releaseVMTicket
+            ]}, function () {
+                req.log.info({err: err}, 'nics cleaned up and vmTicket ' +
+                    'released, returning error');
                 next(err);
             });
+            return;
         }
         createProvisionJob();
     });
@@ -1563,6 +2097,8 @@ function createVm(req, res, next) {
             }
 
             common.setDefaultValues(req.params, {config: req.app.options});
+            req.vm.uuid = req.params.uuid;
+            req.vm.server_uuid = req.params.server_uuid;
 
             if (sync && ['true', 'false'].indexOf(sync) === -1) {
                 var error = [ errors.invalidParamErr('sync') ];
@@ -1719,33 +2255,13 @@ function createVm(req, res, next) {
 
     function onProvisionJob(err, vmuuid, juuid) {
         if (err) {
-            return rollbackRoleTags(err);
+            rollbackRoleTags(err);
+            return;
         }
 
-        req.params.state = 'provisioning';
-
-        // Set timestamp to now so that VMs being provisioned will have a create
-        // timestamp of when we started the provision.
-        req.params.create_timestamp = (new Date());
-
-        // Write the provisioning VM to moray
-        var vm = common.translateVm(req.params, false);
-        req.app.moray.putVm(vmuuid, vm, {}, function (err2) {
-            if (err2) {
-                // When provision has been queued and moray fails putobject
-                // we should be able to see the VM show up eventually when
-                // vm-agent sees it.
-                req.log.error({ err: err2, vm_uuid: vmuuid },
-                    'Error storing provisioning VM %s in moray', vmuuid);
-            } else {
-                req.log.debug({ vm_uuid: vmuuid },
-                    'Provisioning VM %s added to moray', vmuuid);
-            }
-
-
-            req.vm = { uuid: vmuuid };
-            return handleUpdateVMResponse(req, res, next, juuid);
-        });
+        req.vm = { uuid: vmuuid };
+        handleUpdateVMResponse(req, res, next, juuid);
+        return;
     }
 }
 
@@ -1906,12 +2422,15 @@ function putVms(req, res, next) {
     }
 
     // TODO: It is broken that we don't check for deleted VMs when this happens
-    async.eachSeries(Object.keys(req.params.vms), function (uuid, cb) {
-        var vm = common.translateVm(req.params.vms[uuid], false);
-        var oldVm = req.vms[uuid] || {};
-
-        req.app.moray.putVm(uuid, vm, oldVm, cb);
-    }, function (err) {
+    vasync.forEachPipeline({
+        func: function putOneVm(uuid, cb) {
+            var vm = common.translateVm(req.params.vms[uuid], false);
+            var oldVm = req.vms[uuid] || {};
+
+            req.app.moray.putVm(uuid, vm, oldVm, cb);
+        },
+        inputs: Object.keys(req.params.vms)
+    }, function putVmDone(err) {
         if (err) {
             return next(err);
         }
@@ -2012,6 +2531,50 @@ function _loadVms(req, res, next) {
     }
 }
 
+function _getVmSync(req, next) {
+    var m = req.vm;
+
+    // Skip calling CNAPI when a VM hasn't been allocated to a server
+    if (m.server_uuid && m.server_uuid.length > 0) {
+        req.app.cnapi.getVm(m.server_uuid, m.uuid, true, onGetVm);
+        return;
+    } else {
+        onGetVm(null, null);
+        return;
+    }
+
+    function onGetVm(err, vm) {
+        if (err) {
+            return next(err);
+        }
+
+        if (vm) {
+            var newVm = common.translateVm(vm, true);
+            req.app.moray.putVm(newVm.uuid, newVm, req.vm, function (putErr) {
+                if (putErr) {
+                    req.log.error({ err: putErr, uuid: newVm.uuid },
+                        'Error storing VM on moray');
+                    return next(putErr);
+
+                }
+                req.log.debug('VM object %s updated in moray', newVm.uuid);
+                return next();
+            });
+
+        } else {
+            req.app.moray.markAsDestroyed(req.vm, function (markErr, modVm) {
+                if (markErr) {
+                    return next(markErr);
+                }
+
+                req.vm = modVm;
+                return next();
+            });
+        }
+    }
+}
+
+
 /*
  * Mounts vm actions as server routes
  */
diff --git a/lib/workflows/add-nics.js b/lib/workflows/add-nics.js
index 262f82a..f94924d 100644
--- a/lib/workflows/add-nics.js
+++ b/lib/workflows/add-nics.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -23,7 +23,7 @@ var async;  // stub to keep jsl happy
 var common = require('./job-common');
 var fabricCommon = require('./fabric-common');
 
-var VERSION = '7.2.2';
+var VERSION = '7.3.0';
 
 
 /*
@@ -63,36 +63,6 @@ var workflow = module.exports = {
         retry: 1,
         body: setupRequest,
         modules: {}
-    }, {
-        name: 'napi.validate_networks',
-        timeout: 10,
-        retry: 1,
-        body: common.validateNetworks,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
-    }, {
-        name: 'cnapi.get_server_nic_tags',
-        timeout: 10,
-        retry: 1,
-        body: common.getServerNicTags,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'napi.check_server_nic_tags',
-        timeout: 10,
-        retry: 1,
-        body: common.checkServerNicTags,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
-    }, {
-        name: 'napi.add_nics_by_mac',
-        timeout: 20,
-        retry: 1,
-        body: common.addNicsByMac,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
-    }, {
-        name: 'napi.provision_nics',
-        timeout: 20,
-        retry: 1,
-        body: common.provisionNics,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
     }
 
     /**
diff --git a/lib/workflows/job-common.js b/lib/workflows/job-common.js
index 4764c16..8df7f20 100644
--- a/lib/workflows/job-common.js
+++ b/lib/workflows/job-common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -561,41 +561,6 @@ function postBack(job, cb) {
 
 
 
-/*
- * Finish the validation of networks previously done by getting a
- * list of NIC tags.
- */
-function validateNetworks(job, cb) {
-    var networks = job.params.networks;
-    var filteredNetworks = job.params.filteredNetworks;
-
-    // add-nics also calls this function, but if macs are provided we don't
-    // necessarily need to progress further
-    if (job.params.macs && !networks) {
-        return cb();
-    }
-
-    job.nicTagReqs = [];
-
-    function pushTags(net) {
-        if (net.nic_tags_present) {
-            job.nicTagReqs.push(net.nic_tags_present);
-        } else {
-            job.nicTagReqs.push([ net.nic_tag ]);
-        }
-    }
-
-    filteredNetworks.netInfo.forEach(function (net) {
-        pushTags(net);
-    });
-
-    job.log.info({ nicTagReqs: job.nicTagReqs },
-        'NIC Tag requirements retrieved');
-
-    cb(null, 'NIC Tag requirements retrieved');
-}
-
-
 /*
  * Get server object so we can check if it has the corresponding NIC tags.
  */
@@ -640,8 +605,8 @@ function getServerNicTags(job, cb) {
         cb();
     }
 
-    if (job.server_info) {
-        extractServerNicTags(null, job.server_info);
+    if (job.params.server_info) {
+        extractServerNicTags(null, job.params.server_info);
     } else {
         var cnapi = new sdcClients.CNAPI({
             url: cnapiUrl,
@@ -653,314 +618,6 @@ function getServerNicTags(job, cb) {
 }
 
 
-/*
- * Checks that the server has the NIC tags for every network or NIC that was
- * passed to it. While this task is usually done in DAPI when determining where
- * to place a VM, it also needs to be done when adding a new NIC to a VM, or
- * when the server_uuid has been manually specified during provisioning.
- */
-function checkServerNicTags(job, cb) {
-    function done(err) {
-        if (err) {
-            cb(err);
-        } else {
-            cb(null, 'Server has all the required NIC tags');
-        }
-    }
-
-    var macs = job.params.macs;
-
-    if (macs) {
-        /*
-         * If 'macs' was passed, we're dealing with pre-created NICs, so we need
-         * to pull the NICs from NAPI first.
-         */
-        var napi = new sdcClients.NAPI({
-            url: napiUrl,
-            headers: { 'x-request-id': job.params['x-request-id'] }
-        });
-
-        async.mapSeries(macs, function lookupMAC(mac, next) {
-            napi.getNic(mac, function checkTagOkay(err, nic) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                var nicTag = nic.nic_tag;
-
-                if (!nicTag) {
-                    next(new Error('NIC ' + mac + 'does not have a tag'));
-                    return;
-                }
-
-                /*
-                 * This hack is to split the NIC tag off from the vnet_id, which
-                 * fabric NICs have embedded in their nic_tag attribute.
-                 */
-                var overlay = nicTag.match(/^(.+)\/\d+$/);
-                nicTag = overlay ? overlay[1] : nicTag;
-
-                if (job.serverNicTags.indexOf(nicTag) === -1) {
-                    next(new Error('Server does not have NIC tag: ' + nicTag));
-                    return;
-                }
-
-                next();
-            });
-        }, done);
-    } else {
-        /*
-         * Otherwise we're dealing with networks. The nic_tag requirements for
-         * these networks and pools were already loaded by validateNetworks().
-         * We need to make sure that the specified server satisfies at least one
-         * of the tags required for each network and pool.
-         */
-        var serverTags = {};
-        job.serverNicTags.forEach(function extractServerTag(tag) {
-            serverTags[tag] = true;
-        });
-
-        for (var i = 0; i < job.nicTagReqs.length; i++) {
-            var reqs = job.nicTagReqs[i];
-            var satisfied = false;
-
-            for (var j = 0; j < reqs.length; j++) {
-                if (serverTags[reqs[j]]) {
-                    satisfied = true;
-                    break;
-                }
-            }
-
-            if (!satisfied) {
-                done(new Error(
-                    'Server must have one of the following NIC tags: ' +
-                    reqs.join(', ')));
-                return;
-            }
-        }
-
-        done();
-        return;
-    }
-}
-
-
-/*
- * Provisions a list of NICs for the soon to be provisioned machine.
- *
- * The networks list can contain a not null ip attribute on each object, which
- * denotes that we want to allocate that given IP for the correspondant network.
- * This task should be executed after DAPI has allocated a server.
- *
- * If there's at least one NIC with "belongs_to_uuid" set to this machine, then
- * don't provision any new NICs.
- */
-function provisionNics(job, cb) {
-    var macs = job.params.macs;
-
-    if (macs) {
-        cb(null, 'AddNics called with macs -- skipping');
-        return;
-    }
-    var inst_uuid = job.params.uuid || job.params.vm_uuid;
-    var owner_uuid = job.params.owner_uuid;
-
-    var filteredNetworks = job.params.filteredNetworks;
-    if (filteredNetworks === undefined) {
-        cb('Networks should be populated already');
-        return;
-    }
-
-    var networks = filteredNetworks.networks;
-    networks.forEach(function (net) {
-        // Make absolutely sure we're never overriding NAPI's network
-        // owner checks:
-        delete net.check_owner;
-    });
-
-    var poolNetworks = filteredNetworks.networks.filter(function
-        filterOutPoolNets(net) {
-        if (filteredNetworks.pools.indexOf(net.ipv4_uuid) >= 0) {
-            return true;
-        }
-        return false;
-    });
-
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    // Every NIC we provision or updated is added to this array
-    var nics = filteredNetworks.nics.slice();
-    job.params.fabricNatNics = [];
-
-
-    // Return a new copy for every time we provision a new NIC and avoid
-    // accidentally reusing an object
-    function nicParams() {
-        return {
-            owner_uuid: owner_uuid,
-            belongs_to_uuid: inst_uuid,
-            belongs_to_type: 'zone',
-            state: 'provisioning',
-            nic_tags_available: job.serverNicTags,
-            cn_uuid: job.params.server_uuid
-        };
-    }
-
-    // If this is a nic on a fabric, has no gateway provisioned, and the network
-    // requests an internet NAT, add it
-    function addFabricNatNic(fNic) {
-        if (fNic && fNic.fabric && fNic.gateway && !fNic.gateway_provisioned &&
-                fNic.ip !== fNic.gateway && fNic.internet_nat) {
-            job.params.fabricNatNics.push(fNic);
-        }
-    }
-
-    var antiSpoofParams = [
-        'allow_dhcp_spoofing',
-        'allow_ip_spoofing',
-        'allow_mac_spoofing',
-        'allow_restricted_traffic'
-    ];
-
-    job.params.nics = nics;
-
-    /*
-     * We only provision NICs for network_pools below.  The NICs for networks
-     * are provisioned in createVm()->preProvisionNics().
-     */
-    async.series([
-        function provisionPoolNicss(callback) {
-            async.mapSeries(poolNetworks, function (network, next) {
-                var params = nicParams();
-                if (network.ipv4_ips !== undefined)
-                    params.ip = network.ipv4_ips[0];
-                if (network.primary !== undefined)
-                    params.primary = network.primary;
-
-                antiSpoofParams.forEach(function (spoofParam) {
-                    if (network.hasOwnProperty(spoofParam)) {
-                        params[spoofParam] = network[spoofParam];
-                    }
-                });
-
-                napi.provisionNic(network.ipv4_uuid, params,
-                    function (suberr, nic) {
-                    if (suberr) {
-                        next(suberr);
-                    } else {
-                        nics.push(nic);
-                        // pools may contain fabric networks someday
-                        addFabricNatNic(nic);
-                        next();
-                    }
-                });
-            }, callback);
-        },
-        function updateExistingNics(callback) {
-            // Update existing nics
-            async.mapSeries(filteredNetworks.nics, function (nic, next) {
-                var params = nicParams();
-
-                napi.updateNic(nic.mac, params,
-                    function (suberr, updatedNic) {
-                    if (suberr) {
-                        next(suberr);
-                    } else {
-                        addFabricNatNic(updatedNic);
-                        next();
-                    }
-                });
-            }, callback);
-        }
-    ], function (err, results) {
-        if (err) {
-            cb(err);
-        } else {
-            job.log.info({ nics: job.params.nics }, 'NICs allocated');
-
-            // If we hit this due to add_nics setup params so that we call
-            // common.update_network_params properly
-            if (job.task === 'add_nics') {
-                job.params['add_nics'] = nics;
-            }
-
-            cb(null, 'NICs allocated and updated');
-        }
-    });
-
-}
-
-
-
-/*
- * Provisions additional NICs for a zone in NAPI if networks were provided to
- * the job. If macs were provided, load those from NAPI instead.
- *
- * The networks list can contain a not null ip attribute on each object, which
- * denotes that we want to allocate that given IP for the correspondent network.
- */
-function addNicsByMac(job, cb) {
-    var filteredNetworks = job.params.filteredNetworks;
-    var networks = filteredNetworks.networks;
-    var macs     = job.params.macs;
-
-    job.params.fabricNatNics = [];
-
-    // If this is a nic on a fabric, has no gateway provisioned, and the network
-    // requests an internet NAT, add it
-    function addFabricNatNic(fNic) {
-        if (fNic && fNic.fabric && fNic.gateway && !fNic.gateway_provisioned &&
-                fNic.ip !== fNic.gateway && fNic.internet_nat) {
-            job.params.fabricNatNics.push(fNic);
-        }
-    }
-
-    if (networks === undefined && macs === undefined) {
-        cb('Networks or mac are required');
-        return;
-    }
-
-    if (!macs) {
-        cb(null, 'AddNics not called with macs -- skipping');
-        return;
-    }
-
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    var nics = [];
-
-    function done(err) {
-        if (err) {
-            cb(err);
-        } else {
-            job.log.info({ nics: nics }, 'NICs allocated');
-            job.params['add_nics'] = nics;
-
-            cb(null, 'NICs looked up or allocated');
-        }
-    }
-    async.mapSeries(macs, function (mac, next) {
-        napi.getNic(mac, function (err, nic) {
-            if (err) {
-                return next(err);
-            }
-
-            nics.push(nic);
-            addFabricNatNic(nic);
-            next();
-        });
-    }, done);
-}
-
-
-
 /*
  * Exactly the same as removeNics but used as a fallback task for provision and
  * add-nics. Those tasks set either a nics or add-nics object to the params.
@@ -1020,7 +677,7 @@ function cleanupNics(job, cb) {
  */
 function updateNetworkParams(job, cb) {
     var toAdd = job.params.add_nics;
-    if (toAdd === undefined) {
+    if (toAdd === undefined || toAdd.length === 0) {
         cb('add_nics are required');
         return;
     }
@@ -1369,7 +1026,7 @@ function acquireVMTicket(job, cb) {
                     cb(geterr);
                     return;
                 }
-                job.ticket = getticket;
+                job.params.vmTicket = getticket;
                 job.log.info(
                     { ticket: getticket }, 'ticket status after wait');
                 cb();
@@ -1384,27 +1041,30 @@ function waitOnVMTicket(job, cb) {
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
 
-    var ticket = job.ticket;
+    var ticket = job.params.vmTicket;
 
     if (ticket.status === 'active') {
         cb();
         return;
     }
-    cnapi.waitlistTicketWait(job.ticket.uuid, cb);
+    cnapi.waitlistTicketWait(ticket.uuid, cb);
 }
 
 
 function releaseVMTicket(job, cb) {
-    if (!job.ticket) {
-        return cb();
+    var ticket = job.params.vmTicket;
+
+    if (!ticket) {
+        cb();
+        return;
     }
     var cnapi = new sdcClients.CNAPI({
         url: cnapiUrl,
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
-    cnapi.waitlistTicketRelease(job.ticket.uuid, function (err) {
+    cnapi.waitlistTicketRelease(ticket.uuid, function (err) {
         if (err) {
-            job.log.warn({err: err, ticket: job.ticket},
+            job.log.warn({err: err, ticket: ticket},
                 'error releasing CNAPI waitlist VM ticket');
         }
         cb(err);
@@ -1412,71 +1072,19 @@ function releaseVMTicket(job, cb) {
 }
 
 
-function acquireAllocationTicket(job, cb) {
-    var cnapi = new sdcClients.CNAPI({
-        url: cnapiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    var newTicket = {
-        scope: 'vm-allocate',
-        id: 'global',
-        expires_at: (new Date(
-            Date.now() + 60 * 1000).toISOString()),
-        action: 'allocate',
-        workflow_job_uuid: job.uuid
-    };
-
-    cnapi.waitlistTicketCreate('default', newTicket, onCreate);
-
-
-    function onCreate(err, ticket) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        cnapi.waitlistTicketGet(
-            ticket.uuid, function (geterr, getticket)
-        {
-            if (geterr) {
-                cb(geterr);
-                return;
-            }
-            job.allocationTicket = getticket;
-            cb();
-        });
-    }
-}
-
-
-function waitOnAllocationTicket(job, cb) {
-    var cnapi = new sdcClients.CNAPI({
-        url: cnapiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    var allocationTicket = job.allocationTicket;
-
-    if (allocationTicket.status === 'active') {
-        return cb();
-    }
-
-    cnapi.waitlistTicketWait(allocationTicket.uuid, cb);
-}
-
-
 function releaseAllocationTicket(job, cb) {
-    if (!job.allocationTicket) {
+    var ticket = job.allocationTicket;
+
+    if (!ticket) {
         return cb();
     }
     var cnapi = new sdcClients.CNAPI({
         url: cnapiUrl,
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
-    cnapi.waitlistTicketRelease(job.allocationTicket.uuid, function (err) {
+    cnapi.waitlistTicketRelease(ticket.uuid, function (err) {
         if (err) {
-            job.log.warn({err: err, ticket: job.ticket},
+            job.log.warn({err: err, ticket: ticket},
                 'error releasing CNAPI waitlist allocation ticket');
             return;
         }
@@ -1494,11 +1102,7 @@ module.exports = {
     checkUpdated: checkUpdated,
     postBack: postBack,
     getServerNicTags: getServerNicTags,
-    checkServerNicTags: checkServerNicTags,
-    provisionNics: provisionNics,
-    addNicsByMac: addNicsByMac,
     cleanupNics: cleanupNics,
-    validateNetworks: validateNetworks,
     updateNetworkParams: updateNetworkParams,
     updateFwapi: updateFwapi,
     removeNetworkParams: removeNetworkParams,
@@ -1507,8 +1111,6 @@ module.exports = {
     acquireVMTicket: acquireVMTicket,
     waitOnVMTicket: waitOnVMTicket,
     releaseVMTicket: releaseVMTicket,
-    acquireAllocationTicket: acquireAllocationTicket,
-    waitOnAllocationTicket: waitOnAllocationTicket,
     releaseAllocationTicket: releaseAllocationTicket,
     clearSkipZoneAction: clearSkipZoneAction
 };
diff --git a/lib/workflows/provision.js b/lib/workflows/provision.js
index c848fb0..19aae13 100644
--- a/lib/workflows/provision.js
+++ b/lib/workflows/provision.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -23,7 +23,7 @@ var nfsVolumes = require('./nfs-volumes');
 
 var wfapiUrl;
 
-var VERSION = '8.1.2';
+var VERSION = '8.2.0';
 
 
 /*
@@ -126,82 +126,6 @@ function generatePasswords(job, cb) {
 }
 
 
-/*
- * Selects a server for the VM. This function will send VM, image, package and
- * NIC tag requirements to DAPI, and let it figure out which server best fits
- * the requirements.
- *
- * Note that if you pass params['server_uuid'], this function will terminate
- * early, because you have already specified the server you want to provision.
- */
-function getAllocation(job, cb) {
-    var nicTagReqs = job.nicTagReqs;
-    var pkg = job.params.package;
-    var img = job.params.image;
-
-    if (!nicTagReqs) {
-        cb('NIC tag requirements must be present');
-        return;
-    }
-
-    if (!img) {
-        return cb('Image is required');
-    }
-
-    if (job.params['server_uuid']) {
-        cb(null, 'Server UUID present, no need to get allocation from DAPI');
-        return;
-    }
-
-    // There is no sdc-client for CNAPI's DAPI yet
-    var cnapi = restify.createJsonClient({
-        url: cnapiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    /*
-     * In case we're talking to an older DAPI from before heterogeneous pools
-     * were supported, we select the first tag from each list of alternatives.
-     */
-    var nicTags = nicTagReqs.map(function extractFirstTag(arr) {
-        return arr[0];
-    });
-
-    var payload = {
-        vm: job.params,
-        image: img,
-        package: pkg,
-        nic_tags: nicTags,
-        nic_tag_requirements: nicTagReqs
-    };
-
-    job.log.info({ dapiPayload: payload }, 'Payload sent to DAPI');
-
-    cnapi.post('/allocate', payload, function finish(err, req, res, body) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        var server_uuid = body.server.uuid;
-        job.params.server_uuid = server_uuid;
-        job.params.imgapiPeers = body.imgapiPeers;
-        job.server_uuid = server_uuid;
-        job.server_info = {
-            sysinfo: {
-                'Network Interfaces':
-                    body.server.sysinfo['Network Interfaces'],
-                'Virtual Network Interfaces':
-                    body.server.sysinfo['Virtual Network Interfaces']
-            }
-        };
-
-        cb(null, 'VM allocated to Server ' + server_uuid);
-    });
-}
-
-
-
 /**
  * Set up the payload that will be sent to CNAPI and will be used to provision
  * the virtual machine.
@@ -420,6 +344,13 @@ function provision(job, cb) {
 
     var server = job.params['server_uuid'];
 
+    if (job.params.internal_metadata &&
+        job.params.internal_metadata['force_provision_failure']) {
+
+        cb('force_provision_failure set, failing');
+        return;
+    }
+
     return cnapi.createVm(server, job.params.payload, function (err, task) {
         if (err) {
             return cb(err);
@@ -484,85 +415,6 @@ var workflow = module.exports = {
         retry: 1,
         body: generatePasswords,
         modules: { childProcess: 'child_process', async: 'async' }
-    }, {
-        name: 'napi.validate_networks',
-        timeout: 10,
-        retry: 1,
-        body: common.validateNetworks,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
-    },
-
-    /**
-     * Here we serialize the compute node designation api (DAPI) portion of the
-     * workflow via the CNAPI waitlist to ensure that only one allocation
-     * happens at a time. In addition to serialiing all the designations via
-     * the waitlist, we will create waitlist tickets for the provision itself.
-     * DAPI will use the provision tickets to know whether there are in-flight
-     * provisions and prevent multiple concurrent provisions from inadvertently
-     * all ending up on the same compute node.
-     */
-
-    {
-        name: 'dapi.get_allocation_ticket',
-        timeout: 30,
-        retry: 1,
-        body: common.acquireAllocationTicket,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'dapi.wait_allocation_ticket',
-        timeout: 120,
-        retry: 1,
-        body: common.waitOnAllocationTicket,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'dapi.get_allocation',
-        timeout: 30,
-        retry: 1,
-        body: getAllocation,
-        modules: { restify: 'restify' }
-    }, {
-        name: 'cnapi.acquire_vm_ticket',
-        timeout: 30,
-        retry: 1,
-        body: common.acquireVMTicket,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'dapi.release_allocation_ticket',
-        timeout: 30,
-        retry: 1,
-        body: common.releaseAllocationTicket,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'cnapi.wait_on_vm_ticket',
-        timeout: 120,
-        retry: 1,
-        body: common.waitOnVMTicket,
-        modules: { sdcClients: 'sdc-clients' }
-    },
-
-    /**
-     * End of DAPI serialization section.
-     */
-
-    {
-        name: 'cnapi.get_server_nic_tags',
-        timeout: 10,
-        retry: 1,
-        body: common.getServerNicTags,
-        modules: { sdcClients: 'sdc-clients' }
-    }, {
-        name: 'cnapi.check_manual_server_nics',
-        timeout: 10,
-        retry: 1,
-        body: common.checkServerNicTags,
-        modules: { sdcClients: 'sdc-clients' }
-    },
-    {
-        name: 'napi.provision_nics',
-        timeout: 20,
-        retry: 1,
-        body: common.provisionNics,
-        modules: { sdcClients: 'sdc-clients', async: 'async' }
     }
 
     /**
@@ -695,6 +547,8 @@ var workflow = module.exports = {
         body: common.postBack,
         modules: { async: 'async', restify: 'restify', urlModule: 'url' }
     },
+
+    // XXX: this should already be released and is likely always a no-op
     {
         name: 'cnapi.cleanup_allocation_ticket',
         modules: { sdcClients: 'sdc-clients' },
diff --git a/server.js b/server.js
index 2232bcf..f2b367f 100644
--- a/server.js
+++ b/server.js
@@ -304,6 +304,7 @@ function startVmapiService() {
                 moray: moray,
                 morayBucketsInitializer: morayBucketsInitializer,
                 overlay: config.overlay,
+                cnapi: config.cnapi, // TODO: TRITON-1295
                 reserveKvmStorage: config.reserveKvmStorage,
                 serverConfig: {
                     bindPort: config.api.port
diff --git a/test/vms.changefeed.test.js b/test/vms.changefeed.test.js
index 7c97c36..418d613 100644
--- a/test/vms.changefeed.test.js
+++ b/test/vms.changefeed.test.js
@@ -232,6 +232,8 @@ exports.create_vm = function (t) {
         credentials: JSON.stringify({ 'user_pw': '12345678' })
     };
 
+    jobLocation = null;
+
     VM = {
         alias: 'sdcvmapitest_create_vm_' + process.pid,
         uuid: uuid.create(),
@@ -262,6 +264,7 @@ exports.create_vm = function (t) {
             t.ok(body, 'vm ok job: ' + body.job_uuid);
 
             jobLocation = '/jobs/' + body.job_uuid;
+            done();
         });
     });
 
@@ -273,6 +276,17 @@ exports.create_vm = function (t) {
     });
 
     var stateReceived = false;
+
+    /*
+     * It doesn't matter if the request return or the change feed event occurs
+     * first as long as they both occur.
+     */
+    function done() {
+        if (jobLocation !== null && stateReceived) {
+            t.done();
+        }
+    }
+
     function processChangeItem(changeItem) {
         var changeKind = changeItem.changeKind;
         if (!stateReceived &&
@@ -283,7 +297,7 @@ exports.create_vm = function (t) {
             t.ok(true, 'state received');
             stateReceived = true;
             listener._endSocket();
-            t.done();
+            done();
         }
     }
 };
diff --git a/test/vms.disks.test.js b/test/vms.disks.test.js
index 36af2ee..cbed70f 100644
--- a/test/vms.disks.test.js
+++ b/test/vms.disks.test.js
@@ -8,7 +8,6 @@
  * Copyright (c) 2019, Joyent, Inc.
  */
 
-var assert = require('assert-plus');
 var jsprim = require('jsprim');
 var uuid = require('libuuid');
 
@@ -71,9 +70,9 @@ function createVm(t, vmOpts) {
 
     CLIENT.post(opts, vmOpts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
-
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.equal(res.statusCode, 202, 'status code: ' + res.statusCode);
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         VM_UUID = job.vm_uuid;
         var path = '/jobs/' + job.job_uuid;
@@ -91,8 +90,8 @@ function createVm(t, vmOpts) {
 function deleteVm(t) {
     CLIENT.del('/vms/' + VM_UUID, function delCb(err, req, res, job) {
         common.ifError(t, err, 'err');
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var path = '/jobs/' + job.job_uuid;
         waitForValue(path, 'execution', 'succeeded', {
@@ -110,8 +109,8 @@ function deleteVm(t) {
 
 exports.setup = function setup(t) {
     common.setUp(function setUpCb(setupErr, _client) {
-        assert.ifError(setupErr);
-        assert.ok(_client, 'restify client');
+        common.ifError(t, setupErr, 'setupErr');
+        t.ok(_client, 'restify client');
         CLIENT = _client;
 
         CLIENT.napi.get('/networks', function getNet(err, req, res, networks) {
@@ -188,8 +187,8 @@ exports.add_disk = function add_disk(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
@@ -206,6 +205,8 @@ exports.check_added_disk = function check_added_disk(t) {
     var path = '/vms/' + VM_UUID;
     CLIENT.get(path, function getCb(err, req, res, vm) {
         common.ifError(t, err, 'err');
+        t.ok(vm);
+        t.ok(vm.disks);
 
         var disks = vm.disks;
         t.equal(disks.length, 2);
@@ -262,8 +263,8 @@ exports.resize_disk_down_with_flag = function resize_disk_down_with_flag(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
@@ -300,8 +301,8 @@ exports.resize_disk_up = function resize_disk_up(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
@@ -350,8 +351,9 @@ exports.delete_disk = function delete_disk(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.equal(res.statusCode, 202, 'status code: ' + res.statusCode);
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
@@ -387,8 +389,9 @@ exports.add_disk_with_pci_slot = function add_disk_with_pci_slot(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.equal(res.statusCode, 202, 'status code: ' + res.statusCode);
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
@@ -449,8 +452,8 @@ exports.add_disk_with_uuid = function add_disk_with_uuid(t) {
     CLIENT.post(path, opts, function postCb(err, req, res, job) {
         common.ifError(t, err, 'err');
 
-        assert.object(job, 'job');
-        assert.uuid(job.job_uuid, 'job.job_uuid');
+        t.ok(job, 'job');
+        t.ok(job.job_uuid, 'job.job_uuid');
 
         var jobPath = '/jobs/' + job.job_uuid;
         waitForValue(jobPath, 'execution', 'succeeded', {
diff --git a/test/vms.full.test.js b/test/vms.full.test.js
index f1712dd..70ca67c 100644
--- a/test/vms.full.test.js
+++ b/test/vms.full.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 // var test = require('tap').test;
@@ -31,6 +31,7 @@ var newUuid;
 var jobLocation;
 var vmLocation;
 var vmCount;
+var nicCount;
 var pkgId;
 var nicMac;
 
@@ -822,9 +823,9 @@ exports.create_vm_dapi_failure = function (t) {
         brand: 'joyent-minimal',
         billing_id: '00000000-0000-0000-0000-000000000000',
         cpu_cap: 100,
+        ram: 32,
         internal_metadata: {
-            // to force DAPI to fail this provision
-            force_designation_failure: true
+            force_provision_failure: true
         },
         quota: 10,
         creator_uuid: CUSTOMER
@@ -853,7 +854,6 @@ exports.get_eventual_fail_job = function (t) {
     getJobOk(t);
 };
 
-
 exports.wait_provisioned_job_failed = function (t) {
     waitForValue(jobLocation, 'execution', 'failed', {
         client: client
