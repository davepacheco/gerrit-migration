From d4ffa3e945ef3af7895b0cefa218da08706a7bb2 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 22 Jun 2017 21:21:33 -0700
Subject: [PATCH] wip: cueball

---
 lib/client-fsm.js       | 1326 ++++++++++++++++++---------------------
 lib/zk-session.js       |  460 ++++++++++++++
 lib/zk-streams.js       |    4 +-
 package.json            |    5 +-
 test/basic.test.js      |  274 ++++----
 test/multi-node.test.js |   94 ++-
 6 files changed, 1246 insertions(+), 917 deletions(-)
 create mode 100644 lib/zk-session.js

diff --git a/lib/client-fsm.js b/lib/client-fsm.js
index 9493d5c..5665086 100644
--- a/lib/client-fsm.js
+++ b/lib/client-fsm.js
@@ -6,7 +6,7 @@
  * Copyright (c) 2016, Joyent, Inc.
  */
 
-module.exports = { Client: ZKClientFSM };
+module.exports = { Client: ZKClient };
 
 const mod_fsm = require('mooremachine');
 const mod_assert = require('assert-plus');
@@ -19,151 +19,494 @@ const mod_events = require('events');
 const mod_zkstreams = require('./zk-streams');
 const mod_net = require('net');
 const mod_bunyan = require('bunyan');
+const mod_cueball = require('cueball');
+const mod_zks = require('./zk-session');
+const mod_verror = require('verror');
+const mod_vasync = require('vasync');
 
-function ZKClientFSM(opts) {
+function ZKClient(opts) {
 	mod_assert.object(opts, 'options');
 
 	mod_assert.optionalObject(opts.log, 'options.log');
 	if (opts.log == undefined) {
-		this.zs_log = mod_bunyan.createLogger({
+		this.zc_log = mod_bunyan.createLogger({
 			name: 'zkstream',
-			component: 'ZKClientFSM'
+			component: 'ZKClient'
 		});
 	} else {
-		this.zs_log = opts.log.child({
-			component: 'ZKClientFSM'
+		this.zc_log = opts.log.child({
+			component: 'ZKClient'
 		});
 	}
 
 	mod_assert.optionalArrayOfObject(opts.servers, 'options.servers');
 	if (opts.servers === undefined) {
-		mod_assert.string(opts.host, 'options.host');
+		mod_assert.string(opts.address, 'options.address');
 		mod_assert.number(opts.port, 'options.port');
-		this.zs_servers = [
-			{ host: opts.host, port: opts.port }
+		this.zc_servers = [
+			{ address: opts.address, port: opts.port }
 		];
 	} else {
-		this.zs_servers = opts.servers;
-		this.zs_servers.forEach(function (srv) {
-			mod_assert.string(srv.host, 'servers[].host');
+		this.zc_servers = opts.servers;
+		this.zc_servers.forEach(function (srv) {
+			mod_assert.string(srv.address, 'servers[].address');
 			mod_assert.number(srv.port, 'servers[].port');
 		});
 	}
-	shuffle(this.zs_servers);
-	mod_assert.optionalNumber(opts.timeout, 'options.timeout');
-	this.zs_timeout = opts.timeout;
-	if (this.zs_timeout === undefined)
-		this.zs_timeout = 30000;
-	this.zs_decoder = undefined;
-	this.zs_encoder = undefined;
-	this.zs_xidMap = {};
-	this.zs_xid = 0;
-	this.zs_reqs = {};
-	this.zs_watchers = {};
-	this.zs_socket = undefined;
-	this.zs_server = undefined;
-
-	this.zs_cr = undefined;
-	this.zs_lastPkt = undefined;
-	this.zs_lastZxid = new mod_jsbn.BigInteger('0');
-
-	this.zs_minDelay = 1000;
-	this.zs_maxDelay = this.zs_timeout;
-	this.zs_delay = this.zs_minDelay;
+	mod_assert.optionalNumber(opts.sessionTimeout,
+	    'options.sessionTimeout');
+	this.zc_sessionTimeout = opts.sessionTimeout;
+	if (this.zc_sessionTimeout === undefined)
+		this.zc_sessionTimeout = 30000;
+
+	this.zc_session = undefined;
+	this.zc_oldSession = undefined;
+
+	this.zc_resolver = new mod_cueball.StaticIpResolver({
+		defaultPort: 2181,
+		backends: this.zc_servers
+	});
+
+	this.zc_set = new mod_cueball.ConnectionSet({
+		resolver: this.zc_resolver,
+		log: this.zc_log,
+		recovery: {
+			connect: {
+				timeout: 3000,
+				retries: 3,
+				delay: 500
+			},
+			default: {
+				timeout: 5000,
+				retries: 3,
+				delay: 1000
+			}
+		},
+		target: 1,
+		maximum: 3,
+		connectionHandlesError: true,
+		constructor: this._makeConnection.bind(this)
+	});
 
-	mod_fsm.FSM.call(this, 'init');
+	this.zc_set.on('added', this._onSetAdded.bind(this));
+	this.zc_set.on('removed', this._onSetRemoved.bind(this));
+	this.zc_set.on('stateChanged', this._onSetStateChanged.bind(this));
+
+	this.zc_conns = {};
+	this.zc_hdls = {};
+
+	mod_fsm.FSM.call(this, 'normal');
 }
-mod_util.inherits(ZKClientFSM, mod_fsm.FSM);
+mod_util.inherits(ZKClient, mod_fsm.FSM);
 
-ZKClientFSM.prototype.connect = function () {
-	mod_assert.ok(this.isInState('closed') || this.isInState('init'));
-	this.emit('connectAsserted');
+ZKClient.prototype.state_normal = function (S) {
+	this._newSession();
+	this.zc_resolver.start();
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closing');
+	});
 };
 
-ZKClientFSM.prototype.close = function () {
-	mod_assert.ok(!this.isInState('closed'));
+ZKClient.prototype.state_closing = function (S) {
+	var done = 0;
+	var self = this;
+
+	S.on(this.zc_session, 'stateChanged', function (st) {
+		if ((st === 'closed' || st === 'expired') && ++done == 3) {
+			S.gotoState('closed');
+		}
+	});
+
+	S.on(this.zc_set, 'stateChanged', function (st) {
+		if (st === 'stopped' && ++done == 3) {
+			S.gotoState('closed');
+		}
+	});
+
+	S.on(this.zc_resolver, 'stateChanged', function (st) {
+		if (st === 'stopped' && ++done == 3) {
+			S.gotoState('closed');
+		}
+	});
+
+	if (this.zc_session.isInState('closed') ||
+	    this.zc_session.isInState('expired')) {
+		++done;
+	}
+	if (this.zc_set.isInState('stopped'))
+		++done;
+	if (this.zc_resolver.isInState('stopped'))
+		++done;
+	if (done == 3) {
+		S.gotoState('closed');
+	} else {
+		this.zc_set.stop();
+		this.zc_resolver.stop();
+		this.zc_session.close();
+	}
+
+	S.interval(5000, function () {
+		self.zc_log.trace('still waiting for zk client to shut down, ' +
+		    '%d/3 done', done);
+	});
+};
+
+ZKClient.prototype.state_closed = function (S) {
+	this.emit('close');
+};
+
+ZKClient.prototype.close = function () {
 	this.emit('closeAsserted');
 };
 
-ZKClientFSM.prototype.destroy = function () {
-	if (this.isInState('closed'))
+ZKClient.prototype._newSession = function () {
+	var self = this;
+	if (!this.isInState('normal'))
 		return;
-	this.emit('closeAsserted');
+	var s = new mod_zks.ZKSession({
+		timeout: this.zc_sessionTimeout,
+		log: this.zc_log
+	});
+	this.zc_session = s;
+	function initialHandler(st) {
+		if (st === 'attached') {
+			s.removeListener('stateChanged', initialHandler);
+			s.on('stateChanged', finalHandler);
+			var c = s.getConnection();
+			if (c.isInState('connected')) {
+				setImmediate(function () {
+					self.emit('connect');
+				});
+			} else {
+				c.on('stateChanged', onConnCh);
+				function onConnCh(st) {
+					if (st === 'connected') {
+						c.removeListener(
+						    'stateChanged', onConnCh);
+						self.emit('connect');
+					}
+				}
+			}
+		}
+	}
+	function finalHandler(st) {
+		if (st === 'expired') {
+			self.emit('expire');
+		}
+	}
+	this.zc_session.on('stateChanged', initialHandler);
 };
 
-ZKClientFSM.prototype.nextXid = function () {
-	return (this.zs_xid++);
+ZKClient.prototype.getSession = function () {
+	if (!this.isInState('normal'))
+		return (undefined);
+	if (this.zc_session.isInState('expired') ||
+	    this.zc_session.isInState('closed')) {
+		this.zc_oldSession = this.zc_session;
+		this._newSession();
+	}
+	return (this.zc_session);
 };
 
-ZKClientFSM.prototype.state_init = function (S) {
-	S.on(this, 'connectAsserted', function () {
-		S.gotoState('connecting');
+ZKClient.prototype._onSetAdded = function (key, conn, hdl) {
+	this.zc_conns[key] = conn;
+	this.zc_hdls[key] = hdl;
+};
+
+ZKClient.prototype._onSetRemoved = function (key) {
+	var hdl = this.zc_hdls[key];
+	var conn = this.zc_conns[key];
+	mod_assert.object(hdl);
+	delete (this.zc_hdls[key]);
+	conn.destroy();
+	delete (this.zc_conns[key]);
+	hdl.release();
+};
+
+ZKClient.prototype._onSetStateChanged = function (st) {
+	var self = this;
+	if (st === 'failed') {
+		setImmediate(function () {
+			self.emit('failed', new Error('Failed to connect to ' +
+			    'ZK (exhausted initial retry policy)'));
+		});
+	}
+};
+
+ZKClient.prototype._makeConnection = function (backend) {
+	var c = new ZKConnectionFSM({
+		client: this,
+		backend: backend,
+		log: this.zc_log
 	});
+	c.connect();
+	return (c);
 };
 
-ZKClientFSM.prototype.state_closed = function (S) {
-	S.on(this, 'connectAsserted', function () {
-		S.gotoState('connecting');
+ZKClient.prototype.currentConnection = function () {
+	return (this.getSession().getConnection());
+};
+
+ZKClient.prototype.ping = function (cb) {
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	return (conn.ping(cb));
+};
+
+ZKClient.prototype.list = function (path, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.optionalFunc(cb, 'callback');
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'GET_CHILDREN2',
+		path: path,
+		watch: false
 	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null, pkt.children, pkt.stat);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
 
-	this.zs_log.info('closed connection');
+ZKClient.prototype.get = function (path, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.optionalFunc(cb, 'callback');
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'GET_DATA',
+		path: path,
+		watch: false
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null, pkt.data, pkt.stat);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
 
-	if (this.zs_encoder)
-		this.zs_encoder.end();
-	this.zs_encoder = undefined;
-	if (this.zs_socket)
-		this.zs_socket.destroy();
-	this.zs_socket = undefined;
-	this.zs_decoder = undefined;
+ZKClient.prototype.create = function (path, data, options, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.buffer(data, 'data');
+	mod_assert.optionalObject(options, 'options');
+	mod_assert.optionalFunc(cb, 'callback');
+	if (options === undefined)
+		options = {};
+	mod_assert.optionalArrayOfObject(options.acl, 'options.acl');
+	mod_assert.optionalArrayOfString(options.flags, 'options.flags');
 
-	this.zs_cr = undefined;
-	this.zs_lastPkt = undefined;
-	this.zs_lastZxid = new mod_jsbn.BigInteger('0');
+	if (options.acl === undefined) {
+		options.acl = [ {
+		    id: { scheme: 'world', id: 'anyone' },
+		    perms: ['read', 'write', 'create', 'delete', 'admin']
+		} ];
+	}
 
-	this.zs_xidMap = {};
-	this.zs_xid = 0;
-	this.zs_reqs = {};
-	this.zs_watchers = {};
+	if (options.flags === undefined) {
+		options.flags = [];
+	}
 
-	this.zs_delay = this.zs_minDelay;
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'CREATE',
+		path: path,
+		data: data,
+		acl: options.acl,
+		flags: options.flags
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null, pkt.path);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
 
-	var self = this;
-	S.immediate(function () {
-		self.emit('close');
+ZKClient.prototype.set = function (path, data, version, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.buffer(data, 'data');
+	mod_assert.optionalNumber(version, 'version');
+	mod_assert.optionalFunc(cb, 'callback');
+
+	if (version === undefined)
+		version = -1;
+
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'SET_DATA',
+		path: path,
+		data: data,
+		version: version
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null, pkt.path);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
+
+ZKClient.prototype.delete = function (path, version, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.number(version, 'version');
+	mod_assert.optionalFunc(cb, 'callback');
+
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'DELETE',
+		path: path,
+		version: version
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
+
+ZKClient.prototype.stat = function (path, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.optionalFunc(cb, 'callback');
+
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'EXISTS',
+		path: path,
+		watch: false
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null, pkt.stat);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
+
+ZKClient.prototype.sync = function (path, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.optionalFunc(cb, 'callback');
+
+	var conn = this.currentConnection();
+	if (conn === undefined)
+		throw (new Error('Not connected to ZooKeeper'));
+	var req = conn.request({
+		opcode: 'SYNC',
+		path: path
+	});
+	if (cb) {
+		req.once('reply', function onReply(pkt) {
+			cb(null);
+		});
+		req.once('error', cb);
+	}
+	return (req);
+};
+
+ZKClient.prototype.watcher = function (path) {
+	return (this.getSession().watcher(path));
+};
+
+
+
+function ZKConnectionFSM(opts) {
+	mod_assert.object(opts, 'options');
+	mod_assert.object(opts.log, 'options.log');
+	mod_assert.object(opts.client, 'options.client');
+	mod_assert.object(opts.backend, 'options.backend');
+
+	this.zcf_client = opts.client;
+	this.zcf_log = opts.log.child({
+		component: 'ZKConnectionFSM'
+	});
+	this.zcf_decoder = undefined;
+	this.zcf_encoder = undefined;
+	this.zcf_xidMap = {};
+	this.zcf_xid = 0;
+	this.zcf_reqs = {};
+	this.zcf_socket = undefined;
+	this.zcf_server = opts.backend;
+	this.zcf_session = undefined;
+
+	mod_fsm.FSM.call(this, 'init');
+}
+mod_util.inherits(ZKConnectionFSM, mod_fsm.FSM);
+
+ZKConnectionFSM.prototype.connect = function () {
+	mod_assert.ok(this.isInState('closed') || this.isInState('init'));
+	this.emit('connectAsserted');
+};
+
+ZKConnectionFSM.prototype.close = function () {
+	mod_assert.ok(!this.isInState('closed'));
+	this.emit('closeAsserted');
+};
+
+ZKConnectionFSM.prototype.destroy = function () {
+	if (this.isInState('closed'))
+		return;
+	this.emit('closeAsserted');
+};
+
+ZKConnectionFSM.prototype.nextXid = function () {
+	return (this.zcf_xid++);
+};
+
+ZKConnectionFSM.prototype.state_init = function (S) {
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
 	});
 };
 
-ZKClientFSM.prototype.state_connecting = function (S) {
+ZKConnectionFSM.prototype.state_connecting = function (S) {
 	var self = this;
-	this.zs_decoder = new mod_zkstreams.ZKDecodeStream({
+	this.zcf_decoder = new mod_zkstreams.ZKDecodeStream({
 		fsm: this
 	});
-	this.zs_encoder = new mod_zkstreams.ZKEncodeStream({
+	this.zcf_encoder = new mod_zkstreams.ZKEncodeStream({
 		fsm: this
 	});
 
-	this.zs_server = this.zs_servers.shift();
-	this.zs_servers.push(this.zs_server);
-
-	this.zs_log = this.zs_log.child({
-		zkHost: this.zs_server.host,
-		zkPort: this.zs_server.port
+	this.zcf_log = this.zcf_log.child({
+		zkAddress: this.zcf_server.address,
+		zkPort: this.zcf_server.port
 	});
-	this.zs_log.trace('attempting new connection');
+	this.zcf_log.trace('attempting new connection');
 
-	this.zs_socket = mod_net.connect({
-		host: this.zs_server.host,
-		port: this.zs_server.port,
+	this.zcf_socket = mod_net.connect({
+		host: this.zcf_server.host,
+		port: this.zcf_server.port,
 		allowHalfOpen: true
 	});
-	S.on(this.zs_socket, 'connect', function () {
+	S.on(this.zcf_socket, 'connect', function () {
 		S.gotoState('handshaking');
 	});
-	S.on(this.zs_socket, 'error', function (err) {
-		self.zs_lastError = err;
-		S.gotoState('connectError');
+	S.on(this.zcf_socket, 'error', function (err) {
+		self.zcf_lastError = err;
+		S.gotoState('error');
 	});
-	S.on(this.zs_socket, 'close', function () {
+	S.on(this.zcf_socket, 'close', function () {
 		S.gotoState('closed');
 	});
 	S.on(this, 'closeAsserted', function () {
@@ -171,133 +514,66 @@ ZKClientFSM.prototype.state_connecting = function (S) {
 	});
 };
 
-ZKClientFSM.prototype.state_connectError = function (S) {
+ZKConnectionFSM.prototype.state_handshaking = function (S) {
 	var self = this;
 
-	if (this.zs_encoder)
-		this.zs_encoder.end();
-	this.zs_encoder = undefined;
-	if (this.zs_socket)
-		this.zs_socket.destroy();
-	this.zs_socket = undefined;
-	this.zs_decoder = undefined;
-
-	this.zs_log.warn(this.zs_lastError, 'failed to connect to ZK');
-	/*
-	 * Don't use S.immediate here, we always want to make sure this gets
-	 * emitted, even though we're leaving this state.
-	 */
-	setImmediate(function () {
-		self.emit('error', self.zs_lastError);
-	});
-
-	if (this.zs_cr !== undefined && this.zs_lastPkt !== undefined) {
-		var now = new Date();
-		var delta = now.getTime() - this.zs_lastPkt.getTime();
-		if (delta > this.zs_cr.timeOut) {
-			this.zs_log.trace('has been %d ms since last ' +
-			    'session renewal, zk session lost',
-			    delta);
-			S.gotoState('closed');
-			return;
-		}
-	}
-
-	S.timeout(this.zs_delay, function () {
-		S.gotoState('connecting');
-	});
-
-	S.on(this, 'closeAsserted', function () {
-		S.gotoState('closed');
-	});
-
-	this.zs_delay *= 2;
-	if (this.zs_delay > this.zs_maxDelay)
-		this.zs_delay = this.zs_maxDelay;
-};
-
-ZKClientFSM.prototype.state_handshaking = function (S) {
-	var self = this;
-	S.on(this.zs_decoder, 'readable', function zkReadConnectResp() {
-		var pkt = self.zs_decoder.read();
+	S.on(this.zcf_decoder, 'readable', function zkReadConnectResp() {
+		var pkt = self.zcf_decoder.read();
 		if (pkt === null)
 			return;
-		if (self.zs_decoder.read() !== null) {
-			self.zs_lastError = new mod_errors.ZKProtocolError(
+		if (self.zcf_decoder.read() !== null) {
+			self.zcf_lastError = new mod_errors.ZKProtocolError(
 			    'UNEXPECTED_PACKET', 'Received unexpected ' +
 			    'additional packet during connect phase');
 			S.gotoState('error');
 			return;
 		}
 		if (pkt.protocolVersion !== 0) {
-			self.zs_lastError = new mod_errors.ZKProtocolError(
+			self.zcf_lastError = new mod_errors.ZKProtocolError(
 			    'VERSION_INCOMPAT', 'Server version is not ' +
 			    'compatible');
 			S.gotoState('error');
 			return;
 		}
-		if (pkt.sessionId.toString('hex') === '0000000000000000') {
-			self.zs_lastError = new mod_errors.ZKProtocolError(
-			    'SESSION_EXPIRED', 'Attempted to resume a ' +
-			    'session that had already expired');
-			S.gotoState('closed');
-			return;
-		}
-		var verb = 'created';
-		if (self.zs_cr !== undefined) {
-			verb = 'resumed';
-		}
-		self.zs_log.info('%s zookeeper session %s with timeout %d ms',
-		    verb, pkt.sessionId.toString('hex'), pkt.timeOut);
-		self.zs_log = self.zs_log.child({
-			zkSessionId: pkt.sessionId.toString('hex')
-		});
-		self.zs_cr = pkt;
-		self.zs_lastPkt = new Date();
-		S.gotoState('connected');
+		self.emit('packet', pkt);
 	});
 	function onError(err) {
-		self.zs_lastError = err;
-		S.gotoState('connectError');
+		self.zcf_lastError = err;
+		S.gotoState('error');
 	}
-	S.on(this.zs_decoder, 'error', onError);
-	S.on(this.zs_encoder, 'error', onError);
-	S.on(this.zs_socket, 'error', onError);
-	S.on(this.zs_socket, 'end', function () {
-		self.zs_lastError = new mod_errors.ZKProtocolError(
+	S.on(this.zcf_decoder, 'error', onError);
+	S.on(this.zcf_encoder, 'error', onError);
+	S.on(this.zcf_socket, 'error', onError);
+	S.on(this.zcf_socket, 'end', function () {
+		self.zcf_lastError = new mod_errors.ZKProtocolError(
 		    'CONNECTION_LOSS', 'Connection closed unexpectedly.');
-		S.gotoState('connectError');
+		S.gotoState('error');
 	});
 	S.on(this, 'closeAsserted', function () {
 		S.gotoState('closed');
 	});
-	S.timeout(Math.round(this.zs_timeout / 2), function () {
-		self.zs_lastError = new mod_errors.ZKProtocolError(
-		    'TIMEOUT', 'Timed out while waiting for ZK handshake to ' +
-		    'complete');
-		S.gotoState('connectError');
-	});
-	this.zs_socket.pipe(this.zs_decoder);
-	this.zs_encoder.pipe(this.zs_socket);
-	if (this.zs_cr !== undefined) {
-		this.zs_log.trace('attempting to resume session %s',
-		    this.zs_cr.sessionId.toString('hex'));
-	}
-	this.zs_encoder.write({
-		protocolVersion: 0,
-		lastZxidSeen: this.zs_lastZxid,
-		timeOut: this.zs_timeout,
-		sessionId: this.zs_cr ?
-		    this.zs_cr.sessionId : new mod_jsbn.BigInteger('0'),
-		passwd: this.zs_cr ?
-		    this.zs_cr.passwd : new Buffer(16).fill(0)
-	});
+	this.zcf_socket.pipe(this.zcf_decoder);
+	this.zcf_encoder.pipe(this.zcf_socket);
+
+	this.zcf_session = this.zcf_client.getSession();
+	if (this.zcf_session === undefined) {
+		S.gotoState('closed');
+		return;
+	}
+
+	S.on(this.zcf_session, 'stateChanged', function (st) {
+		if (st === 'attached') {
+			S.gotoState('connected');
+		}
+	});
+
+	this.zcf_session.attachAndSendCR(this);
 };
 
-ZKClientFSM.prototype.state_connected = function (S) {
+ZKConnectionFSM.prototype.state_connected = function (S) {
 	var self = this;
 
-	var pingInterval = this.zs_cr.timeOut / 4;
+	var pingInterval = this.zcf_session.getTimeout() / 4;
 	if (pingInterval < 2000)
 		pingInterval = 2000;
 	var pingTimer = S.interval(pingInterval, function () {
@@ -305,41 +581,41 @@ ZKClientFSM.prototype.state_connected = function (S) {
 	});
 	pingTimer.unref();
 
-	S.on(this.zs_decoder, 'readable', function onZkReadable() {
-		var pkt;
-		while (self.zs_decoder &&
-		    (pkt = self.zs_decoder.read()) !== null) {
-
-			self.zs_lastPkt = new Date();
+	this.zcf_log = this.zcf_log.child({
+		sessionId: this.zcf_session.getSessionId()
+	});
 
-			if (pkt.opcode === 'NOTIFICATION') {
-				self.processNotification(pkt);
+	S.on(this.zcf_decoder, 'readable', function onZkReadable() {
+		var pkt;
+		while (self.zcf_decoder &&
+		    (pkt = self.zcf_decoder.read()) !== null) {
+			self.emit('packet', pkt);
+
+			/*
+			 * Watchers and notifications are processed by
+			 * the ZKSession instance.
+			 */
+			if (pkt.opcode === 'NOTIFICATION')
 				continue;
-			}
-
-			var zxid = new mod_jsbn.BigInteger(pkt.zxid);
-			if (self.zs_lastZxid === undefined ||
-			    zxid.compareTo(self.zs_lastZxid) > 0) {
-				self.zs_lastZxid = zxid;
-			}
 
+			/* Everything else we need to emit on the req object */
 			self.processReply(pkt);
 		}
 	});
-	S.on(this.zs_decoder, 'end', function () {
-		self.zs_lastError = new mod_errors.ZKProtocolError(
+	S.on(this.zcf_decoder, 'end', function () {
+		self.zcf_lastError = new mod_errors.ZKProtocolError(
 		    'CONNECTION_LOSS', 'Connection closed unexpectedly.');
 		S.gotoState('error');
 	});
 	function onError(err) {
-		self.zs_lastError = err;
+		self.zcf_lastError = err;
 		S.gotoState('error');
 	}
-	S.on(this.zs_decoder, 'error', onError);
-	S.on(this.zs_encoder, 'error', onError);
-	S.on(this.zs_socket, 'error', onError);
-	S.on(this.zs_socket, 'end', function () {
-		self.zs_lastError = new mod_errors.ZKProtocolError(
+	S.on(this.zcf_decoder, 'error', onError);
+	S.on(this.zcf_encoder, 'error', onError);
+	S.on(this.zcf_socket, 'error', onError);
+	S.on(this.zcf_socket, 'end', function () {
+		self.zcf_lastError = new mod_errors.ZKProtocolError(
 		    'CONNECTION_LOSS', 'Connection closed unexpectedly.');
 		S.gotoState('error');
 	});
@@ -347,155 +623,156 @@ ZKClientFSM.prototype.state_connected = function (S) {
 		S.gotoState('closing');
 	});
 	S.on(this, 'pingTimeout', function () {
-		self.zs_lastError = new mod_errors.ZKPingTimeoutError();
+		self.zcf_lastError = new mod_errors.ZKPingTimeoutError();
 		S.gotoState('error');
 	});
 
-	this.resumeWatchers();
 	S.immediate(function () {
 		self.emit('connect');
 	});
 };
 
-ZKClientFSM.prototype.processNotification = function (pkt) {
+ZKConnectionFSM.prototype.state_closing = function (S) {
 	var self = this;
-	if (pkt.state !== 'SYNC_CONNECTED') {
-		self.zs_log.warn({
-			xid: pkt.xid,
-			errorCode: pkt.err,
-			state: pkt.state,
-			type: pkt.type,
-			zxid: pkt.zxid.toString('hex')
-		}, 'received notification with bad state %s', pkt.state);
-		return;
-	}
-	var watcher = self.zs_watchers[pkt.path];
-	var evt = pkt.type.toLowerCase().replace(/_[a-z]/g, function (s) {
-		return (s.slice(1).toUpperCase());
-	});
-	self.zs_log.trace({
-		xid: pkt.xid,
-		errorCode: pkt.err,
-		state: pkt.state,
-		zxid: pkt.zxid.toString('hex'),
-		type: pkt.type
-	}, 'notification %s for %s', evt, pkt.path);
-	if (watcher)
-		watcher.emit(evt);
-};
-
-ZKClientFSM.prototype.processReply = function (pkt) {
-	var self = this;
-
-	var req = self.zs_reqs[pkt.xid];
-
-	self.zs_log.trace({
-		xid: pkt.xid,
-		opcode: req.packet.opcode,
-		errorCode: pkt.err
-	}, 'server replied to request');
-
-	if (req === undefined) {
-		self.emit('packet', pkt);
-	} else {
-		if (pkt.err === 'OK') {
-			req.emit('reply', pkt);
-			return;
-		}
-		var err = new mod_errors.ZKError(
-		    pkt.err, mod_consts.ERR_TEXT[pkt.err]);
-		req.emit('error', err, pkt);
-	}
-};
-
-ZKClientFSM.prototype.state_closing = function (S) {
-	var self = this;
-	var xid = this.nextXid();
-	S.on(this.zs_decoder, 'readable', function () {
+	var xid;
+	S.on(this.zcf_decoder, 'readable', function () {
 		var pkt;
-		while (self.zs_decoder &&
-		    (pkt = self.zs_decoder.read()) !== null) {
+		while (self.zcf_decoder &&
+		    (pkt = self.zcf_decoder.read()) !== null) {
 			if (pkt.xid !== xid) {
-				var req = self.zs_reqs[pkt.xid];
-				if (req !== undefined) {
-					if (pkt.err === 'OK') {
-						req.emit('reply', pkt);
-						continue;
-					}
-					var err = new mod_errors.ZKError(
-					    pkt.err,
-					    mod_consts.ERR_TEXT[pkt.err]);
-					req.emit('error', err, pkt);
-				}
+				self.processReply(pkt);
+
+				if (Object.keys(self.zcf_reqs).length < 1)
+					sendCloseSession();
 			} else {
 				S.gotoState('closed');
 				return;
 			}
 		}
 	});
-	S.on(this.zs_decoder, 'error', function (err) {
-		self.zs_lastError = err;
+	S.on(this.zcf_decoder, 'error', function (err) {
+		self.zcf_lastError = err;
 		S.gotoState('closed');
 	});
-	S.on(this.zs_encoder, 'error', function (err) {
-		self.zs_lastError = err;
+	S.on(this.zcf_encoder, 'error', function (err) {
+		self.zcf_lastError = err;
 		S.gotoState('closed');
 	});
-	S.on(this.zs_decoder, 'end', function () {
+	S.on(this.zcf_decoder, 'end', function () {
 		S.gotoState('closed');
 	});
-	S.on(this.zs_socket, 'error', function (err) {
-		self.zs_lastError = err;
+	S.on(this.zcf_socket, 'error', function (err) {
+		self.zcf_lastError = err;
 		S.gotoState('closed');
 	});
-	this.zs_log.info({ xid: xid }, 'sent CLOSE_SESSION request');
-	this.zs_encoder.write({
-		opcode: 'CLOSE_SESSION',
-		xid: xid
-	});
-	this.zs_encoder.end();
+	if (Object.keys(self.zcf_reqs).length < 1)
+		sendCloseSession();
+
+	function sendCloseSession() {
+		xid = self.nextXid();
+		self.zcf_log.info({ xid: xid }, 'sent CLOSE_SESSION request');
+		self.zcf_encoder.write({
+			opcode: 'CLOSE_SESSION',
+			xid: xid
+		});
+		self.zcf_encoder.end();
+	}
 };
 
-ZKClientFSM.prototype.state_error = function (S) {
+ZKConnectionFSM.prototype.state_error = function (S) {
 	var self = this;
-	this.zs_log.warn(this.zs_lastError, 'error communicating with ZK, ' +
-	    'cancelling all outstanding requests');
-	Object.keys(this.zs_reqs).forEach(function (xid) {
-		self.zs_reqs[xid].emit('error', self.zs_lastError);
-	});
-	this.zs_reqs = {};
-
-	if (this.zs_encoder)
-		this.zs_encoder.end();
-	this.zs_encoder = undefined;
-	if (this.zs_socket)
-		this.zs_socket.destroy();
-	this.zs_socket = undefined;
-	this.zs_decoder = undefined;
-
-	if (this.zs_cr !== undefined && this.zs_lastPkt !== undefined) {
-		var now = new Date();
-		var delta = now.getTime() - this.zs_lastPkt.getTime();
-		if (delta < this.zs_cr.timeOut) {
-			this.zs_log.trace('has been %d ms since last ' +
-			    'session renewal, will retry (session timeout = ' +
-			    '%d ms)', delta, this.zs_cr.timeOut);
-			S.gotoState('connecting');
-			return;
-		}
-	}
+	this.zcf_log.warn(this.zcf_lastError, 'error communicating with ZK');
+	Object.keys(this.zcf_reqs).forEach(function (xid) {
+		self.zcf_reqs[xid].emit('error', self.zcf_lastError);
+	});
+	this.zcf_reqs = {};
+
 	/*
 	 * Don't use S.immediate here, we always want to make sure this gets
 	 * emitted, even though we're leaving this state.
 	 */
 	setImmediate(function () {
-		self.emit('error', self.zs_lastError);
+		self.emit('error', self.zcf_lastError);
 	});
 
 	S.gotoState('closed');
 };
 
-ZKClientFSM.prototype.ping = function (cb) {
+ZKConnectionFSM.prototype.state_closed = function (S) {
+	if (this.zcf_encoder)
+		this.zcf_encoder.end();
+	this.zcf_encoder = undefined;
+	if (this.zcf_socket)
+		this.zcf_socket.destroy();
+	this.zcf_socket = undefined;
+	this.zcf_decoder = undefined;
+
+	var self = this;
+	S.immediate(function () {
+		self.emit('close');
+	});
+};
+
+ZKConnectionFSM.prototype.processReply = function (pkt) {
+	var self = this;
+
+	var req = self.zcf_reqs[pkt.xid];
+
+	self.zcf_log.trace({
+		xid: pkt.xid,
+		opcode: req.packet.opcode,
+		errorCode: pkt.err
+	}, 'server replied to request');
+
+	if (req !== undefined) {
+		if (pkt.err === 'OK') {
+			req.emit('reply', pkt);
+			return;
+		}
+		var err = new mod_errors.ZKError(
+		    pkt.err, mod_consts.ERR_TEXT[pkt.err]);
+		req.emit('error', err, pkt);
+	}
+};
+
+function ZKRequest(packet) {
+	mod_events.EventEmitter.call(this);
+	this.packet = packet;
+}
+mod_util.inherits(ZKRequest, mod_events.EventEmitter);
+
+ZKConnectionFSM.prototype.request = function (pkt) {
+	mod_assert.object(pkt, 'packet');
+	var self = this;
+	if (!this.isInState('connected'))
+		throw (new Error('Client must be connected to send requests'));
+
+	var req = new ZKRequest(pkt);
+	pkt.xid = this.nextXid();
+	this.zcf_reqs[pkt.xid] = req;
+	req.once('reply', endRequest);
+	req.once('error', endRequest);
+
+	this.zcf_log.trace({
+		xid: pkt.xid,
+		opcode: pkt.opcode
+	}, 'sent request to server');
+
+	this.zcf_encoder.write(pkt);
+
+	return (req);
+
+	function endRequest() {
+		delete (self.zcf_reqs[pkt.xid]);
+	}
+};
+
+ZKConnectionFSM.prototype.send = function (pkt) {
+	mod_assert.object(pkt, 'packet');
+	this.zcf_encoder.write(pkt);
+};
+
+ZKConnectionFSM.prototype.ping = function (cb) {
 	mod_assert.optionalFunc(cb, 'callback');
 	if (!this.isInState('connected'))
 		throw (new Error('Client must be connected to send packets'));
@@ -505,28 +782,31 @@ ZKClientFSM.prototype.ping = function (cb) {
 		opcode: 'PING'
 	};
 	var req = new ZKRequest(pkt);
-	if (this.zs_reqs[pkt.xid] !== undefined) {
-		this.zs_reqs[pkt.xid].once('reply', function () {
+	if (this.zcf_reqs[pkt.xid] !== undefined) {
+		this.zcf_reqs[pkt.xid].once('reply', function () {
 			if (cb !== undefined)
 				cb();
 		});
-		this.zs_reqs[pkt.xid].once('error', function (err) {
+		this.zcf_reqs[pkt.xid].once('error', function (err) {
 			if (cb !== undefined)
 				cb(err);
 		});
 		return;
 	}
-	this.zs_reqs[pkt.xid] = req;
+	this.zcf_reqs[pkt.xid] = req;
 	req.once('reply', onPacket);
 	req.once('error', onError);
-	var timer = setTimeout(onTimeout, this.zs_cr.timeOut / 4);
+	var timeout = this.zcf_session.getTimeout() / 8;
+	if (timeout < 2000)
+		timeout = 2000;
+	var timer = setTimeout(onTimeout, this.zcf_session.getTimeout() / 8);
 	var t1 = new Date();
-	this.zs_encoder.write(pkt);
+	this.zcf_encoder.write(pkt);
 	function onPacket(pkt2) {
-		delete (self.zs_reqs[pkt.xid]);
+		delete (self.zcf_reqs[pkt.xid]);
 		var t2 = new Date();
 		clearTimeout(timer);
-		self.zs_log.trace('ping ok in %d ms', (t2 - t1));
+		self.zcf_log.trace('ping ok in %d ms', (t2 - t1));
 		if (cb !== undefined)
 			cb(null, (t2 - t1));
 	}
@@ -535,59 +815,20 @@ ZKClientFSM.prototype.ping = function (cb) {
 		self.emit('pingTimeout');
 	}
 	function onError(err) {
-		delete (self.zs_reqs[pkt.xid]);
+		delete (self.zcf_reqs[pkt.xid]);
 		clearTimeout(timer);
 		if (cb !== undefined)
 			cb(err);
 	}
 };
 
-ZKClientFSM.prototype.resumeWatchers = function () {
-	var self = this;
-	var events = {
-		dataChanged: [],
-		createdOrDestroyed: [],
-		childrenChanged: []
-	};
-	var count = 0;
-	var paths = Object.keys(this.zs_watchers);
-	paths.forEach(function (path) {
-		var w = self.zs_watchers[path];
-		var evts = w.eventsActive();
-		var cod = false;
-		evts.forEach(function (evt) {
-			if (evt === 'created' || evt === 'deleted') {
-				if (cod)
-					return;
-				events.createdOrDestroyed.push(path);
-				++count;
-				cod = true;
-			} else if (evt === 'dataChanged') {
-				events.dataChanged.push(path);
-				++count;
-			} else if (evt === 'childrenChanged') {
-				events.childrenChanged.push(path);
-				++count;
-			}
-		});
-	});
-	if (count < 1)
-		return;
-	var zxid = this.zs_lastZxid;
-	var hex = zxid.toString(16);
-	this.zs_log.info('re-arming %d node watchers at zxid %s', count, hex);
-	this.setWatches(events, zxid, function (err) {
-		if (err) {
-			self.emit('pingTimeout');
-		}
-	});
-};
-
-ZKClientFSM.prototype.setWatches = function (events, zxid, cb) {
+ZKConnectionFSM.prototype.setWatches = function (events, zxid, cb) {
 	mod_assert.object(events, 'events');
 	mod_assert.func(cb, 'callback');
-	if (!this.isInState('connected'))
-		throw (new Error('Client must be connected to send packets'));
+	if (!this.isInState('connected')) {
+		throw (new mod_verror.VError('Client must be connected to ' +
+		    'send packets (is in state %s)', this.getState()));
+	}
 	var self = this;
 	var pkt = {
 		xid: mod_consts.XID_SET_WATCHES,
@@ -596,342 +837,23 @@ ZKClientFSM.prototype.setWatches = function (events, zxid, cb) {
 		events: events
 	};
 	var req = new ZKRequest(pkt);
-	if (this.zs_reqs[pkt.xid] !== undefined) {
-		this.zs_reqs[pkt.xid].once('reply', function () {
-			self.setWatches(events, cb);
+	if (this.zcf_reqs[pkt.xid] !== undefined) {
+		this.zcf_reqs[pkt.xid].once('reply', function () {
+			self.setWatches(events, zxid, cb);
 		});
-		this.zs_reqs[pkt.xid].once('error', cb);
+		this.zcf_reqs[pkt.xid].once('error', cb);
 		return;
 	}
-	this.zs_reqs[pkt.xid] = req;
+	this.zcf_reqs[pkt.xid] = req;
 	req.once('reply', onPacket);
 	req.once('error', onError);
-	this.zs_encoder.write(pkt);
+	this.zcf_encoder.write(pkt);
 	function onPacket(pkt2) {
-		delete (self.zs_reqs[pkt.xid]);
+		delete (self.zcf_reqs[pkt.xid]);
 		cb(null);
 	}
 	function onError(err) {
-		delete (self.zs_reqs[pkt.xid]);
+		delete (self.zcf_reqs[pkt.xid]);
 		cb(err);
 	}
 };
-
-function ZKRequest(packet) {
-	mod_events.EventEmitter.call(this);
-	this.packet = packet;
-}
-mod_util.inherits(ZKRequest, mod_events.EventEmitter);
-
-ZKClientFSM.prototype.request = function (pkt) {
-	mod_assert.object(pkt, 'packet');
-	var self = this;
-	if (!this.isInState('connected'))
-		throw (new Error('Client must be connected to send packets'));
-
-	var req = new ZKRequest(pkt);
-	pkt.xid = this.nextXid();
-	this.zs_reqs[pkt.xid] = req;
-	req.once('reply', endRequest);
-	req.once('error', endRequest);
-
-	this.zs_log.trace({
-		xid: pkt.xid,
-		opcode: pkt.opcode
-	}, 'sent request to server');
-
-	this.zs_encoder.write(pkt);
-
-	return (req);
-
-	function endRequest() {
-		delete (self.zs_reqs[pkt.xid]);
-	}
-};
-
-ZKClientFSM.prototype.list = function (path, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
-	var req = this.request({
-		opcode: 'GET_CHILDREN2',
-		path: path,
-		watch: false
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.children, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.get = function (path, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
-	var req = this.request({
-		opcode: 'GET_DATA',
-		path: path,
-		watch: false
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.data, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.create = function (path, data, options, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.buffer(data, 'data');
-	mod_assert.optionalObject(options, 'options');
-	mod_assert.optionalFunc(cb, 'callback');
-	if (options === undefined)
-		options = {};
-	mod_assert.optionalArrayOfObject(options.acl, 'options.acl');
-	mod_assert.optionalArrayOfString(options.flags, 'options.flags');
-
-	if (options.acl === undefined) {
-		options.acl = [ {
-		    id: { scheme: 'world', id: 'anyone' },
-		    perms: ['read', 'write', 'create', 'delete', 'admin']
-		} ];
-	}
-
-	if (options.flags === undefined) {
-		options.flags = [];
-	}
-
-	var req = this.request({
-		opcode: 'CREATE',
-		path: path,
-		data: data,
-		acl: options.acl,
-		flags: options.flags
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.path);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.set = function (path, data, version, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.buffer(data, 'data');
-	mod_assert.optionalNumber(version, 'version');
-	mod_assert.optionalFunc(cb, 'callback');
-
-	if (version === undefined)
-		version = -1;
-
-	var req = this.request({
-		opcode: 'SET_DATA',
-		path: path,
-		data: data,
-		version: version
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.path);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.delete = function (path, version, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.number(version, 'version');
-	mod_assert.optionalFunc(cb, 'callback');
-
-	var req = this.request({
-		opcode: 'DELETE',
-		path: path,
-		version: version
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.stat = function (path, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
-
-	var req = this.request({
-		opcode: 'EXISTS',
-		path: path,
-		watch: false
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-ZKClientFSM.prototype.sync = function (path, cb) {
-	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
-
-	var req = this.request({
-		opcode: 'SYNC',
-		path: path
-	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null);
-		});
-		req.once('error', cb);
-	}
-	return (req);
-};
-
-function ZKWatcher(client, path) {
-	this.zkw_path = path;
-	this.zkw_client = client;
-	mod_events.EventEmitter.call(this);
-}
-mod_util.inherits(ZKWatcher, mod_events.EventEmitter);
-
-ZKWatcher.prototype.eventsActive = function () {
-	var self = this;
-	var evts = ['created', 'deleted', 'dataChanged', 'childrenChanged'];
-	evts = evts.filter(function (evt) {
-		return (self.listeners(evt).length > 0);
-	});
-	return (evts);
-};
-
-ZKWatcher.prototype.once = function () {
-	throw (new Error('ZKWatcher does not support once() (use on)'));
-};
-
-ZKWatcher.prototype.on = function (evt, cb) {
-	mod_assert.string(evt, 'event');
-	mod_assert.func(cb, 'callback');
-	var first = (this.listeners(evt).length < 1);
-	mod_events.EventEmitter.prototype.on.call(this, evt, cb);
-	if (evt !== 'error' && first)
-		this.emit(evt);
-	return (this);
-};
-
-ZKWatcher.prototype.emit = function (evt) {
-	var self = this;
-	if (this.listeners(evt).length < 1)
-		return;
-	if (!this.zkw_client.isInState('connected')) {
-		function onStateChanged(st) {
-			if (st === 'connected') {
-				self.emit(evt);
-				self.zkw_client.removeListener('stateChanged',
-				    onStateChanged);
-			}
-		}
-		this.zkw_client.zs_log.trace({
-			event: evt,
-			clientState: this.zkw_client.getState()
-		}, 'deferring watcher refresh until after reconnect');
-		this.zkw_client.on('stateChanged', onStateChanged);
-		return;
-	}
-	var qpkt = this.reqPacket(evt);
-	var req = this.zkw_client.request(qpkt);
-	req.on('reply', function (pkt) {
-		var args = [evt];
-		switch (evt) {
-		case 'created':
-			args.push(pkt.stat);
-			break;
-		case 'deleted':
-			return;
-		case 'dataChanged':
-			args.push(pkt.data, pkt.stat);
-			break;
-		case 'childrenChanged':
-			args.push(pkt.children, pkt.stat);
-			break;
-		default:
-			throw (new Error('Unknown watcher event ' + evt));
-		}
-		mod_events.EventEmitter.prototype.emit.apply(self, args);
-	});
-	req.on('error', function (err) {
-		if (err.code === 'PING_TIMEOUT') {
-			self.emit(evt);
-			return;
-		}
-		if (evt === 'created' && err.code === 'NO_NODE') {
-			return;
-		}
-		if (evt === 'deleted' && err.code === 'NO_NODE') {
-			mod_events.EventEmitter.prototype.emit.call(self, evt);
-			return;
-		}
-		if (err.code === 'NO_NODE') {
-			function onCreated() {
-				self.removeListener('created', onCreated);
-				self.emit(evt);
-			}
-			self.on('created', onCreated);
-			return;
-		}
-		mod_events.EventEmitter.prototype.emit.call(self, 'error', err);
-	});
-};
-
-ZKWatcher.prototype.reqPacket = function (evt) {
-	var pkt = {
-		path: this.zkw_path,
-		watch: true
-	};
-	switch (evt) {
-	case 'created':
-	case 'deleted':
-		pkt.opcode = 'EXISTS';
-		break;
-	case 'dataChanged':
-		pkt.opcode = 'GET_DATA';
-		break;
-	case 'childrenChanged':
-		pkt.opcode = 'GET_CHILDREN2';
-		break;
-	default:
-		throw (new Error('Unknown watcher event ' + evt));
-	}
-	return (pkt);
-};
-
-ZKClientFSM.prototype.watcher = function (path) {
-	var w = this.zs_watchers[path];
-	if (w)
-		return (w);
-	w = new ZKWatcher(this, path);
-	this.zs_watchers[path] = w;
-	return (w);
-};
-
-/* A Fisher-Yates shuffle. */
-function shuffle(array) {
-	var i = array.length;
-	while (i > 0) {
-		var j = Math.floor(Math.random() * i);
-		--i;
-		var temp = array[i];
-		array[i] = array[j];
-		array[j] = temp;
-	}
-	return (array);
-}
diff --git a/lib/zk-session.js b/lib/zk-session.js
new file mode 100644
index 0000000..d2d85e8
--- /dev/null
+++ b/lib/zk-session.js
@@ -0,0 +1,460 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+module.exports = {
+	ZKSession: ZKSession,
+	ZKWatcher: ZKWatcher
+};
+
+const mod_fsm = require('mooremachine');
+const mod_assert = require('assert-plus');
+const mod_consts = require('./zk-consts');
+const mod_util = require('util');
+const mod_stream = require('stream');
+const mod_errors = require('./errors');
+const mod_jsbn = require('jsbn');
+const mod_events = require('events');
+const mod_bunyan = require('bunyan');
+const mod_verror = require('verror');
+
+function ZKSession(opts) {
+	mod_assert.object(opts, 'options');
+	mod_assert.number(opts.timeout, 'options.timeout');
+	mod_assert.object(opts.log, 'options.log');
+
+	this.zs_conn = undefined;
+
+	this.zs_lastPkt = undefined;
+	this.zs_expiryTimer = new mod_events.EventEmitter();
+	this.zs_watchers = {};
+	this.zs_timeout = opts.timeout;
+	this.zs_log = opts.log.child({
+		component: 'ZKSession'
+	});
+
+	this.zs_lastZxid = new mod_jsbn.BigInteger('0');
+	this.zs_sessionId = new mod_jsbn.BigInteger('0');
+	this.zs_passwd = new Buffer(8).fill(0);
+
+	mod_fsm.FSM.call(this, 'detached');
+}
+mod_util.inherits(ZKSession, mod_fsm.FSM);
+
+ZKSession.prototype.isAlive = function () {
+	if (this.zs_sessionId === undefined)
+		return (false);
+	if (this.zs_lastPkt === undefined)
+		return (false);
+	var now = new Date();
+	var delta = now.getTime() - this.zs_lastPkt.getTime();
+	if (delta < this.zs_timeout)
+		return (true);
+	return (false);
+};
+
+ZKSession.prototype.attachAndSendCR = function (conn) {
+	if (!this.isInState('detached')) {
+		throw (new Error('ZKSession#attachAndSendCR may only be ' +
+		    'called in state "detached" (is in ' + this.getState() +
+		    ')'));
+	}
+	this.emit('assertAttach', conn);
+};
+
+ZKSession.prototype.resetExpiryTimer = function () {
+	var self = this;
+	this.zs_lastPkt = new Date();
+	if (this.zs_expiryTimer.ref)
+		clearTimeout(this.zs_expiryTimer.ref);
+	this.zs_expiryTimer.ref = setTimeout(function () {
+		self.zs_expiryTimer.ref = undefined;
+		self.zs_expiryTimer.emit('timeout');
+	}, this.zs_timeout);
+};
+
+ZKSession.prototype.getTimeout = function () {
+	return (this.zs_timeout);
+};
+
+ZKSession.prototype.getConnection = function () {
+	if (!this.isInState('attached'))
+		return (undefined);
+	return (this.zs_conn);
+};
+
+ZKSession.prototype.getSessionId = function () {
+	var b = new Buffer(this.zs_sessionId.toByteArray());
+	return (b.toString('hex'));
+};
+
+ZKSession.prototype.close = function () {
+	this.emit('closeAsserted');
+};
+
+ZKSession.prototype.state_detached = function (S) {
+	var self = this;
+	if (this.zs_conn)
+		this.zs_conn.destroy();
+	this.zs_conn = undefined;
+	S.on(this, 'assertAttach', function (client) {
+		self.zs_conn = client;
+		S.gotoState('attaching');
+	});
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closed');
+	});
+	S.on(this.zs_expiryTimer, 'timeout', function () {
+		S.gotoState('expired');
+	});
+};
+
+ZKSession.prototype.state_attaching = function (S) {
+	var self = this;
+
+	function onError() {
+		if (self.isAlive()) {
+			S.gotoState('detached');
+		} else if (!self.zs_sessionId.equals(
+		    mod_jsbn.BigInteger.ZERO)) {
+			S.gotoState('expired');
+		} else {
+			S.gotoState('detached');
+		}
+	}
+
+	S.on(this.zs_conn, 'error', onError);
+	/*
+	 * This can happen separately to an 'error' event when cueball
+	 * times out the connect attempt.
+	 */
+	S.on(this.zs_conn, 'close', onError);
+
+	S.on(this.zs_conn, 'packet', function (pkt) {
+		var sid = new mod_jsbn.BigInteger(pkt.sessionId);
+		if (sid.equals(mod_jsbn.BigInteger.ZERO)) {
+			S.gotoState('expired');
+			return;
+		}
+		var verb = 'created';
+		if (!self.zs_sessionId.equals(mod_jsbn.BigInteger.ZERO))
+			verb = 'resumed';
+		self.zs_log.info('%s zookeeper session %s with timeout ' +
+		    '%d ms', verb, pkt.sessionId.toString('hex'), pkt.timeOut);
+		self.zs_log = self.zs_log.child({
+			id: pkt.sessionId.toString('hex')
+		});
+		self.zs_timeout = pkt.timeOut;
+		self.zs_sessionId = sid;
+		self.zs_passwd = pkt.passwd;
+		self.resetExpiryTimer();
+		S.gotoState('attached');
+	});
+
+	S.on(this.zs_expiryTimer, 'timeout', function () {
+		S.gotoState('expired');
+	});
+
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closing');
+	});
+
+	this.zs_conn.send({
+		protocolVersion: 0,
+		lastZxidSeen: this.zs_lastZxid,
+		timeOut: this.zs_timeout,
+		sessionId: this.zs_sessionId,
+		passwd: this.zs_passwd
+	});
+};
+
+ZKSession.prototype.state_attached = function (S) {
+	var self = this;
+
+	S.on(this.zs_conn, 'close', function () {
+		if (self.isAlive()) {
+			S.gotoState('detached');
+		} else {
+			S.gotoState('expired');
+		}
+	});
+
+	S.on(this.zs_conn, 'error', function () {
+		if (self.isAlive()) {
+			S.gotoState('detached');
+		} else {
+			S.gotoState('expired');
+		}
+	});
+
+	S.on(this.zs_conn, 'packet', function (pkt) {
+		self.resetExpiryTimer();
+		if (pkt.opcode !== 'NOTIFICATION') {
+			var zxid = new mod_jsbn.BigInteger(pkt.zxid);
+			if (self.zs_lastZxid === undefined ||
+			    zxid.compareTo(self.zs_lastZxid) > 0) {
+				self.zs_lastZxid = zxid;
+			}
+			return;
+		}
+		self.processNotification(pkt);
+	});
+
+	S.on(this.zs_expiryTimer, 'timeout', function () {
+		S.gotoState('expired');
+	});
+
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closing');
+	});
+
+	S.on(this.zs_conn, 'stateChanged', function (st) {
+		if (st === 'connected') {
+			self.resumeWatches();
+		}
+	});
+};
+
+ZKSession.prototype.state_closing = function (S) {
+	S.on(this.zs_conn, 'error', function () {
+		S.gotoState('closed');
+	});
+
+	S.on(this.zs_conn, 'close', function () {
+		S.gotoState('closed');
+	});
+
+	S.on(this.zs_expiryTimer, 'timeout', function () {
+		S.gotoState('closed');
+	});
+
+	this.zs_conn.close();
+};
+
+ZKSession.prototype.state_expired = function (S) {
+	if (this.zs_conn)
+		this.zs_conn.destroy();
+	this.zs_conn = undefined;
+	if (this.zs_expiryTimer.ref)
+		clearTimeout(this.zs_expiryTimer.ref);
+	this.zs_expiryTimer = undefined;
+	this.zs_log.warn('ZK session expired');
+};
+
+ZKSession.prototype.state_closed = function (S) {
+	if (this.zs_conn)
+		this.zs_conn.destroy();
+	this.zs_conn = undefined;
+	if (this.zs_expiryTimer.ref)
+		clearTimeout(this.zs_expiryTimer.ref);
+	this.zs_expiryTimer = undefined;
+	this.zs_log.info('ZK session closed');
+};
+
+ZKSession.prototype.processNotification = function (pkt) {
+	var self = this;
+	if (pkt.state !== 'SYNC_CONNECTED') {
+		self.zs_log.warn({
+			xid: pkt.xid,
+			errorCode: pkt.err,
+			state: pkt.state,
+			type: pkt.type,
+			zxid: pkt.zxid.toString('hex')
+		}, 'received notification with bad state %s', pkt.state);
+		return;
+	}
+	var watcher = self.zs_watchers[pkt.path];
+	var evt = pkt.type.toLowerCase().replace(/_[a-z]/g, function (s) {
+		return (s.slice(1).toUpperCase());
+	});
+	self.zs_log.trace({
+		xid: pkt.xid,
+		errorCode: pkt.err,
+		state: pkt.state,
+		zxid: pkt.zxid.toString('hex'),
+		type: pkt.type
+	}, 'notification %s for %s', evt, pkt.path);
+	if (watcher)
+		watcher.emit(evt);
+};
+
+ZKSession.prototype.resumeWatches = function () {
+	var self = this;
+	var events = {
+		dataChanged: [],
+		createdOrDestroyed: [],
+		childrenChanged: []
+	};
+	var count = 0;
+	var paths = Object.keys(this.zs_watchers);
+	paths.forEach(function (path) {
+		var w = self.zs_watchers[path];
+		var evts = w.eventsActive();
+		var cod = false;
+		evts.forEach(function (evt) {
+			if (evt === 'created' || evt === 'deleted') {
+				if (cod)
+					return;
+				events.createdOrDestroyed.push(path);
+				++count;
+				cod = true;
+			} else if (evt === 'dataChanged') {
+				events.dataChanged.push(path);
+				++count;
+			} else if (evt === 'childrenChanged') {
+				events.childrenChanged.push(path);
+				++count;
+			}
+		});
+	});
+	if (count < 1)
+		return;
+	var zxid = this.zs_lastZxid;
+	var hex = zxid.toString(16);
+	this.zs_log.info('re-arming %d node watchers at zxid %s', count, hex);
+	this.zs_conn.setWatches(events, zxid, function (err) {
+		if (err) {
+			self.emit('pingTimeout');
+		}
+	});
+};
+
+ZKSession.prototype.watcher = function (path) {
+	var w = this.zs_watchers[path];
+	if (w)
+		return (w);
+	w = new ZKWatcher(this, path);
+	this.zs_watchers[path] = w;
+	return (w);
+};
+
+function ZKWatcher(session, path) {
+	this.zkw_path = path;
+	this.zkw_session = session;
+	mod_events.EventEmitter.call(this);
+}
+mod_util.inherits(ZKWatcher, mod_events.EventEmitter);
+
+ZKWatcher.prototype.eventsActive = function () {
+	var self = this;
+	var evts = ['created', 'deleted', 'dataChanged', 'childrenChanged'];
+	evts = evts.filter(function (evt) {
+		return (self.listeners(evt).length > 0);
+	});
+	return (evts);
+};
+
+ZKWatcher.prototype.once = function () {
+	throw (new Error('ZKWatcher does not support once() (use on)'));
+};
+
+ZKWatcher.prototype.on = function (evt, cb) {
+	mod_assert.string(evt, 'event');
+	mod_assert.func(cb, 'callback');
+	var first = (this.listeners(evt).length < 1);
+	mod_events.EventEmitter.prototype.on.call(this, evt, cb);
+	if (evt !== 'error' && first)
+		this.emit(evt);
+	return (this);
+};
+
+ZKWatcher.prototype.emit = function (evt) {
+	var self = this;
+	if (this.listeners(evt).length < 1)
+		return;
+	if (!this.zkw_session.isInState('attached')) {
+		function onStateChanged(st) {
+			if (st === 'connected') {
+				self.emit(evt);
+				self.zkw_session.removeListener('stateChanged',
+				    onStateChanged);
+			}
+		}
+		this.zkw_session.zs_log.trace({
+			event: evt,
+			clientState: this.zkw_session.getState()
+		}, 'deferring watcher refresh until after reconnect');
+		this.zkw_session.on('stateChanged', onStateChanged);
+		return;
+	}
+	var conn = this.zkw_session.getConnection();
+	if (!conn.isInState('connected')) {
+		setImmediate(function () {
+			self.emit(evt);
+		});
+		return;
+	}
+	var qpkt = this._reqPacket(evt);
+	var req = conn.request(qpkt);
+	req.on('reply', function (pkt) {
+		var args = [evt];
+		switch (evt) {
+		case 'created':
+			args.push(pkt.stat);
+			break;
+		case 'deleted':
+			return;
+		case 'dataChanged':
+			args.push(pkt.data, pkt.stat);
+			break;
+		case 'childrenChanged':
+			args.push(pkt.children, pkt.stat);
+			break;
+		default:
+			throw (new Error('Unknown watcher event ' + evt));
+		}
+		mod_events.EventEmitter.prototype.emit.apply(self, args);
+	});
+	req.on('error', function (err) {
+		if (err.code === 'PING_TIMEOUT') {
+			self.emit(evt);
+			return;
+		}
+		if (evt === 'created' && err.code === 'NO_NODE') {
+			return;
+		}
+		if (evt === 'deleted' && err.code === 'NO_NODE') {
+			mod_events.EventEmitter.prototype.emit.call(self, evt);
+			return;
+		}
+		if (err.code === 'NO_NODE') {
+			function onCreated() {
+				self.removeListener('created', onCreated);
+				self.emit(evt);
+			}
+			self.on('created', onCreated);
+			return;
+		}
+		setImmediate(function () {
+			self.emit(evt);
+		});
+		self.zkw_session.zs_log.trace(err, 'watcher attach failure; ' +
+		    'will retry');
+	});
+};
+
+ZKWatcher.prototype._reqPacket = function (evt) {
+	var pkt = {
+		path: this.zkw_path,
+		watch: true
+	};
+	switch (evt) {
+	case 'created':
+	case 'deleted':
+		pkt.opcode = 'EXISTS';
+		break;
+	case 'dataChanged':
+		pkt.opcode = 'GET_DATA';
+		break;
+	case 'childrenChanged':
+		pkt.opcode = 'GET_CHILDREN2';
+		break;
+	default:
+		throw (new Error('Unknown watcher event ' + evt));
+	}
+	return (pkt);
+};
diff --git a/lib/zk-streams.js b/lib/zk-streams.js
index b65b3c8..6e4eafa 100644
--- a/lib/zk-streams.js
+++ b/lib/zk-streams.js
@@ -76,7 +76,7 @@ ZKDecodeStream.prototype._transform = function (chunk, enc, cb) {
 			self.push(pkt);
 		} else {
 			try {
-				pkt = zkb.readResponse(self.zd_fsm.zs_xidMap);
+				pkt = zkb.readResponse(self.zd_fsm.zcf_xidMap);
 			} catch (e) {
 				self.emit('error',
 				    new mod_errors.ZKProtocolError('BAD_DECODE',
@@ -123,7 +123,7 @@ ZKEncodeStream.prototype._transform = function (pkt, enc, cb) {
 			sub.writeRequest(pkt);
 		});
 		this.push(zkb.toBuffer());
-		this.ze_fsm.zs_xidMap[pkt.xid] = pkt.opcode;
+		this.ze_fsm.zcf_xidMap[pkt.xid] = pkt.opcode;
 		cb();
 	}
 };
diff --git a/package.json b/package.json
index 7112b36..27ecd3a 100644
--- a/package.json
+++ b/package.json
@@ -6,11 +6,12 @@
   "dependencies": {
     "assert-plus": "^1.0.0",
     "bunyan": "^1.8.10",
+    "cueball": "^2.2.7",
     "jsbn": "^0.1.0",
     "mooremachine": "^2.0.0",
     "node-uuid": "^1.4.7",
-    "vasync": "^1.6.3",
-    "verror": "^1.6.1"
+    "vasync": "^1.6.4",
+    "verror": "^1.10.0"
   },
   "devDependencies": {
     "json": "^9.0.3",
diff --git a/test/basic.test.js b/test/basic.test.js
index d67f8d5..f6b92d5 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -21,31 +21,23 @@ var zk;
 var connCount = 0;
 
 mod_tape.test('connect failure: refused', function (t) {
-	var errs = 0;
-
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed') {
-			t.end();
-		}
+	zkc.on('connect', function (st) {
+		t.fail();
 	});
 
-	zkc.on('error', function (err) {
-		t.ok(err);
-		t.strictEqual(err.code, 'ECONNREFUSED');
-		++errs;
+	zkc.on('failed', function () {
+		zkc.close();
 	});
 
-	setTimeout(function () {
-		zkc.close();
-		t.ok(errs < 5);
-	}, 5000);
+	zkc.on('close', function () {
+		t.end();
+	});
 });
 
 mod_tape.test('start awful zk server', function (t) {
@@ -60,32 +52,23 @@ mod_tape.test('start awful zk server', function (t) {
 });
 
 mod_tape.test('connect failure: immediate close', function (t) {
-	var errs = 0;
-
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed') {
-			t.end();
-		}
+	zkc.on('close', function () {
+		t.end();
 	});
 
-	zkc.on('error', function (err) {
-		t.ok(err);
-		t.strictEqual(err.code, 'CONNECTION_LOSS');
-		++errs;
+	zkc.on('connect', function () {
+		t.fail();
 	});
 
-	setTimeout(function () {
+	zkc.on('failed', function () {
 		zkc.close();
-		t.ok(errs < 5);
-		t.strictEqual(errs, connCount);
-	}, 5000);
+	});
 });
 
 mod_tape.test('stop awful zk server', function (t) {
@@ -103,65 +86,58 @@ mod_tape.test('start zk server', function (t) {
 });
 
 mod_tape.test('simple connect and ping', function (t) {
+	var pinged = false;
+
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'connected') {
-			zkc.ping(function (err) {
-				t.error(err);
-				zkc.close();
-			});
-		} else if (st === 'closed') {
-			t.end();
-		}
+	zkc.on('close', function () {
+		t.ok(pinged);
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		zkc.ping(function (err) {
+			t.error(err);
+			pinged = true;
+			zkc.close();
+		});
 	});
 });
 
 mod_tape.test('simple connect and ping, with death', function (t) {
 	var stopped = false;
-	var errs = 0;
 	var t1, t2;
 
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181,
-		timeout: 5000
+		sessionTimeout: 5000
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'connected') {
-			zkc.ping(function (err) {
-				t1 = new Date();
-				t.error(err);
-				zk.stop();
-			});
-		} else if (st === 'closed') {
-			t2 = new Date();
-			var delta = t2.getTime() - t1.getTime();
-			t.ok(delta >= 5000);
-			t.ok(errs < 10);
-			t.end();
-		}
+	zkc.on('close', function () {
+		t.end();
 	});
 
-	zkc.on('error', function (err) {
-		t.ok(err);
+	zkc.on('expire', function () {
 		t.ok(stopped);
-		t.strictEqual(err.code, 'ECONNREFUSED');
-		++errs;
+		t2 = new Date();
+		var delta = t2.getTime() - t1.getTime();
+		t.ok(delta >= 5000);
+		zkc.close();
 	});
 
-	zk.on('stateChanged', function (st) {
-		if (st === 'stopped') {
+	zkc.on('connect', function () {
+		zkc.ping(function (err) {
+			t1 = new Date();
+			t.error(err);
 			stopped = true;
-		}
+			zk.stop();
+		});
 	});
 });
 
@@ -183,17 +159,15 @@ mod_tape.test('set up test object', function (t) {
 mod_tape.test('find the test object', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var req = zkc.list('/');
 		req.once('reply', function (pkt) {
 			t.strictEqual(pkt.opcode, 'GET_CHILDREN2');
@@ -220,16 +194,15 @@ mod_tape.test('find the test object', function (t) {
 mod_tape.test('delete the test object', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
 		zkc.delete('/foo', 0, function (err) {
 			t.error(err);
 			zkc.close();
@@ -240,17 +213,15 @@ mod_tape.test('delete the test object', function (t) {
 mod_tape.test('ask for a non-existent node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var req = zkc.stat('/foo');
 		req.once('reply', function (pkt) {
 			t.fail('Expected an error');
@@ -267,17 +238,15 @@ mod_tape.test('ask for a non-existent node', function (t) {
 mod_tape.test('create a new node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var d = new Buffer('hi there', 'ascii');
 		zkc.create('/foo', d, {}, function (err, path) {
 			t.error(err);
@@ -294,17 +263,15 @@ mod_tape.test('create a new node', function (t) {
 mod_tape.test('create a large node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var d = new Buffer(9000);
 		d.fill(5);
 		zkc.create('/bignode', d, {}, function (err, path) {
@@ -327,49 +294,47 @@ mod_tape.test('create a large node', function (t) {
 mod_tape.test('data watcher', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
+
+	zkc.on('close', function () {
+		t.end();
+	});
 
 	var data = new Buffer('hi there', 'ascii');
 	var count = 0;
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('connect', function () {
 		zkc.watcher('/foo').on('dataChanged', function (newData) {
 			t.ok(Buffer.isBuffer(newData));
 			t.strictEqual(newData.toString('base64'),
 			    data.toString('base64'));
 			if (++count === 1) {
 				data = new Buffer('hi', 'ascii');
+				console.log('doing set');
+				zk.cli('set', '/foo', 'hi', function (err) {
+					t.error(err);
+					t.strictEqual(count, 2);
+					zkc.close();
+				});
 			}
 		});
-		zk.cli('set', '/foo', 'hi', function (err) {
-			t.error(err);
-			t.strictEqual(count, 2);
-			zkc.close();
-		});
 	});
 });
 
 mod_tape.test('delete it while watching', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		zkc.watcher('/foo').on('deleted', function () {
 			zkc.close();
 		});
@@ -392,17 +357,15 @@ mod_tape.test('set up test object', function (t) {
 mod_tape.test('delete it while watching data', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var dwFired = 0;
 		var w = zkc.watcher('/foobar');
 		w.on('dataChanged', function (data, stat) {
@@ -431,17 +394,15 @@ mod_tape.test('set up test object', function (t) {
 mod_tape.test('children watcher', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var sawFoobar, sawFoo, sawNone;
 		var w = zkc.watcher('/');
 		w.on('childrenChanged', function (kids, stat) {
@@ -478,17 +439,15 @@ mod_tape.test('children watcher', function (t) {
 mod_tape.test('children watcher no node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'closed')
-			t.end();
-		if (st !== 'connected')
-			return;
+	zkc.on('close', function () {
+		t.end();
+	});
 
+	zkc.on('connect', function () {
 		var noKids, allKids;
 		var w = zkc.watcher('/parent');
 		w.on('childrenChanged', function (kids, stat) {
@@ -533,40 +492,33 @@ mod_tape.test('session resumption with watcher', function (t) {
 
 	var zkc1 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc1.connect();
 
 	var zkc2 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: 2181
 	});
-	zkc2.connect();
 
-	zkc1.on('error', function (err) {
-		t.ok(err);
-		t.ok(err.message === 'I killed it');
+	zkc1.on('close', function () {
+		if (++closed >= 2)
+			t.end();
 	});
 
-	zkc1.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
+	zkc2.on('close', function () {
+		if (++closed >= 2)
 			t.end();
-		if (st !== 'connected')
-			return;
+	});
 
+	zkc1.on('connect', function () {
 		if (++connected == 2) {
 			create();
 		}
 	});
 
-	zkc2.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
-			t.end();
-		if (st !== 'connected')
-			return;
-
+	zkc2.on('connect', function () {
 		if (++connected == 2) {
 			create();
 		}
@@ -602,7 +554,7 @@ mod_tape.test('session resumption with watcher', function (t) {
 		zkc2.stat('/foo', function (err, stat) {
 			t.error(err);
 
-			var sock = zkc1.zs_socket;
+			var sock = zkc1.getSession().getConnection().zcf_socket;
 			t.ok(sock.listeners('error').length > 0);
 			sock.emit('error', new Error('I killed it'));
 			sock.destroy();
diff --git a/test/multi-node.test.js b/test/multi-node.test.js
index 3473529..0b6db5b 100644
--- a/test/multi-node.test.js
+++ b/test/multi-node.test.js
@@ -68,40 +68,38 @@ mod_tape.test('start zk servers', function (t) {
 mod_tape.test('simple connect and ping #1', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['1'].clientPort
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'connected') {
-			zkc.ping(function (err) {
-				t.error(err);
-				zkc.close();
-			});
-		} else if (st === 'closed') {
-			t.end();
-		}
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		zkc.ping(function (err) {
+			t.error(err);
+			zkc.close();
+		});
 	});
 });
 
 mod_tape.test('simple connect and ping #3', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['3'].clientPort
 	});
-	zkc.connect();
 
-	zkc.on('stateChanged', function (st) {
-		if (st === 'connected') {
-			zkc.ping(function (err) {
-				t.error(err);
-				zkc.close();
-			});
-		} else if (st === 'closed') {
-			t.end();
-		}
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		zkc.ping(function (err) {
+			t.error(err);
+			zkc.close();
+		});
 	});
 });
 
@@ -110,34 +108,32 @@ mod_tape.test('write visibility', function (t) {
 
 	var zkc1 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['1'].clientPort
 	});
-	zkc1.connect();
 	var zkc2 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['2'].clientPort
 	});
-	zkc2.connect();
 
-	zkc1.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
+	zkc1.on('close', function () {
+		if (++closed >= 2)
 			t.end();
-		if (st !== 'connected')
-			return;
+	});
 
+	zkc2.on('close', function () {
+		if (++closed >= 2)
+			t.end();
+	});
+
+	zkc1.on('connect', function () {
 		if (++connected == 2) {
 			create();
 		}
 	});
 
-	zkc2.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
-			t.end();
-		if (st !== 'connected')
-			return;
-
+	zkc2.on('connect', function () {
 		if (++connected == 2) {
 			create();
 		}
@@ -169,34 +165,32 @@ mod_tape.test('cross-server data watch', function (t) {
 
 	var zkc1 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['1'].clientPort
 	});
-	zkc1.connect();
 	var zkc2 = new mod_zkc.Client({
 		log: log,
-		host: 'localhost',
+		address: '127.0.0.1',
 		port: zks['2'].clientPort
 	});
-	zkc2.connect();
 
-	zkc1.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
+	zkc1.on('close', function () {
+		if (++closed >= 2)
 			t.end();
-		if (st !== 'connected')
-			return;
+	});
+
+	zkc2.on('close', function () {
+		if (++closed >= 2)
+			t.end();
+	});
 
+	zkc1.on('connect', function () {
 		if (++connected == 2) {
 			setup();
 		}
 	});
 
-	zkc2.on('stateChanged', function (st) {
-		if (st === 'closed' && ++closed >= 2)
-			t.end();
-		if (st !== 'connected')
-			return;
-
+	zkc2.on('connect', function () {
 		if (++connected == 2) {
 			setup();
 		}
-- 
2.21.0

