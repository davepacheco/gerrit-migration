From bf45b3d69a17991985ba0a07da101c8f6a54d818 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Sat, 7 Oct 2017 04:53:11 +0000
Subject: [PATCH] libperiodic

---
 .gitignore                                    |   4 +
 manifest                                      |   2 +
 usr/src/lib/Makefile                          |   3 +
 usr/src/lib/libperiodic/Makefile              |  42 ++
 usr/src/lib/libperiodic/Makefile.com          |  33 ++
 usr/src/lib/libperiodic/amd64/Makefile        |  19 +
 usr/src/lib/libperiodic/common/libperiodic.c  | 391 ++++++++++++++++++
 usr/src/lib/libperiodic/common/libperiodic.h  |  53 +++
 usr/src/lib/libperiodic/common/llib-lperiodic |  19 +
 usr/src/lib/libperiodic/common/mapfile-vers   |  42 ++
 usr/src/lib/libperiodic/i386/Makefile         |  18 +
 usr/src/lib/libperiodic/sparc/Makefile        |  18 +
 usr/src/lib/libperiodic/sparcv9/Makefile      |  19 +
 usr/src/test/os-tests/runfiles/default.run    |  10 +
 usr/src/test/os-tests/tests/Makefile          |   2 +-
 usr/src/test/os-tests/tests/periodic/Makefile |  67 +++
 .../test/os-tests/tests/periodic/absolute.c   | 101 +++++
 .../test/os-tests/tests/periodic/badargs.c    | 156 +++++++
 usr/src/test/os-tests/tests/periodic/cancel.c | 101 +++++
 .../test/os-tests/tests/periodic/interleave.c | 142 +++++++
 .../test/os-tests/tests/periodic/interval.c   | 125 ++++++
 .../test/os-tests/tests/periodic/oneshot.c    |  96 +++++
 .../test/os-tests/tests/periodic/periodic.c   | 117 ++++++
 .../test/os-tests/tests/periodic/reschedule.c | 184 +++++++++
 usr/src/test/os-tests/tests/periodic/stress.c | 199 +++++++++
 25 files changed, 1962 insertions(+), 1 deletion(-)
 create mode 100644 usr/src/lib/libperiodic/Makefile
 create mode 100644 usr/src/lib/libperiodic/Makefile.com
 create mode 100644 usr/src/lib/libperiodic/amd64/Makefile
 create mode 100644 usr/src/lib/libperiodic/common/libperiodic.c
 create mode 100644 usr/src/lib/libperiodic/common/libperiodic.h
 create mode 100644 usr/src/lib/libperiodic/common/llib-lperiodic
 create mode 100644 usr/src/lib/libperiodic/common/mapfile-vers
 create mode 100644 usr/src/lib/libperiodic/i386/Makefile
 create mode 100644 usr/src/lib/libperiodic/sparc/Makefile
 create mode 100644 usr/src/lib/libperiodic/sparcv9/Makefile
 create mode 100644 usr/src/test/os-tests/tests/periodic/Makefile
 create mode 100644 usr/src/test/os-tests/tests/periodic/absolute.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/badargs.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/cancel.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/interleave.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/interval.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/oneshot.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/periodic.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/reschedule.c
 create mode 100644 usr/src/test/os-tests/tests/periodic/stress.c

diff --git a/.gitignore b/.gitignore
index db479b360e..f7c5ede334 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3866,6 +3866,10 @@ usr/src/lib/libpctx/amd64/lint.out
 usr/src/lib/libpctx/amd64/llib-lpctx.ln
 usr/src/lib/libpctx/i386/lint.out
 usr/src/lib/libpctx/i386/llib-lpctx.ln
+usr/src/lib/libperiodic/amd64/llib-lperiodic.ln
+usr/src/lib/libperiodic/amd64/lint.out
+usr/src/lib/libperiodic/i386/llib-lperiodic.ln
+usr/src/lib/libperiodic/i386/lint.out
 usr/src/lib/libpicl/amd64/lint.out
 usr/src/lib/libpicl/amd64/llib-lpicl.ln
 usr/src/lib/libpicl/i386/lint.out
diff --git a/manifest b/manifest
index e985ab93fd..61cfc1c4a0 100644
--- a/manifest
+++ b/manifest
@@ -4911,6 +4911,7 @@ s usr/lib/amd64/libpanel.so=libpanel.so.1
 f usr/lib/amd64/libpcidb.so.1 0755 root bin
 f usr/lib/amd64/libpctx.so.1 0755 root bin
 s usr/lib/amd64/libpctx.so=libpctx.so.1
+f usr/lib/amd64/libperiodic.so.1 0755 root bin
 f usr/lib/amd64/libpicl.so.1 0755 root bin
 s usr/lib/amd64/libpicl.so=libpicl.so.1
 f usr/lib/amd64/libpkcs11.so.1 0755 root bin
@@ -6341,6 +6342,7 @@ s usr/lib/libpanel.so=libpanel.so.1
 f usr/lib/libpcidb.so.1 0755 root bin
 f usr/lib/libpctx.so.1 0755 root bin
 s usr/lib/libpctx.so=libpctx.so.1
+f usr/lib/libperiodic.so.1 0755 root bin
 f usr/lib/libpicl.so.1 0755 root bin
 s usr/lib/libpicl.so=libpicl.so.1
 f usr/lib/libpicld_pluginutil.so.1 0755 root bin
diff --git a/usr/src/lib/Makefile b/usr/src/lib/Makefile
index 7f82981d8c..ae4ba599f7 100644
--- a/usr/src/lib/Makefile
+++ b/usr/src/lib/Makefile
@@ -176,6 +176,7 @@ SUBDIRS +=				\
 	libpam		\
 	libpcidb	\
 	libpctx		\
+	libperiodic	\
 	libpicl		\
 	libpicltree	\
 	libpkg		\
@@ -444,6 +445,7 @@ HDRSUBDIRS=				\
 	libpam		\
 	libpcidb	\
 	libpctx		\
+	libperiodic	\
 	libpicl		\
 	libpicltree	\
 	libpool		\
@@ -650,6 +652,7 @@ libnisdb:	libldap5
 libnwam:	libscf libbsm libdladm libipadm
 libpcp:		libumem libdevinfo
 libpctx:	libproc
+libperiodic:	libumem libavl librefhash libidspace
 libpkg:		libwanboot libscf libadm
 libpool:	libscf libexacct
 libpp:		libast
diff --git a/usr/src/lib/libperiodic/Makefile b/usr/src/lib/libperiodic/Makefile
new file mode 100644
index 0000000000..8ad5bb9e92
--- /dev/null
+++ b/usr/src/lib/libperiodic/Makefile
@@ -0,0 +1,42 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include		../Makefile.lib
+
+HDRS =		libperiodic.h
+HDRDIR =	common
+SUBDIRS =	$(MACH)
+$(BUILD64)SUBDIRS +=	$(MACH64)
+
+all :=		TARGET = all
+clean :=	TARGET = clean
+clobber :=	TARGET = clobber
+install :=	TARGET = install
+lint :=		TARGET = lint
+
+.KEEP_STATE:
+
+all clean clobber install lint: $(SUBDIRS)
+
+install_h: 	$(ROOTHDRS)
+
+check:		$(CHECKHDRS)
+
+$(SUBDIRS):  FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
+
+include ../Makefile.targ
diff --git a/usr/src/lib/libperiodic/Makefile.com b/usr/src/lib/libperiodic/Makefile.com
new file mode 100644
index 0000000000..da288ea197
--- /dev/null
+++ b/usr/src/lib/libperiodic/Makefile.com
@@ -0,0 +1,33 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+LIBRARY =	libperiodic.a
+VERS =		.1
+OBJECTS =	libperiodic.o
+
+include ../../Makefile.lib
+
+LIBS =		$(DYNLIB) $(LINTLIB)
+LDLIBS +=	-lc -lumem -lavl -lrefhash -lidspace
+
+SRCDIR =	../common
+
+.KEEP_STATE:
+
+all: $(LIBS)
+
+lint: lintcheck
+
+include ../../Makefile.targ
diff --git a/usr/src/lib/libperiodic/amd64/Makefile b/usr/src/lib/libperiodic/amd64/Makefile
new file mode 100644
index 0000000000..4bf70f21c8
--- /dev/null
+++ b/usr/src/lib/libperiodic/amd64/Makefile
@@ -0,0 +1,19 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include ../Makefile.com
+include ../../Makefile.lib.64
+
+install: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64)
diff --git a/usr/src/lib/libperiodic/common/libperiodic.c b/usr/src/lib/libperiodic/common/libperiodic.c
new file mode 100644
index 0000000000..f9a83b5c31
--- /dev/null
+++ b/usr/src/lib/libperiodic/common/libperiodic.c
@@ -0,0 +1,391 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Provide a library which allows for one shot and periodic callbacks to be
+ * made in a manner not disimilar to timeout(9F). Importantly this library does
+ * not maintain its own event loop and instead designed to be used in event
+ * based systems.
+ */
+
+#include <errno.h>
+#include <libidspace.h>
+#include <limits.h>
+#include <port.h>
+#include <signal.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <strings.h>
+#include <synch.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <time.h>
+#include <umem.h>
+#include <libidspace.h>
+#include <sys/refhash.h>
+
+#include <libperiodic.h>
+
+typedef enum periodic_flags {
+	PERIODIC_F_ONESHOT	= 0x01,
+	PERIODIC_F_DELIVERING	= 0x02,
+	PERIODIC_F_DESTROY	= 0x04
+} periodic_flags_t;
+
+typedef struct periodic {
+	periodic_func_t		*peri_func;
+	void			*peri_arg;
+	periodic_handle_t	*peri_handle;
+	id_t			peri_id;
+	hrtime_t		peri_value;
+	hrtime_t		peri_expire;
+	periodic_flags_t	peri_flags;
+	avl_node_t		peri_link;
+	refhash_link_t		peri_reflink;
+} periodic_t;
+
+struct periodic_handle {
+	mutex_t		ph_lock;
+	cond_t		ph_cond;
+	avl_tree_t	ph_tree;
+	timer_t		ph_timer;
+	boolean_t	ph_processing;
+	id_space_t	*ph_idspace;
+	refhash_t	*ph_refhash;
+};
+
+/*
+ * This is an arbitrary prime number we pulled out of thin air, sorry.
+ */
+#define	PERIODIC_NBUCKETS	73
+
+static void
+periodic_hash_dtor(void *buf)
+{
+	periodic_t *p = buf;
+	periodic_handle_t *perh = p->peri_handle;
+
+	VERIFY3S(p->peri_id, !=, -1);
+	id_free(perh->ph_idspace, p->peri_id);
+	umem_free(p, sizeof (periodic_t));
+}
+
+static int
+periodic_hash_comparator(const void *l, const void *r)
+{
+	const id_t lid = *(id_t *)l;
+	const id_t rid = *(id_t *)r;
+
+	if (lid > rid)
+		return (1);
+	if (rid < lid)
+		return (-1);
+	return (0);
+}
+
+static uint64_t
+periodic_hash(const void *v)
+{
+	const id_t *id = v;
+
+	return (*id);
+}
+
+static int
+periodic_comparator(const void *l, const void *r)
+{
+	const periodic_t *pl = l, *pr = r;
+
+	if (pl->peri_expire > pr->peri_expire)
+		return (1);
+	else if (pl->peri_expire < pr->peri_expire)
+		return (-1);
+
+	/*
+	 * Multiple timers can have the same delivery time, so sort within that
+	 * by the address of the timer itself.
+	 */
+	if ((uintptr_t)l > (uintptr_t)r)
+		return (1);
+	else if ((uintptr_t)l < (uintptr_t)r)
+		return (-1);
+
+	return (0);
+}
+
+periodic_handle_t *
+periodic_init(int port, void *arg, clockid_t clocktype)
+{
+	int ret;
+	periodic_handle_t *perh;
+	port_notify_t pn;
+	struct sigevent evp;
+	char buf[32];
+
+	perh = umem_alloc(sizeof (periodic_handle_t), UMEM_DEFAULT);
+	if (perh == NULL)
+		return (NULL);
+
+	if ((ret = mutex_init(&perh->ph_lock, USYNC_THREAD | LOCK_ERRORCHECK,
+	    NULL)) != 0) {
+		umem_free(perh, sizeof (periodic_handle_t));
+		errno = ret;
+		return (NULL);
+	}
+
+	if ((ret = cond_init(&perh->ph_cond, USYNC_THREAD, NULL)) != 0) {
+		VERIFY0(mutex_destroy(&perh->ph_lock));
+		umem_free(perh, sizeof (periodic_handle_t));
+		errno = ret;
+		return (NULL);
+	}
+
+	(void) snprintf(buf, sizeof (buf), "periodic_%p", perh);
+	if ((perh->ph_idspace = id_space_create(buf, 1, INT32_MAX)) == NULL) {
+		ret = errno;
+		VERIFY0(cond_destroy(&perh->ph_cond));
+		VERIFY0(mutex_destroy(&perh->ph_lock));
+		umem_free(perh, sizeof (periodic_handle_t));
+		errno = ret;
+		return (NULL);
+	}
+
+	if ((perh->ph_refhash = refhash_create(PERIODIC_NBUCKETS, periodic_hash,
+	    periodic_hash_comparator, periodic_hash_dtor, sizeof (periodic_t),
+	    offsetof(periodic_t, peri_reflink), offsetof(periodic_t, peri_id),
+	    UMEM_DEFAULT)) == NULL) {
+		ret = errno;
+		id_space_destroy(perh->ph_idspace);
+		VERIFY0(cond_destroy(&perh->ph_cond));
+		VERIFY0(mutex_destroy(&perh->ph_lock));
+		umem_free(perh, sizeof (periodic_handle_t));
+		errno = ret;
+		return (NULL);
+
+	}
+
+	avl_create(&perh->ph_tree, periodic_comparator, sizeof (periodic_t),
+	    offsetof(periodic_t, peri_link));
+
+	pn.portnfy_port = port;
+	pn.portnfy_user = arg;
+	evp.sigev_notify = SIGEV_PORT;
+	evp.sigev_value.sival_ptr = &pn;
+
+	if (timer_create(clocktype, &evp, &perh->ph_timer) != 0) {
+		ret = errno;
+		refhash_destroy(perh->ph_refhash);
+		id_space_destroy(perh->ph_idspace);
+		VERIFY0(cond_destroy(&perh->ph_cond));
+		VERIFY0(mutex_destroy(&perh->ph_lock));
+		umem_free(perh, sizeof (periodic_handle_t));
+		errno = ret;
+		return (NULL);
+	}
+
+	perh->ph_processing = B_FALSE;
+
+	return (perh);
+}
+
+void
+periodic_fini(periodic_handle_t *perh)
+{
+	mutex_enter(&perh->ph_lock);
+	VERIFY3S(perh->ph_processing, ==, B_FALSE);
+	VERIFY3S(avl_is_empty(&perh->ph_tree), ==, B_TRUE);
+	mutex_exit(&perh->ph_lock);
+	VERIFY0(timer_delete(perh->ph_timer));
+	perh->ph_timer = -1;
+	avl_destroy(&perh->ph_tree);
+	refhash_destroy(perh->ph_refhash);
+	id_space_destroy(perh->ph_idspace);
+	VERIFY0(cond_destroy(&perh->ph_cond));
+	VERIFY0(mutex_destroy(&perh->ph_lock));
+	umem_free(perh, sizeof (periodic_handle_t));
+}
+
+static void
+periodic_rearm(periodic_handle_t *perh)
+{
+	struct itimerspec it;
+	periodic_t *p;
+
+	VERIFY(MUTEX_HELD(&perh->ph_lock));
+	bzero(&it, sizeof (struct itimerspec));
+	p = avl_first(&perh->ph_tree);
+	if (p != NULL) {
+		it.it_value.tv_sec = p->peri_expire / NANOSEC;
+		it.it_value.tv_nsec = p->peri_expire % NANOSEC;
+	}
+
+	VERIFY0(timer_settime(perh->ph_timer, TIMER_ABSTIME, &it, NULL));
+}
+
+void
+periodic_fire(periodic_handle_t *perh)
+{
+	hrtime_t now;
+	mutex_enter(&perh->ph_lock);
+	now = gethrtime();
+	VERIFY3S(perh->ph_processing, ==, B_FALSE);
+	perh->ph_processing = B_TRUE;
+
+	for (;;) {
+		periodic_t *p;
+
+		p = avl_first(&perh->ph_tree);
+		if (p == NULL || p->peri_expire > now)
+			break;
+
+		avl_remove(&perh->ph_tree, p);
+
+		/*
+		 * Drop the lock to allow for callbacks into the system while
+		 * delivering an event.
+		 */
+		p->peri_flags |= PERIODIC_F_DELIVERING;
+		mutex_exit(&perh->ph_lock);
+
+		p->peri_func(p->peri_arg);
+
+		mutex_enter(&perh->ph_lock);
+		p->peri_flags &= ~PERIODIC_F_DELIVERING;
+
+		/*
+		 * If we have a one shot timer, then it's our responsibility to
+		 * clean it up. Otherwise, if we've been marked that it's being
+		 * destroyed, due to a call to cancel, then don't touch it again
+		 * and signal anyone who might be waiting. Otherwise, we must
+		 * have a periodic so, go ahead and reschedule it effectively.
+		 */
+		if ((p->peri_flags & PERIODIC_F_ONESHOT) &&
+		    !(p->peri_flags & PERIODIC_F_DESTROY)) {
+			VERIFY3S(p->peri_id, !=, -1);
+			refhash_remove(perh->ph_refhash, p);
+		} else if ((p->peri_flags & PERIODIC_F_DESTROY) == 0) {
+			VERIFY3S((p->peri_flags & PERIODIC_F_ONESHOT), ==, 0);
+			VERIFY(LLONG_MAX - p->peri_expire > p->peri_value);
+			p->peri_expire += p->peri_value;
+			avl_add(&perh->ph_tree, p);
+		} else {
+			(void) cond_broadcast(&perh->ph_cond);
+		}
+	}
+
+	periodic_rearm(perh);
+	perh->ph_processing = B_FALSE;
+	mutex_exit(&perh->ph_lock);
+}
+
+int
+periodic_schedule(periodic_handle_t *perh, hrtime_t time, int flags,
+    periodic_func_t *func, void *farg, periodic_id_t *idp)
+{
+	periodic_t *p;
+
+	if (flags != 0 &&
+	    (flags & ~(PERIODIC_ONESHOT | PERIODIC_ABSOLUTE)) != 0) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if ((flags & PERIODIC_ABSOLUTE) && !(flags & PERIODIC_ONESHOT)) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if (func == NULL) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if (time < 0) {
+		errno = ERANGE;
+		return (-1);
+	}
+
+	p = umem_zalloc(sizeof (periodic_t), UMEM_DEFAULT);
+	if (p == NULL) {
+		errno = ENOMEM;
+		return (-1);
+	}
+
+	p->peri_func = func;
+	p->peri_arg = farg;
+	if (flags & PERIODIC_ONESHOT)
+		p->peri_flags |= PERIODIC_F_ONESHOT;
+
+	p->peri_handle = perh;
+	p->peri_value = time;
+	if (flags & PERIODIC_ABSOLUTE) {
+		p->peri_expire = time;
+	} else {
+		p->peri_expire = gethrtime();
+		if (LLONG_MAX - p->peri_value < p->peri_value) {
+			umem_free(p, sizeof (periodic_t));
+			errno = EOVERFLOW;
+			return (-1);
+		}
+		p->peri_expire += p->peri_value;
+	}
+
+	mutex_enter(&perh->ph_lock);
+	p->peri_id = id_alloc(perh->ph_idspace);
+	if (p->peri_id == -1) {
+		mutex_exit(&perh->ph_lock);
+		umem_free(p, sizeof (periodic_t));
+		errno = ENOMEM;
+		return (-1);
+	}
+
+	refhash_insert(perh->ph_refhash, p);
+	avl_add(&perh->ph_tree, p);
+	if (perh->ph_processing == B_FALSE)
+		periodic_rearm(perh);
+	*idp = p->peri_id;
+	mutex_exit(&perh->ph_lock);
+
+	return (0);
+}
+
+int
+periodic_cancel(periodic_handle_t *perh, periodic_id_t id)
+{
+	periodic_t *p;
+
+	mutex_enter(&perh->ph_lock);
+	if ((p = refhash_lookup(perh->ph_refhash, &id)) == NULL) {
+		mutex_exit(&perh->ph_lock);
+		errno = ENOENT;
+		return (-1);
+	}
+
+	p->peri_flags |= PERIODIC_F_DESTROY;
+	if (p->peri_flags & PERIODIC_F_DELIVERING) {
+		while (p->peri_flags & PERIODIC_F_DELIVERING)
+			(void) cond_wait(&perh->ph_cond, &perh->ph_lock);
+	} else {
+		avl_remove(&perh->ph_tree, p);
+	}
+
+	refhash_remove(perh->ph_refhash, p);
+
+	if (perh->ph_processing == B_FALSE)
+		periodic_rearm(perh);
+	mutex_exit(&perh->ph_lock);
+
+	return (0);
+}
diff --git a/usr/src/lib/libperiodic/common/libperiodic.h b/usr/src/lib/libperiodic/common/libperiodic.h
new file mode 100644
index 0000000000..9cf264098b
--- /dev/null
+++ b/usr/src/lib/libperiodic/common/libperiodic.h
@@ -0,0 +1,53 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+#ifndef _LIBPERIODIC_H
+#define	_LIBPERIODIC_H
+
+/*
+ * This library provides timer infrastructure designed to be a part of an event
+ * loop based arond event ports. It manages timer expirations and can be used to
+ * maintain a large tree of such events.
+ */
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef id_t periodic_id_t;
+typedef struct periodic_handle periodic_handle_t;
+typedef void (periodic_func_t)(void *);
+
+#define	PERIODIC_INVALID_ID	-1
+
+extern periodic_handle_t *periodic_init(int, void *, clockid_t);
+extern void periodic_fire(periodic_handle_t *);
+extern void periodic_fini(periodic_handle_t *);
+
+#define	PERIODIC_ONESHOT	0x01
+#define	PERIODIC_ABSOLUTE	0x02
+extern int periodic_schedule(periodic_handle_t *, hrtime_t, int,
+    periodic_func_t *, void *, periodic_id_t *);
+extern int periodic_cancel(periodic_handle_t *, periodic_id_t);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LIBPERIODIC_H */
diff --git a/usr/src/lib/libperiodic/common/llib-lperiodic b/usr/src/lib/libperiodic/common/llib-lperiodic
new file mode 100644
index 0000000000..19bb7536c8
--- /dev/null
+++ b/usr/src/lib/libperiodic/common/llib-lperiodic
@@ -0,0 +1,19 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/* LINTLIBRARY */
+/* PROTOLIB1 */
+
+#include <libperiodic.h>
diff --git a/usr/src/lib/libperiodic/common/mapfile-vers b/usr/src/lib/libperiodic/common/mapfile-vers
new file mode 100644
index 0000000000..5dd6c64c8c
--- /dev/null
+++ b/usr/src/lib/libperiodic/common/mapfile-vers
@@ -0,0 +1,42 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 <contributor>
+#
+
+#
+# MAPFILE HEADER START
+#
+# WARNING:  STOP NOW.  DO NOT MODIFY THIS FILE.
+# Object versioning must comply with the rules detailed in
+#
+#	usr/src/lib/README.mapfiles
+#
+# You should not be making modifications here until you've read the most current
+# copy of that file. If you need help, contact a gatekeeper for guidance.
+#
+# MAPFILE HEADER END
+#
+
+$mapfile_version 2
+
+
+SYMBOL_VERSION ILLUMOSprivate {
+    global:
+	periodic_cancel;
+	periodic_fini;
+	periodic_fire;
+	periodic_init;
+	periodic_schedule;
+    local:
+	*;
+};
diff --git a/usr/src/lib/libperiodic/i386/Makefile b/usr/src/lib/libperiodic/i386/Makefile
new file mode 100644
index 0000000000..f2b4f63da5
--- /dev/null
+++ b/usr/src/lib/libperiodic/i386/Makefile
@@ -0,0 +1,18 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include ../Makefile.com
+
+install: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/libperiodic/sparc/Makefile b/usr/src/lib/libperiodic/sparc/Makefile
new file mode 100644
index 0000000000..f2b4f63da5
--- /dev/null
+++ b/usr/src/lib/libperiodic/sparc/Makefile
@@ -0,0 +1,18 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include ../Makefile.com
+
+install: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/libperiodic/sparcv9/Makefile b/usr/src/lib/libperiodic/sparcv9/Makefile
new file mode 100644
index 0000000000..4bf70f21c8
--- /dev/null
+++ b/usr/src/lib/libperiodic/sparcv9/Makefile
@@ -0,0 +1,19 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include ../Makefile.com
+include ../../Makefile.lib.64
+
+install: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64)
diff --git a/usr/src/test/os-tests/runfiles/default.run b/usr/src/test/os-tests/runfiles/default.run
index c52364877e..8128b96ce0 100644
--- a/usr/src/test/os-tests/runfiles/default.run
+++ b/usr/src/test/os-tests/runfiles/default.run
@@ -73,3 +73,13 @@ tests = ['acquire-compare', 'acquire-spray']
 
 [/opt/os-tests/tests/OS-6097.32]
 [/opt/os-tests/tests/OS-6097.64]
+
+[/opt/os-tests/tests/periodic/absolute]
+[/opt/os-tests/tests/periodic/badargs]
+[/opt/os-tests/tests/periodic/cancel]
+[/opt/os-tests/tests/periodic/interleave]
+[/opt/os-tests/tests/periodic/interval]
+[/opt/os-tests/tests/periodic/oneshot]
+[/opt/os-tests/tests/periodic/periodic]
+[/opt/os-tests/tests/periodic/reschedule]
+[/opt/os-tests/tests/periodic/stress]
diff --git a/usr/src/test/os-tests/tests/Makefile b/usr/src/test/os-tests/tests/Makefile
index 9424fa157e..a1b7ef9e9a 100644
--- a/usr/src/test/os-tests/tests/Makefile
+++ b/usr/src/test/os-tests/tests/Makefile
@@ -15,7 +15,7 @@
 #
 
 SUBDIRS = poll secflags sigqueue spoof-ras sdevfs sockfs stress timer tmpfs \
-	file-locking pf_key
+	file-locking pf_key periodic
 
 PROGS = \
 	OS-6097
diff --git a/usr/src/test/os-tests/tests/periodic/Makefile b/usr/src/test/os-tests/tests/periodic/Makefile
new file mode 100644
index 0000000000..54b8a38673
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/Makefile
@@ -0,0 +1,67 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2015 Joyent, Inc.
+#
+
+include $(SRC)/Makefile.master
+
+ROOTOPTPKG = $(ROOT)/opt/os-tests
+TESTDIR = $(ROOTOPTPKG)/tests/periodic
+
+PROGS = 		\
+	absolute	\
+	badargs		\
+	cancel		\
+	interleave	\
+	interval	\
+	oneshot 	\
+	periodic	\
+	reschedule	\
+	stress
+
+include $(SRC)/cmd/Makefile.cmd
+include $(SRC)/test/Makefile.com
+
+CMDS = $(PROGS:%=$(TESTDIR)/%)
+$(CMDS) := FILEMODE = 0555
+
+CPPFLAGS += -D_REENTRANT
+LDLIBS += -lumem -lperiodic
+
+all: $(PROGS)
+
+install: all $(CMDS)
+
+lint: lint_SRCS
+
+clobber: clean
+	-$(RM) $(PROGS)
+
+clean:
+	-$(RM) *.o
+
+%.o: %.c
+	$(COMPILE.c) -o $@ -c $<
+	$(POST_PROCESS_O)
+
+$(PROG): $(OBJS)
+	$(LINK.c) $(OBJS) -o $@ $(LDLIBS)
+	$(POST_PROCESS)
+
+$(CMDS): $(TESTDIR) $(PROGS)
+
+$(TESTDIR):
+	$(INS.dir)
+
+$(TESTDIR)/%: %
+	$(INS.file)
diff --git a/usr/src/test/os-tests/tests/periodic/absolute.c b/usr/src/test/os-tests/tests/periodic/absolute.c
new file mode 100644
index 0000000000..fe43fd4edd
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/absolute.c
@@ -0,0 +1,101 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Create a simple one-shot timer based on absolute time and make sure that it
+ * fires.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include <libperiodic.h>
+
+static hrtime_t absolute_start;
+static hrtime_t absolute_target;
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+/* ARGSUSED */
+static void
+absolute_fire(void *arg)
+{
+	hrtime_t end = gethrtime();
+
+	if (absolute_target > end) {
+		fprintf(stderr, "timer fired, but before oneshot time: "
+		    "start: %lx, expected: %lx, callback: %lx\n",
+		    absolute_start, absolute_target, end);
+		exit(1);
+	}
+	exit(0);
+}
+
+int
+main(void)
+{
+	int port;
+	periodic_handle_t *ph;
+	periodic_id_t phid;
+	port_event_t pe;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	absolute_start = gethrtime();
+	absolute_target = absolute_start + MSEC2NSEC(10);
+	if (periodic_schedule(ph, absolute_target,
+	    PERIODIC_ONESHOT | PERIODIC_ABSOLUTE,
+	    absolute_fire, NULL, &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (port_get(port, &pe, NULL) != 0) {
+		fprintf(stderr, "failed to port_get: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	periodic_fire(ph);
+
+	/* The oneshot should fire there and we should exit */
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/badargs.c b/usr/src/test/os-tests/tests/periodic/badargs.c
new file mode 100644
index 0000000000..3852ae523a
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/badargs.c
@@ -0,0 +1,156 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Test various invalid scenarios.
+ */
+
+#include <errno.h>
+#include <port.h>
+#include <strings.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <limits.h>
+#include <priv.h>
+#include <sys/debug.h>
+#include <libperiodic.h>
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+
+/*ARGSUSED*/
+static void
+badarg_callback(void *arg)
+{
+	exit(1);
+}
+
+int
+main(void)
+{
+	int port, ret;
+	periodic_handle_t *ph;
+	periodic_id_t id;
+	priv_set_t *priv;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(-1, NULL, CLOCK_MONOTONIC);
+	VERIFY3P(ph, ==, NULL);
+	VERIFY3S(errno, ==, EBADF);
+
+	ph = periodic_init(port, NULL, -1);
+	VERIFY3P(ph, ==, NULL);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	/* Garbage cancel values */
+	ret = periodic_cancel(ph, -1);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, ENOENT);
+
+	ret = periodic_cancel(ph, 42);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, ENOENT);
+
+	ret = periodic_cancel(ph, INT32_MAX);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, ENOENT);
+
+	ret = periodic_cancel(ph, INT32_MIN);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, ENOENT);
+
+	/* Various garbage values for schedule */
+	ret = periodic_schedule(ph, -1, 0, badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, ERANGE);
+
+	ret = periodic_schedule(ph, MSEC2NSEC(10), 0, NULL, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ret = periodic_schedule(ph, MSEC2NSEC(10), ~PERIODIC_ONESHOT,
+	    badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ret = periodic_schedule(ph, MSEC2NSEC(10), PERIODIC_ABSOLUTE,
+	    badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ret = periodic_schedule(ph, LLONG_MAX - 1, PERIODIC_ONESHOT,
+	    badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EOVERFLOW);
+
+	ret = periodic_schedule(ph, LLONG_MAX - gethrtime() + 1,
+	    PERIODIC_ONESHOT, badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EOVERFLOW);
+
+	ret = periodic_schedule(ph, LLONG_MAX - 1, 0,
+	    badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EOVERFLOW);
+
+	ret = periodic_schedule(ph, LLONG_MAX - gethrtime() + 1, 0,
+	    badarg_callback, NULL, &id);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EOVERFLOW);
+
+	periodic_fini(ph);
+
+	/*
+	 * Verify we can't create a clock monotonic without CLOCK_HIGHRES. Just
+	 * switch ourselves to the basic set for now.
+	 */
+	priv = priv_allocset();
+	VERIFY3P(priv, !=, NULL);
+	priv_basicset(priv);
+	ret = setppriv(PRIV_SET, PRIV_PERMITTED, priv);
+	VERIFY3S(ret, ==, 0);
+	ret = setppriv(PRIV_SET, PRIV_EFFECTIVE, priv);
+	VERIFY3S(ret, ==, 0);
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	VERIFY3P(ph, ==, NULL);
+	VERIFY3S(errno, ==, EPERM);
+
+	exit(0);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/cancel.c b/usr/src/test/os-tests/tests/periodic/cancel.c
new file mode 100644
index 0000000000..1219162784
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/cancel.c
@@ -0,0 +1,101 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Verify that if we remove an entry before it fires that we never end up having
+ * something fire ourselves.
+ */
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/debug.h>
+
+#include <libperiodic.h>
+
+
+#define	CANCEL_PERIOD	MSEC2NSEC(100)
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+
+static void
+cancel_fire(void *arg)
+{
+	fprintf(stderr, "cancel_fire fired when it should never have\n");
+	exit(1);
+}
+
+int
+main(void)
+{
+	int port, ret;
+	periodic_handle_t *ph;
+	periodic_id_t phid;
+	port_event_t pe;
+	struct timespec ts;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (periodic_schedule(ph, CANCEL_PERIOD, 0, cancel_fire, NULL,
+	    &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+	ret = periodic_cancel(ph, phid);
+	VERIFY3S(ret, ==, 0);
+
+	/*
+	 * Depending on everything that happens, we may not be fast enough to
+	 * cancel the timer. However, there should be nothing which runs or
+	 * fires and taking another loop should verify that we get a timeout.
+	 */
+	for (;;) {
+		ts.tv_sec = 0;
+		ts.tv_nsec = CANCEL_PERIOD * 5;
+		if (port_get(port, &pe, &ts) == 0) {
+			periodic_fire(ph);
+			continue;
+		}
+		VERIFY3S(errno, ==, ETIME);
+		break;
+	}
+
+	exit(0);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/interleave.c b/usr/src/test/os-tests/tests/periodic/interleave.c
new file mode 100644
index 0000000000..4598b4630b
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/interleave.c
@@ -0,0 +1,142 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Create a periodic and a one shot. Have the one shot be a multiple of the
+ * periodic and verify that the periodic will fire a few times before the
+ * one shot and then that the one shot fires again afterwards. eg. we want an
+ * A | A | B | A  pattern.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <sys/debug.h>
+
+#include <libperiodic.h>
+
+static mutex_t ileave_lock = ERRORCHECKMUTEX;
+static int ileave_pcount;
+static int ileave_ocount;
+
+#define	ILEAVE_PERIOD	MSEC2NSEC(45)
+#define	ILEAVE_ONESHOT	MSEC2NSEC(100)
+#define	TRY_MAX		100
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+
+/*
+ * Oneshot callback
+ */
+static void
+ileave_ofire(void *arg)
+{
+	mutex_enter(&ileave_lock);
+	VERIFY3S(ileave_pcount, >=, 2);
+	VERIFY3S(ileave_ocount, ==, 0);
+	ileave_ocount++;
+	mutex_exit(&ileave_lock);
+}
+
+/*
+ * Periodic callback
+ */
+static void
+ileave_pfire(void *arg)
+{
+	mutex_enter(&ileave_lock);
+	ileave_pcount++;
+	if (ileave_ocount > 0) {
+		VERIFY3S(ileave_pcount, >, 1);
+		exit(0);
+	}
+	mutex_exit(&ileave_lock);
+}
+
+int
+main(void)
+{
+	int port, loopcount;
+	periodic_handle_t *ph;
+	periodic_id_t phid, ohid;
+	port_event_t pe;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (periodic_schedule(ph, ILEAVE_PERIOD, 0, ileave_pfire, NULL,
+	    &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (periodic_schedule(ph, ILEAVE_ONESHOT, PERIODIC_ONESHOT,
+	    ileave_ofire, NULL, &ohid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	loopcount = 0;
+	for (;;) {
+		/*
+		 * The use of the loop counter here is a simple heuristic to try
+		 * to make sure that we don't end up infinitely looping and
+		 * broken.
+		 */
+		loopcount++;
+		if (loopcount > TRY_MAX)
+			break;
+
+		if (port_get(port, &pe, NULL) != 0) {
+			fprintf(stderr, "failed to port_get: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+
+		periodic_fire(ph);
+	}
+
+	/* The oneshot should fire there and we should exit */
+	fprintf(stderr, "interleaving did not occur");
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/interval.c b/usr/src/test/os-tests/tests/periodic/interval.c
new file mode 100644
index 0000000000..f548e45a84
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/interval.c
@@ -0,0 +1,125 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Test that we properly are honoring the interval. Meaning that even if we end
+ * up being slower the first time, that we end up catching up and firing it
+ * right away the next. We use slightly longer times to try and avoid scheduling
+ * pathologies.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/debug.h>
+
+#include <libperiodic.h>
+
+#define	IVAL_PERIOD	MSEC2NSEC(100)
+#define	IVAL_STALL	MSEC2NSEC(500)
+#define	TRY_MAX		50
+
+static int ival_count;
+static hrtime_t ival_time;
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+
+static void
+ival_fire(void *arg)
+{
+	hrtime_t now, diff;
+
+	if (ival_count == 0) {
+		struct timespec tv;
+		tv.tv_sec = 0;
+		tv.tv_nsec = IVAL_STALL;
+		(void) nanosleep(&tv, NULL);
+		ival_count++;
+		ival_time = gethrtime();
+		return;
+	}
+
+	now = gethrtime();
+	diff = now - ival_time;
+	VERIFY3S(diff, <, IVAL_PERIOD);
+	exit(0);
+}
+
+int
+main(void)
+{
+	int port, loopcount;
+	periodic_handle_t *ph;
+	periodic_id_t phid;
+	port_event_t pe;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (periodic_schedule(ph, IVAL_PERIOD, 0, ival_fire, NULL,
+	    &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	loopcount = 0;
+	for (;;) {
+		/*
+		 * The use of the loop counter here is a simple heuristic to try
+		 * to make sure that we don't end up infinitely looping and
+		 * broken.
+		 */
+		loopcount++;
+		if (loopcount > TRY_MAX)
+			break;
+
+		if (port_get(port, &pe, NULL) != 0) {
+			fprintf(stderr, "failed to port_get: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+
+		periodic_fire(ph);
+	}
+
+	/* The oneshot should fire there and we should exit */
+	fprintf(stderr, "interval logic did not properly fire");
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/oneshot.c b/usr/src/test/os-tests/tests/periodic/oneshot.c
new file mode 100644
index 0000000000..2f62ed78fe
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/oneshot.c
@@ -0,0 +1,96 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Create a simple one-shot timer and make sure that it fires.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include <libperiodic.h>
+
+static hrtime_t oneshot_start;
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+/* ARGSUSED */
+static void
+oneshot_fire(void *arg)
+{
+	hrtime_t end = gethrtime();
+
+	if (end - oneshot_start < MSEC2NSEC(10)) {
+		fprintf(stderr, "timer fired, but didn't elapse 10ms, "
+		    "start: %llx, end: %llx\n", oneshot_start, end);
+		exit(1);
+	}
+	exit(0);
+}
+
+int
+main(void)
+{
+	int port;
+	periodic_handle_t *ph;
+	periodic_id_t phid;
+	port_event_t pe;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	oneshot_start = gethrtime();
+	if (periodic_schedule(ph, MSEC2NSEC(10), PERIODIC_ONESHOT,
+	    oneshot_fire, NULL, &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (port_get(port, &pe, NULL) != 0) {
+		fprintf(stderr, "failed to port_get: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	periodic_fire(ph);
+
+	/* The oneshot should fire there and we should exit */
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/periodic.c b/usr/src/test/os-tests/tests/periodic/periodic.c
new file mode 100644
index 0000000000..f2d0ab41af
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/periodic.c
@@ -0,0 +1,117 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Create a simple periodic timer and make sure that it fires.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include <libperiodic.h>
+
+static hrtime_t period_start;
+static int period_count;
+
+#define	PERIOD_MAX	10
+#define	TRY_MAX		100
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+/* ARGSUSED */
+static void
+period_fire(void *arg)
+{
+	hrtime_t end = gethrtime();
+
+	period_count++;
+	if (end - period_start < MSEC2NSEC(10) * period_count) {
+		fprintf(stderr, "timer fired, but didn't elapse 10ms, "
+		    "start: %lx, end: %lx\n", period_start, end);
+		exit(1);
+	}
+	if (period_count == PERIOD_MAX)
+		exit(0);
+}
+
+int
+main(void)
+{
+	int port, loopcount;
+	periodic_handle_t *ph;
+	periodic_id_t phid;
+	port_event_t pe;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	period_start = gethrtime();
+	if (periodic_schedule(ph, MSEC2NSEC(10), 0, period_fire, NULL,
+	    &phid) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	loopcount = 0;
+	for (;;) {
+		/*
+		 * The use of the loop counter here is a simple heuristic to try
+		 * to make sure that we don't end up infinitely looping and
+		 * broken.
+		 */
+		loopcount++;
+		if (loopcount > TRY_MAX)
+			break;
+
+		if (port_get(port, &pe, NULL) != 0) {
+			fprintf(stderr, "failed to port_get: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+
+		periodic_fire(ph);
+
+
+	}
+
+	/* The oneshot should fire there and we should exit */
+	fprintf(stderr, "periodic timer did not fire sufficiently");
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/reschedule.c b/usr/src/test/os-tests/tests/periodic/reschedule.c
new file mode 100644
index 0000000000..1c5fb0235a
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/reschedule.c
@@ -0,0 +1,184 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Simulate a classic kernel subsystem doing a traditional settimeout() in a
+ * loop in one thread and another coming around and canceling it. We then wait
+ * enough time to verify that it hasn't fired again.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <sys/debug.h>
+
+#include <libperiodic.h>
+
+
+static mutex_t resched_lock = ERRORCHECKMUTEX;
+static cond_t resched_cond = DEFAULTCV;
+static periodic_id_t resched_id;
+static int resched_count;
+static boolean_t resched_cancel;
+static periodic_handle_t *resched_ph;
+
+#define	RESCHED_INTERVAL	MSEC2NSEC(10)
+#define	RESCHED_MAX	10
+#define	TRY_MAX		100
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+/* ARGSUSED */
+static void *
+resched_watchdog(void *arg)
+{
+	int ret, count;
+	struct timespec ts;
+
+	mutex_enter(&resched_lock);
+	while (resched_count < RESCHED_MAX)
+		(void) cond_wait(&resched_cond, &resched_lock);
+	resched_cancel = B_TRUE;
+	mutex_exit(&resched_lock);
+
+	ret = periodic_cancel(resched_ph, resched_id);
+	if (ret == -1) {
+		VERIFY3S(errno, ==, ENOENT);
+	}
+
+	/*
+	 * We want to verify that the periodic is now empty and no more events
+	 * will fire. There's no great way to do this. So let's just sleep for
+	 * 10 normal timer intervals and verify that we don't increase the
+	 * resched_count. Note, depending on timing, we may have gotten one more
+	 * tick in than we originally anticipated because it changed the
+	 * resched_id out from under us, but it will cancel. To allow for this,
+	 * count may also be resched_count - 1.
+	 */
+	mutex_enter(&resched_lock);
+	count = resched_count;
+	mutex_exit(&resched_lock);
+
+	ts.tv_sec = 0;
+	ts.tv_nsec = 10 * RESCHED_INTERVAL;
+	(void) nanosleep(&ts, NULL);
+
+	mutex_enter(&resched_lock);
+	if (count != resched_count && count + 1 != resched_count) {
+		fprintf(stderr, "resched_count is off, something must have "
+		    "fired after the fact: expected %d, got %d\n", count,
+		    resched_count);
+		exit(1);
+	}
+	mutex_exit(&resched_lock);
+
+	exit(0);
+}
+
+/* ARGSUSED */
+static void
+resched_tick(void *arg)
+{
+	mutex_enter(&resched_lock);
+	resched_count++;
+
+	if (resched_count == RESCHED_MAX)
+		cond_signal(&resched_cond);
+
+	if (resched_cancel == B_FALSE) {
+		if (periodic_schedule(resched_ph, RESCHED_INTERVAL,
+		    PERIODIC_ONESHOT, resched_tick, NULL, &resched_id) != 0) {
+			fprintf(stderr, "failed to schedule periodic: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+	}
+
+	mutex_exit(&resched_lock);
+}
+
+int
+main(void)
+{
+	int port, ret, loopcount;
+	port_event_t pe;
+	thread_t thr;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	resched_ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (resched_ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if ((ret = thr_create(NULL, 0, resched_watchdog, NULL, 0, &thr)) != 0) {
+		fprintf(stderr, "failed to create watchdog therad: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	if (periodic_schedule(resched_ph, RESCHED_INTERVAL,
+	    PERIODIC_ONESHOT, resched_tick, NULL, &resched_id) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	loopcount = 0;
+
+	for (;;) {
+		/*
+		 * The use of the loop counter here is a simple heuristic to try
+		 * to make sure that we don't end up infinitely looping and
+		 * broken.
+		 */
+		loopcount++;
+		if (loopcount > TRY_MAX)
+			break;
+
+		if (port_get(port, &pe, NULL) != 0) {
+			fprintf(stderr, "failed to port_get: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+
+		periodic_fire(resched_ph);
+	}
+
+	/* The oneshot should fire there and we should exit */
+	fprintf(stderr, "reschedule loop count exceeded");
+	exit(1);
+}
diff --git a/usr/src/test/os-tests/tests/periodic/stress.c b/usr/src/test/os-tests/tests/periodic/stress.c
new file mode 100644
index 0000000000..59e243225c
--- /dev/null
+++ b/usr/src/test/os-tests/tests/periodic/stress.c
@@ -0,0 +1,199 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
+/*
+ * Generate a lot of periodic timer activity. Then clean everything up. Note
+ * that we'll end up cleaning everything up and allow ourselve to be cleaned up.
+ */
+
+#include <stdio.h>
+#include <port.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <sys/debug.h>
+
+#include <libperiodic.h>
+
+#define	STRESS_NPERIODIC	20
+#define	STRESS_NONESHOT		20
+
+#define	STRESS_TIMER_MAX	20
+#define	STRESS_TIMEOUT		NANOSEC
+
+static periodic_handle_t *stress_ph;
+static periodic_id_t stress_pids[STRESS_NPERIODIC];
+static periodic_id_t stress_oids[STRESS_NPERIODIC];
+
+static mutex_t stress_lock = ERRORCHECKMUTEX;
+static boolean_t stress_over;
+
+const char *
+_umem_debug_init()
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+
+
+static hrtime_t
+stress_getto(void)
+{
+	hrtime_t r;
+	r = arc4random_uniform(STRESS_TIMER_MAX) + 1;
+	r = MSEC2NSEC(r);
+	return (r);
+}
+
+static void
+stress_periodic_fire(void *arg)
+{
+}
+
+static void
+stress_teardown_fire(void *arg)
+{
+	mutex_enter(&stress_lock);
+	stress_over = B_TRUE;
+	mutex_exit(&stress_lock);
+}
+
+static void
+stress_oneshot_fire(void *arg)
+{
+	int slot = (uintptr_t)arg;
+	hrtime_t next;
+
+	next = stress_getto();
+
+	mutex_enter(&stress_lock);
+	if (stress_over == B_TRUE) {
+		mutex_exit(&stress_lock);
+		return;
+	}
+
+	if (periodic_schedule(stress_ph, next, PERIODIC_ONESHOT,
+	    stress_oneshot_fire, arg, &stress_oids[slot]) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+	mutex_exit(&stress_lock);
+}
+
+
+/*
+ * This function exists for DTrace and leak detection logic which is used
+ * outside of the test runner generally. The function must be weak otherwise the
+ * compiler can optimize out the call to the nop. Do not remove this or the call
+ * after everything has been cleaned up.
+ */
+#pragma weak stress_leakdetect
+void
+stress_leakdetect(void)
+{
+}
+
+int
+main(void)
+{
+	int port, i;
+	port_event_t pe;
+	periodic_id_t id;
+
+	port = port_create();
+	if ((port = port_create()) < 0) {
+		fprintf(stderr, "failed to create event port: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	stress_ph = periodic_init(port, NULL, CLOCK_MONOTONIC);
+	if (stress_ph == NULL) {
+		fprintf(stderr, "failed to create periodic handle: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	for (i = 0; i < STRESS_NONESHOT; i++) {
+		hrtime_t next = stress_getto();
+
+		if (periodic_schedule(stress_ph, next, PERIODIC_ONESHOT,
+		    stress_oneshot_fire, (void *)(uintptr_t)i,
+		    &stress_oids[i]) != 0) {
+			fprintf(stderr, "failed to schedule periodic: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+	}
+
+	for (i = 0; i < STRESS_NPERIODIC; i++) {
+		hrtime_t next = stress_getto();
+
+		if (periodic_schedule(stress_ph, next, 0, stress_periodic_fire,
+		    (void *)(uintptr_t)i, &stress_pids[i]) != 0) {
+			fprintf(stderr, "failed to schedule periodic: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+	}
+
+	if (periodic_schedule(stress_ph, STRESS_TIMEOUT, PERIODIC_ONESHOT,
+	    stress_teardown_fire, NULL, &id) != 0) {
+		fprintf(stderr, "failed to schedule periodic: %s\n",
+		    strerror(errno));
+		exit(1);
+	}
+
+	for (;;) {
+		/*
+		 * The use of the loop counter here is a simple heuristic to try
+		 * to make sure that we don't end up infinitely looping and
+		 * broken.
+		 */
+		if (port_get(port, &pe, NULL) != 0) {
+			fprintf(stderr, "failed to port_get: %s\n",
+			    strerror(errno));
+			exit(1);
+		}
+
+		periodic_fire(stress_ph);
+		mutex_enter(&stress_lock);
+		if (stress_over == B_TRUE) {
+			mutex_exit(&stress_lock);
+			break;
+		}
+		mutex_exit(&stress_lock);
+	}
+
+	for (i = 0; i < STRESS_NPERIODIC; i++) {
+		(void) periodic_cancel(stress_ph, stress_pids[i]);
+	}
+
+	for (i = 0; i < STRESS_NONESHOT; i++) {
+		(void) periodic_cancel(stress_ph, stress_oids[i]);
+	}
+
+	periodic_fini(stress_ph);
+	stress_leakdetect();
+	exit(0);
+}
-- 
2.21.0

