From 93f73bac17fe9d52447cbf19cb02e92b0781e6d4 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Wed, 14 Mar 2018 11:50:31 -0500
Subject: [PATCH] VPC branch with squashed commits

- Overlay header/interface updates for VL3 routing
- Overlay annotations where changes are needed
- Overlay: remove defines for union resolution
- libsvp: Update with overlay_target.h changes
- More TODO comments
- Add OVERLAY_PROP_T_ETHER plus svp/dcid & svp/router_mac properties.
- missing mutex_exit in varpd_svp_getprop
- Stub for varpd_files_lookup_l3
- Stub for varpd_files_lookup_l3 (fix)
- Updated overlay_target.h definitions
- Fix .WAIT in Makefile
- New SVP messages & a version addition, but still WIP, on varpd
  Reviewed by: Jason King <jbk@joyent.com>
- overlay_target_entry needs a spot for vlan
- Add dcid property to overlay
- Update varpd_files to support VL3->UL3 lookups
- Restore SVP_R_ROUTE_REQ, and all that goes with it.
  Interpret sl3a_uport == 0 in SVP_R_VL3_ACK to indicate the VL3 IP
  is a next-hop router.
  Add "route" log messages for shootdowns.
---
 usr/src/cmd/dladm/dladm.c                     |  30 +-
 usr/src/lib/libdladm/common/libdloverlay.c    |  13 +-
 usr/src/lib/libdladm/common/libdloverlay.h    |   6 +-
 usr/src/lib/varpd/Makefile                    |   5 +-
 .../lib/varpd/files/common/libvarpd_files.c   | 732 +++++++++++++++++-
 usr/src/lib/varpd/libvarpd/common/libvarpd.c  |  12 +-
 .../lib/varpd/libvarpd/common/libvarpd_arp.c  |  11 +-
 .../lib/varpd/libvarpd/common/libvarpd_impl.h |   5 +-
 .../varpd/libvarpd/common/libvarpd_overlay.c  |  10 +-
 .../varpd/libvarpd/common/libvarpd_persist.c  |   8 +-
 .../varpd/libvarpd/common/libvarpd_provider.h |   6 +-
 .../lib/varpd/libvarpd/common/mapfile-plugin  |   3 +-
 .../lib/varpd/libvarpd/common/mapfile-vers    |   3 +-
 usr/src/lib/varpd/svp/common/libvarpd_svp.c   | 321 +++++++-
 usr/src/lib/varpd/svp/common/libvarpd_svp.h   |  15 +-
 .../lib/varpd/svp/common/libvarpd_svp_prot.h  |  60 +-
 .../varpd/svp/common/libvarpd_svp_remote.c    |  59 +-
 usr/src/man/man1m/dladm.1m                    |  16 +-
 usr/src/uts/common/io/overlay/overlay.c       | 101 ++-
 .../uts/common/io/overlay/overlay_target.c    |  55 +-
 usr/src/uts/common/sys/ethernet.h             |  14 +
 usr/src/uts/common/sys/overlay.h              |   4 +-
 usr/src/uts/common/sys/overlay_common.h       |   3 +-
 usr/src/uts/common/sys/overlay_impl.h         |  43 +-
 usr/src/uts/common/sys/overlay_target.h       |  50 +-
 25 files changed, 1472 insertions(+), 113 deletions(-)

diff --git a/usr/src/cmd/dladm/dladm.c b/usr/src/cmd/dladm/dladm.c
index 1edd13b0cb..e46ce50af7 100644
--- a/usr/src/cmd/dladm/dladm.c
+++ b/usr/src/cmd/dladm/dladm.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright 2016 Nexenta Systems, Inc.
  */
 
@@ -419,7 +419,8 @@ static cmd_t	cmds[] = {
 	    "    show-bridge      -t [-p] [-o <field>,...] [-s [-i <interval>]]"
 	    " <bridge>\n"						},
 	{ "create-overlay",	do_create_overlay,
-	    "    create-overlay   [-t] -e <encap> -s <search> -v <vnetid>\n"
+	    "    create-overlay   [-t] [-d <dcid>] -e <encap> -s <search> "
+	    "-v <vnetid>\n"
 	    "\t\t     [ -p <prop>=<value>[,...]] <overlay>"	},
 	{ "delete-overlay",	do_delete_overlay,
 	    "    delete-overlay   <overlay>"			},
@@ -1463,6 +1464,7 @@ static const struct option overlay_create_lopts[] = {
 	{ "search",	required_argument,	NULL,	's' },
 	{ "temporary", 	no_argument,		NULL,	't' },
 	{ "vnetid",	required_argument,	NULL,	'v' },
+	{ "dcid",	optional_argument,	NULL,	'd' },
 	{ NULL,		0,			NULL,	0 }
 };
 
@@ -9891,15 +9893,26 @@ do_create_overlay(int argc, char *argv[], const char *use)
 	char			name[MAXLINKNAMELEN];
 	dladm_status_t		status;
 	uint32_t		flags = DLADM_OPT_ACTIVE | DLADM_OPT_PERSIST;
+	uint32_t		dcid = 0;
 	uint64_t		vid;
 	boolean_t		havevid = B_FALSE;
 	char			propstr[DLADM_STRSIZE];
 	dladm_arg_list_t	*proplist = NULL;
 
 	bzero(propstr, sizeof (propstr));
-	while ((opt = getopt_long(argc, argv, ":te:v:p:s:",
+	while ((opt = getopt_long(argc, argv, ":td:e:v:p:s:",
 	    overlay_create_lopts, NULL)) != -1) {
 		switch (opt) {
+		case 'd':
+			errno = 0;
+			dcid = strtoul(optarg, &endp, 10);
+			if (*endp != '\0' || (dcid == 0 && errno == EINVAL))
+				die("couldn't parse datacenter id: %s",
+				    optarg);
+			if ((dcid == ULONG_MAX && errno == ERANGE) ||
+			    (dcid > UINT32_MAX))
+				die("datacenter id too large: %s", optarg);
+			break;
 		case 'e':
 			encap = optarg;
 			break;
@@ -9916,6 +9929,7 @@ do_create_overlay(int argc, char *argv[], const char *use)
 				die("property list too long '%s'", propstr);
 			break;
 		case 'v':
+			errno = 0;
 			vid = strtoul(optarg, &endp, 10);
 			if (*endp != '\0' || (vid == 0 && errno == EINVAL))
 				die("couldn't parse virtual networkd id: %s",
@@ -9958,7 +9972,7 @@ do_create_overlay(int argc, char *argv[], const char *use)
 	    != DLADM_STATUS_OK)
 		die("invalid overlay property");
 
-	status = dladm_overlay_create(handle, name, encap, search, vid,
+	status = dladm_overlay_create(handle, name, encap, search, vid, dcid,
 	    proplist, &errlist, flags);
 	dladm_free_props(proplist);
 	if (status != DLADM_STATUS_OK) {
@@ -9988,7 +10002,7 @@ do_delete_overlay(int argc, char *argv[], const char *use)
 
 typedef struct showoverlay_state {
 	ofmt_handle_t		sho_ofmt;
-	const char 		*sho_linkname;
+	const char		*sho_linkname;
 	dladm_overlay_propinfo_handle_t sho_info;
 	uint8_t			sho_value[DLADM_OVERLAY_PROP_SIZEMAX];
 	uint32_t		sho_size;
@@ -10079,6 +10093,12 @@ print_overlay_value(char *outbuf, uint_t bufsize, uint_t type, const void *pbuf,
 	case OVERLAY_PROP_T_STRING:
 		(void) snprintf(outbuf, bufsize, "%s", pbuf);
 		break;
+	case OVERLAY_PROP_T_ETHER:
+		if (ether_ntoa_r((struct ether_addr *)pbuf, outbuf) == NULL) {
+			warn("malformed overlay ethernet property\n");
+			(void) snprintf(outbuf, bufsize, "--");
+		}
+		break;
 	default:
 		abort();
 	}
diff --git a/usr/src/lib/libdladm/common/libdloverlay.c b/usr/src/lib/libdladm/common/libdloverlay.c
index a83105b91c..e508c4a16f 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.c
+++ b/usr/src/lib/libdladm/common/libdloverlay.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2015 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 #include <libdladm_impl.h>
@@ -127,6 +127,11 @@ dladm_overlay_parse_prop(overlay_prop_type_t type, void *buf, uint32_t *sizep,
 		bcopy(&ipv6, buf, sizeof (struct in6_addr));
 		*sizep = sizeof (struct in6_addr);
 		break;
+	case OVERLAY_PROP_T_ETHER:
+		if (ether_aton_r(val, (struct ether_addr *)buf) == NULL)
+			return (DLADM_STATUS_BADARG);
+		*sizep = ETHERADDRL;
+		break;
 	default:
 		abort();
 	}
@@ -475,7 +480,7 @@ dladm_overlay_walk_prop(dladm_handle_t handle, datalink_id_t linkid,
 
 dladm_status_t
 dladm_overlay_create(dladm_handle_t handle, const char *name,
-    const char *encap, const char *search, uint64_t vid,
+    const char *encap, const char *search, uint64_t vid, uint32_t dcid,
     dladm_arg_list_t *props, dladm_errlist_t *errs, uint32_t flags)
 {
 	int ret, i;
@@ -495,6 +500,7 @@ dladm_overlay_create(dladm_handle_t handle, const char *name,
 	bzero(&oic, sizeof (oic));
 	oic.oic_linkid = linkid;
 	oic.oic_vnetid = vid;
+	oic.oic_dcid = dcid;
 	(void) strlcpy(oic.oic_encap, encap, MAXLINKNAMELEN);
 
 	status = DLADM_STATUS_OK;
@@ -542,8 +548,7 @@ dladm_overlay_create(dladm_handle_t handle, const char *name,
 		return (dladm_errno2status(ret));
 	}
 
-	if ((ret = libvarpd_c_instance_create(vch, linkid, search,
-	    &id)) != 0) {
+	if ((ret = libvarpd_c_instance_create(vch, linkid, search, &id)) != 0) {
 		(void) dladm_errlist_append(errs,
 		    "failed to create varpd instance: %s", strerror(ret));
 		libvarpd_c_destroy(vch);
diff --git a/usr/src/lib/libdladm/common/libdloverlay.h b/usr/src/lib/libdladm/common/libdloverlay.h
index 39b01ccae3..3da3a34f46 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.h
+++ b/usr/src/lib/libdladm/common/libdloverlay.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2015 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 #ifndef _LIBDLOVERLAY_H
@@ -45,8 +45,8 @@ typedef struct dladm_overlay_status {
 } dladm_overlay_status_t;
 
 extern dladm_status_t dladm_overlay_create(dladm_handle_t, const char *,
-    const char *, const char *, uint64_t, dladm_arg_list_t *, dladm_errlist_t *,
-    uint32_t);
+    const char *, const char *, uint64_t, uint32_t, dladm_arg_list_t *,
+    dladm_errlist_t *, uint32_t);
 extern dladm_status_t dladm_overlay_delete(dladm_handle_t, datalink_id_t);
 
 typedef void (*dladm_overlay_status_f)(dladm_handle_t, datalink_id_t,
diff --git a/usr/src/lib/varpd/Makefile b/usr/src/lib/varpd/Makefile
index daa849572e..a0e4537ab9 100644
--- a/usr/src/lib/varpd/Makefile
+++ b/usr/src/lib/varpd/Makefile
@@ -10,10 +10,10 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
-SUBDIRS = libvarpd .WAIT direct files svp
+SUBDIRS = libvarpd direct files svp
 
 all :=		TARGET = all
 clean :=	TARGET = clean
@@ -26,6 +26,7 @@ lint :=		TARGET = lint
 .KEEP_STATE:
 
 all clean clobber install install_h check lint: $(SUBDIRS)
+direct files svp: libvarpd
 
 $(SUBDIRS):  FRC
 	@cd $@; pwd; $(MAKE) $(TARGET)
diff --git a/usr/src/lib/varpd/files/common/libvarpd_files.c b/usr/src/lib/varpd/files/common/libvarpd_files.c
index 812919a07d..7571913844 100644
--- a/usr/src/lib/varpd/files/common/libvarpd_files.c
+++ b/usr/src/lib/varpd/files/common/libvarpd_files.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -28,7 +28,7 @@
  * The plug-in only has a single property, which is the location of the JSON
  * file. The JSON file itself looks something like:
  *
- * 	{
+ *	{
  *		"aa:bb:cc:dd:ee:ff": {
  *			"arp": "10.23.69.1",
  *			"ndp": "2600:3c00::f03c:91ff:fe96:a264",
@@ -36,7 +36,42 @@
  *			"port": 8080
  *		},
  *		...
- *	}
+ *
+ *		"local-subnet1": {
+ *			"prefix": "192.168.1.0/24",
+ *			"vlan": 123
+ *		},
+ *		...
+ *
+ *		"remote-subnet1": {
+ *			"dcid": 11223344,
+ *			"prefix": "10.21.10.0/24",
+ *			"vnet": 5340123,
+ *			"vlan": 789,
+ *			"routermac": "12:34:56:78:aa:bb",
+ *			"macs": {
+ *				"aa:bb:cc:dd:ee:ff": {
+ *					"arp": "192.168.50.22",
+ *					...
+ *				}
+ *			}
+ *		},
+ *		...
+ *		"attach-group1": [
+ *			"remote-subnet1",
+ *			"remote-subnet2",
+ *			"local-subnet1",
+ *			...
+ *		],
+ *		...
+ *
+ * Entries for performing VL3 routing (local-, remote-, and attach-) must
+ * all start with their respective prefixes (local-, remote-, or attach-) to
+ * identify the type of entry.  Names of entries are limited to
+ * FABRIC_NAME_MAX-1  characters.
+ *
+ * NOTE: This isn't very sophisticated, so attachment entries need to appear
+ * after the entries referenced in it.
  */
 
 #include <libvarpd_provider.h>
@@ -60,6 +95,22 @@
 
 #include <libvarpd_files_json.h>
 
+#define	FABRIC_NAME_MAX	64
+typedef struct varpd_files_fabric {
+	char		vafs_name[FABRIC_NAME_MAX];
+	nvlist_t	*vafs_nvl;
+	struct in6_addr	vafs_addr;
+	uint64_t	vafs_vnet;
+	uint32_t	vafs_dcid;
+	uint16_t	vafs_vlan;
+	uint8_t		vafs_prefixlen;
+	uint8_t		vafs_routermac[ETHERADDRL];
+} varpd_files_fabric_t;
+
+typedef struct varpd_files_attach {
+	varpd_files_fabric_t **vff_fabrics;
+} varpd_files_attach_t;
+
 typedef struct varpd_files {
 	overlay_plugin_dest_t	vaf_dest;	/* RO */
 	varpd_provider_handle_t	*vaf_hdl;	/* RO */
@@ -67,12 +118,91 @@ typedef struct varpd_files {
 	nvlist_t		*vaf_nvl;	/* WO */
 	uint64_t		vaf_nmisses;	/* Atomic */
 	uint64_t		vaf_narp;	/* Atomic */
+	varpd_files_fabric_t	*vaf_fabrics;	/* RO */
+	varpd_files_attach_t	*vaf_attach;	/* RO */
+	uint64_t		vaf_vnet;	/* RO */
+	uint32_t		vaf_dcid;	/* RO */
 } varpd_files_t;
 
 static const char *varpd_files_props[] = {
 	"files/config"
 };
 
+/*
+ * Try to convert a string to an IP address or IP address + prefix.  We first
+ * try to convert as an IPv6 address, and if that fails, we try to convert as
+ * an IPv4 adress and then wrap it in an IPv6 address.
+ *
+ * To parse an address+prefix length (e.g. 192.168.0.1/24), prefixlen must be
+ * non-NULL.  If prefixlen is not NULL and a lone address is supplied,
+ * *prefixlen will be set to 128.  If prefixlen is NULL, only a lone address
+ * can be successfully parsed.
+ *
+ * Note: if this is a wrapped IPv4 address with a prefix, *prefixlen is adjusted
+ * to reflect the value as an IPv6 address, e.g. 192.168.1.0/24 will have a
+ * prefixlen of 120 (96 + 24).
+ *
+ */
+static int
+str_to_ip(const char *s, struct in6_addr *v6, uint8_t *prefixlen)
+{
+	const char *slash;	/* he is real */
+	char addrstr[INET6_ADDRSTRLEN] = { 0 };
+	size_t addrlen;
+	boolean_t is_v4 = B_FALSE;
+
+	slash = strchr(s, '/');
+
+	if (prefixlen != NULL) {
+		addrlen = (slash != NULL) ? (size_t)(slash - s) : strlen(s);
+	} else {
+		if (slash != NULL)
+			return (EINVAL);
+		addrlen = strlen(s);
+	}
+
+	if (addrlen > sizeof (addrstr))
+		return (EINVAL);
+
+	bcopy(s, addrstr, addrlen);
+
+	if (inet_pton(AF_INET6, addrstr, v6) != 1) {
+		uint32_t v4;
+
+		if (inet_pton(AF_INET, addrstr, &v4) != 1)
+			return (EINVAL);
+
+		IN6_IPADDR_TO_V4MAPPED(v4, v6);
+		is_v4 = B_TRUE;
+	}
+
+	if (prefixlen != NULL) {
+		if (slash == NULL) {
+			*prefixlen = is_v4 ? 32 : 128;
+		} else {
+			unsigned long mask = 0;
+
+			errno = 0;
+			mask = strtoul(slash + 1, NULL, 10);
+			if (errno != 0)
+				return (EINVAL);
+
+			if (is_v4) {
+				if (mask > 32)
+					return (EINVAL);
+				mask += 96;
+			}
+
+			if (mask > 128)
+				return (EINVAL);
+
+			*prefixlen = (uint8_t)mask;
+		}
+	}
+
+	return (0);
+}
+
 static boolean_t
 varpd_files_valid_dest(overlay_plugin_dest_t dest)
 {
@@ -103,20 +233,19 @@ varpd_files_create(varpd_provider_handle_t *hdl, void **outp,
 	vaf->vaf_path = NULL;
 	vaf->vaf_nvl = NULL;
 	vaf->vaf_hdl = hdl;
+	vaf->vaf_dcid = libvarpd_plugin_dcid(hdl);
 	*outp = vaf;
 	return (0);
 }
 
+static int varpd_files_normalize_remote(nvlist_t *, nvlist_t *);
+
 static int
-varpd_files_normalize_nvlist(varpd_files_t *vaf, nvlist_t *nvl)
+varpd_files_normalize_ethers(nvlist_t *nvl, nvlist_t *out, boolean_t is_sub)
 {
 	int ret;
-	nvlist_t *out;
 	nvpair_t *pair;
 
-	if ((ret = nvlist_alloc(&out, NV_UNIQUE_NAME, 0)) != 0)
-		return (ret);
-
 	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
 	    pair = nvlist_next_nvpair(nvl, pair)) {
 		char *name, fname[ETHERADDRSTRL];
@@ -135,6 +264,41 @@ varpd_files_normalize_nvlist(varpd_files_t *vaf, nvlist_t *nvl)
 			return (EINVAL);
 		}
 
+		/* Remote subnet */
+		if (!is_sub && strncmp(name, "remote-", 7) == 0) {
+			nvlist_t *rem;
+
+			ret = nvlist_alloc(&rem, NV_UNIQUE_NAME, 0);
+			if (ret != 0) {
+				nvlist_free(out);
+				return (EINVAL);
+			}
+
+			ret = varpd_files_normalize_remote(data, rem);
+			if (ret != 0) {
+				nvlist_free(out);
+				return (EINVAL);
+			}
+
+			ret = nvlist_add_nvlist(out, name, rem);
+			nvlist_free(rem);
+			if (ret != 0) {
+				nvlist_free(out);
+				return (EINVAL);
+			}
+			continue;
+		}
+
+		/* attached and local fabrics */
+		if (!is_sub && (strncmp(name, "attach-", 7) == 0 ||
+		    strncmp(name, "local-", 6) == 0)) {
+			if ((ret = nvlist_add_nvlist(out, name, data)) != 0) {
+				nvlist_free(out);
+				return (EINVAL);
+			}
+			continue;
+		}
+
 		if (ether_aton_r(name, e) == NULL) {
 			nvlist_free(out);
 			return (EINVAL);
@@ -151,10 +315,327 @@ varpd_files_normalize_nvlist(varpd_files_t *vaf, nvlist_t *nvl)
 		}
 	}
 
+	return (0);
+}
+
+static int
+varpd_files_normalize_remote(nvlist_t *nvl, nvlist_t *out)
+{
+	nvlist_t *macs, *mout;
+	nvpair_t *pair;
+	int ret;
+
+	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(nvl, pair)) {
+		char *name;
+
+		name = nvpair_name(pair);
+
+		if (strcmp(name, "macs") == 0) {
+			if ((ret = nvpair_value_nvlist(pair, &macs)) != 0) {
+				nvlist_free(out);
+				return (EINVAL);
+			}
+
+			/* This entry is handled at the end */
+			continue;
+		}
+
+		if ((ret = nvlist_add_nvpair(out, pair)) != 0) {
+			nvlist_free(out);
+			return (EINVAL);
+		}
+	}
+
+	if (macs == NULL) {
+		nvlist_free(out);
+		return (EINVAL);
+	}
+
+	if ((ret = nvlist_alloc(&mout, NV_UNIQUE_NAME, 0)) != 0) {
+		nvlist_free(out);
+		return (EINVAL);
+	}
+
+	if ((ret = varpd_files_normalize_ethers(macs, mout, B_TRUE)) != 0) {
+		/* mout is freed on error by varpd_files_normalize_ethers() */
+		nvlist_free(out);
+		return (EINVAL);
+	}
+
+	ret = nvlist_add_nvlist(out, "macs", mout);
+	nvlist_free(mout);
+	if (ret != 0) {
+		nvlist_free(out);
+		return (EINVAL);
+	}
+
+	return (0);
+}
+
+static int
+varpd_files_normalize_nvlist(varpd_files_t *vaf, nvlist_t *nvl)
+{
+	int ret;
+	nvlist_t *out;
+	nvpair_t *pair;
+
+	if ((ret = nvlist_alloc(&out, NV_UNIQUE_NAME, 0)) != 0)
+		return (ret);
+
+	if ((ret = varpd_files_normalize_ethers(nvl, out, B_FALSE)) != 0) {
+		/* varpd_files_normalize_ethers() frees out on error */
+		return (EINVAL);
+	}
+
 	vaf->vaf_nvl = out;
 	return (0);
 }
 
+static int
+varpd_files_add_local_subnet(varpd_files_t *vaf, varpd_files_fabric_t *net,
+    const char *name, nvlist_t *nvl)
+{
+	char *s;
+	int32_t vlan;
+	int ret;
+
+	net->vafs_dcid = vaf->vaf_dcid;
+	net->vafs_vnet = vaf->vaf_vnet;
+	net->vafs_nvl = vaf->vaf_nvl;
+
+	(void) strlcpy(net->vafs_name, name, sizeof (net->vafs_name));
+
+	if ((ret = nvlist_lookup_string(nvl, "prefix", &s)) != 0)
+		return (EINVAL);
+	if (str_to_ip(s, &net->vafs_addr, &net->vafs_prefixlen) != 0)
+		return (EINVAL);
+
+	if ((ret = nvlist_lookup_int32(nvl, "prefix", &vlan)) != 0)
+		return (EINVAL);
+	if (vlan < 0 || vlan > 4096)
+		return (EINVAL);
+	net->vafs_vlan = (uint16_t)vlan;
+
+	/* XXX: routermac */
+	return (0);
+}
+
+static int
+varpd_files_add_remote_subnet(varpd_files_fabric_t *net, const char *netname,
+    nvlist_t *nvl)
+{
+	nvpair_t *pair;
+	int ret;
+
+	(void) strlcpy(net->vafs_name, netname, sizeof (net->vafs_name));
+
+	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(nvl, pair)) {
+		char *name = nvpair_name(pair);
+		int32_t i32;
+
+		if (strcmp(name, "dcid") == 0) {
+			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
+				return (ret);
+
+			net->vafs_dcid = (uint32_t)i32;
+		} else if (strcmp(name, "prefix") == 0) {
+			char *s;
+
+			if ((ret = nvpair_value_string(pair, &s)) != 0)
+				return (ret);
+
+			if (str_to_ip(s, &net->vafs_addr,
+			    &net->vafs_prefixlen) != 0)
+				return (EINVAL);
+		} else if (strcmp(name, "vnet") == 0) {
+			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
+				return (ret);
+			net->vafs_vnet = i32;
+		} else if (strcmp(name, "vlan") == 0) {
+			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
+				return (ret);
+			if (i32 > 4096 || i32 < 0)
+				return (EINVAL);
+			net->vafs_vlan = i32;
+		} else if (strcmp(name, "macs") == 0) {
+			nvlist_t *macs;
+
+			if ((ret = nvpair_value_nvlist(pair, &macs)) != 0)
+				return (ret);
+
+			if ((ret = nvlist_dup(macs, &net->vafs_nvl, 0)) != 0)
+				return (ret);
+		} else if (strcmp(name, "routermac") == 0) {
+			char *s;
+			struct ether_addr *e;
+			e = (struct ether_addr *)&net->vafs_routermac;
+
+			if ((ret = nvpair_value_string(pair, &s)) != 0)
+				return (ret);
+
+			if (ether_aton_r(s, e) == NULL)
+				return (EINVAL);
+
+		}
+	}
+
+	return (0);
+}
+
+static void varpd_files_stop_fabrics(varpd_files_t *);
+
+static int
+varpd_files_start_fabrics(varpd_files_t *vaf)
+{
+	nvpair_t *pair;
+	size_t nfabric = 0;
+	int ret;
+
+	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
+		char *name = nvpair_name(pair);
+
+		if (strncmp(name, "remote-", 7) != 0 &&
+		    strncmp(name, "attach-", 7) != 0)
+			continue;
+
+		nfabric++;
+	}
+
+	if (nfabric == 0)
+		return (0);
+
+	vaf->vaf_fabrics = calloc(nfabric + 1, sizeof (varpd_files_fabric_t));
+	if (vaf->vaf_fabrics == NULL)
+		return (ENOMEM);
+
+	nfabric = 0;
+	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
+		char *name = nvpair_name(pair);
+		boolean_t is_remote = B_FALSE;
+		boolean_t is_local = B_FALSE;
+
+		if (strncmp(name, "remote-", 7) == 0)
+			is_remote = B_TRUE;
+		if (strncmp(name, "local-", 7) == 0)
+			is_local = B_TRUE;
+
+		if (!is_remote && !is_local)
+			continue;
+
+		varpd_files_fabric_t *net = &vaf->vaf_fabrics[nfabric++];
+		nvlist_t *netnvl;
+
+		if ((ret = nvpair_value_nvlist(pair, &netnvl)) != 0) {
+			varpd_files_stop_fabrics(vaf);
+			return (ret);
+		}
+
+		ret = is_remote ?
+		    varpd_files_add_remote_subnet(net, name, netnvl) :
+		    varpd_files_add_local_subnet(vaf, net, name, netnvl);
+
+		if (ret != 0) {
+			varpd_files_stop_fabrics(vaf);
+			return (ret);
+		}
+	}
+
+	return (0);
+}
+
+static varpd_files_fabric_t *
+varpd_files_fabric_getbyname(varpd_files_t *vaf, const char *name)
+{
+	varpd_files_fabric_t *fab = &vaf->vaf_fabrics[0];
+
+	for (fab = &vaf->vaf_fabrics[0]; fab->vafs_name[0] != '\0'; fab++) {
+		if (strcmp(fab->vafs_name, name) != 0)
+			continue;
+		return (fab);
+	}
+
+	return (NULL);
+}
+
+static void
+varpd_files_stop_attached(varpd_files_t *vaf)
+{
+	size_t i;
+
+	if (vaf->vaf_attach == NULL)
+		return;
+
+	for (i = 0; vaf->vaf_attach[i].vff_fabrics != NULL; i++)
+		free(vaf->vaf_attach[i].vff_fabrics);
+
+	free(vaf->vaf_attach);
+	vaf->vaf_attach = NULL;
+}
+
+static int
+varpd_files_start_attached(varpd_files_t *vaf)
+{
+	nvpair_t *pair;
+	size_t nattach = 0;
+	int ret;
+
+	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
+		char *name;
+
+		name = nvpair_name(pair);
+		if (strncmp(name, "attach-", 7) != 0)
+			continue;
+
+		if (nvpair_type(pair) != DATA_TYPE_STRING_ARRAY)
+			return (EINVAL);
+
+		nattach++;
+	}
+
+	if (nattach == 0)
+		return (0);
+
+	if ((vaf->vaf_attach = calloc(nattach + 1,
+	    sizeof (varpd_files_attach_t))) == NULL)
+		return (ENOMEM);
+
+	nattach = 0;
+	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
+		varpd_files_attach_t *fa = &vaf->vaf_attach[nattach++];
+		char **fabrics = NULL;
+		uint_t i, nelem = 0;
+
+		if ((ret = nvpair_value_string_array(pair, &fabrics,
+		    &nelem)) != NULL) {
+			varpd_files_stop_attached(vaf);
+			return (ret);
+		}
+
+		if ((fa = calloc(nelem + 1, sizeof (varpd_files_fabric_t *))) ==
+		    NULL) {
+			varpd_files_stop_attached(vaf);
+			return (ENOMEM);
+		}
+
+		for (i = 0; i < nelem; i++) {
+			fa->vff_fabrics[i] =
+			    varpd_files_fabric_getbyname(vaf, fabrics[i]);
+			if (fa->vff_fabrics[i] == NULL) {
+				varpd_files_stop_attached(vaf);
+				return (ENOENT);
+			}
+		}
+	}
+
+	return (0);
+}
+
 static int
 varpd_files_start(void *arg)
 {
@@ -191,20 +672,54 @@ varpd_files_start(void *arg)
 	if (ret == 0) {
 		ret = varpd_files_normalize_nvlist(vaf, nvl);
 		nvlist_free(nvl);
+		nvl = NULL;
 	}
 	if (munmap(maddr, st.st_size) != 0)
 		abort();
 	if (close(fd) != 0)
 		abort();
+	if (ret != 0) {
+		nvlist_free(nvl);
+		return (ret);
+	}
+
+	if ((ret = varpd_files_start_fabrics(vaf)) != 0) {
+		nvlist_free(nvl);
+		return (ret);
+	}
+
+	if ((ret = varpd_files_start_attached(vaf)) != 0) {
+		varpd_files_stop_fabrics(vaf);
+		nvlist_free(nvl);
+		return (ret);
+	}
 
 	return (ret);
 }
 
+static void
+varpd_files_stop_fabrics(varpd_files_t *vaf)
+{
+	varpd_files_fabric_t *net = NULL;
+
+	if (vaf == NULL || vaf->vaf_fabrics == NULL)
+		return;
+
+	for (net = vaf->vaf_fabrics; net->vafs_name[0] != '\0'; net++) {
+		if (net->vafs_nvl != vaf->vaf_nvl)
+			nvlist_free(net->vafs_nvl);
+	}
+	free(vaf->vaf_fabrics);
+	vaf->vaf_fabrics = NULL;
+}
+
+
 static void
 varpd_files_stop(void *arg)
 {
 	varpd_files_t *vaf = arg;
 
+	varpd_files_stop_fabrics(vaf);
 	nvlist_free(vaf->vaf_nvl);
 	vaf->vaf_nvl = NULL;
 }
@@ -222,9 +737,156 @@ varpd_files_destroy(void *arg)
 	umem_free(vaf, sizeof (varpd_files_t));
 }
 
+static nvlist_t *
+varpd_files_lookup_l3subnet(varpd_files_t *vaf, varpd_files_attach_t *attach,
+    const struct in6_addr *dst, overlay_target_point_t *otp,
+    overlay_target_route_t *otr)
+{
+	varpd_files_fabric_t *net = NULL;
+	nvlist_t *macs = NULL;
+	size_t i;
+	boolean_t found = B_FALSE;
+
+	for (i = 0; attach->vff_fabrics[i] != NULL; i++) {
+		net = attach->vff_fabrics[i];
+
+		if (IN6_ARE_PREFIXEDADDR_EQUAL(dst, &net->vafs_addr,
+		    net->vafs_prefixlen)) {
+			found = B_TRUE;
+			break;
+		}
+	}
+
+	if (nvlist_lookup_nvlist(net->vafs_nvl, "macs", &macs) != 0)
+		return (NULL);
+
+	otr->otr_vnet = net->vafs_vnet;
+	otr->otr_vlan = net->vafs_vlan;
+	otr->otr_dcid = net->vafs_dcid;
+	otr->otr_dst_prefixlen = net->vafs_prefixlen;
+	bcopy(net->vafs_routermac, otr->otr_srcmac, ETHERADDRL);
+	return (macs);
+}
+
+static varpd_files_attach_t *
+varpd_files_find_attach(varpd_files_t *vaf, const struct in6_addr *src,
+    uint16_t vlan, overlay_target_route_t *otr)
+{
+	varpd_files_attach_t *attach;
+	varpd_files_fabric_t *fab;
+	size_t i;
+
+	if (vaf->vaf_attach == NULL)
+		return (NULL);
+
+	for (attach = vaf->vaf_attach; attach->vff_fabrics != NULL; attach++) {
+		for (i = 0; attach->vff_fabrics[i] != NULL; i++) {
+			fab = attach->vff_fabrics[i];
+
+			if (fab->vafs_dcid == vaf->vaf_dcid &&
+			    fab->vafs_vlan == vlan &&
+			    IN6_ARE_PREFIXEDADDR_EQUAL(src, &fab->vafs_addr,
+			    fab->vafs_prefixlen)) {
+				otr->otr_src_prefixlen = fab->vafs_prefixlen;
+				return (attach);
+			}
+			fab++;
+		}
+	}
+
+	return (NULL);
+}
+
+static void
+varpd_files_lookup_l3(varpd_files_t *vaf, varpd_query_handle_t *qh,
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
+    overlay_target_route_t *otr)
+{
+	const struct in6_addr *dest_ip;
+	const struct in6_addr *src_ip;
+	struct in6_addr ul3 = { 0 };
+	varpd_files_attach_t *attach = NULL;
+	char *s;
+	nvlist_t *macs = NULL, *entry = NULL;
+	nvpair_t *pair = NULL;
+	int32_t prefixlen;
+
+	dest_ip = &otl->otl_addru.otlu_l3.otl3_dstip;
+	src_ip = &otl->otl_addru.otlu_l3.otl3_srcip;
+
+	if ((attach = varpd_files_find_attach(vaf, src_ip, otl->otl_vlan,
+	    otr)) == NULL) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	if ((macs = varpd_files_lookup_l3subnet(vaf, attach, dest_ip,
+	    otp, otr)) == NULL) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	for (pair = nvlist_next_nvpair(macs, NULL); pair != NULL;
+	    pair = nvlist_next_nvpair(macs, pair)) {
+		char *s;
+		struct in6_addr v6;
+
+		if (nvpair_value_nvlist(pair, &entry) != 0)
+			continue;
+
+		if (nvlist_lookup_string(entry, "arp", &s) != 0)
+			continue;
+
+		if (str_to_ip(s, &v6, NULL) != 0)
+			continue;
+
+		if (IN6_ARE_ADDR_EQUAL(dest_ip, &v6))
+			break;
+	}
+
+	if (pair == NULL) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	if (nvlist_lookup_string(entry, "ip", &s) != 0) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	if (str_to_ip(s, &ul3, NULL) != 0) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+	bcopy(&ul3, &otp->otp_ip, sizeof (ul3));
+
+	if (vaf->vaf_dest & OVERLAY_PLUGIN_D_PORT) {
+		int32_t port;
+
+		if (nvlist_lookup_int32(entry, "port", &port) != 0) {
+			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+			return;
+		}
+
+		otp->otp_port = port;
+	} else {
+		otp->otp_port = 0;
+	}
+
+	s = nvpair_name(pair);
+
+	if (ether_aton_r(s, (struct ether_addr *)otp->otp_mac) == NULL) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_OK);
+}
+
 static void
 varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
-    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
+    overlay_target_route_t *otr)
 {
 	char macstr[ETHERADDRSTRL], *ipstr;
 	nvlist_t *nvl;
@@ -238,25 +900,40 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 		return;
 	}
 
-	if (otl->otl_sap == ETHERTYPE_ARP) {
+	/*
+	 * Shuffle off L3 lookups to their own codepath.
+	 */
+	if (otl->otl_l3req) {
+		varpd_files_lookup_l3(vaf, qh, otl, otp, otr);
+		return;
+	}
+
+	/*
+	 * At this point, the traditional overlay_target_point_t is all that
+	 * needs filling in.  Zero-out the otr for safety.
+	 */
+	bzero(otr, sizeof (*otr));
+
+	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_ARP) {
 		libvarpd_plugin_proxy_arp(vaf->vaf_hdl, qh, otl);
 		return;
 	}
 
-	if (otl->otl_sap == ETHERTYPE_IPV6 &&
-	    otl->otl_dstaddr[0] == 0x33 &&
-	    otl->otl_dstaddr[1] == 0x33) {
+	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_IPV6 &&
+	    otl->otl_addru.otlu_l2.otl2_dstaddr[0] == 0x33 &&
+	    otl->otl_addru.otlu_l2.otl2_dstaddr[1] == 0x33) {
 		libvarpd_plugin_proxy_ndp(vaf->vaf_hdl, qh, otl);
 		return;
 	}
 
-	if (otl->otl_sap == ETHERTYPE_IP &&
-	    bcmp(otl->otl_dstaddr, bcast, ETHERADDRL) == 0) {
+	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_IP &&
+	    bcmp(otl->otl_addru.otlu_l2.otl2_dstaddr, bcast, ETHERADDRL) == 0) {
 		char *mac;
 		struct ether_addr a, *addr;
 
 		addr = &a;
-		if (ether_ntoa_r((struct ether_addr *)otl->otl_srcaddr,
+		if (ether_ntoa_r(
+		    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_srcaddr,
 		    macstr) == NULL) {
 			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 			return;
@@ -281,7 +958,8 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 		return;
 	}
 
-	if (ether_ntoa_r((struct ether_addr *)otl->otl_dstaddr,
+	if (ether_ntoa_r(
+	    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_dstaddr,
 	    macstr) == NULL) {
 		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 		return;
@@ -308,18 +986,9 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 		return;
 	}
 
-	/*
-	 * Try to parse it as a v6 address and then if it's not, try to
-	 * transform it into a v4 address which we'll then wrap it into a v4
-	 * mapped address.
-	 */
-	if (inet_pton(AF_INET6, ipstr, &otp->otp_ip) != 1) {
-		uint32_t v4;
-		if (inet_pton(AF_INET, ipstr, &v4) != 1) {
-			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-			return;
-		}
-		IN6_IPADDR_TO_V4MAPPED(v4, &otp->otp_ip);
+	if (str_to_ip(ipstr, &otp->otp_ip, NULL) != 0) {
+		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
+		return;
 	}
 
 	libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_OK);
@@ -344,6 +1013,7 @@ varpd_files_propinfo(void *arg, uint_t propid, varpd_prop_handle_t *vph)
 	libvarpd_prop_set_prot(vph, OVERLAY_PROP_PERM_RRW);
 	libvarpd_prop_set_type(vph, OVERLAY_PROP_T_STRING);
 	libvarpd_prop_set_nodefault(vph);
+
 	return (0);
 }
 
@@ -361,7 +1031,6 @@ varpd_files_getprop(void *arg, const char *pname, void *buf, uint32_t *sizep)
 			return (EOVERFLOW);
 		*sizep = len;
 		(void) strlcpy(buf, vaf->vaf_path, *sizep);
-
 	} else {
 		*sizep = 0;
 	}
@@ -543,7 +1212,8 @@ varpd_files_proxy_dhcp(void *arg, varpd_dhcp_handle_t *vdh, int type,
 		return;
 	}
 
-	if (ether_ntoa_r((struct ether_addr *)otl->otl_srcaddr,
+	if (ether_ntoa_r(
+	    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_srcaddr,
 	    macstr) == NULL) {
 		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
 		return;
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd.c b/usr/src/lib/varpd/libvarpd/common/libvarpd.c
index e4460089cc..9de3602e62 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd.c
@@ -150,6 +150,7 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	varpd_instance_t *inst, lookup;
 	overlay_plugin_dest_t dest;
 	uint64_t vid;
+	uint32_t dcid;
 
 	/*
 	 * We should really have our own errnos.
@@ -158,7 +159,8 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	if (plugin == NULL)
 		return (ENOENT);
 
-	if ((ret = libvarpd_overlay_info(vip, linkid, &dest, NULL, &vid)) != 0)
+	if ((ret = libvarpd_overlay_info(vip, linkid, &dest, NULL, &vid,
+	    &dcid)) != 0)
 		return (ret);
 
 	inst = umem_alloc(sizeof (varpd_instance_t), UMEM_DEFAULT);
@@ -175,6 +177,7 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	inst->vri_dest = dest;
 	inst->vri_plugin = plugin;
 	inst->vri_impl = vip;
+	inst->vri_dcid = dcid;
 	inst->vri_flags = 0;
 	if ((ret = plugin->vpp_ops->vpo_create((varpd_provider_handle_t *)inst,
 	    &inst->vri_private, dest)) != 0) {
@@ -217,6 +220,13 @@ libvarpd_plugin_vnetid(varpd_provider_handle_t *vhp)
 	return (inst->vri_vnetid);
 }
 
+uint32_t
+libvarpd_plugin_dcid(varpd_provider_handle_t *vhp)
+{
+	varpd_instance_t *inst = (varpd_instance_t *)vhp;
+	return (inst->vri_dcid);
+}
+
 varpd_instance_handle_t *
 libvarpd_instance_lookup(varpd_handle_t *vhp, uint64_t id)
 {
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
index df69207fe0..5e0b66a4be 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
@@ -75,7 +75,7 @@ libvarpd_plugin_proxy_arp(varpd_provider_handle_t *hdl,
 	}
 	vaq->vaq_bsize = sizeof (vaq->vaq_buf);
 
-	if (otl->otl_sap != ETHERTYPE_ARP) {
+	if (otl->otl_addru.otlu_l2.otl2_sap != ETHERTYPE_ARP) {
 		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
 		umem_free(vaq, sizeof (varpd_arp_query_t));
 		return;
@@ -248,8 +248,8 @@ libvarpd_plugin_proxy_ndp(varpd_provider_handle_t *hdl,
 	}
 	vaq->vaq_bsize = sizeof (vaq->vaq_buf);
 
-	if (otl->otl_dstaddr[0] != 0x33 ||
-	    otl->otl_dstaddr[1] != 0x33) {
+	if (otl->otl_addru.otlu_l2.otl2_dstaddr[0] != 0x33 ||
+	    otl->otl_addru.otlu_l2.otl2_dstaddr[1] != 0x33) {
 		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
 		umem_free(vaq, sizeof (varpd_arp_query_t));
 		return;
@@ -505,13 +505,14 @@ libvarpd_plugin_proxy_dhcp(varpd_provider_handle_t *hdl,
 	}
 	vdq->vdq_bsize = sizeof (vdq->vdq_buf);
 
-	if (otl->otl_sap != ETHERTYPE_IP) {
+	if (otl->otl_addru.otlu_l2.otl2_sap != ETHERTYPE_IP) {
 		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
 		umem_free(vdq, sizeof (varpd_dhcp_query_t));
 		return;
 	}
 
-	if (bcmp(otl->otl_dstaddr, libvarpd_arp_bcast, ETHERADDRL) != 0) {
+	if (bcmp(otl->otl_addru.otlu_l2.otl2_dstaddr, libvarpd_arp_bcast,
+	    ETHERADDRL) != 0) {
 		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
 		umem_free(vdq, sizeof (varpd_dhcp_query_t));
 		return;
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
index 7ecd3a952f..01fe6908ba 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_IMPL_H
@@ -77,6 +77,7 @@ typedef struct varpd_instance {
 	varpd_impl_t	*vri_impl;		/* RO */
 	varpd_plugin_t	*vri_plugin;		/* RO */
 	void		*vri_private;		/* RO */
+	uint32_t	vri_dcid;		/* RO */
 	mutex_t		vri_lock;
 	varpd_instance_flags_t vri_flags;	/* vri_lock */
 } varpd_instance_t;
@@ -208,7 +209,7 @@ extern int libvarpd_dirwalk(varpd_impl_t *, const char *, const char *,
 extern int libvarpd_overlay_init(varpd_impl_t *);
 extern void libvarpd_overlay_fini(varpd_impl_t *);
 extern int libvarpd_overlay_info(varpd_impl_t *, datalink_id_t,
-    overlay_plugin_dest_t *, uint64_t *, uint64_t *);
+    overlay_plugin_dest_t *, uint64_t *, uint64_t *, uint32_t *);
 extern int libvarpd_overlay_associate(varpd_instance_t *);
 extern int libvarpd_overlay_disassociate(varpd_instance_t *);
 extern int libvarpd_overlay_degrade(varpd_instance_t *, const char *);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
index b7506c56cf..060559124e 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -53,7 +53,8 @@ libvarpd_overlay_fini(varpd_impl_t *vip)
 
 int
 libvarpd_overlay_info(varpd_impl_t *vip, datalink_id_t linkid,
-    overlay_plugin_dest_t *destp, uint64_t *flags, uint64_t *vnetid)
+    overlay_plugin_dest_t *destp, uint64_t *flags, uint64_t *vnetid,
+    uint32_t *dcid)
 {
 	overlay_targ_info_t oti;
 
@@ -67,6 +68,8 @@ libvarpd_overlay_info(varpd_impl_t *vip, datalink_id_t linkid,
 		*flags = oti.oti_flags;
 	if (vnetid != NULL)
 		*vnetid = oti.oti_vnetid;
+	if (dcid != NULL)
+		*dcid = oti.oti_dcid;
 	return (0);
 }
 
@@ -280,7 +283,8 @@ libvarpd_overlay_lookup_handle(varpd_impl_t *vip)
 	vqp->vq_instance = inst;
 
 	inst->vri_plugin->vpp_ops->vpo_lookup(inst->vri_private,
-	    (varpd_query_handle_t *)vqp, otl, &otr->otr_answer);
+	    (varpd_query_handle_t *)vqp, otl, &otr->otr_answer,
+	    &otr->otr_route);
 }
 
 void
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
index 27cc802a9c..f8b1fcedfc 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.  All rights reserved.
+ * Copyright 2018 Joyent, Inc.  All rights reserved.
  */
 
 /*
@@ -281,7 +281,7 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	int err;
 	nvlist_t *pvl;
 	uint64_t id, flags, vid;
-	uint32_t linkid, dest, mode;
+	uint32_t linkid, dest, mode, dcid;
 	char *pluginstr;
 	varpd_plugin_t *plugin;
 	overlay_plugin_dest_t adest;
@@ -312,7 +312,8 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	if (plugin->vpp_mode != mode)
 		return (EINVAL);
 
-	if (libvarpd_overlay_info(vip, linkid, &adest, &flags, &vid) != 0)
+	if (libvarpd_overlay_info(vip, linkid, &adest, &flags, &vid,
+	    &dcid) != 0)
 		return (EINVAL);
 
 	if (dest != adest)
@@ -334,6 +335,7 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	inst->vri_dest = dest;
 	inst->vri_plugin = plugin;
 	inst->vri_impl = vip;
+	inst->vri_dcid = dcid;
 	inst->vri_flags = 0;
 	if (plugin->vpp_ops->vpo_restore(pvl, (varpd_provider_handle_t *)inst,
 	    dest, &inst->vri_private) != 0) {
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
index 64fa99d308..93749683df 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_PROVIDER_H
@@ -315,7 +315,8 @@ typedef void (*varpd_plugin_destroy_f)(void *);
 #define	VARPD_LOOKUP_DROP	(-1)
 typedef int (*varpd_plugin_default_f)(void *, overlay_target_point_t *);
 typedef void (*varpd_plugin_lookup_f)(void *, varpd_query_handle_t *,
-    const overlay_targ_lookup_t *, overlay_target_point_t *);
+    const overlay_targ_lookup_t *, overlay_target_point_t *,
+    overlay_target_route_t *);
 
 #define	VARPD_QTYPE_ETHERNET	0x0
 typedef void (*varpd_plugin_arp_f)(void *, varpd_arp_handle_t *, int,
@@ -373,6 +374,7 @@ extern const bunyan_logger_t *libvarpd_plugin_bunyan(varpd_provider_handle_t *);
  * Misc. Information APIs
  */
 extern uint64_t libvarpd_plugin_vnetid(varpd_provider_handle_t *);
+extern uint32_t	libvarpd_plugin_dcid(varpd_provider_handle_t *);
 
 /*
  * Lookup Replying query and proxying
diff --git a/usr/src/lib/varpd/libvarpd/common/mapfile-plugin b/usr/src/lib/varpd/libvarpd/common/mapfile-plugin
index 8cef7f669f..d9043b2d3a 100644
--- a/usr/src/lib/varpd/libvarpd/common/mapfile-plugin
+++ b/usr/src/lib/varpd/libvarpd/common/mapfile-plugin
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 #
@@ -39,6 +39,7 @@ SYMBOL_SCOPE {
 	libvarpd_panic			{ FLAGS = EXTERN };
 	libvarpd_plugin_alloc		{ FLAGS = EXTERN };
 	libvarpd_plugin_arp_reply	{ FLAGS = EXTERN };
+	libvarpd_plugin_dcid		{ FLAGS = EXTERN };
 	libvarpd_plugin_dhcp_reply	{ FLAGS = EXTERN };
 	libvarpd_plugin_free		{ FLAGS = EXTERN };
 	libvarpd_plugin_proxy_arp	{ FLAGS = EXTERN };
diff --git a/usr/src/lib/varpd/libvarpd/common/mapfile-vers b/usr/src/lib/varpd/libvarpd/common/mapfile-vers
index 7aa930cb54..5980100aff 100644
--- a/usr/src/lib/varpd/libvarpd/common/mapfile-vers
+++ b/usr/src/lib/varpd/libvarpd/common/mapfile-vers
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 #
@@ -82,6 +82,7 @@ SYMBOL_VERSION SUNWprivate {
 	libvarpd_plugin_free;
 	libvarpd_plugin_arp_reply;
 	libvarpd_plugin_dhcp_reply;
+	libvarpd_plugin_dcid;
 	libvarpd_plugin_query_reply;
 	libvarpd_plugin_proxy_arp;
 	libvarpd_plugin_proxy_dhcp;
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.c b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
index 58828065a1..efa209734b 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -360,7 +360,8 @@ static umem_cache_t *svp_lookup_cache;
 typedef enum svp_lookup_type {
 	SVP_L_UNKNOWN	= 0x0,
 	SVP_L_VL2	= 0x1,
-	SVP_L_VL3	= 0x2
+	SVP_L_VL3	= 0x2,
+	SVP_L_ROUTE	= 0x3
 } svp_lookup_type_t;
 
 typedef struct svp_lookup {
@@ -374,6 +375,11 @@ typedef struct svp_lookup {
 			varpd_arp_handle_t	*svl_vah;
 			uint8_t			*svl_out;
 		} svl_vl3;
+		struct svl_lookup_route {
+			varpd_query_handle_t	*svl_handle;
+			overlay_target_point_t	*svl_point;
+			overlay_target_route_t	*svl_route;
+		} svl_route;
 	} svl_u;
 	svp_query_t				svl_query;
 } svp_lookup_t;
@@ -382,7 +388,9 @@ static const char *varpd_svp_props[] = {
 	"svp/host",
 	"svp/port",
 	"svp/underlay_ip",
-	"svp/underlay_port"
+	"svp/underlay_port",
+	"svp/dcid",
+	"svp/router_oui"
 };
 
 static const uint8_t svp_bcast[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@@ -429,8 +437,10 @@ static void
 svp_vl3_lookup_cb(svp_t *svp, svp_status_t status, const uint8_t *vl2mac,
     const struct in6_addr *uip, const uint16_t uport, void *arg)
 {
-	overlay_target_point_t point;
+	/* Initialize address-holders to 0 for comparisons-to-zeroes later. */
+	overlay_target_point_t point = { 0 };
 	svp_lookup_t *svl = arg;
+	uint8_t nexthop_mac[6] = { 0, 0, 0, 0, 0, 0 };
 
 	assert(svp != NULL);
 	assert(svl != NULL);
@@ -443,9 +453,35 @@ svp_vl3_lookup_cb(svp_t *svp, svp_status_t status, const uint8_t *vl2mac,
 	}
 
 	/* Inject the L2 mapping before the L3 */
-	bcopy(uip, &point.otp_ip, sizeof (struct in6_addr));
-	point.otp_port = uport;
-	libvarpd_inject_varp(svp->svp_hdl, vl2mac, &point);
+	if (uport != 0 &&
+	    bcmp(uip, &point.otp_ip, sizeof (struct in6_addr)) != 0) {
+		/* Normal L3 lookup result... */
+		bcopy(uip, &point.otp_ip, sizeof (struct in6_addr));
+		point.otp_port = uport;
+		libvarpd_inject_varp(svp->svp_hdl, vl2mac, &point);
+	} else {
+		/*
+		 * Oh my, we have a next-hop router IP.
+		 * Set the MAC to the ouid+vid concatenated
+		 * special-router-MAC. Overlay down below will know
+		 * that uport == 0 means the MAC is a special one.
+		 */
+		if (bcmp(svp->svp_router_oui, nexthop_mac, ETHERADDRL) == 0) {
+			/*
+			 * We don't have a router_oui, so we can't support
+			 * special-router-MAC.  Drop it.
+			 */
+			libvarpd_plugin_arp_reply(svl->svl_u.svl_vl3.svl_vah,
+			    VARPD_LOOKUP_DROP);
+			umem_cache_free(svp_lookup_cache, svl);
+			return;
+		}
+		bcopy(svp->svp_router_oui, nexthop_mac, 3);
+		nexthop_mac[3] = (svp->svp_vid >> 16) & 0xff;
+		nexthop_mac[4] = (svp->svp_vid >> 8) & 0xff;
+		nexthop_mac[5] = svp->svp_vid & 0xff;
+		vl2mac = nexthop_mac;
+	}
 
 	bcopy(vl2mac, svl->svl_u.svl_vl3.svl_out, ETHERADDRL);
 	libvarpd_plugin_arp_reply(svl->svl_u.svl_vl3.svl_vah,
@@ -486,17 +522,53 @@ svp_shootdown_cb(svp_t *svp, const uint8_t *vl2mac, const struct in6_addr *uip,
     const uint16_t uport)
 {
 	/*
-	 * We should probably do a conditional invlaidation here.
+	 * We should probably do a conditional invalidation here.
 	 */
 	libvarpd_inject_varp(svp->svp_hdl, vl2mac, NULL);
 }
 
+static void
+svp_route_lookup_cb(svp_t *svp, svp_status_t status, uint32_t dcid,
+    uint32_t vnetid, uint16_t vlan, uint8_t *srcmac, uint8_t *dstmac,
+    uint16_t ul3_port, uint8_t *ul3_addr, uint8_t srcpfx, uint8_t dstpfx,
+    void *arg)
+{
+	svp_lookup_t *svl = arg;
+	overlay_target_point_t *otp;
+	overlay_target_route_t *otr;
+
+	if (status != SVP_S_OK) {
+		libvarpd_plugin_query_reply(svl->svl_u.svl_route.svl_handle,
+		    VARPD_LOOKUP_DROP);
+		umem_cache_free(svp_lookup_cache, svl);
+		return;
+	}
+
+	otp = svl->svl_u.svl_route.svl_point;
+	bcopy(dstmac, otp->otp_mac, ETHERADDRL);
+	bcopy(ul3_addr, &otp->otp_ip, sizeof (struct in6_addr));
+	otp->otp_port = ul3_port;
+
+	otr = svl->svl_u.svl_route.svl_route;
+	otr->otr_vnet = vnetid;
+	otr->otr_vlan = vlan;
+	bcopy(srcmac, otr->otr_srcmac, ETHERADDRL);
+	otr->otr_dcid = dcid;
+	otr->otr_src_prefixlen = srcpfx;
+	otr->otr_dst_prefixlen = dstpfx;
+
+	libvarpd_plugin_query_reply(svl->svl_u.svl_route.svl_handle,
+	    VARPD_LOOKUP_OK);
+	umem_cache_free(svp_lookup_cache, svl);
+}
+
 static svp_cb_t svp_defops = {
 	svp_vl2_lookup_cb,
 	svp_vl3_lookup_cb,
 	svp_vl2_invalidate_cb,
 	svp_vl3_inject_cb,
-	svp_shootdown_cb
+	svp_shootdown_cb,
+	svp_route_lookup_cb,
 };
 
 static boolean_t
@@ -586,24 +658,90 @@ varpd_svp_destroy(void *arg)
 	umem_free(svp, sizeof (svp_t));
 }
 
+static void
+varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
+    overlay_target_route_t *otr)
+{
+	svp_lookup_t *slp;
+	uint32_t type;
+	const struct in6_addr *src = &otl->otl_addru.otlu_l3.otl3_srcip,
+	    *dst = &otl->otl_addru.otlu_l3.otl3_dstip;
+
+	/*
+	 * otl is an L3 request, so we have src/dst IPs for the inner packet.
+	 * We also have the vlan.
+	 *
+	 * Assume kernel's overlay module is caching well, so we are directly
+	 * going to query (i.e. no caching up here of actual destinations).
+	 *
+	 * Our existing remote sever (svp_remote), but with the new message
+	 * SVP_R_ROUTE_REQ.
+	 */
+
+	/* XXX KEBE SAYS DO SOME otl verification too... */
+	if (IN6_IS_ADDR_V4MAPPED(src)) {
+		if (!IN6_IS_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IP;
+	} else {
+		if (IN6_IS_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IPV6;
+	}
+
+	slp = umem_cache_alloc(svp_lookup_cache, UMEM_DEFAULT);
+	if (slp == NULL) {
+		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	slp->svl_type = SVP_L_ROUTE;
+	slp->svl_u.svl_route.svl_handle = vqh;
+	slp->svl_u.svl_route.svl_point = otp;
+	slp->svl_u.svl_route.svl_route = otr;
+
+	svp_remote_route_lookup(svp, &slp->svl_query, src, dst,
+	    otl->otl_vnetid, (uint16_t)otl->otl_vlan, slp);
+}
+
 static void
 varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
-    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
+    overlay_target_route_t *otr)
 {
 	svp_lookup_t *slp;
 	svp_t *svp = arg;
 
+	/*
+	 * Shuffle off L3 lookups to their own codepath.
+	 */
+	if (otl->otl_l3req) {
+		varpd_svp_lookup_l3(svp, vqh, otl, otp, otr);
+		return;
+	}
+	/*
+	 * At this point, the traditional overlay_target_point_t is all that
+	 * needs filling in.  Zero-out the otr for safety.
+	 */
+	bzero(otr, sizeof (*otr));
+
+
 	/*
 	 * Check if this is something that we need to proxy, eg. arp or ndp.
 	 */
-	if (otl->otl_sap == ETHERTYPE_ARP) {
+	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_ARP) {
 		libvarpd_plugin_proxy_arp(svp->svp_hdl, vqh, otl);
 		return;
 	}
 
-	if (otl->otl_dstaddr[0] == 0x33 &&
-	    otl->otl_dstaddr[1] == 0x33) {
-		if (otl->otl_sap == ETHERTYPE_IPV6) {
+	if (otl->otl_addru.otlu_l2.otl2_dstaddr[0] == 0x33 &&
+	    otl->otl_addru.otlu_l2.otl2_dstaddr[1] == 0x33) {
+		if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_IPV6) {
 			libvarpd_plugin_proxy_ndp(svp->svp_hdl, vqh, otl);
 		} else {
 			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
@@ -617,8 +755,9 @@ varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
 	 * handle broadcast and if the multicast bit is set, lowest bit of the
 	 * first octet of the MAC, then we drop it now.
 	 */
-	if (bcmp(otl->otl_dstaddr, svp_bcast, ETHERADDRL) == 0 ||
-	    (otl->otl_dstaddr[0] & 0x01) == 0x01) {
+	if (bcmp(otl->otl_addru.otlu_l2.otl2_dstaddr, svp_bcast,
+	    ETHERADDRL) == 0 ||
+	    (otl->otl_addru.otlu_l2.otl2_dstaddr[0] & 0x01) == 0x01) {
 		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
 		return;
 	}
@@ -639,7 +778,8 @@ varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
 	slp->svl_u.svl_vl2.svl_handle = vqh;
 	slp->svl_u.svl_vl2.svl_point = otp;
 
-	svp_remote_vl2_lookup(svp, &slp->svl_query, otl->otl_dstaddr, slp);
+	svp_remote_vl2_lookup(svp, &slp->svl_query,
+	    otl->otl_addru.otlu_l2.otl2_dstaddr, slp);
 }
 
 /* ARGSUSED */
@@ -687,6 +827,22 @@ varpd_svp_propinfo(void *arg, uint_t propid, varpd_prop_handle_t *vph)
 		    sizeof (svp_defuport));
 		libvarpd_prop_set_range_uint32(vph, 1, UINT16_MAX);
 		break;
+	case 4:
+		/* svp/dcid */
+		libvarpd_prop_set_name(vph, varpd_svp_props[4]);
+		libvarpd_prop_set_prot(vph, OVERLAY_PROP_PERM_RRW);
+		libvarpd_prop_set_type(vph, OVERLAY_PROP_T_UINT);
+		libvarpd_prop_set_nodefault(vph);
+		/* XXX KEBE ASKS should I just set high to UINT32_MAX? */
+		libvarpd_prop_set_range_uint32(vph, 1, UINT32_MAX - 1);
+		break;
+	case 5:
+		/* svp/router_oui */
+		libvarpd_prop_set_name(vph, varpd_svp_props[5]);
+		libvarpd_prop_set_prot(vph, OVERLAY_PROP_PERM_RRW);
+		libvarpd_prop_set_type(vph, OVERLAY_PROP_T_ETHER);
+		libvarpd_prop_set_nodefault(vph);
+		break;
 	default:
 		return (EINVAL);
 	}
@@ -733,14 +889,13 @@ varpd_svp_getprop(void *arg, const char *pname, void *buf, uint32_t *sizep)
 			bcopy(&val, buf, sizeof (uint64_t));
 			*sizep = sizeof (uint64_t);
 		}
-
 		mutex_exit(&svp->svp_lock);
 		return (0);
 	}
 
 	/* svp/underlay_ip */
 	if (strcmp(pname, varpd_svp_props[2]) == 0) {
-		if (*sizep > sizeof (struct in6_addr))
+		if (*sizep < sizeof (struct in6_addr))
 			return (EOVERFLOW);
 		mutex_enter(&svp->svp_lock);
 		if (svp->svp_huip == B_FALSE) {
@@ -749,6 +904,7 @@ varpd_svp_getprop(void *arg, const char *pname, void *buf, uint32_t *sizep)
 			bcopy(&svp->svp_uip, buf, sizeof (struct in6_addr));
 			*sizep = sizeof (struct in6_addr);
 		}
+		mutex_exit(&svp->svp_lock);
 		return (0);
 	}
 
@@ -772,6 +928,42 @@ varpd_svp_getprop(void *arg, const char *pname, void *buf, uint32_t *sizep)
 		return (0);
 	}
 
+	/* svp/dcid */
+	if (strcmp(pname, varpd_svp_props[4]) == 0) {
+		uint64_t val;
+
+		if (*sizep < sizeof (uint64_t))
+			return (EOVERFLOW);
+
+		mutex_enter(&svp->svp_lock);
+		if (svp->svp_uport == 0) {
+			*sizep = 0;
+		} else {
+			val = svp->svp_dcid;
+			bcopy(&val, buf, sizeof (uint64_t));
+			*sizep = sizeof (uint64_t);
+		}
+
+		mutex_exit(&svp->svp_lock);
+		return (0);
+	}
+
+	/* svp/router_oui */
+	if (strcmp(pname, varpd_svp_props[5]) == 0) {
+		if (*sizep < ETHERADDRL)
+			return (EOVERFLOW);
+		mutex_enter(&svp->svp_lock);
+
+		if (ether_is_zero(&svp->svp_router_oui)) {
+			*sizep = 0;
+		} else {
+			bcopy(&svp->svp_router_oui, buf, ETHERADDRL);
+			*sizep = ETHERADDRL;
+		}
+
+		mutex_exit(&svp->svp_lock);
+		return (0);
+	}
 	return (EINVAL);
 }
 
@@ -857,6 +1049,37 @@ varpd_svp_setprop(void *arg, const char *pname, const void *buf,
 		return (0);
 	}
 
+	/* svp/dcid */
+	if (strcmp(pname, varpd_svp_props[4]) == 0) {
+		const uint64_t *valp = buf;
+		if (size < sizeof (uint64_t))
+			return (EOVERFLOW);
+
+		/* XXX KEBE ASKS, use UINT32_MAX instead? */
+		if (*valp == 0 || *valp > UINT32_MAX - 1)
+			return (EINVAL);
+
+		mutex_enter(&svp->svp_lock);
+		svp->svp_dcid = (uint32_t)*valp;
+		mutex_exit(&svp->svp_lock);
+
+		return (0);
+	}
+
+	/* svp/router_oui */
+	if (strcmp(pname, varpd_svp_props[5]) == 0) {
+		if (size < ETHERADDRL)
+			return (EOVERFLOW);
+		mutex_enter(&svp->svp_lock);
+		bcopy(buf, &svp->svp_router_oui, ETHERADDRL);
+		/* Zero-out the low three bytes. */
+		svp->svp_router_oui[3] = 0;
+		svp->svp_router_oui[4] = 0;
+		svp->svp_router_oui[5] = 0;
+		mutex_exit(&svp->svp_lock);
+		return (0);
+	}
+
 	return (EINVAL);
 }
 
@@ -867,6 +1090,7 @@ varpd_svp_save(void *arg, nvlist_t *nvp)
 	svp_t *svp = arg;
 
 	mutex_enter(&svp->svp_lock);
+	/* svp/host */
 	if (svp->svp_host != NULL) {
 		if ((ret = nvlist_add_string(nvp, varpd_svp_props[0],
 		    svp->svp_host)) != 0) {
@@ -875,6 +1099,7 @@ varpd_svp_save(void *arg, nvlist_t *nvp)
 		}
 	}
 
+	/* svp/port */
 	if (svp->svp_port != 0) {
 		if ((ret = nvlist_add_uint16(nvp, varpd_svp_props[1],
 		    svp->svp_port)) != 0) {
@@ -883,6 +1108,7 @@ varpd_svp_save(void *arg, nvlist_t *nvp)
 		}
 	}
 
+	/* svp/underlay_ip */
 	if (svp->svp_huip == B_TRUE) {
 		char buf[INET6_ADDRSTRLEN];
 
@@ -898,6 +1124,7 @@ varpd_svp_save(void *arg, nvlist_t *nvp)
 		}
 	}
 
+	/* svp/underlay_port */
 	if (svp->svp_uport != 0) {
 		if ((ret = nvlist_add_uint16(nvp, varpd_svp_props[3],
 		    svp->svp_uport)) != 0) {
@@ -906,6 +1133,33 @@ varpd_svp_save(void *arg, nvlist_t *nvp)
 		}
 	}
 
+	/* svp/dcid */
+	if (svp->svp_dcid != 0) {
+		if ((ret = nvlist_add_uint32(nvp, varpd_svp_props[4],
+		    svp->svp_dcid)) != 0) {
+			mutex_exit(&svp->svp_lock);
+			return (ret);
+		}
+	}
+
+	/* svp/router_oui */
+	if (!ether_is_zero(&svp->svp_router_oui)) {
+		char buf[ETHERADDRSTRL];
+
+		/* XXX KEBE SAYS See underlay_ip... */
+		if (ether_ntoa_r((struct ether_addr *)&svp->svp_router_oui,
+		    buf) == NULL) {
+			libvarpd_panic("unexpected ether_ntoa_r failure: %d",
+			    errno);
+		}
+
+		if ((ret = nvlist_add_string(nvp, varpd_svp_props[5],
+		    buf)) != 0) {
+			mutex_exit(&svp->svp_lock);
+			return (ret);
+		}
+	}
+
 	mutex_exit(&svp->svp_lock);
 	return (0);
 }
@@ -916,7 +1170,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 {
 	int ret;
 	svp_t *svp;
-	char *ipstr, *hstr;
+	char *ipstr, *hstr, *etherstr;
 
 	if (varpd_svp_valid_dest(dest) == B_FALSE)
 		return (ENOTSUP);
@@ -924,6 +1178,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 	if ((ret = varpd_svp_create(hdl, (void **)&svp, dest)) != 0)
 		return (ret);
 
+	/* svp/host */
 	if ((ret = nvlist_lookup_string(nvp, varpd_svp_props[0],
 	    &hstr)) != 0) {
 		if (ret != ENOENT) {
@@ -937,6 +1192,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 		(void) strlcpy(svp->svp_host, hstr, blen);
 	}
 
+	/* svp/port */
 	if ((ret = nvlist_lookup_uint16(nvp, varpd_svp_props[1],
 	    &svp->svp_port)) != 0) {
 		if (ret != ENOENT) {
@@ -946,6 +1202,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 		svp->svp_port = 0;
 	}
 
+	/* svp/underlay_ip */
 	if ((ret = nvlist_lookup_string(nvp, varpd_svp_props[2],
 	    &ipstr)) != 0) {
 		if (ret != ENOENT) {
@@ -968,6 +1225,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 		svp->svp_huip = B_TRUE;
 	}
 
+	/* svp/underlay_port */
 	if ((ret = nvlist_lookup_uint16(nvp, varpd_svp_props[3],
 	    &svp->svp_uport)) != 0) {
 		if (ret != ENOENT) {
@@ -977,6 +1235,29 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 		svp->svp_uport = 0;
 	}
 
+	/* svp/dcid */
+	if ((ret = nvlist_lookup_uint32(nvp, varpd_svp_props[4],
+	    &svp->svp_dcid)) != 0) {
+		if (ret != ENOENT) {
+			varpd_svp_destroy(svp);
+			return (ret);
+		}
+		svp->svp_dcid = 0;
+	}
+
+	/* svp/router_oui */
+	if ((ret = nvlist_lookup_string(nvp, varpd_svp_props[5],
+	    &etherstr)) != 0) {
+		if (ret != ENOENT) {
+			varpd_svp_destroy(svp);
+			return (ret);
+		}
+		bzero(&svp->svp_router_oui, ETHERADDRL);
+	} else if (ether_aton_r(etherstr,
+	    (struct ether_addr *)&svp->svp_router_oui) == NULL) {
+		libvarpd_panic("unexpected ether_aton_r failure: %d", errno);
+	}
+
 	svp->svp_hdl = hdl;
 	*outp = svp;
 	return (0);
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.h b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
index 8192b842ce..e44f720468 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_SVP_H
@@ -74,6 +74,8 @@ typedef union svp_query_data {
 	svp_vl3_ack_t	sdq_vl3a;
 	svp_log_req_t	sdq_logr;
 	svp_lrm_ack_t	sdq_lrma;
+	svp_route_req_t	sqd_rr;
+	svp_route_ack_t	sqd_ra;
 } svp_query_data_t;
 
 typedef void (*svp_query_f)(svp_query_t *, void *);
@@ -245,6 +247,9 @@ typedef void (*svp_vl3_inject_f)(svp_t *, const uint16_t,
     const struct in6_addr *, const uint8_t *, const uint8_t *);
 typedef void (*svp_shootdown_f)(svp_t *, const uint8_t *,
     const struct in6_addr *, const uint16_t uport);
+typedef void (*svp_route_lookup_f)(svp_t *, svp_status_t, uint32_t, uint32_t,
+    uint16_t, uint8_t *, uint8_t *, uint16_t, uint8_t *, uint8_t, uint8_t,
+    void *);
 
 typedef struct svp_cb {
 	svp_vl2_lookup_f	scb_vl2_lookup;
@@ -252,6 +257,7 @@ typedef struct svp_cb {
 	svp_vl2_invalidation_f	scb_vl2_invalidate;
 	svp_vl3_inject_f	scb_vl3_inject;
 	svp_shootdown_f		scb_shootdown;
+	svp_route_lookup_f	scb_route_lookup;
 } svp_cb_t;
 
 /*
@@ -268,8 +274,11 @@ struct svp {
 	char			*svp_host;	/* svp_lock */
 	uint16_t		svp_port;	/* svp_lock */
 	uint16_t		svp_uport;	/* svp_lock */
+	uint32_t		svp_dcid;	/* svp_lock (but write-once?) */
 	boolean_t		svp_huip;	/* svp_lock */
 	struct in6_addr		svp_uip;	/* svp_lock */
+	/* NOTE: lower-3 bytes are 0s. */
+	uint8_t		svp_router_oui[6];	/* svp_lock (but write-once?) */
 };
 
 extern bunyan_logger_t *svp_bunyan;
@@ -283,6 +292,10 @@ extern void svp_remote_vl3_lookup(svp_t *, svp_query_t *,
     const struct sockaddr *, void *);
 extern void svp_remote_vl2_lookup(svp_t *, svp_query_t *, const uint8_t *,
     void *);
+extern void svp_remote_route_lookup(svp_t *, svp_query_t *,
+    const struct in6_addr *, const struct in6_addr *, uint32_t,
+    uint16_t, void *);
+
 
 /*
  * Init functions
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
index 16dbdbec05..ca16c21886 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_SVP_PROT_H
@@ -34,6 +34,8 @@ extern "C" {
  */
 
 #define	SVP_VERSION_ONE	1
+#define	SVP_VERSION_TWO	2
+/* XXX KEBE SAYS -- we are not yet ready to bump this. */
 #define	SVP_CURRENT_VERSION	SVP_VERSION_ONE
 
 typedef struct svp_req {
@@ -58,7 +60,9 @@ typedef enum svp_op {
 	SVP_R_LOG_ACK		= 0x0A,
 	SVP_R_LOG_RM		= 0x0B,
 	SVP_R_LOG_RM_ACK	= 0x0C,
-	SVP_R_SHOOTDOWN		= 0x0D
+	SVP_R_SHOOTDOWN		= 0x0D,
+	SVP_R_ROUTE_REQ		= 0x0E,
+	SVP_R_ROUTE_ACK		= 0x0F
 } svp_op_t;
 
 typedef enum svp_status {
@@ -70,7 +74,7 @@ typedef enum svp_status {
 } svp_status_t;
 
 /*
- * A client issues the SVP_R_VL2_REQ whenever it needs to perform a VLS->UL3
+ * A client issues the SVP_R_VL2_REQ whenever it needs to perform a VL2->UL3
  * lookup. Requests have the following structure:
  */
 typedef struct svp_vl2_req {
@@ -169,7 +173,8 @@ typedef struct svp_log_req {
  */
 typedef enum svp_log_type {
 	SVP_LOG_VL2	= 0x01,
-	SVP_LOG_VL3	= 0x02
+	SVP_LOG_VL3	= 0x02,
+	SVP_LOG_ROUTE	= 0x03
 } svp_log_type_t;
 
 typedef struct svp_log_vl2 {
@@ -189,6 +194,21 @@ typedef struct svp_log_vl3 {
 	uint32_t	svl3_vnetid;
 } svp_log_vl3_t;
 
+typedef struct svp_log_route {
+	uint32_t	svlr_type;	/* Should be SVP_LOG_ROUTE */
+	uint8_t		svlr_id[16];	/* 16-byte UUID */
+	uint32_t	svlr_src_vnetid;	/* Source VXLAN vnetid. */
+	uint32_t	svlr_dst_vnetid;	/* Dest. VXLAN vnetid. */
+	uint32_t	svlr_dcid;	/* Remote/dest Data Center ID. */
+	uint8_t		svlr_srcip[16];	/* Source IP address base. */
+	uint8_t		svlr_dstip[16];	/* Destination IP address base. */
+	uint16_t	svlr_dst_vlan;	/* Source VLAN id. */
+	uint16_t	svlr_src_vlan;	/* Destination VLAN id. */
+	uint8_t		svlr_src_prefixlen;	/* Source IP prefix length. */
+	uint8_t		svlr_dst_prefixlen;	/* Dest. IP prefix length. */
+	uint16_t	svlr_pad;	/* So we can be aligned... */
+} svp_log_route_t;
+
 typedef struct svp_log_ack {
 	uint32_t	svla_status;
 	uint8_t		svla_data[];
@@ -229,6 +249,38 @@ typedef struct svp_shootdown {
 	uint32_t	svsd_vnetid;
 } svp_shootdown_t;
 
+/*
+ * A route-request (SVP_R_ROUTE_REQ) queries the local SVP server to get a
+ * far-remote (i.e. another Triton Data Center, nee. SDC) SVP server for
+ * far-remote networks.  Modern overlay modules will request IP destinations
+ * for remote-Triton networks, but they must know how to reach the
+ * remote-Triton SVP server.
+ */
+typedef struct svp_route_req {
+	uint32_t	srr_vnetid;	/* Requester's vnet ID. */
+	uint16_t	srr_vlan;	/* Requester's VLAN ID. */
+	uint16_t	srr_pad;	/* Zero on xmit, ignore on receipt. */
+	uint8_t		srr_srcip[16];	/* VL3 Source IP. */
+	uint8_t		srr_dstip[16];	/* VL3 Destination IP. */
+} svp_route_req_t;
+
+/*
+ * The far-remote Triton Data Center will answer with the requisite information
+ * to send overlay packets to the appropriate far-remote CNs.
+ */
+typedef struct svp_route_ack {
+	uint32_t	sra_status;	/* Status. */
+	uint32_t	sra_dcid;	/* Far-remote Data Center ID. */
+	uint32_t	sra_vnetid;	/* Far-remote vnet ID. */
+	uint16_t	sra_vlan;	/* Far-remote VLAN ID. */
+	uint16_t	sra_port;	/* Destination UL3 port. */
+	uint8_t		sra_ip[16];	/* Destination UL3 address. */
+	uint8_t	sra_srcmac[ETHERADDRL];	/* Far-remote VL2 source. */
+	uint8_t	sra_dstmac[ETHERADDRL];	/* Far-remote VL2 dest. */
+	uint8_t		sra_src_pfx;	/* Far-remote VL3 source prefix */
+	uint8_t		sra_dst_pfx;	/* Far-remote VL3 dest. prefix */
+} svp_route_ack_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
index 8d482e4a12..50e31b6e97 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -245,6 +245,8 @@ svp_remote_attach(svp_remote_t *srp, svp_t *svp)
 		libvarpd_panic("missing callback scb_vl2_invalidate");
 	if (svp->svp_cb.scb_vl3_inject == NULL)
 		libvarpd_panic("missing callback scb_vl3_inject");
+	if (svp->svp_cb.scb_route_lookup == NULL)
+		libvarpd_panic("missing callback scb_route_lookup");
 
 	check.svp_vid = svp->svp_vid;
 	if (avl_find(&srp->sr_tree, &check, &where) != NULL)
@@ -351,6 +353,61 @@ svp_remote_vl2_lookup(svp_t *svp, svp_query_t *sqp, const uint8_t *mac,
 	mutex_exit(&srp->sr_lock);
 }
 
+static void
+svp_remote_route_lookup_cb(svp_query_t *sqp, void *arg)
+{
+	svp_t *svp = sqp->sq_svp;
+	svp_route_ack_t *sra = (svp_route_ack_t *)sqp->sq_wdata;
+
+	if (sqp->sq_status == SVP_S_OK) {
+		svp->svp_cb.scb_route_lookup(svp, sqp->sq_status,
+		    sra->sra_dcid, sra->sra_vnetid, sra->sra_vlan,
+		    sra->sra_srcmac, sra->sra_dstmac, sra->sra_port,
+		    sra->sra_ip, sra->sra_src_pfx, sra->sra_dst_pfx, arg);
+	} else {
+		svp->svp_cb.scb_route_lookup(svp, sqp->sq_status,
+		    0, 0, 0, NULL, NULL, 0, NULL, 0, 0, arg);
+	}
+}
+
+void
+svp_remote_route_lookup(svp_t *svp, svp_query_t *sqp,
+    const struct in6_addr *src, const struct in6_addr *dst, uint32_t vnetid,
+    uint16_t vlan, void *arg)
+{
+	svp_remote_t *srp;
+	svp_route_req_t *srr = &sqp->sq_rdun.sqd_rr;
+
+	srp = svp->svp_remote;
+	sqp->sq_func = svp_remote_route_lookup_cb;
+	sqp->sq_arg = arg;
+	sqp->sq_svp = svp;
+	sqp->sq_state = SVP_QUERY_INIT;
+	sqp->sq_header.svp_ver = htons(SVP_CURRENT_VERSION);
+	sqp->sq_header.svp_op = htons(SVP_R_ROUTE_REQ);
+	sqp->sq_header.svp_size = htonl(sizeof (svp_route_req_t));
+	sqp->sq_header.svp_id = id_alloc(svp_idspace);
+	if (sqp->sq_header.svp_id == (id_t)-1)
+		libvarpd_panic("failed to allcoate from svp_idspace: %d",
+		    errno);
+	sqp->sq_header.svp_crc32 = htonl(0);
+	sqp->sq_rdata = srr;
+
+	bcopy(src, srr->srr_srcip, sizeof (struct in6_addr));
+	bcopy(dst, srr->srr_dstip, sizeof (struct in6_addr));
+	/* Caller should've checked both are the same type... */
+	srr->srr_vnetid = vnetid;
+	srr->srr_vlan = vlan;
+	srr->srr_pad = 0;
+
+	mutex_enter(&srp->sr_lock);
+	if (!svp_remote_conn_queue(srp, sqp)) {
+		sqp->sq_status = SVP_S_FATAL;
+		sqp->sq_func(sqp, arg);
+	}
+	mutex_exit(&srp->sr_lock);
+}
+
 static void
 svp_remote_vl3_lookup_cb(svp_query_t *sqp, void *arg)
 {
diff --git a/usr/src/man/man1m/dladm.1m b/usr/src/man/man1m/dladm.1m
index c647cd7f19..544e58e4e8 100644
--- a/usr/src/man/man1m/dladm.1m
+++ b/usr/src/man/man1m/dladm.1m
@@ -176,7 +176,7 @@ dladm \- administer data links
 
 .LP
 .nf
-\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR \fB-v\fR \fIvnetid\fR [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
+\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR \fB-v\fR \fIvnetid\fR [\fB-d\fR \fIdcid\fR] [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
 \fBdladm delete-overlay\fR \fIoverlay\fR
 \fBdladm modify-overlay\fR \fB-d\fR \fImac\fR | \fB-f\fR | \fB-s\fR \fImac=ip:port\fR \fIoverlay\fR
 \fBdladm show-overlay\fR [ \fB-f\fR | \fB-t\fR ] [[\fB-p\fR] \fB-o\fR \fIfield\fR[,...]] [\fIoverlay\fR]
@@ -4446,8 +4446,8 @@ The tunnel destination address.
 .sp
 .ne 2
 .na
-\fBdladm create-overlay\fR \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR
-\fB-v\fR \fIvnetid\fR [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
+\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR
+\fB-v\fR \fIvnetid\fR [\fB-d\fR \fIdcid\fR] [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
 .ad
 .sp .6
 .RS 4n
@@ -4501,6 +4501,16 @@ Use \fIsearch\fR as the search plugin for \fIoverlay\fR. The search plugin
 determines how non-local targets are found and where packets are directed to.
 .RE
 
+.sp
+.ne 2
+.na
+\fB\fB-d\fR \fIdcid\fR
+.ad
+.sp .6
+.RS 4n
+Set the datacenter id to \fIdcid\fR.
+.RE
+
 .sp
 .ne 2
 .na
diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index 3f34ec3b58..c2f79d06ef 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -205,6 +205,10 @@
  * 		UTF-8. Note that the size of the string includes the null
  * 		terminator.
  *
+ * 	OVERLAY_PROP_T_ETHER
+ *
+ *		An ether_addr_t, which has a fixed size.
+ *
  * The next thing that we apply to a property is its permission. The permissions
  * are put together by the bitwise or of the following flags and values.
  *
@@ -830,15 +834,17 @@ typedef enum overlay_dev_prop {
 	OVERLAY_DEV_P_MTU = 0,
 	OVERLAY_DEV_P_VNETID,
 	OVERLAY_DEV_P_ENCAP,
-	OVERLAY_DEV_P_VARPDID
+	OVERLAY_DEV_P_VARPDID,
+	OVERLAY_DEV_P_DCID
 } overlay_dev_prop_t;
 
-#define	OVERLAY_DEV_NPROPS	4
+#define	OVERLAY_DEV_NPROPS	5
 static const char *overlay_dev_props[] = {
 	"mtu",
 	"vnetid",
 	"encap",
-	"varpd/id"
+	"varpd/id",
+	"dcid"
 };
 
 #define	OVERLAY_MTU_MIN	576
@@ -1076,6 +1082,11 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 		mp->b_next = NULL;
 		ep = NULL;
 
+		/*
+		 * TODO: we probably need to change 'storage' to a
+		 * refheld overlay_target_entry_t and also maybe set
+		 * local vlan from packet header for check below
+		 */
 		ret = overlay_target_lookup(odd, mp,
 		    (struct sockaddr *)&storage, &slen);
 		if (ret != OVERLAY_TARGET_OK) {
@@ -1085,6 +1096,17 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 			continue;
 		}
 
+		/*
+		 * TODO:
+		 *	set hdr.msg_name from target_entry
+		 *
+		 *	if !local:
+		 *		check fabric attachment
+		 *		modify vlan tag, VL2 mac addresses
+		 *
+		 *	set einfo.ovdi_id to vnet id (move into loop since
+		 *	things cannot assume to all have same vnet id anymore)
+		 */
 		hdr.msg_name = &storage;
 		hdr.msg_namelen = slen;
 
@@ -1260,6 +1282,14 @@ overlay_i_create(void *karg, intptr_t arg, int mode, cred_t *cred, int *rvalp)
 	}
 	odd->odd_vid = oicp->oic_vnetid;
 
+	if (oicp->oic_dcid > UINT32_MAX) {
+		odd->odd_plugin->ovp_ops->ovpo_fini(odd->odd_pvoid);
+		overlay_plugin_rele(odd->odd_plugin);
+		kmem_free(odd, sizeof (overlay_dev_t));
+		return (EINVAL);
+	}
+	odd->odd_dcid = oicp->oic_dcid;
+
 	mac = mac_alloc(MAC_VERSION);
 	if (mac == NULL) {
 		mutex_exit(&overlay_dev_lock);
@@ -1695,6 +1725,12 @@ overlay_i_propinfo(void *karg, intptr_t arg, int mode, cred_t *cred,
 		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
 		overlay_prop_set_nodefault(phdl);
 		break;
+	case OVERLAY_DEV_P_DCID:
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_READ);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_nodefault(phdl);
+		overlay_prop_set_range_uint32(phdl, 0, UINT32_MAX);
+		break;
 	default:
 		overlay_hold_rele(odd);
 		mac_perim_exit(mph);
@@ -1804,6 +1840,18 @@ overlay_i_getprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 		}
 		mutex_exit(&odd->odd_lock);
 		break;
+	case OVERLAY_DEV_P_DCID:
+		/*
+		 * While it's read-only while inside of a mux, we're not in a
+		 * context that can guarantee that. Therefore we always grab the
+		 * overlay_dev_t's odd_lock.
+		 */
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_dcid, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
+
 	default:
 		ret = ENOENT;
 	}
@@ -1845,6 +1893,38 @@ overlay_setprop_vnetid(overlay_dev_t *odd, uint64_t vnetid)
 	mutex_exit(&odd->odd_lock);
 }
 
+static void
+overlay_setprop_dcid(overlay_dev_t *odd, uint32_t dcid)
+{
+	mutex_enter(&odd->odd_lock);
+
+	/* Simple case, not active */
+	if (!(odd->odd_flags & OVERLAY_F_IN_MUX)) {
+		odd->odd_dcid = dcid;
+		mutex_exit(&odd->odd_lock);
+		return;
+	}
+
+	/*
+	 * In the hard case, we need to set the drop flag, quiesce I/O and then
+	 * we can go ahead and do everything.
+	 */
+	odd->odd_flags |= OVERLAY_F_MDDROP;
+	overlay_io_wait(odd, OVERLAY_F_IOMASK);
+	mutex_exit(&odd->odd_lock);
+
+	overlay_mux_remove_dev(odd->odd_mux, odd);
+	mutex_enter(&odd->odd_lock);
+	odd->odd_dcid = dcid;
+	mutex_exit(&odd->odd_lock);
+	overlay_mux_add_dev(odd->odd_mux, odd);
+
+	mutex_enter(&odd->odd_lock);
+	ASSERT(odd->odd_flags & OVERLAY_F_IN_MUX);
+	odd->odd_flags &= ~OVERLAY_F_IN_MUX;
+	mutex_exit(&odd->odd_lock);
+}
+
 /* ARGSUSED */
 static int
 overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
@@ -1855,7 +1935,7 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 	overlay_ioc_prop_t *oip = karg;
 	uint_t propid = UINT_MAX;
 	mac_perim_handle_t mph;
-	uint64_t maxid, *vidp;
+	uint64_t maxid, *vidp, *dcidp;
 
 	if (oip->oip_size > OVERLAY_PROP_SIZEMAX)
 		return (EINVAL);
@@ -1941,6 +2021,19 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 	case OVERLAY_DEV_P_VARPDID:
 		ret = EPERM;
 		break;
+	case OVERLAY_DEV_P_DCID:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		dcidp = (uint64_t *)oip->oip_value;
+		if (*dcidp > UINT32_MAX) {
+			ret = EINVAL;
+			break;
+		}
+		overlay_setprop_dcid(odd, *dcidp);
+		break;
+
 	default:
 		ret = ENOENT;
 	}
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index f4147b56d1..cb79bfdfdb 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -141,6 +141,8 @@ overlay_entry_cache_destructor(void *buf, void *arg)
 	mutex_destroy(&ote->ote_lock);
 }
 
+/* TODO: we will need to modify these to hash/cmp DCID + MAC */
+
 static uint64_t
 overlay_mac_hash(const void *v)
 {
@@ -237,6 +239,8 @@ overlay_target_free(overlay_dev_t *odd)
 		avl_tree_t *ap = &odd->odd_target->ott_u.ott_dyn.ott_tree;
 		overlay_target_entry_t *ote;
 
+		/* TODO: remove from L3 trees */
+
 		/*
 		 * Our AVL tree and hashtable contain the same elements,
 		 * therefore we should just remove it from the tree, but then
@@ -303,6 +307,10 @@ overlay_target_quiesce(overlay_target_t *ott)
  * This functions assumes that the destination mode is OVERLAY_PLUGIN_D_IP |
  * OVERLAY_PLUGIN_D_PORT. As we don't have an implementation of anything else at
  * this time, say for NVGRE, we drop all packets that mcuh this.
+ *
+ * XXX: It might be better to replace the 'sock' argument with
+ * overlay_target_entry_t** and set it with the found entry in the case
+ * of OVERLAY_TARGET_OK.
  */
 int
 overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
@@ -350,6 +358,16 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 	 */
 	if (mac_header_info(odd->odd_mh, mp, &mhi) != 0)
 		return (OVERLAY_TARGET_DROP);
+
+	/*
+	 * TODO: compare mhi.mhi_daddr with odd->macaddr.
+	 * If match,
+	 * 	get VL3 dest from mp
+	 * 	lookup target using VL3 dest
+	 * otherwise,
+	 * 	lookup target using VL2 dest (existing refhash_lookup() call
+	 * 	below)
+	 */
 	mutex_enter(&ott->ott_lock);
 	entry = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
 	    mhi.mhi_daddr);
@@ -360,6 +378,11 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 			mutex_exit(&ott->ott_lock);
 			return (OVERLAY_TARGET_DROP);
 		}
+		/*
+		 * TODO: set entry->ote_dcid, if VL3 lookup, copy dst addr
+		 * into entry->ote_ip.  Probably zero out the address we're
+		 * not lookup up (VL2 or VL3) as well.
+		 */
 		bcopy(mhi.mhi_daddr, entry->ote_addr, ETHERADDRL);
 		entry->ote_chead = entry->ote_ctail = mp;
 		entry->ote_mbsize = msgsize(mp);
@@ -437,6 +460,7 @@ overlay_target_info(overlay_target_hdl_t *thdl, void *arg)
 	if (odd->odd_flags & OVERLAY_F_ACTIVATED)
 		oti->oti_flags |= OVERLAY_TARG_INFO_F_ACTIVE;
 	oti->oti_vnetid = odd->odd_vid;
+	oti->oti_dcid = odd->odd_dcid;
 	mutex_exit(&odd->odd_lock);
 	overlay_hold_rele(odd);
 	return (0);
@@ -630,6 +654,13 @@ again:
 		goto again;
 	}
 
+	/*
+	 * TODO: If VL3 request,
+	 *	set otl->otl_l3req
+	 *	Fill in otl_{src,dst}ip
+	 * Else
+	 *	clear otl->otl_l3req
+	 */
 	otl->otl_dlid = entry->ote_odd->odd_linkid;
 	otl->otl_reqid = (uintptr_t)entry;
 	otl->otl_varpdid = entry->ote_ott->ott_id;
@@ -637,10 +668,10 @@ again:
 
 	otl->otl_hdrsize = mhi.mhi_hdrsize;
 	otl->otl_pktsize = msgsize(entry->ote_chead) - otl->otl_hdrsize;
-	bcopy(mhi.mhi_daddr, otl->otl_dstaddr, ETHERADDRL);
-	bcopy(mhi.mhi_saddr, otl->otl_srcaddr, ETHERADDRL);
-	otl->otl_dsttype = mhi.mhi_dsttype;
-	otl->otl_sap = mhi.mhi_bindsap;
+	bcopy(mhi.mhi_daddr, otl->otl_addru.otlu_l2.otl2_dstaddr, ETHERADDRL);
+	bcopy(mhi.mhi_saddr, otl->otl_addru.otlu_l2.otl2_srcaddr, ETHERADDRL);
+	otl->otl_addru.otlu_l2.otl2_dsttype = mhi.mhi_dsttype;
+	otl->otl_addru.otlu_l2.otl2_sap = mhi.mhi_bindsap;
 	otl->otl_vlan = VLAN_ID(mhi.mhi_tci);
 	mutex_exit(&entry->ote_lock);
 
@@ -686,6 +717,11 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 
 	/*
 	 * For now do an in-situ drain.
+	 *
+	 * TODO: overlay_m_tx() will need to perform remote fabric attachment
+	 * checks, which may leave mblk_t's left in the msg chain for
+	 * mblk_t's whose connectivity with the target entry are unknown.
+	 * This will then need to deal with the leftovers.
 	 */
 	mp = overlay_m_tx(entry->ote_odd, mp);
 	freemsgchain(mp);
@@ -731,6 +767,15 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 		goto done;
 	}
 
+	/*
+	 * TODO: This will need to be smarter.  This drop can only apply to
+	 * packets from the same source fabric as the first mblk_t in the
+	 * chain.  If the target exists, packets from other fabrics which
+	 * are chained to this target entry may be able to be sent (if we
+	 * already know they are attached), or we might need to query from
+	 * those other source fabrics if we don't know if the two are
+	 * attached.
+	 */
 	mp = entry->ote_chead;
 	if (mp != NULL) {
 		entry->ote_chead = mp->b_next;
diff --git a/usr/src/uts/common/sys/ethernet.h b/usr/src/uts/common/sys/ethernet.h
index 5b9de2f2bf..f19912bfc3 100644
--- a/usr/src/uts/common/sys/ethernet.h
+++ b/usr/src/uts/common/sys/ethernet.h
@@ -23,6 +23,8 @@
  *
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -139,6 +141,18 @@ struct ether_vlan_extinfo {
 #define	ether_copy(a, b) (bcopy((caddr_t)a, (caddr_t)b, 6))
 #endif
 
+/*
+ * Ethernet is-zero check
+ */
+#if defined(__sparc) || defined(__i386) || defined(__amd64)
+#define	ether_is_zero(a) \
+	(((short *)a)[0] == 0 && ((short *)a)[1] == 0 && ((short *)a)[2] == 0)
+#else
+#define	ether_is_zero(a) (((uint8_t *)a)[0] == 0 && ((uint8_t *)a)[1] == 0 && \
+	((uint8_t *)a)[2] == 0 && ((uint8_t *)a)[3] == 0 && \
+	((uint8_t *)a)[4] == 0 && ((uint8_t *)a)[5] == 0)
+#endif
+
 #ifdef	_KERNEL
 extern int localetheraddr(struct ether_addr *, struct ether_addr *);
 extern char *ether_sprintf(struct ether_addr *);
diff --git a/usr/src/uts/common/sys/overlay.h b/usr/src/uts/common/sys/overlay.h
index 12d0dbca51..90f1843282 100644
--- a/usr/src/uts/common/sys/overlay.h
+++ b/usr/src/uts/common/sys/overlay.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #ifndef _SYS_OVERLAY_H
@@ -40,7 +40,7 @@ extern "C" {
 
 typedef struct overlay_ioc_create {
 	datalink_id_t	oic_linkid;
-	uint32_t	oic_filler;
+	uint32_t	oic_dcid;
 	uint64_t	oic_vnetid;
 	char		oic_encap[MAXLINKNAMELEN];
 } overlay_ioc_create_t;
diff --git a/usr/src/uts/common/sys/overlay_common.h b/usr/src/uts/common/sys/overlay_common.h
index d638096006..de682a0397 100644
--- a/usr/src/uts/common/sys/overlay_common.h
+++ b/usr/src/uts/common/sys/overlay_common.h
@@ -42,7 +42,8 @@ typedef enum overlay_prop_type {
 	OVERLAY_PROP_T_INT = 0x1,	/* signed int */
 	OVERLAY_PROP_T_UINT,		/* unsigned int */
 	OVERLAY_PROP_T_IP,		/* sinaddr6 */
-	OVERLAY_PROP_T_STRING		/* OVERLAY_PROPS_SIZEMAX */
+	OVERLAY_PROP_T_STRING,		/* OVERLAY_PROPS_SIZEMAX */
+	OVERLAY_PROP_T_ETHER		/* 6-byte MAC address */
 } overlay_prop_type_t;
 
 typedef enum overlay_prop_prot {
diff --git a/usr/src/uts/common/sys/overlay_impl.h b/usr/src/uts/common/sys/overlay_impl.h
index 7fb8b8da1d..7d42bfca19 100644
--- a/usr/src/uts/common/sys/overlay_impl.h
+++ b/usr/src/uts/common/sys/overlay_impl.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _SYS_OVERLAY_IMPL_H
@@ -59,7 +59,7 @@ typedef struct overlay_mux {
 	int			omux_domain;	/* RO: socket domain */
 	int			omux_family;	/* RO: socket family */
 	int			omux_protocol;	/* RO: socket protocol */
-	struct sockaddr 	*omux_addr;	/* RO: socket address */
+	struct sockaddr		*omux_addr;	/* RO: socket address */
 	socklen_t		omux_alen;	/* RO: sockaddr len */
 	kmutex_t		omux_lock;	/* Protects everything below */
 	uint_t			omux_count;	/* Active instances */
@@ -82,11 +82,41 @@ typedef struct overlay_target {
 		overlay_target_point_t	ott_point;
 		struct overlay_target_dyn {
 			refhash_t	*ott_dhash;
+			refhash_t	*ott_l3dhash;
 			avl_tree_t	ott_tree;
+			/* XXX: Do we actually need a tree sorted by VL3? */
+			avl_tree_t	ott_l3tree;
 		} ott_dyn;
 	} ott_u;
 } overlay_target_t;
 
+/*
+ * Initially at least, we represent a group of fabrics that are attached to
+ * each other as a circular linked list.  Within an overlay_dev_t, we then
+ * maintain a list of pointers into these lists for each fabric that's
+ * present locally on the CN as we learn them:
+ *
+ */
+typedef struct overlay_fabric_attach {
+	struct overlay_fabric_attach *ofa_next;
+	struct in6_addr	ofa_addr;
+	uint32_t	ofa_dcid;
+	uint16_t	ofa_vlan;
+	uint8_t		ofa_prefixlen;
+	uint8_t		ofa_pad;
+} overlay_fabric_attach_t;
+
+/*
+ * Since we have two different refhashes for an overlay_target_entry_t
+ * (VL2 aka MAC address and VL3 aka IP address), we want to maintain
+ * the refcount in only one place. We elect to use the ott_dhash
+ * refhash to do so.
+ */
+#define	OVERLAY_TARGET_ENTRY_HOLD(tgt, e) \
+	refhash_hold((tgt)->ott_u.ott_dyn.ott_dhash, e)
+#define	OVERLAY_TARGET_ENTRY_RELE(tgt, e) \
+	refhash_rele((tgt)->ott_u.ott_dyn.ott_dhash, e)
+
 typedef enum overlay_dev_flag {
 	OVERLAY_F_ACTIVATED	= 0x01, /* Activate ioctl completed */
 	OVERLAY_F_IN_MUX	= 0x02,	/* Currently in a mux */
@@ -117,6 +147,9 @@ typedef struct overlay_dev {
 	uint64_t	odd_vid;		/* RO if active else odd_lock */
 	avl_node_t	odd_muxnode;		/* managed by mux */
 	overlay_target_t *odd_target;		/* See big theory statement */
+	overlay_fabric_attach_t **odd_fattach;	/* protected by odd_lock */
+	uint32_t	odd_dcid;		/* RO if active else odd_lock */
+	uint8_t		odd_macaddr[ETHERADDRL]; /* RO same as odd_dcid */
 	char		odd_fmamsg[OVERLAY_STATUS_BUFLEN];	/* odd_lock */
 } overlay_dev_t;
 
@@ -130,10 +163,15 @@ typedef enum overlay_target_entry_flags {
 typedef struct overlay_target_entry {
 	kmutex_t		ote_lock;
 	refhash_link_t		ote_reflink;	/* hashtable link */
+	refhash_link_t		ote_l3_reflink;	/* IP hashtable link */
 	avl_node_t		ote_avllink;	/* iteration link */
+	avl_node_t		ote_l3_avllink;	/* IP iteration link */
 	list_node_t		ote_qlink;
 	overlay_target_entry_flags_t ote_flags;	/* RW: state flags */
+	uint32_t		ote_dcid;
+	uint16_t		ote_vlan;	/* RO: VL3 vlan id */
 	uint8_t			ote_addr[ETHERADDRL];	/* RO: mac addr */
+	struct in6_addr		ote_ip;		/* RO: VL3 IP */
 	overlay_target_t	*ote_ott;	/* RO */
 	overlay_dev_t		*ote_odd;	/* RO */
 	overlay_target_point_t	ote_dest;	/* RW: destination */
@@ -143,7 +181,6 @@ typedef struct overlay_target_entry {
 	hrtime_t		ote_vtime;	/* RW: valid timestamp */
 } overlay_target_entry_t;
 
-
 #define	OVERLAY_CTL	"overlay"
 
 extern dev_info_t *overlay_dip;
diff --git a/usr/src/uts/common/sys/overlay_target.h b/usr/src/uts/common/sys/overlay_target.h
index cae193c334..b205266baf 100644
--- a/usr/src/uts/common/sys/overlay_target.h
+++ b/usr/src/uts/common/sys/overlay_target.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2015 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 #ifndef _OVERLAY_TARGET_H
@@ -29,12 +29,33 @@
 extern "C" {
 #endif
 
+/*
+ * The overlay_target_point_t structure represents the destination where
+ * encapsulated frames are sent.  Currently supported virtualization protocls
+ * (i.e. vxlan) only use otp_ip and otp_port, but other methods might use
+ * a L2 address instead of an L3 address to represent a destination.
+ */
 typedef struct overlay_target_point {
 	uint8_t		otp_mac[ETHERADDRL];
 	struct in6_addr	otp_ip;
 	uint16_t	otp_port;
 } overlay_target_point_t;
 
+/*
+ * The overlay_target_route_t represents the information necessary to send
+ * packets to remote (routed) destinations.  Note: we currently only include
+ * the L3 address prefix lengths since overlay can deduce the subnet address
+ * from the original VL3 IP in the request + the prefix length in the reply.
+ */
+typedef struct overlay_target_route {
+	uint64_t	otr_vnet;
+	uint16_t	otr_vlan;
+	uint8_t		otr_srcmac[ETHERADDRL];
+	uint32_t	otr_dcid;
+	uint8_t		otr_src_prefixlen;
+	uint8_t		otr_dst_prefixlen;
+} overlay_target_route_t;
+
 #define	OVERLAY_TARG_IOCTL	(('o' << 24) | ('v' << 16) | ('t' << 8))
 
 #define	OVERLAY_TARG_INFO	(OVERLAY_TARG_IOCTL | 0x01)
@@ -52,6 +73,7 @@ typedef struct overlay_targ_info {
 	uint32_t		oti_needs;
 	uint64_t		oti_flags;
 	uint64_t		oti_vnetid;
+	uint32_t		oti_dcid;
 } overlay_targ_info_t;
 
 /*
@@ -134,7 +156,7 @@ typedef struct overlay_targ_id {
  *
  * 		This ioctl can be used to copy data from a given request into a
  * 		user buffer. This can be used in combination with
- * 		OVERLAY_TARG_INJECT to implemnt services such as a proxy-arp.
+ * 		OVERLAY_TARG_INJECT to implement services such as a proxy-arp.
  *
  *
  * 	OVERLAY_TARG_RESEND - overlay_targ_pkt_t
@@ -152,6 +174,18 @@ typedef struct overlay_targ_id {
 #define	OVERLAY_TARG_PKT	(OVERLAY_TARG_IOCTL | 0x14)
 #define	OVERLAY_TARG_RESEND	(OVERLAY_TARG_IOCTL | 0x15)
 
+typedef struct overlay_targ_l2 {
+	uint8_t		otl2_srcaddr[ETHERADDRL];
+	uint8_t		otl2_dstaddr[ETHERADDRL];
+	uint32_t	otl2_dsttype;
+	uint32_t	otl2_sap;
+} overlay_targ_l2_t;
+
+typedef struct overlay_targ_l3 {
+	struct in6_addr	otl3_srcip;
+	struct in6_addr	otl3_dstip;
+} overlay_targ_l3_t;
+
 typedef struct overlay_targ_lookup {
 	uint64_t	otl_dlid;
 	uint64_t	otl_reqid;
@@ -159,16 +193,19 @@ typedef struct overlay_targ_lookup {
 	uint64_t	otl_vnetid;
 	uint64_t	otl_hdrsize;
 	uint64_t	otl_pktsize;
-	uint8_t		otl_srcaddr[ETHERADDRL];
-	uint8_t		otl_dstaddr[ETHERADDRL];
-	uint32_t	otl_dsttype;
-	uint32_t	otl_sap;
+	union {
+		overlay_targ_l2_t	otlu_l2;
+		overlay_targ_l3_t	otlu_l3;
+	} otl_addru;
 	int32_t		otl_vlan;
+	boolean_t	otl_l3req;
 } overlay_targ_lookup_t;
 
+
 typedef struct overlay_targ_resp {
 	uint64_t	otr_reqid;
 	overlay_target_point_t otr_answer;
+	overlay_target_route_t otr_route; /* Ignored for VL2->UL3 requests */
 } overlay_targ_resp_t;
 
 typedef struct overlay_targ_pkt {
@@ -269,6 +306,7 @@ typedef struct overlay_targ_list {
 typedef struct overlay_targ_cache_entry {
 	uint8_t			otce_mac[ETHERADDRL];
 	uint16_t		otce_flags;
+	uint32_t		otce_dcid;
 	overlay_target_point_t	otce_dest;
 } overlay_targ_cache_entry_t;
 
-- 
2.21.0

