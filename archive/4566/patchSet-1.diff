From 01fc88188348c8ddac9713453fb5e424c57dd7c1 Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Fri, 20 Jul 2018 17:29:49 +0200
Subject: [PATCH] OS-7089 exec_init() should be able to handle a 64bit init
 process

---
 usr/src/uts/common/os/main.c | 49 +++++++++++++++++++++++++-----------
 1 file changed, 34 insertions(+), 15 deletions(-)

diff --git a/usr/src/uts/common/os/main.c b/usr/src/uts/common/os/main.c
index dda0b3e4a6..da07d06924 100644
--- a/usr/src/uts/common/os/main.c
+++ b/usr/src/uts/common/os/main.c
@@ -24,10 +24,10 @@
  */
 
 /*	Copyright (c) 1988 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*	  All Rights Reserved		*/
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -145,13 +145,12 @@ char initargs[BOOTARGS_MAX] = "";		/* also referenced by zone0 */
 int
 exec_init(const char *initpath, const char *args)
 {
-	caddr32_t ucp;
-	caddr32_t *uap;
-	caddr32_t *argv;
-	caddr32_t exec_fnamep;
+	uintptr_t ucp, *uap, *argv;
+	uintptr32_t *uap32, *argv32;
+	uintptr_t exec_fnamep;
 	char *scratchargs;
 	int i, sarg;
-	size_t argvlen, alen;
+	size_t argvlen, argv32len, alen;
 	boolean_t in_arg;
 	int argc = 0;
 	int error = 0, count = 0;
@@ -181,9 +180,12 @@ exec_init(const char *initpath, const char *args)
 			in_arg = B_TRUE;
 		}
 	}
-	argvlen = sizeof (caddr32_t) * (argc + 1);
+	argvlen = sizeof (uintptr_t) * (argc + 1);
 	argv = kmem_zalloc(argvlen, KM_SLEEP);
 
+	argv32len = sizeof (caddr32_t) * (argc + 1);
+	argv32 = kmem_zalloc(argv32len, KM_SLEEP);
+
 	/*
 	 * We pull off a bit of a hack here.  We work our way through the
 	 * args string, putting nulls at the ends of space delimited tokens
@@ -199,7 +201,7 @@ exec_init(const char *initpath, const char *args)
 	 *	-0x05 -  <------. |
 	 *	-0x06 \0	| |
 	 *	-0x07 t		| |
-	 *	-0x08 i 	| |
+	 *	-0x08 i	| |
 	 *	-0x09 n		| |
 	 *	-0x0a i  <---.  | |
 	 *	-0x10 NULL   |  | |	(argv[3])
@@ -213,7 +215,7 @@ exec_init(const char *initpath, const char *args)
 	 * stack ptr, and sarg is the string index of the start of the
 	 * argument.
 	 */
-	ucp = (caddr32_t)(uintptr_t)p->p_usrstack;
+	ucp = (uintptr_t)p->p_usrstack;
 
 	argc = 0;
 	in_arg = B_FALSE;
@@ -224,6 +226,8 @@ exec_init(const char *initpath, const char *args)
 			if (in_arg == B_TRUE) {
 				in_arg = B_FALSE;
 				scratchargs[i] = '\0';
+				argv32[argc] =
+				    (uintptr32_t)(ucp - (alen - sarg));
 				argv[argc++] = ucp - (alen - sarg);
 			}
 		} else if (in_arg == B_FALSE) {
@@ -234,28 +238,43 @@ exec_init(const char *initpath, const char *args)
 	ucp -= alen;
 	error |= copyout(scratchargs, (caddr_t)(uintptr_t)ucp, alen);
 
-	uap = (caddr32_t *)P2ALIGN((uintptr_t)ucp, sizeof (caddr32_t));
-	uap--;	/* advance to be below the word we're in */
-	uap -= (argc + 1);	/* advance argc words down, plus one for NULL */
-	error |= copyout(argv, uap, argvlen);
+	if (p->p_model == DATAMODEL_ILP32) {
+		uap32 = (uintptr32_t *)
+		    P2ALIGN((uintptr_t)ucp, sizeof (uintptr32_t));
+		/* advance to be below the word we're in */
+		uap32--;
+		/* advance argc words down, plus one for NULL */
+		uap32 -= (argc + 1);
+		error |= copyout(argv32, uap32, argv32len);
+		uap = (uintptr_t *)uap32;
+	} else {
+		uap = (uintptr_t *)P2ALIGN((uintptr_t)ucp, sizeof (uintptr_t));
+		/* advance to be below the word we're in */
+		uap--;
+		/* advance argc words down, plus one for NULL */
+		uap -= (argc + 1);
+		error |= copyout(argv, uap, argvlen);
+	}
 
 	if (error != 0) {
 		zcmn_err(p->p_zone->zone_id, CE_WARN,
 		    "Could not construct stack for init.\n");
 		kmem_free(argv, argvlen);
+		kmem_free(argv32, argv32len);
 		kmem_free(scratchargs, alen);
 		return (EFAULT);
 	}
 
 	exec_fnamep = argv[0];
 	kmem_free(argv, argvlen);
+	kmem_free(argv32, argv32len);
 	kmem_free(scratchargs, alen);
 
 	/*
 	 * Point at the arguments.
 	 */
 	lwp->lwp_ap = lwp->lwp_arg;
-	lwp->lwp_arg[0] = (uintptr_t)exec_fnamep;
+	lwp->lwp_arg[0] = exec_fnamep;
 	lwp->lwp_arg[1] = (uintptr_t)uap;
 	lwp->lwp_arg[2] = NULL;
 	curthread->t_post_sys = 1;
-- 
2.21.0

