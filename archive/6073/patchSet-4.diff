From f329a476010462a7e25b134fe6d1e0d529eb00a0 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Fri, 8 Mar 2019 16:25:14 +0000
Subject: [PATCH] OS-7625 loader fails to boot Dell R510 in UEFI mode OS-7644
 mnode_range_setup() makes assumptions about mnodes

---
 usr/src/boot/sys/boot/common/multiboot2.c |  72 +++++++++-----
 usr/src/uts/i86pc/vm/vm_machdep.c         | 115 +++++++++++-----------
 2 files changed, 103 insertions(+), 84 deletions(-)

diff --git a/usr/src/boot/sys/boot/common/multiboot2.c b/usr/src/boot/sys/boot/common/multiboot2.c
index 67c28b1528..9b0bee2f9c 100644
--- a/usr/src/boot/sys/boot/common/multiboot2.c
+++ b/usr/src/boot/sys/boot/common/multiboot2.c
@@ -13,6 +13,10 @@
  * Copyright 2017 Toomas Soome <tsoome@me.com>
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * This module adds support for loading and booting illumos multiboot2
  * kernel. This code is only built to support the illumos kernel, it does
@@ -799,11 +803,26 @@ mbi_size(struct preloaded_file *fp, char *cmdline)
 	return (size);
 }
 
+#if defined(EFI)
+static bool
+overlaps(uintptr_t start1, size_t size1, uintptr_t start2, size_t size2)
+{
+	if (start1 < start2 + size2 &&
+	    start1 + size1 >= start2) {
+		printf("overlaps: %zx-%zx, %zx-%zx\n",
+		    start1, start1 + size1, start2, start2 + size2);
+		return (true);
+	}
+
+	return (false);
+}
+#endif
+
 static int
 multiboot2_exec(struct preloaded_file *fp)
 {
+	multiboot2_info_header_t *mbi = NULL;
 	struct preloaded_file *mfp;
-	multiboot2_info_header_t *mbi;
 	char *cmdline = NULL;
 	struct devdesc *rootdev;
 	struct file_metadata *md;
@@ -813,14 +832,34 @@ multiboot2_exec(struct preloaded_file *fp)
 	struct bios_smap *smap;
 #if defined(EFI)
 	multiboot_tag_module_t *module, *mp;
+	struct relocator *relocator = NULL;
 	EFI_MEMORY_DESCRIPTOR *map;
 	UINTN map_size, desc_size;
-	struct relocator *relocator;
 	struct chunk_head *head;
 	struct chunk *chunk;
 	vm_offset_t tmp;
 
 	efi_getdev((void **)(&rootdev), NULL, NULL);
+
+	/*
+	 * We need 5 pages for relocation. We'll allocate from the heap: while
+	 * it's possible that our heap got placed low down enough to be in the
+	 * way of where we're going to relocate our kernel, it's hopefully not
+	 * likely.
+	 */
+	if ((relocator = malloc(EFI_PAGE_SIZE * 5)) == NULL) {
+		printf("relocator malloc failed!\n");
+		error = ENOMEM;
+		goto error;
+	}
+
+	if (overlaps((uintptr_t)relocator, EFI_PAGE_SIZE * 5,
+	    load_addr, fp->f_size)) {
+		printf("relocator pages overlap the kernel!\n");
+		error = EINVAL;
+		goto error;
+	}
+
 #else
 	i386_getdev((void **)(&rootdev), NULL, NULL);
 
@@ -830,7 +869,6 @@ multiboot2_exec(struct preloaded_file *fp)
 	}
 #endif
 
-	mbi = NULL;
 	error = EINVAL;
 	if (rootdev == NULL) {
 		printf("can't determine root device\n");
@@ -1175,25 +1213,7 @@ multiboot2_exec(struct preloaded_file *fp)
 		tag->mb_size = sizeof (*tag) + map_size;
 		tag->mb_descr_size = (uint32_t)desc_size;
 
-		/*
-		 * Find relocater pages. We assume we have free pages
-		 * below kernel load address.
-		 * In this version we are using 5 pages:
-		 * relocator data, trampoline, copy, memmove, stack.
-		 */
-		for (i = 0, map = (EFI_MEMORY_DESCRIPTOR *)tag->mb_efi_mmap;
-		    i < map_size / desc_size;
-		    i++, map = NextMemoryDescriptor(map, desc_size)) {
-			if (map->PhysicalStart == 0)
-				continue;
-			if (map->Type != EfiConventionalMemory)
-				continue;
-			if (map->PhysicalStart < load_addr &&
-			    map->NumberOfPages > 5)
-				break;
-		}
-		if (map->PhysicalStart == 0)
-			panic("Could not find memory for relocater");
+		map = (EFI_MEMORY_DESCRIPTOR *)tag->mb_efi_mmap;
 
 		if (keep_bs == 0) {
 			status = BS->ExitBootServices(IH, key);
@@ -1230,7 +1250,6 @@ multiboot2_exec(struct preloaded_file *fp)
 	 * physical address for MBI.
 	 * Now we must move all pieces to place and start the kernel.
 	 */
-	relocator = (struct relocator *)(uintptr_t)map->PhysicalStart;
 	head = &relocator->rel_chunk_head;
 	STAILQ_INIT(head);
 
@@ -1290,11 +1309,14 @@ multiboot2_exec(struct preloaded_file *fp)
 	panic("exec returned");
 
 error:
-	if (cmdline != NULL)
-		free(cmdline);
+	free(cmdline);
+
 #if defined(EFI)
+	free(relocator);
+
 	if (mbi != NULL)
 		efi_free_loadaddr((vm_offset_t)mbi, EFI_SIZE_TO_PAGES(size));
 #endif
+
 	return (error);
 }
diff --git a/usr/src/uts/i86pc/vm/vm_machdep.c b/usr/src/uts/i86pc/vm/vm_machdep.c
index 6c9a51be42..e59c89be8b 100644
--- a/usr/src/uts/i86pc/vm/vm_machdep.c
+++ b/usr/src/uts/i86pc/vm/vm_machdep.c
@@ -24,7 +24,7 @@
 /*
  * Copyright (c) 2010, Intel Corporation.
  * All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
@@ -160,7 +160,7 @@ typedef struct {
 		pgcnt_t	mnr_mts_pgcnt;
 		int	mnr_mts_colors;
 		pgcnt_t *mnr_mtsc_pgcnt;
-	} 	*mnr_mts;
+	}	*mnr_mts;
 #endif
 } mnoderange_t;
 
@@ -202,11 +202,11 @@ int nranges = NUM_MEM_RANGES;
  * This combines mem_node_config and memranges into one data
  * structure to be used for page list management.
  */
-mnoderange_t	*mnoderanges;
-int		mnoderangecnt;
-int		mtype4g;
-int		mtype16m;
-int		mtypetop;	/* index of highest pfn'ed mnoderange */
+static mnoderange_t *mnoderanges;
+static int mnoderangecnt;
+static int mtype4g;
+static int mtype16m;
+static int mtypetop;
 
 /*
  * 4g memory management variables for systems with more than 4g of memory:
@@ -262,9 +262,9 @@ static int	desfree4gshift = 4;	/* maxmem4g shift to derive DESFREE4G */
 
 #define	FREEMEM16M	MTYPE_FREEMEM(mtype16m)
 #define	DESFREE16M	desfree16m
-#define	RESTRICT16M_ALLOC(freemem, pgcnt, flags)		\
-	((freemem != 0) && ((flags & PG_PANIC) == 0) &&		\
-	    ((freemem >= (FREEMEM16M)) ||			\
+#define	RESTRICT16M_ALLOC(freemem, pgcnt, flags) \
+	(mtype16m != -1 && (freemem != 0) && ((flags & PG_PANIC) == 0) && \
+	    ((freemem >= (FREEMEM16M)) || \
 	    (FREEMEM16M  < (DESFREE16M + pgcnt))))
 
 static pgcnt_t	desfree16m = 0x380;
@@ -1387,39 +1387,46 @@ mnode_range_cnt(int mnode)
 #endif	/* __xpv */
 }
 
-/*
- * mnode_range_setup() initializes mnoderanges.
- */
+static int
+mnoderange_cmp(const void *v1, const void *v2)
+{
+	const mnoderange_t *m1 = v1;
+	const mnoderange_t *m2 = v2;
+
+	if (m1->mnr_pfnlo < m2->mnr_pfnlo)
+		return (-1);
+	return (m1->mnr_pfnlo > m2->mnr_pfnlo);
+}
+
 void
 mnode_range_setup(mnoderange_t *mnoderanges)
 {
-	mnoderange_t *mp = mnoderanges;
-	int	mnode, mri;
-	int	mindex = 0;	/* current index into mnoderanges array */
-	int	i, j;
-	pfn_t	hipfn;
-	int	last, hi;
-
-	for (mnode = 0; mnode < max_mem_nodes; mnode++) {
+	mnoderange_t *mp;
+	size_t nr_ranges;
+	size_t mnode;
+
+	for (mnode = 0, nr_ranges = 0, mp = mnoderanges;
+	    mnode < max_mem_nodes; mnode++) {
+		size_t mri = nranges - 1;
+
 		if (mem_node_config[mnode].exists == 0)
 			continue;
 
-		mri = nranges - 1;
-
 		while (MEMRANGEHI(mri) < mem_node_config[mnode].physbase)
 			mri--;
 
 		while (mri >= 0 && mem_node_config[mnode].physmax >=
 		    MEMRANGELO(mri)) {
-			mnoderanges->mnr_pfnlo = MAX(MEMRANGELO(mri),
+			mp->mnr_pfnlo = MAX(MEMRANGELO(mri),
 			    mem_node_config[mnode].physbase);
-			mnoderanges->mnr_pfnhi = MIN(MEMRANGEHI(mri),
+			mp->mnr_pfnhi = MIN(MEMRANGEHI(mri),
 			    mem_node_config[mnode].physmax);
-			mnoderanges->mnr_mnode = mnode;
-			mnoderanges->mnr_memrange = mri;
-			mnoderanges->mnr_exists = 1;
-			mnoderanges++;
-			mindex++;
+			mp->mnr_mnode = mnode;
+			mp->mnr_memrange = mri;
+			mp->mnr_next = -1;
+			mp->mnr_exists = 1;
+			mp++;
+			nr_ranges++;
 			if (mem_node_config[mnode].physmax > MEMRANGEHI(mri))
 				mri--;
 			else
@@ -1428,33 +1435,26 @@ mnode_range_setup(mnoderange_t *mnoderanges)
 	}
 
 	/*
-	 * For now do a simple sort of the mnoderanges array to fill in
-	 * the mnr_next fields.  Since mindex is expected to be relatively
-	 * small, using a simple O(N^2) algorithm.
+	 * mnoderangecnt can be larger than nr_ranges when memory DR is
+	 * supposedly supported.
 	 */
-	for (i = 0; i < mindex; i++) {
-		if (mp[i].mnr_pfnlo == 0)	/* find lowest */
-			break;
-	}
-	ASSERT(i < mindex);
-	last = i;
-	mtype16m = last;
-	mp[last].mnr_next = -1;
-	for (i = 0; i < mindex - 1; i++) {
-		hipfn = (pfn_t)(-1);
-		hi = -1;
-		/* find next highest mnode range */
-		for (j = 0; j < mindex; j++) {
-			if (mp[j].mnr_pfnlo > mp[last].mnr_pfnlo &&
-			    mp[j].mnr_pfnlo < hipfn) {
-				hipfn = mp[j].mnr_pfnlo;
-				hi = j;
-			}
-		}
-		mp[hi].mnr_next = last;
-		last = hi;
-	}
-	mtypetop = last;
+	VERIFY3U(nr_ranges, <=, mnoderangecnt);
+
+	qsort(mnoderanges, nr_ranges, sizeof (mnoderange_t), mnoderange_cmp);
+
+	/*
+	 * If some intrepid soul takes the axe to the memory DR code, we can
+	 * remove ->mnr_next altogether, as we just sorted by ->mnr_pfnlo order.
+	 *
+	 * The VERIFY3U() above can be "==" then too.
+	 */
+	for (size_t i = 1; i < nr_ranges; i++)
+		mnoderanges[i].mnr_next = i - 1;
+
+	mtypetop = nr_ranges - 1;
+	mtype16m = pfn_2_mtype(0x0); /* Can be -1 ... */
+	if (physmax4g)
+		mtype4g = pfn_2_mtype(0xfffff);
 }
 
 #ifndef	__xpv
@@ -1976,9 +1976,6 @@ page_coloring_setup(caddr_t pcmemaddr)
 
 	mnode_range_setup(mnoderanges);
 
-	if (physmax4g)
-		mtype4g = pfn_2_mtype(0xfffff);
-
 	for (k = 0; k < NPC_MUTEX; k++) {
 		fpc_mutex[k] = (kmutex_t *)addr;
 		addr += (max_mem_nodes * sizeof (kmutex_t));
-- 
2.21.0

