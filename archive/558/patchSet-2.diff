From 0b3e19f89a6c4320dcba5b9c0b6baa5c64f8b6e6 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 28 Sep 2016 18:24:13 -0700
Subject: [PATCH] CNS-159 update to latest cueball

---
 lib/dns-clients.js   |   2 +-
 lib/dns-server.js    |   2 +-
 lib/reaper-stream.js | 202 ++++++++++++++++++++-----------------------
 package.json         |   6 +-
 updater.js           |  70 +++++++--------
 5 files changed, 131 insertions(+), 151 deletions(-)

diff --git a/lib/dns-clients.js b/lib/dns-clients.js
index dd33224..203b8f2 100644
--- a/lib/dns-clients.js
+++ b/lib/dns-clients.js
@@ -15,7 +15,7 @@ var util = require('util');
 var assert = require('assert-plus');
 var utils = require('./utils');
 var bunyan = require('bunyan');
-var named = require('named');
+var named = require('mname');
 var EventEmitter = require('events').EventEmitter;
 var sprintf = util.format;
 var vasync = require('vasync');
diff --git a/lib/dns-server.js b/lib/dns-server.js
index e374392..c419715 100644
--- a/lib/dns-server.js
+++ b/lib/dns-server.js
@@ -12,7 +12,7 @@ var util = require('util');
 var assert = require('assert-plus');
 var utils = require('./utils');
 var bunyan = require('bunyan');
-var named = require('named');
+var named = require('mname');
 var EventEmitter = require('events').EventEmitter;
 var sprintf = util.format;
 var vasync = require('vasync');
diff --git a/lib/reaper-stream.js b/lib/reaper-stream.js
index 0671f83..40bbbb3 100644
--- a/lib/reaper-stream.js
+++ b/lib/reaper-stream.js
@@ -60,21 +60,16 @@ function ReaperFSM(strm, opts) {
 }
 util.inherits(ReaperFSM, FSM);
 
-ReaperFSM.prototype.fetch = function (uuid) {
-	var eve = new EventEmitter();
-	var self = this;
-	eve.send = function () {
-		self.client.get('/vms/' + uuid, function (err, req, res, obj) {
-			if (err) {
-				eve.emit('error', err);
-				return;
-			}
-			utils.cleanVM(obj);
-			obj.origin = 'reaper';
-			eve.emit('result', obj);
-		});
-	};
-	return (eve);
+ReaperFSM.prototype.fetch = function (uuid, cb) {
+	this.client.get('/vms/' + uuid, function (err, req, res, obj) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		utils.cleanVM(obj);
+		obj.origin = 'reaper';
+		cb(null, obj);
+	});
 };
 
 ReaperFSM.prototype.start = function () {
@@ -86,32 +81,32 @@ ReaperFSM.prototype.wake = function () {
 	this.emit('wakeAsserted');
 };
 
-ReaperFSM.prototype.state_idle = function (on, once, timeout) {
-	var self = this;
-	once(this, 'startAsserted', function () {
-		self.gotoState('listVms');
+ReaperFSM.prototype.state_idle = function (S) {
+	S.on(this, 'startAsserted', function () {
+		S.gotoState('listVms');
 	});
 	if (this.onTimer) {
-		timeout(this.reapTime*1000, function () {
-			self.gotoState('listVms');
+		S.timeout(this.reapTime*1000, function () {
+			S.gotoState('listVms');
 		});
 	}
 };
 
-ReaperFSM.prototype.state_listVms = function (on, once, timeout) {
+ReaperFSM.prototype.state_listVms = function (S) {
 	var self = this;
-	timeout(10000, function () {
+	S.timeout(10000, function () {
 		self.lastError = new Error(
 		    'Timed out waiting for redis response');
-		self.gotoState('listError');
+		S.gotoState('listError');
 	});
-	var req = FSM.wrap(this.redis.keys).call(this.redis, 'vm:*');
 
-	once(req, 'error', function (err) {
-		self.lastError = err;
-		self.gotoState('listError');
-	});
-	once(req, 'return', function (keys) {
+	this.redis.keys('vm:*', S.callback(function (err, keys) {
+		if (err) {
+			self.lastError = err;
+			S.gotoState('listError');
+			return;
+		}
+
 		for (var i = 0; i < keys.length; ++i) {
 			var parts = keys[i].split(':');
 			if (parts.length === 2 && parts[0] === 'vm') {
@@ -122,55 +117,50 @@ ReaperFSM.prototype.state_listVms = function (on, once, timeout) {
 		self.log.debug('pushed %d candidates for reaping',
 		    self.remaining.length);
 
-		self.gotoState('next');
-	});
-
-	req.run();
+		S.gotoState('next');
+	}));
 };
 
-ReaperFSM.prototype.state_listError = function (on, once, timeout) {
-	var self = this;
+ReaperFSM.prototype.state_listError = function (S) {
 	this.log.error(this.lastError,
 	    'error while listing VMs in redis, retry in 1s');
-	timeout(1000, function () {
-		self.gotoState('listVms');
+	S.timeout(1000, function () {
+		S.gotoState('listVms');
 	});
 };
 
-ReaperFSM.prototype.state_next = function () {
-	var self = this;
-	self.retries = 3;
-	if (self.remaining.length > 0) {
-		self.vmuuid = self.remaining.shift();
-		self.gotoState('checkLastVisited');
+ReaperFSM.prototype.state_next = function (S) {
+	this.retries = 3;
+	if (this.remaining.length > 0) {
+		this.vmuuid = this.remaining.shift();
+		S.gotoState('checkLastVisited');
 	} else {
-		self.log.debug('reaping complete');
-		self.gotoState('idle');
+		this.log.debug('reaping complete');
+		S.gotoState('idle');
 	}
 };
 
-ReaperFSM.prototype.state_checkLastVisited = function (on, once, timeout) {
+ReaperFSM.prototype.state_checkLastVisited = function (S) {
 	var self = this;
 	var log = self.log.child({uuid: self.vmuuid});
-	timeout(1000, function () {
+	S.timeout(1000, function () {
 		self.lastError = new Error(
 		    'Timed out waiting for redis response');
-		self.gotoState('checkError');
+		S.gotoState('checkError');
 	});
 
-	var req = FSM.wrap(self.redis.hget).call(self.redis,
-	    'vm:' + self.vmuuid, 'last_visit');
-
-	once(req, 'error', function (err) {
-		self.lastError = err;
-		self.gotoState('checkError');
-	});
+	this.redis.hget('vm:' + self.vmuuid, 'last_visit',
+	    S.callback(function (err, val) {
+		if (err) {
+			self.lastError = err;
+			S.gotoState('checkError');
+			return;
+		}
 
-	once(req, 'return', function (val) {
 		if (val === null) {
 			log.warn({queue: self.remaining.length},
 			    'vm has no last_visited record, skipping');
-			self.gotoState('next');
+			S.gotoState('next');
 			return;
 		}
 
@@ -180,31 +170,29 @@ ReaperFSM.prototype.state_checkLastVisited = function (on, once, timeout) {
 			log.trace({queue: self.remaining.length},
 			    'reaping, last visited %d sec ago',
 			    (now - lastVisited));
-			self.gotoState('checkReaped');
+			S.gotoState('checkReaped');
 		} else {
-			self.gotoState('next');
+			S.gotoState('next');
 		}
-	});
-
-	req.run();
+	}));
 };
 
-ReaperFSM.prototype.state_checkReaped = function (on, once, timeout) {
+ReaperFSM.prototype.state_checkReaped = function (S) {
 	var self = this;
-	timeout(1000, function () {
+	S.timeout(1000, function () {
 		self.lastError = new Error(
 		    'Timed out waiting for redis response');
-		self.gotoState('checkError');
+		S.gotoState('checkError');
 	});
-	var req = FSM.wrap(self.redis.hget).call(self.redis,
-	    'vm:' + self.vmuuid, 'reaped');
 
-	once(req, 'error', function (err) {
-		self.lastError = err;
-		self.gotoState('checkError');
-	});
+	this.redis.hget('vm:' + self.vmuuid, 'reaped',
+	    S.callback(function (err, val) {
+		if (err) {
+			self.lastError = err;
+			S.gotoState('checkError');
+			return;
+		}
 
-	once(req, 'return', function (val) {
 		/*
 		 * If we found something, this is the second time we've
 		 * visited this VM and it's still destroyed. We can
@@ -212,50 +200,48 @@ ReaperFSM.prototype.state_checkReaped = function (on, once, timeout) {
 		 */
 		if (val !== null) {
 			self.redis.del('vm:' + self.vmuuid);
-			self.gotoState('next');
+			S.gotoState('next');
 			return;
 		}
 
-		self.gotoState('fetchAndPush');
-	});
-
-	req.run();
+		S.gotoState('fetchAndPush');
+	}));
 };
 
-ReaperFSM.prototype.state_fetchAndPush = function (on, once, timeout) {
+ReaperFSM.prototype.state_fetchAndPush = function (S) {
 	var self = this;
-	timeout(5000, function () {
+	S.timeout(5000, function () {
 		self.lastError = new Error(
 		    'Timed out waiting for VMAPI response');
-		self.gotoState('checkError');
-	});
-	var req = self.fetch(self.vmuuid);
-	once(req, 'error', function (err) {
-		self.lastError = new Error('Error from VMAPI: ' +
-		    err.name + ': ' + err.message);
-		self.lastError.name = 'VMAPIError';
-		self.lastError.origin = err;
-		self.gotoState('checkError');
+		S.gotoState('checkError');
 	});
-	once(req, 'result', function (obj) {
+	this.fetch(this.vmuuid, S.callback(function (err, obj) {
+		if (err) {
+			self.lastError = new Error('Error from VMAPI: ' +
+			    err.name + ': ' + err.message);
+			self.lastError.name = 'VMAPIError';
+			self.lastError.origin = err;
+			S.gotoState('checkError');
+			return;
+		}
+
 		if (obj.state === 'destroyed' || obj.destroyed ||
 		    obj.state === 'failed' || obj.state === 'incomplete') {
 			self.redis.hset('vm:' + self.vmuuid, 'reaped', 'yes');
 		}
 
 		if (self.stream.push(obj) === false) {
-			self.gotoState('sleep_full');
+			S.gotoState('sleep_full');
 			return;
 		}
 
-		self.gotoState('sleep');
-	});
-	req.send();
+		S.gotoState('sleep');
+	}));
 };
 
-ReaperFSM.prototype.state_sleep_full = function (on, once, timeout) {
+ReaperFSM.prototype.state_sleep_full = function (S) {
 	var self = this;
-	timeout(self.sleep, function () {
+	S.timeout(self.sleep, function () {
 		/*
 		 * Pipeline is full, and stayed full for our entire sleep
 		 * interval (we didn't get a wake-up). Increase our sleep
@@ -269,24 +255,24 @@ ReaperFSM.prototype.state_sleep_full = function (on, once, timeout) {
 			    ' (is this a bug?)');
 			self.sleep = self.maxSleep;
 		}
-		self.gotoState('next');
+		S.gotoState('next');
 	});
-	once(this, 'wakeAsserted', function () {
-		self.gotoState('next');
+	S.on(this, 'wakeAsserted', function () {
+		S.gotoState('next');
 	});
 };
 
-ReaperFSM.prototype.state_sleep = function (on, once, timeout) {
+ReaperFSM.prototype.state_sleep = function (S) {
 	var self = this;
 	/*
 	 * If we weren't full, we always wait for our entire sleep interval
 	 * and ignore wakeups, so that we don't dominate the pipeline's
 	 * available throughput.
 	 */
-	timeout(self.sleep, function () {
-		self.gotoState('next');
+	S.timeout(self.sleep, function () {
+		S.gotoState('next');
 	});
-	once(this, 'wakeAsserted', function () {
+	S.on(this, 'wakeAsserted', function () {
 		/*
 		 * If the pipeline has emptied out, head down towards our
 		 * lowest sleep interval -- it might have been a transient
@@ -298,7 +284,7 @@ ReaperFSM.prototype.state_sleep = function (on, once, timeout) {
 	});
 };
 
-ReaperFSM.prototype.state_checkError = function (on, once, timeout) {
+ReaperFSM.prototype.state_checkError = function (S) {
 	var self = this;
 	--(self.retries);
 	var log = self.log.child({uuid: self.vmuuid,
@@ -306,14 +292,14 @@ ReaperFSM.prototype.state_checkError = function (on, once, timeout) {
 	if (self.retries > 0) {
 		log.error(self.lastError,
 		    'error while checking vm, retrying in 1s');
-		timeout(1000, function () {
-			self.gotoState('checkLastVisited');
+		S.timeout(1000, function () {
+			S.gotoState('checkLastVisited');
 		});
 	} else {
 		log.error(self.lastError,
 		    'error while checking vm, out of retries -- will skip');
-		timeout(5000, function () {
-			self.gotoState('next');
+		S.timeout(5000, function () {
+			S.gotoState('next');
 		});
 	}
 };
diff --git a/package.json b/package.json
index 9c00737..0ee3ece 100644
--- a/package.json
+++ b/package.json
@@ -26,15 +26,15 @@
     "assert-plus": "0.1.5",
     "bunyan": "1.5.1",
     "changefeed": "1.1.9",
-    "cueball": "0.3.12",
+    "cueball": "1.0.1",
     "dashdash": "1.10.1",
     "deep-equal": "1.0.1",
     "ipaddr.js": "1.0.3",
     "jsprim": "1.2.2",
     "ldapjs": "1.0.0",
     "lru-cache": "2.7.0",
-    "mooremachine": "1.1.3",
-    "named": "git+https://github.com/arekinath/node-named#v1.0.6",
+    "mooremachine": "2.0.0",
+    "mname": "1.0.8",
     "redis": "2.1.0",
     "restify": "4.0.3",
     "restify-clients": "1.1.1",
diff --git a/updater.js b/updater.js
index 610ab88..fd615b7 100644
--- a/updater.js
+++ b/updater.js
@@ -74,7 +74,7 @@ var nlf = new NAPILegacyFilter(opts);
 var npf = new NetPoolFilter(opts);
 var nf = new NetFilter(opts);
 var ffs = new FlagFilter(opts);
-var s = new UpdateStream(opts);
+var us = new UpdateStream(opts);
 var rs = new ReaperStream(opts);
 
 /*
@@ -115,86 +115,80 @@ function AppFSM() {
 }
 util.inherits(AppFSM, FSM);
 
-AppFSM.prototype.state_initial = function (on, once, timeout) {
-	var self = this;
-
+AppFSM.prototype.state_initial = function (S) {
 	ps.pipe(cnf);
 	cnf.pipe(uf);
 	uf.pipe(nlf);
 	nlf.pipe(npf);
 	npf.pipe(nf);
 	nf.pipe(ffs);
-	ffs.pipe(s);
+	ffs.pipe(us);
 	rs.pipe(cnf);
 
-	once(cfl, 'bootstrap', function () {
-		self.gotoState('cfFirstPoll');
+	S.on(cfl, 'bootstrap', function () {
+		S.gotoState('cfFirstPoll');
 	});
-	once(cfl, 'error', function () {
-		self.gotoState('fallbackFirstPoll');
+	S.on(cfl, 'error', function () {
+		S.gotoState('fallbackFirstPoll');
 	});
 	cfl.register();
 };
 
-AppFSM.prototype.state_cfFirstPoll = function (on, once, timeout) {
-	var self = this;
-	s.openSerial(false);
+AppFSM.prototype.state_cfFirstPoll = function (S) {
+	us.openSerial(false);
 	ps.start();
-	once(ps, 'pollFinish', function () {
+	S.on(ps, 'pollFinish', function () {
 		log.info('Poll done, committing...');
-		s.closeSerial();
-		self.gotoState('cfRunning');
+		us.closeSerial();
+		S.gotoState('cfRunning');
 	});
-	once(cfl, 'error', function () {
-		self.gotoState('fallbackFirstPoll');
+	S.on(cfl, 'error', function () {
+		S.gotoState('fallbackFirstPoll');
 	});
 };
 
-AppFSM.prototype.state_cfRunning = function (on, once, timeout) {
-	var self = this;
+AppFSM.prototype.state_cfRunning = function (S) {
 	cfl.pipe(cff);
 	cff.pipe(cnf);
 	rs.setReapTime(CF_REAP_TIME);
 	rs.start();
 
-	once(cfl, 'bootstrap', function () {
-		self.gotoState('cfFirstPoll');
+	S.on(cfl, 'bootstrap', function () {
+		S.gotoState('cfFirstPoll');
 	});
 
-	once(cfl, 'error', function () {
-		self.gotoState('fallback');
+	S.on(cfl, 'error', function () {
+		S.gotoState('fallback');
 	});
 };
 
-AppFSM.prototype.state_fallbackFirstPoll = function (on, once, timeout) {
-	var self = this;
-	s.openSerial(false);
+AppFSM.prototype.state_fallbackFirstPoll = function (S) {
+	us.openSerial(false);
 	ps.start();
-	once(ps, 'pollFinish', function () {
+	S.on(ps, 'pollFinish', function () {
 		log.info('Poll done, committing...');
-		s.closeSerial();
-		self.gotoState('fallback');
+		us.closeSerial();
+		S.gotoState('fallback');
 	});
-	on(cfl, 'error', function () {
+	S.on(cfl, 'error', function () {
 		/* Ignore any CF errors while in fallback mode. */
 	});
-	once(cfl, 'bootstrap', function () {
-		self.gotoState('cfFirstPoll');
+	S.on(cfl, 'bootstrap', function () {
+		S.gotoState('cfFirstPoll');
 	});
 };
 
-AppFSM.prototype.state_fallback = function (on, once, timeout) {
-	var self = this;
+AppFSM.prototype.state_fallback = function (S) {
 	rs.setReapTime(FALLBACK_REAP_TIME);
 	rs.start();
-	on(pollTimeEmitter, 'timeout', function () {
+	S.on(pollTimeEmitter, 'timeout', function () {
 		ps.start();
 	});
-	on(cfl, 'error', function () {
+	S.on(cfl, 'error', function () {
 		/* Ignore any CF errors while in fallback mode. */
 	});
-	once(cfl, 'bootstrap', function () {
-		self.gotoState('cfFirstPoll');
+	S.on(cfl, 'bootstrap', function () {
+		S.gotoState('cfFirstPoll');
 	});
 };
 
-- 
2.21.0

