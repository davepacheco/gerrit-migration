commit cf5518703ff707de275d4b1616747180827703cc
Author: Rob Johnston <rob.johnston@joyent.com>
Date:   2019-05-07T21:33:44+00:00 (5 months ago)
    
    OS-7014 Add libtopo support for Upgradable Firmware Modules
    OS-7026 Add DDI support for Upgradable Firmware Modules

diff --git a/manifest b/manifest
index 99c2e55a1d..74e3e76951 100644
--- a/manifest
+++ b/manifest
@@ -713,6 +713,7 @@ f kernel/drv/amd64/tzmon 0755 root sys
 f kernel/drv/amd64/ucode 0755 root sys
 f kernel/drv/amd64/udp 0755 root sys
 f kernel/drv/amd64/udp6 0755 root sys
+f kernel/drv/amd64/ufm 0755 root sys
 f kernel/drv/amd64/ugen 0755 root sys
 f kernel/drv/amd64/uhci 0755 root sys
 f kernel/drv/amd64/usb_ac 0755 root sys
@@ -861,6 +862,7 @@ f kernel/drv/tzmon.conf 0644 root sys
 f kernel/drv/ucode.conf 0644 root sys
 f kernel/drv/udp.conf 0644 root sys
 f kernel/drv/udp6.conf 0644 root sys
+f kernel/drv/ufm.conf 0644 root sys
 f kernel/drv/uhci.conf 0644 root sys
 f kernel/drv/usbftdi.conf 0644 root sys
 f kernel/drv/usbser_edge.conf 0644 root sys
@@ -3831,6 +3833,8 @@ f usr/include/sys/ddi_intr_impl.h 0644 root bin
 f usr/include/sys/ddi_isa.h 0644 root bin
 f usr/include/sys/ddi_obsolete.h 0644 root bin
 f usr/include/sys/ddi_periodic.h 0644 root bin
+f usr/include/sys/ddi_ufm.h 0644 root bin
+f usr/include/sys/ddi_ufm_impl.h 0644 root bin
 f usr/include/sys/ddidevmap.h 0644 root bin
 f usr/include/sys/ddidmareq.h 0644 root bin
 f usr/include/sys/ddifm.h 0644 root bin
@@ -19140,6 +19144,7 @@ s usr/share/man/man7d/ticotsord.7d=ticlts.7d
 f usr/share/man/man7d/tty.7d 0444 root bin
 f usr/share/man/man7d/ttymux.7d 0444 root bin
 f usr/share/man/man7d/tzmon.7d 0444 root bin
+f usr/share/man/man7d/ufm.7d 0444 root bin
 f usr/share/man/man7d/ugen.7d 0444 root bin
 f usr/share/man/man7d/uhci.7d 0444 root bin
 s usr/share/man/man7d/urandom.7d=random.7d
@@ -19290,6 +19295,7 @@ f usr/share/man/man9e/awrite.9e 0444 root bin
 f usr/share/man/man9e/chpoll.9e 0444 root bin
 f usr/share/man/man9e/close.9e 0444 root bin
 f usr/share/man/man9e/csx_event_handler.9e 0444 root bin
+f usr/share/man/man9e/ddi_ufm.9e 0444 root bin
 f usr/share/man/man9e/detach.9e 0444 root bin
 f usr/share/man/man9e/devmap.9e 0444 root bin
 f usr/share/man/man9e/devmap_access.9e 0444 root bin
@@ -19976,6 +19982,9 @@ s usr/share/man/man9f/ddi_taskq_resume.9f=taskq.9f
 s usr/share/man/man9f/ddi_taskq_suspend.9f=taskq.9f
 s usr/share/man/man9f/ddi_taskq_wait.9f=taskq.9f
 s usr/share/man/man9f/ddi_trigger_softintr.9f=ddi_add_softintr.9f
+f usr/share/man/man9f/ddi_ufm.9f 0444 root bin
+f usr/share/man/man9f/ddi_ufm_image.9f 0444 root bin
+f usr/share/man/man9f/ddi_ufm_slot.9f 0444 root bin
 f usr/share/man/man9f/ddi_umem_alloc.9f 0444 root bin
 s usr/share/man/man9f/ddi_umem_free.9f=ddi_umem_alloc.9f
 f usr/share/man/man9f/ddi_umem_iosetup.9f 0444 root bin
diff --git a/usr/src/lib/fm/topo/libtopo/common/hc.c b/usr/src/lib/fm/topo/libtopo/common/hc.c
index 9c64077549..6a0de2f676 100644
--- a/usr/src/lib/fm/topo/libtopo/common/hc.c
+++ b/usr/src/lib/fm/topo/libtopo/common/hc.c
@@ -205,6 +205,7 @@ static const hcc_t hc_canon[] = {
 	{ SUBCHASSIS, TOPO_STABILITY_PRIVATE },
 	{ SYSTEMBOARD, TOPO_STABILITY_PRIVATE },
 	{ TRANSCEIVER, TOPO_STABILITY_PRIVATE },
+	{ UFM, TOPO_STABILITY_PRIVATE },
 	{ USB_DEVICE, TOPO_STABILITY_PRIVATE },
 	{ XAUI, TOPO_STABILITY_PRIVATE },
 	{ XFP, TOPO_STABILITY_PRIVATE }
diff --git a/usr/src/lib/fm/topo/libtopo/common/libtopo.h b/usr/src/lib/fm/topo/libtopo/common/libtopo.h
index 9c1f12b952..ed0084bf14 100644
--- a/usr/src/lib/fm/topo/libtopo/common/libtopo.h
+++ b/usr/src/lib/fm/topo/libtopo/common/libtopo.h
@@ -1018,9 +1018,22 @@ typedef enum topo_led_type {
 } topo_led_type_t;
 
 typedef enum topo_slot_type {
-	TOPO_SLOT_TYPE_DIMM = 1
+	TOPO_SLOT_TYPE_DIMM = 1,
+	TOPO_SLOT_TYPE_UFM
 } topo_slot_type_t;
 
+typedef enum topo_ufm_slot_mode {
+	TOPO_UFM_SLOT_MODE_RO = 1,
+	TOPO_UFM_SLOT_MODE_RW
+} topo_ufm_slot_mode_t;
+
+typedef struct topo_ufm_slot_info {
+	uint32_t usi_slotid;
+	topo_ufm_slot_mode_t usi_mode;
+	const char *usi_version;
+	boolean_t usi_active;
+	nvlist_t *usi_extra;
+} topo_ufm_slot_info_t;
 
 #ifdef __cplusplus
 }
diff --git a/usr/src/lib/fm/topo/libtopo/common/mapfile-vers b/usr/src/lib/fm/topo/libtopo/common/mapfile-vers
index cd9a854357..fe3adf94cc 100644
--- a/usr/src/lib/fm/topo/libtopo/common/mapfile-vers
+++ b/usr/src/lib/fm/topo/libtopo/common/mapfile-vers
@@ -92,6 +92,8 @@ SYMBOL_VERSION SUNWprivate {
 	topo_mod_alloc;
 	topo_mod_auth;
 	topo_mod_clean_str;
+	topo_mod_create_ufm;
+	topo_mod_create_ufm_slot;
 	topo_mod_clrdebug;
 	topo_mod_cpufmri;
 	topo_mod_devfmri;
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
index 8d96367afe..13515ffc77 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 #ifndef _TOPO_HC_H
@@ -93,6 +93,7 @@ extern "C" {
 #define	SUBCHASSIS	"subchassis"
 #define	SYSTEMBOARD	"systemboard"
 #define	TRANSCEIVER	"transceiver"
+#define	UFM		"ufm"
 #define	USB_DEVICE	"usb-device"
 #define	XAUI		"xaui"
 #define	XFP		"xfp"
@@ -268,9 +269,16 @@ extern "C" {
 #define	TOPO_PROP_MB_PRODUCT		"product-id"
 #define	TOPO_PROP_MB_ASSET		"asset-tag"
 #define	TOPO_PROP_MB_FIRMWARE_VENDOR	"firmware-vendor"
-#define	TOPO_PROP_MB_FIRMWARE_REV	"firmware-revision"
 #define	TOPO_PROP_MB_FIRMWARE_RELDATE	"firmware-release-date"
 
+#define	TOPO_PGROUP_UFM			"ufm-properties"
+#define	TOPO_PROP_UFM_DESCR		"ufm-description"
+
+#define	TOPO_PGROUP_UFM_SLOT		"ufm-slot-properties"
+#define	TOPO_PROP_UFM_SLOT_VERSION	"ufm-slot-version"
+#define	TOPO_PROP_UFM_SLOT_MODE		"ufm-slot-mode"
+#define	TOPO_PROP_UFM_SLOT_ACTIVE	"ufm-slot_active"
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_mod.c b/usr/src/lib/fm/topo/libtopo/common/topo_mod.c
index 9c6f52ee00..a013b24d0e 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_mod.c
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_mod.c
@@ -971,3 +971,222 @@ topo_mod_hc_occupied(topo_mod_t *mod, tnode_t *node, topo_version_t version,
 
 	return (0);
 }
+
+/*
+ * Convenience routine for creating a UFM slot node.  This routine assumes
+ * that the caller has already created the containing range via a call to
+ * topo_node_range_create().
+ */
+tnode_t *
+topo_mod_create_ufm_slot(topo_mod_t *mod, tnode_t *ufmnode,
+    topo_ufm_slot_info_t *slotinfo)
+{
+	nvlist_t *auth = NULL, *fmri = NULL;
+	tnode_t *slotnode;
+	topo_pgroup_info_t pgi;
+	int err, rc;
+
+	if (slotinfo == NULL || slotinfo->usi_version == NULL ||
+	    slotinfo->usi_mode == 0) {
+		topo_mod_dprintf(mod, "invalid slotinfo");
+		topo_mod_seterrno(mod, ETOPO_MOD_INVAL);
+		return (NULL);
+	}
+	if ((auth = topo_mod_auth(mod, ufmnode)) == NULL) {
+		topo_mod_dprintf(mod, "topo_mod_auth() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	if ((fmri = topo_mod_hcfmri(mod, ufmnode, FM_HC_SCHEME_VERSION,
+	    SLOT, slotinfo->usi_slotid, NULL, auth, NULL, NULL, NULL)) ==
+	    NULL) {
+		nvlist_free(auth);
+		topo_mod_dprintf(mod, "topo_mod_hcfmri() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	if ((slotnode = topo_node_bind(mod, ufmnode, SLOT,
+	    slotinfo->usi_slotid, fmri)) == NULL) {
+		nvlist_free(auth);
+		nvlist_free(fmri);
+		topo_mod_dprintf(mod, "topo_node_bind() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	/* Create authority and system pgroups */
+	topo_pgroup_hcset(slotnode, auth);
+	nvlist_free(auth);
+	nvlist_free(fmri);
+
+	/* Just inherit the parent's FRU */
+	if (topo_node_fru_set(slotnode, NULL, NULL, &err) != 0) {
+		topo_mod_dprintf(mod, "failed to set FRU on %s: %s", UFM,
+		    topo_strerror(err));
+		(void) topo_mod_seterrno(mod, err);
+		goto slotfail;
+	}
+
+	pgi.tpi_name = TOPO_PGROUP_SLOT;
+	pgi.tpi_namestab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_datastab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_version = TOPO_VERSION;
+	rc = topo_pgroup_create(slotnode, &pgi, &err);
+
+	if (rc == 0)
+		rc += topo_prop_set_uint32(slotnode, TOPO_PGROUP_SLOT,
+		    TOPO_PROP_SLOT_TYPE, TOPO_PROP_IMMUTABLE,
+		    TOPO_SLOT_TYPE_UFM, &err);
+
+	pgi.tpi_name = TOPO_PGROUP_UFM_SLOT;
+
+	if (rc == 0)
+		rc += topo_pgroup_create(slotnode, &pgi, &err);
+
+	if (rc == 0)
+		rc += topo_prop_set_uint32(slotnode, TOPO_PGROUP_UFM_SLOT,
+		    TOPO_PROP_UFM_SLOT_MODE, TOPO_PROP_IMMUTABLE,
+		    slotinfo->usi_mode, &err);
+
+	if (rc == 0)
+		rc += topo_prop_set_uint32(slotnode, TOPO_PGROUP_UFM_SLOT,
+		    TOPO_PROP_UFM_SLOT_ACTIVE, TOPO_PROP_IMMUTABLE,
+		    (uint32_t)slotinfo->usi_active, &err);
+
+	if (rc == 0)
+		rc += topo_prop_set_string(slotnode, TOPO_PGROUP_UFM_SLOT,
+		    TOPO_PROP_UFM_SLOT_VERSION, TOPO_PROP_IMMUTABLE,
+		    slotinfo->usi_version, &err);
+
+	if (rc == 0 && slotinfo->usi_extra != NULL) {
+		nvpair_t *elem = NULL;
+		char *pname, *pval;
+
+		while ((elem = nvlist_next_nvpair(slotinfo->usi_extra,
+		    elem)) != NULL) {
+			if (nvpair_type(elem) != DATA_TYPE_STRING)
+				break;
+
+			pname = nvpair_name(elem);
+			if ((rc += nvpair_value_string(elem, &pval)) != 0)
+				break;
+
+			rc += topo_prop_set_string(slotnode,
+			    TOPO_PGROUP_UFM_SLOT, pname, TOPO_PROP_IMMUTABLE,
+			    pval, &err);
+
+			if (rc != 0)
+				break;
+		}
+	}
+
+	if (rc != 0) {
+		topo_mod_dprintf(mod, "error setting properties on %s node",
+		    SLOT);
+		(void) topo_mod_seterrno(mod, err);
+		goto slotfail;
+	}
+	return (slotnode);
+
+slotfail:
+	topo_node_unbind(slotnode);
+	return (NULL);
+}
+
+/*
+ * This is a convenience routine to allow enumerator modules to easily create
+ * the necessary UFM node layout for the most common case, which will be a
+ * single UFM with a single slot.  This routine assumes that the caller has
+ * already created the containing range via a call to topo_node_range_create().
+ *
+ * For more complex scenarios (like multiple slots per UFM), callers can set
+ * the slotinfo param to NULL.  In this case the ufm node will get created, but
+ * it will skip creating the slot node - allowing the module to manually call
+ * topo_mod_create_ufm_slot() to create custom UFM slots.
+ */
+tnode_t *
+topo_mod_create_ufm(topo_mod_t *mod, tnode_t *parent, const char *descr,
+    topo_ufm_slot_info_t *slotinfo)
+{
+	nvlist_t *auth = NULL, *fmri = NULL;
+	tnode_t *ufmnode, *slotnode;
+	topo_pgroup_info_t pgi;
+	int err, rc;
+
+	if ((auth = topo_mod_auth(mod, parent)) == NULL) {
+		topo_mod_dprintf(mod, "topo_mod_auth() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	if ((fmri = topo_mod_hcfmri(mod, parent, FM_HC_SCHEME_VERSION,
+	    UFM, 0, NULL, auth, NULL, NULL, NULL)) ==
+	    NULL) {
+		nvlist_free(auth);
+		topo_mod_dprintf(mod, "topo_mod_hcfmri() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	if ((ufmnode = topo_node_bind(mod, parent, UFM, 0, fmri)) == NULL) {
+		nvlist_free(auth);
+		nvlist_free(fmri);
+		topo_mod_dprintf(mod, "topo_node_bind() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		return (NULL);
+	}
+
+	/* Create authority and system pgroups */
+	topo_pgroup_hcset(ufmnode, auth);
+	nvlist_free(auth);
+	nvlist_free(fmri);
+
+	/* Just inherit the parent's FRU */
+	if (topo_node_fru_set(ufmnode, NULL, NULL, &err) != 0) {
+		topo_mod_dprintf(mod, "failed to set FRU on %s: %s", UFM,
+		    topo_strerror(err));
+		(void) topo_mod_seterrno(mod, err);
+		goto ufmfail;
+	}
+
+	pgi.tpi_name = TOPO_PGROUP_UFM;
+	pgi.tpi_namestab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_datastab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_version = TOPO_VERSION;
+	rc = topo_pgroup_create(ufmnode, &pgi, &err);
+
+	if (rc == 0)
+		rc += topo_prop_set_string(ufmnode, TOPO_PGROUP_UFM,
+		    TOPO_PROP_UFM_DESCR, TOPO_PROP_IMMUTABLE, descr, &err);
+
+	if (rc != 0) {
+		topo_mod_dprintf(mod, "error setting properties on %s node",
+		    UFM);
+		(void) topo_mod_seterrno(mod, err);
+		goto ufmfail;
+	}
+
+	if (slotinfo != NULL) {
+		if (topo_node_range_create(mod, ufmnode, SLOT, 0, 0) < 0) {
+			topo_mod_dprintf(mod, "error creating %s range", SLOT);
+			goto ufmfail;
+		}
+		slotnode = topo_mod_create_ufm_slot(mod, ufmnode, slotinfo);
+
+		if (slotnode == NULL)
+			goto ufmfail;
+	}
+	return (ufmnode);
+
+ufmfail:
+	topo_node_unbind(ufmnode);
+	return (NULL);
+}
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_mod.h b/usr/src/lib/fm/topo/libtopo/common/topo_mod.h
index 5df706a282..8f625303d1 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_mod.h
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_mod.h
@@ -262,6 +262,11 @@ extern int topo_prop_method_register(tnode_t *, const char *, const char *,
     topo_type_t, const char *, const nvlist_t *, int *);
 extern void topo_prop_method_unregister(tnode_t *, const char *, const char *);
 
+extern tnode_t *topo_mod_create_ufm(topo_mod_t *, tnode_t *, const char *,
+    topo_ufm_slot_info_t *);
+extern tnode_t *topo_mod_create_ufm_slot(topo_mod_t *, tnode_t *,
+    topo_ufm_slot_info_t *);
+
 /*
  * This enum definition is used to define a set of error tags associated with
  * the module api error conditions.  The shell script mkerror.sh is
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_mod.map b/usr/src/lib/fm/topo/libtopo/common/topo_mod.map
index 53a0177ab3..0e91797461 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_mod.map
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_mod.map
@@ -73,6 +73,9 @@ SYMBOL_SCOPE {
 	topo_mod_smbios			{ TYPE = FUNCTION; FLAGS = extern };
 	topo_mod_pcidb			{ TYPE = FUNCTION; FLAGS = extern };
 
+	topo_mod_create_ufm		{ TYPE = FUNCTION; FLAGS = extern };
+	topo_mod_create_ufm_slot	{ TYPE = FUNCTION; FLAGS = extern };
+
 	topo_method_register		{ TYPE = FUNCTION; FLAGS = extern };
 	topo_method_unregister		{ TYPE = FUNCTION; FLAGS = extern };
 	topo_method_unregister_all	{ TYPE = FUNCTION; FLAGS = extern };
diff --git a/usr/src/lib/fm/topo/modules/common/disk/disk_common.c b/usr/src/lib/fm/topo/modules/common/disk/disk_common.c
index 8088e79f02..68f3c8735b 100644
--- a/usr/src/lib/fm/topo/modules/common/disk/disk_common.c
+++ b/usr/src/lib/fm/topo/modules/common/disk/disk_common.c
@@ -304,6 +304,23 @@ disk_set_props(topo_mod_t *mod, tnode_t *parent,
 	}
 	err = 0;
 
+	/*
+	 * Create UFM node to capture the drive firmware version
+	 */
+	if (dnode->ddn_firm != NULL) {
+		topo_ufm_slot_info_t slotinfo = { 0 };
+
+		slotinfo.usi_version = dnode->ddn_firm;
+		slotinfo.usi_active = B_TRUE;
+		slotinfo.usi_mode = TOPO_UFM_SLOT_MODE_RW;
+		if (topo_node_range_create(mod, dtn, UFM, 0, 0) != 0 ||
+		    topo_mod_create_ufm(mod, dtn, "drive firmware",
+		    &slotinfo) == NULL) {
+			topo_mod_dprintf(mod, "failed to create %s node", UFM);
+			goto out;
+		}
+	}
+
 out:
 	if (drive_descr != NULL)
 		dm_free_descriptor(drive_descr);
diff --git a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
index 1220305584..5d6c516e45 100644
--- a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
+++ b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <assert.h>
@@ -515,6 +515,7 @@ ipmi_enum_sp(topo_mod_t *mod, tnode_t *pnode)
 	nvlist_t *auth, *fmri;
 	tnode_t *sp_node;
 	topo_pgroup_info_t pgi;
+	topo_ufm_slot_info_t slotinfo = { 0 };
 	int err, ch, i, ret = -1;
 
 	if ((ihp = topo_mod_ipmi_hold(mod)) == NULL)
@@ -576,6 +577,18 @@ ipmi_enum_sp(topo_mod_t *mod, tnode_t *pnode)
 	}
 	nvlist_free(fmri);
 
+	/*
+	 * Create UFM node to capture the SP LOM version
+	 */
+	slotinfo.usi_version = sp_rev;
+	slotinfo.usi_active = B_TRUE;
+	slotinfo.usi_mode = TOPO_UFM_SLOT_MODE_RW;
+	if (topo_node_range_create(mod, sp_node, UFM, 0, 0) != 0 ||
+	    topo_mod_create_ufm(mod, sp_node, "LOM", &slotinfo) == NULL) {
+		topo_mod_dprintf(mod, "failed to create %s node", UFM);
+		goto out;
+	}
+
 	/*
 	 * Iterate through the channels to find the LAN channel.
 	 */
diff --git a/usr/src/lib/fm/topo/modules/common/pcibus/pcibus.c b/usr/src/lib/fm/topo/modules/common/pcibus/pcibus.c
index 1417440b2f..437501b706 100644
--- a/usr/src/lib/fm/topo/modules/common/pcibus/pcibus.c
+++ b/usr/src/lib/fm/topo/modules/common/pcibus/pcibus.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 #include <sys/fm/protocol.h>
@@ -31,6 +31,8 @@
 #include <string.h>
 #include <strings.h>
 #include <alloca.h>
+#include <fcntl.h>
+#include <unistd.h>
 #include <sys/param.h>
 #include <sys/pci.h>
 #include <sys/pcie.h>
@@ -38,6 +40,9 @@
 #include <libnvpair.h>
 #include <fm/topo_mod.h>
 #include <fm/topo_hc.h>
+#include <sys/ddi_ufm.h>
+#include <sys/stat.h>
+#include <sys/types.h>
 
 #include <hostbridge.h>
 #include <pcibus.h>
@@ -159,6 +164,181 @@ hostbridge_asdevice(topo_mod_t *mod, tnode_t *bus)
 	return (0);
 }
 
+static int
+pciexfn_add_ufm(topo_mod_t *mod, tnode_t *node)
+{
+	char *devpath = NULL;
+	ufm_ioc_getcaps_t ugc = { 0 };
+	ufm_ioc_bufsz_t ufbz = { 0 };
+	ufm_ioc_report_t ufmr = { 0 };
+	nvlist_t *ufminfo = NULL, **images;
+	uint_t nimages;
+	int err, fd, ret = -1;
+
+	topo_mod_dprintf(mod, "Opening %s", DDI_UFM_DEV);
+	if ((fd = open(DDI_UFM_DEV, O_RDONLY)) < 0) {
+		topo_mod_dprintf(mod, "%s: failed to open %s", __func__,
+		    DDI_UFM_DEV);
+		return (0);
+	}
+	if (topo_prop_get_string(node, TOPO_PGROUP_IO, TOPO_IO_DEV, &devpath,
+	    &err) != 0) {
+		(void) close(fd);
+		return (topo_mod_seterrno(mod, EMOD_UNKNOWN));
+	}
+
+	/*
+	 * Make an ioctl to probe if the driver for this function is
+	 * UFM-capable.  If the ioctl fails or if it doesn't advertise the
+	 * DDI_UFM_CAP_REPORT capability, we bail out.
+	 */
+	ugc.ufmg_version = DDI_UFM_CURRENT_VERSION;
+	(void) strncpy(ugc.ufmg_devpath, devpath, MAXPATHLEN);
+	if (ioctl(fd, UFM_IOC_GETCAPS, &ugc) < 0) {
+		topo_mod_dprintf(mod, "UFM_IOC_GETCAPS failed: %s",
+		    strerror(errno));
+		(void) close(fd);
+		topo_mod_strfree(mod, devpath);
+		return (0);
+	}
+	if (! (ugc.ufmg_caps & DDI_UFM_CAP_REPORT)) {
+		topo_mod_dprintf(mod, "driver doesn't advertise "
+		    "DDI_UFM_CAP_REPORT");
+		(void) close(fd);
+		topo_mod_strfree(mod, devpath);
+		return (0);
+	}
+
+	/*
+	 * If we made it this far, then the driver is indeed UFM-capable and
+	 * is capable of reporting its firmware information.  First step is to
+	 * make an ioctl to query the size of the report data so that we can
+	 * allocate a buffer large enough to hold it.
+	 */
+	ufbz.ufbz_version = DDI_UFM_CURRENT_VERSION;
+	(void) strncpy(ufbz.ufbz_devpath, devpath, MAXPATHLEN);
+	if (ioctl(fd, UFM_IOC_REPORTSZ, &ufbz) < 0) {
+		topo_mod_dprintf(mod, "UFM_IOC_REPORTSZ failed: %s\n",
+		    strerror(errno));
+		(void) close(fd);
+		topo_mod_strfree(mod, devpath);
+		return (0);
+	}
+
+	ufmr.ufmr_version = DDI_UFM_CURRENT_VERSION;
+	if ((ufmr.ufmr_buf = topo_mod_alloc(mod, ufbz.ufbz_size)) == NULL) {
+		topo_mod_dprintf(mod, "failed to alloc %u bytes\n",
+		    ufbz.ufbz_size);
+		(void) close(fd);
+		topo_mod_strfree(mod, devpath);
+		return (topo_mod_seterrno(mod, EMOD_NOMEM));
+	}
+	ufmr.ufmr_bufsz = ufbz.ufbz_size;
+	(void) strncpy(ufmr.ufmr_devpath, devpath, MAXPATHLEN);
+	topo_mod_strfree(mod, devpath);
+
+	/*
+	 * Now, make the ioctl to retrieve the actual report data.  The data
+	 * is stored as a packed nvlist.
+	 */
+	if (ioctl(fd, UFM_IOC_REPORT, &ufmr) < 0) {
+		topo_mod_dprintf(mod, "UFM_IOC_REPORT failed: %s\n",
+		    strerror(errno));
+		topo_mod_free(mod, ufmr.ufmr_buf, ufmr.ufmr_bufsz);
+		(void) close(fd);
+		return (topo_mod_seterrno(mod, EMOD_UNKNOWN));
+	}
+	(void) close(fd);
+
+	if (nvlist_unpack(ufmr.ufmr_buf, ufmr.ufmr_bufsz, &ufminfo,
+	    NV_ENCODE_NATIVE) != 0) {
+		topo_mod_dprintf(mod, "failed to unpack nvlist\n");
+		topo_mod_free(mod, ufmr.ufmr_buf, ufmr.ufmr_bufsz);
+		return (topo_mod_seterrno(mod, EMOD_UNKNOWN));
+	}
+	topo_mod_free(mod, ufmr.ufmr_buf, ufmr.ufmr_bufsz);
+
+	if (nvlist_lookup_nvlist_array(ufminfo, DDI_UFM_NV_IMAGES, &images,
+	    &nimages) != 0) {
+		topo_mod_dprintf(mod, "failed to lookup %s nvpair",
+		    DDI_UFM_NV_IMAGES);
+		(void) topo_mod_seterrno(mod, EMOD_UNKNOWN);
+		goto err;
+	}
+	if (topo_node_range_create(mod, node, UFM, 0, (nimages - 1)) != 0) {
+		topo_mod_dprintf(mod, "failed to create %s range", UFM);
+		/* errno set */
+		goto err;
+	}
+	for (uint_t i = 0; i < nimages; i++) {
+		tnode_t *ufmnode = NULL;
+		char *descr;
+		uint_t nslots;
+		nvlist_t **slots;
+
+		if (nvlist_lookup_string(images[i], DDI_UFM_NV_IMAGE_DESC,
+		    &descr) != 0 ||
+		    nvlist_lookup_nvlist_array(images[i],
+		    DDI_UFM_NV_IMAGE_SLOTS, &slots, &nslots) != 0) {
+			(void) topo_mod_seterrno(mod, EMOD_UNKNOWN);
+			goto err;
+		}
+		if ((ufmnode = topo_mod_create_ufm(mod, node, descr, NULL)) ==
+		    NULL) {
+			topo_mod_dprintf(mod, "failed to create ufm nodes for "
+			    "%s", descr);
+			/* errno set */
+			goto err;
+		}
+		for (uint_t s = 0; s < nslots; s++) {
+			topo_ufm_slot_info_t slotinfo = { 0 };
+			uint32_t slotattrs;
+
+			if (nvlist_lookup_string(slots[s],
+			    DDI_UFM_NV_SLOT_VERSION,
+			    (char **)&slotinfo.usi_version) != 0 ||
+			    nvlist_lookup_uint32(slots[s],
+			    DDI_UFM_NV_SLOT_ATTR, &slotattrs) != 0) {
+				topo_node_unbind(ufmnode);
+				topo_mod_dprintf(mod, "malformed slot nvlist");
+				(void) topo_mod_seterrno(mod, EMOD_UNKNOWN);
+				goto err;
+			}
+			(void) nvlist_lookup_nvlist(slots[s],
+			    DDI_UFM_NV_SLOT_MISC, &slotinfo.usi_extra);
+
+			if (slotattrs & DDI_UFM_ATTR_READABLE &&
+			    slotattrs & DDI_UFM_ATTR_WRITEABLE)
+				slotinfo.usi_mode = TOPO_UFM_SLOT_MODE_RW;
+			else
+				slotinfo.usi_mode = TOPO_UFM_SLOT_MODE_RO;
+
+			if (slotattrs & DDI_UFM_ATTR_ACTIVE)
+				slotinfo.usi_active = B_TRUE;
+
+			if (topo_node_range_create(mod, ufmnode, SLOT, 0,
+			    (nslots - 1)) < 0) {
+				topo_mod_dprintf(mod, "failed to create %s "
+				    "range", SLOT);
+				/* errno set */
+				goto err;
+			}
+			if (topo_mod_create_ufm_slot(mod, ufmnode,
+			    &slotinfo) == NULL) {
+				topo_node_unbind(ufmnode);
+				topo_mod_dprintf(mod, "failed to create ufm "
+				    "slot %d for %s", s, descr);
+				/* errno set */
+				goto err;
+			}
+		}
+	}
+	ret = 0;
+err:
+	nvlist_free(ufminfo);
+	return (ret);
+}
+
 tnode_t *
 pciexfn_declare(topo_mod_t *mod, tnode_t *parent, di_node_t dn,
     topo_instance_t i)
@@ -235,6 +415,17 @@ pciexfn_declare(topo_mod_t *mod, tnode_t *parent, di_node_t dn,
 		topo_node_unbind(ntn);
 		return (NULL);
 	}
+
+	/*
+	 * Check if the driver associated with this function exports firmware
+	 * information via the DDI UFM subsystem and, if so, create the
+	 * corresponding ufm topo nodes.
+	 */
+	if (pciexfn_add_ufm(mod, ntn) != 0) {
+		topo_node_unbind(ntn);
+		return (NULL);
+	}
+
 	/*
 	 * We may find pci-express buses or plain-pci buses beneath a function
 	 */
diff --git a/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c b/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
index cdbb9d566e..8d20f943a4 100644
--- a/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
+++ b/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
@@ -520,18 +520,6 @@ smbios_enum_motherboard(smbios_hdl_t *shp, smb_enum_data_t *smed)
 	if (rc == 0 && asset != NULL)
 		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
 		    TOPO_PROP_MB_ASSET, TOPO_PROP_IMMUTABLE, asset, &err);
-	if (rc == 0 && bios_vendor != NULL)
-		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
-		    TOPO_PROP_MB_FIRMWARE_VENDOR, TOPO_PROP_IMMUTABLE,
-		    bios_vendor, &err);
-	if (rc == 0 && bios_rev != NULL)
-		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
-		    TOPO_PROP_MB_FIRMWARE_REV, TOPO_PROP_IMMUTABLE,
-		    bios_rev, &err);
-	if (rc == 0 && bios_reldate != NULL)
-		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
-		    TOPO_PROP_MB_FIRMWARE_RELDATE, TOPO_PROP_IMMUTABLE,
-		    bios_reldate, &err);
 
 	if (rc != 0) {
 		topo_mod_dprintf(mod, "error setting properties on %s node",
@@ -539,6 +527,44 @@ smbios_enum_motherboard(smbios_hdl_t *shp, smb_enum_data_t *smed)
 		(void) topo_mod_seterrno(mod, err);
 		goto err;
 	}
+	/*
+	 * If we were able to gleen the BIOS version from SMBIOS, then set
+	 * up a UFM node to capture that information.
+	 */
+	if (bios_rev != NULL) {
+		topo_ufm_slot_info_t slotinfo = { 0 };
+		nvlist_t *extra;
+
+		slotinfo.usi_version = bios_rev;
+		slotinfo.usi_active = B_TRUE;
+		slotinfo.usi_mode = TOPO_UFM_SLOT_MODE_RW;
+
+		if (bios_vendor != NULL || bios_reldate != NULL) {
+			if (nvlist_alloc(&extra, NV_UNIQUE_NAME, 0) != 0) {
+				goto err;
+			}
+			if (bios_vendor != NULL && nvlist_add_string(extra,
+			    TOPO_PROP_MB_FIRMWARE_VENDOR, bios_vendor) != 0) {
+				nvlist_free(extra);
+				goto err;
+			}
+			if (bios_reldate != NULL && nvlist_add_string(extra,
+			    TOPO_PROP_MB_FIRMWARE_RELDATE, bios_reldate) !=
+			    0) {
+				nvlist_free(extra);
+				goto err;
+			}
+			slotinfo.usi_extra = extra;
+		}
+		if (topo_node_range_create(mod, mbnode, UFM, 0, 0) != 0) {
+			topo_mod_dprintf(mod, "failed to create %s range",
+			    UFM);
+			goto err;
+		}
+		(void) topo_mod_create_ufm(mod, mbnode, "BIOS", &slotinfo);
+		nvlist_free(extra);
+	}
+
 err:
 	topo_mod_strfree(mod, manuf);
 	topo_mod_strfree(mod, prod);
diff --git a/usr/src/man/man7d/Makefile b/usr/src/man/man7d/Makefile
index c984ee588a..67e0be0750 100644
--- a/usr/src/man/man7d/Makefile
+++ b/usr/src/man/man7d/Makefile
@@ -12,7 +12,7 @@
 #
 # Copyright 2011, Richard Lowe
 # Copyright 2016 Garrett D'Amore <garrett@damore.org>
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright 2019 Peter Tribble
@@ -126,6 +126,7 @@ _MANFILES=	aac.7d		\
 		tty.7d		\
 		ttymux.7d	\
 		tzmon.7d	\
+		ufm.7d		\
 		ugen.7d		\
 		uhci.7d		\
 		usb_ac.7d	\
diff --git a/usr/src/man/man7d/ufm.7d b/usr/src/man/man7d/ufm.7d
new file mode 100644
index 0000000000..984a238ec4
--- /dev/null
+++ b/usr/src/man/man7d/ufm.7d
@@ -0,0 +1,247 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright 2019 Joyent, Inc.
+.\"
+.TH UFM 7D "May 7, 2019"
+.SH NAME
+ufm \- Upgradeable Firmware Module driver
+.SH SYNOPSIS
+.LP
+.nf
+\fB/dev/ufm\fR
+.fi
+
+.SH DESCRIPTION
+.LP
+The ufm device is a character special file that provides acccess to
+Upgradeable Firmware Image information, as described in ddi_ufm(7E)
+via an ioctl interface.
+
+.SH FILES
+.sp
+.ne 2
+.na
+\fB\fB/kernel/drv/amd64/ufm\fR \fR
+.ad
+.sp .6
+.RS 4n
+64-bit AMD64 ELF kernel driver \fR
+.RE
+.sp
+.ne 2
+.na
+\fB\fB/kernel/drv/sparcv9/ufm\fR \fR
+.ad
+.sp .6
+.RS 4n
+64-bit SPARC ELF kernel driver \fR
+.RE
+.sp
+.ne 2
+.na
+\fB\fB/kernel/drv/ufm.conf\fR \fR
+.ad
+.sp .6
+.RS 4n
+Driver configuration file \fR
+.RE
+
+.SH IOCTLS
+.LP
+The ufm driver implements a versioned ioctl interface for accessing UFM
+facilities.
+The ioctl interfaces are defined in sys/ddi_ufm.h.
+The following ioctl cmds are supported by DDI_UFM_VERSION_ONE:
+.sp
+.ne 2
+.na
+\fB UFM_IOC_GETCAPS\fR
+.sp
+.ad
+.RS 3n
+The UFM_IOC_GETCAPS ioctl is used to retrieve a the set of DDI UFM
+capabilities supported by this device instance.
+Currently there is only a single capability DDI_UFM_CAP_REPORT, which indicates
+that the driver is capable of reporting UFM information.  
+
+The ddi_ufm_cap_t type defines a bitfield enumerating the full set of DDI UFM
+capabilities.
+.sp
+.nf
+typedef enum {
+	DDI_UFM_CAP_REPORT	= 1 << 0,
+} ddi_ufm_cap_t;
+.fi
+
+The ufm_ioc_getcaps_t type defines the input/output data for the
+UFM_IOC_GETCAPS ioctl. Callers should specify the ufmg_version and ufmg_devpath
+fields.
+On success the ufmg_caps field will be filled in with a value indicating the
+supported UFM capabilities of the device specified in ufmg_devpath.
+.sp
+.nf
+typedef struct ufm_ioc_getcaps {
+	uint_t 		ufmg_version;	/* DDI_UFM_VERSION */
+	uint_t		ufmg_caps;	/* UFM Caps */
+	char 		ufmg_devpath[MAXPATHLEN];
+} ufm_ioc_getcaps_t;
+.fi
+.RE
+
+\fB UFM_IOC_REPORTSZ\fR
+.ad
+.RS 3n
+.sp
+The UFM_IOC_REPORTSZ ioctl is used to retrieve the amount of space (in bytes)
+required to hold the UFM data for this device instance.
+This should be used to allocate a sufficiently size buffer for the
+UFM_IOC_REPORT ioctl.
+
+The ufm_ioc_bufsz_t struct defines the input/output data for the
+UFM_IOC_REPORTSZ ioctl.
+Callers should specify the ufbz_version and ufbz_devpath fields.
+On success the ufmg_size field will be filled in with the required buffer size.
+.sp
+.nf
+typedef struct ufm_ioc_bufsz {
+	uint_t 		ufbz_version;	/* DDI_UFM_VERSION */
+	size_t		ufbz_size;	/* sz of buf to be returned by ioctl */
+	char		ufbz_devpath[MAXPATHLEN];
+} ufm_ioc_bufsz_t;
+.fi
+.RE
+
+\fB UFM_IOC_REPORT\fR
+.ad
+.RS 3n
+.sp
+The UFM_IOC_REPORT ioctl returns UFM image and slot data in the form of a
+packed nvlist.
+
+The ufm_ioc_report_t struct defines the input/output data for the UFM_IOC_REPORT
+ioctl.
+Callers should specify the ufmr_version, ufmr_bufsz and ufmr_devpath fields.
+On success, the ufmr_buf field will point to a packed nvlist containing the UFM
+data for the specified device instance.
+.sp
+.nf
+typedef struct ufm_ioc_report {
+	uint_t		ufmr_version;	/* DDI_UFM_VERSION */
+	size_t		ufmr_bufsz;	/* size of caller-supplied buffer */
+	caddr_t		ufmr_buf;	/* buf to hold packed output nvl */
+	char		ufmr_devpath[MAXPATHLEN];
+} ufm_ioc_report_t;
+.fi
+.RE
+
+.SH EXAMPLE
+.LP
+This example demonstrates how to use the UFM_IOC_GETCAPS ioctl to determine
+the UFM capabilities of a given device instance.
+
+.sp
+.in +2
+.nf
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ddi_ufm.h>
+#include <sys/types.h>
+
+static const char devname[] = "/pci@ce,0/pci8086,2030@0/pci15d9,808@0";
+
+int
+main(int argc, char **argv)
+{
+        int fd;
+        ufm_ioc_getcaps_t ioc = { 0 };
+
+        if ((fd = open(DDI_UFM_DEV, O_RDWR)) < 0) {
+                (void) fprintf(stderr, "failed to open %s (%s)\n", DDI_UFM_DEV,
+                    strerror(errno));
+                return (1);
+        }
+
+        ioc.ufmg_version = DDI_UFM_CURRENT_VERSION;
+        (void) strcpy(ioc.ufmg_devpath, devname);
+
+        if (ioctl(fd, UFM_IOC_GETCAPS, &ioc) < 0) {
+                (void) fprintf(stderr, "getcaps ioctl failed (%s)\n",
+                    strerror(errno));
+                (void) close(fd);
+                return (1);
+        }
+        if ((ioc.ufmg_caps & DDI_UFM_CAP_REPORT) == 0) {
+                (void) printf("Ddriver does not support DDI_UFM_CAP_REPORT\n");
+        } else {
+                (void) printf("Driver supports DDI_UFM_CAP_REPORT\n");
+        }
+        (void) close(fd);
+        return (0);
+}
+
+.fi
+.in -2
+
+.SH ERRORS
+.ne 2
+.na
+\fBENOTUP\fR
+.ad
+.RS 10n
+The requested ioctl is not supported by the target device.
+.RE
+
+.sp
+.ne 2
+.na
+\fBEFAULT\fR
+.ad
+.RS 10n
+The ufd driver encouontered a failure to copying data either from to or to the
+address space of the calling process.
+.RE
+
+\fBEAGAIN\fR
+.ad
+.RS 10n
+The device driver is not currently ready to accept calls to it's DDI UFM entry
+points.  This may be because the driver is not fully initialized or because the
+driver is in the process of detaching.
+.RE
+
+\fBEIO\fR
+.ad
+.RS 10n
+A failure occurred while executing a DDI UFM entry point.
+.RE
+
+.SH ATTRIBUTES
+.LP
+See \fBattributes\fR(5) for descriptions of the following attributes:
+.sp
+.TS
+box;
+c | c
+l | l .
+ATTRIBUTE TYPE	ATTRIBUTE VALUE
+_
+Interface Stability	Evolving
+.TE
+
+.SH SEE ALSO
+.LP
+\fBddi_ufm\fR(9E), \fBddi_ufm\fR(9F), \fBddi_ufm_image\fR(9E), \fBddi_ufm_slot\fR(9E),
+\fBattributes\fR(5)
diff --git a/usr/src/man/man9e/Makefile b/usr/src/man/man9e/Makefile
index 8036f34cda..d51daf342d 100644
--- a/usr/src/man/man9e/Makefile
+++ b/usr/src/man/man9e/Makefile
@@ -12,7 +12,7 @@
 #
 # Copyright 2011, Richard Lowe
 # Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 include		$(SRC)/Makefile.master
@@ -28,6 +28,7 @@ MANFILES=	Intro.9e		\
 		close.9e		\
 		csx_event_handler.9e	\
 		detach.9e		\
+		ddi_ufm.9e		\
 		devmap.9e		\
 		devmap_access.9e	\
 		devmap_contextmgt.9e	\
diff --git a/usr/src/man/man9e/ddi_ufm.9e b/usr/src/man/man9e/ddi_ufm.9e
new file mode 100644
index 0000000000..f678c55499
--- /dev/null
+++ b/usr/src/man/man9e/ddi_ufm.9e
@@ -0,0 +1,372 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright (c) 2019, Joyent, Inc.
+.\"
+.Dd Apr 30, 2019
+.Dt DDI_UFM 9E
+.Os
+.Sh NAME
+.Nm ddi_ufm ,
+.Nm ddi_ufm_op_nimages ,
+.Nm ddi_ufm_op_fill_image ,
+.Nm ddi_ufm_op_nslots ,
+.Nm ddi_ufm_op_fil_slot
+.Nd DDI upgradable firmware module entry points
+.Sh SYNOPSIS
+.Vt typedef struct ddi_ufm_handle ddi_ufm_handle_t
+.Vt typedef struct ddi_ufm_ops ddi_ufm_ops_t
+.In sys/ddi_ufm.h
+.Ft int
+.Fo ddi_ufm_op_nimages
+.Fa "ddi_ufm_handle_t *uhp"
+.Fa "void *drv_arg"
+.Fa "uint_t *nimgp"
+.Fc
+.Ft int
+.Fo ddi_ufm_op_fill_image
+.Fa "ddi_ufm_handle_t *uhp"
+.Fa "void *drv_arg"
+.Fa "uint_t imgid"
+.Fa "ddi_ufm_image_t *uip"
+.Fc
+.Ft int
+.Fo ddi_ufm_fill_slot
+.Fa "ddi_ufm_handle_t *uhp"
+.Fa "void *drv_arg"
+.Fa "uint_t imgid"
+.Fa "uint_t slotid"
+.Fa "ddi_ufm_slot_t *usp"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Evolving - This interface is evolving still in illumos. API and ABI stability is not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa  uhp
+A handle corresponding to the device's UFM handle.
+This is the same value as returned in .Xr ddi_ufm_init 9F .
+.It Fa  drv_arg
+This is a private value that the driver passed in when calling
+.Xr ddi_ufm_init 9F .
+.Fa nimgp
+A pointer that the driver should set with a number of images.
+.Fa nslotp
+A pointer that the driver should set with a number of slots.
+.It Fa imgid
+An integer indicating which image information is being requested for.
+.It Fa uip
+An opaque pointer that represents a UFM image.
+.It Fa slotid
+An integer indicating which slot information is being requested for.
+.It Fa usp
+An opaque pointer that represents a UFM slot.
+.El
+.Sh DESCRIPTION
+Upgradable firmware modules (UFM) are a potential component of many
+devices.
+These interfaces aim to provide a simple series of callbacks
+for a device driver to implement such that it is easy to report
+information and in the future, manipulate firmware modules.
+.Ss UFM Background
+UFMs may come in different flavors and styles ranging from a
+firmware blob, to an EEPROM image, to microcode, and more.
+Take for example a hard drive.
+While it contains a field replaceable unit (FRU), it also contains some amount
+of firmware that manages the drive and can be updated independently of replacing the drive.
+.Pp
+The motherboard often has a UFM in the form of the BIOS or UEFI.
+The Lights out management controller on a system has a UFM, which is usually
+the entire system image.
+CPUs also have a UFM in the form of microcode.
+.Pp
+An important property of a UFM is that it is a property of the device
+itself.
+For example, many WiFi device drivers are required to send a binary blob of
+firmware to the device after every reset.
+Because these images are not properties of the device and must be upgraded by
+either changing the device driver or related system files, we do not consider
+these UFMs.
+.Pp
+There are also devices that have firmware which is a property of the
+device, but may not be upgradable from the running OS.
+This may be because the vendor doesn't have tooling to upgrade the image or
+because the firmware image itself cannot be upgraded in the field at all.
+For example, a YubiKey has a firmware image that's burned into it in the
+factory, but there is no way to change the firmware on it short of
+replacing the device in its entirety.
+However, because these images are a permanent part of the device, we also
+consider them a UFM.
+.Ss Images and Slots
+A device that supports UFMs is made up of one or more distinct firmware
+images.
+Each image has its own unique purpose.
+For example, a motherboard may have both a BIOS and a CPLD image, each of which
+has independent firmware revisions.
+.Pp
+A given image may have a number of slots.
+A slot represents a particular version of the image.
+Only one slot can be active at a given time.
+Devices support slots such that a firmware image can be downloaded
+to the device without impacting the current device if it fails half-way
+through.
+The slot that's currently in use is referred to as the .Em active slot.
+.Pp
+The various entry points are designed such that all a driver has to do
+is provide information about the image and its slots to the kernel, it
+does not have to wrangle with how that is marshalled to users and the
+appearance of those structures.
+.Ss Registering with the UFM Subsystem
+During a device driver's
+.Xr attach 9E
+entry point, a device driver should register with the UFM subsystem by
+filling out a UFM operations vector and then calling
+.Xr ddi_ufm_init 9F .
+The driver may pass in a value, usually a pointer to its soft state
+pointer, which it will then receive when its subsequent entry points are
+called.
+.Pp
+Once the driver has finished initializing, it must call
+.Xr ddi_ufm_update 9F
+to indicate that the driver is in a state where it's ready to receive
+calls to the entry points.
+.Pp
+The various UFM entry points may be called from an arbitrary kernel
+context.
+However, they will only ever be called from a single thread at
+a given time.
+.Ss UFM operations vector
+The UFM operations vector is a structure that has the following members:
+.Bd -literal -offset indent
+typedef struct ddi_ufm_ops {
+	int (*ddi_ufm_op_nimages)(ddi_ufm_handle_t *uhp, void *arg,
+	    uint_t *nimgp);
+	int (*ddi_ufm_op_fill_image)(ddi_ufm_handle_t *uhp, void *arg,
+            uint_t imgid, ddi_ufm_image_t *img);
+	int (*ddi_ufm_op_fill_slot)(ddi_ufm_handle_t *uhp, void *arg,
+            int imgid, ddi_ufm_image_t *img, uint_t slotid,
+	    ddi_ufm_slot_t *slotp);
+} ddi_ufm_ops_t;
+.Ed
+.Pp
+The .Fn ddi_ufm_op_nimages entry point is optional.
+If a device only has a single image, then there is no reason to implement the
+.Fn ddi_ufm_op_nimages entry point.
+The system will assume that there is only a single image.
+.Pp
+Slots and images are numbered starting at zero.
+If a driver indicates support for multiple images or slots then the images
+or slots will be numbered sequentially going from 0 to the number of images or
+slots minus one.
+These values will be passed to the various entry points to indicate which image
+and slot the system is interested in.
+It is up to the driver to maintain a consistent view of the images and slots
+for a given UFM.
+.Pp
+The members of this structure should be filled in the following ways:
+.Bl -tag -width Fn
+.It Fn ddi_ufm_op_nimages
+The
+.Fn ddi_ufm_op_nimages
+entry point is an optional entry point that answers the question of how
+many different, distinct firmware images are present on the device.
+Once the driver determines how many are present, it should set the value in
+.Fa nimgp to the determined value.
+.Pp
+It is legal for a device to pass in zero for this value, which indicates
+that there are none present.
+.Pp
+Upon successful completion, the driver should return
+.Sy 0 .
+Otherwise, the driver should return the appropriate error number.
+For a full list of error numbers, see
+.Xr Intro 2 .
+Common values are:
+.Bl -tag -width Er -offset width
+.It Er EIO
+An error occurred while communicating with the device to determine the
+number of firmware images.
+.El
+.It Fn ddi_ufm_op_fill_image
+The
+.Fn ddi_ufm_op_fill_image
+entry point is used to fill in information about a given image.
+The value in
+.Fa imgid
+is used to indicate which image the system is asking to fill
+information about.
+If the driver does not recognize the image ID in
+.Fa imgid
+then it should return an error.
+.Pp
+The
+.Ft ddi_ufm_image_t
+structure passed in
+.Fa uip
+is opaque.
+To fill in information about the image, the driver should call the functions
+described in
+.Xr ddi_ufm_image 9F .
+.Pp
+The driver should call the
+.Xr ddi_ufm_image_set_desc 9F
+function to set a description of the image which indicates its purpose.
+This should be a human-readable string.
+The driver may also set any ancillary data that it deems may be useful with the
+.Xr ddi_ufm_image_set_misc 9F function.
+This function takes an nvlist, allowing the driver to set arbitrary keys and values.
+.Pp
+Once the driver has finished setting all of the information about the
+image then the driver should return
+.Sy 0 .
+Otherwise, the driver should return the appropriate error number.
+For a full list of error numbers, see
+.Xr Intro 2 .
+Common values are:
+.Bl -tag -width Er -offset width
+.It Er EINVAL
+The image indicated by
+.Fa imgid
+is unknown.
+.It Er EIO
+An error occurred talking to the device while trying to fill out
+firmware image information.
+.It Er ENOMEM
+The driver was unable to allocate memory while filling out image
+information.
+.El
+.It Fn ddi_ufm_op_fill_slot
+The
+.Fn ddi_ufm_op_fill_slot
+function is used to fill in information about a specific slot for a
+specific image.
+The value in
+.Fa imgid
+indicates the image the system wants slot information for and the value
+in
+.Fa slotid
+indicates which slot of that image the system is interested in.
+If the device driver does not recognize the value in either or
+.Fa imgid
+or
+.Fa slotid ,
+then it should return an error.
+.Pp
+The
+.Ft ddi_ufm_slot_t
+structure passed in
+.Fa usp
+is opaque.
+To fill in information about the image the driver should call the functions
+described in
+.Xr ddi_ufm_slot 9F .
+.Pp
+The driver should call the
+.Xr ddi_ufm_slot_set_version 9F
+function to indicate the version of the UFM.
+The version is a device-specific character string.
+It should contain the current version of the UFM as a human can understand it
+and it should try to match the format used by device vendor.
+.Pp
+The
+.Xr ddi_ufm_slot_set_attrs 9F
+function should be used to set the attributes of the UFM slot.
+These attributes include the following enumeration values:
+.Bl -tag -width Dv
+.It Dv DDI_UFM_ATTR_READABLE
+This attribute indicates that the firmware image in the specified slot
+may be read, even if the device driver does not currently support such
+functionality.
+.It Dv DDI_UFM_ATTR_WRITEABLE
+This attributes indicates that the firmware image in the specified slot
+may be updated, even if the driver does not currently support such
+functionality.
+.El
+.Pp
+The
+.Xr ddi_ufm_set_primary 9F
+function should be used to indicate whether the specified slot is the
+primary slot.
+The primary slot is the one whose firmware revision is actively being used.
+If there is only one slot, then there is no need to call this function, it is
+always considered the primary.
+.Pp
+Finally, if there are any device-specific key-value pairs that form
+useful, ancillary data, then the driver should assemble an nvlist and
+pass it to the
+.Xr ddi_ufm_set_misc 9F
+function.
+.Pp
+Once the driver has finished setting all of the information about the
+slot then the driver should return
+.Sy 0 .
+Otherwise, the driver should return the appropriate error number.
+For a full list of error numbers, see
+.Xr Intro 2 .
+Common values are:
+.Bl -tag -width Er -offset width
+.It Er EINVAL
+The image or slot indicated by
+.Fa imgid
+and
+.Fa slotid
+is unknown.
+.It Er EIO
+An error occurred talking to the device while trying to fill out
+firmware slot information.
+.It Er ENOMEM
+The driver was unable to allocate memory while filling out slot 
+information.
+.El
+.El
+.Ss Caching and Updates
+The system will fetch firmware and slot information on an as-needed
+basis.
+Once it obtains some information, it may end up caching this information on
+behalf of the driver.
+Whenever the driver believes that something could have changed -- it need know
+that it has -- then the driver must call
+.Xr ddi_ufm_update 9F .
+.Ss Locking
+All UFM operations on a single UFM handle will always be run serially.
+However, the device driver may still need to apply adequate locking to
+its structure members as other may be accessing the same data structure
+or trying to communicate with the device.
+.Ss Unregistering from the UFM subsystem
+When a device driver is detached, it should unregister from the UFM
+subsystem.
+To do so, the driver should call
+.Xr ddi_ufm_fini 9F .
+By the time this function returns, the driver is guaranteed that no UFM
+entry points will be called.
+However, if there are outstanding UFM related activity, the function will
+block until it is terminated.
+.Ss ioctl Interface
+Userland consumers can access UFM information via a set of ioctls that are
+implemented by the ufd(7D) driver.
+.Sh CONTEXT
+The various UFM entry points that a device driver must implement will
+always be called from
+.Sy kernel
+context.
+.Sh SEE ALSO
+.Xr Intro 2 ,
+.Xr attach 9E ,
+.Xr ddi_ufm_fini 9F ,
+.Xr ddi_ufm_image 9F ,
+.Xr ddi_ufm_image_set_desc 9F ,
+.Xr ddi_ufm_image_set_misc 9F ,
+.Xr ddi_ufm_image_set_nslots 9F ,
+.Xr ddi_ufm_init 9F ,
+.Xr ddi_ufm_slot 9F ,
+.Xr ddi_ufm_slot_set_attrs 9F ,
+.Xr ddi_ufm_slot_set_misc 9F ,
+.Xr ddi_ufm_slot_set_version 9F ,
+.Xr ddi_ufm_update 9F
diff --git a/usr/src/man/man9f/Makefile b/usr/src/man/man9f/Makefile
index 6681cd036e..a7335ad4c9 100644
--- a/usr/src/man/man9f/Makefile
+++ b/usr/src/man/man9f/Makefile
@@ -12,7 +12,7 @@
 #
 # Copyright 2017, Richard Lowe
 # Copyright 2014 Garrett D'Amore <garrett@damore>
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 # Copyright 2016 Nexenta Systems, Inc.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 #
@@ -242,6 +242,9 @@ MANFILES=	ASSERT.9f				\
 		ddi_strtol.9f				\
 		ddi_strtoll.9f				\
 		ddi_strtoul.9f				\
+		ddi_ufm.9f				\
+		ddi_ufm_image.9f			\
+		ddi_ufm_slot.9f				\
 		ddi_umem_alloc.9f			\
 		ddi_umem_iosetup.9f			\
 		ddi_umem_lock.9f			\
diff --git a/usr/src/man/man9f/ddi_ufm.9f b/usr/src/man/man9f/ddi_ufm.9f
new file mode 100644
index 0000000000..3cb48ead7d
--- /dev/null
+++ b/usr/src/man/man9f/ddi_ufm.9f
@@ -0,0 +1,162 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright (c) 2019, Joyent, Inc.
+.\"
+.Dd Apr 30, 2019
+.Dt DDI_UFM 9F
+.Os
+.Sh NAME
+.Nm ddi_ufm ,
+.Nm ddi_ufm_init ,
+.Nm ddi_ufm_update ,
+.Nm ddi_ufm_fini
+.Nd DDI upgradable firmware module interfaces
+.Sh SYNOPSIS
+.In sys/ddi_ufm.h
+.Ft int
+.Fo ddi_ufm_init
+.Fa "dev_info_t *dip"
+.Fa "int version"
+.Fa "ddi_ufm_ops_t *ops"
+.Fa "ddi_ufm_handle_t **ufmpp"
+.Fa "void *drv_arg"
+.Fc
+.Ft void
+.Fo ddi_ufm_update
+.Fa "ddi_ufm_handle_t *ufmp"
+.Fc
+.Ft void
+.Fo ddi_ufm_fini
+.Fa "ddi_ufm_handle_t *ufmp"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Evolving -
+This interface is evolving still in illumos.
+API and ABI stability is not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa dip
+Pointer to the devices
+.Vt dev_info
+structure for the specific instance.
+.It Fa version
+A value which indicates the current revision of the interface that the
+device supports.
+Should generally be set to
+.Dv DDI_UFM_CURRENT_VERSION .
+.It Fa ops
+A pointer to a UFM operations structure.
+See
+.Xr ddi_ufm 9E
+for more information.
+.It Fa ufmp
+A pinter to the opaque handle returned from
+.Fn ddi_ufm_init .
+.It Fa ufmpp
+A pointer to store the opaque handle from
+.Fn ddi_ufm_init .
+.It Fa drv_arg
+A driver specific argument that will be passed to various operations.
+.El
+.Sh DESCRIPTION
+These functions provide support for initializing and performing various
+upgradeable firmware module (UFM) operations.
+For more information, please see
+.Xr ddi_ufm 9E .
+.Pp
+The
+.Fn ddi_ufm_init
+function is used to initialize support for the UFM subsystem for a given
+device.
+The
+.Fa dip
+argument should be the
+.Vt dev_info
+structure of the specific device.
+The
+.Fa version
+argument represents the current revision of the UFM interface that the
+driver supports.
+Drivers inside of illumos should always use
+.Dv DDI_UFM_CURRENT_VERSION .
+Device drivers which need to bind to a specific revision, should instead
+pass the latest version:
+.Dv DDI_UFM_VERSION_ONE .
+The operations structure,
+.Fa ops ,
+should be filled according to the rules in
+.Xr ddi_ufm 9E .
+These will be the entry points that device drivers call.
+The value of
+.Fa drv_arg
+will be passed to all of the driver's entry points.
+When the function returns,
+.Fa ufmpp
+will be filled in with a handle that the driver should reference when
+needing to perform subsequent UFM operations.
+No UFM entry points will be called until after the driver calls the
+.Fn ddi_ufm_update
+function.
+.Pp
+When the device driver is detaching or needs to unregister from the UFM
+subsystem, then the device driver should call the
+.Fn ddi_ufm_fini
+function with the handle that they obtained during the call to
+initialize.
+Note, this function will block and ensure that any outstanding UFM operations
+are terminated.
+The driver must not hold any locks that are required in its callbacks across
+the call to
+.Fn ddi_ufm_fini .
+.Pp
+The
+.Fn ddi_ufm_update
+function should be used in two different circumstances.
+It should be used at the end of a driver's
+.Xr attach 9E
+endpoint to indicate that it is ready to receive UFM requests.
+It should also be called whenever the driver believes that the UFM might have
+changed.
+This may happen after a device reset or firmware change.
+Unlike the other functions, this can be called from any context with any locks
+held, excepting high-level interrupt context which normal device drivers
+will not have interrupts for.
+.Sh RETURN VALUES
+Upon successful completion, the
+.Fn ddi_ufm_init
+function returns zero, indicating that it has successfully registered
+with the UFM subsystem.
+.Fa ufmpp
+will be filled in with a pointer to the UFM handle.
+.Pp
+The
+.Fn ddi_ufm_init
+and
+.Fn ddi_ufm_fini
+functions are generally called from a device's
+.Xr attach 9E
+and
+.Xr fini 9E
+routines, though they may be called from
+.Sy user
+or
+.Sy kernel
+context.
+.Pp
+The
+.Fn ddi_ufm_update
+function may be called from any context except a high-level interrupt
+handler above lock level.
+.Sh SEE ALSO
+.Xr attach 9E ,
+.Xr ddi_ufm 9E ,
+.Xr fini 9E
diff --git a/usr/src/man/man9f/ddi_ufm_image.9f b/usr/src/man/man9f/ddi_ufm_image.9f
new file mode 100644
index 0000000000..9ca4cd8ec9
--- /dev/null
+++ b/usr/src/man/man9f/ddi_ufm_image.9f
@@ -0,0 +1,88 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright 2019 Joyent, Inc.
+.\"
+.Dd Apr 30, 2019
+.Dt DDI_UFM_IMAGE 9F
+.Os
+.Sh NAME
+.Nm ddi_ufm_image_set_desc ,
+.Nm ddi_ufm_image_set_misc
+.Nd UFM image property routines
+.Sh SYNOPSIS
+.In sys/ddi_ufm.h
+.Ft void
+.Fo ddi_ufm_image_set_desc
+.Fa "ddi_ufm_image_t *uip"
+.Fa "const char *description"
+.Fc
+.Ft void
+.Fo ddi_ufm_image_set_misc
+.Fa "ddi_ufm_image_t *uip"
+.Fa "nvlist_t *nvl"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Evolving -
+This interface is evolving still in illumos.
+API and ABI stability is not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa uip
+A pointer to a UFM image that was passed to the driver in its
+.Xr ddi_ufm_op_fill_image 9E
+entry point.
+.It Fa description
+A human-readable description of the firmware image.
+.It Fa nvl
+An nvlist_t with ancillary, device-specific data.
+.El
+.Sh DESCRIPTION
+The
+.Fn ddi_ufm_image_set_desc
+and
+.Fn ddi_ufm_image_set_misc
+functions are used by device drivers to set information about a firmware
+image on the image structure
+.Fa uip
+as a part of implementing their
+.Xr ddi_ufm_op_fill_image 9E
+entry point.
+For more information on images and the use of these functions, see the
+descrption of the
+.Fn ddi_ufm_op_fill_image
+function in
+.Xr ddi_ufm 9E .
+.Pp
+The
+.Fn ddi_ufm_image_set_desc
+function sets the description of the firmware image.
+This description is intended for administrators and should convey the intended
+use of the image.
+.Pp
+The
+.Fn ddi_ufm_image_set_misc
+function is used by drivers to set ancillary key-value data that may be
+useful to a consumer.
+The driver should create an nvlist for this purpose with
+.Xr nvlist_alloc 9F
+Once the driver passes the nvlist to the
+.Fn ddi_ufm_image_set_misc
+function, then the driver must not manipulate or free the nvlist at all.
+It is the property of the UFM subsystem.
+.Sh CONTEXT
+These function should only be called in the context of the
+.Xr ddi_ufm_op_fill_image 9E
+entry point.
+.Sh SEE ALSO
+.Xr ddi_ufm 9E ,
+.Xr ddi_ufm_op_fill_image 9E ,
+.Xr nvlist_alloc 9F
diff --git a/usr/src/man/man9f/ddi_ufm_slot.9f b/usr/src/man/man9f/ddi_ufm_slot.9f
new file mode 100644
index 0000000000..c547905581
--- /dev/null
+++ b/usr/src/man/man9f/ddi_ufm_slot.9f
@@ -0,0 +1,111 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright 2019 Joyent, Inc.
+.\"
+.Dd Apr 30, 2019
+.Dt DDI_UFM_SLOT 9F
+.Os
+.Sh NAME
+.Nm ddi_ufm_slot ,
+.Nm ddi_ufm_slot_set_version ,
+.Nm ddi_ufm_slot_set_attrs ,
+.Nm ddi_ufm_slot_set_misc
+.Nd UFM slot property routines
+.Sh SYNOPSIS
+#include <sys/ddi_ufm.h>
+.sp
+.Ft void
+.Fo ddi_ufm_slot_set_version
+.Fa "ddi_ufm_slot_t *usp"
+.Fa "const char *version"
+.Fc
+.Ft void
+.Fo ddi_ufm_slot_set_attrs
+.Fa "ddi_ufm_slot_t *usp"
+.Fa "ddi_ufm_attr_t attrs"
+.Fc
+.Ft void
+.Fo ddi_ufm_slot_set_misc
+.Fa "ddi_ufm_slot_t *usp"
+.Fa "nvlist_t *nvl"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Evolving -
+This interface is evolving still in illumos.
+API and ABI stability is not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa usp
+A pointer to a UFM slot structure that was passed to the driver in its
+.Xr ddi_ufm_op_fill_slot 9E
+entry point.
+.It Fa version
+A device-specific ASCII string that indicates the current version of the
+firmware image in the slot.
+.It Fa attrs
+The bitwise-inclusive-OR of one of several attributes of a firmware
+slot.
+See the discussion of the
+.Fn ddi_ufm_op_fill_slot
+function in
+.Xr ddi_ufm 9E .
+.It Fa nvl
+An nvlist_t with ancillary, device-specific data.
+.El
+.Sh DESCRIPTION
+The
+.Fn ddi_ufm_slot_set_version ,
+.Fn ddi_ufm_slot_set_attrs ,
+and
+.Fn ddi_ufm_slot_set_misc
+functions are used by device drivers to set information about a firmware
+slot on the slot structure
+.Fa usp
+as a part of implementing their
+.Xr ddi_ufm_op_fill_slot 9E
+entry point.
+For more information on slots and the use of these functions, see the
+description of the
+.Fn ddi_ufm_op_fill_slot
+function in
+.Xr ddi_ufm 9E .
+.Pp
+The
+.Fn ddi_ufm_slot_set_version
+function sets the version property of a firmware slot.
+The version should be a human-readable ASCII string that describes the current
+firmware revision in a way that makes sense to an administrator and someone
+who is referencing the documentation of a vendor.
+.Pp
+The
+.Fn ddi_ufm_slot_set_attrs
+function describes attributes of a UFM slot as defined by the
+ddi_ufm_attr_t enum.
+.Pp
+The
+.Fn ddi_ufm_slot_set_misc
+function is used by the driver to set ancillary key-value data that may
+be useful to a consumer.
+For example, a driver may use this method to encode specific information that
+the firmware provides about how or when it was produced or installed on the
+device.
+The driver should create an nvlist for this purpose with
+.Xr nvlist_alloc 9F .
+Once the driver passes the nvlist to the
+.Fn ddi_ufm_slot_set_misc
+function, then the driver must not manipulate or free the nvlist at all.
+It is the property of the UFM subsystem.
+.Sh CONTEXT
+These functions should only be called in the context of the
+.Xr ddi_ufm_op_fill_slot 9E
+entry point.
+.Sh SEE ALSO
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 8c5d9c8c33..58ca7818f4 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -152,6 +152,7 @@ GENUNIX_OBJS +=	\
 		ddi_intr_irm.o	\
 		ddi_nodeid.o	\
 		ddi_periodic.o	\
+		ddi_ufm.o	\
 		devcfg.o	\
 		devcache.o	\
 		device.o	\
diff --git a/usr/src/uts/common/io/i40e/i40e_main.c b/usr/src/uts/common/io/i40e/i40e_main.c
index 0623aee513..4d34330bb8 100644
--- a/usr/src/uts/common/io/i40e/i40e_main.c
+++ b/usr/src/uts/common/io/i40e/i40e_main.c
@@ -1420,6 +1420,9 @@ i40e_unconfigure(dev_info_t *devinfo, i40e_t *i40e)
 	if (i40e->i40e_attach_progress & I40E_ATTACH_FM_INIT)
 		i40e_fm_fini(i40e);
 
+	if (i40e->i40e_attach_progress & I40E_ATTACH_UFM_INIT)
+		ddi_ufm_fini(i40e->i40e_ufmh);
+
 	kmem_free(i40e->i40e_aqbuf, I40E_ADMINQ_BUFSZ);
 	kmem_free(i40e, sizeof (i40e_t));
 
@@ -2033,7 +2036,7 @@ i40e_set_shared_vsi_props(i40e_t *i40e,
 	info->mapping_flags = LE_16(I40E_AQ_VSI_QUE_MAP_CONTIG);
 	info->queue_mapping[0] =
 	    LE_16((vsi_qp_base << I40E_AQ_VSI_QUEUE_SHIFT) &
-		I40E_AQ_VSI_QUEUE_MASK);
+	    I40E_AQ_VSI_QUEUE_MASK);
 
 	/*
 	 * tc_queues determines the size of the traffic class, where
@@ -2057,9 +2060,9 @@ i40e_set_shared_vsi_props(i40e_t *i40e,
 	 */
 	info->tc_mapping[0] =
 	    LE_16(((0 << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) &
-		    I40E_AQ_VSI_TC_QUE_OFFSET_MASK) |
-		((tc_queues << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT) &
-		    I40E_AQ_VSI_TC_QUE_NUMBER_MASK));
+	    I40E_AQ_VSI_TC_QUE_OFFSET_MASK) |
+	    ((tc_queues << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT) &
+	    I40E_AQ_VSI_TC_QUE_NUMBER_MASK));
 
 	/*
 	 * I40E_AQ_VSI_PVLAN_MODE_ALL ("VLAN driver insertion mode")
@@ -2262,7 +2265,7 @@ i40e_config_def_vsi(i40e_t *i40e, i40e_hw_t *hw)
 			i40e_error(i40e, "Unexpected L2 filter count: %u"
 			    " (expected 0)",
 			    i40e->i40e_resources.ifr_nmacfilt_used);
-			    return (B_FALSE);
+			return (B_FALSE);
 		}
 	}
 
@@ -3208,6 +3211,86 @@ i40e_drain_rx(i40e_t *i40e)
 	return (B_TRUE);
 }
 
+/*
+ * DDI UFM Callbacks
+ */
+static int
+i40e_ufm_fill_image(ddi_ufm_handle_t *ufmh, void *arg, uint_t imgno,
+    ddi_ufm_image_t *img)
+{
+	if (imgno != 0)
+		return (EINVAL);
+
+	ddi_ufm_image_set_desc(img, "Firmware");
+	ddi_ufm_image_set_nslots(img, 1);
+
+	return (DDI_SUCCESS);
+}
+
+static int
+i40e_ufm_fill_slot(ddi_ufm_handle_t *ufmh, void *arg, uint_t slotno,
+    ddi_ufm_slot_t *slot)
+{
+	i40e_t *i40e = (i40e_t *)arg;
+	char *fw_ver, *fw_bld, *api_ver;
+	nvlist_t *misc = NULL;
+	int err;
+
+	if (slotno != 0 ||
+	    ddi_prop_lookup_string(DDI_DEV_T_ANY, i40e->i40e_dip, 0,
+	    "firmware-version", &fw_ver) != DDI_PROP_SUCCESS ||
+	    ddi_prop_lookup_string(DDI_DEV_T_ANY, i40e->i40e_dip, 0,
+	    "firmware-build", &fw_bld) != DDI_PROP_SUCCESS ||
+	    ddi_prop_lookup_string(DDI_DEV_T_ANY, i40e->i40e_dip, 0,
+	    "api-version", &api_ver) != DDI_PROP_SUCCESS) {
+		err = EINVAL;
+		goto err;
+	}
+
+	ddi_ufm_slot_set_attrs(slot, DDI_UFM_ATTR_READABLE |
+	    DDI_UFM_ATTR_WRITEABLE | DDI_UFM_ATTR_ACTIVE);
+	ddi_ufm_slot_set_version(slot, fw_ver);
+
+	(void) nvlist_alloc(&misc, NV_UNIQUE_NAME, KM_SLEEP);
+	if (nvlist_add_string(misc, "firmare-build", fw_bld) != 0 ||
+	    nvlist_add_string(misc, "api-version", api_ver) != 0) {
+		err = ENOMEM;
+		goto err;
+	}
+	ddi_ufm_slot_set_misc(slot, misc);
+
+	ddi_prop_free(fw_ver);
+	ddi_prop_free(fw_bld);
+	ddi_prop_free(api_ver);
+
+	return (DDI_SUCCESS);
+err:
+	nvlist_free(misc);
+	if (fw_ver != NULL)
+		ddi_prop_free(fw_ver);
+	if (fw_bld != NULL)
+		ddi_prop_free(fw_bld);
+	if (api_ver != NULL)
+		ddi_prop_free(api_ver);
+
+	return (err);
+}
+
+static int
+i40e_ufm_getcaps(ddi_ufm_handle_t *ufmh, void *arg, ddi_ufm_cap_t *caps)
+{
+	*caps = DDI_UFM_CAP_REPORT;
+
+	return (DDI_SUCCESS);
+}
+
+static ddi_ufm_ops_t i40e_ufm_ops = {
+	NULL,
+	i40e_ufm_fill_image,
+	i40e_ufm_fill_slot,
+	i40e_ufm_getcaps
+};
+
 static int
 i40e_attach(dev_info_t *devinfo, ddi_attach_cmd_t cmd)
 {
@@ -3323,6 +3406,14 @@ i40e_attach(dev_info_t *devinfo, ddi_attach_cmd_t cmd)
 	}
 	i40e->i40e_attach_progress |= I40E_ATTACH_ENABLE_INTR;
 
+	if (ddi_ufm_init(i40e->i40e_dip, DDI_UFM_CURRENT_VERSION, &i40e_ufm_ops,
+	    &i40e->i40e_ufmh, i40e) != 0) {
+		i40e_error(i40e, "failed to initialize UFM subsystem");
+		goto attach_fail;
+	}
+	ddi_ufm_update(i40e->i40e_ufmh);
+	i40e->i40e_attach_progress |= I40E_ATTACH_UFM_INIT;
+
 	atomic_or_32(&i40e->i40e_state, I40E_INITIALIZED);
 
 	mutex_enter(&i40e_glock);
diff --git a/usr/src/uts/common/io/i40e/i40e_sw.h b/usr/src/uts/common/io/i40e/i40e_sw.h
index e7b64c2160..7b0ff20c95 100644
--- a/usr/src/uts/common/io/i40e/i40e_sw.h
+++ b/usr/src/uts/common/io/i40e/i40e_sw.h
@@ -70,6 +70,7 @@ extern "C" {
 #include <sys/list.h>
 #include <sys/debug.h>
 #include <sys/sdt.h>
+#include <sys/ddi_ufm.h>
 #include "i40e_type.h"
 #include "i40e_osdep.h"
 #include "i40e_prototype.h"
@@ -342,6 +343,7 @@ typedef enum i40e_attach_state {
 	I40E_ATTACH_ENABLE_INTR	= 0x1000,	/* DDI interrupts enabled */
 	I40E_ATTACH_FM_INIT	= 0x2000,	/* FMA initialized */
 	I40E_ATTACH_LINK_TIMER	= 0x4000,	/* link check timer */
+	I40E_ATTACH_UFM_INIT	= 0x8000,	/* DDI UFM initialized */
 } i40e_attach_state_t;
 
 
@@ -932,6 +934,9 @@ typedef struct i40e {
 	 */
 	uint32_t	i40e_led_status;
 	boolean_t	i40e_led_saved;
+
+	/* DDI UFM handle */
+	ddi_ufm_handle_t	*i40e_ufmh;
 } i40e_t;
 
 /*
diff --git a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
index 05298d8b05..a01b332e36 100644
--- a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
+++ b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2016 Nexenta Systems, Inc. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright 2014 OmniTI Computer Consulting, Inc. All rights reserved.
  * Copyright (c) 2014, Tegile Systems Inc. All rights reserved.
  */
@@ -112,6 +112,8 @@
 #include <sys/fm/util.h>
 #include <sys/fm/io/ddi.h>
 
+#include <sys/ddi_ufm.h>
+
 /*
  * autoconfiguration data and routines.
  */
@@ -131,7 +133,17 @@ static int mptsas_quiesce(dev_info_t *devi);
 #endif	/* __sparc */
 
 /*
- * Resource initilaization for hardware
+ * ddi_ufm_ops
+ */
+static int mptsas_ufm_fill_image(ddi_ufm_handle_t *ufmh, void *arg,
+    uint_t imgno, ddi_ufm_image_t *img);
+static int mptsas_ufm_fill_slot(ddi_ufm_handle_t *ufmh, void *arg,
+    uint_t slotno, ddi_ufm_slot_t *slot);
+static int mptsas_ufm_getcaps(ddi_ufm_handle_t *ufmh, void *arg,
+    ddi_ufm_cap_t *caps);
+
+/*
+ * Resource initialization for hardware
  */
 static void mptsas_setup_cmd_reg(mptsas_t *mpt);
 static void mptsas_disable_bus_master(mptsas_t *mpt);
@@ -559,6 +571,12 @@ static struct dev_ops mptsas_ops = {
 #endif	/* __sparc */
 };
 
+static ddi_ufm_ops_t mptsas_ufm_ops = {
+	NULL,
+	mptsas_ufm_fill_image,
+	mptsas_ufm_fill_slot,
+	mptsas_ufm_getcaps
+};
 
 #define	MPTSAS_MOD_STRING "MPTSAS HBA Driver 00.00.00.24"
 
@@ -1237,6 +1255,14 @@ mptsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 
 	mptsas_fm_init(mpt);
 
+	/*
+	 * Initialize us with the UFM subsystem
+	 */
+	if (ddi_ufm_init(dip, DDI_UFM_CURRENT_VERSION, &mptsas_ufm_ops,
+	    &mpt->m_ufmh, mpt) != 0) {
+		mptsas_log(mpt, CE_WARN, "failed to initialize UFM subsystem");
+	}
+
 	if (mptsas_alloc_handshake_msg(mpt,
 	    sizeof (Mpi2SCSITaskManagementRequest_t)) == DDI_FAILURE) {
 		mptsas_log(mpt, CE_WARN, "cannot initialize handshake msg.");
@@ -1537,6 +1563,9 @@ mptsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 	 * After this point, we are not going to fail the attach.
 	 */
 
+	/* Let the UFM susbsystem know we're ready to receive callbacks */
+	ddi_ufm_update(mpt->m_ufmh);
+
 	/* Print message of HBA present */
 	ddi_report_dev(dip);
 
@@ -1876,6 +1905,9 @@ mptsas_do_detach(dev_info_t *dip)
 	if (!mpt) {
 		return (DDI_FAILURE);
 	}
+
+	ddi_ufm_fini(mpt->m_ufmh);
+
 	/*
 	 * Still have pathinfo child, should not detach mpt driver
 	 */
@@ -16969,3 +17001,49 @@ mptsas_dma_addr_destroy(ddi_dma_handle_t *dma_hdp, ddi_acc_handle_t *acc_hdp)
 	ddi_dma_free_handle(dma_hdp);
 	*dma_hdp = NULL;
 }
+
+/*
+ * DDI UFM Callbacks
+ */
+static int
+mptsas_ufm_fill_image(ddi_ufm_handle_t *ufmh, void *arg, uint_t imgno,
+    ddi_ufm_image_t *img)
+{
+	mptsas_t *mpt = (mptsas_t *)arg;
+
+	if (imgno != 0)
+		return (EINVAL);
+
+	ddi_ufm_image_set_desc(img, "IOC Firmware");
+	ddi_ufm_image_set_nslots(img, 1);
+
+	return (DDI_SUCCESS);
+}
+
+static int
+mptsas_ufm_fill_slot(ddi_ufm_handle_t *ufmh, void *arg, uint_t slotno,
+    ddi_ufm_slot_t *slot)
+{
+	mptsas_t *mpt = (mptsas_t *)arg;
+	char *buf;
+
+	if (slotno != 0 || ddi_prop_lookup_string(DDI_DEV_T_ANY, mpt->m_dip, 0,
+	    "firmware-version", &buf) != DDI_PROP_SUCCESS)
+		return (EINVAL);
+
+	ddi_ufm_slot_set_attrs(slot, DDI_UFM_ATTR_READABLE |
+	    DDI_UFM_ATTR_WRITEABLE | DDI_UFM_ATTR_ACTIVE);
+	ddi_ufm_slot_set_version(slot, buf);
+
+	ddi_prop_free(buf);
+
+	return (DDI_SUCCESS);
+}
+
+static int
+mptsas_ufm_getcaps(ddi_ufm_handle_t *ufmh, void *arg, ddi_ufm_cap_t *caps)
+{
+	*caps = DDI_UFM_CAP_REPORT;
+
+	return (DDI_SUCCESS);
+}
diff --git a/usr/src/uts/common/io/ufm.c b/usr/src/uts/common/io/ufm.c
new file mode 100644
index 0000000000..7eb1b54aca
--- /dev/null
+++ b/usr/src/uts/common/io/ufm.c
@@ -0,0 +1,483 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * The ufm(7D) pseudo driver provides an ioctl interface for DDI UFM
+ * information.  See ddi_ufm.h.
+ */
+#include <sys/sunddi.h>
+#include <sys/esunddi.h>
+#include <sys/ddi_ufm.h>
+#include <sys/ddi_ufm_impl.h>
+#include <sys/conf.h>
+#include <sys/debug.h>
+#include <sys/kmem.h>
+#include <sys/stat.h>
+
+/* XXX - add debug tunable? */
+
+static dev_info_t *ufm_devi;
+
+static int ufm_open(dev_t *, int, int, cred_t *);
+static int ufm_close(dev_t, int, int, cred_t *);
+static int ufm_ioctl(dev_t, int, intptr_t, int, cred_t *, int *);
+
+static struct cb_ops ufm_cb_ops = {
+	ufm_open,		/* open */
+	ufm_close,		/* close */
+	nodev,			/* strategy */
+	nodev,			/* print */
+	nodev,			/* dump */
+	nodev,			/* read */
+	nodev,			/* write */
+	ufm_ioctl,		/* ioctl */
+	nodev,			/* devmap */
+	nodev,			/* mmap */
+	nodev,			/* segmap */
+	nochpoll,		/* poll */
+	ddi_prop_op,		/* cprop_op */
+	NULL,			/* streamtab  */
+	D_NEW | D_MP		/* driver compatibility flags */
+};
+
+static int ufm_info(dev_info_t *, ddi_info_cmd_t, void *, void **);
+static int ufm_attach(dev_info_t *, ddi_attach_cmd_t);
+static int ufm_detach(dev_info_t *, ddi_detach_cmd_t);
+
+static struct dev_ops ufm_ops = {
+	DEVO_REV,			/* devo_rev, */
+	0,				/* refcnt  */
+	ufm_info,			/* info */
+	nulldev,			/* identify */
+	nulldev,			/* probe */
+	ufm_attach,			/* attach */
+	ufm_detach,			/* detach */
+	nodev,				/* reset */
+	&ufm_cb_ops,			/* cb_ops */
+	NULL,				/* bus os */
+	NULL,				/* power */
+	ddi_quiesce_not_supported,	/* quiesce */
+};
+
+static struct modldrv modldrv = {
+	&mod_driverops, "Upgradeable FW Module driver", &ufm_ops,
+};
+
+static struct modlinkage modlinkage = {
+	MODREV_1, (void *)&modldrv, NULL
+};
+
+
+int
+_init(void)
+{
+	int ret;
+
+	ret = mod_install(&modlinkage);
+
+	return (ret);
+}
+
+int
+_fini(void)
+{
+	int ret;
+
+	ret = mod_remove(&modlinkage);
+
+	return (ret);
+}
+
+int
+_info(struct modinfo *modinfop)
+{
+	return (mod_info(&modlinkage, modinfop));
+}
+
+/*ARGSUSED*/
+static int
+ufm_info(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
+{
+	switch (infocmd) {
+	case DDI_INFO_DEVT2DEVINFO:
+		*result = ufm_devi;
+		return (DDI_SUCCESS);
+	case DDI_INFO_DEVT2INSTANCE:
+		*result = 0;
+		return (DDI_SUCCESS);
+	}
+	return (DDI_FAILURE);
+}
+
+static int
+ufm_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
+{
+	if (cmd != DDI_ATTACH)
+		return (DDI_FAILURE);
+
+	if (ddi_create_minor_node(devi, "ufm",
+	    S_IFCHR, 0, DDI_PSEUDO, 0) == DDI_FAILURE) {
+		ddi_remove_minor_node(devi, NULL);
+		return (DDI_FAILURE);
+	}
+
+	ufm_devi = devi;
+	return (DDI_SUCCESS);
+}
+
+static int
+ufm_detach(dev_info_t *devi, ddi_detach_cmd_t cmd)
+{
+	if (cmd != DDI_DETACH)
+		return (DDI_FAILURE);
+
+	ddi_remove_minor_node(devi, NULL);
+	return (DDI_SUCCESS);
+}
+
+/*ARGSUSED*/
+static int
+ufm_open(dev_t *devp, int flag, int otyp, cred_t *cred_p)
+{
+	return (0);
+}
+
+/*ARGSUSED*/
+static int
+ufm_close(dev_t dev, int flag, int otyp, cred_t *cred)
+{
+	return (0);
+}
+
+static boolean_t
+ufm_driver_ready(ddi_ufm_handle_t *ufmh)
+{
+	ASSERT(ufmh != NULL);
+
+	if (ufmh->ufmh_state & DDI_UFM_STATE_SHUTTING_DOWN ||
+	    !(ufmh->ufmh_state & DDI_UFM_STATE_READY)) {
+		mutex_exit(&ufmh->ufmh_lock);
+		return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
+static int
+ufm_ioc_report(ddi_ufm_handle_t *ufmh, nvlist_t **out_nvl)
+{
+	nvlist_t **images = NULL, **slots = NULL;
+
+	ASSERT(ufmh != NULL && ufmh->ufmh_images != NULL);
+
+	images = kmem_zalloc(sizeof (nvlist_t *) * ufmh->ufmh_nimages,
+	    KM_SLEEP);
+	for (int i = 0; i < ufmh->ufmh_nimages; i ++) {
+		ddi_ufm_image_t *img = &ufmh->ufmh_images[i];
+
+		(void) nvlist_alloc(&images[i], NV_UNIQUE_NAME, KM_SLEEP);
+		(void) nvlist_add_string(images[i], DDI_UFM_NV_IMAGE_DESC,
+		    img->ufmi_desc);
+		if (img->ufmi_misc != NULL)
+			(void) nvlist_add_nvlist(images[i],
+			    DDI_UFM_NV_IMAGE_MISC, img->ufmi_misc);
+
+		slots = kmem_zalloc(sizeof (nvlist_t *) * img->ufmi_nslots,
+		    KM_SLEEP);
+		for (int s = 0; s < img->ufmi_nslots; s++) {
+			ddi_ufm_slot_t *slot = &img->ufmi_slots[s];
+
+			(void) nvlist_alloc(&slots[s], NV_UNIQUE_NAME,
+			    KM_SLEEP);
+			(void) nvlist_add_string(slots[s],
+			    DDI_UFM_NV_SLOT_VERSION, slot->ufms_version);
+			(void) nvlist_add_uint32(slots[s],
+			    DDI_UFM_NV_SLOT_ATTR, slot->ufms_attrs);
+			if (slot->ufms_misc != NULL)
+				(void) nvlist_add_nvlist(slots[s],
+				    DDI_UFM_NV_SLOT_MISC, slot->ufms_misc);
+		}
+		(void) nvlist_add_nvlist_array(images[i],
+		    DDI_UFM_NV_IMAGE_SLOTS, slots, img->ufmi_nslots);
+	}
+	(void) nvlist_alloc(out_nvl, NV_UNIQUE_NAME, KM_SLEEP);
+	(void) nvlist_add_nvlist_array(*out_nvl, DDI_UFM_NV_IMAGES, images,
+	    ufmh->ufmh_nimages);
+
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+ufm_ioctl(dev_t dev, int cmd, intptr_t data, int mode, cred_t *credp,
+    int *rvalp)
+{
+	ddi_ufm_handle_t *ufmh;
+	uint_t model;
+	int ret = 0;
+	char *buf;
+	ufm_ioc_getcaps_t ugc;
+	size_t sz;
+	nvlist_t *out_nvl = NULL;
+	ufm_ioc_bufsz_t ufbz;
+	ufm_ioc_report_t ufmr;
+	dev_info_t *dip;
+
+#ifdef _MULTI_DATAMODEL
+	ufm_ioc_bufsz32_t ufbz32;
+	ufm_ioc_report32_t ufmr32;
+#endif
+
+	model = ddi_model_convert_from(mode);
+
+	switch (cmd) {
+	case UFM_IOC_GETCAPS:
+		if (ddi_copyin((void *)data, &ugc, sizeof (ufm_ioc_getcaps_t),
+		    mode) != 0)
+			return (EFAULT);
+
+		if ((dip = e_ddi_hold_devi_by_path(ugc.ufmg_devpath, 0)) ==
+		    NULL) {
+			return (ENOTSUP);
+		}
+		if ((ufmh = ufm_find(ugc.ufmg_devpath)) == NULL) {
+			ddi_release_devi(dip);
+			return (ENOTSUP);
+		}
+		ASSERT(MUTEX_HELD(&ufmh->ufmh_lock));
+
+		if (! ufm_driver_ready(ufmh)) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (EAGAIN);
+		}
+
+		if (ugc.ufmg_version > ufmh->ufmh_version) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (ENOTSUP);
+		}
+
+		if (ufmh->ufmh_images == NULL) {
+			if ((ret = ufm_cache_fill(ufmh)) != 0) {
+				ddi_release_devi(dip);
+				mutex_exit(&ufmh->ufmh_lock);
+				return (ret);
+			}
+		}
+
+		ugc.ufmg_caps = ufmh->ufmh_caps;
+		ddi_release_devi(dip);
+		mutex_exit(&ufmh->ufmh_lock);
+
+		if (ddi_copyout(&ugc, (void *)data, sizeof (ufm_ioc_getcaps_t),
+		    mode) != 0)
+			return (EFAULT);
+
+		break;
+
+	case UFM_IOC_REPORTSZ:
+		switch (model) {
+#ifdef _MULTI_DATAMODEL
+		case DDI_MODEL_ILP32:
+			if (ddi_copyin((void *)data, &ufbz32,
+			    sizeof (ufm_ioc_bufsz32_t), mode) != 0)
+				return (EFAULT);
+			ufbz.ufbz_version = ufbz32.ufbz_version;
+			(void) strcpy(ufbz.ufbz_devpath, ufbz32.ufbz_devpath);
+			break;
+#endif /* _MULTI_DATAMODEL */
+		case DDI_MODEL_NONE:
+		default:
+			if (ddi_copyin((void *)data, &ufbz,
+			    sizeof (ufm_ioc_bufsz_t), mode) != 0)
+				return (EFAULT);
+		}
+
+		if ((dip = e_ddi_hold_devi_by_path(ufbz.ufbz_devpath, 0)) ==
+		    NULL) {
+			return (ENOTSUP);
+		}
+		if ((ufmh = ufm_find(ufbz.ufbz_devpath)) == NULL) {
+			ddi_release_devi(dip);
+			return (ENOTSUP);
+		}
+		ASSERT(MUTEX_HELD(&ufmh->ufmh_lock));
+
+		if (! ufm_driver_ready(ufmh)) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (EAGAIN);
+		}
+
+		if (ufbz.ufbz_version > ufmh->ufmh_version) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (ENOTSUP);
+		}
+
+		if (ufmh->ufmh_images == NULL) {
+			if ((ret = ufm_cache_fill(ufmh)) != 0) {
+				ddi_release_devi(dip);
+				mutex_exit(&ufmh->ufmh_lock);
+				return (ret);
+			}
+		}
+		if ((ufmh->ufmh_caps & DDI_UFM_CAP_REPORT) == 0) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (ENOTSUP);
+		}
+
+		if ((ret = ufm_ioc_report(ufmh, &out_nvl)) != 0) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (EIO);
+		}
+		ddi_release_devi(dip);
+		mutex_exit(&ufmh->ufmh_lock);
+
+		if ((ret = nvlist_size(out_nvl, &sz, NV_ENCODE_NATIVE)) != 0) {
+			nvlist_free(out_nvl);
+			return (ret);
+		}
+		nvlist_free(out_nvl);
+
+		switch (model) {
+#ifdef _MULTI_DATAMODEL
+		case DDI_MODEL_ILP32:
+			ufbz32.ufbz_size = sz;
+			if (ddi_copyout(&ufbz32, (void *)data,
+			    sizeof (ufm_ioc_bufsz32_t), mode) != 0)
+				return (EFAULT);
+			break;
+#endif /* _MULTI_DATAMODEL */
+		case DDI_MODEL_NONE:
+		default:
+			ufbz.ufbz_size = sz;
+			if (ddi_copyout(&ufbz, (void *)data,
+			    sizeof (ufm_ioc_bufsz_t), mode) != 0)
+				return (EFAULT);
+		}
+
+		break;
+
+	case UFM_IOC_REPORT:
+		switch (model) {
+#ifdef _MULTI_DATAMODEL
+		case DDI_MODEL_ILP32:
+			if (ddi_copyin((void *)data, &ufmr32,
+			    sizeof (ufm_ioc_report32_t), mode) != 0)
+				return (EFAULT);
+			ufmr.ufmr_version = ufmr32.ufmr_version;
+			(void) strcpy(ufmr.ufmr_devpath, ufmr32.ufmr_devpath);
+			ufmr.ufmr_bufsz = ufmr32.ufmr_bufsz;
+			ufmr.ufmr_buf = (caddr_t)(uintptr_t)ufmr32.ufmr_buf;
+			break;
+#endif /* _MULTI_DATAMODEL */
+		case DDI_MODEL_NONE:
+		default:
+			if (ddi_copyin((void *)data, &ufmr,
+			    sizeof (ufm_ioc_report_t), mode) != 0)
+				return (EFAULT);
+		}
+
+		if ((dip = e_ddi_hold_devi_by_path(ufmr.ufmr_devpath, 0)) ==
+		    NULL) {
+			return (ENOTSUP);
+		}
+		if ((ufmh = ufm_find(ufmr.ufmr_devpath)) == NULL) {
+			ddi_release_devi(dip);
+			return (ENOTSUP);
+		}
+		ASSERT(MUTEX_HELD(&ufmh->ufmh_lock));
+
+		if (! ufm_driver_ready(ufmh)) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (EAGAIN);
+		}
+
+		if (ufmr.ufmr_version > ufmh->ufmh_version) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (ENOTSUP);
+		}
+
+		if (ufmh->ufmh_images == NULL) {
+			if ((ret = ufm_cache_fill(ufmh)) != 0) {
+				ddi_release_devi(dip);
+				mutex_exit(&ufmh->ufmh_lock);
+				return (ret);
+			}
+		}
+
+		if ((ufmh->ufmh_caps & DDI_UFM_CAP_REPORT) == 0) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (ENOTSUP);
+		}
+
+		if ((ret = ufm_ioc_report(ufmh, &out_nvl)) != 0) {
+			ddi_release_devi(dip);
+			mutex_exit(&ufmh->ufmh_lock);
+			return (EIO);
+		}
+		ddi_release_devi(dip);
+		mutex_exit(&ufmh->ufmh_lock);
+
+		if ((ret = nvlist_size(out_nvl, &sz, NV_ENCODE_NATIVE)) != 0) {
+			nvlist_free(out_nvl);
+			return (ret);
+		}
+		if (sz > ufmr.ufmr_bufsz) {
+			nvlist_free(out_nvl);
+			return (ENAMETOOLONG);
+		}
+
+		if ((buf = kmem_alloc(sz, KM_NOSLEEP)) == NULL ||
+		    nvlist_pack(out_nvl, &buf, &sz, NV_ENCODE_NATIVE,
+		    KM_SLEEP) != 0) {
+			kmem_free(buf, sz);
+			nvlist_free(out_nvl);
+			return (ENOMEM);
+		}
+		nvlist_free(out_nvl);
+		if (ddi_copyout(buf, ufmr.ufmr_buf, sz, mode) != 0) {
+			kmem_free(buf, sz);
+			return (EFAULT);
+		}
+
+		switch (model) {
+#ifdef _MULTI_DATAMODEL
+		case DDI_MODEL_ILP32:
+			if (ddi_copyout(&ufmr32, (void *)data,
+			    sizeof (ufm_ioc_report32_t), mode) != 0)
+				return (EFAULT);
+			break;
+#endif /* _MULTI_DATAMODEL */
+		case DDI_MODEL_NONE:
+		default:
+			if (ddi_copyout(&ufmr, (void *)data,
+			    sizeof (ufm_ioc_report_t), mode) != 0)
+				return (EFAULT);
+		}
+		kmem_free(buf, sz);
+		break;
+	default:
+		return (EINVAL);
+	}
+	return (0);
+
+}
diff --git a/usr/src/uts/common/io/ufm.conf b/usr/src/uts/common/io/ufm.conf
new file mode 100644
index 0000000000..8e4a4a0a87
--- /dev/null
+++ b/usr/src/uts/common/io/ufm.conf
@@ -0,0 +1,16 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+name="ufm" parent="pseudo" instance=0;
diff --git a/usr/src/uts/common/mapfiles/ddi.mapfile b/usr/src/uts/common/mapfiles/ddi.mapfile
index 1377af5857..ab65377941 100644
--- a/usr/src/uts/common/mapfiles/ddi.mapfile
+++ b/usr/src/uts/common/mapfiles/ddi.mapfile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 #
@@ -101,6 +101,7 @@ SYMBOL_SCOPE {
 	ddi_prop_free			{ FLAGS = EXTERN };
 	ddi_prop_get_int		{ FLAGS = EXTERN };
 	ddi_prop_lookup_int_array	{ FLAGS = EXTERN };
+	ddi_prop_lookup_string		{ FLAGS = EXTERN };
 	ddi_prop_op			{ FLAGS = EXTERN };
 	ddi_prop_remove_all		{ FLAGS = EXTERN };
 	ddi_prop_update_int_array	{ FLAGS = EXTERN };
@@ -116,6 +117,15 @@ SYMBOL_SCOPE {
 	ddi_taskq_create		{ FLAGS = EXTERN };
 	ddi_taskq_destroy		{ FLAGS = EXTERN };
 	ddi_taskq_dispatch		{ FLAGS = EXTERN };
+	ddi_ufm_fini			{ FLAGS = EXTERN };
+	ddi_ufm_image_set_desc		{ FLAGS = EXTERN };
+	ddi_ufm_image_set_misc		{ FLAGS = EXTERN };
+	ddi_ufm_image_set_nslots	{ FLAGS = EXTERN };
+	ddi_ufm_init			{ FLAGS = EXTERN };
+	ddi_ufm_slot_set_attrs		{ FLAGS = EXTERN };
+	ddi_ufm_slot_set_misc		{ FLAGS = EXTERN };
+	ddi_ufm_slot_set_version	{ FLAGS = EXTERN };
+	ddi_ufm_update			{ FLAGS = EXTERN };
 	delay				{ FLAGS = EXTERN };
 	desballoc			{ FLAGS = EXTERN };
 	dev_err				{ FLAGS = EXTERN };
@@ -158,6 +168,9 @@ SYMBOL_SCOPE {
 	mutex_tryenter			{ FLAGS = EXTERN };
 	nochpoll			{ FLAGS = EXTERN };
 	nodev				{ FLAGS = EXTERN };
+	nvlist_add_string		{ FLAGS = EXTERN };
+	nvlist_alloc			{ FLAGS = EXTERN };
+	nvlist_free			{ FLAGS = EXTERN };
 	nulldev				{ FLAGS = EXTERN };
 	panic				{ FLAGS = EXTERN };
 	pci_config_get16		{ FLAGS = EXTERN };
diff --git a/usr/src/uts/common/os/autoconf.c b/usr/src/uts/common/os/autoconf.c
index 229c250a64..71af31ba2b 100644
--- a/usr/src/uts/common/os/autoconf.c
+++ b/usr/src/uts/common/os/autoconf.c
@@ -22,6 +22,9 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
 
 /*
  * This file contains ddi functions needed during boot and DR.
@@ -49,6 +52,7 @@
 #include <sys/bootconf.h>
 #include <sys/fm/util.h>
 #include <sys/ddifm_impl.h>
+#include <sys/ddi_ufm_impl.h>
 
 extern dev_info_t *top_devinfo;
 extern dev_info_t *scsi_vhci_dip;
@@ -91,6 +95,7 @@ setup_ddi(void)
 	fm_init();
 	ndi_fm_init();
 	irm_init();
+	ufm_init();
 
 	(void) i_ddi_load_drvconf(DDI_MAJOR_T_NONE);
 
diff --git a/usr/src/uts/common/os/ddi_ufm.c b/usr/src/uts/common/os/ddi_ufm.c
new file mode 100644
index 0000000000..c48ce145a0
--- /dev/null
+++ b/usr/src/uts/common/os/ddi_ufm.c
@@ -0,0 +1,344 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#include <sys/avl.h>
+#include <sys/ddi_ufm.h>
+#include <sys/ddi_ufm_impl.h>
+#include <sys/debug.h>
+#include <sys/kmem.h>
+#include <sys/sunddi.h>
+#include <sys/stddef.h>
+
+/*
+ * The UFM subsystem tracks it's internal state with respect to device
+ * drivers that participate in the DDI UFM subsystem on a per-instance basis
+ * via ddi_ufm_handle_t structures (see ddi_ufm_impl.h).  This is known as the
+ * UFM handle.  The UFM handle contains a pointer to the driver's UFM ops,
+ * which the ufm(7D) pseudo driver uses to invoke the UFM entry points in
+ * response to DDI UFM ioctls.  Additionally, the DDI UFM subsystem uses the
+ * handle to maintain cached UFM image and slot data.
+ *
+ * In order to track provide fast lookups of a driver instance's UFM handle,
+ * the DDI UFM subsystem stores a pointer to the handle in a global AVL tree.
+ * UFM handles are added to the tree as part of ddi_ufm_init(9E) and removed
+ * from the tree as part of ddi_ufm_fini(9E).
+ *
+ * Some notes on the locking strategy/rules.
+ *
+ * All access to the tree is serialized via the mutex, ufm_lock.
+ * Additionally, each UFM handle is protected by a per-handle mutex.
+ *
+ * Code must acquire ufm_lock in order to walk the tree.  Before reading or
+ * modifying the state of any UFM handle, code should then acquire the
+ * UFM handle lock.  Once the UFM handle lock has been acquired, ufm_lock
+ * should be dropped.
+ *
+ * Only one UFM handle lock should be held at any time.
+ * If a UFM handle lock is held, it must be released before attempting to
+ * re-acquire ufm_lock.
+ *
+ * Calling a UFM entry point and/or reading/modifying UFM handle state:
+ * - acquire ufm_lock
+ * - walk tree to find UFH handle
+ * - acquire UFM handle lock
+ * - release ufm_lock
+ * - call entry point and/or access handle state
+ */
+static avl_tree_t ufm_handles;
+static kmutex_t ufm_lock;
+
+static int ufm_handle_compare(const void *, const void *);
+
+static void
+ufm_cache_invalidate(ddi_ufm_handle_t *ufmh)
+{
+	ASSERT(MUTEX_HELD(&ufmh->ufmh_lock));
+
+	if (ufmh->ufmh_images == NULL)
+		return;
+
+	for (int i = 0; i < ufmh->ufmh_nimages; i++) {
+		struct ddi_ufm_image *img = &ufmh->ufmh_images[i];
+
+		if (img->ufmi_slots == NULL)
+			continue;
+
+		for (int s = 0; s < img->ufmi_nslots; s++) {
+			struct ddi_ufm_slot *slot = &img->ufmi_slots[s];
+
+			kmem_free(slot->ufms_version,
+			    strlen(slot->ufms_version));
+		}
+		kmem_free(img->ufmi_slots,
+		    (img->ufmi_nslots * sizeof (ddi_ufm_slot_t)));
+		kmem_free(img->ufmi_desc, strlen(img->ufmi_desc));
+	}
+
+	kmem_free(ufmh->ufmh_images,
+	    (ufmh->ufmh_nimages * sizeof (ddi_ufm_image_t)));
+	ufmh->ufmh_images = NULL;
+	ufmh->ufmh_nimages = 0;
+	ufmh->ufmh_caps = 0;
+}
+
+int
+ufm_cache_fill(ddi_ufm_handle_t *ufmh)
+{
+	int ret;
+	uint_t nimgs;
+	ddi_ufm_cap_t caps;
+
+	ASSERT(MUTEX_HELD(&ufmh->ufmh_lock));
+
+	/*
+	 * First check which UFM caps this driver supports.  If it doesn't
+	 * support DDI_UFM_CAP_REPORT, then there's nothing to cache and we
+	 * can just return.
+	 */
+	ret = ufmh->ufmh_ops->ddi_ufm_op_getcaps(ufmh, ufmh->ufmh_arg, &caps);
+	if (ret != DDI_SUCCESS)
+		return (ret);
+
+	ufmh->ufmh_caps = caps;
+	/* XXX - return if !DDI_UFM_CAP_REPORT */
+
+	/*
+	 * Next, figure out how many UFM images the device has.  If a
+	 * ddi_ufm_op_nimages entry point wasn't specified, then we assume
+	 * that the device has a single image.
+	 */
+	if (ufmh->ufmh_ops->ddi_ufm_op_nimages != NULL) {
+		ret = ufmh->ufmh_ops->ddi_ufm_op_nimages(ufmh, ufmh->ufmh_arg,
+		    &nimgs);
+		if (ret == DDI_SUCCESS)
+			ufmh->ufmh_nimages = nimgs;
+		else
+			goto cache_fail;
+	} else {
+		ufmh->ufmh_nimages = 1;
+	}
+
+	/*
+	 * Now that we know how many images we're dealing with, allocate space
+	 * for an appropriately-sized array of ddi_ufm_image_t structs and then
+	 * iterate through them calling the ddi_ufm_op_fill_image entry point
+	 * so that the driver can fill them in.
+	 */
+	ufmh->ufmh_images =
+	    kmem_zalloc((sizeof (ddi_ufm_image_t) * ufmh->ufmh_nimages),
+	    KM_NOSLEEP);
+	if (ufmh->ufmh_images == NULL)
+		return (ENOMEM);
+
+	for (int i = 0; i < ufmh->ufmh_nimages; i++) {
+		struct ddi_ufm_image *img = &ufmh->ufmh_images[i];
+
+		ret = ufmh->ufmh_ops->ddi_ufm_op_fill_image(ufmh,
+		    ufmh->ufmh_arg, i, img);
+
+		if (ret != DDI_SUCCESS)
+			goto cache_fail;
+
+		ASSERT(img->ufmi_desc != NULL && img->ufmi_nslots != 0);
+
+		img->ufmi_slots =
+		    kmem_zalloc((sizeof (ddi_ufm_slot_t) * img->ufmi_nslots),
+		    KM_NOSLEEP);
+		if (img->ufmi_slots == NULL) {
+			ret = ENOMEM;
+			goto cache_fail;
+		}
+
+		for (int s = 0; s < img->ufmi_nslots; s++) {
+			struct ddi_ufm_slot *slot = &img->ufmi_slots[s];
+
+			ret = ufmh->ufmh_ops->ddi_ufm_op_fill_slot(ufmh,
+			    ufmh->ufmh_arg, s, slot);
+
+			if (ret != DDI_SUCCESS)
+				goto cache_fail;
+
+			ASSERT(slot->ufms_version != NULL &&
+			    slot->ufms_attrs != 0);
+		}
+	}
+	return (0);
+
+cache_fail:
+	ufm_cache_invalidate(ufmh);
+	return (ret);
+}
+
+/*
+ * This gets called early in boot by setup_ddi().
+ */
+void
+ufm_init(void)
+{
+	mutex_init(&ufm_lock, NULL, MUTEX_DEFAULT, NULL);
+
+	avl_create(&ufm_handles, ufm_handle_compare,
+	    sizeof (ddi_ufm_handle_t),
+	    offsetof(ddi_ufm_handle_t, ufmh_link));
+}
+
+static int
+ufm_handle_compare(const void *a1, const void *a2)
+{
+	struct ddi_ufm_handle *hdl1, *hdl2;
+	int cmp;
+
+	hdl1 = (struct ddi_ufm_handle *)a1;
+	hdl2 = (struct ddi_ufm_handle *)a2;
+
+	cmp = strcmp(hdl1->ufmh_devpath, hdl2->ufmh_devpath);
+
+	if (cmp > 0)
+		return (1);
+	else if (cmp < 0)
+		return (-1);
+	else
+		return (0);
+}
+
+/*
+ * This is used by the ufm driver to lookup the UFM handle associated with a
+ * particular devpath.
+ *
+ * On success, this function returns the reqested UFH handle, with its lock
+ * held.  Caller is responsible to dropping the lock when it is done with the
+ * handle.
+ */
+struct ddi_ufm_handle *
+ufm_find(const char *devpath)
+{
+	struct ddi_ufm_handle find = { 0 }, *ufmh;
+
+	strcpy(find.ufmh_devpath, devpath);
+
+	mutex_enter(&ufm_lock);
+	ufmh = avl_find(&ufm_handles, &find, NULL);
+	mutex_exit(&ufm_lock);
+
+	if (ufmh != NULL)
+		mutex_enter(&ufmh->ufmh_lock);
+
+	return (ufmh);
+}
+
+int
+ddi_ufm_init(dev_info_t *dip, uint_t version, ddi_ufm_ops_t *ufmops,
+    ddi_ufm_handle_t **ufmh, void *arg)
+{
+	ASSERT(version != 0 && ufmops != NULL);
+	ASSERT(ufmops->ddi_ufm_op_fill_image != NULL &&
+	    ufmops->ddi_ufm_op_fill_slot != NULL &&
+	    ufmops->ddi_ufm_op_getcaps != NULL);
+
+	if (version > DDI_UFM_CURRENT_VERSION)
+		return (ENOTSUP);
+
+	*ufmh = kmem_zalloc(sizeof (ddi_ufm_handle_t), KM_SLEEP);
+	mutex_init(&(*ufmh)->ufmh_lock, NULL, MUTEX_DEFAULT, NULL);
+	(*ufmh)->ufmh_ops = ufmops;
+	(*ufmh)->ufmh_arg = arg;
+	(*ufmh)->ufmh_version = version;
+	(void) ddi_pathname(dip, (*ufmh)->ufmh_devpath);
+	(*ufmh)->ufmh_state |= DDI_UFM_STATE_INIT;
+
+	/*
+	 * Add the UFM handle to the global AVL tree of handles.
+	 */
+	mutex_enter(&ufm_lock);
+	avl_add(&ufm_handles, *ufmh);
+	mutex_exit(&ufm_lock);
+
+	return (DDI_SUCCESS);
+}
+
+void
+ddi_ufm_fini(ddi_ufm_handle_t *ufmh)
+{
+	ASSERT(ufmh != NULL);
+
+	mutex_enter(&ufm_lock);
+	avl_remove(&ufm_handles, ufmh);
+	mutex_exit(&ufm_lock);
+
+	mutex_enter(&ufmh->ufmh_lock);
+	ufmh->ufmh_state |= DDI_UFM_STATE_SHUTTING_DOWN;
+	ufm_cache_invalidate(ufmh);
+	mutex_exit(&ufmh->ufmh_lock);
+
+	mutex_destroy(&ufmh->ufmh_lock);
+	kmem_free(ufmh, sizeof (ddi_ufm_handle_t));
+}
+
+void
+ddi_ufm_update(ddi_ufm_handle_t *ufmh)
+{
+	ASSERT(ufmh != NULL);
+
+	mutex_enter(&ufmh->ufmh_lock);
+	if (ufmh->ufmh_state & DDI_UFM_STATE_SHUTTING_DOWN) {
+		mutex_exit(&ufmh->ufmh_lock);
+		return;
+	}
+	ufm_cache_invalidate(ufmh);
+	ufmh->ufmh_state |= DDI_UFM_STATE_READY;
+	mutex_exit(&ufmh->ufmh_lock);
+}
+
+void
+ddi_ufm_image_set_desc(ddi_ufm_image_t *uip, const char *desc)
+{
+	ASSERT(uip != NULL && desc != NULL);
+	uip->ufmi_desc = i_ddi_strdup((char *)desc, KM_SLEEP);
+}
+
+void
+ddi_ufm_image_set_nslots(ddi_ufm_image_t *uip, uint_t nslots)
+{
+	ASSERT(uip != NULL);
+	uip->ufmi_nslots = nslots;
+}
+
+void
+ddi_ufm_image_set_misc(ddi_ufm_image_t *uip, nvlist_t *misc)
+{
+	ASSERT(uip != NULL && misc != NULL);
+	uip->ufmi_misc = misc;
+}
+
+void
+ddi_ufm_slot_set_version(ddi_ufm_slot_t *usp, const char *version)
+{
+	ASSERT(usp != NULL && version != NULL);
+	usp->ufms_version = i_ddi_strdup((char *)version, KM_SLEEP);
+}
+
+void
+ddi_ufm_slot_set_attrs(ddi_ufm_slot_t *usp, ddi_ufm_attr_t attr)
+{
+	ASSERT(usp != NULL);
+	usp->ufms_attrs = attr;
+}
+
+void
+ddi_ufm_slot_set_misc(ddi_ufm_slot_t *usp, nvlist_t *misc)
+{
+	ASSERT(usp != NULL && misc != NULL);
+	usp->ufms_misc = misc;
+}
diff --git a/usr/src/uts/common/sys/Makefile b/usr/src/uts/common/sys/Makefile
index 5a6d7a204c..d4da4c9bbc 100644
--- a/usr/src/uts/common/sys/Makefile
+++ b/usr/src/uts/common/sys/Makefile
@@ -21,9 +21,8 @@
 
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 # Copyright 2013 Garrett D'Amore <garrett@damore.org>
-# Copyright 2015, Joyent, Inc. All rights reserved.
 # Copyright 2013 Saso Kiselkov. All rights reserved.
 # Copyright 2015 Igor Kozhukhov <ikozhukhov@gmail.com>
 # Copyright 2017 Nexenta Systems, Inc.
@@ -171,6 +170,8 @@ CHKHDRS=			\
 	ddi_implfuncs.h		\
 	ddi_obsolete.h		\
 	ddi_periodic.h		\
+	ddi_ufm.h		\
+	ddi_ufm_impl.h		\
 	ddidevmap.h		\
 	ddidmareq.h		\
 	ddimapreq.h		\
diff --git a/usr/src/uts/common/sys/ddi_ufm.h b/usr/src/uts/common/sys/ddi_ufm.h
new file mode 100644
index 0000000000..de38a06b07
--- /dev/null
+++ b/usr/src/uts/common/sys/ddi_ufm.h
@@ -0,0 +1,211 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#ifndef _SYS_DDI_UFM_H
+#define	_SYS_DDI_UFM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/cred.h>
+#include <sys/dditypes.h>
+#include <sys/nvpair.h>
+#include <sys/param.h>
+
+#define	DDI_UFM_DEV		"/dev/ufm"
+#define	DDI_UFM_CURRENT_VERSION	1
+#define	DDI_UFM_VERSION_ONE	1
+
+#define	UFM_IOC			('u' << 24) | ('f' << 16) | ('m' << 8)
+#define	UFM_IOC_GETCAPS		(UFM_IOC | 1)
+#define	UFM_IOC_REPORTSZ	(UFM_IOC | 2)
+#define	UFM_IOC_REPORT		(UFM_IOC | 3)
+#define	UFM_IOC_MAX		UFM_IOC_REPORT
+
+/*
+ * Bitfield enumerating the DDI UFM capabilities supported by this device
+ * instance.  Currently there is only a single capability of being able to
+ * report UFM information.  Future UFM versions may add additional capabilities
+ * such as the ability to obtain a raw dump the firmware image or ability to
+ * upgrade the firmware.  When support for new capabilties are added to the DDI
+ * UFM subsystem, it should be reflected in this enum and the implementation of
+ * the UFM_IOC_GETCAPS should be extended appropriately.
+ */
+typedef enum {
+	DDI_UFM_CAP_REPORT	= 1 << 0,
+} ddi_ufm_cap_t;
+
+/*
+ * This struct defines the input/output data for the UFM_IOC_GETCAPS ioctl.
+ * Callers should specify the ufmg_version and ufmg_devpath fields.  On success
+ * the ufmg_caps field will be filled in with a value indicating the supported
+ * UFM capabilities of the device specified in ufmg_devpath.
+ */
+typedef struct ufm_ioc_getcaps {
+	uint_t 		ufmg_version;	/* DDI_UFM_VERSION */
+	uint_t		ufmg_caps;	/* UFM Caps */
+	char 		ufmg_devpath[MAXPATHLEN];
+} ufm_ioc_getcaps_t;
+
+/*
+ * This struct defines the input/output data for the UFM_IOC_REPORTSZ ioctl.
+ * Callers should specify the ufbz_version and ufbz_devpath fields.  On success
+ * the ufmg_size field will be filled in with the amount of space (in bytes)
+ * required to hold the UFM data for this device instance.  This should be used
+ * to allocate a sufficiently size buffer for the UFM_IOC_REPORT ioctl.
+ */
+typedef struct ufm_ioc_bufsz {
+	uint_t 		ufbz_version;	/* DDI_UFM_VERSION */
+	size_t		ufbz_size;	/* sz of buf to be returned by ioctl */
+	char		ufbz_devpath[MAXPATHLEN];
+} ufm_ioc_bufsz_t;
+
+#ifdef _KERNEL
+typedef struct ufm_ioc_bufsz32 {
+	uint_t		ufbz_version;
+	size32_t	ufbz_size;
+	char		ufbz_devpath[MAXPATHLEN];
+} ufm_ioc_bufsz32_t;
+#endif	/* _KERNEL */
+
+/*
+ * This struct defines the input/output data for the UFM_IOC_REPORT ioctl.
+ * Callers should specify the ufmr_version, ufmr_bufsz and ufmr_devpath fields.
+ * On success, the ufmr_buf field will point to a packed nvlist containing the
+ * UFM data for the specified device instance.
+ */
+typedef struct ufm_ioc_report {
+	uint_t		ufmr_version;	/* DDI_UFM_VERSION */
+	size_t		ufmr_bufsz;	/* size of caller-supplied buffer */
+	caddr_t		ufmr_buf;	/* buf to hold packed output nvl */
+	char		ufmr_devpath[MAXPATHLEN];
+} ufm_ioc_report_t;
+
+#ifdef _KERNEL
+typedef struct ufm_ioc_report32 {
+	uint_t		ufmr_version;
+	size32_t	ufmr_bufsz;
+	caddr32_t	ufmr_buf;
+	char		ufmr_devpath[MAXPATHLEN];
+} ufm_ioc_report32_t;
+#endif	/* _KERNEL */
+
+/*
+ * The UFM_IOC_REPORT ioctl return UFM image and slot data in the form of a
+ * packed nvlist.  The nvlist contains and array of nvlists (one-per-image).
+ * Each image nvlist contains will contain a string nvpair containing a
+ * description of the image and an optional nvlist nvpair containing
+ * miscellaneous image information.
+ */
+#define	DDI_UFM_NV_IMAGES		"ufm-images"
+#define	DDI_UFM_NV_IMAGE_DESC		"ufm-image-description"
+#define	DDI_UFM_NV_IMAGE_MISC		"ufm-image-misc"
+
+/*
+ * Each image nvlist also contains an array of nvlists representing the slots.
+ */
+#define	DDI_UFM_NV_IMAGE_SLOTS		"ufm-image-slots"
+
+/*
+ * Each slot nvlist as a string nvpair describing the firmware image version
+ * and an uint32 nvpair describing the slot attributes (see ddi_ufm_attr_t
+ * above).  An option nvlist nvpar may be present containing additional
+ * miscellaneous slot data.
+ */
+#define	DDI_UFM_NV_SLOT_VERSION		"ufm-slot-version"
+
+typedef enum {
+	DDI_UFM_ATTR_READABLE	= 1 << 0,
+	DDI_UFM_ATTR_WRITEABLE	= 1 << 1,
+	DDI_UFM_ATTR_ACTIVE	= 1 << 2
+} ddi_ufm_attr_t;
+
+#define	DDI_UFM_NV_SLOT_ATTR		"ufm-slot-attributes"
+
+#define	DDI_UFM_NV_SLOT_MISC		"ufm-slot-misc"
+
+#ifdef _KERNEL
+/* opaque structures */
+typedef struct ddi_ufm_handle ddi_ufm_handle_t;
+typedef struct ddi_ufm_image ddi_ufm_image_t;
+typedef struct ddi_ufm_slot ddi_ufm_slot_t;
+
+/*
+ * DDI UFM Operations vector
+ */
+typedef struct ddi_ufm_ops {
+	int (*ddi_ufm_op_nimages)(ddi_ufm_handle_t *, void *, uint_t *);
+	int (*ddi_ufm_op_fill_image)(ddi_ufm_handle_t *, void *, uint_t,
+	    ddi_ufm_image_t *);
+	int (*ddi_ufm_op_fill_slot)(ddi_ufm_handle_t *, void *, uint_t,
+	    ddi_ufm_slot_t *);
+	int (*ddi_ufm_op_getcaps)(ddi_ufm_handle_t *, void *, ddi_ufm_cap_t *);
+} ddi_ufm_ops_t;
+
+/*
+ * During a device driver's attach(9E) entry point, a device driver should
+ * register with the UFM subsystem by filling out a UFM operations vector
+ * (see above) and then calling ddi_ufm_init(9F).  The driver may pass in a
+ * value, usually a pointer to its soft state pointer, which it will then
+ * receive when its subsequent entry points are called.
+ */
+int ddi_ufm_init(dev_info_t *, uint_t version, ddi_ufm_ops_t *,
+    ddi_ufm_handle_t **, void *);
+
+/*
+ * Device drivers should call ddi_ufm_update(9F) after driver initialization is
+ * complete and after calling ddi_ufm_init(9F), in order to indicate to the
+ * UFM subsystem that the driver is in a state where it is ready to receive
+ * calls to its UFM entry points.
+ *
+ * Additionally, ehenever the driver detects a change in the state of a UFM, it
+ * should call ddi_ufm_update(9F).  This will cause the UFM subsystem to
+ * invalidate any cached state regarding this driver's UFM(s)
+ */
+void ddi_ufm_update(ddi_ufm_handle_t *);
+
+/*
+ * A device driver shoulld call ddi_ufm_fini(9F) during its detach(9E) entry
+ * point.  Upon return, the driver is gaurunteed that no further DDI UFM entry
+ * points will be called and thus any related state can be safely torn down.
+ *
+ * After return, the UFM handle is no longer valid and should not be used in
+ * any future ddi_ufm_* calls.
+ */
+void ddi_ufm_fini(ddi_ufm_handle_t *);
+
+/*
+ * These interfaces should only be called within the context of a
+ * ddi_ufm_op_fill_image callback.
+ */
+void ddi_ufm_image_set_desc(ddi_ufm_image_t *, const char *);
+void ddi_ufm_image_set_nslots(ddi_ufm_image_t *, uint_t);
+void ddi_ufm_image_set_misc(ddi_ufm_image_t *, nvlist_t *);
+
+/*
+ * These interfaces should only be called within the context of a
+ * ddi_ufm_op_fill_slot callback.
+ */
+void ddi_ufm_slot_set_version(ddi_ufm_slot_t *, const char *);
+void ddi_ufm_slot_set_attrs(ddi_ufm_slot_t *, ddi_ufm_attr_t);
+void ddi_ufm_slot_set_misc(ddi_ufm_slot_t *, nvlist_t *);
+#endif /* _KERNEL */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _SYS_DDI_UFM_H */
diff --git a/usr/src/uts/common/sys/ddi_ufm_impl.h b/usr/src/uts/common/sys/ddi_ufm_impl.h
new file mode 100644
index 0000000000..48a640c74f
--- /dev/null
+++ b/usr/src/uts/common/sys/ddi_ufm_impl.h
@@ -0,0 +1,74 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#ifndef _SYS_DDI_UFM_IMPL_H
+#define	_SYS_DDI_UFM_IMPL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/avl.h>
+#include <sys/ddi_ufm.h>
+#include <sys/mutex.h>
+#include <sys/nvpair.h>
+#include <sys/types.h>
+
+typedef enum {
+	DDI_UFM_STATE_INIT		= 1 << 0,
+	DDI_UFM_STATE_READY		= 1 << 1,
+	DDI_UFM_STATE_SHUTTING_DOWN	= 1 << 2
+} ddi_ufm_state_t;
+
+/* private interface for startup_ddi() */
+void ufm_init();
+
+/* private interfaces for ufm driver */
+struct ddi_ufm_handle *ufm_find(const char *);
+int ufm_cache_fill(struct ddi_ufm_handle *ufmh);
+
+struct ddi_ufm_slot {
+	uint_t			ufms_slotno;
+	char			*ufms_version;
+	ddi_ufm_attr_t		ufms_attrs;
+	nvlist_t		*ufms_misc;
+};
+
+struct ddi_ufm_image {
+	uint_t			ufmi_imageno;
+	char   			*ufmi_desc;
+	nvlist_t		*ufmi_misc;
+	struct ddi_ufm_slot	*ufmi_slots;
+	uint_t			ufmi_nslots;
+};
+
+struct ddi_ufm_handle {
+	kmutex_t		ufmh_lock;
+	char			ufmh_devpath[MAXPATHLEN];
+	ddi_ufm_ops_t		*ufmh_ops;
+	void			*ufmh_arg;
+	uint_t			ufmh_state;
+	uint_t			ufmh_version;
+	struct ddi_ufm_image	*ufmh_images;
+	uint_t			ufmh_nimages;
+	ddi_ufm_cap_t		ufmh_caps;
+	avl_node_t		ufmh_link;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _SYS_DDI_UFM_IMPL_H */
diff --git a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mptsas_var.h b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mptsas_var.h
index be8bf675b8..5b7a3f6442 100644
--- a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mptsas_var.h
+++ b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mptsas_var.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2014, Tegile Systems Inc. All rights reserved.
  */
 
@@ -62,6 +62,7 @@
 #include <sys/isa_defs.h>
 #include <sys/sunmdi.h>
 #include <sys/mdi_impldefs.h>
+#include <sys/ddi_ufm.h>
 #include <sys/scsi/adapters/mpt_sas/mptsas_ioctl.h>
 #include <sys/scsi/adapters/mpt_sas/mpi/mpi2_tool.h>
 #include <sys/scsi/adapters/mpt_sas/mpi/mpi2_cnfg.h>
@@ -914,6 +915,9 @@ typedef struct mptsas {
 	uint16_t		m_dev_handle;
 	uint16_t		m_smp_devhdl;
 
+	/* DDI UFM Handle */
+	ddi_ufm_handle_t	*m_ufmh;
+
 	/*
 	 * Event recording
 	 */
diff --git a/usr/src/uts/intel/Makefile.intel b/usr/src/uts/intel/Makefile.intel
index 00785ef1be..6745d4e2ed 100644
--- a/usr/src/uts/intel/Makefile.intel
+++ b/usr/src/uts/intel/Makefile.intel
@@ -21,7 +21,7 @@
 #
 # Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright (c) 2013 Andrew Stormont.  All rights reserved.
-# Copyright 2016 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 # Copyright 2016 Garrett D'Amore <garrett@damore.org>
 # Copyright 2018 Nexenta Systems, Inc.
 #
@@ -356,6 +356,7 @@ DRV_KMODS	+= trill
 DRV_KMODS	+= udp
 DRV_KMODS	+= udp6
 DRV_KMODS	+= ucode
+DRV_KMODS	+= ufm
 DRV_KMODS	+= ural
 DRV_KMODS	+= uath
 DRV_KMODS	+= urtw
diff --git a/usr/src/uts/intel/ufm/Makefile b/usr/src/uts/intel/ufm/Makefile
new file mode 100644
index 0000000000..ee16a1d019
--- /dev/null
+++ b/usr/src/uts/intel/ufm/Makefile
@@ -0,0 +1,48 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+UTSBASE	= ../..
+
+MODULE = ufm
+OBJECTS	= $(OBJS_DIR)/ufm.o
+LINTS = $(LINTS_DIR)/ufm.ln
+ROOTMODULE = $(ROOT_DRV_DIR)/$(MODULE)
+CONF_SRCDIR = $(UTSBASE)/common/io
+
+include $(UTSBASE)/intel/Makefile.intel
+
+ALL_TARGET = $(BINARY) $(SRC_CONFILE)
+LINT_TARGET = $(MODULE).lint
+INSTALL_TARGET = $(BINARY) $(ROOTMODULE) $(ROOT_CONFFILE)
+
+.KEEP_STATE:
+
+def: $(DEF_DEPS)
+
+all: $(ALL_DEPS)
+
+clean: $(CLEAN_DEPS)
+
+clobber: $(CLOBBER_DEPS)
+
+lint: $(LINT_DEPS)
+
+modlintlib: $(MODLINTLIB_DEPS)
+
+clean.lint: $(CLEAN_LINT_DEPS)
+
+install: $(INSTALL_DEPS)
+
+include $(UTSBASE)/intel/Makefile.targ
