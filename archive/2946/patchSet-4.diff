From c1ce0aa57c4e53955967178f18a934d5a12d6818 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Fri, 15 Dec 2017 18:43:02 +0100
Subject: [PATCH] TOOLS-1806 sdcadm can erroneously behave as if moray is in HA
 mode

---
 lib/procedures/index.js           |   6 +-
 lib/procedures/shared.js          |  56 +++--
 lib/procedures/update-moray-v2.js | 380 ++++++++++++++++++++++--------
 3 files changed, 327 insertions(+), 115 deletions(-)

diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index 7bd4167..a18c5ec 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -384,14 +384,12 @@ function coordinatePlan(opts, cb) {
             var remaining = [];
             changes.forEach(function (change) {
                 if (change.type === 'update-instance' &&
-                    change.service.name === 'moray')
-                {
+                    change.service.name === 'moray') {
                     change.inst = change.instance;
                     handle.push(change);
                 } else if ((change.type === 'update-service' ||
                     change.type === 'rollback-service') &&
-                    change.service.name === 'moray')
-                {
+                    change.service.name === 'moray') {
                     var svcInsts = instsFromSvcName[change.service.name] || [];
                     if (svcInsts.length && svcInsts.length > 1) {
                         var chInsts = forceSameImage ? svcInsts :
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index bc4f2a7..3be70e5 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -328,7 +328,7 @@ function waitForInstToBeUp(arg, cb) {
     var progress = arg.opts.progress;
     var sdcadm = arg.opts.sdcadm;
     var inst = arg.change.inst;
-    var uuid = (arg.tmpUUID) ? arg.tmpUUID: inst.instance;
+    var uuid = (arg.tmpUUID) ? arg.tmpUUID : inst.zonename;
 
     var counter = 0;
     var limit = 60;
@@ -342,7 +342,8 @@ function waitForInstToBeUp(arg, cb) {
             funcs: [
                 function checkInstIsRunning(_, next) {
                     if (running) {
-                        return next();
+                        next();
+                        return;
                     }
                     sdcadm.vmapi.getVm({
                         uuid: uuid
@@ -375,7 +376,8 @@ function waitForInstToBeUp(arg, cb) {
                 },
                 function checkInstSvcs(_, next) {
                     if (!running) {
-                        return next();
+                        next();
+                        return;
                     }
 
                     arg.opts.sdcadm.checkHealth({
@@ -385,17 +387,19 @@ function waitForInstToBeUp(arg, cb) {
                             arg.opts.log.debug({
                                 err: err
                             }, 'checkInstSvcs');
-                            return next(err);
+                            next(err);
+                            return;
                         }
                         arg.opts.log.debug({
                             results: results
                         }, 'checkInstSvcs');
                         var res = results[0];
                         if (res.health_errors && res.health_errors.length) {
-                            return next(new errors.InstanceIsDownError(
+                            next(new errors.InstanceIsDownError(
                                         res.health_errors[0].message));
+                            return;
                         }
-                        return next();
+                        next();
                     });
                 }
             ]
@@ -406,26 +410,27 @@ function waitForInstToBeUp(arg, cb) {
                 var hErrs = inst.health_errors;
                 if (hErrs && hErrs.length && hErrs[0].message &&
                     hErrs[0].message.match(/State\: maintenance/)) {
-                    return cb(new errors.InstanceIsDownError(
+                    cb(new errors.InstanceIsDownError(
                                 hErrs[0].message));
+                    return;
                 }
 
                 if (counter < limit) {
                     // Cleanup errors for next iteration, or it'll fail again:
                     delete inst.health_errors;
-                    return setTimeout(_waitForInstance, 5000);
+                    setTimeout(_waitForInstance, 5000);
                 } else {
-                    return cb(new errors.InstanceIsDownError(format(
+                    cb(new errors.InstanceIsDownError(format(
                         'Timeout (5m) waiting for %s instance %s ' +
-                        'to come up', inst.service, inst.zonename)));
+                        'to come up', inst.service, uuid)));
                 }
             } else {
-                return cb(null);
+                cb(null);
             }
         });
     }
     progress('Waiting for %s instance %s to come up',
-            inst.service, inst.zonename);
+            inst.service, uuid);
     _waitForInstance();
 }
 
@@ -487,7 +492,8 @@ function checkHA(arg, next) {
 
 function provisionTmpVm(arg, next) {
     if (arg.HA) {
-        return next();
+        next();
+        return;
     }
     var progress = arg.opts.progress;
     var sdcadm = arg.opts.sdcadm;
@@ -509,10 +515,13 @@ function provisionTmpVm(arg, next) {
         }
     }, function (err, body) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
-        arg.tmpUUID = body.uuid;
-        return next();
+        if (body && body.uuid) {
+            arg.tmpUUID = body.uuid;
+        }
+        next();
     });
 }
 
@@ -526,11 +535,20 @@ function waitForTmpInstToBeUp(arg, next) {
 
 
 function getTmpInstanceUUID(arg, next) {
+    assert.object(arg, 'arg');
+    assert.func(next, 'next');
     if (arg.HA) {
-        return next();
+        next();
+        return;
     }
+    assert.object(arg.opts, 'arg.opts');
+    assert.func(arg.opts.progress, 'arg.opts.progress');
+    assert.object(arg.opts.log, 'arg.opts.log');
+    assert.string(arg.tmpAlias, 'arg.tmpAlias');
+
     var progress = arg.opts.progress;
     var log = arg.opts.log;
+
     progress('Running vmadm lookup to get tmp instance UUID');
     var argv = [
         '/usr/sbin/vmadm',
@@ -538,14 +556,16 @@ function getTmpInstanceUUID(arg, next) {
         '-1',
         'alias=' + arg.tmpAlias
     ];
+
     common.execFilePlus({
         argv: argv,
         log: log
-    }, function (err, stdout, stderr) {
+    }, function (err, stdout) {
         if (err) {
             next(err);
         } else {
             arg.tmpUUID = stdout.trim();
+            assert.uuid(arg.tmpUUID);
             log.debug('Tmp instance found: %s', arg.tmpUUID);
             next();
         }
diff --git a/lib/procedures/update-moray-v2.js b/lib/procedures/update-moray-v2.js
index 411dcb9..13faf8d 100644
--- a/lib/procedures/update-moray-v2.js
+++ b/lib/procedures/update-moray-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -18,6 +18,9 @@ var common = require('../common');
 
 var Procedure = require('./procedure').Procedure;
 var s = require('./shared');
+
+var TMP_VM_RE = /^moray\d+tmp$/;
+
 /**
  * Procedure for updating moray service, HA
  */
@@ -46,7 +49,9 @@ UpdateMorayV2.prototype.summarize = function morayv2Summarize() {
                     common.indent(sprintf('(%s@%s)', img.name, img.version))];
         if (c0.insts) {
             out[0] += ':';
-            out = out.concat(c0.insts.map(function (inst) {
+            out = out.concat(c0.insts.filter(function filterTmpInsts(inst) {
+                return !TMP_VM_RE.test(inst.alias);
+            }).map(function instanceMsg(inst) {
                 return common.indent(sprintf('instance "%s" (%s) in server %s',
                     inst.zonename, inst.alias, inst.server));
             }));
@@ -55,41 +60,56 @@ UpdateMorayV2.prototype.summarize = function morayv2Summarize() {
     }
 };
 
+/*
+ * The update of moray service instances will happen as follows:
+ *
+ * First, we're gonna check if we're on HA setup and, if that's the
+ * case, we'll just proceed with the update of each one of the existing
+ * instances, giving that the existence of more of one moray instance
+ * grants the availability of the service and, therefore, of all the
+ * APIs involved into the update process.
+ *
+ * In case we're not on HA setup, we need to create a temporary instance
+ * (usually aliased moray0tmp), in order to avoid service disruption during
+ * the upgrade process. Once the update has been completed, we remove the
+ * temporary instance, leaving system on the same state we found it.
+ *
+ * Sometimes, we may fail destroying this temporary instance, either leaving
+ * the zone around, or destroying the zone, but leaving the sapi record not
+ * removed. This can cause the next update attempt to incorrectly interpret
+ * that we're into HA setup, which is not correct. In case we've just left
+ * the SAPI record around, we'll destroy it and continue normally. If we've
+ * also left the VM, we'll take advantage of it in order to speed up the
+ * update process and, once we're done, remove it, returning the system to
+ * the expected state.
+ */
 
 UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
-    common.assertStrictOptions('morayv2Execute', opts, {
-        sdcadm: 'object',
-        plan: 'object',
-        log: 'object',
-        progress: 'func',
-        wrkDir: 'string',
-        upDir: 'optionalString',
-        concurrency: 'optionalNumber',
-        ufds_backup_timeout: 'optionalNumber'
-    });
+    assert.object(opts, 'opts');
+    assert.object(opts.plan, 'opts.plan');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.log, 'opts.log');
+    assert.func(opts.progress, 'opts.progress');
     assert.func(cb, 'cb');
 
     var self = this;
     var progress = opts.progress;
     var rollback = opts.plan.rollback || false;
+    var sdcadm = opts.sdcadm;
 
     function updateMoray(change, nextSvc) {
-        var inst = change.inst;
 
         var arg = {
             change: change,
             opts: opts,
             userScript: false,
-            HA: false,
+            // We already know if we're on HA setup from `checkServiceHA`:
+            HA: change.HA,
             tmpAlias: null,
-            tmpUUID: null
+            tmpUUID: null,
+            tmpInstanceExists: false
         };
 
-        if ((change.insts && change.insts.length > 1) || change.HA) {
-            arg.HA = true;
-        } else {
-            arg.tmpAlias = inst.alias + 'tmp';
-        }
 
         if (opts.plan.changes.length > 1) {
             progress('');
@@ -98,6 +118,84 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
 
         var funcs = [];
 
+        if (change.tmpInsts) {
+            // If we have temporary instances around we want to check if
+            // those are just legacy SAPI instances w/o a running VM and
+            // clear them, or if we could take advantage of those temporary
+            // instances to speed up the update process otherwise:
+            funcs.push(function checkTmpInstsVms(ctx, next) {
+                vasync.forEachParallel({
+                    func: function getVmapiVm(tmpInst, nextVm) {
+                        sdcadm.vmapi.getVm({
+                            uuid: tmpInst.uuid
+                        }, function (vmErr, vm) {
+                            if (vmErr) {
+                                nextVm(new errors.SDCClientError(vmErr,
+                                    'vmapi'));
+                                return;
+                            }
+
+                            if (vm.state !== 'running') {
+                                ctx.tmpInstToRemove = ctx.tmpInstToRemove || [];
+                                ctx.tmpInstToRemove.push(tmpInst.uuid);
+                            } else {
+                                // We can safely set tmpAlias and tmpUUID
+                                // values here to our existing tmp instance
+                                ctx.tmpAlias = tmpInst.params.alias;
+                                ctx.tmpUUID = tmpInst.uuid;
+                                ctx.tmpInstanceExists = true;
+                            }
+                            nextVm();
+                        });
+                    },
+                    inputs: ctx.change.tmpInsts
+                }, next);
+            });
+            // Remove SAPI instances without a running VM from change.tmpInsts:
+            funcs.push(function removeDestroyedInsts(ctx, next) {
+                if (!ctx.tmpInstToRemove || !ctx.tmpInstToRemove.length) {
+                    next();
+                    return;
+                }
+                ctx.change.tmpInsts = ctx.change.tmpInsts.filter(
+                    function removeDestroyedInst(inst) {
+                    return (!ctx.tmpInstToRemove.indexOf(inst.uuid));
+                });
+                next();
+            });
+            // Remove SAPI instances w/o a running VM from SAPI:
+            funcs.push(function removeInstFromSapi(ctx, next) {
+                if (!ctx.tmpInstToRemove || !ctx.tmpInstToRemove.length) {
+                    next();
+                    return;
+                }
+                vasync.forEachParallel({
+                    inputs: ctx.tmpInstToRemove,
+                    func: function removeFromSapi(inst, nextInst) {
+                        sdcadm.sapi.deleteInstance(inst, function (remErr) {
+                            if (remErr) {
+                                nextInst(new errors.SDCClientError(remErr,
+                                    'sapi'));
+                                return;
+                            }
+                            nextInst();
+                        });
+                    }
+                }, next);
+            });
+        }
+
+        if (change.tmpInsts || !arg.HA) {
+            funcs.push(function setTmpInstAlias(ctx, next) {
+                if (ctx.tmpAlias) {
+                    next();
+                    return;
+                }
+                ctx.tmpAlias  = ctx.change.insts[0].alias + 'tmp';
+                next();
+            });
+        }
+
         if (rollback) {
             funcs.push(s.getOldUserScript);
         } else {
@@ -107,30 +205,26 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
 
         funcs.push(s.updateSvcUserScript);
 
-        if (arg.HA) {
-            change.insts.forEach(function (ins) {
-                funcs.push(function (_, next) {
-                    s.updateVmUserScriptRemote({
-                        service: change.service,
-                        progress: progress,
-                        zonename: ins.zonename,
-                        log: opts.log,
-                        server: ins.server,
-                        userScript: arg.userScript
-                    }, next);
-                });
+        change.insts.forEach(function (ins) {
+            funcs.push(function updateVmUserScript(_, next) {
+                s.updateVmUserScriptRemote({
+                    service: change.service,
+                    progress: progress,
+                    zonename: ins.zonename,
+                    log: opts.log,
+                    server: ins.server,
+                    userScript: arg.userScript
+                }, next);
             });
-        } else {
-            funcs.push(s.updateVmUserScript);
-        }
+        });
 
         funcs.push(s.updateSapiSvc);
 
         if (arg.HA) {
             change.insts.forEach(function (ins) {
                 funcs = funcs.concat([
-                    function imgadmInstall(_, next) {
-                        return s.imgadmInstallRemote({
+                    function imgadmInstallForInst(_, next) {
+                        s.imgadmInstallRemote({
                             progress: progress,
                             img: change.image,
                             log: opts.log,
@@ -165,12 +259,19 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                             sdcadm: opts.sdcadm
                         }, next);
                     },
-                    function waitForInstToBeUp(_, next) {
-                        progress('Wait (sleep) for %s instance %s to come up',
-                            ins.service, ins.zonename);
-                        setTimeout(next, 15 * 1000);
+                    function waitForEachInstanceToBeUp(_, next) {
+                        s.waitForInstToBeUp({
+                            opts: {
+                                progress: progress,
+                                sdcadm: opts.sdcadm,
+                                log: opts.log
+                            },
+                            change: {
+                                inst: ins
+                            }
+                        }, next);
                     },
-                    function waitUntilInstInDNS(_, next) {
+                    function waitUntilEachInstInDNS(_, next) {
                         s.waitUntilVmInDNS({
                             log: opts.log,
                             progress: progress,
@@ -184,82 +285,145 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
             });
         } else {
             funcs = funcs.concat([
-                s.imgadmInstall,
-                function getHeadnode(_, next) {
-                    opts.sdcadm.getCurrServerUuid(function (err, hn) {
-                        if (err) {
-                            next(err);
+                function imgadmInstall(ctx, next) {
+                    s.imgadmInstallRemote({
+                        progress: progress,
+                        img: ctx.change.image,
+                        log: opts.log,
+                        server: ctx.change.inst.server
+                    }, next);
+                },
+                /**
+                 * Create a temporary "morayXtmp" instance when no HA
+                 */
+                function provisionTmpVm(ctx, next) {
+                    if (ctx.tmpInstanceExists) {
+                        next();
+                        return;
+                    }
+                    var provOpts = {
+                        opts: {
+                            progress: progress,
+                            sdcadm: opts.sdcadm,
+                            log: opts.log
+                        },
+                        tmpAlias: ctx.tmpAlias,
+                        change: ctx.change,
+                        server_uuid: ctx.change.inst.server
+                    };
+                    s.provisionTmpVm(provOpts, function provCb(provErr) {
+                        if (provErr) {
+                            next(provErr);
+                            return;
+                        }
+                        if (!provOpts.tmpUUID) {
+                            next(new errors.InternalError('Provisioning ' +
+                                'temporary VM did not return VM UUID'));
                             return;
                         }
-                        arg.server_uuid = hn;
+                        ctx.tmpUUID = provOpts.tmpUUID;
                         next();
                     });
                 },
-                /**
-                 * Create a temporary "morayXtmp" instance when no HA
-                 */
-                s.provisionTmpVm,
-                s.waitForTmpInstToBeUp,
-                s.getTmpInstanceUUID,
-                s.checkIfTmpVMHasErrors,
-                function waitUntilTmpInDNS(_, next) {
-                    return s.waitUntilVmInDNS({
+                function waitForTmpInstToBeUp(ctx, next) {
+                    if (ctx.tmpInstanceExists) {
+                        next();
+                        return;
+                    }
+                    s.waitForInstToBeUp({
+                        opts: {
+                            progress: progress,
+                            sdcadm: opts.sdcadm,
+                            log: opts.log
+                        },
+                        tmpUUID: ctx.tmpUUID,
+                        change: ctx.change
+                    }, next);
+                },
+                function waitUntilTmpInDNS(ctx, next) {
+                    if (ctx.tmpInstanceExists) {
+                        next();
+                        return;
+                    }
+                    s.waitUntilVmInDNS({
                         log: opts.log,
                         progress: progress,
-                        zonename: arg.tmpUUID,
-                        alias: arg.tmpAlias,
-                        server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        zonename: ctx.tmpUUID,
+                        alias: ctx.tmpAlias,
+                        server: ctx.change.inst.server,
+                        domain: ctx.change.service.metadata.SERVICE_DOMAIN
                     }, next);
                 },
-                function disableVMRegistrar(_, next) {
-                    return s.disableVMRegistrar({
+
+                function disableVMRegistrar(ctx, next) {
+                    s.disableVMRegistrar({
                         log: opts.log,
                         progress: progress,
-                        zonename: inst.zonename
+                        zonename: ctx.change.inst.zonename
                     }, next);
                 },
-                function waitUntilVMNotInDNS(_, next) {
+                function waitUntilVMNotInDNS(ctx, next) {
                     s.waitUntilVMNotInDNS({
                         log: opts.log,
                         progress: progress,
-                        zonename: inst.zonename,
-                        server: inst.server,
-                        alias: inst.alias,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        zonename: ctx.change.inst.zonename,
+                        server: ctx.change.inst.server,
+                        alias: ctx.change.inst.alias,
+                        domain: ctx.change.service.metadata.SERVICE_DOMAIN
                     }, next);
                 },
-                s.reprovision,
-                s.waitForInstToBeUp,
-                function waitUntilVmInDNS(_, next) {
+                function reprovisionSingleInst(ctx, next) {
+                    s.reprovisionRemote({
+                        server: ctx.change.inst.server,
+                        img: ctx.change.image,
+                        zonename: ctx.change.inst.zonename,
+                        progress: progress,
+                        log: opts.log,
+                        sdcadm: opts.sdcadm
+                    }, next);
+                },
+                function waitForInstanceToBeUp(ctx, next) {
+                    s.waitForInstToBeUp({
+                        opts: {
+                            progress: progress,
+                            sdcadm: opts.sdcadm,
+                            log: opts.log
+                        },
+                        change: {
+                            inst: ctx.change.inst
+                        }
+                    }, next);
+                },
+                function waitUntilInstInDNS(ctx, next) {
                     s.waitUntilVmInDNS({
                         log: opts.log,
                         progress: progress,
-                        zonename: inst.zonename,
-                        alias: inst.alias,
-                        server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        zonename: ctx.change.inst.zonename,
+                        server: ctx.change.inst.server,
+                        alias: ctx.change.inst.alias,
+                        domain: ctx.change.service.metadata.SERVICE_DOMAIN
                     }, next);
                 },
-                function disableTmpVMRegistrar(_, next) {
-                    return s.disableVMRegistrar({
+                function disableTmpVMRegistrar(ctx, next) {
+                    s.disableVMRegistrar({
                         log: opts.log,
                         progress: progress,
-                        zonename: arg.tmpUUID
+                        zonename: ctx.tmpUUID
                     }, next);
                 },
-                function waitUntilTmpVMNotInDNS(_, next) {
-                    return s.waitUntilVMNotInDNS({
+                function waitUntilTmpVMNotInDNS(ctx, next) {
+                    s.waitUntilVMNotInDNS({
                         log: opts.log,
                         progress: progress,
-                        zonename: arg.tmpUUID,
-                        alias: arg.tmpAlias,
-                        server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        zonename: ctx.tmpUUID,
+                        alias: ctx.tmpAlias,
+                        server: ctx.change.inst.server,
+                        domain: ctx.change.service.metadata.SERVICE_DOMAIN
                     }, next);
                 },
-                s.stopTmpVm,
-                s.destroyTmpVM
+                function destroyTmpVm(ctx, next) {
+                    s.destroyTmpVM(ctx, next);
+                }
             ]);
         }
         vasync.pipeline({funcs: funcs, arg: arg}, nextSvc);
@@ -272,15 +436,45 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
             service_uuid: change.service.uuid
         }, function (err, insts) {
             if (err) {
-                return nextSvc(new errors.SDCClientError(err, 'SAPI'));
+                nextSvc(new errors.SDCClientError(err, 'SAPI'));
+                return;
             }
-            if (insts.length > 1) {
-                change.HA = true;
-                if (!change.insts) {
-                    change.insts = [change.inst];
+            // Try to find if any of the existing SAPI instances is a temporary
+            // one left around from a previous update failure:
+            var tmpInsts = insts.filter(function findTmpInsts(ins) {
+                return (ins.params && ins.params.alias &&
+                    TMP_VM_RE.test(ins.params.alias));
+            });
+            if (tmpInsts.length) {
+                change.tmpInsts = tmpInsts;
+                // In case we have temporary instances, we will not update
+                // them. Just take advantage of it (probably will have just
+                // a single temporary instance) in order to speed up the
+                // update process. Remove temporary instances from main
+                // "insts" object:
+                if (change.insts) {
+                    change.insts = change.insts.filter(
+                        function skipTmpInst(ins) {
+                        return (ins.alias && !TMP_VM_RE.test(ins.alias));
+                    });
                 }
             }
-            return updateMoray(change, nextSvc);
+
+            // Shortcut to single instance update:
+            if (change.insts && change.insts.length === 1 && !change.inst) {
+                change.inst = change.insts[0];
+            }
+
+            // Having a temporary instance doesn't mean we're on HA setup:
+            if ((insts.length > 1 && !tmpInsts.length) ||
+                (insts.length >= tmpInsts.length + 1)) {
+                change.HA = true;
+            }
+
+            if (!change.insts) {
+                change.insts = [change.inst];
+            }
+            updateMoray(change, nextSvc);
         });
     }
 
-- 
2.21.0

