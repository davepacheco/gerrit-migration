From 46acfc8879916b38991e72123e27c0b6eefd5116 Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Wed, 12 Apr 2017 16:56:04 -0700
Subject: [PATCH] MORAY-104 moray: disallow filtering on non-indexed fields
 except interactively

---
 CHANGES.md             |   4 ++
 docs/man/man3/moray.md |  16 +++++
 lib/client.js          |   9 ++-
 lib/objects.js         | 129 ++++++++++++++++++++++++++++++++++++++++-
 package.json           |   2 +-
 5 files changed, 155 insertions(+), 5 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index 905f8bc..991eafb 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## v3.2.0
+
+* [MORAY-104](http://smartos.org/bugview/MORAY-104) disallow filtering on non-indexed fields except interactively
+
 ## v3.1.1
 
 * [MORAY-396](http://smartos.org/bugview/MORAY-396) update to cueball v2
diff --git a/docs/man/man3/moray.md b/docs/man/man3/moray.md
index 24939d7..4ddab86 100644
--- a/docs/man/man3/moray.md
+++ b/docs/man/man3/moray.md
@@ -239,6 +239,22 @@ Callers may also provide:
   this client has not been closed.  This is useful for making sure that client
   consumers clean up after themselves.
 
+`requireIndexes` (boolean)
+  If true, all `findObjects` requests sent from this client will respond with a
+  `NotIndexedError` error if at least one of the fields included in the search
+  filter has an index that can't be used.
+
+  If the server that handles a given `findObjects` request does not support
+  checking that search fields have usable indexes, an `UnhandledOptionsError`
+  event will be emitted. In this case, the error object will have a property
+  named `unhandledOptions` whose value is an array of strings that will contain
+  the string `'requireIndexes'`, to represent that this option wasn't handled by
+  the moray server that served the `findObjects` request.
+
+  Passing `requireIndexes: false` to any `findObjects` request will disable this
+  behavior for that specific request, regardless of the value of the
+  `requireIndexes` option passed when instantiating the client.
+
 Some legacy options are accepted as documented in the source.
 
 ## ENVIRONMENT
diff --git a/lib/client.js b/lib/client.js
index c674756..e08178c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -84,6 +84,7 @@ function MorayClient(options) {
     assert.object(options.log, 'options.log');
     assert.optionalBool(options.unwrapErrors, 'options.unwrapErrors');
     assert.optionalBool(options.failFast, 'options.failFast');
+    assert.optionalBool(options.requireIndexes, 'options.requireIndexes');
 
     coptions = parseMorayParameters(options);
     cueballOptions = coptions.cueballOptions;
@@ -93,6 +94,7 @@ function MorayClient(options) {
 
     this.unwrapErrors = options.unwrapErrors ? true : false;
     this.failFast = options.failFast ? true : false;
+    this.requireIndexes = options.requireIndexes ? true : false;
 
     /* Helper objects. */
     this.log = options.log.child({
@@ -765,9 +767,14 @@ MorayClient.prototype.findObjects = function findObjects(b, f, opts) {
     assert.string(f, 'filter');
     assert.optionalObject(opts, 'options');
 
+    var defaultOpts = {requireIndexes: this.requireIndexes};
+    if (opts && opts.requireIndexes === undefined) {
+        opts.requireIndexes = this.requireIndexes;
+    }
+
     var rpcctx = this.ctxCreateForEmitter();
     if (rpcctx) {
-        var rv = objects.findObjects(rpcctx, b, f, (opts || {}));
+        var rv = objects.findObjects(rpcctx, b, f, (opts || defaultOpts));
         this.releaseWhenDone(rpcctx, rv);
         return (rv);
     }
diff --git a/lib/objects.js b/lib/objects.js
index cd502af..b0425bc 100644
--- a/lib/objects.js
+++ b/lib/objects.js
@@ -119,6 +119,74 @@ function deleteObject(rpcctx, bucket, key, options, callback) {
     });
 }
 
+/*
+ * Returns an array of strings representing the name of options that should have
+ * been explicitly marked as handled by a moray server, but were not. Returns an
+ * empty array in case this set is empty.
+ *
+ * @param {Object} options - represents the options passed to a findObjects
+ * request.
+ *
+ * @param {Object} handledOptions - represents the options that were actually
+ * acknowledged as handled by the moray server that served this findObjects
+ * request.
+ *
+ * @param {Object} optionsSpec - stores functions that determine when the value
+ * of an option passed to a findObjects request means that the use of that
+ * option needs to be handled by the moray server serving that request. For
+ * instance, when passing: `requireIndexes: false` to a findObjects request,
+ * there's no need to require the server to acknowledge that it can handle this
+ * option.
+ */
+function getUnhandledOptions(options, handledOptions, optionsSpec) {
+    assert.object(options, 'options');
+    assert.object(handledOptions, 'handledOptions');
+    assert.object(optionsSpec, 'optionsSpec');
+
+    var optionName;
+    var optionValue;
+    var testNeedHandlingFn;
+    var unhandledOptions = [];
+
+    for (optionName in options) {
+        if (!Object.hasOwnProperty.call(optionsSpec, optionName)) {
+            continue;
+        }
+
+        optionValue = options[optionName];
+
+        testNeedHandlingFn = optionsSpec[optionName].testNeedHandling;
+        assert.func(testNeedHandlingFn, 'testNeedHandlingFn');
+
+        if (testNeedHandlingFn(optionValue) &&
+            handledOptions[optionName] === false) {
+            unhandledOptions.push(optionName);
+        }
+    }
+
+    return (unhandledOptions);
+}
+
+/*
+ * Emits an UnhandledOptionsError error event on the event emitter "res".
+ *
+ * @param {Object} res - the response object on which to emit the error.
+ *
+ * @param {Array} unhandledOptions - an array of strings that represents the
+ * name of options that should have been marked as explicitly handled by the
+ * moray server serving a findObjects request.
+ */
+function emitUnhandledOptionsError(res, unhandledOptions) {
+    assert.object(res, 'res');
+    assert.object(unhandledOptions, 'unhandledOptions');
+
+    var err = new Error('Unhandled options: ' + unhandledOptions.join(', '));
+    err.name = 'UnhandledOptionsError';
+    err.unhandledOptions = unhandledOptions;
+
+    res.emit('error', err);
+}
+
 function findObjects(rpcctx, bucket, filter, options) {
     var opts, log, req, res;
 
@@ -126,8 +194,33 @@ function findObjects(rpcctx, bucket, filter, options) {
     assert.string(bucket, 'bucket');
     assert.string(filter, 'filter');
     assert.object(options, 'options');
+    assert.optionalBool(options.requireIndexes, 'options.requireIndexes');
+
+    var gotMetadataRecord = false;
+    var isFirstDataRecord = true;
+    var needMetadataRecord = false;
+    var handledOptions = {
+        'requireIndexes': false
+    };
+    var optionsSpec = {
+        requireIndexes: {
+            testNeedHandling: function testNeedHandling(value) {
+                return (value === true);
+            }
+        }
+    };
+    var optionsToHandle = [];
+    var unhandledOptionsErrorEmitted = false;
+
+    optionsToHandle = getUnhandledOptions(options, handledOptions,
+        optionsSpec);
+    needMetadataRecord  = optionsToHandle.length > 0;
 
     opts = makeOptions(options);
+    if (needMetadataRecord) {
+        opts.internalOpts = {sendHandledOptions: true};
+    }
+
     log = rpc.childLogger(rpcctx, opts);
     res = new EventEmitter();
     req = rpc.rpcCommon({
@@ -139,15 +232,45 @@ function findObjects(rpcctx, bucket, filter, options) {
         if (err) {
             res.emit('error', err);
         } else {
-            res.emit('end');
+            if (!unhandledOptionsErrorEmitted) {
+                if (needMetadataRecord && !gotMetadataRecord) {
+                    emitUnhandledOptionsError(res, optionsToHandle);
+                } else {
+                    res.emit('end');
+                }
+            }
         }
 
         res.emit('_moray_internal_rpc_done');
     });
 
     req.on('data', function onObject(msg) {
-        log.debug({ object: msg }, 'findObjects: record found');
-        res.emit('record', msg);
+        var unhandledOptions = [];
+
+        if (isFirstDataRecord && needMetadataRecord) {
+            if (Object.hasOwnProperty.call(msg, '_handledOptions')) {
+                gotMetadataRecord = true;
+
+                if (msg._handledOptions) {
+                    if (msg._handledOptions.indexOf('requireIndexes') !== -1) {
+                        handledOptions.requireIndexes = true;
+                    }
+                }
+            }
+
+            unhandledOptions = getUnhandledOptions(options, handledOptions,
+                optionsSpec);
+            if (unhandledOptions.length > 0) {
+                emitUnhandledOptionsError(res, unhandledOptions);
+                unhandledOptionsErrorEmitted = true;
+                req.removeListener('data', onObject);
+            }
+
+            isFirstDataRecord = false;
+        } else {
+            log.debug({ object: msg }, 'findObjects: record found');
+            res.emit('record', msg);
+        }
     });
 
     return (res);
diff --git a/package.json b/package.json
index 8ad1858..671f2cb 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "3.1.1",
+    "version": "3.2.0",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
-- 
2.21.0

