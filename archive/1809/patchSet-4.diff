commit fcaf7144807b7bd7d356ad50b7043bb21ca0bfde (refs/changes/09/1809/4)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-05-16T12:55:41-07:00 (2 years, 5 months ago)
    
    MORAY-104 moray: disallow filtering on non-indexed fields except interactively

diff --git a/CHANGES.md b/CHANGES.md
index 905f8bc..991eafb 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## v3.2.0
+
+* [MORAY-104](http://smartos.org/bugview/MORAY-104) disallow filtering on non-indexed fields except interactively
+
 ## v3.1.1
 
 * [MORAY-396](http://smartos.org/bugview/MORAY-396) update to cueball v2
diff --git a/bin/findobjects b/bin/findobjects
index 3b27514..7f18989 100755
--- a/bin/findobjects
+++ b/bin/findobjects
@@ -21,7 +21,7 @@ var prettyPrint = true;
 cmdutil.configure({
     'usageMessage': 'fetch objects from Moray matching a filter',
     'synopses': [
-        moraycli.commonUsage + '[-Hns] [-a attr] [-d attr] [-l limit] ' +
+        moraycli.commonUsage + '[-Hins] [-a attr] [-d attr] [-l limit] ' +
             '[-o offset] BUCKET FILTER'
     ]
 });
@@ -32,7 +32,7 @@ parser = moraycli.parseCliOptions({
     'argv': process.argv,
     'env': process.env,
     'errstream': process.stderr,
-    'extraOptStr': 'a:d:Hl:no:s',
+    'extraOptStr': 'a:d:Hil:no:s',
     'clientOptions': clientOptions,
     'onUsage': cmdutil.usage,
     'onOption': function (option) {
@@ -55,6 +55,10 @@ parser = moraycli.parseCliOptions({
             prettyPrint = false;
             break;
 
+        case 'i':
+            findOptions.requireIndexes = true;
+            break;
+
         case 'l':
             p = parseInt(option.optarg, 10);
             if (isNaN(p) || p < 0) {
diff --git a/docs/man/man1/findobjects.md b/docs/man/man1/findobjects.md
index 381e584..2b23f9f 100644
--- a/docs/man/man1/findobjects.md
+++ b/docs/man/man1/findobjects.md
@@ -6,7 +6,7 @@ findobjects - fetch the contents of multiple objects using a filter
 
 ## SYNOPSIS
 
-`findobjects [COMMON_OPTIONS] [-Hns] [-a FIELD] [-d FIELD] [-l LIMIT] [-o OFFSET] BUCKET FILTER`
+`findobjects [COMMON_OPTIONS] [-Hins] [-a FIELD] [-d FIELD] [-l LIMIT] [-o OFFSET] BUCKET FILTER`
 
 ## DESCRIPTION
 
@@ -69,6 +69,12 @@ use unindexed fields often results in truncated result sets.
   Print objects using minimal JSON with one object per line (instead of
   inserting newlines within objects and indenting for readability)
 
+`-i`
+  Require all fields used in `FILTER` to have associated usable indexes.  That
+  is, every field mentioned in `FILTER` must have a corresponding index, and no
+  field must be being re-indexed.  If the requirement is not met, the command
+  will return an error.
+
 `-l LIMIT`
   Return at most `LIMIT` objects.  With `-o OFFSET`, this can be used to page
   through a large result set.  However, this interacts badly with filters on
diff --git a/docs/man/man3/moray.md b/docs/man/man3/moray.md
index 24939d7..4ddab86 100644
--- a/docs/man/man3/moray.md
+++ b/docs/man/man3/moray.md
@@ -239,6 +239,22 @@ Callers may also provide:
   this client has not been closed.  This is useful for making sure that client
   consumers clean up after themselves.
 
+`requireIndexes` (boolean)
+  If true, all `findObjects` requests sent from this client will respond with a
+  `NotIndexedError` error if at least one of the fields included in the search
+  filter has an index that can't be used.
+
+  If the server that handles a given `findObjects` request does not support
+  checking that search fields have usable indexes, an `UnhandledOptionsError`
+  event will be emitted. In this case, the error object will have a property
+  named `unhandledOptions` whose value is an array of strings that will contain
+  the string `'requireIndexes'`, to represent that this option wasn't handled by
+  the moray server that served the `findObjects` request.
+
+  Passing `requireIndexes: false` to any `findObjects` request will disable this
+  behavior for that specific request, regardless of the value of the
+  `requireIndexes` option passed when instantiating the client.
+
 Some legacy options are accepted as documented in the source.
 
 ## ENVIRONMENT
diff --git a/lib/client.js b/lib/client.js
index c674756..e08178c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -84,6 +84,7 @@ function MorayClient(options) {
     assert.object(options.log, 'options.log');
     assert.optionalBool(options.unwrapErrors, 'options.unwrapErrors');
     assert.optionalBool(options.failFast, 'options.failFast');
+    assert.optionalBool(options.requireIndexes, 'options.requireIndexes');
 
     coptions = parseMorayParameters(options);
     cueballOptions = coptions.cueballOptions;
@@ -93,6 +94,7 @@ function MorayClient(options) {
 
     this.unwrapErrors = options.unwrapErrors ? true : false;
     this.failFast = options.failFast ? true : false;
+    this.requireIndexes = options.requireIndexes ? true : false;
 
     /* Helper objects. */
     this.log = options.log.child({
@@ -765,9 +767,14 @@ MorayClient.prototype.findObjects = function findObjects(b, f, opts) {
     assert.string(f, 'filter');
     assert.optionalObject(opts, 'options');
 
+    var defaultOpts = {requireIndexes: this.requireIndexes};
+    if (opts && opts.requireIndexes === undefined) {
+        opts.requireIndexes = this.requireIndexes;
+    }
+
     var rpcctx = this.ctxCreateForEmitter();
     if (rpcctx) {
-        var rv = objects.findObjects(rpcctx, b, f, (opts || {}));
+        var rv = objects.findObjects(rpcctx, b, f, (opts || defaultOpts));
         this.releaseWhenDone(rpcctx, rv);
         return (rv);
     }
diff --git a/lib/objects.js b/lib/objects.js
index cd502af..03d99ca 100644
--- a/lib/objects.js
+++ b/lib/objects.js
@@ -119,6 +119,102 @@ function deleteObject(rpcctx, bucket, key, options, callback) {
     });
 }
 
+/*
+ * Returns an array of strings representing the name of options that should have
+ * been explicitly marked as handled by a moray server, but were not. Returns an
+ * empty array in case this set is empty.
+ *
+ * @param {Object} handledOptions - represents the options that were actually
+ * acknowledged as handled by the Moray server that served this findObjects
+ * request. If an option was acknowledged as handled by the server, then a
+ * property with the name of the option will have the value true in the
+ * "handledOptions" object.
+ *
+ * @param {string[]} optionsToHandle - represents the options that are expected
+ * to be handled by the Moray server that served this findObjects request.
+ */
+function getUnhandledOptions(handledOptions, optionsToHandle) {
+    assert.object(handledOptions, 'handledOptions');
+    assert.arrayOfString(optionsToHandle, 'optionsToHandle');
+
+    var optionName;
+    var optionNameIndex;
+    var unhandledOptions = [];
+
+    for (optionNameIndex in optionsToHandle) {
+        optionName = optionsToHandle[optionNameIndex];
+        if (!handledOptions[optionName]) {
+            unhandledOptions.push(optionName);
+        }
+    }
+
+    return (unhandledOptions);
+}
+
+/*
+ * Based on the option specifications in "optionsSpec", returns the option names
+ * present in "options" that require an acknowledgement from Moray that they've
+ * been handled.
+ *
+ * @param {Object} options
+ * @param {Object} optionsSpec - stores metadata about some findObjects options,
+ * such as a function named "testNeedHandling"
+ */
+function getOptionsToHandle(options, optionsSpec) {
+    assert.object(options, 'options');
+    assert.object(optionsSpec, 'optionsSpec');
+
+    var optionName;
+    var optionValue;
+    var optionsToHandle = [];
+    var testNeedHandlingFn;
+
+    for (optionName in options) {
+        if (!Object.hasOwnProperty.call(options, optionName)) {
+            continue;
+        }
+
+        if (optionsSpec[optionName] !== undefined) {
+            assert.object(optionsSpec[optionName], 'optionsSpec[optionName]');
+            testNeedHandlingFn = optionsSpec[optionName].testNeedHandling;
+            assert.func(testNeedHandlingFn, 'testNeedHandlingFn');
+
+            optionValue = options[optionName];
+            if (testNeedHandlingFn(optionValue)) {
+                optionsToHandle.push(optionName);
+            }
+        }
+    }
+
+    return (optionsToHandle);
+}
+
+/*
+ * Creates an return a VError instance that represents an error due to the Moray
+ * server not handling options that were expected to be handled by the client.
+ *
+ * @param {Array} unhandledOptions - an array of strings that represents the
+ * name of options that should have been marked as explicitly handled by the
+ * moray server serving a findObjects request.
+ *
+ * @param {Object} cause - an instance of Error that will be used as the "cause"
+ * for the newly created VError object.
+ */
+function createUnhandledOptionsError(unhandledOptions, cause) {
+    assert.arrayOfString(unhandledOptions, 'unhandledOptions');
+    assert.optionalObject(cause, 'cause');
+
+    var err = new VError({
+        name: 'UnhandledOptionsError',
+        info: {
+            unhandledOptions: unhandledOptions
+        },
+        cause: cause
+    }, 'Unhandled options: %j', unhandledOptions);
+
+    return (err);
+}
+
 function findObjects(rpcctx, bucket, filter, options) {
     var opts, log, req, res;
 
@@ -126,8 +222,34 @@ function findObjects(rpcctx, bucket, filter, options) {
     assert.string(bucket, 'bucket');
     assert.string(filter, 'filter');
     assert.object(options, 'options');
+    assert.optionalBool(options.requireIndexes, 'options.requireIndexes');
+
+    var scheduleEmitUnhandledOptionsError = false;
+    var gotMetadataRecord = false;
+    var isFirstDataRecord = true;
+    var needMetadataRecord = false;
+    var handledOptions = {
+        'requireIndexes': false
+    };
+    var optionsSpec = {
+        requireIndexes: {
+            testNeedHandling: function testNeedHandling(value) {
+                return (value === true);
+            }
+        }
+    };
+    var optionsToHandle = [];
+    var unhandledOptions = [];
+    var unhandledOptionsErrorEmitted = false;
+
+    optionsToHandle = getOptionsToHandle(options, optionsSpec);
+    needMetadataRecord = optionsToHandle.length > 0;
 
     opts = makeOptions(options);
+    if (needMetadataRecord) {
+        opts.internalOpts = {sendHandledOptions: true};
+    }
+
     log = rpc.childLogger(rpcctx, opts);
     res = new EventEmitter();
     req = rpc.rpcCommon({
@@ -137,17 +259,62 @@ function findObjects(rpcctx, bucket, filter, options) {
         'rpcargs': [ bucket, filter, opts ]
     }, function (err) {
         if (err) {
+            if (VError.hasCauseWithName(err, 'FastRequestAbandonedError') &&
+                scheduleEmitUnhandledOptionsError === true) {
+                err = createUnhandledOptionsError(unhandledOptions, err);
+            }
+
             res.emit('error', err);
         } else {
-            res.emit('end');
+            if (!unhandledOptionsErrorEmitted) {
+                if (needMetadataRecord && !gotMetadataRecord) {
+                    /*
+                     * Emit an 'UnhandledOptionsError' even if the request was
+                     * successful but no data record was sent as part of the
+                     * response, because in this case the client expected at
+                     * least one data record to acknowledge which options were
+                     * handled.
+                     */
+                    err = createUnhandledOptionsError(unhandledOptions);
+                    res.emit('error', err);
+                } else {
+                    res.emit('end');
+                }
+            }
         }
 
         res.emit('_moray_internal_rpc_done');
     });
 
     req.on('data', function onObject(msg) {
-        log.debug({ object: msg }, 'findObjects: record found');
-        res.emit('record', msg);
+        if (isFirstDataRecord && needMetadataRecord) {
+            if (Object.hasOwnProperty.call(msg, '_handledOptions')) {
+                gotMetadataRecord = true;
+
+                if (msg._handledOptions) {
+                    if (msg._handledOptions.indexOf('requireIndexes') !== -1) {
+                        handledOptions.requireIndexes = true;
+                    }
+                }
+            }
+
+            unhandledOptions = getUnhandledOptions(handledOptions,
+                optionsToHandle);
+            if (unhandledOptions.length > 0) {
+                scheduleEmitUnhandledOptionsError = true;
+                req.abandon();
+                /*
+                 * Make sure we don't emit a 'record' event after emitting an
+                 * "UnhandledOptionsError" error.
+                 */
+                req.removeListener('data', onObject);
+            }
+
+            isFirstDataRecord = false;
+        } else {
+            log.debug({ object: msg }, 'findObjects: record found');
+            res.emit('record', msg);
+        }
     });
 
     return (res);
diff --git a/package.json b/package.json
index 8ad1858..671f2cb 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "3.1.1",
+    "version": "3.2.0",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
