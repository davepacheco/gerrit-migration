commit 607ef8493dec2069254c51e36666f58b06974bda (refs/changes/64/2064/3)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-06-15T00:27:19+00:00 (2 years, 4 months ago)
    
    NAPI-404 napi_nics needs more indexes for searching
    NAPI-304 NAPI happily moves past failed migrations, causing itself much misery
    Reviewed by: Jason King <jason.king@joyent.com>

diff --git a/docs/index.md b/docs/index.md
index 3ce0723..5e58b4f 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -960,34 +960,42 @@ Delete a fabric network.
 
 
 
-# Nics
+# NICs
 
-These endpoints manage nics.
+These endpoints manage NICs.
 
 ## ListNics (GET /nics)
 
-Returns a list of all nics.
+Returns a list of all NICs.
 
 ### Inputs
 
-All parameters are optional filters on the list. A nic is output in the list
+All parameters are optional filters on the list. A NIC is output in the list
 if it matches *all* of the input parameters.
 
-| Field             | Type                   | Description                                                |
-| ----------------- | ---------------------- | ---------------------------------------------------------- |
-| owner_uuid        | UUID                   | Nic Owner                                                  |
-| belongs_to_uuid   | UUID                   | The UUID of what this Nic belongs to                       |
-| belongs_to_type   | String                 | The type that this belongs to (eg: 'zone', 'server')       |
-| network_uuid      | String                 | The UUID of the network the NIC is on                      |
-| nic_tag           | String                 | The nic tag that this nic is on                            |
-| nic_tags_provided | Array of nic tag names | Nic tags provided by the nic                               |
-| offset            | Integer                | Starting offset, see [Pagination](#pagination)             |
-| limit             | Integer                | Maximum number of responses, see [Pagination](#pagination) |
+| Field                    | Type                   | Description                                                                      |
+| ------------------------ | ---------------------- | -------------------------------------------------------------------------------- |
+| owner_uuid               | UUID                   | NIC Owner                                                                        |
+| belongs_to_uuid          | UUID                   | The UUID of what this NIC belongs to                                             |
+| belongs_to_type          | String                 | The type that the NIC belongs to (e.g., 'zone', 'server')                        |
+| allow_dhcp_spoofing      | Boolean                | Whether the NIC is allowed to function as a DHCP server                          |
+| allow_ip_spoofing        | Boolean                | Whether the NIC is allowed to spoof IP addresses                                 |
+| allow_mac_spoofing       | Boolean                | Whether the NIC is allowed to spoof MAC addresses                                |
+| allow_restricted_traffic | Boolean                | Whether the NIC is allowed to send non-IP, non-ICMP, non-ARP traffic             |
+| allow_unfiltered_promisc | Boolean                | Whether the NIC is allowed to listen promiscuously to traffic on different VLANs |
+| cn_uuid                  | String                 | The UUID of the Compute Node that the NIC is on                                  |
+| network_uuid             | String                 | The UUID of the network the NIC is on                                            |
+| nic_tag                  | String                 | The NIC tag that this NIC is on                                                  |
+| nic_tags_provided        | Array of NIC tag names | NIC tags provided by the NIC                                                     |
+| state                    | String                 | What state the NIC is in (e.g., 'running', 'stopped', 'provisioning')            |
+| underlay                 | Boolean                | Whether the NIC is being used to service overlay networks                        |
+| offset                   | Integer                | Starting offset, see [Pagination](#pagination)                                   |
+| limit                    | Integer                | Maximum number of responses, see [Pagination](#pagination)                       |
 
 Note: all filter fields above can have multiple comma-separated values to search
 on (like a logical OR), excepting `offset` and `limit`.
 
-### Example: list all nics
+### Example: list all NICs
 
     GET /nics
 
diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index 50c56d0..1e09c17 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -104,6 +104,12 @@ function ldapFilter(inObj, bucket) {
             }
             arr.push(')');
 
+        } else if (typeof (inObj[i]) === 'boolean') {
+            if (inObj[i]) {
+                arr.push(util.format('(%s=true)', i));
+            } else {
+                arr.push(util.format('(!(%s=true))', i));
+            }
         } else {
             arr.push(util.format('(%s=%s)', i, inObj[i]));
         }
diff --git a/lib/models/network.js b/lib/models/network.js
index a5a7d65..6b3f5e8 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -1195,9 +1195,12 @@ Network.prototype.raw = function networkRaw(opts) {
         vlan_id: this.params.vlan_id
     };
 
-    if (opts && opts.migration) {
-        // We only care about writing this deprecated field when we're
-        // migrating the records - after that, it will be unused
+    /*
+     * We only care about writing this deprecated field when we have
+     * a "global" network. Since "name" is unique, we don't want to
+     * put people's conflicting fabric names here.
+     */
+    if (!this.params.fabric) {
         raw.name = this.params.name;
     }
 
diff --git a/lib/models/nic/bucket.js b/lib/models/nic/bucket.js
index 26200ac..a3ac4a2 100644
--- a/lib/models/nic/bucket.js
+++ b/lib/models/nic/bucket.js
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -18,15 +18,25 @@ var BUCKET = {
     schema: {
         index: {
             admin: { type: 'boolean' },
+            allow_dhcp_spoofing: { type: 'boolean' },
+            allow_ip_spoofing: { type: 'boolean' },
+            allow_mac_spoofing: { type: 'boolean' },
+            allow_restricted_traffic: { type: 'boolean' },
+            allow_unfiltered_promisc: { type: 'boolean' },
             belongs_to_type: { type: 'string' },
             belongs_to_uuid: { type: 'string' },
+            cn_uuid: { type: 'string' },
+            created_timestamp: { type: 'number' },
             ipaddr: { type: 'ip' },
             mac: { type: 'number', unique: true },
+            modified_timestamp: { type: 'number' },
             network_uuid: { type: 'string' },
             nic_tag: { type: 'string' },
             nic_tags_provided_arr: { type: '[string]' },
             owner_uuid: { type: 'string' },
             primary_flag: { type: 'boolean' },
+            state: { type: 'string' },
+            underlay: { type: 'boolean' },
             v: { type: 'number' },
 
             // Deprecated indexes, left here in case we need to rollback:
@@ -35,7 +45,7 @@ var BUCKET = {
         }
     },
     morayVersion: 2,        // moray version must be > than this
-    version: 2
+    version: 3
 };
 
 module.exports = {
diff --git a/lib/models/nic/list.js b/lib/models/nic/list.js
index 8410186..5bafb0b 100644
--- a/lib/models/nic/list.js
+++ b/lib/models/nic/list.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -30,14 +30,22 @@ var vasync = require('vasync');
 var LIST_SCHEMA = {
     strict: true,
     optional: {
+        allow_dhcp_spoofing: validate.bool,
+        allow_ip_spoofing: validate.bool,
+        allow_mac_spoofing: validate.bool,
+        allow_restricted_traffic: validate.bool,
+        allow_unfiltered_promisc: validate.bool,
         limit: validate.limit,
         offset: validate.offset,
         owner_uuid: validate.UUIDarray,
+        cn_uuid: validate.UUIDarray,
         belongs_to_uuid: validate.UUIDarray,
         belongs_to_type: validate.stringOrArray,
         nic_tag: validate.stringOrArray,
         nic_tags_provided: validate.stringOrArray,
-        network_uuid: validate.UUIDarray
+        network_uuid: validate.UUIDarray,
+        state: validate.string,
+        underlay: validate.bool
     }
 };
 
diff --git a/lib/models/nic/obj.js b/lib/models/nic/obj.js
index 7ae0036..fc9a44d 100644
--- a/lib/models/nic/obj.js
+++ b/lib/models/nic/obj.js
@@ -516,7 +516,7 @@ Nic.prototype.raw = function nicRaw() {
         raw.network_uuid = this.network.uuid;
 
         if (this.ip.type === 'ipv4') {
-            raw.ip = util_ip.aton(raw.ipaddr);
+            raw.ip = this.ip.address.toLong();
         }
     } else {
         // Try to add what information we do have - for example, when doing
@@ -526,8 +526,9 @@ Nic.prototype.raw = function nicRaw() {
         }
 
         if (this.params.ipaddr) {
-            raw.ip = this.params.ipaddr.toLong();
-            raw.ipaddr = this.params.ipaddr.toString();
+            var ip = util_ip.toIPAddr(this.params.ipaddr);
+            raw.ip = ip.toLong();
+            raw.ipaddr = ip.toString();
         } else if (this.params.ip) {
             raw.ip = this.params.ip;
             raw.ipaddr = util_ip.ntoa(raw.ip);
diff --git a/server.js b/server.js
index dd7f9c9..8ff2e6b 100644
--- a/server.js
+++ b/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -57,10 +57,11 @@ server.on('initialized', function _afterReady() {
     server.doMigrations(function (err) {
         if (err) {
             log.error(err, 'Error migrating data');
-        } else {
-            log.info('Migrations complete');
+            return;
         }
 
+        log.info('Migrations complete');
+
         server.loadInitialData(function () {
             log.info('Initial data loaded');
         });
diff --git a/test/unit/nics-list.test.js b/test/unit/nics-list.test.js
new file mode 100644
index 0000000..cf0ef98
--- /dev/null
+++ b/test/unit/nics-list.test.js
@@ -0,0 +1,571 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for searching for NICs
+ */
+
+'use strict';
+
+var h = require('./helpers');
+var mod_net = require('../lib/net');
+var mod_nic = require('../lib/nic');
+var mod_nicTag = require('../lib/nic-tag');
+var mod_server = require('../lib/server');
+var mod_uuid = require('node-uuid');
+var test = require('tape');
+
+
+// --- Globals
+
+var NIC_TAG1 = 'nic_tag1';
+var NIC_TAG2 = 'nic_tag2';
+
+var OWNERS = [
+    mod_uuid.v4(),
+    mod_uuid.v4()
+];
+
+var SERVERS = [
+    mod_uuid.v4(),
+    mod_uuid.v4()
+];
+
+var ZONES = [
+    mod_uuid.v4(),
+    mod_uuid.v4(),
+    mod_uuid.v4(),
+    mod_uuid.v4(),
+    mod_uuid.v4()
+];
+
+var NETS = [
+    {
+        name: 'nic-list-net0',
+        vlan_id: 3,
+        subnet: '10.2.1.0/24',
+        gateway: '10.2.1.5',
+        provision_start_ip: '10.2.1.6',
+        provision_end_ip: '10.2.1.250',
+        nic_tag: NIC_TAG1,
+        resolvers: [ '8.8.8.8' ]
+    },
+    {
+        name: 'nic-list-net1',
+        vlan_id: 20,
+        subnet: '10.50.0.0/16',
+        gateway: '10.50.0.1',
+        provision_start_ip: '10.50.0.50',
+        provision_end_ip: '10.50.255.250',
+        nic_tag: NIC_TAG2,
+        resolvers: [ '8.8.4.4' ]
+    }
+];
+
+var NICS = [ ];
+
+var state = {
+    nics: NICS
+};
+
+
+// -- Internal helpers
+
+function splice(arr, idx, count) {
+    var copy = arr.slice();
+    copy.splice(idx, count);
+    return copy;
+}
+
+
+// --- Setup
+
+test('Initial setup', function (t) {
+    h.reset();
+
+    t.test('create client and server', function (t2) {
+        h.createClientAndServer(function (err, res, moray) {
+            t2.ifError(err, 'server creation');
+            t2.ok(res, 'client');
+            t2.ok(moray, 'moray');
+            t2.end();
+        });
+    });
+
+    t.test('create nic tag', function (t2) {
+        mod_nicTag.create(t2, {
+            name: NIC_TAG1
+        });
+    });
+
+    t.test('create nic_tag2', function (t2) {
+        mod_nicTag.create(t2, {
+            name: NIC_TAG2
+        });
+    });
+
+    t.test('create NETS[0]', function (t2) {
+        mod_net.create(t2, {
+            params: NETS[0],
+            partialExp: NETS[0]
+        }, function (_, res) {
+            NETS[0] = res;
+            t2.end();
+        });
+    });
+
+    t.test('create NETS[1]', function (t2) {
+        mod_net.create(t2, {
+            params: NETS[1],
+            partialExp: NETS[1]
+        }, function (_, res) {
+            NETS[1] = res;
+            t2.end();
+        });
+    });
+
+    t.test('create NICS[0]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[0].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONES[0],
+                allow_dhcp_spoofing: true,
+                owner_uuid: OWNERS[0],
+                cn_uuid: SERVERS[0],
+                state: 'running'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[1]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[0].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONES[1],
+                allow_ip_spoofing: true,
+                owner_uuid: OWNERS[0],
+                cn_uuid: SERVERS[0],
+                state: 'stopped'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[2]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONES[2],
+                allow_mac_spoofing: true,
+                owner_uuid: OWNERS[1],
+                cn_uuid: SERVERS[1],
+                state: 'provisioning'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[3]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONES[3],
+                allow_restricted_traffic: true,
+                owner_uuid: OWNERS[1],
+                cn_uuid: SERVERS[1],
+                state: 'provisioning'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[4]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONES[3],
+                allow_unfiltered_promisc: true,
+                owner_uuid: OWNERS[1],
+                cn_uuid: SERVERS[1],
+                state: 'stopped'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[5]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[0].uuid,
+            params: {
+                belongs_to_type: 'server',
+                belongs_to_uuid: SERVERS[0],
+                owner_uuid: OWNERS[1],
+                underlay: true,
+                state: 'provisioning'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[6]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'server',
+                belongs_to_uuid: SERVERS[0],
+                owner_uuid: OWNERS[1],
+                state: 'running'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[7]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'server',
+                belongs_to_uuid: SERVERS[1],
+                owner_uuid: OWNERS[1],
+                state: 'provisioning'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+
+    t.test('create NICS[8]', function (t2) {
+        mod_nic.provision(t2, {
+            net: NETS[0].uuid,
+            params: {
+                belongs_to_type: 'other',
+                belongs_to_uuid: mod_uuid.v4(),
+                owner_uuid: OWNERS[0],
+                state: 'running'
+            },
+            state: state,
+            partialExp: {}
+        });
+    });
+});
+
+
+// --- Tests
+
+test('Filter on "cn_uuid"', function (t) {
+    var s1nics = [
+        NICS[0],
+        NICS[1]
+    ];
+
+    var s2nics = [
+        NICS[2],
+        NICS[3],
+        NICS[4]
+    ];
+
+    t.test('List NICs on SERVERS[0]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                cn_uuid: SERVERS[0]
+            },
+            deepEqual: true,
+            present: s1nics
+        });
+    });
+
+    t.test('List NICs on SERVERS[1]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                cn_uuid: SERVERS[1]
+            },
+            deepEqual: true,
+            present: s2nics
+        });
+    });
+
+    t.test('List NICs on all SERVERS', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                cn_uuid: SERVERS
+            },
+            deepEqual: true,
+            present: s1nics.concat(s2nics)
+        });
+    });
+});
+
+test('Filter on "network_uuid"', function (t) {
+    t.test('Listing NICs on NETS[0]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                network_uuid: NETS[0].uuid
+            },
+            deepEqual: true,
+            present: [
+                NICS[0],
+                NICS[1],
+                NICS[5],
+                NICS[8]
+            ]
+        });
+    });
+
+    t.test('Listing NICs on NETS[1]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                network_uuid: NETS[1].uuid
+            },
+            deepEqual: true,
+            present: [
+                NICS[2],
+                NICS[3],
+                NICS[4],
+                NICS[6],
+                NICS[7]
+            ]
+        });
+    });
+});
+
+test('Filter on "underlay"', function (t) {
+    t.test('underlay=true', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                underlay: true
+            },
+            deepEqual: true,
+            present: [ NICS[5] ]
+        });
+    });
+
+    t.test('underlay=false', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                underlay: 'false'
+            },
+            deepEqual: true,
+            present: splice(NICS, 5, 1)
+        });
+    });
+});
+
+test('Filter on NIC spoofing properties', function (t) {
+    function testSpoofFilter(prop, index) {
+        var filter1 = {};
+        var filter2 = {};
+
+        filter1[prop] = true;
+        filter2[prop] = false;
+
+        var filter1res = [ NICS[index] ];
+        var filter2res = splice(NICS, index, 1);
+
+        t.test(prop + '=true', function (t2) {
+            mod_nic.list(t2, {
+                params: filter1,
+                deepEqual: true,
+                present: filter1res
+            });
+        });
+
+        t.test(prop + '=false', function (t2) {
+            mod_nic.list(t2, {
+                params: filter2,
+                deepEqual: true,
+                present: filter2res
+            });
+        });
+    }
+
+    testSpoofFilter('allow_dhcp_spoofing', 0);
+    testSpoofFilter('allow_ip_spoofing', 1);
+    testSpoofFilter('allow_mac_spoofing', 2);
+    testSpoofFilter('allow_restricted_traffic', 3);
+    testSpoofFilter('allow_unfiltered_promisc', 4);
+});
+
+
+test('Filter on "owner_uuid"', function (t) {
+    t.test('NICs that belong to OWNERS[0]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                owner_uuid: OWNERS[0]
+            },
+            deepEqual: true,
+            present: [
+                NICS[0],
+                NICS[1],
+                NICS[8]
+            ]
+        });
+    });
+
+    t.test('NICs that belong to OWNERS[1]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                owner_uuid: OWNERS[1]
+            },
+            deepEqual: true,
+            present: [
+                NICS[2],
+                NICS[3],
+                NICS[4],
+                NICS[5],
+                NICS[6],
+                NICS[7]
+            ]
+        });
+    });
+});
+
+
+test('Filter on "belongs_to_type"', function (t) {
+    t.test('NICs that belong to "zone"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_type: 'zone'
+            },
+            deepEqual: true,
+            present: [
+                NICS[0],
+                NICS[1],
+                NICS[2],
+                NICS[3],
+                NICS[4]
+            ]
+        });
+    });
+
+    t.test('NICs that belong to "server"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_type: 'server'
+            },
+            deepEqual: true,
+            present: [
+                NICS[5],
+                NICS[6],
+                NICS[7]
+            ]
+        });
+    });
+
+    t.test('NICs that belong to "other"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_type: 'other'
+            },
+            deepEqual: true,
+            present: [ NICS[8] ]
+        });
+    });
+});
+
+
+test('Filter on "state"', function (t) {
+    t.test('NICs that are "running"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                state: 'running'
+            },
+            deepEqual: true,
+            present: [
+                NICS[0],
+                NICS[6],
+                NICS[8]
+            ]
+        });
+    });
+
+    t.test('NICs that are "provisioning"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                state: 'provisioning'
+            },
+            deepEqual: true,
+            present: [
+                NICS[2],
+                NICS[3],
+                NICS[5],
+                NICS[7]
+            ]
+        });
+    });
+
+    t.test('NICs that are "stopped"', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                state: 'stopped'
+            },
+            deepEqual: true,
+            present: [ NICS[1], NICS[4] ]
+        });
+    });
+});
+
+
+test('Filter on "belongs_to_uuid"', function (t) {
+    t.test('NICs belonging to SERVERS[0]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_uuid: SERVERS[0]
+            },
+            deepEqual: true,
+            present: [ NICS[5], NICS[6] ]
+        });
+    });
+
+    t.test('NICS on ZONES[0] and ZONES[1]', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_uuid: [ ZONES[0], ZONES[1] ]
+            },
+            deepEqual: true,
+            present: [ NICS[0], NICS[1] ]
+        });
+    });
+});
+
+
+test('Filter on NIC_TAG1', function (t) {
+    mod_nic.list(t, {
+        params: {
+            nic_tag: NIC_TAG1
+        },
+        deepEqual: true,
+        exp: [
+            NICS[0],
+            NICS[1],
+            NICS[5],
+            NICS[8]
+        ]
+    });
+});
+
+
+// --- Shutdown
+
+test('delete nics', mod_nic.delAllCreated);
+
+test('Stop server', mod_server.close);
