From cff9ef095a9a489020c41e49c88ebe90dce30922 Mon Sep 17 00:00:00 2001
From: Isaac Davis <isaac.davis@joyent.com>
Date: Wed, 8 May 2019 00:18:01 +0000
Subject: [PATCH] TRITON-1694 create Triton Grafana image TRITON-1656 Want new
 EnsureNicOnServiceInstances procedure in sdcadm

---
 CHANGES.md                                |   5 +
 etc/defaults.json                         |   3 +-
 lib/cli/do_update_other.js                |  34 +-
 lib/common.js                             |  42 ++-
 lib/post-setup/common-external-nics.js    |  73 ++--
 lib/post-setup/grafana.js                 | 155 ++++++++
 lib/post-setup/index.js                   |   1 +
 lib/procedures/download-images.js         |  11 +-
 lib/procedures/ensure-nic-on-instances.js | 406 ++++++++++++++++++++
 lib/procedures/index.js                   |   6 +-
 lib/sdcadm.js                             | 439 +++++++++++++---------
 package.json                              |   4 +-
 12 files changed, 931 insertions(+), 248 deletions(-)
 create mode 100644 lib/post-setup/grafana.js
 create mode 100644 lib/procedures/ensure-nic-on-instances.js

diff --git a/CHANGES.md b/CHANGES.md
index 49d1f8e..b7902ce 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -10,6 +10,11 @@
 
 # sdcadm Changelog
 
+## 1.29.0
+
+- MANTA-3992 Add `sdcadm post-setup grafana` to setup a core Triton
+  Grafana service.
+- TRITON-1656 Want new EnsureNicOnServiceInstances procedure in sdcadm
 
 ## 1.28.0
 
diff --git a/etc/defaults.json b/etc/defaults.json
index 283bf92..d3e90bf 100644
--- a/etc/defaults.json
+++ b/etc/defaults.json
@@ -47,7 +47,8 @@
         "volapi": "volapi",
         "logarchiver": "logarchiver",
         "kbmapi": "kbmapi",
-        "prometheus": "manta-prometheus"
+        "prometheus": "manta-prometheus",
+        "grafana": "grafana"
     },
     "svcMinImages": {
         "binder": "20140731T211135Z",
diff --git a/lib/cli/do_update_other.js b/lib/cli/do_update_other.js
index 479463b..f4a47ff 100644
--- a/lib/cli/do_update_other.js
+++ b/lib/cli/do_update_other.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var util = require('util');
@@ -785,26 +785,40 @@ function do_update_other(subcmd, opts, args, cb) {
             ];
             var toUpdateItems = [];
 
+            var svcNames = ['adminui', 'imgapi'];
+
             var svcs = ctx.svcs.filter(function (svc) {
-                return (svc.name === 'adminui' || svc.name === 'imgapi');
+                return (svcNames.indexOf(svc.name) !== -1);
             });
 
-            self.sdcadm.checkMissingExternalNics({
-                progress: progress
-            }, function (sdcadmErr, vmsNics) {
+            self.sdcadm.checkMissingNics({
+                svcNames: svcNames,
+                nicTag: 'external'
+            }, function (sdcadmErr, nicLists) {
                 if (sdcadmErr) {
                     next(sdcadmErr);
                     return;
                 }
 
                 /*
-                 * vmsNics has two members: doimgapi and doadminui which
-                 * will be true if adding the nics to imgapi0 or adminui0 is
-                 * still pending and, on that case, we can safely skip the
-                 * service here, otherwise, we need to update params.
+                 * We get the set of uuids of services that have instances that
+                 * lack an external nic.
+                 */
+                var svcsWithoutNic = new Set();
+                nicLists.instsWithoutNic.forEach(function addToSet(inst) {
+                    svcsWithoutNic.add(inst.service_uuid);
+                });
+
+                /*
+                 * If the service is in the set of services that have instances
+                 * that lack an external nic, then the action of adding the nics
+                 * to imgapi0 or adminui0 is still pending, and, on that case,
+                 * we can safely skip the service here. Otherwise, we need to
+                 * check if params match the old/initial networks and update
+                 * params if so.
                  */
                 svcs.forEach(function (svc) {
-                    if (!vmsNics['do' + svc.name] &&
+                    if (!svcsWithoutNic.has(svc.uuid) &&
                         svc.params &&
                         (jsprim.deepEqual(svc.params.networks, oldNetworks) ||
                         jsprim.deepEqual(svc.params.networks, initialNetworks))
diff --git a/lib/common.js b/lib/common.js
index 0de8d5b..7dfe176 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -30,7 +30,6 @@ var VError = require('verror');
 var errors = require('./errors');
 var InternalError = errors.InternalError;
 
-
 // --- globals
 
 var DEFAULTS_PATH = path.resolve(__dirname, '..', 'etc', 'defaults.json');
@@ -40,6 +39,30 @@ var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
 
 var SECONDS = 1000;
 
+/*
+ * A map of abstract network types to functions that can be used to identify
+ * those types. Used below in validateNetType, netTypeToNetFunc, and
+ * netTypeToNicFunc.
+ *
+ * Note that the functions from the netconfig library use the network's nic tag
+ * to identify the network as admin, external, or manta, so the abstract network
+ * types in the map correspond to nic tags, not network names.
+ */
+var NETWORK_FUNC_MAP = {
+    'admin': {
+        netFunc: netconfig.isNetAdmin,
+        nicFunc: netconfig.isNicAdmin
+    },
+    'external': {
+        netFunc: netconfig.isNetExternal,
+        nicFunc: netconfig.isNicExternal
+    },
+    'manta': {
+        netFunc: netconfig.isNetManta,
+        nicFunc: netconfig.isNicManta
+    }
+};
+
 // --- exports
 
 /*
@@ -1815,6 +1838,18 @@ function flattenMultiError(err) {
     return VError.errorFromList(flattenedErrs);
 }
 
+function validateNetType(s) {
+    return NETWORK_FUNC_MAP.hasOwnProperty(s);
+}
+
+function netTypeToNetFunc(s) {
+    return NETWORK_FUNC_MAP[s].netFunc;
+}
+
+function netTypeToNicFunc(s) {
+    return NETWORK_FUNC_MAP[s].nicFunc;
+}
+
 // --- exports
 
 module.exports = {
@@ -1853,6 +1888,9 @@ module.exports = {
     copyFile: copyFile,
     safeCycles: safeCycles,
     utcTimestamp: utcTimestamp,
-    flattenMultiError: flattenMultiError
+    flattenMultiError: flattenMultiError,
+    validateNetType: validateNetType,
+    netTypeToNetFunc: netTypeToNetFunc,
+    netTypeToNicFunc: netTypeToNicFunc
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/post-setup/common-external-nics.js b/lib/post-setup/common-external-nics.js
index 263a5d1..c9cad3b 100644
--- a/lib/post-setup/common-external-nics.js
+++ b/lib/post-setup/common-external-nics.js
@@ -5,22 +5,45 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
  * 'sdcadm post-setup common-external-nics'
  */
 
-var assert = require('assert-plus');
-
+var errors = require('../errors');
+var EnsureNicProc = require('../procedures/ensure-nic-on-instances')
+    .EnsureNicOnInstancesProcedure;
+var runProcs = require('../procedures').runProcs;
 
+function do_common_external_nics(subcmd, opts, args, cb) {
+    var self = this;
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    } else if (args.length > 0) {
+        cb(new errors.UsageError('too many args: ' + args));
+        return;
+    }
 
-// --- internal support stuff
+    const ensureNicProc = new EnsureNicProc({
+        svcNames: ['imgapi', 'adminui'],
+        nicTag: 'external',
+        primary: true,
+        hardFail: true,
+        volatile: false
+    });
+
+    runProcs({
+        log: self.log,
+        procs: [ensureNicProc],
+        sdcadm: self.sdcadm,
+        ui: self.ui
+    }, cb);
+}
 
-function CommonExternalNics() {}
-CommonExternalNics.prototype.name = 'common-external-nics';
-CommonExternalNics.prototype.help = (
+do_common_external_nics.help = (
     'Add external NICs to the adminui and imgapi zones.\n' +
     '\n' +
     'By default no SDC core zones are given external nics in initial\n' +
@@ -29,41 +52,7 @@ CommonExternalNics.prototype.help = (
     'and for the imgapi instance (to enable it to reach out to \n' +
     'updates.joyent.com and images.joyent.com for images). IMGAPI\n' +
     'instances are always firewalled such that only outbound connections\n' +
-    'are allowed.\n'
-);
-CommonExternalNics.prototype.execute = function (options, cb) {
-    assert.object(options.sdcadm, 'options.sdcadm');
-    assert.object(options.log, 'options.log');
-    assert.func(options.progress, 'options.progress');
-    assert.func(cb, 'cb');
-
-    var sdcadm = options.sdcadm;
-
-    sdcadm.setupCommonExternalNics({
-        progress: options.progress
-    }, cb);
-};
-
-
-
-// --- CLI
-
-function do_common_external_nics(subcmd, opts, _args, cb) {
-    if (opts.help) {
-        this.do_help('help', {}, [subcmd], cb);
-        return;
-    }
-
-    var proc = new CommonExternalNics();
-    proc.execute({
-        sdcadm: this.sdcadm,
-        log: this.log.child({postSetup: 'common-external-nics'}, true),
-        progress: this.progress
-    }, cb);
-}
-
-do_common_external_nics.help = (
-    CommonExternalNics.prototype.help +
+    'are allowed.\n' +
     '\n' +
     'Usage:\n' +
     '     {{name}} common-external-nics\n'
diff --git a/lib/post-setup/grafana.js b/lib/post-setup/grafana.js
new file mode 100644
index 0000000..d30f9a5
--- /dev/null
+++ b/lib/post-setup/grafana.js
@@ -0,0 +1,155 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * The 'sdcadm post-setup grafana' CLI subcommand.
+ */
+
+var errors = require('../errors');
+var AddServiceProc = require('../procedures/add-service').AddServiceProcedure;
+var EnsureNicProc = require('../procedures/ensure-nic-on-instances')
+    .EnsureNicOnInstancesProcedure;
+var runProcs = require('../procedures').runProcs;
+
+function do_grafana(subcmd, opts, args, cb) {
+    var self = this;
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    } else if (args.length > 0) {
+        cb(new errors.UsageError('too many args: ' + args));
+        return;
+    }
+
+    const svcName = 'grafana';
+    const addServiceOpts = {
+        svcName: svcName,
+        packageName: 'sdc_1024',
+        delegatedDataset: true,
+        networks: [
+            {name: 'admin'},
+            /*
+             * Grafana is on the external network to allow login access from
+             * the public internet.
+             */
+            {name: 'external', primary: true}
+        ]
+    };
+
+    if (opts.image) {
+        addServiceOpts.image = opts.image;
+    }
+
+    if (opts.channel) {
+        addServiceOpts.channel = opts.channel;
+    }
+
+    if (opts.server) {
+        addServiceOpts.server = opts.server;
+    }
+
+    /*
+     * We add the manta nic here, rather than in the hard-coded service json
+     * above, because the EnsureNicOnInstancesProcedure will gracefully
+     * handle the case where the manta network does not exist.
+     *
+     * If the manta network doesn't exist, the procedure will do nothing. If
+     * `sdcadm post-setup grafana` is run later and the manta network now
+     * exists, the procedure will add a manta nic to the existing grafana
+     * instance.
+     *
+     * We set 'volatile' to true here because we're also (possibly) creating the
+     * grafana service and instance in the same runProcs sequence, and thus
+     * must defer lookup of the service and instance to the execute() phase.
+     */
+    const ensureNicOpts = {
+        svcNames: [ svcName ],
+        nicTag: 'manta',
+        primary: false,
+        hardFail: false,
+        volatile: true
+    };
+
+    const addServiceProc = new AddServiceProc(addServiceOpts);
+    const ensureNicProc = new EnsureNicProc(ensureNicOpts);
+    runProcs({
+        log: self.log,
+        procs: [addServiceProc, ensureNicProc],
+        sdcadm: self.sdcadm,
+        ui: self.ui,
+        dryRun: opts.dry_run,
+        skipConfirm: opts.yes
+    }, cb);
+}
+
+do_grafana.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['yes', 'y'],
+        type: 'bool',
+        help: 'Answer yes to all confirmations.'
+    },
+    {
+        names: ['dry-run', 'n'],
+        type: 'bool',
+        help: 'Do a dry-run.'
+    },
+    {
+        names: ['server', 's'],
+        type: 'string',
+        help: 'Either hostname or uuid of the server on which to create' +
+            ' the instance. (By default the headnode will be used.)',
+        helpArg: 'SERVER'
+    },
+    {
+        group: 'Image selection (by default latest image on default ' +
+            'channel)'
+    },
+    {
+        names: ['image', 'i'],
+        type: 'string',
+        help: 'Specifies which image to use for the first instance. ' +
+            'Use "latest" (the default) for the latest available on ' +
+            'updates.joyent.com, "current" for the latest image already ' +
+            'in the datacenter (if any), or an image UUID or version.'
+    },
+    {
+        names: ['channel', 'C'],
+        type: 'string',
+        help: 'The updates.joyent.com channel from which to fetch the ' +
+            'image. See `sdcadm channel get` for the default channel.'
+    }
+
+];
+
+do_grafana.help = [
+    'Create the "grafana" service and a first instance.',
+    '',
+    'Usage:',
+    '     {{name}} grafana',
+    '',
+    '{{options}}',
+    'The "grafana" service provides a graphical front-end to the Prometheus ' +
+    'time-series database.'
+].join('\n');
+
+do_grafana.logToFile = true;
+
+// --- exports
+
+module.exports = {
+    do_grafana: do_grafana
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/post-setup/index.js b/lib/post-setup/index.js
index 14c468c..4cc429a 100644
--- a/lib/post-setup/index.js
+++ b/lib/post-setup/index.js
@@ -79,6 +79,7 @@ PostSetupCLI.prototype.do_volapi = require('./volapi').do_volapi;
 PostSetupCLI.prototype.do_logarchiver = require('./logarchiver').do_logarchiver;
 PostSetupCLI.prototype.do_kbmapi = require('./kbmapi').do_kbmapi;
 PostSetupCLI.prototype.do_prometheus = require('./prometheus').do_prometheus;
+PostSetupCLI.prototype.do_grafana = require('./grafana').do_grafana;
 
 // --- exports
 
diff --git a/lib/procedures/download-images.js b/lib/procedures/download-images.js
index 8ea658c..7233928 100644
--- a/lib/procedures/download-images.js
+++ b/lib/procedures/download-images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -186,15 +186,16 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
                  * case.
                  */
                 if (VError.findCauseByName(genErr, 'RemoteSourceError')) {
-                    sdcadm.checkMissingExternalNics({
-                        progress: progress
-                    }, function (checkErr, checkRes) {
+                    sdcadm.checkMissingNics({
+                        svcNames: ['imgapi'],
+                        nicTag: 'external'
+                    }, function (checkErr, nicLists) {
                         if (checkErr) {
                             cb(VError.errorFromList([genErr, checkErr]));
                             return;
                         }
 
-                        if (checkRes.doimgapi) {
+                        if (nicLists.instsWithNic.length === 0) {
                             progress(
                                 '* * *\n' +
                                 'There was an error trying to download ' +
diff --git a/lib/procedures/ensure-nic-on-instances.js b/lib/procedures/ensure-nic-on-instances.js
new file mode 100644
index 0000000..cf8f58f
--- /dev/null
+++ b/lib/procedures/ensure-nic-on-instances.js
@@ -0,0 +1,406 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Procedure to add an external, admin, or manta nic to every instance of a
+ * given service. If some service instances already have the nic but some do
+ * not, the nic will be added to the applicable instances.
+ *
+ * This procedure is currently used in multiple places: for example, to add
+ * external nics to adminui and imgapi in
+ * `sdcadm post-setup common-external-nics`, and to add a manta nic to grafana
+ * in `sdcadm post-setup grafana`.
+ */
+
+var assert = require('assert-plus');
+var sprintf = require('extsprintf').sprintf;
+var util = require('util');
+var vasync = require('vasync');
+
+var common = require('../common');
+var errors = require('../errors');
+var Procedure = require('./procedure').Procedure;
+
+/*
+ * Constructor options:
+ * - svcNames (Array of String): List of services whose instances the procedure
+ *   will add nics to.
+ * - nicTag (String): One of 'external', 'admin', or 'manta'. Specifies the
+ *   type of nic to add.
+ * - primary (Boolean): Optional; false by default. Specifies whether the new
+ *   nic will be set as the primary nic. Note that, if an instance already has
+ *   the nic specified by nicTag but the nic has the wrong 'primary' status,
+ *   this procedure WILL NOT update that nic's 'primary' status -- that nic will
+ *   be left alone.
+ * - hardFail (Boolean): Optional; true by default. Controls the procedure's
+ *   behavior when the specified network doesn't exist. If hardFail is true, the
+ *   procedure will return an error. If hardFail is false, the procedure will do
+ *   nothing and report success.
+ * - volatile (Boolean): Optional; false by default. Caller should set this to
+ *   true if we're running other procedures in `runProcs` that might create,
+ *   delete, or modify services in 'svcNames' or instances of these services, or
+ *   modify networks, in their execute() functions. Setting 'volatile' to true
+ *   will defer the work of determining determining which nics to add from the
+ *   prepare() function to the execute() function. Assuming the caller places
+ *   the other relevant procedures before this procedure in the procedure list,
+ *   this will ensure that all changes to instances have been made before this
+ *   procedure's execute() function runs, allowing an accurate lookup of
+ *   services, instances, and networks.
+ */
+function EnsureNicOnInstancesProcedure(opts) {
+    assert.object(opts, 'opts');
+    assert.arrayOfString(opts.svcNames, 'opts.svcNames');
+    assert.string(opts.nicTag, 'opts.nicTag');
+    assert.ok(common.validateNetType(opts.nicTag),
+        'nicTag is invalid');
+    assert.optionalBool(opts.primary, 'opts.primary');
+    assert.optionalBool(opts.hardFail, 'opts.hardFail');
+    assert.optionalBool(opts.volatile, 'opts.volatile');
+
+    this.svcNames = opts.svcNames;
+    this.nicTag = opts.nicTag;
+    this.primary = opts.primary === undefined ? false : opts.primary;
+    this.hardFail = opts.hardFail === undefined ? true : opts.hardFail;
+    this.volatile = opts.volatile === undefined ? false : opts.volatile;
+
+}
+util.inherits(EnsureNicOnInstancesProcedure, Procedure);
+
+/*
+ * Gets all the instances of the specified services, checks the state of their
+ * nics, and sorts the instances into two lists: those that require action and
+ * those that do not. If no instances lack the nic specified by self.nicTag, we
+ * have nothing to do, and indicate this fact to the calling function. If
+ * 'volatile' is true, defers this work to the execute() function.
+ *
+ * Object properties set by this method, if 'volatile' is false, are:
+ * - networkFound (Boolean): Whether or not the network specified by nicTag
+ *   was found
+ * - networkName (String): The name of the network, if the network was found
+ * - instsWithNic (Array of Object): Instances that already have the desired nic
+ * - instsWithoutNic (Array of Object): Instances that lack the desired nic
+ */
+EnsureNicOnInstancesProcedure.prototype.prepare =
+    function prepare(opts, cb) {
+
+    const self = this;
+
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    assert.object(opts.ui, 'opts.ui');
+
+    assert.string(self.nicTag, 'self.nicTag');
+    assert.ok(common.validateNetType(self.nicTag),
+        'nicTag is invalid');
+    assert.bool(self.hardFail, 'self.hardFail');
+    assert.bool(self.volatile, 'self.volatile');
+
+    const ui = opts.ui;
+
+    /*
+     * If the user has specified the 'volatile' flag, return early; defer all
+     * work to the 'execute' function.
+     */
+    if (self.volatile) {
+        cb(null, false);
+        return;
+    }
+
+    self.doVolatileOperations(opts, function didVolatile(err, results) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        let nothingToDo;
+
+        /*
+         * If we found the network, we check to see if any of the instances lack
+         * the relevant nic, and set nothingToDo accordingly.
+         *
+         * If we didn't find the network but we got here, then we know that
+         * hardFail is false, and we indicate that there is nothing to do.
+         */
+        if (self.networkFound) {
+            assert.arrayOfObject(self.instsWithoutNic);
+            self.instsWithNic.forEach(function reportExistingNic(inst) {
+                ui.info(sprintf('Instance %s (%s) already has %s nic',
+                    inst.uuid, inst.params.alias, self.nicTag));
+            });
+            nothingToDo = self.instsWithoutNic.length === 0;
+        } else {
+            assert.equal(self.hardFail, false,
+                'hardFail is true but network does not exist');
+            ui.info('%s network not found; not adding nic', self.nicTag);
+            nothingToDo = true;
+        }
+
+        cb(null, nothingToDo);
+    });
+};
+
+
+EnsureNicOnInstancesProcedure.prototype.summarize =
+    function summarize() {
+
+    const self = this;
+
+    assert.arrayOfString(self.svcNames, 'self.svcNames');
+    assert.string(self.nicTag, 'self.nicTag');
+    assert.ok(common.validateNetType(self.nicTag),
+        'nicTag is invalid');
+
+    let out = [];
+
+    if (self.volatile) {
+        /*
+         * If the user has specified the 'volatile' flag, print a generic update
+         * message -- we don't know what instances require action yet.
+         */
+        out.push(sprintf('Ensure all instances of %s service have %s nic, if ' +
+            '%s network exists', self.svcNames.join(', '), self.nicTag,
+            self.nicTag));
+    } else {
+        /*
+         * Otherwise, verify that prepare has run already and print the specific
+         * instances that require action.
+         */
+        assert.arrayOfObject(self.instsWithoutNic, 'self.instsWithoutNic');
+
+        self.instsWithoutNic.forEach(function reportMissingNic(inst) {
+            out.push(sprintf('add %s nic to instance %s (%s)', self.nicTag,
+                inst.uuid, inst.params.alias));
+        });
+    }
+
+    return out.join('\n');
+};
+
+/*
+ * Adds the nic to the instances that lack it. If 'volatile' is true, this
+ * method also does the work of figuring out which instances require action.
+ *
+ * Object properties set by this method, if 'volatile' is true, are:
+ * - networkFound (Boolean): Whether or not the network specified by nicTag
+ *   was found
+ * - networkName (String): The name of the network, if the network was found
+ * - instsWithNic (Array of Object): Instances that already have the desired nic
+ * - instsWithoutNic (Array of Object): Instances that lack the desired nic
+ *
+ * If 'volatile' is false, these properties will have been set by prepare().
+ */
+EnsureNicOnInstancesProcedure.prototype.execute =
+    function execute(opts, cb) {
+
+    const self = this;
+
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+
+    assert.string(self.nicTag, 'self.nicTag');
+    assert.ok(common.validateNetType(self.nicTag),
+        'nicTag is invalid');
+    assert.bool(self.primary, 'self.primary');
+
+    const sdcadm = opts.sdcadm;
+    const ui = opts.ui;
+
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function doVolatileIfNecessary(_, next) {
+                if (!self.volatile) {
+                    next();
+                    return;
+                }
+                self.doVolatileOperations(opts, next);
+            }, function addNics(_, next) {
+                /*
+                 * However we got here, volatile or not, the fields set by
+                 * doVolatileOperations should exist at this point.
+                 */
+                assert.bool(self.networkFound, 'self.networkFound');
+                if (self.networkFound) {
+                    assert.arrayOfObject(self.instsWithNic,
+                        'self.instsWithNic');
+                    assert.arrayOfObject(self.instsWithoutNic,
+                        'self.instsWithoutNic');
+                    assert.string(self.networkName);
+                    sdcadm.addNics({
+                        ui: ui,
+                        insts: self.instsWithoutNic,
+                        networkName: self.networkName,
+                        primary: self.primary
+                    }, next);
+                } else {
+                    /*
+                     * If we didn't find the network but we got here, we know
+                     * hardFail is false. Otherwise, we would have returned
+                     * early with an error.
+                     */
+                    assert.equal(self.hardFail, false,
+                        'hardFail is true but network does not exist');
+                    /*
+                     * volatile must be true if we're here. If volatile were
+                     * false, we should have discovered that the network didn't
+                     * exist in prepare() -- execute() should never have run.
+                     */
+                    assert.equal(self.volatile, true,
+                        'volatile is false but missing network not detected ' +
+                        'until execute()');
+
+                    ui.info('%s network not found; not adding nic',
+                        self.nicTag);
+                    next();
+                }
+            }
+        ]
+    }, cb);
+
+};
+
+/*
+ * This method groups the set of operations whose place of execution in the
+ * runProcs sequence is determined by the presence of the 'volatile' flag. This
+ * method should be called from prepare() or execute() rather than directly.
+ *
+ * Object properties set by this method are:
+ * - networkFound (Boolean): Whether or not the network specified by nicTag
+ *   was found
+ * - networkName (String): The name of the network, if the network was found
+ * - instsWithNic (Array of Object): Instances that already have the desired nic
+ * - instsWithoutNic (Array of Object): Instances that lack the desired nic
+ */
+EnsureNicOnInstancesProcedure.prototype.doVolatileOperations =
+    function doVolatileOperations(opts, cb) {
+
+    const self = this;
+
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.sdcadm.napi, 'opts.sdcadm.napi');
+
+    assert.arrayOfString(self.svcNames, 'self.svcNames');
+    assert.string(self.nicTag, 'self.nicTag');
+    assert.ok(common.validateNetType(self.nicTag),
+        'nicTag is invalid');
+    assert.bool(self.hardFail, 'self.hardFail');
+
+    const sdcadm = opts.sdcadm;
+    const napi = opts.sdcadm.napi;
+
+    let networkFound = false;
+    let networkName;
+    let instsWithNic;
+    let instsWithoutNic;
+
+    vasync.pipeline({
+        funcs: [
+            /*
+             * We can't look up exact network names -- they could differ between
+             * environments because of RAN.
+             *
+             * Thus, to check if the relevant network exists, we get all of the
+             * networks and iterate through them, looking for a match.
+             */
+            function checkNetworkExists(_, next) {
+                napi.listNetworks({
+                    fabric: false
+                }, function gotNetworks(err, networks) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    let isDesiredNetwork =
+                        common.netTypeToNetFunc(self.nicTag);
+                    networks.forEach(function checkNetwork(network) {
+                        if (isDesiredNetwork(network)) {
+                            /*
+                             * We save the network name so we can use it later
+                             * when adding a nic to each zone. We can't use
+                             * nicTag to specify the network, because vmapi
+                             * looks up networks by name or uuid, not nic tag,
+                             * when adding nics. Network names are unique, so
+                             * the name is sufficient to identify the network
+                             */
+                            networkFound = true;
+                            networkName = network.name;
+                        }
+                    });
+                    /*
+                     * If the network doesn't exist and hardFail is true, fail
+                     * here. Otherwise, continue. At the end of this function,
+                     * we handle the case where hardFail is false and we didn't
+                     * find the network.
+                     */
+                    if (!networkFound && self.hardFail) {
+                        next(new errors.InternalError({
+                            message: sprintf('No network found that matches ' +
+                                'type "%s"', self.nicTag)
+                        }));
+                        return;
+                    }
+                    next();
+                });
+            },
+            function getMissingNics(_, next) {
+                if (networkFound) {
+                    sdcadm.checkMissingNics({
+                        svcNames: self.svcNames,
+                        nicTag: self.nicTag
+                    }, function gotMissingNics(err, nicLists) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        instsWithNic = nicLists.instsWithNic;
+                        instsWithoutNic = nicLists.instsWithoutNic;
+                        next();
+                    });
+                } else {
+                    /*
+                     * If we didn't find the network but we've still made it
+                     * here, we know that hardFail must be false, and continue
+                     * without attempting to look up the nics.
+                     */
+                    assert.equal(self.hardFail, false,
+                        'hardFail is true but network does not exist');
+                    next();
+                }
+            }
+        ]
+    }, function pipelineDone(err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        self.networkFound = networkFound;
+        self.networkName = networkName;
+        self.instsWithNic = instsWithNic;
+        self.instsWithoutNic = instsWithoutNic;
+        cb();
+    });
+};
+
+// --- exports
+
+module.exports = {
+    EnsureNicOnInstancesProcedure: EnsureNicOnInstancesProcedure
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index 397040c..33d09e0 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -203,9 +203,9 @@ function coordinatePlan(opts, cb) {
         function updateSimpleServices(_, next) {
             var simpleServices = [
                 'amon', 'amonredis', 'assets', 'cnapi', 'cns', 'dhcpd',
-                'docker', 'fwapi', 'kbmapi', 'logarchiver', 'manta', 'napi',
-                'prometheus', 'rabbitmq', 'redis', 'sdc', 'ufds', 'vmapi',
-                'volapi'
+                'docker', 'fwapi', 'grafana', 'kbmapi', 'logarchiver', 'manta',
+                'napi', 'prometheus', 'rabbitmq', 'redis', 'sdc', 'ufds',
+                'vmapi', 'volapi'
             ].concat(HA_READY_SIMPLE_SVCS);
             var handle = [];
             var remaining = [];
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index 555eaf3..f5b1798 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -27,6 +27,7 @@ var mkdirp = require('mkdirp');
 var netconfig = require('triton-netconfig');
 var sdcClients = require('sdc-clients');
 var semver = require('semver');
+var sprintf = require('extsprintf').sprintf;
 var UFDS = require('ufds');
 var uuid = require('node-uuid');
 var urclient = require('urclient');
@@ -2745,7 +2746,7 @@ SdcAdm.prototype._selfAvailable = function _selfAvailable(cb) {
  * Update to the latest available sdcadm package.
  *
  * @param options {Object}  Required.
- *      - image {String}. Required. The image we want to udpate to, either
+ *      - image {String}. Required. The image we want to update to, either
  *        'latest' or a valid sdcadm image UUID.
  *      - allowMajorUpdate {Boolean} Optional. Default false. By default
  *        self-update will only consider versions of the same major version.
@@ -3713,14 +3714,15 @@ SdcAdm.prototype.checkHealth = function checkHealth(opts, cb) {
         cloudapi: '/--ping',
         cnapi: '/ping',
         fwapi: '/ping',
+        grafana: '/ping',
         imgapi: '/ping',
         napi: '/ping',
         papi: '/ping',
+        prometheus: '/-/healthy',
         sapi: '/ping',
         vmapi: '/ping',
         volapi: '/ping',
         workflow: '/ping',
-        prometheus: '/-/healthy',
         // agents
         firewaller: '/status'
     };
@@ -3728,6 +3730,7 @@ SdcAdm.prototype.checkHealth = function checkHealth(opts, cb) {
     var pingPorts = {
         cloudapi: 443,
         firewaller: 2021,
+        grafana: 443,
         prometheus: 9090
     };
 
@@ -4180,223 +4183,293 @@ SdcAdm.prototype.checkHealth = function checkHealth(opts, cb) {
     });
 };
 
-
-// Extracted from setupCommonExternalNics b/c it's also used by DownloadImages
-// to check if the reason for an IMGAPI failure could be the lack of external
-// nic into imgapi zone
-SdcAdm.prototype.checkMissingExternalNics =
-function checkMissingExternalNics(opts, cb) {
+/*
+ * Checks the instances of a given set of services for a nic corresponding to
+ * a given network.
+ *
+ * @param opts {Object} Required.
+ *      - svcNames {Array of Object} Required. The list of services whose
+ *        instances the function will check.
+ *      - nicTag {String} Required. One of 'external', 'admin', or 'manta'.
+ *        Specifies the type of nic to check for.
+ *
+ * @return {Object}
+ *      - instsWithNic {Array of Object} The instances that already have the
+ *        specified nic.
+ *      - instsWithoutNic {Array of Object} The instances that lack the
+ *        specified nic.
+ */
+SdcAdm.prototype.checkMissingNics = function checkMissingNics(opts, cb) {
     var self = this;
-    assert.func(opts.progress, 'opts.progress');
+
+    assert.object(opts, 'opts');
     assert.func(cb, 'cb');
 
+    assert.arrayOfString(opts.svcNames, 'opts.svcNames');
+    assert.string(opts.nicTag, 'opts.nicTag');
+    assert.ok(common.validateNetType(opts.nicTag),
+        'nicTag is invalid');
+
     var sapi = self.sapi;
     var napi = self.napi;
 
-    var svcadminui;
-    var svcimgapi;
-    var doadminui = true;
-    var doimgapi = true;
+    var svcNames = opts.svcNames;
+    var nicTag = opts.nicTag;
 
-    function getInstance(svcname, callback) {
-        sapi.listServices({ name: svcname }, onServices);
+    var instsWithoutNic = [];
+    var instsWithNic = [];
 
-        function onServices(err, svcs) {
-            if (err) {
-                cb(new errors.SDCClientError(err, 'sapi'));
-                return;
-            }
-            if (!svcs.length) {
-                cb(new Error('Couldn\'t find imgapi SAPI service'));
-                return;
-            }
-
-            sapi.listInstances({ service_uuid: svcs[0].uuid },
-            function (listerr, inst) {
-                if (listerr) {
-                    cb(new errors.SDCClientError(listerr, 'sapi'));
-                    return;
-                }
-                callback(null, inst[0]);
-            });
-        }
-    }
-
-    vasync.pipeline({ funcs: [
-        // Look up details for the adminui, imgapi instances.
-        function (_, next) {
-            getInstance('adminui', function (err, inst) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
-                svcadminui = inst;
-                next();
-            });
-        },
-        function (_, next) {
-            getInstance('imgapi', function (err, inst) {
-                if (err) {
-                    cb(err);
-                    return;
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function ensureSdcApp(_, next) {
+                self.ensureSdcApp({}, next);
+            },
+            // Collect the uuids of the specified services
+            function getSvcUuids(ctx, next) {
+                function getUuid(name, nextName) {
+                    sapi.listServices({
+                        name: name,
+                        application: self.sdcApp.uuid
+                    }, function gotSvcs(err, svcs) {
+                        if (err) {
+                            nextName(new errors.SDCClientError(err, 'sapi'));
+                            return;
+                        }
+                        if (svcs.length === 0) {
+                            nextName(new errors.InternalError({
+                                message: sprintf('No service found with name ' +
+                                    '%s under sdc application', name)
+                            }));
+                            return;
+                        }
+                        if (svcs.length > 1) {
+                            nextName(new errors.InternalError({
+                                message: sprintf('Multiple services found ' +
+                                    'with name %s under sdc application', name)
+                            }));
+                            return;
+                        }
+                        ctx.svcUuids.push(svcs[0].uuid);
+                        nextName();
+                    });
                 }
-                svcimgapi = inst;
-                next();
-            });
-        },
-        // Check what NICS the imgapi and adminui zones currently have. Only do
-        // work for those which do not yet have an external nic.
-        function (_, next) {
-            var listOpts = {
-                belongs_to_type: 'zone',
-                belongs_to_uuid: [ svcimgapi.uuid, svcadminui.uuid ]
-            };
-            napi.listNics(listOpts, function (err, nics) {
-                if (err) {
-                    cb(new errors.SDCClientError(err, 'napi'));
-                    return;
+                ctx.svcUuids = [];
+                vasync.forEachParallel({
+                    inputs: svcNames,
+                    func: getUuid
+                }, next);
+            },
+            // Collect the instances of the specified services
+            function getSvcInstances(ctx, next) {
+                function getInst(svcUuid, nextUuid) {
+                    sapi.listInstances({
+                        service_uuid: svcUuid
+                    }, function gotInsts(err, insts) {
+                        if (err) {
+                            nextUuid(new errors.SDCClientError(err, 'sapi'));
+                            return;
+                        }
+                        ctx.svcInsts = ctx.svcInsts.concat(insts);
+                        nextUuid();
+                    });
                 }
+                ctx.svcInsts = [];
+                vasync.forEachParallel({
+                    inputs: ctx.svcUuids,
+                    func: getInst
+                }, next);
+            },
+            /*
+             * Check each instance for the specified nic, and sort the instances
+             * into the two result lists accordingly
+             */
+            function checkNics(ctx, next) {
+                function checkNic(inst, nextInst) {
+                    var listOpts = {
+                        belongs_to_type: 'zone',
+                        belongs_to_uuid: [ inst.uuid ]
+                    };
+                    napi.listNics(listOpts, function (err, nics) {
+                        if (err) {
+                            nextInst(new errors.SDCClientError(err, 'napi'));
+                            return;
+                        }
 
-                if (!nics.length) {
-                    cb(new Error(
-                        'Couldn\'t find NICs for imgapi or adminui'));
-                    return;
-                }
+                        if (!nics.length) {
+                            nextInst(new VError(
+                                'Couldn\'t find NICs for zone %s', inst.uuid));
+                            return;
+                        }
 
-                for (var i = 0, nic; i < nics.length; i++) {
-                    nic = nics[i];
-                    if (nic.belongs_to_uuid === svcadminui.uuid &&
-                        netconfig.isNicExternal(nic)) {
-                        doadminui = false;
-                    } else if (nic.belongs_to_uuid === svcimgapi.uuid &&
-                        netconfig.isNicExternal(nic)) {
-                        doimgapi = false;
-                    }
+                        var found = false;
+                        for (var i = 0, nic; i < nics.length; i++) {
+                            nic = nics[i];
+                            var isDesiredNic =
+                                common.netTypeToNicFunc(nicTag);
+                            if (isDesiredNic(nic)) {
+                                found = true;
+                            }
+                        }
+                        var l = found ? instsWithNic : instsWithoutNic;
+                        l.push(inst);
+                        nextInst();
+                    });
                 }
-
-                next();
-            });
-        }
-    ]}, function (err) {
+                vasync.forEachParallel({
+                    inputs: ctx.svcInsts,
+                    func: checkNic
+                }, next);
+            }
+        ]
+    }, function pipelineDone(err) {
         if (err) {
             cb(err);
-        } else {
-            cb(null, {
-                doimgapi: doimgapi,
-                doadminui: doadminui,
-                svcadminui: svcadminui,
-                svcimgapi: svcimgapi
-            });
+            return;
         }
+        cb(null, {
+            instsWithNic: instsWithNic,
+            instsWithoutNic: instsWithoutNic
+        });
     });
 };
 
-SdcAdm.prototype.setupCommonExternalNics = function
-setupCommonExternalNics(opts, cb) {
-    assert.func(opts.progress, 'options.progress');
-
+/*
+ * Adds a nic corresponding to a given network to each instance in the given
+ * list. This function also updates each instance's service to reflect the
+ * updated network state.
+ *
+ * @param opts {Object} Required.
+ *      - ui {Object} Required. A CLI `UI` instance for this sdcadm invocation.
+ *      - insts {Array of Object} Required. The list of instances to add the nic
+ *        to.
+ *      - networkName {String} Required. The name of the network to add.
+ *      - primary {Boolean} Required. Specifies whether the added nic should be
+ *        set as the primary nic.
+ */
+SdcAdm.prototype.addNics = function addNics(opts, cb) {
     var self = this;
-    var doadminui = true;
-    var doimgapi = true;
-    var progress = opts.progress;
-    var svcadminui;
-    var svcimgapi;
 
-    function addExternaNicToZone(svcobj, subcb) {
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    assert.object(opts.ui, 'opts.ui');
+    assert.arrayOfObject(opts.insts, 'opts.insts');
+    assert.string(opts.networkName, 'opts.networkName');
+    assert.bool(opts.primary, 'opts.primary');
+
+    var ui = opts.ui;
+    var insts = opts.insts;
+    var networkName = opts.networkName;
+    var primary = opts.primary;
+
+    var sapi = self.sapi;
+    var vmapi = self.vmapi;
+    var log = self.log;
+
+    function addNicToZone(inst, nextInst) {
         var addparams = {
-            uuid: svcobj.uuid,
+            uuid: inst.uuid,
             networks: [
-                { 'name': 'external', primary: true }
+                { 'name': networkName, primary: primary }
             ]
         };
-        self.vmapi.addNicsAndWait(addparams, function (err, job) {
+        vmapi.addNicsAndWait(addparams, function addedNic(err, res) {
             if (err) {
-                return subcb(new errors.SDCClientError(err, 'vmapi'));
-            }
-            return subcb(null, job);
-        });
-    }
-
-    function updateSvcParamsNetworks(name, subcb) {
-        self.sapi.listServices({name: name}, function (sapiErr, svcArr) {
-            if (sapiErr) {
-                subcb(new errors.SDCClientError(sapiErr, 'sapi'));
-                return;
-            }
-
-            if (!svcArr.length) {
-                subcb(new errors.InternalError(new Error(
-                    'Cannot find service ' + name)));
+                nextInst(new errors.SDCClientError(err, 'vmapi'));
                 return;
             }
-
-            self.sapi.updateService(svcArr[0].uuid, {
-                params: {
-                    networks: [
-                        { name: 'admin' },
-                        { name: 'external', primary: true}
-                    ]
-                }
-            }, function (err) {
-                if (err) {
-                    subcb(new errors.SDCClientError(err, 'sapi'));
-                    return;
-                }
-                subcb();
-            });
+            ui.info('Added %s nic to instance %s (%s)', networkName, inst.uuid,
+                inst.params.alias);
+            log.info({
+                networkName: networkName,
+                inst: inst.uuid,
+                alias: inst.params.alias
+            }, 'Added nic to instance');
+            nextInst();
+            return;
         });
     }
 
-    vasync.pipeline({ funcs: [
-        function (_, next) {
-            self.checkMissingExternalNics(opts, function (err, res) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                doimgapi = res.doimgapi;
-                doadminui = res.doadminui;
-                svcadminui = res.svcadminui;
-                svcimgapi = res.svcimgapi;
-                next();
-            });
-        },
-
-        function (_, next) {
-            if (!doadminui) {
-                progress('AdminUI already has an external nic');
-                next();
-                return;
-            }
-            addExternaNicToZone(svcadminui, function (err) {
-                if (err) {
-                    next(err);
-                    return;
+    function updateSvcParamsNetworks(svcUuid, nextUuid) {
+        vasync.pipeline({
+            arg: {}, // ctx
+            funcs: [
+                /*
+                 * We get the service object so we can retrieve its existing
+                 * network list.
+                 */
+                function getSvc(ctx, next) {
+                    sapi.getService(svcUuid, function gotService(err, svc) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.svc = svc;
+                        next();
+                    });
+                /*
+                 * We merge the updated network into the existing network list,
+                 * and update the service.
+                 */
+                }, function updateSvc(ctx, next) {
+                    var updatedNetwork = { name: networkName };
+                    if (primary) {
+                        updatedNetwork.primary = true;
+                    }
+                    var newNetworks = [updatedNetwork];
+                    ctx.svc.params.networks.forEach(function addNetwork(n) {
+                        if (n.name !== networkName) {
+                            newNetworks.push(n);
+                        }
+                    });
+                    sapi.updateService(svcUuid, {
+                        params: {
+                            networks: newNetworks
+                        }
+                    }, function updatedSvc(err) {
+                        if (err) {
+                            next(new errors.SDCClientError(err, 'sapi'));
+                            return;
+                        }
+                        next();
+                    });
                 }
-                progress('Added external nic to adminui');
-                updateSvcParamsNetworks('adminui', next);
-            });
-        },
+            ]
+        }, nextUuid);
+    }
 
-        function (_, next) {
-            if (!doimgapi) {
-                progress('IMGAPI already has an external nic');
-                next();
-                return;
+    vasync.pipeline({
+        funcs: [
+            function addNicToZones(_, next) {
+                vasync.forEachParallel({
+                    inputs: insts,
+                    func: addNicToZone
+                }, next);
+            },
+            function getServicesToUpdate(_, next) {
+                /*
+                 * We will call updateSvcParamsNetworks for every service with
+                 * an instance in instsWithoutNic, but there's no need to call
+                 * the function more than once per service, even if multiple
+                 * instances of the service exist. Thus, we add each instance's
+                 * service_uuid to a Set as we iterate through the instances,
+                 * which gives us a duplicate-free collection of service uuids
+                 * to update.
+                 */
+                var svcUuidSet = new Set();
+                insts.forEach(function addToSet(inst) {
+                    svcUuidSet.add(inst.service_uuid);
+                });
+                vasync.forEachParallel({
+                    inputs: Array.from(svcUuidSet),
+                    func: updateSvcParamsNetworks
+                }, next);
             }
-            addExternaNicToZone(svcimgapi, function (err) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                progress('Added external nic to imgapi');
-                updateSvcParamsNetworks('imgapi', next);
-            });
-        }
-    ]}, cb);
+        ]
+    }, cb);
 };
 
-
 /*
  * Generate a rollback plan from the contents of the given update plan.
  *
diff --git a/package.json b/package.json
index f3f9e1b..e368f2f 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "sdcadm",
   "description": "Administer a Triton Data Center",
-  "version": "1.28.0",
+  "version": "1.29.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -27,7 +27,7 @@
     "strsplit": "1.0.0",
     "tabula": "1.9.0",
     "tape": "4.10.1",
-    "triton-netconfig": "1.0.0",
+    "triton-netconfig": "1.4.0",
     "ufds": "1.3.0",
     "urclient": "1.2.0",
     "vasync": "2.2.0",
-- 
2.21.0

