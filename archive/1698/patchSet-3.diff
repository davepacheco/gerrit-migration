From 75419dfcb28985db63a7bd5689181322c5098538 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Wed, 22 Mar 2017 16:14:54 +0100
Subject: [PATCH] TOOLS-1634 'sdcadm up' parallel import of images can break
 when multiple images share a new origin image Reviewed by: Trent Mick
 <trentm@gmail.com> Approved by: Trent Mick <trentm@gmail.com>

---
 lib/procedures/download-images.js | 339 ++++++++++++++++++++++--------
 1 file changed, 254 insertions(+), 85 deletions(-)

diff --git a/lib/procedures/download-images.js b/lib/procedures/download-images.js
index 8a36175..d855cac 100644
--- a/lib/procedures/download-images.js
+++ b/lib/procedures/download-images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var p = console.log;
@@ -65,119 +65,288 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
         }
     }
 
+    /*
+     * Keep track of errors during parallel image imports
+     */
+    var errs = [];
 
-    var q = vasync.queuev({
-        concurrency: 4,
-        worker: function importUpdateImage(image, next) {
-            function deleteImage(_, nextStep) {
-                if (image.state !== 'unactivated') {
-                    return nextStep();
-                }
 
-                progress('Removing unactivated image %s\n(%s@%s)', image.uuid,
-                    image.name, image.version);
+    /*
+     * Given an array containing an array of images, this function will
+     * recursively call itself until we get the origins for all the images,
+     * storing these in arrays of the form:
+     * [..., [Arr of origins of level 2], [Arr of origins of level 1], [imgs]]
+     *
+     * The callback will be called with `f(err, collectionsOfImages)`
+     */
+    function getAncestorsForImages(colsToRetrieve, callback) {
+        var currCol = colsToRetrieve[0];
+        var newCol = [];
+        vasync.forEachParallel({
+            inputs: currCol,
+            func: function checkImgOrigin(img, nextImg) {
+                if (!img.origin) {
+                    nextImg();
+                    return;
+                }
 
-                sdcadm.imgapi.deleteImage(image.uuid, function (err) {
-                    if (err) {
-                        progress('Error removing unactivated image %s\n(%s@%s)',
-                                    image.uuid, image.name, image.version);
+                /*
+                 * If we find that the image origin has already been queued for
+                 * download, we need to move it up on the download queue, since
+                 * we want it downloaded before the image we're evaluating now.
+                 */
+                var found = false;
+                colsToRetrieve.forEach(function (aCol) {
+                    var pos;
+                    for (pos = 0; pos < aCol.length; pos += 1) {
+                        if (aCol[pos].uuid === img.origin) {
+                            newCol.push(aCol[pos]);
+                            delete (aCol[pos]);
+                            found = true;
+                        }
+                    }
+                });
+                if (found) {
+                    nextImg();
+                    return;
+                }
 
-                        var e = new errors.SDCClientError(err, 'imgapi');
-                        e.image = image.uuid;
-                        sdcadm.log.error({err: e}, 'Error removing image');
-                        nextStep(e);
-                    } else {
-                        nextStep();
+                var orig = img.origin;
+                sdcadm.imgapi.getImage(orig, function (err, local) {
+                    if (!err) {
+                        /*
+                         * Origin already imported but unactivated.
+                         */
+                        if (local.state === 'unactivated') {
+                            newCol.push(local);
+                        }
+                        nextImg();
+                        return;
+                    } else if (err) {
+                        if (err.body.code !== 'ResourceNotFound') {
+                            nextImg(new errors.SDCClientError(err, 'imgapi'));
+                            return;
+                        } else {
+                            /*
+                             * We need to fetch origin details from remote
+                             * (origin not imported).
+                             */
+                            sdcadm.updates.getImage(orig, function (er, rem) {
+                                if (er) {
+                                    nextImg(new errors.SDCClientError(er,
+                                        'updates'));
+                                    return;
+                                }
+                                newCol.push(rem);
+                                nextImg();
+                            });
+                        }
                     }
                 });
             }
+        }, function paraCb(paraErr) {
+            if (paraErr) {
+                callback(paraErr);
+                return;
+            }
+            if (newCol.length) {
+                var uuids = [];
+                newCol = newCol.filter(function (elm) {
+                    var isNew = (uuids.indexOf(elm.uuid) === -1);
+                    if (isNew) {
+                        uuids.push(elm.uuid);
+                    }
+                    return isNew;
+                });
+                colsToRetrieve.unshift(newCol);
+                getAncestorsForImages(colsToRetrieve, callback);
+            } else {
+                callback(null, colsToRetrieve);
+            }
+        });
+    }
+
+
+    function importCollectionOfImages(collection, nextCollection) {
+        var q = vasync.queuev({
+            concurrency: 4,
+            worker: function importUpdateImage(image, next) {
+                /*
+                 * Need to be verified here b/c there sdcadm parts other than
+                 * procedures index calling DownloadImages.
+                 */
+                function checkIfImageIsUnactivated(_, nextStep) {
+                    if (image.state === 'unactivated') {
+                        nextStep();
+                        return;
+                    }
+                    sdcadm.imgapi.getImage(image.uuid, function (err, local) {
+                        if (err && err.body.code === 'ResourceNotFound') {
+                            nextStep();
+                        } else if (err) {
+                            nextStep(new errors.SDCClientError(err, 'imgapi'));
+                        } else {
+                            if (local.state === 'unactivated') {
+                                // Let DownloadImages know that it has to
+                                // remove the image first:
+                                image.state = 'unactivated';
+                            }
+                            nextStep();
+                        }
+                    });
+                }
+
+                function deleteImage(_, nextStep) {
+                    if (image.state !== 'unactivated') {
+                        return nextStep();
+                    }
+
+                    progress('Removing unactivated image %s\n(%s@%s)',
+                        image.uuid, image.name, image.version);
 
-            function getImage(_, nextStep) {
-                progress('Downloading image %s\n    (%s@%s)',
-                    image.uuid, image.name, image.version);
-                sdcadm.imgapi.adminImportRemoteImageAndWait(
-                    image.uuid,
-                    source,
-                    {
-                        // TODO: Once IMGAPI-408 is sufficient deployed, then
-                        // drop this `skipOwnerCheck`.
-                        skipOwnerCheck: true,
-                        // Retry image import 5 times by default:
-                        retries: 5
-                    },
-                    function (err, img, res) {
+                    sdcadm.imgapi.deleteImage(image.uuid, function (err) {
                         if (err) {
-                            progress('Error importing image %s\n(%s@%s)',
+                            progress(
+                                'Error removing unactivated image %s\n(%s@%s)',
                                 image.uuid, image.name, image.version);
+
                             var e = new errors.SDCClientError(err, 'imgapi');
                             e.image = image.uuid;
+                            sdcadm.log.error({err: e}, 'Error removing image');
                             nextStep(e);
                         } else {
-                            progress('Imported image %s\n    (%s@%s)',
-                                image.uuid, image.name, image.version);
                             nextStep();
                         }
                     });
+                }
+
+                function getImage(_, nextStep) {
+                    progress('Downloading image %s\n    (%s@%s)',
+                        image.uuid, image.name, image.version);
+                    sdcadm.imgapi.adminImportRemoteImageAndWait(
+                        image.uuid,
+                        source,
+                        {
+                            // TODO: Once IMGAPI-408 is sufficient deployed,
+                            // then drop this `skipOwnerCheck`.
+                            skipOwnerCheck: true,
+                            // Retry image import 5 times by default:
+                            retries: 5
+                        },
+                        function (err, img, res) {
+                            if (err) {
+                                progress('Error importing image %s\n(%s@%s)',
+                                    image.uuid, image.name, image.version);
+                                var e = new errors.SDCClientError(err,
+                                    'imgapi');
+                                e.image = image.uuid;
+                                nextStep(e);
+                            } else {
+                                progress('Imported image %s\n    (%s@%s)',
+                                    image.uuid, image.name, image.version);
+                                nextStep();
+                            }
+                        });
+                }
+
+                vasync.pipeline({funcs: [
+                    checkIfImageIsUnactivated,
+                    deleteImage,
+                    getImage
+                ]}, next);
             }
+        });
 
-            vasync.pipeline({funcs: [deleteImage, getImage]}, next);
+        function onTaskComplete(err) {
+            if (err) {
+                errs.push(err);
+            }
         }
-    });
 
-    // TODO: For now we just collect import errors and return them. We
-    //       should do better with retries (either here or in the imgapi
-    //       client).
-    var errs = [];
-    function onTaskComplete(err) {
+        q.on('end', function done() {
+            nextCollection();
+        });
+
+        q.push(collection, onTaskComplete);
+        q.close();
+    }
+
+
+
+    /*
+     * TOOLS-1634: We need to make sure that all the origins for
+     * all our images are imported and active in local IMGAPI.
+     * Additionally, we cannot try to import origins and the images
+     * created from those origins in parallel, so we need to import
+     * the different level of images ancestors sequentially.
+     *
+     * We'll use an array of arrays, prepending collections to this array as
+     * we go deeper in image's origins. Every origin not already on the local
+     * IMGAPI or with a state of 'unactivated' will be imported. Once we have
+     * a collection of 'sibiling' origins, we'll normalize that collection
+     * (remove duplicates) and prepend to `collectionsToRetrieve`:
+     */
+    var collectionsToRetrieve = [];
+    /*
+     * We'll begin with the service images we want to retrieve first,
+     * then we'll continue with successive origins.
+     */
+    collectionsToRetrieve.unshift(self.images);
+
+    getAncestorsForImages(collectionsToRetrieve, function (err, collections) {
         if (err) {
-            errs.push(err);
+            cb(err);
+            return;
         }
-    }
 
-    q.on('end', function done() {
-        var er = (errs.length === 1) ? errs[0] :
-            new errors.MultiError(errs);
-
-        // Check if the problem is that external nics are missing.
-        if (errs.length) {
-            var remoteSourceErr = errs.some(function (e) {
-                return (e && e.we_cause &&
-                    e.we_cause.name === 'RemoteSourceError');
-            });
-
-            if (remoteSourceErr) {
-                options.sdcadm.checkMissingExternalNics({
-                    progress: options.progress
-                }, function (err, res) {
-                    if (err) {
-                        return cb(errs);
-                    }
+        vasync.forEachPipeline({
+            inputs: collections,
+            func: importCollectionOfImages
+        }, function pipeCb(pipeErr) {
+            if (pipeErr) {
+                cb(pipeErr);
+                return;
+            }
+            var er = (errs.length === 1) ? errs[0] :
+                new errors.MultiError(errs);
 
-                    var doimgapi = res.doimgapi;
-                    if (doimgapi) {
-                        p('');
-                        var msg = 'There is an error trying to download ' +
-                            'images because the imgapi zone has no ' +
-                            'external NIC.\nPlease run:\n\n' +
-                            '   sdcadm post-setup common-external-nics\n' +
-                            '\nand try again.\n';
-                        p(msg);
-                    }
-                    // we need to return the error anyway:
-                    return cb(er);
+            // Check if the problem is that external nics are missing.
+            if (errs.length) {
+                var remoteSourceErr = errs.some(function (e) {
+                    return (e && e.we_cause &&
+                        e.we_cause.name === 'RemoteSourceError');
                 });
+
+                if (remoteSourceErr) {
+                    sdcadm.checkMissingExternalNics({
+                        progress: progress
+                    }, function (nicsErr, res) {
+                        if (nicsErr) {
+                            return cb(errs);
+                        }
+
+                        var doimgapi = res.doimgapi;
+                        if (doimgapi) {
+                            p('');
+                            var msg = 'There is an error trying to download ' +
+                                'images because the imgapi zone has no ' +
+                                'external NIC.\nPlease run:\n\n' +
+                                '   sdcadm post-setup common-external-nics\n' +
+                                '\nand try again.\n';
+                            p(msg);
+                        }
+                        // we need to return the error anyway:
+                        cb(er);
+                        return;
+                    });
+                } else {
+                    cb(er);
+                }
             } else {
-                cb(er);
+                cb();
             }
-        } else {
-            cb();
-        }
+        });
     });
-
-    for (var i = 0; i < self.images.length; i++) {
-        q.push(self.images[i], onTaskComplete);
-    }
-    q.close();
 };
 
 //---- exports
-- 
2.21.0

