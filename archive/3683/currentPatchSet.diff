From 9dfd8b48e15641cbd518c98d24f1d9df4774b182 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Mon, 19 Mar 2018 10:54:57 -0500
Subject: [PATCH] Add dcid property to overlay

---
 usr/src/cmd/dladm/dladm.c                     | 24 ++++--
 usr/src/lib/libdladm/common/libdloverlay.c    |  8 +-
 usr/src/lib/libdladm/common/libdloverlay.h    |  6 +-
 usr/src/lib/varpd/libvarpd/common/libvarpd.c  | 12 ++-
 .../lib/varpd/libvarpd/common/libvarpd_impl.h |  5 +-
 .../varpd/libvarpd/common/libvarpd_overlay.c  |  7 +-
 .../varpd/libvarpd/common/libvarpd_persist.c  |  8 +-
 .../varpd/libvarpd/common/libvarpd_provider.h |  1 +
 usr/src/man/man1m/dladm.1m                    | 16 +++-
 usr/src/uts/common/io/overlay/overlay.c       | 81 ++++++++++++++++++-
 .../uts/common/io/overlay/overlay_target.c    |  1 +
 usr/src/uts/common/sys/overlay.h              |  4 +-
 usr/src/uts/common/sys/overlay_target.h       |  1 +
 13 files changed, 145 insertions(+), 29 deletions(-)

diff --git a/usr/src/cmd/dladm/dladm.c b/usr/src/cmd/dladm/dladm.c
index a67400c300..e46ce50af7 100644
--- a/usr/src/cmd/dladm/dladm.c
+++ b/usr/src/cmd/dladm/dladm.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright 2016 Nexenta Systems, Inc.
  */
 
@@ -419,7 +419,8 @@ static cmd_t	cmds[] = {
 	    "    show-bridge      -t [-p] [-o <field>,...] [-s [-i <interval>]]"
 	    " <bridge>\n"						},
 	{ "create-overlay",	do_create_overlay,
-	    "    create-overlay   [-t] -e <encap> -s <search> -v <vnetid>\n"
+	    "    create-overlay   [-t] [-d <dcid>] -e <encap> -s <search> "
+	    "-v <vnetid>\n"
 	    "\t\t     [ -p <prop>=<value>[,...]] <overlay>"	},
 	{ "delete-overlay",	do_delete_overlay,
 	    "    delete-overlay   <overlay>"			},
@@ -1463,6 +1464,7 @@ static const struct option overlay_create_lopts[] = {
 	{ "search",	required_argument,	NULL,	's' },
 	{ "temporary", 	no_argument,		NULL,	't' },
 	{ "vnetid",	required_argument,	NULL,	'v' },
+	{ "dcid",	optional_argument,	NULL,	'd' },
 	{ NULL,		0,			NULL,	0 }
 };
 
@@ -9891,15 +9893,26 @@ do_create_overlay(int argc, char *argv[], const char *use)
 	char			name[MAXLINKNAMELEN];
 	dladm_status_t		status;
 	uint32_t		flags = DLADM_OPT_ACTIVE | DLADM_OPT_PERSIST;
+	uint32_t		dcid = 0;
 	uint64_t		vid;
 	boolean_t		havevid = B_FALSE;
 	char			propstr[DLADM_STRSIZE];
 	dladm_arg_list_t	*proplist = NULL;
 
 	bzero(propstr, sizeof (propstr));
-	while ((opt = getopt_long(argc, argv, ":te:v:p:s:",
+	while ((opt = getopt_long(argc, argv, ":td:e:v:p:s:",
 	    overlay_create_lopts, NULL)) != -1) {
 		switch (opt) {
+		case 'd':
+			errno = 0;
+			dcid = strtoul(optarg, &endp, 10);
+			if (*endp != '\0' || (dcid == 0 && errno == EINVAL))
+				die("couldn't parse datacenter id: %s",
+				    optarg);
+			if ((dcid == ULONG_MAX && errno == ERANGE) ||
+			    (dcid > UINT32_MAX))
+				die("datacenter id too large: %s", optarg);
+			break;
 		case 'e':
 			encap = optarg;
 			break;
@@ -9916,6 +9929,7 @@ do_create_overlay(int argc, char *argv[], const char *use)
 				die("property list too long '%s'", propstr);
 			break;
 		case 'v':
+			errno = 0;
 			vid = strtoul(optarg, &endp, 10);
 			if (*endp != '\0' || (vid == 0 && errno == EINVAL))
 				die("couldn't parse virtual networkd id: %s",
@@ -9958,7 +9972,7 @@ do_create_overlay(int argc, char *argv[], const char *use)
 	    != DLADM_STATUS_OK)
 		die("invalid overlay property");
 
-	status = dladm_overlay_create(handle, name, encap, search, vid,
+	status = dladm_overlay_create(handle, name, encap, search, vid, dcid,
 	    proplist, &errlist, flags);
 	dladm_free_props(proplist);
 	if (status != DLADM_STATUS_OK) {
@@ -9988,7 +10002,7 @@ do_delete_overlay(int argc, char *argv[], const char *use)
 
 typedef struct showoverlay_state {
 	ofmt_handle_t		sho_ofmt;
-	const char 		*sho_linkname;
+	const char		*sho_linkname;
 	dladm_overlay_propinfo_handle_t sho_info;
 	uint8_t			sho_value[DLADM_OVERLAY_PROP_SIZEMAX];
 	uint32_t		sho_size;
diff --git a/usr/src/lib/libdladm/common/libdloverlay.c b/usr/src/lib/libdladm/common/libdloverlay.c
index 030854b3de..e508c4a16f 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.c
+++ b/usr/src/lib/libdladm/common/libdloverlay.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2015 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 #include <libdladm_impl.h>
@@ -480,7 +480,7 @@ dladm_overlay_walk_prop(dladm_handle_t handle, datalink_id_t linkid,
 
 dladm_status_t
 dladm_overlay_create(dladm_handle_t handle, const char *name,
-    const char *encap, const char *search, uint64_t vid,
+    const char *encap, const char *search, uint64_t vid, uint32_t dcid,
     dladm_arg_list_t *props, dladm_errlist_t *errs, uint32_t flags)
 {
 	int ret, i;
@@ -500,6 +500,7 @@ dladm_overlay_create(dladm_handle_t handle, const char *name,
 	bzero(&oic, sizeof (oic));
 	oic.oic_linkid = linkid;
 	oic.oic_vnetid = vid;
+	oic.oic_dcid = dcid;
 	(void) strlcpy(oic.oic_encap, encap, MAXLINKNAMELEN);
 
 	status = DLADM_STATUS_OK;
@@ -547,8 +548,7 @@ dladm_overlay_create(dladm_handle_t handle, const char *name,
 		return (dladm_errno2status(ret));
 	}
 
-	if ((ret = libvarpd_c_instance_create(vch, linkid, search,
-	    &id)) != 0) {
+	if ((ret = libvarpd_c_instance_create(vch, linkid, search, &id)) != 0) {
 		(void) dladm_errlist_append(errs,
 		    "failed to create varpd instance: %s", strerror(ret));
 		libvarpd_c_destroy(vch);
diff --git a/usr/src/lib/libdladm/common/libdloverlay.h b/usr/src/lib/libdladm/common/libdloverlay.h
index 39b01ccae3..3da3a34f46 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.h
+++ b/usr/src/lib/libdladm/common/libdloverlay.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2015 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 #ifndef _LIBDLOVERLAY_H
@@ -45,8 +45,8 @@ typedef struct dladm_overlay_status {
 } dladm_overlay_status_t;
 
 extern dladm_status_t dladm_overlay_create(dladm_handle_t, const char *,
-    const char *, const char *, uint64_t, dladm_arg_list_t *, dladm_errlist_t *,
-    uint32_t);
+    const char *, const char *, uint64_t, uint32_t, dladm_arg_list_t *,
+    dladm_errlist_t *, uint32_t);
 extern dladm_status_t dladm_overlay_delete(dladm_handle_t, datalink_id_t);
 
 typedef void (*dladm_overlay_status_f)(dladm_handle_t, datalink_id_t,
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd.c b/usr/src/lib/varpd/libvarpd/common/libvarpd.c
index e4460089cc..9de3602e62 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd.c
@@ -150,6 +150,7 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	varpd_instance_t *inst, lookup;
 	overlay_plugin_dest_t dest;
 	uint64_t vid;
+	uint32_t dcid;
 
 	/*
 	 * We should really have our own errnos.
@@ -158,7 +159,8 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	if (plugin == NULL)
 		return (ENOENT);
 
-	if ((ret = libvarpd_overlay_info(vip, linkid, &dest, NULL, &vid)) != 0)
+	if ((ret = libvarpd_overlay_info(vip, linkid, &dest, NULL, &vid,
+	    &dcid)) != 0)
 		return (ret);
 
 	inst = umem_alloc(sizeof (varpd_instance_t), UMEM_DEFAULT);
@@ -175,6 +177,7 @@ libvarpd_instance_create(varpd_handle_t *vhp, datalink_id_t linkid,
 	inst->vri_dest = dest;
 	inst->vri_plugin = plugin;
 	inst->vri_impl = vip;
+	inst->vri_dcid = dcid;
 	inst->vri_flags = 0;
 	if ((ret = plugin->vpp_ops->vpo_create((varpd_provider_handle_t *)inst,
 	    &inst->vri_private, dest)) != 0) {
@@ -217,6 +220,13 @@ libvarpd_plugin_vnetid(varpd_provider_handle_t *vhp)
 	return (inst->vri_vnetid);
 }
 
+uint32_t
+libvarpd_plugin_dcid(varpd_provider_handle_t *vhp)
+{
+	varpd_instance_t *inst = (varpd_instance_t *)vhp;
+	return (inst->vri_dcid);
+}
+
 varpd_instance_handle_t *
 libvarpd_instance_lookup(varpd_handle_t *vhp, uint64_t id)
 {
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
index 7ecd3a952f..01fe6908ba 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_IMPL_H
@@ -77,6 +77,7 @@ typedef struct varpd_instance {
 	varpd_impl_t	*vri_impl;		/* RO */
 	varpd_plugin_t	*vri_plugin;		/* RO */
 	void		*vri_private;		/* RO */
+	uint32_t	vri_dcid;		/* RO */
 	mutex_t		vri_lock;
 	varpd_instance_flags_t vri_flags;	/* vri_lock */
 } varpd_instance_t;
@@ -208,7 +209,7 @@ extern int libvarpd_dirwalk(varpd_impl_t *, const char *, const char *,
 extern int libvarpd_overlay_init(varpd_impl_t *);
 extern void libvarpd_overlay_fini(varpd_impl_t *);
 extern int libvarpd_overlay_info(varpd_impl_t *, datalink_id_t,
-    overlay_plugin_dest_t *, uint64_t *, uint64_t *);
+    overlay_plugin_dest_t *, uint64_t *, uint64_t *, uint32_t *);
 extern int libvarpd_overlay_associate(varpd_instance_t *);
 extern int libvarpd_overlay_disassociate(varpd_instance_t *);
 extern int libvarpd_overlay_degrade(varpd_instance_t *, const char *);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
index 5cdfd20ebe..060559124e 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -53,7 +53,8 @@ libvarpd_overlay_fini(varpd_impl_t *vip)
 
 int
 libvarpd_overlay_info(varpd_impl_t *vip, datalink_id_t linkid,
-    overlay_plugin_dest_t *destp, uint64_t *flags, uint64_t *vnetid)
+    overlay_plugin_dest_t *destp, uint64_t *flags, uint64_t *vnetid,
+    uint32_t *dcid)
 {
 	overlay_targ_info_t oti;
 
@@ -67,6 +68,8 @@ libvarpd_overlay_info(varpd_impl_t *vip, datalink_id_t linkid,
 		*flags = oti.oti_flags;
 	if (vnetid != NULL)
 		*vnetid = oti.oti_vnetid;
+	if (dcid != NULL)
+		*dcid = oti.oti_dcid;
 	return (0);
 }
 
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
index 27cc802a9c..f8b1fcedfc 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_persist.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.  All rights reserved.
+ * Copyright 2018 Joyent, Inc.  All rights reserved.
  */
 
 /*
@@ -281,7 +281,7 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	int err;
 	nvlist_t *pvl;
 	uint64_t id, flags, vid;
-	uint32_t linkid, dest, mode;
+	uint32_t linkid, dest, mode, dcid;
 	char *pluginstr;
 	varpd_plugin_t *plugin;
 	overlay_plugin_dest_t adest;
@@ -312,7 +312,8 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	if (plugin->vpp_mode != mode)
 		return (EINVAL);
 
-	if (libvarpd_overlay_info(vip, linkid, &adest, &flags, &vid) != 0)
+	if (libvarpd_overlay_info(vip, linkid, &adest, &flags, &vid,
+	    &dcid) != 0)
 		return (EINVAL);
 
 	if (dest != adest)
@@ -334,6 +335,7 @@ libvarpd_persist_restore_instance(varpd_impl_t *vip, nvlist_t *nvl)
 	inst->vri_dest = dest;
 	inst->vri_plugin = plugin;
 	inst->vri_impl = vip;
+	inst->vri_dcid = dcid;
 	inst->vri_flags = 0;
 	if (plugin->vpp_ops->vpo_restore(pvl, (varpd_provider_handle_t *)inst,
 	    dest, &inst->vri_private) != 0) {
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
index 6fbc113fbf..93749683df 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
@@ -374,6 +374,7 @@ extern const bunyan_logger_t *libvarpd_plugin_bunyan(varpd_provider_handle_t *);
  * Misc. Information APIs
  */
 extern uint64_t libvarpd_plugin_vnetid(varpd_provider_handle_t *);
+extern uint32_t	libvarpd_plugin_dcid(varpd_provider_handle_t *);
 
 /*
  * Lookup Replying query and proxying
diff --git a/usr/src/man/man1m/dladm.1m b/usr/src/man/man1m/dladm.1m
index c647cd7f19..544e58e4e8 100644
--- a/usr/src/man/man1m/dladm.1m
+++ b/usr/src/man/man1m/dladm.1m
@@ -176,7 +176,7 @@ dladm \- administer data links
 
 .LP
 .nf
-\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR \fB-v\fR \fIvnetid\fR [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
+\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR \fB-v\fR \fIvnetid\fR [\fB-d\fR \fIdcid\fR] [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
 \fBdladm delete-overlay\fR \fIoverlay\fR
 \fBdladm modify-overlay\fR \fB-d\fR \fImac\fR | \fB-f\fR | \fB-s\fR \fImac=ip:port\fR \fIoverlay\fR
 \fBdladm show-overlay\fR [ \fB-f\fR | \fB-t\fR ] [[\fB-p\fR] \fB-o\fR \fIfield\fR[,...]] [\fIoverlay\fR]
@@ -4446,8 +4446,8 @@ The tunnel destination address.
 .sp
 .ne 2
 .na
-\fBdladm create-overlay\fR \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR
-\fB-v\fR \fIvnetid\fR [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
+\fBdladm create-overlay\fR [\fB-t\fR] \fB-e\fR \fIencap\fR \fB-s\fR \fIsearch\fR
+\fB-v\fR \fIvnetid\fR [\fB-d\fR \fIdcid\fR] [\fB-p\fR \fIprop\fR=\fIvalue\fR[,...]] \fIoverlay\fR
 .ad
 .sp .6
 .RS 4n
@@ -4501,6 +4501,16 @@ Use \fIsearch\fR as the search plugin for \fIoverlay\fR. The search plugin
 determines how non-local targets are found and where packets are directed to.
 .RE
 
+.sp
+.ne 2
+.na
+\fB\fB-d\fR \fIdcid\fR
+.ad
+.sp .6
+.RS 4n
+Set the datacenter id to \fIdcid\fR.
+.RE
+
 .sp
 .ne 2
 .na
diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index d20621bcb3..c2f79d06ef 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -834,15 +834,17 @@ typedef enum overlay_dev_prop {
 	OVERLAY_DEV_P_MTU = 0,
 	OVERLAY_DEV_P_VNETID,
 	OVERLAY_DEV_P_ENCAP,
-	OVERLAY_DEV_P_VARPDID
+	OVERLAY_DEV_P_VARPDID,
+	OVERLAY_DEV_P_DCID
 } overlay_dev_prop_t;
 
-#define	OVERLAY_DEV_NPROPS	4
+#define	OVERLAY_DEV_NPROPS	5
 static const char *overlay_dev_props[] = {
 	"mtu",
 	"vnetid",
 	"encap",
-	"varpd/id"
+	"varpd/id",
+	"dcid"
 };
 
 #define	OVERLAY_MTU_MIN	576
@@ -1280,6 +1282,14 @@ overlay_i_create(void *karg, intptr_t arg, int mode, cred_t *cred, int *rvalp)
 	}
 	odd->odd_vid = oicp->oic_vnetid;
 
+	if (oicp->oic_dcid > UINT32_MAX) {
+		odd->odd_plugin->ovp_ops->ovpo_fini(odd->odd_pvoid);
+		overlay_plugin_rele(odd->odd_plugin);
+		kmem_free(odd, sizeof (overlay_dev_t));
+		return (EINVAL);
+	}
+	odd->odd_dcid = oicp->oic_dcid;
+
 	mac = mac_alloc(MAC_VERSION);
 	if (mac == NULL) {
 		mutex_exit(&overlay_dev_lock);
@@ -1715,6 +1725,12 @@ overlay_i_propinfo(void *karg, intptr_t arg, int mode, cred_t *cred,
 		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
 		overlay_prop_set_nodefault(phdl);
 		break;
+	case OVERLAY_DEV_P_DCID:
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_READ);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_nodefault(phdl);
+		overlay_prop_set_range_uint32(phdl, 0, UINT32_MAX);
+		break;
 	default:
 		overlay_hold_rele(odd);
 		mac_perim_exit(mph);
@@ -1824,6 +1840,18 @@ overlay_i_getprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 		}
 		mutex_exit(&odd->odd_lock);
 		break;
+	case OVERLAY_DEV_P_DCID:
+		/*
+		 * While it's read-only while inside of a mux, we're not in a
+		 * context that can guarantee that. Therefore we always grab the
+		 * overlay_dev_t's odd_lock.
+		 */
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_dcid, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
+
 	default:
 		ret = ENOENT;
 	}
@@ -1865,6 +1893,38 @@ overlay_setprop_vnetid(overlay_dev_t *odd, uint64_t vnetid)
 	mutex_exit(&odd->odd_lock);
 }
 
+static void
+overlay_setprop_dcid(overlay_dev_t *odd, uint32_t dcid)
+{
+	mutex_enter(&odd->odd_lock);
+
+	/* Simple case, not active */
+	if (!(odd->odd_flags & OVERLAY_F_IN_MUX)) {
+		odd->odd_dcid = dcid;
+		mutex_exit(&odd->odd_lock);
+		return;
+	}
+
+	/*
+	 * In the hard case, we need to set the drop flag, quiesce I/O and then
+	 * we can go ahead and do everything.
+	 */
+	odd->odd_flags |= OVERLAY_F_MDDROP;
+	overlay_io_wait(odd, OVERLAY_F_IOMASK);
+	mutex_exit(&odd->odd_lock);
+
+	overlay_mux_remove_dev(odd->odd_mux, odd);
+	mutex_enter(&odd->odd_lock);
+	odd->odd_dcid = dcid;
+	mutex_exit(&odd->odd_lock);
+	overlay_mux_add_dev(odd->odd_mux, odd);
+
+	mutex_enter(&odd->odd_lock);
+	ASSERT(odd->odd_flags & OVERLAY_F_IN_MUX);
+	odd->odd_flags &= ~OVERLAY_F_IN_MUX;
+	mutex_exit(&odd->odd_lock);
+}
+
 /* ARGSUSED */
 static int
 overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
@@ -1875,7 +1935,7 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 	overlay_ioc_prop_t *oip = karg;
 	uint_t propid = UINT_MAX;
 	mac_perim_handle_t mph;
-	uint64_t maxid, *vidp;
+	uint64_t maxid, *vidp, *dcidp;
 
 	if (oip->oip_size > OVERLAY_PROP_SIZEMAX)
 		return (EINVAL);
@@ -1961,6 +2021,19 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 	case OVERLAY_DEV_P_VARPDID:
 		ret = EPERM;
 		break;
+	case OVERLAY_DEV_P_DCID:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		dcidp = (uint64_t *)oip->oip_value;
+		if (*dcidp > UINT32_MAX) {
+			ret = EINVAL;
+			break;
+		}
+		overlay_setprop_dcid(odd, *dcidp);
+		break;
+
 	default:
 		ret = ENOENT;
 	}
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 0e4a826fac..cb79bfdfdb 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -460,6 +460,7 @@ overlay_target_info(overlay_target_hdl_t *thdl, void *arg)
 	if (odd->odd_flags & OVERLAY_F_ACTIVATED)
 		oti->oti_flags |= OVERLAY_TARG_INFO_F_ACTIVE;
 	oti->oti_vnetid = odd->odd_vid;
+	oti->oti_dcid = odd->odd_dcid;
 	mutex_exit(&odd->odd_lock);
 	overlay_hold_rele(odd);
 	return (0);
diff --git a/usr/src/uts/common/sys/overlay.h b/usr/src/uts/common/sys/overlay.h
index 12d0dbca51..90f1843282 100644
--- a/usr/src/uts/common/sys/overlay.h
+++ b/usr/src/uts/common/sys/overlay.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #ifndef _SYS_OVERLAY_H
@@ -40,7 +40,7 @@ extern "C" {
 
 typedef struct overlay_ioc_create {
 	datalink_id_t	oic_linkid;
-	uint32_t	oic_filler;
+	uint32_t	oic_dcid;
 	uint64_t	oic_vnetid;
 	char		oic_encap[MAXLINKNAMELEN];
 } overlay_ioc_create_t;
diff --git a/usr/src/uts/common/sys/overlay_target.h b/usr/src/uts/common/sys/overlay_target.h
index 99468a4371..b205266baf 100644
--- a/usr/src/uts/common/sys/overlay_target.h
+++ b/usr/src/uts/common/sys/overlay_target.h
@@ -73,6 +73,7 @@ typedef struct overlay_targ_info {
 	uint32_t		oti_needs;
 	uint64_t		oti_flags;
 	uint64_t		oti_vnetid;
+	uint32_t		oti_dcid;
 } overlay_targ_info_t;
 
 /*
-- 
2.21.0

