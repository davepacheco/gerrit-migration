commit a600bc1d768c038aca26139e445c740929ca583d (refs/changes/26/4626/3)
Author: Jason King <jason.king@joyent.com>
Date:   2018-08-07T12:39:06-05:00 (1 year, 2 months ago)
    
    Allow adjustment of 2Q cache sizes while running

diff --git a/usr/src/cmd/dladm/dladm.c b/usr/src/cmd/dladm/dladm.c
index ca66f66428..7405c883bc 100644
--- a/usr/src/cmd/dladm/dladm.c
+++ b/usr/src/cmd/dladm/dladm.c
@@ -426,7 +426,7 @@ static cmd_t	cmds[] = {
 	    "    delete-overlay   <overlay>"			},
 	{ "modify-overlay",	do_modify_overlay,
 	    "    modify-overlay   -d [dcid/]mac | -f | -s [dcid/]mac=ip:port "
-	    "<overlay>"						},
+	    " | -p prop=value[,...] <overlay>"						},
 	{ "show-overlay",	do_show_overlay,
 	    "    show-overlay     [-f | -t] [[-p] -o <field>,...] "
 	    "[<overlay>]\n"						},
@@ -1471,6 +1471,7 @@ static const struct option overlay_create_lopts[] = {
 static const struct option overlay_modify_lopts[] = {
 	{ "delete-entry",	required_argument,	NULL,	'd' },
 	{ "flush-table",	no_argument,		NULL,	'f' },
+	{ "prop",		required_argument,	NULL,	'p' },
 	{ "set-entry",		required_argument,	NULL,	's' },
 	{ NULL,			0,			NULL,	0 }
 };
@@ -10557,15 +10558,16 @@ static void
 do_modify_overlay(int argc, char *argv[], const char *use)
 {
 	int			opt, ocnt = 0;
-	boolean_t		flush, set, delete;
+	boolean_t		flush, set, delete, setprop;
 	uint32_t		dcid = 0;
 	struct ether_addr	e;
 	char			*dest;
 	datalink_id_t		linkid = DATALINK_ALL_LINKID;
 	dladm_status_t		status;
+	char			propstr[DLADM_STRSIZE] = { 0 };
 
-	flush = set = delete = B_FALSE;
-	while ((opt = getopt_long(argc, argv, ":fd:s:", overlay_modify_lopts,
+	flush = set = delete = setprop = B_FALSE;
+	while ((opt = getopt_long(argc, argv, ":fd:p:s:", overlay_modify_lopts,
 	    NULL)) != -1) {
 		switch (opt) {
 		case 'd':
@@ -10581,6 +10583,16 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 			flush = B_TRUE;
 			ocnt++;
 			break;
+		case 'p':
+			if (setprop == B_TRUE)
+				die_optdup('p');
+			setprop = B_TRUE;
+			(void) strlcat(propstr, optarg, DLADM_STRSIZE);
+			if (strlcat(propstr, ",", DLADM_STRSIZE) >=
+			    DLADM_STRSIZE)
+				die("property list too long '%s'", propstr);
+			ocnt++;
+			break;
 		case 's':
 			if (set == B_TRUE)
 				die_optdup('s');
@@ -10600,9 +10612,9 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 	}
 
 	if (ocnt == 0)
-		die("need to specify one of -d, -f, or -s");
+		die("need to specify one of -d, -f, -p, or -s");
 	if (ocnt > 1)
-		die("only one of -d, -f, or -s may be used");
+		die("only one of -d, -f, -p, or -s may be used");
 
 	if (argv[optind] == NULL)
 		die("missing required overlay device\n");
@@ -10637,4 +10649,29 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 			    "target cache %s", optarg, argv[optind]);
 	}
 
+	if (setprop == B_TRUE) {
+		dladm_arg_list_t *proplist = NULL;
+		uint_t i;
+
+		if (dladm_parse_link_props(propstr, &proplist, B_FALSE)
+		    != DLADM_STATUS_OK)
+			die("invalid overlay property");
+
+		for (i = 0; i < proplist->al_count; i++) {
+			dladm_status_t status;
+
+			status = dladm_overlay_setprop(handle, linkid,
+			    proplist->al_info[i].ai_name,
+			    proplist->al_info[i].ai_val,
+			    proplist->al_info[i].ai_count);
+
+			if (status != DLADM_STATUS_OK) {
+				die_dlerr(status, "failed to set property %s "
+				    "for overlay device %s",
+				    proplist->al_info[i].ai_name, argv[optind]);
+			}
+		}
+
+		dladm_free_props(proplist);
+	}
 }
diff --git a/usr/src/lib/libdladm/common/libdloverlay.c b/usr/src/lib/libdladm/common/libdloverlay.c
index 9aabb05558..db58da0a34 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.c
+++ b/usr/src/lib/libdladm/common/libdloverlay.c
@@ -208,16 +208,16 @@ dladm_overlay_setprop(dladm_handle_t handle, datalink_id_t linkid,
 	prop.oip_linkid = linkid;
 	prop.oip_id = info.oipi_id;
 	prop.oip_name[0] = '\0';
-	if ((ret = dladm_overlay_parse_prop(info.oipi_type, prop.oip_value,
+	if ((status = dladm_overlay_parse_prop(info.oipi_type, prop.oip_value,
 	    &prop.oip_size, valp[0])) != DLADM_STATUS_OK)
-		return (ret);
+		return (status);
 
 	status = DLADM_STATUS_OK;
 	ret = ioctl(dladm_dld_fd(handle), OVERLAY_IOC_SETPROP, &prop);
 	if (ret != 0)
 		status = dladm_errno2status(errno);
 
-	return (ret);
+	return (status);
 }
 
 /*
diff --git a/usr/src/lib/libdladm/common/libdloverlay.h b/usr/src/lib/libdladm/common/libdloverlay.h
index 89b4c2fcff..e058cb7349 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.h
+++ b/usr/src/lib/libdladm/common/libdloverlay.h
@@ -72,6 +72,8 @@ extern dladm_status_t dladm_overlay_prop_info(dladm_overlay_propinfo_handle_t,
     const mac_propval_range_t **);
 extern dladm_status_t dladm_overlay_get_prop(dladm_handle_t, datalink_id_t,
     dladm_overlay_propinfo_handle_t, void *buf, size_t *bufsize);
+extern dladm_status_t dladm_overlay_setprop(dladm_handle_t, datalink_id_t,
+    const char *, char *const *, uint_t);
 
 typedef int (*dladm_overlay_prop_f)(dladm_handle_t, datalink_id_t,
     dladm_overlay_propinfo_handle_t, void *);
diff --git a/usr/src/lib/libdladm/common/mapfile-vers b/usr/src/lib/libdladm/common/mapfile-vers
index 589bbf5330..3b595920f7 100644
--- a/usr/src/lib/libdladm/common/mapfile-vers
+++ b/usr/src/lib/libdladm/common/mapfile-vers
@@ -281,6 +281,7 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	dladm_overlay_status;
 	dladm_overlay_prop_info;
 	dladm_overlay_get_prop;
+	dladm_overlay_setprop;
 	dladm_overlay_walk_prop;
 
 	dladm_overlay_cache_set;
diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index 0943e94d4c..c54a6e0d9c 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -891,22 +891,61 @@ typedef enum overlay_dev_prop {
 	OVERLAY_DEV_P_VNETID,
 	OVERLAY_DEV_P_ENCAP,
 	OVERLAY_DEV_P_VARPDID,
-	OVERLAY_DEV_P_DCID
+	OVERLAY_DEV_P_DCID,
+	OVERLAY_DEV_P_VL2_CACHE_SIZE,
+	OVERLAY_DEV_P_VL2_CACHE_A,
+	OVERLAY_DEV_P_ROUTE_CACHE_SIZE,
+	OVERLAY_DEV_P_ROUTE_CACHE_A
 } overlay_dev_prop_t;
 
-#define	OVERLAY_DEV_NPROPS	5
+#define	OVERLAY_DEV_NPROPS	9
 static const char *overlay_dev_props[] = {
 	"mtu",
 	"vnetid",
 	"encap",
 	"varpd/id",
-	"dcid"
+	"dcid",
+	"vl2_cache_size",
+	"_vl2_cache_a",
+	"route_cache_size",
+	"_route_cache_a"
 };
 
+/* properties that can be changed live */
+static boolean_t overlay_dev_liveprop[] = {
+	B_FALSE,	/* mtu */
+	B_FALSE,	/* vnetid */
+	B_FALSE,	/* encap */
+	B_FALSE,	/* varpd/id */
+	B_FALSE,	/* dcid */
+	B_TRUE,		/* vl2_cache_size */
+	B_TRUE,		/* _vl2_cache_a */
+	B_TRUE,		/* route_cache_size */
+	B_TRUE		/* _route_cache_a */
+};
+
+CTASSERT(ARRAY_SIZE(overlay_dev_props) == OVERLAY_DEV_NPROPS);
+CTASSERT(ARRAY_SIZE(overlay_dev_liveprop) == OVERLAY_DEV_NPROPS);
+
 #define	OVERLAY_MTU_MIN	576
 #define	OVERLAY_MTU_DEF	1400
 #define	OVERLAY_MTU_MAX	8900
 
+/* The 2Q parameter 'a' is a percentage */
+#define	OVERLAY_CACHE_MAX_A 100
+/* An somewhat arbitrary default, biasing towards storing more MFU entries */
+#define	OVERLAY_CACHE_A_DEF 75
+
+/* Somewhat arbitrary min and max values */
+#define	OVERLAY_VL2_CACHE_MIN	256
+#define	OVERLAY_VL2_CACHE_MAX	10240
+#define	OVERLAY_VL2_CACHE_DEF	OVERLAY_VL2_CACHE_MIN
+
+/* Somewhat arbitrary min and max values */
+#define	OVERLAY_ROUTE_CACHE_MIN	256
+#define	OVERLAY_ROUTE_CACHE_MAX 10240
+#define	OVERLAY_ROUTE_CACHE_DEF	OVERLAY_ROUTE_CACHE_MIN
+
 overlay_dev_t *
 overlay_hold_by_dlid(datalink_id_t id)
 {
@@ -1329,6 +1368,11 @@ overlay_i_create(void *karg, intptr_t arg, int mode, cred_t *cred, int *rvalp)
 	}
 	odd->odd_dcid = oicp->oic_dcid;
 
+	odd->odd_vl2sz = OVERLAY_VL2_CACHE_DEF;
+	odd->odd_vl2a = OVERLAY_CACHE_A_DEF;
+	odd->odd_routesz = OVERLAY_ROUTE_CACHE_DEF;
+	odd->odd_routea = OVERLAY_CACHE_A_DEF;
+
 	mac = mac_alloc(MAC_VERSION);
 	if (mac == NULL) {
 		mutex_exit(&overlay_dev_lock);
@@ -1682,6 +1726,7 @@ overlay_i_propinfo(void *karg, intptr_t arg, int mode, cred_t *cred,
 	int ret;
 	mac_perim_handle_t mph;
 	uint_t propid = UINT_MAX;
+	uint32_t def;
 	overlay_ioc_propinfo_t *oip = karg;
 	overlay_prop_handle_t phdl = (overlay_prop_handle_t)oip;
 
@@ -1770,6 +1815,36 @@ overlay_i_propinfo(void *karg, intptr_t arg, int mode, cred_t *cred,
 		overlay_prop_set_nodefault(phdl);
 		overlay_prop_set_range_uint32(phdl, 0, UINT32_MAX);
 		break;
+	case OVERLAY_DEV_P_VL2_CACHE_SIZE:
+		def = OVERLAY_VL2_CACHE_DEF;
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_RW);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_default(phdl, &def, sizeof (def));
+		overlay_prop_set_range_uint32(phdl, OVERLAY_VL2_CACHE_MIN,
+		    OVERLAY_VL2_CACHE_MAX);
+		break;
+	case OVERLAY_DEV_P_VL2_CACHE_A:
+		def = OVERLAY_CACHE_A_DEF;
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_RW);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_default(phdl, &def, sizeof (def));
+		overlay_prop_set_range_uint32(phdl, 0, OVERLAY_CACHE_MAX_A);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_SIZE:
+		def = OVERLAY_ROUTE_CACHE_DEF;
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_RW);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_default(phdl, &def, sizeof (def));
+		overlay_prop_set_range_uint32(phdl, OVERLAY_ROUTE_CACHE_MIN,
+		    OVERLAY_ROUTE_CACHE_MAX);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_A:
+		def = OVERLAY_CACHE_A_DEF;
+		overlay_prop_set_prot(phdl, OVERLAY_PROP_PERM_RW);
+		overlay_prop_set_type(phdl, OVERLAY_PROP_T_UINT);
+		overlay_prop_set_default(phdl, &def, sizeof (def));
+		overlay_prop_set_range_uint32(phdl, 0, OVERLAY_CACHE_MAX_A);
+		break;
 	default:
 		overlay_hold_rele(odd);
 		mac_perim_exit(mph);
@@ -1890,7 +1965,30 @@ overlay_i_getprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 		mutex_exit(&odd->odd_lock);
 		oip->oip_size = sizeof (uint32_t);
 		break;
-
+	case OVERLAY_DEV_P_VL2_CACHE_SIZE:
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_vl2sz, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
+	case OVERLAY_DEV_P_VL2_CACHE_A:
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_vl2a, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_SIZE:
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_routesz, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_A:
+		mutex_enter(&odd->odd_lock);
+		bcopy(&odd->odd_routea, oip->oip_value, sizeof (uint32_t));
+		mutex_exit(&odd->odd_lock);
+		oip->oip_size = sizeof (uint32_t);
+		break;
 	default:
 		ret = ENOENT;
 	}
@@ -1964,6 +2062,114 @@ overlay_setprop_dcid(overlay_dev_t *odd, uint32_t dcid)
 	mutex_exit(&odd->odd_lock);
 }
 
+static int
+overlay_setprop_vl2_cachesz(overlay_dev_t *odd, uint32_t sz)
+{
+	overlay_target_t *ott = NULL;
+	int ret = 0;
+
+	if (sz == 0)
+		sz = OVERLAY_VL2_CACHE_DEF;
+
+	/* Caller should have validated this */
+	ASSERT3U(sz, >=, OVERLAY_VL2_CACHE_MIN);
+	ASSERT3U(sz, <=, OVERLAY_VL2_CACHE_MAX);
+
+	mutex_enter(&odd->odd_lock);
+	ott = odd->odd_target;
+
+	/* ott_mode is RO if the target exists */
+	if (ott != NULL && ott->ott_mode == OVERLAY_TARGET_DYNAMIC) {
+		mutex_enter(&ott->ott_lock);
+		ret = qqcache_adjust_size(ott->ott_u.ott_dyn.ott_dhash, sz);
+		mutex_exit(&ott->ott_lock);
+	}
+
+	if (ret == 0)
+		odd->odd_vl2sz = sz;
+	mutex_exit(&odd->odd_lock);
+
+	return (ret);
+}
+
+static int
+overlay_setprop_vl2_cachea(overlay_dev_t *odd, uint32_t a)
+{
+	overlay_target_t *ott = NULL;
+	int ret = 0;
+
+	/* Caller should have validated this */
+	ASSERT3U(a, <=, 100);
+
+	mutex_enter(&odd->odd_lock);
+	ott = odd->odd_target;
+
+	/* ott_mode is RO if the target exists */
+	if (ott != NULL && ott->ott_mode == OVERLAY_TARGET_DYNAMIC) {
+		mutex_enter(&ott->ott_lock);
+		ret = qqcache_adjust_a(ott->ott_u.ott_dyn.ott_dhash, a);
+		mutex_exit(&ott->ott_lock);
+	}
+	if (ret == 0)
+		odd->odd_vl2a = a;
+	mutex_exit(&odd->odd_lock);
+
+	return (ret);
+}
+
+static int
+overlay_setprop_route_cachesz(overlay_dev_t *odd, uint32_t sz)
+{
+	overlay_target_t *ott = NULL;
+	int ret = 0;
+
+	if (sz == 0)
+		sz = OVERLAY_ROUTE_CACHE_DEF;
+
+	ASSERT3U(sz, >=, OVERLAY_ROUTE_CACHE_MIN);
+	ASSERT3U(sz, <=, OVERLAY_ROUTE_CACHE_MAX);
+
+	mutex_enter(&odd->odd_lock);
+	ott = odd->odd_target;
+
+	/* ott_mode is RO if the target exists */
+	if (ott != NULL && ott->ott_mode == OVERLAY_TARGET_DYNAMIC) {
+		mutex_enter(&ott->ott_lock);
+		ret = qqcache_adjust_size(ott->ott_u.ott_dyn.ott_l3dhash, sz);
+		mutex_exit(&ott->ott_lock);
+	}
+	if (ret == 0)
+		odd->odd_routesz = sz;
+	mutex_exit(&odd->odd_lock);
+
+	return (ret);
+}
+
+static int
+overlay_setprop_route_cachea(overlay_dev_t *odd, uint32_t a)
+{
+	overlay_target_t *ott = NULL;
+	int ret = 0;
+
+	/* Caller should have validated this */
+	ASSERT3U(a, <=, 100);
+
+	mutex_enter(&odd->odd_lock);
+	ott = odd->odd_target;
+
+	/* ott_mode is RO if the target exists */
+	if (ott != NULL && ott->ott_mode == OVERLAY_TARGET_DYNAMIC) {
+		mutex_enter(&ott->ott_lock);
+		ret = qqcache_adjust_a(ott->ott_u.ott_dyn.ott_l3dhash, a);
+		mutex_exit(&ott->ott_lock);
+	}
+	if (ret == 0)
+		odd->odd_routea = a;
+	mutex_exit(&odd->odd_lock);
+
+	return (ret);
+}
+
 /* ARGSUSED */
 static int
 overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
@@ -1974,7 +2180,7 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 	overlay_ioc_prop_t *oip = karg;
 	uint_t propid = UINT_MAX;
 	mac_perim_handle_t mph;
-	uint64_t maxid, *vidp, *dcidp;
+	uint64_t maxid, *vidp, *dcidp, *vl2szp, *vl2ap, *routeszp, *routeap;
 
 	if (oip->oip_size > OVERLAY_PROP_SIZEMAX)
 		return (EINVAL);
@@ -1984,31 +2190,48 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 		return (ENOENT);
 
 	oip->oip_name[OVERLAY_PROP_NAMELEN-1] = '\0';
-	mac_perim_enter_by_mh(odd->odd_mh, &mph);
-	mutex_enter(&odd->odd_lock);
-	if (odd->odd_flags & OVERLAY_F_ACTIVATED) {
-		mac_perim_exit(mph);
-		mutex_exit(&odd->odd_lock);
-		return (ENOTSUP);
-	}
-	mutex_exit(&odd->odd_lock);
+
+	/*
+	 * Currently, only certain overlay properties (and no encapsulation
+	 * properties) can be changed while the overlay device is active.
+	 */
 	if (oip->oip_id == -1) {
 		int i;
 
 		for (i = 0; i < OVERLAY_DEV_NPROPS; i++) {
 			if (strcmp(overlay_dev_props[i], oip->oip_name) == 0)
 				break;
-			if (i == OVERLAY_DEV_NPROPS) {
-				ret = odd->odd_plugin->ovp_ops->ovpo_setprop(
-				    odd->odd_pvoid, oip->oip_name,
-				    oip->oip_value, oip->oip_size);
-				overlay_hold_rele(odd);
-				mac_perim_exit(mph);
-				return (ret);
-			}
 		}
 
-		propid = i;
+		if (i < OVERLAY_DEV_NPROPS)
+			propid = i;
+	} else if (oip->oip_id < OVERLAY_DEV_NPROPS) {
+		propid = oip->oip_id;
+	}
+
+	/*
+	 * A bit tricky, but propid is initalized to UINT_MAX, so we know we
+	 * have an overlay property whenever propid < OVERLAY_DEV_NPROPS,
+	 * otherwise we have a plugin property.
+	 */
+	mac_perim_enter_by_mh(odd->odd_mh, &mph);
+	mutex_enter(&odd->odd_lock);
+	if ((odd->odd_flags & OVERLAY_F_ACTIVATED) &&
+	    ((propid >= OVERLAY_DEV_NPROPS || !overlay_dev_liveprop[propid]))) {
+		mutex_exit(&odd->odd_lock);
+		mac_perim_exit(mph);
+		overlay_hold_rele(odd);
+		return (ENOTSUP);
+	}
+	mutex_exit(&odd->odd_lock);
+
+	if (oip->oip_id == -1 && propid >= OVERLAY_DEV_NPROPS) {
+		ret = odd->odd_plugin->ovp_ops->ovpo_setprop(
+		    odd->odd_pvoid, oip->oip_name,
+		    oip->oip_value, oip->oip_size);
+		mac_perim_exit(mph);
+		overlay_hold_rele(odd);
+		return (ret);
 	} else if (oip->oip_id >= OVERLAY_DEV_NPROPS) {
 		uint_t id = oip->oip_id - OVERLAY_DEV_NPROPS;
 
@@ -2072,7 +2295,56 @@ overlay_i_setprop(void *karg, intptr_t arg, int mode, cred_t *cred,
 		}
 		overlay_setprop_dcid(odd, *dcidp);
 		break;
-
+	case OVERLAY_DEV_P_VL2_CACHE_SIZE:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		vl2szp = (uint64_t *)oip->oip_value;
+		if (*vl2szp != 0 && (*vl2szp < OVERLAY_VL2_CACHE_MIN ||
+		    *vl2szp > OVERLAY_VL2_CACHE_MAX)) {
+			ret = EINVAL;
+			break;
+		}
+		ret = overlay_setprop_vl2_cachesz(odd, *vl2szp);
+		break;
+	case OVERLAY_DEV_P_VL2_CACHE_A:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		vl2ap = (uint64_t *)oip->oip_value;
+		if (*vl2ap > OVERLAY_CACHE_MAX_A) {
+			ret = EINVAL;
+			break;
+		}
+		ret = overlay_setprop_vl2_cachea(odd, *vl2ap);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_SIZE:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		routeszp = (uint64_t *)oip->oip_value;
+		if (*routeszp != 0 && (*routeszp < OVERLAY_ROUTE_CACHE_MIN ||
+		   OVERLAY_ROUTE_CACHE_MAX)) {
+			ret = EINVAL;
+			break;
+		}
+		ret = overlay_setprop_route_cachesz(odd, *routeszp);
+		break;
+	case OVERLAY_DEV_P_ROUTE_CACHE_A:
+		if (oip->oip_size != sizeof (uint64_t)) {
+			ret = EINVAL;
+			break;
+		}
+		routeap = (uint64_t *)oip->oip_value;
+		if (*routeap > OVERLAY_CACHE_MAX_A) {
+			ret = EINVAL;
+			break;
+		}
+		ret = overlay_setprop_route_cachea(odd, *routeap);
+		break;
 	default:
 		ret = ENOENT;
 	}
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 15019297d5..171acd034f 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -1055,6 +1055,13 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		}
 	}
 
+	mutex_enter(&odd->odd_lock);
+	if (odd->odd_flags & OVERLAY_F_VARPD) {
+		mutex_exit(&odd->odd_lock);
+		overlay_hold_rele(odd);
+		return (EEXIST);
+	}
+
 	ott = kmem_cache_alloc(overlay_target_cache, KM_SLEEP);
 	ott->ott_flags = 0;
 	ott->ott_ocount = 0;
@@ -1069,7 +1076,7 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		int ret;
 
 		ret = qqcache_create(&ott->ott_u.ott_dyn.ott_dhash,
-		    OVERLAY_CACHE_SIZE, OVERLAY_CACHE_A, OVERLAY_HSIZE,
+		    odd->odd_vl2sz, odd->odd_vl2a, OVERLAY_HSIZE,
 		    overlay_mac_hash, overlay_mac_cmp,
 		    overlay_target_entry_l2qq_dtor,
 		    sizeof (overlay_target_entry_t),
@@ -1084,7 +1091,7 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		}
 
 		ret = qqcache_create(&ott->ott_u.ott_dyn.ott_l3dhash,
-		    OVERLAY_CACHE_SIZE, OVERLAY_CACHE_A, OVERLAY_HSIZE,
+		    odd->odd_routesz, odd->odd_routea, OVERLAY_HSIZE,
 		    overlay_ip_hash, overlay_ip_cmp,
 		    overlay_target_entry_l3qq_dtor,
 		    sizeof (overlay_target_entry_t),
@@ -1092,7 +1099,7 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		    offsetof(overlay_target_entry_t, ote_u.ote_vl3), KM_SLEEP);
 		if (ret != 0) {
 			mutex_exit(&odd->odd_lock);
-			qqcache_destroy(ott->ott_u.ott_dyn.ott_dhash);
+			qqcache_destroy(ott->ott_u.ott_dyn.ott_l3dhash);
 			kmem_cache_free(overlay_target_cache, ott);
 			overlay_hold_rele(odd);
 			return (ret);
@@ -1105,21 +1112,12 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		    sizeof (overlay_target_entry_t),
 		    offsetof(overlay_target_entry_t, ote_avllink));
 	}
-	mutex_enter(&odd->odd_lock);
-	if (odd->odd_flags & OVERLAY_F_VARPD) {
-		mutex_exit(&odd->odd_lock);
-		kmem_cache_free(overlay_target_cache, ott);
-		overlay_hold_rele(odd);
-		return (EEXIST);
-	}
 
 	odd->odd_flags |= OVERLAY_F_VARPD;
 	odd->odd_target = ott;
 	mutex_exit(&odd->odd_lock);
 
 	overlay_hold_rele(odd);
-
-
 	return (0);
 }
 
diff --git a/usr/src/uts/common/sys/overlay_impl.h b/usr/src/uts/common/sys/overlay_impl.h
index 557ad6f98c..28e80d6d58 100644
--- a/usr/src/uts/common/sys/overlay_impl.h
+++ b/usr/src/uts/common/sys/overlay_impl.h
@@ -120,6 +120,10 @@ typedef struct overlay_dev {
 	avl_node_t	odd_muxnode;		/* managed by mux */
 	overlay_target_t *odd_target;		/* See big theory statement */
 	uint32_t	odd_dcid;		/* RO if active else odd_lock */
+    uint32_t	odd_vl2sz;      /* protected by odd_lock */
+    uint32_t    odd_vl2a;       /* protected by odd_lock */
+    uint32_t	odd_routesz;    /* protected by odd_lock */
+    uint32_t    odd_routea;     /* protected by odd_lock */
 	uint8_t		odd_macaddr[ETHERADDRL]; /* RO same as odd_dcid */
 	char		odd_fmamsg[OVERLAY_STATUS_BUFLEN];	/* odd_lock */
 } overlay_dev_t;
