commit 547ee2dcf30499362d9ddf25eae6eadea0c2fc3a (refs/changes/56/156/2)
Author: Matt Smillie <matt.smillie@joyent.com>
Date:   2016-07-27T16:36:02-07:00 (3 years, 2 months ago)
    
    DOCKER-585: Support --network option in `docker run` for specifying networks

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 32e278d..1d205a2 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -215,40 +215,6 @@ function listNetworks(opts, params, callback) {
         callback);
 }
 
-/**
- * Add the user's default fabric network to the payload.  If they've specified
- * ports to publish, add an external network as well.
- */
-function addFabricNetworksToPayload(opts, container, payload, callback) {
-    var dc = opts.app.config.datacenterName;
-    var log = opts.log;
-    var requireExternal = false;
-
-    if (publishingPorts(container) || opts.fabricRequireExternal) {
-        requireExternal = true;
-    }
-
-    opts.app.ufds.getDcLocalConfig(opts.account.uuid, dc, function (err, conf) {
-        log.debug({err: err, conf: conf, account: opts.account.uuid},
-            'get DC local config');
-
-        if (err || !conf || !conf.defaultnetwork) {
-            callback(errors.ufdsErrorWrap(err,
-                'could not get default network'));
-            return;
-        }
-
-        payload.networks = [ {uuid: conf.defaultnetwork} ];
-
-        if (requireExternal) {
-            payload.networks.push({uuid: opts.config.overlay.externalPool});
-        }
-
-        payload.networks[payload.networks.length - 1].primary = true;
-        return callback();
-    });
-}
-
 /**
  * Add the "EXPOSE" firewall rules to the payload.  Note that we open up all
  * ports between docker hosts right now, since this is what other inter-host
@@ -559,60 +525,317 @@ function addRulesToFWAPI(opts, rules, payload, callback) {
     });
 }
 
-
 /**
- * Add networks to the payload: 'external' if no fabrics are enabled.  If
- * fabrics are enabled, then add the user's default fabric network.  If
- * fabrics are enabled and the container is publishing ports, also add the
- * NAT pool as a public-facing network.
+ * Add networks to the payload. Dispatches to one of these supported networking
+ * configurations:
+ *   1. without fabrics configured: external networking only.
+ *
+ *   With fabrics enabled:
+ *   2. 'bridge' or nothing specified provisions on the user's default network,
+ *      potentially also with the external network.
+ *   3. Specifying a network name will provision to the named *fabric* network.
+ *   4. Specifying a network id (or portion) will provision to that *fabric*
+ *      network.
+ *
+ *   Docker resolves name/id collisions in the following way:
+ *     - a name is preferred to a partial id
+ *     - a full id is preferred to a name
  */
 function addNetworksToPayload(opts, container, payload, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.config, 'opts.config');
     assert.object(opts.config.napi, 'opts.config.napi');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.config.overlay, 'opts.config.overlay');
+
+    assert.optionalString(opts.config.overlay.externalPool,
+        'opts.config.overlay.externalPool');
+    assert.optionalBool(opts.config.overlay.enabled,
+        'opts.config.overlay.enabled');
     assert.func(callback, 'callback');
 
-    if (opts.config.overlay.enabled) {
-        opts.log.debug('Fabrics configured: using for networking');
-        return addFabricNetworksToPayload(opts, container, payload, callback);
+    /*
+     * currently there are four network possibilities:
+     *  - no fabrics configured -> external network.
+     *  - fabrics configured and...
+     *    - 'bridge' or no network specified: default fabric
+     *    - 'fabric' name or id specified: that specific fabric
+     */
+    if (!opts.config.overlay.enabled) {
+        return externalNetworkByName(opts, payload, callback);
+    } else {
+        if (container.HostConfig.NetworkMode === 'bridge'
+            || container.HostConfig.NetworkMode === 'default'
+            || common.objEmpty(container.HostConfig.NetworkMode)) {
+            return defaultFabricNetwork(opts, payload, callback);
+        } else {
+            return namedNetwork(opts, container, payload, callback);
+        }
     }
+}
+
+/*
+ * When fabrics are not configured, we will use the named
+ * network, defaulting to 'external'.
+ */
+function externalNetworkByName(opts, payload, callback) {
+    assert.object(opts.config, 'opts.config');
+    assert.optionalString(opts.config.externalNetwork,
+        'opts.config.externalNetwork');
+    assert.object(opts.account, 'opts.account');
+    assert.string(opts.account.uuid, 'opts.account.uuid');
+    assert.object(payload, 'payload');
+    assert.func(callback, 'callback');
 
     var log = opts.log;
-    log.debug('Fabrics not configured: using external network');
+    var listParams = {
+        name: opts.config.externalNetwork || 'external',
+        fabric: false,
+        provisionable_by: opts.account.uuid
+    };
 
-    // No fabrics configured - fall back to provisioning on the external
-    // network
+    log.debug({ listParams: listParams },
+        format('Networks: fabrics not configured, using network %s',
+        listParams.name));
 
-    var netName = opts.config.externalNetwork || 'external';
-    listNetworks(opts, {name: netName}, function (err, networks) {
-        var external_net;
-        log.debug({err: err, res: networks}, 'list external networks');
+    listNetworks(opts, listParams, function (err, networks) {
+        log.debug({ err: err, res: networks },
+            format('Networks: listNetworks result for %s', listParams.name));
 
         if (err) {
-            callback(errors.napiErrorWrap(err, 'problem listing networks'));
+            callback(errors.napiErrorWrap(err,
+                format('Networks: problem listing network %s',
+                    listParams.name)));
+            return;
+        }
+
+        if (networks.length < 1) {
+            log.error({ networks: networks, params: listParams },
+                format('Networks: network %s provisionable by %s not found',
+                    listParams.name, listParams.provisionable_by));
+            callback(new errors.NetworkNotFoundError(listParams.name));
+            return;
+        }
+
+        payload.networks = [ { uuid: networks[0], primary: true} ];
+        callback();
+        return;
+    });
+}
+
+/*
+ * When fabrics are configured, but no specific network is supplied,
+ * or if 'bridge' is supplied, we will use the user's default fabric
+ * network, stored in UFDS.
+ *
+ * Additionally, if the user is publishing ports or we have the
+ * `fabricRequireExternal` option (currently used by docker build,
+ * see DOCKER-705), we will also attach to configured network pool
+ * (typically the external/public pool).
+ */
+function defaultFabricNetwork(opts, payload, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.app.config, 'opts.app.config');
+    assert.string(opts.app.config.datacenterName,
+        'opts.app.config.datacenterName');
+    assert.object(opts.log, 'opt.log');
+    assert.object(payload, 'payload');
+    assert.func(callback, 'callback');
+
+    var dc = opts.app.config.datacenterName;
+    var log = opts.log;
+
+    log.debug('Networks: using default fabric network');
+
+    opts.app.ufds.getDcLocalConfig(opts.account.uuid, dc, function (err, conf) {
+        log.debug({err: err, conf: conf, account: opts.account.uuid},
+            'Networks: get DC local config');
+
+        if (err || !conf || !conf.defaultnetwork) {
+            callback(errors.ufdsErrorWrap(err,
+                'Networks: could not get default network'));
             return;
         }
 
-        networks.forEach(function (n) {
-            if (!external_net
-                && n.name === netName) {
+        payload.networks = [ { uuid: conf.defaultnetwork, primary: true } ];
+
+        callback();
+        return;
+    });
+}
+
+/*
+ * When fabrics are configured and a specific network name is supplied,
+ * we will find and use the specified network.
+ */
+function namedNetwork(opts, container, payload, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.string(opts.account.uuid, 'opts.account.uuid');
+    assert.object(opts.config, 'opts.config');
+    assert.object(opts.config.napi, 'opts.config.napi');
+    assert.object(opts.log, 'opts.log');
+    assert.object(container, 'container');
+    assert.object(container.HostConfig, 'container.HostConfig');
+    assert.string(container.HostConfig.NetworkMode,
+        'container.HostConfig.NetworkMode');
+    assert.notEqual(container.HostConfig.NetworkMode, '',
+        'NetworkMode is empty');
+    assert.func(callback, 'callback');
+
+    // need to search on networks by: name, fabric-true, owner_uuid
+    var log = opts.log;
+    var query = container.HostConfig.NetworkMode;
+    var napi = getNapiClient(opts.config.napi);
+
+    // NOTE: the order of the functions in this parallel() call is significant;
+    // they are ordered by how docker prefers to resolve IDs:
+    // 1. exact id match
+    // 2. exact name match
+    // 3. partial id match
+    vasync.parallel({
+        funcs: [
+            function byExactId(cb) {
+                // length === 64, and 0..31 === 32..63, or it's an 'impossible'
+                // id under our double-uuid convention, and we can skip it.
+                if (query.substr(0, 32) !== query.substr(32)) {
+                    log.debug({ query: query },
+                        'Networks: impossible exactId: %s, skipping', query);
+                    setImmediate(cb, null, []);
+                    return;
+                }
+                var uuid = utils.shortNetworkIdToUuidPrefix(query);
+
+                // XXX - ldapEscape required to work around NAPI-367
+                var listParams = {
+                    uuid: utils.ldapEscape(uuid),
+                    fabric: true,
+                    owner_uuid: opts.account.uuid
+                };
+
+                napi.listNetworks(listParams,
+                    { headers: { 'x-request-id': opts.req_id }}, cb);
+            },
+            function byName(cb) {
+                var listParams = {
+                    name: query,
+                    fabric: true,
+                    owner_uuid: opts.account.uuid
+                };
 
-                external_net = n.uuid;
+                log.debug({ listParams: listParams },
+                    format('Networks: searching for network %s',
+                        listParams.name));
+
+                napi.listNetworks(listParams,
+                    { headers: {'x-request-id': opts.req_id }}, cb);
+            },
+            function byDockerId(cb) {
+                // we assume the 'double uuid' convention for networks here,
+                // that is, dockerId = (uuid + uuid).replace(/-/g, '').
+                // So if we have a query.length > 31, 32... must be a prefix of
+                // 0..31. If not, the id supplied is impossible in our system.
+                if (query.length >= 32) {
+                    // this must be a prefix of the first half of the input
+                    var secondHalf = query.substr(32);
+                    var firstHalf = query.substr(0, 31);
+
+                    if (secondHalf.length >= firstHalf.length
+                        || secondHalf !==
+                        firstHalf.substr(0, secondHalf.length)) {
+
+                        log.info({ query: query },
+                            'Networks: impossible network id %s, skipping',
+                            query);
+                        setImmediate(cb, null, []);
+                        return;
+                    }
+                }
+
+                // To perform the search, we transform the provided query to
+                // a (potentially partial) UUID, and perform a wildcard search
+                // on it.
+                // XXX - ldapEscape required to work around NAPI-367
+                var uuidSearchStr = utils.ldapEscape(
+                    utils.shortNetworkIdToUuidPrefix(query)) + '*';
+
+                var listParams = {
+                    uuid: uuidSearchStr,
+                    fabric: true,
+                    owner_uuid: opts.account.uuid
+                };
+
+                log.debug({ listParams: listParams },
+                    format('Networks: searching for network %s',
+                        listParams.uuid));
+
+                napi.listNetworks(listParams,
+                    { headers: {'x-request-id': opts.req_id }}, cb);
             }
-        });
+        ]
+    }, function _listedNetworks(err, results) {
+        // results.operations is ordered per the funcs array provided
+        // to vasync.parallel (see vasync docs). We can tolerate partial
+        // errors as long as they are lower in the preference chain.
+        // IOW, we callback with the err/result of the most-preferred
+        // search, and log any additional errors.
+        var bestMatch = results.operations.reduce(function (acc, op) {
+            if (acc.err || acc.result) {
+                return acc;
+            }
+            if (op.err) {
+                acc.err = op.err;
+                return acc;
+            }
+            // all match funcs are listNetworks, contract is to return an
+            // err (handled above) or array.
+            switch (op.result.length) {
+            case 0:
+                break;
+            case 1:
+                acc.result = op.result[0];
+                break;
+            default:
+                acc.err = new errors.AmbiguousDockerNetworkIdPrefixError(query);
+                break;
+            }
+            return acc;
+        }, { err: null, result: null });
+
+        if (bestMatch.err) {
+            // found an error before a result.
+            log.error({ err: bestMatch.err, query: query },
+                format('Networks: Error finding network to match %s', query));
+            callback(bestMatch.err);
+            return;
+        }
 
-        if (!external_net) {
-            callback(new errors.DockerError(
-                'unable to find "'+netName+'" network uuid'));
+        if (!bestMatch.err && !bestMatch.result) {
+            log.info({ query: query, user: opts.account.uuid },
+                format('Networks: no results for query %s', query));
+            callback(new errors.NetworkNotFoundError(query));
             return;
         }
 
-        payload.networks = [ {uuid: external_net, primary: true} ];
-        return callback();
+        if (!bestMatch.err && err) {
+            // found result before an error, but did have errs.
+            log.warn({ err: err },
+                'Networks: non-critical error searching NAPI');
+        }
+
+        log.debug({ network: bestMatch.result }, 'Networks: chose %s/%s',
+            bestMatch.result.name, bestMatch.result.uuid);
+
+        payload.networks = [ { uuid: bestMatch.result.uuid, primary: true } ];
+        log.debug({ payload: payload }, format('Networks: built payload'));
+
+        callback();
+        return;
     });
 }
 
+
 /**
  * Add a rule or rules to payload.firewall_rules
  */
@@ -1735,6 +1958,24 @@ function buildVmPayload(opts, container, callback) {
             addNetworksToPayload(opts, container, payload, cb);
         },
 
+        function addExternalNet(_, cb) {
+            if (publishingPorts(container) || opts.fabricRequireExternal) {
+                assert.object(opts.config.overlay, 'opts.config.overlay');
+                assert.string(opts.config.overlay.externalPool,
+                    'opts.config.overlay.externalPool');
+                // external must be primary.
+                payload.networks.forEach(function (nw) {
+                    delete nw.primary;
+                });
+
+                payload.networks.push(
+                    { uuid: opts.config.overlay.externalPool, primary: true });
+            }
+
+            cb();
+            return;
+        },
+
         function handleVolumesFrom(_, cb) {
             // This must happen after we've added the owner_uuid to the payload.
             // ...and is where we add --volumes-from volumes.
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index e7a756b..4feaa12 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -25,6 +25,38 @@ function vmUuidToShortDockerId(uuid) {
     return uuid.replace(/-/g, '').slice(0, 12);
 }
 
+function networkUuidToDockerId(uuid) {
+    return (uuid + uuid).replace(/-/g, '');
+}
+
+function shortNetworkIdToUuidPrefix(id) {
+    var partial = '';
+
+    // consider a uuid as eight groups of four chars, plus hyphens.
+    // concatenate those groups in reverse order, jumping to the
+    // appropriate starting group.
+
+    switch (Math.ceil(id.substr(0, 32).length / 4)) {
+    case 8: // 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'
+    case 7: // 'abcdabcd-abcd-abcd-abcd-abcdabcd'
+    case 6: // 'abcdabcd-abcd-abcd-abcd-abcd'
+        partial = '-' + id.substr(20, 12) + partial; /*jsl:fallthru*/
+    case 5: // 'abcdabcd-abcd-abcd-abcd'
+        partial = '-' + id.substr(16, 4) + partial;  /*jsl:fallthru*/
+    case 4: // 'abcdabcd-abcd-abcd'
+        partial = '-' + id.substr(12, 4) + partial;  /*jsl:fallthru*/
+    case 3: // 'abcdabcd-abcd'
+        partial = '-' + id.substr(8, 4) + partial;   /*jsl:fallthru*/
+    case 2: // 'abcdabcd'
+    case 1: // 'abcd'
+        partial = id.substr(0, 8) + partial;         /*jsl:fallthru*/
+    case 0:
+    default:
+        break;
+    }
+    return partial;
+}
+
 /**
  * Docker containers are stored on the VM "tags" field
  * (https://github.com/joyent/sdc-vmapi/blob/master/docs/index.md#vm-metadata).
@@ -943,16 +975,28 @@ function compressPorts(ports) {
     return ranges;
 }
 
+/*
+ * Escapes strings for ldap filters.
+ * See: pfmooney/node-ldap-filter/lib/substr_filter.js#L12-L15
+ */
+// XXX - workaround for NAPI-367
+function ldapEscape(str) {
+    /* JSSTYLED */
+    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
+}
 
 // ---- exports
 
 module.exports = {
     compressPorts: compressPorts,
     vmUuidToShortDockerId: vmUuidToShortDockerId,
+    networkUuidToDockerId: networkUuidToDockerId,
+    shortNetworkIdToUuidPrefix: shortNetworkIdToUuidPrefix,
     getNormalizedFilters: getNormalizedFilters,
     getPublishedPorts: getPublishedPorts,
     isValidDockerConatinerName: isValidDockerConatinerName,
     imgobjToInspect: imgobjToInspect,
     vmobjToContainer: vmobjToContainer,
-    vmobjToInspect: vmobjToInspect
+    vmobjToInspect: vmobjToInspect,
+    ldapEscape: ldapEscape
 };
diff --git a/lib/errors.js b/lib/errors.js
index a330f3b..85450a3 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -341,6 +341,54 @@ AmbiguousDockerContainerIdPrefixError.statusCode = 404;
 AmbiguousDockerContainerIdPrefixError.description =
     'A Docker container id prefix matches more than one container.';
 
+/*
+ * An error indicating that a supplied query has matched more than one docker
+ * network. We expect this to happen only when the user has specified a prefix
+ * of an id that matches more than one of their provisionable networks.
+ */
+function AmbiguousDockerNetworkIdPrefixError(idPrefix, networks) {
+    assert.string(idPrefix, 'idPrefix');
+    assert.optionalArrayOfString(networks, 'networks');
+
+    var message = fmt('multiple networks match prefix %s', idPrefix);
+    if (networks && networks.length > 0) {
+        message += ': ' + networks.map(function (net) {
+            return fmt('%s/%s', net.name, net.uuid);
+        }).join(', ');
+    }
+    _DockerBaseError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: message
+    });
+}
+util.inherits(AmbiguousDockerNetworkIdPrefixError, _DockerBaseError);
+AmbiguousDockerNetworkIdPrefixError.prototype.name
+    = 'AmbiguousDockerNetworkIdPrefixError';
+AmbiguousDockerNetworkIdPrefixError.restCode
+    = 'AmbiguousDockerNetworkIdPrefix';
+AmbiguousDockerNetworkIdPrefixError.statusCode = 404;
+AmbiguousDockerNetworkIdPrefixError.description
+    = 'A Docker network id prefix matches more than one network.';
+
+/*
+ * Network not found.
+ */
+function NetworkNotFoundError(network) {
+    assert.string(network, 'network');
+
+    var message = fmt('network %s not found', network);
+    _DockerBaseError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: message
+    });
+}
+util.inherits(NetworkNotFoundError, _DockerBaseError);
+NetworkNotFoundError.prototype.name = 'NetworkNotFoundError';
+NetworkNotFoundError.prototype.restCode = 'ResourceNotFound';
+NetworkNotFoundError.statusCode = 404;
+NetworkNotFoundError.description = 'Network not found';
 
 /**
  * An error used to expose the error from a node-sdc-clients API request.
@@ -684,7 +732,9 @@ module.exports = {
     AmbiguousDockerImageIdError: AmbiguousDockerImageIdError,
     AmbiguousDockerContainerIdPrefixError:
         AmbiguousDockerContainerIdPrefixError,
+    AmbiguousDockerNetworkIdPrefixError: AmbiguousDockerNetworkIdPrefixError,
     FileNotFoundError: FileNotFoundError,
+    NetworkNotFoundError: NetworkNotFoundError,
     PathNotDirectoryError: PathNotDirectoryError,
 
     cnapiErrorWrap: cnapiErrorWrap,
diff --git a/lib/validate.js b/lib/validate.js
index e968f17..396c76b 100644
--- a/lib/validate.js
+++ b/lib/validate.js
@@ -226,6 +226,50 @@ function assertGelfAddress(arg, name) {
     }
 }
 
+/*
+ * Docker docs: Supported standard values are:
+ * bridge, host, none, and container:<name|id>,
+ * Any other value is taken as a custom network's
+ * name or id to which the provisioning container
+ * should connect.
+ *
+ * We support: bridge, other.
+ */
+function assertNetworkMode(networkMode, name) {
+    if (networkMode === 'bridge') {
+        return;
+    }
+
+    if (networkMode === 'host' || networkMode === 'none') {
+        throw new errors.NotImplementedError(
+            fmt('NetworkMode %s is not supported', networkMode));
+    }
+
+    if (networkMode.match(/^container:/)) {
+        throw new errors.NotImplementedError(
+            'Container networking is not supported');
+    }
+}
+
+function assertNetworkingParams(config) {
+    if (!config.NetworkMode
+        || config.NetworkMode === 'bridge'
+        || config.NetworkMode === 'default') {
+        return;
+    }
+
+    /* BEGIN JSSTYLED */
+    /*
+     * link behaviour with user-defined networking is not yet
+     * supported, see:
+     * https://docs.docker.com/v1.10/engine/userguide/networking/work-with-networks/#linking-containers-in-user-defined-networks
+     * https://docs.docker.com/v1.10/engine/userguide/networking/default_network/dockerlinks/
+     */
+    /* END JSSTYLED */
+    if (config.Links && config.Links.length > 0) {
+        throw new errors.NotImplementedError('user-defined networking links');
+    }
+}
 
 function assertPortBindings(bindings, name) {
     for (var b in bindings) {
@@ -384,6 +428,8 @@ function validateCreateContainer(req, res, next) {
         assertOptionalArrayOfString(container.Env, 'Env');
         assertOptionalArrayOfString(container.Entrypoint, 'Entrypoint');
 
+        assertOptionalArrayOfString(container.HostConfig.Links,
+            'HostConfig.Links');
         assertOptionalArrayOfString(container.HostConfig.ExtraHosts,
             'HostConfig.Entrypoint');
         assertOptionalBool(container.HostConfig.PublishAllPorts,
@@ -392,6 +438,16 @@ function validateCreateContainer(req, res, next) {
             'HostConfig.PortBindings');
         assertOptionalObject(container.HostConfig.LogConfig,
             'HostConfig.LogConfig');
+        assertOptionalString(container.HostConfig.NetworkMode,
+            'HostConfig.NetworkMode');
+
+        if (container.HostConfig.NetworkMode) {
+            assertNetworkMode(container.HostConfig.NetworkMode,
+                'HostConfig.NetworkMode');
+        }
+
+        // ensures mutually-compatible networking params.
+        assertNetworkingParams(container.HostConfig);
 
         if (container.HostConfig.PortBindings) {
             assertPortBindings(container.HostConfig.PortBindings,
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index bcbab29..da3c40f 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -14,6 +14,7 @@
 
 var exec = require('child_process').exec;
 var format = require('util').format;
+var libuuid = require('libuuid');
 var test = require('tape');
 var util = require('util');
 var vasync = require('vasync');
@@ -36,6 +37,8 @@ var STATE = {
 };
 var CONFIG = configLoader.loadConfigSync({log: STATE.log});
 var VMAPI;
+var NAPI;
+var FABRICS = false;
 
 
 // --- Tests
@@ -90,6 +93,15 @@ test('setup', function (tt) {
         });
     });
 
+    // init the napi client to create a fabric to test against.
+    tt.test('napi client init', function (t) {
+        h.createNapiClient(function (err, client) {
+            t.ifErr(err, 'napi client');
+            NAPI = client;
+            t.end();
+        });
+    });
+
     tt.test('pull nginx image', function (t) {
         var url = '/images/create?fromImage=nginx%3Alatest';
         DOCKER_ALICE.post(url, function (err, req, res) {
@@ -100,7 +112,6 @@ test('setup', function (tt) {
 
 });
 
-
 test('api: create with non-string label values (DOCKER-737)', function (t) {
     var payload = {
         // Boilerplate
@@ -334,6 +345,293 @@ test('api: create with env var that has no value (DOCKER-741)', function (tt) {
     });
 });
 
+test('ensure fabrics enabled', function (tt) {
+    tt.test('fabric configuration', function (t) {
+        var listOpts = {};
+        var listParams = {};
+        NAPI.listFabricVLANs(ALICE.account.uuid, listOpts, listParams,
+            function (err, vlans) {
+                if (err) {
+                    FABRICS = false;
+                    if (err.code !== 'PreconditionRequiredError') {
+                        t.ifErr(err);
+                    }
+                } else {
+                    FABRICS = true;
+                }
+                t.end();
+        });
+    });
+});
+
+
+/*
+ * Tests for `docker run --net`
+ *
+ * Of particular interest is whether we can appropriately disambiguate the
+ * user-supplied network name/id. The docker heuristic appears to be:
+ * 1. exact id match
+ * 2. exact name match
+ * 3. any partial id match
+ * See lib/backends/sdc/containers.js for implementation.
+ */
+/*
+ * XXX - pending NAPI-258, we are creating NAT zones, a fabric vlan, and
+ * several fabric networks that can't be easily cleaned up. They should
+ * still be re-usable for repeated test runs, but particularly unlucky
+ * partial failures in the tests *may* require some manual cleanup:
+ * - delete NAT zones for ALICE & the fabric networks
+ * - delete fabric networks
+ * - delete fabric vlan
+ */
+test('create with NetworkMode (docker run --net=)', function (tt) {
+    // set fabric status
+
+    var fVlan;
+    var fNetwork1;
+    var fNetwork2;
+    var fNetwork3;
+
+    if (!FABRICS) {
+        tt.comment('Fabrics not enabled, skipping tests that require them.');
+        tt.end();
+        return;
+    }
+
+    tt.test('fabric vlan setup', function (t) {
+        // create a new one.
+        var fabricParams = {
+            name: 'sdcdockertest_apicreate_vlan4',
+            description: 'integration test fixture',
+            vlan_id: 4
+        };
+        h.getOrCreateFabricVLAN(NAPI, ALICE.account.uuid, fabricParams,
+            function (err, vlan) {
+                t.ifErr(err, 'create fabric vlan');
+                fVlan = vlan;
+                t.end();
+                return;
+            }
+        );
+    });
+
+    tt.test('fabric network setup', function (t) {
+        var nw1uuid = libuuid.create();
+
+        // nw2's name is deliberately ambiguous with a short version of nw1's
+        // id. The exact name (nw2) should be preferred to the partial id.
+        var nw2name = nw1uuid.replace(/-/g, '').substr(0, 12);
+
+        // nw3's name is identical to nw1's full id. The full exact id should
+        // be preferred over a name, so nw1 should be picked.
+        var nw3name = (nw1uuid + nw1uuid).replace(/-/g, '');
+
+        var nw1params = {
+            name: 'sdcdockertest_apicreate_net1',
+            subnet: '10.0.8.0/24',
+            provision_start_ip: '10.0.8.2',
+            provision_end_ip: '10.0.8.254',
+            uuid: nw1uuid,
+            gateway: '10.0.8.1',
+            resolvers: ['8.8.8.8', '8.8.4.4']
+        };
+
+        // name deliberately ambiguous with a short version of nw1's docker id
+        var nw2params = {
+            name: nw2name,
+            subnet: '10.0.9.0/24',
+            provision_start_ip: '10.0.9.2',
+            provision_end_ip: '10.0.9.254',
+            gateway: '10.0.9.1',
+            resolvers: ['8.8.8.8', '8.8.4.4']
+        };
+
+        // name deliberately identical to nw1's docker id
+        var nw3params = {
+            name: nw3name,
+            subnet: '10.0.10.0/24',
+            provision_start_ip: '10.0.10.2',
+            provision_end_ip: '10.0.10.254',
+            gateway: '10.0.10.1',
+            resolvers: ['8.8.8.8', '8.8.4.4']
+        };
+
+        vasync.pipeline({
+            funcs: [
+                function fnw1(_, cb) {
+                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
+                        fVlan.vlan_id, nw1params, function (err, network) {
+                            if (err) {
+                                return cb(err);
+                            }
+                            nw2params.name =
+                                network.uuid.replace(/-/g, '').substr(0, 12);
+                            nw3params.name = (network.uuid + network.uuid)
+                                .replace(/-/g, '');
+                            return cb(null, network);
+                        }
+                    );
+                },
+                function fnw2(_, cb) {
+                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
+                        fVlan.vlan_id, nw2params, cb);
+                },
+                function fnw3(_, cb) {
+                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
+                        fVlan.vlan_id, nw3params, cb);
+                }
+            ]
+        }, function (err, results) {
+            t.ifErr(err, 'create networks');
+            if (err) {
+                t.end();
+                return;
+            }
+            fNetwork1 = results.operations[0].result;
+            fNetwork2 = results.operations[1].result;
+            fNetwork3 = results.operations[2].result;
+
+            t.end();
+        });
+    });
+
+    // attempt a create with a name.
+    tt.test('create with a network name', function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': fNetwork1.name },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            t.ifErr(err, 'create NetworkMode: networkName');
+            var nics = result.vm.nics;
+            t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+    });
+
+    tt.test('create with a complete network id', function (t) {
+        var fullId = (fNetwork1.uuid + fNetwork1.uuid).replace(/-/g, '');
+
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': fullId },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var nics = result.vm.nics;
+            t.equal(nics.length, 1, 'only one nic');
+            t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+    });
+
+    tt.test('create with partial network id', function (t) {
+        var partialId = (fNetwork1.uuid + fNetwork1.uuid).replace(/-/g, '');
+        partialId = partialId.substr(0, 10);
+
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': partialId },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var nics = result.vm.nics;
+            t.equal(nics.length, 1, 'only one nic');
+            t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+    });
+
+    tt.test('prefer name over partial id', function (t) {
+        // fNetwork2 is named using a partial id from fNetwork1.
+
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': fNetwork2.name },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var nics = result.vm.nics;
+            t.equal(nics.length, 1, 'only one nic');
+            t.equal(nics[0].network_uuid, fNetwork2.uuid, 'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+    });
+
+    tt.test('prefer full id over name', function (t) {
+        // fNetwork3 is named with the full dockerId of fNetwork1.
+
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': fNetwork3.name },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var nics = result.vm.nics;
+            t.equal(nics.length, 1, 'only one nic');
+            t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+
+    });
+
+    tt.test('create with a network that doesn\'t exist', function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': 'netmodefoobar' },
+            expectedErr: '(Error) network netmodefoobar not found',
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            t.ok(err, 'should err on create');
+            t.end();
+        }
+    });
+});
 
 test('cleanup', function (tt) {
     tt.test('delete nginx image', function (t) {
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 6743d3d..57beb0e 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -35,7 +35,8 @@ var CONFIG = {
     fwapi_url: process.env.FWAPI_URL,
     papi_url: process.env.PAPI_URL,
     sapi_url: process.env.SAPI_URL,
-    vmapi_url: process.env.VMAPI_URL
+    vmapi_url: process.env.VMAPI_URL,
+    napi_url: process.env.NAPI_URL
 };
 var p = console.error;
 var UA = 'sdcdockertest';
@@ -1222,7 +1223,21 @@ function createVmapiClient(callback) {
     });
 }
 
+/**
+ * Get a simple restify JSON client to NAPI.
+ */
+function createNapiClient(callback) {
+    assert.func(callback, 'callback');
 
+    createClientOpts('napi', function (err, opts) {
+        if (err) {
+            return callback(err);
+        }
+
+        callback(null, new sdcClients.NAPI(opts));
+        return;
+    });
+}
 
 /**
  * Test the given Docker 'info' API response.
@@ -1637,6 +1652,52 @@ function didRestifyHandlerRun(reqId, handlerName, callback) {
     });
 }
 
+/*
+ * Gets or creates a fabric VLAN for use in testing.
+ */
+function getOrCreateFabricVLAN(client, userUuid, fabricParams, callback) {
+    assert.object(client, 'napi client');
+    assert.uuid(userUuid, 'user uuid');
+    assert.object(fabricParams, 'fabricParams');
+
+    client.getFabricVLAN(userUuid, fabricParams.vlan_id, {},
+        function (err, vlan) {
+            if (err && err.restCode !== 'ResourceNotFound') {
+                return callback(err);
+            } else if (vlan) {
+                return callback(null, vlan);
+            }
+            client.createFabricVLAN(userUuid, fabricParams, callback);
+        }
+    );
+}
+
+/*
+ * Gets or creates a fabric network for use in testing; based on the
+ * network *name*.
+ */
+function getOrCreateFabricNetwork(client, userUuid, vlan_id, params, callback) {
+    assert.object(client, 'napi client');
+    assert.uuid(userUuid, 'user uuid');
+    assert.number(vlan_id, 'vlan_id');
+    assert.object(params, 'network params');
+
+    var listParams = {
+        name: params.name
+    };
+    client.listFabricNetworks(userUuid, vlan_id, listParams,
+        function (err, networks) {
+            if (err) {
+                return callback(err);
+            }
+            if (networks.length !== 0) {
+                return callback(null, networks[0]);
+            }
+            client.createFabricNetwork(userUuid, vlan_id, params, callback);
+        }
+    );
+}
+
 // --- exports
 
 module.exports = {
@@ -1645,11 +1706,14 @@ module.exports = {
     createFwapiClient: createFwapiClient,
     createPapiClient: createPapiClient,
     createVmapiClient: createVmapiClient,
+    createNapiClient: createNapiClient,
     dockerIdToUuid: sdcCommon.dockerIdToUuid,
     initDockerEnv: initDockerEnv,
     listContainers: listContainers,
     createDockerContainer: createDockerContainer,
     buildDockerContainer: buildDockerContainer,
+    getOrCreateFabricVLAN: getOrCreateFabricVLAN,
+    getOrCreateFabricNetwork: getOrCreateFabricNetwork,
 
     getDockerEnv: getDockerEnv,
 
diff --git a/test/runtest.common b/test/runtest.common
index a768623..ddd0cf8 100644
--- a/test/runtest.common
+++ b/test/runtest.common
@@ -43,6 +43,8 @@ export VMAPI_URL="http://$(vmadm lookup -j alias=vmapi0 | json 0.nics \
     | json -c 'this.nic_tag==="admin"' 0.ip)"
 export SAPI_URL="http://$(vmadm lookup -j alias=sapi0 | json 0.nics \
     | json -c 'this.nic_tag==="admin"' 0.ip)"
+export NAPI_URL="http://$(vmadm lookup -j alias=napi0 | json 0.nics \
+    | json -c 'this.nic_tag==="admin"' 0.ip)"
 
 # Docker CLI versions for testing:
 # 1. 'DOCKER_AVAILABLE_CLI_VERSIONS' is the set of 'docker' CLI versions we
