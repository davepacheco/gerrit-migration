commit 68c19e00b9bcccd25ebe94f547d7c98063ce4e5a (refs/changes/27/3427/1)
Author: Trent Mick <trentm@gmail.com>
Date:   2018-02-20T14:16:41-08:00 (1 year, 8 months ago)
    
    TRITON-140 improve config-agent logging to specify why each SAPI GetConfig call

diff --git a/agent.js b/agent.js
index 25736f8..6485fea 100644
--- a/agent.js
+++ b/agent.js
@@ -20,7 +20,6 @@ var assert = require('assert-plus');
 var async = require('async');
 var fs = require('fs');
 var optimist = require('optimist');
-var uuidv4 = require('uuid/v4');
 var util = require('./lib/common/util');
 
 var Agent = require('./lib/agent/agent');
@@ -103,19 +102,7 @@ var autoMetadata = config.autoMetadata = {};
  */
 function startPeriodicRefresh() {
 	function checkOnce() {
-		var startTime = Date.now();
-		var reqId = uuidv4();
-		log.trace({req_id: reqId}, 'start periodic check');
-
 		agent.checkAndRefresh(function doneCheck(err) {
-			log.debug(
-				{
-					err: err,
-					req_id: reqId,
-					elapsedMs: Date.now() - startTime
-				},
-				'done periodic check');
-
 			setTimeout(checkOnce, config.pollInterval);
 		});
 	}
diff --git a/lib/agent/agent.js b/lib/agent/agent.js
index 2f2b3da..870e46d 100644
--- a/lib/agent/agent.js
+++ b/lib/agent/agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -51,6 +51,7 @@ var once = require('once');
 var path = require('path');
 var sdc = require('sdc-clients');
 var sprintf = require('util').format;
+var uuidv4 = require('uuid/v4');
 var vasync = require('vasync');
 
 
@@ -297,98 +298,122 @@ Agent.prototype.initInstance = function initInstance(instance, cb) {
 };
 
 Agent.prototype.checkAndRefresh = function checkAndRefresh(cb) {
+	assert.func(cb, 'cb');
+
 	var self = this;
+	var startTime = Date.now();
+	var log = self.log.child({req_id: uuidv4()}, true);
+
+	log.trace('checkAndRefresh: start');
+
 	vasync.forEachParallel({
-		func: function (instance, subsubcb) {
-			self.checkAndRefreshInstance.call(self, instance,
-								subsubcb);
+		func: function checkAnInst(inst, next) {
+			self.checkAndRefreshInst({
+				inst: inst,
+				log: log
+			}, next);
 		},
 		inputs: self.instances
-	}, function (err) {
-		if (cb)
-			cb(err);
+	}, function doneCheckInsts(err) {
+		var elapsedMs = Date.now() - startTime;
+		if (err) {
+			log.warn({err: err, elapsedMs: elapsedMs},
+				'checkAndRefresh: finish: failure');
+		} else {
+			log.debug({elapsedMs: elapsedMs},
+				'checkAndRefresh: finish: success');
+		}
+		cb(err);
 	});
 };
 
-Agent.prototype.checkAndRefreshInstance =
-function checkAndRefreshInstance(instance, cb) {
+Agent.prototype.checkAndRefreshInst = function checkAndRefreshInst(opts, cb) {
+	assert.object(opts, 'opts');
+	assert.uuid(opts.inst, 'opts.inst');
+	assert.object(opts.log, 'opts.log');
+	assert.uuid(opts.log.fields.req_id, 'opts.log.fields.req_id');
+	assert.func(cb, 'cb');
+
 	var self = this;
-	var log = self.log;
-	var sapi = self.sapi;
+	var inst = opts.inst;
+	var log = opts.log.child({inst: inst}, true);
 
-	var opts = {};
-	if (self.etags[instance]) {
-		opts.headers = { 'if-none-match': self.etags[instance] };
+	var reqOpts = {
+		headers: {
+			'x-request-id': log.fields.req_id
+		}
+	};
+	if (self.etags[inst]) {
+		reqOpts.headers['if-none-match'] = self.etags[inst];
 	}
 
-	sapi.getConfig(instance, opts, function (err, config, req, res) {
+	log.debug('call SAPI GetConfig');
+	self.sapi.getConfig(inst, reqOpts, function (err, config, req, res) {
 		if (err) {
-			log.error(err, 'failed to get config');
-			return (cb(err));
+			log.error(err, 'SAPI GetConfig error');
+			cb(err);
+			return;
 		}
 
-		log.trace({ config: config }, 'read config from SAPI');
 
 		if (res.statusCode === 304) {
-			log.debug('configuration for instance %s has not '
-				+ 'changed', instance);
-			return (cb());
+			log.debug('config has not changed (304 response)');
+			cb();
+			return;
 		}
+		log.trace({config: config}, 'SAPI GetConfig result');
 
-		// Only write etags if SAPI is returning them
+		// Only write etags if SAPI is returning them.
 		if (res.headers.etag) {
-			self.etags[instance] = res.headers.etag;
+			self.etags[inst] = res.headers.etag;
 		}
 
-		return (refresh(config));
+		refresh(config);
 	});
 
 	function refresh(config) {
 		async.waterfall([
-			function resolveLocalManifests(subcb) {
-				var manifests = resolveManifests.call(self,
+			function resolveLocalManifests(next) {
+				var manifests = self.resolveManifests(
+					log,
 					config.manifests,
-					self.localManifests[instance] || []);
+					self.localManifests[inst] || []);
 
-				return (subcb(null,
-					manifests,
-					config.metadata));
+				next(null, manifests, config.metadata);
 			},
-			function renderFiles(manifests, metadata, subcb) {
+			function renderFiles(manifests, metadata, next) {
 				assert.object(manifests, 'manifests');
 				assert.object(metadata, 'metadata');
 
-				log.debug({
-					manifests: manifests,
-					metadata: metadata
-				}, 'read manifests and metadata');
-
 				Object.keys(manifests).forEach(function (name) {
-					self.renderConfigFile(manifests[name],
+					self.renderConfigFile(
+						log.child({manifest: name}, true),
+						manifests[name],
 						metadata);
 				});
 
-				return (subcb(null, manifests));
+				next(null, manifests);
 			},
-			function writeFiles(manifests, subcb) {
+			function writeFiles(manifests, next) {
 				assert.object(manifests, 'manifests');
 
 				vasync.forEachParallel({
-					func: function (name, subsubcb) {
-						writeConfigFile.call(self,
+					func: function (name, nextManifest) {
+						self.writeConfigFile(
+							log.child({manifest: name}, true),
 							manifests[name],
-							subsubcb);
+							nextManifest);
 					},
 					inputs: Object.keys(manifests)
 				}, function (err) {
-					return (subcb(err));
+					return (next(err));
 				});
 			}
 		], function (err, results) {
 			if (err) {
 				log.error(err,
 						'failed to write files for ' +
-						'instance %s', instance);
+						'instance %s', inst);
 			}
 			cb(err);
 		});
@@ -482,9 +507,8 @@ function readManifests(dir, cb) {
  * to be used for this zone's configuration.  Any local manifest with the same
  * name as a SAPI manifest will override that SAPI manifest.
  */
-function resolveManifests(sapiManifests, localManifests) {
-	var log = this.log;
-
+Agent.prototype.resolveManifests =
+function resolveManifests(log, sapiManifests, localManifests) {
 	assert.arrayOfObject(sapiManifests, 'sapiManifests');
 	assert.arrayOfObject(localManifests, 'localManifests');
 
@@ -546,20 +570,18 @@ function resolveManifests(sapiManifests, localManifests) {
 		'resolved SAPI and local manifests');
 
 	return (manifests);
-}
-
+};
 
-function runPostCommand(post_cmd, cb) {
-	var self = this;
-	var log = self.log;
 
+Agent.prototype.runPostCommand = function runPostCommand(log, post_cmd, cb) {
+	assert.object(log, 'log');
 	assert.string(post_cmd, 'post_cmd');
 
-	log.info({ post_cmd: post_cmd }, 'running post_cmd');
+	log.info({post_cmd: post_cmd}, 'running post_cmd');
 
 	exec(post_cmd, function (err, stdout, stderr) {
 		if (err) {
-			log.error({
+			log.warn({
 				err: err,
 				stdout: stdout,
 				stderr: stderr,
@@ -573,30 +595,26 @@ function runPostCommand(post_cmd, cb) {
 
 		return (cb(err));
 	});
-}
+};
 
 
 /*
  * Render a configuration file from its manifest.
  */
 Agent.prototype.renderConfigFile =
-function renderConfigFile(manifest, rawMetadata)
+function renderConfigFile(log, manifest, rawMetadata)
 {
 	var self = this;
-	var log = self.log;
 
 	assert.object(manifest, 'manifest');
 	assert.string(manifest.template, 'manifest.template');
 	assert.object(rawMetadata, 'rawMetadata');
 	var metadata = objCopy(rawMetadata);
 
-	log.debug('rendering configuration file from manifest %s',
-		manifest.name);
-
 	Object.keys(self.localMetadata).forEach(function (key) {
 		if (metadata[key]) {
-			log.debug('overwriting metadata key "%s" with local ' +
-				'metadata', key);
+			log.debug('overwriting metadata key "%s" with ' +
+				'localMetadata', key);
 		}
 		metadata[key] = self.localMetadata[key];
 	});
@@ -607,35 +625,28 @@ function renderConfigFile(manifest, rawMetadata)
 	}
 	metadata.auto = self.autoMetadata;
 
-	log.debug({ metadata: metadata }, 'using metadata to render file');
-
 	var contents = null;
 	try {
 		contents = hogan.compile(manifest.template).render(metadata);
 	} catch (e) {
 		log.error('invalid hogan template: ' + e.message);
 	}
-
 	if (!contents) {
 		log.error('failed to render configuration file');
-	} else {
-		log.debug({ contents: contents },
-			'rendered configuration file');
 	}
 
 	manifest.contents = contents;
 
-	log.debug({ contents: contents }, 'generated contents for manifest %s',
-		manifest.name);
+	log.debug('rendered manifest file contents');
 
 	return (manifest);
 };
 
 
-function writeConfigFile(manifest, cb) {
+Agent.prototype.writeConfigFile = function writeConfigFile(log, manifest, cb) {
 	var self = this;
-	var log = self.log;
 
+	assert.object(log, 'log');
 	assert.object(manifest, 'manifest');
 	assert.string(manifest.name, 'manifest.name');
 	assert.string(manifest.path, 'manifest.path');
@@ -674,7 +685,7 @@ function writeConfigFile(manifest, cb) {
 		},
 		function (subcb) {
 			if (existing && contents === existing) {
-				log.debug('file %s unchaged; not updating ' +
+				log.debug('file %s unchanged; not updating ' +
 					'file', manifest.path);
 				return (subcb(null, false));
 			}
@@ -692,8 +703,7 @@ function writeConfigFile(manifest, cb) {
 					return (subcb(err));
 				}
 
-				log.info('updated file %s for manifest %s',
-					manifest.path, manifest.name);
+				log.info('updated file %s', manifest.path);
 
 				return (subcb(null, true));
 			});
@@ -704,16 +714,16 @@ function writeConfigFile(manifest, cb) {
 			assert.bool(updated, 'updated');
 			assert.func(subcb, 'subcb');
 
-			if (!updated)
+			if (!updated) {
 				return (subcb(null));
+			}
 
 			if (!manifest.post_cmd) {
-				log.debug('no post command to run for ' +
-					'manifest %s', manifest.name);
+				log.trace('no post_cmd');
 				return (subcb(null));
 			}
 
-			runPostCommand.call(self, manifest.post_cmd,
+			self.runPostCommand(log, manifest.post_cmd,
 			function (err) {
 				/*
 				 * If the post command fails, it's not a fatal
@@ -733,7 +743,7 @@ function writeConfigFile(manifest, cb) {
 
 		return (cb(null));
 	});
-}
+};
 
 module.exports = Agent;
 /* vim: set noet sw=4 sts=4 ts=4: */
