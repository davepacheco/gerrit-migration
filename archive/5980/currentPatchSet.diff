commit ca600b1d450606310a3bc05ea3573aacd0e6c826
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2019-04-05T15:43:21+00:00 (6 months ago)
    
    TRITON-9 affinity is racy
    Reviewed by: Orlando Vazquez <orlando@joyent.com>
    Reviewed by: Pedro Palaz√≥n Candel <pedro@joyent.com>
    Approved by: Orlando Vazquez <orlando@joyent.com>

diff --git a/lib/backends/sdc/affinity.js b/lib/backends/sdc/affinity.js
index b35381a..34501e8 100644
--- a/lib/backends/sdc/affinity.js
+++ b/lib/backends/sdc/affinity.js
@@ -6,10 +6,11 @@
 
 /* BEGIN JSSTYLED */
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  * Container affinity support (i.e. the rules/hints for deciding to what
- * server a new container is provisioned).
+ * server a new container is provisioned). Parses affinity strings into an
+ * affinity format sdc-designation understands.
  *
  * The goal is to provide the affinity features that Docker Swarm provides
  * with its "affinity" container filters, described here:
@@ -37,24 +38,6 @@
  *   Note: We will skip this one. For Triton an image is present on all nodes
  *   in the DC. Until a possible future when Triton acts as a Swarm master
  *   for multiple DCs, the semantics of this affinity don't apply.
- *
- * # Affinities -> Locality Hints
- *
- * Triton's feature for a VM creation providing affinity is "locality hints".
- * Therefore we'll be translating given Docker affinities (via both
- * the '-e' envvar syntax and the newer '--label' syntax) to Triton's
- * "locality hints". See here for the locality hints big-theory comment
- * and implementation:
- *      https://github.com/joyent/sdc-designation/blob/master/lib/algorithms/soft-filter-locality-hints.js
- *
- * # Limitations
- *
- * - sdc-designation's locality hints cannot handle mixed strict and non-strict
- *   rules. E.g.:
- *      docker run -e affinity:container==db0 -e 'affinity:container!=db1' ...
- *   To support that we'd need to extend the "locality" data structure format.
- *   Currently we just drop the non-strict rules when hitting this. An
- *   alternative would be to error out.
  */
 /* END JSSTYLED */
 
@@ -62,7 +45,6 @@ var assert = require('assert-plus');
 var format = require('util').format;
 var strsplit = require('strsplit');
 var vasync = require('vasync');
-var XRegExp = require('xregexp');
 
 var common = require('../../common');
 var errors = require('../../errors');
@@ -214,7 +196,6 @@ function _parseFilterExpr(s) {
             && expr.value[expr.value.length - 1] === '/')
         {
             expr.valueType = 're';
-            expr.valueRe = XRegExp(expr.value.slice(1, -1));
         } else if (expr.value.indexOf('*') !== -1) {
             expr.valueType = 'glob';
         } else {
@@ -227,11 +208,6 @@ function _parseFilterExpr(s) {
         + 'expected one of %s: %j', operators.join(', '), s));
 }
 
-function _strFromFilterExpr(expr) {
-    return format('%s%s%s%s', expr.key, expr.operator, expr.isSoft ? '~' : '',
-        expr.value);
-}
-
 /**
  * Parse an affinity string from a `docker run` "com.docker.swarm.affinities"
  * label.
@@ -258,317 +234,10 @@ function _affinityStrsFromLabel(label) {
 }
 
 
-/*
- * Find the VM(s) matching the given 'affinity' (parsed by _parseFilterExpr).
- *
- * If `affinity.key === "container"`, the affinity value can be any of:
- * - instance uuid: use that directly
- * - docker id: if at least a 32-char prefix of a docker_id,
- *   then can construct instance UUID from that and use that
- *   directly
- * - short docker id: look up all docker containers by uuid
- * - name: lookup all (not just docker) containers by alias
- * - name glob: lookup all (not just docker) containers by alias
- *   IIUC, Swarm's impl. is just simple globbing: '*'-only
- * - name regex: lookup all (not just docker) containers by
- *   alias.
- *
- * Else `affinity.key` is a tag key:
- * Find any VMs matching that key/value. As above, the value can be an exact
- * value (stringified comparison), glob (simple '*'-only glob) or regex.
- *
- * Dev Note: Annoyingly we prefix docker labels with "docker:label:" on
- * VM.tags. So we search both. Note that this can look obtuse or ambiguious
- * to the docker user if a container has both 'foo' and 'docker:label:foo'
- * VM tags.
- *
- * @param {Object} opts.affinity
- * @param {Object} opts.log
- * @param {UUID} opts.ownerUuid
- * @param {Object} opts.vmapi
- * @param {Object} opts.cache: Used to cache data for repeated calls to this
- *      function for a single `localityFromContainer` call.
- * @param {Function} cb: `function (err, vmUuids)`
- */
-function _vmUuidsFromAffinity(opts, cb) {
-    assert.object(opts.affinity, 'opts.affinity');
-    assert.object(opts.log, 'opts.log');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.object(opts.cache, 'opts.cache');
-    assert.func(cb, 'cb');
-
-    var aff = opts.affinity;
-    var i;
-    var log = opts.log;
-    var query;
-    var vm;
-    var vms;
-
-
-    // A caching version of VMAPI 'ListVms?state=active&owner_uuid=$ownerUuid'.
-    var getAllActiveVms = function (vmsCb) {
-        if (opts.cache.allActiveVms) {
-            vmsCb(null, opts.cache.allActiveVms);
-            return;
-        }
-        opts.vmapi.listVms({
-            fields: 'uuid,alias,internal_metadata,docker',
-            owner_uuid: opts.ownerUuid,
-            state: 'active'
-        }, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, allActiveVms) {
-            if (err) {
-                vmsCb(err);
-            } else {
-                opts.cache.allActiveVms = allActiveVms;
-                vmsCb(null, allActiveVms);
-            }
-        });
-    };
-
-
-    // $tag=$value
-    // $tag=$glob
-    if (aff.key !== 'container' && aff.valueType !== 're') {
-        query = {
-            fields: 'uuid,alias,tags',
-            owner_uuid: opts.ownerUuid,
-            state: 'active',
-            predicate: JSON.stringify({
-                or: [
-                    {eq: ['tag.' + aff.key,              aff.value]},
-                    {eq: ['tag.docker:label:' + aff.key, aff.value]}
-                ]
-            })
-        };
-        opts.vmapi.listVms(query, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, vms_) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            log.debug({affinity: _strFromFilterExpr(aff), vms: vms_},
-                '_vmUuidsFromAffinity');
-            var vmUuids = vms_.map(function (vm_) { return vm_.uuid; });
-            cb(null, vmUuids);
-        });
-
-    // $tag==/regex/
-    // Get a all '$key=*'-tagged VMs and post-filter with `valueRe`.
-    } else if (aff.key !== 'container' && aff.valueType === 're') {
-        query = {
-            fields: 'uuid,alias,tags',
-            owner_uuid: opts.ownerUuid,
-            state: 'active',
-            predicate: JSON.stringify({
-                or: [
-                    {eq: ['tag.' + aff.key,              '*']},
-                    {eq: ['tag.docker:label:' + aff.key, '*']}
-                ]
-            })
-        };
-        opts.vmapi.listVms(query, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, allVms) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            vms = [];
-            for (i = 0; i < allVms.length; i++) {
-                vm = allVms[i];
-
-                var tag = vm.tags[aff.key];
-                if (tag !== undefined && aff.valueRe.test(tag.toString())) {
-                    // Docker labels can only be strings. Triton VM tags can
-                    // also be booleans or numbers.
-                    vms.push(vm);
-                    continue;
-                }
-                var label = vm.tags['docker:label:' + aff.key];
-                if (label !== undefined && aff.valueRe.test(label)) {
-                    vms.push(vm);
-                    continue;
-                }
-            }
-            log.debug({affinity: _strFromFilterExpr(aff), vms: vms},
-                '_vmUuidsFromAffinity');
-            var vmUuids = vms.map(function (vm_) { return vm_.uuid; });
-            cb(null, vmUuids);
-        });
-
-    // container==UUID
-    } else if (common.isUUID(aff.value)) {
-        assert.equal(aff.key, 'container');
-        cb(null, [aff.value]);
-
-    // container==<full 64-char docker id>
-    //
-    // Given a full 64-char docker id, Docker-docker will skip container
-    // *name* matching (at least that's what containers.js#findContainerIdMatch
-    // implies). We'll do the same here. Any other length means we need to
-    // consider name matching.
-    } else if (/^[a-f0-9]{64}$/.test(aff.value)) {
-        assert.equal(aff.key, 'container');
-        var vmUuid = common.dockerIdToUuid(aff.value);
-        opts.vmapi.getVm({
-            uuid: vmUuid,
-            owner_uuid: opts.ownerUuid,
-            fields: 'uuid,alias,state,internal_metadata,docker'
-        }, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, vm_) {
-            if (err && err.statusCode !== 404) {
-                cb(err);
-            } else if (!err && vm_ && vm_.docker
-                && ['destroyed', 'failed'].indexOf(vm_.state) === -1
-                && vm_.internal_metadata['docker:id'] === aff.value)
-            {
-                cb(null, [vmUuid]);
-            } else {
-                cb(null, []);
-            }
-        });
-
-    // container=<name>
-    // container=<short docker id>
-    // container=<name glob> (simple '*'-globbing only)
-    // container=<name regex>
-    //
-    // List all active VMs (non-docker too) and pass to "containers.js"
-    // filter function to select a match.
-    } else {
-        assert.equal(aff.key, 'container');
-
-        vms = [];
-        vasync.pipeline({funcs: [
-            /*
-             * First attempt an exact name (aka alias) match as a quick out,
-             * if possible.
-             */
-            function attemptNameMatch(_, next) {
-                if (aff.valueType !== 'exact' && aff.valueType !== 'glob') {
-                    next();
-                    return;
-                }
-
-                opts.vmapi.listVms({
-                    fields: 'uuid,alias',
-                    owner_uuid: opts.ownerUuid,
-                    state: 'active',
-                    predicate: JSON.stringify({
-                        eq: ['alias', aff.value] // this supports simple glob
-                    })
-                }, {
-                    headers: {'x-request-id': log.fields.req_id}
-                }, function (err, vms_) {
-                    if (err) {
-                        next(err);
-                    } else {
-                        vms = vms_;
-                        next();
-                    }
-                });
-            },
-
-            function fullVmListSearch(_, next) {
-                if (vms.length) {
-                    // Already got results.
-                    next();
-                    return;
-                }
-
-                getAllActiveVms(function (err, allVms) {
-                    if (err) {
-                        next(err);
-                        return;
-                    }
-
-                    switch (aff.valueType) {
-                    case 're':
-                        // Regex is only on container name, not id.
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && aff.valueRe.test(vm.alias)) {
-                                vms.push(vm);
-                            }
-                        }
-                        next();
-                        break;
-                    case 'glob':
-                        // Glob is only on container name, not id.
-                        var valueRe = new RegExp(
-                            '^' + XRegExp.escape(aff.value) + '$');
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && valueRe.test(vm.alias)) {
-                                vms.push(vm);
-                            }
-                        }
-                        next();
-                        break;
-                    case 'exact':
-                        /*
-                         * This is a exact name match (preferred) or id prefix.
-                         * If there are multiple id-prefix matches, we'll
-                         * raise an ambiguity error.
-                         */
-                        var exactErr;
-                        var idPrefixMatches = [];
-                        var nameMatch;
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && vm.alias === aff.value) {
-                                nameMatch = vm;
-                                break;
-                            }
-                            if (vm.docker
-                                && vm.internal_metadata['docker:id']
-                                && vm.internal_metadata['docker:id'].indexOf(
-                                    aff.value) === 0)
-                            {
-                                idPrefixMatches.push(vm);
-                            }
-                        }
-                        if (nameMatch) {
-                            vms.push(nameMatch);
-                        } else if (idPrefixMatches.length > 1) {
-                            exactErr = new
-                                errors.AmbiguousDockerContainerIdPrefixError(
-                                    aff.value, idPrefixMatches);
-                        } else if (idPrefixMatches.length === 1) {
-                            vms.push(idPrefixMatches[0]);
-                        }
-                        next(exactErr);
-                        break;
-                    default:
-                        next(new Error('unknown affinity valueType: '
-                            + aff.valueType));
-                        break;
-                    }
-                });
-            }
-        ]}, function (err) {
-            if (err) {
-                cb(err);
-            } else {
-                log.debug({affinity: _strFromFilterExpr(aff), vms: vms},
-                    '_vmUuidsFromAffinity');
-                var vmUuids = vms.map(function (vm_) { return vm_.uuid; });
-                cb(null, vmUuids);
-            }
-        });
-    }
-}
-
-
 // ---- exports
 
 /**
- * Calculate "locality" hints for a VMAPI CreateVm payload from Docker Swarm
+ * Parse affitinies for a VMAPI CreateVm payload from Docker Swarm
  * "Env" and "Labels" affinity entries, if any, in a "docker run" API call.
  *
  * *Side-effects*:
@@ -593,31 +262,14 @@ function _vmUuidsFromAffinity(opts, cb) {
  *      flav!=staging
  *      role==/^web/
  *
- * Locality hints only speak VM uuids. They look like the following (all
- * fields are optional):
- *      {
- *          strict: <true|false>,
- *          near: [<array of VM uuids>],
- *          far: [<array of VM uuids>]
- *      }
- *
- * Looking up VMs in VMAPI is necessary for the translation.
- * Some failure modes:
- * - VMAPI requests could fail.
- * - No VMs could be found matching the filter, and the affinity is
- *   a strict '=='. (If we didn't fail, then we'd end up setting no `
- *   locality` and the strict affinity would be blithely ignored.)
- *
- * @param {Function} cb: `function (err, locality)` called back with one of:
- *      `err` is an Error instance if there was a problem; or err and locality
- *      not set if there were no affinities; or `locality` is set to a
- *      locality hints object per the sdc-designation spec.
+ * @param {Function} cb: `function (err, parsedAffinities)` called back with
+ *      one of: `err` is an Error instance if there was a problem; or err and
+ *      affinity not set if there were no affinities; or `affinity` is set to
+ *      an array of parsed affinity objects which sdc-designation understands.
  */
-function localityFromContainer(opts, cb) {
+function affinityFromContainer(opts, cb) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
     assert.object(opts.container, 'opts.container');
     assert.func(cb, 'cb');
 
@@ -629,113 +281,12 @@ function localityFromContainer(opts, cb) {
         cb(affErr);
         return;
     }
-    if (affinities.length === 0) {
-        cb();
-        return;
-    }
-    log.debug({affinities: affinities}, 'localityFromContainer: affinities');
 
-    /**
-     * Limitation: sdc-designation's soft-filter-locality-hints.js can't
-     * handle mixed hard (strict) and soft (non-strict) affinities. However,
-     * while affinities just mean a specific server or not, we can effectively
-     * handle this by just dropping soft affinities if there are hard ones.
-     */
-    var haveHard = false;
-    var haveSoft = false;
-    var softAffinities = [];
-    var hardAffinities = [];
-    for (var i = 0; i < affinities.length; i++) {
-        var isSoft = affinities[i].isSoft;
-        if (isSoft) {
-            haveSoft = true;
-            softAffinities.push(affinities[i]);
-        } else {
-            haveHard = true;
-            hardAffinities.push(affinities[i]);
-        }
-    }
-    if (haveHard && haveSoft) {
-        log.debug({softAffinities: softAffinities},
-            'localityFromContainer: mixed hard and soft affinities: '
-            + 'drop soft affinities');
-        affinities = hardAffinities;
-    }
-
-    var strict = haveHard;
-    var near = [];
-    var far = [];
-
-    // TODO: Really want forEachParallel with concurrency.
-    var cache = {};
-    vasync.forEachPipeline({
-        inputs: affinities,
-        func: function setLocalityFromAff(aff, next) {
-            if (aff.key === 'image') {
-                log.debug({affinity: aff}, 'ignore "image" affinity');
-                next();
-            } else {
-                _vmUuidsFromAffinity({
-                    affinity: aff,
-                    log: log,
-                    ownerUuid: opts.ownerUuid,
-                    vmapi: opts.vmapi,
-                    cache: cache
-                }, function (err, vmUuids) {
-                    if (err) {
-                        next(err);
-                    } else if (vmUuids.length === 0) {
-                        /*
-                         * Either we drop the affinity or error out. If
-                         * it is a strict '==', then we need to error out
-                         * (no server will match). If it is non-strict, or
-                         * '!=', then we are fine dropping the affinity.
-                         *
-                         * See some discussion in DAPI-306.
-                         */
-                        if (!strict || aff.operator === '!=') {
-                            log.debug({affinity: aff},
-                                'drop affinity, no matching vms');
-                            next();
-                        } else if (aff.key !== 'container') {
-                            next(new errors.ResourceNotFoundError(format(
-                                'no active containers found matching tag '
-                                + '"%s=%s" for affinity "%s"',
-                                aff.key, aff.value, _strFromFilterExpr(aff))));
-                        } else {
-                            next(new errors.ResourceNotFoundError(format(
-                                'no active containers found matching "%s" '
-                                + 'for affinity "%s"',
-                                aff.value, _strFromFilterExpr(aff))));
-                        }
-                    } else {
-                        if (aff.operator === '==') {
-                            near = near.concat(vmUuids);
-                        } else {
-                            far = far.concat(vmUuids);
-                        }
-                        next();
-                    }
-                });
-            }
-        }
-    }, function (err) {
-        if (err) {
-            cb(err);
-        } else if (!near.length && !far.length) {
-            cb();
-        } else {
-            var locality = {
-                strict: strict
-            };
-            if (near.length > 0) locality.near = near;
-            if (far.length > 0) locality.far = far;
-            cb(null, locality);
-        }
-    });
+    log.debug({affinities: affinities}, 'affinityFromContainer: affinities');
+    cb(null, affinities);
 }
 
 
 module.exports = {
-    localityFromContainer: localityFromContainer
+    affinityFromContainer: affinityFromContainer
 };
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 6e7be45..0ba6d20 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -1957,23 +1957,19 @@ function buildVmPayload(opts, container, callback) {
             cb();
         },
 
-        /*
-         * Determine locality hints from Docker Swarm's syntaxes for
-         * container "affinities".
-         */
-        function addLocalityHintsFromAffinities(_, cb) {
-            affinity.localityFromContainer({
+        function parseAffinityHints(_, cb) {
+            affinity.affinityFromContainer({
                 log: opts.log,
                 vmapi: opts.vmapi,
                 ownerUuid: opts.account.uuid,
                 container: container
-            }, function (err, locality) {
+            }, function (err, affinities) {
                 if (err) {
                     cb(err);
                     return;
                 }
-                if (locality) {
-                    payload.locality = locality;
+                if (affinity) {
+                    payload.affinity = affinities;
                 }
                 cb();
             });
diff --git a/package.json b/package.json
index ba43b92..2c937f8 100644
--- a/package.json
+++ b/package.json
@@ -32,8 +32,7 @@
     "ufds": "1.2.0",
     "vasync": "2.1.0",
     "verror": "1.9.0",
-    "wf-client": "0.2.1",
-    "xregexp": "3.1.0"
+    "wf-client": "0.2.1"
   },
   "devDependencies": {
     "deep-equal": "~0.2.0",
diff --git a/test/integration/cli-affinity.test.js b/test/integration/cli-affinity.test.js
index 7b44222..1b0a8ef 100644
--- a/test/integration/cli-affinity.test.js
+++ b/test/integration/cli-affinity.test.js
@@ -45,8 +45,8 @@ test('affinities a la Swarm', function (tt) {
             + '*\' -d --name %s alpine sleep 3600', containerName);
         cli.run(t, {
             args: args,
-            // JSSTYLED
-            expectedErr: /\(ResourceNotFound\) no active containers found matching "sdcdockertest_affinity_\*" for affinity "container==sdcdockertest_affinity_\*"/
+            expectedErr: 'Error response from daemon: (DockerNoCompute'
+                + 'ResourcesError) No compute resources available.'
         }, function (err) {
             t.end();
         });
@@ -77,9 +77,8 @@ test('affinities a la Swarm', function (tt) {
             containerName);
         cli.run(t, {
             args: args,
-            expectedErr: 'Error response from daemon: (ResourceNotFound) '
-                + 'no active containers found matching tag "foo=bar2" for '
-                + 'affinity "foo==bar2"'
+            expectedErr: 'Error response from daemon: (DockerNoCompute'
+                + 'ResourcesError) No compute resources available.'
         }, function (err) {
             t.end();
         });
diff --git a/test/unit/affinity.test.js b/test/unit/affinity.test.js
index 28c1662..387bbaf 100644
--- a/test/unit/affinity.test.js
+++ b/test/unit/affinity.test.js
@@ -5,12 +5,11 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
- * Test lib/backends/sdc/affinity.js by mocking out the expected VMAPI.listVms
- * calls.
+ * Test lib/backends/sdc/affinity.js parsing.
  */
 
 var assert = require('assert-plus');
@@ -18,510 +17,172 @@ var bunyan = require('bunyan');
 var format = require('util').format;
 var test = require('tape');
 
-var localityFromContainer = require('../../lib/backends/sdc/affinity')
-    .localityFromContainer;
+var affinityFromContainer = require('../../lib/backends/sdc/affinity')
+    .affinityFromContainer;
 
 
 // ---- globals
 
+
 var log = bunyan.createLogger({
     name: 'affinity.test',
     level: process.env.TRACE ? 'trace' : bunyan.FATAL + 1 /* off */,
     req_id: '655b2da4-3165-9549-8626-531ef9336e1e'
 });
 
-var ABE = 'abe00000-bad2-f64d-ae99-986b4fca0308';
-var BOB = 'b0b00000-bfe9-d94d-8874-7b56aea62a6c';
-
-
-/*
- * ---- Mock VMAPI client
- *
- * A very limited Mock VMAPI client that implements a small subset of `listVms`.
- */
-
-function _vmDottedLookup(obj, lookup) {
-    var o = obj;
-    var parts = lookup.split('.');
-    var s = [];
-    for (var i = 0; i < parts.length; i++) {
-        var part = parts[i];
-        if (part === 'tag') {
-            part = 'tags';  // VMAPI "?tag.foo=bar" looks up "tags.foo".
-        }
-        s.push(part);
-        if (!o.hasOwnProperty(part)) {
-            return undefined;
-        }
-        o = o[part];
-    }
-    return o;
-}
-
-function _evalPred(pred, vm) {
-    if (pred.eq) {
-        var val = _vmDottedLookup(vm, pred.eq[0]);
-        if (val === undefined) {
-            return false;
-        }
-        var q = pred.eq[1];
-        if (q.indexOf('*') !== -1) {
-            /*
-             * Glob comparison.
-             *
-             * This conversion is broken for other regex special chars in
-             * the predicate value, but this is the same naive conversion
-             * that Docker Swarm is doing and this is just a quick mock.
-             *      https://github.com/docker/swarm/blob/ee28008f/
-             *          scheduler/filter/expr.go#L87-L88
-             */
-            // JSSTYLED
-            var re = new RegExp('^' + q.replace(/\*/g, '.*') + '$');
-            return Boolean(re.test(val));
-        } else {
-            return (val === q);
-        }
-    } else {
-        throw new Error(format('unknown predicate op: %j', pred));
-    }
-}
-
-function MockVMAPI(vms) {
-    this.vms = vms;
-}
-
-MockVMAPI.prototype.getVm = function getVm(query, options, cb) {
-    assert.uuid(query.uuid, 'query.uuid');
-    assert.equal(options.headers['x-request-id'], log.fields.req_id);
-
-    var vms = this.vms;
-
-    if (query.owner_uuid) {
-        vms = vms.filter(
-            function (vm) { return vm.owner_uuid === query.owner_uuid; });
-    }
-
-    var hit;
-    for (var i = 0; i < vms.length; i++) {
-        if (vms[i].uuid === query.uuid) {
-            hit = vms[i];
-            break;
-        }
-    }
-
-    if (hit && query.fields) {
-        var fields = query.fields.split(',');
-        var newHit = {};
-        fields.forEach(function (field) {
-            newHit[field] = hit[field];
-        });
-        hit = newHit;
-    }
-
-    if (hit) {
-        cb(null, hit);
-    } else {
-        var err = new Error('vm ' + query.uuid + ' not found');
-        err.statusCode = 404;
-        err.restCode = 'ResourceNotFound';
-        err.body = {
-            code: 'ResourceNotFound',
-            message: err.message
-        };
-        cb(err);
-    }
-};
-
-
-MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
-    assert.equal(options.headers['x-request-id'], log.fields.req_id);
-
-    var filtered;
-    var i;
-    var isMatch;
-    var vm;
-    var vms = this.vms;
-    var vmState;
-
-    assert.optionalUuid(query.owner_uuid, 'query.owner_uuid');
-    if (query.owner_uuid) {
-        vms = vms.filter(
-            function (vm_) { return vm_.owner_uuid === query.owner_uuid; });
-    }
-
-    assert.optionalString(query.state, 'query.state');
-    if (query.state) {
-        if (query.state === 'active') {
-            filtered = [];
-            for (i = 0; i < vms.length; i++) {
-                vm = vms[i];
-                vmState = vm.state || 'running';
-                if (['destroyed', 'failed'].indexOf(vmState) === -1) {
-                    filtered.push(vm);
-                }
-            }
-            vms = filtered;
-        } else {
-            filtered = [];
-            for (i = 0; i < vms.length; i++) {
-                vm = vms[i];
-                vmState = vm.state || 'running';
-                if (vmState === query.state) {
-                    filtered.push(vm);
-                }
-            }
-            vms = filtered;
-        }
-    }
-
-    assert.optionalString(query.predicate, 'query.predicate');
-    if (query.predicate) {
-        var pred = JSON.parse(query.predicate);
-
-        var hits = [];
-        try {
-            if (pred.or) {
-                // E.g.:
-                //  {"or":[
-                //      {"eq":["tag.foo","b*"]},
-                //      {"eq":["tag.docker:label:foo","b*"]}
-                //  ]}
-                for (i = 0; i < vms.length; i++) {
-                    vm = vms[i];
-                    for (var j = 0; j < pred.or.length; j++) {
-                        var subpred = pred.or[j];
-                        isMatch = _evalPred(subpred, vm);
-                        log.trace({isMatch: isMatch, vm: vm, pred: subpred},
-                            '_evalPred');
-                        if (isMatch) {
-                            hits.push(vm);
-                            break;
-                        }
-                    }
-                }
-            } else if (pred.eq) {
-                for (i = 0; i < vms.length; i++) {
-                    vm = vms[i];
-                    isMatch = _evalPred(pred, vm);
-                    log.trace({isMatch: isMatch, vm: vm, pred: pred},
-                        '_evalPred');
-                    if (isMatch) {
-                        hits.push(vm);
-                    }
-                }
-            } else {
-                throw new Error(format('unexpected listVms predicate: %j',
-                    pred));
-            }
-        } catch (err) {
-            cb(err);
-            return;
-        }
-
-        vms = hits;
-    }
-
-    if (query.fields) {
-        var fields = query.fields.split(',');
-        vms = vms.map(function (hit) {
-            var reducedVm = {};
-            fields.forEach(function (field) {
-                reducedVm[field] = hit[field];
-            });
-            return reducedVm;
-        });
-    }
-
-    log.trace({query: query, vms: vms}, 'listVms');
-    cb(null, vms);
-};
-
-
 
 // ---- tests
 
 
 test('affinity', function (tt) {
-
-    var vmapi = new MockVMAPI([
-        // Owned by Abe:
-        {
-            'uuid': 'cafe0000-3943-49d5-851f-afd5e2ed93e5',
-            'alias': 'cafe0',
-            'owner_uuid': ABE,
-            'tags': {}
-        },
-        {
-            'uuid': 'db000000-b5eb-4e92-a542-93d4ca011294',
-            'alias': 'db0',
-            'owner_uuid': ABE,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-a',
-                'primary': true
-            }
-        },
-        {
-            'uuid': 'db000001-1e4b-4fbd-9763-0492e32e7d07',
-            'alias': 'db1',
-            'owner_uuid': ABE,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-b'
-            }
-        },
-        {
-            'uuid': 'beef0000-f7d7-4721-9833-66700c5c280d',
-            'alias': 'beef0',
-            'owner_uuid': ABE,
-            'docker': true,
-            'tags': {
-                'sdc_docker': true,
-                'docker:label:role': 'cattle'
-            },
-            'internal_metadata': {
-                // JSSTYLED
-                'docker:id': 'beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'
-            }
-        },
-
-        // Owned by bob: b0b00000-bfe9-d94d-8874-7b56aea62a6c
-        {
-            'uuid': 'db000000-b5eb-4e92-a542-93d4ca011294',
-            'alias': 'db0',
-            'owner_uuid': BOB,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-a',
-                'primary': true
-            }
-        }
-    ]);
-
     var cases = [
         {
             name: '(no env)',
-            ownerUuid: ABE,
             container: {
                 Labels: {}
             },
-            locality: undefined
+            affinity: undefined
         },
         {
             name: '(no labels)',
-            ownerUuid: ABE,
             container: {
                 Env: []
             },
-            locality: undefined
+            affinity: undefined
         },
 
         {
             name: '(no affinities)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['WUZZLE=fuzz']
             },
-            locality: undefined
+            affinity: undefined
         },
-
         {
             name: 'role==database (env)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['affinity:role==database']
             },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['role==database'])
+            affinity: [ {
+                key: 'role',
+                operator: '==',
+                value: 'database',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
             name: 'role==database (label)',
-            ownerUuid: ABE,
             container: {
                 Labels: {'com.docker.swarm.affinities': '["role==database"]'},
                 Env: ['FOO=bar']
             },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: ['FOO=bar'],
-            modifiedAffinitiesLabel: JSON.stringify(['role==database'])
+            affinity: [ {
+                key: 'role',
+                operator: '==',
+                value: 'database',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: ['FOO=bar']
         },
         {
             name: 'role!=database (env)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['affinity:role!=database']
             },
-            locality: {
-                strict: true,
-                far: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['role!=database'])
+            affinity: [ {
+                key: 'role',
+                operator: '!=',
+                value: 'database',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
             name: 'role!=database (label)',
-            ownerUuid: ABE,
             container: {
                 Labels: {'com.docker.swarm.affinities': '["role!=database"]'},
                 Env: ['FOO=bar']
             },
-            locality: {
-                strict: true,
-                far: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: ['FOO=bar'],
-            modifiedAffinitiesLabel: JSON.stringify(['role!=database'])
-        },
-
-        {
-            name: 'role==cattle (picks up docker:label:*)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: ['affinity:role==cattle']
-            },
-            locality: {
-                strict: true,
-                near: ['beef0000-f7d7-4721-9833-66700c5c280d']
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['role==cattle'])
+            affinity: [ {
+                key: 'role',
+                operator: '!=',
+                value: 'database',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: ['FOO=bar']
         },
-
         {
             name: 'shard==shard-* (glob)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['affinity:shard==shard-*']
             },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['shard==shard-*'])
+            affinity: [ {
+                key: 'shard',
+                operator: '==',
+                value: 'shard-*',
+                valueType: 'glob',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
             name: 'shard==*-a (glob)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['affinity:shard==*-a']
             },
-            locality: {
-                strict: true,
-                near: ['db000000-b5eb-4e92-a542-93d4ca011294']
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['shard==*-a'])
+            affinity: [ {
+                key: 'shard',
+                operator: '==',
+                value: '*-a',
+                valueType: 'glob',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
-
         {
             name: 'shard==/ard-[ab]$/ (regex)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: ['affinity:shard==/ard-[ab]$/']
             },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['shard==/ard-[ab]$/'])
-        },
-
-        {
-            name: 'shard==nada (no hits + "==" should be an error)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: ['affinity:shard==nada']
-            },
-            err: {
-                // JSSTYLED
-                messageRe: /no active containers found matching tag "shard=nada" for affinity "shard==nada"/
-            }
+            affinity: [ {
+                key: 'shard',
+                operator: '==',
+                value: '/ard-[ab]$/',
+                valueType: 're',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
-        {
-            name: 'shard!=nada (no hits, but not "==" so not error)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: ['affinity:shard!=nada']
-            },
-            locality: undefined
-        },
-        {
-            name: 'shard==~nada (no hits, but not "==" so not error)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: ['affinity:shard==~nada']
-            },
-            locality: undefined
-        },
-
-        /*
-         * `container==???` cases to test:
-         * - instance uuid
-         * - docker id: 32 chars and up
-         * - short docker id
-         * - name
-         * - name glob ('*'-only)
-         * - name regex
-         */
         {
             name: 'container==db000000-b5eb-4e92-a542-93d4ca011294 (uuid)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: [
                     'affinity:container==db000000-b5eb-4e92-a542-93d4ca011294'
                 ]
             },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(
-                ['container==db000000-b5eb-4e92-a542-93d4ca011294'])
+            affinity: [ {
+                key: 'container',
+                operator: '==',
+                value: 'db000000-b5eb-4e92-a542-93d4ca011294',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
             name: 'container==beef0000f7d7...c6af74 (64-char docker id)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: [
@@ -529,214 +190,145 @@ test('affinity', function (tt) {
                     'affinity:container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'
                 ]
             },
-            locality: {
-                strict: true,
-                near: [
-                    'beef0000-f7d7-4721-9833-66700c5c280d'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(
-                // JSSTYLED
-                ['container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'])
-        },
-        {
-            // JSSTYLED
-            name: 'container==beef0000f7d7...c6abad (64-char docker id, bad tail chars)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: [
-                    // JSSTYLED
-                    'affinity:container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6abad'
-                ]
-            },
-            err: {
+            affinity: [ {
+                key: 'container',
+                operator: '==',
                 // JSSTYLED
-                messageRe: /no active containers found matching "beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6abad" for affinity "container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6abad"/,
-                restCode: 'ResourceNotFound'
-            }
+                value: 'beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
             name: 'container==beef0000f7d7 (short docker id)',
-            ownerUuid: ABE,
             container: {
                 Labels: {},
                 Env: [
                     'affinity:container==beef0000f7d7'
                 ]
             },
-            locality: {
-                strict: true,
-                near: [
-                    'beef0000-f7d7-4721-9833-66700c5c280d'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(
-                ['container==beef0000f7d7'])
-        },
-        {
-            name: 'container==db0 (name)',
-            ownerUuid: ABE,
-            container: {
-                Labels: {},
-                Env: [
-                    'affinity:container==db0'
-                ]
-            },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294'
-                ]
-            },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['container==db0'])
+            affinity: [ {
+                key: 'container',
+                operator: '==',
+                value: 'beef0000f7d7',
+                valueType: 'exact',
+                isSoft: false
+            } ],
+            modifiedEnv: []
         },
         {
-            name: 'container==DB0 (name, no match)',
-            ownerUuid: ABE,
+            name: 'container==~foo',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==DB0'
+                    'affinity:container==~foo'
                 ]
             },
-            err: {
-                // JSSTYLED
-                messageRe: /no active containers found matching "DB0" for affinity "container==DB0"/,
-                code: 'ResourceNotFound'
-            }
+            affinity: [ {
+                key: 'container',
+                operator: '==',
+                value: 'foo',
+                valueType: 'exact',
+                isSoft: true
+            } ],
+            modifiedEnv: []
         },
         {
-            name: 'container==db* (name glob)',
-            ownerUuid: ABE,
+            name: 'container!=~foo',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==db*'
-                ]
-            },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
+                    'affinity:container!=~foo'
                 ]
             },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['container==db*'])
+            affinity: [ {
+                key: 'container',
+                operator: '!=',
+                value: 'foo',
+                valueType: 'exact',
+                isSoft: true
+            } ],
+            modifiedEnv: []
         },
+
+        // parse errors
         {
-            name: 'container==DB* (glob, no match)',
-            ownerUuid: ABE,
+            name: 'container=~foo (invalid syntax)',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==DB*'
+                    'affinity:container=~foo'
                 ]
             },
-            err: {
-                // JSSTYLED
-                messageRe: /no active containers found matching "DB\*" for affinity "container==DB\*"/,
-                restCode: 'ResourceNotFound'
-            }
+            affinity: undefined,
+            errMsg: /could not find operator/
         },
         {
-            name: 'container==/^db/ (name regex)',
-            ownerUuid: ABE,
+            name: 'container== (invalid syntax)',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==/^db/'
-                ]
-            },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
+                    'affinity:container=='
                 ]
             },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['container==/^db/'])
+            affinity: undefined,
+            errMsg: /invalid value/
         },
         {
-            name: 'container==/^DB/ (glob, no match)',
-            ownerUuid: ABE,
+            name: '==foo (invalid syntax)',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==/^DB/'
+                    'affinity:==foo'
                 ]
             },
-            err: {
-                // JSSTYLED
-                messageRe: /no active containers found matching "\/\^DB\/" for affinity "container==\/\^DB\/"/,
-                restCode: 'ResourceNotFound'
-            }
+            affinity: undefined,
+            errMsg: /invalid key/
         },
         {
-            name: 'container==/(?i)^DB/ (name regex, case-insensitive)',
-            ownerUuid: ABE,
+            name: 'container==/a!/ (invalid syntax)',
             container: {
                 Labels: {},
                 Env: [
-                    'affinity:container==/(?i)^DB/'
-                ]
-            },
-            locality: {
-                strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294',
-                    'db000001-1e4b-4fbd-9763-0492e32e7d07'
+                    'affinity:container==/a!/'
                 ]
             },
-            modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(['container==/(?i)^DB/'])
+            affinity: undefined,
+            errMsg: /invalid value/
         }
     ];
 
-    cases.forEach(function (c) {
+    cases.forEach(function checkCase(c) {
         if (process.env.FILTER && c.name.indexOf(process.env.FILTER) === -1) {
             tt.skip('  ' + c.name + ' (FILTER=' + process.env.FILTER + ')');
             return;
         }
 
-        tt.test('  ' + c.name, function (t) {
-            localityFromContainer({
+        tt.test('  ' + c.name, function runTest(t) {
+            affinityFromContainer({
                 log: log,
-                vmapi: vmapi,
-                ownerUuid: c.ownerUuid,
                 container: c.container
-            }, function (err, locality) {
-                if (c.err) {
-                    t.ok(err, 'err calling localityFromContainer');
-                    if (c.err.messageRe) {
-                        t.ok(c.err.messageRe.test(err.message), format(
-                            'err.message matches %s: %j', c.err.messageRe,
-                            err.message));
-                    }
-                    if (c.err.restCode) {
-                        t.equal(err.restCode, c.err.restCode, 'err.restCode');
-                    }
+            }, function parseCb(err, affinity) {
+                if (c.errMsg) {
+                    t.ok(err, 'err calling affinityFromContainer');
+
+                    t.ok(c.errMsg.test(err.message), format(
+                        'err.message matches %s: %j', c.errMsg,
+                        err.message));
                 } else {
-                    t.ifErr(err, 'no err calling localityFromContainer');
+                    t.ifErr(err, 'no err calling affinityFromContainer');
                 }
-                if (c.hasOwnProperty('locality')) {
-                    t.deepEqual(locality, c.locality, 'locality');
+
+                if (c.affinity) {
+                    t.deepEqual(affinity, c.affinity, 'affinity');
                 }
+
                 if (c.modifiedEnv) {
                     t.deepEqual(c.container.Env, c.modifiedEnv,
                         'modified container.Env');
                 }
-                if (c.modifiedAffinitiesLabel) {
-                    t.equal(c.container.Labels['com.docker.swarm.affinities'],
-                        c.modifiedAffinitiesLabel,
-                        // JSSTYLED
-                        'modified container.Labels["com.docker.swarm.affinities"]');
-                }
+
                 t.end();
             });
         });
