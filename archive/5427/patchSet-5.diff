From 6b0eddc4375be0903f2e3b58b18bd97a9ec8460b Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 23 Jan 2019 17:40:43 -0800
Subject: [PATCH] joyent/node-zkstream#39 ZKWatcher onStateChanged looking for
 wrong state

---
 lib/zk-session.js  | 464 +++++++++++++++++++++++++++++++++++++++------
 test/basic.test.js | 241 ++++++++++++++++++++++-
 2 files changed, 645 insertions(+), 60 deletions(-)

diff --git a/lib/zk-session.js b/lib/zk-session.js
index cbc86f0..d1db8e0 100644
--- a/lib/zk-session.js
+++ b/lib/zk-session.js
@@ -130,6 +130,7 @@ ZKSession.prototype.state_detached = function (S) {
 	S.on(this.zs_expiryTimer, 'timeout', function () {
 		S.gotoState('expired');
 	});
+	this.watchersDisconnected();
 };
 
 ZKSession.prototype.state_attaching = function (S) {
@@ -361,6 +362,18 @@ ZKSession.prototype.state_closed = function (S) {
 	this.zs_log.info('ZK session closed');
 };
 
+ZKSession.prototype.watchersDisconnected = function () {
+	var paths = Object.keys(this.zs_watchers);
+	var self = this;
+	paths.forEach(function (path) {
+		var w = self.zs_watchers[path];
+		var evts = w.events();
+		evts.forEach(function (event) {
+			event.disconnected();
+		});
+	});
+};
+
 ZKSession.prototype.processNotification = function (pkt) {
 	var self = this;
 	if (pkt.state !== 'SYNC_CONNECTED') {
@@ -390,7 +403,7 @@ ZKSession.prototype.processNotification = function (pkt) {
 	notifications.increment({event: evt});
 
 	if (watcher)
-		watcher.emit(evt);
+		watcher.notify(evt);
 };
 
 ZKSession.prototype.resumeWatches = function () {
@@ -402,11 +415,15 @@ ZKSession.prototype.resumeWatches = function () {
 	};
 	var count = 0;
 	var paths = Object.keys(this.zs_watchers);
+	var allEvts = [];
 	paths.forEach(function (path) {
 		var w = self.zs_watchers[path];
-		var evts = w.eventsActive();
+		var evts = w.events();
 		var cod = false;
-		evts.forEach(function (evt) {
+		evts.forEach(function (event) {
+			if (!event.isInState('resuming'))
+				return;
+			var evt = event.getEvent();
 			if (evt === 'created' || evt === 'deleted') {
 				if (cod)
 					return;
@@ -420,6 +437,7 @@ ZKSession.prototype.resumeWatches = function () {
 				events.childrenChanged.push(path);
 				++count;
 			}
+			allEvts.push(event);
 		});
 	});
 	if (count < 1)
@@ -430,7 +448,11 @@ ZKSession.prototype.resumeWatches = function () {
 	this.zs_conn.setWatches(events, zxid, function (err) {
 		if (err) {
 			self.emit('pingTimeout');
+			return;
 		}
+		allEvts.forEach(function (event) {
+			event.resume();
+		});
 	});
 };
 
@@ -438,23 +460,76 @@ ZKSession.prototype.watcher = function (path) {
 	var w = this.zs_watchers[path];
 	if (w)
 		return (w);
-	w = new ZKWatcher(this, path);
+	w = new ZKWatcher(this, path, this.zs_log);
 	this.zs_watchers[path] = w;
 	return (w);
 };
 
-function ZKWatcher(session, path) {
+/*
+ * The ZKWatcher provides the EventEmitter that is returned by
+ * ZKSession#watcher. It's not an FSM, but it spins up and interacts with
+ * many ZKWatchEvent FSMs under its zkw_events lookup property.
+ *
+ * The available events emitted to end-users of the API are:
+ *  - created
+ *  - deleted
+ *  - dataChanged
+ *  - childrenChanged
+ *
+ * However, in the ZK protocol itself the created and deleted events are
+ * collapsed into a single "existence" watcher, so we only spin up a single
+ * FSM for both of those if either one of them or both are watched.
+ *
+ * The ZK server in many early versions we have to deal with only has two
+ * real kinds of watches internally, though -- despite the protocol making it
+ * seem like existence and data watches are separate concepts, it only has one
+ * list which contains both. We try to be conservative and always re-arm our
+ * watchers to make certain we have coverage on the event the user asked us
+ * for, even if it potentially means duplicate notifications (which we filter
+ * out by looking at the zxids).
+ *
+ * Older ZK versions:
+ *
+ *                 created     deleted     dataCh      childrenCh
+ * GET_DATA           X           X           X
+ * EXISTS             X           X           X
+ * GET_CHILDREN2                  X                        X
+ *
+ * Newer ZK versions (>=3.5?):
+ *
+ *                 created     deleted     dataCh      childrenCh
+ * GET_DATA                       X           X
+ * EXISTS             X           X
+ * GET_CHILDREN2                  X                        X
+ *
+ * We have to know about this, because when watchers fire they are removed
+ * and we have to re-watch the node again. If we are trying to keep only a watch
+ * on the existence of a node and suddenly get a dataChanged notification
+ * about it (see the table above), we have to discard that event (we're not
+ * watching for data changes), but we *must* proceed to set up the existence
+ * watcher again, because from the server's perspective the watch has fired and
+ * is finished.
+ */
+function ZKWatcher(session, path, log) {
 	this.zkw_path = path;
 	this.zkw_session = session;
+	this.zkw_events = {};
+	this.zkw_log = log.child({
+	    component: 'ZKWatcher',
+	    path: path
+	});
 	mod_events.EventEmitter.call(this);
 }
 mod_util.inherits(ZKWatcher, mod_events.EventEmitter);
 
-ZKWatcher.prototype.eventsActive = function () {
+/* Returns all our running watch FSMs. */
+ZKWatcher.prototype.events = function () {
+	var evts = [];
 	var self = this;
-	var evts = ['created', 'deleted', 'dataChanged', 'childrenChanged'];
-	evts = evts.filter(function (evt) {
-		return (self.listeners(evt).length > 0);
+	['createdOrDeleted', 'dataChanged', 'childrenChanged'].forEach(
+	    function (evt) {
+		if (self.zkw_events[evt])
+			evts.push(self.zkw_events[evt]);
 	});
 	return (evts);
 };
@@ -463,99 +538,374 @@ ZKWatcher.prototype.once = function () {
 	throw (new Error('ZKWatcher does not support once() (use on)'));
 };
 
+/* Called by the ZKSession when a notification is received. */
+ZKWatcher.prototype.notify = function (evt) {
+	var toNotify = [];
+	switch (evt) {
+	case 'created':
+		toNotify = ['createdOrDeleted', 'dataChanged'];
+		break;
+	case 'deleted':
+		toNotify = ['createdOrDeleted', 'dataChanged',
+		    'childrenChanged'];
+		break;
+	case 'dataChanged':
+		toNotify = ['dataChanged', 'createdOrDeleted'];
+		break;
+	case 'childrenChanged':
+		toNotify = ['childrenChanged'];
+		break;
+	default:
+		throw (new Error('Unknown notification type: ' + evt));
+	}
+	var self = this;
+	var notified = false;
+	toNotify.forEach(function (type) {
+		var event = self.zkw_events[type];
+		if (event && !event.isInState('disarmed')) {
+			event.notify();
+			notified = true;
+		}
+	});
+	if (!notified) {
+		/*
+		 * This is bad: it means our picture of which events can hit
+		 * which kinds of watchers in ZK is wrong. We can't guarantee
+		 * we can have a working watcher in this condition, so abort.
+		 */
+		throw (new Error('Got notification for ' + evt + ' but ' +
+		    'have no matching events on ' + this.zkw_path));
+	}
+};
+
 ZKWatcher.prototype.on = function (evt, cb) {
 	mod_assert.string(evt, 'event');
 	mod_assert.func(cb, 'callback');
 	var first = (this.listeners(evt).length < 1);
 	mod_events.EventEmitter.prototype.on.call(this, evt, cb);
 	if (evt !== 'error' && first)
-		this.emit(evt);
+		this._armEvent(evt);
 	return (this);
 };
 
-ZKWatcher.prototype.emit = function (evt) {
+ZKWatcher.prototype._armEvent = function (evt) {
+	if (evt === 'deleted' || evt === 'created')
+		evt = 'createdOrDeleted';
+	if (this.zkw_events[evt] === undefined) {
+		this.zkw_events[evt] = new ZKWatchEvent(this.zkw_session,
+		    this.zkw_path, this, evt, this.zkw_log);
+	}
+	if (this.zkw_events[evt].isInState('disarmed'))
+		this.zkw_events[evt].arm();
+};
+
+/*
+ * This FSM represents the state of an individual watch we're trying to
+ * maintain with the ZK server.
+ *
+ * It lives as long as the session does, and operates in a loop re-arming
+ * itself each time something happens that disarms the watcher on the server
+ * side (e.g. the watcher firing a notification or losing our connection).
+ *
+ *        +----------+
+ *        |          |
+ *        | disarmed |
+ *        |          |
+ *        +--+-------+
+ *           |
+ *           |
+ *           | arm() (from ZKWatcher)
+ *           v
+ *        +--+-----------+
+ *        |              |
+ *  +---->+ wait_session +<---------<----+--<---------+
+ *  |     |              |                \           |
+ *  |     +--+-----------+                 |          |
+ *  |        |                             ^ node     |
+ *  |        | session attached            | created  |
+ *  |        v                             |          ^
+ *  |     +--+-------------+         +-----+-----+    |
+ *  |     |                |         |           |    |
+ *  ^     | wait_connected |         | wait_node |    |
+ *  |     |                |         |           |    |
+ *  |     +--+-------------+         +-----+-----+    |
+ *  |        |                             ^          |
+ *  |        | connected                   |          |
+ *  |        v                             |          |
+ *  |     +--+-----+                       ^          ^
+ *  |     |        |                       |          |
+ *  +--<--+ arming +--->----------->-------+          |
+ * error  |        |      NO_NODE && !(existence)     |
+ *        +-+------+                                  |
+ *          |                                         |
+ *          | response from ZK  +---->  emit!         ^
+ *          v                                         |
+ *        +-+-------+                                 |
+ *        |         | notify() (from ZKWatcher)      /|
+ *        |  armed  +--->--------->----------->-----/ |
+ *        |         +<------------<----------<----\   |
+ *        +----+----+                             |   |
+ *             |                         resume() |   ^ notify()
+ *             |                 (from ZKSession) ^   | (from ZKSession)
+ *             v disconnected()                   |   |
+ *             | (from ZKSession)               +-+---+----+
+ *             |                                |          |
+ *             +--------->------------->------->+ resuming |
+ *                                              |          |
+ *                                              +----------+
+ *
+ */
+function ZKWatchEvent(session, path, emitter, evt, log) {
+	this.zkwe_path = path;
+	this.zkwe_session = session;
+	this.zkwe_emitter = emitter;
+	this.zkwe_evt = evt;
+	this.zkwe_prevZxid = null;
+	this.zkwe_log = log.child({ event: evt });
+	mod_fsm.FSM.call(this, 'disarmed');
+}
+mod_util.inherits(ZKWatchEvent, mod_fsm.FSM);
+
+ZKWatchEvent.prototype.getEvent = function () {
+	return (this.zkwe_evt);
+};
+
+/* Called by the watch emitter below when someone does .on('event', ...); */
+ZKWatchEvent.prototype.arm = function () {
+	this.emit('armAsserted');
+};
+
+/*
+ * Called by the watch emitter when a notification is given to it by the
+ * ZKSession which matches this event.
+ *
+ * Note that in e.g. wait_session we also use events emitted by the ZKSession
+ * to sync up with it. We get a call here because receiving notifications
+ * does not change the state of the ZKSession (unlike attaching to a new conn).
+ */
+ZKWatchEvent.prototype.notify = function () {
+	if (this.isInState('armed') || this.isInState('resuming'))
+		this.emit('notifyAsserted');
+	/*
+	 * In other states we ignore this: we're already in transition to
+	 * set the watcher up (or re-arm it), so we don't need to be woken
+	 * up.
+	 */
+};
+
+/*
+ * This is called by the ZKSession above to let us know that the session has
+ * become detached and we are on the list to be auto-resumed (with catch-up)
+ * after reconnection.
+ *
+ * We can't just use the state change of the ZKSession because we need to be
+ * certain that we are actually on its list of watchers to re-arm after
+ * reconnect -- instead we have it tell us explicitly through this function.
+ */
+ZKWatchEvent.prototype.disconnected = function () {
+	if (this.isInstate('armed'))
+		this.emit('disconnectAsserted');
+	/*
+	 * In any other state, we do nothing. The ZKSession will only
+	 * auto-resume watchers that were armed when we disconnected. Others
+	 * will receive an error in their current state and retry.
+	 */
+};
+/* And then the ZKSession lets us know when auto-resume is complete. */
+ZKWatchEvent.prototype.resume = function () {
+	mod_assert.ok(this.isInState('resuming'));
+	this.emit('resumeAsserted');
+};
+
+/*
+ * We start here: the watch has not been established with the ZK server, and
+ * we're not yet ready to start trying.
+ *
+ * This is the only state when we should never receive notifications.
+ */
+ZKWatchEvent.prototype.state_disarmed = function (S) {
 	var self = this;
-	if (this.listeners(evt).length < 1)
-		return;
-	if (!this.zkw_session.isInState('attached')) {
-		function onStateChanged(st) {
-			if (st === 'connected') {
-				self.emit(evt);
-				self.zkw_session.removeListener('stateChanged',
-				    onStateChanged);
-			}
-		}
-		this.zkw_session.zs_log.trace({
-			event: evt,
-			clientState: this.zkw_session.getState()
-		}, 'deferring watcher refresh until after reconnect');
-		this.zkw_session.on('stateChanged', onStateChanged);
+	S.on(this, 'armAsserted', function () {
+		self.zkwe_log.trace('arming watcher');
+		S.gotoState('wait_session');
+	});
+};
+
+/*
+ * We can't "arm" the watcher (send the command to the ZK server with the
+ * watch flag set) until we know the session and connection are up and ready.
+ *
+ * So we go through wait_session and wait_connected first before arming.
+ */
+ZKWatchEvent.prototype.state_wait_session = function (S) {
+	if (this.zkwe_session.isInState('attached')) {
+		S.gotoState('wait_connected');
 		return;
 	}
-	var conn = this.zkw_session.getConnection();
+	S.on(this.zkwe_session, 'stateChanged', function (state) {
+		if (state === 'attached') {
+			S.gotoState('wait_connected');
+		}
+	});
+	this.zkwe_session.zs_log.trace({
+		event: this.zkwe_evt,
+		clientState: this.zkwe_session.getState()
+	}, 'deferring watcher arm until after reconnect');
+};
+
+ZKWatchEvent.prototype.state_wait_connected = function (S) {
+	var conn = this.zkwe_session.getConnection();
 	if (!conn.isInState('connected')) {
-		setImmediate(function () {
-			self.emit(evt);
+		/*
+		 * Don't transition synchronously back to wait_session, we
+		 * want to give the connection a chance to get to the right
+		 * state (it might have only just connected in this turn of
+		 * the event loop and we saw the session change before it)
+		 */
+		S.immediate(function () {
+			S.gotoState('wait_session');
 		});
 		return;
 	}
-	var qpkt = this._reqPacket(evt);
+	S.gotoState('arming');
+};
+
+/*
+ * In this state we send the actual command with the watch flag set, then
+ * double-check that the zxid we're looking at has actually changed, emit
+ * events on the emitter, and transition to "armed".
+ *
+ * We also handle some errors that can occur (not all of which mean we failed
+ * to arm the watcher, for various ZK protocol reasons described below).
+ */
+ZKWatchEvent.prototype.state_arming = function (S) {
+	/*
+	 * We can rely on the fact that wait_connected checked for the
+	 * connection's state before synchronously transitioning to us.
+	 *
+	 * So calling conn.request() won't throw.
+	 */
+	var conn = this.zkwe_session.getConnection();
+	var qpkt = this.toPacket();
+
 	var req = conn.request(qpkt);
-	req.on('reply', function (pkt) {
+	var evt = this.zkwe_evt;
+	var self = this;
+	/*
+	 * In ZK to "arm" a watcher on a node and receive a notification when
+	 * it changes, you have to do an initial request for the same data you
+	 * want to watch.
+	 *
+	 * Once you get a valid reply to it (or certain kinds of errors), you
+	 * can consider the watcher "armed".
+	 */
+	S.on(req, 'reply', function (pkt) {
 		var args = [evt];
+		var zxid;
 		switch (evt) {
-		case 'created':
+		case 'createdOrDeleted':
+			/* EXISTS returned ok, so the node exists. */
+			args[0] = 'created';
+			zxid = pkt.stat.czxid;
 			args.push(pkt.stat);
 			break;
-		case 'deleted':
-			return;
 		case 'dataChanged':
+			zxid = pkt.stat.mzxid;
 			args.push(pkt.data, pkt.stat);
 			break;
 		case 'childrenChanged':
+			zxid = pkt.stat.pzxid;
 			args.push(pkt.children, pkt.stat);
 			break;
 		default:
 			throw (new Error('Unknown watcher event ' + evt));
 		}
-		mod_events.EventEmitter.prototype.emit.apply(self, args);
-	});
-	req.on('error', function (err) {
-		if (err.code === 'PING_TIMEOUT') {
-			self.emit(evt);
+		self.zkwe_log.trace({ zxid: zxid.toString('hex'),
+		    prevZxid: self.zkwe_prevZxid ?
+		    self.zkwe_prevZxid.toString('hex') : null },
+		    'got reply to arm request');
+		if (self.zkwe_prevZxid && zxid.equals(self.zkwe_prevZxid)) {
+			S.gotoState('armed');
 			return;
 		}
-		if (evt === 'created' && err.code === 'NO_NODE') {
+		mod_events.EventEmitter.prototype.emit.apply(self.zkwe_emitter,
+		    args);
+		self.zkwe_prevZxid = zxid;
+		S.gotoState('armed');
+	});
+	S.on(req, 'error', function (err) {
+		/* We lost our connection, so try again. */
+		if (err.code === 'PING_TIMEOUT') {
+			S.gotoState('wait_session');
 			return;
 		}
-		if (evt === 'deleted' && err.code === 'NO_NODE') {
-			mod_events.EventEmitter.prototype.emit.call(self, evt);
+		/*
+		 * Creation/destruction watchers are armed even if we get a
+		 * NO_NODE error (this means it doesn't currently exist and
+		 * we're now watching it for existence).
+		 */
+		if (evt === 'createdOrDeleted' && err.code === 'NO_NODE') {
+			mod_events.EventEmitter.prototype.emit.call(
+			    self.zkwe_emitter, 'deleted');
+			S.gotoState('armed');
 			return;
 		}
+		/*
+		 * Other types of watchers won't attach to a node that
+		 * doesn't exist yet -- we'll have to try arming this watcher
+		 * again once the node exists.
+		 */
 		if (err.code === 'NO_NODE') {
-			function onCreated() {
-				self.removeListener('created', onCreated);
-				self.emit(evt);
-			}
-			self.on('created', onCreated);
+			S.gotoState('wait_node');
 			return;
 		}
-		setImmediate(function () {
-			self.emit(evt);
-		});
-		self.zkw_session.zs_log.trace(err, 'watcher attach failure; ' +
+		self.zkwe_log.trace(err, 'watcher attach failure; ' +
 		    'will retry');
+		S.gotoState('wait_session');
+	});
+};
+
+ZKWatchEvent.prototype.state_wait_node = function (S) {
+	S.on(this.zkwe_emitter, 'created', function () {
+		S.gotoState('wait_session');
 	});
 };
 
-ZKWatcher.prototype._reqPacket = function (evt) {
+/*
+ * In the armed state, we have established our watcher with the ZK server and
+ * are waiting either for a notification to come in (in which case we re-fetch
+ * the node information and then emit the event), or a disconnect/detach.
+ */
+ZKWatchEvent.prototype.state_armed = function (S) {
+	S.on(this, 'notifyAsserted', function () {
+		S.gotoState('wait_session');
+	});
+	S.on(this, 'disconnectAsserted', function () {
+		S.gotoState('resuming');
+	});
+};
+
+/*
+ * ZKSession told us it detached due to disconnection and we are going to be
+ * auto-resumed. Sit tight until it tells us what to do next (or we get a
+ * catch-up notification).
+ */
+ZKWatchEvent.prototype.state_resuming = function (S) {
+	S.on(this, 'resumeAsserted', function () {
+		S.gotoState('armed');
+	});
+	S.on(this, 'notifyAsserted', function () {
+		S.gotoState('wait_session');
+	});
+};
+
+ZKWatchEvent.prototype.toPacket = function () {
 	var pkt = {
-		path: this.zkw_path,
+		path: this.zkwe_path,
 		watch: true
 	};
-	switch (evt) {
-	case 'created':
-	case 'deleted':
+	switch (this.zkwe_evt) {
+	case 'createdOrDeleted':
 		pkt.opcode = 'EXISTS';
 		break;
 	case 'dataChanged':
@@ -565,7 +915,7 @@ ZKWatcher.prototype._reqPacket = function (evt) {
 		pkt.opcode = 'GET_CHILDREN2';
 		break;
 	default:
-		throw (new Error('Unknown watcher event ' + evt));
+		throw (new Error('Unknown watcher event ' + this.zkwe_evt));
 	}
 	return (pkt);
 };
diff --git a/test/basic.test.js b/test/basic.test.js
index f74f2af..4e6d65e 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -829,6 +829,129 @@ mod_tape.test('children watcher no node', function (t) {
 	});
 });
 
+mod_tape.test('deletion watcher seq: delete, create, delete', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	var evts = [];
+	var d = new Buffer('hi', 'ascii');
+
+	mod_vasync.waterfall([
+		function (cb) {
+			zkc.on('connect', cb);
+		},
+		function (cb) {
+			zkc.create('/delseq', d, {}, cb);
+		},
+		function (_, cb) {
+			var w = zkc.watcher('/delseq');
+			w.on('deleted', function () {
+				evts.push('deleted');
+			});
+			w.on('created', function () {
+				if (evts.length === 0)
+					cb();
+				evts.push('created');
+			});
+		},
+		function (cb) {
+			zkc.delete('/delseq', -1, cb);
+		},
+		function (cb) {
+			zkc.create('/delseq', d, {}, cb);
+		},
+		function (_, cb) {
+			zkc.delete('/delseq', -1, cb);
+		},
+		function (cb) {
+			wait(t, 'events collected', 30000, function () {
+				return (evts.length >= 4);
+			}, cb);
+		},
+		function (cb) {
+			t.deepEqual(evts, ['created', 'deleted', 'created',
+			    'deleted']);
+			cb();
+		}
+	], function (err) {
+		t.error(err);
+		zkc.close();
+	});
+});
+
+mod_tape.test('data watcher seq: set, delete, create, set, delete',
+    function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	var evts = [];
+	var d = new Buffer('hi', 'ascii');
+	var d2 = new Buffer('hi2', 'ascii');
+
+	mod_vasync.waterfall([
+		function (cb) {
+			zkc.on('connect', cb);
+		},
+		function (cb) {
+			zkc.create('/dataseq', d, {}, cb);
+		},
+		function (_, cb) {
+			var w = zkc.watcher('/dataseq');
+			w.on('dataChanged', function (data) {
+				if (evts.length === 0)
+					cb();
+				evts.push(data.toString());
+			});
+		},
+		function (cb) {
+			zkc.set('/dataseq', d2, -1, cb);
+		},
+		function (_, cb) {
+			zkc.delete('/dataseq', -1, cb);
+		},
+		function (cb) {
+			zkc.create('/dataseq', d, {}, cb);
+		},
+		function (_, cb) {
+			wait(t, 'events collected', 30000, function () {
+				return (evts.length >= 2);
+			}, cb);
+		},
+		function (cb) {
+			zkc.set('/dataseq', d2, -1, cb);
+		},
+		function (_, cb) {
+			zkc.delete('/dataseq', -1, cb);
+		},
+		function (cb) {
+			wait(t, 'events collected', 30000, function () {
+				return (evts.length >= 4);
+			}, cb);
+		},
+		function (cb) {
+			t.deepEqual(evts, ['hi', 'hi2', 'hi', 'hi2']);
+			cb();
+		}
+	], function (err) {
+		t.error(err);
+		zkc.close();
+	});
+});
+
 mod_tape.test('session resumption with watcher', function (t) {
 	var connected = 0;
 	var closed = 0;
@@ -919,6 +1042,117 @@ mod_tape.test('session resumption with watcher', function (t) {
 	}
 });
 
+mod_tape.test('session resumption new watcher race (#39)', function (t) {
+	var closed = 0;
+	var counts = {};
+
+	function incrCount(k) {
+		if (counts[k] === undefined)
+			counts[k] = 0;
+		++counts[k];
+	}
+
+	var zkc1 = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	var zkc2 = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	var ev1 = [];
+	zkc1.on('connect', ev1.push.bind(ev1, 'connect'));
+	zkc1.on('session', ev1.push.bind(ev1, 'session'));
+	zkc1.on('expire', ev1.push.bind(ev1, 'expire'));
+	zkc1.on('disconnect', ev1.push.bind(ev1, 'disconnect'));
+
+	zkc1.on('close', function () {
+		t.deepEqual(ev1,
+		    ['session', 'connect', 'disconnect', 'connect']);
+		if (++closed >= 2)
+			t.end();
+	});
+
+	zkc2.on('close', function () {
+		if (++closed >= 2)
+			t.end();
+	});
+
+	mod_vasync.waterfall([
+		function (cb) {
+			mod_vasync.parallel({
+				funcs: [
+					function (ccb) {
+						zkc1.once('connect', ccb);
+					},
+					function (ccb) {
+						zkc2.once('connect', ccb);
+					}
+				]
+			}, cb);
+		},
+		function (_, cb) {
+			zkc1.once('connect', cb);
+
+			zkc1.watcher('/race1').on('created',
+			    incrCount.bind(this, 'race1'));
+
+			var sock = zkc1.getSession().getConnection().zcf_socket;
+			t.ok(sock.listeners('error').length > 0);
+			sock.emit('error', new Error('I killed it'));
+			sock.destroy();
+
+			zkc1.watcher('/race2').on('created',
+			    incrCount.bind(this, 'race2'));
+
+			setImmediate(function () {
+				zkc1.watcher('/race3').on('created',
+				    incrCount.bind(this, 'race3'));
+			});
+		},
+		function (cb) {
+			var d = new Buffer('hi there', 'ascii');
+			mod_vasync.parallel({
+				funcs: [
+					function (ccb) {
+						zkc2.create('/race1', d,
+						    {}, ccb);
+					},
+					function (ccb) {
+						zkc2.create('/race2', d,
+						    {}, ccb);
+					},
+					function (ccb) {
+						zkc2.create('/race3', d,
+						    {}, ccb);
+					}
+				]
+			}, cb);
+		},
+		function (_, cb) {
+			wait(t, 'watchers have fired', 30000,
+			    function () {
+				return (counts.race1 == 1 &&
+				    counts.race2 == 1 &&
+				    counts.race3 == 1);
+			}, cb);
+		},
+		function (cb) {
+			t.equal(zkc1.getSession().
+			    listeners('stateChanged').length, 1);
+			zkc1.close();
+			zkc2.close();
+			cb();
+		}
+	], function (err) {
+		t.error(err);
+	});
+});
+
 mod_tape.test('session resumption with watcher (ping timeout)', function (t) {
 	var connected = 0;
 	var closed = 0;
@@ -1068,7 +1302,8 @@ mod_tape.test('connect failure: immediate close', function (t) {
 });
 
 mod_tape.test('stop awful zk server', function (t) {
-	zk.close();
-	zk = undefined;
-	t.end();
+	zk.close(function () {
+		zk = undefined;
+		t.end();
+	});
 });
-- 
2.21.0

