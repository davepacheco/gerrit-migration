commit 41044f8ce6e8aadc458d99bb7794723e8c08b836
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-07-02T17:57:32+00:00 (1 year, 3 months ago)
    
    TRITON-389 net-agent should subscribe to NAPI changefeed

diff --git a/lib/aggr-fsm.js b/lib/aggr-fsm.js
index a874297..2a1d25b 100644
--- a/lib/aggr-fsm.js
+++ b/lib/aggr-fsm.js
@@ -127,7 +127,7 @@ AggrFSM.prototype.state_waiting = function (S) {
     });
 
     /*
-     * Refresh periodically.
+     * Refresh periodically for installations w/o changefeed.
      */
     S.timeout(60 * 60 * 1000, function () {
         S.gotoState('refresh');
diff --git a/lib/net-agent.js b/lib/net-agent.js
index e007f7b..2dbb048 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -69,6 +69,7 @@
 'use strict';
 
 var assert = require('assert-plus');
+var mod_changefeed = require('changefeed');
 var mod_clients = require('sdc-clients');
 var mod_cueball = require('cueball');
 var mod_jsprim = require('jsprim');
@@ -92,6 +93,10 @@ function getNetAgentVersion() {
     return _versionCache;
 }
 
+function refreshFSM(_, fsm) {
+    fsm.refresh();
+}
+
 
 // --- Exports
 
@@ -130,6 +135,52 @@ function NetAgent(options) {
         userAgent: userAgent
     });
 
+    this.feed = mod_changefeed.createListener({
+        log: this.log.child({
+            component: 'changefeed',
+            level: 'info'
+        }),
+        url: options.napi.url,
+        instance: this.agent_uuid,
+        service: 'net-agent',
+        resources: [
+            {
+                resource: 'network',
+                subResources: [
+                    'create',
+                    'delete',
+                    'gateway',
+                    'resolvers',
+                    'routes'
+                ]
+            },
+            {
+                resource: 'nic',
+                subResources: [
+                    'create',
+                    'delete',
+                    'allow_dhcp_spoofing',
+                    'allow_ip_spoofing',
+                    'allow_mac_spoofing',
+                    'allow_restricted_traffic',
+                    'allow_unfiltered_promisc'
+                ]
+            },
+            {
+                resource: 'aggregation',
+                subResources: [
+                    'create',
+                    'delete'
+                ]
+            }
+        ],
+        backoff: {
+            maxTimeout: 30000,
+            minTimeout: 5000,
+            retries: Infinity
+        }
+    });
+
     this.watcher = new WatcherFSM({
         app: this
     });
@@ -275,17 +326,29 @@ NetAgent.prototype.state_init = function (S) {
 };
 
 NetAgent.prototype.state_init.watchzones = function (S) {
-    S.validTransitions([ 'running' ]);
+    S.validTransitions([ 'init.watchfeeds' ]);
 
     S.on(this.watcher, 'stateChanged', function (newState) {
         if (newState === 'waiting') {
-            S.gotoState('running');
+            S.gotoState('init.watchfeeds');
         }
     });
 
     this.watcher.start();
 };
 
+NetAgent.prototype.state_init.watchfeeds = function (S) {
+    S.validTransitions([ 'running' ]);
+
+    /*
+     * Ideally we'd wait for the "bootstrap" event so we know
+     * we're connected, but older NAPIs don't have changefeeds.
+     */
+    this.feed.register();
+
+    S.gotoState('running');
+};
+
 NetAgent.prototype.state_running = function (S) {
     var self = this;
 
@@ -294,6 +357,19 @@ NetAgent.prototype.state_running = function (S) {
     S.on(self, 'stopAsserted', function () {
         S.gotoState('stopping');
     });
+
+    /*
+     * Watch events from the NAPI changefeed.
+     */
+    S.on(self.feed, 'readable', function onFeedReadable() {
+        self._cfdrain();
+    });
+
+    S.on(self.feed, 'bootstrap', function onBootstrap(bsinfo) {
+        self._cfbootstrap(bsinfo);
+    });
+
+    self._cfdrain();
 };
 
 NetAgent.prototype.state_stopping = function (S) {
@@ -301,6 +377,7 @@ NetAgent.prototype.state_stopping = function (S) {
 
     S.validTransitions([ 'stopped' ]);
 
+    self.feed.close();
     self.cueballAgent.stop();
 
     S.gotoState('stopped');
@@ -310,4 +387,103 @@ NetAgent.prototype.state_stopped = function (S) {
     S.validTransitions([ ]);
 };
 
+NetAgent.prototype._processAggr = function (change) {
+    var aggr = this.aggrs[change.name];
+
+    if (change.changeKind.subResources.indexOf('delete') !== -1) {
+        if (aggr) {
+            this.releaseAggr(change.name, this.cn_uuid);
+        }
+        return;
+    }
+
+    if (aggr) {
+        aggr.refresh();
+        return;
+    }
+
+    if (change.belongs_to_uuid === this.cn_uuid) {
+        this.watchAggr(change.name);
+        return;
+    }
+};
+
+NetAgent.prototype._processNetwork = function processNetwork(change) {
+    if (!mod_jsprim.hasKey(this.nets, change.changedResourceId)) {
+        return;
+    }
+
+    if (change.changeKind.subResources.indexOf('delete') !== -1) {
+        this.releaseNet(change.changedResourceId);
+        return;
+    }
+
+    this.nets[change.changedResourceId].refresh();
+};
+
+NetAgent.prototype._processNic = function processNic(change) {
+    var mac = change.changedResourceId;
+    var nic = this.nics[mac];
+
+    if (change.changeKind.subResources.indexOf('delete') !== -1) {
+        if (nic) {
+            this.releaseNic(mac, change.belongs_to_uuid);
+        }
+        return;
+    }
+
+    if (nic) {
+        nic.refresh();
+        return;
+    }
+
+    if (change.cn_uuid === this.cn_uuid) {
+        this.watchNic(mac);
+        return;
+    }
+};
+
+NetAgent.prototype._cfdrain = function drainChangeFeed() {
+    var change, resource;
+
+    while ((change = this.feed.read()) !== null) {
+        resource = change.changeKind.resource;
+
+        switch (resource) {
+        case 'aggregation':
+            this._processAggr(change);
+            break;
+        case 'network':
+            this._processNetwork(change);
+            break;
+        case 'nic':
+            this._processNic(change);
+            break;
+        default:
+            this.log.warn({ change: change },
+                'unknown resource type %j', resource);
+            break;
+        }
+    }
+};
+
+NetAgent.prototype._cfbootstrap = function bootstrapChangeFeed(bsinfo) {
+    assert.object(bsinfo, 'bsinfo');
+
+    switch (bsinfo.resource) {
+    case 'aggregation':
+        mod_jsprim.forEachKey(this.aggrs, refreshFSM);
+        break;
+    case 'network':
+        mod_jsprim.forEachKey(this.nets, refreshFSM);
+        break;
+    case 'nic':
+        mod_jsprim.forEachKey(this.nics, refreshFSM);
+        break;
+    default:
+        this.log.warn({ bootstrap: bsinfo }, 'unrecognized bootstrap resource');
+        break;
+    }
+};
+
 module.exports = NetAgent;
diff --git a/lib/net-fsm.js b/lib/net-fsm.js
index df20f4b..afc4435 100644
--- a/lib/net-fsm.js
+++ b/lib/net-fsm.js
@@ -76,7 +76,7 @@ NetworkFSM.prototype.state_waiting = function (S) {
     }
 
     /*
-     * Refresh periodically.
+     * Refresh periodically for installations w/o changefeed.
      */
     S.timeout(5 * 60 * 1000, function () {
         S.gotoState('refresh');
diff --git a/lib/nic-fsm.js b/lib/nic-fsm.js
index 3f0301f..1c7d828 100644
--- a/lib/nic-fsm.js
+++ b/lib/nic-fsm.js
@@ -192,7 +192,7 @@ NicFSM.prototype.state_waiting = function (S) {
     });
 
     /*
-     * Refresh periodically.
+     * Refresh periodically for installations w/o changefeed.
      *
      * Since most of our important attributes live on the network object, we
      * wait an hour to check here, and rely on the network information refresh
diff --git a/package.json b/package.json
index 0d5c8b3..3b31d49 100644
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "dependencies": {
         "assert-plus": "^1.0.0",
         "bunyan": "1.8.12",
+        "changefeed": "git+https://github.com/joyent/node-sdc-changefeed.git#new-registration",
         "cueball": "2.5.1",
         "forkexec": "1.1.0",
         "jsprim": "1.4.1",
