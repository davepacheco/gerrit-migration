From 8cc06883a01b0f98b99c573c941aa94e7211de8c Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 19 May 2017 00:42:54 +0000
Subject: [PATCH] joyent/node-vasync#32 Would like a tryEach function

---
 Makefile                |   2 +-
 README.md               |  56 +++++++++++
 lib/vasync.js           | 205 ++++++++++++++++++++++------------------
 package.json            |   4 +-
 tests/compat_tryEach.js |  91 ++++++++++++++++++
 5 files changed, 264 insertions(+), 94 deletions(-)
 create mode 100644 tests/compat_tryEach.js

diff --git a/Makefile b/Makefile
index 32b2d4a..21bfe69 100644
--- a/Makefile
+++ b/Makefile
@@ -17,7 +17,7 @@ JSSTYLE		 = jsstyle
 #
 # Files
 #
-JS_FILES	:= $(shell find lib tests -name '*.js' -not -name compat.js)
+JS_FILES	:= $(shell find lib tests -name '*.js' -not -name compat\*.js)
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSL_CONF_NODE	 = jsl.node.conf
diff --git a/README.md b/README.md
index 170be46..44cacda 100644
--- a/README.md
+++ b/README.md
@@ -41,6 +41,8 @@ have several ways of getting at this state:
   invoke the same function on N inputs in parallel
 * [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke
   N functions in series (and stop on failure)
+* [tryEach](#tryeach-invoke-n-functions-in-series-and-stop-on-success): invoke
+  N functions in series (and stop on success)
 * [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):
   invoke the same function on N inputs in series (and stop on failure)
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
@@ -225,6 +227,60 @@ Note that the second and third stages are now "waiting", rather than "pending"
 in the `parallel` case.  The error and complete result look just like the
 parallel case.
 
+### tryEach: invoke N functions in series (and stop on success)
+
+Synopsis: `tryEach(funcs, callback)`
+
+This function is like `pipeline` except that instead of stopping on failure, it
+stops on success. The callback gets called with the (err, results) of either a)
+the first successful function or b) the last function to fail (if all have
+failed). Unlike `waterfall`, nothing gets propogated between calls --- instead,
+we pass all results to callback (as an array) when the pipeline halts.
+
+This example is similar to the one above, except that it runs the steps in
+sequence and stops early because `tryEach` stops on the first success:
+
+```js
+console.log(mod_vasync.tryEach([
+        function f1 (callback) { mod_fs.stat('/notreal', callback); },
+        function f2 (callback) { mod_fs.stat('/noexist', callback); },
+        function f3 (callback) { mod_fs.stat('/var', callback); },
+        function f4 (callback) { mod_fs.stat('/noexist', callback); }
+    ],
+    function (err, results) {
+            console.log('error: %s', err);
+            console.log('results: %s', mod_util.inspect(results));
+}));
+
+```
+
+The the above code will stop when it finishes f3, and we will only print a
+single result and no errors:
+
+```js
+error: null
+results: { dev: 65760,
+  mode: 16877,
+  nlink: 41,
+  uid: 0,
+  gid: 3,
+  rdev: -1,
+  blksize: 2560,
+  ino: 11,
+  size: 41,
+  blocks: 7,
+  atime: Thu May 28 2015 16:21:25 GMT+0000 (UTC),
+  mtime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC),
+  ctime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC) }
+```
+
+If we comment out `f3`, we get the following output:
+
+```js
+error: Error: ENOENT, stat '/noexist'
+results: undefined
+```
+
 
 ### forEachPipeline: invoke the same function on N inputs in series (and stop on failure)
 
diff --git a/lib/vasync.js b/lib/vasync.js
index ccc3e2a..eafb3a7 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -13,6 +13,7 @@ var mod_verror = require('verror');
 exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
 exports.pipeline = pipeline;
+exports.tryEach = tryEach;
 exports.forEachPipeline = forEachPipeline;
 exports.queue = queue;
 exports.queuev = queuev;
@@ -149,76 +150,34 @@ function forEachParallel(args, callback)
  */
 function pipeline(args, callback)
 {
-	var funcs, uarg, rv, next;
-
 	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
 	mod_assert.ok(Array.isArray(args['funcs']),
 	    '"args.funcs" must be specified and must be an array');
 
-	funcs = args['funcs'].slice(0);
-	uarg = args['arg'];
-
-	rv = {
-	    'operations': funcs.map(function (func) {
-		return ({
-		    'func': func,
-		    'funcname': func.name || '(anon)',
-		    'status': 'waiting'
-		});
-	    }),
-	    'successes': [],
-	    'ndone': 0,
-	    'nerrors': 0
+	var opts = {
+	    'funcs': args['funcs'].slice(0),
+	    'callback': callback,
+	    'args': { impl: 'pipeline', uarg: args['arg'] },
+	    'stop_when': 'error',
+	    'res_type': 'values'
 	};
+	return (waterfall_impl(opts));
+}
 
-	if (funcs.length === 0) {
-		setImmediate(function () { callback(null, rv); });
-		return (rv);
-	}
-
-	next = function (err, result) {
-		if (rv['nerrors'] > 0 ||
-		    rv['ndone'] >= rv['operations'].length) {
-			throw new mod_verror.VError('pipeline callback ' +
-			    'invoked after the pipeline has already ' +
-			    'completed (%j)', rv);
-		}
-
-		var entry = rv['operations'][rv['ndone']++];
-
-		mod_assert.equal(entry['status'], 'pending');
-
-		entry['status'] = err ? 'fail' : 'ok';
-		entry['err'] = err;
-		entry['result'] = result;
-
-		if (err)
-			rv['nerrors']++;
-		else
-			rv['successes'].push(result);
-
-		if (err || rv['ndone'] == funcs.length) {
-			callback(err, rv);
-		} else {
-			var nextent = rv['operations'][rv['ndone']];
-			nextent['status'] = 'pending';
-
-			/*
-			 * We invoke the next function on the next tick so that
-			 * the caller (stage N) need not worry about the case
-			 * that the next stage (stage N + 1) runs in its own
-			 * context.
-			 */
-			setImmediate(function () {
-				nextent['func'](uarg, next);
-			});
-		}
+function tryEach(funcs, callback)
+{
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+	var opts = {
+	    'funcs': funcs.slice(0),
+	    'callback': callback,
+	    'args': { impl: 'tryEach' },
+	    'stop_when': 'success',
+	    'res_type': 'array'
 	};
-
-	rv['operations'][0]['status'] = 'pending';
-	funcs[0](uarg, next);
-
-	return (rv);
+	return (waterfall_impl(opts));
 }
 
 /*
@@ -231,23 +190,23 @@ function pipeline(args, callback)
  *	inputs		array of input values
  */
 function forEachPipeline(args, callback) {
-    mod_assert.equal(typeof (args), 'object', '"args" must be an object');
-    mod_assert.equal(typeof (args['func']), 'function',
-		'"args.func" must be specified and must be a function');
-    mod_assert.ok(Array.isArray(args['inputs']),
-		'"args.inputs" must be specified and must be an array');
-    mod_assert.equal(typeof (callback), 'function',
-		'callback argument must be specified and must be a function');
+	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
+	mod_assert.equal(typeof (args['func']), 'function',
+	    '"args.func" must be specified and must be a function');
+	mod_assert.ok(Array.isArray(args['inputs']),
+	    '"args.inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (callback), 'function',
+	    'callback argument must be specified and must be a function');
 
-    var func = args['func'];
+	var func = args['func'];
 
-    var funcs = args['inputs'].map(function (input) {
+	var funcs = args['inputs'].map(function (input) {
 		return (function (_, subcallback) {
-			return (func(input, subcallback));
-		});
-    });
+				return (func(input, subcallback));
+			});
+	});
 
-    return (pipeline({'funcs': funcs}, callback));
+	return (pipeline({'funcs': funcs}, callback));
 }
 
 
@@ -535,11 +494,44 @@ Barrier.prototype.done = function (name)
  */
 function waterfall(funcs, callback)
 {
-	var rv, current, next;
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+	var opts = {
+	    'funcs': funcs.slice(0),
+	    'callback': callback,
+	    'args': { impl: 'waterfall' },
+	    'stop_when': 'error',
+	    'res_type': 'values'
+	};
+	return (waterfall_impl(opts));
+}
 
-	mod_assert.ok(Array.isArray(funcs));
-	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function');
-	funcs = funcs.slice(0);
+function waterfall_impl(opts)
+{
+	mod_assert.ok(typeof (opts) === 'object');
+	var rv, current, next;
+	var funcs = opts.funcs;
+	var callback = opts.callback;
+
+	mod_assert.ok(Array.isArray(funcs),
+	    '"opts.funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1,
+	    'Function "waterfall_impl" must take only 1 arg');
+	mod_assert.ok(opts.res_type === 'values' ||
+	    opts.res_type === 'array',
+	    '"opts.res_type" must either be "value" or "array"');
+	mod_assert.ok(opts.stop_when === 'error' ||
+	    opts.stop_when === 'success',
+	    '"opts.stop_when" must either be "error" or "success"');
+	mod_assert.ok(opts.args.impl === 'pipeline' ||
+	    opts.args.impl === 'waterfall' || opts.args.impl === 'tryEach',
+	    '"opts.args.impl" must be "pipeline", "waterfall", or "tryEach"');
+	if (opts.args.impl === 'pipeline') {
+		mod_assert.ok(typeof (opts.args.uarg) !== undefined,
+		    '"opts.args.uarg" should be defined when pipeline is used');
+	}
 
 	rv = {
 	    'operations': funcs.map(function (func) {
@@ -556,12 +548,16 @@ function waterfall(funcs, callback)
 
 	if (funcs.length === 0) {
 		if (callback)
-			setImmediate(function () { callback(null, rv); });
+			setImmediate(function () {
+				var res = (opts.args.impl === 'pipeline') ? rv
+				    : undefined;
+				callback(null, res);
+			});
 		return (rv);
 	}
 
 	next = function (idx, err) {
-		var args, entry, nextentry;
+		var res_key, args, entry, nextentry;
 
 		if (err === undefined)
 			err = null;
@@ -573,24 +569,42 @@ function waterfall(funcs, callback)
 			    rv['operations'][idx].funcname));
 		}
 
-		mod_assert.equal(idx, rv['ndone']);
+		mod_assert.equal(idx, rv['ndone'],
+		    'idx should be equal to ndone');
 		entry = rv['operations'][rv['ndone']++];
-		args = Array.prototype.slice.call(arguments, 2);
+		if (opts.args.impl === 'tryEach' ||
+		    opts.args.impl === 'waterfall') {
+			args = Array.prototype.slice.call(arguments, 2);
+			res_key = 'results';
+		} else if (opts.args.impl === 'pipeline') {
+			args = [ opts.args.uarg ];
+			res_key = 'result';
+		}
 
-		mod_assert.equal(entry['status'], 'pending');
+		mod_assert.equal(entry['status'], 'pending',
+		    'status should be pending');
 		entry['status'] = err ? 'fail' : 'ok';
 		entry['err'] = err;
-		entry['results'] = args;
+		entry[res_key] = args;
 
 		if (err)
 			rv['nerrors']++;
 		else
 			rv['successes'].push(args);
 
-		if (err || rv['ndone'] == funcs.length) {
+		if ((opts.stop_when === 'error' && err) ||
+		    (opts.stop_when === 'success' &&
+		    rv['successes'].length > 0) ||
+		    rv['ndone'] == funcs.length) {
 			if (callback) {
-				args.unshift(err);
-				callback.apply(null, args);
+				if (opts.res_type === 'values' ||
+				    (opts.res_type === 'array' &&
+				     args.length <= 1)) {
+					args.unshift(err);
+					callback.apply(null, args);
+				} else if (opts.res_type === 'array') {
+					callback(err, args);
+				}
 			}
 		} else {
 			nextentry = rv['operations'][rv['ndone']];
@@ -598,13 +612,22 @@ function waterfall(funcs, callback)
 			current++;
 			args.push(next.bind(null, current));
 			setImmediate(function () {
-				nextentry['func'].apply(null, args);
+				var nfunc = nextentry['func'];
+				if (opts.args.impl !== 'tryEach') {
+					nfunc.apply(null, args);
+				} else {
+					nfunc(next.bind(null, current));
+				}
 			});
 		}
 	};
 
 	rv['operations'][0]['status'] = 'pending';
 	current = 0;
-	funcs[0](next.bind(null, current));
+	if (opts.args.impl !== 'pipeline') {
+		funcs[0](next.bind(null, current));
+	} else {
+		funcs[0](opts.args.uarg, next.bind(null, current));
+	}
 	return (rv);
 }
diff --git a/package.json b/package.json
index 9a263cb..7c842de 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "vasync",
-	"version": "1.6.4",
+	"version": "2.0.0",
 	"description": "utilities for observable asynchronous control flow",
 	"main": "./lib/vasync.js",
 	"repository": {
@@ -8,7 +8,7 @@
 		"url": "git://github.com/davepacheco/node-vasync.git"
 	},
 	"scripts": {
-		"test": "./node_modules/.bin/tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
+		"test": "./node_modules/.bin/tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js && ./node_modules/.bin/nodeunit tests/compat_tryEach.js"
 	},
 	"devDependencies": {
 		"tap": "~0.4.8",
diff --git a/tests/compat_tryEach.js b/tests/compat_tryEach.js
new file mode 100644
index 0000000..d667297
--- /dev/null
+++ b/tests/compat_tryEach.js
@@ -0,0 +1,91 @@
+var async = require('../lib/vasync');
+
+/*
+ * tryEach tests, transliterated from mocha to tap.
+ *
+ * They are nearly identical except for some details related to vasync. For
+ * example, the `results` variable that gets passed to the callback is never
+ * undefined.
+ */
+
+
+exports['tryEach no callback'] = function (test) {
+    async.tryEach([]);
+    test.done();
+};
+exports['tryEach empty'] = function (test) {
+    async.tryEach([], function (err, results) {
+        test.equals(err, null);
+        test.same(results, undefined);
+        test.done();
+    });
+};
+exports['tryEach one task, multiple results'] = function (test) {
+    var RESULTS = ['something', 'something2'];
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULTS[0], RESULTS[1]);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULTS);
+        test.done();
+    });
+};
+exports['tryEach one task'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
+exports['tryEach two tasks, one failing'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(new Error('Failure'), {});
+        },
+        function (callback) {
+            callback(null, RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
+exports['tryEach two tasks, both failing'] = function (test) {
+    var ERROR_RESULT = new Error('Failure2');
+    async.tryEach([
+        function (callback) {
+            callback(new Error('Should not stop here'));
+        },
+        function (callback) {
+            callback(ERROR_RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, ERROR_RESULT);
+        test.same(results, undefined);
+        test.done();
+    });
+};
+exports['tryEach two tasks, non failing'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULT);
+        },
+        function () {
+            test.fail('Should not been called');
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
-- 
2.21.0

