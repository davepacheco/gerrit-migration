commit 8416f1d76d0f1e89f35a25e30d398f77b6fba189 (refs/changes/77/1977/4)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2017-05-19T01:09:51+00:00 (2 years, 5 months ago)
    
    joyent/node-vasync#32 Would like a tryEach function

diff --git a/lib/vasync.js b/lib/vasync.js
index ccc3e2a..a4dc6a8 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -13,6 +13,7 @@ var mod_verror = require('verror');
 exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
 exports.pipeline = pipeline;
+exports.tryEach = tryEach;
 exports.forEachPipeline = forEachPipeline;
 exports.queue = queue;
 exports.queuev = queuev;
@@ -149,76 +150,32 @@ function forEachParallel(args, callback)
  */
 function pipeline(args, callback)
 {
-	var funcs, uarg, rv, next;
-
 	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
 	mod_assert.ok(Array.isArray(args['funcs']),
 	    '"args.funcs" must be specified and must be an array');
 
-	funcs = args['funcs'].slice(0);
-	uarg = args['arg'];
-
-	rv = {
-	    'operations': funcs.map(function (func) {
-		return ({
-		    'func': func,
-		    'funcname': func.name || '(anon)',
-		    'status': 'waiting'
-		});
-	    }),
-	    'successes': [],
-	    'ndone': 0,
-	    'nerrors': 0
+	var opts = {
+	    funcs: args['funcs'].slice(0),
+	    callback: callback,
+	    args: { impl: 'pipeline', uarg: args['arg'] },
+	    stop_when: 'error',
+	    res_type: 'values'
 	};
+	return (waterfall_impl(opts));
+}
 
-	if (funcs.length === 0) {
-		setImmediate(function () { callback(null, rv); });
-		return (rv);
-	}
-
-	next = function (err, result) {
-		if (rv['nerrors'] > 0 ||
-		    rv['ndone'] >= rv['operations'].length) {
-			throw new mod_verror.VError('pipeline callback ' +
-			    'invoked after the pipeline has already ' +
-			    'completed (%j)', rv);
-		}
-
-		var entry = rv['operations'][rv['ndone']++];
-
-		mod_assert.equal(entry['status'], 'pending');
-
-		entry['status'] = err ? 'fail' : 'ok';
-		entry['err'] = err;
-		entry['result'] = result;
-
-		if (err)
-			rv['nerrors']++;
-		else
-			rv['successes'].push(result);
-
-		if (err || rv['ndone'] == funcs.length) {
-			callback(err, rv);
-		} else {
-			var nextent = rv['operations'][rv['ndone']];
-			nextent['status'] = 'pending';
-
-			/*
-			 * We invoke the next function on the next tick so that
-			 * the caller (stage N) need not worry about the case
-			 * that the next stage (stage N + 1) runs in its own
-			 * context.
-			 */
-			setImmediate(function () {
-				nextent['func'](uarg, next);
-			});
-		}
+function tryEach(funcs, callback)
+{
+	mod_assert.ok(Array.isArray(funcs));
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function');
+	var opts = {
+	    funcs: funcs.slice(0),
+	    callback: callback,
+	    args: { impl: 'tryEach' },
+	    stop_when: 'success',
+	    res_type: 'array'
 	};
-
-	rv['operations'][0]['status'] = 'pending';
-	funcs[0](uarg, next);
-
-	return (rv);
+	return (waterfall_impl(opts));
 }
 
 /*
@@ -231,23 +188,23 @@ function pipeline(args, callback)
  *	inputs		array of input values
  */
 function forEachPipeline(args, callback) {
-    mod_assert.equal(typeof (args), 'object', '"args" must be an object');
-    mod_assert.equal(typeof (args['func']), 'function',
-		'"args.func" must be specified and must be a function');
-    mod_assert.ok(Array.isArray(args['inputs']),
-		'"args.inputs" must be specified and must be an array');
-    mod_assert.equal(typeof (callback), 'function',
-		'callback argument must be specified and must be a function');
+	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
+	mod_assert.equal(typeof (args['func']), 'function',
+	    '"args.func" must be specified and must be a function');
+	mod_assert.ok(Array.isArray(args['inputs']),
+	    '"args.inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (callback), 'function',
+	    'callback argument must be specified and must be a function');
 
-    var func = args['func'];
+	var func = args['func'];
 
-    var funcs = args['inputs'].map(function (input) {
+	var funcs = args['inputs'].map(function (input) {
 		return (function (_, subcallback) {
-			return (func(input, subcallback));
-		});
-    });
+				return (func(input, subcallback));
+			});
+	});
 
-    return (pipeline({'funcs': funcs}, callback));
+	return (pipeline({'funcs': funcs}, callback));
 }
 
 
@@ -534,12 +491,36 @@ Barrier.prototype.done = function (name)
  * were emitted by the previous function followed by the callback.
  */
 function waterfall(funcs, callback)
+{
+	mod_assert.ok(Array.isArray(funcs));
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function');
+	var opts = {
+	    funcs: funcs.slice(0),
+	    callback: callback,
+	    args: { impl: 'waterfall' },
+	    stop_when: 'error',
+	    res_type: 'values'
+	};
+	return (waterfall_impl(opts));
+}
+
+function waterfall_impl(opts)
 {
 	var rv, current, next;
+	var funcs = opts.funcs;
+	var callback = opts.callback;
 
 	mod_assert.ok(Array.isArray(funcs));
-	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function');
-	funcs = funcs.slice(0);
+	mod_assert.ok(arguments.length == 1);
+	mod_assert.ok(opts.res_type === 'values' ||
+	    opts.res_type === 'array');
+	mod_assert.ok(opts.stop_when === 'error' ||
+	    opts.stop_when === 'success');
+	mod_assert.ok(opts.args.impl === 'pipeline' ||
+	opts.args.impl === 'waterfall' || opts.args.impl === 'tryEach');
+	if (opts.args.impl === 'pipeline') {
+	    mod_assert.ok(typeof (opts.args.uarg) !== undefined);
+	}
 
 	rv = {
 	    'operations': funcs.map(function (func) {
@@ -556,12 +537,16 @@ function waterfall(funcs, callback)
 
 	if (funcs.length === 0) {
 		if (callback)
-			setImmediate(function () { callback(null, rv); });
+			setImmediate(function () {
+				var res = (opts.args.impl === 'pipeline') ? rv
+				    : undefined;
+				callback(null, res);
+			});
 		return (rv);
 	}
 
 	next = function (idx, err) {
-		var args, entry, nextentry;
+		var res_key, args, entry, nextentry;
 
 		if (err === undefined)
 			err = null;
@@ -575,22 +560,38 @@ function waterfall(funcs, callback)
 
 		mod_assert.equal(idx, rv['ndone']);
 		entry = rv['operations'][rv['ndone']++];
-		args = Array.prototype.slice.call(arguments, 2);
+		if (opts.args.impl === 'tryEach' ||
+		    opts.args.impl === 'waterfall') {
+			args = Array.prototype.slice.call(arguments, 2);
+			res_key = 'results';
+		} else if (opts.args.impl === 'pipeline') {
+			args = [ opts.args.uarg ];
+			res_key = 'result';
+		}
 
 		mod_assert.equal(entry['status'], 'pending');
 		entry['status'] = err ? 'fail' : 'ok';
 		entry['err'] = err;
-		entry['results'] = args;
+		entry[res_key] = args;
 
 		if (err)
 			rv['nerrors']++;
 		else
 			rv['successes'].push(args);
 
-		if (err || rv['ndone'] == funcs.length) {
+		if ((opts.stop_when === 'error' && err) ||
+		    (opts.stop_when === 'success' &&
+		    rv['successes'].length > 0) ||
+		    rv['ndone'] == funcs.length) {
 			if (callback) {
-				args.unshift(err);
-				callback.apply(null, args);
+				if (opts.res_type === 'values' ||
+				    (opts.res_type === 'array' &&
+				     args.length <= 1)) {
+					args.unshift(err);
+					callback.apply(null, args);
+				} else if (opts.res_type === 'array') {
+					callback(err, args);
+				}
 			}
 		} else {
 			nextentry = rv['operations'][rv['ndone']];
@@ -598,13 +599,22 @@ function waterfall(funcs, callback)
 			current++;
 			args.push(next.bind(null, current));
 			setImmediate(function () {
-				nextentry['func'].apply(null, args);
+				var nfunc = nextentry['func'];
+				if (opts.args.impl !== 'tryEach') {
+					nfunc.apply(null, args);
+				} else {
+					nfunc(next.bind(null, current));
+				}
 			});
 		}
 	};
 
 	rv['operations'][0]['status'] = 'pending';
 	current = 0;
-	funcs[0](next.bind(null, current));
+	if (opts.args.impl !== 'pipeline') {
+		funcs[0](next.bind(null, current));
+	} else {
+		funcs[0](opts.args.uarg, next.bind(null, current));
+	}
 	return (rv);
 }
diff --git a/package.json b/package.json
index 9a263cb..0762cdb 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "vasync",
-	"version": "1.6.4",
+	"version": "1.7.0",
 	"description": "utilities for observable asynchronous control flow",
 	"main": "./lib/vasync.js",
 	"repository": {
@@ -8,7 +8,7 @@
 		"url": "git://github.com/davepacheco/node-vasync.git"
 	},
 	"scripts": {
-		"test": "./node_modules/.bin/tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
+		"test": "./node_modules/.bin/tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
 	},
 	"devDependencies": {
 		"tap": "~0.4.8",
diff --git a/tests/compat.js b/tests/compat.js
index 8461a82..2cb733c 100644
--- a/tests/compat.js
+++ b/tests/compat.js
@@ -102,3 +102,93 @@ exports['waterfall error'] = function(test){
     });
     setTimeout(test.done, 50);
 };
+
+/*
+ * tryEach tests, transliterated from mocha to tap.
+ *
+ * They are nearly identical except for some details related to vasync. For
+ * example, the `results` variable that gets passed to the callback is never
+ * undefined.
+ */
+
+
+exports['tryEach no callback'] = function (test) {
+    async.tryEach([]);
+    test.done();
+};
+exports['tryEach empty'] = function (test) {
+    async.tryEach([], function (err, results) {
+        test.equals(err, null);
+        test.same(results, undefined);
+        test.done();
+    });
+};
+exports['tryEach one task, multiple results'] = function (test) {
+    var RESULTS = ['something', 'something2'];
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULTS[0], RESULTS[1]);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULTS);
+        test.done();
+    });
+};
+exports['tryEach one task'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
+exports['tryEach two tasks, one failing'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(new Error('Failure'), {});
+        },
+        function (callback) {
+            callback(null, RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
+exports['tryEach two tasks, both failing'] = function (test) {
+    var ERROR_RESULT = new Error('Failure2');
+    async.tryEach([
+        function (callback) {
+            callback(new Error('Should not stop here'));
+        },
+        function (callback) {
+            callback(ERROR_RESULT);
+        }
+    ], function (err, results) {
+        test.equals(err, ERROR_RESULT);
+        test.same(results, undefined);
+        test.done();
+    });
+};
+exports['tryEach two tasks, non failing'] = function (test) {
+    var RESULT = 'something';
+    async.tryEach([
+        function (callback) {
+            callback(null, RESULT);
+        },
+        function () {
+            assert.fail('Should not been called');
+        },
+    ], function (err, results) {
+        test.equals(err, null);
+        test.same(results, RESULT);
+        test.done();
+    });
+};
