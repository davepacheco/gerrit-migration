From a65c4ec932a82508d88bb3a2d2cd4d63c0083cfa Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Mon, 19 Nov 2018 20:36:47 -0800
Subject: [PATCH] TRITON-955 dummy cn-agent should support installation of
 agents

---
 lib/app.js                                 | 102 +----
 lib/backends/dummy/common.js               | 233 +++++++++--
 lib/backends/dummy/index.js                |  80 ++--
 lib/backends/dummy/tasks/agent_install.js  | 452 +++++++++++++++++++++
 lib/backends/dummy/tasks/refresh_agents.js |  54 +++
 lib/backends/dummy/tasks/shared.js         |  87 ++++
 lib/backends/smartos/index.js              | 112 +++++
 7 files changed, 971 insertions(+), 149 deletions(-)
 create mode 100644 lib/backends/dummy/tasks/agent_install.js
 create mode 100644 lib/backends/dummy/tasks/refresh_agents.js
 create mode 100644 lib/backends/dummy/tasks/shared.js

diff --git a/lib/app.js b/lib/app.js
index 38c1c06..c860256 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -133,97 +133,29 @@ App.prototype.createCnapiConnection = function createCnapiConnection(callback) {
 App.prototype.updateAgents = function (callback) {
     var self = this;
 
-    if (self.config.skip_agents_update) {
-        self.log.warn('skip_agents_update set, skipping agents update');
-        callback();
-        return;
-    }
-
     assert.object(self.cnapiClient, 'self.cnapiClient');
 
-    var agents = self.sysinfo['SDC Agents'];
-    var agents_dir = '/opt/smartdc/agents/lib/node_modules';
-
-    fs.readdir(agents_dir, function (err, files) {
+    self.backend.getAgents({
+        serverUuid: self.uuid,
+        sysinfo: self.sysinfo
+    }, function gotAgents(err, agents) {
         if (err) {
-            callback(err);
+            callback(new verror.VError('Cannot get agents image versions'));
             return;
         }
-        async.each(files, function getImageAndUUID(name, cb) {
-            var uuid_path = '/opt/smartdc/agents/etc/' + name;
-            var uuidFileExists;
-            var uuid;
-            var image_uuid;
-            async.series([
-                function getImage(next) {
-                    var fpath = agents_dir + '/' + name + '/image_uuid';
-                    fs.readFile(fpath, {
-                        encoding: 'utf8'
-                    }, function (er2, img_uuid) {
-                        if (er2) {
-                            next(er2);
-                            return;
-                        }
-                        image_uuid = img_uuid.trim();
-                        next();
-                    });
-                },
-                function agentUuidFileExists(next) {
-                    fs.exists(uuid_path, function (exists) {
-                        if (exists) {
-                            uuidFileExists = true;
-                        }
-                        next();
-                    });
-                },
-                function getUUID(next) {
-                    if (!uuidFileExists) {
-                        next();
-                        return;
-                    }
-                    fs.readFile(uuid_path, {
-                        encoding: 'utf8'
-                    }, function (er2, agent_uuid) {
-                        if (er2) {
-                            next(er2);
-                            return;
-                        }
-                        uuid = agent_uuid.trim();
-                        next();
-                    });
-                }
-            ], function seriesCb(er2, results) {
-                if (er2) {
-                    cb(er2);
-                    return;
-                }
-                agents.forEach(function (a) {
-                    if (a.name === name) {
-                        a.image_uuid = image_uuid;
-                        if (uuid) {
-                            a.uuid = uuid;
-                        }
-                    }
-                });
-                cb();
-            });
-        }, function (er3) {
-            if (er3) {
-                callback(new verror.VError('Cannot get agents image versions'));
-                return;
+
+        self.log.info({ agents: agents }, 'Posting agents');
+        self.cnapiClient.post('/servers/' + self.uuid, {
+            agents: agents
+        }, function (postErr) {
+            if (postErr) {
+                self.log.warn({ error: postErr },
+                    'error posting agents to cnapi');
+            } else {
+                self.log.info('posted agents info to cnapi');
             }
-            self.log.info({agents: agents}, 'Posting agents');
-            self.cnapiClient.post('/servers/' + self.uuid, {
-                agents: agents
-            }, function (er4) {
-                if (er4) {
-                    self.log.warn({ error: er4 }, 'posting agents to cnapi');
-                } else {
-                    self.log.info('posted agents info to cnapi');
-                }
-                callback();
-                return;
-            });
+
+            callback();
         });
     });
 };
diff --git a/lib/backends/dummy/common.js b/lib/backends/dummy/common.js
index e64c67c..3dbc7cc 100644
--- a/lib/backends/dummy/common.js
+++ b/lib/backends/dummy/common.js
@@ -17,9 +17,10 @@
 var child_process = require('child_process');
 var execFile = child_process.execFile;
 var fs = require('fs');
+var path = require('path');
 
 var assert = require('assert-plus');
-var async = require('async');
+var vasync = require('vasync');
 
 var mockcloudRoot;
 try {
@@ -35,6 +36,13 @@ try {
 }
 var SERVER_ROOT = mockcloudRoot + '/servers';
 
+
+// These are used for caching the results of mdata-get so we don't need to
+// re-run that for every server when we have multiple servers.
+var cachedDatacenterName;
+var cachedDNSDomain;
+
+
 function mdataGet(key, callback) {
     assert.string(key, 'key');
     assert.func(callback, 'callback');
@@ -69,49 +77,222 @@ function provisionInProgressFile(uuidOrZonename, callback) {
 }
 
 function ensureProvisionComplete(uuid, callback) {
+    assert.uuid(uuid, 'uuid');
+    assert.func(callback, 'callback');
+
     var filename = '/var/tmp/machine-provision-' + uuid;
-    var expiresAt;
     var timeoutMinutes = 10;
 
-    function checkIfReady() {
-        fs.exists(filename, function (exists) {
-            if (!exists) {
-                return callback();
+    function callbackWhenComplete() {
+        fs.stat(filename, function (err, stats) {
+            var expiresAt;
+            var now;
+
+            if (err) {
+                if (err.code === 'ENOENT') {
+                    // File is gone, provision is complete.
+                    callback();
+                    return;
+                }
+                // We don't know, something is wrong.
+                callback(err);
+                return;
+            }
+
+            expiresAt = timeoutMinutes * 60 * 1000 + stats.ctime;
+            now = Date.now();
+
+            if (now > expiresAt) {
+                // Expired, so consider provision complete and delete file.
+                fs.unlink(filename, function () {
+                    callback();
+                    return;
+                });
+            } else {
+                // Not expired yet, so try again in 1 second.
+                setTimeout(checkIfReady, 1000);
+            }
+        });
+    }
+
+    callbackWhenComplete();
+}
+
+function getSdcConfig(callback) {
+    var config = {};
+
+    if (cachedDatacenterName !== undefined && cachedDNSDomain !== undefined) {
+        callback(null, {
+            datacenter_name: cachedDatacenterName,
+            dns_domain: cachedDNSDomain
+        });
+        return;
+    }
+
+    mdataGet('sdc:datacenter_name', function _onDC(dcErr, datacenter) {
+        if (dcErr) {
+            callback(dcErr);
+            return;
+        }
+
+        config.datacenter_name = datacenter;
+
+        mdataGet('dnsDomain', function _onDomain(domErr, dnsDomain) {
+            if (domErr) {
+                callback(domErr);
+                return;
+            }
+
+            config.dns_domain = dnsDomain;
+
+            // Since we succeeded, cache these values.
+            cachedDatacenterName = datacenter;
+            cachedDNSDomain = dnsDomain;
+
+            callback(null, config);
+        });
+    });
+}
+
+function getAgent(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.string(opts.agentsDir, 'opts.agentsDir');
+    assert.string(opts.subDir, 'opts.subDir');
+    assert.func(callback, 'callback');
+
+    var agent = {
+        name: opts.subDir // might be replaced if we have a package.json
+    };
+    var agentDir;
+
+    agentDir = path.join(opts.agentsDir, opts.subDir);
+
+    function _getUuidFile(filename, key, cb) {
+        var fn = path.join(agentDir, filename);
+
+        fs.readFile(fn, function _readFile(err, data) {
+            if (err) {
+                if (err.code === 'ENOENT') {
+                    cb();
+                } else {
+                    cb(err);
+                }
+                return;
             }
 
-            return async.waterfall([
-                function (wf$callback) {
-                    if (!expiresAt) {
-                        fs.stat(filename, function (error, stats) {
-                            expiresAt =
-                                timeoutMinutes * 60 * 1000 + stats.ctime;
-                            return wf$callback(error);
-                        });
+            agent[key] = data.toString().trim();
+            assert.uuid(agent[key], 'agent.' + key);
+
+            cb();
+        });
+    }
+
+    vasync.pipeline({funcs: [
+        function _getImageUuid(_, cb) {
+            _getUuidFile('image_uuid', 'image_uuid', cb);
+        },
+        function getInstanceUuid(_, cb) {
+            _getUuidFile('instance_uuid', 'uuid', cb);
+        },
+        function getPackageJSON(_, cb) {
+            var fn = path.join(agentDir, 'package.json');
+            var pkgJSON;
+
+            fs.readFile(fn, function _readFile(err, data) {
+                if (err) {
+                    if (err.code === 'ENOENT') {
+                        cb();
+                    } else {
+                        cb(err);
                     }
-                    return wf$callback();
+                    return;
                 }
-            ],
-            function (error) {
-                // Check if we exceeded the timeout duration.
-                var now = Number(new Date());
-                if (now > expiresAt) {
-                    fs.unlink(filename, function () {
-                        return callback();
-                    });
-                } else {
-                    setTimeout(checkIfReady, 10 * 1000);
+
+                // This might blow up, but that's a programmer error since we
+                // wrote these files. They should be valid JSON.
+                pkgJSON = JSON.parse(data.toString());
+
+                if (pkgJSON.name) {
+                    agent.name = pkgJSON.name;
+                }
+                if (pkgJSON.version) {
+                    agent.version = pkgJSON.version;
                 }
+
+                cb();
             });
+        }
+    ]}, function gotAgent(err) {
+        callback(err, agent);
+    });
+}
+
+//
+// getAgents() looks at files in SERVER_ROOT/opts.serverUuid/agents and calls
+// callback with:
+//
+//  callback(err, agents);
+//
+// where err is an error object or null. And when err is null, agents is an
+// array that looks like:
+//
+//  [
+//      {
+//          "image_uuid": "<image_uuid>",
+//          "name": "net-agent",
+//          "uuid": "<instance_uuid>",
+//          "version": "2.2.0"
+//      },
+//      ...
+//  ]
+//
+//
+function getAgents(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+
+    var agents = [];
+    var agentsDir = path.join(SERVER_ROOT, opts.serverUuid, 'agents');
+
+    // Defined here so opts we need are in scope.
+    function _getAgent(dir, cb) {
+        getAgent({
+            agentsDir: agentsDir,
+            subDir: dir,
+        }, function _onGetAgent(err, agent) {
+            if (!err) {
+                agents.push(agent);
+            }
+            cb(err);
         });
     }
 
-    checkIfReady();
+    fs.readdir(agentsDir, function onReaddir(err, dirs) {
+        if (err) {
+            if (err.code === 'ENOENT') {
+                callback(null, agents);
+            } else {
+                callback(err);
+            }
+            return;
+        }
+
+        vasync.forEachPipeline({
+            func: _getAgent,
+            inputs: dirs
+        }, function gotAgents(err) {
+            callback(err, agents);
+        });
+    });
 }
 
 
 module.exports = {
     ensureProvisionComplete: ensureProvisionComplete,
+    getAgents: getAgents,
     getPlatformBuildstamp: getPlatformBuildstamp,
+    getSdcConfig: getSdcConfig,
     mdataGet: mdataGet,
     provisionInProgressFile: provisionInProgressFile,
     SERVER_ROOT: SERVER_ROOT
diff --git a/lib/backends/dummy/index.js b/lib/backends/dummy/index.js
index b624127..6d5a790 100644
--- a/lib/backends/dummy/index.js
+++ b/lib/backends/dummy/index.js
@@ -12,7 +12,6 @@ var execFile = require('child_process').execFile;
 var fs = require('fs');
 var fmt = require('util').format;
 var os = require('os');
-var path = require('path');
 
 var assert = require('assert-plus');
 var jsprim = require('jsprim');
@@ -62,6 +61,14 @@ var queueDefns = [
         name: 'nop',
         tasks: [ 'nop' ]
     },
+    {
+        name: 'agents_tasks',
+        maxConcurrent: 1,
+        tasks: [
+            'agent_install',
+            'refresh_agents'
+        ]
+    },
     {
         name: 'server_tasks',
         tasks: [
@@ -91,48 +98,14 @@ function DummyBackend(opts) {
 DummyBackend.prototype.getAgentConfig =
 function getAgentConfig(opts, callback) {
     var config = {
-        no_rabbit: true,
-        skip_agents_update: true
+        no_rabbit: true
     };
 
     callback(null, config);
 };
 
-
-DummyBackend.prototype.getSdcConfig = function getSdcConfig(opts, callback) {
-    var config = {};
-
-    if (cachedDatacenterName !== undefined && cachedDNSDomain !== undefined) {
-        callback(null, {
-            datacenter_name: cachedDatacenterName,
-            dns_domain: cachedDNSDomain
-        });
-        return;
-    }
-
-    common.mdataGet('sdc:datacenter_name', function _onDC(dcErr, datacenter) {
-        if (dcErr) {
-            callback(dcErr);
-            return;
-        }
-
-        config.datacenter_name = datacenter;
-
-        common.mdataGet('dnsDomain', function _onDomain(domErr, dnsDomain) {
-            if (domErr) {
-                callback(domErr);
-                return;
-            }
-
-            config.dns_domain = dnsDomain;
-
-            // Since we succeeded, cache these values.
-            cachedDatacenterName = datacenter;
-            cachedDNSDomain = dnsDomain;
-
-            callback(null, config);
-        });
-    });
+DummyBackend.prototype.getSdcConfig = function getSdcConfig(_, callback) {
+    common.getSdcConfig(callback);
 };
 
 DummyBackend.prototype.getSysinfo = function getSysinfo(opts, callback) {
@@ -326,6 +299,37 @@ DummyBackend.prototype.loadVms = function loadVms(opts, callback) {
 };
 
 
+// Loads information about the agents on this mock CN.
+//
+// opts must contain:
+//
+//  serverUuid -- the UUID of the CN
+//
+// data will be loaded and callback will be called with:
+//
+//  callback(err, agents);
+//
+// where on failure `err` will be an Error object. On success, `err` will be
+// null and `agents` will be an array of agents that looks like:
+//
+//  [
+//      {
+//          "image_uuid": "<image_uuid>",
+//          "name": "net-agent",
+//          "uuid": "<instance_uuid>",
+//          "version": "2.2.0"
+//      },
+//      ...
+//  ]
+//
+DummyBackend.prototype.getAgents = function getAgents(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+
+    common.getAgents(opts, callback);
+};
+
+
 // Dummy needs no watchers, other backends would start watching whatever they
 // need in the filesystem/system and whenever they decide something changed that
 // might cause cn-agent's cache to be dirty, they should call dirtyFn() with no
diff --git a/lib/backends/dummy/tasks/agent_install.js b/lib/backends/dummy/tasks/agent_install.js
new file mode 100644
index 0000000..188bc80
--- /dev/null
+++ b/lib/backends/dummy/tasks/agent_install.js
@@ -0,0 +1,452 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * This task installs agents on this mock CN. The only parameter accepted is
+ * 'image_uuid' which is expected to be an image that exists in the local
+ * DC's imgapi.
+ *
+ * The task will:
+ *
+ *  * download the manifest (to memory)
+ *  * download the file (to /var/tmp/<server_uuid>/)
+ *  * check vs. the sha1 and size from the manifest
+ *  * name the file according to the compression
+ *  * confirm the file contains image_uuid (it's an agent image)
+ *  * extract image_uuid and package.json into place in
+ *    (SERVER_ROOT/<server_uuid>/agents/<agent>/)
+ *  * delete the temporary file from /var/tmp/<server_uuid>/
+ *  * refresh CNAPI's view of the agents
+ *
+ * if there are errors at any point in this process, it will leave things as
+ * they are for investigation.
+ *
+ * This task should be idempotent as running multiple times with the same
+ * image_uuid should result in that version of the agent being installed.
+ *
+ *  "SELF-UPDATING" cn-agent:
+ *
+ *  Since updating agents here does not actually modify the running cn-agent,
+ *  updating cn-agent works the same as every other agent. In the future we may
+ *  want to make this behave slightly differently with cn-agent in order to
+ *  mimick the real update behavior.
+ *
+ */
+
+
+var child_process = require('child_process');
+var execFile = child_process.execFile;
+var fs = require('fs');
+var path = require('path');
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var common = require('../common');
+var refreshAgents = require('./shared').refreshAgents;
+var Task = require('../../../task_agent/task');
+
+var CURL_CMD = '/usr/bin/curl';
+var SERVER_ROOT = common.SERVER_ROOT;
+
+
+function AgentInstallTask(req) {
+    Task.call(this);
+    this.req = req;
+}
+
+function getAgentImage(uuid, options, callback) {
+    var imgapi_domain = options.imgapi_domain;
+    var log = options.log;
+    var output_prefix = options.output_prefix;
+    var server_uuid = options.server_uuid;
+
+    // Ensure required options were passed
+    assert.string(imgapi_domain, 'imgapi_domain');
+    assert.object(log, 'log');
+    assert.string(output_prefix, 'output_prefix');
+    assert.uuid(server_uuid, 'server_uuid');
+
+    var compression;
+    var file_url;
+    var manifest_url;
+    var manifest;
+    var output_file;
+    var agent_name;
+
+    file_url = 'http://imgapi.' + imgapi_domain + '/images/' + uuid + '/file';
+    manifest_url = 'http://imgapi.' + imgapi_domain + '/images/' + uuid;
+
+    vasync.pipeline({funcs: [
+        function getImgapiManifest(_, cb) {
+            var args = ['-f', '-sS', manifest_url];
+
+            log.debug({cmdline: CURL_CMD + ' ' + args.join(' ')}, 'executing');
+            execFile(CURL_CMD, args, function (err, stdout, stderr) {
+                if (err) {
+                    log.error({
+                        err: err,
+                        stdout: stdout,
+                        stderr: stderr,
+                        url: manifest_url
+                    }, 'failed to download manifest');
+                    if (err.message.match(/404 Not Found/)) {
+                        cb(new Error('Image not found at ' + manifest_url));
+                    } else {
+                        cb(err);
+                    }
+                    return;
+                }
+                try {
+                    manifest = JSON.parse(stdout);
+                    agent_name = manifest.name;
+                    log.debug({
+                        manifest: manifest,
+                        url: manifest_url
+                    }, 'got imgapi manifest');
+                } catch (e) {
+                    log.error(e, 'failed to parse manifest');
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
+        }, function getImgapiFile(_, cb) {
+            var args = ['-f', '-sS', '-o', output_prefix + '.file', file_url];
+
+            log.debug({cmdline: CURL_CMD + ' ' + args.join(' ')}, 'executing');
+            execFile(CURL_CMD, args, function (err, stdout, stderr) {
+                if (err) {
+                    log.error({
+                        err: err,
+                        stdout: stdout,
+                        stderr: stderr,
+                        url: file_url
+                    }, 'failed to download file');
+                    if (err.message.match(/404 Not Found/)) {
+                        cb(new Error('Image not found at ' + file_url));
+                    } else {
+                        cb(err);
+                    }
+                    return;
+                }
+                log.debug({
+                    filename: output_prefix + '.file',
+                    url: file_url
+                }, 'got imgapi file');
+                cb();
+            });
+        }, function checkSize(_, cb) {
+            var expected_size = manifest.files[0].size;
+            var filename = output_prefix + '.file';
+            var message;
+
+            fs.stat(filename, function (err, stat) {
+                if (err) {
+                    log.error('failed to stat ' + filename);
+                    cb(err);
+                    return;
+                }
+                if (stat.size !== expected_size) {
+                    message = 'unexpected file size (' + expected_size +
+                        ' vs ' + stat.size + ')';
+                    log.error({
+                        actual: stat.size,
+                        expected: expected_size,
+                        filename: filename
+                    }, message);
+                    cb(new Error(message));
+                    return;
+                }
+                log.debug({
+                    actual: stat.size,
+                    expected: expected_size,
+                    filename: filename
+                }, 'file size ok');
+                cb();
+            });
+
+        }, function checkSha1(_, cb) {
+            var args;
+            var cmd = '/usr/bin/openssl';
+            var expected_sha1 = manifest.files[0].sha1;
+            var filename = output_prefix + '.file';
+
+            args = ['sha1', filename];
+
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            execFile(cmd, args, function (err, stdout, stderr) {
+                var parts;
+                var sha1;
+
+                if (err) {
+                    log.error({
+                        err: err,
+                        stdout: stdout,
+                        stderr: stderr
+                    }, 'failed to identify sha1');
+                    cb(err);
+                    return;
+                }
+
+                parts = stdout.split(' ');
+                if (parts.length === 2) {
+                    sha1 = parts[1].split(/\s/)[0];
+                } else {
+                    log.error({
+                        stdout: stdout,
+                        stderr: stderr
+                    }, 'unable to parse sha1');
+                    cb(new Error('unable to parse sha1: ' + stdout));
+                    return;
+                }
+
+                if (sha1 !== expected_sha1) {
+                    log.error({
+                        actual_sha1: sha1,
+                        expected_sha1: expected_sha1,
+                        filename: filename
+                    }, 'invalid sha1');
+                    cb(new Error('sha1 does not match: (' + sha1 + ' vs ' +
+                                    expected_sha1 + ')'));
+                    return;
+                }
+
+                log.debug({
+                    actual_sha1: sha1,
+                    expected_sha1: expected_sha1,
+                    filename: filename
+                }, 'sha1 ok');
+                cb();
+            });
+        }, function identifyCompression(_, cb) {
+            var args = ['-b', output_prefix + '.file'];
+            var cmd = '/usr/bin/file';
+            var expected_compression = manifest.files[0].compression;
+
+            if (expected_compression) {
+                // manifest has a compression type, use that.
+                compression = expected_compression;
+                cb();
+                return;
+            }
+
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            execFile(cmd, args, function (err, stdout, stderr) {
+                if (err) {
+                    log.error({
+                        err: err,
+                        stdout: stdout,
+                        stderr: stderr
+                    }, 'failed to identify file magic');
+                    cb(err);
+                    return;
+                }
+
+                if (stdout.match(/^gzip compressed data/)) {
+                    compression = 'gzip';
+                    cb();
+                } else if (stdout.match(/^bzip2 compressed data/)) {
+                    compression = 'bzip2';
+                    cb();
+                } else {
+                    log.error({
+                        stdout: stdout,
+                        stderr: stderr
+                    }, 'unhandled file type');
+                    cb(new Error('unhandled file type: ' + stdout));
+                }
+            });
+        }, function renameBasedOnFileType(_, cb) {
+            var oldname = output_prefix + '.file';
+            var newname;
+
+            if (compression === 'gzip') {
+                newname = output_prefix + '.tar.gz';
+            } else if (compression === 'bzip2') {
+                newname = output_prefix + '.tar.bz2';
+            } else {
+                log.error('unknown compression: ' + compression);
+                cb(new Error('unknown compression: ' + compression));
+                return;
+            }
+
+            log.debug({oldname: oldname, newname: newname}, 'renaming file');
+            fs.rename(oldname, newname, function (err) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                output_file = newname;
+                cb();
+            });
+        }, function checkIsAgentImage(_, cb) {
+            // check that image_uuid exists as a heuristic to attempt to
+            // ensure this is an agent image (since we don't have separate type)
+            var args = [];
+            var cmd = '/usr/bin/tar';
+            var filename;
+            var message;
+
+            if (!agent_name) {
+                message = 'manifest is missing "name"';
+                log.error({manifest: manifest}, message);
+                cb(new Error(message));
+                return;
+            }
+            filename = agent_name + '/image_uuid';
+
+            if (compression === 'gzip') {
+                args.push('-ztf');
+            } else if (compression === 'bzip2') {
+                args.push('-jtf');
+            } else {
+                message = 'invalid compression type: ' + compression;
+                log.error({manifest: manifest, compression: compression},
+                    message);
+                cb(new Error(message));
+                return;
+            }
+
+            args.push(output_file);
+            args.push(filename);
+
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            execFile(cmd, args, function (err, stdout, _) {
+                var trimmed;
+
+                if (err) {
+                    log.error({err: err, file: output_file},
+                        'failed to list file from image');
+                    cb(err);
+                    return;
+                }
+
+                trimmed = stdout.replace(new RegExp('[\\s]+$', 'g'), '');
+                if (trimmed === filename) {
+                    log.debug('found ' + filename + ' in ' + output_file);
+                    cb();
+                } else {
+                    message = 'could not find ' + filename + ' in ' +
+                        output_file;
+                    log.error({stdout: stdout}, message);
+                    cb(new Error(message));
+                }
+            });
+        }
+    ]}, function pipelineCb(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, output_file, agent_name);
+    });
+}
+
+
+Task.createTask(AgentInstallTask);
+
+function start() {
+    var self = this;
+
+    assert.object(self.sysinfo, 'self.sysinfo');
+    assert.uuid(self.sysinfo.UUID, 'self.sysinfo.UUID');
+
+    var image_uuid = self.req.params.image_uuid;
+    var opts;
+    var package_file;
+    var package_name;
+    var tmpdir = path.join('/var/tmp/', self.sysinfo.UUID);
+
+    opts = {
+        log: self.log,
+        output_prefix: path.join(tmpdir, image_uuid),
+        server_uuid: self.sysinfo.UUID
+    };
+
+    vasync.pipeline({ arg: { server_uuid: self.sysinfo.UUID }, funcs: [
+        function getImgapiAddress(ctx, cb) {
+            common.getSdcConfig(function onConfig(err, config) {
+                if (!err) {
+                    opts.imgapi_domain = config.datacenter_name + '.' +
+                        config.dns_domain;
+                }
+                cb(err);
+            });
+        },
+        function mkTempDir(ctx, cb) {
+            fs.mkdir(tmpdir, function onMkdir(err) {
+                if (err && err.code !== 'EEXIST') {
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
+        },
+        function getImage(ctx, cb) {
+            getAgentImage(image_uuid, opts,
+                function _gotAgentImage(err, file, name) {
+                    if (err) {
+                        return cb(err);
+                    }
+
+                    self.log.debug('downloaded agent %s image %s to %s',
+                            name, image_uuid, file);
+
+                    ctx.package_file = file;
+                    ctx.package_name = name;
+                    return cb();
+               });
+        },
+        function installPackage(ctx, cb) {
+            // TODO: install ctx.package_file / ctx.package_name
+
+            self.log.info(ctx, 'would install agent');
+
+            cb();
+        },
+        function cleanupImage(ctx, cb) {
+            self.log.info(ctx, 'would cleanup tempfile');
+
+            cb();
+        },
+        function sendAgentsToCNAPI(ctx, cb) {
+            // Since the agent has been updated at this point, the task will
+            // return success. So any failure to tell CNAPI is logged only.
+            refreshAgents({
+                log: self.log,
+                serverUuid: self.sysinfo.UUID
+            }, function (err) {
+                if (err) {
+                    self.log.error({
+                        err: err
+                    }, 'Error posting agents to CNAPI');
+                } else {
+                    self.log.info('Agents updated into CNAPI');
+                }
+                return cb();
+            });
+        }
+    ]}, function agentInstallTaskCb(err) {
+        if (err) {
+            self.fatal('AgentInstall error: ' + err.message);
+            return;
+        }
+
+        self.progress(100);
+        self.finish();
+    });
+}
+
+AgentInstallTask.setStart(start);
+
+module.exports = AgentInstallTask;
diff --git a/lib/backends/dummy/tasks/refresh_agents.js b/lib/backends/dummy/tasks/refresh_agents.js
new file mode 100644
index 0000000..98a26d7
--- /dev/null
+++ b/lib/backends/dummy/tasks/refresh_agents.js
@@ -0,0 +1,54 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * This task updates the information regarding agents installed on this CN
+ * into CNAPI.
+ */
+
+var assert = require('assert-plus');
+
+var refreshAgents = require('./shared').refreshAgents;
+var Task = require('../../../task_agent/task');
+
+function RefreshAgentsTask(req) {
+    Task.call(this);
+    this.req = req;
+}
+
+Task.createTask(RefreshAgentsTask);
+
+function start() {
+    var self = this;
+
+    assert.object(self.log, 'self.log');
+    assert.object(self.sysinfo, 'self.sysinfo');
+    assert.uuid(self.sysinfo.UUID, 'self.sysinfo.UUID');
+
+    // We ignore errors here because the smartos backend does.
+    refreshAgents({
+        log: self.log,
+        serverUuid: self.sysinfo.UUID
+    }, function (err) {
+        if (err) {
+            self.fatal('AgentInstall error: ' + err.message);
+            return;
+        }
+        self.log.info('Agents updated into CNAPI');
+
+        self.progress(100);
+        self.finish();
+    });
+}
+
+
+RefreshAgentsTask.setStart(start);
+
+module.exports = RefreshAgentsTask;
diff --git a/lib/backends/dummy/tasks/shared.js b/lib/backends/dummy/tasks/shared.js
new file mode 100644
index 0000000..464168b
--- /dev/null
+++ b/lib/backends/dummy/tasks/shared.js
@@ -0,0 +1,87 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Functionalities shared between two or more cn-agent tasks
+ */
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var vasync = require('vasync');
+
+var common = require('../common');
+
+function refreshAgents(opts, callback) {
+    var log = opts.log;
+
+    assert.object(opts, 'opts');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+    assert.func(callback, 'callback');
+
+    var agents;
+    var cnapiUrl;
+    var serverUuid = opts.serverUuid;
+
+    vasync.pipeline({funcs: [
+        function retrieveCnapiAddresses(_, cb) {
+            common.getSdcConfig(function onConfig(err, config) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                cnapiUrl = 'http://cnapi.' + config.datacenter_name + '.' +
+                    config.dns_domain;
+
+                log.info({
+                    cnapiUrl: cnapiUrl
+                }, 'cnapi URL');
+
+                cb();
+            });
+        },
+        function getAgents(_, cb) {
+            common.getAgents({
+                serverUuid: serverUuid
+            }, function gotAgents(err, _agents) {
+                if (!err) {
+                    agents = _agents;
+                    log.debug({
+                        agents: agents,
+                        serverUuid: serverUuid
+                    }, 'loaded agents');
+                }
+                cb(err);
+            });
+        },
+        function postAgentsToCnapi(_, cb) {
+            var client;
+            var url = 'http://' + cnapiUrl;
+
+            var restifyOptions = {
+                url: url,
+                connectTimeout: 5000,
+                requestTimeout: 5000
+            };
+
+            log.info(restifyOptions, 'cnapi URL was %s', cnapiUrl);
+
+            client = restify.createJsonClient(restifyOptions);
+
+            client.post('/servers/' + serverUuid, {
+                agents: agents
+            }, cb);
+        }
+    ]}, callback);
+}
+
+module.exports = {
+    refreshAgents: refreshAgents
+};
diff --git a/lib/backends/smartos/index.js b/lib/backends/smartos/index.js
index b5f27c1..0733a63 100644
--- a/lib/backends/smartos/index.js
+++ b/lib/backends/smartos/index.js
@@ -25,6 +25,7 @@ var async = require('async');
 var kstat = require('kstat');
 var sprintf = require('sprintf').sprintf;
 var vasync = require('vasync');
+var verror = require('verror');
 var vmadm = require('vmadm');
 var zfs = require('zfs').zfs;
 var zpool = require('zfs').zpool;
@@ -709,6 +710,117 @@ SmartosBackend.prototype.loadVms = function loadVms(opts, callback) {
 };
 
 
+//
+// Loads information about the agents on this CN
+//
+// opts must contain:
+//
+//  serverUuid -- the UUID of the CN
+//  sysinfo    -- the sysinfo object for this CN
+//
+// data will be loaded and callback will be called with:
+//
+//  callback(err, agents);
+//
+// where on failure `err` will be an Error object. On success, `err` will be
+// null and `agents` will be an array of agents that looks like:
+//
+//  [
+//      {
+//          "image_uuid": "<image_uuid>",
+//          "name": "net-agent",
+//          "uuid": "<instance_uuid>",
+//          "version": "2.2.0"
+//      },
+//      ...
+//  ]
+//
+SmartosBackend.prototype.getAgents = function getAgents(opts, callback) {
+
+    assert.object(opts, 'opts');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+    assert.object(opts.sysinfo, 'opts.sysinfo');
+
+    var agents = opts.sysinfo['SDC Agents'];
+    var agents_dir = '/opt/smartdc/agents/lib/node_modules';
+
+    fs.readdir(agents_dir, function (err, files) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        async.each(files, function getImageAndUUID(name, cb) {
+            var uuid_path = '/opt/smartdc/agents/etc/' + name;
+            var uuidFileExists;
+            var uuid;
+            var image_uuid;
+
+            async.series([
+                function getImage(next) {
+                    var fpath = agents_dir + '/' + name + '/image_uuid';
+
+                    fs.readFile(fpath, {
+                        encoding: 'utf8'
+                    }, function (er2, img_uuid) {
+                        if (er2) {
+                            next(er2);
+                            return;
+                        }
+                        image_uuid = img_uuid.trim();
+                        next();
+                    });
+                },
+                function agentUuidFileExists(next) {
+                    fs.exists(uuid_path, function (exists) {
+                        if (exists) {
+                            uuidFileExists = true;
+                        }
+                        next();
+                    });
+                },
+                function getUUID(next) {
+                    if (!uuidFileExists) {
+                        next();
+                        return;
+                    }
+                    fs.readFile(uuid_path, {
+                        encoding: 'utf8'
+                    }, function (er2, agent_uuid) {
+                        if (er2) {
+                            next(er2);
+                            return;
+                        }
+                        uuid = agent_uuid.trim();
+                        next();
+                    });
+                }
+            ], function seriesCb(er2, results) {
+                if (er2) {
+                    cb(er2);
+                    return;
+                }
+                agents.forEach(function (a) {
+                    if (a.name === name) {
+                        a.image_uuid = image_uuid;
+                        if (uuid) {
+                            a.uuid = uuid;
+                        }
+                    }
+                });
+                cb();
+            });
+        }, function (er3) {
+            if (er3) {
+                callback(new verror.VError('Cannot get agents image versions'));
+                return;
+            }
+
+            callback(null, agents);
+        });
+   });
+};
+
+
 SmartosBackend.prototype.getZpoolInfo = function _getZpoolInfo(_, callback) {
     var self = this;
 
-- 
2.21.0

