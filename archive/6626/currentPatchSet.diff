From f118d0481c54bb10b25e452bdde780f9bdcad5ac Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Thu, 11 Jul 2019 11:02:41 -0400
Subject: [PATCH] add tests for jobs

---
 Cargo.toml             |   3 +
 Makefile               |  15 +-
 examples/gen_sharks.rs |  22 ++
 src/agent.rs           |  23 +-
 src/api.rs             | 116 ++++++++++
 src/error.rs           |  23 +-
 src/job.rs             | 493 +++++++++++++++++++++++++++++++++--------
 src/lib.rs             |   3 +
 src/picker.rs          |  75 ++++---
 src/util.rs            |  14 ++
 10 files changed, 645 insertions(+), 142 deletions(-)
 create mode 100644 examples/gen_sharks.rs
 create mode 100644 src/api.rs

diff --git a/Cargo.toml b/Cargo.toml
index 91a17fa..01c904e 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -34,3 +34,6 @@ rusqlite = "0.19.0"
 walkdir = "2"
 log = "0.4.6"
 pretty_env_logger = "0.3.0"
+rand = "0.7.0"
+quickcheck = "0.8.5"
+failure = "0.1.5"
diff --git a/Makefile b/Makefile
index 6eacb3f..942b63d 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,16 @@
-all: 
+all: check doc test
 	cargo build
 	cp src/config.json target/debug/
+
+doc:
+	cargo doc
+
+clean:
+	cargo clean 
+
+check: 
+	cargo clippy
+	cargo check
+
+test:
+	RUST_LOG=remora=trace cargo test -- --nocapture
diff --git a/examples/gen_sharks.rs b/examples/gen_sharks.rs
new file mode 100644
index 0000000..04e1488
--- /dev/null
+++ b/examples/gen_sharks.rs
@@ -0,0 +1,22 @@
+/*
+pub struct MockPicker {
+    sharks: Arc<Mutex<Option<Vec<StorageNode>>>>,
+    handle: Mutex<Option<JoinHandle<()>>>,
+    running: Arc<AtomicBool>,
+}
+
+
+impl MockPicker
+    pub fn new() -> Self {
+        MockPicker {
+            running: Arc::new(AtomicBool::new(true)),
+            handle: Mutex::new(None),
+            sharks: Arc::new(Mutex::new(Some(vec![]))),
+        }
+    }
+
+*/
+
+fn main() {
+    println!("hello world");
+}
diff --git a/src/agent.rs b/src/agent.rs
index 6662d90..2e8901d 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -28,7 +28,7 @@ use crate::job::TaskStatus;
 use reqwest::StatusCode;
 use rusqlite;
 use serde::ser::SerializeMap;
-use serde_derive::Deserialize;
+use serde_derive::{Serialize, Deserialize};
 use threadpool::ThreadPool;
 use trust_dns_resolver::Resolver;
 use uuid::Uuid;
@@ -39,6 +39,22 @@ type Assignments = HashMap<String, Arc<RwLock<Vec<Task>>>>;
 static REMORA_SCHEDULED_DIR: &str = "/manta/remora";
 static REMORA_FINISHED_DIR: &str = "/var/tmp/remora";
 
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub enum AgentAssignmentStatus {
+    Scheduled, // Haven't even started it yet
+    Running, // Currently processing it
+    Complete(Option<Vec<Task>>), // Done, but if there are failures, they're here
+}
+
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct AgentAssignmentStats {
+    pub uuid: String,
+    pub state: AgentAssignmentStatus,
+    pub failed: usize,
+    pub complete: usize,
+    pub total: usize,
+}
+
 #[derive(Deserialize, StateData, StaticResponseExtender)]
 struct QueryStringExtractor {
     uuid: String,
@@ -53,10 +69,7 @@ pub struct Agent {
 impl Agent {
     pub fn new(tx: Arc<Mutex<mpsc::Sender<String>>>) -> Agent {
         let assignments = Arc::new(Mutex::new(Assignments::new()));
-        Agent {
-            assignments,
-            tx,
-        }
+        Agent { assignments, tx }
     }
 }
 
diff --git a/src/api.rs b/src/api.rs
new file mode 100644
index 0000000..bae97df
--- /dev/null
+++ b/src/api.rs
@@ -0,0 +1,116 @@
+use crate::job::ProcessAssignment;
+use futures::future::Future;
+use futures::stream::Stream;
+use gotham::handler::{Handler, IntoHandlerError, HandlerFuture, NewHandler};
+use gotham::helpers::http::response::create_empty_response;
+use gotham::router::builder::*;
+use gotham::router::Router;
+use gotham::state::{FromState, State};
+use hyper::{Body, StatusCode};
+use std::panic::RefUnwindSafe;
+use std::sync::Arc;
+use rand::AsByteSliceMut;
+
+#[derive(Clone)]
+pub(crate) struct JobActionApi<T> {
+    job_action: Arc<T>,
+}
+
+fn handle_assignment<T>(
+    action_api: JobActionApi<T>,
+    mut state: State,
+) -> Box<HandlerFuture>
+where
+    T: 'static + ProcessAssignment,
+{
+    let res = create_empty_response(&state, StatusCode::OK);
+
+    let bod = Body::take_from(&mut state).concat2().wait();
+
+    let fut =
+        Body::take_from(&mut state)
+            .concat2()
+            .then(move |body| match body {
+                Ok(b) => {
+                    // TODO: Could just pace a slice?
+//                    let assignment = serde_json::from_slice(&b).unwrap();
+                    match action_api.job_action.process(b.as_byte_slice_mut()) {
+                        Ok(()) => return Ok((state, res)),
+                        Err(e) => return Err((state, e.into_handler_error())),
+                    }
+                }
+                Err(e) => Err((state, e.into_handler_error())),
+            });
+
+    Box::new(fut)
+}
+
+fn router<T>(action_api: JobActionApi<T>) -> Router
+where
+    T: 'static + ProcessAssignment + RefUnwindSafe,
+{
+    build_simple_router(|route| {
+        route.post("/assignment").to_new_handler(action_api);
+    })
+}
+
+impl<T: ProcessAssignment> JobActionApi<T> {
+    pub fn start(job_action: Arc<T>)
+    where
+        T: 'static + ProcessAssignment + RefUnwindSafe,
+    {
+        let addr = "127.0.0.1:7878";
+        let action_api = Self { job_action };
+
+        gotham::start(addr, router(action_api))
+    }
+}
+
+impl<T> NewHandler for JobActionApi<T>
+    where T: 'static + ProcessAssignment + RefUnwindSafe
+{
+    type Instance = Self;
+
+    fn new_handler(&self) -> gotham::error::Result<Self::Instance> {
+        let new_action = Self {
+            job_action: Arc::clone(&self.job_action)
+        };
+
+        Ok(new_action)
+    }
+}
+
+impl<T: 'static + ProcessAssignment + RefUnwindSafe> Handler for JobActionApi<T> {
+    fn handle(self, state: State) -> Box<HandlerFuture> {
+        handle_assignment(self, state)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use gotham::test::TestServer;
+    use crate::job::EvacuateJob;
+
+    #[test]
+    fn post() {
+        let job_action = Arc::new(EvacuateJob::new("foo"));
+        let action_api = JobActionApi {
+            job_action,
+        };
+        let test_server = TestServer::new(router(action_api)).unwrap();
+        let response = test_server
+            .client()
+            .post(
+                "http://localhost:7878/assignments",
+                "data",
+                mime::APPLICATION_JSON,
+            )
+            .perform()
+            .unwrap();
+
+        //assert_eq!(response.status(), StatusCode::OK);
+
+        println!("Body: {:?}", response.read_body().unwrap());
+    }
+}
diff --git a/src/error.rs b/src/error.rs
index c179343..e4eaaae 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -1,11 +1,13 @@
 // Copyright 2019 Joyent, Inc.
 
+use hyper;
 use std::fmt;
 
 #[derive(Debug)]
 pub enum Error {
     Internal(InternalError),
     IoError(std::io::Error),
+    Hyper(hyper::Error),
 }
 
 impl std::error::Error for Error {
@@ -13,10 +15,17 @@ impl std::error::Error for Error {
         match self {
             Error::Internal(e) => e.msg.as_str(),
             Error::IoError(e) => e.description(),
+            Error::Hyper(e) => e.description(),
         }
     }
 }
 
+impl From<hyper::Error> for Error {
+    fn from(error: hyper::Error) -> Self {
+        Error::Hyper(error)
+    }
+}
+
 impl From<std::io::Error> for Error {
     fn from(error: std::io::Error) -> Self {
         Error::IoError(error)
@@ -34,21 +43,23 @@ impl fmt::Display for Error {
         match self {
             Error::Internal(e) => write!(f, "{}", e),
             Error::IoError(e) => write!(f, "{}", e),
+            Error::Hyper(e) => write!(f, "{}", e),
         }
     }
 }
 
-#[derive(Debug)]
+#[derive(Debug, PartialEq)]
 pub struct InternalError {
     msg: String,
-    code: InternalErrorCode,
+    pub code: InternalErrorCode,
 }
 
-#[derive(Debug, Copy, Clone)]
+#[derive(Debug, Copy, Clone, PartialEq)]
 pub enum InternalErrorCode {
-    Other = 0,
-    InvalidJobAction = 1,
-    Crossbeam = 2,
+    Other,
+    InvalidJobAction,
+    Crossbeam,
+    PickerError,
 }
 
 impl fmt::Display for InternalError {
diff --git a/src/job.rs b/src/job.rs
index 1f2e1e3..5a6e604 100644
--- a/src/job.rs
+++ b/src/job.rs
@@ -1,10 +1,11 @@
 // Copyright 2019 Joyent, Inc.
 
-
+use crate::api;
 use crate::config::Config;
 use crate::error::{CrossbeamError, Error, InternalError, InternalErrorCode};
 use crate::picker as mod_picker;
-use crate::picker::{Picker, StorageNode};
+use crate::picker::{SharkSource, StorageNode};
+use crate::agent::{AgentAssignmentStats, AgentAssignmentStatus};
 use crossbeam_channel as crossbeam;
 use libmanta::moray::{MantaObject, MantaObjectShark};
 use serde::{Deserialize, Serialize};
@@ -43,12 +44,12 @@ pub enum JobAction {
 
 #[derive(Debug, Clone, PartialEq)]
 enum EvacuateObjectStatus {
-    Unprocessed,    // Default state
-    Processing,     // Object has been included in an assignment and that
-                    // assignment has been submitted to a remora agent.
-    Skipped,        // Could not find a shark to put this object in. TODO: Why?
-     // TODO: Failed,   // Failed to Evacuate Object ???
-     // TODO: Retrying, // Retrying a failed evacuate attempt
+    Unprocessed, // Default state
+    Processing,  // Object has been included in an assignment and that
+    // assignment has been submitted to a remora agent.
+    Skipped, // Could not find a shark to put this object in. TODO: Why?
+             // TODO: Failed,   // Failed to Evacuate Object ???
+             // TODO: Retrying, // Retrying a failed evacuate attempt
 }
 
 #[derive(Debug, Clone)]
@@ -92,11 +93,12 @@ struct EvacuateDestShark {
     status: DestSharkStatus,
 }
 
+/// Evacuate a given `from_shark`
 #[derive(Debug)]
 pub struct EvacuateJob {
     dest_shark_list: RwLock<HashMap<StorageId, EvacuateDestShark>>,
     objects: Vec<EvacuateObject>, // TODO: remove in favor of diesel w/ sqlite
-    assignments: RwLock<Vec<Assignment>>,
+    assignments: RwLock<HashMap<String, Assignment>>,
     from_shark: MantaObjectShark,
     min_avail_mb: Option<u64>,
     max_tasks_per_assignment: Option<u32>,
@@ -115,7 +117,7 @@ enum AssignmentState {
 pub struct Assignment {
     id: String,
     dest_shark: StorageId,
-    tasks: Vec<Task>,
+    tasks: HashMap<String, Task>,
     max_size: u64,
     total_size: u64,
     state: AssignmentState,
@@ -193,15 +195,16 @@ impl Default for JobState {
 }
 
 impl EvacuateJob {
-    pub fn new(from_shark: String) -> Self {
+    pub fn new<S: Into<String>>(from_shark: S) -> Self {
+        let manta_storage_id = from_shark.into();
         Self {
             min_avail_mb: Some(1000),
             max_tasks_per_assignment: Some(100),
             dest_shark_list: RwLock::new(HashMap::new()),
             objects: vec![],
-            assignments: RwLock::new(vec![]),
+            assignments: RwLock::new(HashMap::new()),
             from_shark: MantaObjectShark {
-                manta_storage_id: from_shark,
+                manta_storage_id,
                 ..Default::default()
             },
         }
@@ -225,23 +228,17 @@ impl EvacuateJob {
         false
     }
 
-    fn post_assignment(&self, mut assignment: Assignment) -> Result<(), Error> {
-        // TODO agent: Send assignment to agent
-        // TODO sqlite: put assignment into persistent store?
-
-        assignment.state = AssignmentState::Assigned;
-        let mut assignments = self.assignments.write().unwrap();
-        assignments.push(assignment);
-        Ok(())
-    }
-
     /// checks all assigned assignments for their current status from the
     /// agent returning number of assignments that changed state
     fn check_assignments(&self) -> Result<u32, Error> {
+
+        // TODO: Might not need to do any of this after the ProcessAssignment
+        // trait work
+
         debug!("checking assignments");
         let mut updated_shark_count = 0;
         let mut assignments = self.assignments.write().unwrap();
-        for assignment in assignments.iter_mut() {
+        for (id, assignment) in assignments.iter_mut() {
             if assignment.state != AssignmentState::Assigned {
                 continue;
             }
@@ -322,10 +319,72 @@ impl EvacuateJob {
     }
 }
 
+impl PostAssignment for EvacuateJob {
+    fn post(&self, mut assignment: Assignment) -> Result<(), Error> {
+        // TODO agent: Send assignment to agent
+        let uuid = Uuid::new_v4().to_string();
+        // TODO sqlite: put assignment into persistent store?
+
+        assignment.state = AssignmentState::Assigned;
+        assignment.id = uuid.clone();
+        let mut assignments = self.assignments.write().unwrap();
+        assignments.insert(uuid, assignment);
+        Ok(())
+    }
+}
+
+impl ProcessAssignment for EvacuateJob {
+    fn process<'a, T>(&self, returned_assignment: T) -> Result<(), Error>
+        where T: From<&'a[u8]>
+    {
+        let agent_assignment:AgentAssignmentStats = serde_json::from_str(returned_assignment
+            .as_str())
+            .unwrap();
+
+
+        // TODO: dont unwrap
+        let mut assignment = self.assignments
+            .write()
+            .unwrap()
+            .get_mut(&agent_assignment.uuid)
+            .unwrap();
+
+        match agent_assignment.state {
+            AgentAssignmentStatus::Scheduled |
+            AgentAssignmentStatus::Running => { return Ok(() ); }
+            AgentAssignmentStatus::Complete(None) => {
+                // mark all objects complete
+            },
+            AgentAssignmentStatus::Complete(Some(failed_tasks)) => {
+            }
+        }
+        //let mut write_assignments = self.assignments.write().unwrap();
+
+        /*
+        if let Some(mut update_assignment) = (*write_assignments)
+            .into_iter()
+            .find(|a| a.id == assignment_in.id)
+        {
+            write_assignments.iter().fin
+            write_assignments.index(update_assignment)
+
+            update_assignment.state = assignment_in.state;
+        } else {
+            error!(
+                "Received update for unknown assignment: {}",
+                assignment_in.id
+            );
+        }
+        */
+
+        Ok(())
+    }
+}
+
 // TODO: bring this into impl EvacuateJob
 fn run_evacuate_job(job: Job) -> Result<(), Error> {
     debug!("Running evacuate job: {:?}", &job);
-    let domain = &job.config.domain_name;
+    println!("Starting Evacuate Job: {}", &job.id);
 
     let job_action = match job.action {
         JobAction::Evacuate(action) => Arc::new(action),
@@ -338,18 +397,19 @@ fn run_evacuate_job(job: Job) -> Result<(), Error> {
         }
     };
 
-    println!("Starting Evacuate Job: {}", &job.id);
-
+    let domain = &job.config.domain_name;
     let min_shard = job.config.min_shard_num();
     let max_shard = job.config.max_shard_num();
 
-    // Steps:
-    // TODO lock evacuating server to readonly
-
+    // TODO: How big should each channel be?
     let (obj_tx, obj_rx) = crossbeam::bounded(5);
     let (empty_assignment_tx, empty_assignment_rx) = crossbeam::bounded(5);
     let (full_assignment_tx, full_assignment_rx) = crossbeam::bounded(5);
 
+    // TODO: lock evacuating server to readonly
+
+    api::JobActionApi::start(Arc::clone(&job_action));
+
     let sharkspotter_handle = start_sharkspotter(
         obj_tx,
         domain.as_str(),
@@ -358,7 +418,12 @@ fn run_evacuate_job(job: Job) -> Result<(), Error> {
         max_shard,
     )?;
 
-    let assignment_generator = start_assignment_generator(
+    let processor_thread = start_assignment_processor(
+        full_assignment_rx,
+        Arc::clone(&job_action),
+    )?;
+
+    let generator_thread = start_assignment_generator(
         obj_rx,
         empty_assignment_rx,
         full_assignment_tx,
@@ -372,7 +437,6 @@ fn run_evacuate_job(job: Job) -> Result<(), Error> {
 
     let assignment_manager = start_assignment_manager(
         empty_assignment_tx,
-        full_assignment_rx,
         Arc::clone(&job_action),
         Arc::clone(&picker),
     )?;
@@ -384,19 +448,21 @@ fn run_evacuate_job(job: Job) -> Result<(), Error> {
 
     picker.fini();
 
-    sharkspotter_handle
-        .join()
-        .unwrap()
-        .unwrap_or_else(|e| {
-            error!("Error joining sharkspotter handle: {}\n", e);
-            std::process::exit(1);
+    sharkspotter_handle.join().unwrap().unwrap_or_else(|e| {
+        error!("Error joining sharkspotter handle: {}\n", e);
+        std::process::exit(1);
     });
 
-    assignment_generator
+    generator_thread
         .join()
         .unwrap()
         .expect("Error joining assignment generator thread");
 
+    processor_thread
+        .join()
+        .unwrap()
+        .expect("Error joining assignment processor thread");
+
     Ok(())
 }
 
@@ -425,25 +491,26 @@ fn start_sharkspotter(
     thread::Builder::new()
         .name(String::from("sharkspotter"))
         .spawn(move || {
-        let mut count = 0;
-        sharkspotter::run(&config, move |obj, _shard| {
-            // while testing limit the number of objects processed for now
-            count += 1;
-            if count > 2000 {
-                return Err(std::io::Error::new(
-                    ErrorKind::Other,
-                    "Just stop already",
-                ));
-            }
+            let mut count = 0;
+            sharkspotter::run(&config, move |obj, _shard| {
+                // while testing, limit the number of objects processed for now
+                count += 1;
+                if count > 2000 {
+                    return Err(std::io::Error::new(
+                        ErrorKind::Other,
+                        "Just stop already",
+                    ));
+                }
 
-            // TODO:
-            // - add shard number
-            sender.send(obj).map_err(CrossbeamError::from).map_err(|e| {
-                std::io::Error::new(ErrorKind::Other, e.description())
+                // TODO:
+                // - add shard number
+                sender.send(obj).map_err(CrossbeamError::from).map_err(|e| {
+                    std::io::Error::new(ErrorKind::Other, e.description())
+                })
             })
+            .map_err(Error::from)
         })
         .map_err(Error::from)
-    }).map_err(Error::from)
 }
 
 /// The assignment manager manages the destination sharks and
@@ -463,12 +530,14 @@ fn start_sharkspotter(
 /// the future, or make it tunable)
 /// * If all storage ndoes with availableMb > Some TBD threshold have an
 /// outstanding assignment, sleep/wait for an assignment to complete.
-fn start_assignment_manager(
+fn start_assignment_manager<S>(
     empty_assignment_tx: crossbeam::Sender<Assignment>,
-    full_assignment_rx: crossbeam::Receiver<Assignment>,
     job_action: Arc<EvacuateJob>,
-    picker: Arc<Picker>,
-) -> Result<thread::JoinHandle<Result<(), Error>>, Error> {
+    picker: Arc<S>,
+) -> Result<thread::JoinHandle<Result<(), Error>>, Error>
+where
+    S: SharkSource + 'static,
+{
     let builder = thread::Builder::new();
 
     builder
@@ -503,7 +572,16 @@ fn start_assignment_manager(
                         .choose(&mod_picker::PickerAlgorithm::Default(&algo))
                     {
                         Some(sharks) => sharks,
-                        None => valid_sharks,
+                        None => {
+                            if valid_sharks.is_empty() {
+                                return Err(InternalError::new(
+                                    Some(InternalErrorCode::PickerError),
+                                    "No valid sharks available.",
+                                )
+                                .into());
+                            }
+                            valid_sharks
+                        }
                     };
 
                     // update destination shark list
@@ -546,34 +624,13 @@ fn start_assignment_manager(
                     dest_shark: cur_shark.manta_storage_id.clone(),
                     max_size: cur_shark.available_mb / 2,
                     total_size: 0,
-                    tasks: vec![],
+                    tasks: HashMap::new(),
                     state: AssignmentState::Init,
                 };
 
                 match empty_assignment_tx.send(assignment) {
-                    Ok(()) => {
-                        // TODO: this should be it's own thread, and the
-                        // generator should send the assignment to that thread.
-                        // See step 3 in the block comment at the top of this
-                        // function.
-                        while let Ok(new_assignment) =
-                            full_assignment_rx.try_recv()
-                        {
-                            // TODO: update shark with space avail?  Might not be needed
-                            // since we take a picker snapshot before we start adding to
-                            // a shark
-
-                            info!(
-                                "Posting Assignment: {}\n",
-                                serde_json::to_string(&new_assignment).unwrap()
-                            );
-                            job_action.post_assignment(new_assignment)?;
-                        }
-                    }
+                    Ok(()) => (),
                     Err(e) => {
-                        // TODO: this thread should probably spawn
-                        // assignment_generator thread(s) so that it can maintain
-                        // the generator threads.
                         error!("{}", CrossbeamError::from(e));
                         break;
                     }
@@ -645,7 +702,6 @@ fn start_assignment_generator(
                                 // current assignment and break out of the
                                 // assignment loop.
                                 if !assignment.tasks.is_empty() {
-                                    // TODO: map error
                                     match full_assignment_tx
                                         .send(assignment)
                                         .map_err(CrossbeamError::from)
@@ -716,7 +772,8 @@ fn start_assignment_generator(
                     // Add the task to the assignment.
                     // This creates a task copying the relevant fields of the
                     // object.
-                    assignment.tasks.push(Task {
+                    let key = format!("{}/{}", &obj.owner, &obj.object_id);
+                    assignment.tasks.insert(key, Task {
                         object_id: obj.object_id.to_owned(),
                         owner: obj.owner.to_owned(),
                         md5sum: obj.content_md5.to_owned(),
@@ -741,21 +798,267 @@ fn start_assignment_generator(
                     &assignment
                 );
 
-                full_assignment_tx
-                    .send(assignment)
-                    .map_err(|e| {
-                        error!(
-                            "Error sending assignment back to manager: {}", e
-                        );
+                full_assignment_tx.send(assignment).map_err(|e| {
+                    error!("Error sending assignment back to manager: {}", e);
 
-                        InternalError::new(
-                            Some(InternalErrorCode::Crossbeam),
-                            CrossbeamError::from(e).description(),
-                        )
-                    })?;
+                    InternalError::new(
+                        Some(InternalErrorCode::Crossbeam),
+                        CrossbeamError::from(e).description(),
+                    )
+                })?;
             }
 
             Ok(())
         })
         .map_err(Error::from)
 }
+
+fn assignment_processor<T>(
+    assign_rx: crossbeam::Receiver<Assignment>,
+    job_action: Arc<T>,
+) -> Result<(), Error>
+where
+    T: PostAssignment,
+{
+    loop {
+        match assign_rx.recv() {
+            Ok(assignment) => {
+                {
+                    // TODO: update shark with space avail?
+
+                    info!(
+                        "Posting Assignment: {}\n",
+                        serde_json::to_string(&assignment).unwrap()
+                    );
+                    job_action.post(assignment)?;
+                }
+            }
+            Err(err) => {
+                return Err(InternalError::new(
+                    Some(InternalErrorCode::Crossbeam),
+                    err.description(),
+                )
+                .into());
+            }
+        }
+    }
+}
+
+fn start_assignment_processor(
+    assign_rx: crossbeam::Receiver<Assignment>,
+    job_action: Arc<EvacuateJob>,
+) -> Result<thread::JoinHandle<Result<(), Error>>, Error> {
+    let builder = thread::Builder::new();
+
+    builder
+        .name(String::from("assignment_processor"))
+        .spawn(move || assignment_processor(assign_rx, job_action))
+        .map_err(Error::from)
+}
+
+trait PostAssignment: Sync + Send {
+    fn post(&self, assignment: Assignment) -> Result<(), Error>;
+}
+
+pub(crate) trait ProcessAssignment: Sync + Send {
+    // TODO: String should probably be &[u8]
+    fn process<'a, T>(&self, assignment: T) -> Result<(), Error>
+        where T: From<&'a[u8]>;
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::picker::PickerAlgorithm;
+    use crate::util;
+    use quickcheck::{Arbitrary, StdThreadGen};
+    use rand::Rng;
+
+    fn generate_sharks(num_sharks: u8) -> Vec<StorageNode> {
+        let mut rng = rand::thread_rng();
+        let mut ret = vec![];
+
+        for _ in 0..num_sharks {
+            let percent_used: u8 = rng.gen_range(0, 101);
+            let timestamp: u64 = rng.gen();
+            let available_mb: u64 = rng.gen();
+            let filesystem: String = util::random_string(rng.gen_range(1, 20));
+            let datacenter: String = util::random_string(rng.gen_range(1, 20));
+            let manta_storage_id: String =
+                format!("{}.stor.joyent.us", rng.gen_range(1, 100));
+
+            ret.push(StorageNode {
+                available_mb,
+                percent_used,
+                filesystem,
+                datacenter,
+                manta_storage_id,
+                timestamp,
+            });
+        }
+        ret
+    }
+
+    struct MockPicker {
+        first: bool,
+    }
+
+    impl MockPicker {
+        fn new() -> Self {
+            MockPicker { first: true }
+        }
+    }
+
+    impl SharkSource for MockPicker {
+        fn choose(&self, _: &PickerAlgorithm) -> Option<Vec<StorageNode>> {
+            let mut rng = rand::thread_rng();
+            let random = rng.gen_range(0, 10);
+
+            if self.first {
+                return Some(generate_sharks(random));
+            }
+
+            if random == 0 {
+                return None;
+            }
+
+            Some(generate_sharks(random))
+        }
+    }
+
+    #[derive(Default)]
+    struct EmptyPicker {}
+    impl SharkSource for EmptyPicker {
+        fn choose(&self, _algo: &PickerAlgorithm) -> Option<Vec<StorageNode>> {
+            None
+        }
+    }
+
+    #[test]
+    fn empty_picker_test() {
+        let picker = Arc::new(EmptyPicker {});
+        let (empty_assignment_tx, _) = crossbeam::bounded(5);
+        //let (_, full_assignment_rx) = crossbeam::bounded(5);
+
+        let job_action = EvacuateJob::new(String::from("1.stor.joyent.us"));
+        let job_action = Arc::new(job_action);
+
+        let handle = start_assignment_manager(
+            empty_assignment_tx,
+            Arc::clone(&job_action),
+            Arc::clone(&picker),
+        );
+
+        let handle = match handle {
+            Ok(h) => h,
+            Err(e) => {
+                assert_eq!(
+                    true, false,
+                    "Could not start assignment manager {}",
+                    e
+                );
+                return;
+            }
+        };
+
+        let ret = handle.join().unwrap();
+
+        assert_eq!(ret.is_err(), true);
+
+        match ret.unwrap_err() {
+            Error::Internal(e) => {
+                assert_eq!(e.code, InternalErrorCode::PickerError);
+            }
+            _ => {
+                assert_eq!(1, 0, "Incorrect Error Code");
+            }
+        }
+    }
+
+    #[test]
+    fn full_test() {
+        pretty_env_logger::init();
+
+        let picker = MockPicker::new();
+        let picker = Arc::new(picker);
+        let (empty_assignment_tx, empty_assignment_rx) = crossbeam::bounded(5);
+        let (full_assignment_tx, full_assignment_rx) = crossbeam::bounded(5);
+        let (obj_tx, obj_rx) = crossbeam::bounded(5);
+
+        let job_action = EvacuateJob::new(String::from("1.stor.joyent.us"));
+        let job_action = Arc::new(job_action);
+
+        let mut test_objects = vec![];
+
+        let mut g = StdThreadGen::new(10);
+        for _ in 0..1000 {
+            let mobj = MantaObject::arbitrary(&mut g);
+            test_objects.push(mobj);
+        }
+
+        let test_objects_copy = test_objects.clone();
+
+        let obj_generator_th = thread::spawn(move || {
+            for o in test_objects_copy.into_iter() {
+                obj_tx.send(o).unwrap();
+            }
+        });
+
+        let generator_thread = start_assignment_generator(
+            obj_rx,
+            empty_assignment_rx,
+            full_assignment_tx,
+            Arc::clone(&job_action),
+        )
+        .unwrap();
+
+        let manager_thread = start_assignment_manager(
+            empty_assignment_tx,
+            Arc::clone(&job_action),
+            Arc::clone(&picker),
+        )
+        .unwrap();
+
+        struct MockJobAction {
+            objects: Vec<MantaObject>,
+        }
+
+        impl PostAssignment for MockJobAction {
+            fn post(&self, assignment: Assignment) -> Result<(), Error> {
+                for (_, t) in assignment.tasks.iter() {
+                    assert!(
+                        self.objects
+                            .iter()
+                            .any(|o| { t.object_id == o.object_id }),
+                        "Missing {} from objects",
+                        t.object_id
+                    );
+                }
+                println!("{:?}", assignment.tasks.len());
+                Ok(())
+            }
+        }
+
+        let job_action = Arc::clone(&Arc::new(MockJobAction {
+            objects: test_objects,
+        }));
+
+        match assignment_processor(full_assignment_rx, job_action) {
+            Ok(()) => (),
+            Err(_) => println!("Done"),
+        };
+
+        obj_generator_th.join().unwrap();
+
+        manager_thread
+            .join()
+            .unwrap()
+            .expect("Error joining assignment generator thread");
+
+        generator_thread
+            .join()
+            .unwrap()
+            .expect("Error joining assignment generator thread");
+    }
+
+}
diff --git a/src/lib.rs b/src/lib.rs
index dda0567..d0a5e5f 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,9 +1,12 @@
 // Copyright 2019 Joyent, Inc.
 
+/// Manta Object Rebalancer
+
 #[macro_use]
 extern crate log;
 
 pub mod agent;
+mod api;
 pub mod config;
 pub mod error;
 pub mod job;
diff --git a/src/picker.rs b/src/picker.rs
index f305662..a9d10f0 100644
--- a/src/picker.rs
+++ b/src/picker.rs
@@ -2,7 +2,7 @@
 
 use crate::error::Error;
 use reqwest;
-use serde::Deserialize;
+use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::sync::{
     atomic::{AtomicBool, Ordering},
@@ -11,7 +11,7 @@ use std::sync::{
 use std::thread::JoinHandle;
 use std::{thread, time};
 
-#[derive(Debug, Deserialize, Clone)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct StorageNode {
     #[serde(alias = "availableMB")]
     pub available_mb: u64,
@@ -41,40 +41,39 @@ pub enum PickerAlgorithm<'a> {
     Default(&'a DefaultPickerAlgorithm),
 }
 
+#[derive(Default)]
 pub struct DefaultPickerAlgorithm {
     pub blacklist: Vec<String>,
     pub min_avail_mb: Option<u64>,
 }
 
 impl<'a> PickerAlgorithm<'a> {
-    fn choose(&self, sharks: Vec<StorageNode>) -> Vec<StorageNode> {
+    fn choose(&self, sharks: &[StorageNode]) -> Vec<StorageNode> {
         match self {
-            PickerAlgorithm::Default(algo) => default_method(algo, &sharks),
+            PickerAlgorithm::Default(algo) => algo.method(sharks),
         }
     }
 }
 
-// TODO: put me somewhere more sensible
-fn default_method(
-    algo: &DefaultPickerAlgorithm,
-    sharks: &[StorageNode],
-) -> Vec<StorageNode> {
-    let mut ret: Vec<StorageNode> = vec![];
-
-    // if the min_avail_mb is not specified or if the sharks available space
-    // is less than min_avail_mb skip it.
-    for s in sharks.iter() {
-        if let Some(min_avail_mb) = algo.min_avail_mb {
-            if algo.blacklist.contains(&s.datacenter)
-                || s.available_mb < min_avail_mb
-            {
-                continue;
+impl DefaultPickerAlgorithm {
+    fn method(&self, sharks: &[StorageNode]) -> Vec<StorageNode> {
+        let mut ret: Vec<StorageNode> = vec![];
+
+        // If the min_avail_mb is specified and the sharks available space is less
+        // than min_avail_mb skip it.
+        for s in sharks.iter() {
+            if let Some(min_avail_mb) = self.min_avail_mb {
+                if self.blacklist.contains(&s.datacenter)
+                    || s.available_mb < min_avail_mb
+                {
+                    continue;
+                }
             }
+            ret.push(s.to_owned())
         }
-        ret.push(s.to_owned())
-    }
 
-    ret
+        ret
+    }
 }
 
 impl Picker {
@@ -108,19 +107,6 @@ impl Picker {
         }
     }
 
-    /// Choose the sharks based on the specified algorithm
-    pub fn choose(&self, algo: &PickerAlgorithm) -> Option<Vec<StorageNode>> {
-        let mut sharks: Vec<StorageNode>;
-
-        if let Some(s) = self.get_sharks() {
-            sharks = s.clone();
-        } else {
-            return None;
-        }
-
-        Some(algo.choose(sharks))
-    }
-
     /// Get the the Vec<sharks> from the picker.
     pub fn get_sharks(&self) -> Option<Vec<StorageNode>> {
         self.sharks.lock().unwrap().take()
@@ -149,6 +135,25 @@ impl Picker {
     }
 }
 
+impl SharkSource for Picker {
+    /// Choose the sharks based on the specified algorithm
+    fn choose(&self, algo: &PickerAlgorithm) -> Option<Vec<StorageNode>> {
+        let mut sharks: Vec<StorageNode>;
+
+        if let Some(s) = self.get_sharks() {
+            sharks = s.clone();
+        } else {
+            return None;
+        }
+
+        Some(algo.choose(&sharks))
+    }
+}
+
+pub trait SharkSource: Sync + Send {
+    fn choose(&self, algo: &PickerAlgorithm) -> Option<Vec<StorageNode>>;
+}
+
 // Use our prototype picker zone for now.  Might change this to a shard 1 moray
 // client in the future.
 fn fetch_sharks() -> Vec<StorageNode> {
diff --git a/src/util.rs b/src/util.rs
index 986b5e5..cd94c94 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -1,6 +1,20 @@
 // Copyright 2019 Joyent, Inc.
 
+#[cfg(test)]
+use rand::distributions::Alphanumeric;
+#[cfg(test)]
+use rand::Rng;
+
 pub fn shard_host2num(shard_host: &str) -> u32 {
     let shard_split: Vec<&str> = shard_host.split('.').collect();
     shard_split[0].parse().unwrap()
 }
+
+// Used in test
+#[cfg(test)]
+pub fn random_string(len: usize) -> String {
+    rand::thread_rng()
+        .sample_iter(&Alphanumeric)
+        .take(len)
+        .collect()
+}
-- 
2.21.0

