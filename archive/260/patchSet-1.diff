From be3557fef1e193383818551bf3f804cc0cc3aca9 Mon Sep 17 00:00:00 2001
From: Dave Pacheco <dap@joyent.com>
Date: Tue, 9 Aug 2016 13:32:27 -0700
Subject: [PATCH] joyent/node-verror#10 better support for extra properties on
 Errors joyent/node-verror#11 make it easy to find causes of a particular kind

---
 .gitmodules                    |   3 +
 CHANGES.md                     |   4 +
 LICENSE                        |   2 +-
 Makefile                       |  16 +-
 Makefile.targ                  |  82 +++++--
 README.md                      | 431 +++++++++++++++++++++++++++------
 deps/catest                    |   1 +
 examples/info.js               |  31 +++
 examples/levels-verror.js      |   2 +-
 examples/multierror.js         |   7 +
 lib/verror.js                  | 361 +++++++++++++++++++--------
 package.json                   |   5 +-
 test/common.js                 |  27 +++
 test/tst.common.js             | 167 +++++++++++++
 {tests => test}/tst.context.js |   2 +-
 test/tst.info.js               |  75 ++++++
 {tests => test}/tst.inherit.js |  37 ++-
 test/tst.multierror.js         |  57 +++++
 test/tst.verror.js             | 102 ++++++++
 test/tst.werror.js             | 127 ++++++++++
 tests/tst.serror.js            |  66 -----
 tests/tst.verror.js            | 169 -------------
 tests/tst.werror.js            | 179 --------------
 23 files changed, 1322 insertions(+), 631 deletions(-)
 create mode 100644 CHANGES.md
 create mode 160000 deps/catest
 create mode 100644 examples/info.js
 create mode 100644 examples/multierror.js
 create mode 100644 test/common.js
 create mode 100644 test/tst.common.js
 rename {tests => test}/tst.context.js (94%)
 create mode 100644 test/tst.info.js
 rename {tests => test}/tst.inherit.js (72%)
 create mode 100644 test/tst.multierror.js
 create mode 100644 test/tst.verror.js
 create mode 100644 test/tst.werror.js
 delete mode 100644 tests/tst.serror.js
 delete mode 100644 tests/tst.verror.js
 delete mode 100644 tests/tst.werror.js

diff --git a/.gitmodules b/.gitmodules
index e69de29..2f12284 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "deps/catest"]
+	path = deps/catest
+	url = https://github.com/joyent/catest.git
diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..d481694
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,4 @@
+# v1.7.0
+
+* #10 better support for extra properties on Errors
+* #11 make it easy to find causes of a particular kind
diff --git a/LICENSE b/LICENSE
index cbc0bb3..82a5cb8 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Copyright (c) 2012, Joyent, Inc. All rights reserved.
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/Makefile b/Makefile
index 7af7375..fe7b7cc 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+# Copyright (c) 2016, Joyent, Inc. All rights reserved.
 #
 # Makefile: top-level Makefile
 #
@@ -11,12 +11,13 @@
 #
 # Tools
 #
+CATEST		 = deps/catest/catest
 NPM		 = npm
 
 #
 # Files
 #
-JS_FILES	:= $(shell find lib examples tests -name '*.js')
+JS_FILES	:= $(shell find lib examples test -name '*.js')
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSL_CONF_NODE	 = jsl.node.conf
@@ -26,12 +27,9 @@ all:
 	$(NPM) install
 
 .PHONY: test
-test:
-	node tests/tst.inherit.js
-	node tests/tst.verror.js
-	node tests/tst.werror.js
-	node tests/tst.serror.js
-	node tests/tst.context.js
-	@echo all tests passed
+test: $(CATEST)
+	$(CATEST) -a
+
+$(CATEST): deps/catest/.git
 
 include ./Makefile.targ
diff --git a/Makefile.targ b/Makefile.targ
index 2a64fe7..ea19000 100644
--- a/Makefile.targ
+++ b/Makefile.targ
@@ -1,6 +1,14 @@
 # -*- mode: makefile -*-
 #
-# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
 #
 # Makefile.targ: common targets.
 #
@@ -58,9 +66,13 @@
 #	JSL_FILES_NODE	JavaScript files to check with Node config file.
 #	JSL_FILES_WEB	JavaScript files to check with Web config file.
 #
+#	JSON_FILES	JSON files to be validated
+#
+#	JSSTYLE_FILES	JavaScript files to be style-checked
+#
 # You can also override these variables:
 #
-#	BASH		Path to bash (default: bash)
+#	BASH		Path to bash (default: "bash")
 #
 #	CSCOPE_DIRS	Directories to search for source files for the cscope
 #			index. (default: ".")
@@ -71,10 +83,16 @@
 #	JSL_FLAGS_WEB
 #	JSL_FLAGS
 #
-#	JSSTYLE		Path to jsstyle (default: jsstyle)
+#	JSON		Path to json tool (default: "json")
+#
+#	JSSTYLE		Path to jsstyle (default: "jsstyle")
 #
 #	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
 #
+#	RESTDOWN_EXT	By default '.restdown' is required for DOC_FILES
+#			(see above). If you want to use, say, '.md' instead, then
+#			set 'RESTDOWN_EXT=.md' in your Makefile.
+#
 
 #
 # Defaults for the various tools we use.
@@ -85,10 +103,12 @@ CP		?= cp
 CSCOPE		?= cscope
 CSCOPE_DIRS	?= .
 JSL		?= jsl
+JSON		?= json
 JSSTYLE		?= jsstyle
 MKDIR		?= mkdir -p
 MV		?= mv
 RESTDOWN_FLAGS	?=
+RESTDOWN_EXT	?= .restdown
 RMTREE		?= rm -rf
 JSL_FLAGS  	?= --nologo --nosummary
 
@@ -157,27 +177,39 @@ check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
 %.bashstyle: %
 	$(BASHSTYLE) $^
 
-.PHONY: check-jsl check-jsl-node check-jsl-web
-check-jsl: check-jsl-node check-jsl-web
+.PHONY: check-json
+check-json: $(JSON_FILES:%=%.jsonchk)
 
-check-jsl-node: $(JSL_FILES_NODE:%=%.jslnodechk)
+%.jsonchk: %
+	$(JSON) --validate -f $^
 
-check-jsl-web: $(JSL_FILES_WEB:%=%.jslwebchk)
+#
+# The above approach can be slow when there are many files to check because it
+# requires that "make" invoke the check tool once for each file, rather than
+# passing in several files at once.  For the JavaScript check targets, we define
+# a variable for the target itself *only if* the list of input files is
+# non-empty.  This avoids invoking the tool if there are no files to check.
+#
+JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
+.PHONY: check-jsl-node
+check-jsl-node: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
 
-%.jslnodechk: % $(JSL_EXEC)
-	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $<
+JSL_WEB_TARGET = $(if $(JSL_FILES_WEB), check-jsl-web)
+.PHONY: check-jsl-web
+check-jsl-web: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $(JSL_FILES_WEB)
 
-%.jslwebchk: % $(JSL_EXEC)
-	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $<
+.PHONY: check-jsl
+check-jsl: $(JSL_NODE_TARGET) $(JSL_WEB_TARGET)
 
+JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
 .PHONY: check-jsstyle
-check-jsstyle: $(JSSTYLE_FILES:%=%.jsstylechk)
-
-%.jsstylechk: % $(JSSTYLE_EXEC)
-	$(JSSTYLE) $(JSSTYLE_FLAGS) $<
+check-jsstyle:  $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
 
 .PHONY: check
-check: check-jsl check-jsstyle check-bash
+check: check-jsl check-json $(JSSTYLE_TARGET) check-bash
 	@echo check ok
 
 .PHONY: clean
@@ -233,25 +265,25 @@ DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
 #
 .PHONY: docs
 docs:							\
-    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.html)		\
-    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.json)		\
-    $(DOC_MEDIA_FILES_BUILD)
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.json)		\
+	$(DOC_MEDIA_FILES_BUILD)
 
 #
 # We keep the intermediate files so that the next build can see whether the
 # files in DOC_BUILD are up to date.
 #
 .PRECIOUS:					\
-    $(DOC_FILES:%.restdown=docs/%.html)		\
-    $(DOC_FILES:%.restdown=docs/%json)
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%json)
 
 #
 # We do clean those intermediate files, as well as all of DOC_BUILD.
 #
 CLEAN_FILES +=					\
-    $(DOC_BUILD)				\
-    $(DOC_FILES:%.restdown=docs/%.html)		\
-    $(DOC_FILES:%.restdown=docs/%.json)
+	$(DOC_BUILD)				\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.json)
 
 #
 # Before installing the files, we must make sure the directories exist. The |
@@ -264,7 +296,7 @@ $(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
 $(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
 	$(CP) $< $@
 
-docs/%.json docs/%.html: docs/%.restdown | $(DOC_BUILD) $(RESTDOWN_EXEC)
+docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC)
 	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
 
 $(DOC_BUILD):
diff --git a/README.md b/README.md
index 1f8cec0..902bdf3 100644
--- a/README.md
+++ b/README.md
@@ -1,76 +1,73 @@
-# verror: richer JavaScript errors
+# verror: rich JavaScript errors
 
-This module provides two classes:
+This module provides several classes in support of Joyent's [Best Practices for
+Error Handling in Node.js](http://www.joyent.com/developers/node/design/errors).
+If you find any of the behavior here confusing or surprising, check out that
+document first.
 
-* VError, for combining errors while preserving each one's error message, and
-* WError, for wrapping errors.
+The error classes here support:
 
-Both support printf-style error messages using
-[extsprintf](https://github.com/davepacheco/node-extsprintf).
+* printf-style arguments for the message
+* chains of causes
+* properties to provide extra information about the error
+* creating your own subclasses that support all of these
 
-## printf-style Error constructor
+The classes here are:
 
-At the most basic level, VError is just like JavaScript's Error class, but with
-printf-style arguments:
+* **VError**, for chaining errors while preserving each one's error message.
+  This is useful in servers and command-line utilities when you want to
+  propagate an error up a call stack, but allow various levels to add their own
+  context.  See examples below.
+* **WError**, for wrapping errors while hiding the lower-level messages from the
+  top-level error.  This is useful for API endpoints where you don't want to
+  expose internal error messages, but you still want to preserve the error chain
+  for logging and debugging.
+* **SError**, which is just like VError but interprets printf-style arguments
+  more strictly.
+* **MultiError**, which is just an Error that encapsulates one or more other
+  errors.  (This is used for parallel operations that return several errors.)
 
-```javascript
-var VError = require('verror');
-
-var filename = '/etc/passwd';
-var err = new VError('missing file: "%s"', filename);
-console.log(err.message);
-```
 
-This prints:
-
-    missing file: "/etc/passwd"
+# Quick start
 
-`err.stack` works the same as for built-in errors:
+If nothing else, you can use VError as a drop-in replacement for the built-in
+JavaScript Error class, with the addition of printf-style messages:
 
 ```javascript
-console.log(err.stack);
+var err = new VError('missing file: "%s"', '/etc/passwd');
+console.log(err.message);
 ```
 
 This prints:
 
     missing file: "/etc/passwd"
-        at Object.<anonymous> (/Users/dap/node-verror/examples/varargs.js:4:11)
-        at Module._compile (module.js:449:26)
-        at Object.Module._extensions..js (module.js:467:10)
-        at Module.load (module.js:356:32)
-        at Function.Module._load (module.js:312:12)
-        at Module.runMain (module.js:492:10)
-        at process.startup.processNextTick.process._tickCallback (node.js:244:9)
-
-
-## Causes
 
-You can also pass a `cause` argument, which is another Error.  For example:
+You can also pass a `cause` argument, which is any other Error object:
 
 ```javascript
 var fs = require('fs');
-var VError = require('verror');
-
 var filename = '/nonexistent';
 fs.stat(filename, function (err1) {
-	var err2 = new VError(err1, 'stat "%s" failed', filename);
+	var err2 = new VError(err1, 'stat "%s"', filename);
 	console.error(err2.message);
 });
 ```
 
 This prints out:
 
-    stat "/nonexistent" failed: ENOENT, stat '/nonexistent'
+    stat "/nonexistent": ENOENT, stat '/nonexistent'
 
 which resembles how Unix programs typically report errors:
 
     $ sort /nonexistent
     sort: open failed: /nonexistent: No such file or directory
 
-To match the Unixy feel, just prepend the program's name to the VError's
-`message`.
+To match the Unixy feel, when you print out the error, just prepend the
+program's name to the VError's `message`.  Or just call
+[node-cmdutil.fail(your_verror)](https://github.com/joyent/node-cmdutil), which
+does this for you.
 
-You can also get the next-level Error using `err.cause()`:
+You can get the next-level Error using `err.cause()`:
 
 ```javascript
 console.error(err2.cause().message);
@@ -80,10 +77,10 @@ prints:
 
     ENOENT, stat '/nonexistent'
 
-Of course, you can nest these as many times as you want:
+Of course, you can chain these as many times as you want, and it works with any
+kind of Error:
 
 ```javascript
-var VError = require('verror');
 var err1 = new Error('No such file or directory');
 var err2 = new VError(err1, 'failed to stat "%s"', '/junk');
 var err3 = new VError(err2, 'request failed');
@@ -95,47 +92,345 @@ This prints:
     request failed: failed to stat "/junk": No such file or directory
 
 The idea is that each layer in the stack annotates the error with a description
-of what it was doing (with a printf-like format string) and the result is a
-message that explains what happened at every level.
+of what it was doing.  The end result is a message that explains what happened
+at each level.
+
+You can also decorate Error objects with additional information so that callers
+can not only handle each kind of error differently, but also construct their own
+error messages (e.g., to localize them, format them, group them by type, and so
+on).  See the example below.
+
+
+# Deeper dive
+
+The two main goals for VError are:
+
+* **Make it easy to construct clear, complete error messages intended for
+  people.**  Clear error messages greatly improve both user experience and
+  debuggability, so we wanted to make it easy to build them.  That's why the
+  constructor takes printf-style arguments.
+* **Make it easy to construct objects with programmatically-accessible
+  metadata** (which we call _informational properties_).  Instead of just saying
+  "connection refused while connecting to 192.168.1.2:80", you can add
+  properties like `"ip": "192.168.1.2"` and `"tcpPort": 80`.  This can be used
+  for feeding into monitoring systems, analyzing large numbers of Errors (as
+  from a log file), or localizing error messages.
+
+To really make this useful, it also needs to be easy to compose Errors:
+higher-level code should be able to augment the Errors reported by lower-level
+code to provide a more complete description of what happened.  Instead of saying
+"connection refused", you can say "operation X failed: connection refused".
+That's why VError supports `causes`.
+
+In order for all this to work, programmers need to know that it's generally safe
+to wrap lower-level Errors with higher-level ones.  If you have existing code
+that handles Errors produced by a library, you should be able to wrap those
+Errors with a VError to add information without breaking the error handling
+code.  There are two obvious ways that this could break such consumers:
+
+* The error's name might change.  People typically use `name` to determine what
+  kind of Error they've got.  To ensure compatibility, you can create VErrors
+  with custom names, but this approach isn't great because it prevents you from
+  representing complex failures.  For this reason, VError provides
+  `findCauseByName`, which essentially asks: does this Error _or any of its
+  causes_ have this specific type?  If error handling code uses
+  `findCauseByName`, then subsystems can construct very specific causal chains
+  for debuggability and still let people handle simple cases easily.  There's an
+  example below.
+* The error's properties might change.  People often hang additional properties
+  off of Error objects.  If we wrap an existing Error in a new Error, those
+  properties would be lost unless we copied them.  But there are a variety of
+  both standard and non-standard Error properties that should _not_ be copied in
+  this way: most obviously `name`, `message`, and `stack`, but also `fileName`,
+  `lineNumber`, and a few others.  Plus, it's useful for some Error subclasses
+  to have their own private properties -- and there'd be no way to know whether
+  these should be copied.  For these reasons, VError first-classes these
+  information properties.  You have to provide them in the constructor, you can
+  only fetch them with the `info()` function, and VError takes care of making
+  sure properties from causes wind up in the `info()` output.
+
+Let's put this all together with an example from the node-fast RPC library.
+node-fast implements a simple RPC protocol for Node programs.  There's a server
+and client interface, and clients make RPC requests to servers.  Let's say the
+server fails with an UnauthorizedError with message "user 'bob' is not
+authorized".  The client wraps all server errors with a FastServerError.  The
+client also wraps all request errors with a FastRequestError that includes the
+name of the RPC call being made.  The result of this failed RPC might look like
+this:
+
+    name: FastRequestError
+    message: "request failed: server error: user 'bob' is not authorized"
+    rpcMsgid: <unique identifier for this request>
+    rpcMethod: GetObject
+    cause:
+        name: FastServerError
+        message: "server error: user 'bob' is not authorized"
+        cause:
+            name: UnauthorizedError
+            message: "user 'bob' is not authorized"
+            rpcUser: "bob"
+
+When the caller uses `VError.info()`, the information properties are collapsed
+so that it looks like this:
+
+    message: "request failed: server error: user 'bob' is not authorized"
+    rpcMsgid: <unique identifier for this request>
+    rpcMethod: GetObject
+    rpcUser: "bob"
+
+Taking this apart:
+
+* The error's message is a complete description of the problem.  The caller can
+  report this directly to its caller, which can potentially make its way back to
+  an end user (if appropriate).  It can also be logged.
+* The caller can tell that the request failed on the server, rather than as a
+  result of a client problem (e.g., failure to serialize the request), a
+  transport problem (e.g., failure to connect to the server), or something else
+  (e.g., a timeout).  They do this using `findCauseByName('FastServerError')`
+  rather than checking the `name` field directly.
+* If the caller logs this error, the logs can be analyzed to aggregate 
+  errors by cause, by RPC method name, by user, or whatever.  Or the
+  error can be correlated with other events for the same rpcMsgid.
+* It wasn't very hard for any part of the code to contribute to this Error.
+  Each part of the stack has just a few lines to provide exactly what it knows,
+  with very little boilerplate.
+
+It's not expected that you'd use these complex forms all the time.  Despite
+supporting the complex case above, you can still just do:
+
+   new VError("my service isn't working");
+
+for the simple cases.
+
+
+# Reference: VError, WError, SError
+
+VError, WError, and SError are convenient drop-in replacements for `Error` that
+support printf-style arguments, first-class causes, informational properties,
+and other useful features.
+
+
+## Constructors
+
+The VError constructor has several forms:
+
+```javascript
+/*
+ * This is the most general form.  You can specify any supported options
+ * (including "cause" and "info") this way.
+ */
+new VError(options, sprintf_args...)
+
+/*
+ * This is a useful shorthand when the only option you need is "cause".
+ */
+new VError(cause, sprintf_args...)
+
+/*
+ * This is a useful shorthand when you don't need any options at all.
+ */
+new VError(sprintf_args...)
+```
+
+All of these forms construct a new VError that behaves just like the built-in
+JavaScript `Error` class, with some additional methods described below.
+
+In the first form, `options` is a plain object with any of the following
+optional properties:
+
+Option name      | Type             | Meaning
+---------------- | ---------------- | -------
+`name`           | string           | Describes what kind of error this is.  This is intended for programmatic use to distinguish between different kinds of errors.  Note that in modern versions of Node.js, this name is ignored in the `stack` property value, but callers can still use the `name` property to get at it.
+`cause`          | any Error object | Indicates that the new error was caused by `cause`.  See `cause()` below.  If unspecified, the cause will be `null`.
+`strict`         | boolean          | If true, then `null` and `undefined` values in `sprintf_args` are passed through to `sprintf()`.  Otherwise, these are replaced with the strings `'null'`, and '`undefined`', respectively.
+`constructorOpt` | function         | If specified, then the stack trace for this error ends at function `constructorOpt`.  Functions called by `constructorOpt` will not show up in the stack.  This is useful when this class is subclassed.
+`info`           | object           | Specifies arbitrary informational properties that are available through the `VError.info(err)` static class method.  See that method for details.
+
+The second form is equivalent to using the first form with the specified `cause`
+as the error's cause.  This form is distinguished from the first form because
+the first argument is an Error.
+
+The third form is equivalent to using the first form with all default option
+values.  This form is distinguished from the other forms because the first
+argument is not an object or an Error.
+
+The `WError` constructor is used exactly the same way as the `VError`
+constructor.  The `SError` constructor is also used the same way as the
+`VError` constructor except that in all cases, the `strict` property is
+overriden to `true.
+
+
+## Public properties
+
+`VError`, `WError`, and `SError` all provide the same public properties as
+JavaScript's built-in Error objects.
+
+Property name | Type   | Meaning
+------------- | ------ | -------
+`name`        | string | Programmatically-usable name of the error.
+`message`     | string | Human-readable summary of the failure.  Programmatically-accessible details are provided through `VError.info(err)` class method.
+`stack`       | string | Human-readable stack trace where the Error was constructed.
+
+For all of these classes, the printf-style arguments passed to the constructor
+are processed with `sprintf()` to form a message.  For `WError`, this becomes
+the complete `message` property.  For `SError` and `VError`, this message is
+prepended to the message of the cause, if any (with a suitable separator), and
+the result becomes the `message` property.
+
+The `stack` property is managed entirely by the underlying JavaScript
+implementation.  It's generally implemented using a getter function because
+constructing the human-readable stack trace is somewhat expensive.
+
+## Class methods
+
+The following methods are defined on the `VError` class and as exported
+functions on the `verror` module.  They're defined this way rather than using
+methods on VError instances so that they can be used on Errors not created with
+`VError`.
+
+### `VError.cause(err)`
+
+The `cause()` function returns the next Error in the cause chain for `err`, or
+`null` if there is no next error.  See the `cause` argument to the constructor.
+Errors can have arbitrarily long cause chains.  You can walk the `cause` chain
+by invoking `VError.cause(err)` on each subsequent return value.  If `err` is
+not a `VError`, the cause is `null`.
 
+### `VError.info(err)`
 
-## WError: wrap layered errors
+Returns an object with all of the extra error information that's been associated
+with this Error and all of its causes.  These are the properties passed in using
+the `info` option to the constructor.  Properties not specified in the
+constructor for this Error are implicitly inherited from this error's cause.
 
-Sometimes you don't want an Error's "message" field to include the details of
-all of the low-level errors, but you still want to be able to get at them
-programmatically.  For example, in an HTTP server, you probably don't want to
-spew all of the low-level errors back to the client, but you do want to include
-them in the audit log entry for the request.  In that case, you can use a
-WError, which is created exactly like VError (and also supports both
-printf-style arguments and an optional cause), but the resulting "message" only
-contains the top-level error.  It's also more verbose, including the class
-associated with each error in the cause chain.  Using the same example above,
-but replacing `err3`'s VError with WError, so that it looks like this:
+These properties are intended to provide programmatically-accessible metadata
+about the error.  For an error that indicates a failure to resolve a DNS name,
+informational properties might include the DNS name to be resolved, or even the
+list of resolvers used to resolve it.  The values of these properties should
+generally be plain objects (i.e., consisting only of null, undefined, numbers,
+booleans, strings, and objects and arrays containing only other plain objects).
+
+
+## Examples
+
+The "Demo" section above covers several basic cases.  Here's a more advanced
+case:
 
 ```javascript
-var verror = require('verror');
-var err1 = new Error('No such file or directory');
-var err2 = new verror.VError(err1, 'failed to stat "%s"', '/junk');
-var err3 = new verror.WError(err2, 'request failed');
-console.error(err3.message);
+var err1 = new VError('something bad happened');
+/* ... */
+var err2 = new VError({
+    'name': 'ConnectionError',
+    'cause': err1,
+    'info': {
+        'errno': 'ECONNREFUSED',
+        'remote_ip': '127.0.0.1',
+        'port': 215
+    }
+}, 'failed to connect to "%s:%d"', '127.0.0.1', 215);
+
+console.log(err2.message);
+console.log(err2.name);
+console.log(VError.info(err2));
+console.log(err2.stack);
+```
+
+This outputs:
+
+    failed to connect to "127.0.0.1:215": something bad happened
+    ConnectionError
+    { errno: 'ECONNREFUSED', remote_ip: '127.0.0.1', port: 215 }
+    ConnectionError: failed to connect to "127.0.0.1:215": something bad happened
+        at Object.<anonymous> (/home/dap/node-verror/examples/info.js:5:12)
+        at Module._compile (module.js:456:26)
+        at Object.Module._extensions..js (module.js:474:10)
+        at Module.load (module.js:356:32)
+        at Function.Module._load (module.js:312:12)
+        at Function.Module.runMain (module.js:497:10)
+        at startup (node.js:119:16)
+        at node.js:935:3
+
+Information properties are inherited up the cause chain, with values at the top
+of the chain overriding same-named values lower in the chain.  To continue that
+example:
+
+```javascript
+var err3 = new VError({
+    'name': 'RequestError',
+    'cause': err2,
+    'info': {
+        'errno': 'EBADREQUEST'
+    }
+}, 'request failed');
+
+console.log(err3.message);
+console.log(err3.name);
+console.log(VError.info(err3));
+console.log(err3.stack);
+```
+
+This outputs:
+
+    request failed: failed to connect to "127.0.0.1:215": something bad happened
+    RequestError
+    { errno: 'EBADREQUEST', remote_ip: '127.0.0.1', port: 215 }
+    RequestError: request failed: failed to connect to "127.0.0.1:215": something bad happened
+        at Object.<anonymous> (/home/dap/node-verror/examples/info.js:20:12)
+        at Module._compile (module.js:456:26)
+        at Object.Module._extensions..js (module.js:474:10)
+        at Module.load (module.js:356:32)
+        at Function.Module._load (module.js:312:12)
+        at Function.Module.runMain (module.js:497:10)
+        at startup (node.js:119:16)
+        at node.js:935:3
+
+# Reference: MultiError
+
+MultiError is an Error class that represents a group of Errors.  This is used
+when you logically need to provide a single Error, but you want to preserve
+information about multiple underying Errors.  A common case is when you execute
+several operations in parallel and some of them fail.
+
+MultiErrors are constructed as:
+
+```javascript
+new MultiError(error_list)
+```
+
+`error_list` is an array of at least one `Error` object.
+
+The cause of the MultiError is the first error provided.  None of the other
+`VError` options are supported.  The `message` for a MultiError consists the
+`message` from the first error, prepended with a message indicating that there
+were other errors.
+
+For example:
+
+```javascript
+err = new MultiError([
+    new Error('failed to resolve DNS name "abc.example.com"'),
+    new Error('failed to resolve DNS name "def.example.com"'),
+]);
+
+console.error(err.message);
 ```
 
-we get this output:
+outputs:
+
+    first of 2 errors: failed to resolve DNS name "abc.example.com"
+
+## Public methods
 
-    request failed
 
-That's what we wanted -- just a high-level summary for the client.  But we can
-get the object's toString() for the full details:
+### `errors()`
 
-    WError: request failed; caused by WError: failed to stat "/nonexistent";
-    caused by Error: No such file or directory
+Returns an array of the errors used to construct this MultiError.
 
-For a complete example, see examples/werror.js.
 
 # Contributing
 
-Contributions welcome.  Code should be "make check" clean.  To run "make check",
-you'll need these tools:
+Contributions should be "make prepush" clean.  To run "make check", you'll need
+these tools:
 
 * https://github.com/davepacheco/jsstyle
 * https://github.com/davepacheco/javascriptlint
diff --git a/deps/catest b/deps/catest
new file mode 160000
index 0000000..ca13864
--- /dev/null
+++ b/deps/catest
@@ -0,0 +1 @@
+Subproject commit ca138645cc9647d6976063c61fa9f28dd16c5023
diff --git a/examples/info.js b/examples/info.js
new file mode 100644
index 0000000..0906e4b
--- /dev/null
+++ b/examples/info.js
@@ -0,0 +1,31 @@
+var VError = require('../lib/verror');
+
+var err1 = new VError('something bad happened');
+/* ... */
+var err2 = new VError({
+    'name': 'ConnectionError',
+    'cause': err1,
+    'info': {
+	'errno': 'ECONNREFUSED',
+	'remote_ip': '127.0.0.1',
+	'port': 215
+    }
+}, 'failed to connect to "%s:%d"', '127.0.0.1', 215);
+
+console.log(err2.message);
+console.log(err2.name);
+console.log(VError.info(err2));
+console.log(err2.stack);
+
+var err3 = new VError({
+    'name': 'RequestError',
+    'cause': err2,
+    'info': {
+	'errno': 'EBADREQUEST'
+    }
+}, 'request failed');
+
+console.log(err3.message);
+console.log(err3.name);
+console.log(VError.info(err3));
+console.log(err3.stack);
diff --git a/examples/levels-verror.js b/examples/levels-verror.js
index b6bc14c..e82526f 100644
--- a/examples/levels-verror.js
+++ b/examples/levels-verror.js
@@ -32,5 +32,5 @@ handleRequest('/nonexistent', function (err) {
 		console.log(extsprintf.sprintf('%r', err));
 	}
 
-    /* ... */
+	/* ... */
 });
diff --git a/examples/multierror.js b/examples/multierror.js
new file mode 100644
index 0000000..d3ceedc
--- /dev/null
+++ b/examples/multierror.js
@@ -0,0 +1,7 @@
+var MultiError = require('../lib/verror').MultiError;
+
+var err = new MultiError([
+    new Error('failed to resolve DNS name "abc.example.com"'),
+    new Error('failed to resolve DNS name "def.example.com"')
+]);
+console.error(err.message);
diff --git a/lib/verror.js b/lib/verror.js
index 5e6df17..3dfb8b0 100644
--- a/lib/verror.js
+++ b/lib/verror.js
@@ -2,11 +2,12 @@
  * verror.js: richer JavaScript errors
  */
 
-var mod_assert = require('assert');
+var mod_assertplus = require('assert-plus');
 var mod_util = require('util');
 
 var mod_extsprintf = require('extsprintf');
 var mod_isError = require('core-util-is').isError;
+var sprintf = mod_extsprintf.sprintf;
 
 /*
  * Public interface
@@ -22,43 +23,66 @@ VError.WError = WError;
 VError.MultiError = MultiError;
 
 /*
- * VError([cause], fmt[, arg...]): Like JavaScript's built-in Error class, but
- * supports a "cause" argument (another error) and a printf-style message.  The
- * cause argument can be null or omitted entirely.
+ * Common function used to parse constructor arguments for VError, WError, and
+ * SError.  Named arguments to this function:
  *
- * Examples:
+ *     strict		force strict interpretation of sprintf arguments, even
+ *     			if the options in "argv" don't say so
  *
- * CODE                                    MESSAGE
- * new VError('something bad happened')    "something bad happened"
- * new VError('missing file: "%s"', file)  "missing file: "/etc/passwd"
- *   with file = '/etc/passwd'
- * new VError(err, 'open failed')          "open failed: file not found"
- *   with err.message = 'file not found'
+ *     argv		error's constructor arguments, which are to be
+ *     			interpreted as described in README.md.  For quick
+ *     			reference, "argv" has one of the following forms:
+ *
+ *          [ sprintf_args... ]           (argv[0] is a string)
+ *          [ cause, sprintf_args... ]    (argv[0] is an Error)
+ *          [ options, sprintf_args... ]  (argv[0] is an object)
+ *
+ * This function normalizes these forms, producing an object with the following
+ * properties:
+ *
+ *    options           equivalent to "options" in third form.  This will never
+ *    			be a direct reference to what the caller passed in
+ *    			(i.e., it may be a shallow copy), so it can be freely
+ *    			modified.
+ *
+ *    shortmessage      result of sprintf(sprintf_args), taking options.strict
+ *    			into account as described in README.md.
  */
-function VError(options)
+function parseConstructorArguments(args)
 {
-	var args, obj, causedBy, ctor, tailmsg;
+	var argv, options, sprintf_args, shortmessage, k;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.bool(args.strict, 'args.strict');
+	mod_assertplus.array(args.argv, 'args.argv');
+	argv = args.argv;
 
 	/*
-	 * This is a regrettable pattern, but JavaScript's built-in Error class
-	 * is defined to work this way, so we allow the constructor to be called
-	 * without "new".
+	 * First, figure out which form of invocation we've been given.
 	 */
-	if (!(this instanceof VError)) {
-		args = Array.prototype.slice.call(arguments, 0);
-		obj = Object.create(VError.prototype);
-		VError.apply(obj, arguments);
-		return (obj);
-	}
-
-	if (mod_isError(options) || typeof (options) === 'object') {
-		args = Array.prototype.slice.call(arguments, 1);
+	if (argv.length === 0) {
+		options = {};
+		sprintf_args = [];
+	} else if (mod_isError(argv[0])) {
+		options = { 'cause': argv[0] };
+		sprintf_args = argv.slice(1);
+	} else if (typeof (argv[0]) === 'object') {
+		options = {};
+		for (k in argv[0]) {
+			options[k] = argv[0][k];
+		}
+		sprintf_args = argv.slice(1);
 	} else {
-		args = Array.prototype.slice.call(arguments, 0);
-		options = undefined;
+		mod_assertplus.string(argv[0],
+		    'first argument to VError, SError, or WError ' +
+		    'constructor must be a string, object, or Error');
+		options = {};
+		sprintf_args = argv;
 	}
 
 	/*
+	 * Now construct the error's message.
+	 *
 	 * extsprintf (which we invoke here with our caller's arguments in order
 	 * to construct this Error's message) is strict in its interpretation of
 	 * values to be processed by the "%s" specifier.  The value passed to
@@ -82,36 +106,104 @@ function VError(options)
 	 * desiring the strict behavior can use the SError class or pass the
 	 * "strict" option to the VError constructor.
 	 */
-	if (!options || !options.strict) {
-		args = args.map(function (a) {
+	mod_assertplus.object(options);
+	if (!options.strict && !args.strict) {
+		sprintf_args = sprintf_args.map(function (a) {
 			return (a === null ? 'null' :
 			    a === undefined ? 'undefined' : a);
 		});
 	}
 
-	tailmsg = args.length > 0 ?
-	    mod_extsprintf.sprintf.apply(null, args) : '';
-	this.jse_shortmsg = tailmsg;
-	this.jse_summary = tailmsg;
+	if (sprintf_args.length === 0) {
+		shortmessage = '';
+	} else {
+		shortmessage = sprintf.apply(null, sprintf_args);
+	}
+
+	return ({
+	    'options': options,
+	    'shortmessage': shortmessage
+	});
+}
+
+/*
+ * See README.md for reference documentation.
+ */
+function VError()
+{
+	var args, obj, parsed, cause, ctor, message, k;
+
+	args = Array.prototype.slice.call(arguments, 0);
+
+	/*
+	 * This is a regrettable pattern, but JavaScript's built-in Error class
+	 * is defined to work this way, so we allow the constructor to be called
+	 * without "new".
+	 */
+	if (!(this instanceof VError)) {
+		obj = Object.create(VError.prototype);
+		VError.apply(obj, arguments);
+		return (obj);
+	}
+
+	/*
+	 * For convenience and backwards compatibility, we support several
+	 * different calling forms.  Normalize them here.
+	 */
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
+
+	/*
+	 * If we've been given a name, apply it now.
+	 */
+	if (parsed.options.name) {
+		mod_assertplus.string(parsed.options.name,
+		    'error\'s "name" must be a string');
+		this.name = parsed.options.name;
+	}
+
+	/*
+	 * For debugging, we keep track of the original short message (attached
+	 * this Error particularly) separately from the complete message (which
+	 * includes the messages of our cause chain).
+	 */
+	this.jse_shortmsg = parsed.shortmessage;
+	message = parsed.shortmessage;
 
-	if (options) {
-		causedBy = options.cause;
+	/*
+	 * If we've been given a cause, record a reference to it and update our
+	 * message appropriately.
+	 */
+	cause = parsed.options.cause;
+	if (cause) {
+		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
+		this.jse_cause = cause;
 
-		if (!causedBy || !mod_isError(options.cause))
-			causedBy = options;
+		if (!parsed.options.skipCauseMessage) {
+			message += ': ' + cause.message;
+		}
+	}
 
-		if (causedBy && mod_isError(causedBy)) {
-			this.jse_cause = causedBy;
-			this.jse_summary += ': ' + causedBy.message;
+	/*
+	 * If we've been given an object with properties, shallow-copy that
+	 * here.  We don't want to use a deep copy in case there are non-plain
+	 * objects here, but we don't want to use the original object in case
+	 * the caller modifies it later.
+	 */
+	this.jse_info = {};
+	if (parsed.options.info) {
+		for (k in parsed.options.info) {
+			this.jse_info[k] = parsed.options.info[k];
 		}
 	}
 
-	this.message = this.jse_summary;
-	Error.call(this, this.jse_summary);
+	this.message = message;
+	Error.call(this, message);
 
 	if (Error.captureStackTrace) {
-		ctor = options ? options.constructorOpt : undefined;
-		ctor = ctor || arguments.callee;
+		ctor = parsed.options.constructorOpt || arguments.callee;
 		Error.captureStackTrace(this, ctor);
 	}
 
@@ -131,41 +223,106 @@ VError.prototype.toString = function ve_toString()
 	return (str);
 };
 
+/*
+ * This method is provided for compatibility.  New callers should use
+ * VError.cause() instead.  That method also uses the saner `null` return value
+ * when there is no cause.
+ */
 VError.prototype.cause = function ve_cause()
 {
-	return (this.jse_cause);
+	var cause = VError.cause(this);
+	return (cause === null ? undefined : cause);
+};
+
+/*
+ * Static methods
+ *
+ * These class-level methods are provided so that callers can use them on
+ * instances of Errors that are not VErrors.  New interfaces should be provided
+ * only using static methods to eliminate the class of programming mistake where
+ * people fail to check whether the Error object has the corresponding methods.
+ */
+
+VError.cause = function (err)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
+};
+
+VError.info = function (err)
+{
+	var rv, cause, k;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	cause = VError.cause(err);
+	if (cause !== null) {
+		rv = VError.info(cause);
+	} else {
+		rv = {};
+	}
+
+	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
+		for (k in err.jse_info) {
+			rv[k] = err.jse_info[k];
+		}
+	}
+
+	return (rv);
+};
+
+VError.findCauseByName = function (err, name)
+{
+	var cause;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.string(name);
+	mod_assertplus.ok(name.length > 0, 'name cannot be empty');
+
+	for (cause = err; cause !== null; cause = VError.cause(cause)) {
+		mod_assertplus.ok(mod_isError(cause));
+		if (cause.name == name) {
+			return (cause);
+		}
+	}
+
+	return (null);
 };
 
 
 /*
  * SError is like VError, but stricter about types.  You cannot pass "null" or
- * "undefined" as string arguments to the formatter.  Since SError is only a
- * different function, not really a different class, we don't set
- * SError.prototype.name.
+ * "undefined" as string arguments to the formatter.
  */
 function SError()
 {
-	var fmtargs, opts, key, args;
-
-	opts = {};
-	opts.constructorOpt = SError;
-
-	if (mod_isError(arguments[0])) {
-		opts.cause = arguments[0];
-		fmtargs = Array.prototype.slice.call(arguments, 1);
-	} else if (typeof (arguments[0]) == 'object') {
-		for (key in arguments[0])
-			opts[key] = arguments[0][key];
-		fmtargs = Array.prototype.slice.call(arguments, 1);
-	} else {
-		fmtargs = Array.prototype.slice.call(arguments, 0);
+	var args, obj, parsed, options;
+
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof SError)) {
+		obj = Object.create(SError.prototype);
+		SError.apply(obj, arguments);
+		return (obj);
 	}
 
-	opts.strict = true;
-	args = [ opts ].concat(fmtargs);
-	VError.apply(this, args);
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': true
+	});
+
+	options = parsed.options;
+	if (!options.hasOwnProperty('constructorOpt')) {
+		options['constructorOpt'] = SError;
+	}
+
+	VError.call(this, options, '%s', parsed.shortmessage);
+
+	return (this);
 }
 
+/*
+ * We don't bother setting SError.prototype.name because once constructed,
+ * SErrors are just like VErrors.
+ */
 mod_util.inherits(SError, VError);
 
 
@@ -177,74 +334,78 @@ mod_util.inherits(SError, VError);
  */
 function MultiError(errors)
 {
-	mod_assert.ok(errors.length > 0);
+	mod_assertplus.array(errors, 'list of errors');
+	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
 	this.ase_errors = errors;
 
-	VError.call(this, errors[0], 'first of %d error%s',
-	    errors.length, errors.length == 1 ? '' : 's');
+	VError.call(this, {
+	    'cause': errors[0],
+	    'constructorOpt': MultiError
+	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
 }
 
 mod_util.inherits(MultiError, VError);
+MultiError.prototype.name = 'MultiError';
+
+MultiError.prototype.errors = function me_errors()
+{
+	return (this.ase_errors.slice(0));
+};
 
 
 /*
- * Like JavaScript's built-in Error class, but supports a "cause" argument which
- * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
- * The cause argument can be null.
+ * See README.md for reference details.
  */
-function WError(options)
+function WError()
 {
-	Error.call(this);
+	var args, obj, parsed, options;
 
-	var args, cause, ctor;
-	if (typeof (options) === 'object') {
-		args = Array.prototype.slice.call(arguments, 1);
-	} else {
-		args = Array.prototype.slice.call(arguments, 0);
-		options = undefined;
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof WError)) {
+		obj = Object.create(WError.prototype);
+		WError.apply(obj, args);
+		return (obj);
 	}
 
-	if (args.length > 0) {
-		this.message = mod_extsprintf.sprintf.apply(null, args);
-	} else {
-		this.message = '';
-	}
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
 
-	if (options) {
-		if (mod_isError(options)) {
-			cause = options;
-		} else {
-			cause = options.cause;
-			ctor = options.constructorOpt;
-		}
+	options = parsed.options;
+	options['skipCauseMessage'] = true;
+	if (!options.hasOwnProperty('constructorOpt')) {
+		options['constructorOpt'] = WError;
 	}
 
-	Error.captureStackTrace(this, ctor || this.constructor);
-	if (cause)
-		this.cause(cause);
+	VError.call(this, options, '%s', parsed.shortmessage);
 
+	return (this);
 }
 
-mod_util.inherits(WError, Error);
+mod_util.inherits(WError, VError);
 WError.prototype.name = 'WError';
 
-
 WError.prototype.toString = function we_toString()
 {
 	var str = (this.hasOwnProperty('name') && this.name ||
 		this.constructor.name || this.constructor.prototype.name);
 	if (this.message)
 		str += ': ' + this.message;
-	if (this.we_cause && this.we_cause.message)
-		str += '; caused by ' + this.we_cause.toString();
+	if (this.jse_cause && this.jse_cause.message)
+		str += '; caused by ' + this.jse_cause.toString();
 
 	return (str);
 };
 
+/*
+ * For purely historical reasons, WError's cause() function allows you to set
+ * the cause.
+ */
 WError.prototype.cause = function we_cause(c)
 {
 	if (mod_isError(c))
-		this.we_cause = c;
+		this.jse_cause = c;
 
-	return (this.we_cause);
+	return (this.jse_cause);
 };
diff --git a/package.json b/package.json
index eea1f70..9ee1c8a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "verror",
-	"version": "1.6.1",
+	"version": "1.7.0",
 	"description": "richer JavaScript errors",
 	"main": "./lib/verror.js",
 	"repository": {
@@ -8,8 +8,9 @@
 		"url": "git://github.com/davepacheco/node-verror.git"
 	},
 	"dependencies": {
+		"assert-plus": "^1.0.0",
 		"core-util-is": "1.0.2",
-		"extsprintf": "1.2.0"
+		"extsprintf": "^1.2.0"
 	},
 	"engines": [
 		"node >=0.6.0"
diff --git a/test/common.js b/test/common.js
new file mode 100644
index 0000000..36a7bc2
--- /dev/null
+++ b/test/common.js
@@ -0,0 +1,27 @@
+/*
+ * test/common.js: common utility functions used in multiple tests
+ */
+
+exports.cleanStack = cleanStack;
+exports.oldNode = oldNode;
+
+/*
+ * Remove full paths and relative line numbers from stack traces so that we can
+ * compare against "known-good" output.
+ */
+function cleanStack(stacktxt)
+{
+	var re = new RegExp('\\(/.*/tst.*js:\\d+:\\d+\\)', 'gm');
+	stacktxt = stacktxt.replace(re, '(dummy filename)');
+	return (stacktxt);
+}
+
+/*
+ * Node's behavior with respect to Error's names and messages changed
+ * significantly with v0.12, so a number of tests regrettably need to check for
+ * that.
+ */
+function oldNode()
+{
+	return (/^0\.10\./.test(process.versions['node']));
+}
diff --git a/test/tst.common.js b/test/tst.common.js
new file mode 100644
index 0000000..4f44e70
--- /dev/null
+++ b/test/tst.common.js
@@ -0,0 +1,167 @@
+/*
+ * tst.common.js: tests functionality that's common to the VError, SError, and
+ * WError classes.
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+var mod_testcommon = require('./common');
+
+var SError = mod_verror.SError;
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ * The stack trace limit has to be large enough to capture all of Node's frames,
+ * which are more than the default (10 frames) in Node v6.
+ */
+Error.stackTraceLimit = 20;
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+/*
+ * Runs all tests using the class "cons".  We'll apply this to each of the main
+ * classes.
+ */
+function runTests(cons, label)
+{
+	var err, stack, stackname;
+
+	console.error('running common tests for: %s', cons.name);
+
+	/*
+	 * On Node v0.10 and earlier, the name that's used in the "stack" output
+	 * is the constructor that was used for this object.  On Node v0.12 and
+	 * later, it's the value of the "name" property on the Error when it was
+	 * constructed.
+	 */
+	if (mod_testcommon.oldNode()) {
+		stackname = cons.name;
+	} else {
+		stackname = label;
+	}
+
+	/* no arguments */
+	err = new cons();
+	mod_assert.equal(err.name, label);
+	mod_assert.ok(err instanceof Error);
+	mod_assert.ok(err instanceof cons);
+	mod_assert.equal(err.message, '');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname,
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* used without "new" */
+	err = cons('test %s', 'foo');
+	mod_assert.equal(err.name, label);
+	mod_assert.ok(err instanceof Error);
+	mod_assert.ok(err instanceof cons);
+	mod_assert.equal(err.message, 'test foo');
+
+	/* options-argument form */
+	err = new cons({});
+	mod_assert.equal(err.name, label);
+	mod_assert.equal(err.message, '');
+	mod_assert.ok(err.cause() === undefined);
+
+	/* simple message */
+	err = new cons('my error');
+	mod_assert.equal(err.name, label);
+	mod_assert.equal(err.message, 'my error');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname + ': my error',
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = new cons({}, 'my error');
+	mod_assert.equal(err.name, label);
+	mod_assert.equal(err.message, 'my error');
+	mod_assert.ok(err.cause() === undefined);
+
+	/* printf-style message */
+	err = new cons('%s error: %3d problems', 'very bad', 15);
+	mod_assert.equal(err.message, 'very bad error:  15 problems');
+	mod_assert.ok(err.cause() === undefined);
+
+	err = new cons({}, '%s error: %3d problems', 'very bad', 15);
+	mod_assert.equal(err.message, 'very bad error:  15 problems');
+	mod_assert.ok(err.cause() === undefined);
+
+	/* null cause (for backwards compatibility with older versions) */
+	err = new cons(null, 'my error');
+	mod_assert.equal(err.message, 'my error');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname + ': my error',
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = new cons({ 'cause': null }, 'my error');
+	mod_assert.equal(err.message, 'my error');
+	mod_assert.ok(err.cause() === undefined);
+
+	err = new cons(null);
+	mod_assert.equal(err.message, '');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname,
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* constructorOpt */
+	function makeErr(options) {
+		return (new cons(options, 'test error'));
+	}
+	err = makeErr({});
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname + ': test error',
+	    '    at makeErr (dummy filename)',
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = makeErr({ 'constructorOpt': makeErr });
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackname + ': test error',
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* invoked without "new" */
+	err = cons('my %s string', 'testing!');
+	mod_assert.equal(err.name, label);
+	mod_assert.ok(err instanceof cons);
+	mod_assert.ok(err instanceof Error);
+	mod_assert.equal(err.message, 'my testing! string');
+
+	/* custom "name" */
+	err = new cons({ 'name': 'SomeOtherError' }, 'another kind of error');
+	mod_assert.equal(err.name, 'SomeOtherError');
+	mod_assert.ok(err instanceof cons);
+	mod_assert.ok(err instanceof Error);
+	mod_assert.equal(err.message, 'another kind of error');
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    'SomeOtherError: another kind of error',
+	    '    at runTests (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+}
+
+runTests(VError, 'VError');
+runTests(WError, 'WError');
+runTests(SError, 'VError');
diff --git a/tests/tst.context.js b/test/tst.context.js
similarity index 94%
rename from tests/tst.context.js
rename to test/tst.context.js
index 4bb4d26..300a4a3 100644
--- a/tests/tst.context.js
+++ b/test/tst.context.js
@@ -15,7 +15,7 @@ var verr = new VError(err);
 mod_assert.ok(mod_isError(verr.cause()));
 
 var context = mod_vm.createContext({
-	callback: function callback(err2) {
+	'callback': function callback(err2) {
 		mod_assert.ok(mod_isError(err2));
 		var verr2 = new VError(err);
 		mod_assert.ok(mod_isError(verr2.cause()));
diff --git a/test/tst.info.js b/test/tst.info.js
new file mode 100644
index 0000000..4fa85b2
--- /dev/null
+++ b/test/tst.info.js
@@ -0,0 +1,75 @@
+/*
+ * tst.info.js: tests the way informational properties are inherited with nested
+ * errors.
+ */
+
+var mod_assert = require('assert');
+var mod_fs = require('fs');
+var mod_verror = require('../lib/verror');
+
+var VError = mod_verror.VError;
+
+var err1, err2, err3;
+
+/* base case using "options" to specify cause */
+err1 = new Error('bad');
+err2 = new VError({
+    'cause': err1
+}, 'worse');
+mod_assert.equal(err2.cause(), err1);
+mod_assert.equal(err2.message, 'worse: bad');
+mod_assert.deepEqual(VError.info(err2), {});
+
+/* simple info usage */
+err1 = new VError({
+    'name': 'MyError',
+    'info': {
+	'errno': 'EDEADLK',
+	'anobject': { 'hello': 'world' }
+    }
+}, 'bad');
+mod_assert.equal(err1.name, 'MyError');
+mod_assert.deepEqual(VError.info(err1), {
+    'errno': 'EDEADLK',
+    'anobject': { 'hello': 'world' }
+});
+
+/* simple property propagation using old syntax */
+err2 = new VError(err1, 'worse');
+mod_assert.equal(err2.cause(), err1);
+mod_assert.equal(err2.message, 'worse: bad');
+mod_assert.deepEqual(VError.info(err2), {
+    'errno': 'EDEADLK',
+    'anobject': { 'hello': 'world' }
+});
+
+/* one property override */
+err2 = new VError({
+    'cause': err1,
+    'info': {
+	'anobject': { 'hello': 'moon' }
+    }
+}, 'worse');
+mod_assert.equal(err2.cause(), err1);
+mod_assert.equal(err2.message, 'worse: bad');
+mod_assert.deepEqual(VError.info(err2), {
+    'errno': 'EDEADLK',
+    'anobject': { 'hello': 'moon' }
+});
+
+/* add a third-level to the chain */
+err3 = new VError({
+    'cause': err2,
+    'name': 'BigError',
+    'info': {
+	'remote_ip': '127.0.0.1'
+    }
+}, 'what next');
+mod_assert.equal(err3.name, 'BigError');
+mod_assert.equal(VError.info(err3).remote_ip, '127.0.0.1');
+mod_assert.equal(err3.cause(), err2);
+mod_assert.equal(err3.message, 'what next: worse: bad');
+mod_assert.equal(VError.info(err3).errno, 'EDEADLK');
+mod_assert.deepEqual(VError.info(err3).anobject, { 'hello': 'moon' });
+
+console.log('test passed');
diff --git a/tests/tst.inherit.js b/test/tst.inherit.js
similarity index 72%
rename from tests/tst.inherit.js
rename to test/tst.inherit.js
index b0e49be..999936a 100644
--- a/tests/tst.inherit.js
+++ b/test/tst.inherit.js
@@ -4,6 +4,7 @@
 
 var mod_assert = require('assert');
 var mod_util = require('util');
+var mod_testcommon = require('./common');
 
 var VError = require('../lib/verror');
 var WError = VError.WError;
@@ -46,12 +47,27 @@ mod_assert.equal(err.cause(), suberr);
 mod_assert.equal(err.message, 'top');
 mod_assert.equal(err.toString(),
 	'WErrorChild: top; caused by Error: root cause');
-mod_assert.equal(err.stack.split('\n')[0],
-	'WErrorChild: top; caused by Error: root cause');
 
+/*
+ * On Node 0.10 and earlier, the 'stack' property appears to use the error's
+ * toString() method.  On newer versions, it appears to use the message
+ * property the first time err.stack is accessed (_not_ when it was
+ * constructed).  Since the point of WError is to omit the cause messages from
+ * the WError's message, there's no way to have the err.stack property show the
+ * detailed message in Node 0.12 and later.
+ */
+if (mod_testcommon.oldNode()) {
+	mod_assert.equal(err.stack.split('\n')[0],
+	    'WErrorChild: top; caused by Error: root cause');
+} else {
+	mod_assert.equal(err.stack.split('\n')[0], 'WErrorChild: top');
+
+}
 
-// Test that `<Ctor>.toString()` uses the ctor name. I.e. setting
-// `<Ctor>.prototype.name` isn't necessary.
+/*
+ * Test that "<Ctor>.toString()" uses the constructor name, so that setting
+ * "<Ctor>.prototype.name" isn't necessary.
+ */
 function VErrorChildNoName() {
 	VError.apply(this, Array.prototype.slice.call(arguments));
 }
@@ -67,8 +83,10 @@ err = new WErrorChildNoName('top');
 mod_assert.equal(err.toString(), 'WErrorChildNoName: top');
 
 
-// Test that `<Ctor>.prototype.name` can be used for the `.toString()`
-// when the ctor is anonymous.
+/*
+ * Test that `<Ctor>.prototype.name` can be used for the `.toString()`
+ * when the ctor is anonymous.
+ */
 var VErrorChildAnon = function () {
 	VError.apply(this, Array.prototype.slice.call(arguments));
 };
@@ -85,10 +103,9 @@ WErrorChildAnon.prototype.name = 'WErrorChildAnon';
 err = new WErrorChildAnon('top');
 mod_assert.equal(err.toString(), 'WErrorChildAnon: top');
 
-
-// Test get appropriate exception name in `.toString()` when reconstituting
-// an error instance a la:
-//    https://github.com/mcavage/node-fast/blob/master/lib/client.js#L215
+/*
+ * Test that we get an appropriate exception name in toString() output.
+ */
 err = new VError('top');
 err.name = 'CustomNameError';
 mod_assert.equal(err.toString(), 'CustomNameError: top');
diff --git a/test/tst.multierror.js b/test/tst.multierror.js
new file mode 100644
index 0000000..1742d07
--- /dev/null
+++ b/test/tst.multierror.js
@@ -0,0 +1,57 @@
+/*
+ * tst.multierror.js: tests MultiError class
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+var mod_testcommon = require('./common');
+
+var MultiError = mod_verror.MultiError;
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ * The stack trace limit has to be large enough to capture all of Node's frames,
+ * which are more than the default (10 frames) in Node v6.
+ */
+Error.stackTraceLimit = 20;
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+function main()
+{
+	var err1, err2, err3, merr, stack;
+
+	mod_assert.throws(function () {
+		console.error(new MultiError());
+	}, /list of errors \(array\) is required/);
+
+	mod_assert.throws(function () {
+		console.error(new MultiError([]));
+	}, /must be at least one error/);
+
+	err1 = new Error('error one');
+	err2 = new Error('error two');
+	err3 = new Error('error three');
+	merr = new MultiError([ err1, err2, err3 ]);
+	mod_assert.equal(err1, merr.cause());
+	mod_assert.equal(merr.message, 'first of 3 errors: error one');
+	mod_assert.equal(merr.name, 'MultiError');
+	stack = mod_testcommon.cleanStack(merr.stack);
+	mod_assert.equal(stack, [
+	    'MultiError: first of 3 errors: error one',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	merr = new MultiError([ err1 ]);
+	mod_assert.equal(merr.message, 'first of 1 error: error one');
+	mod_assert.equal(merr.name, 'MultiError');
+	stack = mod_testcommon.cleanStack(merr.stack);
+	mod_assert.equal(stack, [
+	    'MultiError: first of 1 error: error one',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+}
+
+main();
diff --git a/test/tst.verror.js b/test/tst.verror.js
new file mode 100644
index 0000000..3c27556
--- /dev/null
+++ b/test/tst.verror.js
@@ -0,0 +1,102 @@
+/*
+ * tst.verror.js: tests functionality that's specific to the VError and SError
+ * classes.
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+var mod_testcommon = require('./common');
+
+var SError = mod_verror.SError;
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ * The stack trace limit has to be large enough to capture all of Node's frames,
+ * which are more than the default (10 frames) in Node v6.
+ */
+Error.stackTraceLimit = 20;
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+function main()
+{
+	var err, suberr, stack, stackname;
+
+	console.error('running VError/SError tests');
+
+	/* "null" or "undefined" as string for extsprintf */
+	err = new VError('my %s string', null);
+	mod_assert.equal('my null string', err.message);
+	err = new VError('my %s string', undefined);
+	mod_assert.equal('my undefined string', err.message);
+
+	mod_assert.throws(function () {
+		console.error(
+		    new VError({ 'strict': true }, 'my %s string', null));
+	}, /attempted to print undefined or null as a string/);
+	mod_assert.throws(function () {
+		console.error(new SError('my %s string', undefined));
+	}, /attempted to print undefined or null as a string/);
+
+	mod_assert.throws(function () {
+		console.error(new SError('my %s string', null));
+	}, /attempted to print undefined or null as a string/);
+	mod_assert.throws(function () {
+		console.error(new SError('my %s string', undefined));
+	}, /attempted to print undefined or null as a string/);
+
+	/* caused by another error, with no additional message */
+	suberr = new Error('root cause');
+	err = new VError(suberr);
+	mod_assert.equal(err.message, ': root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	err = new VError({ 'cause': suberr });
+	mod_assert.equal(err.message, ': root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	/* caused by another error, with annotation */
+	err = new VError(suberr, 'proximate cause: %d issues', 3);
+	mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
+	mod_assert.ok(err.cause() === suberr);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    'VError: proximate cause: 3 issues: root cause',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = new SError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
+	mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
+	mod_assert.ok(err.cause() === suberr);
+	stack = mod_testcommon.cleanStack(err.stack);
+	/* See the comment in tst.common.js. */
+	stackname = mod_testcommon.oldNode() ? 'SError': 'VError';
+	mod_assert.equal(stack, [
+	    stackname + ': proximate cause: 3 issues: root cause',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* caused by another VError, with annotation. */
+	suberr = err;
+	err = new VError(suberr, 'top');
+	mod_assert.equal(err.message,
+	    'top: proximate cause: 3 issues: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	err = new VError({ 'cause': suberr }, 'top');
+	mod_assert.equal(err.message,
+	    'top: proximate cause: 3 issues: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	/* caused by a WError */
+	suberr = new WError(new Error('root cause'), 'mid');
+	err = new VError(suberr, 'top');
+	mod_assert.equal(err.message, 'top: mid');
+	mod_assert.ok(err.cause() === suberr);
+}
+
+main();
diff --git a/test/tst.werror.js b/test/tst.werror.js
new file mode 100644
index 0000000..7e07f69
--- /dev/null
+++ b/test/tst.werror.js
@@ -0,0 +1,127 @@
+/*
+ * tst.werror.js: tests basic functionality specific to the WError class.
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+var mod_testcommon = require('./common');
+
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ * The stack trace limit has to be large enough to capture all of Node's frames,
+ * which are more than the default (10 frames) in Node v6.
+ */
+Error.stackTraceLimit = 20;
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+function main()
+{
+	var err, suberr, stack, stackmessage;
+
+	/*
+	 * Most of the test cases here have analogs in tst.common.js.  In this
+	 * test, we check for WError-specific behavior (e.g., toString()).
+	 */
+	console.error('running WError-specific tests');
+
+	/* no arguments */
+	err = new WError();
+	mod_assert.equal(err.toString(), 'WError');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    'WError',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* options-argument form */
+	err = new WError({});
+	mod_assert.equal(err.toString(), 'WError');
+	mod_assert.ok(err.cause() === undefined);
+
+	/* simple message */
+	err = new WError('my error');
+	mod_assert.equal(err.message, 'my error');
+	mod_assert.equal(err.toString(), 'WError: my error');
+	mod_assert.ok(err.cause() === undefined);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    'WError: my error',
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = new WError({}, 'my error');
+	mod_assert.equal(err.toString(), 'WError: my error');
+	mod_assert.ok(err.cause() === undefined);
+
+	/* caused by another error, with no additional message */
+	suberr = new Error('root cause');
+	err = new WError(suberr);
+	mod_assert.equal(err.message, '');
+	mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	err = new WError({ 'cause': suberr });
+	mod_assert.equal(err.message, '');
+	mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	/* caused by another error, with annotation */
+	err = new WError(suberr, 'proximate cause: %d issues', 3);
+	mod_assert.equal(err.message, 'proximate cause: 3 issues');
+	mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
+	    'caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+	stack = mod_testcommon.cleanStack(err.stack);
+	/* See the comment in tst.inherit.js. */
+	stackmessage = mod_testcommon.oldNode() ?
+	    'WError: proximate cause: 3 issues; caused by Error: root cause' :
+	    'WError: proximate cause: 3 issues';
+	mod_assert.equal(stack, [
+	    stackmessage,
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	err = new WError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
+	mod_assert.equal(err.message, 'proximate cause: 3 issues');
+	mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
+	    'caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+	stack = mod_testcommon.cleanStack(err.stack);
+	mod_assert.equal(stack, [
+	    stackmessage,
+	    '    at main (dummy filename)',
+	    '    at Object.<anonymous> (dummy filename)'
+	].join('\n') + '\n' + nodestack);
+
+	/* caused by another WError, with annotation. */
+	suberr = err;
+	err = new WError(suberr, 'top');
+	mod_assert.equal(err.message, 'top');
+	mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
+	    'proximate cause: 3 issues; caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	err = new WError({ 'cause': suberr }, 'top');
+	mod_assert.equal(err.message, 'top');
+	mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
+	    'proximate cause: 3 issues; caused by Error: root cause');
+	mod_assert.ok(err.cause() === suberr);
+
+	/* caused by a VError */
+	suberr = new VError(new Error('root cause'), 'mid');
+	err = new WError(suberr, 'top');
+	mod_assert.equal(err.message, 'top');
+	mod_assert.equal(err.toString(),
+	    'WError: top; caused by VError: mid: root cause');
+	mod_assert.ok(err.cause() === suberr);
+}
+
+main();
diff --git a/tests/tst.serror.js b/tests/tst.serror.js
deleted file mode 100644
index 88ed610..0000000
--- a/tests/tst.serror.js
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * tst.serror.js: tests basic functionality of the SError class.
- */
-
-var mod_assert = require('assert');
-var mod_verror = require('../lib/verror');
-
-var VError = mod_verror.VError;
-var SError = mod_verror.SError;
-
-var err, suberr, stack, nodestack;
-
-/*
- * See tst.verror.js
- */
-function cleanStack(stacktxt)
-{
-	var re = new RegExp(__filename + ':\\d+:\\d+', 'gm');
-	stacktxt = stacktxt.replace(re, 'tst.serror.js');
-	return (stacktxt);
-}
-
-nodestack = new Error().stack.split('\n').slice(2).join('\n');
-
-/* basic no-args case */
-err = new SError();
-mod_assert.equal(err.name, 'VError');
-mod_assert.ok(err instanceof Error);
-mod_assert.ok(err instanceof VError);
-mod_assert.ok(err instanceof SError);
-mod_assert.equal(err.message, '');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'SError',
-    '    at Object.<anonymous> (tst.serror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* simple case */
-err = new SError('hello %d %ss', 3, 'world');
-mod_assert.equal(err.message, 'hello 3 worlds');
-
-/* include a cause */
-suberr = err;
-err = new SError(suberr, 'something wrong%s', '?');
-mod_assert.equal(err.message, 'something wrong?: hello 3 worlds');
-mod_assert.ok(err.cause() === suberr);
-
-/* include options */
-err = new SError({
-    'cause': suberr,
-    'constructorOpt': arguments.callee
-}, 'something wrong?');
-mod_assert.equal(err.message, 'something wrong?: hello 3 worlds');
-mod_assert.ok(err.cause() === suberr);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'SError: something wrong?: hello 3 worlds'
-].join('\n') + '\n' + nodestack);
-
-/* bad arguments */
-mod_assert.throws(function () { err = new SError('foo%sbar', null); },
-    /attempted to print undefined or null as a string/);
-mod_assert.throws(function () { err = new SError('foo%sbar', null); },
-    /attempted to print undefined or null as a string/);
-console.log('tests passed');
diff --git a/tests/tst.verror.js b/tests/tst.verror.js
deleted file mode 100644
index 2eb4c80..0000000
--- a/tests/tst.verror.js
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * tst.verror.js: tests basic functionality of the VError class.
- */
-
-var mod_assert = require('assert');
-var mod_verror = require('../lib/verror');
-
-var VError = mod_verror.VError;
-var WError = mod_verror.WError;
-
-var err, suberr, stack, substack;
-
-/*
- * Remove full paths and relative line numbers from stack traces so that we can
- * compare against "known-good" output.
- */
-function cleanStack(stacktxt)
-{
-	var re = new RegExp(__filename + ':\\d+:\\d+', 'gm');
-	stacktxt = stacktxt.replace(re, 'tst.verror.js');
-	return (stacktxt);
-}
-
-/*
- * Save the generic parts of all stack traces so we can avoid hardcoding
- * Node-specific implementation details in our testing of stack traces.
- */
-var nodestack = new Error().stack.split('\n').slice(2).join('\n');
-
-/* no arguments */
-err = new VError();
-mod_assert.equal(err.name, 'VError');
-mod_assert.ok(err instanceof Error);
-mod_assert.ok(err instanceof VError);
-mod_assert.equal(err.message, '');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* options-argument form */
-err = new VError({});
-mod_assert.equal(err.message, '');
-mod_assert.ok(err.cause() === undefined);
-
-/* simple message */
-err = new VError('my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: my error',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new VError({}, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.ok(err.cause() === undefined);
-
-/* printf-style message */
-err = new VError('%s error: %3d problems', 'very bad', 15);
-mod_assert.equal(err.message, 'very bad error:  15 problems');
-mod_assert.ok(err.cause() === undefined);
-
-err = new VError({}, '%s error: %3d problems', 'very bad', 15);
-mod_assert.equal(err.message, 'very bad error:  15 problems');
-mod_assert.ok(err.cause() === undefined);
-
-/* caused by another error, with no additional message */
-suberr = new Error('root cause');
-err = new VError(suberr);
-mod_assert.equal(err.message, ': root cause');
-mod_assert.ok(err.cause() === suberr);
-
-err = new VError({ 'cause': suberr });
-mod_assert.equal(err.message, ': root cause');
-mod_assert.ok(err.cause() === suberr);
-
-/* caused by another error, with annotation */
-err = new VError(suberr, 'proximate cause: %d issues', 3);
-mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
-mod_assert.ok(err.cause() === suberr);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: proximate cause: 3 issues: root cause',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new VError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
-mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
-mod_assert.ok(err.cause() === suberr);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: proximate cause: 3 issues: root cause',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* caused by another VError, with annotation. */
-suberr = err;
-err = new VError(suberr, 'top');
-mod_assert.equal(err.message, 'top: proximate cause: 3 issues: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-err = new VError({ 'cause': suberr }, 'top');
-mod_assert.equal(err.message, 'top: proximate cause: 3 issues: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-/* caused by a WError */
-suberr = new WError(new Error('root cause'), 'mid');
-err = new VError(suberr, 'top');
-mod_assert.equal(err.message, 'top: mid');
-mod_assert.ok(err.cause() === suberr);
-
-/* null cause (for backwards compatibility with older versions) */
-err = new VError(null, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: my error',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new VError({ 'cause': null }, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.ok(err.cause() === undefined);
-
-err = new VError(null);
-mod_assert.equal(err.message, '');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* constructorOpt */
-function makeErr(options) {
-	return (new VError(options, 'test error'));
-}
-err = makeErr({});
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: test error',
-    '    at makeErr (tst.verror.js)',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = makeErr({ 'constructorOpt': makeErr });
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'VError: test error',
-    '    at Object.<anonymous> (tst.verror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* "null" or "undefined" as string for extsprintf */
-err = new VError('my %s string', null);
-mod_assert.equal('my null string', err.message);
-err = new VError('my %s string', undefined);
-mod_assert.equal('my undefined string', err.message);
-
-/* invoked without "new" */
-err = VError('my %s string', 'testing!');
-mod_assert.equal(err.name, 'VError');
-mod_assert.ok(err instanceof VError);
-mod_assert.ok(err instanceof Error);
-mod_assert.equal(err.message, 'my testing! string');
diff --git a/tests/tst.werror.js b/tests/tst.werror.js
deleted file mode 100644
index c8cdc61..0000000
--- a/tests/tst.werror.js
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * tst.werror.js: tests basic functionality of the WError class.
- */
-
-var mod_assert = require('assert');
-var mod_verror = require('../lib/verror');
-
-var VError = mod_verror.VError;
-var WError = mod_verror.WError;
-
-var err, suberr, stack, substack;
-
-/*
- * Remove full paths and relative line numbers from stack traces so that we can
- * compare against "known-good" output.
- */
-function cleanStack(stacktxt)
-{
-	var re = new RegExp(__filename + ':\\d+:\\d+', 'gm');
-	stacktxt = stacktxt.replace(re, 'tst.werror.js');
-	return (stacktxt);
-}
-
-/*
- * Save the generic parts of all stack traces so we can avoid hardcoding
- * Node-specific implementation details in our testing of stack traces.
- */
-var nodestack = new Error().stack.split('\n').slice(2).join('\n');
-
-/* no arguments */
-err = new WError();
-mod_assert.equal(err.name, 'WError');
-mod_assert.ok(err instanceof Error);
-mod_assert.ok(err instanceof WError);
-mod_assert.equal(err.message, '');
-mod_assert.equal(err.toString(), 'WError');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* options-argument form */
-err = new WError({});
-mod_assert.equal(err.message, '');
-mod_assert.equal(err.toString(), 'WError');
-mod_assert.ok(err.cause() === undefined);
-
-/* simple message */
-err = new WError('my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.equal(err.toString(), 'WError: my error');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: my error',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new WError({}, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.equal(err.toString(), 'WError: my error');
-mod_assert.ok(err.cause() === undefined);
-
-/* printf-style message */
-err = new WError('%s error: %3d problems', 'very bad', 15);
-mod_assert.equal(err.message, 'very bad error:  15 problems');
-mod_assert.equal(err.toString(), 'WError: very bad error:  15 problems');
-mod_assert.ok(err.cause() === undefined);
-
-err = new WError({}, '%s error: %3d problems', 'very bad', 15);
-mod_assert.equal(err.message, 'very bad error:  15 problems');
-mod_assert.equal(err.toString(), 'WError: very bad error:  15 problems');
-mod_assert.ok(err.cause() === undefined);
-
-/* caused by another error, with no additional message */
-suberr = new Error('root cause');
-err = new WError(suberr);
-mod_assert.equal(err.message, '');
-mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-err = new WError({ 'cause': suberr });
-mod_assert.equal(err.message, '');
-mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-/* caused by another error, with annotation */
-err = new WError(suberr, 'proximate cause: %d issues', 3);
-mod_assert.equal(err.message, 'proximate cause: 3 issues');
-mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
-    'caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: proximate cause: 3 issues; caused by Error: root cause',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new WError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
-mod_assert.equal(err.message, 'proximate cause: 3 issues');
-mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
-    'caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: proximate cause: 3 issues; caused by Error: root cause',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* caused by another WError, with annotation. */
-suberr = err;
-err = new WError(suberr, 'top');
-mod_assert.equal(err.message, 'top');
-mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
-    'proximate cause: 3 issues; caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-err = new WError({ 'cause': suberr }, 'top');
-mod_assert.equal(err.message, 'top');
-mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
-    'proximate cause: 3 issues; caused by Error: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-/* caused by a VError */
-suberr = new VError(new Error('root cause'), 'mid');
-err = new WError(suberr, 'top');
-mod_assert.equal(err.message, 'top');
-mod_assert.equal(err.toString(),
-    'WError: top; caused by VError: mid: root cause');
-mod_assert.ok(err.cause() === suberr);
-
-/* null cause (for backwards compatibility with older versions) */
-err = new WError(null, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.equal(err.toString(), 'WError: my error');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: my error',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = new WError({ 'cause': null }, 'my error');
-mod_assert.equal(err.message, 'my error');
-mod_assert.equal(err.toString(), 'WError: my error');
-mod_assert.ok(err.cause() === undefined);
-
-err = new WError(null);
-mod_assert.equal(err.message, '');
-mod_assert.equal(err.toString(), 'WError');
-mod_assert.ok(err.cause() === undefined);
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-/* constructorOpt */
-function makeErr(options) {
-	return (new WError(options, 'test error'));
-}
-err = makeErr({});
-mod_assert.equal(err.toString(), 'WError: test error');
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: test error',
-    '    at makeErr (tst.werror.js)',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-
-err = makeErr({ 'constructorOpt': makeErr });
-mod_assert.equal(err.toString(), 'WError: test error');
-stack = cleanStack(err.stack);
-mod_assert.equal(stack, [
-    'WError: test error',
-    '    at Object.<anonymous> (tst.werror.js)'
-].join('\n') + '\n' + nodestack);
-- 
2.21.0

