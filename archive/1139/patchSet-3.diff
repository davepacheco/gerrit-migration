From 9bd5ab4fa0b935efa7851ca6597ffca81af9e70a Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 16 Dec 2016 23:56:05 +0000
Subject: [PATCH] NAPI-383 Migrate NAPI to restify-warden

---
 lib/util/validate.js | 359 +------------------------------------------
 package.json         |   1 +
 tools/rsync-to       |   7 +-
 3 files changed, 12 insertions(+), 355 deletions(-)

diff --git a/lib/util/validate.js b/lib/util/validate.js
index a6d61cf..1bb785c 100644
--- a/lib/util/validate.js
+++ b/lib/util/validate.js
@@ -19,14 +19,11 @@ var constants = require('../util/constants');
 var errors = require('./errors');
 var fmt = require('util').format;
 var ipaddr = require('ip6addr');
-var jsprim = require('jsprim');
-var restify = require('restify');
 var util = require('util');
 var util_common = require('./common');
 var util_ip = require('./ip');
 var util_mac = require('./mac');
-var verror = require('verror');
-var vasync = require('vasync');
+var warden = require('restify-warden');
 
 
 
@@ -37,52 +34,12 @@ var vasync = require('vasync');
 var INTERFACE_NAME_RE = /[a-zA-Z0-9_]{0,31}/;
 var INTERFACE_NUM_RE = /[0-9]+$/;
 var STR_RE = /\s/g;
-var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-
 
 
 // --- Internal helpers
 
 
 
-/**
- * Calls callback with the appropriate error depending on the contents of errs
- */
-function errResult(errs, validated, callback) {
-    var invalid = false;
-
-    if (errs.length !== 0) {
-        var realErrs = [];
-        var sortedErrs = errs.filter(function (e) {
-            if (!e.hasOwnProperty('field')) {
-                realErrs.push(e);
-                return false;
-            }
-            if (!invalid && e.hasOwnProperty('code') &&
-                e.code !== 'MissingParameter') {
-                invalid = true;
-            }
-
-            return true;
-        }).sort(function (a, b) { return (a.field > b.field) ? 1 : -1; });
-
-        if (realErrs.length !== 0) {
-            return callback(new restify.InternalError(
-                realErrs.length === 1 ? realErrs[0] :
-                    new verror.MultiError(realErrs),
-                'Internal error'));
-        }
-
-        return callback(new errors.InvalidParamsError(
-            invalid ? constants.msg.INVALID_PARAMS : 'Missing parameters',
-            sortedErrs));
-    }
-
-    return callback(null, validated);
-}
-
-
-
 // --- Exports
 
 
@@ -120,48 +77,6 @@ function validateEnum(values) {
     };
 }
 
-
-/**
- * Validates a "fields" array - an array of strings specifying which of an
- * object's fields to return in a response.  `fields` is the list of allowed
- * fields that can be in the array.
- */
-function validateFieldsArray(fields) {
-    assert.arrayOfString(fields, 'fields');
-    return function _validateFieldsArray(_, name, arr, callback) {
-        if (!util.isArray(arr)) {
-            return callback(new errors.invalidParam(name,
-                    constants.msg.ARRAY_OF_STR));
-        }
-
-        if (arr.length === 0) {
-            return callback(new errors.invalidParam(name,
-                    constants.msg.ARRAY_EMPTY));
-        }
-
-        if (arr.length >= fields.length) {
-            return callback(new errors.invalidParam(name,
-                fmt('can only specify a maximum of %d fields',
-                fields.length)));
-        }
-
-        for (var a in arr) {
-            if (typeof (arr[a]) !== 'string') {
-                return callback(new errors.invalidParam(name,
-                        constants.msg.ARRAY_OF_STR));
-            }
-
-            if (fields.indexOf(arr[a]) === -1) {
-                return callback(new errors.invalidParam(name,
-                    'unknown field specified'));
-            }
-        }
-
-        return callback(null, arr);
-    };
-}
-
-
 /**
  * Validates that a name is a valid illumos interface name
  */
@@ -438,47 +353,6 @@ function validateMTU(min, errmsg) {
     };
 }
 
-
-/**
- * Validates a UUID
- */
-function validateUUID(_, name, uuid, callback) {
-    if (typeof (uuid) !== 'string' || !UUID_RE.test(uuid)) {
-        return callback(new errors.invalidParam(name,
-                constants.msg.INVALID_UUID));
-    }
-
-    return callback(null, uuid);
-}
-
-
-/**
- * Validates an array of UUIDs
- */
-function validateUUIDarray(_, name, val, callback) {
-    var arr = util_common.arrayify(val);
-
-    // Dedup the list and find invalid UUIDs
-    var invalid = {};
-    var valid = {};
-    arr.forEach(function (uuid) {
-        if (UUID_RE.test(uuid)) {
-            valid[uuid] = 1;
-        } else {
-            invalid[uuid] = 1;
-        }
-    });
-
-    if (!jsprim.isEmpty(invalid)) {
-        var err = new errors.invalidParam(name, 'invalid UUID');
-        err.invalid = Object.keys(invalid).sort();
-        return callback(err);
-    }
-
-    return callback(null, Object.keys(valid).sort());
-}
-
-
 /**
  * Validates a VLAN ID
  */
@@ -506,233 +380,14 @@ function validateVxlanID(_, name, vlan_id, callback) {
 }
 
 
-function isNotInteger(val, id) {
-    assert.string(val);
-    return (val === '' || val.trim() !== val || isNaN(id) ||
-        Math.floor(id) !== id);
-}
-
-/**
- * Checks for valid limits and offsets which are integers greater than or equal
- * to zero. val usually is a string as it comes in from an HTTP query parameter.
- */
-function validateOffset(_, name, val, callback) {
-    var id = Number(val);
-
-    if (typeof (val) !== 'number') {
-        if (isNotInteger(val, id)) {
-            return callback(new errors.invalidParam(name,
-                constants.msg.OFFSET));
-        }
-    }
-
-    if (isNaN(id) || id < constants.MIN_OFFSET) {
-        return callback(new errors.invalidParam(name, constants.msg.OFFSET));
-    }
-
-    return callback(null, id);
-}
-
-
-/**
- * Checks for valid limits which are integers in the range (0, 1000]. val is
- * usually a string as it comes in from an HTTP query parameter.
- */
-function validateLimit(_, name, val, callback) {
-    var id = Number(val);
-
-    if (typeof (val) !== 'number') {
-        if (isNotInteger(val, id)) {
-            return callback(new errors.invalidParam(name,
-                constants.msg.LIMIT));
-        }
-    }
-
-    if (isNaN(id) || id < constants.MIN_LIMIT || id > constants.MAX_LIMIT) {
-        return callback(new errors.invalidParam(name, constants.msg.LIMIT));
-    }
-
-    return callback(null, id);
-}
-
-/**
- * Check for any uknown parameters if strict mode is engaged.
- */
-function validateUnknowns(params, req, opt) {
-    var field;
-    var unknowns = [];
-
-    for (field in params) {
-        if (!params.hasOwnProperty(field)) {
-            continue;
-        }
-        if ((req && req.hasOwnProperty(field)) ||
-           (opt && opt.hasOwnProperty(field))) {
-            continue;
-        }
-
-        unknowns.push(field);
-    }
-
-    if (unknowns.length === 0) {
-        return null;
-    }
-
-    return new errors.unknownParams(unknowns);
-}
-
-
-/**
- * Validate parameters on an object.
- *
- * @param opts {Object}: Options for validating the input object
- * - `strict` {Boolean}: Fail if there are extra, unknown fields on the object
- * - `required` {Object}: A map of validation functions for each required field
- * - `optional` {Object}: A map of validation functions for each optional field
- * @param arg {Any}: A value to pass as the first argument to each validation
- *     function. Usually an object containing configuration information or a
- *     database handle.
- * @param params {Object}: Object to validate
- * @param callback {Function}: Callback with (err, validated) where validated
- *     is an object with only validated fields or fields added by the
- *     validation functions.
- */
-function validateParams(opts, arg, params, callback) {
-    var errs = [];
-    var field;
-    var validatedParams = {};
-
-    assert.object(opts, 'opts');
-    assert.optionalBool(opts.strict, 'opts.strict');
-    assert.optionalObject(opts.required, 'opts.required');
-    assert.optionalObject(opts.optional, 'opts.optional');
-    assert.func(callback);
-
-    if (!params || typeof (params) !== 'object' || Array.isArray(params)) {
-        errs.push(errors.invalidParam('parameters',
-            constants.msg.PARAMETERS_ARE_OBJECTS));
-        errResult(errs, validatedParams, callback);
-        return;
-    }
-
-    var toValidate = [];
-
-    for (field in opts.required) {
-        assert.func(opts.required[field],
-            fmt('opts.required[%s]', field));
-
-        if (params.hasOwnProperty(field)) {
-            toValidate.push({
-                field: field,
-                fn: opts.required[field],
-                val: params[field]
-            });
-        } else {
-            errs.push(errors.missingParam(field));
-        }
-    }
-
-    for (field in opts.optional) {
-        assert.func(opts.optional[field],
-            fmt('opts.required[%s]', field));
-
-        if (params.hasOwnProperty(field)) {
-            toValidate.push({
-                field: field,
-                fn: opts.optional[field],
-                val: params[field]
-            });
-        }
-    }
-
-    vasync.forEachParallel({
-        inputs: toValidate,
-        func: function _callValidateFn(val, cb) {
-            // TODO: allow specifying an array of validation functions, and bail
-            // after the first failure
-
-            val.fn(arg, val.field, val.val, function (e, validated, multi) {
-                if (e) {
-                    errs.push(e);
-                }
-
-                if (typeof (validated) !== 'undefined') {
-                    validatedParams[val.field] = validated;
-
-                    // if (typeof (validated) === 'object' &&
-                    //     !validated.hasOwnProperty('length')) {
-                    //     for (var v in validated) {
-                    //         validatedParams[v] = validated[v];
-                    //     }
-                    // } else {
-                    //     validatedParams[val.field] = validated;
-                    // }
-
-                }
-                if (typeof (multi) !== 'undefined' &&
-                    typeof (multi) === 'object') {
-
-                    for (var v in multi) {
-                        validatedParams[v] = multi[v];
-                    }
-                }
-
-                return cb();
-            });
-        }
-    }, function after() {
-        if (opts.strict) {
-            var err = validateUnknowns(params, opts.required,
-                opts.optional);
-            if (err !== null) {
-                errs.push(err);
-            }
-        }
-
-        if (opts.hasOwnProperty('after') && errs.length === 0) {
-            if (!Array.isArray(opts.after)) {
-                opts.after = [opts.after];
-            }
-            return crossValidate(errs, arg, params, validatedParams,
-                opts.after, callback);
-        }
-        return errResult(errs, validatedParams, callback);
-    });
-}
-
-/**
- * Used by validate.params to call an array of 'after' functions, which have
- * access to all the raw and validated parameters. This is typically used to
- * validate conditions between parameters, e.g., nicTag/network MTUs.
- */
-function crossValidate(errs, arg, raw, validated, afterFuncs, callback) {
-    vasync.forEachPipeline({
-        inputs: afterFuncs,
-        func: function _validate(func, cb) {
-            func(arg, raw, validated, function (err) {
-                if (err) {
-                    if (Array.isArray(err)) {
-                        errs = errs.concat(err);
-                    } else {
-                        errs.push(err);
-                    }
-                }
-                return cb();
-            });
-        }
-    }, function (_, _results) {
-        return errResult(errs, validated, callback);
-    });
-}
-
 module.exports = {
     bool: validateBoolean,
     enum: validateEnum,
-    fieldsArray: validateFieldsArray,
+    fieldsArray: warden.fieldsArray,
     IP: validateIP,
     ipArray: validateIParray,
     interfaceName: validateInterfaceName,
-    limit: validateLimit,
+    limit: warden.limit,
     MAC: validateMAC,
     MACarray: validateMACarray,
     nicTagMTU: validateMTU(constants.MTU_NICTAG_MIN,
@@ -740,14 +395,14 @@ module.exports = {
     networkMTU: validateMTU(constants.MTU_NETWORK_MIN,
         constants.MTU_NETWORK_INVALID_MSG),
     nicTagName: validateNicTagName,
-    offset: validateOffset,
-    params: validateParams,
+    offset: warden.offset,
+    params: warden.params,
     string: validateString,
     stringOrArray: validateStringOrArray,
     stringArray: validateStringArray,
     subnet: validateSubnet,
-    UUID: validateUUID,
-    UUIDarray: validateUUIDarray,
+    UUID: warden.UUID,
+    UUIDarray: warden.UUIDarray,
     VLAN: validateVLAN,
     VxLAN: validateVxlanID
 };
diff --git a/package.json b/package.json
index 57b3b1f..edeefb2 100644
--- a/package.json
+++ b/package.json
@@ -18,6 +18,7 @@
     "node-uuid": "1.4.7",
     "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#c756be9",
     "restify": "4.1.1",
+    "restify-warden": "git+https://github.com/joyent/node-restify-warden.git",
     "sdc-clients": "9.2.0",
     "tape": "4.5.1",
     "trace-event": "1.3.0",
diff --git a/tools/rsync-to b/tools/rsync-to
index e207979..05066cf 100755
--- a/tools/rsync-to
+++ b/tools/rsync-to
@@ -19,11 +19,12 @@ set -o errexit
 TOP=$(cd $(dirname $0)/../; pwd)
 NODE=root@$1
 
-if [[ -z "$NAPI_ZONE" ]]; then
-    NAPI_ZONE=$(ssh $NODE "/opt/smartdc/bin/sdc-vmapi /vms" 2>/dev/null \
+while [[ -z "$NAPI_ZONE" ]]; do
+    echo "Trying to get NAPI zone"
+    NAPI_ZONE=$(ssh $NODE "/opt/smartdc/bin/sdc-vmapi /vms?alias=napi0" 2>/dev/null \
         | json -H -c 'this.tags && this.tags.smartdc_role === "napi"' \
             -c 'this.state === "running"' 0.uuid)
-fi
+done
 echo "NAPI_ZONE: $NAPI_ZONE"
 
 extraOpts=
-- 
2.21.0

