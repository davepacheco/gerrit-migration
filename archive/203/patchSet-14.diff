From 9c8be9eb8534c92c875f550875c8de7f5d4c034d Mon Sep 17 00:00:00 2001
From: "Pedro P. Candel" <pedro@joyent.com>
Date: Thu, 30 Mar 2017 18:24:35 +0200
Subject: [PATCH] TOOLS-1345 sdcadm update manatee does not update more than
 one async

---
 lib/common.js                       |  25 +-
 lib/procedures/shared.js            | 241 +++++++++------
 lib/procedures/update-manatee-v2.js | 456 +++++++++++++++-------------
 3 files changed, 421 insertions(+), 301 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 0c8f3e5..5518a77 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -878,19 +878,24 @@ function manateeAdmRemote(opts, cb) {
  * {
  *      primary: {
  *          pg_status: 'ok',
- *          repl_status: 'sync'
+ *          repl_status: 'sync',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      sync: {
  *          pg_status: 'ok',
- *          repl_status: 'async'
+ *          repl_status: 'async',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      async: [{
  *          pg_status: 'ok'
+ *          repl_status: 'async' | '-',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      }]
  * }
  *
  * Note that it's theoretically possible to have more than one async member,
- * but it isn't too common.
+ * but it isn't too common. On those cases, every async member but the last
+ * one will also have a 'repl_status' member with an expected value of 'async'.
  */
 function manateeShardStatus(opts, cb) {
     assert.object(opts, 'opts');
@@ -899,10 +904,11 @@ function manateeShardStatus(opts, cb) {
     assert.object(opts.log, 'opts.log');
     assert.func(cb, 'cb');
 
-    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -H';
+    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -o peerabbr -H';
     manateeAdmRemote(opts, function (err, stdout, stderr) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
 
         var rawPgSt = JSON.parse(stdout);
@@ -923,19 +929,22 @@ function manateeShardStatus(opts, cb) {
             if (m[0] === 'primary' || m[0] === 'sync') {
                 shardPgSt[m[0]] = {
                     pg_status: m[1],
-                    repl_status: m[2]
+                    repl_status: m[2],
+                    peer_abbr: m[3]
                 };
             } else {
                 if (!shardPgSt[m[0]]) {
                     shardPgSt[m[0]] = [];
                 }
                 shardPgSt[m[0]].push({
-                    pg_status: m[1] || '-'
+                    pg_status: m[1] || '-',
+                    repl_status: m[2] || '-',
+                    peer_abbr: m[3]
                 });
             }
         });
 
-        return cb(null, shardPgSt);
+        cb(null, shardPgSt);
     });
 }
 
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index e4c34d0..356728d 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var path = require('path');
@@ -1155,6 +1155,10 @@ function manateeSitterSvcStatus(opts, callback) {
  *      @param {Boolean} hasManatee21: when true, use `pg-status` instead
  *          of the deprecated `status`, which was added for version 2.1.0
  *          of manatee-adm
+ *      @param {String} peer: UUID of the manatee peer we are waiting for
+ *          (useful when we have more than one async member). If this value is
+ *          not given, we assume that the value given for `state` is required
+ *          for *all* the peers with the provided `role`.
  * @param {Function} callback: of the form f(err).
  */
 function waitForManatee(opts, callback) {
@@ -1164,12 +1168,17 @@ function waitForManatee(opts, callback) {
     assert.string(opts.manateeUUID, 'opts.manateeUUID');
     assert.string(opts.role, 'opts.role');
     assert.string(opts.state, 'opts.state');
+    assert.optionalString(opts.peer, 'opts.peer');
     assert.optionalString(opts.leaderIP, 'opts.leaderIP');
     assert.optionalBool(opts.hasManatee21, 'opts.hasManatee21');
     assert.func(callback, 'callback');
 
     opts.hasManatee21 = opts.hasManatee21 || false;
 
+    if (opts.peer && common.UUID_RE.test(opts.peer)) {
+        opts.peer = opts.peer.substring(0, opts.peer.indexOf('-'));
+    }
+
     var func = (opts.hasManatee21) ? common.manateeShardStatus : getShardStatus;
 
     // Translate from deprecated shard status to simplified object format.
@@ -1185,18 +1194,29 @@ function waitForManatee(opts, callback) {
                     pg_status: obj.sdc[m].online ? 'ok': '-',
                     repl_status: (obj.sdc[m].repl &&
                         obj.sdc[m].repl.sync_state) ?
-                            obj.sdc[m].repl.sync_state : '-'
+                            obj.sdc[m].repl.sync_state : '-',
+                    peer_abbr: obj.sdc[m].zoneId.substring(0,
+                            obj.sdc[m].zoneId.indexOf('-'))
                 };
             } else if (!obj.sdc[m].error) {
-                if (!shardPgSt[m]) {
-                    shardPgSt[m] = [];
+                if (!shardPgSt.async) {
+                    shardPgSt.async = [];
                 }
+                var peerSt = {};
 
                 if (typeof (obj.sdc[m].online) !== 'undefined') {
-                    shardPgSt[m].push({
-                        pg_status: obj.sdc[m].online ? 'ok': '-'
-                    });
+                    peerSt.pg_status =  obj.sdc[m].online ? 'ok': '-';
                 }
+
+                if (obj.sdc[m].repl && obj.sdc[m].repl.sync_state) {
+                    peerSt.repl_status = obj.sdc[m].repl.sync_state;
+                }
+
+                if (obj.sdc[m].zoneId) {
+                    peerSt.peer_abbr = obj.sdc[m].zoneId.substring(0,
+                            obj.sdc[m].zoneId.indexOf('-'));
+                }
+                shardPgSt.async.push(peerSt);
             }
         });
         opts.log.trace({
@@ -1217,7 +1237,8 @@ function waitForManatee(opts, callback) {
             counter += 1;
 
             if (err) {
-                return callback(err);
+                callback(err);
+                return;
             }
 
             if (!opts.hasManatee21) {
@@ -1255,24 +1276,55 @@ function waitForManatee(opts, callback) {
                 break;
             case 'async':
                 if (opts.state === 'disabled') {
-                    if (!obj.async || !obj.async.length ||
-                            obj.async[0].pg_status !== 'ok') {
+                    if (!obj.async || !obj.async.length) {
+                        done = true;
+                    } else if (opts.peer) {
+                        // If we have a specific peer, we can check if it is
+                        // disabled.
+                        var peerArr = obj.async.filter(function (p) {
+                            return (p.peer_abbr === opts.peer);
+                        });
+
+                        if (peerArr.length && peerArr[0].pg_status !== 'ok') {
+                            done = true;
+                        }
+                    // Otherwise, we'll assume that we want every async peer
+                    // disabled.
+                    } else if (obj.async.every(function (peer) {
+                            return (peer.pg_status !== 'ok');
+                        })) {
                         done = true;
                     }
+
                 } else {
-                    if (!obj.async || !obj.async.length) {
+                    // If we don't have an async member yet, or some of the
+                    // async members have a pg_status not OK, we'll need to
+                    // wait for them.
+                    // Also, we want to wait for the async members to catch
+                    // up on replication, either straight from the sync, or
+                    // from the sucessive async members
+                    if (!obj.async || !obj.async.length ||
+                        obj.async.some(function (peer) {
+                        return (peer.pg_status !== 'ok');
+                    }) || (obj.sync && obj.sync.repl_status !== 'async')) {
                         done = false;
                     } else {
-                        if (obj.async[0].pg_status === 'ok' && obj.sync &&
-                                obj.sync.repl_status === 'async') {
-                            done = true;
-                        }
+                        // The latest shard member will never have a
+                        // replication status but if we have more than one
+                        // async member, all of them but the latest one should
+                        // have a replication status of 'async', if not just
+                        // reset the previous completion flag:
+                        done = obj.async.some(function (peer) {
+                            return (peer.repl_status &&
+                                    peer.repl_status !== 'async');
+                        });
                     }
                 }
                 break;
             default:
-                return callback(new errors.UsageError(
-                            'Unknown manatee role ' + opts.role));
+                callback(new errors.UsageError(
+                    'Unknown manatee role ' + opts.role));
+                return;
             }
 
 
@@ -1284,13 +1336,15 @@ function waitForManatee(opts, callback) {
             }, 'manatee shard state object');
 
             if (done) {
-                return callback(null);
+                callback(null);
+                return;
             }
 
             // If mode is deposed, it will not change nevermore, let's
             // return here and avoid waiting for anything else
             if (obj.deposed) {
-                return callback('deposed');
+                callback('deposed');
+                return;
             }
 
             if (counter < limit) {
@@ -1303,17 +1357,18 @@ function waitForManatee(opts, callback) {
                     vm: opts.manateeUUID
                 }, function (er2, st) {
                     if (er2) {
-                        return callback(er2);
+                        callback(er2);
+                        return;
                     }
                     if (st === 'maintenance') {
                         return callback(new InternalError({
                             message: 'manatee-sitter went into maintenance'
                         }));
                     }
-                    return setTimeout(_waitForStatus, 5000);
+                    setTimeout(_waitForStatus, 5000);
                 });
             } else {
-                return callback(format(
+                callback(format(
                     'Timeout (15m) waiting for manatee %s to be %s',
                     opts.role, opts.state));
             }
@@ -1382,39 +1437,7 @@ function disableManateeSitter(opts, cb) {
     var leaderIP = opts.leaderIP || null;
     var hasManatee21 = opts.hasManatee21 || false;
 
-    vasync.pipeline({funcs: [
-        function disableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                return next();
-            }
-            progress('Disabling async manatee');
-            disableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
-
-        function waitAsyncDisabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                return next();
-            }
-            progress('Waiting for async manatee to be disabled');
-            var _opts = {
-                state: 'disabled',
-                role: 'async',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
-        },
-
+    var funcs = [
         function disableSyncManatee(_, next) {
             if (!shard.sync) {
                 return next();
@@ -1472,7 +1495,44 @@ function disableManateeSitter(opts, cb) {
             }
             waitForManatee(_opts, next);
         }
-    ]}, cb);
+    ];
+
+    if (shard.async && shard.async.length) {
+        shard.async.forEach(function (peer) {
+            funcs.unshift(
+                function disableAsyncManatee(_, next) {
+                    progress('Disabling async manatee peer %s',
+                        peer.zoneId);
+                    disableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
+
+                function waitAsyncDisabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be disabled',
+                        peer.zoneId);
+                    var _opts = {
+                        state: 'disabled',
+                        role: 'async',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
+
+    vasync.pipeline({funcs: funcs}, cb);
 
 }
 
@@ -1489,7 +1549,7 @@ function enableManateeSitter(opts, cb) {
     var leaderIP = opts.leaderIP || null;
     var hasManatee21 = opts.hasManatee21 || false;
 
-    vasync.pipeline({funcs: [
+    var funcs = [
         function enablePrimaryManatee(_, next) {
             progress('Enabling primary manatee');
             enableRemoteSvc({
@@ -1548,41 +1608,44 @@ function enableManateeSitter(opts, cb) {
                 _opts.leaderIP = leaderIP;
             }
             waitForManatee(_opts, next);
-        },
+        }
+    ];
 
-        function enableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                return next();
-            }
-            progress('Enabling async manatee');
-            enableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
+    if (shard.async && shard.async.length) {
+        shard.async.forEach(function (peer) {
+            funcs.push(
+                function enableAsyncManatee(_, next) {
+                    progress('Enabling async manatee peer %s', peer.zoneId);
+                    enableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
 
-        function waitAsyncEnabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                return next();
-            }
-            progress('Waiting for async manatee to be enabled');
-            var _opts = {
-                role: 'async',
-                state: 'enabled',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
-        }
+                function waitAsyncEnabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be enabled',
+                        peer.zoneId);
+                    var _opts = {
+                        role: 'async',
+                        state: 'enabled',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
 
-    ]}, cb);
+    vasync.pipeline({funcs: funcs}, cb);
 }
 
 /**
diff --git a/lib/procedures/update-manatee-v2.js b/lib/procedures/update-manatee-v2.js
index d95f641..0b9ed37 100644
--- a/lib/procedures/update-manatee-v2.js
+++ b/lib/procedures/update-manatee-v2.js
@@ -196,9 +196,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
             // In case of failure, prevent update procedure to re-run updates
             // of instances already updated on the previous attempt:
-            async_updated: false,
-            sync_updated: false,
-            primary_updated: false
+            updated_vms: []
         };
         var manateeUUID;
         var sapiUUID;
@@ -226,7 +224,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
         function waitForManatee(
                 role, state, server, zone, hasManatee21, callback
         ) {
-            return s.waitForManatee({
+            s.waitForManatee({
                 log: log,
                 server: server,
                 manateeUUID: zone,
@@ -344,8 +342,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             }
             progress('Freezing cluster state');
             common.manateeFreeze({
-                server: arg.shard.async.server_uuid,
-                vm: arg.shard.async.zoneId,
+                server: arg.shard.primary.server_uuid,
+                vm: arg.shard.primary.zoneId,
                 reason: 'sdcadm ' + opts.wrkDir,
                 log: log
             }, function (err) {
@@ -396,9 +394,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             });
         }
 
-        var context = {};
-
-        vasync.pipeline({arg: context, funcs: funcs.concat([
+        vasync.pipeline({arg: arg, funcs: funcs.concat([
 
             /*
              * We cannot generally proceed successfully through this
@@ -459,7 +455,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 getShardStateLocally(manateeUUID, hasPgStatus,
                         function (err, st) {
                     if (err) {
-                        return next(err);
+                        next(err);
+                        return;
                     }
                     Object.keys(st).forEach(function (m) {
                         if (['primary', 'sync', 'async'].indexOf(m) !== -1) {
@@ -473,8 +470,9 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             '`manatee-adm rebuild`\n before attempting the ' +
                             'update again.';
                         progress(msg);
-                        return next(new errors.UpdateError(new Error(msg),
-                                    'manatee-adm'));
+                        next(new errors.UpdateError(new Error(msg),
+                            'manatee-adm'));
+                        return;
                     }
                     // Refuse to update HA setup w/o all the shard members.
                     // Instead, suggest to complete HA setup
@@ -484,15 +482,13 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             'sdcadm post-setup ha-manatee\n before ' +
                             'attempting the update again.';
                         progress(msg2);
-                        return next(new errors.UpdateError(new Error(msg2),
-                                    'sdcadm'));
+                        next(new errors.UpdateError(new Error(msg2),
+                            'sdcadm'));
+                        return;
 
                     }
-                    // For now can handle only a single 'async' manatee
-                    if (arg.shard.async && arg.shard.async.length) {
-                        arg.shard.async = arg.shard.async[0];
-                    }
-                    return next();
+                    next();
+                    return;
                 });
             },
 
@@ -503,22 +499,39 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     arg.shard.primary.server_hostname = change.inst.hostname;
                     arg.shard.primary.alias = change.inst.alias;
                     arg.shard.primary.image = change.inst.image;
-                    return next();
+                    next();
+                    return;
                 }
 
-
                 vasync.forEachParallel({
                     inputs: Object.keys(arg.shard),
                     func: function getManateeServer(role, callback) {
-                        var inst = change.insts.filter(function (x) {
-                            return (x.zonename === arg.shard[role].zoneId);
-                        })[0];
-                        arg.shard[role].server_uuid = inst.server;
-                        arg.shard[role].server_hostname = inst.hostname;
-                        arg.shard[role].alias = inst.alias;
-                        arg.shard[role].image = inst.image;
-                        arg.shard[role].role = role;
-                        callback();
+                        var i, inst;
+                        if (Array.isArray(arg.shard[role])) {
+                            for (i = 0; i < arg.shard[role].length; i += 1) {
+                                inst = change.insts.filter(function (x) {
+                                    return (x.zonename ===
+                                            arg.shard[role][i].zoneId);
+                                })[0];
+                                arg.shard[role][i].server_uuid = inst.server;
+                                arg.shard[role][i].server_hostname =
+                                    inst.hostname;
+                                arg.shard[role][i].alias = inst.alias;
+                                arg.shard[role][i].image = inst.image;
+                                arg.shard[role][i].role = role;
+                            }
+                            callback();
+                        } else {
+                            inst = change.insts.filter(function (x) {
+                                return (x.zonename === arg.shard[role].zoneId);
+                            })[0];
+                            arg.shard[role].server_uuid = inst.server;
+                            arg.shard[role].server_hostname = inst.hostname;
+                            arg.shard[role].alias = inst.alias;
+                            arg.shard[role].image = inst.image;
+                            arg.shard[role].role = role;
+                            callback();
+                        }
                     }
                 }, next);
             },
@@ -532,7 +545,9 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     nodes.push(arg.shard.sync.server_uuid);
                 }
                 if (arg.shard.async) {
-                    nodes.push(arg.shard.async.server_uuid);
+                    arg.shard.async.forEach(function (peer) {
+                        nodes.push(peer.server_uuid);
+                    });
                 }
                 nodes = nodes.sort().filter(function (item, pos, ary) {
                     return (!pos || item !== ary[pos - 1]);
@@ -582,39 +597,45 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
 
             function checkInstanceImages(_, next) {
                 if (!arg.HA || opts.plan.forceSameImage) {
-                    return next();
+                    next();
+                    return;
                 }
+                var inputs = [arg.shard.primary, arg.shard.sync];
+                arg.shard.async.forEach(function (peer) {
+                    inputs.push(peer);
+                });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function (vm, next_) {
                         sdcadm.imgapi.getImage(vm.image, function (err, img_) {
                             if (err) {
-                                return next_(err);
+                                next_(err);
+                                return;
                             }
                             if (img_.uuid === arg.change.image.uuid) {
-                                arg[vm.role + '_updated'] = true;
+                                arg.updated_vms.push(vm.zoneId);
                             }
-                            return next_();
+                            next_();
+                            return;
                         });
                     }
                 }, function paraCb(parallelErr) {
                     if (parallelErr) {
-                        return next(parallelErr);
+                        next(parallelErr);
+                        return;
                     }
-                    return next();
+                    next();
                 });
             },
 
             function installPrimaryImage(_, next) {
                 if (!arg.HA) {
-                    return s.imgadmInstall(arg, next);
+                    s.imgadmInstall(arg, next);
                 } else {
-                    if (arg.primary_updated) {
-                        return next();
+                    if (arg.updated_vms.indexOf(
+                            arg.shard.primary.zoneId) !== -1) {
+                        next();
+                        return;
                     }
                     progress('Installing image %s\n    (%s@%s) on server %s',
                         arg.change.image.uuid, arg.change.image.name,
@@ -631,71 +652,85 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
             },
 
-            function installImageAsyncServer(_, next) {
+            function installImageSyncServer(_, next) {
                 if (!arg.HA) {
-                    return next();
+                    next();
+                    return;
                 }
 
-                if (arg.shard.async.server_uuid ===
-                        arg.shard.primary.server_uuid) {
-                    return next();
+                if ((arg.shard.sync.server_uuid ===
+                        arg.shard.primary.server_uuid)) {
+                    next();
+                    return;
                 }
 
-                if (arg.async_updated) {
-                    return next();
+                if (arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
+                    next();
+                    return;
                 }
 
                 progress('Installing image %s\n    (%s@%s) on server %s',
                     arg.change.image.uuid, arg.change.image.name,
-                    arg.change.image.version, arg.shard.async.server_uuid);
+                    arg.change.image.version, arg.shard.sync.server_uuid);
 
                 s.imgadmInstallRemote({
-                    server: arg.shard.async.server_uuid,
+                    server: arg.shard.sync.server_uuid,
                     img: arg.change.image,
                     progress: progress,
                     log: log
                 }, next);
             },
 
-            function installImageSyncServer(_, next) {
+            function installImageAsyncServers(_, next) {
                 if (!arg.HA) {
-                    return next();
+                    next();
+                    return;
                 }
 
-                if ((arg.shard.sync.server_uuid ===
-                        arg.shard.primary.server_uuid) ||
-                        (arg.shard.sync.server_uuid ===
-                         arg.shard.async.server_uuid)) {
-                    return next();
-                }
+                vasync.forEachPipeline({
+                    inputs: arg.shard.async,
+                    func: function installAsyncImg(peer, next_) {
+                        if ((peer.server_uuid ===
+                            arg.shard.primary.server_uuid) ||
+                            (peer.server_uuid === arg.shard.sync.server_uuid)) {
+                            next_();
+                            return;
+                        }
 
-                if (arg.sync_updated) {
-                    return next();
-                }
+                        if (arg.updated_vms.indexOf(peer.zoneId) !== -1) {
+                            next_();
+                            return;
+                        }
 
-                progress('Installing image %s\n    (%s@%s) on server %s',
-                    arg.change.image.uuid, arg.change.image.name,
-                    arg.change.image.version, arg.shard.sync.server_uuid);
+                        progress('Installing image %s\n    ' +
+                            '(%s@%s) on server %s',
+                            arg.change.image.uuid, arg.change.image.name,
+                            arg.change.image.version, peer.server_uuid);
 
-                s.imgadmInstallRemote({
-                    server: arg.shard.sync.server_uuid,
-                    img: arg.change.image,
-                    progress: progress,
-                    log: log
+                        s.imgadmInstallRemote({
+                            server: peer.server_uuid,
+                            img: arg.change.image,
+                            progress: progress,
+                            log: log
+                        }, next_);
+                    }
                 }, next);
             },
 
+
+
             // TOOLS-1223: ensure automatic fix for MANATEE-292
             function setCanmount(_, next) {
                 if (!arg.HA) {
-                    return next();
+                    next();
+                    return;
                 }
+                var inputs = [arg.shard.primary, arg.shard.sync];
+                arg.shard.async.forEach(function (peer) {
+                    inputs.push(peer);
+                });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function _setCanmount(vm, next_) {
                         getCanmount(vm.server_uuid, vm.zoneId,
                                 function (cmErr, canmount) {
@@ -837,85 +872,117 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 return freeze(_,  next);
             },
 
-            function reprovisionAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    return next();
-                }
-                progress('Reprovisioning "async" manatee');
-                return s.reprovisionRemote({
-                    server: arg.shard.async.server_uuid,
-                    img: arg.change.image,
-                    zonename: arg.shard.async.zoneId,
-                    progress: progress,
-                    log: log,
-                    sdcadm: opts.sdcadm
-                }, next);
-            },
+            function reprovisionAsyncPeers(_, next) {
+                var backfillDone = false;
+                function reprovisionAsyncPeer(peer, nextPeer) {
+                    vasync.pipeline({
+                        arg: peer,
+                        funcs: [
+                            function reprovisionAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function waitForAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    return next();
-                }
-                progress('Wait for manatee instance %s to come up',
-                    arg.shard.async.zoneId);
-                return s.waitForInstToBeUp({
-                    change: {
-                        server: arg.shard.async.server_uuid,
-                        type: 'update-instance',
-                        service: 'manatee',
-                        image: arg.change.image,
-                        inst: {
-                            instance: arg.shard.async.zoneId,
-                            zonename: arg.shard.async.zoneId,
-                            uuid: arg.shard.async.zoneId,
-                            server: arg.shard.async.server_uuid,
-                            service: 'manatee',
-                            image: arg.change.image.uuid,
-                            version: arg.change.image.version,
-                            type: 'vm'
-                        }
-                    },
-                    opts: {
-                        progress: progress,
-                        sdcadm: sdcadm,
-                        log: log
-                    }
-                }, next);
-            },
+                                progress('Reprovisioning "async" manatee (%s)',
+                                    p.alias);
+                                s.reprovisionRemote({
+                                    server: p.server_uuid,
+                                    img: arg.change.image,
+                                    zonename: p.zoneId,
+                                    progress: progress,
+                                    log: log,
+                                    sdcadm: opts.sdcadm
+                                }, nextStep);
+                            },
+
+                            function waitForAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Wait for manatee instance %s (%s) ' +
+                                    'to come up', p.zoneId, p.alias);
+                                s.waitForInstToBeUp({
+                                    change: {
+                                        server: p.server_uuid,
+                                        type: 'update-instance',
+                                        service: 'manatee',
+                                        image: arg.change.image,
+                                        inst: {
+                                            instance: p.zoneId,
+                                            zonename: p.zoneId,
+                                            uuid: p.zoneId,
+                                            server: p.server_uuid,
+                                            service: 'manatee',
+                                            image: arg.change.image.uuid,
+                                            version: arg.change.image.version,
+                                            type: 'vm'
+                                        }
+                                    },
+                                    opts: {
+                                        progress: progress,
+                                        sdcadm: sdcadm,
+                                        log: log
+                                    }
+                                }, nextStep);
+                            },
+
+                            function asyncStateBackfill(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA || version !== '1.0.0' ||
+                                    backfillDone) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function asyncStateBackfill(_, next) {
-                if (!arg.HA || version !== '1.0.0' || arg.async_updated) {
-                    return next();
+                                progress('Backfilling cluster state');
+                                common.manateeAdmRemote({
+                                    server: p.server_uuid,
+                                    vm: p.zoneId,
+                                    cmd: 'state-backfill -y',
+                                    log: log
+                                }, function (err) {
+                                    backfillDone = true;
+                                    nextStep(err);
+                                });
+                            },
+
+                            function waitForHA(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Waiting for manatee "async" to be ' +
+                                    'online (%s)', p.alias);
+                                waitForManatee('async', 'enabled',
+                                    arg.shard.primary.server_uuid,
+                                    arg.shard.primary.zoneId, hasPgStatus,
+                                    nextStep);
+                            }
+                        ]
+                    }, nextPeer);
                 }
-                progress('Backfilling cluster state');
-                common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
-                    cmd: 'state-backfill -y',
-                    log: log
+                vasync.forEachPipeline({
+                    inputs: arg.shard.async,
+                    func: reprovisionAsyncPeer
                 }, next);
             },
-
-            function waitForHA(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    return next();
-                }
-                progress('Waiting for manatee async to be online');
-                waitForManatee('async', 'enabled',
-                        arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
-            },
-
             function freezeBeforeSync(_, next) {
-                return freeze(_,  next);
+                freeze(_,  next);
             },
 
             function reprovisionSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
-                    return next();
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
+                    next();
+                    return;
                 }
                 progress('Reprovisioning "sync" manatee');
-                return s.reprovisionRemote({
+                s.reprovisionRemote({
                     server: arg.shard.sync.server_uuid,
                     img: arg.change.image,
                     zonename: arg.shard.sync.zoneId,
@@ -926,12 +993,14 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
-                    return next();
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
+                    next();
+                    return;
                 }
                 progress('Wait for manatee instance %s to come up',
                     arg.shard.sync.zoneId);
-                return s.waitForInstToBeUp({
+                s.waitForInstToBeUp({
                     change: {
                         server: arg.shard.sync.server_uuid,
                         type: 'update-instance',
@@ -957,25 +1026,29 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForHASync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
-                    return next();
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
+                    next();
+                    return;
                 }
                 progress('Waiting for manatee sync to be online');
                 waitForManatee('sync', 'enabled', arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
+                    arg.shard.primary.zoneId, hasPgStatus, next);
             },
 
             function freezeBeforePrimary(_, next) {
-                return freeze(_,  next);
+                freeze(_,  next);
             },
 
             // ---- Shared between HA and no-HA -------------------------------
             function reprovisionPrimary(_, next) {
-                if (arg.HA && arg.primary_updated) {
-                    return next();
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(arg.shard.primary.zoneId) !== -1) {
+                    next();
+                    return;
                 }
                 progress('Reprovisioning "primary" manatee');
-                return s.reprovisionRemote({
+                s.reprovisionRemote({
                     server: arg.shard.primary.server_uuid,
                     img: arg.change.image,
                     zonename: arg.shard.primary.zoneId,
@@ -986,13 +1059,15 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForPrimaryInstance(_, next) {
-                if (arg.HA && arg.primary_updated) {
-                    return next();
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(arg.shard.primary.zoneId) !== -1) {
+                    next();
+                    return;
                 }
 
                 progress('Wait for manatee instance %s to come up',
                     arg.shard.primary.zoneId);
-                return s.waitForInstToBeUp({
+                s.waitForInstToBeUp({
                     change: {
                         server: arg.shard.primary.server_uuid,
                         type: 'update-instance',
@@ -1070,12 +1145,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, next_);
                     }
-                }, function (wfErr, wfRes) {
-                    if (wfErr) {
-                        return next(wfErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function disableWorkflowApis(_, next) {
@@ -1090,12 +1160,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, next_);
                     }
-                }, function (wfErr, wfRes) {
-                    if (wfErr) {
-                        return next(wfErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function disableMorays(_, next) {
@@ -1110,12 +1175,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, next_);
                     }
-                }, function (morErr, morRes) {
-                    if (morErr) {
-                        return next(morErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function enableMorays(_, next) {
@@ -1130,12 +1190,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, next_);
                     }
-                }, function (morErr, morRes) {
-                    if (morErr) {
-                        return next(morErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function wait4Morays(_, next) {
@@ -1160,10 +1215,12 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, function (err, stdout, stderr) {
                             if (err) {
-                                return next_(err);
+                                next_(err);
+                                return;
                             }
                             if (stdout.indexOf('maintenance') === -1) {
-                                return next_();
+                                next_();
+                                return;
                             }
                             s.disableRemoteSvc({
                                 server: vm.server_uuid,
@@ -1172,7 +1229,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                                 log: log
                             }, function (err2) {
                                 if (err2) {
-                                    return next_(err2);
+                                    next_(err2);
+                                    return;
                                 }
                                 s.enableRemoteSvc({
                                     server: vm.server_uuid,
@@ -1183,12 +1241,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             });
                         });
                     }
-                }, function (wfErr, wfRes) {
-                    if (wfErr) {
-                        return next(wfErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function enableWfApis(_, next) {
@@ -1203,12 +1256,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             log: log
                         }, next_);
                     }
-                }, function (wfErr, wfRes) {
-                    if (wfErr) {
-                        return next(wfErr);
-                    }
-                    return next();
-                });
+                }, next);
             },
 
             function resetSapiToFullMode(_, next) {
@@ -1244,8 +1292,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Waiting for manatee shard to reach full HA');
                 waitForManatee('async', 'enabled',
-                    arg.shard.async.server_uuid,
-                    arg.shard.async.zoneId, hasPgStatus, function (err) {
+                    arg.shard.sync.server_uuid,
+                    arg.shard.sync.zoneId, hasPgStatus, function (err) {
                         if (err) {
                             if (err === 'deposed') {
                                 var msg = 'manatee instance ' +
@@ -1270,8 +1318,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Unfreezing cluster state');
                 common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
+                    server: arg.shard.sync.server_uuid,
+                    vm: arg.shard.sync.zoneId,
                     cmd: 'unfreeze',
                     log: log
                 }, function (err, stdou, stder) {
@@ -1286,7 +1334,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 });
             }
 
-        ]), arg: arg}, nextSvc);
+        ])}, nextSvc);
     }
 
     vasync.forEachPipeline({
-- 
2.21.0

