From 9b8205c65dc55c3e4eaf3c554fe807373e583009 Mon Sep 17 00:00:00 2001
From: "Pedro P. Candel" <pedro@joyent.com>
Date: Thu, 24 May 2018 20:02:46 +0200
Subject: [PATCH] TOOLS-1345 sdcadm update manatee does not update more than
 one async

---
 lib/common.js                       |  27 +-
 lib/procedures/shared.js            | 240 ++++++++++-------
 lib/procedures/update-manatee-v2.js | 399 ++++++++++++++++------------
 3 files changed, 387 insertions(+), 279 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 675690a..d2528e2 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -893,19 +893,26 @@ function manateeAdmRemote(opts, cb) {
  * {
  *      primary: {
  *          pg_status: 'ok',
- *          repl_status: 'sync'
+ *          repl_status: 'sync',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      sync: {
  *          pg_status: 'ok',
- *          repl_status: 'async'
+ *          repl_status: 'async',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      async: [{
  *          pg_status: 'ok'
+ *          repl_status: 'async' | '-',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      }]
  * }
  *
  * Note that it's theoretically possible to have more than one async member,
- * but it isn't too common.
+ * but it isn't too common. On those cases, every async member but the last
+ * one will also have a 'repl_status' member with an expected value of 'async',
+ * otherwise, the 'repl_status' for the async member will be '-', which means
+ * no replication.
  */
 function manateeShardStatus(opts, cb) {
     assert.object(opts, 'opts');
@@ -914,10 +921,11 @@ function manateeShardStatus(opts, cb) {
     assert.object(opts.log, 'opts.log');
     assert.func(cb, 'cb');
 
-    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -H';
+    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -o peerabbr -H';
     manateeAdmRemote(opts, function (err, stdout, stderr) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
 
         // We are intentionally ignoring `stderr` here. We already have all
@@ -935,19 +943,22 @@ function manateeShardStatus(opts, cb) {
             if (m[0] === 'primary' || m[0] === 'sync') {
                 shardPgSt[m[0]] = {
                     pg_status: m[1],
-                    repl_status: m[2]
+                    repl_status: m[2],
+                    peer_abbr: m[3]
                 };
             } else {
                 if (!shardPgSt[m[0]]) {
                     shardPgSt[m[0]] = [];
                 }
                 shardPgSt[m[0]].push({
-                    pg_status: m[1] || '-'
+                    pg_status: m[1] || '-',
+                    repl_status: m[2] || '-',
+                    peer_abbr: m[3]
                 });
             }
         });
 
-        return cb(null, shardPgSt);
+        cb(null, shardPgSt);
     });
 }
 
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index 50c479b..182989e 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -1268,6 +1268,10 @@ function manateeSitterSvcStatus(opts, callback) {
  *      @param {Boolean} hasManatee21: when true, use `pg-status` instead
  *          of the deprecated `status`, which was added for version 2.1.0
  *          of manatee-adm
+ *      @param {String} peer: UUID of the manatee peer we are waiting for
+ *          (useful when we have more than one async member). If this value is
+ *          not given, we assume that the value given for `state` is required
+ *          for *all* the peers with the provided `role`.
  * @param {Function} callback: of the form f(err).
  */
 function waitForManatee(opts, callback) {
@@ -1277,6 +1281,7 @@ function waitForManatee(opts, callback) {
     assert.string(opts.manateeUUID, 'opts.manateeUUID');
     assert.string(opts.role, 'opts.role');
     assert.string(opts.state, 'opts.state');
+    assert.optionalString(opts.peer, 'opts.peer');
     assert.optionalString(opts.leaderIP, 'opts.leaderIP');
     assert.optionalBool(opts.hasManatee21, 'opts.hasManatee21');
     assert.optionalBool(opts.oneNodeWriteMode, 'opts.oneNodeWriteMode');
@@ -1284,6 +1289,10 @@ function waitForManatee(opts, callback) {
 
     opts.hasManatee21 = opts.hasManatee21 || false;
 
+    if (opts.peer && common.UUID_RE.test(opts.peer)) {
+        opts.peer = opts.peer.substring(0, opts.peer.indexOf('-'));
+    }
+
     var func = (opts.hasManatee21) ? common.manateeShardStatus : getShardStatus;
 
     // Translate from deprecated shard status to simplified object format.
@@ -1300,18 +1309,29 @@ function waitForManatee(opts, callback) {
                     pg_status: member.online ? 'ok' : '-',
                     repl_status: (member.repl &&
                         member.repl.sync_state) ?
-                            member.repl.sync_state : '-'
+                            member.repl.sync_state : '-',
+                    peer_abbr: member.zoneId.substring(0,
+                            member.zoneId.indexOf('-'))
                 };
             } else if (!member.error) {
-                if (!shardPgSt[m]) {
-                    shardPgSt[m] = [];
+                if (!shardPgSt.async) {
+                    shardPgSt.async = [];
                 }
+                var peerSt = {};
 
                 if (typeof (member.online) !== 'undefined') {
-                    shardPgSt[m].push({
-                        pg_status: member.online ? 'ok' : '-'
-                    });
+                    peerSt.pg_status =  member.online ? 'ok' : '-';
+                }
+
+                if (member.repl && member.repl.sync_state) {
+                    peerSt.repl_status = member.repl.sync_state;
+                }
+
+                if (member.zoneId) {
+                    peerSt.peer_abbr = member.zoneId.substring(0,
+                            member.zoneId.indexOf('-'));
                 }
+                shardPgSt.async.push(peerSt);
             }
         });
         opts.log.trace({
@@ -1371,24 +1391,53 @@ function waitForManatee(opts, callback) {
                 break;
             case 'async':
                 if (opts.state === 'disabled') {
-                    if (!obj.async || !obj.async.length ||
-                            obj.async[0].pg_status !== 'ok') {
+                    if (!obj.async || !obj.async.length) {
+                        done = true;
+                    } else if (opts.peer) {
+                        // If we have a specific peer, we can check if it is
+                        // disabled.
+                        var peerArr = obj.async.filter(function (p) {
+                            return (p.peer_abbr === opts.peer);
+                        });
+
+                        if (peerArr.length && peerArr[0].pg_status !== 'ok') {
+                            done = true;
+                        }
+                    // Otherwise, we'll assume that we want every async peer
+                    // disabled.
+                    } else if (obj.async.every(function (peer) {
+                            return (peer.pg_status !== 'ok');
+                        })) {
                         done = true;
                     }
+
                 } else {
-                    if (!obj.async || !obj.async.length) {
+                    // If we don't have an async member yet, or some of the
+                    // async members have a pg_status not OK, we'll need to
+                    // wait for them.
+                    // Also, we want to wait for the async members to catch
+                    // up on replication, either straight from the sync, or
+                    // from the successive async members
+                    if (!obj.async ||
+                        obj.async.some(function (peer) {
+                        return (peer.pg_status !== 'ok');
+                    }) || (obj.sync && obj.sync.repl_status !== 'async')) {
                         done = false;
                     } else {
-                        if (obj.async[0].pg_status === 'ok' && obj.sync &&
-                                obj.sync.repl_status === 'async') {
-                            done = true;
-                        }
+                        // The latest shard member will never have a
+                        // replication status but if we have more than one
+                        // async member, all of them but the latest one should
+                        // have a replication status of 'async', if not just
+                        // reset the previous completion flag:
+                        done = obj.async.some(function (peer) {
+                            return (peer.repl_status !== 'async');
+                        });
                     }
                 }
                 break;
             default:
                 callback(new errors.UsageError(
-                            'Unknown manatee role ' + opts.role));
+                    'Unknown manatee role ' + opts.role));
                 return;
             }
 
@@ -1505,57 +1554,7 @@ function disableManateeSitter(opts, cb) {
     // Do we have a standalone manatee or is part of a shard?:
     var oneNodeWriteMode = false;
 
-    vasync.pipeline({funcs: [
-        function getState(_, next) {
-            getShardState({
-                log: opts.log,
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                hasManatee21: hasManatee21,
-                leaderIP: leaderIP
-            }, function (err, state) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                oneNodeWriteMode = state.oneNodeWriteMode;
-                next();
-            });
-        },
-        function disableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Disabling async manatee');
-            disableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
-
-        function waitAsyncDisabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Waiting for async manatee to be disabled');
-            var _opts = {
-                state: 'disabled',
-                role: 'async',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
-        },
-
+    var funcs = [
         function disableSyncManatee(_, next) {
             if (!shard.sync) {
                 next();
@@ -1616,7 +1615,44 @@ function disableManateeSitter(opts, cb) {
             }
             waitForManatee(_opts, next);
         }
-    ]}, cb);
+    ];
+
+    if (shard.async) {
+        shard.async.forEach(function (peer) {
+            funcs.unshift(
+                function disableAsyncManatee(_, next) {
+                    progress('Disabling async manatee peer %s',
+                        peer.zoneId);
+                    disableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
+
+                function waitAsyncDisabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be disabled',
+                        peer.zoneId);
+                    var _opts = {
+                        state: 'disabled',
+                        role: 'async',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
+
+    vasync.pipeline({funcs: funcs}, cb);
 
 }
 
@@ -1633,7 +1669,7 @@ function enableManateeSitter(opts, cb) {
     var leaderIP = opts.leaderIP || null;
     var hasManatee21 = opts.hasManatee21 || false;
 
-    vasync.pipeline({funcs: [
+    var funcs = [
         function enablePrimaryManatee(_, next) {
             progress('Enabling primary manatee');
             enableRemoteSvc({
@@ -1694,43 +1730,43 @@ function enableManateeSitter(opts, cb) {
                 _opts.leaderIP = leaderIP;
             }
             waitForManatee(_opts, next);
-        },
-
-        function enableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Enabling async manatee');
-            enableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
-
-        function waitAsyncEnabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Waiting for async manatee to be enabled');
-            var _opts = {
-                role: 'async',
-                state: 'enabled',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
         }
+    ];
 
-    ]}, cb);
+    if (shard.async) {
+        shard.async.forEach(function (peer) {
+            funcs.push(
+                function enableAsyncManatee(_, next) {
+                    progress('Enabling async manatee peer %s', peer.zoneId);
+                    enableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
+
+                function waitAsyncEnabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be enabled',
+                        peer.zoneId);
+                    var _opts = {
+                        role: 'async',
+                        state: 'enabled',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
+    vasync.pipeline({funcs: funcs}, cb);
 }
 
 /**
diff --git a/lib/procedures/update-manatee-v2.js b/lib/procedures/update-manatee-v2.js
index 84cd803..6d41e53 100644
--- a/lib/procedures/update-manatee-v2.js
+++ b/lib/procedures/update-manatee-v2.js
@@ -200,9 +200,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
             // In case of failure, prevent update procedure to re-run updates
             // of instances already updated on the previous attempt:
-            async_updated: false,
-            sync_updated: false,
-            primary_updated: false
+            updated_vms: []
         };
         var manateeUUID;
         var sapiUUID;
@@ -220,6 +218,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
         // manatee-adm status:
         var hasPgStatus = false;
 
+        // The different shard members, handy:
+        var primary, sync, asyncs;
 
         if (change.insts && change.insts.length > 1) {
             arg.HA = true;
@@ -357,8 +357,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             }
             progress('Freezing cluster state');
             common.manateeFreeze({
-                server: arg.shard.async.server_uuid,
-                vm: arg.shard.async.zoneId,
+                server: arg.shard.primary.server_uuid,
+                vm: arg.shard.primary.zoneId,
                 reason: 'sdcadm ' + opts.wrkDir,
                 log: log
             }, function (err) {
@@ -410,8 +410,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             });
         }
 
-        vasync.pipeline({funcs: funcs.concat([
-
+        vasync.pipeline({arg: arg, funcs: funcs.concat([
             /*
              * We cannot generally proceed successfully through this
              * update process if Ur is not available at all, so ensure
@@ -487,7 +486,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             'update again.';
                         progress(msg);
                         next(new errors.UpdateError(new Error(msg),
-                                    'manatee-adm'));
+                            'manatee-adm'));
                         return;
                     }
                     // Refuse to update HA setup w/o all the shard members.
@@ -499,13 +498,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             'attempting the update again.';
                         progress(msg2);
                         next(new errors.UpdateError(new Error(msg2),
-                                    'sdcadm'));
+                            'sdcadm'));
                         return;
-
-                    }
-                    // For now can handle only a single 'async' manatee
-                    if (arg.shard.async && arg.shard.async.length) {
-                        arg.shard.async = arg.shard.async[0];
                     }
                     next();
                 });
@@ -518,6 +512,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     arg.shard.primary.server_hostname = change.inst.hostname;
                     arg.shard.primary.alias = change.inst.alias;
                     arg.shard.primary.image = change.inst.image;
+                    primary = arg.shard.primary;
                     next();
                     return;
                 }
@@ -526,15 +521,33 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 vasync.forEachParallel({
                     inputs: Object.keys(arg.shard),
                     func: function getManateeServer(role, callback) {
-                        var inst = change.insts.filter(function (x) {
-                            return (x.zonename === arg.shard[role].zoneId);
-                        })[0];
-                        arg.shard[role].server_uuid = inst.server;
-                        arg.shard[role].server_hostname = inst.hostname;
-                        arg.shard[role].alias = inst.alias;
-                        arg.shard[role].image = inst.image;
-                        arg.shard[role].role = role;
-                        callback();
+                        var inst;
+                        var sRole = arg.shard[role];
+                        if (Array.isArray(sRole)) {
+                            sRole.forEach(function populate(member) {
+                                inst = change.insts.filter(function findId(x) {
+                                    return (x.zonename ===
+                                            member.zoneId);
+                                })[0];
+                                member.server_uuid = inst.server;
+                                member.server_hostname =
+                                    inst.hostname;
+                                member.alias = inst.alias;
+                                member.image = inst.image;
+                                member.role = role;
+                            });
+                            callback();
+                        } else {
+                            inst = change.insts.filter(function (x) {
+                                return (x.zonename === sRole.zoneId);
+                            })[0];
+                            sRole.server_uuid = inst.server;
+                            sRole.server_hostname = inst.hostname;
+                            sRole.alias = inst.alias;
+                            sRole.image = inst.image;
+                            sRole.role = role;
+                            callback();
+                        }
                     }
                 }, next);
             },
@@ -545,11 +558,16 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     return;
                 }
                 var nodes = [arg.shard.primary.server_uuid];
+                primary = arg.shard.primary;
                 if (arg.shard.sync) {
+                    sync = arg.shard.sync;
                     nodes.push(arg.shard.sync.server_uuid);
                 }
                 if (arg.shard.async) {
-                    nodes.push(arg.shard.async.server_uuid);
+                    asyncs = arg.shard.async;
+                    arg.shard.async.forEach(function (peer) {
+                        nodes.push(peer.server_uuid);
+                    });
                 }
                 nodes = nodes.sort().filter(function (item, pos, ary) {
                     return (!pos || item !== ary[pos - 1]);
@@ -605,12 +623,10 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     next();
                     return;
                 }
+                var inputs = [primary, sync].concat(asyncs).filter(
+                    function exists(x) { return x; });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function (vm, next_) {
                         sdcadm.imgapi.getImage(vm.image, function (err, img_) {
                             if (err) {
@@ -618,7 +634,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                                 return;
                             }
                             if (img_.uuid === arg.change.image.uuid) {
-                                arg[vm.role + '_updated'] = true;
+                                arg.updated_vms.push(vm.zoneId);
                             }
                             next_();
                         });
@@ -630,17 +646,18 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 if (!arg.HA) {
                     s.imgadmInstall(arg, next);
                 } else {
-                    if (arg.primary_updated) {
+                    if (arg.updated_vms.indexOf(
+                            primary.zoneId) !== -1) {
                         next();
                         return;
                     }
                     progress('Installing image %s\n    (%s@%s) on server %s',
                         arg.change.image.uuid, arg.change.image.name,
                         arg.change.image.version,
-                        arg.shard.primary.server_uuid);
+                        primary.server_uuid);
 
                     s.imgadmInstallRemote({
-                        server: arg.shard.primary.server_uuid,
+                        server: primary.server_uuid,
                         img: arg.change.image,
                         progress: progress,
                         log: log
@@ -648,69 +665,81 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
             },
 
-            function installImageAsyncServer(_, next) {
-                if (!arg.HA || arg.async_updated ||
-                    (arg.shard.async.server_uuid ===
-                        arg.shard.primary.server_uuid)) {
+            function installImageSyncServer(_, next) {
+                if (!arg.HA) {
+                    next();
+                    return;
+                }
+
+                if (sync.server_uuid === primary.server_uuid) {
+                    next();
+                    return;
+                }
+
+                if (arg.updated_vms.indexOf(sync.zoneId) !== -1) {
                     next();
                     return;
                 }
 
                 progress('Installing image %s\n    (%s@%s) on server %s',
                     arg.change.image.uuid, arg.change.image.name,
-                    arg.change.image.version, arg.shard.async.server_uuid);
+                    arg.change.image.version, sync.server_uuid);
 
                 s.imgadmInstallRemote({
-                    server: arg.shard.async.server_uuid,
+                    server: sync.server_uuid,
                     img: arg.change.image,
                     progress: progress,
                     log: log
                 }, next);
             },
 
-            function installImageSyncServer(_, next) {
+            function installImageAsyncServers(_, next) {
                 if (!arg.HA) {
                     next();
                     return;
                 }
 
-                if ((arg.shard.sync.server_uuid ===
-                        arg.shard.primary.server_uuid) ||
-                        (arg.shard.sync.server_uuid ===
-                         arg.shard.async.server_uuid)) {
-                    next();
-                    return;
-                }
+                vasync.forEachPipeline({
+                    inputs: asyncs,
+                    func: function installAsyncImg(peer, next_) {
+                        if (peer.server_uuid === primary.server_uuid ||
+                            peer.server_uuid === sync.server_uuid) {
+                            next_();
+                            return;
+                        }
 
-                if (arg.sync_updated) {
-                    next();
-                    return;
-                }
+                        if (arg.updated_vms.indexOf(peer.zoneId) !== -1) {
+                            next_();
+                            return;
+                        }
 
-                progress('Installing image %s\n    (%s@%s) on server %s',
-                    arg.change.image.uuid, arg.change.image.name,
-                    arg.change.image.version, arg.shard.sync.server_uuid);
+                        progress('Installing image %s\n    ' +
+                            '(%s@%s) on server %s',
+                            arg.change.image.uuid, arg.change.image.name,
+                            arg.change.image.version, peer.server_uuid);
 
-                s.imgadmInstallRemote({
-                    server: arg.shard.sync.server_uuid,
-                    img: arg.change.image,
-                    progress: progress,
-                    log: log
+                        s.imgadmInstallRemote({
+                            server: peer.server_uuid,
+                            img: arg.change.image,
+                            progress: progress,
+                            log: log
+                        }, next_);
+                    }
                 }, next);
             },
 
+
+
             // TOOLS-1223: ensure automatic fix for MANATEE-292
             function setCanmount(_, next) {
                 if (!arg.HA) {
                     next();
                     return;
                 }
+                var inputs = [primary, sync].concat(asyncs).filter(
+                    function exists(x) { return x; });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function _setCanmount(vm, next_) {
                         getCanmount(vm.server_uuid, vm.zoneId,
                                 function (cmErr, canmount) {
@@ -815,8 +844,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             function getManateeAdmVersion(_, next) {
                 progress('Checking manatee-adm version');
                 common.manateeAdmRemote({
-                    server: arg.shard.primary.server_uuid,
-                    vm: arg.shard.primary.zoneId,
+                    server: primary.server_uuid,
+                    vm: primary.zoneId,
                     cmd: 'version',
                     log: log
                 }, function (err, stdou, stder) {
@@ -842,7 +871,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
 
                 progress('Verifying full HA setup');
-                if (!arg.shard.sync || !arg.shard.async) {
+                if (!sync || !asyncs) {
                     progress(
                         'Incomplete HA setup. Please finish manatee setup' +
                         'and make sure primary, sync and async peers are ' +
@@ -857,93 +886,121 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 freeze(_,  next);
             },
 
-            function reprovisionAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Reprovisioning "async" manatee');
-                s.reprovisionRemote({
-                    server: arg.shard.async.server_uuid,
-                    img: arg.change.image,
-                    zonename: arg.shard.async.zoneId,
-                    progress: progress,
-                    log: log,
-                    sdcadm: opts.sdcadm
-                }, next);
-            },
+            function reprovisionAsyncPeers(_, next) {
+                var backfillDone = false;
+                function reprovisionAsyncPeer(peer, nextPeer) {
+                    vasync.pipeline({
+                        arg: peer,
+                        funcs: [
+                            function reprovisionAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function waitForAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Wait for manatee instance %s to come up',
-                    arg.shard.async.zoneId);
-                s.waitForInstToBeUp({
-                    change: {
-                        server: arg.shard.async.server_uuid,
-                        type: 'update-instance',
-                        service: 'manatee',
-                        image: arg.change.image,
-                        inst: {
-                            instance: arg.shard.async.zoneId,
-                            zonename: arg.shard.async.zoneId,
-                            uuid: arg.shard.async.zoneId,
-                            server: arg.shard.async.server_uuid,
-                            service: 'manatee',
-                            image: arg.change.image.uuid,
-                            version: arg.change.image.version,
-                            type: 'vm'
-                        }
-                    },
-                    opts: {
-                        progress: progress,
-                        sdcadm: sdcadm,
-                        log: log
-                    }
-                }, next);
-            },
+                                progress('Reprovisioning "async" manatee (%s)',
+                                    p.alias);
+                                s.reprovisionRemote({
+                                    server: p.server_uuid,
+                                    img: arg.change.image,
+                                    zonename: p.zoneId,
+                                    progress: progress,
+                                    log: log,
+                                    sdcadm: opts.sdcadm
+                                }, nextStep);
+                            },
+
+                            function waitForAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Wait for manatee instance %s (%s) ' +
+                                    'to come up', p.zoneId, p.alias);
+                                s.waitForInstToBeUp({
+                                    change: {
+                                        server: p.server_uuid,
+                                        type: 'update-instance',
+                                        service: 'manatee',
+                                        image: arg.change.image,
+                                        inst: {
+                                            instance: p.zoneId,
+                                            zonename: p.zoneId,
+                                            uuid: p.zoneId,
+                                            server: p.server_uuid,
+                                            service: 'manatee',
+                                            image: arg.change.image.uuid,
+                                            version: arg.change.image.version,
+                                            type: 'vm'
+                                        }
+                                    },
+                                    opts: {
+                                        progress: progress,
+                                        sdcadm: sdcadm,
+                                        log: log
+                                    }
+                                }, nextStep);
+                            },
+
+                            function asyncStateBackfill(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA || version !== '1.0.0' ||
+                                    backfillDone) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function asyncStateBackfill(_, next) {
-                if (!arg.HA || version !== '1.0.0' || arg.async_updated) {
-                    next();
-                    return;
+                                progress('Backfilling cluster state');
+                                common.manateeAdmRemote({
+                                    server: p.server_uuid,
+                                    vm: p.zoneId,
+                                    cmd: 'state-backfill -y',
+                                    log: log
+                                }, function (err) {
+                                    backfillDone = true;
+                                    nextStep(err);
+                                });
+                            },
+
+                            function waitForHA(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Waiting for manatee "async" to be ' +
+                                    'online (%s)', p.alias);
+                                waitForManatee('async', 'enabled',
+                                    primary.server_uuid,
+                                    primary.zoneId, hasPgStatus,
+                                    nextStep);
+                            }
+                        ]
+                    }, nextPeer);
                 }
-                progress('Backfilling cluster state');
-                common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
-                    cmd: 'state-backfill -y',
-                    log: log
+                vasync.forEachPipeline({
+                    inputs: asyncs,
+                    func: reprovisionAsyncPeer
                 }, next);
             },
 
-            function waitForHA(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Waiting for manatee async to be online');
-                waitForManatee('async', 'enabled',
-                        arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
-            },
-
             function freezeBeforeSync(_, next) {
                 freeze(_,  next);
             },
 
             function reprovisionSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(sync.zoneId) !== -1) {
                     next();
                     return;
                 }
                 progress('Reprovisioning "sync" manatee');
                 s.reprovisionRemote({
-                    server: arg.shard.sync.server_uuid,
+                    server: sync.server_uuid,
                     img: arg.change.image,
-                    zonename: arg.shard.sync.zoneId,
+                    zonename: sync.zoneId,
                     progress: progress,
                     log: log,
                     sdcadm: opts.sdcadm
@@ -951,23 +1008,24 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(sync.zoneId) !== -1) {
                     next();
                     return;
                 }
                 progress('Wait for manatee instance %s to come up',
-                    arg.shard.sync.zoneId);
+                    sync.zoneId);
                 s.waitForInstToBeUp({
                     change: {
-                        server: arg.shard.sync.server_uuid,
+                        server: sync.server_uuid,
                         type: 'update-instance',
                         service: 'manatee',
                         image: arg.change.image,
                         inst: {
-                            instance: arg.shard.sync.zoneId,
-                            zonename: arg.shard.sync.zoneId,
-                            uuid: arg.shard.sync.zoneId,
-                            server: arg.shard.sync.server_uuid,
+                            instance: sync.zoneId,
+                            zonename: sync.zoneId,
+                            uuid: sync.zoneId,
+                            server: sync.server_uuid,
                             service: 'manatee',
                             image: arg.change.image.uuid,
                             version: arg.change.image.version,
@@ -983,13 +1041,14 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForHASync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(sync.zoneId) !== -1) {
                     next();
                     return;
                 }
                 progress('Waiting for manatee sync to be online');
-                waitForManatee('sync', 'enabled', arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
+                waitForManatee('sync', 'enabled', primary.server_uuid,
+                    primary.zoneId, hasPgStatus, next);
             },
 
             function freezeBeforePrimary(_, next) {
@@ -998,15 +1057,16 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
 
             // ---- Shared between HA and no-HA -------------------------------
             function reprovisionPrimary(_, next) {
-                if (arg.HA && arg.primary_updated) {
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(primary.zoneId) !== -1) {
                     next();
                     return;
                 }
                 progress('Reprovisioning "primary" manatee');
                 s.reprovisionRemote({
-                    server: arg.shard.primary.server_uuid,
+                    server: primary.server_uuid,
                     img: arg.change.image,
-                    zonename: arg.shard.primary.zoneId,
+                    zonename: primary.zoneId,
                     progress: progress,
                     log: log,
                     sdcadm: opts.sdcadm
@@ -1014,7 +1074,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForPrimaryInstance(_, next) {
-                if (arg.HA && arg.primary_updated) {
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(primary.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -1023,15 +1084,15 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     arg.shard.primary.zoneId);
                 s.waitForInstToBeUp({
                     change: {
-                        server: arg.shard.primary.server_uuid,
+                        server: primary.server_uuid,
                         type: 'update-instance',
                         service: 'manatee',
                         image: arg.change.image,
                         inst: {
-                            instance: arg.shard.primary.zoneId,
-                            zonename: arg.shard.primary.zoneId,
-                            uuid: arg.shard.primary.zoneId,
-                            server: arg.shard.primary.server_uuid,
+                            instance: primary.zoneId,
+                            zonename: primary.zoneId,
+                            uuid: primary.zoneId,
+                            server: primary.server_uuid,
                             service: 'manatee',
                             image: arg.change.image.uuid,
                             version: arg.change.image.version,
@@ -1054,8 +1115,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Backfilling cluster state');
                 common.manateeAdmRemote({
-                    server: arg.shard.primary.server_uuid,
-                    vm: arg.shard.primary.zoneId,
+                    server: primary.server_uuid,
+                    vm: primary.zoneId,
                     cmd: 'state-backfill -y',
                     log: log
                 }, next);
@@ -1068,8 +1129,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Wait for primary PostgreSQL');
                 common.waitForPostgresUp({
-                    server: arg.shard.primary.server_uuid,
-                    vm: arg.shard.primary.zoneId,
+                    server: primary.server_uuid,
+                    vm: primary.zoneId,
                     log: log
                 }, next);
             },
@@ -1083,8 +1144,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Ensure ONE NODE WRITE MODE');
                 common.manateeAdmRemote({
-                    server: arg.shard.primary.server_uuid,
-                    vm: arg.shard.primary.zoneId,
+                    server: primary.server_uuid,
+                    vm: primary.zoneId,
                     cmd: 'set-onwm -m on -y',
                     log: log
                 }, next);
@@ -1254,13 +1315,13 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Waiting for manatee shard to reach full HA');
                 waitForManatee('async', 'enabled',
-                    arg.shard.async.server_uuid,
-                    arg.shard.async.zoneId, hasPgStatus, function (err) {
+                    sync.server_uuid,
+                    sync.zoneId, hasPgStatus, function (err) {
                         if (err) {
                             if (err === 'deposed') {
                                 var msg = 'manatee instance ' +
-                                    arg.shard.primary.zoneId + ' on server ' +
-                                    arg.shard.primary.server_uuid + ' is on ' +
+                                    primary.zoneId + ' on server ' +
+                                    primary.server_uuid + ' is on ' +
                                     'deposed state. Please log into this ' +
                                     'VM an run:\n\t `manatee-adm rebuild`.';
                                 progress(msg);
@@ -1282,8 +1343,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Unfreezing cluster state');
                 common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
+                    server: sync.server_uuid,
+                    vm: sync.zoneId,
                     cmd: 'unfreeze',
                     log: log
                 }, function (err, stdout, stderr) {
@@ -1300,7 +1361,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 });
             }
 
-        ]), arg: arg}, nextSvc);
+        ])}, nextSvc);
     }
 
     vasync.forEachPipeline({
-- 
2.21.0

