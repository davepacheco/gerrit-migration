From e33c26c9f153c3aeaa225e85dd3bdb7e5d062548 Mon Sep 17 00:00:00 2001
From: "Pedro P. Candel" <pedro@joyent.com>
Date: Thu, 24 May 2018 18:38:43 +0200
Subject: [PATCH] TOOLS-1345 sdcadm update manatee does not update more than
 one async

---
 lib/common.js                       |  25 ++-
 lib/procedures/shared.js            | 251 ++++++++++++---------
 lib/procedures/update-manatee-v2.js | 336 ++++++++++++++++------------
 3 files changed, 359 insertions(+), 253 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 675690a..ef80291 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -893,19 +893,24 @@ function manateeAdmRemote(opts, cb) {
  * {
  *      primary: {
  *          pg_status: 'ok',
- *          repl_status: 'sync'
+ *          repl_status: 'sync',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      sync: {
  *          pg_status: 'ok',
- *          repl_status: 'async'
+ *          repl_status: 'async',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      },
  *      async: [{
  *          pg_status: 'ok'
+ *          repl_status: 'async' | '-',
+ *          peer_abbr: UUID_FIRST_8_CHARS
  *      }]
  * }
  *
  * Note that it's theoretically possible to have more than one async member,
- * but it isn't too common.
+ * but it isn't too common. On those cases, every async member but the last
+ * one will also have a 'repl_status' member with an expected value of 'async'.
  */
 function manateeShardStatus(opts, cb) {
     assert.object(opts, 'opts');
@@ -914,10 +919,11 @@ function manateeShardStatus(opts, cb) {
     assert.object(opts.log, 'opts.log');
     assert.func(cb, 'cb');
 
-    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -H';
+    opts.cmd = 'pg-status -o role -o pg-online -o pg-repl -o peerabbr -H';
     manateeAdmRemote(opts, function (err, stdout, stderr) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
 
         // We are intentionally ignoring `stderr` here. We already have all
@@ -935,19 +941,22 @@ function manateeShardStatus(opts, cb) {
             if (m[0] === 'primary' || m[0] === 'sync') {
                 shardPgSt[m[0]] = {
                     pg_status: m[1],
-                    repl_status: m[2]
+                    repl_status: m[2],
+                    peer_abbr: m[3]
                 };
             } else {
                 if (!shardPgSt[m[0]]) {
                     shardPgSt[m[0]] = [];
                 }
                 shardPgSt[m[0]].push({
-                    pg_status: m[1] || '-'
+                    pg_status: m[1] || '-',
+                    repl_status: m[2] || '-',
+                    peer_abbr: m[3]
                 });
             }
         });
 
-        return cb(null, shardPgSt);
+        cb(null, shardPgSt);
     });
 }
 
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index 50c479b..c52fc4d 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -1268,6 +1268,10 @@ function manateeSitterSvcStatus(opts, callback) {
  *      @param {Boolean} hasManatee21: when true, use `pg-status` instead
  *          of the deprecated `status`, which was added for version 2.1.0
  *          of manatee-adm
+ *      @param {String} peer: UUID of the manatee peer we are waiting for
+ *          (useful when we have more than one async member). If this value is
+ *          not given, we assume that the value given for `state` is required
+ *          for *all* the peers with the provided `role`.
  * @param {Function} callback: of the form f(err).
  */
 function waitForManatee(opts, callback) {
@@ -1277,6 +1281,7 @@ function waitForManatee(opts, callback) {
     assert.string(opts.manateeUUID, 'opts.manateeUUID');
     assert.string(opts.role, 'opts.role');
     assert.string(opts.state, 'opts.state');
+    assert.optionalString(opts.peer, 'opts.peer');
     assert.optionalString(opts.leaderIP, 'opts.leaderIP');
     assert.optionalBool(opts.hasManatee21, 'opts.hasManatee21');
     assert.optionalBool(opts.oneNodeWriteMode, 'opts.oneNodeWriteMode');
@@ -1284,6 +1289,10 @@ function waitForManatee(opts, callback) {
 
     opts.hasManatee21 = opts.hasManatee21 || false;
 
+    if (opts.peer && common.UUID_RE.test(opts.peer)) {
+        opts.peer = opts.peer.substring(0, opts.peer.indexOf('-'));
+    }
+
     var func = (opts.hasManatee21) ? common.manateeShardStatus : getShardStatus;
 
     // Translate from deprecated shard status to simplified object format.
@@ -1297,21 +1306,32 @@ function waitForManatee(opts, callback) {
             var member = obj.sdc[m];
             if ((m === 'primary' || m === 'sync') && !member.error) {
                 shardPgSt[m] = {
-                    pg_status: member.online ? 'ok' : '-',
-                    repl_status: (member.repl &&
-                        member.repl.sync_state) ?
-                            member.repl.sync_state : '-'
+                    pg_status: obj.sdc[m].online ? 'ok' : '-',
+                    repl_status: (obj.sdc[m].repl &&
+                        obj.sdc[m].repl.sync_state) ?
+                            obj.sdc[m].repl.sync_state : '-',
+                    peer_abbr: obj.sdc[m].zoneId.substring(0,
+                            obj.sdc[m].zoneId.indexOf('-'))
                 };
-            } else if (!member.error) {
-                if (!shardPgSt[m]) {
-                    shardPgSt[m] = [];
+            } else if (!obj.sdc[m].error) {
+                if (!shardPgSt.async) {
+                    shardPgSt.async = [];
                 }
+                var peerSt = {};
 
-                if (typeof (member.online) !== 'undefined') {
-                    shardPgSt[m].push({
-                        pg_status: member.online ? 'ok' : '-'
-                    });
+                if (typeof (obj.sdc[m].online) !== 'undefined') {
+                    peerSt.pg_status =  obj.sdc[m].online ? 'ok' : '-';
+                }
+
+                if (obj.sdc[m].repl && obj.sdc[m].repl.sync_state) {
+                    peerSt.repl_status = obj.sdc[m].repl.sync_state;
+                }
+
+                if (obj.sdc[m].zoneId) {
+                    peerSt.peer_abbr = obj.sdc[m].zoneId.substring(0,
+                            obj.sdc[m].zoneId.indexOf('-'));
                 }
+                shardPgSt.async.push(peerSt);
             }
         });
         opts.log.trace({
@@ -1371,24 +1391,54 @@ function waitForManatee(opts, callback) {
                 break;
             case 'async':
                 if (opts.state === 'disabled') {
-                    if (!obj.async || !obj.async.length ||
-                            obj.async[0].pg_status !== 'ok') {
+                    if (!obj.async || !obj.async.length) {
+                        done = true;
+                    } else if (opts.peer) {
+                        // If we have a specific peer, we can check if it is
+                        // disabled.
+                        var peerArr = obj.async.filter(function (p) {
+                            return (p.peer_abbr === opts.peer);
+                        });
+
+                        if (peerArr.length && peerArr[0].pg_status !== 'ok') {
+                            done = true;
+                        }
+                    // Otherwise, we'll assume that we want every async peer
+                    // disabled.
+                    } else if (obj.async.every(function (peer) {
+                            return (peer.pg_status !== 'ok');
+                        })) {
                         done = true;
                     }
+
                 } else {
-                    if (!obj.async || !obj.async.length) {
+                    // If we don't have an async member yet, or some of the
+                    // async members have a pg_status not OK, we'll need to
+                    // wait for them.
+                    // Also, we want to wait for the async members to catch
+                    // up on replication, either straight from the sync, or
+                    // from the sucessive async members
+                    if (!obj.async || !obj.async.length ||
+                        obj.async.some(function (peer) {
+                        return (peer.pg_status !== 'ok');
+                    }) || (obj.sync && obj.sync.repl_status !== 'async')) {
                         done = false;
                     } else {
-                        if (obj.async[0].pg_status === 'ok' && obj.sync &&
-                                obj.sync.repl_status === 'async') {
-                            done = true;
-                        }
+                        // The latest shard member will never have a
+                        // replication status but if we have more than one
+                        // async member, all of them but the latest one should
+                        // have a replication status of 'async', if not just
+                        // reset the previous completion flag:
+                        done = obj.async.some(function (peer) {
+                            return (peer.repl_status &&
+                                    peer.repl_status !== 'async');
+                        });
                     }
                 }
                 break;
             default:
                 callback(new errors.UsageError(
-                            'Unknown manatee role ' + opts.role));
+                    'Unknown manatee role ' + opts.role));
                 return;
             }
 
@@ -1505,57 +1555,7 @@ function disableManateeSitter(opts, cb) {
     // Do we have a standalone manatee or is part of a shard?:
     var oneNodeWriteMode = false;
 
-    vasync.pipeline({funcs: [
-        function getState(_, next) {
-            getShardState({
-                log: opts.log,
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                hasManatee21: hasManatee21,
-                leaderIP: leaderIP
-            }, function (err, state) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                oneNodeWriteMode = state.oneNodeWriteMode;
-                next();
-            });
-        },
-        function disableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Disabling async manatee');
-            disableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
-
-        function waitAsyncDisabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Waiting for async manatee to be disabled');
-            var _opts = {
-                state: 'disabled',
-                role: 'async',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
-        },
-
+    var funcs = [
         function disableSyncManatee(_, next) {
             if (!shard.sync) {
                 next();
@@ -1616,7 +1616,44 @@ function disableManateeSitter(opts, cb) {
             }
             waitForManatee(_opts, next);
         }
-    ]}, cb);
+    ];
+
+    if (shard.async && shard.async.length) {
+        shard.async.forEach(function (peer) {
+            funcs.unshift(
+                function disableAsyncManatee(_, next) {
+                    progress('Disabling async manatee peer %s',
+                        peer.zoneId);
+                    disableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
+
+                function waitAsyncDisabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be disabled',
+                        peer.zoneId);
+                    var _opts = {
+                        state: 'disabled',
+                        role: 'async',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
+
+    vasync.pipeline({funcs: funcs}, cb);
 
 }
 
@@ -1633,7 +1670,7 @@ function enableManateeSitter(opts, cb) {
     var leaderIP = opts.leaderIP || null;
     var hasManatee21 = opts.hasManatee21 || false;
 
-    vasync.pipeline({funcs: [
+    var funcs = [
         function enablePrimaryManatee(_, next) {
             progress('Enabling primary manatee');
             enableRemoteSvc({
@@ -1694,43 +1731,43 @@ function enableManateeSitter(opts, cb) {
                 _opts.leaderIP = leaderIP;
             }
             waitForManatee(_opts, next);
-        },
-
-        function enableAsyncManatee(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Enabling async manatee');
-            enableRemoteSvc({
-                server: shard.async[0].server,
-                zone: shard.async[0].zoneId,
-                fmri: 'manatee-sitter',
-                log: log
-            }, next);
-        },
-
-        function waitAsyncEnabled(_, next) {
-            if (!shard.async || !shard.async.length) {
-                next();
-                return;
-            }
-            progress('Waiting for async manatee to be enabled');
-            var _opts = {
-                role: 'async',
-                state: 'enabled',
-                server: shard.primary.server,
-                manateeUUID: shard.primary.zoneId,
-                log: log,
-                hasManatee21: hasManatee21
-            };
-            if (leaderIP) {
-                _opts.leaderIP = leaderIP;
-            }
-            waitForManatee(_opts, next);
         }
+    ];
 
-    ]}, cb);
+    if (shard.async && shard.async.length) {
+        shard.async.forEach(function (peer) {
+            funcs.push(
+                function enableAsyncManatee(_, next) {
+                    progress('Enabling async manatee peer %s', peer.zoneId);
+                    enableRemoteSvc({
+                        server: peer.server,
+                        zone: peer.zoneId,
+                        fmri: 'manatee-sitter',
+                        log: log
+                    }, next);
+                },
+
+                function waitAsyncEnabled(_, next) {
+                    progress('Waiting for async manatee peer %s to be enabled',
+                        peer.zoneId);
+                    var _opts = {
+                        role: 'async',
+                        state: 'enabled',
+                        server: shard.primary.server,
+                        manateeUUID: shard.primary.zoneId,
+                        log: log,
+                        hasManatee21: hasManatee21,
+                        peer: peer.zoneId
+                    };
+                    if (leaderIP) {
+                        _opts.leaderIP = leaderIP;
+                    }
+                    waitForManatee(_opts, next);
+                }
+            );
+        });
+    }
+    vasync.pipeline({funcs: funcs}, cb);
 }
 
 /**
diff --git a/lib/procedures/update-manatee-v2.js b/lib/procedures/update-manatee-v2.js
index 84cd803..f18c94e 100644
--- a/lib/procedures/update-manatee-v2.js
+++ b/lib/procedures/update-manatee-v2.js
@@ -200,9 +200,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
             // In case of failure, prevent update procedure to re-run updates
             // of instances already updated on the previous attempt:
-            async_updated: false,
-            sync_updated: false,
-            primary_updated: false
+            updated_vms: []
         };
         var manateeUUID;
         var sapiUUID;
@@ -357,8 +355,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             }
             progress('Freezing cluster state');
             common.manateeFreeze({
-                server: arg.shard.async.server_uuid,
-                vm: arg.shard.async.zoneId,
+                server: arg.shard.primary.server_uuid,
+                vm: arg.shard.primary.zoneId,
                 reason: 'sdcadm ' + opts.wrkDir,
                 log: log
             }, function (err) {
@@ -410,8 +408,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             });
         }
 
-        vasync.pipeline({funcs: funcs.concat([
-
+        vasync.pipeline({arg: arg, funcs: funcs.concat([
             /*
              * We cannot generally proceed successfully through this
              * update process if Ur is not available at all, so ensure
@@ -487,7 +484,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             'update again.';
                         progress(msg);
                         next(new errors.UpdateError(new Error(msg),
-                                    'manatee-adm'));
+                            'manatee-adm'));
                         return;
                     }
                     // Refuse to update HA setup w/o all the shard members.
@@ -499,13 +496,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                             'attempting the update again.';
                         progress(msg2);
                         next(new errors.UpdateError(new Error(msg2),
-                                    'sdcadm'));
+                            'sdcadm'));
                         return;
-
-                    }
-                    // For now can handle only a single 'async' manatee
-                    if (arg.shard.async && arg.shard.async.length) {
-                        arg.shard.async = arg.shard.async[0];
                     }
                     next();
                 });
@@ -526,15 +518,32 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 vasync.forEachParallel({
                     inputs: Object.keys(arg.shard),
                     func: function getManateeServer(role, callback) {
-                        var inst = change.insts.filter(function (x) {
-                            return (x.zonename === arg.shard[role].zoneId);
-                        })[0];
-                        arg.shard[role].server_uuid = inst.server;
-                        arg.shard[role].server_hostname = inst.hostname;
-                        arg.shard[role].alias = inst.alias;
-                        arg.shard[role].image = inst.image;
-                        arg.shard[role].role = role;
-                        callback();
+                        var inst;
+                        if (Array.isArray(arg.shard[role])) {
+                            arg.shard[role].forEach(function (i) {
+                                inst = change.insts.filter(function (x) {
+                                    return (x.zonename ===
+                                            arg.shard[role][i].zoneId);
+                                })[0];
+                                arg.shard[role][i].server_uuid = inst.server;
+                                arg.shard[role][i].server_hostname =
+                                    inst.hostname;
+                                arg.shard[role][i].alias = inst.alias;
+                                arg.shard[role][i].image = inst.image;
+                                arg.shard[role][i].role = role;
+                            });
+                            callback();
+                        } else {
+                            inst = change.insts.filter(function (x) {
+                                return (x.zonename === arg.shard[role].zoneId);
+                            })[0];
+                            arg.shard[role].server_uuid = inst.server;
+                            arg.shard[role].server_hostname = inst.hostname;
+                            arg.shard[role].alias = inst.alias;
+                            arg.shard[role].image = inst.image;
+                            arg.shard[role].role = role;
+                            callback();
+                        }
                     }
                 }, next);
             },
@@ -549,7 +558,9 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     nodes.push(arg.shard.sync.server_uuid);
                 }
                 if (arg.shard.async) {
-                    nodes.push(arg.shard.async.server_uuid);
+                    arg.shard.async.forEach(function (peer) {
+                        nodes.push(peer.server_uuid);
+                    });
                 }
                 nodes = nodes.sort().filter(function (item, pos, ary) {
                     return (!pos || item !== ary[pos - 1]);
@@ -605,12 +616,12 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                     next();
                     return;
                 }
+                var inputs = [arg.shard.primary, arg.shard.sync];
+                arg.shard.async.forEach(function (peer) {
+                    inputs.push(peer);
+                });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function (vm, next_) {
                         sdcadm.imgapi.getImage(vm.image, function (err, img_) {
                             if (err) {
@@ -618,7 +629,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                                 return;
                             }
                             if (img_.uuid === arg.change.image.uuid) {
-                                arg[vm.role + '_updated'] = true;
+                                arg.updated_vms.push(vm.zoneId);
                             }
                             next_();
                         });
@@ -630,7 +641,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 if (!arg.HA) {
                     s.imgadmInstall(arg, next);
                 } else {
-                    if (arg.primary_updated) {
+                    if (arg.updated_vms.indexOf(
+                            arg.shard.primary.zoneId) !== -1) {
                         next();
                         return;
                     }
@@ -648,26 +660,6 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
             },
 
-            function installImageAsyncServer(_, next) {
-                if (!arg.HA || arg.async_updated ||
-                    (arg.shard.async.server_uuid ===
-                        arg.shard.primary.server_uuid)) {
-                    next();
-                    return;
-                }
-
-                progress('Installing image %s\n    (%s@%s) on server %s',
-                    arg.change.image.uuid, arg.change.image.name,
-                    arg.change.image.version, arg.shard.async.server_uuid);
-
-                s.imgadmInstallRemote({
-                    server: arg.shard.async.server_uuid,
-                    img: arg.change.image,
-                    progress: progress,
-                    log: log
-                }, next);
-            },
-
             function installImageSyncServer(_, next) {
                 if (!arg.HA) {
                     next();
@@ -675,14 +667,12 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
 
                 if ((arg.shard.sync.server_uuid ===
-                        arg.shard.primary.server_uuid) ||
-                        (arg.shard.sync.server_uuid ===
-                         arg.shard.async.server_uuid)) {
+                        arg.shard.primary.server_uuid)) {
                     next();
                     return;
                 }
 
-                if (arg.sync_updated) {
+                if (arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -699,18 +689,56 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }, next);
             },
 
+            function installImageAsyncServers(_, next) {
+                if (!arg.HA) {
+                    next();
+                    return;
+                }
+
+                vasync.forEachPipeline({
+                    inputs: arg.shard.async,
+                    func: function installAsyncImg(peer, next_) {
+                        if ((peer.server_uuid ===
+                            arg.shard.primary.server_uuid) ||
+                            (peer.server_uuid === arg.shard.sync.server_uuid)) {
+                            next_();
+                            return;
+                        }
+
+                        if (arg.updated_vms.indexOf(peer.zoneId) !== -1) {
+                            next_();
+                            return;
+                        }
+
+                        progress('Installing image %s\n    ' +
+                            '(%s@%s) on server %s',
+                            arg.change.image.uuid, arg.change.image.name,
+                            arg.change.image.version, peer.server_uuid);
+
+                        s.imgadmInstallRemote({
+                            server: peer.server_uuid,
+                            img: arg.change.image,
+                            progress: progress,
+                            log: log
+                        }, next_);
+                    }
+                }, next);
+            },
+
+
+
             // TOOLS-1223: ensure automatic fix for MANATEE-292
             function setCanmount(_, next) {
                 if (!arg.HA) {
                     next();
                     return;
                 }
+                var inputs = [arg.shard.primary, arg.shard.sync];
+                arg.shard.async.forEach(function (peer) {
+                    inputs.push(peer);
+                });
                 vasync.forEachParallel({
-                    inputs: [
-                        arg.shard.primary,
-                        arg.shard.sync,
-                        arg.shard.async
-                    ],
+                    inputs: inputs,
                     func: function _setCanmount(vm, next_) {
                         getCanmount(vm.server_uuid, vm.zoneId,
                                 function (cmErr, canmount) {
@@ -857,85 +885,113 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 freeze(_,  next);
             },
 
-            function reprovisionAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Reprovisioning "async" manatee');
-                s.reprovisionRemote({
-                    server: arg.shard.async.server_uuid,
-                    img: arg.change.image,
-                    zonename: arg.shard.async.zoneId,
-                    progress: progress,
-                    log: log,
-                    sdcadm: opts.sdcadm
-                }, next);
-            },
+            function reprovisionAsyncPeers(_, next) {
+                var backfillDone = false;
+                function reprovisionAsyncPeer(peer, nextPeer) {
+                    vasync.pipeline({
+                        arg: peer,
+                        funcs: [
+                            function reprovisionAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function waitForAsync(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Wait for manatee instance %s to come up',
-                    arg.shard.async.zoneId);
-                s.waitForInstToBeUp({
-                    change: {
-                        server: arg.shard.async.server_uuid,
-                        type: 'update-instance',
-                        service: 'manatee',
-                        image: arg.change.image,
-                        inst: {
-                            instance: arg.shard.async.zoneId,
-                            zonename: arg.shard.async.zoneId,
-                            uuid: arg.shard.async.zoneId,
-                            server: arg.shard.async.server_uuid,
-                            service: 'manatee',
-                            image: arg.change.image.uuid,
-                            version: arg.change.image.version,
-                            type: 'vm'
-                        }
-                    },
-                    opts: {
-                        progress: progress,
-                        sdcadm: sdcadm,
-                        log: log
-                    }
-                }, next);
-            },
+                                progress('Reprovisioning "async" manatee (%s)',
+                                    p.alias);
+                                s.reprovisionRemote({
+                                    server: p.server_uuid,
+                                    img: arg.change.image,
+                                    zonename: p.zoneId,
+                                    progress: progress,
+                                    log: log,
+                                    sdcadm: opts.sdcadm
+                                }, nextStep);
+                            },
+
+                            function waitForAsync(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Wait for manatee instance %s (%s) ' +
+                                    'to come up', p.zoneId, p.alias);
+                                s.waitForInstToBeUp({
+                                    change: {
+                                        server: p.server_uuid,
+                                        type: 'update-instance',
+                                        service: 'manatee',
+                                        image: arg.change.image,
+                                        inst: {
+                                            instance: p.zoneId,
+                                            zonename: p.zoneId,
+                                            uuid: p.zoneId,
+                                            server: p.server_uuid,
+                                            service: 'manatee',
+                                            image: arg.change.image.uuid,
+                                            version: arg.change.image.version,
+                                            type: 'vm'
+                                        }
+                                    },
+                                    opts: {
+                                        progress: progress,
+                                        sdcadm: sdcadm,
+                                        log: log
+                                    }
+                                }, nextStep);
+                            },
+
+                            function asyncStateBackfill(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA || version !== '1.0.0' ||
+                                    backfillDone) {
+                                    nextStep();
+                                    return;
+                                }
 
-            function asyncStateBackfill(_, next) {
-                if (!arg.HA || version !== '1.0.0' || arg.async_updated) {
-                    next();
-                    return;
+                                progress('Backfilling cluster state');
+                                common.manateeAdmRemote({
+                                    server: p.server_uuid,
+                                    vm: p.zoneId,
+                                    cmd: 'state-backfill -y',
+                                    log: log
+                                }, function (err) {
+                                    backfillDone = true;
+                                    nextStep(err);
+                                });
+                            },
+
+                            function waitForHA(p, nextStep) {
+                                if (arg.updated_vms.indexOf(p.zoneId) !== -1 ||
+                                    !arg.HA) {
+                                    nextStep();
+                                    return;
+                                }
+                                progress('Waiting for manatee "async" to be ' +
+                                    'online (%s)', p.alias);
+                                waitForManatee('async', 'enabled',
+                                    arg.shard.primary.server_uuid,
+                                    arg.shard.primary.zoneId, hasPgStatus,
+                                    nextStep);
+                            }
+                        ]
+                    }, nextPeer);
                 }
-                progress('Backfilling cluster state');
-                common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
-                    cmd: 'state-backfill -y',
-                    log: log
+                vasync.forEachPipeline({
+                    inputs: arg.shard.async,
+                    func: reprovisionAsyncPeer
                 }, next);
             },
 
-            function waitForHA(_, next) {
-                if (!arg.HA || arg.async_updated) {
-                    next();
-                    return;
-                }
-                progress('Waiting for manatee async to be online');
-                waitForManatee('async', 'enabled',
-                        arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
-            },
-
             function freezeBeforeSync(_, next) {
                 freeze(_,  next);
             },
 
             function reprovisionSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -951,7 +1007,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForSync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -983,13 +1040,14 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForHASync(_, next) {
-                if (!arg.HA || arg.sync_updated) {
+                if (!arg.HA ||
+                    arg.updated_vms.indexOf(arg.shard.sync.zoneId) !== -1) {
                     next();
                     return;
                 }
                 progress('Waiting for manatee sync to be online');
                 waitForManatee('sync', 'enabled', arg.shard.primary.server_uuid,
-                        arg.shard.primary.zoneId, hasPgStatus, next);
+                    arg.shard.primary.zoneId, hasPgStatus, next);
             },
 
             function freezeBeforePrimary(_, next) {
@@ -998,7 +1056,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
 
             // ---- Shared between HA and no-HA -------------------------------
             function reprovisionPrimary(_, next) {
-                if (arg.HA && arg.primary_updated) {
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(arg.shard.primary.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -1014,7 +1073,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
             },
 
             function waitForPrimaryInstance(_, next) {
-                if (arg.HA && arg.primary_updated) {
+                if (arg.HA &&
+                    arg.updated_vms.indexOf(arg.shard.primary.zoneId) !== -1) {
                     next();
                     return;
                 }
@@ -1254,8 +1314,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Waiting for manatee shard to reach full HA');
                 waitForManatee('async', 'enabled',
-                    arg.shard.async.server_uuid,
-                    arg.shard.async.zoneId, hasPgStatus, function (err) {
+                    arg.shard.sync.server_uuid,
+                    arg.shard.sync.zoneId, hasPgStatus, function (err) {
                         if (err) {
                             if (err === 'deposed') {
                                 var msg = 'manatee instance ' +
@@ -1282,8 +1342,8 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 }
                 progress('Unfreezing cluster state');
                 common.manateeAdmRemote({
-                    server: arg.shard.async.server_uuid,
-                    vm: arg.shard.async.zoneId,
+                    server: arg.shard.sync.server_uuid,
+                    vm: arg.shard.sync.zoneId,
                     cmd: 'unfreeze',
                     log: log
                 }, function (err, stdout, stderr) {
@@ -1300,7 +1360,7 @@ UpdateManateeV2.prototype.execute = function manateev2Execute(opts, cb) {
                 });
             }
 
-        ]), arg: arg}, nextSvc);
+        ])}, nextSvc);
     }
 
     vasync.forEachPipeline({
-- 
2.21.0

