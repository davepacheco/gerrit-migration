From fcd0c90a5b4634a0d41726538ec6ce3ad98ca84a Mon Sep 17 00:00:00 2001
From: Tim Foster <tim.foster@joyent.com>
Date: Wed, 2 Oct 2019 12:08:30 +0100
Subject: [PATCH] OS-7943 Want platform build test artifact

---
 .gitignore                            |   2 +
 Makefile                              |  55 +++++-
 tools/generate-manifest-from-ips.nawk | 273 ++++++++++++++++++++++++++
 3 files changed, 328 insertions(+), 2 deletions(-)
 create mode 100755 tools/generate-manifest-from-ips.nawk

diff --git a/.gitignore b/.gitignore
index d1aedc4c..ed564488 100644
--- a/.gitignore
+++ b/.gitignore
@@ -18,6 +18,7 @@
 /proto.boot
 /proto.images
 /proto.strap
+/proto.tests
 /src/*.o
 /src/bootparams
 /src/disk_size
@@ -95,6 +96,7 @@ src/sysinfo_mod.so
 src/vm/node_modules/props.js
 src/zonememstat
 src/zonemon
+tests.manifest.gen
 tools/pwgen-2.06/Makefile
 tools/pwgen-2.06/autom4te.cache
 zonestat.1
diff --git a/Makefile b/Makefile
index ce6473fb..54655f47 100644
--- a/Makefile
+++ b/Makefile
@@ -31,6 +31,7 @@ MPROTO =	$(ROOT)/manifest.d
 BOOT_MPROTO =	$(ROOT)/boot.manifest.d
 BOOT_PROTO =	$(ROOT)/proto.boot
 IMAGES_PROTO =	$(ROOT)/proto.images
+TESTS_PROTO =	$(ROOT)/proto.tests
 MCPROTO =	$(ROOT)/mancheck.conf.d
 
 # On Darwin/OS X we support running 'make check'
@@ -108,6 +109,19 @@ BOOT_MANIFESTS := \
 
 SUBDIR_MANIFESTS :=	$(LOCAL_SUBDIRS:%=$(MPROTO)/%.sd.manifest)
 
+TEST_IPS_MANIFEST_ROOT = projects/illumos/usr/src/pkg/manifests
+
+#
+# To avoid cross-repository flag days, the list of IPS manifest
+# files which define the files included in the test archive is
+# stored in the illumos-joyent.git repository. By including the
+# following Makefile, we get the $(TEST_IPS_MANIFEST_FILES) macro.
+#
+include projects/illumos/usr/src/Makefile.testarchive
+
+TEST_IPS_MANIFESTS = $(TEST_IPS_MANIFEST_FILES:%=$(TEST_IPS_MANIFEST_ROOT)/%)
+TESTS_MANIFEST = $(ROOT)/tests.manifest.gen
+
 SUBDIR_MANCHECK_CONFS := \
 	$(LOCAL_SUBDIRS:%=$(MCPROTO)/%.sd.mancheck.conf)
 
@@ -119,6 +133,10 @@ IMAGES_VERSION :=	images-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
     echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
 IMAGES_TARBALL :=	output/$(IMAGES_VERSION).tgz
 
+TESTS_VERSION :=	tests-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
+    echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
+TESTS_TARBALL :=	output/$(TESTS_VERSION).tgz
+
 ifdef PLATFORM_PASSWORD
 PLATFORM_PASSWORD_OPT=-p $(PLATFORM_PASSWORD)
 endif
@@ -251,6 +269,33 @@ $(BOOT_MANIFEST): $(BOOT_MANIFESTS)
 	-rm -f $@
 	./tools/build_manifest $(BOOT_MPROTO) | ./tools/sorter > $@
 
+$(TESTS_MANIFEST): world
+	-rm -f $@
+	echo "f tests.manifest.gen 0444 root sys" >> $@
+	echo "f tests.buildstamp 0444 root sys" >> $@
+	cat $(TEST_IPS_MANIFESTS) | \
+	    ./tools/generate-manifest-from-ips.nawk | \
+	    ./tools/sorter >> $@
+
+
+#
+# We want a copy of the buildstamp in the tests archive, but
+# don't want to call it 'buildstamp' since that would potentially
+# overwrite the same file in the platform.tgz if they were
+# ever extracted to the same area for investigation. Juggle a bit.
+#
+$(TESTS_TARBALL): $(TESTS_MANIFEST)
+	pfexec rm -f $@
+	pfexec rm -rf $(TESTS_PROTO)
+	mkdir -p $(TESTS_PROTO)
+	cp $(STAMPFILE) $(ROOT)/tests.buildstamp
+	pfexec ./tools/builder/builder $(TESTS_MANIFEST) $(TESTS_PROTO) \
+	    $(PROTO) $(ROOT)
+	pfexec gtar -C $(TESTS_PROTO) -I pigz -cf $@ .
+	rm $(ROOT)/tests.buildstamp
+
+tests-tar: $(TESTS_TARBALL)
+
 #
 # Update source code from parent repositories.  We do this for each local
 # project as well as for illumos, illumos-extra, and smartos-live via the
@@ -378,7 +423,7 @@ check: $(JSLINT)
 
 clean:
 	./tools/clobber_illumos
-	rm -f $(MANIFEST) $(BOOT_MANIFEST)
+	rm -f $(MANIFEST) $(BOOT_MANIFEST) $(TESTS_MANIFEST)
 	rm -rf $(MPROTO)/* $(BOOT_MPROTO)/* $(MCPROTO)/*
 	(cd $(ROOT)/src && gmake clean)
 	[ ! -d $(ROOT)/projects/illumos-extra ] || \
@@ -396,8 +441,9 @@ clean:
 	(cd $(ROOT) && [ -h $(STRAP_PROTO) ] || rm -rf $(STRAP_PROTO))
 	(cd $(ROOT) && pfexec rm -rf $(BOOT_PROTO))
 	(cd $(ROOT) && pfexec rm -rf $(IMAGES_PROTO))
+	(cd $(ROOT) && pfexec rm -rf $(TESTS_PROTO))
 	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO) \
-	    $(IMAGES_PROTO))
+	    $(IMAGES_PROTO) $(TESTS_PROTO))
 	rm -f tools/cryptpass
 	(cd tools/builder && gmake clean)
 	(cd tools/format_image && gmake clean)
@@ -456,6 +502,7 @@ PLATFORM_TARBALL		= output/$(PLATFORM_TARBALL_BASE)
 
 PUB_IMAGES_BASE			= images$(PLATFORM_DEBUG_SUFFIX)-$(PLATFORM_STAMP).tgz
 PUB_BOOT_BASE			= boot$(PLATFORM_DEBUG_SUFFIX)-$(PLATFORM_STAMP).tgz
+PUB_TESTS_BASE			= tests$(PLATFORM_DEBUG_SUFFIX)-$(PLATFORM_STAMP).tgz
 
 PUB_PLATFORM_IMG_BASE		= platform$(PLATFORM_DEBUG_SUFFIX)-$(PLATFORM_STAMP).tgz
 PUB_PLATFORM_MF_BASE		= platform$(PLATFORM_DEBUG_SUFFIX)-$(PLATFORM_STAMP).imgmanifest
@@ -465,6 +512,7 @@ PUB_PLATFORM_TARBALL		= $(PLATFORM_BITS_DIR)/$(PUB_PLATFORM_IMG_BASE)
 
 PUB_IMAGES_TARBALL		= $(PLATFORM_BITS_DIR)/$(PUB_IMAGES_BASE)
 PUB_BOOT_TARBALL		= $(PLATFORM_BITS_DIR)/$(PUB_BOOT_BASE)
+PUB_TESTS_TARBALL		= $(PLATFORM_BITS_DIR)/$(PUB_TESTS_BASE)
 
 PLATFORM_IMAGE_UUID		?= $(shell uuid -v4)
 
@@ -487,6 +535,7 @@ common-platform-publish:
 	@echo "# Publish common platform$(PLATFORM_DEBUG_SUFFIX) bits"
 	mkdir -p $(PLATFORM_BITS_DIR)
 	cp $(PLATFORM_TARBALL) $(PUB_PLATFORM_TARBALL)
+	cp $(TESTS_TARBALL) $(PUB_TESTS_TARBALL)
 	for config_file in configure-projects configure-build; do \
 	    if [[ -f $$config_file ]]; then \
 	        cp $$config_file $(PLATFORM_BITS_DIR); \
@@ -617,12 +666,14 @@ common-release: \
 .PHONY: triton-release
 triton-release: \
     images-tar \
+    tests-tar \
     triton-platform-publish \
     platform-bits-upload
 
 .PHONY: triton-smartos-release
 triton-smartos-release: \
     images-tar \
+    tests-tar \
     triton-platform-publish \
     smartos-build \
     smartos-publish \
diff --git a/tools/generate-manifest-from-ips.nawk b/tools/generate-manifest-from-ips.nawk
new file mode 100755
index 00000000..1a8744a4
--- /dev/null
+++ b/tools/generate-manifest-from-ips.nawk
@@ -0,0 +1,273 @@
+#!/opt/local/bin/nawk -f
+
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+#
+# This nawk script is used to generate SmartOS 'manifest' files from
+# IPS package manifests. This is basic, and doesn't compare to the significant
+# tooling infrastructure that the IPS provides (pkgmogrify transforms,
+# dependency generation, include directives, etc.) but we don't have that
+# available when building SmartOS, so we make do.
+# There is limited support here for the pkgmogrify transforms that are commonly
+# found in IPS manifests as checked into the Illumos gate.
+#
+
+#
+# Define a series of global variables.
+#
+BEGIN {
+    action_name = "";
+
+    # attrs are the IPS attributes for a given action, set a dummy entry for
+    # 'path' here as a canary.
+    attrs["path"] = "tweet tweet";
+
+    # the full text of the action, built up over continuation lines if needed
+    action = "";
+
+    # A state flag, '1' if we're processing a continuation line, i.e. the
+    # preceding line ended with a '\' character. Set to '0' otherwise.
+    continuation = 0;
+
+    # defaults if specific attributes are not set. pkgmogrify transforms
+    # in usr/src/pkg/defaults will do a much better job here unfortunately.
+    default_mode = "0555";
+    default_owner = "root";
+    default_group = "sys";
+
+    # A dictionary of the pkgmogrify macros commonly used by Illumos IPS
+    # manifests. This is not exhaustive.
+    macros["ARCH"] = "i386";
+    macros["ARCH32"] = "i86";
+    macros["ARCH64"] = "amd64";
+    macros["i386_ONLY"] = "";
+
+    # set to '1' to enable debug messages.
+    debug_mode = 0;
+
+    # the set of actions we ignore. Leading and trailing spaces are significant
+    # as we search for ' <string> ' to cope with substrings, eg. link hardlink
+    ignored_actions = " set license device signature ";
+}
+
+function debug(text) {
+    if (debug_mode == 1) {
+        print " ==== " text;
+    }
+}
+
+function replace_macros(string) {
+    for (macro in macros) {
+        re = "\\$\\(" macro "\\)"
+        sub(re, macros[macro], string);
+    }
+    return string;
+}
+
+#
+# Break our action into the global associative array, 'attrs'.
+#
+function parse_action() {
+    if (length(action) == 0) {
+        debug("attempted to parse empty action!");
+        return;
+    }
+    split(action, pairs);
+    for (i=1; i<= length(pairs); i++) {
+        split(pairs[i], keyval, "=");
+        attrs[keyval[1]] = keyval[2];
+    }
+}
+
+#
+# Write a line of the output manifest, having computed 'action_name' and 'attrs'
+#
+function emit_line() {
+    if (length(action) == 0) {
+        debug("attempted to emit line with no action present!");
+        return;
+    }
+
+    if (action_name == "file") {
+        name = "f";
+        default_mode = "0444";
+    } else if (action_name == "dir") {
+        name = "d";
+        default_mode = "0555";
+    } else if (action_name == "link") {
+        name = "s";
+    } else if (action_name == "hardlink") {
+        name = "h";
+    }
+
+    if ("owner" in attrs) {
+        owner = attrs["owner"]
+    } else {
+        owner = default_owner;
+    }
+
+    if ("group" in attrs) {
+        group = attrs["group"]
+    } else {
+        group = default_group;
+    }
+
+    if ("mode" in attrs) {
+        mode = attrs["mode"];
+    } else {
+        mode = default_mode;
+    }
+
+    if (action_name == "file" || action_name == "dir") {
+        print name " " replace_macros(attrs["path"]) " " mode " " owner " " group;
+    } else if (action_name == "link" || action_name == "hardlink") {
+
+        #
+        # SmartOS manifests expect full paths in targets, but IPS manifests
+        # don't require that. Try to catch these cases by looking for link
+        # targets that are either relative, or contain no directory
+        # separators, and prepend the parent directory of the source path.
+        #
+        if (match(attrs["target"], "^\.") != 0 || match(attrs["target"], "/") == 0) {
+            split(attrs["path"], path_comps, "/");
+            targ_dir = "";
+            for (i=1; i < length(path_comps); i++) {
+                targ_dir = targ_dir path_comps[i] "/";
+            }
+            debug("missing or relative target path. Computed " targ_dir);
+            attrs["target"] = targ_dir attrs["target"];
+        }
+        print name " " replace_macros(attrs["path"]) "=" replace_macros(attrs["target"]);
+    }
+
+    action = "";
+    action_name = "";
+    delete attrs;
+    # revive our canary
+    attrs["path"] = "tweet tweet";
+}
+
+#
+# returns 1 if we should call 'next' to read the next line
+# and continue loading this action (when the action line has
+# a continuation line) We can't call 'next' directly from
+# a function in awk.
+#
+function parse_or_next() {
+    if (match($0, "\\\\$") != 0) {
+        continuation = 1;
+        sub("\\\\$", "", $0);
+        action = $0;
+        return 1;
+    } else {
+        action = $0;
+        parse_action();
+        emit_line();
+        return 0
+    }
+}
+
+#
+# Deal with file actions
+#
+/^file|^\$\(i386_ONLY\)file/ {
+    debug("file action: " $0);
+    action = "";
+    action_name = "file";
+    res = parse_or_next();
+    if (res == 1) {
+        next;
+    }
+}
+
+#
+# Deal with directory actions
+#
+/^dir|^\$\(i386_ONLY\)dir/ {
+    debug("dir action: " $0);
+    action_name = "dir";
+    res = parse_or_next();
+    if (res == 1) {
+        next;
+    }
+}
+
+#
+# Deal with hardlinks
+#
+/^hardlink|^\$\(i386_ONLY\)hardlink/ {
+    debug("hardlink action: " $0);
+    action_name = "hardlink";
+    res = parse_or_next();
+    if (res == 1) {
+        next;
+    }
+}
+
+#
+# Deal with symlinks
+#
+/^link|^\$\(i386_ONLY\)link/ {
+    debug("symlink action: " $0);
+    action_name = "link";
+    res = parse_or_next();
+    if (res == 1) {
+        next;
+    }
+}
+
+#
+# Deal with comments by just ignoring them
+#
+/^#/ {
+    debug("comment: " $0);
+    next;
+}
+
+#
+# The "match-everything" case. Deal with continuation lines, and log/ignore
+# all actions we don't know about.
+#
+// {
+    split($0, words, " ");
+    search = " " words[1] " "
+    if (match(ignored_actions, search) != 0) {
+        debug("ignored action: " $0);
+        next;
+    }
+    if (continuation == 1) {
+        cont = $0;
+        if (match(cont, "\\\\$") != 0) {
+            debug("still in a continuation");
+
+            sub("\\\\$", "", cont);
+            debug("cont is: " cont)
+            action = action cont;
+            debug("action is now: " action)
+            next;
+        } else {
+            debug("ended our continuation")
+            continuation = 0;
+            action = action cont;
+            debug("complete action is: " action)
+            parse_action();
+            emit_line();
+        }
+    }
+}
+
+END {
+    # drain any remaining action we have buffered till now.
+    if (continuation == 1) {
+        parse_action();
+        emit_line();
+    }
+}
-- 
2.21.0

