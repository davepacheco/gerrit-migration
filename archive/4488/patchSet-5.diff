commit bf6da93b813b028f98978f3b2c4e9845935e165a (refs/changes/88/4488/5)
Author: Chris Burroughs <chris.burroughs@joyent.com>
Date:   2018-07-30T16:51:26+00:00 (1 year, 2 months ago)
    
    TOOLS-1958 'sdcadm experimental update-agents' saves the agents shar as "agent-UUID.sh" instead of "agents-UUID.sh"
    TOOLS-1959 sdcadm: agent[s]-UUID.sh files build up in /usbkey/extra/agents

diff --git a/CHANGES.md b/CHANGES.md
index 62d1bd1..3ca2ce6 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright 2018 Joyent, Inc.
+    Copyright (c) 2018 Joyent, Inc.
 -->
 
 # sdcadm Changelog
@@ -17,6 +17,8 @@
 ## 1.19.1
 
 - TRITON-572 sdcadm post-setup cloudapi should let sapi determine instance networks
+- TOOLS-1958 / TOOLS-1959 `sdcadm experimental update-agents` Uses a consistent
+  name for the downloaded agents shars and only retains a finite number.
 
 ## 1.19.0
 
diff --git a/README.md b/README.md
index da095de..37f60a6 100644
--- a/README.md
+++ b/README.md
@@ -72,3 +72,18 @@ tests in a single file, instead of all test files, consider using the -f flag
 with the `runtests` command. For example, to run the tests in sdcadm.test.js:
 
     /opt/smartdc/sdcadm/test/runtests -f sdcadm.test.js
+
+
+### Unit Tests
+
+`sdadm` includes some unit tests. At this time the coverage is significantly
+less than the integration tests.  Unit tests can be run with:
+
+    make test-unit
+
+Individual test files can be run with a command such as:
+
+    ./node_modules/.bin/tap test/unit/foo.js
+
+`node-tap` includes several flags that may be useful while developing, such as
+only running suites that match a certain name.
diff --git a/lib/cli/do_update_agents.js b/lib/cli/do_update_agents.js
index 0ba0d48..7653bf0 100644
--- a/lib/cli/do_update_agents.js
+++ b/lib/cli/do_update_agents.js
@@ -7,130 +7,322 @@
 /*
  * Copyright (c) 2018, Joyent, Inc.
  */
+'use strict';
 
 /*
  * The 'sdcadm experimental update-agents' CLI subcommand.
  */
 
-var fs = require('fs');
-var path = require('path');
-var util = require('util');
-var format = util.format;
+const fs = require('fs');
+const path = require('path');
+const util = require('util');
 
 var assert = require('assert-plus');
-var crypto = require('crypto');
-var vasync = require('vasync');
-var mkdirp = require('mkdirp');
-var uuid = require('node-uuid');
-var ProgressBar = require('progbar').ProgressBar;
-var VError = require('verror');
-
-var common = require('../common');
-var errors = require('../errors');
-var steps = require('../steps');
-var svcadm = require('../svcadm');
-var ur = require('../ur');
+const crypto = require('crypto');
+const mkdirp = require('mkdirp');
+const uuid = require('node-uuid');
+const vasync = require('vasync');
+const ProgressBar = require('progbar').ProgressBar;
+const VError = require('verror');
+
+const common = require('../common');
+const errors = require('../errors');
+const steps = require('../steps');
+const svcadm = require('../svcadm');
+const ur = require('../ur');
+
+
+function sha1Path(filePath, cb) {
+    const hash = crypto.createHash('sha1');
+    const s = fs.createReadStream(filePath);
+    s.on('data', function onData(d) {
+        hash.update(d);
+    });
+    s.on('end', function onEnd() {
+        cb(null, hash.digest('hex'));
+    });
+}
+
 
 /*
  * Fetch a given agent installer image (or if desired, latest), download it,
  * then deploy it on the selected servers.
  *
- * @param options.agentsshar {String} A string indicating the agentsshar to
+ * @param opts.agentsshar {String} A string indicating the agentsshar to
  *      which to update. This is the string 'latest', an updates server UUID, or
  *      a path to a locally downloaded agentsshar.
- * @param options.all {Boolean} Update on all setup servers.
- *      One of `options.all` or `options.servers` must be specified.
- * @param options.servers {Array} Array of server hostnames or UUIDs on which
- *      to update. One of `options.all` or `options.servers` must be specified.
+ * @param opts.all {Boolean} Update on all setup servers.
+ *      One of `opts.all` or `opts.servers` must be specified.
+ * @param opts.servers {Array} Array of server hostnames or UUIDs on which
+ *      to update. One of `opts.all` or `opts.servers` must be specified.
  * ...
  *
  * TODO: finish documenting
  */
-function updateAgents(options, callback) {
-    assert.object(options, 'options');
-    assert.object(options.sdcadm, 'options.sdcadm');
-    assert.string(options.agentsshar, 'options.agentsshar');
-    assert.optionalBool(options.justDownload, 'options.justDownload');
-    assert.optionalBool(options.skipLatestSymlink,
-        'options.skipLatestSymlink');
-    assert.optionalBool(options.justUpdateSymlink,
-        'options.justUpdateSymlink');
-    assert.optionalBool(options.yes, 'options.yes');
-    assert.optionalBool(options.all, 'options.all');
-    assert.optionalArrayOfString(options.servers, 'options.servers');
-    assert.func(options.progress, 'options.progress');
-    assert.func(callback, 'callback');
+function UpdateAgents(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.string(opts.agentsshar, 'opts.agentsshar');
+    assert.number(opts.concurrency, 'opts.concurrency');
+    assert.optionalBool(opts.justDownload, 'opts.justDownload');
+    assert.optionalBool(opts.skipLatestSymlink,
+        'opts.skipLatestSymlink');
+    assert.optionalBool(opts.justUpdateSymlink,
+        'opts.justUpdateSymlink');
+    assert.optionalBool(opts.yes, 'opts.yes');
+    assert.optionalBool(opts.all, 'opts.all');
+    assert.optionalArrayOfString(opts.servers, 'opts.servers');
+    assert.func(opts.progress, 'opts.progress');
+
+    if ((opts.all && opts.servers) ||
+        (!opts.all && !opts.servers &&
+         !opts.justDownload && !opts.justUpdateSymlink)) {
+        throw new errors.UsageError(
+            'must specify exactly one of "opts.all" or "opts.servers"');
+    }
+
+    this.downloadDir = '/var/tmp';
+
+    this.agentsshar = opts.agentsshar;
+    this.all = opts.all;
+    this.concurrency = opts.concurrency;
+    this.justDownload = opts.justDownload;
+    this.justUpdateSymlink = opts.justUpdateSymlink;
+    this.log = opts.sdcadm.log;
+    this.progress = opts.progress;
+    this.sdcadm = opts.sdcadm;
+    this.servers = opts.servers;
+    this.skipLatestSymlink = opts.skipLatestSymlink;
+    this.yes = opts.yes;
+}
+
+UpdateAgents.prototype._setImageToLatest =  function _setImageToLatest(cb) {
+    assert.func(cb, 'cb');
+    assert.string(this.channel, 'this.channel');
+
+    const self = this;
+    const filter = {
+        name: 'agentsshar'
+    };
+    this.progress(
+        'Finding latest "agentsshar" on updates server (channel "%s")',
+        this.channel);
+    this.sdcadm.updates.listImages(filter, function (err, images) {
+        if (err) {
+            cb(new errors.SDCClientError(err, 'updates'));
+            return;
+            }
+        if (Array.isArray(images) && !images.length) {
+            cb(new errors.UpdateError('no images found'));
+            return;
+        }
+        common.sortArrayOfObjects(images, ['published_at']);
+        self.image = images[images.length - 1];
+        self.progress('Latest is agentsshar %s (%s)',
+                      self.image.uuid, self.image.version);
+        cb();
+    });
+};
+
+UpdateAgents.prototype._setImageFromUuid =
+function _setImageFromUuid(imageUuid, cb) {
+    assert.uuid(imageUuid, 'imageUuid');
+    assert.func(cb, 'cb');
 
-    if ((options.all && options.servers) ||
-        (!options.all && !options.servers &&
-         !options.justDownload && !options.justUpdateSymlink)) {
-        callback(new errors.UsageError(
-            'must specify exactly one of "options.all" or "options.servers"'));
+    const self = this;
+
+    this.sdcadm.updates.getImage(imageUuid, function (err, foundImage) {
+        if (err) {
+            cb(new errors.SDCClientError(err, 'updates'));
+            return;
+            }
+        self.image = foundImage;
+        self.progress('Found agentsshar %s (%s)',
+                      self.image.uuid, self.image.version);
+        cb();
+    });
+};
+
+
+UpdateAgents.prototype._stepVerifyFilepath =
+function _stepVerifyFilepath(_, next) {
+    assert.func(next, 'next');
+
+    if (!this.justUpdateSymlink) {
+        next();
+        return;
+    }
+    if (!this.filepath) {
+        next(new Error('existing file must be specified when using ' +
+                       '"--just-update-symlink" option'));
         return;
     }
+    next();
+};
+
 
-    var sdcadm = options.sdcadm;
-    var log = sdcadm.log;
-
-    var startTime = Date.now();
-    var downloadDir = '/var/tmp';
-    var filepath;
-    var channel;
-    var image;
-    var progress = options.progress;
-    var justDownload = options.justDownload;
-    var skipLatestSymlink = options.skipLatestSymlink;
-    var justUpdateSymlink = options.justUpdateSymlink;
-
-    function setImageToLatest(cb) {
-        var filter = {
-            name: 'agentsshar'
-        };
-        progress('Finding latest "agentsshar" on updates server (channel "%s")',
-            channel);
-        sdcadm.updates.listImages(filter, function (err, images) {
+/*
+ * If we are about to download an image, first check to see if that
+ * image is already available locally (verifying via checksum).
+ * If so, then switch to using that file.
+ */
+UpdateAgents.prototype._stepHaveSharAlreadyFromLink =
+function _stepHaveSharAlreadyFromLink(_, next) {
+    assert.func(next, 'next');
+
+    const self = this;
+
+    if (self.filepath) {
+        next();
+        return;
+    }
+
+    // lla == "Latest Local Agentsshar"
+    const llaLink = '/usbkey/extra/agents/latest';
+    fs.exists(llaLink, function (exists) {
+        if (!exists) {
+            self.log.debug({llaLink: llaLink}, 'symlink to latest ' +
+                           'agentsshar is missing, skipping shortcut');
+            next();
+            return;
+        }
+        fs.readlink(llaLink, function (err, linkTarget) {
             if (err) {
-                cb(new errors.SDCClientError(err, 'updates'));
-                return;
-            }
-            if (Array.isArray(images) && !images.length) {
-                cb(new errors.UpdateError('no images found'));
+                self.log.error({err: err, llaLink: llaLink},
+                               'could not read agents "latest" symlink');
+                next(new errors.UpdateError(
+                    err,
+                    'could not read agents "latest" symlink, ' +
+                        llaLink));
                 return;
             }
-            common.sortArrayOfObjects(images, ['published_at']);
-            image = images[images.length - 1];
-            progress('Latest is agentsshar %s (%s)', image.uuid, image.version);
-            cb();
+
+            const llaPath = path.resolve(
+                path.dirname(llaLink), linkTarget);
+            self.log.debug({llaPath: llaPath}, 'latest local agentsshar');
+            sha1Path(llaPath, function (checksumErr, checksum) {
+                if (checksumErr) {
+                    next(checksumErr);
+                    return;
+                }
+                if (checksum === self.image.files[0].sha1) {
+                    self.progress('The %s agentsshar already exists ' +
+                                  'at %s, using it', self.agentsshar,
+                                  llaPath);
+                    self.filepath = llaPath;
+                }
+                next();
+            });
         });
+    });
+};
+
+UpdateAgents.prototype._stepHaveSharAlreadyFromDownload =
+function _stepHaveSharAlreadyFromDownload(_, next) {
+    assert.func(next, 'next');
+
+    const self = this;
+
+    if (self.filepath) {
+        next();
+        return;
     }
 
-    function setImageFromUuid(imageUuid, cb) {
-        sdcadm.updates.getImage(imageUuid, function (err, foundImage) {
-            if (err) {
-                cb(new errors.SDCClientError(err, 'updates'));
+    const predownloadedPath = path.resolve(self.downloadDir,
+                                           'agents-' + self.image.uuid + '.sh');
+    fs.exists(predownloadedPath, function (exists) {
+        if (!exists) {
+            next();
+            return;
+        }
+        sha1Path(predownloadedPath, function (checksumErr, checksum) {
+            if (checksumErr) {
+                next(checksumErr);
                 return;
             }
-            image = foundImage;
-            progress('Found agentsshar %s (%s)', image.uuid, image.version);
-            cb();
+            if (checksum === self.image.files[0].sha1) {
+                self.progress('The %s agentsshar already exists ' +
+                              'at %s, using it', self.agentsshar,
+                              predownloadedPath);
+                self.filepath = predownloadedPath;
+            }
+            next();
         });
+    });
+};
+
+UpdateAgents.prototype._stepCreateLatestSymlink =
+function _stepCreateLatestSymlink(ctx, next) {
+    assert.func(next, 'next');
+
+    const self = this;
+
+    if (self.justDownload || self.skipLatestSymlink) {
+        next();
+        return;
     }
 
-    function sha1Path(filePath, cb) {
-        var hash = crypto.createHash('sha1');
-        var s = fs.createReadStream(filePath);
-        s.on('data', function (d) {
-            hash.update(d);
-        });
-        s.on('end', function () {
-            cb(null, hash.digest('hex'));
+    const symlink = '/usbkey/extra/agents/latest';
+    self.progress('Create %s symlink', symlink);
+    fs.unlink(symlink, function (unlinkErr) {
+        if (unlinkErr && unlinkErr.code !== 'ENOENT') {
+            next(new VError(unlinkErr,
+                            'Unable to remove % symlink', symlink));
+            return;
+        }
+        fs.symlink(ctx.fname, symlink, function (symlinkErr) {
+            if (symlinkErr) {
+                next(new VError(symlinkErr,
+                                'Unable to create "latest" symlink to "%s"',
+                                ctx.fname));
+                return;
+            }
+            next();
         });
+    });
+};
+
+UpdateAgents.prototype._stepDownloadAgentsshar =
+function _stepDownloadAgentsshar(ctx, next) {
+    assert.func(next, 'next');
+
+    const self = this;
+
+    if (self.filepath) {
+        next();
+        return;
     }
+    self.filepath = path.resolve(self.downloadDir,
+                                 'agents-' + self.image.uuid + '.sh');
+    ctx.deleteAgentssharOnFinish = true;
+    self.progress('Downloading agentsshar from updates server ' +
+                  '(channel "%s")\n    to %s', self.channel, self.filepath);
+    self.sdcadm.updates.getImageFile(
+        self.image.uuid, self.filepath,
+        function (err) {
+            if (err) {
+                next(new errors.SDCClientError(err, 'updates'));
+            } else {
+                next();
+            }
+        });
+};
+
+
+UpdateAgents.prototype.exec = function exec(callback) {
+    assert.func(callback, 'callback');
 
-    var context = {
-        progress: progress,
-        log: sdcadm.log,
-        sdcadm: sdcadm,
+    const self = this;
+    let startTime = Date.now();
+
+    this.filepath = null;
+    this.channel = null;
+    this.image = null;
+
+    const context = {
+        log: self.log,
+        progress: self.progress,
+        sdcadm: self.sdcadm,
         urconn: null
     };
 
@@ -140,14 +332,14 @@ function updateAgents(options, callback) {
          * it:
          */
         function urDiscoveryGetReady(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
 
-            sdcadm.getUrConnection(function (err, urconn) {
+            self.sdcadm.getUrConnection(function (err, urconn) {
                 if (err) {
-                    log.debug({
+                    self.log.debug({
                         err: err
                     }, 'ur error');
                     next(new errors.InternalError({
@@ -157,17 +349,17 @@ function updateAgents(options, callback) {
                     return;
                 }
 
-                log.debug('ur connected');
+                self.log.debug('ur connected');
                 ctx.urconn = urconn;
                 next();
             });
         },
 
         function getChannelIfNeeded(_, next) {
-            if (options.agentsshar === 'latest' ||
-                common.UUID_RE.test(options.agentsshar)) {
-                sdcadm.getDefaultChannel(function (err, ch) {
-                    channel = ch;
+            if (self.agentsshar === 'latest' ||
+                common.UUID_RE.test(self.agentsshar)) {
+                self.sdcadm.getDefaultChannel(function (err, ch) {
+                    self.channel = ch;
                     next(err);
                 });
             } else {
@@ -176,118 +368,33 @@ function updateAgents(options, callback) {
         },
 
         function setImageOrFilepath(_, next) {
-            if (options.agentsshar === 'latest') {
-                setImageToLatest(next);
-            } else if (common.UUID_RE.test(options.agentsshar)) {
-                setImageFromUuid(options.agentsshar, next);
-            } else if (fs.existsSync(options.agentsshar)) {
-                filepath = options.agentsshar;
+            if (self.agentsshar === 'latest') {
+                self._setImageToLatest(next);
+            } else if (common.UUID_RE.test(self.agentsshar)) {
+                self._setImageFromUuid(self.agentsshar, next);
+            } else if (fs.existsSync(self.agentsshar)) {
+                self.filepath = self.agentsshar;
                 next();
             } else {
-                next(new Error(format('could not find agentsshar: "%s" is ' +
-                    'not a UUID or an existing file', options.agentsshar)));
+                next(new Error(
+                    util.format('could not find agentsshar: "%s" is ' +
+                                'not a UUID or an existing file',
+                                self.agentsshar)));
             }
         },
 
-        function verifyFilepath(_, next) {
-            if (!justUpdateSymlink) {
-                next();
-                return;
-            }
-            if (!filepath) {
-                next(new Error('existing file must be specified when using ' +
-                    '"--just-update-symlink" option'));
-                return;
-            }
-            next();
-        },
-
-        /*
-         * If we are about to download an image, first check to see if that
-         * image is already available locally (verifying via checksum).
-         * If so, then switch to using that file.
-         */
-        function haveSharAlready_candidate1(_, next) {
-            if (filepath) {
-                next();
-                return;
-            }
-
-            // lla == "Latest Local Agentsshar"
-            var llaLink = '/usbkey/extra/agents/latest';
-            fs.exists(llaLink, function (exists) {
-                if (!exists) {
-                    log.debug({llaLink: llaLink}, 'symlink to latest ' +
-                        'agentsshar is missing, skipping shortcut');
-                    next();
-                    return;
-                }
-                fs.readlink(llaLink, function (err, linkTarget) {
-                    if (err) {
-                        log.error({err: err, llaLink: llaLink},
-                            'could not read agents "latest" symlink');
-                        next(new errors.UpdateError(err,
-                            'could not read agents "latest" symlink, ' +
-                            llaLink));
-                        return;
-                    }
-
-                    var llaPath = path.resolve(
-                        path.dirname(llaLink), linkTarget);
-                    log.debug({llaPath: llaPath}, 'latest local agentsshar');
-                    sha1Path(llaPath, function (checksumErr, checksum) {
-                        if (checksumErr) {
-                            next(checksumErr);
-                            return;
-                        }
-                        if (checksum === image.files[0].sha1) {
-                            progress('The %s agentsshar already exists ' +
-                                'at %s, using it', options.agentsshar,
-                                llaPath);
-                            filepath = llaPath;
-                        }
-                        next();
-                    });
-                });
-            });
-        },
-        function haveSharAlready_candidate2(_, next) {
-            if (filepath) {
-                next();
-                return;
-            }
-
-            var predownloadedPath = path.resolve(downloadDir,
-                'agent-' + image.uuid + '.sh');
-            fs.exists(predownloadedPath, function (exists) {
-                if (!exists) {
-                    next();
-                    return;
-                }
-                sha1Path(predownloadedPath, function (checksumErr, checksum) {
-                    if (checksumErr) {
-                        next(checksumErr);
-                        return;
-                    }
-                    if (checksum === image.files[0].sha1) {
-                        progress('The %s agentsshar already exists ' +
-                            'at %s, using it', options.agentsshar,
-                            predownloadedPath);
-                        filepath = predownloadedPath;
-                    }
-                    next();
-                });
-            });
-        },
+        self._stepVerifyFilepath.bind(self),
+        self._stepHaveSharAlreadyFromLink.bind(self),
+        self._stepHaveSharAlreadyFromDownload.bind(self),
 
         function listServers(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
-            progress('Finding servers to update');
+            self.progress('Finding servers to update');
             // Get all servers to validate if unsetup servers are selected.
-            sdcadm.cnapi.listServers({}, function (err, servers) {
+            self.sdcadm.cnapi.listServers({}, function (err, servers) {
                 if (err) {
                     next(err);
                     return;
@@ -298,20 +405,20 @@ function updateAgents(options, callback) {
         },
 
         function findServersToUpdate(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
 
-            if (options.all) {
+            if (self.all) {
                 ctx.serversToUpdate = ctx.allServers.filter(function (svr) {
                     return svr.setup;
                 });
                 next();
             } else {
-                var i, s;
-                var serverFromUuid = {};
-                var serverFromHostname = {};
+                let i, s;
+                const serverFromUuid = {};
+                const serverFromHostname = {};
                 for (i = 0; i < ctx.allServers.length; i++) {
                     s = ctx.allServers[i];
                     serverFromUuid[s.uuid] = s;
@@ -319,11 +426,11 @@ function updateAgents(options, callback) {
                 }
 
                 ctx.serversToUpdate = [];
-                var serverToUpdateFromUuid = {};
-                var unsetupServerIds = [];
-                var notFoundServerIds = [];
-                for (i = 0; i < options.servers.length; i++) {
-                    var id = options.servers[i];
+                const serverToUpdateFromUuid = {};
+                const unsetupServerIds = [];
+                const notFoundServerIds = [];
+                for (i = 0; i < self.servers.length; i++) {
+                    const id = self.servers[i];
                     s = serverFromUuid[id] || serverFromHostname[id];
                     if (s) {
                         // Avoid drop dupes in `opts.servers`.
@@ -339,14 +446,14 @@ function updateAgents(options, callback) {
                     }
                 }
                 if (notFoundServerIds.length) {
-                    next(new Error(format(
+                    next(new Error(util.format(
                         '%d of %d selected servers were not found in CNAPI: %s',
-                        notFoundServerIds.length, options.servers.length,
+                        notFoundServerIds.length, self.servers.length,
                         notFoundServerIds.join(', '))));
                 } else if (unsetupServerIds.length) {
-                    next(new Error(format(
+                    next(new Error(util.format(
                         '%d of %d selected servers are not setup: %s',
-                        unsetupServerIds.length, options.servers.length,
+                        unsetupServerIds.length, self.servers.length,
                         unsetupServerIds.join(', '))));
                 } else {
                     next();
@@ -355,14 +462,14 @@ function updateAgents(options, callback) {
         },
 
         function urDiscovery(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
 
             common.urDiscovery({
-                sdcadm: sdcadm,
-                progress: progress,
+                sdcadm: self.sdcadm,
+                progress: self.progress,
                 nodes: ctx.serversToUpdate.map(
                     function (s) { return s.uuid; }),
                 urconn: ctx.urconn
@@ -377,8 +484,9 @@ function updateAgents(options, callback) {
         },
 
         function earlyAbortForJustDownload(_, next) {
-            if (justDownload && filepath) {
-                progress('Agentsshar is already downloaded to %s', filepath);
+            if (self.justDownload && self.filepath) {
+                self.progress('Agentsshar is already downloaded to %s',
+                              self.filepath);
                 next(true); // early abort signal
             } else {
                 next();
@@ -386,83 +494,66 @@ function updateAgents(options, callback) {
         },
 
         function confirm(ctx, next) {
-            progress('\nThis update will make the following changes:');
-            progress(common.indent('Ensure core agent SAPI services exist'));
-            if (!filepath) {
-                assert.object(image, 'image');
-                progress(common.indent(format(
+            self.progress('\nThis update will make the following changes:');
+            self.progress(
+                common.indent('Ensure core agent SAPI services exist'));
+            if (!self.filepath) {
+                assert.object(self.image, 'self.image');
+                self.progress(common.indent(util.format(
                     'Download agentsshar %s\n    (%s)',
-                    image.uuid, image.version)));
+                    self.image.uuid, self.image.version)));
             }
-            if (!justDownload && !justUpdateSymlink) {
-                progress(common.indent(format(
+            if (!self.justDownload && !self.justUpdateSymlink) {
+                self.progress(common.indent(util.format(
                     'Update GZ agents on %d (of %d) servers using\n' +
                     '    agentsshar %s', ctx.serversToUpdate.length,
                     ctx.allServers.length,
-                    (filepath ? filepath : image.version))));
+                    (self.filepath ? self.filepath : self.image.version))));
             }
-            if (justUpdateSymlink && filepath) {
-                progress(common.indent(format('Update ' +
+            if (self.justUpdateSymlink && self.filepath) {
+                self.progress(common.indent(util.format('Update ' +
                     '\'/usbkey/extra/agents/latest\' symkink to %s',
-                    filepath)));
+                    self.filepath)));
             }
-            progress('');
-            if (options.yes) {
+            self.progress('');
+            if (self.yes) {
                 next();
                 return;
             }
-            var msg = 'Would you like to continue? [y/N] ';
+            const msg = 'Would you like to continue? [y/N] ';
             common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
                 if (answer !== 'y') {
-                    progress('Aborting agents update');
+                    self.progress('Aborting agents update');
                     callback();
                     return;
                 }
-                progress('');
+                self.progress('');
                 startTime = Date.now(); // Reset to not count confirm time.
                 next();
             });
         },
 
         steps.sapiEnsureAgentServices,
-
-        function downloadAgentsshar(ctx, next) {
-            if (filepath) {
-                next();
-                return;
-            }
-            filepath = path.resolve(downloadDir,
-                'agent-' + image.uuid + '.sh');
-            ctx.deleteAgentssharOnFinish = true;
-            progress('Downloading agentsshar from updates server ' +
-                '(channel "%s")\n    to %s', channel, filepath);
-            sdcadm.updates.getImageFile(image.uuid, filepath, function (err) {
-                if (err) {
-                    next(new errors.SDCClientError(err, 'updates'));
-                } else {
-                    next();
-                }
-            });
-        },
+        self._stepDownloadAgentsshar.bind(self),
 
         function copyFileToAssetsDir(_, next) {
-            if (justDownload) {
+            if (self.justDownload) {
                 next();
                 return;
             }
-            var assetsdir = '/usbkey/extra/agents';
-            if (path.dirname(filepath) === assetsdir) {
+            const assetsdir = '/usbkey/extra/agents';
+            if (path.dirname(self.filepath) === assetsdir) {
                 next();
                 return;
             }
-            progress('Copy agentsshar to assets dir: %s', assetsdir);
-            var argv = ['cp', filepath, assetsdir];
+            self.progress('Copy agentsshar to assets dir: %s', assetsdir);
+            const argv = ['cp', self.filepath, assetsdir];
             mkdirp.sync(assetsdir);
             common.execFilePlus({
                 argv: argv,
-                log: sdcadm.log
+                log: self.sdcadm.log
             }, function (err, stderr, stdout) {
-                sdcadm.log.trace({
+                self.sdcadm.log.trace({
                     cmd: argv.join(' '),
                     err: err,
                     stdout: stdout,
@@ -470,7 +561,7 @@ function updateAgents(options, callback) {
                 }, 'ran cp command');
                 if (err) {
                     next(new errors.InternalError({
-                        message: format('error copying shar file to %s',
+                        message: util.format('error copying shar file to %s',
                                          assetsdir),
                         cmd: argv.join(' '),
                         stdout: stdout,
@@ -484,53 +575,38 @@ function updateAgents(options, callback) {
         },
 
         function setFileName(ctx, next) {
-            ctx.fname = path.basename(filepath);
+            ctx.fname = path.basename(self.filepath);
             next();
         },
 
-        function createLatestSymlink(ctx, next) {
-            if (justDownload || skipLatestSymlink) {
+        self._stepCreateLatestSymlink.bind(self),
+
+        function removeOldAgentsShars(ctx, next) {
+            if (self.justDownload || self.justUpdateSymlink ||
+                self.skipLatestSymlink) {
                 next();
                 return;
             }
-            var symlink = '/usbkey/extra/agents/latest';
-            progress('Create %s symlink', symlink);
-            fs.unlink(symlink, function (unlinkErr) {
-                if (unlinkErr && unlinkErr.code !== 'ENOENT') {
-                    next(new VError(unlinkErr,
-                        'Unable to remove % symlink', symlink));
-                    return;
-                }
-
-                fs.symlink(ctx.fname, symlink, function (symlinkErr) {
-                    if (symlinkErr) {
-                        next(new VError(symlinkErr,
-                            'Unable to create "latest" symlink to "%s"',
-                            ctx.fname));
-                        return;
-                    }
-                    next();
-                });
-            });
+            steps.usbkey.removeOldAgentsShars(ctx, next);
         },
 
         function updateCNAgents(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
 
-            progress('Starting agentsshar update on %d servers',
+            self.progress('Starting agentsshar update on %d servers',
                 ctx.urServersToUpdate.length);
 
-            var ip = sdcadm.config.assets_admin_ip;
-            var f = ctx.fname;
-            var ff = '/var/tmp/' + f;
+            const ip = self.sdcadm.config.assets_admin_ip;
+            const f = ctx.fname;
+            const ff = '/var/tmp/' + f;
             // Do not override log file if we run installer more than once for
             // the same version.
             // TODO(trent): Won't these build up? Should clean these out.
-            var lf = '/var/tmp/' + f + '_' + uuid() + '_install.log';
-            var nodeConfigCmd = [
+            const lf = '/var/tmp/' + f + '_' + uuid() + '_install.log';
+            const nodeConfigCmd = [
                 'cd /var/tmp;',
                 '',
                 /*
@@ -574,7 +650,7 @@ function updateAgents(options, callback) {
                 ''
             ].join('\n');
 
-            var downloadCmd = [
+            const downloadCmd = [
                 'cd /var/tmp;',
                 /*
                  * Exit non zero if agents dir does not exist
@@ -593,7 +669,7 @@ function updateAgents(options, callback) {
                 ''
             ].join('\n');
 
-            var installCmd = [
+            const installCmd = [
                 'cd /var/tmp;',
                 '',
                 /*
@@ -626,13 +702,13 @@ function updateAgents(options, callback) {
                 ],
                 func: function runUrQueue(cmd, nextCmd) {
                     assert.object(ctx.urconn, 'ctx.urconn');
-                    var queueOpts = {
-                        sdcadm: sdcadm,
+                    const queueOpts = {
+                        sdcadm: self.sdcadm,
                         urConnection: ctx.urconn,
-                        log: sdcadm.log,
-                        progress: progress,
+                        log: self.sdcadm.log,
+                        progress: self.progress,
                         command: cmd.str,
-                        concurrency: options.rate,
+                        concurrency: self.concurrency,
                         timeout: cmd.timeout
                     };
 
@@ -645,8 +721,8 @@ function updateAgents(options, callback) {
                         });
                         queueOpts.progbar = bar;
                     }
-                    sdcadm.log.trace(
-                        {command: cmd.str, concurrency: options.rate},
+                    self.sdcadm.log.trace(
+                        {command: cmd.str, concurrency: self.concurrency},
                         'runUrQueue');
 
                     var rq = ur.runQueue(queueOpts, function (err, results) {
@@ -659,7 +735,7 @@ function updateAgents(options, callback) {
                         var errs = [];
                         results.forEach(function (r) {
                             if (r.error || r.result.exit_status !== 0) {
-                                errs.push(new errors.UpdateError(format(
+                                errs.push(new errors.UpdateError(util.format(
                                     '%s failed on server %s (%s): %j',
                                     cmd.progbarName, r.uuid, r.hostname,
                                     r.error || r.result)));
@@ -677,7 +753,7 @@ function updateAgents(options, callback) {
                     rq.on('success', function onSuccess(server, result) {
                         // A non-zero exit from the command is a "success".
                         if (result.exit_status !== 0) {
-                            var errmsg = format(
+                            var errmsg = util.format(
                                 '%s failed on server %s (%s): %j',
                                 cmd.progbarName, server.uuid,
                                 server.hostname, result);
@@ -705,15 +781,16 @@ function updateAgents(options, callback) {
         },
 
         function doCleanup(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
             if (ctx.deleteAgentssharOnFinish) {
-                progress('Deleting temporary %s', filepath);
-                fs.unlink(filepath, function (err) {
+                self.progress('Deleting temporary %s', self.filepath);
+                fs.unlink(self.filepath, function (err) {
                     if (err) {
-                        sdcadm.log.warn(err, 'could not unlink %s', filepath);
+                        self.sdcadm.log.warn(err, 'could not unlink %s',
+                                             self.filepath);
                     }
                     next();
                 });
@@ -727,31 +804,31 @@ function updateAgents(options, callback) {
         // instances and until we move from update agents using a shar file
         // to the individual agents update.
         function refreshSysinfo(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
 
-            progress('Reloading sysinfo on updated servers');
+            self.progress('Reloading sysinfo on updated servers');
 
-            var errs = [];
+            const errs = [];
 
-            var queue = vasync.queue(
+            const queue = vasync.queue(
                 function upSysinfo(server, cb) {
-                    sdcadm.cnapi.refreshSysinfoAndWait(
+                    self.sdcadm.cnapi.refreshSysinfoAndWait(
                         server.uuid,
-                        sdcadm.config.wfapi.url,
+                        self.sdcadm.config.wfapi.url,
                         {},
                         function cnapiCb(err, job) {
                         if (err) {
-                            sdcadm.log.error({
+                            self.sdcadm.log.error({
                                 err: err,
                                 server: server
                             }, 'CNAPI sysinfo-refresh');
                             errs.push(server.uuid);
                         }
                         if (job && job.execution === 'failed') {
-                            sdcadm.log.debug({
+                            self.sdcadm.log.debug({
                                 job: job,
                                 server: server
                             }, 'CNAPI sysinfo-refresh job failed');
@@ -766,15 +843,16 @@ function updateAgents(options, callback) {
             queue.close();
             queue.on('end', function done() {
                 if (errs.length) {
-                    progress(
+                    self.progress(
                         'Sysinfo reload failed for the following servers:');
                     errs.forEach(function (e) {
-                        progress(common.indent(e));
+                        self.progress(common.indent(e));
                     });
-                    progress(
+                    self.progress(
                         'Please consider reviewing sysinfo for these servers');
                 } else {
-                    progress('Sysinfo reloaded for all the running servers');
+                    self.progress(
+                        'Sysinfo reloaded for all the running servers');
                 }
                 next();
             });
@@ -786,27 +864,27 @@ function updateAgents(options, callback) {
          * race.
          */
         function refreshConfigAgents(ctx, next) {
-            if (justDownload || justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink) {
                 next();
                 return;
             }
-            progress('Refreshing config-agent on all the updated servers');
+            self.progress('Refreshing config-agent on all the updated servers');
 
-            var queue = vasync.queue(
+            const queue = vasync.queue(
                 function refreshCfgAgent(server, cb) {
                     svcadm.svcadmRefresh({
                         server_uuid: server.uuid,
                         wait: false,
                         fmri: 'config-agent',
-                        sdcadm: sdcadm,
-                        log: sdcadm.log
+                        sdcadm: self.sdcadm,
+                        log: self.sdcadm.log
                     }, cb);
                 },
                 10);
             queue.push(ctx.serversToUpdate); // No need for per task done cb
             queue.close();
             queue.on('end', function done() {
-                progress('Config-agent refreshed on updated servers');
+                self.progress('Config-agent refreshed on updated servers');
                 next();
             });
         },
@@ -817,27 +895,27 @@ function updateAgents(options, callback) {
         if (err === true) { // early abort signal
             err = null;
         }
-        if (justDownload || justUpdateSymlink) {
+        if (self.justDownload || self.justUpdateSymlink) {
             callback(err);
             return;
         }
         if (!err) {
-            progress('Successfully updated agents (%s)',
+            self.progress('Successfully updated agents (%s)',
                     common.humanDurationFromMs(Date.now() - startTime));
         }
         callback(err);
     });
-}
+};
 
 
-/*
+/**
  * Update agents in datancenter with a given or latest agents installer.
+ * @this Cmdln
  */
-
 function do_update_agents(subcmd, opts, args, cb) {
     var self = this;
     if (opts.help) {
-        this.do_help('help', {}, [subcmd], cb);
+        self.do_help('help', {}, [subcmd], cb);
         return;
     }
     if (!opts.latest && !args[0]) {
@@ -878,7 +956,7 @@ function do_update_agents(subcmd, opts, args, cb) {
             });
         },
         function runUpdateAgents(_, next) {
-            updateAgents({
+            const cmd = new UpdateAgents({
                 sdcadm: self.sdcadm,
                 agentsshar: agentsshar,
                 progress: self.progress,
@@ -889,7 +967,8 @@ function do_update_agents(subcmd, opts, args, cb) {
                 servers: servers,
                 all: opts.all,
                 concurrency: Number(opts.concurrency)
-            }, next);
+            });
+            cmd.exec(next);
         }
     ]}, cb);
 
@@ -990,5 +1069,7 @@ do_update_agents.options = [
 // --- exports
 
 module.exports = {
-    do_update_agents: do_update_agents
+    do_update_agents: do_update_agents,
+    _UpdateAgents: UpdateAgents,
+    _sha1Path: sha1Path
 };
diff --git a/lib/steps/usbkey.js b/lib/steps/usbkey.js
index 69e720d..47d0435 100644
--- a/lib/steps/usbkey.js
+++ b/lib/steps/usbkey.js
@@ -14,13 +14,15 @@ const path = require('path');
 
 var assert = require('assert-plus');
 
+
 // keep a finite number cn_tools backups on the usb key
 function removeOldCNToolsTarballs(arg, next) {
     assert.optionalFunc(arg.progress, 'arg.progress');
+    assert.func(next, 'next');
 
     const progress = arg.progress || console.log;
     const backupPath = '/usbkey/extra/joysetup/';
-    var tarballs = fs.readdirSync(backupPath).filter(
+    let tarballs = fs.readdirSync(backupPath).filter(
         function isCNTools(p) {
             return (p.startsWith('cn_tools.') &&
                     p.endsWith('tar.gz') &&
@@ -38,6 +40,52 @@ function removeOldCNToolsTarballs(arg, next) {
     next();
 }
 
+// keep only a finite number of agentsshar files
+function removeOldAgentsShars(arg, next) {
+    assert.optionalFunc(arg.progress, 'arg.progress');
+    assert.func(next, 'next');
+
+    const progress = arg.progress || console.log;
+    const agentsDir = '/usbkey/extra/agents';
+    const latestLinkName = '/usbkey/extra/agents/latest';
+
+    let latest;
+    if (fs.existsSync('/usbkey/extra/agents/latest')) {
+        latest = path.resolve(agentsDir,
+                              fs.readlinkSync(latestLinkName));
+    }
+
+    let shars = fs.readdirSync('/usbkey/extra/agents/').filter(
+        function isShar(p) {
+            return (p.endsWith('.sh') &&
+                    // Prefix was changed from agent- to agents- in TOOLS-1958
+                    (p.startsWith('agents-') || p.startsWith('agent-')) &&
+                    path.resolve(agentsDir, p) !== latest);
+        });
+
+    // With the possible exception of the first run, there should only be a
+    // handful of old agent shars to consider.  The full agent install already
+    // takes minutes.
+    const sortedShars = shars.map(function statShar(fname) {
+        return {fname: fname,
+                mtime: fs.statSync(path.resolve(agentsDir, fname)).mtime};
+    }).sort(function cmp(a, b) {
+        return a.mtime - b.mtime;
+    }).map(function (pair) {
+        return pair.fname;
+    });
+    sortedShars.reverse();
+    const toDelete = sortedShars.slice(3);
+    if (toDelete.length) {
+        progress('Removing old agentshars: ' + toDelete.join(', '));
+        toDelete.forEach(function rmShar(fname) {
+            fs.unlinkSync(path.join(agentsDir, fname));
+        });
+    }
+    next();
+}
+
 module.exports = {
-    removeOldCNToolsTarballs: removeOldCNToolsTarballs
+    removeOldCNToolsTarballs: removeOldCNToolsTarballs,
+    removeOldAgentsShars: removeOldAgentsShars
 };
diff --git a/package.json b/package.json
index 32b5229..c2c5659 100644
--- a/package.json
+++ b/package.json
@@ -37,7 +37,7 @@
     "marked-man": "0.1.4",
     "eslint": "4.13.1",
     "eslint-plugin-joyent": "~2.0.0",
-    "mock-fs": "4.4.x",
+    "mock-fs": "4.5.x",
     "tap": "^12.0.1",
     "zkstream": "0.11.2"
   },
diff --git a/test/unit/cli/do_update_agents.test.js b/test/unit/cli/do_update_agents.test.js
new file mode 100644
index 0000000..c060908
--- /dev/null
+++ b/test/unit/cli/do_update_agents.test.js
@@ -0,0 +1,358 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+'use strict';
+
+const crypto = require('crypto');
+const fs = require('fs');
+const path = require('path');
+
+var assert = require('assert-plus');
+
+const mockfs = require('mock-fs');
+const tap = require('tap');
+const VError = require('verror');
+
+const errors = require('../../../lib/errors');
+
+const do_update_agents = require('../../../lib/cli/do_update_agents');
+const UpdateAgents = do_update_agents._UpdateAgents;
+const sha1Path = do_update_agents._sha1Path;
+const testutil = require('../testutil');
+
+
+class StubImgApi {
+    getImageFile(uuid, filePath, account, options, callback) {
+        assert.string(uuid, 'uuid');
+        assert.string(filePath, 'filePath');
+        if (typeof (account) === 'function') {
+            callback = account;
+            options = {};
+            account = undefined;
+        } else if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+        assert.func(callback, 'callback');
+
+        fs.writeFileSync(filePath, 'fake ' + uuid);
+        callback();
+    }
+}
+
+
+function testCmd(opts) {
+    const log = testutil.createBunyanLogger(tap);
+
+    const defaults = {
+        sdcadm: {log: log, updates: new StubImgApi()},
+        agentsshar: 'latest',
+        concurrency: 4,
+        progress: tap.comment,
+        all: true
+    };
+    return new UpdateAgents(Object.assign({}, defaults, opts));
+}
+
+
+tap.test('sha1Path', function (suite) {
+    const testFiles = {'empty': '',
+                       'quote': 'Java is to JavaScript what Car is to Carpet.'};
+    suite.afterEach(mockfs.restore);
+
+    suite.test('empty', function (t) {
+        mockfs({'/test': testFiles});
+        t.plan(2);
+        sha1Path('/test/empty', function (err, hex) {
+            t.false(err);
+            t.equal(hex, 'da39a3ee5e6b4b0d3255bfef95601890afd80709');
+            t.done();
+        });
+    });
+
+    suite.test('quote', function (t) {
+        mockfs({'/test': testFiles});
+        t.plan(2);
+        sha1Path('/test/quote', function (err, hex) {
+            t.false(err);
+            t.equal(hex, 'f9d44427c3763e5b9d76837f72428841fdde87d6');
+            t.done();
+        });
+    });
+
+    suite.done();
+});
+
+
+tap.test('UpdateAgents._stepVerifyFilepath', function (suite) {
+
+    suite.test('full update', function (t) {
+        const subject = testCmd({justUpdateSymlink: false});
+        t.plan(1);
+        subject._stepVerifyFilepath({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('just symlink with filepath', function (t) {
+        const subject = testCmd({justUpdateSymlink: true});
+        subject.filepath = '/test/foo';
+        t.plan(1);
+        subject._stepVerifyFilepath({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('just symlink no filepath', function (t) {
+        const subject = testCmd({justUpdateSymlink: true});
+        t.plan(1);
+        subject._stepVerifyFilepath({}, function (err) {
+            t.type(err, Error);
+            t.done();
+        });
+    });
+
+    suite.done();
+});
+
+
+tap.test('UpdateAgents._stepHaveSharAlreadyFromLink', function (suite) {
+    suite.afterEach(mockfs.restore);
+
+    suite.test('shortcut', function (t) {
+        mockfs({'/usbkey/extra/agents/': {}});
+        const subject = testCmd();
+        subject.filepath = '/test/foo';
+        t.plan(1);
+        subject._stepHaveSharAlreadyFromLink({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('not a link', function (t) {
+        mockfs({'/usbkey/extra/agents/': {'latest': ''}});
+        const subject = testCmd();
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromLink({}, function (err) {
+            t.type(err, errors.UpdateError);
+            t.equal(VError.cause(err).code, 'EINVAL');
+            t.done();
+        });
+    });
+
+    suite.test('skip missing link', function (t) {
+        mockfs({'/usbkey/extra/agents/': {}});
+        const subject = testCmd();
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromLink({}, function (err) {
+            t.false(err);
+            t.false(subject.filepath);
+            t.done();
+        });
+    });
+
+    suite.test('good hash', function (t) {
+        const content = 'this is a fantastic image';
+        const hash = crypto.createHash('sha1').update(content).digest('hex');
+        const fname = 'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh';
+        mockfs({'/usbkey/extra/agents/':
+                {[fname]: content,
+                 'latest': mockfs.symlink({
+                     path: fname})
+                }});
+
+        const subject = testCmd();
+        subject.image = {files: [{sha1: hash}]};
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromLink({}, function (err) {
+            t.false(err);
+            t.equal(subject.filepath,
+                    path.resolve('/usbkey/extra/agents/', fname));
+            t.done();
+        });
+    });
+
+    suite.test('bad hash', function (t) {
+        const content = 'this is a fantastic image';
+        const hash = crypto.createHash('sha1').update('wrong!').digest('hex');
+        const fname = 'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh';
+        mockfs({'/usbkey/extra/agents/':
+                {[fname]: content,
+                 'latest': mockfs.symlink({
+                     path: fname})
+                }});
+
+        const subject = testCmd();
+        subject.image = {files: [{sha1: hash}]};
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromLink({}, function (err) {
+            t.false(err);
+            t.false(subject.filepath);
+            t.done();
+        });
+    });
+
+    suite.done();
+});
+
+
+tap.test('UpdateAgents._stepHaveSharAlreadyFromDownload', function (suite) {
+    suite.afterEach(mockfs.restore);
+
+    suite.test('shortcut', function (t) {
+        mockfs({'/usbkey/extra/agents/': {}});
+        const subject = testCmd();
+        subject.filepath = '/test/foo';
+        t.plan(1);
+        subject._stepHaveSharAlreadyFromDownload({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('does not exist', function (t) {
+        mockfs({'/var/tmp': {}});
+        const subject = testCmd();
+        subject.image = {uuid: 'ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749'};
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromDownload({}, function (err) {
+            t.false(err);
+            t.false(subject.filepath);
+            t.done();
+        });
+    });
+
+    suite.test('good hash', function (t) {
+        const content = 'high quality bits';
+        const hash = crypto.createHash('sha1').update(content).digest('hex');
+        const fname = 'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh';
+        mockfs({'/var/tmp': {[fname]: content}});
+        const subject = testCmd();
+        subject.image = {uuid: 'ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749',
+                     files: [{sha1: hash}]};
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromDownload({}, function (err) {
+            t.false(err);
+            t.equal(subject.filepath, path.resolve('/var/tmp/', fname));
+            t.done();
+        });
+    });
+
+    suite.test('bad hash', function (t) {
+        const content = 'high quality bits';
+        const hash = crypto.createHash('sha1').update('wrong!').digest('hex');
+        const fname = 'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh';
+        mockfs({'/var/tmp': {[fname]: content}});
+        const subject = testCmd();
+        subject.image = {uuid: 'ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749',
+                     files: [{sha1: hash}]};
+        t.plan(2);
+        subject._stepHaveSharAlreadyFromDownload({}, function (err) {
+            t.false(err);
+            t.false(subject.filepath);
+            t.done();
+        });
+    });
+
+    suite.done();
+});
+
+
+tap.test('UpdateAgents._stepCreateLatestSymlink', function (suite) {
+    suite.afterEach(mockfs.restore);
+
+    suite.test('shortcut: justDownload', function (t) {
+        mockfs({'/usbkey/extra/agents/': {}});
+        const subject = testCmd({justDownload: true});
+        t.plan(1);
+        subject._stepCreateLatestSymlink({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('shortcut: skipLatestSymlink', function (t) {
+        mockfs({'/usbkey/extra/agents/': {}});
+        const subject = testCmd({skipLatestSymlink: true});
+        t.plan(1);
+        subject._stepCreateLatestSymlink({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('silently ignore ENOENT', function (t) {
+        mockfs({'/usbkey/extra/agents/': {'new-agent.sh': ''}});
+        const subject = testCmd();
+        t.plan(2);
+        subject._stepCreateLatestSymlink(
+            {fname: 'new-agent.sh'}, function (err) {
+                t.false(err);
+                t.equals(fs.readlinkSync('/usbkey/extra/agents/latest'),
+                         'new-agent.sh');
+                t.done();
+            });
+    });
+
+    suite.test('existing symlink', function (t) {
+        mockfs({'/usbkey/extra/agents/': {
+            'old-agent.sh': '',
+            'new-agent.sh': '',
+            'latest': mockfs.symlink({path: 'old-agent.sh'})
+        }});
+        const subject = testCmd();
+        t.plan(2);
+        subject._stepCreateLatestSymlink(
+            {fname: 'new-agent.sh'}, function (err) {
+                t.false(err);
+                t.equals(fs.readlinkSync('/usbkey/extra/agents/latest'),
+                         'new-agent.sh');
+                t.done();
+            });
+    });
+
+
+    suite.done();
+});
+
+
+tap.test('UpdateAgents._stepDownloadAgentsshar', function (suite) {
+    suite.afterEach(mockfs.restore);
+
+    suite.test('shortcut', function (t) {
+        mockfs({'/usbkey/extra/agents/': {},
+                '/var/tmp': {}});
+        const subject = testCmd();
+        subject.filepath = '/test/foo';
+        t.plan(1);
+        subject._stepDownloadAgentsshar({}, function (err) {
+            t.false(err);
+            t.done();
+        });
+    });
+
+    suite.test('download', function (t) {
+        mockfs({'/usbkey/extra/agents/': {},
+                '/var/tmp': {}});
+        const subject = testCmd();
+        subject.image = {uuid: 'ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749'};
+        t.plan(2);
+        subject._stepDownloadAgentsshar({}, function (err) {
+            t.false(err);
+            t.ok(fs.existsSync(
+                '/var/tmp/agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh'));
+            t.done();
+        });
+    });
+
+    suite.done();
+});
diff --git a/test/unit/steps/usbkey.test.js b/test/unit/steps/usbkey.test.js
index 8d3426d..0bbf3d2 100644
--- a/test/unit/steps/usbkey.test.js
+++ b/test/unit/steps/usbkey.test.js
@@ -10,18 +10,21 @@
 'use strict';
 
 const fs = require('fs');
+const path = require('path');
 
 const mockfs = require('mock-fs');
 const tap = require('tap');
 
 const usbkey = require('../../../lib/steps/usbkey');
 
-const joysetupDir = '/usbkey/extra/joysetup/';
 
 tap.test('removeOldCNToolsTarballs', function (suite) {
+    const joysetupDir = '/usbkey/extra/joysetup/';
+    const progress = suite.comment;
+
     suite.test('empty', function (t) {
         mockfs({[joysetupDir]: {}});
-        usbkey.removeOldCNToolsTarballs({}, function () {
+        usbkey.removeOldCNToolsTarballs({progress: progress}, function () {
             const stats = fs.statSync(joysetupDir);
             t.ok(stats.isDirectory(joysetupDir));
             const files = fs.readdirSync(joysetupDir);
@@ -37,7 +40,7 @@ tap.test('removeOldCNToolsTarballs', function (suite) {
                  'joysetup.sh': '',
                  'agentsetup.sh': '',
                  'cn_tools.20180208T185323.tar.gz': ''}});
-        usbkey.removeOldCNToolsTarballs({}, function () {
+        usbkey.removeOldCNToolsTarballs({progress: progress}, function () {
             const files = fs.readdirSync(joysetupDir);
             t.ok(files.length === 4);
             mockfs.restore();
@@ -84,7 +87,7 @@ tap.test('removeOldCNToolsTarballs', function (suite) {
                 fakeFiles[fname] = '';
             }
             mockfs({[joysetupDir]: fakeFiles});
-            usbkey.removeOldCNToolsTarballs({}, function () {
+            usbkey.removeOldCNToolsTarballs({progress: progress}, function () {
                 checkRemoved(tt);
             });
         });
@@ -95,7 +98,7 @@ tap.test('removeOldCNToolsTarballs', function (suite) {
                 fakeFiles[fname] = '';
             }
             mockfs({[joysetupDir]: fakeFiles});
-            usbkey.removeOldCNToolsTarballs({}, function () {
+            usbkey.removeOldCNToolsTarballs({progress: progress}, function () {
                 checkRemoved(tt);
             });
         });
@@ -105,3 +108,111 @@ tap.test('removeOldCNToolsTarballs', function (suite) {
 
     suite.end();
 });
+
+
+tap.test('removeOldAgentsShars', function (suite) {
+    const agentsDir = '/usbkey/extra/agents/';
+    const progress = suite.comment;
+    suite.afterEach(mockfs.restore);
+
+    const fakeAgentsFiles = {
+        'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh': mockfs.file({
+            content: '',
+            mtime: new Date(2018, 6, 25, 20, 47)}),
+        'agent-fc6847e2-6f0b-4282-bf19-1d5448ef4a20.sh': mockfs.file({
+            content: '',
+            mtime: new Date(2018, 6, 22, 18, 29)}),
+        'agents-release-20180510-20180510t044437z-g707200f.sh': mockfs.file({
+            content: '',
+            mtime: new Date(2018, 5, 21, 18, 43)})
+    };
+    const moreFakeAgentFiles = {
+        'agent-8404446e-31bf-4b5f-ba31-2cebe725f61f.sh': mockfs.file({
+            content: '',
+            mtime: new Date(2018, 6, 27, 18, 40)}),
+        'agents-e7264c70-21b4-4f27-a13e-450265954645.sh': mockfs.file({
+            content: '',
+            mtime: new Date(2018, 7, 3, 20, 11)})
+    };
+
+    suite.test('empty', function (t) {
+        mockfs({[agentsDir]: {}});
+        t.plan(2);
+        usbkey.removeOldAgentsShars({progress: progress}, function (err) {
+            t.false(err);
+            t.ok(fs.existsSync(agentsDir));
+            t.done();
+        });
+    });
+
+    suite.test('too few to prune', function (t) {
+        const fakeFs = {[agentsDir]: fakeAgentsFiles};
+        fakeFs[agentsDir]['latest'] = mockfs.symlink({
+            path: 'agent-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh'});
+        mockfs(fakeFs);
+        t.plan(2);
+        usbkey.removeOldAgentsShars({progress: progress}, function (err) {
+            t.false(err);
+            t.equal(fs.readdirSync(agentsDir).length, 4);
+            t.done();
+        });
+    });
+
+    suite.test('prune', function (t) {
+        const fakeFs = {[agentsDir]:
+                        Object.assign({}, fakeAgentsFiles, moreFakeAgentFiles)};
+        fakeFs[agentsDir]['latest'] = mockfs.symlink({
+            path: 'agents-e7264c70-21b4-4f27-a13e-450265954645'});
+        mockfs(fakeFs);
+        t.plan(5);
+        usbkey.removeOldAgentsShars({progress: progress}, function (err) {
+            t.false(err);
+            t.equal(fs.readdirSync(agentsDir).length, 4);
+            t.ok(fs.existsSync(
+                path.resolve(
+                    agentsDir,
+                    'agents-e7264c70-21b4-4f27-a13e-450265954645.sh')));
+            t.ok(fs.existsSync(
+                path.resolve(agentsDir,
+                             'agent-8404446e-31bf-4b5f-ba31-2cebe725f61f.sh')));
+            t.ok(fs.existsSync(
+                path.resolve(
+                    agentsDir,
+                    'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh')));
+            t.done();
+        });
+    });
+
+    suite.test('prune when eldest is latest', function (t) {
+        const fakeFs = {[agentsDir]:
+                        Object.assign({}, fakeAgentsFiles, moreFakeAgentFiles)};
+        fakeFs[agentsDir]['latest'] = mockfs.symlink({
+            path: 'agents-release-20180510-20180510t044437z-g707200f.sh'});
+        mockfs(fakeFs);
+        t.plan(6);
+        usbkey.removeOldAgentsShars({progress: progress}, function (err) {
+            t.false(err);
+            // Here we end up keeping one more file": "latest, the 3 most recent
+            // by mtime, and the file that "latest" points to.
+            t.equal(fs.readdirSync(agentsDir).length, 5);
+            t.ok(fs.existsSync(
+                path.resolve(
+                    agentsDir,
+                    'agents-release-20180510-20180510t044437z-g707200f.sh')));
+            t.ok(fs.existsSync(
+                path.resolve(
+                    agentsDir,
+                    'agents-e7264c70-21b4-4f27-a13e-450265954645.sh')));
+            t.ok(fs.existsSync(
+                path.resolve(agentsDir,
+                             'agent-8404446e-31bf-4b5f-ba31-2cebe725f61f.sh')));
+            t.ok(fs.existsSync(
+                path.resolve(
+                    agentsDir,
+                    'agents-ebc7b8c2-8b3a-409b-b2d9-3c23f0e2b749.sh')));
+            t.done();
+        });
+    });
+
+    suite.end();
+});
diff --git a/test/unit/testutil.js b/test/unit/testutil.js
new file mode 100644
index 0000000..658c498
--- /dev/null
+++ b/test/unit/testutil.js
@@ -0,0 +1,31 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+'use strict';
+
+const bunyan = require('bunyan');
+
+function TestCommentStream(test) {
+    this.test = test;
+}
+
+TestCommentStream.prototype.write = function write(rec) {
+    this.test.comment(rec);
+};
+
+function createBunyanLogger(test) {
+    return bunyan.createLogger(
+        {name: 'unit',
+         streams: [{type: 'raw',
+                    stream: new TestCommentStream(test)}]});
+}
+
+module.exports = {
+    createBunyanLogger: createBunyanLogger
+};
