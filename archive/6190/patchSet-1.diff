From faa6188c1448528fc39d7365eb65ae623a0ec56a Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Thu, 2 May 2019 16:19:53 -0700
Subject: [PATCH] OS-7749 zoneadm uninstall is too slow for vminfod's timeout

---
 src/vm/man/vmadm.1m.md                |   3 +-
 src/vm/node_modules/VM.js             | 222 ++++-----
 src/vm/node_modules/vminfod/client.js | 648 +++++++++++++++++++++++++-
 src/vm/sbin/vmadm.js                  |   4 +-
 4 files changed, 740 insertions(+), 137 deletions(-)

diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index 72b030fa..f5c04c81 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -94,7 +94,7 @@ tab-complete UUIDs rather than having to type them out for every command.
         See the 'SNAPSHOTS' section below for some more details on how to use
         these snapshots, and their restrictions.
 
-      events [-fjr] [uuid]
+      events [-fjr] [<uuid>]
 
         Output events seen for a given VM (all VMs on the system if the uuid
         argument is omitted).  The command will run indefinitely outputting a
@@ -2745,4 +2745,3 @@ Some of the vmadm commands depend on the vmadmd(1M) service:
 If the vmadmd service is stopped while the vmadm utility is running, the vmadm
 command behaviour will be undefined. Additionally if the service is not
 running, some commands will be unavailable.
-
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index f8431444..fccd36b7 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -20,8 +20,10 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2019, Joyent, Inc.
- *
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
  * Experimental functions, expect these interfaces to be unstable and
  * potentially go away entirely:
  *
@@ -11879,7 +11881,7 @@ function deleteZone(uuid, log, callback)
 {
     var tracers_obj;
     var vmobj;
-    var vs;
+    var vmWatcher;
 
     assert(log, 'no logger passed to deleteZone()');
 
@@ -11889,25 +11891,28 @@ function deleteZone(uuid, log, callback)
         log = tracers_obj.log;
     }
 
-    async.series([
-        function (cb) {
-            vs = new vminfod.VminfodEventStream({
-                name: sprintf('VM.js deleteZone (%s)', uuid),
-                parseReady: true,
-                log: log
-            });
-
-            vs.once('ready', function (ready_ev) {
-                try {
-                    vmobj = vminfodEventGetVM(uuid, ready_ev);
-                } catch (e) {
-                    cb(e);
-                    return;
+    vasync.pipeline({funcs: [
+        function getVmWatcher(_, cb) {
+            vminfod.createVmWatcher({
+                log: log,
+                zonename: uuid,
+                clientName: sprintf('VM.js deleteZone (%s)', uuid),
+                obtainVm: true
+            }, function (err, watcher, vm) {
+                if (err) {
+                    cb(err);
+                } else {
+                    vmWatcher = watcher;
+                    if (!vm) {
+                        cb(createVmNotFoundError(uuid));
+                    } else {
+                        vmobj = vm;
+                        cb();
+                    }
                 }
-
-                cb();
             });
-        }, function (cb) {
+        },
+        function guardIndestructible(_, cb) {
             if (vmobj.indestructible_zoneroot) {
                 cb(new Error('indestructible_zoneroot is set, cannot delete'));
             } else if (vmobj.indestructible_delegated) {
@@ -11915,7 +11920,7 @@ function deleteZone(uuid, log, callback)
             } else {
                 cb();
             }
-        }, function (cb) {
+        }, function guardSharedVolumesInUse(_, cb) {
             var data_prefix;
             var data_volumes = [];
 
@@ -12003,7 +12008,7 @@ function deleteZone(uuid, log, callback)
                     + JSON.stringify(volume_users)));
             });
         // TODO: replace these next two with VM.stop(..{force: true} ?
-        }, function (cb) {
+        }, function setAutobootFalse(_, cb) {
             log.debug('setting autoboot=false');
             zonecfg(uuid, ['set autoboot=false'], {log: log},
                 function (e, fds) {
@@ -12017,7 +12022,7 @@ function deleteZone(uuid, log, callback)
                 }
                 cb();
             });
-        }, function (cb) {
+        }, function haltTheZone(_, cb) {
             log.debug('halting zone');
             zoneadm(['-u', uuid, 'halt', '-X'], log,
                 function (e, fds) {
@@ -12031,7 +12036,7 @@ function deleteZone(uuid, log, callback)
                 }
                 cb();
             });
-        }, function (cb) {
+        }, function maybeArchiveTheVm(_, cb) {
             log.debug('archive_on_delete is set to '
                 + !!vmobj.archive_on_delete);
             if (!vmobj.archive_on_delete) {
@@ -12041,63 +12046,44 @@ function deleteZone(uuid, log, callback)
             archiveVM(vmobj.uuid, log, function () {
                 cb();
             });
-        }, function (cb) {
-            var cancelFn;
-
-            vasync.parallel({funcs: [
-                function (cb2) {
-                    var obj = {
-                        uuid: uuid
-                    };
-                    var changes = [
-                        {
-                            path: ['zone_state'],
-                            action: 'changed',
-                            newValue: 'configured'
-                        },
-                        {
-                            path: ['zfs_filesystem'],
-                            action: 'removed'
-                        },
-                        {
-                            path: ['zpool'],
-                            action: 'removed'
-                        }
-                    ];
-                    var opts = {
-                        timeout: VMINFOD_TIMEOUT,
-                        catchErrors: true,
-                        startFresh: true
-                    };
-
-                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
-                }, function (cb2) {
-                    log.debug('uninstalling zone');
-                    zoneadm(['-u', uuid, 'uninstall', '-F'], log,
-                        function (e, fds) {
-
-                        if (e) {
-                            log.warn({err: e, stdout: fds.stdout,
-                                stderr: fds.stderr},
-                                'Error uninstalling zone: %s', e.message);
-                            cancelFn();
-                        } else {
-                            log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                                'uninstalled zone');
-                        }
+        },
+        function zoneadmUninstall(_, cb) {
+            vmWatcher.startWatch({
+                changes: [
+                    {
+                        path: ['zone_state'],
+                        action: 'changed',
+                        newValue: 'configured'
+                    },
+                    {
+                        path: ['zfs_filesystem'],
+                        action: 'removed'
+                    },
+                    {
+                        path: ['zpool'],
+                        action: 'removed'
+                    }
+                ]
+            });
 
-                        cb2();
-                    });
-                }]
-            }, function (err, res) {
+            log.debug('uninstalling zone');
+            zoneadm(['-u', uuid, 'uninstall', '-F'], log, function (err, fds) {
                 if (err) {
-                    cb(err);
-                    return;
+                    // Here we are assuming we have hit the following:
+                    //   zoneadm: zone '$uuid': is already in state 'configured'
+                    // We want to continue deleting the zone, so log and
+                    // move on.
+                    log.warn({err: err, stdout: fds.stdout, stderr: fds.stderr},
+                        'Error uninstalling zone: %s', err.message);
+                    cb();
+                } else {
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'uninstalled zone');
+                    vmWatcher.wait({timeout: 5 * 1000}, cb);
                 }
-
-                cb();
             });
-        }, function (cb) {
+        },
+        function deleteAnyVolumes(_, cb) {
             function _loggedDeleteVolume(volume, callbk) {
                 return deleteVolume(volume, log, callbk);
             }
@@ -12120,57 +12106,33 @@ function deleteZone(uuid, log, callback)
                     + vmobj.uuid);
                 cb();
             }
-        }, function (cb) {
+        }, function zonecfgDelete(_, cb) {
             if (!vmobj.zonename) {
                 cb();
                 return;
             }
 
-            var cancelFn;
-
-            vasync.parallel({funcs: [
-                function (cb2) {
-                    // block on vminfod event
-                    var obj = {
-                        type: 'delete',
-                        uuid: uuid
-                    };
-                    var opts = {
-                        timeout: VMINFOD_TIMEOUT,
-                        catchErrors: true,
-                        startFresh: true
-                    };
-
-                    cancelFn = vs.watchForEvent(obj, opts, cb2);
-                }, function (cb2) {
-                    log.debug('deleting zone');
-                    zonecfg(uuid, ['delete', '-F'],
-                        {log: log},
-                        function (e, fds) {
-
-                        if (e) {
-                            log.warn({err: e, stdout: fds.stdout,
-                                stderr: fds.stderr},
-                                'Error deleting VM');
-                            cancelFn();
-                            cb2(e);
-                            return;
-                        }
+            vmWatcher.clearWatch();
+            vmWatcher.startWatch({
+                events: [
+                    {
+                        type: 'delete'
+                    }
+                ]
+            });
 
-                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                            'deleted VM %s', uuid);
-                        cb2();
-                    });
-                }]
-            }, function (err, res) {
-                if (err) {
-                    cb(err);
-                    return;
+            log.debug('deleting zone');
+            zonecfg(uuid, ['delete', '-F'], {log: log}, function (err, fds) {
+                if (!err) {
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'deleted VM %s', uuid);
                 }
-
-                cb();
+                cb(err);
             });
-        }, function (cb) {
+        }, function zonecfgDeleteEventWait(_, cb) {
+            vmWatcher.wait({timeout: 5 * 1000}, cb);
+        },
+        function removePotentialReceivingFile(_, cb) {
             // delete the incoming payload if it exists
             fs.unlink('/etc/zones/' + vmobj.uuid + '-receiving.json',
                 function (e) {
@@ -12183,12 +12145,11 @@ function deleteZone(uuid, log, callback)
                 }
             );
         }
-    ], function (error) {
-        if (vs) {
-            vs.stop();
-            vs = null;
+    ]}, function finish(err) {
+        if (vmWatcher) {
+            vmWatcher.close();
         }
-        callback(error);
+        callback(err);
     });
 }
 
@@ -18630,20 +18591,23 @@ function deepEqual(a, b) {
     }
 }
 
+function createVmNotFoundError(uuid) {
+    var err = new Error(sprintf('VM %s not found', uuid));
+    err.code = 'ENOENT';
+    return err;
+}
+
 function vminfodEventGetVM(uuid, ready_ev) {
     assert.uuid(uuid, 'uuid');
     assert.object(ready_ev, 'ready_ev');
     assert.object(ready_ev.vms, 'ready_ev.vms (parseReady must be enabled)');
 
-    var err;
     var vmobj;
 
     vmobj = ready_ev.vms[uuid];
 
     if (!vmobj) {
-        err = new Error(sprintf('VM %s not found', uuid));
-        err.code = 'ENOENT';
-        throw err;
+        throw createVmNotFoundError(uuid);
     }
 
     assert.object(vmobj, 'vmobj');
diff --git a/src/vm/node_modules/vminfod/client.js b/src/vm/node_modules/vminfod/client.js
index 23616817..d699639c 100644
--- a/src/vm/node_modules/vminfod/client.js
+++ b/src/vm/node_modules/vminfod/client.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  */
 
@@ -61,7 +61,7 @@
  *     }
  * });
  *
- * // or instead, call a convenince function
+ * // or instead, call a convenience function
  *
  * - VminfodEventStream#watchForEvent(obj, opts, cb)
  *
@@ -130,7 +130,7 @@
  * effectively.  Under the hood, a VminfodEventStream will be created and used
  * to manage an internal object of all VMs that vminfod is aware of.  This way,
  * the internal object is kept up to date by getting notified of any changes
- * from the vminfod service.  For Example:
+ * from the vminfod service.  For example:
  *
  * var vw = new require('vminfod/client').VminfodWatcher();
  *
@@ -139,7 +139,7 @@
  *     var vms = vw.vms();
  *     // vms[<uuid>] == vmobj
  *
- *     var vmobj = vw.vm('uuid');
+ *     var vmobj = vw.vm('<uuid>');
  *     // vmobj is an object, or undefined if it is not found
  * });
  *
@@ -181,6 +181,7 @@ var DEFAULT_READY_TIMEOUT = 30 * 1000;
 module.exports.VminfodClient = VminfodClient;
 module.exports.VminfodEventStream = VminfodEventStream;
 module.exports.VminfodWatcher = VminfodWatcher;
+module.exports.createVmWatcher = createVmWatcher;
 
 var log = bunyan.createLogger({
     level: 'debug',
@@ -1093,6 +1094,645 @@ VminfodWatcher.prototype.stop = function vminfodWatcherStop() {
     self.vw_vs.stop();
 };
 
+
+
+
+/*
+ * A VmWatcher is a convenience wrapper around `VminfodEventStream` to
+ * wait on one or more vminfod events on a single VM. The typical use case is:
+ *
+ * - create a VmWatcher for VM $ZONENAME to start watching for relevant events
+ *   (or event "changes")
+ * - do some action on the VM
+ * - wait for the given events (with a given timeout)
+ * - cleanup
+ *
+ * In code that can look like:
+ *
+ *      // Example values.
+ *      var ZONENAME = 'c6c56fca-6ab6-11e9-bbbb-7f35c0181c27';
+ *      var CHANGES = [
+ *          { path: ['zone_state'], action: 'changed', newValue: 'configured' },
+ *          { path: ['zfs_filesystem'], action: 'removed' },
+ *          { path: ['zpool'], action: 'removed' }
+ *      ];
+ *      var TIMEOUT = 5 * 1000;
+ *
+ *      var vmObj;
+ *      var vmWatcher;
+ *      vasync.pipeline({funcs: [
+ *          function startWatchingForEvents(_, next) {
+ *              vminfod.createVmWatcher({
+ *                  log: log,
+ *                  zonename: ZONENAME,
+ *                  // Optionally determine if should get the initial VM obj.
+ *                  obtainVm: true,
+ *                  // Pass in "events" and/or modify event "changes" to start
+ *                  // watching for. Alternatively, one can separately call
+ *                  // `vmWatcher.startWatch(...)`.
+ *                  changes: CHANGES
+ *              }, function (err, watcher, vm) {
+ *                  // This returns a watcher when the underlying event
+ *                  // stream is "ready".
+ *                  vmWatcher = watcher;
+ *                  vmObj = vm;
+ *                  next(err);
+ *              );
+ *          },
+ *
+ *          function doTheAction(_, next) {
+ *              // Example action:
+ *              zoneadm(['-u', ZONENAME, 'uninstall', '-F'], function (err) {
+ *                  if (err) {
+ *                      next(err);
+ *                  }
+ *                  // ...
+ *              });
+ *          },
+ *
+ *          function waitForTheEvents(_, next) {
+ *              vmWatcher.wait({timeout: TIMEOUT}, function (err) {
+ *                  next(err);
+ *              });
+ *          }
+ *      ]}, function doneActionAndWatch(err) {
+ *          vmWatcher.close();
+ *          cb(err);
+ *      });
+ *
+ * `vminfod.createVmWatcher` will create a vminfo event stream, wait for it
+ * to be ready, then start watching for given events and/or event changes.
+ * This does *not yet block* waiting for those events. Typically some action
+ * is then performed on the VM. Only *then* do we start waiting for the
+ * expected vminfod events (via `vmWatcher.wait()`).
+ *
+ * There is an advantage, over prior approaches, in waiting to start the timeout
+ * after the VM action is complete. On very slow or overloaded servers the
+ * VM action could take longer than the timeout. This convolved two concepts:
+ * a timeout (if one is wanted) for the VM action and a timeout waiting to
+ * ensure vminfod was up to date before returning.
+ *
+ * A `VmWatcher` instance may be re-used to watch for subsequent events/changes
+ * by calling `clearWatch()` and then `startWatch(...)` again.
+ *
+ * @param {String} zonename - The VM zonename (a UUID).
+ * @param {Object} log - A bunyan logger object.
+ * @param {String} clientName - Optional. A string to identify the caller
+ *      (a la HTTP user-agent). This is used for logging and error messages.
+ * @param {Boolean} obtainVm - Optional, default false. Whether to obtain the
+ *      initial vm object.
+ * @param {Array} events - Optional. An array of event patterns to start
+ *      watching for immediately. See `eventPatternMatch()` for details.
+ * @param {Array} changes - Optional. An array of event change patterns to start
+ *      watching for immediately. See `eventChangePatternMatch()` for details.
+ * @param {Function} cb - Callback `function (err, vmWatcher)`. This calls back
+ *      either on error, or when the vminfod event stream is ready (i.e. has
+ *      responded with its "ready" event).
+ */
+function createVmWatcher(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.zonename, 'opts.zonename');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.clientName, 'opts.clientName');
+    assert.optionalBool(opts.obtainVm, 'opts.obtainVm');
+    assert.optionalArrayOfObject(opts.events, 'opts.events');
+    assert.optionalArrayOfObject(opts.changes, 'opts.changes');
+    assert.func(cb, 'cb');
+
+    var calledBack = false;
+    var watcher = new VmWatcher({
+        zonename: opts.zonename,
+        log: opts.log,
+        clientName: opts.clientName,
+        obtainVm: opts.obtainVm
+    });
+
+    // This `vmObj` is only non-null if obtainVm=true and the VM exists.
+    watcher.once('ready', function onReady(vmObj) {
+        if (opts.events || opts.changes) {
+            watcher.startWatch({
+                events: opts.events,
+                changes: opts.changes
+            });
+        }
+        if (!calledBack) {
+            calledBack = true;
+            cb(null, watcher, vmObj);
+        }
+    });
+
+    // Handle an error before the 'ready' event.
+    watcher.once('error', function onError(err) {
+        if (!calledBack) {
+            calledBack = true;
+            cb(err);
+        }
+    });
+}
+
+function VmWatcher(opts) {
+    var self = this;
+
+    assert.ok(self instanceof VmWatcher, 'must be called with "new"');
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.zonename, 'opts.zonename');
+    assert.optionalString(opts.clientName, 'opts.clientName');
+    assert.optionalBool(opts.obtainVm, 'opts.obtainVm');
+
+    self.zonename = opts.zonename;
+    self.clientName = opts.clientName || opts.log.fields.name;
+    self.log = opts.log.child({client: opts.clientName}, true);
+    self._vsErr = null;
+
+    self.clearWatch();
+
+    self.vs = new VminfodEventStream({
+        log: self.log,
+        name: self.clientName,
+
+        // Dev Note:
+        //
+        // A reasonably common use case of VmWatcher is to want the current VM
+        // object. To support this, we use the available "ready" event from
+        // VminfodEventStream. However, this isn't a great design.
+        //
+        // The vminfod "GET /events" endpoint starts with a "ready" event that
+        // includes the VM object for *all* VMs. As well, with current vminfod
+        // that "event.vms" is a double-stringified structure that must be
+        // parsed again. On nightly (admitted slow) hardware, with only 30 VMs,
+        // this takes up to 1-2ms to parse.
+        //
+        // It would be more appropriate to have this not be O(number of VMs)
+        // somehow, whether that is via "GET /events?zonename=$zonename" that
+        // scopes to a single VM; or a "ready" event that does not include all
+        // this data and the client separately calls "GET /vm/$zonename"; or
+        // something else.
+        parseReady: opts.obtainVm
+    });
+
+    self.vs.once('ready', function onVsReady(readyEv) {
+        var vmObj = null;
+        if (opts.obtainVm) {
+            vmObj = readyEv.vms[opts.zonename] || null;
+        }
+        self.emit('ready', vmObj);
+    });
+
+    // Error handling: If there is an error on the vminfod event stream we
+    // want to:
+    // - error out any current waiters
+    // - save the error to return on any subsequent `.wait()` calls
+    self.vs.on('error', function onVsError(err) {
+        self._vsErr = err;
+        if (self._waiters) {
+            self._waiters.forEach(function oneWaiter(waiter) {
+                waiter.finish(self._vsErr);
+                clearTimeout(waiter.timeout);
+            });
+            self._waiters = null;
+        }
+        self.emit('error', err);
+    });
+
+    self.vs.on('readable', function onVsReadable() {
+        var ev;
+        while ((ev = self.vs.read())) {
+            self._handleEvent(ev);
+        }
+    });
+}
+util.inherits(VmWatcher, EventEmitter);
+
+
+/*
+ * Clear a current "watch" (as started by `startWatch()`). This must be called
+ * before re-calling `<vmWatcher>.startWatch()` to re-use a VmWatcher.
+ */
+VmWatcher.prototype.clearWatch = function vmWatcherClearWatch() {
+    var self = this;
+    self._watching = false;
+    self._eventPatterns = null;
+    self._changePatterns = null;
+    self._unusedEvents = null;
+    self._waiters = null;
+};
+
+
+/*
+ * Start a "watch" -- i.e. start watching for the given event patterns or
+ * event change patterns on the vminfod event stream for this VM.
+ *
+ * The watch is "complete" when all patterns have been matched by an event.
+ * When watching incoming events, only a *single* event pattern or event change
+ * pattern will be matched per event. This allows watching for duplicate
+ * events, by specifying the pattern multiple times.
+ *
+ * @param {Array} events - Optional. An array of event patterns to start
+ *      watching for immediately. See `eventPatternMatch()` for details.
+ * @param {Array} changes - Optional. An array of event change patterns to start
+ *      watching for immediately. See `eventChangePatternMatch()` for details.
+ */
+VmWatcher.prototype.startWatch = function vmWatcherStartWatch(opts) {
+    assert.object(opts, 'opts');
+    assert.ok(opts.events || opts.changes,
+        'must specify at least one of opts.events or opts.changes');
+    assert.optionalArrayOfObject(opts.events, 'opts.events');
+    // Validate change patterns.
+    if (opts.changes) {
+        var validateChangePatternObj = function (chPatObj) {
+            assert.array(chPatObj.path, '<change pattern object>.path');
+            assert.ok(Object.keys(chPatObj).length > 1,
+                '<change pattern object> must have a "path" and at least '
+                + 'one additional field');
+        };
+        opts.changes.forEach(function validateChangePattern(chPat) {
+            if (Array.isArray(chPat)) {
+                chPat.forEach(validateChangePatternObj);
+            } else {
+                validateChangePatternObj(chPat);
+            }
+        });
+    }
+
+    var self = this;
+    assert.equal(self._watching, false,
+        'cannot <VmWatcher>.startWatch() when already watching, '
+        + 'call <VmWatcher>.clearWatch() to clear');
+    self._watching = true;
+
+    // Note: We aren't doing a deep copy here, so these individual pattern
+    // object *could* be changed by the caller.
+    self._eventPatterns = opts.events ? opts.events.slice() : [];
+    self._changePatterns = opts.changes ? opts.changes.slice() : [];
+
+    self.log.debug({eventPatterns: self._eventPatterns,
+        changePatterns: self._changePatterns}, 'VmWatcher.startWatch');
+
+    // In case it is useful for debugging, we retain a list of events for
+    // this VM that did not match against watch "events" and "changes". This
+    // is included in logging on `.wait()` timeout errors.
+    self._unusedEvents = [];
+
+    // Array of `{onFinish: <function>, timeout: <timeout handle>}` for each
+    // call to `.wait()`.
+    self._waiters = [];
+};
+
+
+/*
+ * Wait for the current watch to be complete. I.e., block until incoming events
+ * on the vminfod event stream have matched all given event and event change
+ * patterns.
+ *
+ * If the events have already been observed between the time `startWatch`
+ * and this `wait` are called, then this will call back immediately (in the
+ * next tick).
+ *
+ * @param {Number} opts.timeout - A number of milliseconds after which to
+ *      timeout.
+ * @param {Function} cb - callback with signature `function (err)`. On timeout,
+ *      `err` is set to a new Error object with `err.code = 'ETIMEOUT'`.
+ *      Otherwise, `err` is `null`.
+ */
+VmWatcher.prototype.wait = function vmWatcherWait(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.finite(opts.timeout, 'opts.timeout'); // in milliseconds
+    assert.func(cb, 'cb');
+
+    var onFinish;
+    var onTimeout;
+    var self = this;
+    var start = process.hrtime();
+    var waiter;
+
+    assert.ok(self._watching,
+        'called <VmWatcher>.wait() before <VmWatcher>.startWatch() was called');
+
+    onFinish = function (err) {
+        var elapsed = hrtime.hrtimeDelta(process.hrtime(), start);
+        var waitTime = elapsed[0] + elapsed[1]/1e9;
+        self.log.debug({err: err, waitTime: waitTime}, 'VmWatcher.wait finish');
+        cb(err);
+    };
+    onTimeout = function () {
+        // Remove this waiter from `self._waiters`, so its `onFinish` isn't
+        // called if the watched events come in later.
+        for (var i = 0; i < self._waiters.length; i++) {
+            if (self._waiters[i] === waiter) {
+                self._waiters.splice(i, 1);
+                break;
+            }
+        }
+
+        // Callback with an ETIMEOUT error.
+        var msg = f('vminfod.VmWatcher "%s" wait timeout exceeded',
+            self.clientName);
+        var err = new Error(msg);
+        err.code = 'ETIMEOUT';
+        self.log.debug({
+            err: err,
+            waitTime: opts.timeout / 1000,
+            remainingEvents: self._eventPatterns,
+            remainingChanges: self._changePatterns,
+            unusedEvents: self._unusedEvents
+        }, 'VmWatcher.wait timeout');
+        cb(err);
+    };
+
+
+    // Error immediately if there was an earlier event stream error.
+    if (self._vsErr) {
+        onFinish(self._vsErr);
+        return;
+    }
+
+    // Quick out if no unmatched events.
+    if (self._eventPatterns.length === 0 && self._changePatterns.length === 0) {
+        setImmediate(function noNeedToWait() {
+            onFinish(null);
+        });
+        return;
+    }
+
+    waiter = {
+        finish: onFinish,
+        timeout: setTimeout(onTimeout, opts.timeout)
+    };
+    self._waiters.push(waiter);
+};
+
+VmWatcher.prototype.close = function vmWatcherClose() {
+    // Clear any waiters timeouts.
+    var self = this;
+    if (self._waiters) {
+        for (var i = 0; i < self._waiters.length; i++) {
+            clearTimeout(self._waiters[i].timeout);
+        }
+        self._waiters = null;
+    }
+
+    this.vs.stop();
+};
+
+
+/*
+ * Determine if the vminfod `event` matches the event `pattern`.
+ *
+ * A vminfod event looks like this:
+ *      {
+ *        // `type` is "create", "delete", or "modify" (see vminfod.js)
+ *        "type": "modify",
+ *        "date": "2019-04-29T22:40:11.787Z",
+ *        "zonename": "16ae8c35-00e3-c322-bae5-92002c12b763",
+ *        "uuid": "16ae8c35-00e3-c322-bae5-92002c12b763",
+ *        "vm": {
+ *          // the full VM object, as from `vmadm get`.
+ *          "zonename": "16ae8c35-00e3-c322-bae5-92002c12b763",
+ *          "quota": 25,
+ *          "brand": "lx",
+ *          ...
+ *        },
+ *        // Events of type "modify" have this "changes" array. See
+ *        // `eventChangePatternMatch()` to match "changes" entries.
+ *        "changes": [
+ *          {
+ *            "prettyPath": "zone_state",
+ *            "path": [
+ *              "zone_state"
+ *            ],
+ *            "action": "changed",
+ *            "oldValue": "installed",
+ *            "newValue": "ready"
+ *          },
+ *          ...
+ *        ]
+ *      }
+ *
+ * An "event pattern" is an object of the same form as an event, that is
+ * matched field-by-field for equality. Examples that would match above.
+ *
+ *      {"type": "modify"}
+ *      {"type": "modify", "vm": {"brand": "lx"}}
+ *
+ * @returns {Boolean} `true` if it matches, `false` if not.
+ */
+function eventPatternMatch(event, pattern) {
+    return objSameValues(pattern, event);
+}
+
+/*
+ * Determine if the vminfod `event` "changes" entry, `change`, matches the given
+ * event change `pattern`.
+ *
+ * See `eventPatternMatch` above for an example of a full vminfod event object.
+ * A `change` is one of the object entries in the `event.changes` array. E.g.:
+ *
+ *          {
+ *            "prettyPath": "zone_state",
+ *            "path": [
+ *              "zone_state"
+ *            ],
+ *            "action": "changed",
+ *            "oldValue": "installed",
+ *            "newValue": "ready"
+ *          }
+ *
+ * another example:
+ *
+ *          {
+ *            "prettyPath": "dobjs.snapshots.zones/ffe...bad/data/manatee.*",
+ *            "path": [
+ *              "dobjs",
+ *              "snapshots",
+ *              "zones/ffe...bad/data/manatee",
+ *              null
+ *            ],
+ *            "action": "added",
+ *            "newValue": {
+ *              "snapname": "1556731621350",
+ *              "dataset": "zones/ffe...bad/data/manatee",
+ *              "created_at": 1556731621,
+ *              "size": 1860768
+ *            }
+ *          }
+ *
+ *
+ * A "change pattern" is either:
+ * (a) an object with a "path" field and at least one other, for example:
+ *
+ *          {
+ *              path: ['zone_state'],
+ *              action: 'changed',
+ *              newValue: 'ready'
+ *          }
+ *
+ *     another example:
+ *
+ *          {
+ *              path: ['disks', null, 'missing'],
+ *              action: 'removed'
+ *          }
+ *
+ * (b) or, an array of such objects, e.g.:
+ *
+ *          [
+ *              {
+ *                  path: ['state'],
+ *                  action: 'changed',
+ *                  newValue: 'running'
+ *              },
+ *              {
+ *                  path: ['state'],
+ *                  action: 'changed',
+ *                  newValue: 'stopped'
+ *              }
+ *          ]
+ *
+ *
+ * A change pattern object is matched against a change by checking each field
+ * for equality. However, the "path" field is required and has special case
+ * matching. A "path" is an array of strings or `null` values. A `null` value
+ * in the array matches any value:
+ *     `['disks', null, 'missing']` matches `['disks', 'foo', 'missing']`
+ *
+ * A change pattern *array* matches a change object if *any of its pattern
+ * object entries* match the change object.
+ *
+ * Typically the "prettyPath" field is *not* used for matching. The "path"
+ * field is required and is the more appropriate field to use. See the
+ * "../diff.js" file for details on the change object format.
+ *
+ * @returns {Boolean} `true` if it matches, `false` if not.
+ */
+function eventChangePatternMatch(change, pattern) {
+    assert.object(change, 'change');
+
+    var i;
+    var patternObjMatch = function (patternObj) {
+        assert.object(patternObj, 'patternObj');
+        assert.array(patternObj.path, 'patternObj.path');
+
+        var chPath = change.path;
+        var j;
+        var patPath = patternObj.path;
+        var match;
+
+        // Special case "path" field.
+        if (patPath.length !== chPath.length) {
+            return false;
+        }
+        for (j = 0; j < patPath.length; j++) {
+            if (!(patPath[j] === chPath[j] || patPath[j] === null)) {
+                return false;
+            }
+        }
+
+        // Compare the rest of the fields.
+        //
+        // We temporarily delete/re-add the "path" field so we can more
+        // easily use the generic `objSameValues()` without having to copy
+        // objects.
+        delete patternObj.path;
+        match = objSameValues(patternObj, change);
+        patternObj.path = patPath;
+
+        return match;
+    };
+
+
+    if (Array.isArray(pattern)) {
+        // Logical OR: if any of the pattern objects match, then return true.
+        for (i = 0; i < pattern.length; i++) {
+            if (patternObjMatch(pattern[i])) {
+                return true;
+            }
+        }
+        return false;
+    } else {
+        return patternObjMatch(pattern);
+    }
+}
+
+VmWatcher.prototype._handleEvent = function _vmWatcherHandleEvent(event) {
+    // Attempt to match the new event to `self._eventPatterns` and
+    // `self._changePatterns`. If both those arrays go empty, then notify
+    // any `self._waiters`. We consume at most one pattern per event/change,
+    // to allow matching duplicate events/changes.
+
+    var ch;
+    var i;
+    var j;
+    var matchedEventPattern = null;
+    var matchedChangePatterns;
+    var pat;
+    var self = this;
+    var watchComplete;
+
+    // Only consider events for this VM, and while we a watch is active.
+    if (!self._watching || event.zonename !== self.zonename) {
+        return;
+    }
+
+    self.log.trace({event: event}, 'VmWatcher _handleEvent');
+
+    // Try to match an event pattern.
+    if (self._eventPatterns.length) {
+        for (i = 0; i < self._eventPatterns.length; i++) {
+            pat = self._eventPatterns[i];
+            if (eventPatternMatch(event, pat)) {
+                matchedEventPattern = pat;
+                self._eventPatterns.splice(i, 1);
+                break;
+            }
+        }
+    }
+
+    // Try to match each event.changes entry to a change pattern.
+    if (self._changePatterns.length && event.changes) {
+        for (j = 0; j < event.changes.length; j++) {
+            ch = event.changes[j];
+
+            for (i = 0; i < self._changePatterns.length; i++) {
+                pat = self._changePatterns[i];
+                if (eventChangePatternMatch(ch, pat)) {
+                    self._changePatterns.splice(i, 1);
+                    if (!matchedChangePatterns) {
+                        matchedChangePatterns = [];
+                    }
+                    matchedChangePatterns.push(pat);
+                    break;
+                }
+            }
+        }
+    }
+
+    if (!matchedEventPattern && !matchedChangePatterns) {
+        self._unusedEvents.push(event);
+    } else {
+        watchComplete = (self._eventPatterns.length === 0
+            && self._changePatterns.length === 0);
+        self.log.debug(
+            {
+                event: event,
+                matchedEventPattern: matchedEventPattern,
+                matchedChangePatterns: matchedChangePatterns,
+                watchComplete: watchComplete
+            },
+            'VmWatcher matched event');
+        if (watchComplete) {
+            for (i = 0; i < self._waiters.length; i++) {
+                clearTimeout(self._waiters[i].timeout);
+                self._waiters[i].finish(null);
+            }
+            self._waiters = null;
+        }
+    }
+};
+
+
+
+
 /*
  * Check to see that all key=>value pairs in "a" are found in "b".
  */
diff --git a/src/vm/sbin/vmadm.js b/src/vm/sbin/vmadm.js
index 7616ba5b..5edf9dbc 100755
--- a/src/vm/sbin/vmadm.js
+++ b/src/vm/sbin/vmadm.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  */
 
@@ -152,7 +152,7 @@ function usage(message, code)
     out('console <uuid>');
     out('delete <uuid>');
     out('delete-snapshot <uuid> <snapname>');
-    out('events [-fjr] [uuid]');
+    out('events [-fjr] [<uuid>]');
     out('get <uuid>');
     out('info <uuid> [type,...]');
     out('install <uuid>');
-- 
2.21.0

