commit 4d8b3e60c1df2bf163bc5c72e673f98586b8392c (refs/changes/62/4862/1)
Author: Jan Wyszynski <jan.wyszynski@joyent.com>
Date:   2018-09-21T21:35:57+00:00 (1 year, 1 month ago)
    
    MANTA-3943 add 'gc' mode to manta-adm

diff --git a/cmd/manta-adm.js b/cmd/manta-adm.js
index 5b004aa..b3ca017 100755
--- a/cmd/manta-adm.js
+++ b/cmd/manta-adm.js
@@ -256,6 +256,127 @@ MantaAdm.prototype.do_cn.options = [
     }
 ];
 
+function MantaAdmGc(parent)
+{
+	this.magc_parent = parent;
+	cmdln.Cmdln.call(this, {
+	    'name': parent.name + ' gc',
+	    'desc': 'Configure automatic garbage-collection.'
+	});
+}
+util.inherits(MantaAdmGc, cmdln.Cmdln);
+
+MantaAdm.prototype.do_gc = MantaAdmGc;
+
+MantaAdmGc.prototype.do_show = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm, func;
+		adm = self.magc_parent.madm_adm;
+		func = adm.dumpDeployedInstanceMetadataJson;
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, process.stdout, {
+				'doall': opts.all,
+				'svcname': 'garbage-collector'
+			});
+			self.magc_parent.finiAdm();
+		});
+	});
+};
+
+MantaAdmGc.prototype.do_show.options = [ {
+	'names': [ 'all', 'a' ],
+	'type': 'bool',
+	'help': 'Show results from all datacenters, rather than just ' +
+		'the local one'
+} ];
+
+MantaAdmGc.prototype.do_update = function (subcmd, opts, args, callback)
+{
+	var filename, adm;
+	var self = this;
+
+	if (args.length === 0) {
+		callback(new Error(
+			'expected filename for desired configuration'));
+		return;
+	}
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	filename = args[0];
+
+	vasync.pipeline({
+		funcs: [
+			function initAdm(_, stepcb) {
+				assertplus.ok(opts !== null);
+				self.magc_parent.initAdm(opts, function () {
+					adm = self.magc_parent.madm_adm;
+					stepcb();
+				});
+			},
+			function fetchDeployed(_, stepcb) {
+				adm.fetchDeployed(stepcb);
+			},
+			function readConfig(_, stepcb) {
+				adm.readInstanceMetadataConfigFromFile(
+					filename, stepcb);
+			},
+			function execUpdate(_, stepcb) {
+				adm.updateDeployedInstanceMetadata(stepcb);
+			}
+		]
+	}, function (err) {
+		if (err)
+			fatal(err.message);
+		self.magc_parent.finiAdm();
+		callback();
+	});
+};
+
+MantaAdmGc.prototype.do_update.options = [];
+
+MantaAdmGc.prototype.do_genconfig = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+		var func = adm.genGcMetadataConfig;
+		var options = {
+			outstream: process.stdout
+		};
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, options, function (ferr) {
+				if (ferr)
+					fatal(ferr.message);
+
+				self.magc_parent.finiAdm();
+			});
+		});
+	});
+};
+
+MantaAdmGc.prototype.do_genconfig.options = [];
+
 MantaAdm.prototype.do_genconfig = function (subcmd, opts, args, callback)
 {
 	var self = this;
@@ -346,6 +467,7 @@ MantaAdm.prototype.do_genconfig.options = [ {
  */
 MantaAdm.prototype.do_show = function (subcmd, opts, args, callback)
 {
+
 	var self = this;
 	var selected, filter;
 
diff --git a/config/services/garbage-collector/service.json b/config/services/garbage-collector/service.json
index c67c992..1178eac 100644
--- a/config/services/garbage-collector/service.json
+++ b/config/services/garbage-collector/service.json
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.coal b/config/services/garbage-collector/service.json.coal
index 6e69706..73b11c2 100644
--- a/config/services/garbage-collector/service.json.coal
+++ b/config/services/garbage-collector/service.json.coal
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 1
+		"GC_CONCURRENCY": 1,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.lab b/config/services/garbage-collector/service.json.lab
index aea0169..16f5ac9 100644
--- a/config/services/garbage-collector/service.json.lab
+++ b/config/services/garbage-collector/service.json.lab
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.production b/config/services/garbage-collector/service.json.production
index c67c992..1178eac 100644
--- a/config/services/garbage-collector/service.json.production
+++ b/config/services/garbage-collector/service.json.production
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/lib/adm.js b/lib/adm.js
index 3165112..bf62b32 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -418,6 +418,13 @@ function maAdm(log)
 	 */
 	this.ma_instances_local_bysvcname = null;
 
+	/*
+	 * Mapping from SAPI instance uuid to objects containing metadata fields
+	 * that the instance should be updated with. If the instance already has
+	 * those fields, they will be updated with the new values.
+	 */
+	this.ma_instance_metadata_updates = null;
+
 	/*
 	 * CNAPI server objects, indexed by server_uuid.
 	 */
@@ -2386,6 +2393,76 @@ maAdm.prototype.genconfigFromFile = function (args, callback)
 	}));
 };
 
+/*
+ * [public] Distribute index shards to garbage-collector instances as evenly as
+ * possible.
+ */
+maAdm.prototype.genGcMetadataConfig = function (args, callback)
+{
+	var self, opts, outstream, index_shards, gc_instuuids, gc_idx;
+
+	assertplus.object(args.outstream, 'args.outstream');
+
+	self = this;
+	index_shards = self.ma_app.metadata['INDEX_MORAY_SHARDS'];
+	opts = {
+		svcname: 'garbage-collector'
+	};
+	outstream = args.outstream;
+
+	self.getDeployedInstanceMetadataJson(opts, function (gc_md) {
+		gc_instuuids = Object.keys(gc_md);
+		gc_idx = 0;
+
+		vasync.pipeline({ funcs: [
+			function remove_previous(_, done) {
+				vasync.forEachPipeline({
+					inputs: gc_instuuids,
+					func: function (gc_instuuid, next) {
+						gc_md[gc_instuuid][
+							'GC_ASSIGNED_SHARDS'] =
+							[];
+						next();
+					}
+				}, done);
+			},
+			function assign_shards(_, done) {
+				vasync.forEachPipeline({
+					inputs: index_shards,
+					func: function (shard, next) {
+						var copy = jsprim.mergeObjects(
+							shard, {});
+						delete (copy.last);
+						gc_md[gc_instuuids[gc_idx]][
+							'GC_ASSIGNED_SHARDS'
+							].push(copy);
+						gc_idx = (gc_idx + 1) %
+							gc_instuuids.length;
+						next();
+					}
+				}, done);
+			},
+			function format(_, done) {
+				vasync.forEachPipeline({
+					inputs: gc_instuuids,
+					func: function (gc_instuuid, next) {
+						var gc_shards = gc_md[
+							gc_instuuid][
+							'GC_ASSIGNED_SHARDS'];
+						gc_shards[gc_shards.length - 1
+							].last = true;
+						next();
+					}
+				}, function (lerr) {
+					outstream.write(JSON.stringify(gc_md,
+						null, '    ') + '\n');
+					done(lerr);
+				});
+			}
+		] }, callback);
+	});
+};
+
 /*
  * [public] Iterate zones matching a filter, invoking "callback" synchronously
  * for each one.  Returns an error if the filter was invalid.
@@ -2672,6 +2749,74 @@ maAdm.prototype.dumpDeployedConfigByService = function (sout, conf)
 	});
 };
 
+
+maAdm.prototype.getDeployedInstanceMetadataJson = function (args, callback)
+{
+	var self, instuuids, rv, svc_objs;
+
+	assertplus.object(args, 'args');
+	assertplus.string(args.svcname, 'args.svcname');
+
+	self = this;
+	rv = {};
+	svc_objs = Object.keys(self.ma_services).filter(function (svcuuid) {
+		return (self.ma_services[svcuuid].name === args.svcname);
+	});
+	if (svc_objs.length === 0) {
+		console.log('no service');
+		return;
+	}
+	instuuids = Object.keys(self.ma_instance_info).filter(
+		function (instuuid) {
+		return (self.ma_instance_info[instuuid].inst_svcname ===
+			args.svcname);
+	});
+
+	vasync.forEachPipeline({
+		inputs: instuuids,
+		func: function (instuuid, next) {
+			rv[instuuid] = self.ma_instance_info[
+				instuuid].inst_metadata;
+			next();
+		}
+	}, function (_) {
+		callback(rv);
+	});
+};
+
+maAdm.prototype.dumpDeployedInstanceMetadataJson = function (sout, conf)
+{
+	var self = this;
+
+	self.getDeployedInstanceMetadataJson(conf, function (rv) {
+		sout.write(JSON.stringify(rv, null, '    ') + '\n');
+	});
+
+};
+
+maAdm.prototype.updateDeployedInstanceMetadata = function (callback)
+{
+	var self = this;
+
+	vasync.forEachPipeline({
+		inputs: Object.keys(self.ma_instance_metadata_updates),
+		func: function (instuuid, next) {
+			var updates = self.ma_instance_metadata_updates[
+				instuuid];
+			self.ma_sdc.SAPI.updateInstance(instuuid, {
+				metadata: updates
+			}, next);
+		}
+	}, function (err) {
+		if (err) {
+			callback(new VError('error while updating ' +
+				'instance metadata', err));
+			return;
+		}
+		callback();
+	});
+};
+
 maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
 {
 	var self, svcuuids, rv;
@@ -3078,6 +3223,55 @@ maAdm.prototype.readConfigRaw = function (contents)
 	return (null);
 };
 
+maAdm.prototype.readInstanceMetadataConfigFromFile =
+function (filename, callback)
+{
+	var self = this;
+	fs.readFile(filename, function (err, contents) {
+		if (err) {
+			callback(new VError(err, 'reading "%s":', filename));
+			return;
+		}
+
+		err = self.readInstanceMetadataConfigRaw(
+			contents.toString('utf8'));
+		if (err)
+			err = new VError(err, 'processing "%s"', filename);
+		callback(err);
+	});
+};
+
+maAdm.prototype.readInstanceMetadataConfigRaw = function (contents)
+{
+	var self, instuuid, prev_svcname, next_svcname, json;
+
+	self = this;
+
+	try {
+		json = JSON.parse(contents);
+	} catch (ex) {
+		return (ex);
+	}
+
+	for (instuuid in json) {
+		prev_svcname = next_svcname;
+		if (!self.ma_instance_info.hasOwnProperty(instuuid)) {
+			return (new VError('unknown instance "%s"', instuuid));
+		}
+		next_svcname = self.ma_instance_info[instuuid].inst_svcname;
+
+		if (prev_svcname !== undefined &&
+			prev_svcname !== next_svcname) {
+			return (new VError('instances of mulitple distinct ' +
+				'services cannot be updated at once'));
+		}
+	}
+
+	self.ma_instance_metadata_updates = json;
+
+	return (null);
+};
+
 /*
  * Assuming we've already loaded the current deployed configuration and the
  * user-specified configuration, generate a plan to make reality match what the
