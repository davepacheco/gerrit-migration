From b16be049afe165eb071e21ca2b930b1683cbf5ad Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Thu, 20 Sep 2018 01:42:02 +0000
Subject: [PATCH] MANTA-3943 add 'accel-gc' subcommand to manta-adm MANTA-4046
 add manta-adm accel-gc migrate-config subcommand

---
 cmd/manta-adm.js                              | 705 +++++++++++++++++
 .../services/garbage-collector/service.json   |  13 +-
 .../garbage-collector/service.json.coal       |  13 +-
 .../garbage-collector/service.json.lab        |  13 +-
 .../garbage-collector/service.json.production |  13 +-
 docs/man/man1/manta-adm.md                    | 133 ++++
 lib/adm.js                                    | 730 +++++++++++++++++-
 lib/common.js                                 |   5 +
 man/man1/manta-adm.1                          | 148 +++-
 9 files changed, 1754 insertions(+), 19 deletions(-)

diff --git a/cmd/manta-adm.js b/cmd/manta-adm.js
index 5b004aa..817b431 100755
--- a/cmd/manta-adm.js
+++ b/cmd/manta-adm.js
@@ -39,12 +39,14 @@ var assertplus = require('assert-plus');
 var bunyan = require('bunyan');
 var cmdln = require('cmdln');
 var cmdutil = require('cmdutil');
+var fs = require('fs');
 var jsprim = require('jsprim');
 var path = require('path');
 var restifyClients = require('restify-clients');
 var util = require('util');
 var vasync = require('vasync');
 var VError = require('verror').VError;
+var MultiError = require('verror').MultiError;
 var common = require('../lib/common');
 var deploy = require('../lib/deploy');
 var madm = require('../lib/adm');
@@ -256,6 +258,560 @@ MantaAdm.prototype.do_cn.options = [
     }
 ];
 
+function MantaAdmAccelGc(parent)
+{
+	this.magc_parent = parent;
+	cmdln.Cmdln.call(this, {
+	    'name': parent.name + ' gc',
+	    'desc': 'Configure accelerated garbage-collection.'
+	});
+}
+util.inherits(MantaAdmAccelGc, cmdln.Cmdln);
+
+MantaAdm.prototype.do_accel_gc = MantaAdmAccelGc;
+
+MantaAdmAccelGc.prototype.do_show = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm, func;
+		adm = self.magc_parent.madm_adm;
+
+		if (opts.json) {
+			func = adm.dumpDeployedInstanceMetadataJson;
+		} else {
+			callback(new Error('human-readable format ' +
+			    'not yet supported, use -j to print json'));
+			return;
+		}
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, process.stdout, process.stderr, {
+			    'doall': opts.all,
+			    'svcname': 'garbage-collector',
+			    'fields': common.GC_METADATA_FIELDS
+			});
+			self.magc_parent.finiAdm();
+			callback();
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_show.help =
+    'Output a JSON object mapping of metadata shards to ' +
+    'garbage-collectors.\n\n' +
+    'Usage:\n\n' +
+    '    manta-adm accel-gc show\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_show.options = [ {
+    'names': [ 'all', 'a' ],
+    'type': 'bool',
+    'help': 'Show results from all datacenters, rather than just ' +
+	    'the local one'
+}, {
+    'names': [ 'json', 'j' ],
+    'type': 'bool',
+    'help': 'Show results in JSON form suitable for passing to ' +
+	    '"manta-adm accel-gc update".'
+} ];
+
+MantaAdmAccelGc.prototype.do_update = function (subcmd, opts, args, callback)
+{
+	var self, adm;
+	var filename;
+
+	self = this;
+
+	if (args.length === 0) {
+		callback(new Error(
+		    'expected filename for desired configuration'));
+		return;
+	}
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	filename = args[0];
+
+	vasync.pipeline({
+		funcs: [
+			function initAdm(_, stepcb) {
+				assertplus.ok(opts !== null);
+				self.magc_parent.initAdm(opts, function () {
+					adm = self.magc_parent.madm_adm;
+					stepcb();
+				});
+			},
+			function fetchDeployed(_, stepcb) {
+				adm.fetchDeployed(stepcb);
+			},
+			function readConfig(_, stepcb) {
+				adm.readInstanceMetadataConfigFromFile(
+				    filename, stepcb);
+			},
+			function execUpdate(_, stepcb) {
+				adm.updateDeployedInstanceMetadata({
+				    svcname: 'garbage-collector'
+				}, stepcb);
+			}
+		]
+	}, function (err) {
+		if (err)
+			fatal(err.message);
+		self.magc_parent.finiAdm();
+		callback();
+	});
+};
+
+MantaAdmAccelGc.prototype.do_update.help =
+    'Update the mapping of index shards to garbage-collectors.\n\n' +
+    'Usage:\n\n' +
+    '    manta-adm accel-gc update [OPTIONS] CONFIG-FILE\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_update.options = [];
+
+MantaAdmAccelGc.prototype.do_gen_shard_assignment =
+function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+		var func = adm.genGcMetadataConfig;
+		var options = {
+		    outstream: process.stdout
+		};
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, options, function (ferr) {
+				if (ferr)
+					fatal(ferr.message);
+				self.magc_parent.finiAdm();
+				callback();
+			});
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_gen_shard_assignment.help =
+    'Generate an assignment of index shards to deployed ' +
+    'garbage-collector instances.\n\n' +
+    '    manta-adm accel-gc gen-shard-assignment\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_gen_shard_assignment.options = [];
+
+MantaAdmAccelGc.prototype.do_genconfig = function (subcmd, opts, args, callback)
+{
+	var num_collectors, max_cns;
+	var avoid_svcs;
+	var imageuuid;
+	var self;
+
+	if (args.length !== 2) {
+		callback(new Error('missing arguments: IMAGE_UUID ' +
+		    'NCOLLECTORS'));
+		return;
+	}
+
+	self = this;
+	imageuuid = args[0];
+
+	num_collectors = jsprim.parseInteger(args[1], { base: 10 });
+	if (num_collectors instanceof Error) {
+		callback(new VError(num_collectors, 'unable to generate ' +
+		    'garbage-collector deployment config'));
+		return;
+	}
+
+	max_cns = opts.max_cns;
+	avoid_svcs = (opts.ignore_criteria) ? [] : (opts.avoid_svcs || [
+	    'loadbalancer',
+	    'nameservice',
+	    'storage'
+	]);
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+		var func = adm.layerServiceOnDeployedConfig;
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, {
+			    avoid_svcs: avoid_svcs,
+			    image_uuid: imageuuid,
+			    max_cns: max_cns,
+			    num_instances: num_collectors,
+			    outstream: process.stdout,
+			    errstream: process.stderr,
+			    svcname: 'garbage-collector'
+			});
+
+			self.magc_parent.finiAdm();
+			callback();
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_genconfig.help =
+    'Layer a number of garbage-collector instances on top of an existing ' +
+    'Manta deployment.\n\n' +
+    '    manta-adm accel-gc genconfig [OPTIONS] IMAGE_UUID NCOLLECTORS\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_genconfig.options = [ {
+    'names': [ 'max-cns', 'm' ],
+    'type': 'integer',
+    'helpArg': 'MAX_CNS',
+    'help': 'The number of CNs on which to distribute collector instances. ' +
+	    'If this option is not specified the collector instances will '  +
+	    'be distributed on as many viable CNs as possible'
+},
+{
+    'names': [ 'avoid-svcs', 'a' ],
+    'type': 'arrayOfString',
+    'help': 'Avoid co-locating garbage-collector instances with the given '  +
+	    'service. Specify multiple services by repeating this option: '  +
+	    '\'-a loadbalancer -a nameservice\'. By default, this command '  +
+	    'avoids co-locating services with loadbalancer, nameservice, '   +
+	    'and storage instances.'
+},
+{
+    'names': [ 'ignore-criteria', 'i' ],
+    'type': 'bool',
+    'help': 'Ignore service co-location constraints, which may not be ' +
+	    'satisfiable in all deployments.'
+} ];
+
+/*
+ * Some Manta deployments may have garbage-collectors that expect a deprecated
+ * set of SAPI variables. To ease the operational load of migrating the
+ * collectors to use the current set of variables, the following subcommand does
+ * the following:
+ *
+ * 1. Retrieves the set of instance-level metadata for all garbage-collectors
+ * 2. Validates that all of the garbage-collectors use the same set of SAPI
+ *    variables for configuration
+ * 3. Translates each instance-level garbage-collector configuration from the
+ *    old set of variables to the new set
+ * 4. Commits the translated configuration to SAPI
+ * 5. Updates the SAPI garbage-collectoro service configuration with default
+ *    values for the new variables
+ *
+ * By default, this subcommand will not remove any of the old configuration
+ * variables from either the service configuration object, or the instance-level
+ * configuration objects. Running in the default mode, this will configure
+ * garbage-collection with the union of the old and new configuration variables.
+ *
+ * If the `--remove-old` option is used, this function will remove the
+ * deprecated SAPI variables from both the instance-level and service-level
+ * configuration objects.
+ *
+ * The operation of this mode is idemptotent in the sense that it may be invoked
+ * on a Manta where all collectors are deployed with the new set of variables.
+ * The result is a no-op.
+ *
+ * The recommended use case for this subcommand is to run it in the default mode
+ * (without the `--remove-old` option) first. When this succeeds and the
+ * garbage-collectors come up with the 'union' configuration, the `--remove-old`
+ * option may be passed to get rid of the deprecated variables.
+ */
+MantaAdmAccelGc.prototype.do_migrate_config =
+function (subcmd, opts, args, callback)
+{
+	var self = this;
+	var adm, log;
+
+	var oldFields = [
+		'GC_SHARD_NUM_LO',
+		'GC_SHARD_NUM_HI'
+	];
+	var oldServiceFields = [
+		'GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY'
+	];
+	var newFields = common.GC_METADATA_FIELDS;
+
+	var funcs = [
+		function (next) {
+			adm.fetchDeployed(function (err) {
+				next(err);
+			});
+		},
+		function (next) {
+			assertplus.func(next);
+			adm.getDeployedInstanceMetadataJson({
+				fields: oldFields.concat(newFields),
+				svcname: 'garbage-collector'
+			}, function (err, metadata) {
+				log.debug({
+					err: err ? err.message : null,
+					metadata: metadata
+				}, 'got deployed garbage-collector ' +
+				    'configs');
+				next(err, metadata);
+			});
+		},
+		function (metadata, next) {
+			validateGcInstanceConfigs(metadata, oldFields,
+			    newFields, function (err) {
+				log.debug({
+					err: err ? err.message : null
+				}, 'validated garbage-collector ' +
+				    'configs');
+				next(err, metadata);
+			});
+		},
+		function (metadata, next) {
+			translateGcInstanceConfigs(adm.ma_app, metadata,
+			    function (err) {
+				log.debug({
+					err: err ? err.message : null,
+					metadata: metadata
+				}, 'transformed garbage-collector ' +
+				    'configs');
+				next(err, metadata);
+			});
+		},
+		function (metadata, next) {
+			var remove = {};
+			if (opts.remove_old) {
+				Object.keys(metadata).forEach(function (uuid) {
+					oldFields.forEach(function (field) {
+						if (!remove.hasOwnProperty(
+						    uuid))
+							remove[uuid] = {};
+						remove[uuid][field] =
+						    metadata[uuid][field];
+					});
+				});
+			}
+			adm.updateDeployedInstanceMetadata({
+			    svcname: 'garbage-collector'
+			}, metadata, remove, function (err) {
+				log.debug({
+				    err: (err) ? err.message : null,
+				    metadata: metadata,
+				    removeMetadata: remove
+				}, 'updated SAPI instance(s) metadata');
+				next(err, metadata);
+			});
+		},
+		function (metadata, next) {
+			var removeMetadata = {};
+			if (opts.remove_old) {
+				Object.keys(metadata).forEach(function (uuid) {
+					oldFields.forEach(function (field) {
+						removeMetadata[field] =
+						    metadata[field];
+					});
+					oldServiceFields.forEach(
+					    function (field) {
+						removeMetadata[field] =
+						    metadata[field];
+					});
+				});
+			}
+			updateDeployedGcServiceMetadata(adm, metadata,
+			    removeMetadata, function (err) {
+				log.debug({
+				    err: (err) ? err.message : null,
+				    metadata: metadata,
+				    removeMetadata: removeMetadata
+				}, 'updated SAPI service metadata');
+				next(err);
+			});
+		}
+	];
+
+	self.magc_parent.initAdm(opts, function () {
+		adm = self.magc_parent.madm_adm;
+		log = self.magc_parent.madm_log;
+
+		vasync.waterfall(funcs, function (err) {
+			if (err)
+				fatal(err.message);
+			self.magc_parent.finiAdm();
+			callback();
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_migrate_config.help =
+    'Migrate garbage-collector SAPI configuration in a deployment.\n\n' +
+    '    manta-adm accel-gc migrate-config [OPTIONS]\n\n'               +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_migrate_config.options = [ {
+    'names': ['remove-old', 'r'],
+    'type': 'bool',
+    'helpArg': 'REMOVE_OLD',
+    'help': 'Remove deprecated SAPI variables after migrating the '   +
+	    'configuration. It is recommended that this option only ' +
+	    'be used after migration  without removal has succeeded.'
+} ];
+
+MantaAdmAccelGc.prototype.do_enable =
+function (subcmd, opts, args, callback) {
+	var self;
+	var account;
+
+	if (args.length !== 1) {
+		callback(new Error('missing arguments: ACCOUNT-LOGIN'));
+		return;
+	}
+
+	self = this;
+	account = args[0];
+
+	if (account === 'poseidon') {
+		callback(new Error('accelerated gc is not supported for ' +
+		    'poseidon'));
+		return;
+	}
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+
+		adm.fetchDeployed(function (err) {
+			if (err) {
+				callback(err);
+				return;
+			}
+			var options = {
+				account: account
+			};
+			adm.disableSnaplinks(options, function (disableErr) {
+				if (disableErr)
+					fatal(disableErr.message);
+				self.magc_parent.finiAdm();
+				callback();
+			});
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_enable.help =
+    'Enable accelerated garbage-collection for an account.\n' +
+    'This also disables snaplinks for the account.\n\n' +
+    '    manta-adm accel-gc enable [ACCOUNT-LOGIN]\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_enable.options = [];
+
+MantaAdmAccelGc.prototype.do_disable =
+function (subcmd, opts, args, callback) {
+	var self;
+	var account;
+
+	if (args.length != 1) {
+		callback(new Error('missing arguments: ACCOUNT-LOGIN'));
+		return;
+	}
+
+	self = this;
+	account = args[0];
+
+	if (account === 'poseidon') {
+		callback(new Error('accelerated gc is not supported for ' +
+		    'poseidon'));
+		return;
+	}
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+
+		adm.fetchDeployed(function (err) {
+			if (err) {
+				callback(err);
+				return;
+			}
+			var options = {
+				account: account
+			};
+			adm.enableSnaplinks(options, function (enableErr) {
+				if (enableErr)
+					fatal(enableErr.message);
+				self.magc_parent.finiAdm();
+				callback();
+			});
+		});
+
+	});
+};
+
+MantaAdmAccelGc.prototype.do_disable.help =
+    'Disable accelerated garbage-collection for an account.\n' +
+    'This enables snaplinks for the account.\n\n' +
+    '    manta-adm accel-gc disable [ACCOUNT-LOGIN]\n\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_disable.options = [];
+
+MantaAdmAccelGc.prototype.do_accounts =
+function (subcmd, opts, args, callback) {
+	var self, options;
+
+	self = this;
+	options = {};
+
+	if (args.length != 0) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	options = listPrepareArgs(opts, madm.gcColumnNames());
+	if (options instanceof Error) {
+		callback(options);
+		return;
+	}
+	options.stream = process.stdout;
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			adm.dumpSnaplinkDisabledAccounts(
+			    options, function (outputErr) {
+				if (err)
+					fatal(outputErr.message);
+				self.magc_parent.finiAdm();
+				callback();
+			});
+		});
+	});
+};
+
+MantaAdmAccelGc.prototype.do_accounts.help =
+    'List accounts using accelerated garbage-collection.\n\n' +
+    '    manta-adm accel-gc accounts [OPTIONS]\n' +
+    '{{options}}';
+
+MantaAdmAccelGc.prototype.do_accounts.options = [
+    maCommonOptions.omitHeader,
+    maCommonOptions.columns
+];
+
 MantaAdm.prototype.do_genconfig = function (subcmd, opts, args, callback)
 {
 	var self = this;
@@ -1984,6 +2540,155 @@ function checkColumns(allowed, columns)
 	return (selected);
 }
 
+/*
+ * Some Manta deployments may have garbage-collectors that expect a particular
+ * set of deprecated SAPI variables. To reduce the operational load of
+ * migrating to the new configuration, `manta-adm` has logic that validates that
+ * the operator is migrating from a Manta in which all garbage-collectors are
+ * deployed on the old set of variables to a Manta in which all
+ * garbage-collectors are configured with the new set of variables.
+ *
+ * This function will report an error in the following cases:
+ * - At least one garbage-collector is found to contain a partial old and
+ *   partial new configuration. In this case, it is unclear which configuration
+ *   to use for that collector.
+ * - Some garbage-collectors in the Manta deployment are found to be on the old
+ *   configuration, and some are found to be on the new configuration. This
+ *   condition requires that the operator decide which configuration to use.
+ *
+ * The function succeeds all of the following are true:
+ * - All collectors have either
+ *   	a) A complete old configuration
+ *   	b) A complete new configuration
+ *   	c) A complete old and new configuration
+ * - All collectors match the same case from the previous bullet
+ *
+ * Arguments:
+ * - `metadata`: A JSON object mapping from garbage-collector instance uuid to
+ *   SAPI instance metadata object.
+ * - `oldFields`: An array of strings representing the 'deprecated' SAPI fields.
+ * - `newFields`: An array of strings representing the new SAPI fields
+ * - `callback`: A function that may be invoked with an error.
+ */
+function validateGcInstanceConfigs(metadata, oldFields, newFields, callback)
+{
+	var errors = [];
+	Object.keys(metadata).forEach(function (instance) {
+		var md = metadata[instance];
+		var missingOld = oldFields.filter(
+		    function (field) {
+			return (!md.hasOwnProperty(field));
+		});
+		var missingNew = newFields.filter(
+		    function (field) {
+			return (!md.hasOwnProperty(field));
+		});
+		if (missingOld.length != 0 &&
+		    missingNew.length != 0) {
+			errors.push(new VError('garbage-collector "%s" '  +
+			    'has an incomplete instance config. Missing ' +
+			    'old fields: %s. Missing new fields: %s',
+			    instance, util.inspect(missingOld),
+			    util.inspect(missingNew)));
+		}
+	});
+
+	if (errors.length > 0) {
+		callback(new MultiError(errors));
+		return;
+	}
+	callback();
+}
+
+/*
+ * If `validateGcInstanceConfigs` succeeds, the following helper function may be
+ * used to translate the instance metadata of all garbage-collectors in the
+ * deployment from a version that uses the old fields to a version that uses the
+ * new fields.
+ *
+ * This function will not remove any of the old fields. It will also not commit
+ * any changes to the underlying SAPI data.
+ *
+ * Arguments:
+ * - `app`: The Manta SAPI application object
+ * - `metadata`: A JSON object mapping from garbage-collector instance uuid to
+ *   SAPI instance metadata object.
+ * - `callback`: A function that may be invoked with an error.
+ */
+function translateGcInstanceConfigs(app, metadata, callback)
+{
+	Object.keys(metadata).forEach(function (instance) {
+		var md = metadata[instance];
+		if (!md.hasOwnProperty('GC_ASSIGNED_SHARDS')) {
+			var assignedShards = [];
+			var lo = md['GC_SHARD_NUM_LO'];
+			var hi = md['GC_SHARD_NUM_HI'];
+
+			var domain = app.metadata['DOMAIN_NAME'];
+
+			if (!(lo === hi && lo === 0)) {
+				for (var i = lo; i <= hi; i++) {
+					assignedShards.push({
+						host: [i, 'moray',
+						    domain].join('.')
+					});
+				}
+				assignedShards[
+				    assignedShards.length - 1].last = true;
+			}
+			md['GC_ASSIGNED_SHARDS'] = assignedShards;
+		}
+		if (!md.hasOwnProperty('GC_ASSIGNED_BUCKETS')) {
+			md['GC_ASSIGNED_BUCKETS'] = [ {
+				name: 'manta_fastdelete_queue',
+				last: true
+			} ];
+		}
+		if (!md.hasOwnProperty('GC_CONCURRENCY')) {
+			md['GC_CONCURRENCY'] =
+			    md['GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY'];
+		}
+	});
+	callback();
+}
+
+function updateDeployedGcServiceMetadata(adm, metadata, removeMetadata,
+    callback)
+{
+	var file = util.format('%s/../config/services/%s/service.json',
+	    path.dirname(__filename), 'garbage-collector');
+	var size = adm.ma_app.metadata['SIZE'];
+
+	file = [file, size].join('.');
+
+	fs.readFile(file, function (err, contents) {
+		var addMetadata;
+		if (err) {
+			callback(err);
+			return;
+		}
+		try {
+			addMetadata = JSON.parse(
+			    contents.toString('utf8')).metadata;
+		} catch (e) {
+			callback(new VError(e, 'parse "%s"', file));
+			return;
+		}
+
+		adm.updateDeployedServiceMetadata({
+			svcname: 'garbage-collector'
+		}, addMetadata, removeMetadata, function (updateErr) {
+			adm.ma_log.debug({
+				err: updateErr ? updateErr.message : null,
+				metadata: addMetadata,
+				remove: removeMetadata
+			}, 'updated garbage-collector ' +
+			    'service metadata');
+			callback(err);
+		});
+	});
+}
+
 function fatal(msg)
 {
 	console.error('%s: %s', maArg0, msg);
diff --git a/config/services/garbage-collector/service.json b/config/services/garbage-collector/service.json
index c67c992..354e842 100644
--- a/config/services/garbage-collector/service.json
+++ b/config/services/garbage-collector/service.json
@@ -13,9 +13,14 @@
 		"GC_RECORD_READ_SORT_ATTR": "_mtime",
 		"GC_RECORD_DELETE_BATCH_SIZE": 3500,
 		"GC_RECORD_DELETE_DELAY": 500,
-		"GC_SHARD_NUM_LO": 0,
-		"GC_SHARD_NUM_HI": 0,
-		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CACHE_CAPACITY": 12800000,
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.coal b/config/services/garbage-collector/service.json.coal
index 6e69706..5edc9b1 100644
--- a/config/services/garbage-collector/service.json.coal
+++ b/config/services/garbage-collector/service.json.coal
@@ -13,9 +13,14 @@
 		"GC_RECORD_READ_SORT_ATTR": "_mtime",
 		"GC_RECORD_DELETE_BATCH_SIZE": 50,
 		"GC_RECORD_DELETE_DELAY": 1000,
-		"GC_SHARD_NUM_LO": 0,
-		"GC_SHARD_NUM_HI": 0,
-		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 1
+		"GC_CACHE_CAPACITY": 3200000,
+		"GC_CONCURRENCY": 1,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.lab b/config/services/garbage-collector/service.json.lab
index aea0169..50e9c42 100644
--- a/config/services/garbage-collector/service.json.lab
+++ b/config/services/garbage-collector/service.json.lab
@@ -13,9 +13,14 @@
 		"GC_RECORD_READ_SORT_ATTR": "_mtime",
 		"GC_RECORD_DELETE_BATCH_SIZE": 50,
 		"GC_RECORD_DELETE_DELAY": 1000,
-		"GC_SHARD_NUM_LO": 0,
-		"GC_SHARD_NUM_HI": 0,
-		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CACHE_CAPACITY": 12800000,
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.production b/config/services/garbage-collector/service.json.production
index c67c992..354e842 100644
--- a/config/services/garbage-collector/service.json.production
+++ b/config/services/garbage-collector/service.json.production
@@ -13,9 +13,14 @@
 		"GC_RECORD_READ_SORT_ATTR": "_mtime",
 		"GC_RECORD_DELETE_BATCH_SIZE": 3500,
 		"GC_RECORD_DELETE_DELAY": 500,
-		"GC_SHARD_NUM_LO": 0,
-		"GC_SHARD_NUM_HI": 0,
-		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CACHE_CAPACITY": 12800000,
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/docs/man/man1/manta-adm.md b/docs/man/man1/manta-adm.md
index 23d4124..b895a86 100644
--- a/docs/man/man1/manta-adm.md
+++ b/docs/man/man1/manta-adm.md
@@ -6,6 +6,8 @@ manta-adm - administer a Manta deployment
 
 ## SYNOPSIS
 
+`manta-adm accel-gc SUBCOMMAND... [OPTIONS...]`
+
 `manta-adm alarm SUBCOMMAND... [OPTIONS...]`
 
 `manta-adm cn [-l LOG_FILE] [-H] [-o FIELD...] [-n] [-s] CN_FILTER`
@@ -32,6 +34,9 @@ deployment.  This command only operates on zones within the same datacenter.
 The command may need to be repeated in other datacenters in order to execute it
 across an entire Manta deployment.
 
+`manta-adm accel-gc`
+  Administer garbage-collector zones and accelerated gc-enabled accounts.
+
 `manta-adm alarm`
   List and configure amon-based alarms for Manta.
 
@@ -163,6 +168,134 @@ status of the program to determine success or failure.
 
 ## SUBCOMMANDS
 
+### "accel-gc" subcommand
+
+`manta-adm accel-gc show [-j]`
+
+`manta-adm accel-gc update CONFIG_FILE`
+
+`manta-adm accel-gc gen-shard-assignment`
+
+`manta-adm accel-gc genconfig [-m MAX_CNS] [-a SERVICE...] [-i] IMAGE_UUID
+NCOLLECTORS`
+
+`manta-adm accel-gc migrate-config [-r|--remove-old]`
+
+`manta-adm accel-gc enable ACCOUNT_LOGIN`
+
+`manta-adm accel-gc disable ACCOUNT_LOGIN`
+
+`manta-adm accel-gc accounts [-H] [-o FIELD...]`
+
+Accelerated garbage-collection is a low-latency alternative to the backup-based
+garbage-collection pipeline in the Mola software consolidation. The system
+allows users to trade Manta's snaplink functionality for faster storage space
+reclamation.
+
+Accounts that do not have any snaplinks can be marked as snaplink-disabled,
+indicating that all of the objects owned by the account have a single reference
+in the metadata tier. This constrained setting allows garbage-collector zones,
+each of which is responsible for processing deleted objects on some subset of
+the index shards, to coordinate object file cleanup as soon as a front-door
+delete request completes.
+
+The `manta-adm accel-gc` subcommand provides tools that allow operators:
+
+* manage the assignment of metadata shards to garbage-collector instances
+* toggle accelerated garbage-collection for individual accounts
+
+`manta-adm accel-gc show -j`
+
+Dump a mapping that shows which shards are assigned to which garbage-collectors.
+The output of this command can be re-purposed as input to `manta-adm
+accel-gc update`. The interaction between these commands is similar to that
+between `manta-adm show` and `manta-adm update`.
+
+`manta-adm accel-gc update CONFIG_FILE`
+
+Update the mapping from shards to garbage-collectors. This will require restarting
+the garbage-collectors so that they pick up the new assigned shards. CONFIG_FILE
+here should have the same format as the output of `manta-adm accel-gc show -j`.
+
+`manta-adm accel-gc genconfig [-m MAX_CNS] [-a SERVICE...] [-i] IMAGE_UUID
+NCOLLECTORS`
+
+Generate a service deployment layout (interpretable by manta-adm update) by
+layering NCOLLECTORS garbage-collector zones onto the existing deployment
+layout in a minimally disruptive fashion. By default, this means the command
+will:
+
+* avoid colocating garbage-collector zones with loadbalancer or nameservice
+  zones.
+* add garbage-collectors to at most MAX_CNS CNs meeting the previous criterion
+  if specified, otherwise use as many CNs meeting the above criterion as are
+  available.
+* distribute garbage-collectors as evenly as possible amongest the CNs between
+  the above criteria.
+
+In some deployments these criteria cannot be met. To generate a layout that
+does not meet the criteria pass the -i flag. The flag should not be used in
+production deployments.
+
+To change the list of services to avoid, pass multiple SERVICEs in a
+comma-separated list or with repeated -a flags.
+
+`manta-adm accel-gc migrate-config [-r|--remove-old]`
+
+Some Manta deployment may have garbage-collector instances that expect a
+deprecated set of SAPI variables. This subcommand eases the operational load of
+migrating such a Manta to use the new set of SAPI variables. This command first
+validates that the currently deployed garbage-collectors are consistently
+configured and all expect one of the following:
+
+* the deprecated set of SAPI variables
+* the new set of SAPI variables
+* the union of the deprecated and new sets of SAPI variables
+
+If the garbage-collectors in the deployment do not meet these constraints, this
+subcommand will fail with a descriptive error. If the garbage-collectors do meet
+these constraints and the garbage-collectors do not already expect the new set
+of SAPI variables, this command will:
+
+* translate the instance-level metadata configurations of all garbage-collectors
+* update the service-level garbage-collector metadata with defaults for the new
+  variables
+
+If the `--remove-old` option is specified, this command will also remove the
+deprecated set of SAPI variables from both the instance-level and service-level
+configuration metadata.
+
+In deployments with the updated configuration, it is not necessary to run this
+command (doing so will be a no-op). In deployments using the deprecated
+configuration, the recommended usage is to first run the command without the
+`--remove-old` option. If this succeeds, the subcommand can be safely re-run
+with the `--remove-old` option.
+
+`manta-adm accel-gc gen-shard-assignment`
+
+Generate a mapping from shards to garbage-collectors based on SAPI metadata that
+distributes index shards to garbage-collectors as evenly as possible.
+
+`manta-adm accel-gc enable ACCOUNT_LOGIN`
+
+Enable accelerated garbage-collection for the account. No snaplinks to data
+owned by this account will be allowed after this command completes. Note that
+this command does not get rid of any existing snaplinks to objects owned by the
+account. It is not safe to use accelerated garbage-collection for an account
+that may own snaplinked data.
+
+`manta-adm accel-gc disable ACCOUNT_LOGIN`
+
+Disable accelerated garbage-collection for the account. Objects owned by the
+account which are deleted while the account has accelerated garbage-collection
+disabled will have to be garbage-collected with the offline garbage-collection
+defined in the Mola software consolidation.
+
+`manta-adm accel-gc accounts [-H] [-o FIELD]`
+
+List accounts for which accelerated garbage-collection is enabled in a
+human-readable format.
+
 ### "alarm" subcommand
 
 `manta-adm alarm close ALARM_ID...`
diff --git a/lib/adm.js b/lib/adm.js
index 3165112..3e9cb02 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -21,6 +21,7 @@ var net = require('net');
 var path = require('path');
 var sprintf = require('sprintf-js').sprintf;
 var tab = require('tab');
+var util = require('util');
 var vasync = require('vasync');
 var wordwrap = require('wordwrap');
 
@@ -42,6 +43,7 @@ exports.cnColumnNames = cnColumnNames;
 exports.probeGroupColumnNames = probeGroupColumnNames;
 exports.maintWindowColumnNames = maintWindowColumnNames;
 exports.zkColumnNames = zkColumnNames;
+exports.gcColumnNames = gcColumnNames;
 exports.MantaAdm = maAdm;
 
 var maMaxConcurrency = 50; /* concurrent requests to SDC services */
@@ -322,6 +324,22 @@ function zkColumnNames()
 	return (Object.keys(maZkColumns));
 }
 
+var maGcColumns = {
+    'uuid': {
+	'label': 'ACCOUNT UUID',
+	'width': 40
+    },
+    'login': {
+	'label': 'LOGIN',
+	'width': 12
+    }
+};
+
+function gcColumnNames()
+{
+	return (Object.keys(maGcColumns));
+}
+
 /*
  * Library interface for manta-adm functionality.  This object provides methods
  * for discovering deployed Manta zones and updating the deployment to match a
@@ -418,6 +436,13 @@ function maAdm(log)
 	 */
 	this.ma_instances_local_bysvcname = null;
 
+	/*
+	 * Mapping from SAPI instance uuid to objects containing metadata fields
+	 * that the instance should be updated with. If the instance already has
+	 * those fields, they will be updated with the new values.
+	 */
+	this.ma_instance_metadata_updates = null;
+
 	/*
 	 * CNAPI server objects, indexed by server_uuid.
 	 */
@@ -2386,6 +2411,379 @@ maAdm.prototype.genconfigFromFile = function (args, callback)
 	}));
 };
 
+maAdm.prototype.disableSnaplinks = function (args, callback) {
+	var self;
+	var account, uuid;
+	var disabledAccounts;
+
+	assertplus.string(args.account, 'args.account');
+
+	self = this;
+	account = args.account;
+
+	self.ma_sdc.UFDS.getUser(account, function (err, user) {
+		if (err) {
+			callback(new VError(err, 'unable to disable ' +
+			    'snaplinks for user account ' + account));
+			return;
+		}
+		uuid = user.uuid;
+		disabledAccounts = self.ma_app.metadata[
+		    'ACCOUNTS_SNAPLINKS_DISABLED'] || [];
+
+		for (var i = 0; i < disabledAccounts.length; i++) {
+			var disabledAccount = disabledAccounts[i];
+			if (disabledAccount.uuid === uuid) {
+				callback(new Error('snaplinks ' +
+				    'already disabled for ' + account));
+				return;
+			}
+			delete (disabledAccount.last);
+		}
+
+		disabledAccounts.push({
+		    uuid: uuid,
+		    last: true
+		});
+
+		self.ma_sdc.SAPI.updateApplication(self.ma_app.uuid, {
+		    metadata: {
+		        'ACCOUNTS_SNAPLINKS_DISABLED': disabledAccounts
+		    }
+		}, function (updateErr) {
+			if (updateErr) {
+				callback(new VError(updateErr, 'unable ' +
+				    'to disable snaplinks for user account ' +
+				    uuid));
+				return;
+			}
+			callback();
+		});
+	});
+};
+
+maAdm.prototype.enableSnaplinks = function (args, callback) {
+	var disabledAccounts, newDisabledAccounts;
+	var account, uuid;
+	var found;
+	var self;
+
+	assertplus.string(args.account, 'args.account');
+
+	self = this;
+	account = args.account;
+	newDisabledAccounts = [];
+	found = false;
+
+	self.ma_sdc.UFDS.getUser(account, function (err, user) {
+		if (err) {
+			callback(new VError(err, 'unable to enable snaplinks ' +
+			    'for user account ' + uuid));
+			return;
+		}
+		uuid = user.uuid;
+		disabledAccounts = self.ma_app.metadata[
+		    'ACCOUNTS_SNAPLINKS_DISABLED'] || [];
+
+		for (var i = 0; i < disabledAccounts.length; i++) {
+			var disabledAccount = disabledAccounts[i];
+			delete (disabledAccount.last);
+
+			if (disabledAccount.uuid === uuid) {
+				found = true;
+			} else {
+				newDisabledAccounts.push(disabledAccount);
+			}
+		}
+
+		if (!found) {
+			callback(new VError('snaplinks already enabled for ' +
+			    'account ' + account));
+			return;
+		}
+
+		if (newDisabledAccounts.length > 0) {
+			newDisabledAccounts[
+			    newDisabledAccounts.length - 1].last = true;
+		}
+
+		self.ma_sdc.SAPI.updateApplication(self.ma_app.uuid, {
+		    metadata: {
+		        'ACCOUNTS_SNAPLINKS_DISABLED': newDisabledAccounts
+		    }
+		}, function (updateErr) {
+			if (updateErr) {
+				callback(new VError(updateErr, 'unable ' +
+				    'to disable snaplinks for user account ' +
+				    uuid));
+				return;
+			}
+			callback();
+		});
+	});
+};
+
+maAdm.prototype.dumpSnaplinkDisabledAccounts = function (args, callback) {
+	var self;
+	var rows;
+
+	assertplus.object(args.stream, 'args.stream');
+	assertplus.optionalArrayOfString(args.columns, 'args.columns');
+	assertplus.optionalBool(args.omitHeader, 'args.omitHeader');
+
+	self = this;
+	rows = [];
+
+	var disabledAccounts = self.ma_app.metadata[
+	    'ACCOUNTS_SNAPLINKS_DISABLED'] || [];
+
+	vasync.forEachPipeline({
+		inputs: disabledAccounts,
+		func: function (account, next) {
+			self.ma_sdc.UFDS.getUser(account.uuid,
+			    function (err, user) {
+				if (err) {
+					next(err);
+					return;
+				}
+				rows.push([user.uuid, user.login]);
+				next();
+			});
+		}
+	}, function (err) {
+		if (err) {
+			callback(new VError(err, 'error listing snaplink ' +
+			    'disabled accounts'));
+			return;
+		}
+		self.doList({
+		    'stream': args.stream,
+		    'columnsSelected': args.columns,
+		    'columnsDefault': [ 'uuid', 'login' ],
+		    'columnMetadata': maGcColumns,
+		    'omitHeader': args.omitHeader,
+		    'rows': rows
+		});
+		callback();
+	});
+};
+
+/*
+ * [public] Distribute index shards to garbage-collector instances as evenly as
+ * possible.
+ */
+maAdm.prototype.genGcMetadataConfig = function (args, callback)
+{
+	var self, opts, outstream;
+	var index_shards, gc_instuuids;
+	var assignedShards;
+	var gc_idx;
+
+	assignedShards = 'GC_ASSIGNED_SHARDS';
+
+	assertplus.object(args.outstream, 'args.outstream');
+
+	self = this;
+	index_shards = self.ma_app.metadata['INDEX_MORAY_SHARDS'] || [];
+	opts = {
+	    svcname: 'garbage-collector',
+	    fields: common.GC_METADATA_FIELDS
+	};
+	outstream = args.outstream;
+
+	self.getDeployedInstanceMetadataJson(opts, function (err, gc_md) {
+		if (err) {
+			callback(err);
+			return;
+		}
+
+		var gc_instuuid;
+		var i;
+
+		gc_instuuids = Object.keys(gc_md);
+		gc_idx = 0;
+
+		if (gc_instuuids.length === 0) {
+			callback(new Error('no garbage-collectors ' +
+			    'found.'));
+			return;
+		}
+
+		/*
+		 * Clear the previous mapping.
+		 */
+		for (i = 0; i < gc_instuuids.length; i++) {
+			gc_instuuid = gc_instuuids[i];
+			gc_md[gc_instuuid][assignedShards] = [];
+		}
+
+		/*
+		 * Distribute index shards evenly across all garbage-collectors
+		 * in the DC.
+		 */
+		for (i = 0; i < index_shards.length; i++) {
+			var copy = jsprim.deepCopy(index_shards[i]);
+			delete (copy.last);
+
+			gc_md[gc_instuuids[gc_idx]][assignedShards].push(copy);
+			gc_idx = (gc_idx + 1) % gc_instuuids.length;
+		}
+
+		/*
+		 * Add the "last" field to the final element in each array. This
+		 * field is required by mustache.
+		 */
+		for (i = 0; i < gc_instuuids.length; i++) {
+			gc_instuuid = gc_instuuids[i];
+			var gc_shards = gc_md[gc_instuuid][assignedShards];
+			if (gc_shards.length > 0) {
+				gc_shards[gc_shards.length - 1].last = true;
+			}
+		}
+
+		outstream.write(JSON.stringify(gc_md, null, '    ') + '\n');
+		callback();
+	});
+};
+
+/*
+ * [public] This method generates a Manta deployment layout that includes new
+ * instances of a service. The new instances are layered on the existing
+ * configuration in a minimally disruptive fashion. That is, they are added to
+ * CNs that (a) contain the fewest number of deployed instances and (b) do not
+ * have instances of any of the services listed in 'avoid_svcs'.
+ *
+ * The motivation for (b) is that it may be preferable to avoid adding load to
+ * CNs that run system-critical services like 'nameservice' or 'loadbalancer'.
+ */
+maAdm.prototype.layerServiceOnDeployedConfig = function (args)
+{
+	var self, instances_per_cn;
+	var selected_cns;
+
+	assertplus.array(args.avoid_svcs, 'args.avoid_svcs');
+	assertplus.string(args.image_uuid, 'args.image_uuid');
+	assertplus.optionalNumber(args.max_cns, 'args.max_cns');
+	assertplus.number(args.num_instances, 'args.num_instances');
+	assertplus.object(args.outstream, 'args.outstream');
+	assertplus.object(args.errstream, 'args.errstream');
+	assertplus.string(args.svcname, 'args.svcname');
+
+	self = this;
+	instances_per_cn = {};
+	selected_cns = [];
+
+	/*
+	 * Check if the service exists in SAPI. If it doesn't, `manta-init` may
+	 * be required prior to layering on instances of the service.
+	 */
+	if (!self.isServiceDeployed(args.svcname)) {
+		args.errstream.write('missing service ' + args.svcname +
+		    '.\n');
+		return;
+	}
+
+	/*
+	 * Retrieve the current Manta deployment configuration.
+	 */
+	var cfg = self.getDeployedConfigByServiceJson();
+
+	/*
+	 * Count the total number of instances deployed on each CN.
+	 */
+	Object.keys(cfg).forEach(function (cnuuid) {
+		var cn_cfg = cfg[cnuuid];
+		var total = 0;
+		var svcs_in_cn = Object.keys(cn_cfg);
+
+		svcs_in_cn.forEach(function (svcname) {
+			var svc_cfg = cn_cfg[svcname];
+			var images_in_shard;
+
+			/*
+			 * If the service is sharded, count the instances
+			 * deployed in each shard.
+			 */
+			if (svcs.serviceIsSharded(svcname)) {
+				var shards_in_svc = Object.keys(svc_cfg);
+				shards_in_svc.forEach(function (shard) {
+					var sh_cfg = svc_cfg[shard];
+					images_in_shard =
+					    Object.keys(svc_cfg[shard]);
+
+					images_in_shard.forEach(
+					    function (imageuuid) {
+						total += sh_cfg[imageuuid];
+					});
+				});
+				return;
+			}
+
+			images_in_shard = Object.keys(svc_cfg);
+			images_in_shard.forEach(function (imageuuid) {
+				total += svc_cfg[imageuuid];
+			});
+
+			instances_per_cn[cnuuid] = total;
+		});
+	});
+
+	/*
+	 * Filter list of CNs, removing those that have instances of a service
+	 * the caller has asked to avoid.
+	 */
+	var viable_cns = Object.keys(instances_per_cn).filter(
+	    function (cnuuid) {
+		var viable = true;
+
+		for (var j = 0; j < args.avoid_svcs.length; j++) {
+			if (cfg[cnuuid].hasOwnProperty(args.avoid_svcs[j])) {
+				viable = false;
+			}
+		}
+
+		return (viable);
+	});
+
+	/*
+	 * Sort the list of CNs that meet the caller criteria by the total
+	 * number of instance deployed on each.
+	 */
+	selected_cns = viable_cns.sort(function (cn1, cn2) {
+		if (instances_per_cn[cn1] > instances_per_cn[cn2]) {
+			return (1);
+		}
+		if (instances_per_cn[cn1] < instances_per_cn[cn2]) {
+			return (-1);
+		}
+		return (0);
+	});
+
+	if (selected_cns.length === 0) {
+		console.error('no CNs meet deployment criteria');
+		return;
+	}
+
+	if (args.max_cns) {
+		selected_cns = selected_cns.slice(0, args.max_cns);
+	}
+
+	for (var i = 0; i < args.num_instances; i++) {
+		var next_cn = selected_cns[i % selected_cns.length];
+
+		if (!cfg[next_cn].hasOwnProperty(args.svcname)) {
+			cfg[next_cn][args.svcname] = {};
+		}
+		if (!cfg[next_cn][args.svcname][args.image_uuid]) {
+			cfg[next_cn][args.svcname][args.image_uuid] = 0;
+		}
+
+		cfg[next_cn][args.svcname][args.image_uuid]++;
+	}
+
+	args.outstream.write(JSON.stringify(cfg, null, '    ') + '\n');
+};
+
 /*
  * [public] Iterate zones matching a filter, invoking "callback" synchronously
  * for each one.  Returns an error if the filter was invalid.
@@ -2672,9 +3070,275 @@ maAdm.prototype.dumpDeployedConfigByService = function (sout, conf)
 	});
 };
 
-maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
+maAdm.prototype.getDeployedInstanceMetadataJson = function (args, callback)
 {
-	var self, svcuuids, rv;
+	var self, rv;
+	var instuuids, fields;
+
+	assertplus.object(args, 'args');
+	assertplus.optionalArray(args.fields, 'args.fields');
+	assertplus.string(args.svcname, 'args.svcname');
+	assertplus.optionalBool(args.doall, 'args.doall');
+
+	self = this;
+	rv = {};
+
+	if (!svcs.serviceNameIsValid(args.svcname)) {
+		callback(new VError('unknown service: %s', args.svcname));
+		return;
+	}
+
+	fields = args.fields;
+
+	if (!self.isServiceDeployed(args.svcname)) {
+		callback(new VError('missing service: %s', args.svcname));
+		return;
+	}
+
+	instuuids = Object.keys(self.ma_instance_info).filter(
+	    function (uuid) {
+		var instance = self.ma_instance_info[uuid];
+		return (instance.inst_svcname === args.svcname &&
+		    (args.doall || instance.inst_local));
+	});
+
+	for (var i = 0; i < instuuids.length; i++) {
+		var instuuid = instuuids[i];
+		var inst_metadata = self.ma_instance_info[
+		    instuuid].inst_metadata;
+
+		rv[instuuid] = {};
+
+		for (var j = 0; j < fields.length; j++) {
+			var field = fields[j];
+			if (inst_metadata.hasOwnProperty(field)) {
+				rv[instuuid][field] = inst_metadata[field];
+			}
+		}
+	}
+
+	callback(null, rv);
+};
+
+maAdm.prototype.dumpDeployedInstanceMetadataJson = function (sout, serr, conf)
+{
+	var self;
+
+	assertplus.object(conf, 'conf');
+	assertplus.object(sout, 'sout');
+
+	assertplus.array(conf.fields, 'conf.fields');
+	assertplus.string(conf.svcname, 'conf.svcname');
+	assertplus.optionalBool(conf.doall, 'conf.doall');
+
+	self = this;
+
+	self.getDeployedInstanceMetadataJson(conf, function (err, rv) {
+		if (err) {
+			serr.write(err.message + '\n');
+			return;
+		}
+		if (Object.keys(rv).length === 0) {
+			sout.write('no ' + conf.svcname + 's found.\n');
+			return;
+		}
+		sout.write(JSON.stringify(rv, null, '    ') + '\n');
+	});
+
+};
+
+maAdm.prototype.updateDeployedServiceMetadata =
+function (opts, add, remove, callback)
+{
+	assertplus.object(opts, 'opts');
+	assertplus.string(opts.svcname, 'opts.svcname');
+
+	if (add instanceof Function) {
+		callback();
+		return;
+	}
+
+	if (remove instanceof Function) {
+		callback = remove;
+		remove = {};
+	}
+
+	assertplus.object(add, 'add');
+	assertplus.object(remove, 'remove');
+	assertplus.func(callback, 'callback');
+
+	var self = this;
+
+	if (!self.isServiceDeployed(opts.svcname)) {
+		callback(new VError('missing service: %s'));
+		return;
+	}
+
+	var services = Object.keys(self.ma_services).filter(
+	    function (serviceuuid) {
+		return (self.ma_services[serviceuuid]['name'] === opts.svcname);
+	});
+
+	if (services.length !== 1) {
+		callback(new VError('multiple "%s" services found',
+		    opts.svcname));
+		return;
+	}
+
+	var uuid = services[0];
+	var addMetadata = jsprim.mergeObjects(self.ma_services[uuid].metadata,
+	    add);
+	var removeMetadata = {};
+	Object.keys(remove).forEach(function (key) {
+		removeMetadata[key] = addMetadata[key];
+	});
+
+	function updateServiceMetadata(svcuuid, action, metadata, done) {
+		self.ma_sdc.SAPI.updateService(svcuuid, {
+		    action: action,
+		    metadata: metadata
+		}, function (err, _) {
+			if (err) {
+				done(new VError(err, 'error running ' +
+				    'action %s for keys %s on "%s" ' +
+				    'service config', action,
+				    Object.keys(metadata), opts.svcname));
+				return;
+			}
+			done();
+		});
+	}
+
+	vasync.waterfall([
+		function (next) {
+			updateServiceMetadata(uuid, 'update',
+			    addMetadata, next);
+		},
+		function (next) {
+			updateServiceMetadata(uuid, 'delete',
+			    removeMetadata, next);
+		}
+	], callback);
+};
+
+maAdm.prototype.updateDeployedInstanceMetadata =
+function (opts, add, remove, callback)
+{
+	var self = this;
+
+	/*
+	 * In some use-cases for this function, updates to the garbage-collector
+	 * instance-level configuration objects will be read from a file, or
+	 * consumed as command line arguments. In some cases, individual
+	 * instance configuration updates are passed in as arguments to this
+	 * function in the `add` and `remove` objects.
+	 */
+	var updates = self.ma_instance_metadata_updates || {};
+
+	if (add instanceof Function) {
+		callback = add;
+		add = {};
+		remove = {};
+	}
+	if (remove instanceof Function) {
+		callback = remove;
+		remove = {};
+	}
+
+	assertplus.object(opts, 'opts');
+	assertplus.string(opts.svcname, 'opts.svcname');
+	assertplus.object(add, 'add');
+	assertplus.object(remove, 'remove');
+	assertplus.func(callback, 'callback');
+
+	if (!self.isServiceDeployed(opts.svcname)) {
+		callback(new VError('missing service: %s', opts.svcname));
+		return;
+	}
+
+	var addUpdates = {};
+	var removeUpdates = {};
+	var uuids = {};
+
+	/*
+	 * Determine the full list of uuids touched by this operation.
+	 */
+	Object.keys(updates).forEach(function (uuid) {
+		uuids[uuid] = true;
+	});
+	Object.keys(add).forEach(function (uuid) {
+		uuids[uuid] = true;
+	});
+	Object.keys(remove).forEach(function (uuid) {
+		uuids[uuid] = true;
+	});
+
+	/*
+	 * Construct `addUpdates`, and `removeUpdates`. These specify, for each
+	 * garbage-collector instance, what fields should be updated/added, and
+	 * what fields should be removed.
+	 */
+	Object.keys(uuids).forEach(function (uuid) {
+		addUpdates[uuid] = jsprim.mergeObjects(updates[uuid],
+		    add[uuid]);
+		removeUpdates[uuid] = remove[uuid];
+	});
+
+	function updateKeysForInstance(instuuid, action, metadata, cb) {
+		self.ma_sdc.SAPI.updateInstance(instuuid, {
+		    action: action,
+		    metadata: metadata
+		}, function (err) {
+			if (err) {
+				cb(new VError(err, 'error running action ' +
+				    '"%s" for keys %s on "%s" instance config',
+				    action, Object.keys(metadata), instuuid));
+				return;
+			}
+			cb();
+		});
+	}
+
+	vasync.forEachPipeline({
+		inputs: Object.keys(uuids),
+		func: function (uuid, next) {
+			var adds = addUpdates[uuid] || {};
+			var removes = removeUpdates[uuid] || {};
+			vasync.waterfall([
+				function (stepcb) {
+					updateKeysForInstance(uuid, 'update',
+					    adds, stepcb);
+				},
+				function (stepcb) {
+					updateKeysForInstance(uuid, 'delete',
+					    removes, stepcb);
+				}
+			], next);
+		}
+	}, function (err) {
+		if (err) {
+			callback(err);
+			return;
+		}
+		callback();
+	});
+};
+
+maAdm.prototype.isServiceDeployed = function (svcname)
+{
+	var self = this;
+
+	var svc_objs = Object.keys(self.ma_services).filter(function (svcuuid) {
+		return (self.ma_services[svcuuid].name === svcname);
+	});
+	return (svc_objs.length !== 0);
+};
+
+maAdm.prototype.getDeployedConfigByServiceJson = function ()
+{
+	var self;
+	var rv;
+	var svcuuids;
 
 	self = this;
 	svcuuids = Object.keys(this.ma_config_bycn).sort(function (s1, s2) {
@@ -2699,6 +3363,13 @@ maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
 		}
 	});
 
+	return (rv);
+};
+
+maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
+{
+	var rv = this.getDeployedConfigByServiceJson();
+
 	sout.write(JSON.stringify(rv, null, '    ') + '\n');
 };
 
@@ -3078,6 +3749,61 @@ maAdm.prototype.readConfigRaw = function (contents)
 	return (null);
 };
 
+/*
+ * Reads a configuration file mapping instance uuids of a common SAPI service to
+ * json objects representing their corresponding SAPI metadata. This format is
+ * used to support batch updating metadata that may vary across different
+ * instances.
+ */
+maAdm.prototype.readInstanceMetadataConfigFromFile =
+function (filename, callback)
+{
+	var self = this;
+	fs.readFile(filename, function (err, contents) {
+		if (err) {
+			callback(new VError(err, 'reading "%s":', filename));
+			return;
+		}
+
+		err = self.readInstanceMetadataConfigRaw(
+		    contents.toString('utf8'));
+		if (err)
+			err = new VError(err, 'processing "%s"', filename);
+		callback(err);
+	});
+};
+
+maAdm.prototype.readInstanceMetadataConfigRaw = function (contents)
+{
+	var self, instuuid, prev_svcname, next_svcname, json;
+
+	self = this;
+
+	try {
+		json = JSON.parse(contents);
+	} catch (ex) {
+		return (ex);
+	}
+
+	for (instuuid in json) {
+		prev_svcname = next_svcname;
+		if (!self.ma_instance_info.hasOwnProperty(instuuid)) {
+			return (new VError('unknown instance "%s"', instuuid));
+		}
+		next_svcname = self.ma_instance_info[instuuid].inst_svcname;
+
+		if (prev_svcname !== undefined &&
+		    prev_svcname !== next_svcname) {
+			return (new VError('instances of mulitple distinct ' +
+			    'services cannot be updated at once'));
+		}
+	}
+
+	self.ma_instance_metadata_updates = json;
+
+	return (null);
+};
+
 /*
  * Assuming we've already loaded the current deployed configuration and the
  * user-specified configuration, generate a plan to make reality match what the
diff --git a/lib/common.js b/lib/common.js
index 6236c61..1acace8 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -46,6 +46,11 @@ exports.HASH_RING_IMGAPI_SERVICE = 'HASH_RING_IMGAPI_SERVICE';
 
 exports.CONFIG_FILE_DEFAULT = path.join(__dirname, '..', 'etc', 'config.json');
 
+exports.GC_METADATA_FIELDS = [
+    'GC_ASSIGNED_SHARDS',
+    'GC_ASSIGNED_BUCKETS',
+    'GC_CONCURRENCY'
+];
 
 // -- Helper functions
 
diff --git a/man/man1/manta-adm.1 b/man/man1/manta-adm.1
index 7b4f748..1eb7bbb 100644
--- a/man/man1/manta-adm.1
+++ b/man/man1/manta-adm.1
@@ -4,6 +4,8 @@
 manta\-adm \- administer a Manta deployment
 .SH SYNOPSIS
 .PP
+\fB\fCmanta\-adm accel\-gc SUBCOMMAND... [OPTIONS...]\fR
+.PP
 \fB\fCmanta\-adm alarm SUBCOMMAND... [OPTIONS...]\fR
 .PP
 \fB\fCmanta\-adm cn [\-l LOG_FILE] [\-H] [\-o FIELD...] [\-n] [\-s] CN_FILTER\fR
@@ -28,6 +30,9 @@ deployment.  This command only operates on zones within the same datacenter.
 The command may need to be repeated in other datacenters in order to execute it
 across an entire Manta deployment.
 .TP
+\fB\fCmanta\-adm accel\-gc\fR
+Administer garbage\-collector zones and accelerated gc\-enabled accounts.
+.TP
 \fB\fCmanta\-adm alarm\fR
 List and configure amon\-based alarms for Manta.
 .TP
@@ -58,7 +63,7 @@ Stores user identity information
 \fBelectric\-moray\fP
 Moray proxy that handles sharding using consistent hashing
 .TP
-\fBgarbage-collector\fP
+\fBgarbage\-collector\fP
 Processes delete records in specialized Postgres tables
 .TP
 \fBjobpuller\fP
@@ -160,6 +165,147 @@ subcommand is still considered an experimental interface.  All other documented
 subcommands, options, and arguments are committed, and you can use the exit
 status of the program to determine success or failure.
 .SH SUBCOMMANDS
+.SS "accel\-gc" subcommand
+.PP
+\fB\fCmanta\-adm accel\-gc show [\-j]\fR
+.PP
+\fB\fCmanta\-adm accel\-gc update CONFIG_FILE\fR
+.PP
+\fB\fCmanta\-adm accel\-gc gen\-shard\-assignment\fR
+.PP
+\fB\fCmanta\-adm accel\-gc genconfig [\-m MAX_CNS] [\-a SERVICE...] [\-i] IMAGE_UUID
+NCOLLECTORS\fR
+.PP
+\fB\fCmanta\-adm accel\-gc migrate\-config [\-r|\-\-remove\-old]\fR
+.PP
+\fB\fCmanta\-adm accel\-gc enable ACCOUNT_LOGIN\fR
+.PP
+\fB\fCmanta\-adm accel\-gc disable ACCOUNT_LOGIN\fR
+.PP
+\fB\fCmanta\-adm accel\-gc accounts [\-H] [\-o FIELD...]\fR
+.PP
+Accelerated garbage\-collection is a low\-latency alternative to the backup\-based
+garbage\-collection pipeline in the Mola software consolidation. The system
+allows users to trade Manta's snaplink functionality for faster storage space
+reclamation.
+.PP
+Accounts that do not have any snaplinks can be marked as snaplink\-disabled,
+indicating that all of the objects owned by the account have a single reference
+in the metadata tier. This constrained setting allows garbage\-collector zones,
+each of which is responsible for processing deleted objects on some subset of
+the index shards, to coordinate object file cleanup as soon as a front\-door
+delete request completes.
+.PP
+The \fB\fCmanta\-adm accel\-gc\fR subcommand provides tools that allow operators:
+.RS
+.IP \(bu 2
+manage the assignment of metadata shards to garbage\-collector instances
+.IP \(bu 2
+toggle accelerated garbage\-collection for individual accounts
+.RE
+.PP
+\fB\fCmanta\-adm accel\-gc show \-j\fR
+.PP
+Dump a mapping that shows which shards are assigned to which garbage\-collectors.
+The output of this command can be re\-purposed as input to \fB\fCmanta\-adm
+accel\-gc update\fR\&. The interaction between these commands is similar to that
+between \fB\fCmanta\-adm show\fR and \fB\fCmanta\-adm update\fR\&.
+.PP
+\fB\fCmanta\-adm accel\-gc update CONFIG_FILE\fR
+.PP
+Update the mapping from shards to garbage\-collectors. This will require restarting
+the garbage\-collectors so that they pick up the new assigned shards. CONFIG_FILE
+here should have the same format as the output of \fB\fCmanta\-adm accel\-gc show \-j\fR\&.
+.PP
+\fB\fCmanta\-adm accel\-gc genconfig [\-m MAX_CNS] [\-a SERVICE...] [\-i] IMAGE_UUID
+NCOLLECTORS\fR
+.PP
+Generate a service deployment layout (interpretable by manta\-adm update) by
+layering NCOLLECTORS garbage\-collector zones onto the existing deployment
+layout in a minimally disruptive fashion. By default, this means the command
+will:
+.RS
+.IP \(bu 2
+avoid colocating garbage\-collector zones with loadbalancer or nameservice
+zones.
+.IP \(bu 2
+add garbage\-collectors to at most MAX_CNS CNs meeting the previous criterion
+if specified, otherwise use as many CNs meeting the above criterion as are
+available.
+.IP \(bu 2
+distribute garbage\-collectors as evenly as possible amongest the CNs between
+the above criteria.
+.RE
+.PP
+In some deployments these criteria cannot be met. To generate a layout that
+does not meet the criteria pass the \-i flag. The flag should not be used in
+production deployments.
+.PP
+To change the list of services to avoid, pass multiple SERVICEs in a
+comma\-separated list or with repeated \-a flags.
+.PP
+\fB\fCmanta\-adm accel\-gc migrate\-config [\-r|\-\-remove\-old]\fR
+.PP
+Some Manta deployment may have garbage\-collector instances that expect a
+deprecated set of SAPI variables. This subcommand eases the operational load of
+migrating such a Manta to use the new set of SAPI variables. This command first
+validates that the currently deployed garbage\-collectors are consistently
+configured and all expect one of the following:
+.RS
+.IP \(bu 2
+the deprecated set of SAPI variables
+.IP \(bu 2
+the new set of SAPI variables
+.IP \(bu 2
+the union of the deprecated and new sets of SAPI variables
+.RE
+.PP
+If the garbage\-collectors in the deployment do not meet these constraints, this
+subcommand will fail with a descriptive error. If the garbage\-collectors do meet
+these constraints and the garbage\-collectors do not already expect the new set
+of SAPI variables, this command will:
+.RS
+.IP \(bu 2
+translate the instance\-level metadata configurations of all garbage\-collectors
+.IP \(bu 2
+update the service\-level garbage\-collector metadata with defaults for the new
+variables
+.RE
+.PP
+If the \fB\fC\-\-remove\-old\fR option is specified, this command will also remove the
+deprecated set of SAPI variables from both the instance\-level and service\-level
+configuration metadata.
+.PP
+In deployments with the updated configuration, it is not necessary to run this
+command (doing so will be a no\-op). In deployments using the deprecated
+configuration, the recommended usage is to first run the command without the
+\fB\fC\-\-remove\-old\fR option. If this succeeds, the subcommand can be safely re\-run
+with the \fB\fC\-\-remove\-old\fR option.
+.PP
+\fB\fCmanta\-adm accel\-gc gen\-shard\-assignment\fR
+.PP
+Generate a mapping from shards to garbage\-collectors based on SAPI metadata that
+distributes index shards to garbage\-collectors as evenly as possible.
+.PP
+\fB\fCmanta\-adm accel\-gc enable ACCOUNT_LOGIN\fR
+.PP
+Enable accelerated garbage\-collection for the account. No snaplinks to data
+owned by this account will be allowed after this command completes. Note that
+this command does not get rid of any existing snaplinks to objects owned by the
+account. It is not safe to use accelerated garbage\-collection for an account
+that may own snaplinked data.
+.PP
+\fB\fCmanta\-adm accel\-gc disable ACCOUNT_LOGIN\fR
+.PP
+Disable accelerated garbage\-collection for the account. Objects owned by the
+account which are deleted while the account has accelerated garbage\-collection
+disabled will have to be garbage\-collected with the offline garbage\-collection
+defined in the Mola software consolidation.
+.PP
+\fB\fCmanta\-adm accel\-gc accounts [\-H] [\-o FIELD]\fR
+.PP
+List accounts for which accelerated garbage\-collection is enabled in a
+human\-readable format.
 .SS "alarm" subcommand
 .PP
 \fB\fCmanta\-adm alarm close ALARM_ID...\fR
-- 
2.21.0

