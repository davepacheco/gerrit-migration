From c354183d471a9e990f7059b159ceb5dec5023546 Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Thu, 20 Sep 2018 01:42:02 +0000
Subject: [PATCH] MANTA-3943 add 'gc' mode to manta-adm

---
 cmd/manta-adm.js                              | 193 +++++++++
 .../services/garbage-collector/service.json   |   9 +-
 .../garbage-collector/service.json.coal       |   9 +-
 .../garbage-collector/service.json.lab        |   9 +-
 .../garbage-collector/service.json.production |   9 +-
 lib/adm.js                                    | 384 +++++++++++++++++-
 6 files changed, 608 insertions(+), 5 deletions(-)

diff --git a/cmd/manta-adm.js b/cmd/manta-adm.js
index 5b004aa..eed7089 100755
--- a/cmd/manta-adm.js
+++ b/cmd/manta-adm.js
@@ -256,6 +256,199 @@ MantaAdm.prototype.do_cn.options = [
     }
 ];
 
+function MantaAdmGc(parent)
+{
+	this.magc_parent = parent;
+	cmdln.Cmdln.call(this, {
+	    'name': parent.name + ' gc',
+	    'desc': 'Configure automatic garbage-collection.'
+	});
+}
+util.inherits(MantaAdmGc, cmdln.Cmdln);
+
+MantaAdm.prototype.do_gc = MantaAdmGc;
+
+MantaAdmGc.prototype.do_show = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	if (opts.include_all === undefined) {
+		opts.include_all = false;
+	}
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm, func;
+		adm = self.magc_parent.madm_adm;
+		func = adm.dumpDeployedInstanceMetadataJson;
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, process.stdout, {
+			    'doall': opts.all,
+			    'svcname': 'garbage-collector',
+			    'include_all': opts.include_all
+			});
+			self.magc_parent.finiAdm();
+		});
+	});
+};
+
+MantaAdmGc.prototype.do_show.options = [ {
+	'names': [ 'all', 'a' ],
+	'type': 'bool',
+	'help': 'Show results from all datacenters, rather than just ' +
+		'the local one',
+	'names': [ 'include_all', 'A' ],
+	'type': 'bool',
+	'help': 'Toggle whether to include default SAPI fields'
+} ];
+
+MantaAdmGc.prototype.do_update = function (subcmd, opts, args, callback)
+{
+	var filename, adm;
+	var self = this;
+
+	if (args.length === 0) {
+		callback(new Error(
+			'expected filename for desired configuration'));
+		return;
+	}
+
+	if (args.length > 1) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+
+	filename = args[0];
+
+	vasync.pipeline({
+		funcs: [
+			function initAdm(_, stepcb) {
+				assertplus.ok(opts !== null);
+				self.magc_parent.initAdm(opts, function () {
+					adm = self.magc_parent.madm_adm;
+					stepcb();
+				});
+			},
+			function fetchDeployed(_, stepcb) {
+				adm.fetchDeployed(stepcb);
+			},
+			function readConfig(_, stepcb) {
+				adm.readInstanceMetadataConfigFromFile(
+				    filename, stepcb);
+			},
+			function execUpdate(_, stepcb) {
+				adm.updateDeployedInstanceMetadata(stepcb);
+			}
+		]
+	}, function (err) {
+		if (err)
+			fatal(err.message);
+		self.magc_parent.finiAdm();
+		callback();
+	});
+};
+
+MantaAdmGc.prototype.do_update.options = [];
+
+MantaAdmGc.prototype.do_gen_shard_assignment = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+		var func = adm.genGcMetadataConfig;
+		var options = {
+		    outstream: process.stdout
+		};
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, options, function (ferr) {
+				if (ferr)
+					fatal(ferr.message);
+
+				self.magc_parent.finiAdm();
+			});
+		});
+	});
+};
+
+MantaAdmGc.prototype.do_gen_shard_assignment.options = [];
+
+MantaAdmGc.prototype.do_genconfig = function (subcmd, opts, args, callback)
+{
+	var self, imageuuid, ignore_criteria, num_collectors, max_cns;
+
+	if (args.length !== 2) {
+		callback(new Error('missing arguments: IMAGE_UUID ' +
+		    'NCOLLECTORS'));
+		return;
+	}
+
+	self = this;
+	imageuuid = args[0];
+
+	try {
+		num_collectors = parseInt(args[1], 10);
+	} catch (err) {
+		callback(new VError(err, 'invalid argument: NCOLLECTORS'));
+		return;
+	}
+
+	max_cns = opts.max_cns;
+	ignore_criteria = opts.ignore_criteria;
+
+	self.magc_parent.initAdm(opts, function () {
+		var adm = self.magc_parent.madm_adm;
+		var func = adm.layerServiceOnDeployedConfig;
+
+		adm.fetchDeployed(function (err) {
+			if (err)
+				fatal(err.message);
+
+			func.call(adm, {
+			    avoid_svcs: (ignore_criteria) ? [] : [
+			        'loadbalancer',
+			        'nameservice'
+			    ],
+			    image_uuid: imageuuid,
+			    max_cns: max_cns,
+			    num_instances: num_collectors,
+			    outstream: process.stdout,
+			    svcname: 'garbage-collector'
+			});
+
+			self.magc_parent.finiAdm();
+		});
+	});
+};
+
+MantaAdmGc.prototype.do_genconfig.options = [ {
+    'names': [ 'max-cns', 'm' ],
+    'type': 'integer',
+    'helpArg': 'MAX_CNS',
+    'help': 'The number of CNs on which to distribute collector instances. ' +
+	    'If this option is not specified the collector instances will '  +
+	    'be distributed on as many viable CNs as possible'
+}, {
+    'names': [ 'ignore-criteria', 'i' ],
+    'type': 'bool',
+    'help': 'This mode will typically avoid co-locating garbage-collector '   +
+	    'instances with loadbalancer and nameservice instances. This is ' +
+	    'not possible in all deployments. If this flag is present the '   +
+	    'deployment script ignores these criteria.'
+} ];
+
 MantaAdm.prototype.do_genconfig = function (subcmd, opts, args, callback)
 {
 	var self = this;
diff --git a/config/services/garbage-collector/service.json b/config/services/garbage-collector/service.json
index c67c992..1178eac 100644
--- a/config/services/garbage-collector/service.json
+++ b/config/services/garbage-collector/service.json
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.coal b/config/services/garbage-collector/service.json.coal
index 6e69706..73b11c2 100644
--- a/config/services/garbage-collector/service.json.coal
+++ b/config/services/garbage-collector/service.json.coal
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 1
+		"GC_CONCURRENCY": 1,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.lab b/config/services/garbage-collector/service.json.lab
index aea0169..16f5ac9 100644
--- a/config/services/garbage-collector/service.json.lab
+++ b/config/services/garbage-collector/service.json.lab
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/config/services/garbage-collector/service.json.production b/config/services/garbage-collector/service.json.production
index c67c992..1178eac 100644
--- a/config/services/garbage-collector/service.json.production
+++ b/config/services/garbage-collector/service.json.production
@@ -16,6 +16,13 @@
 		"GC_SHARD_NUM_LO": 0,
 		"GC_SHARD_NUM_HI": 0,
 		"GC_CACHE_CAPACITY": 1000000000000,
-		"GC_MANTA_FASTDELETE_QUEUE_CONCURRENCY": 2
+		"GC_CONCURRENCY": 2,
+		"GC_ASSIGNED_SHARDS": [],
+		"GC_ASSIGNED_BUCKETS": [
+			{
+				"name": "manta_fastdelete_queue",
+				"last": true
+			}
+		]
 	}
 }
diff --git a/lib/adm.js b/lib/adm.js
index 3165112..6da2dff 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -418,6 +418,13 @@ function maAdm(log)
 	 */
 	this.ma_instances_local_bysvcname = null;
 
+	/*
+	 * Mapping from SAPI instance uuid to objects containing metadata fields
+	 * that the instance should be updated with. If the instance already has
+	 * those fields, they will be updated with the new values.
+	 */
+	this.ma_instance_metadata_updates = null;
+
 	/*
 	 * CNAPI server objects, indexed by server_uuid.
 	 */
@@ -2386,6 +2393,204 @@ maAdm.prototype.genconfigFromFile = function (args, callback)
 	}));
 };
 
+/*
+ * [public] Distribute index shards to garbage-collector instances as evenly as
+ * possible.
+ */
+maAdm.prototype.genGcMetadataConfig = function (args, callback)
+{
+	var self, opts, outstream, index_shards, gc_instuuids, gc_idx;
+
+	assertplus.object(args.outstream, 'args.outstream');
+
+	self = this;
+	index_shards = self.ma_app.metadata['INDEX_MORAY_SHARDS'];
+	opts = {
+	    svcname: 'garbage-collector',
+	    include_all: args.include_all || false
+	};
+	outstream = args.outstream;
+
+	self.getDeployedInstanceMetadataJson(opts, function (gc_md) {
+		gc_instuuids = Object.keys(gc_md);
+		gc_idx = 0;
+
+		vasync.pipeline({ funcs: [
+			function remove_previous(_, done) {
+				vasync.forEachPipeline({
+					inputs: gc_instuuids,
+					func: function (gc_instuuid, next) {
+						gc_md[gc_instuuid][
+						    'GC_ASSIGNED_SHARDS'] =
+						    [];
+						next();
+					}
+				}, done);
+			},
+			function assign_shards(_, done) {
+				vasync.forEachPipeline({
+					inputs: index_shards,
+					func: function (shard, next) {
+						var copy = jsprim.mergeObjects(
+							shard, {});
+						delete (copy.last);
+						gc_md[gc_instuuids[gc_idx]][
+						    'GC_ASSIGNED_SHARDS'
+						     ].push(copy);
+						gc_idx = (gc_idx + 1) %
+						    gc_instuuids.length;
+						next();
+					}
+				}, done);
+			},
+			function format(_, done) {
+				vasync.forEachPipeline({
+					inputs: gc_instuuids,
+					func: function (gc_instuuid, next) {
+						var gc_shards = gc_md[
+						    gc_instuuid][
+						    'GC_ASSIGNED_SHARDS'];
+						gc_shards[gc_shards.length - 1
+						    ].last = true;
+						next();
+					}
+				}, function (lerr) {
+					outstream.write(JSON.stringify(gc_md,
+					    null, '    ') + '\n');
+					done(lerr);
+				});
+			}
+		] }, callback);
+	});
+};
+
+/*
+ * [public] This method generates a Manta deployment layout that includes new
+ * instances of a service. The new instances are layered on the existing
+ * configuration in a minimally disruptive fashion. That is, they are added to
+ * CNs that (a) contain the fewest number of deployed instances and (b) do not
+ * have instances of any of the services listed in 'avoid_svcs'.
+ *
+ * The motivation for (b) is that it may be preferable to avoid adding load to
+ * CNs that run system-critical services like 'nameservice' or 'loadbalancer'.
+ */
+maAdm.prototype.layerServiceOnDeployedConfig = function (args)
+{
+	var self, selected_cns, instances_per_cn;
+
+	assertplus.array(args.avoid_svcs, 'args.avoid_svcs');
+	assertplus.string(args.image_uuid, 'args.image_uuid');
+	assertplus.optionalNumber(args.max_cns, 'args.max_cns');
+	assertplus.number(args.num_instances, 'args.num_instances');
+	assertplus.object(args.outstream, 'args.outstream');
+	assertplus.string(args.svcname, 'args.svcname');
+
+	self = this;
+	instances_per_cn = {};
+	selected_cns = [];
+
+	/*
+	 * Retrieve the current Manta deployment configuration.
+	 */
+	var cfg = self.getDeployedConfigByServiceJson();
+
+	/*
+	 * Count the total number of instances deployed on each CN.
+	 */
+	Object.keys(cfg).forEach(function (cnuuid) {
+		var cn_cfg = cfg[cnuuid];
+		var total = 0;
+		var svcs_in_cn = Object.keys(cn_cfg);
+
+		svcs_in_cn.forEach(function (svcname) {
+			var svc_cfg = cn_cfg[svcname];
+			var images_in_shard;
+
+			/*
+			 * If the service is sharded, count the instances
+			 * deployed in each shard.
+			 */
+			if (svcs.serviceIsSharded(svcname)) {
+				var shards_in_svc = Object.keys(svc_cfg);
+				shards_in_svc.forEach(function (shard) {
+					var sh_cfg = svc_cfg[shard];
+					images_in_shard =
+					    Object.keys(svc_cfg[shard]);
+
+					images_in_shard.forEach(
+					    function (imageuuid) {
+						total += sh_cfg[imageuuid];
+					});
+				});
+				return;
+			}
+
+			images_in_shard = Object.keys(svc_cfg);
+			images_in_shard.forEach(function (imageuuid) {
+				total += svc_cfg[imageuuid];
+			});
+
+			instances_per_cn[cnuuid] = total;
+		});
+	});
+
+	/*
+	 * Sort the CNs by the total number of instances deployed on each.
+	 */
+	var cns_sorted = Object.keys(instances_per_cn).sort(
+		function (cn1, cn2) {
+		if (instances_per_cn[cn1] > instances_per_cn[cn2]) {
+			return (1);
+		}
+		if (instances_per_cn[cn1] < instances_per_cn[cn2]) {
+			return (-1);
+		}
+		return (0);
+	});
+
+	/*
+	 * Filter the sorted list of CNs, removing those that have instances of
+	 * a service the caller has asked to avoid.
+	 */
+	for (var i = 0; i < cns_sorted.length; i++) {
+		var cn = cns_sorted[i];
+		var viable = true;
+
+		for (var j = 0; j < args.avoid_svcs.length; j++) {
+			if (cfg[cn].hasOwnProperty(args.avoid_svcs[j])) {
+				viable = false;
+			}
+		}
+
+		if (viable)
+			selected_cns.push(cn);
+	}
+
+	if (selected_cns.length === 0) {
+		console.error('no CNs meet deployment criteria');
+		return;
+	}
+
+	if (args.max_cns) {
+		selected_cns = selected_cns.slice(0, args.max_cns);
+	}
+
+	for (i = 0; i < args.num_instances; i++) {
+		var next_cn = selected_cns[i % selected_cns.length];
+
+		if (!cfg[next_cn].hasOwnProperty(args.svcname)) {
+			cfg[next_cn][args.svcname] = {};
+		}
+		if (!cfg[next_cn][args.svcname][args.image_uuid]) {
+			cfg[next_cn][args.svcname][args.image_uuid] = 0;
+		}
+
+		cfg[cn][args.svcname][args.image_uuid]++;
+	}
+
+	args.outstream.write(JSON.stringify(cfg, null, '    ') + '\n');
+};
+
 /*
  * [public] Iterate zones matching a filter, invoking "callback" synchronously
  * for each one.  Returns an error if the filter was invalid.
@@ -2672,7 +2877,128 @@ maAdm.prototype.dumpDeployedConfigByService = function (sout, conf)
 	});
 };
 
-maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
+maAdm.prototype.loadServiceSpecificSAPIMetadata = function (args, callback)
+{
+	assertplus.object(args, 'args');
+	assertplus.string(args.svcname, 'args.svcname');
+
+	var svcConfigFile = path.join(__dirname, '..', 'config', 'services',
+	    args.svcname, 'service.json');
+
+	fs.readFile(svcConfigFile, function (err, contents) {
+		var conf, md;
+
+		if (err) {
+			err = new VError(err, 'read "%s"', svcConfigFile);
+			callback(err);
+			return;
+		}
+
+		try {
+			conf = JSON.parse(contents.toString('utf8'));
+		} catch (e) {
+			err = new VError(err, 'parse "%s"', svcConfigFile);
+			callback(err);
+			return;
+		}
+
+		md = conf.metadata || {};
+		callback(err, Object.keys(md));
+	});
+};
+
+maAdm.prototype.getDeployedInstanceMetadataJson = function (args, callback)
+{
+	var self, include_all, instuuids, rv, svc_objs;
+
+	assertplus.object(args, 'args');
+	assertplus.string(args.svcname, 'args.svcname');
+	assertplus.bool(args.include_all, 'args.include_all');
+
+	self = this;
+	rv = {};
+	include_all = args.include_all;
+	svc_objs = Object.keys(self.ma_services).filter(function (svcuuid) {
+		return (self.ma_services[svcuuid].name === args.svcname);
+	});
+	if (svc_objs.length === 0) {
+		return;
+	}
+	instuuids = Object.keys(self.ma_instance_info).filter(
+		function (instuuid) {
+		return (self.ma_instance_info[instuuid].inst_svcname ===
+		    args.svcname);
+	});
+
+	self.loadServiceSpecificSAPIMetadata(args, function (err, allowed) {
+		if (err) {
+			callback(err);
+			return;
+		}
+		vasync.forEachPipeline({
+			inputs: instuuids,
+			func: function (instuuid, next) {
+				rv[instuuid] = {};
+				var md = self.ma_instance_info[
+				    instuuid].inst_metadata;
+				if (include_all) {
+					allowed = Object.keys(md);
+				}
+				for (var i = 0; i < allowed.length; i++) {
+					var property = allowed[i];
+					if (md.hasOwnProperty(property)) {
+						rv[instuuid][property] =
+						    md[property];
+					}
+				}
+				next();
+			}
+		}, function (_) {
+			callback(rv);
+		});
+	});
+};
+
+maAdm.prototype.dumpDeployedInstanceMetadataJson = function (sout, conf)
+{
+	var self = this;
+
+	assertplus.optionalBool(conf.include_all, 'conf.include_all');
+
+	if (conf.include_all === undefined) {
+		conf.include_all = false;
+	}
+
+	self.getDeployedInstanceMetadataJson(conf, function (rv) {
+		sout.write(JSON.stringify(rv, null, '    ') + '\n');
+	});
+
+};
+
+maAdm.prototype.updateDeployedInstanceMetadata = function (callback)
+{
+	var self = this;
+
+	vasync.forEachPipeline({
+		inputs: Object.keys(self.ma_instance_metadata_updates),
+		func: function (instuuid, next) {
+			var updates = self.ma_instance_metadata_updates[
+			    instuuid];
+			self.ma_sdc.SAPI.updateInstance(instuuid, {
+			    metadata: updates
+			}, next);
+		}
+	}, function (err) {
+		if (err) {
+			callback(new VError('error while updating ' +
+			    'instance metadata', err));
+			return;
+		}
+		callback();
+	});
+};
+
+maAdm.prototype.getDeployedConfigByServiceJson = function ()
 {
 	var self, svcuuids, rv;
 
@@ -2699,6 +3025,13 @@ maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
 		}
 	});
 
+	return (rv);
+};
+
+maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
+{
+	var rv = this.getDeployedConfigByServiceJson();
+
 	sout.write(JSON.stringify(rv, null, '    ') + '\n');
 };
 
@@ -3078,6 +3411,55 @@ maAdm.prototype.readConfigRaw = function (contents)
 	return (null);
 };
 
+maAdm.prototype.readInstanceMetadataConfigFromFile =
+function (filename, callback)
+{
+	var self = this;
+	fs.readFile(filename, function (err, contents) {
+		if (err) {
+			callback(new VError(err, 'reading "%s":', filename));
+			return;
+		}
+
+		err = self.readInstanceMetadataConfigRaw(
+		    contents.toString('utf8'));
+		if (err)
+			err = new VError(err, 'processing "%s"', filename);
+		callback(err);
+	});
+};
+
+maAdm.prototype.readInstanceMetadataConfigRaw = function (contents)
+{
+	var self, instuuid, prev_svcname, next_svcname, json;
+
+	self = this;
+
+	try {
+		json = JSON.parse(contents);
+	} catch (ex) {
+		return (ex);
+	}
+
+	for (instuuid in json) {
+		prev_svcname = next_svcname;
+		if (!self.ma_instance_info.hasOwnProperty(instuuid)) {
+			return (new VError('unknown instance "%s"', instuuid));
+		}
+		next_svcname = self.ma_instance_info[instuuid].inst_svcname;
+
+		if (prev_svcname !== undefined &&
+		    prev_svcname !== next_svcname) {
+			return (new VError('instances of mulitple distinct ' +
+				'services cannot be updated at once'));
+		}
+	}
+
+	self.ma_instance_metadata_updates = json;
+
+	return (null);
+};
+
 /*
  * Assuming we've already loaded the current deployed configuration and the
  * user-specified configuration, generate a plan to make reality match what the
-- 
2.21.0

