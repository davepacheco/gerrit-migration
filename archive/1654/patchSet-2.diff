commit 8011601b4a50cc3e9d23cae044df56c04566bab8 (refs/changes/54/1654/2)
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2017-03-14T16:57:38-07:00 (2 years, 7 months ago)
    
    AGENT-1065 cn-agent crashing with "Uncaught AssertionError: Cannot write to a destroyed stream"

diff --git a/lib/docker-stdio.js b/lib/docker-stdio.js
index 9a2029b..985c5b8 100644
--- a/lib/docker-stdio.js
+++ b/lib/docker-stdio.js
@@ -721,19 +721,26 @@ function tryEnd(socket) {
     }
 }
 
-function writeData(streamType, stream, chunk) {
-    assert.ok(stream);
-    assert.notEqual(stream.destroyed,
-        true,
-        'Cannot write to a destroyed stream');
-    assert.string(chunk);
+function writeData(opts) {
+    var data;
 
-    var data = JSON.stringify({
-        type: streamType,
-        data: chunk
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.streamType, 'opts.streamType');
+    assert.object(opts.stream, 'opts.stream');
+    assert.string(opts.chunk, 'opts.chunk');
+    assert.ok(opts.stream);
+
+    if (opts.stream.destroyed) {
+        opts.log.warn('cannot write to a destroyed stream');
+        return;
+    }
+
+    data = JSON.stringify({
+        type: opts.streamType,
+        data: opts.chunk
     }) + '\r\n';
 
-    stream.write(data);
+    opts.stream.write(data);
 }
 
 function writeEnd(stream, obj, callback) {
@@ -921,7 +928,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
 
     cmdSpawn.stdout.on('data', function (data) {
         params.stdout_written += data.length;
-        writeData(params.Tty ? 'tty' : 'stdout', socket, data.toString());
+        writeData({
+            log: log,
+            streamType: params.Tty ? 'tty' : 'stdout',
+            stream: socket,
+            chunk: data.toString()
+        });
     });
 
     cmdSpawn.stderr.on('data', function (data) {
@@ -941,9 +953,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
                     }, execline.message);
                     // TODO: send an error code back to the client instead
                     // of just the fatal message.
-                    writeData(params.Tty ? 'tty' : 'stderr',
-                        socket,
-                        execline.line + '\r\n');
+                    writeData({
+                        log: log,
+                        streamType: params.Tty ? 'tty' : 'stderr',
+                        stream: socket,
+                        chunk: execline.line + '\r\n'
+                    });
                 } else {
                     if (execline.message.indexOf('EXEC') === 0) {
                         params.in_dockerexec = false;
@@ -955,7 +970,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
                 }
             });
         } else {
-            writeData(params.Tty ? 'tty' : 'stderr', socket, data.toString());
+            writeData({
+                log: log,
+                streamType: params.Tty ? 'tty' : 'stderr',
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
@@ -1032,7 +1052,12 @@ function runContainerPtyCommand(params, cmd, args, socket) {
                     }, execline.message);
                     // TODO: send an error code back to the client instead
                     // of just the fatal message.
-                    writeData('tty', socket, execline.line + '\r\n');
+                    writeData({
+                        log: log,
+                        streamType: 'tty',
+                        stream: socket,
+                        chunk: execline.line + '\r\n'
+                    });
                 } else {
                     if (execline.message.indexOf('EXEC') === 0) {
                         in_dockerexec = false;
@@ -1045,7 +1070,12 @@ function runContainerPtyCommand(params, cmd, args, socket) {
             });
         } else {
             output_written += data.length;
-            writeData('tty', socket, data.toString());
+            writeData({
+                log: log,
+                streamType: 'tty',
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
@@ -1116,6 +1146,12 @@ function runContainerLogsCommand(container, params, socket) {
                 continue;
             }
 
+            // If the socket has already been closed, do not continue to try to
+            // write data to it.
+            if (socket.destroyed) {
+                break;
+            }
+
             var rec = JSON.parse(line);
             var data;
             if (params.Timestamps) {
@@ -1124,26 +1160,40 @@ function runContainerLogsCommand(container, params, socket) {
                 data = rec.log;
             }
 
-            writeData(rec.stream, socket, data.toString());
+            writeData({
+                log: log,
+                streamType: rec.stream,
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
-    cmdSpawn.on('exit', function (code, signal) {
+    cmdSpawn.on('exit', function onCmdSpawnExit(code, signal) {
         log.info('cmdSpawn "%s %s" exited with status code %d signal %s',
             cmd, cmdArgs.join(' '), code, signal);
     });
 
-    cmdSpawn.on('close', function (code, signal) {
+    cmdSpawn.on('close', function onCmdSpawnClose(code, signal) {
         log.info('cmdSpawn "%s %s" closed with status code %d signal %s',
             cmd, cmdArgs.join(' '), code, signal);
         tryEnd(socket);
     });
 
-    cmdSpawn.on('error', function (error) {
+    cmdSpawn.on('error', function onCmdSpawnError(error) {
         log.error('cmdSpawn threw an error %s', error.toString());
     });
 
-    socket.on('end', function () {
+    // Kill the cat/tail process after the socket is closed so we don't
+    // continue to get `readable` events from lstream.
+    socket.on('close', function onSocketClose() {
+        log.info(
+            'logs socket for container %s has closed, ending container stdio',
+            container);
+        cmdSpawn.kill();
+    });
+
+    socket.on('end', function onSocketEnd() {
         log.info('socket for "%s %s" has ended', cmd, cmdArgs.join(' '));
         tryEnd(socket);
     });
