commit a608a3a8312a02cd0036965021a588fabdbc3f8b (refs/changes/54/1654/4)
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2017-03-16T11:56:42-07:00 (2 years, 7 months ago)
    
    AGENT-1065 cn-agent crashing with "Uncaught AssertionError: Cannot write to a destroyed stream"

diff --git a/lib/docker-stdio.js b/lib/docker-stdio.js
index 9a2029b..24f2edd 100644
--- a/lib/docker-stdio.js
+++ b/lib/docker-stdio.js
@@ -19,6 +19,7 @@ var assert = require('assert-plus');
 var async = require('async');
 var bunyan = require('bunyan');
 var once = require('once');
+var VError = require('verror').VError;
 var child_process = require('child_process');
 var fs = require('fs');
 var http = require('http');
@@ -721,19 +722,26 @@ function tryEnd(socket) {
     }
 }
 
-function writeData(streamType, stream, chunk) {
-    assert.ok(stream);
-    assert.notEqual(stream.destroyed,
-        true,
-        'Cannot write to a destroyed stream');
-    assert.string(chunk);
+function writeData(opts) {
+    var data;
 
-    var data = JSON.stringify({
-        type: streamType,
-        data: chunk
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.streamType, 'opts.streamType');
+    assert.object(opts.stream, 'opts.stream');
+    assert.string(opts.chunk, 'opts.chunk');
+    assert.ok(opts.stream);
+
+    if (opts.stream.destroyed) {
+        opts.log.warn('cannot write to a destroyed stream');
+        return;
+    }
+
+    data = JSON.stringify({
+        type: opts.streamType,
+        data: opts.chunk
     }) + '\r\n';
 
-    stream.write(data);
+    opts.stream.write(data);
 }
 
 function writeEnd(stream, obj, callback) {
@@ -921,7 +929,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
 
     cmdSpawn.stdout.on('data', function (data) {
         params.stdout_written += data.length;
-        writeData(params.Tty ? 'tty' : 'stdout', socket, data.toString());
+        writeData({
+            log: log,
+            streamType: params.Tty ? 'tty' : 'stdout',
+            stream: socket,
+            chunk: data.toString()
+        });
     });
 
     cmdSpawn.stderr.on('data', function (data) {
@@ -941,9 +954,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
                     }, execline.message);
                     // TODO: send an error code back to the client instead
                     // of just the fatal message.
-                    writeData(params.Tty ? 'tty' : 'stderr',
-                        socket,
-                        execline.line + '\r\n');
+                    writeData({
+                        log: log,
+                        streamType: params.Tty ? 'tty' : 'stderr',
+                        stream: socket,
+                        chunk: execline.line + '\r\n'
+                    });
                 } else {
                     if (execline.message.indexOf('EXEC') === 0) {
                         params.in_dockerexec = false;
@@ -955,7 +971,12 @@ function runAttachedContainerCommand(params, log, cmdSpawn, socket) {
                 }
             });
         } else {
-            writeData(params.Tty ? 'tty' : 'stderr', socket, data.toString());
+            writeData({
+                log: log,
+                streamType: params.Tty ? 'tty' : 'stderr',
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
@@ -1032,7 +1053,12 @@ function runContainerPtyCommand(params, cmd, args, socket) {
                     }, execline.message);
                     // TODO: send an error code back to the client instead
                     // of just the fatal message.
-                    writeData('tty', socket, execline.line + '\r\n');
+                    writeData({
+                        log: log,
+                        streamType: 'tty',
+                        stream: socket,
+                        chunk: execline.line + '\r\n'
+                    });
                 } else {
                     if (execline.message.indexOf('EXEC') === 0) {
                         in_dockerexec = false;
@@ -1045,7 +1071,12 @@ function runContainerPtyCommand(params, cmd, args, socket) {
             });
         } else {
             output_written += data.length;
-            writeData('tty', socket, data.toString());
+            writeData({
+                log: log,
+                streamType: 'tty',
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
@@ -1075,15 +1106,22 @@ function runContainerPtyCommand(params, cmd, args, socket) {
 
 
 /*
- * cat/tail the stdio.log file and then use linestream to process every line
- * in order to correctly send data back to the multiplexed streams
+ * Run `cat` or `tail` (using the latter if we're "following") the stdio.log
+ * file and then use linestream to process every line in order to correctly
+ * send data back to the multiplexed streams.
  */
-function runContainerLogsCommand(container, params, socket) {
-    assert.object(params.log, 'log');
 
+function runContainerLogsCommand(container, params, socket) {
     var cmd;
     var cmdArgs = [];
+    var cmdSpawnExited = false;
+    var cmdSpawnExitInterval;
     var log = params.log;
+    var cmdSpawnExitCurrentlyWaited = 0;
+    var cmdSpawnExitIntervalDuration =  500;
+    var cmdSpawnExitTimeoutDuration = 5000;
+
+    assert.object(params.log, 'log');
 
     if (params.Tail === 'all' && !params.Follow) {
         cmd = '/usr/bin/cat';
@@ -1116,6 +1154,12 @@ function runContainerLogsCommand(container, params, socket) {
                 continue;
             }
 
+            // If the socket has already been closed, do not continue to try to
+            // write data to it.
+            if (socket.destroyed) {
+                break;
+            }
+
             var rec = JSON.parse(line);
             var data;
             if (params.Timestamps) {
@@ -1124,31 +1168,79 @@ function runContainerLogsCommand(container, params, socket) {
                 data = rec.log;
             }
 
-            writeData(rec.stream, socket, data.toString());
+            writeData({
+                log: log,
+                streamType: rec.stream,
+                stream: socket,
+                chunk: data.toString()
+            });
         }
     });
 
-    cmdSpawn.on('exit', function (code, signal) {
+    cmdSpawn.on('exit', function onCmdSpawnExit(code, signal) {
         log.info('cmdSpawn "%s %s" exited with status code %d signal %s',
             cmd, cmdArgs.join(' '), code, signal);
+        cmdSpawnExited = true;
+        clearInterval(cmdSpawnExitInterval);
+        lstream.removeAllListeners('readable');
     });
 
-    cmdSpawn.on('close', function (code, signal) {
+    cmdSpawn.on('close', function onCmdSpawnClose(code, signal) {
         log.info('cmdSpawn "%s %s" closed with status code %d signal %s',
             cmd, cmdArgs.join(' '), code, signal);
         tryEnd(socket);
     });
 
-    cmdSpawn.on('error', function (error) {
+    cmdSpawn.on('error', function onCmdSpawnError(error) {
         log.error('cmdSpawn threw an error %s', error.toString());
     });
 
-    socket.on('end', function () {
+    // Kill the cat/tail process after the socket is closed so we don't
+    // continue to get `readable` events from lstream.
+    socket.on('close', function onSocketClose() {
+        log.info(
+            'logs socket for container %s has closed, ending container stdio',
+            container);
+
+        cmdSpawn.kill();
+
+        beginExitCheckingInterval();
+    });
+
+    socket.on('end', function onSocketEnd() {
         log.info('socket for "%s %s" has ended', cmd, cmdArgs.join(' '));
         tryEnd(socket);
     });
 
     cmdSpawn.stdout.pipe(lstream);
+
+    function beginExitCheckingInterval() {
+        cmdSpawnExitInterval = setInterval(function onCmdSpawnExitInterval() {
+            cmdSpawnExitCurrentlyWaited += cmdSpawnExitInterval;
+
+            if (!cmdSpawnExited) {
+                cmdSpawn.kill();
+            } else {
+                // process has already exited, nothing left to do
+                clearInterval(cmdSpawnExitInterval);
+                return;
+            }
+
+            log.warn(
+                'stdio logs process has not exited (waiting %d seconds)',
+                cmdSpawnExitIntervalDuration / 1000);
+
+            if (cmdSpawnExitCurrentlyWaited >=
+                    cmdSpawnExitTimeoutDuration)
+            {
+                log.warn(
+                    'stdio logs process did not exit after signal ' +
+                    '(waited %d seconds)', cmdSpawnExitCurrentlyWaited / 1000);
+                throw new VError.VError(
+                    'could not terminate stdio logs child process');
+            }
+        }, cmdSpawnExitIntervalDuration).unref();
+    }
 }
 
 
