From f7c6e29c3ea474007f6c9b54967017156a1d05c4 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 1 Mar 2017 18:39:27 -0800
Subject: [PATCH] DOCKER-1005 want separate keys for docker and cloudapi
 (signed certificates)

---
 lib/auth.js  | 55 +++++++++++++++++++++++++++++++++++++++++++++++-----
 package.json |  2 +-
 2 files changed, 51 insertions(+), 6 deletions(-)

diff --git a/lib/auth.js b/lib/auth.js
index e7a3422..5ab41d7 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -62,6 +62,51 @@ function authTls(req, res, next) {
     var cert = sshpk.parseCertificate(peerCert.raw, 'x509');
     var peerKey = cert.subjectKey;
     var peerKeyFp = peerKey.fingerprint('sha512').toString();
+    var lookupFp = peerKey.fingerprint('md5').toString('hex');
+
+    /*
+     * As well as a simple self-signed certificate for an actual account key,
+     * we also accept a certificate for a different key that is validly signed
+     * by an account key.
+     *
+     * If the user is using one of these new types of certificates, enforce
+     * the expiry time and use the issuer's CN to look up the real account
+     * key.
+     */
+    if (cert.purposes.indexOf('joyentDocker') !== -1) {
+        log.trace('found "joyentDocker" certificate purpose, will treat as '
+            + 'new-style certificate');
+
+        if (cert.isExpired()) {
+            /*
+             * It's ok to tell the client details about this error -- we aren't
+             * telling them about anything in the DB, just about the cert they
+             * sent to us.
+             */
+            next(new errors.UnauthorizedError('Client certificate expired'));
+            return;
+        }
+
+        if (!cert.subjects[0].equals(cert.issuer)) {
+            var fp;
+            try {
+                fp = sshpk.parseFingerprint(cert.issuer.cn);
+                if (fp.algorithm === 'md5') {
+                    lookupFp = fp.toString('hex');
+                } else {
+                    log.info('CN= fingerprint in issuer was not MD5');
+                    fp = undefined;
+                }
+            } catch (e) {
+                log.info({err: e}, 'failed to parse CN= fingerprint in issuer');
+            }
+            if (fp === undefined) {
+                next(new errors.UnauthorizedError('Client certificate is not '
+                    + 'self-signed, and the issuer DN could not be parsed'));
+                return;
+            }
+        }
+    }
 
     var account;
     var ufdsKey;
@@ -94,8 +139,7 @@ function authTls(req, res, next) {
     }
 
     function getKey(_, cb) {
-        var fp = peerKey.fingerprint('md5').toString('hex');
-        ufds.getKey(account, fp, function (err, key) {
+        ufds.getKey(account, lookupFp, function (err, key) {
             if (err) {
                 log.info({err: err, login: login, authn: true},
                     'ufds.getKey err');
@@ -118,10 +162,11 @@ function authTls(req, res, next) {
             return;
         }
         /*
-         * Double-check with the SHA512 hash of the key, to prevent MD5
-         * collisions from breaking our authentication.
+         * Check the actual signature on the certificate -- this will prevent
+         * MD5 collisions from authing the key in the self-signed case,
+         * and will do the actual validation in the account-key-signed case.
          */
-        if (key.fingerprint('sha512').matches(peerKey)) {
+        if (cert.isSignedByKey(key)) {
             authCache.set(login, peerKeyFp);
             cb();
         } else {
diff --git a/package.json b/package.json
index 5a227c8..6c6a822 100644
--- a/package.json
+++ b/package.json
@@ -22,7 +22,7 @@
     "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#a3e7780",
     "sdc-clients": "10.0.3",
     "sprintf": "0.1.5",
-    "sshpk": "1.10.0",
+    "sshpk": "1.11.0",
     "strsplit": "1.0.0",
     "tape": "^4.4.0",
     "trace-event": "1.2.0",
-- 
2.21.0

