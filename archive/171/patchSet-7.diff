From c66da9a3a15e7029aece98db1634f0a597263471 Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 29 Jul 2016 21:30:46 +0000
Subject: [PATCH] NAPI-327 net-agent should not leak NICs

---
 bin/net-agent.js        |  17 +-
 lib/common.js           |  42 ++++
 lib/endpoints/index.js  |  24 ++
 lib/endpoints/status.js |  44 ++++
 lib/napi-client.js      |  29 ++-
 lib/net-agent.js        | 367 +++++++++++++++++++++++++++----
 lib/vm.js               | 169 +++++++-------
 package.json            |  18 +-
 tests/config.json       |   8 +
 tests/runtest           |  35 +++
 tests/unit/test.js      | 471 ++++++++++++++++++++++++++++++++++++++++
 11 files changed, 1087 insertions(+), 137 deletions(-)
 create mode 100644 lib/common.js
 create mode 100644 lib/endpoints/index.js
 create mode 100644 lib/endpoints/status.js
 create mode 100644 tests/config.json
 create mode 100755 tests/runtest
 create mode 100644 tests/unit/test.js

diff --git a/bin/net-agent.js b/bin/net-agent.js
index 5b009d2..21c7a3c 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -33,11 +33,6 @@ var sdcConfig;
 var agentConfig;
 var sysinfo;
 
-process.on('uncaughtException', function (e) {
-    console.error('uncaught exception:' + e.message);
-    console.log(e.stack);
-});
-
 function loadConfig(callback) {
     var configPath = '/opt/smartdc/agents/etc/net-agent.config.json';
 
@@ -129,7 +124,15 @@ async.waterfall([
     var netagent;
     if (agentConfig.no_rabbit) {
         netagent = new NetAgent(config);
-        netagent.start();
+        netagent.start(function (err2) {
+            if (err2) {
+                logger.fatal(err2, 'Failed to initialize server');
+                process.exit(1);
+            }
+            var addr = netagent.server.address();
+            logger.info('%s listening on <http://%s:%s>',
+                netagent.server.name, addr.address, addr.port);
+        });
     } else {
         logger.warn('"no_rabbit" flag is not true, net-agent will now sleep');
         // http://nodejs.org/docs/latest/api/all.html#all_settimeout_cb_ms
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..d1b37b0
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+var assert = require('assert-plus');
+var VError = require('verror');
+
+function assertStrictOptions(funcname, opts, expected)
+{
+    assert.string(funcname, 'funcname');
+    assert.object(opts, funcname + ': opts');
+    assert.object(expected, funcname + ': expected');
+
+    var unexpected = [];
+    for (var k in opts) {
+        if (!opts.hasOwnProperty(k)) {
+            continue;
+        }
+        var e = expected[k];
+        if (!e) {
+            unexpected.push(k);
+            continue;
+        }
+        var afunc = assert[e];
+        assert.func(afunc, 'invalid assertion type: ' + e);
+        afunc(opts[k], 'opts.' + k);
+    }
+
+    if (unexpected.length > 0) {
+        throw (new VError(funcname + ': unexpected options: ' +
+            unexpected.join(', ')));
+    }
+}
+
+module.exports = {
+    assertStrictOptions: assertStrictOptions
+};
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
new file mode 100644
index 0000000..42578fc
--- /dev/null
+++ b/lib/endpoints/index.js
@@ -0,0 +1,24 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var toRegister = {
+    '/status': require('./status')
+};
+
+function registerEndpoints(http, log, before) {
+    for (var t in toRegister) {
+        log.debug('Registering endpoints for "%s"', t);
+        toRegister[t].register(http, before);
+    }
+}
+
+module.exports = {
+    registerEndpoints: registerEndpoints
+};
diff --git a/lib/endpoints/status.js b/lib/endpoints/status.js
new file mode 100644
index 0000000..82527b9
--- /dev/null
+++ b/lib/endpoints/status.js
@@ -0,0 +1,44 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var mod_jsprim = require('jsprim');
+
+/*
+ * Status endpoint
+ */
+
+
+
+/*
+ * GET /status
+ */
+function
+getStatus(req, res, next)
+{
+    var stat = {
+        now: mod_jsprim.hrtimeMicrosec(process.hrtime(req.app.na_epoch)),
+        init_history: req.app.na_init_history
+    };
+    res.send(200, stat);
+    next();
+}
+
+function
+register(http, before)
+{
+    http.get({
+        path: '/status',
+        name: 'getStatus'
+    }, before, getStatus);
+}
+
+module.exports = {
+    register: register
+};
diff --git a/lib/napi-client.js b/lib/napi-client.js
index a17ea24..63c28c2 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,8 @@
 
 var async = require('async');
 var NAPI = require('sdc-clients').NAPI;
+var assert = require('assert-plus');
+var common = require('./common');
 
 var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
     'allow_mac_spoofing', 'allow_restricted_traffic',
@@ -44,7 +46,7 @@ function NapiClient(options) {
  *
  * 1. NIC was removed from the VM or VM provision has failed (destroy)
  * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be udpated (update)
+ * 3. NIC exists and has to be updated (update)
  * 4. NIC exists and but has not changed, no need to do anything (noop)
  */
 NapiClient.prototype.updateNics = function (vm, nics, callback) {
@@ -92,10 +94,17 @@ NapiClient.prototype.updateNics = function (vm, nics, callback) {
 
 
 NapiClient.prototype.getNic = function (mac, callback) {
+    assert.object(this.client, 'this.client');
     return this.client.getNic(mac, callback);
 };
 
 
+NapiClient.prototype.searchNics = function (params, callback) {
+    assert.func(callback, 'callback');
+    this.client.searchNics(params, callback);
+};
+
+
 NapiClient.prototype.createNic = function (vm, newNic, callback) {
     var log = this.log;
     var nic = _createNicPayload(vm, newNic);
@@ -127,7 +136,7 @@ NapiClient.prototype.updateNic = function (vm, newNic, napiNic, callback) {
 
     this.client.updateNic(nic.mac, nic, function (err) {
         if (err) {
-            log.error(err, 'Could not udpate NIC %s for VM %s',
+            log.error(err, 'Could not update NIC %s for VM %s',
                 nic.mac, vm.uuid);
             return callback(err);
         }
@@ -162,6 +171,14 @@ NapiClient.prototype.deleteNic = function (vm, nic, callback) {
 };
 
 
+NapiClient.prototype.getNics = function (belongsTo, options, callback) {
+    common.assertStrictOptions('getNics', options, {
+        headers: 'string'
+    });
+    this.client.getNics(belongsTo, options, callback);
+};
+
+
 
 /*
  * Some helper functions for NapiClient
@@ -171,17 +188,15 @@ function _nicChanged(cur, old) {
     var fields = [ 'cn_uuid', 'vlan_id', 'nic_tag', 'primary', 'ip', 'netmask',
         'state' ].concat(ANTI_SPOOF_FIELDS);
     var field;
-    var diff = false;
 
     for (var i = 0; i < fields.length; i++) {
         field = fields[i];
         if (cur[field] !== old[field]) {
-            diff = true;
-            break;
+            return true;
         }
     }
 
-    return diff;
+    return false;
 }
 
 
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 64604a2..82e59c4 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,18 +5,99 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
- * net-agent.js
+ * Net-Agent and NAPI
+ * ==================
+ *
+ * VM Change Events
+ * ----------------
+ *
+ * Net-agent's job is to inform NAPI of any changes to any NICs that result
+ * from VM-related events. For instance, if a VM gets destroyed (either by
+ * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
+ * for telling NAPI that the NIC that used to belong to that VM should be
+ * destroyed.
+ *
+ * Net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone configurations XML file has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever a change is detected, net-agent walks its internal list of VM
+ * objects (which also contains the NIC info) and pushes the NIC objects to
+ * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
+ * address.
+ *
+ * Orphaned NICs
+ * -------------
+ *
+ * One cannot assume that net-agent is continuously reacting to every single
+ * event on a compute node (CN). For example net-agent may be disabled by an
+ * operator, may go down due to an error, or may not receive an event (it
+ * happens). To handle these situations, when net-agent starts up it scans
+ * every NIC on the CN[1], and tells NAPI to delete any NIC if it does not have
+ * a corresponding VM (that is not destroyed). This is only done once on
+ * startup because such a scan can be very expensive.
+ *
+ * [1]: Currently we scan every NIC in the DC, since NAPI doesn't allow us to
+ * filter NICs by compute node. But as soon as it does, we will switch to that
+ * (see NAPI-360).  This means that we have to ignore NICs that have a
+ * `cn_uuid` different from the agent's.
+ *
+ * Net-Agent and Compute Nodes
+ * ===========================
+ *
+ * The previous section described the interaction between a single net-agent
+ * service and a single NAPI service. However, we always have more than one
+ * net-agent. In fact we have one net-agent per CN. All of these net-agents
+ * react only to VM events on their respective CNs. However, they are modifying
+ * global NIC objects, and they all connect to a single NAPI service (this may
+ * change in the future). It is important to keep this mind. We don't want all
+ * of our net-agents to start battering NAPI with requests at the same time.
+ * For the change-event-related requests this is not a problem. However, for
+ * the orphaned-nic-related requests, this could be catastrophic. This is why
+ * we insert a random delay before the searchNics request that is no greater
+ * than 10 minutes.
+ *
+ * Net-Agent and VMs
+ * =================
+ *
+ * Net-Agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory. This set of
+ * VM objects is known as the sample.
+ *
+ * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * and processing the JSON that it produces on stdout. `zoneevent` emits output
+ * whenever a property of the zone has changed. Note that it does not report
+ * higher-level VM properties (that are used by vmadm and vmapi).
+ *
+ * As Net-Agent receives these change events, it updates the changed properties
+ * of the VM objects in the sample. However, it is possible that one of the
+ * change-events does not make it to net-agent. In order to mitigate the drift
+ * between net-agent's picture of reality, and reality itself, net-agent also
+ * does a full `vmadm lookup` every minute, and emits state-change events if it
+ * detects a difference.
  */
 
 var async = require('async');
+var vasync = require('vasync');
 var backoff = require('backoff');
+var restify = require('restify');
+var assert = require('assert-plus');
+var endpoints = require('./endpoints');
 
 var VM = require('./vm');
+var vmadm = require('vmadm');
 var NAPI = require('./napi-client');
+var mod_jsprim = require('jsprim');
+var common = require('./common');
+var VError = require('verror');
+
 
 var _versionCache = null;
 function getNetAgentVersion() {
@@ -33,6 +114,20 @@ function NetAgent(options) {
     this.lastFullSample = null;
     this.uuid = options.uuid;
     this.version = getNetAgentVersion();
+    this.reapNicsTimeout = undefined;
+    this.reapFinished = false;
+    /* The below delays are in microseconds */
+    this.reapNicsLongDelay = 60 * 60 * 1000;
+    var min_timeout = 2 * 60 * 1000;
+    var max_timeout = 10 * 60 * 1000;
+    this.reapNicsStartupDelay = Math.floor(Math.random() * (max_timeout -
+        min_timeout + 1)) + min_timeout;
+    /* The 2 delays below are in millisconds */
+    this.reapNicsInitDelay = 2000;
+    this.reapNicsMaxDelay = 64000;
+    this.na_server = null;
+    this.na_epoch = process.hrtime();
+    this.na_init_history = [];
 
     var userAgent = 'net-agent/' + this.version +
         ' (' + 'node/' + process.versions.node + ')' +
@@ -55,32 +150,198 @@ function NetAgent(options) {
     this.queues = {};
 }
 
+NetAgent.prototype.history = function history(name) {
+    var delta = mod_jsprim.hrtimeMicrosec(process.hrtime(this.na_epoch));
+    this.na_init_history.push({
+        h_name: name,
+        h_time: delta
+    });
+};
+
+/*
+ * This function initializes the restify HTTP server.
+ * Currently, it temporarily listens on port 5311, until we nail down a proper
+ * port-allocation policy for SDC's agents.
+ */
+NetAgent.prototype.initializeServer = function (callback) {
+    var self = this;
+    self.na_server = restify.createServer({
+        log: self.log,
+        name: 'Net Agent',
+        version: '0.0.1'
+    });
+    function populateReq(req, res, next) {
+        req.app = self;
+        next();
+    }
+    endpoints.registerEndpoints(self.na_server, self.log.child({
+        component: 'restify'
+    }), [ populateReq ]);
+
+    self.na_server.listen(5311, callback);
+};
+
 
-NetAgent.prototype.start = function () {
+NetAgent.prototype.start = function (callback) {
     var self = this;
     var log = this.log;
 
-    this.initializeEventWatcher();
+    this.history('InitializingServer');
+    this.initializeServer(function (err) {
+        if (err) {
+            callback(new VError(err, 'could not initialize server'));
+            return;
+        }
+        self.history('InitializingEventWatcher');
+        self.initializeEventWatcher();
+        self.history('InitializedEventWatcher');
+
+        // Wrap our initial full sample in a retry-backoff
+        var opts = { uuid: self.uuid };
+        var fn = self.sendFullSample.bind(self, opts);
+        self.retryUpdate(fn, opts, function onRetry(err2) {
+            if (err2) {
+                log.error(err2, 'Failed retry-backoff ' +
+                    'for initial sendFullSample');
+                return;
+            }
+
+            log.info('Initial NICs state was successfully sent. Good to go');
+            callback();
+        });
+    });
+};
 
-    // Wrap our initial full sample in a retry-backoff
-    var opts = { uuid: this.uuid };
-    var fn = this.sendFullSample.bind(this, opts);
-    this.retryUpdate(fn, opts, onRetry);
+/*
+ * Called on startup. Function asks NAPI for all allocated NICs.  It uses this
+ * list to detect leaked NICs by querying for NICs that are allocated,
+ * unreserved, belong to type 'zone', and not assigned to any existing VM. It
+ * emits a leaked_nic event, which net-agent responds to by destroying the NIC.
+ */
+NetAgent.prototype.reapNics = function () {
+    var self = this;
 
-    function onRetry(err) {
+    assert.object(this.napiClient, 'this.napiClient');
+    assert.object(this.napiClient.log);
+    var log = this.napiClient.log;
+    var napiClient = this.napiClient;
+    var cn_uuid = this.uuid;
+    /*
+     * We get the list of NICs on this CN from NAPI.
+     */
+    function search_nics_cb(err, nics) {
+        /*
+         * We can get an error for the following reasons:
+         *
+         *      -we provided an invalid parameter to the endpoint
+         *      -the /search/nics endpoint does not exist
+         *
+         * The former would be indicative of a bug in SDC, specifically
+         * net-agent (as we should always be passing valid params). The latter
+         * would be indicative of an outdated version of NAPI. If either of
+         * these things happen, we don't initiate any kind of reap. If NAPI
+         * gets upgraded, this will be detected after a very long backoff.
+         */
         if (err) {
-            log.error(err, 'Failed retry-backoff for initial sendFullSample');
+            if (err.body.code === 'InvalidParameters') {
+                log.error('Invalid params passed to /search/nics');
+                self.history('SkippedReapNics');
+            } else if (err.body.code === 'ResourceNotFound') {
+                log.info('Old version of NAPI does not support /search/nics');
+                self.history('BackedOffReapNics');
+                setTimeout(self.reapNics.bind(self), self.reapNicsLongDelay);
+            }
             return;
         }
+        if (self.sample.length > 0) {
+            self.sample.forEach(function backfill_walk_sample(vm) {
+                if (vm.nics.length === 0) {
+                    return;
+                }
+                var nicsToUpdate = [];
+                vm.nics.forEach(function vm_nics(vmnic) {
+                    var found = nics.filter(function find_mac(nic) {
+                        return (vmnic.mac === nic.mac);
+                    });
+                    if (found.length === 0) {
+                        vmnic.cn_uuid = vm.server_uuid;
+                        vmnic.state = 'running';
+                        nicsToUpdate.push(vmnic);
+                    }
+                });
+                self.napiClient.updateNics(vm, nicsToUpdate, function
+                    upnics_cb(err2, res) {
+
+                    if (err2) {
+                        log.error('updateNics failed during backfill.');
+                    }
+                });
+            });
+        }
+        var leaked_nics = nics.filter(function scan_nics(nic) {
+            if (nic.belongs_to_type !== 'zone') {
+                return (false);
+            }
+            if (self.sample[nic.belongs_to_uuid]) {
+                return (false);
+            }
+            return (true);
+        });
+
+        self.history('StartedReapNics');
+        function reap_nic(nic, cb) {
+            /*
+             * Currently, the implementation of deleteNic only looks at the
+             * UUID of the VM. If we are in this function, we know that the
+             * VM itself no longer exists, which is why we don't have a
+             * complete VM object. If deleteNic starts accessing other vm
+             * members in the future, we will have to add them to the
+             * `targ_vm` obj below.
+             */
+            var targ_vm = { uuid: nic.belongs_to_uuid };
+            napiClient.deleteNic(targ_vm, nic,
+                function handle_delete_nic(err2, res2) {
+
+                /*
+                 * If we get an error when trying to delete a NIC, the pipeline
+                 * that we are running in (see below), will stop. So, retrying
+                 * only the delete requests that fail is impossible. So,
+                 * instead, we will want to restart the entire reap process.
+                 */
+                if (err2) {
+                    log.error(err2, 'Error while deleting NIC');
+                    self.reapNics();
+                    cb(err2);
+                    return;
+                }
+                cb(null, res2);
+                return;
+            });
+        }
+
+        vasync.forEachPipeline({
+            'func': reap_nic,
+            'inputs': leaked_nics
+        }, function (err2, res) {
+            if (err2) {
+                log.error(err2, 'Error in vasync reap-pipeline');
+            }
+        });
 
-        log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
     }
+    var retry = backoff.call(napiClient.searchNics.bind(napiClient),
+        { cn_uuid: cn_uuid }, search_nics_cb);
+    retry.retryIf(function (err) {
+        return (err.body.code !== 'InvalidParameters' &&
+                err.body.code !== 'ResourceNotFound');
+    });
+    retry.setStrategy(new backoff.ExponentialStrategy({
+        initialDelay: self.reapNicsInitDelay,
+        maxDelay: self.reapNicsMaxDelay
+    }));
+    retry.start();
 };
 
-
 /*
  * Initializes the EventWatcher event listeners
  */
@@ -89,7 +350,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
     var log = this.log;
     var eventWatcher = this.eventWatcher;
 
-    eventWatcher.on('state', function (uuid, state) {
+    eventWatcher.on('state', function vm_state_event(uuid, state) {
         log.debug('state event for %s state: %s', uuid, state);
         self.pushSample({
             uuid: uuid,
@@ -97,7 +358,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_state', function (uuid, zone_state) {
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
         log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
         self.pushSample({
             uuid: uuid,
@@ -105,7 +366,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_xml', function (uuid) {
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
         log.debug('fs.watch event on /etc/zones for %s', uuid);
         self.pushSample({
             uuid: uuid,
@@ -113,7 +374,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('destroyed', function (uuid) {
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
         var vm = self.sample[uuid];
         if (!vm) {
             log.warn('VM %s appears to have gone away but ' +
@@ -123,10 +384,13 @@ NetAgent.prototype.initializeEventWatcher = function () {
 
         log.info('Found a destroyed VM %s', uuid);
         vm.state = 'destroyed';
-        self.pushSample({ uuid: uuid, cachedVm: vm });
+        self.pushSample({
+            uuid: uuid,
+            cachedVm: vm
+        });
     });
 
-    eventWatcher.on('err', function (err) {
+    eventWatcher.on('err', function zone_err_event(err) {
         log.error(err, 'eventWatcher saw en error');
     });
 };
@@ -140,7 +404,6 @@ NetAgent.prototype.setSample = function (sample) {
     });
 };
 
-
 /*
  * On startup, sendFullSample updates all NICs for all VMs on the server. This
  * will be a blocking call before we turn on the event listeners so we allow
@@ -150,19 +413,43 @@ NetAgent.prototype.sendFullSample = function (opts, callback) {
     var self = this;
     var log = this.log;
 
+    function startEventWatchers() {
+        self.history('StartingEventWatcher');
+        self.eventWatcher.updateState(self.sample);
+        self.eventWatcher.lastCfgEvent = self.lastFullSample;
+        self.eventWatcher.start();
+        self.history('StartedEventWatcher');
+    }
+
+    function doReapNics() {
+        /*
+         * If we fail to sendFullSample, this function will get retried. If we
+         * have already initiated a delayed reapNics() call, we don't want to
+         * re-initiate it.
+         */
+        if (self.reapNicsTimeout === undefined) {
+            self.reapNicsTimeout = setTimeout(function () {
+                self.reapNics();
+            }, self.reapNicsStartupDelay);
+        }
+    }
+
     this.updateSample({}, function (err, sample) {
         if (err) {
             log.error(err, 'updateSample failed, cannot sendFullSample');
             callback(err);
             return;
-
         } else if (Object.keys(sample).length === 0) {
-            log.warn('empty sample returned by vmadm lookup');
+            log.warn('Empty sample returned by vmadm lookup');
+            startEventWatchers();
+            doReapNics();
             callback();
             return;
         }
 
         self.setSample(sample);
+        startEventWatchers();
+        doReapNics();
 
         async.forEachSeries(Object.keys(sample), function (uuid, cb) {
             var options = {
@@ -199,16 +486,14 @@ NetAgent.prototype.sendSample = function (options, callback) {
         this.eventWatcher.removeState(options.uuid);
 
         self._updateVmNics(options, callback);
-
     } else {
         this.updateSample(options, function (err, sample) {
             if (err) {
                 log.error(err, 'updateSample failed, cannot sendSample');
                 callback(err);
-
             } else if (Object.keys(sample).length === 0) {
                 log.warn('empty sample returned by vmadm lookup');
-                 callback();
+                callback();
             } else {
                 self.eventWatcher.updateState(sample);
                 self.setSample(sample);
@@ -234,9 +519,17 @@ NetAgent.prototype.sendSample = function (options, callback) {
  * VM (or our net-agent has just started)
  */
 NetAgent.prototype._updateVmNics = function (options, callback) {
+    common.assertStrictOptions('_updateVmNics', options, {
+        uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject'
+    });
     var log = this.log;
+
     var allNics = [];
 
+    assert.uuid(this.uuid, 'this.uuid');
+
     if (options.vm) {
         options.vm.nics.forEach(function (nic) {
             // When VM is failed just mark all NICs are destroyed
@@ -292,7 +585,6 @@ NetAgent.prototype.pushSample = function (options) {
     if (this.queues[uuid] === undefined) {
         this.queues[uuid] = this.createQueue(uuid);
     }
-
     this.queues[uuid].push(options);
 };
 
@@ -301,6 +593,8 @@ NetAgent.prototype.pushSample = function (options) {
  * Retries an update operation.
  */
 NetAgent.prototype.retryUpdate = function (fn, options, callback) {
+    assert.object(options);
+    assert.uuid(options.uuid);
     var log = this.log;
     var retryOpts = { initialDelay: 2000, maxDelay: 64000 };
 
@@ -326,17 +620,16 @@ NetAgent.prototype.retryUpdate = function (fn, options, callback) {
         return (_log);
     }
 
-    var retry = backoff.call(fn, function (err) {
+    var retry = backoff.call(fn, function backoffCallCb(err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
 
         if (err) {
             log.error({ uuid: options.uuid },
                 'Could not retry operation after %d attempts', attempts);
             return callback(err);
         }
-
         return callback();
     });
 
@@ -359,9 +652,9 @@ NetAgent.prototype.createQueue = function (uuid) {
     var self = this;
     var log = this.log;
 
-    var queue = async.queue(function (opts, callback) {
+    var queue = async.queue(function qcb(opts, callback) {
         var fn = self.sendSample.bind(self, opts);
-        self.retryUpdate(fn, opts, function (err) {
+        self.retryUpdate(fn, opts, function retryUpdateCb(err) {
             if (err) {
                 log.error(err, 'Error updating NICs %', uuid);
                 return callback(err);
@@ -416,6 +709,7 @@ NetAgent.prototype.createQueue = function (uuid) {
 NetAgent.prototype.updateSample = function (options, callback) {
     if (!this._sampleQueue)
         this._sampleQueue = async.queue(updateSample.bind(this), 8);
+
     this._sampleQueue.push(options, callback);
 };
 
@@ -441,7 +735,7 @@ function updateSample(options, callback) {
 
         log.debug('Starting updateSample ' + query);
 
-        VM.list(searchOpts, function (err, vmobjs) {
+        vmadm.lookup(searchOpts, { log: log }, function (err, vmobjs) {
             var vmobj;
             var running = 0;
             var notRunning = 0;
@@ -450,7 +744,6 @@ function updateSample(options, callback) {
             if (err) {
                 log.error(err, 'ERROR: unable update VM list');
                 return cb(err);
-
             } else {
                 for (vmobj in vmobjs) {
                     vmobj = vmobjs[vmobj];
@@ -471,7 +764,7 @@ function updateSample(options, callback) {
                     notRunning: notRunning,
                     nonInventory: nonInventory
                 };
-                log.trace(lookupResults, 'Lookup query results');
+                log.info(lookupResults, 'Lookup query results');
 
                 return cb(null);
             }
@@ -501,7 +794,7 @@ function updateSample(options, callback) {
     var retry = backoff.call(lookup, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
         if (err) {
             log.error('Could not updateSample after %d attempts', attempts);
             return callback(err);
diff --git a/lib/vm.js b/lib/vm.js
index 5715c40..d10ce57 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -21,10 +21,13 @@ var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var EventEmitter = require('events').EventEmitter;
+var vmadm = require('vmadm');
+var LineStream = require('lstream');
+var VError = require('verror');
+var forkexec = require('forkexec');
 
 var async = require('async');
 
-var VMADM = '/usr/sbin/vmadm';
 
 
 
@@ -38,44 +41,6 @@ function isLocal(vms, vm) {
     return null;
 }
 
-
-function listVMs(filter, fields, callback) {
-    if (!callback) {
-        callback = fields;
-        fields = undefined;
-    }
-
-    var args = ['lookup', '-j'];
-    for (var k in filter) {
-        args.push(k + '=' + filter[k]);
-    }
-    if (fields) {
-        args.push('-o', fields.join(','));
-    }
-
-    return execFile(VMADM, args, {maxBuffer: 32 * 1024 * 1024},
-        function (err, stdout, stderr) {
-
-        if (err) {
-            err.stdout = stdout;
-            err.stderr = stderr;
-            return callback(err);
-        }
-
-        var vms;
-
-        try {
-            vms = JSON.parse(stdout);
-        } catch (jsonErr) {
-            jsonErr.stdout = stdout;
-            return callback(jsonErr);
-        }
-
-        return callback(null, vms);
-    });
-}
-
-
 // These are the events being watched by the zoneevent watcher. When zones
 // don't switch to these zone_states we ignore them
 var watchEvents = {
@@ -83,7 +48,7 @@ var watchEvents = {
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 30000;
+var STATE_WATCHER_TIMEOUT = 60 * 1000;
 
 /*
  * The EventWatcher will emit these events:
@@ -128,7 +93,7 @@ EventWatcher.prototype.start = function () {
 EventWatcher.prototype.updateState = function (objs) {
     var self = this;
 
-    Object.keys(objs).forEach(function (uuid) {
+    Object.keys(objs).forEach(function foreachobjs(uuid) {
         self.vmStates[uuid] = {
             state: objs[uuid].state,
             zone_state: objs[uuid].zone_state
@@ -166,10 +131,6 @@ EventWatcher.prototype.startStateWatcher = function () {
         }
 
         vmobjs.forEach(function (vm) {
-            // Only use inventory vms
-            if (vm.do_not_inventory) {
-                return;
-            }
 
             // Don't emit when states stay the same
             var current = self.getState(vm.uuid);
@@ -191,14 +152,33 @@ EventWatcher.prototype.startStateWatcher = function () {
         setTimeout(lookup, STATE_WATCHER_TIMEOUT);
     }
 
-    var lookup = listVMs.bind(null,
-        {}, ['uuid', 'state', 'zone_state', 'do_not_inventory'], onLookup);
+    /*
+     * We get a list of all VMs that don't have the do_not_inventory flag set.
+     * This flag is used by tests and ops to get some things done. For example
+     * it is used by the migrator script to signal to SDC that events for the
+     * target VM should be ignored.
+     */
+    var lookup = vmadm.lookup.bind(null, {}, {
+        fields: [
+            'uuid',
+            'state',
+            'zone_state'],
+         log: log,
+         include_dni: false
+    }, onLookup);
 
     lookup();
 };
 
-
 EventWatcher.prototype.startZoneWatcher = function () {
+    /*
+     * sendFullSample is called in an infinite retry loop. We don't want to
+     * create a swarm of zoneevent processes. Therefore we simply return from
+     * this function, if we already have one such process running.
+     */
+    if (this.zoneeventWatcher !== null) {
+        return;
+    }
     var log = this.log;
     var self = this;
 
@@ -209,32 +189,45 @@ EventWatcher.prototype.startZoneWatcher = function () {
 
     log.info('zoneevent running with pid ' + watcher.pid);
 
-    function onData(data) {
-        log.trace('zone event: ', data.toString());
-
-        // There can be more than one event in a single data event
-        var events = data.toString().split('\n');
-        events.forEach(processEvent);
-    }
-
-    function processEvent(event) {
-        if (event === '') {
-            return;
+    var stdoutStream = new LineStream();
+    var stderrStream = new LineStream();
+    watcher.stdout.pipe(stdoutStream);
+    watcher.stderr.pipe(stderrStream);
+    stdoutStream.on('readable', function () {
+        var line;
+        while ((line = stdoutStream.read()) !== null) {
+            log.info('zone event stderr: ', line.toString());
+            var event = JSON.parse(line);
+            if (watchEvents[event.newstate]) {
+                self.emit('zone_state', event.zonename, event.newstate);
+            }
         }
-
-        event = JSON.parse(event);
-
-        // Only updateSample when it is an event we're watching
-        if (watchEvents[event.newstate]) {
-            self.emit('zone_state', event.zonename, event.newstate);
+    });
+    stderrStream.on('readable', function () {
+        var line;
+        while ((line = stderrStream.read()) !== null) {
+            log.error('zone event stderr: ', line.toString());
         }
-    }
-
-    watcher.stdout.on('data', onData);
+    });
     watcher.stdin.end();
+    var stdout_ended = false;
+    var watcher_exited = false;
+    watcher.stdout.on('end', function () {
+        stdout_ended = true;
+        if (watcher_exited) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+            self.zoneeventWatcher = null;
+        }
+    });
     watcher.on('exit', function (code) {
-        log.warn('zoneevent watcher exited.');
-        watcher = null;
+        if (stdout_ended) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+            self.zoneeventWatcher = null;
+        } else {
+            watcher_exited = true;
+        }
     });
 };
 
@@ -354,27 +347,41 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
  * Double-checks if a VM is actually destroyed
  */
 function checkDestroyed(uuid, callback) {
-    var cmd = '/usr/sbin/zoneadm list -pc | grep ' + uuid + ' || true';
-    exec(cmd, [], function (exitStatus, stdout, stderr) {
-        if (exitStatus) {
-            return callback(new Error(stderr.toString()));
+    var argv = ['/usr/sbin/zoneadm', 'list', '-pc'];
+    var args = {
+        argv: argv,
+        includeStderr: true,
+        timeout: 0
+    };
+    forkexec.forkExecWait(args, function (err, info) {
+        if (err) {
+            return callback(err);
+        }
+        if (info.status !== 0) {
+            return callback(new VError(info.stderr));
+        } else {
+            if (info.stdout.length === 0) {
+                return callback(null, true);
+            }
+            var finalOut = info.stdout.split('\n').filter(function (l) {
+                return (l.indexOf(uuid) !== -1);
+            });
+            if (finalOut.length > 0) {
+                return callback(null, false);
+            } else {
+                return callback(null, true);
+            }
         }
-
-        var destroyed = (stdout.toString().trim() === '');
-        return callback(null, destroyed);
     });
 }
 
-
 function createEventWatcher(options) {
     assert.ok(options.log, 'EventWatcher options.log');
-
     return new EventWatcher(options);
 }
 
 
 module.exports = {
     isLocal: isLocal,
-    list: listVMs,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index 8a31a32..a352d04 100644
--- a/package.json
+++ b/package.json
@@ -6,15 +6,23 @@
     "private": true,
     "dependencies": {
         "async": "0.1.18",
-        "backoff": "2.3.0",
+        "vasync": "^1.6.4",
+        "assert-plus": "^1.0.0",
+        "backoff": "2.5.0",
         "bunyan": "1.3.2",
-        "sdc-bunyan-serializers": "git+ssh://git@github.com:joyent/sdc-bunyan-serializers.git#aefc119",
-        "nodeunit": "0.7.4",
+        "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#aefc119",
         "restify": "2.7.0",
-        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#c962959"
+        "sdc-clients": "^9.5.0",
+        "vmadm": "git+https://github.com/joyent/node-vmadm.git#3cf878481d24c1bc1e74e85a95004a3dde6329f1",
+        "lstream": "0.0.4",
+        "verror": "^1.6.1",
+        "jsprim": "^1.3.0",
+        "forkexec": "^1.1.0"
     },
     "sdcDependencies": {
-        "config-agent": ">=1.3.0"
+        "config-agent": ">=1.3.0",
+        "tape": "4.2.2",
+        "smf": "0.3.1"
     },
     "scripts": {
         "postinstall": "npm/postinstall.sh",
diff --git a/tests/config.json b/tests/config.json
new file mode 100644
index 0000000..ae11c8b
--- /dev/null
+++ b/tests/config.json
@@ -0,0 +1,8 @@
+{
+    "vmapi": {
+        "url": "http://vmapi.coal-1.joyent.us"
+    },
+    "napi": {
+        "url": "http://napi.coal-1.joyent.us"
+    }
+}
diff --git a/tests/runtest b/tests/runtest
new file mode 100755
index 0000000..8b3b419
--- /dev/null
+++ b/tests/runtest
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Run a single net-agent test of any type.
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE_INSTALL=$TOP/node
+UNAME=$(uname -s)
+
+guard_file=/lib/sdc/.sdc-test-no-production-data
+if [[ $UNAME == "SunOS" ]] && [[ ! -f "$guard_file" ]]; then
+    cat <<EOF
+To run this test you must create the file:
+
+    $guard_file
+
+after ensuring you have no production data on this SDC.
+EOF
+    exit 2
+fi
+
+if [[ $1 != "" ]]; then
+	PATH=$NODE_INSTALL/bin:$PATH node $1
+else
+	echo "You must supply an argument to this script"
+fi
diff --git a/tests/unit/test.js b/tests/unit/test.js
new file mode 100644
index 0000000..b213221
--- /dev/null
+++ b/tests/unit/test.js
@@ -0,0 +1,471 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var path = require('path');
+var fs = require('fs');
+
+var DEFAULT_CFG = path.join(__dirname, '..', '/config.json');
+var config = {};
+try {
+    config = JSON.parse(fs.readFileSync(DEFAULT_CFG, 'utf8'));
+} catch (e) {
+    console.log('Error reading config');
+    console.log(e);
+    process.exit(1);
+}
+
+/*
+ * Constants
+ */
+
+var VMAPI_URL = config.vmapi.url || 'http://vmapi.coal-1.joyent.us';
+var NAPI_URL = config.napi.url || 'http://napi.coal-1.joyent.us';
+
+var EXTERNAL_NET = undefined;
+var VM_UUID = undefined;
+/* We use the old sdc-base image from 2014 */
+var IMG_UUID = 'de411e86-548d-11e4-a4b7-3bb60478632a';
+var OWNER_UUID = undefined;
+var SERVER_UUID = undefined;
+var VM_NICS = undefined;
+var NET_UUID = undefined;
+
+/*
+ * Imports and modules
+ */
+
+var test = require('tape');
+var sdcClients = require('sdc-clients');
+var bunyan = require('bunyan');
+var VMAPI = new sdcClients.VMAPI({ url: VMAPI_URL });
+var NAPI = new sdcClients.NAPI({ url: NAPI_URL });
+var vmadm = require('vmadm');
+var smf = require('smf');
+var restify = require('restify');
+var assert = require('assert-plus');
+
+/*
+ * Commonly used functions
+ */
+
+function delay_check(t, seconds, check) {
+    function dcheck() {
+        check(function (gone) {
+            if (gone) {
+                console.log('VM gone');
+                t.end();
+            } else {
+                console.log('VM not gone, waiting');
+                setTimeout(dcheck, seconds * 1000);
+            }
+        });
+    }
+    dcheck();
+}
+
+function check_vm_gone(cb) {
+    searchOpts = { uuid: VM_UUID, state: 'active' };
+    VMAPI.listVms(searchOpts, function (err, vms) {
+        /* If we can't connect to VMAPI we keep retrying until we can. */
+        if (err) {
+            cb(false);
+            return;
+        }
+        if (vms.length) {
+            cb(false);
+        } else {
+            cb(true);
+        }
+    });
+}
+
+
+/*
+ * Functions for manipulating the net-agent service.
+ */
+
+function disable_net_agent(t) {
+    smf.svcadm('disable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not disable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Disabled net-agent');
+        t.end();
+    });
+}
+
+function enable_net_agent(t) {
+    smf.svcadm('enable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not enable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Enabled net-agent');
+        t.end();
+    });
+}
+
+function early_exit(err) {
+    console.log('A test has failed, so there is no point in continuing.');
+    console.log('Subsequent tests were not executed.');
+    console.log('Identify the cause of the test failure and fix it.');
+    console.log('Then retry running this test suite.');
+    if (err) {
+        console.log(err);
+        console.log(err.stack);
+    }
+    process.exit(1);
+}
+
+/*
+ * Functions for checking if nic is present or absent on the system.
+ */
+
+function nic_gone(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error Getting NIC List');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        if (nics.length > 0) {
+            t.ok(false, 'NIC is still here!');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.ok(true, 'NIC is gone.');
+        t.end();
+    });
+}
+
+function nic_exists(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_NICS = nics;
+        if (VM_NICS.length > 0) {
+            NET_UUID = VM_NICS[0].network_uuid;
+            t.end();
+        } else {
+            t.ok(false, 'No Nics Found For VM');
+            t.end();
+            early_exit();
+        }
+    });
+}
+
+
+function add_incpl_nic(t) {
+    var nic = {
+        belongs_to_uuid: VM_UUID,
+        belongs_to_type: 'zone',
+        owner_uuid: OWNER_UUID,
+        network_uuid: NET_UUID
+    };
+    NAPI.provisionNic(NET_UUID, nic, function (err, res) {
+        if (err) {
+            t.ok(false, 'Error provisioning incomplete NIC!');
+            early_exit(err);
+            return;
+        }
+        VMAPI.addNics({uuid: VM_UUID, owner_uuid: OWNER_UUID, macs: [res.mac]},
+            function (err2, res2) {
+                if (err2) {
+                    t.ok(false, 'Error adding incomplete NIC!');
+                    early_exit(err2);
+                    return;
+                }
+                console.log('Added Nic to VM');
+                t.end();
+            });
+        return;
+    });
+}
+
+function check_nic_members(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_NICS = nics;
+
+        if (VM_NICS.length > 0) {
+            VM_NICS.forEach(function (nic) {
+                t.ok(nic.cn_uuid, 'NIC cn_uuid is defined');
+                t.strictEquals(nic.state, 'running');
+            });
+            t.end();
+            return;
+        }
+        t.ok(false, 'No Nics Found For VM');
+        t.end();
+        early_exit();
+    });
+}
+
+/*
+ * Functions for creating/destroying VMs
+ */
+
+function create_vm(t) {
+    VMAPI.createVmAndWait({
+        owner_uuid: OWNER_UUID,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: EXTERNAL_NET.uuid,
+                ipv4_count: 1,
+                primary: true
+            }
+        ],
+        brand: 'joyent-minimal',
+        ram: 256,
+        cpu_cap: 300,
+        alias: 'net-agent-test-vm-1',
+        image_uuid: IMG_UUID
+    }, function createVmCb(err, job) {
+        if (err) {
+            t.error(err, 'Error on creating VM');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_UUID = job.vm_uuid;
+        console.log('Created VM ' + VM_UUID);
+        t.end();
+    });
+};
+
+function destroy_vm(t) {
+    console.log('Destroying VM ' + VM_UUID);
+    vmadm.delete({
+        uuid: VM_UUID,
+        log: bunyan.createLogger({
+            name: 'vmadm.delete',
+            level: 'DEBUG',
+            stream: process.stdout,
+            serializers: bunyan.stdSerializers
+        })
+    }, function (err) {
+        if (err) {
+            t.error(err, 'Error Deleting With `vmadm`');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        t.end();
+    });
+}
+
+function wait_until_agent_ready(t) {
+    var client = restify.createJsonClient({
+        url: 'http://localhost:5311'
+    });
+
+    function try_get_status() {
+        client.get({ path: '/status' }, function (err, req, res, obj) {
+            if (err) {
+                console.log('Error getting status, retrying...');
+                console.log(err);
+                try_get_status();
+                return;
+            }
+            console.log('status object:');
+            console.log(obj);
+            var state = obj.init_history.pop().h_name;
+            if (state === 'StartedReapNics') {
+                console.log('net-agent has started up completely');
+                t.end();
+            } else if (state === 'SkippedReapNics') {
+                console.log('WARNING: net-agent cannot reap NICs');
+                console.log('WARNING: try updating NAPI to complete the' +
+                    ' nic-reap test');
+                early_exit();
+                t.end();
+            } else {
+                console.log('Retrying in 5 seconds');
+                setTimeout(function () {
+                    try_get_status();
+                }, 5 * 1000);
+            }
+        });
+    }
+    try_get_status();
+}
+
+/*
+ * This function asserts that the agent is online. If the agent is not online,
+ * it will wait for it to either move into the online state, or into a
+ * maintenance or degraded state. If the latter occurs, this function causes
+ * the test to abort (in the hope that the dev will fix the service before
+ * running this test again).
+ */
+function assert_svc_state(t) {
+    function wait_for_state() {
+        var fmri = 'svc:/smartdc/agent/net-agent:default';
+        smf.svcs(fmri, function (err, svc) {
+            if (svc.state === 'disabled') {
+                /* enable svc */
+                enable_net_agent(t);
+            } else if (svc.state === 'maintenance' || svc.state === 'degraded') {
+                /* bail out */
+                console.log('net-agent is in ' + svc.state + ' state; bailing.');
+                early_exit();
+                t.end();
+            } else if (svc.state === 'offline' || svc.state === 'unitialized') {
+                /* wait for state chage */
+                setTimeout(function () {
+                    wait_for_state();
+                }, 5 * 1000);
+            } else {
+                t.end();
+            }
+        });
+    }
+    wait_for_state();
+}
+
+/*
+ * The actual tests.
+ */
+
+test('Is Net Agent Running?', function (t) {
+    assert_svc_state(t);
+});
+
+test('Get Network Info', function (t) {
+    NAPI.listNetworks(function (err, nets) {
+        if (err) {
+            t.error(err, 'Could not get network info.');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        nets.forEach(function (n) {
+            assert.string(n.name);
+            if (n.name === 'external') {
+                EXTERNAL_NET = n;
+            }
+        });
+        t.end();
+    });
+});
+
+/*
+ * We use the same OWNER_UUID that is attributed to the napi0 zone.
+ */
+test('Get Owner And Server UUIDs', function (t) {
+    VMAPI.listVms({alias: 'napi0', state: 'active'}, function (err, vms) {
+        if (err) {
+            t.error(err, 'Error getting owner UUID');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        if (vms.length === 1) {
+            OWNER_UUID = vms[0].owner_uuid;
+            SERVER_UUID = vms[0].server_uuid;
+        } else {
+            t.error('vms[] array not expected size. Expected size is 1.');
+            t.error('Actual size is ' + vms.length);
+            early_exit();
+        }
+        t.end();
+    });
+});
+
+
+/*
+ * This group of tests verifies that net-agent reacts to VM-events properly.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Give Agent Some Time', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests verifies that net-agent reaps orphaned NICs if it wasn't
+ * able to react to the VM-events.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Enable Net-Agent Service', enable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Give Agent Some Time', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests, will create a VM, disable net-agent, create and add a
+ * NIC to the VM that has no cn_uuid and a provisioning state, so that the
+ * cn_uuid is undefined and the state is set to 'provisioning'. We then
+ * re-enable net-agent, wait for the reap to begin, and verify that after the
+ * reap the NIC still exists and has a new cn_uuid and its state is running.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Add Incomplete NIC to NAPI', add_incpl_nic);
+test('Enable Net-Agent Service', enable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Give Agent Time To Complete Reap', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify NIC `cn_uuid` and `state`', check_nic_members);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Give Agent Time To Complete Reap', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/* Node will keep running unless we delete the VMAPI and NAPI objects */
+test('Finish', function (t) {
+    delete VMAPI;
+    delete NAPI;
+    t.end();
+});
-- 
2.21.0

