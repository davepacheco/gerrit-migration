From e6b644d735bbccf27714a377828f0706cdf68501 Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 29 Jul 2016 21:30:46 +0000
Subject: [PATCH] NAPI-327 net-agent should not leak NICs

---
 lib/endpoints/index.js  |  14 ++
 lib/endpoints/status.js |  46 +++++++
 lib/napi-client.js      |  13 +-
 lib/net-agent.js        | 290 ++++++++++++++++++++++++++++++++++----
 lib/vm.js               |  69 +++-------
 package.json            |   8 +-
 tests/runtest           |  32 +++++
 tests/unit/test.js      | 299 ++++++++++++++++++++++++++++++++++++++++
 tools/rsync-to          |   4 +-
 9 files changed, 695 insertions(+), 80 deletions(-)
 create mode 100644 lib/endpoints/index.js
 create mode 100644 lib/endpoints/status.js
 create mode 100755 tests/runtest
 create mode 100644 tests/unit/test.js

diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
new file mode 100644
index 0000000..f3fc07c
--- /dev/null
+++ b/lib/endpoints/index.js
@@ -0,0 +1,14 @@
+var toRegister = {
+    '/status': require('./status')
+};
+
+function registerEndpoints(http, log, before) {
+    for (var t in toRegister) {
+        log.debug('Registering endpoints for "%s"', t);
+        toRegister[t].register(http, before);
+    }
+}
+
+module.exports = {
+    registerEndpoints: registerEndpoints
+};
diff --git a/lib/endpoints/status.js b/lib/endpoints/status.js
new file mode 100644
index 0000000..241f1d5
--- /dev/null
+++ b/lib/endpoints/status.js
@@ -0,0 +1,46 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * Status endpoint
+ */
+
+
+
+ /**
+  * GET /status
+  */
+
+function
+getStatus(req, res, next)
+{
+    console.log('getStatus Entry');
+    console.log('getStatus req:');
+    console.log(req);
+    console.log('getStatus app:');
+    console.log(req.app);
+    var stat = {
+        init: req.app.init
+    };
+    res.send(200, stat);
+    console.log('getStatus Return');
+    return next();
+}
+
+function
+register(http, before)
+{
+    http.get(
+        {path: '/status', name: 'getStatus'}, before, getStatus);
+}
+
+module.exports = {
+    register: register
+};
diff --git a/lib/napi-client.js b/lib/napi-client.js
index a17ea24..25b505f 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -44,7 +44,7 @@ function NapiClient(options) {
  *
  * 1. NIC was removed from the VM or VM provision has failed (destroy)
  * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be udpated (update)
+ * 3. NIC exists and has to be updated (update)
  * 4. NIC exists and but has not changed, no need to do anything (noop)
  */
 NapiClient.prototype.updateNics = function (vm, nics, callback) {
@@ -95,6 +95,10 @@ NapiClient.prototype.getNic = function (mac, callback) {
     return this.client.getNic(mac, callback);
 };
 
+NapiClient.prototype.listNics = function (callback) {
+    return this.client.listNics(callback);
+};
+
 
 NapiClient.prototype.createNic = function (vm, newNic, callback) {
     var log = this.log;
@@ -161,6 +165,11 @@ NapiClient.prototype.deleteNic = function (vm, nic, callback) {
     });
 };
 
+NapiClient.prototype.getNics = function (belongsTo, options, callback) {
+    this.client.getNics(belongsTo, options, callback);
+    return;
+};
+
 
 
 /*
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 64604a2..5bc0080 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,19 +5,94 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
- * net-agent.js
+ * Net-Agent and NAPI
+ * ==================
+ *
+ * VM Change Events
+ * ----------------
+ *
+ * Net-agent's job is to inform NAPI of any changes to any NICs that result
+ * from VM-related events. For instance, if a VM gets destroyed (either by
+ * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
+ * for telling NAPI that the NIC that used to belong to that VM should be
+ * destroyed.
+ *
+ * Net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone_xml has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever a change is detected, net-agent walks its internal list of VM
+ * objects (which also contain the NIC info) and pushes the NIC objects to
+ * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
+ * address.
+ *
+ * Orphaned NICs
+ * -------------
+ *
+ * One cannot assume that net-agent is continuously reacting to every single
+ * event on a CN. For example net-agent may be disabled by an operator, may go
+ * down due to an error, or may not receive an event (it happens). To handle
+ * these situations, when net-agent starts up it scans every NIC on the CN[1],
+ * and tells NAPI to delete any NIC if it does not have a corresponding VM (that
+ * is not destroyed). This is only done once on startup because such a scan can
+ * be very expensive.
+ *
+ * [1]: Currently we scan every NIC in the DC, since NAPI doesn't allow us to
+ * filter NICs by CN_UUID. But as soon as it does, we will switch to that. This
+ * means that we have to ignore NICs that have a CN_UUID different from the
+ * agent's.
+ *
+ * Net-Agent and CNs
+ * =================
+ *
+ * The previous section described the interaction between a single net-agent
+ * service and a single NAPI service. However, we always have more than one
+ * net-agent. In fact we have one net-agent per CN. All of these net-agents
+ * react only to VM events on their respective CNs. However, they are modifying
+ * global NIC objects, and they all connect to a single NAPI service (this may
+ * change in the future). It is important to keep this mind. We don't want all
+ * of our net-agents, to start battering NAPI with requests at the same time.
+ * For the change-event-related requests this is not a problem. However, for
+ * the orphaned-nic-related requests, this could be catastrophic. This is why
+ * we insert a random delay before the listNics request that is no greater than
+ * 10 minutes.
+ *
+ * Net-Agent and VMs
+ * =================
+ *
+ * Net-Agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory. This set of
+ * VM objects is known as the sample.
+ *
+ * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * and processing the JSON that it produces on stdout. `zoneevent` emits output
+ * whenever a property of the zone has changed. Note that it does not report
+ * higher-level VM properties (that are used by vmadm and vmapi).
+ *
+ * As Net-Agent receives these change events, it updates the changed properties
+ * of the VM objects in the sample. However, it is possible that one of the
+ * change-events does not make it to net-agent. In order to mitigate the drift
+ * between net-agent's picture of reality, and reality itself, net-agent also
+ * does a full `vmadm lookup` every minute, and emits state-change events if it
+ * detects a difference.
  */
 
 var async = require('async');
 var backoff = require('backoff');
+var restify = require('restify');
+var endpoints = require('./endpoints');
 
 var VM = require('./vm');
 var NAPI = require('./napi-client');
 
+
 var _versionCache = null;
 function getNetAgentVersion() {
     if (_versionCache === null) {
@@ -33,6 +108,7 @@ function NetAgent(options) {
     this.lastFullSample = null;
     this.uuid = options.uuid;
     this.version = getNetAgentVersion();
+    this.init = {};
 
     var userAgent = 'net-agent/' + this.version +
         ' (' + 'node/' + process.versions.node + ')' +
@@ -55,12 +131,40 @@ function NetAgent(options) {
     this.queues = {};
 }
 
+/*
+ * This function initializes the restify HTTP server.
+ * Currently, it temporarily listens on port 5311, until we nail down a proper
+ * port-allocation policy for SDC's agents.
+ */
+NetAgent.prototype.initializeServer = function () {
+    var self = this;
+    var server = restify.createServer({
+        log: self.log,
+        name: 'Net Agent',
+        version: '0.0.1'
+    });
+    function populateReq(req, res, next) {
+        req.app = self;
+        return next();
+    }
+    endpoints.registerEndpoints(server, self.log, [ populateReq ]);
+    server.listen(5311, function () {
+        var addr = server.address();
+        self.log.info('%s listening on <http://%s:%s>',
+            server.name, addr.address, addr.port);
+    });
+};
+
 
 NetAgent.prototype.start = function () {
-    var self = this;
     var log = this.log;
 
+    this.init.phase = 'InitializingServer';
+    this.initializeServer();
+    this.init.phase = 'InitializedServer';
+    this.init.phase = 'InitializingEventWatcher';
     this.initializeEventWatcher();
+    this.init.phase = 'InitializedEventWatcher';
 
     // Wrap our initial full sample in a retry-backoff
     var opts = { uuid: this.uuid };
@@ -74,12 +178,89 @@ NetAgent.prototype.start = function () {
         }
 
         log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
     }
 };
 
+/*
+ * Called on startup. Function asks NAPI for all allocated NICs.  It uses this
+ * list to detect leaked NICs by querying for NICs that are allocated,
+ * unreserved, belong to type 'zone', and not assigned to any existing VM. It
+ * emits a leaked_nic event, which net-agent responds to by destroying the NIC.
+ */
+NetAgent.prototype.reapNics = function () {
+
+    var self = this;
+    var leaked_nics = [];
+
+    console.log('this is:');
+    console.log(this);
+    var napiClient = this.napiClient;
+    console.log('napiClient is:');
+    console.log(napiClient);
+    var sample = this.sample;
+    var cn_uuid = this.uuid;
+    var findOrphanNics = function () {
+        /*
+         * We get list of NICs from NAPI. Currently we get all NICs, but we
+         * should filter by cn_uuid, when NAPI gets support for that.
+         */
+        napiClient.listNics(function list_nics_cb(err, res) {
+            /*
+             * We want to retry if we get an error.
+             */
+            if (err) {
+                napiClient.listNics(list_nics_cb);
+                return;
+            }
+            var nics = res;
+            nics.forEach(function scan_nics(nic) {
+                if (nic.belongs_to_type != 'zone') {
+                    return;
+                }
+                /* Not our responsibility */
+                if (nic.cn_uuid !== cn_uuid) {
+                    return;
+                }
+                nic.leaked = true;
+                var vms = sample;
+                for (var uuid in vms) {
+                    var vm = vms[uuid];
+                    if (vm.uuid == nic.belongs_to_uuid) {
+                        nic.leaked = false;
+                    }
+                }
+                if (nic.leaked) {
+                    leaked_nics.push(nic);
+                }
+            });
+            if (leaked_nics.length === 0) {
+                self.init.phase = 'StartedReapNics';
+                return;
+            }
+            leaked_nics.forEach(function reap_nic(nic) {
+                /*
+                 * Currently, the implementation of deleteNic only looks at the
+                 * UUID of the VM. If we are in this function, we know that the
+                 * VM itself no longer exists, which is why we don't have a
+                 * complete VM object. If deleteNic starts accessing other vm
+                 * members in the future, we will have to add them to the
+                 * `targ_vm` obj below.
+                 */
+                var targ_vm = { uuid: nic.belongs_to_uuid };
+                napiClient.deleteNic(targ_vm, nic,
+                    function handle_delete_nic(err2, res2) {
+
+                    if (err) {
+                        return;
+                    }
+                    return;
+                });
+            });
+            self.init.phase = 'StartedReapNics';
+        });
+    };
+    findOrphanNics();
+};
 
 /*
  * Initializes the EventWatcher event listeners
@@ -89,7 +270,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
     var log = this.log;
     var eventWatcher = this.eventWatcher;
 
-    eventWatcher.on('state', function (uuid, state) {
+    eventWatcher.on('state', function vm_state_event(uuid, state) {
         log.debug('state event for %s state: %s', uuid, state);
         self.pushSample({
             uuid: uuid,
@@ -97,7 +278,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_state', function (uuid, zone_state) {
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
         log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
         self.pushSample({
             uuid: uuid,
@@ -105,7 +286,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_xml', function (uuid) {
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
         log.debug('fs.watch event on /etc/zones for %s', uuid);
         self.pushSample({
             uuid: uuid,
@@ -113,7 +294,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('destroyed', function (uuid) {
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
         var vm = self.sample[uuid];
         if (!vm) {
             log.warn('VM %s appears to have gone away but ' +
@@ -126,7 +307,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         self.pushSample({ uuid: uuid, cachedVm: vm });
     });
 
-    eventWatcher.on('err', function (err) {
+    eventWatcher.on('err', function zone_err_event(err) {
         log.error(err, 'eventWatcher saw en error');
     });
 };
@@ -140,7 +321,6 @@ NetAgent.prototype.setSample = function (sample) {
     });
 };
 
-
 /*
  * On startup, sendFullSample updates all NICs for all VMs on the server. This
  * will be a blocking call before we turn on the event listeners so we allow
@@ -150,19 +330,53 @@ NetAgent.prototype.sendFullSample = function (opts, callback) {
     var self = this;
     var log = this.log;
 
+    function startEventWatchers() {
+            self.init.phase = 'StartingEventWatcher';
+            self.eventWatcher.updateState(self.sample);
+            self.eventWatcher.lastCfgEvent = self.lastFullSample;
+            self.eventWatcher.start();
+            self.init.phase = 'StartedEventWatcher';
+    }
+
     this.updateSample({}, function (err, sample) {
         if (err) {
             log.error(err, 'updateSample failed, cannot sendFullSample');
             callback(err);
             return;
-
         } else if (Object.keys(sample).length === 0) {
             log.warn('empty sample returned by vmadm lookup');
+            startEventWatchers();
             callback();
             return;
         }
 
         self.setSample(sample);
+        startEventWatchers();
+        var min_timeout = 2 * 60 * 1000;
+        var max_timeout = 10 * 60 * 1000;
+        var rand_timeout = Math.floor(Math.random() * (max_timeout -
+            min_timeout + 1)) + min_timeout;
+
+        self.init = {
+            phase: 'StartingReapNics',
+            delay: rand_timeout,
+            elapsed: 0
+        };
+
+        setTimeout(function () {
+            self.reapNics();
+        }, rand_timeout);
+
+        function setElapsed() {
+            var updateInterval = 5 * 1000;
+            setTimeout(function () {
+                self.init.elapsed += updateInterval;
+                if (self.init.elapsed < self.init.delay) {
+                    setElapsed();
+                }
+            }, updateInterval);
+        }
+        setElapsed();
 
         async.forEachSeries(Object.keys(sample), function (uuid, cb) {
             var options = {
@@ -199,16 +413,14 @@ NetAgent.prototype.sendSample = function (options, callback) {
         this.eventWatcher.removeState(options.uuid);
 
         self._updateVmNics(options, callback);
-
     } else {
         this.updateSample(options, function (err, sample) {
             if (err) {
                 log.error(err, 'updateSample failed, cannot sendSample');
                 callback(err);
-
             } else if (Object.keys(sample).length === 0) {
                 log.warn('empty sample returned by vmadm lookup');
-                 callback();
+                callback();
             } else {
                 self.eventWatcher.updateState(sample);
                 self.setSample(sample);
@@ -225,6 +437,7 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * - options.cachedVm: what net-agent currently knows about the VM
  * - options.vm: what net-agent has loaded from vmadm
+ * - options.cn_uuid: the cn_uuid of the vm's NICs
  *
  * When options.vm is undefined, it means that the VM has been destroyed because
  * options.vm gets populated from the vmadm lookup results. We always store the
@@ -232,11 +445,19 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * When options.cachedVm is undefined, then this is the first time we see that
  * VM (or our net-agent has just started)
+ *
+ * When options.cn_uuid is different from this.uuid, we don't do anything.
  */
-NetAgent.prototype._updateVmNics = function (options, callback) {
+NetAgent.prototype._updateVmNicsImpl = function (options, callback)
+{
     var log = this.log;
     var allNics = [];
 
+    if (options.cn_uuid !== this.uuid) {
+        callback();
+        return;
+    }
+
     if (options.vm) {
         options.vm.nics.forEach(function (nic) {
             // When VM is failed just mark all NICs are destroyed
@@ -281,6 +502,30 @@ NetAgent.prototype._updateVmNics = function (options, callback) {
     this.napiClient.updateNics(vm, allNics, callback);
 };
 
+NetAgent.prototype._updateVmNics = function (options, callback)
+{
+    /*
+     * We want to grab the this VM's NICs from NAPI, so that we can have a copy
+     * of their cn_uuid's (which is not stored in the vm-object's `nic`
+     * member). We need the cn_uuid to determine if we are allowed to act on
+     * the NICs or not.
+     */
+    var self = this;
+    self.napiClient.getNics(options.uuid, function (err, nics) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (nics.length > 0) {
+            /* We assume that all of a VM's NICs have the same cn_uuid */
+            options.cn_uuid = nics[0].cn_uuid;
+        } else {
+            options.cn_uuid = this.uuid;
+        }
+        self._updateVmNicsImpl(options, callback);
+    });
+};
+
 
 /*
  * Initializes the serial queue for a single uuid and pushes the item to be
@@ -329,14 +574,13 @@ NetAgent.prototype.retryUpdate = function (fn, options, callback) {
     var retry = backoff.call(fn, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
 
         if (err) {
             log.error({ uuid: options.uuid },
                 'Could not retry operation after %d attempts', attempts);
             return callback(err);
         }
-
         return callback();
     });
 
@@ -414,8 +658,9 @@ NetAgent.prototype.createQueue = function (uuid) {
  */
 
 NetAgent.prototype.updateSample = function (options, callback) {
-    if (!this._sampleQueue)
+    if (!this._sampleQueue) {
         this._sampleQueue = async.queue(updateSample.bind(this), 8);
+    }
     this._sampleQueue.push(options, callback);
 };
 
@@ -441,7 +686,7 @@ function updateSample(options, callback) {
 
         log.debug('Starting updateSample ' + query);
 
-        VM.list(searchOpts, function (err, vmobjs) {
+        VM.list(searchOpts, {log: log}, function (err, vmobjs) {
             var vmobj;
             var running = 0;
             var notRunning = 0;
@@ -450,7 +695,6 @@ function updateSample(options, callback) {
             if (err) {
                 log.error(err, 'ERROR: unable update VM list');
                 return cb(err);
-
             } else {
                 for (vmobj in vmobjs) {
                     vmobj = vmobjs[vmobj];
@@ -501,7 +745,7 @@ function updateSample(options, callback) {
     var retry = backoff.call(lookup, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
         if (err) {
             log.error('Could not updateSample after %d attempts', attempts);
             return callback(err);
diff --git a/lib/vm.js b/lib/vm.js
index 5715c40..835bae5 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -21,10 +21,10 @@ var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var EventEmitter = require('events').EventEmitter;
+var vmadm = require('vmadm');
 
 var async = require('async');
 
-var VMADM = '/usr/sbin/vmadm';
 
 
 
@@ -38,44 +38,6 @@ function isLocal(vms, vm) {
     return null;
 }
 
-
-function listVMs(filter, fields, callback) {
-    if (!callback) {
-        callback = fields;
-        fields = undefined;
-    }
-
-    var args = ['lookup', '-j'];
-    for (var k in filter) {
-        args.push(k + '=' + filter[k]);
-    }
-    if (fields) {
-        args.push('-o', fields.join(','));
-    }
-
-    return execFile(VMADM, args, {maxBuffer: 32 * 1024 * 1024},
-        function (err, stdout, stderr) {
-
-        if (err) {
-            err.stdout = stdout;
-            err.stderr = stderr;
-            return callback(err);
-        }
-
-        var vms;
-
-        try {
-            vms = JSON.parse(stdout);
-        } catch (jsonErr) {
-            jsonErr.stdout = stdout;
-            return callback(jsonErr);
-        }
-
-        return callback(null, vms);
-    });
-}
-
-
 // These are the events being watched by the zoneevent watcher. When zones
 // don't switch to these zone_states we ignore them
 var watchEvents = {
@@ -83,7 +45,7 @@ var watchEvents = {
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 30000;
+var STATE_WATCHER_TIMEOUT = 60 * 1000;
 
 /*
  * The EventWatcher will emit these events:
@@ -128,7 +90,7 @@ EventWatcher.prototype.start = function () {
 EventWatcher.prototype.updateState = function (objs) {
     var self = this;
 
-    Object.keys(objs).forEach(function (uuid) {
+    Object.keys(objs).forEach(function foreachobjs(uuid) {
         self.vmStates[uuid] = {
             state: objs[uuid].state,
             zone_state: objs[uuid].zone_state
@@ -166,10 +128,6 @@ EventWatcher.prototype.startStateWatcher = function () {
         }
 
         vmobjs.forEach(function (vm) {
-            // Only use inventory vms
-            if (vm.do_not_inventory) {
-                return;
-            }
 
             // Don't emit when states stay the same
             var current = self.getState(vm.uuid);
@@ -191,14 +149,24 @@ EventWatcher.prototype.startStateWatcher = function () {
         setTimeout(lookup, STATE_WATCHER_TIMEOUT);
     }
 
-    var lookup = listVMs.bind(null,
-        {}, ['uuid', 'state', 'zone_state', 'do_not_inventory'], onLookup);
+    var opts = {};
+    opts.fields = ['uuid', 'state', 'zone_state'];
+    opts.log = log;
+    opts.include_dni = false;
+    var lookup = vmadm.lookup.bind(null, {}, opts, onLookup);
 
     lookup();
 };
 
-
 EventWatcher.prototype.startZoneWatcher = function () {
+    /*
+     * sendFullSample get called in an infinite retry loop. We don't want to
+     * create a swarm of zoneevent processes. Therefore we simply return from
+     * this function, if we already have one such process running.
+     */
+    if (this.zoneeventWatcher !== null) {
+        return;
+    }
     var log = this.log;
     var self = this;
 
@@ -368,13 +336,12 @@ function checkDestroyed(uuid, callback) {
 
 function createEventWatcher(options) {
     assert.ok(options.log, 'EventWatcher options.log');
-
     return new EventWatcher(options);
 }
 
 
 module.exports = {
     isLocal: isLocal,
-    list: listVMs,
+    list: vmadm.lookup,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index 8a31a32..1e0cb31 100644
--- a/package.json
+++ b/package.json
@@ -4,14 +4,18 @@
     "version": "1.3.0",
     "author": "Joyent (joyent.com)",
     "private": true,
+
     "dependencies": {
         "async": "0.1.18",
-        "backoff": "2.3.0",
+        "backoff": "2.4.1",
         "bunyan": "1.3.2",
         "sdc-bunyan-serializers": "git+ssh://git@github.com:joyent/sdc-bunyan-serializers.git#aefc119",
         "nodeunit": "0.7.4",
         "restify": "2.7.0",
-        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#c962959"
+        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git",
+        "vmadm": "git+ssh://git@github.com:joyent/node-vmadm.git#3cf878481d24c1bc1e74e85a95004a3dde6329f1",
+        "tape": "4.2.2",
+        "smf": "0.3.1"
     },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
diff --git a/tests/runtest b/tests/runtest
new file mode 100755
index 0000000..f386a9f
--- /dev/null
+++ b/tests/runtest
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+#
+# Run a single FWAPI test of any type.
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE_INSTALL=$TOP/node
+NODEUNIT=$TOP/node_modules/.bin/nodeunit
+UNAME=$(uname -s)
+
+guard_file=/lib/sdc/.sdc-test-no-production-data
+if [[ $UNAME == "SunOS" ]] && [[ ! -f "$guard_file" ]]; then
+    cat <<EOF
+To run this test you must create the file:
+
+    $guard_file
+
+after ensuring you have no production data on this SDC.
+EOF
+    exit 2
+fi
+
+PATH=$NODE_INSTALL/bin:$PATH node $1
diff --git a/tests/unit/test.js b/tests/unit/test.js
new file mode 100644
index 0000000..bde2ad0
--- /dev/null
+++ b/tests/unit/test.js
@@ -0,0 +1,299 @@
+var test = require('tape');
+var sdcClients = require('sdc-clients');
+var VMAPI = new sdcClients.VMAPI({ url: 'http://vmapi.coal-1.joyent.us' });
+var NAPI = new sdcClients.NAPI({ url: 'http://napi.coal-1.joyent.us' });
+var vmadm = require('vmadm');
+var smf = require('smf');
+var bunyan = require('bunyan');
+var restify = require('restify');
+
+var external_net = undefined;
+var vm_uuid = undefined;
+/* We use the old sdc-base image from 2014 */
+var img_uuid = 'de411e86-548d-11e4-a4b7-3bb60478632a';
+var owner_uuid = undefined;
+var server_uuid = undefined;
+var vm_nics = undefined;
+
+/*
+ * MAC address-related utilities
+ */
+
+
+var NON_HEX_RE = /[^a-fA-F0-9]/g;
+
+function wait(t, seconds)
+{
+    setTimeout(function () {
+        t.end();
+    }, seconds * 1000);
+}
+
+
+/*
+ * Convert a colon-separated MAC address to an integer
+ */
+function macAddressToNumber(addr) {
+    if (!addr) {
+        return null;
+    }
+
+    var num = addr.replace(/[-:]/g, '');
+    if (num.length != 12) {
+        return null;
+    }
+    if (NON_HEX_RE.test(num)) {
+        return null;
+    }
+
+    num = parseInt(num, 16);
+    if (isNaN(num)) {
+        return null;
+    }
+    return num;
+}
+
+/*
+ * Funcs for manipulating the net-agent service.
+ */
+
+function disable_net_agent(t)
+{
+    smf.svcadm('disable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.ok(false, 'Could not disable net-agent');
+            t.end();
+            return;
+        }
+        /* XXX do we need to check for exit codes? */
+        t.ok(true, 'Disabled net-agent');
+        t.end();
+        return;
+    });
+}
+
+function enable_net_agent(t)
+{
+    smf.svcadm('enable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.ok(false, 'Could not enable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Enabled net-agent');
+        t.end();
+        return;
+    });
+}
+
+/*
+ * Funcs for checking if nic is present or absent on the system.
+ */
+
+function nic_gone(t)
+{
+    NAPI.getNics(vm_uuid, {}, function (err, nics) {
+        if (err) {
+            t.ok(false, 'Error Getting NIC List');
+            t.end();
+            process.exit(0);
+            return;
+        }
+        if (nics.length > 0) {
+            t.ok(false, 'NIC is still here!');
+            t.end();
+            process.exit(0);
+            return;
+        }
+        t.ok(true, 'NIC is gone.');
+        t.end();
+        return;
+    });
+}
+
+function nic_exists(t)
+{
+    NAPI.getNics(vm_uuid, function (err, nics) {
+        if (err) {
+            t.ok(false, 'Error on Getting VM Net Info');
+            t.end();
+            process.exit(1);
+            return;
+        }
+        vm_nics = nics;
+        if (vm_nics.length > 0) {
+            t.end();
+            return;
+        }
+        t.ok(false, 'No Nics Found For VM');
+        t.end();
+        process.exit(1);
+        return;
+    });
+}
+
+/*
+ * Funcs for creating/destroying VMs
+ */
+
+function create_vm(t)
+{
+    var params = {owner_uuid: owner_uuid,
+                  server_uuid: server_uuid,
+                  networks: [{ ipv4_uuid: external_net.uuid,
+                               ipv4_count: 1,
+                               primary: true }],
+                  brand: 'joyent-minimal',
+                  ram: 256,
+                  cpu_cap: 300,
+                  alias: 'net-agent-test-vm-1',
+                  image_uuid: img_uuid
+    };
+
+    VMAPI.createVmAndWait(params, function createVmCb(err, job) {
+        if (err) {
+            console.log(err);
+            t.ok(false, 'Error on creating VM');
+            t.end();
+            process.exit(1);
+            return;
+        }
+        vm_uuid = job.vm_uuid;
+        t.end();
+        return;
+    });
+};
+
+function destroy_vm(t)
+{
+    vmadm.delete({uuid: vm_uuid, log: bunyan.createLogger(
+                    {
+                        name: 'vmadm.delete',
+                        level: 'INFO',
+                        stream: process.stdout,
+                        serializers: bunyan.stdSerializers
+                    })
+    }, function (err) {
+        if (err) {
+            t.ok(false, 'Error Deleting With VMADM');
+            console.log(err);
+            t.end();
+            process.exit(0);
+            return;
+        }
+        t.end();
+        return;
+    });
+}
+
+function wait_till_agent_ready(t)
+{
+    var client = restify.createJsonClient({
+        url: 'http://0.0.0.0:5311'
+    });
+
+    function try_get_status()
+    {
+        client.get({ path: '/status' }, function (err, req, res, obj) {
+            if (err) {
+                console.log('Error getting status, retrying...');
+                console.log(err);
+                try_get_status();
+                return;
+            }
+            console.log(obj.init);
+            if (obj.init.phase === 'StartingReapNics') {
+                var time_rem = obj.init.delay - obj.init.elapsed;
+
+                console.log('Retryig in '+ time_rem + ' us');
+                setTimeout(function () {
+                    try_get_status();
+                }, time_rem);
+            } else if (obj.init.phase === 'StartedReapNics') {
+                console.log('net-agent has started up completely');
+                t.end();
+            } else {
+                console.log('Retrying in 5 seconds');
+                setTimeout(function () {
+                    try_get_status();
+                }, 5 * 1000);
+            }
+            return;
+        });
+    }
+    try_get_status();
+    return;
+}
+
+
+
+test('Get Network Info', function (t) {
+    NAPI.listNetworks(function (err, nets) {
+        if (err) {
+            t.ok(false, 'Could not get network info.');
+            t.end();
+            process.exit(1);
+            return;
+        }
+        for (n in nets) {
+            if (nets[n].name === 'external') {
+                external_net = nets[n];
+            }
+        }
+        t.end();
+        return;
+    });
+});
+
+/*
+ * We use the same owner_uuid that is attributed to the napi0 zone.
+ */
+test('Get Owner And Server UUIDs', function (t) {
+    VMAPI.listVms({alias: 'napi0'}, function (err, vms) {
+        if (err) {
+            t.ok(false, 'Error getting owner UUID');
+            t.end();
+            process.exit(1);
+            return;
+        }
+        owner_uuid = vms[0].owner_uuid;
+        server_uuid = vms[0].server_uuid;
+        t.end();
+    });
+});
+
+
+/*
+ * This group of tests verifies that net-agent reacts to VM-events properly.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    wait(t, 10);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests verifies that net-agent reaps orphaned NICs if it wasn't
+ * able to react to the VM-events.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    wait(t, 10);
+});
+test('Enable Net-Agent Service', enable_net_agent);
+test('Wait Till Agent Ready', wait_till_agent_ready);
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * For reasons unknown, tape does not stop running, so we have to force the
+ * process to quit.
+ */
+test('Finish', function (t) {
+    t.end();
+    process.exit(0);
+});
diff --git a/tools/rsync-to b/tools/rsync-to
index d975b95..989fa9e 100755
--- a/tools/rsync-to
+++ b/tools/rsync-to
@@ -28,7 +28,7 @@ if [[ $(uname -s) != "SunOS" ]]; then
 fi
 
 rsync -av ${TOP}/ \
-    $NODE:/var/tmp/net-agent/ \
+    $NODE:/opt/smartdc/agents/lib/node_modules/net-agent/ \
     $extraOpts \
     --exclude .git/ \
     --exclude /deps/ \
@@ -36,4 +36,4 @@ rsync -av ${TOP}/ \
     --exclude /tools/ \
     --exclude /tmp/
 
-ssh $NODE cp -R /opt/smartdc/agents/lib/node_modules/net-agent/node_modules/ /var/tmp/net-agent/
\ No newline at end of file
+ssh $NODE svcadm restart net-agent
-- 
2.21.0

