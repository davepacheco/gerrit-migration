commit 26380da1e27db27149f204e2adbe9b017bd9210d (refs/changes/71/171/3)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2016-07-29T21:50:48+00:00 (3 years, 2 months ago)
    
    NAPI-327 net-agent should not leak NICs

diff --git a/bin/net-agent.js b/bin/net-agent.js
index 5b009d2..ea5c059 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -33,11 +33,6 @@ var sdcConfig;
 var agentConfig;
 var sysinfo;
 
-process.on('uncaughtException', function (e) {
-    console.error('uncaught exception:' + e.message);
-    console.log(e.stack);
-});
-
 function loadConfig(callback) {
     var configPath = '/opt/smartdc/agents/etc/net-agent.config.json';
 
@@ -129,7 +124,15 @@ async.waterfall([
     var netagent;
     if (agentConfig.no_rabbit) {
         netagent = new NetAgent(config);
-        netagent.start();
+        netagent.start(function (err2) {
+            if (err2) {
+                logger.fatal('Failed to initialize server');
+                process.exit(1);
+            }
+            var addr = netagent.server.address();
+            logger.info('%s listening on <http://%s:%s>',
+                netagent.server.name, addr.address, addr.port);
+        });
     } else {
         logger.warn('"no_rabbit" flag is not true, net-agent will now sleep');
         // http://nodejs.org/docs/latest/api/all.html#all_settimeout_cb_ms
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..0a8f1c9
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,33 @@
+var assert = require('assert-plus');
+var VError = require('verror');
+
+function assertStrictOptions(funcname, opts, expected)
+{
+    assert.string(funcname, 'funcname');
+    assert.object(opts, funcname + ': opts');
+    assert.object(expected, funcname + ': expected');
+
+    var unexpected = [];
+    for (var k in opts) {
+        if (!opts.hasOwnProperty(k)) {
+            continue;
+        }
+        var e = expected[k];
+        if (!e) {
+            unexpected.push(k);
+            continue;
+        }
+        var afunc = assert[e];
+        assert.func(afunc, 'invalid assertion type: ' + e);
+        afunc(opts[k], 'opts.' + k);
+    }
+
+    if (unexpected.length > 0) {
+        throw (new VError(funcname + ': unexpected options: ' +
+            unexpected.join(', ')));
+    }
+}
+
+module.exports = {
+    assertStrictOptions: assertStrictOptions
+};
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
new file mode 100644
index 0000000..42578fc
--- /dev/null
+++ b/lib/endpoints/index.js
@@ -0,0 +1,24 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var toRegister = {
+    '/status': require('./status')
+};
+
+function registerEndpoints(http, log, before) {
+    for (var t in toRegister) {
+        log.debug('Registering endpoints for "%s"', t);
+        toRegister[t].register(http, before);
+    }
+}
+
+module.exports = {
+    registerEndpoints: registerEndpoints
+};
diff --git a/lib/endpoints/status.js b/lib/endpoints/status.js
new file mode 100644
index 0000000..55fbbfc
--- /dev/null
+++ b/lib/endpoints/status.js
@@ -0,0 +1,45 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var mod_jsprim = require('jsprim');
+
+/*
+ * Status endpoint
+ */
+
+
+
+ /**
+  * GET /status
+  */
+
+function
+getStatus(req, res, next)
+{
+    var stat = {
+        now: mod_jsprim.hrtimeMicrosec(process.hrtime(req.app.na_epoch)),
+        init_history: req.app.na_init_history
+    };
+    res.send(200, stat);
+    next();
+}
+
+function
+register(http, before)
+{
+    http.get({
+        path: '/status',
+        name: 'getStatus'
+    }, before, getStatus);
+}
+
+module.exports = {
+    register: register
+};
diff --git a/lib/index.js b/lib/index.js
index e67010b..62708e5 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
diff --git a/lib/napi-client.js b/lib/napi-client.js
index a17ea24..b4e3e37 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,8 @@
 
 var async = require('async');
 var NAPI = require('sdc-clients').NAPI;
+var assert = require('assert-plus');
+var common = require('./common');
 
 var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
     'allow_mac_spoofing', 'allow_restricted_traffic',
@@ -23,6 +25,7 @@ var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
 function NapiClient(options) {
     this.options = options;
     this.log = options.log;
+    console.log('NZ SETTING this.log to: ' + this.log);
     this.uuid = options.uuid;
 
     this.client = new NAPI({
@@ -44,7 +47,7 @@ function NapiClient(options) {
  *
  * 1. NIC was removed from the VM or VM provision has failed (destroy)
  * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be udpated (update)
+ * 3. NIC exists and has to be updated (update)
  * 4. NIC exists and but has not changed, no need to do anything (noop)
  */
 NapiClient.prototype.updateNics = function (vm, nics, callback) {
@@ -92,10 +95,24 @@ NapiClient.prototype.updateNics = function (vm, nics, callback) {
 
 
 NapiClient.prototype.getNic = function (mac, callback) {
+    assert.object(this.client, 'this.client');
     return this.client.getNic(mac, callback);
 };
 
 
+NapiClient.prototype.listNics = function (napiClient, params, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.func(callback, 'callback');
+    napiClient.client.listNics(params, callback);
+};
+
+NapiClient.prototype.searchNics = function (napiClient, params, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.func(callback, 'callback');
+    napiClient.client.searchNics(params, callback);
+};
+
+
 NapiClient.prototype.createNic = function (vm, newNic, callback) {
     var log = this.log;
     var nic = _createNicPayload(vm, newNic);
@@ -127,7 +144,7 @@ NapiClient.prototype.updateNic = function (vm, newNic, napiNic, callback) {
 
     this.client.updateNic(nic.mac, nic, function (err) {
         if (err) {
-            log.error(err, 'Could not udpate NIC %s for VM %s',
+            log.error(err, 'Could not update NIC %s for VM %s',
                 nic.mac, vm.uuid);
             return callback(err);
         }
@@ -162,6 +179,14 @@ NapiClient.prototype.deleteNic = function (vm, nic, callback) {
 };
 
 
+NapiClient.prototype.getNics = function (belongsTo, options, callback) {
+    common.assertStrictOptions('getNics', options, {
+        headers: 'string'
+    });
+    this.client.getNics(belongsTo, options, callback);
+};
+
+
 
 /*
  * Some helper functions for NapiClient
@@ -171,17 +196,15 @@ function _nicChanged(cur, old) {
     var fields = [ 'cn_uuid', 'vlan_id', 'nic_tag', 'primary', 'ip', 'netmask',
         'state' ].concat(ANTI_SPOOF_FIELDS);
     var field;
-    var diff = false;
 
     for (var i = 0; i < fields.length; i++) {
         field = fields[i];
         if (cur[field] !== old[field]) {
-            diff = true;
-            break;
+            return true;
         }
     }
 
-    return diff;
+    return false;
 }
 
 
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 64604a2..cd91ebc 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,18 +5,99 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
- * net-agent.js
+ * Net-Agent and NAPI
+ * ==================
+ *
+ * VM Change Events
+ * ----------------
+ *
+ * Net-agent's job is to inform NAPI of any changes to any NICs that result
+ * from VM-related events. For instance, if a VM gets destroyed (either by
+ * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
+ * for telling NAPI that the NIC that used to belong to that VM should be
+ * destroyed.
+ *
+ * Net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone configurations XML file has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever a change is detected, net-agent walks its internal list of VM
+ * objects (which also contains the NIC info) and pushes the NIC objects to
+ * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
+ * address.
+ *
+ * Orphaned NICs
+ * -------------
+ *
+ * One cannot assume that net-agent is continuously reacting to every single
+ * event on a compute node (CN). For example net-agent may be disabled by an
+ * operator, may go down due to an error, or may not receive an event (it
+ * happens). To handle these situations, when net-agent starts up it scans
+ * every NIC on the CN[1], and tells NAPI to delete any NIC if it does not have
+ * a corresponding VM (that is not destroyed). This is only done once on
+ * startup because such a scan can be very expensive.
+ *
+ * [1]: Currently we scan every NIC in the DC, since NAPI doesn't allow us to
+ * filter NICs by compute node. But as soon as it does, we will switch to that
+ * (see NAPI-360).  This means that we have to ignore NICs that have a
+ * `cn_uuid` different from the agent's.
+ *
+ * Net-Agent and Compute Nodes
+ * ===========================
+ *
+ * The previous section described the interaction between a single net-agent
+ * service and a single NAPI service. However, we always have more than one
+ * net-agent. In fact we have one net-agent per CN. All of these net-agents
+ * react only to VM events on their respective CNs. However, they are modifying
+ * global NIC objects, and they all connect to a single NAPI service (this may
+ * change in the future). It is important to keep this mind. We don't want all
+ * of our net-agents to start battering NAPI with requests at the same time.
+ * For the change-event-related requests this is not a problem. However, for
+ * the orphaned-nic-related requests, this could be catastrophic. This is why
+ * we insert a random delay before the searchNics request that is no greater
+ * than 10 minutes.
+ *
+ * Net-Agent and VMs
+ * =================
+ *
+ * Net-Agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory. This set of
+ * VM objects is known as the sample.
+ *
+ * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * and processing the JSON that it produces on stdout. `zoneevent` emits output
+ * whenever a property of the zone has changed. Note that it does not report
+ * higher-level VM properties (that are used by vmadm and vmapi).
+ *
+ * As Net-Agent receives these change events, it updates the changed properties
+ * of the VM objects in the sample. However, it is possible that one of the
+ * change-events does not make it to net-agent. In order to mitigate the drift
+ * between net-agent's picture of reality, and reality itself, net-agent also
+ * does a full `vmadm lookup` every minute, and emits state-change events if it
+ * detects a difference.
  */
 
 var async = require('async');
+var util = require('util');
 var backoff = require('backoff');
+var restify = require('restify');
+var assert = require('assert-plus');
+var endpoints = require('./endpoints');
 
 var VM = require('./vm');
+var vmadm = require('vmadm');
 var NAPI = require('./napi-client');
+var mod_jsprim = require('jsprim');
+var common = require('./common');
+var VError = require('verror');
+
 
 var _versionCache = null;
 function getNetAgentVersion() {
@@ -33,6 +114,10 @@ function NetAgent(options) {
     this.lastFullSample = null;
     this.uuid = options.uuid;
     this.version = getNetAgentVersion();
+    this.init = {};
+    this.server = null;
+    this.na_epoch = process.hrtime();
+    this.na_init_history = [];
 
     var userAgent = 'net-agent/' + this.version +
         ' (' + 'node/' + process.versions.node + ')' +
@@ -55,32 +140,152 @@ function NetAgent(options) {
     this.queues = {};
 }
 
+NetAgent.prototype.history = function history(name) {
+    var delta = mod_jsprim.hrtimeMicrosec(process.hrtime(this.na_epoch));
+    this.na_init_history.push({
+        h_name: name,
+        h_time: delta
+    });
+};
 
-NetAgent.prototype.start = function () {
+/*
+ * This function initializes the restify HTTP server.
+ * Currently, it temporarily listens on port 5311, until we nail down a proper
+ * port-allocation policy for SDC's agents.
+ */
+NetAgent.prototype.initializeServer = function (callback) {
+    var self = this;
+    self.server = restify.createServer({
+        log: self.log,
+        name: 'Net Agent',
+        version: '0.0.1'
+    });
+    function populateReq(req, res, next) {
+        req.app = self;
+        return next();
+    }
+    endpoints.registerEndpoints(self.server, self.log.child({component:
+        'restify'}), [ populateReq ]);
+
+    self.server.listen(5311, callback);
+};
+
+
+NetAgent.prototype.start = function (callback) {
     var self = this;
     var log = this.log;
 
-    this.initializeEventWatcher();
+    this.history('InitializingServer');
+    this.initializeServer(function (err) {
+        if (err) {
+            callback(new VError(err, 'could not initialize server'));
+            return;
+        }
+        self.history('InitializingEventWatcher');
+        self.initializeEventWatcher();
+        self.history('InitializedEventWatcher');
+
+        // Wrap our initial full sample in a retry-backoff
+        var opts = { uuid: this.uuid };
+        var fn = self.sendFullSample.bind(self, opts);
+        self.retryUpdate(fn, opts, onRetry);
+
+        function onRetry(err2) {
+            if (err2) {
+                log.error(err2, 'Failed retry-backoff for initial sendFullSample');
+                return;
+            }
 
-    // Wrap our initial full sample in a retry-backoff
-    var opts = { uuid: this.uuid };
-    var fn = this.sendFullSample.bind(this, opts);
-    this.retryUpdate(fn, opts, onRetry);
+            log.info('Initial NICs state was successfully sent. Good to go');
+        }
+    });
+};
 
-    function onRetry(err) {
+/*
+ * Called on startup. Function asks NAPI for all allocated NICs.  It uses this
+ * list to detect leaked NICs by querying for NICs that are allocated,
+ * unreserved, belong to type 'zone', and not assigned to any existing VM. It
+ * emits a leaked_nic event, which net-agent responds to by destroying the NIC.
+ */
+NetAgent.prototype.reapNics = function () {
+
+    var self = this;
+
+    assert.object(this.napiClient, 'this.napiClient');
+    assert.object(this.napiClient.log);
+    var log = this.napiClient.log;
+    var napiClient = this.napiClient;
+    var cn_uuid = this.uuid;
+    /*
+     * We get the list of NICs on this CN from NAPI.
+     */
+    function search_nics_cb(err, nics) {
+        /*
+         * We can get an error for the following reasons:
+         *
+         *      -we provided an invalid parameter to the endpoint
+         *      -the /search/nics endpoint does not exist
+         *
+         * The former would be indicative of a bug in SDC, specifically
+         * net-agent (as we should always be passign valid params). The latter
+         * would be indicative of an outdated version of NAPI. If either of
+         * these things happen, we don't initiate any kind of reap. If NAPI
+         * gets upgraded, this will be detected the next time net-agent starts
+         * up.
+         */
         if (err) {
-            log.error(err, 'Failed retry-backoff for initial sendFullSample');
+            if (err.body.code === 'InvalidParameters') {
+                log.error('Invalid params passed to /search/nics');
+            } else if (err.body.code === 'ResourceNotFound') {
+                log.info('Old version of NAPI does not support /search/nics');
+            }
+            self.history('SkippedReapNics');
             return;
         }
+        var leaked_nics = nics.filter(function scan_nics(nic) {
+            if (nic.belongs_to_type !== 'zone') {
+                return (false);
+            }
+            if (self.sample[nic.belongs_to_uuid]) {
+                return (false);
+            }
+            return (true);
+        });
 
-        log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
+        self.history('StartedReapNics');
+
+        leaked_nics.forEach(function reap_nic(nic) {
+            /*
+             * Currently, the implementation of deleteNic only looks at the
+             * UUID of the VM. If we are in this function, we know that the
+             * VM itself no longer exists, which is why we don't have a
+             * complete VM object. If deleteNic starts accessing other vm
+             * members in the future, we will have to add them to the
+             * `targ_vm` obj below.
+             */
+            var targ_vm = { uuid: nic.belongs_to_uuid };
+            napiClient.deleteNic(targ_vm, nic,
+                function handle_delete_nic(err2, res2) {
+
+                if (err2) {
+                    return;
+                }
+                return;
+            });
+        });
     }
+    var retry = backoff.call(napiClient.searchNics, napiClient,
+        {cn_uuid: cn_uuid}, search_nics_cb);
+    retry.retryIf(function (err) {
+        console.log('retryIf');
+        console.log(err);
+        return (err.body.code !== 'InvalidParameters' &&
+                err.body.code !== 'ResourceNotFound');
+    });
+    retry.setStrategy(new backoff.ExponentialStrategy());
+    retry.start();
 };
 
-
 /*
  * Initializes the EventWatcher event listeners
  */
@@ -89,7 +294,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
     var log = this.log;
     var eventWatcher = this.eventWatcher;
 
-    eventWatcher.on('state', function (uuid, state) {
+    eventWatcher.on('state', function vm_state_event(uuid, state) {
         log.debug('state event for %s state: %s', uuid, state);
         self.pushSample({
             uuid: uuid,
@@ -97,7 +302,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_state', function (uuid, zone_state) {
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
         log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
         self.pushSample({
             uuid: uuid,
@@ -105,7 +310,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_xml', function (uuid) {
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
         log.debug('fs.watch event on /etc/zones for %s', uuid);
         self.pushSample({
             uuid: uuid,
@@ -113,7 +318,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('destroyed', function (uuid) {
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
         var vm = self.sample[uuid];
         if (!vm) {
             log.warn('VM %s appears to have gone away but ' +
@@ -123,10 +328,13 @@ NetAgent.prototype.initializeEventWatcher = function () {
 
         log.info('Found a destroyed VM %s', uuid);
         vm.state = 'destroyed';
-        self.pushSample({ uuid: uuid, cachedVm: vm });
+        self.pushSample({
+            uuid: uuid,
+            cachedVm: vm
+        });
     });
 
-    eventWatcher.on('err', function (err) {
+    eventWatcher.on('err', function zone_err_event(err) {
         log.error(err, 'eventWatcher saw en error');
     });
 };
@@ -140,7 +348,6 @@ NetAgent.prototype.setSample = function (sample) {
     });
 };
 
-
 /*
  * On startup, sendFullSample updates all NICs for all VMs on the server. This
  * will be a blocking call before we turn on the event listeners so we allow
@@ -150,19 +357,41 @@ NetAgent.prototype.sendFullSample = function (opts, callback) {
     var self = this;
     var log = this.log;
 
+    function startEventWatchers() {
+            self.history('StartingEventWatcher');
+            self.eventWatcher.updateState(self.sample);
+            self.eventWatcher.lastCfgEvent = self.lastFullSample;
+            self.eventWatcher.start();
+            self.history('StartedEventWatcher');
+    }
+
+    function doReapNics() {
+        var min_timeout = 0.5 * 60 * 1000;
+        var max_timeout = 2 * 60 * 1000;
+        var rand_timeout = Math.floor(Math.random() * (max_timeout -
+            min_timeout + 1)) + min_timeout;
+
+        setTimeout(function () {
+            self.reapNics();
+        }, rand_timeout);
+    }
+
     this.updateSample({}, function (err, sample) {
         if (err) {
             log.error(err, 'updateSample failed, cannot sendFullSample');
             callback(err);
             return;
-
         } else if (Object.keys(sample).length === 0) {
-            log.warn('empty sample returned by vmadm lookup');
+            log.warn('Empty sample returned by vmadm lookup');
+            startEventWatchers();
+            doReapNics();
             callback();
             return;
         }
 
         self.setSample(sample);
+        startEventWatchers();
+        doReapNics();
 
         async.forEachSeries(Object.keys(sample), function (uuid, cb) {
             var options = {
@@ -199,16 +428,14 @@ NetAgent.prototype.sendSample = function (options, callback) {
         this.eventWatcher.removeState(options.uuid);
 
         self._updateVmNics(options, callback);
-
     } else {
         this.updateSample(options, function (err, sample) {
             if (err) {
                 log.error(err, 'updateSample failed, cannot sendSample');
                 callback(err);
-
             } else if (Object.keys(sample).length === 0) {
                 log.warn('empty sample returned by vmadm lookup');
-                 callback();
+                callback();
             } else {
                 self.eventWatcher.updateState(sample);
                 self.setSample(sample);
@@ -225,6 +452,7 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * - options.cachedVm: what net-agent currently knows about the VM
  * - options.vm: what net-agent has loaded from vmadm
+ * - options.cn_uuid: the cn_uuid of the vm's NICs
  *
  * When options.vm is undefined, it means that the VM has been destroyed because
  * options.vm gets populated from the vmadm lookup results. We always store the
@@ -232,10 +460,31 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * When options.cachedVm is undefined, then this is the first time we see that
  * VM (or our net-agent has just started)
+ *
+ * When options.cn_uuid is different from this.uuid, we don't do anything.
  */
-NetAgent.prototype._updateVmNics = function (options, callback) {
+NetAgent.prototype._updateVmNicsImpl = function (options, callback) {
+    common.assertStrictOptions('_updateVmNicsImpl', options, {
+        uuid: 'string',
+        cn_uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject',
+        nicsToBackfill: 'arrayOfObject'
+    });
     var log = this.log;
-    var allNics = [];
+    var vm = options.vm || options.cachedVm;
+
+    /*
+     * Note that when asking NAPI to udpate NICs, it only updates the NICs
+     * partially (whereas Moray updates them atomically). It is conceivable
+     * that `allNics` contains multiple NIC objects with the same MAC address
+     * (because of the backfill array that we are essentially appending to).
+     * This is not a problem, because we only ever update changed properties.
+     */
+    var allNics = options.nicsToBackfill;
+    options.nicsToBackfill = undefined;
+
+    assert.uuid(this.uuid, 'this.uuid');
 
     if (options.vm) {
         options.vm.nics.forEach(function (nic) {
@@ -276,12 +525,84 @@ NetAgent.prototype._updateVmNics = function (options, callback) {
         return;
     }
 
-    var vm = options.vm || options.cachedVm;
-
     this.napiClient.updateNics(vm, allNics, callback);
 };
 
 
+NetAgent.prototype._updateVmNics = function (options, callback) {
+    common.assertStrictOptions('_updateVmNics', options, {
+        uuid: 'string',
+        cn_uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject'
+    });
+    /*
+     * We want to grab this VM's NICs from NAPI, so that we can have a copy of
+     * their cn_uuid (which is not stored in the vm-object's `nic` member).
+     */
+    var self = this;
+    self.napiClient.getNics(options.uuid, {}, function (err, nics) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        options.nicsToBackfill = [];
+        if (nics.length > 0) {
+            /*
+             * We verify that all NICs (a) have the cn_uuid set, (b) have
+             * the same cn_uuid as the VM they belong to, and (c) are in the
+             * 'running' state. If any of these are false, we set the cn_uuid
+             * to the VM's cn_uuid and we set the state to 'running'. The
+             * discrepancy in cn_uuid and state may be the result of developer
+             * error[1] or operator error[2]. The agents have to be resilient
+             * to these errors. However, since there are an infinite number of
+             * ways in which an operator (or developer) can screw up we can
+             * _only_ promise resiliency, not invincibility.
+             *
+             * In most situations, updating the cn_uuid to match that of the VM
+             * is a reasonable thing to do. If doing so does not make the
+             * system any more consistent, then we may have a FUBAR-level
+             * operator error (like running a very old migration script, or
+             * trying to run a custom-rolled one).
+             *
+             * [1]: For example situation (a) is caused by having created VMs
+             * and NICs on a deployment which has/had an old version of NAPI
+             * that does not track each NIC's cn_uuid. Situation (c) results
+             * from the system neglecting to update the NIC state from
+             * 'provisioning' to 'running'.
+             *
+             * [2]: Operators need to do things which are not supported at the
+             * SDC layer, but can be achieved by using tools at the SmartOS
+             * layer -- see: migrations or messing with VMs using vmadm.
+             */
+            var vm = options.vm || options.cachedVm;
+            for (var i = 0; i < nics.length; i++) {
+                var nic = nics[i];
+                var update = false;
+                if (nic.cn_uuid === undefined ||
+                    vm.server_uuid !== nic.cn_uuid) {
+
+                    nic.cn_uuid = vm.server_uuid;
+                    update = true;
+                }
+                if (nic.state !== 'running') {
+                    nic.state = 'running';
+                    update = true;
+                }
+                if (update) {
+                    options.nicsToBackfill.push(nic);
+                }
+            }
+
+            options.cn_uuid = self.uuid;
+        } else {
+            options.cn_uuid = self.uuid;
+        }
+        self._updateVmNicsImpl(options, callback);
+    });
+};
+
+
 /*
  * Initializes the serial queue for a single uuid and pushes the item to be
  * processed.
@@ -289,10 +610,7 @@ NetAgent.prototype._updateVmNics = function (options, callback) {
 NetAgent.prototype.pushSample = function (options) {
     var uuid = options.uuid || this.uuid;
 
-    if (this.queues[uuid] === undefined) {
-        this.queues[uuid] = this.createQueue(uuid);
-    }
-
+    this.queues[uuid] = this.createQueue(uuid);
     this.queues[uuid].push(options);
 };
 
@@ -326,17 +644,16 @@ NetAgent.prototype.retryUpdate = function (fn, options, callback) {
         return (_log);
     }
 
-    var retry = backoff.call(fn, function (err) {
+    var retry = backoff.call(fn, function backoffCallCb(err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
 
         if (err) {
             log.error({ uuid: options.uuid },
                 'Could not retry operation after %d attempts', attempts);
             return callback(err);
         }
-
         return callback();
     });
 
@@ -359,9 +676,9 @@ NetAgent.prototype.createQueue = function (uuid) {
     var self = this;
     var log = this.log;
 
-    var queue = async.queue(function (opts, callback) {
+    var queue = async.queue(function qcb(opts, callback) {
         var fn = self.sendSample.bind(self, opts);
-        self.retryUpdate(fn, opts, function (err) {
+        self.retryUpdate(fn, opts, function retryUpdateCb(err) {
             if (err) {
                 log.error(err, 'Error updating NICs %', uuid);
                 return callback(err);
@@ -414,8 +731,9 @@ NetAgent.prototype.createQueue = function (uuid) {
  */
 
 NetAgent.prototype.updateSample = function (options, callback) {
-    if (!this._sampleQueue)
+    if (!this._sampleQueue) {
         this._sampleQueue = async.queue(updateSample.bind(this), 8);
+    }
     this._sampleQueue.push(options, callback);
 };
 
@@ -441,7 +759,7 @@ function updateSample(options, callback) {
 
         log.debug('Starting updateSample ' + query);
 
-        VM.list(searchOpts, function (err, vmobjs) {
+        vmadm.lookup(searchOpts, {log: log}, function (err, vmobjs) {
             var vmobj;
             var running = 0;
             var notRunning = 0;
@@ -450,7 +768,6 @@ function updateSample(options, callback) {
             if (err) {
                 log.error(err, 'ERROR: unable update VM list');
                 return cb(err);
-
             } else {
                 for (vmobj in vmobjs) {
                     vmobj = vmobjs[vmobj];
@@ -471,7 +788,7 @@ function updateSample(options, callback) {
                     notRunning: notRunning,
                     nonInventory: nonInventory
                 };
-                log.trace(lookupResults, 'Lookup query results');
+                log.info(lookupResults, 'Lookup query results');
 
                 return cb(null);
             }
@@ -501,7 +818,7 @@ function updateSample(options, callback) {
     var retry = backoff.call(lookup, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
         if (err) {
             log.error('Could not updateSample after %d attempts', attempts);
             return callback(err);
diff --git a/lib/vm.js b/lib/vm.js
index 5715c40..24c75ce 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -21,10 +21,12 @@ var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var EventEmitter = require('events').EventEmitter;
+var vmadm = require('vmadm');
+var LineStream = require('lstream');
+var VError = require('verror');
 
 var async = require('async');
 
-var VMADM = '/usr/sbin/vmadm';
 
 
 
@@ -38,44 +40,6 @@ function isLocal(vms, vm) {
     return null;
 }
 
-
-function listVMs(filter, fields, callback) {
-    if (!callback) {
-        callback = fields;
-        fields = undefined;
-    }
-
-    var args = ['lookup', '-j'];
-    for (var k in filter) {
-        args.push(k + '=' + filter[k]);
-    }
-    if (fields) {
-        args.push('-o', fields.join(','));
-    }
-
-    return execFile(VMADM, args, {maxBuffer: 32 * 1024 * 1024},
-        function (err, stdout, stderr) {
-
-        if (err) {
-            err.stdout = stdout;
-            err.stderr = stderr;
-            return callback(err);
-        }
-
-        var vms;
-
-        try {
-            vms = JSON.parse(stdout);
-        } catch (jsonErr) {
-            jsonErr.stdout = stdout;
-            return callback(jsonErr);
-        }
-
-        return callback(null, vms);
-    });
-}
-
-
 // These are the events being watched by the zoneevent watcher. When zones
 // don't switch to these zone_states we ignore them
 var watchEvents = {
@@ -83,7 +47,7 @@ var watchEvents = {
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 30000;
+var STATE_WATCHER_TIMEOUT = 60 * 1000;
 
 /*
  * The EventWatcher will emit these events:
@@ -128,7 +92,7 @@ EventWatcher.prototype.start = function () {
 EventWatcher.prototype.updateState = function (objs) {
     var self = this;
 
-    Object.keys(objs).forEach(function (uuid) {
+    Object.keys(objs).forEach(function foreachobjs(uuid) {
         self.vmStates[uuid] = {
             state: objs[uuid].state,
             zone_state: objs[uuid].zone_state
@@ -166,10 +130,6 @@ EventWatcher.prototype.startStateWatcher = function () {
         }
 
         vmobjs.forEach(function (vm) {
-            // Only use inventory vms
-            if (vm.do_not_inventory) {
-                return;
-            }
 
             // Don't emit when states stay the same
             var current = self.getState(vm.uuid);
@@ -191,14 +151,33 @@ EventWatcher.prototype.startStateWatcher = function () {
         setTimeout(lookup, STATE_WATCHER_TIMEOUT);
     }
 
-    var lookup = listVMs.bind(null,
-        {}, ['uuid', 'state', 'zone_state', 'do_not_inventory'], onLookup);
+    /*
+     * We get a list of all VMs that don't have the do_not_inventory flag set.
+     * This flag is used by tests and ops to get some things done. For example
+     * it is used by the migrator script to signal to SDC that events for the
+     * target VM should be ignored.
+     */
+    var lookup = vmadm.lookup.bind(null, {}, {
+        fields: [
+            'uuid',
+            'state',
+            'zone_state'],
+         log: log,
+         include_dni: false
+    }, onLookup);
 
     lookup();
 };
 
-
 EventWatcher.prototype.startZoneWatcher = function () {
+    /*
+     * sendFullSample is called in an infinite retry loop. We don't want to
+     * create a swarm of zoneevent processes. Therefore we simply return from
+     * this function, if we already have one such process running.
+     */
+    if (this.zoneeventWatcher !== null) {
+        return;
+    }
     var log = this.log;
     var self = this;
 
@@ -209,32 +188,44 @@ EventWatcher.prototype.startZoneWatcher = function () {
 
     log.info('zoneevent running with pid ' + watcher.pid);
 
-    function onData(data) {
-        log.trace('zone event: ', data.toString());
-
-        // There can be more than one event in a single data event
-        var events = data.toString().split('\n');
-        events.forEach(processEvent);
-    }
-
-    function processEvent(event) {
-        if (event === '') {
-            return;
+    var stdoutStream = new LineStream();
+    var stderrStream = new LineStream();
+    watcher.stdout.pipe(stdoutStream);
+    watcher.stderr.pipe(stderrStream);
+    stdoutStream.on('readable', function () {
+        var line;
+        while ((line = stdoutStream.read()) !== null) {
+            log.info('zone event: ', line.toString());
+            var event = JSON.parse(line);
+            if (watchEvents[event.newstate]) {
+                self.emit('zone_state', event.zonename, event.newstate);
+            }
         }
-
-        event = JSON.parse(event);
-
-        // Only updateSample when it is an event we're watching
-        if (watchEvents[event.newstate]) {
-            self.emit('zone_state', event.zonename, event.newstate);
+    });
+    stderrStream.on('readable', function () {
+        var line;
+        while ((line = stdoutStream.read()) !== null) {
+            log.error('zone event: ', line.toString());
         }
-    }
-
-    watcher.stdout.on('data', onData);
+    });
+    // watcher.stdout.on('data', onData);
     watcher.stdin.end();
+    var stdout_ended = false;
+    var watcher_exited = false;
+    watcher.stdout.on('end', function () {
+        stdout_ended = true;
+        if (watcher_exited) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+        }
+    });
     watcher.on('exit', function (code) {
-        log.warn('zoneevent watcher exited.');
-        watcher = null;
+        if (stdout_ended) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+        } else {
+            watcher_exited = true;
+        }
     });
 };
 
@@ -357,7 +348,7 @@ function checkDestroyed(uuid, callback) {
     var cmd = '/usr/sbin/zoneadm list -pc | grep ' + uuid + ' || true';
     exec(cmd, [], function (exitStatus, stdout, stderr) {
         if (exitStatus) {
-            return callback(new Error(stderr.toString()));
+            return callback(new VError(stderr.toString()));
         }
 
         var destroyed = (stdout.toString().trim() === '');
@@ -368,13 +359,11 @@ function checkDestroyed(uuid, callback) {
 
 function createEventWatcher(options) {
     assert.ok(options.log, 'EventWatcher options.log');
-
     return new EventWatcher(options);
 }
 
 
 module.exports = {
     isLocal: isLocal,
-    list: listVMs,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index 8a31a32..c9f627f 100644
--- a/package.json
+++ b/package.json
@@ -6,15 +6,22 @@
     "private": true,
     "dependencies": {
         "async": "0.1.18",
-        "backoff": "2.3.0",
+        "assert-plus": "^1.0.0",
+        "backoff": "2.5.0",
         "bunyan": "1.3.2",
         "sdc-bunyan-serializers": "git+ssh://git@github.com:joyent/sdc-bunyan-serializers.git#aefc119",
         "nodeunit": "0.7.4",
         "restify": "2.7.0",
-        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#c962959"
+        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#22fafaf5578",
+        "vmadm": "git+ssh://git@github.com:joyent/node-vmadm.git#3cf878481d24c1bc1e74e85a95004a3dde6329f1",
+        "lstream": "0.0.4",
+	"verror": "1.6.1",
+        "jsprim": "1.3.0"
     },
     "sdcDependencies": {
-        "config-agent": ">=1.3.0"
+        "config-agent": ">=1.3.0",
+        "tape": "4.2.2",
+        "smf": "0.3.1"
     },
     "scripts": {
         "postinstall": "npm/postinstall.sh",
diff --git a/tests/config.json b/tests/config.json
new file mode 100644
index 0000000..5bc25ec
--- /dev/null
+++ b/tests/config.json
@@ -0,0 +1,8 @@
+{
+	"vmapi": {
+		"url": "http://vmapi.coal-1.joyent.us"
+	},
+	"napi": {
+		"url": "http://napi.coal-1.joyent.us"
+	}
+}
diff --git a/tests/runtest b/tests/runtest
new file mode 100755
index 0000000..b542e30
--- /dev/null
+++ b/tests/runtest
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2016, Joyent, Inc.
+#
+
+#
+# Run a single net-agent test of any type.
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE_INSTALL=$TOP/node
+NODEUNIT=$TOP/node_modules/.bin/nodeunit
+UNAME=$(uname -s)
+
+guard_file=/lib/sdc/.sdc-test-no-production-data
+if [[ $UNAME == "SunOS" ]] && [[ ! -f "$guard_file" ]]; then
+    cat <<EOF
+To run this test you must create the file:
+
+    $guard_file
+
+after ensuring you have no production data on this SDC.
+EOF
+    exit 2
+fi
+
+PATH=$NODE_INSTALL/bin:$PATH node $1
diff --git a/tests/unit/test.js b/tests/unit/test.js
new file mode 100644
index 0000000..6da78de
--- /dev/null
+++ b/tests/unit/test.js
@@ -0,0 +1,364 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var path = require('path');
+var fs = require('fs');
+
+var DEFAULT_CFG = path.join(__dirname, '..', '/config.json');
+var config = {};
+try {
+    config = JSON.parse(fs.readFileSync(DEFAULT_CFG, 'utf8'));
+} catch (e) {
+    console.log('Error reading config');
+    console.log(e);
+    process.exit(1);
+}
+var VMAPI_URL = config.vmapi.url || 'http://vmapi.coal-1.joyent.us';
+var NAPI_URL = config.napi.url || 'http://napi.coal-1.joyent.us';
+
+
+
+var test = require('tape');
+var sdcClients = require('sdc-clients');
+var VMAPI = new sdcClients.VMAPI({ url: VMAPI_URL });
+var NAPI = new sdcClients.NAPI({ url: NAPI_URL });
+var vmadm = require('vmadm');
+var smf = require('smf');
+var bunyan = require('bunyan');
+var restify = require('restify');
+var assert = require('assert-plus');
+
+var EXTERNAL_NET = undefined;
+var VM_UUID = undefined;
+/* We use the old sdc-base image from 2014 */
+var IMG_UUID = 'de411e86-548d-11e4-a4b7-3bb60478632a';
+var OWNER_UUID = undefined;
+var SERVER_UUID = undefined;
+var VM_NICS = undefined;
+
+/*
+ * MAC address-related utilities
+ */
+
+
+function delay_check(t, seconds, check) {
+    function dcheck() {
+        check(function (gone) {
+            if (gone) {
+                console.log('VM gone');
+                t.end();
+            } else {
+                console.log('VM not gone, waiting');
+                setTimeout(function () {
+                    dcheck();
+                }, seconds * 1000);
+            }
+        });
+    }
+    dcheck();
+}
+
+function check_vm_gone(cb) {
+    var gone = true;
+    searchOpts = { uuid: VM_UUID, state: 'active' };
+    VMAPI.listVms(searchOpts, function (err, vms) {
+        /* If we can't connect to VMAPI we keep retrying until we can. */
+        if (err) {
+            cb(!gone);
+            return;
+        }
+        if (vms.length) {
+            cb(!gone);
+        } else {
+            cb(gone);
+        }
+    });
+}
+
+
+/*
+ * Functions for manipulating the net-agent service.
+ */
+
+function disable_net_agent(t) {
+    smf.svcadm('disable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not disable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Disabled net-agent');
+        t.end();
+    });
+}
+
+function enable_net_agent(t) {
+    smf.svcadm('enable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not enable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Enabled net-agent');
+        t.end();
+    });
+}
+
+function early_exit() {
+    console.log('A test has failed, so there is no point in continuing.');
+    console.log('Subsequent tests were not executed.');
+    console.log('Identify the cause of the test failure and fix it.');
+    console.log('Then retry running this test suite.');
+    process.exit(1);
+}
+
+/*
+ * Functions for checking if nic is present or absent on the system.
+ */
+
+function nic_gone(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error Getting NIC List');
+            t.end();
+            early_exit();
+            return;
+        }
+        if (nics.length > 0) {
+            t.ok(false, 'NIC is still here!');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.ok(true, 'NIC is gone.');
+        t.end();
+    });
+}
+
+function nic_exists(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit();
+            return;
+        }
+        VM_NICS = nics;
+
+        if (VM_NICS.length > 0) {
+            t.end();
+            return;
+        }
+        t.ok(false, 'No Nics Found For VM');
+        t.end();
+        early_exit();
+    });
+}
+
+/*
+ * Functions for creating/destroying VMs
+ */
+
+function create_vm(t) {
+
+    VMAPI.createVmAndWait({
+        owner_uuid: OWNER_UUID,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: EXTERNAL_NET.uuid,
+                ipv4_count: 1,
+                primary: true
+            }
+        ],
+        brand: 'joyent-minimal',
+        ram: 256,
+        cpu_cap: 300,
+        alias: 'net-agent-test-vm-1',
+        image_uuid: IMG_UUID
+    }, function createVmCb(err, job) {
+        if (err) {
+            t.error(err, 'Error on creating VM');
+            t.end();
+            early_exit();
+            return;
+        }
+        VM_UUID = job.vm_uuid;
+        t.end();
+    });
+};
+
+function destroy_vm(t) {
+    vmadm.delete({
+        uuid: VM_UUID,
+        log: bunyan.createLogger({
+            name: 'vmadm.delete',
+            level: 'INFO',
+            stream: process.stdout,
+            serializers: bunyan.stdSerializers
+        })
+    }, function (err) {
+        if (err) {
+            t.error(err, 'Error Deleting With `vmadm`');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.end();
+    });
+}
+
+function wait_until_agent_ready(t) {
+    var client = restify.createJsonClient({
+        url: 'http://localhost:5311'
+    });
+
+    function try_get_status() {
+        client.get({ path: '/status' }, function (err, req, res, obj) {
+            if (err) {
+                console.log('Error getting status, retrying...');
+                console.log(err);
+                try_get_status();
+                return;
+            }
+            console.log('status object:');
+            console.log(obj);
+            var state = obj.init_history.pop().h_name;
+            if (state === 'StartedReapNics') {
+                console.log('net-agent has started up completely');
+                t.end();
+            } else if (state === 'SkippedReapNics') {
+                console.log('WARNING: net-agent cannot reap NICs');
+                console.log('WARNING: try updating NAPI to complete the' +
+                    ' nic-reap test');
+                early_exit();
+                t.end();
+            } else {
+                console.log('Retrying in 5 seconds');
+                setTimeout(function () {
+                    try_get_status();
+                }, 5 * 1000);
+            }
+        });
+    }
+    try_get_status();
+}
+
+/*
+ * This function asserts that the agent is online. If the agent is not online,
+ * it will wait for it to either move into the online state, or into a
+ * maintenance or degraded state. If the latter occurs, this function causes
+ * the test to abort (in the hope that the dev will fix the service before
+ * running this test again).
+ */
+function assert_svc_state(t) {
+    function wait_for_state() {
+        smf.svcs('net-agent', function (err, svc) {
+            if (svc.state == 'disabled') {
+                /* enable svc */
+                enable_net_agent(t);
+            } else if (svc.state == 'maintenance' || svc.state == 'degraded') {
+                /* bail out */
+                console.log('net-agent is in ' + svc.state + ' state; bailing.');
+                early_exit();
+                t.end();
+            } else if (svc.state == 'offline' || svc.state == 'unitialized') {
+                /* wait for state chage */
+                setTimeout(function () {
+                    wait_for_state();
+                }, 5 * 1000);
+            } else {
+                t.end();
+            }
+        });
+    }
+    wait_for_state();
+}
+
+
+test('Is Net Agent Running?', function (t) {
+    assert_svc_state(t);
+});
+
+test('Get Network Info', function (t) {
+    NAPI.listNetworks(function (err, nets) {
+        if (err) {
+            t.error(err, 'Could not get network info.');
+            t.end();
+            early_exit();
+            return;
+        }
+        for (var n in nets) {
+            assert.string(nets[n].name);
+            if (nets[n].name === 'external') {
+                EXTERNAL_NET = nets[n];
+            }
+        }
+        t.end();
+    });
+});
+
+/*
+ * We use the same OWNER_UUID that is attributed to the napi0 zone.
+ */
+test('Get Owner And Server UUIDs', function (t) {
+    VMAPI.listVms({alias: 'napi0'}, function (err, vms) {
+        if (err) {
+            t.error(err, 'Error getting owner UUID');
+            t.end();
+            early_exit();
+            return;
+        }
+        OWNER_UUID = vms[0].owner_uuid;
+        SERVER_UUID = vms[0].server_uuid;
+        t.end();
+    });
+});
+
+
+/*
+ * This group of tests verifies that net-agent reacts to VM-events properly.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests verifies that net-agent reaps orphaned NICs if it wasn't
+ * able to react to the VM-events.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Enable Net-Agent Service', enable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * For reasons unknown, tape does not stop running, so we have to force the
+ * process to quit.
+ */
+test('Finish', function (t) {
+    delete VMAPI;
+    delete NAPI;
+    t.end();
+});
