commit 09f196efab9f83482f6d390a386482b24f23350e (refs/changes/71/171/9)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2018-03-19T20:51:23+00:00 (1 year, 7 months ago)
    
    NAPI-327 net-agent should not leak NICs

diff --git a/bin/net-agent.js b/bin/net-agent.js
index aa0bb69..fa7a263 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -124,7 +124,15 @@ async.waterfall([
     var netagent;
     if (agentConfig.no_rabbit) {
         netagent = new NetAgent(config);
-        netagent.start();
+        netagent.start(function (err2) {
+            if (err2) {
+                logger.fatal(err2, 'Failed to initialize server');
+                process.exit(1);
+            }
+            var addr = netagent.na_server.address();
+            logger.info('%s listening on <http://%s:%s>',
+                netagent.na_server.name, addr.address, addr.port);
+        });
     } else {
         logger.warn('"no_rabbit" flag is not true, net-agent will now sleep');
         // http://nodejs.org/docs/latest/api/all.html#all_settimeout_cb_ms
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..d1b37b0
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+var assert = require('assert-plus');
+var VError = require('verror');
+
+function assertStrictOptions(funcname, opts, expected)
+{
+    assert.string(funcname, 'funcname');
+    assert.object(opts, funcname + ': opts');
+    assert.object(expected, funcname + ': expected');
+
+    var unexpected = [];
+    for (var k in opts) {
+        if (!opts.hasOwnProperty(k)) {
+            continue;
+        }
+        var e = expected[k];
+        if (!e) {
+            unexpected.push(k);
+            continue;
+        }
+        var afunc = assert[e];
+        assert.func(afunc, 'invalid assertion type: ' + e);
+        afunc(opts[k], 'opts.' + k);
+    }
+
+    if (unexpected.length > 0) {
+        throw (new VError(funcname + ': unexpected options: ' +
+            unexpected.join(', ')));
+    }
+}
+
+module.exports = {
+    assertStrictOptions: assertStrictOptions
+};
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
new file mode 100644
index 0000000..42578fc
--- /dev/null
+++ b/lib/endpoints/index.js
@@ -0,0 +1,24 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var toRegister = {
+    '/status': require('./status')
+};
+
+function registerEndpoints(http, log, before) {
+    for (var t in toRegister) {
+        log.debug('Registering endpoints for "%s"', t);
+        toRegister[t].register(http, before);
+    }
+}
+
+module.exports = {
+    registerEndpoints: registerEndpoints
+};
diff --git a/lib/endpoints/status.js b/lib/endpoints/status.js
new file mode 100644
index 0000000..82527b9
--- /dev/null
+++ b/lib/endpoints/status.js
@@ -0,0 +1,44 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var mod_jsprim = require('jsprim');
+
+/*
+ * Status endpoint
+ */
+
+
+
+/*
+ * GET /status
+ */
+function
+getStatus(req, res, next)
+{
+    var stat = {
+        now: mod_jsprim.hrtimeMicrosec(process.hrtime(req.app.na_epoch)),
+        init_history: req.app.na_init_history
+    };
+    res.send(200, stat);
+    next();
+}
+
+function
+register(http, before)
+{
+    http.get({
+        path: '/status',
+        name: 'getStatus'
+    }, before, getStatus);
+}
+
+module.exports = {
+    register: register
+};
diff --git a/lib/napi-client.js b/lib/napi-client.js
index 37faaac..63c28c2 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -14,6 +14,8 @@
 
 var async = require('async');
 var NAPI = require('sdc-clients').NAPI;
+var assert = require('assert-plus');
+var common = require('./common');
 
 var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
     'allow_mac_spoofing', 'allow_restricted_traffic',
@@ -92,10 +94,17 @@ NapiClient.prototype.updateNics = function (vm, nics, callback) {
 
 
 NapiClient.prototype.getNic = function (mac, callback) {
+    assert.object(this.client, 'this.client');
     return this.client.getNic(mac, callback);
 };
 
 
+NapiClient.prototype.searchNics = function (params, callback) {
+    assert.func(callback, 'callback');
+    this.client.searchNics(params, callback);
+};
+
+
 NapiClient.prototype.createNic = function (vm, newNic, callback) {
     var log = this.log;
     var nic = _createNicPayload(vm, newNic);
@@ -162,6 +171,14 @@ NapiClient.prototype.deleteNic = function (vm, nic, callback) {
 };
 
 
+NapiClient.prototype.getNics = function (belongsTo, options, callback) {
+    common.assertStrictOptions('getNics', options, {
+        headers: 'string'
+    });
+    this.client.getNics(belongsTo, options, callback);
+};
+
+
 
 /*
  * Some helper functions for NapiClient
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 58dcb02..6f8a25f 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -33,6 +33,37 @@
  * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
  * address.
  *
+ * Orphaned NICs
+ * -------------
+ *
+ * One cannot assume that net-agent is continuously reacting to every single
+ * event on a compute node (CN). For example net-agent may be disabled by an
+ * operator, may go down due to an error, or may not receive an event (it
+ * happens). To handle these situations, when net-agent starts up it scans
+ * every NIC on the CN[1], and tells NAPI to delete any NIC if it does not have
+ * a corresponding VM (that is not destroyed). This is only done once on
+ * startup because such a scan can be very expensive.
+ *
+ * [1]: Currently we scan every NIC in the DC, since NAPI doesn't allow us to
+ * filter NICs by compute node. But as soon as it does, we will switch to that
+ * (see NAPI-360).  This means that we have to ignore NICs that have a
+ * `cn_uuid` different from the agent's.
+ *
+ * Net-Agent and Compute Nodes
+ * ===========================
+ *
+ * The previous section described the interaction between a single net-agent
+ * service and a single NAPI service. However, we always have more than one
+ * net-agent. In fact we have one net-agent per CN. All of these net-agents
+ * react only to VM events on their respective CNs. However, they are modifying
+ * global NIC objects, and they all connect to a single NAPI service (this may
+ * change in the future). It is important to keep this mind. We don't want all
+ * of our net-agents to start battering NAPI with requests at the same time.
+ * For the change-event-related requests this is not a problem. However, for
+ * the orphaned-nic-related requests, this could be catastrophic. This is why
+ * we insert a random delay before the searchNics request that is no greater
+ * than 10 minutes.
+ *
  * Net-Agent and VMs
  * =================
  *
@@ -55,11 +86,18 @@
 
 var assert = require('assert-plus');
 var async = require('async');
+var vasync = require('vasync');
 var backoff = require('backoff');
 var vmadm = require('vmadm');
+var restify = require('restify');
+var endpoints = require('./endpoints');
 
 var VM = require('./vm');
 var NAPI = require('./napi-client');
+var mod_jsprim = require('jsprim');
+var common = require('./common');
+var VError = require('verror');
+
 
 var _versionCache = null;
 function getNetAgentVersion() {
@@ -76,6 +114,20 @@ function NetAgent(options) {
     this.lastFullSample = null;
     this.uuid = options.uuid;
     this.version = getNetAgentVersion();
+    this.reapNicsTimeout = undefined;
+    this.reapFinished = false;
+    /* The below delays are in microseconds */
+    this.reapNicsLongDelay = 60 * 60 * 1000;
+    var min_timeout = 2 * 60 * 1000;
+    var max_timeout = 10 * 60 * 1000;
+    this.reapNicsStartupDelay = Math.floor(Math.random() * (max_timeout -
+        min_timeout + 1)) + min_timeout;
+    /* The 2 delays below are in millisconds */
+    this.reapNicsInitDelay = 2000;
+    this.reapNicsMaxDelay = 64000;
+    this.na_server = null;
+    this.na_epoch = process.hrtime();
+    this.na_init_history = [];
 
     var userAgent = 'net-agent/' + this.version +
         ' (' + 'node/' + process.versions.node + ')' +
@@ -98,32 +150,198 @@ function NetAgent(options) {
     this.queues = {};
 }
 
+NetAgent.prototype.history = function history(name) {
+    var delta = mod_jsprim.hrtimeMicrosec(process.hrtime(this.na_epoch));
+    this.na_init_history.push({
+        h_name: name,
+        h_time: delta
+    });
+};
+
+/*
+ * This function initializes the restify HTTP server.
+ * Currently, it temporarily listens on port 5311, until we nail down a proper
+ * port-allocation policy for SDC's agents.
+ */
+NetAgent.prototype.initializeServer = function (callback) {
+    var self = this;
+    self.na_server = restify.createServer({
+        log: self.log,
+        name: 'Net Agent',
+        version: '0.0.1'
+    });
+    function populateReq(req, res, next) {
+        req.app = self;
+        next();
+    }
+    endpoints.registerEndpoints(self.na_server, self.log.child({
+        component: 'restify'
+    }), [ populateReq ]);
+
+    self.na_server.listen(5311, callback);
+};
+
 
-NetAgent.prototype.start = function () {
+NetAgent.prototype.start = function (callback) {
     var self = this;
     var log = this.log;
 
-    this.initializeEventWatcher();
+    this.history('InitializingServer');
+    this.initializeServer(function (err) {
+        if (err) {
+            callback(new VError(err, 'could not initialize server'));
+            return;
+        }
+        self.history('InitializingEventWatcher');
+        self.initializeEventWatcher();
+        self.history('InitializedEventWatcher');
+
+        // Wrap our initial full sample in a retry-backoff
+        var opts = { uuid: self.uuid };
+        var fn = self.sendFullSample.bind(self, opts);
+        self.retryUpdate(fn, opts, function onRetry(err2) {
+            if (err2) {
+                log.error(err2, 'Failed retry-backoff ' +
+                    'for initial sendFullSample');
+                return;
+            }
 
-    // Wrap our initial full sample in a retry-backoff
-    var opts = { uuid: this.uuid };
-    var fn = this.sendFullSample.bind(this, opts);
-    this.retryUpdate(fn, opts, onRetry);
+            log.info('Initial NICs state was successfully sent. Good to go');
+            callback();
+        });
+    });
+};
 
-    function onRetry(err) {
+/*
+ * Called on startup. Function asks NAPI for all allocated NICs.  It uses this
+ * list to detect leaked NICs by querying for NICs that are allocated,
+ * unreserved, belong to type 'zone', and not assigned to any existing VM. It
+ * emits a leaked_nic event, which net-agent responds to by destroying the NIC.
+ */
+NetAgent.prototype.reapNics = function () {
+    var self = this;
+
+    assert.object(this.napiClient, 'this.napiClient');
+    assert.object(this.napiClient.log);
+    var log = this.napiClient.log;
+    var napiClient = this.napiClient;
+    var cn_uuid = this.uuid;
+    /*
+     * We get the list of NICs on this CN from NAPI.
+     */
+    function search_nics_cb(err, nics) {
+        /*
+         * We can get an error for the following reasons:
+         *
+         *      -we provided an invalid parameter to the endpoint
+         *      -the /search/nics endpoint does not exist
+         *
+         * The former would be indicative of a bug in SDC, specifically
+         * net-agent (as we should always be passing valid params). The latter
+         * would be indicative of an outdated version of NAPI. If either of
+         * these things happen, we don't initiate any kind of reap. If NAPI
+         * gets upgraded, this will be detected after a very long backoff.
+         */
         if (err) {
-            log.error(err, 'Failed retry-backoff for initial sendFullSample');
+            if (err.body.code === 'InvalidParameters') {
+                log.error('Invalid params passed to /search/nics');
+                self.history('SkippedReapNics');
+            } else if (err.body.code === 'ResourceNotFound') {
+                log.info('Old version of NAPI does not support /search/nics');
+                self.history('BackedOffReapNics');
+                setTimeout(self.reapNics.bind(self), self.reapNicsLongDelay);
+            }
             return;
         }
+        if (self.sample.length > 0) {
+            self.sample.forEach(function backfill_walk_sample(vm) {
+                if (vm.nics.length === 0) {
+                    return;
+                }
+                var nicsToUpdate = [];
+                vm.nics.forEach(function vm_nics(vmnic) {
+                    var found = nics.filter(function find_mac(nic) {
+                        return (vmnic.mac === nic.mac);
+                    });
+                    if (found.length === 0) {
+                        vmnic.cn_uuid = vm.server_uuid;
+                        vmnic.state = 'running';
+                        nicsToUpdate.push(vmnic);
+                    }
+                });
+                self.napiClient.updateNics(vm, nicsToUpdate, function
+                    upnics_cb(err2, res) {
+
+                    if (err2) {
+                        log.error('updateNics failed during backfill.');
+                    }
+                });
+            });
+        }
+        var leaked_nics = nics.filter(function scan_nics(nic) {
+            if (nic.belongs_to_type !== 'zone') {
+                return (false);
+            }
+            if (self.sample[nic.belongs_to_uuid]) {
+                return (false);
+            }
+            return (true);
+        });
+
+        self.history('StartedReapNics');
+        function reap_nic(nic, cb) {
+            /*
+             * Currently, the implementation of deleteNic only looks at the
+             * UUID of the VM. If we are in this function, we know that the
+             * VM itself no longer exists, which is why we don't have a
+             * complete VM object. If deleteNic starts accessing other vm
+             * members in the future, we will have to add them to the
+             * `targ_vm` obj below.
+             */
+            var targ_vm = { uuid: nic.belongs_to_uuid };
+            napiClient.deleteNic(targ_vm, nic,
+                function handle_delete_nic(err2, res2) {
+
+                /*
+                 * If we get an error when trying to delete a NIC, the pipeline
+                 * that we are running in (see below), will stop. So, retrying
+                 * only the delete requests that fail is impossible. So,
+                 * instead, we will want to restart the entire reap process.
+                 */
+                if (err2) {
+                    log.error(err2, 'Error while deleting NIC');
+                    self.reapNics();
+                    cb(err2);
+                    return;
+                }
+                cb(null, res2);
+                return;
+            });
+        }
+
+        vasync.forEachPipeline({
+            'func': reap_nic,
+            'inputs': leaked_nics
+        }, function (err2, res) {
+            if (err2) {
+                log.error(err2, 'Error in vasync reap-pipeline');
+            }
+        });
 
-        log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
     }
+    var retry = backoff.call(napiClient.searchNics.bind(napiClient),
+        { cn_uuid: cn_uuid }, search_nics_cb);
+    retry.retryIf(function (err) {
+        return (err.body.code !== 'InvalidParameters' &&
+                err.body.code !== 'ResourceNotFound');
+    });
+    retry.setStrategy(new backoff.ExponentialStrategy({
+        initialDelay: self.reapNicsInitDelay,
+        maxDelay: self.reapNicsMaxDelay
+    }));
+    retry.start();
 };
 
-
 /*
  * Initializes the EventWatcher event listeners
  */
@@ -195,19 +413,43 @@ NetAgent.prototype.sendFullSample = function (opts, callback) {
     var self = this;
     var log = this.log;
 
+    function startEventWatchers() {
+        self.history('StartingEventWatcher');
+        self.eventWatcher.updateState(self.sample);
+        self.eventWatcher.lastCfgEvent = self.lastFullSample;
+        self.eventWatcher.start();
+        self.history('StartedEventWatcher');
+    }
+
+    function doReapNics() {
+        /*
+         * If we fail to sendFullSample, this function will get retried. If we
+         * have already initiated a delayed reapNics() call, we don't want to
+         * re-initiate it.
+         */
+        if (self.reapNicsTimeout === undefined) {
+            self.reapNicsTimeout = setTimeout(function () {
+                self.reapNics();
+            }, self.reapNicsStartupDelay);
+        }
+    }
+
     this.updateSample({}, function (err, sample) {
         if (err) {
             log.error(err, 'updateSample failed, cannot sendFullSample');
             callback(err);
             return;
-
         } else if (Object.keys(sample).length === 0) {
-            log.warn('empty sample returned by vmadm lookup');
+            log.warn('Empty sample returned by vmadm lookup');
+            startEventWatchers();
+            doReapNics();
             callback();
             return;
         }
 
         self.setSample(sample);
+        startEventWatchers();
+        doReapNics();
 
         async.forEachSeries(Object.keys(sample), function (uuid, cb) {
             var options = {
@@ -277,9 +519,17 @@ NetAgent.prototype.sendSample = function (options, callback) {
  * VM (or our net-agent has just started)
  */
 NetAgent.prototype._updateVmNics = function (options, callback) {
+    common.assertStrictOptions('_updateVmNics', options, {
+        uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject'
+    });
     var log = this.log;
+
     var allNics = [];
 
+    assert.uuid(this.uuid, 'this.uuid');
+
     if (options.vm) {
         options.vm.nics.forEach(function (nic) {
             // When VM is failed just mark all NICs are destroyed
diff --git a/package.json b/package.json
index d26c73e..cd9bf12 100644
--- a/package.json
+++ b/package.json
@@ -19,6 +19,10 @@
         "jsprim": "^1.3.0",
         "forkexec": "^1.1.0"
     },
+    "devDependencies": {
+        "tape": "4.2.2",
+        "smf": "0.3.1"
+    },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
     },
diff --git a/tests/config.json b/tests/config.json
new file mode 100644
index 0000000..ae11c8b
--- /dev/null
+++ b/tests/config.json
@@ -0,0 +1,8 @@
+{
+    "vmapi": {
+        "url": "http://vmapi.coal-1.joyent.us"
+    },
+    "napi": {
+        "url": "http://napi.coal-1.joyent.us"
+    }
+}
diff --git a/tests/runtest b/tests/runtest
new file mode 100755
index 0000000..8b3b419
--- /dev/null
+++ b/tests/runtest
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Run a single net-agent test of any type.
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE_INSTALL=$TOP/node
+UNAME=$(uname -s)
+
+guard_file=/lib/sdc/.sdc-test-no-production-data
+if [[ $UNAME == "SunOS" ]] && [[ ! -f "$guard_file" ]]; then
+    cat <<EOF
+To run this test you must create the file:
+
+    $guard_file
+
+after ensuring you have no production data on this SDC.
+EOF
+    exit 2
+fi
+
+if [[ $1 != "" ]]; then
+	PATH=$NODE_INSTALL/bin:$PATH node $1
+else
+	echo "You must supply an argument to this script"
+fi
diff --git a/tests/unit/test.js b/tests/unit/test.js
new file mode 100644
index 0000000..b213221
--- /dev/null
+++ b/tests/unit/test.js
@@ -0,0 +1,471 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var path = require('path');
+var fs = require('fs');
+
+var DEFAULT_CFG = path.join(__dirname, '..', '/config.json');
+var config = {};
+try {
+    config = JSON.parse(fs.readFileSync(DEFAULT_CFG, 'utf8'));
+} catch (e) {
+    console.log('Error reading config');
+    console.log(e);
+    process.exit(1);
+}
+
+/*
+ * Constants
+ */
+
+var VMAPI_URL = config.vmapi.url || 'http://vmapi.coal-1.joyent.us';
+var NAPI_URL = config.napi.url || 'http://napi.coal-1.joyent.us';
+
+var EXTERNAL_NET = undefined;
+var VM_UUID = undefined;
+/* We use the old sdc-base image from 2014 */
+var IMG_UUID = 'de411e86-548d-11e4-a4b7-3bb60478632a';
+var OWNER_UUID = undefined;
+var SERVER_UUID = undefined;
+var VM_NICS = undefined;
+var NET_UUID = undefined;
+
+/*
+ * Imports and modules
+ */
+
+var test = require('tape');
+var sdcClients = require('sdc-clients');
+var bunyan = require('bunyan');
+var VMAPI = new sdcClients.VMAPI({ url: VMAPI_URL });
+var NAPI = new sdcClients.NAPI({ url: NAPI_URL });
+var vmadm = require('vmadm');
+var smf = require('smf');
+var restify = require('restify');
+var assert = require('assert-plus');
+
+/*
+ * Commonly used functions
+ */
+
+function delay_check(t, seconds, check) {
+    function dcheck() {
+        check(function (gone) {
+            if (gone) {
+                console.log('VM gone');
+                t.end();
+            } else {
+                console.log('VM not gone, waiting');
+                setTimeout(dcheck, seconds * 1000);
+            }
+        });
+    }
+    dcheck();
+}
+
+function check_vm_gone(cb) {
+    searchOpts = { uuid: VM_UUID, state: 'active' };
+    VMAPI.listVms(searchOpts, function (err, vms) {
+        /* If we can't connect to VMAPI we keep retrying until we can. */
+        if (err) {
+            cb(false);
+            return;
+        }
+        if (vms.length) {
+            cb(false);
+        } else {
+            cb(true);
+        }
+    });
+}
+
+
+/*
+ * Functions for manipulating the net-agent service.
+ */
+
+function disable_net_agent(t) {
+    smf.svcadm('disable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not disable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Disabled net-agent');
+        t.end();
+    });
+}
+
+function enable_net_agent(t) {
+    smf.svcadm('enable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not enable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Enabled net-agent');
+        t.end();
+    });
+}
+
+function early_exit(err) {
+    console.log('A test has failed, so there is no point in continuing.');
+    console.log('Subsequent tests were not executed.');
+    console.log('Identify the cause of the test failure and fix it.');
+    console.log('Then retry running this test suite.');
+    if (err) {
+        console.log(err);
+        console.log(err.stack);
+    }
+    process.exit(1);
+}
+
+/*
+ * Functions for checking if nic is present or absent on the system.
+ */
+
+function nic_gone(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error Getting NIC List');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        if (nics.length > 0) {
+            t.ok(false, 'NIC is still here!');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.ok(true, 'NIC is gone.');
+        t.end();
+    });
+}
+
+function nic_exists(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_NICS = nics;
+        if (VM_NICS.length > 0) {
+            NET_UUID = VM_NICS[0].network_uuid;
+            t.end();
+        } else {
+            t.ok(false, 'No Nics Found For VM');
+            t.end();
+            early_exit();
+        }
+    });
+}
+
+
+function add_incpl_nic(t) {
+    var nic = {
+        belongs_to_uuid: VM_UUID,
+        belongs_to_type: 'zone',
+        owner_uuid: OWNER_UUID,
+        network_uuid: NET_UUID
+    };
+    NAPI.provisionNic(NET_UUID, nic, function (err, res) {
+        if (err) {
+            t.ok(false, 'Error provisioning incomplete NIC!');
+            early_exit(err);
+            return;
+        }
+        VMAPI.addNics({uuid: VM_UUID, owner_uuid: OWNER_UUID, macs: [res.mac]},
+            function (err2, res2) {
+                if (err2) {
+                    t.ok(false, 'Error adding incomplete NIC!');
+                    early_exit(err2);
+                    return;
+                }
+                console.log('Added Nic to VM');
+                t.end();
+            });
+        return;
+    });
+}
+
+function check_nic_members(t) {
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_NICS = nics;
+
+        if (VM_NICS.length > 0) {
+            VM_NICS.forEach(function (nic) {
+                t.ok(nic.cn_uuid, 'NIC cn_uuid is defined');
+                t.strictEquals(nic.state, 'running');
+            });
+            t.end();
+            return;
+        }
+        t.ok(false, 'No Nics Found For VM');
+        t.end();
+        early_exit();
+    });
+}
+
+/*
+ * Functions for creating/destroying VMs
+ */
+
+function create_vm(t) {
+    VMAPI.createVmAndWait({
+        owner_uuid: OWNER_UUID,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: EXTERNAL_NET.uuid,
+                ipv4_count: 1,
+                primary: true
+            }
+        ],
+        brand: 'joyent-minimal',
+        ram: 256,
+        cpu_cap: 300,
+        alias: 'net-agent-test-vm-1',
+        image_uuid: IMG_UUID
+    }, function createVmCb(err, job) {
+        if (err) {
+            t.error(err, 'Error on creating VM');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        VM_UUID = job.vm_uuid;
+        console.log('Created VM ' + VM_UUID);
+        t.end();
+    });
+};
+
+function destroy_vm(t) {
+    console.log('Destroying VM ' + VM_UUID);
+    vmadm.delete({
+        uuid: VM_UUID,
+        log: bunyan.createLogger({
+            name: 'vmadm.delete',
+            level: 'DEBUG',
+            stream: process.stdout,
+            serializers: bunyan.stdSerializers
+        })
+    }, function (err) {
+        if (err) {
+            t.error(err, 'Error Deleting With `vmadm`');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        t.end();
+    });
+}
+
+function wait_until_agent_ready(t) {
+    var client = restify.createJsonClient({
+        url: 'http://localhost:5311'
+    });
+
+    function try_get_status() {
+        client.get({ path: '/status' }, function (err, req, res, obj) {
+            if (err) {
+                console.log('Error getting status, retrying...');
+                console.log(err);
+                try_get_status();
+                return;
+            }
+            console.log('status object:');
+            console.log(obj);
+            var state = obj.init_history.pop().h_name;
+            if (state === 'StartedReapNics') {
+                console.log('net-agent has started up completely');
+                t.end();
+            } else if (state === 'SkippedReapNics') {
+                console.log('WARNING: net-agent cannot reap NICs');
+                console.log('WARNING: try updating NAPI to complete the' +
+                    ' nic-reap test');
+                early_exit();
+                t.end();
+            } else {
+                console.log('Retrying in 5 seconds');
+                setTimeout(function () {
+                    try_get_status();
+                }, 5 * 1000);
+            }
+        });
+    }
+    try_get_status();
+}
+
+/*
+ * This function asserts that the agent is online. If the agent is not online,
+ * it will wait for it to either move into the online state, or into a
+ * maintenance or degraded state. If the latter occurs, this function causes
+ * the test to abort (in the hope that the dev will fix the service before
+ * running this test again).
+ */
+function assert_svc_state(t) {
+    function wait_for_state() {
+        var fmri = 'svc:/smartdc/agent/net-agent:default';
+        smf.svcs(fmri, function (err, svc) {
+            if (svc.state === 'disabled') {
+                /* enable svc */
+                enable_net_agent(t);
+            } else if (svc.state === 'maintenance' || svc.state === 'degraded') {
+                /* bail out */
+                console.log('net-agent is in ' + svc.state + ' state; bailing.');
+                early_exit();
+                t.end();
+            } else if (svc.state === 'offline' || svc.state === 'unitialized') {
+                /* wait for state chage */
+                setTimeout(function () {
+                    wait_for_state();
+                }, 5 * 1000);
+            } else {
+                t.end();
+            }
+        });
+    }
+    wait_for_state();
+}
+
+/*
+ * The actual tests.
+ */
+
+test('Is Net Agent Running?', function (t) {
+    assert_svc_state(t);
+});
+
+test('Get Network Info', function (t) {
+    NAPI.listNetworks(function (err, nets) {
+        if (err) {
+            t.error(err, 'Could not get network info.');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        nets.forEach(function (n) {
+            assert.string(n.name);
+            if (n.name === 'external') {
+                EXTERNAL_NET = n;
+            }
+        });
+        t.end();
+    });
+});
+
+/*
+ * We use the same OWNER_UUID that is attributed to the napi0 zone.
+ */
+test('Get Owner And Server UUIDs', function (t) {
+    VMAPI.listVms({alias: 'napi0', state: 'active'}, function (err, vms) {
+        if (err) {
+            t.error(err, 'Error getting owner UUID');
+            t.end();
+            early_exit(err);
+            return;
+        }
+        if (vms.length === 1) {
+            OWNER_UUID = vms[0].owner_uuid;
+            SERVER_UUID = vms[0].server_uuid;
+        } else {
+            t.error('vms[] array not expected size. Expected size is 1.');
+            t.error('Actual size is ' + vms.length);
+            early_exit();
+        }
+        t.end();
+    });
+});
+
+
+/*
+ * This group of tests verifies that net-agent reacts to VM-events properly.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Give Agent Some Time', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests verifies that net-agent reaps orphaned NICs if it wasn't
+ * able to react to the VM-events.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Enable Net-Agent Service', enable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Give Agent Some Time', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests, will create a VM, disable net-agent, create and add a
+ * NIC to the VM that has no cn_uuid and a provisioning state, so that the
+ * cn_uuid is undefined and the state is set to 'provisioning'. We then
+ * re-enable net-agent, wait for the reap to begin, and verify that after the
+ * reap the NIC still exists and has a new cn_uuid and its state is running.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Add Incomplete NIC to NAPI', add_incpl_nic);
+test('Enable Net-Agent Service', enable_net_agent);
+test('Check net-agent Not in Maintenance', assert_svc_state);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Give Agent Time To Complete Reap', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify NIC `cn_uuid` and `state`', check_nic_members);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Give Agent Time To Complete Reap', function (t) {
+    setTimeout(function () {
+        t.end();
+    }, 20 * 1000);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/* Node will keep running unless we delete the VMAPI and NAPI objects */
+test('Finish', function (t) {
+    delete VMAPI;
+    delete NAPI;
+    t.end();
+});
