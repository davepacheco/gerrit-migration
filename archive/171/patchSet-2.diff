From f7a8163b3acf67bb8c163c894ace821abf839f3d Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 29 Jul 2016 21:30:46 +0000
Subject: [PATCH] NAPI-327 net-agent should not leak NICs

---
 bin/net-agent.js        |   5 -
 lib/common.js           |  32 ++++
 lib/endpoints/index.js  |  24 +++
 lib/endpoints/status.js |  42 +++++
 lib/index.js            |   2 +-
 lib/napi-client.js      |  22 ++-
 lib/net-agent.js        | 344 ++++++++++++++++++++++++++++++++++++----
 lib/vm.js               | 128 +++++++--------
 package.json            |  11 +-
 tests/runtest           |  32 ++++
 tests/unit/test.js      | 320 +++++++++++++++++++++++++++++++++++++
 tools/rsync-to          |   4 +-
 12 files changed, 854 insertions(+), 112 deletions(-)
 create mode 100644 lib/common.js
 create mode 100644 lib/endpoints/index.js
 create mode 100644 lib/endpoints/status.js
 create mode 100755 tests/runtest
 create mode 100644 tests/unit/test.js

diff --git a/bin/net-agent.js b/bin/net-agent.js
index 5b009d2..96ce866 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -33,11 +33,6 @@ var sdcConfig;
 var agentConfig;
 var sysinfo;
 
-process.on('uncaughtException', function (e) {
-    console.error('uncaught exception:' + e.message);
-    console.log(e.stack);
-});
-
 function loadConfig(callback) {
     var configPath = '/opt/smartdc/agents/etc/net-agent.config.json';
 
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..5cec9b6
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,32 @@
+var assert = require('assert-plus');
+
+function assertStrictOptions(funcname, opts, expected)
+{
+    assert.string(funcname, 'funcname');
+    assert.object(opts, funcname + ': opts');
+    assert.object(expected, funcname + ': expected');
+
+    var unexpected = [];
+    for (var k in opts) {
+        if (!opts.hasOwnProperty(k)) {
+            continue;
+        }
+        var e = expected[k];
+        if (!e) {
+            unexpected.push(k);
+            continue;
+        }
+        var afunc = assert[e];
+        assert.func(afunc, 'invalid assertion type: ' + e);
+        afunc(opts[k], 'opts.' + k);
+    }
+
+    if (unexpected.length > 0) {
+        throw (new Error(funcname + ': unexpected options: ' +
+            unexpected.join(', ')));
+    }
+}
+
+module.exports = {
+    assertStrictOptions: assertStrictOptions
+};
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
new file mode 100644
index 0000000..b961eb9
--- /dev/null
+++ b/lib/endpoints/index.js
@@ -0,0 +1,24 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var toRegister = {
+    '/status': require('./status')
+};
+
+function registerEndpoints(http, log, before) {
+    for (var t in toRegister) {
+        log.debug('Registering endpoints for "%s"', t);
+        toRegister[t].register(http, before);
+    }
+}
+
+module.exports = {
+    registerEndpoints: registerEndpoints
+};
diff --git a/lib/endpoints/status.js b/lib/endpoints/status.js
new file mode 100644
index 0000000..5ec0058
--- /dev/null
+++ b/lib/endpoints/status.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * Status endpoint
+ */
+
+
+
+ /**
+  * GET /status
+  */
+
+function
+getStatus(req, res, next)
+{
+    var stat = {
+        init: req.app.init
+    };
+    res.send(200, stat);
+    next();
+}
+
+function
+register(http, before)
+{
+    http.get({
+        path: '/status',
+        name: 'getStatus'
+    }, before, getStatus);
+}
+
+module.exports = {
+    register: register
+};
diff --git a/lib/index.js b/lib/index.js
index e67010b..ce6219f 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
diff --git a/lib/napi-client.js b/lib/napi-client.js
index a17ea24..df4dc2c 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,8 @@
 
 var async = require('async');
 var NAPI = require('sdc-clients').NAPI;
+var assert = require('assert-plus');
+var common = require('./common');
 
 var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
     'allow_mac_spoofing', 'allow_restricted_traffic',
@@ -44,7 +46,7 @@ function NapiClient(options) {
  *
  * 1. NIC was removed from the VM or VM provision has failed (destroy)
  * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be udpated (update)
+ * 3. NIC exists and has to be updated (update)
  * 4. NIC exists and but has not changed, no need to do anything (noop)
  */
 NapiClient.prototype.updateNics = function (vm, nics, callback) {
@@ -92,10 +94,18 @@ NapiClient.prototype.updateNics = function (vm, nics, callback) {
 
 
 NapiClient.prototype.getNic = function (mac, callback) {
+    assert.object(this.client, 'this.client');
     return this.client.getNic(mac, callback);
 };
 
 
+NapiClient.prototype.listNics = function (napiClient, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.func(callback, 'callback');
+    napiClient.client.listNics(callback);
+};
+
+
 NapiClient.prototype.createNic = function (vm, newNic, callback) {
     var log = this.log;
     var nic = _createNicPayload(vm, newNic);
@@ -162,6 +172,14 @@ NapiClient.prototype.deleteNic = function (vm, nic, callback) {
 };
 
 
+NapiClient.prototype.getNics = function (belongsTo, options, callback) {
+    common.assertStrictOptions('getNics', options, {
+        headers: 'string'
+    });
+    this.client.getNics(belongsTo, options, callback);
+};
+
+
 
 /*
  * Some helper functions for NapiClient
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 64604a2..d39d7c9 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,18 +5,97 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
- * net-agent.js
+ * Net-Agent and NAPI
+ * ==================
+ *
+ * VM Change Events
+ * ----------------
+ *
+ * Net-agent's job is to inform NAPI of any changes to any NICs that result
+ * from VM-related events. For instance, if a VM gets destroyed (either by
+ * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
+ * for telling NAPI that the NIC that used to belong to that VM should be
+ * destroyed.
+ *
+ * Net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone configurations XML file has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever a change is detected, net-agent walks its internal list of VM
+ * objects (which also contains the NIC info) and pushes the NIC objects to
+ * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
+ * address.
+ *
+ * Orphaned NICs
+ * -------------
+ *
+ * One cannot assume that net-agent is continuously reacting to every single
+ * event on a compute node (CN). For example net-agent may be disabled by an
+ * operator, may go down due to an error, or may not receive an event (it
+ * happens). To handle these situations, when net-agent starts up it scans
+ * every NIC on the CN[1], and tells NAPI to delete any NIC if it does not have
+ * a corresponding VM (that is not destroyed). This is only done once on
+ * startup because such a scan can be very expensive.
+ *
+ * [1]: Currently we scan every NIC in the DC, since NAPI doesn't allow us to
+ * filter NICs by compute node. But as soon as it does, we will switch to that
+ * (see NAPI-360).  This means that we have to ignore NICs that have a
+ * `cn_uuid` different from the agent's.
+ *
+ * Net-Agent and Compute Nodes
+ * ===========================
+ *
+ * The previous section described the interaction between a single net-agent
+ * service and a single NAPI service. However, we always have more than one
+ * net-agent. In fact we have one net-agent per CN. All of these net-agents
+ * react only to VM events on their respective CNs. However, they are modifying
+ * global NIC objects, and they all connect to a single NAPI service (this may
+ * change in the future). It is important to keep this mind. We don't want all
+ * of our net-agents to start battering NAPI with requests at the same time.
+ * For the change-event-related requests this is not a problem. However, for
+ * the orphaned-nic-related requests, this could be catastrophic. This is why
+ * we insert a random delay before the listNics request that is no greater than
+ * 10 minutes.
+ *
+ * Net-Agent and VMs
+ * =================
+ *
+ * Net-Agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory. This set of
+ * VM objects is known as the sample.
+ *
+ * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * and processing the JSON that it produces on stdout. `zoneevent` emits output
+ * whenever a property of the zone has changed. Note that it does not report
+ * higher-level VM properties (that are used by vmadm and vmapi).
+ *
+ * As Net-Agent receives these change events, it updates the changed properties
+ * of the VM objects in the sample. However, it is possible that one of the
+ * change-events does not make it to net-agent. In order to mitigate the drift
+ * between net-agent's picture of reality, and reality itself, net-agent also
+ * does a full `vmadm lookup` every minute, and emits state-change events if it
+ * detects a difference.
  */
 
 var async = require('async');
+var util = require('util');
 var backoff = require('backoff');
+var restify = require('restify');
+var assert = require('assert-plus');
+var endpoints = require('./endpoints');
 
 var VM = require('./vm');
+var vmadm = require('vmadm');
 var NAPI = require('./napi-client');
+var common = require('./common');
+
 
 var _versionCache = null;
 function getNetAgentVersion() {
@@ -33,6 +112,7 @@ function NetAgent(options) {
     this.lastFullSample = null;
     this.uuid = options.uuid;
     this.version = getNetAgentVersion();
+    this.init = {};
 
     var userAgent = 'net-agent/' + this.version +
         ' (' + 'node/' + process.versions.node + ')' +
@@ -55,12 +135,48 @@ function NetAgent(options) {
     this.queues = {};
 }
 
+/*
+ * This function initializes the restify HTTP server.
+ * Currently, it temporarily listens on port 5311, until we nail down a proper
+ * port-allocation policy for SDC's agents.
+ */
+NetAgent.prototype.initializeServer = function (callback) {
+    var self = this;
+    var server = restify.createServer({
+        log: self.log,
+        name: 'Net Agent',
+        version: '0.0.1'
+    });
+    function populateReq(req, res, next) {
+        req.app = self;
+        return next();
+    }
+    endpoints.registerEndpoints(server, self.log.child({component: 'restify'}),
+        [ populateReq ]);
+
+    server.listen(5311, function (err) {
+        if (err) {
+            self.log.error('Failed to initialize server.');
+            process.exit(1);
+        }
+        var addr = server.address();
+        self.log.info('%s listening on <http://%s:%s>',
+            server.name, addr.address, addr.port);
+        callback();
+    });
+};
+
 
 NetAgent.prototype.start = function () {
-    var self = this;
     var log = this.log;
 
+    this.init.phase = 'InitializingServer';
+    this.initializeServer(function serverInitialized() {
+        return;
+    });
+    this.init.phase = 'InitializingEventWatcher';
     this.initializeEventWatcher();
+    this.init.phase = 'InitializedEventWatcher';
 
     // Wrap our initial full sample in a retry-backoff
     var opts = { uuid: this.uuid };
@@ -74,12 +190,78 @@ NetAgent.prototype.start = function () {
         }
 
         log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
     }
 };
 
+/*
+ * Called on startup. Function asks NAPI for all allocated NICs.  It uses this
+ * list to detect leaked NICs by querying for NICs that are allocated,
+ * unreserved, belong to type 'zone', and not assigned to any existing VM. It
+ * emits a leaked_nic event, which net-agent responds to by destroying the NIC.
+ */
+NetAgent.prototype.reapNics = function () {
+
+    var self = this;
+
+    assert.object(this.napiClient, 'this.napiClient');
+    var napiClient = this.napiClient;
+    var cn_uuid = this.uuid;
+    /*
+     * We get list of NICs from NAPI. Currently we get all NICs, but we should
+     * filter by cn_uuid, when NAPI gets support for that (see NAPI-360).
+     */
+    function list_nics_cb(err, nics)
+    {
+        var leaked_nics = nics.filter(function scan_nics(nic) {
+            if (nic.belongs_to_type != 'zone') {
+                return (false);
+            }
+            /* Not our responsibility */
+            if (nic.cn_uuid !== cn_uuid) {
+                return (false);
+            }
+            nic.leaked = true;
+            var vms = self.sample;
+            for (var uuid in vms) {
+                var vm = vms[uuid];
+                if (vm.uuid == nic.belongs_to_uuid) {
+                    return (false);
+                }
+            }
+            if (nic.leaked) {
+                return (true);
+            }
+            return (false);
+        });
+
+        self.init.phase = 'StartedReapNics';
+
+        leaked_nics.forEach(function reap_nic(nic) {
+            /*
+             * Currently, the implementation of deleteNic only looks at the
+             * UUID of the VM. If we are in this function, we know that the
+             * VM itself no longer exists, which is why we don't have a
+             * complete VM object. If deleteNic starts accessing other vm
+             * members in the future, we will have to add them to the
+             * `targ_vm` obj below.
+             */
+            var targ_vm = { uuid: nic.belongs_to_uuid };
+            napiClient.deleteNic(targ_vm, nic,
+                function handle_delete_nic(err2, res2) {
+
+                if (err2) {
+                    return;
+                }
+                return;
+            });
+        });
+    }
+    var retry = backoff.call(napiClient.listNics, napiClient,
+        list_nics_cb);
+    retry.setStrategy(new backoff.ExponentialStrategy());
+    retry.failAfter(42);
+    retry.start();
+};
 
 /*
  * Initializes the EventWatcher event listeners
@@ -89,7 +271,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
     var log = this.log;
     var eventWatcher = this.eventWatcher;
 
-    eventWatcher.on('state', function (uuid, state) {
+    eventWatcher.on('state', function vm_state_event(uuid, state) {
         log.debug('state event for %s state: %s', uuid, state);
         self.pushSample({
             uuid: uuid,
@@ -97,7 +279,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_state', function (uuid, zone_state) {
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
         log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
         self.pushSample({
             uuid: uuid,
@@ -105,7 +287,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_xml', function (uuid) {
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
         log.debug('fs.watch event on /etc/zones for %s', uuid);
         self.pushSample({
             uuid: uuid,
@@ -113,7 +295,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('destroyed', function (uuid) {
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
         var vm = self.sample[uuid];
         if (!vm) {
             log.warn('VM %s appears to have gone away but ' +
@@ -123,10 +305,13 @@ NetAgent.prototype.initializeEventWatcher = function () {
 
         log.info('Found a destroyed VM %s', uuid);
         vm.state = 'destroyed';
-        self.pushSample({ uuid: uuid, cachedVm: vm });
+        self.pushSample({
+            uuid: uuid,
+            cachedVm: vm
+        });
     });
 
-    eventWatcher.on('err', function (err) {
+    eventWatcher.on('err', function zone_err_event(err) {
         log.error(err, 'eventWatcher saw en error');
     });
 };
@@ -140,7 +325,6 @@ NetAgent.prototype.setSample = function (sample) {
     });
 };
 
-
 /*
  * On startup, sendFullSample updates all NICs for all VMs on the server. This
  * will be a blocking call before we turn on the event listeners so we allow
@@ -150,19 +334,62 @@ NetAgent.prototype.sendFullSample = function (opts, callback) {
     var self = this;
     var log = this.log;
 
+    function startEventWatchers() {
+            self.init.phase = 'StartingEventWatcher';
+            self.eventWatcher.updateState(self.sample);
+            self.eventWatcher.lastCfgEvent = self.lastFullSample;
+            self.eventWatcher.start();
+            self.init.phase = 'StartedEventWatcher';
+    }
+
     this.updateSample({}, function (err, sample) {
         if (err) {
             log.error(err, 'updateSample failed, cannot sendFullSample');
             callback(err);
             return;
-
         } else if (Object.keys(sample).length === 0) {
             log.warn('empty sample returned by vmadm lookup');
+            startEventWatchers();
             callback();
             return;
         }
 
         self.setSample(sample);
+        startEventWatchers();
+        var min_timeout = 2 * 60 * 1000;
+        var max_timeout = 10 * 60 * 1000;
+        var rand_timeout = Math.floor(Math.random() * (max_timeout -
+            min_timeout + 1)) + min_timeout;
+
+        if (self.init.phase !== 'StartedReapNics') {
+            self.init = {
+                phase: 'StartingReapNics',
+                delay: rand_timeout,
+                elapsed: 0
+            };
+        }
+
+        setTimeout(function () {
+            self.reapNics();
+        }, rand_timeout);
+
+        /*
+         * We update the `elapsed` member, of the `init` global. This value,
+         * along with the value of `rand_timeout` is provided to the consumer
+         * through the /status endpoint. It allows the consumer to calculate
+         * how much time remains until a nic-reap begins. Currently used by
+         * tests.
+         */
+        function setElapsed() {
+            var updateInterval = 5 * 1000;
+            setTimeout(function () {
+                self.init.elapsed += updateInterval;
+                if (self.init.elapsed < self.init.delay) {
+                    setElapsed();
+                }
+            }, updateInterval);
+        }
+        setElapsed();
 
         async.forEachSeries(Object.keys(sample), function (uuid, cb) {
             var options = {
@@ -199,16 +426,14 @@ NetAgent.prototype.sendSample = function (options, callback) {
         this.eventWatcher.removeState(options.uuid);
 
         self._updateVmNics(options, callback);
-
     } else {
         this.updateSample(options, function (err, sample) {
             if (err) {
                 log.error(err, 'updateSample failed, cannot sendSample');
                 callback(err);
-
             } else if (Object.keys(sample).length === 0) {
                 log.warn('empty sample returned by vmadm lookup');
-                 callback();
+                callback();
             } else {
                 self.eventWatcher.updateState(sample);
                 self.setSample(sample);
@@ -225,6 +450,7 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * - options.cachedVm: what net-agent currently knows about the VM
  * - options.vm: what net-agent has loaded from vmadm
+ * - options.cn_uuid: the cn_uuid of the vm's NICs
  *
  * When options.vm is undefined, it means that the VM has been destroyed because
  * options.vm gets populated from the vmadm lookup results. We always store the
@@ -232,11 +458,26 @@ NetAgent.prototype.sendSample = function (options, callback) {
  *
  * When options.cachedVm is undefined, then this is the first time we see that
  * VM (or our net-agent has just started)
+ *
+ * When options.cn_uuid is different from this.uuid, we don't do anything.
  */
-NetAgent.prototype._updateVmNics = function (options, callback) {
+NetAgent.prototype._updateVmNicsImpl = function (options, callback)
+{
+    common.assertStrictOptions('_updateVmNicsImpl', options, {
+        uuid: 'string',
+        cn_uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject'
+    });
     var log = this.log;
     var allNics = [];
 
+    assert.uuid(this.uuid, 'this.uuid');
+    if (options.cn_uuid !== this.uuid) {
+        callback();
+        return;
+    }
+
     if (options.vm) {
         options.vm.nics.forEach(function (nic) {
             // When VM is failed just mark all NICs are destroyed
@@ -281,6 +522,53 @@ NetAgent.prototype._updateVmNics = function (options, callback) {
     this.napiClient.updateNics(vm, allNics, callback);
 };
 
+NetAgent.prototype._updateVmNics = function (options, callback)
+{
+    common.assertStrictOptions('_updateVmNics', options, {
+        uuid: 'string',
+        cn_uuid: 'string',
+        vm: 'optionalObject',
+        cachedVm: 'optionalObject'
+    });
+    /*
+     * We want to grab the this VM's NICs from NAPI, so that we can have a copy
+     * of their cn_uuid (which is not stored in the vm-object's `nic` member).
+     * We need the cn_uuid to determine if we are allowed to act on the NICs or
+     * not.
+     */
+    var self = this;
+    self.napiClient.getNics(options.uuid, {}, function (err, nics) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (nics.length > 0) {
+            var prev_nic = undefined;
+            /*
+             * We verify that all NICs have the same cn_uuid. If not, we log an
+             * error and bail before we change any system state.
+             */
+            for (var nic in nics) {
+                if (prev_nic !== undefined) {
+                    if (nic.cn_uuid !== prev_nic.cn_uuid) {
+                        var err_fmt = 'NICs of VM %s should all' +
+                            ' have the same `cn_uuid`!';
+                        var errstr = util.format(err_fmt, options.uuid);
+                        self.log.error(errstr);
+                        callback(new Error(errstr));
+                        return;
+                    }
+                }
+                prev_nic = nic;
+            }
+            options.cn_uuid = nics[0].cn_uuid;
+        } else {
+            options.cn_uuid = self.uuid;
+        }
+        self._updateVmNicsImpl(options, callback);
+    });
+};
+
 
 /*
  * Initializes the serial queue for a single uuid and pushes the item to be
@@ -292,7 +580,6 @@ NetAgent.prototype.pushSample = function (options) {
     if (this.queues[uuid] === undefined) {
         this.queues[uuid] = this.createQueue(uuid);
     }
-
     this.queues[uuid].push(options);
 };
 
@@ -326,17 +613,16 @@ NetAgent.prototype.retryUpdate = function (fn, options, callback) {
         return (_log);
     }
 
-    var retry = backoff.call(fn, function (err) {
+    var retry = backoff.call(fn, function backoffCallCb(err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
 
         if (err) {
             log.error({ uuid: options.uuid },
                 'Could not retry operation after %d attempts', attempts);
             return callback(err);
         }
-
         return callback();
     });
 
@@ -359,9 +645,9 @@ NetAgent.prototype.createQueue = function (uuid) {
     var self = this;
     var log = this.log;
 
-    var queue = async.queue(function (opts, callback) {
+    var queue = async.queue(function qcb(opts, callback) {
         var fn = self.sendSample.bind(self, opts);
-        self.retryUpdate(fn, opts, function (err) {
+        self.retryUpdate(fn, opts, function retryUpdateCb(err) {
             if (err) {
                 log.error(err, 'Error updating NICs %', uuid);
                 return callback(err);
@@ -414,8 +700,9 @@ NetAgent.prototype.createQueue = function (uuid) {
  */
 
 NetAgent.prototype.updateSample = function (options, callback) {
-    if (!this._sampleQueue)
+    if (!this._sampleQueue) {
         this._sampleQueue = async.queue(updateSample.bind(this), 8);
+    }
     this._sampleQueue.push(options, callback);
 };
 
@@ -441,7 +728,7 @@ function updateSample(options, callback) {
 
         log.debug('Starting updateSample ' + query);
 
-        VM.list(searchOpts, function (err, vmobjs) {
+        vmadm.lookup(searchOpts, {log: log}, function (err, vmobjs) {
             var vmobj;
             var running = 0;
             var notRunning = 0;
@@ -450,7 +737,6 @@ function updateSample(options, callback) {
             if (err) {
                 log.error(err, 'ERROR: unable update VM list');
                 return cb(err);
-
             } else {
                 for (vmobj in vmobjs) {
                     vmobj = vmobjs[vmobj];
@@ -471,7 +757,7 @@ function updateSample(options, callback) {
                     notRunning: notRunning,
                     nonInventory: nonInventory
                 };
-                log.trace(lookupResults, 'Lookup query results');
+                log.info(lookupResults, 'Lookup query results');
 
                 return cb(null);
             }
@@ -501,7 +787,7 @@ function updateSample(options, callback) {
     var retry = backoff.call(lookup, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
         if (err) {
             log.error('Could not updateSample after %d attempts', attempts);
             return callback(err);
diff --git a/lib/vm.js b/lib/vm.js
index 5715c40..f97ce20 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -21,10 +21,11 @@ var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var EventEmitter = require('events').EventEmitter;
+var vmadm = require('vmadm');
+var LineStream = require('lstream');
 
 var async = require('async');
 
-var VMADM = '/usr/sbin/vmadm';
 
 
 
@@ -38,44 +39,6 @@ function isLocal(vms, vm) {
     return null;
 }
 
-
-function listVMs(filter, fields, callback) {
-    if (!callback) {
-        callback = fields;
-        fields = undefined;
-    }
-
-    var args = ['lookup', '-j'];
-    for (var k in filter) {
-        args.push(k + '=' + filter[k]);
-    }
-    if (fields) {
-        args.push('-o', fields.join(','));
-    }
-
-    return execFile(VMADM, args, {maxBuffer: 32 * 1024 * 1024},
-        function (err, stdout, stderr) {
-
-        if (err) {
-            err.stdout = stdout;
-            err.stderr = stderr;
-            return callback(err);
-        }
-
-        var vms;
-
-        try {
-            vms = JSON.parse(stdout);
-        } catch (jsonErr) {
-            jsonErr.stdout = stdout;
-            return callback(jsonErr);
-        }
-
-        return callback(null, vms);
-    });
-}
-
-
 // These are the events being watched by the zoneevent watcher. When zones
 // don't switch to these zone_states we ignore them
 var watchEvents = {
@@ -83,7 +46,7 @@ var watchEvents = {
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 30000;
+var STATE_WATCHER_TIMEOUT = 60 * 1000;
 
 /*
  * The EventWatcher will emit these events:
@@ -128,7 +91,7 @@ EventWatcher.prototype.start = function () {
 EventWatcher.prototype.updateState = function (objs) {
     var self = this;
 
-    Object.keys(objs).forEach(function (uuid) {
+    Object.keys(objs).forEach(function foreachobjs(uuid) {
         self.vmStates[uuid] = {
             state: objs[uuid].state,
             zone_state: objs[uuid].zone_state
@@ -166,10 +129,6 @@ EventWatcher.prototype.startStateWatcher = function () {
         }
 
         vmobjs.forEach(function (vm) {
-            // Only use inventory vms
-            if (vm.do_not_inventory) {
-                return;
-            }
 
             // Don't emit when states stay the same
             var current = self.getState(vm.uuid);
@@ -191,14 +150,33 @@ EventWatcher.prototype.startStateWatcher = function () {
         setTimeout(lookup, STATE_WATCHER_TIMEOUT);
     }
 
-    var lookup = listVMs.bind(null,
-        {}, ['uuid', 'state', 'zone_state', 'do_not_inventory'], onLookup);
+    /*
+     * We get a list of all VMs that don't have the do_not_inventory flag set.
+     * This flag is used by tests and ops to get some things done. For example
+     * it is used by the migrator script to signal to SDC that events for the
+     * target VM should be ignored.
+     */
+    var lookup = vmadm.lookup.bind(null, {}, {
+        fields: [
+            'uuid',
+            'state',
+            'zone_state'],
+         log: log,
+         include_dni: false
+    }, onLookup);
 
     lookup();
 };
 
-
 EventWatcher.prototype.startZoneWatcher = function () {
+    /*
+     * sendFullSample is called in an infinite retry loop. We don't want to
+     * create a swarm of zoneevent processes. Therefore we simply return from
+     * this function, if we already have one such process running.
+     */
+    if (this.zoneeventWatcher !== null) {
+        return;
+    }
     var log = this.log;
     var self = this;
 
@@ -209,32 +187,44 @@ EventWatcher.prototype.startZoneWatcher = function () {
 
     log.info('zoneevent running with pid ' + watcher.pid);
 
-    function onData(data) {
-        log.trace('zone event: ', data.toString());
-
-        // There can be more than one event in a single data event
-        var events = data.toString().split('\n');
-        events.forEach(processEvent);
-    }
-
-    function processEvent(event) {
-        if (event === '') {
-            return;
-        }
-
-        event = JSON.parse(event);
-
-        // Only updateSample when it is an event we're watching
+    function onLine(line)
+    {
+        log.info('zone event: ', line.toString());
+        var event = JSON.parse(line);
         if (watchEvents[event.newstate]) {
             self.emit('zone_state', event.zonename, event.newstate);
         }
     }
 
-    watcher.stdout.on('data', onData);
+    function onErrLine(line)
+    {
+        log.error('zone event: ', line.toString());
+    }
+
+    var stdoutStream = new LineStream();
+    var stderrStream = new LineStream();
+    watcher.stdout.pipe(stdoutStream);
+    watcher.stderr.pipe(stderrStream);
+    stdoutStream.on('line', onLine);
+    stderrStream.on('line', onErrLine);
+    // watcher.stdout.on('data', onData);
     watcher.stdin.end();
+    var stdout_ended = false;
+    var watcher_exited = false;
+    watcher.stdout.on('end', function () {
+        stdout_ended = true;
+        if (watcher_exited) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+        }
+    });
     watcher.on('exit', function (code) {
-        log.warn('zoneevent watcher exited.');
-        watcher = null;
+        if (stdout_ended) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+        } else {
+            watcher_exited = true;
+        }
     });
 };
 
@@ -368,13 +358,11 @@ function checkDestroyed(uuid, callback) {
 
 function createEventWatcher(options) {
     assert.ok(options.log, 'EventWatcher options.log');
-
     return new EventWatcher(options);
 }
 
 
 module.exports = {
     isLocal: isLocal,
-    list: listVMs,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index 8a31a32..d24a592 100644
--- a/package.json
+++ b/package.json
@@ -6,15 +6,20 @@
     "private": true,
     "dependencies": {
         "async": "0.1.18",
-        "backoff": "2.3.0",
+	"assert-plus": "^1.0.0",
+        "backoff": "2.4.1",
         "bunyan": "1.3.2",
         "sdc-bunyan-serializers": "git+ssh://git@github.com:joyent/sdc-bunyan-serializers.git#aefc119",
         "nodeunit": "0.7.4",
         "restify": "2.7.0",
-        "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#c962959"
+        "sdc-clients": "9.2.0",
+        "vmadm": "git+ssh://git@github.com:joyent/node-vmadm.git#3cf878481d24c1bc1e74e85a95004a3dde6329f1",
+	"lstream": "0.0.4"
     },
     "sdcDependencies": {
-        "config-agent": ">=1.3.0"
+        "config-agent": ">=1.3.0",
+        "tape": "4.2.2",
+        "smf": "0.3.1"
     },
     "scripts": {
         "postinstall": "npm/postinstall.sh",
diff --git a/tests/runtest b/tests/runtest
new file mode 100755
index 0000000..b542e30
--- /dev/null
+++ b/tests/runtest
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2016, Joyent, Inc.
+#
+
+#
+# Run a single net-agent test of any type.
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE_INSTALL=$TOP/node
+NODEUNIT=$TOP/node_modules/.bin/nodeunit
+UNAME=$(uname -s)
+
+guard_file=/lib/sdc/.sdc-test-no-production-data
+if [[ $UNAME == "SunOS" ]] && [[ ! -f "$guard_file" ]]; then
+    cat <<EOF
+To run this test you must create the file:
+
+    $guard_file
+
+after ensuring you have no production data on this SDC.
+EOF
+    exit 2
+fi
+
+PATH=$NODE_INSTALL/bin:$PATH node $1
diff --git a/tests/unit/test.js b/tests/unit/test.js
new file mode 100644
index 0000000..0715e34
--- /dev/null
+++ b/tests/unit/test.js
@@ -0,0 +1,320 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+
+var test = require('tape');
+var sdcClients = require('sdc-clients');
+var VMAPI = new sdcClients.VMAPI({ url: 'http://vmapi.coal-1.joyent.us' });
+var NAPI = new sdcClients.NAPI({ url: 'http://napi.coal-1.joyent.us' });
+var vmadm = require('vmadm');
+var smf = require('smf');
+var bunyan = require('bunyan');
+var restify = require('restify');
+
+var EXTERNAL_NET = undefined;
+var VM_UUID = undefined;
+/* We use the old sdc-base image from 2014 */
+var IMG_UUID = 'de411e86-548d-11e4-a4b7-3bb60478632a';
+var OWNER_UUID = undefined;
+var SERVER_UUID = undefined;
+var VM_NICS = undefined;
+
+/*
+ * MAC address-related utilities
+ */
+
+
+function delay_check(t, seconds, check)
+{
+    function dcheck()
+    {
+        check(function (gone) {
+            if (gone) {
+                console.log('VM gone');
+                t.end();
+            } else {
+                console.log('VM not gone, waiting');
+                setTimeout(function () {
+                    dcheck();
+                }, seconds * 1000);
+            }
+        });
+    }
+    dcheck();
+}
+
+function check_vm_gone(cb)
+{
+    var gone = true;
+    searchOpts = { uuid: VM_UUID, state: 'active' };
+    VMAPI.listVms(searchOpts, function (err, vms) {
+        /* If we can't connect to VMAPI we keep retrying until we can. */
+        if (err) {
+            cb(!gone);
+            return;
+        }
+        if (vms.length) {
+            cb(!gone);
+        } else {
+            cb(gone);
+        }
+    });
+}
+
+
+/*
+ * Functions for manipulating the net-agent service.
+ */
+
+function disable_net_agent(t)
+{
+    smf.svcadm('disable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not disable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Disabled net-agent');
+        t.end();
+    });
+}
+
+function enable_net_agent(t)
+{
+    smf.svcadm('enable', 'net-agent', { wait: true }, function (err, code) {
+        if (err) {
+            t.error(err, 'Could not enable net-agent');
+            t.end();
+            return;
+        }
+        t.ok(true, 'Enabled net-agent');
+        t.end();
+    });
+}
+
+function early_exit()
+{
+    console.log('A test has failed, so there is no point in continuing.');
+    console.log('Subsequent tests were not executed.');
+    console.log('Identify the cause of the test failure and fix it.');
+    console.log('Then retry running this test suite.');
+    process.exit(1);
+}
+
+/*
+ * Functions for checking if nic is present or absent on the system.
+ */
+
+function nic_gone(t)
+{
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error Getting NIC List');
+            t.end();
+            early_exit();
+            return;
+        }
+        if (nics.length > 0) {
+            t.ok(false, 'NIC is still here!');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.ok(true, 'NIC is gone.');
+        t.end();
+    });
+}
+
+function nic_exists(t)
+{
+    NAPI.getNics(VM_UUID, {}, function (err, nics) {
+        if (err) {
+            t.error(err, 'Error on Getting VM Net Info');
+            t.end();
+            early_exit();
+            return;
+        }
+        VM_NICS = nics;
+
+        if (VM_NICS.length > 0) {
+            t.end();
+            return;
+        }
+        t.ok(false, 'No Nics Found For VM');
+        t.end();
+        early_exit();
+    });
+}
+
+/*
+ * Functions for creating/destroying VMs
+ */
+
+function create_vm(t)
+{
+
+    VMAPI.createVmAndWait({
+        owner_uuid: OWNER_UUID,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: EXTERNAL_NET.uuid,
+                ipv4_count: 1,
+                primary: true
+            }
+        ],
+        brand: 'joyent-minimal',
+        ram: 256,
+        cpu_cap: 300,
+        alias: 'net-agent-test-vm-1',
+        image_uuid: IMG_UUID
+    }, function createVmCb(err, job) {
+        if (err) {
+            t.error(err, 'Error on creating VM');
+            t.end();
+            early_exit();
+            return;
+        }
+        VM_UUID = job.vm_uuid;
+        t.end();
+    });
+};
+
+function destroy_vm(t)
+{
+    vmadm.delete({
+        uuid: VM_UUID,
+        log: bunyan.createLogger({
+            name: 'vmadm.delete',
+            level: 'INFO',
+            stream: process.stdout,
+            serializers: bunyan.stdSerializers
+        })
+    }, function (err) {
+        if (err) {
+            t.error(err, 'Error Deleting With `vmadm`');
+            t.end();
+            early_exit();
+            return;
+        }
+        t.end();
+    });
+}
+
+function wait_until_agent_ready(t)
+{
+    var client = restify.createJsonClient({
+        url: 'http://localhost:5311'
+    });
+
+    function try_get_status()
+    {
+        client.get({ path: '/status' }, function (err, req, res, obj) {
+            if (err) {
+                console.log('Error getting status, retrying...');
+                console.log(err);
+                try_get_status();
+                return;
+            }
+            console.log(obj.init);
+            if (obj.init.phase === 'StartingReapNics') {
+                var time_rem = obj.init.delay - obj.init.elapsed;
+
+                console.log('Retrying in '+ time_rem + ' us');
+                setTimeout(function () {
+                    try_get_status();
+                }, time_rem);
+            } else if (obj.init.phase === 'StartedReapNics') {
+                console.log('net-agent has started up completely');
+                t.end();
+            } else {
+                console.log('Retrying in 5 seconds');
+                setTimeout(function () {
+                    try_get_status();
+                }, 5 * 1000);
+            }
+            return;
+        });
+    }
+    try_get_status();
+}
+
+
+
+test('Get Network Info', function (t) {
+    NAPI.listNetworks(function (err, nets) {
+        if (err) {
+            t.error(err, 'Could not get network info.');
+            t.end();
+            early_exit();
+            return;
+        }
+        for (var n in nets) {
+            if (nets[n].name === 'external') {
+                EXTERNAL_NET = nets[n];
+            }
+        }
+        t.end();
+    });
+});
+
+/*
+ * We use the same OWNER_UUID that is attributed to the napi0 zone.
+ */
+test('Get Owner And Server UUIDs', function (t) {
+    VMAPI.listVms({alias: 'napi0'}, function (err, vms) {
+        if (err) {
+            t.error(err, 'Error getting owner UUID');
+            t.end();
+            early_exit();
+            return;
+        }
+        OWNER_UUID = vms[0].owner_uuid;
+        SERVER_UUID = vms[0].server_uuid;
+        t.end();
+    });
+});
+
+
+/*
+ * This group of tests verifies that net-agent reacts to VM-events properly.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * This group of tests verifies that net-agent reaps orphaned NICs if it wasn't
+ * able to react to the VM-events.
+ */
+test('Create VM w/ Vmapi', create_vm);
+test('Disable Net-Agent Service', disable_net_agent);
+test('Get VM Net Info', nic_exists);
+test('Destroy VM w/ Vmadm', destroy_vm);
+test('WAIT', function (t) {
+    delay_check(t, 10, check_vm_gone);
+});
+test('Enable Net-Agent Service', enable_net_agent);
+test('Wait Till Agent Ready', wait_until_agent_ready);
+test('Verify That NIC Is Gone', nic_gone);
+
+/*
+ * For reasons unknown, tape does not stop running, so we have to force the
+ * process to quit.
+ */
+test('Finish', function (t) {
+    delete VMAPI;
+    delete NAPI;
+    t.end();
+});
diff --git a/tools/rsync-to b/tools/rsync-to
index d975b95..989fa9e 100755
--- a/tools/rsync-to
+++ b/tools/rsync-to
@@ -28,7 +28,7 @@ if [[ $(uname -s) != "SunOS" ]]; then
 fi
 
 rsync -av ${TOP}/ \
-    $NODE:/var/tmp/net-agent/ \
+    $NODE:/opt/smartdc/agents/lib/node_modules/net-agent/ \
     $extraOpts \
     --exclude .git/ \
     --exclude /deps/ \
@@ -36,4 +36,4 @@ rsync -av ${TOP}/ \
     --exclude /tools/ \
     --exclude /tmp/
 
-ssh $NODE cp -R /opt/smartdc/agents/lib/node_modules/net-agent/node_modules/ /var/tmp/net-agent/
\ No newline at end of file
+ssh $NODE svcadm restart net-agent
-- 
2.21.0

