commit 5be4ffe4395a140ba0dec7b332e077eea529939a (refs/changes/75/5575/1)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2019-02-12T21:36:10-08:00 (8 months ago)
    
    TRITON-1221 cn-agent should ensure CNAPI is updated when sysinfo changes

diff --git a/lib/app.js b/lib/app.js
index 6c7b9c5..bcee351 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -78,6 +78,7 @@ function App(options) {
     this.sdc_config = options.sdc_config;
     this.statusQueued = false;
     this.sysinfo = options.sysinfo;
+    this.sysinfoCount = 0;
     // use the same user-agent format as vm-agent
     this.userAgent = 'cn-agent/' + packageJson.version +
         ' (node/' + process.versions.node + ')' +
@@ -193,6 +194,28 @@ function queueStatusUpdateIfNotAlreadyQueued() {
     });
 };
 
+App.prototype.queueSysinfoUpdateIfNotAlreadyQueued =
+function queueSysinfoUpdateIfNotAlreadyQueued(callback) {
+    assert.optionalFunc(callback, 'callback');
+
+    var self = this;
+
+    if (self.sysinfoQueued === true) {
+        self.log.debug('already have a sysinfo update pending');
+        return;
+    }
+
+    // Queue a sysinfo update
+    self.sysinfoQueued = true;
+    self.cnapiQueue.push('sysinfo', function _onSysinfoUpdated() {
+        self.sysinfoQueued = false;
+        self.sysinfoCount++;
+        if (callback !== undefined) {
+            callback();
+        }
+    });
+};
+
 /*
  * This is used to serialize updates to CNAPI to ensure that we don't overload a
  * busy CNAPI by sending more than 1 request at a time. This is handled via a
@@ -303,9 +326,9 @@ App.prototype.startHeartbeater = function () {
 };
 
 
-// Whenever we start up, we want to ensure we've updated the sysinfo in CNAPI
-// before we continue further. This ensures we've got the correct 'Boot Time'
-// for example. (See also: TRITON-69)
+// Whenever we start up, or when sysinfo changes we want to ensure we've updated
+// the sysinfo in CNAPI. This ensures we've got the correct 'Boot Time' for
+// example. (See also: TRITON-69)
 //
 // We also pass the cnAgentPort which CNAPI can use to communicate with this
 // cn-agent instance.
@@ -313,66 +336,77 @@ App.prototype.registerServer = function registerServer(callback) {
     var self = this;
 
     assert.object(self.cnapiClient, 'self.cnapiClient');
-    assert.object(self.sysinfo, 'self.sysinfo');
-
-    var sysinfo = self.sysinfo;
-    var urlPath = path.join('/servers', self.uuid, 'sysinfo');
-
-    // We'll add our port to the sysinfo here so that if we're not using the
-    // default port, CNAPI knows where to send requests to us.  Our IP can be
-    // found from sysinfo['Admin IP'].
-    sysinfo['CN Agent Port'] = self.agentserver.server.address().port;
-
-    // Make an attempt, if that fails, schedule a new attempt with a delay
-    self.cnapiClient.post({
-        path: urlPath
-    }, {
-        sysinfo: self.sysinfo
-    }, function _afterPost(err, req, res, obj) {
-        var delay;
 
-        if (err) {
-            if (err.statusCode === 404 && err.restCode === 'ResourceNotFound') {
-                // If we get a 404, that means we've got an old CNAPI that
-                // doesn't support registering sysinfo. So we'll not keep
-                // retrying in this case.
-                self.log.warn({
-                    err: err
-                }, 'CNAPI does not seem to support sysinfo registration. ' +
-                    'Skipping.');
+    self.backend.getSysinfo({serverUuid: self.uuid},
+        function onSysinfo(sysinfoErr, sysinfoObj) {
+            assert.ifError(sysinfoErr, 'sysinfo should always succeed');
 
-                callback();
-                return;
-            }
+            var urlPath = path.join('/servers', self.uuid, 'sysinfo');
 
-            delay = self.registerBackoff.duration();
+            // Set the sysinfo we just grabbbed.
+            self.sysinfo = sysinfoObj;
 
-            self.log.warn({
-                err: err,
-                retryInMs: delay
-            }, 'Error posting sysinfo to CNAPI, will retry.');
+            // We'll add our port to the sysinfo here so that if we're not using
+            // the default port, CNAPI knows where to send requests to us. Our
+            // IP can be found from sysinfo['Admin IP'].
+            self.sysinfo['CN Agent Port'] =
+                self.agentserver.server.address().port;
 
-            setTimeout(function _registerAgain() {
-                // The .call() is necessary here because we want the
-                // registerServer function to have the correct `self`, so that
-                // it has self.log, and the same self.registerBackoff that we
-                // do.
-                registerServer.call(self, callback);
-            }, delay);
+            // Make an attempt, if that fails, schedule a new attempt with a
+            // delay
+            self.cnapiClient.post({
+                path: urlPath
+            }, {
+                sysinfo: self.sysinfo
+            }, function _afterPost(err, req, res, obj) {
+                var delay;
 
-            // Note: we don't call callback() because we wait until we're
-            // successful.
+                if (err) {
+                    if (err.statusCode === 404 &&
+                        err.restCode === 'ResourceNotFound') {
+
+                        // If we get a 404, that means we've got an old CNAPI
+                        // that doesn't support registering sysinfo. So we'll
+                        // not keep // retrying in this case.
+                        self.log.warn({
+                            err: err
+                        }, 'CNAPI does not seem to support sysinfo ' +
+                            'registration. Skipping.');
+
+                        callback();
+                        return;
+                    }
+
+                    delay = self.registerBackoff.duration();
+
+                    self.log.warn({
+                        err: err,
+                        retryInMs: delay
+                    }, 'Error posting sysinfo to CNAPI, will retry.');
+
+                    setTimeout(function _registerAgain() {
+                        // The .call() is necessary here because we want the
+                        // registerServer function to have the correct `self`,
+                        // so that it has self.log, and the same
+                        // self.registerBackoff that we do.
+                        registerServer.call(self, callback);
+                    }, delay);
+
+                    // Note: we don't call callback() because we wait until
+                    // we're successful.
 
-            return;
-        }
+                    return;
+                }
 
-        self.log.info({
-            headers: res.headers,
-            statusCode: res.statusCode
-        }, 'posted sysinfo to CNAPI');
+                callback();
 
-        callback();
-    });
+                self.log.info({
+                    headers: res.headers,
+                    statusCode: res.statusCode,
+                    sysinfoCount: self.sysinfoCount
+                }, 'posted sysinfo to CNAPI');
+            });
+        });
 };
 
 
@@ -425,10 +459,17 @@ App.prototype.start = function () {
         funcs: [
             function _createCnapiConnection(_, cb) {
                 self.createCnapiConnection(cb);
-            }, function _registerServer(_, cb) {
-                // We only call cb() once the 'sysinfo' has been handled by
-                // the cnapiQueue.
-                self.cnapiQueue.push('sysinfo', cb);
+            }, function _startSysinfoFileWatcher(_, cb) {
+                self.backend.watchSysinfo({serverUuid: self.uuid},
+                    function _onSysinfoChange() {
+                        // This function (_onSysinfoChange) is called once on
+                        // startup and then again any time the sysinfo changes.
+                        // On the *first* call, we want to call cb() only after
+                        // we've updated CNAPI.
+                        self.log.info('saw sysinfo change, updating to CNAPI');
+                        self.queueSysinfoUpdateIfNotAlreadyQueued(
+                            self.sysinfoCount === 0 ? cb : undefined);
+                    });
             }, function _startHeartbeater(_, cb) {
                 self.startHeartbeater();
                 cb();
diff --git a/lib/backends/common.js b/lib/backends/common.js
index eb744c7..8c8a29d 100644
--- a/lib/backends/common.js
+++ b/lib/backends/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -488,7 +488,117 @@ function adoptInstanceInSapi(opts, callback) {
     attemptAdoption();
 }
 
+//
+// This is designed to watch a "sysinfo" file whether it exists or not, and call
+// opts.callback() whenever that file is changed (or created). If the fs.watch()
+// is broken for any reason (e.g. file is deleted) this will retry creating the
+// watch every retryWatchDelay ms until the watch is reestablished.
+//
+// To use, create a SysinfoFileWatcher passing in options specifying the
+// filename and callback, and then call:
+//
+//   sfw.watch();
+//
+// to start watching.
+//
+// Note: callback will always be called right after the .watch() is run the
+// first time. Since we don't have a previous mtime to compare to so we don't
+// know when the last update was.
+//
+function SysinfoFileWatcher(opts) {
+    assert.object(opts, 'opts');
+    assert.func(opts.callback, 'opts.callback');
+    assert.string(opts.filename, 'opts.filename');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalNumber(opts.retryWatchDelay, 'opts.retryWatchDelay');
+
+    var self = this;
+
+    self.callback = opts.callback;
+    self.filename = opts.filename;
+    self.log = opts.log;
+
+    self.prevMtime = 0;
+    self.retryTimer = null;
+    self.retryWatchDelay = opts.retryWatchDelay || 5000;
+    self.watcher = null;
+    self.watching = false;
+}
+
+SysinfoFileWatcher.prototype.watch = function watch() {
+    var self = this;
+
+    // ensure we only call .watch() once.
+    assert.equal(self.watching, false, 'cannot call .watch() twice');
+    self.watching = true;
+
+    self.retryTimer = null;
+
+    function _onError(err) {
+        if (self.retryTimer === null) {
+            self.retryTimer = setTimeout(self.watch.bind(self),
+                self.retryWatchDelay);
+        }
+    }
+
+    function _onEvt(evt) {
+        self.log.trace({evt: evt, filename: self.filename},
+            'saw fs.watch() event for sysinfo file');
+        _checkMtime();
+    }
+
+    function _checkMtime() {
+        fs.stat(self.filename, function _onStat(err, stats) {
+            var mtime;
+
+            if (err) {
+                _onError(err);
+                return;
+            }
+
+            mtime = stats.mtime.getTime();
+            if (mtime > self.prevMtime) {
+                // We've detected a change!
+                self.callback();
+            }
+
+            self.prevMtime = mtime;
+        });
+    }
+
+    // This happens in a try{} block, because if for some reason the file
+    // doesn't exist, we'll get an exception rather than an error. Unfortunately
+    // in some cases we'll get both an error and an exception (e.g. when the
+    // file is deleted we get an error then we'll get an exception when
+    // fs.watch() internally tries to re-watch the file and gets ENOENT.
+    // We work around this in _onError() by only doing a retry if we're not
+    // already retrying.
+    try {
+        self.watcher = fs.watch(self.filename, _onEvt);
+    } catch (e) {
+        _onError(e);
+        return;
+    }
+
+    self.log.debug('watching sysinfo file %s', self.filename);
+
+    // We check the mtime here because if we are a retry, the sysinfo might have
+    // changed since it was last checked and this way we'll catch that. In the
+    // case that this is the first ever run, we'll just end up setting the
+    // prevMtime and sending an initial sysinfo update.
+    //
+    // Note: part of the expected interface here is that .watch() will always
+    // call callback when it's started up. This is because we don't know whether
+    // any changes happened since we were last running, and it allows cn-agent
+    // to just startup this watcher at startup and know we'll send the initial
+    // sysinfo, and all subsequent changes.
+    _checkMtime();
+
+    self.watcher.on('error', _onError);
+};
+
 module.exports = {
     adoptInstanceInSapi: adoptInstanceInSapi,
-    getAgentImage: getAgentImage
+    getAgentImage: getAgentImage,
+    SysinfoFileWatcher: SysinfoFileWatcher
 };
diff --git a/lib/backends/dummy/index.js b/lib/backends/dummy/index.js
index 7f6f5e3..d499228 100644
--- a/lib/backends/dummy/index.js
+++ b/lib/backends/dummy/index.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var jsprim = require('jsprim');
 var vasync = require('vasync');
 
+var backends_common = require('../common');
 var common = require('./common');
 var sysinfoGetter = require('./lib/sysinfo');
 
@@ -129,6 +130,26 @@ DummyBackend.prototype.getSysinfo = function getSysinfo(opts, callback) {
     });
 };
 
+// This will call callback() every time sysinfo has changed.
+DummyBackend.prototype.watchSysinfo = function watchSysinfo(opts, callback) {
+    assert.func(callback, 'callback');
+    assert.object(opts, 'opts');
+    assert.optionalUuid(opts.serverUuid, 'opts.serverUuid');
+
+    var self = this;
+    var getter = new sysinfoGetter();
+    var serverUuid = opts.serverUuid || self.serverUuid;
+
+    var watcher = new common.SysinfoFileWatcher({
+        callback: callback,
+        filename: getter.filename({serverUuid: serverUuid}),
+        log: self.log
+    });
+
+    watcher.watch();
+};
+
+
 function _getAdminIpSysinfo(sysinfo_object, callback) {
     var adminIp = netconfig.adminIpFromSysinfo(sysinfo_object);
 
diff --git a/lib/backends/dummy/lib/sysinfo.js b/lib/backends/dummy/lib/sysinfo.js
index 8bcf1bc..eac69ba 100644
--- a/lib/backends/dummy/lib/sysinfo.js
+++ b/lib/backends/dummy/lib/sysinfo.js
@@ -23,9 +23,10 @@ sysinfo.prototype.get = function get(opts, callback) {
     assert.object(opts.serverAddress, 'opts.serverAddress');
     assert.func(callback, 'callback');
 
-    var filename = common.SERVER_ROOT + '/' + opts.serverUuid + '/sysinfo.json';
+    var self = this;
+    var _filename = self.filename(opts);
 
-    fs.readFile(filename, function onData(err, data) {
+    fs.readFile(_filename, function onData(err, data) {
         var sinfo;
 
         if (err) {
@@ -41,6 +42,16 @@ sysinfo.prototype.get = function get(opts, callback) {
     });
 };
 
+sysinfo.prototype.filename = function filename(opts) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+
+    var _filename = common.SERVER_ROOT + '/' + opts.serverUuid +
+        '/sysinfo.json';
+
+    return (_filename);
+};
+
 module.exports = sysinfo;
 
 if (require.main === module) {
diff --git a/lib/backends/smartos/index.js b/lib/backends/smartos/index.js
index d88d416..2cb7df0 100644
--- a/lib/backends/smartos/index.js
+++ b/lib/backends/smartos/index.js
@@ -5,11 +5,10 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
-// This file serves as an example of the minimum required in order to implement
-// a cn-agent backend.
+// This file is the main file for the SmartOS cn-agent backend.
 
 var cp = require('child_process');
 var EventEmitter = require('events').EventEmitter;
@@ -30,6 +29,7 @@ var vmadm = require('vmadm');
 var zfs = require('zfs').zfs;
 var zpool = require('zfs').zpool;
 
+var backends_common = require('../common');
 var imgadm = require('./imgadm');
 var smartdc_config = require('./smartdc-config');
 
@@ -668,6 +668,21 @@ SmartosBackend.prototype.getFirstAdminIp = function getFirstAdminIp(_, sysinfo,
     return smartdc_config.getFirstAdminIp(sysinfo, callback);
 };
 
+// This will call callback() every time sysinfo has changed.
+SmartosBackend.prototype.watchSysinfo = function watchSysinfo(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var self = this;
+    var watcher = new backends_common.SysinfoFileWatcher({
+        callback: callback,
+        filename: '/tmp/.sysinfo.json',
+        log: self.log
+    });
+
+    watcher.watch();
+};
+
 SmartosBackend.prototype.getBootTime = function getBootTime(_, callback) {
     // sysinfo will have the 'Boot Time' cached, so we use that
     smartdc_config.sysinfo(function onSysinfo(err, sysinfo) {
diff --git a/lib/task_agent/task_runner.js b/lib/task_agent/task_runner.js
index 6584afe..98e8c92 100644
--- a/lib/task_agent/task_runner.js
+++ b/lib/task_agent/task_runner.js
@@ -14,6 +14,7 @@
  * process.
  */
 
+var EventEmitter = require('events');
 var fork = require('child_process').fork;
 var fs = require('fs');
 var path = require('path');
@@ -47,7 +48,7 @@ function TaskRunner(options) {
 }
 
 
-util.inherits(TaskRunner, process.EventEmitter);
+util.inherits(TaskRunner, EventEmitter);
 
 var MAXIMUM_MESSAGE_STRING_LENGTH = 1000;
 
diff --git a/package.json b/package.json
index 9496601..1a80623 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cn-agent",
   "description": "Triton Compute Node Agent",
-  "version": "2.8.0",
+  "version": "2.9.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
