commit ed94ae44f502008cf5736972b3bc9afce7177ff5 (refs/changes/75/5575/9)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2019-02-14T14:10:43-08:00 (8 months ago)
    
    TRITON-1221 cn-agent should ensure CNAPI is updated when sysinfo changes
    Reviewed by: Trent Mick <trentm@gmail.com>

diff --git a/lib/app.js b/lib/app.js
index 6381d9a..794e483 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -78,6 +78,8 @@ function App(options) {
     this.sdc_config = options.sdc_config;
     this.statusQueued = false;
     this.sysinfo = options.sysinfo;
+    this.sysinfoCount = 0;
+    this.sysinfoQueued = false;
     // use the same user-agent format as vm-agent
     this.userAgent = 'cn-agent/' + packageJson.version +
         ' (node/' + process.versions.node + ')' +
@@ -92,7 +94,7 @@ function App(options) {
         this.isUpdateHelper = true;
     }
 
-    // ensure we have all the config required to connect to and use CNAPI
+    // Ensure we have all the config required to connect to and use CNAPI.
     assert.object(this.config, 'this.config');
     assert.optionalObject(this.config.cnapi, 'this.config.cnapi');
     assert.string(this.sdc_config.dns_domain, 'this.sdc_config.dns_domain');
@@ -193,6 +195,28 @@ function queueStatusUpdateIfNotAlreadyQueued() {
     });
 };
 
+App.prototype.queueSysinfoUpdateIfNotAlreadyQueued =
+function queueSysinfoUpdateIfNotAlreadyQueued(callback) {
+    assert.optionalFunc(callback, 'callback');
+
+    var self = this;
+
+    if (self.sysinfoQueued === true) {
+        self.log.debug('Already have a sysinfo update pending');
+        return;
+    }
+
+    // Queue a sysinfo update
+    self.sysinfoQueued = true;
+    self.cnapiQueue.push('sysinfo', function _onSysinfoUpdated() {
+        self.sysinfoQueued = false;
+        self.sysinfoCount++;
+        if (callback !== undefined) {
+            callback();
+        }
+    });
+};
+
 /*
  * This is used to serialize updates to CNAPI to ensure that we don't overload a
  * busy CNAPI by sending more than 1 request at a time. This is handled via a
@@ -303,9 +327,9 @@ App.prototype.startHeartbeater = function () {
 };
 
 
-// Whenever we start up, we want to ensure we've updated the sysinfo in CNAPI
-// before we continue further. This ensures we've got the correct 'Boot Time'
-// for example. (See also: TRITON-69)
+// Whenever we start up, or when sysinfo changes we want to ensure we've updated
+// the sysinfo in CNAPI. This ensures we've got the correct 'Boot Time' for
+// example. (See also: TRITON-69)
 //
 // We also pass the cnAgentPort which CNAPI can use to communicate with this
 // cn-agent instance.
@@ -313,65 +337,83 @@ App.prototype.registerServer = function registerServer(callback) {
     var self = this;
 
     assert.object(self.cnapiClient, 'self.cnapiClient');
-    assert.object(self.sysinfo, 'self.sysinfo');
-
-    var sysinfo = self.sysinfo;
-    var urlPath = path.join('/servers', self.uuid, 'sysinfo');
 
-    // We'll add our port to the sysinfo here so that if we're not using the
-    // default port, CNAPI knows where to send requests to us.  Our IP can be
-    // found from sysinfo['Admin IP'].
-    sysinfo['CN Agent Port'] = self.agentserver.server.address().port;
+    var serverAddress = self.agentserver.server.address();
 
-    // Make an attempt, if that fails, schedule a new attempt with a delay
-    self.cnapiClient.post({
-        path: urlPath
-    }, {
-        sysinfo: self.sysinfo
-    }, function _afterPost(err, req, res, obj) {
-        var delay;
-
-        if (err) {
-            if (err.statusCode === 404 && err.restCode === 'ResourceNotFound') {
-                // If we get a 404, that means we've got an old CNAPI that
-                // doesn't support registering sysinfo. So we'll not keep
-                // retrying in this case.
-                self.log.warn({
-                    err: err
-                }, 'CNAPI does not seem to support sysinfo registration. ' +
-                    'Skipping.');
+    // We always grab the sysinfo here so that we're only ever trying to POST
+    // the most recent state. If the POST fails (e.g. with an ETag error) the
+    // whole registerServer will be retried, so we'll re-gather the sysinfo
+    // which should ensure we're never overwriting newer sysinfo with older
+    // sysinfo.
+    self.backend.getSysinfo({
+        serverAddress: serverAddress,
+        serverUuid: self.uuid
+    }, function onSysinfo(sysinfoErr, sysinfoObj) {
+        assert.ifError(sysinfoErr, 'sysinfo should always succeed');
+
+        var urlPath = path.join('/servers', self.uuid, 'sysinfo');
+
+        // Set the sysinfo we just grabbbed.
+        self.sysinfo = sysinfoObj;
+
+        // We'll add our port to the sysinfo here so that if we're not using
+        // the default port, CNAPI knows where to send requests to us. Our
+        // IP can be found from sysinfo['Admin IP'].
+        self.sysinfo['CN Agent Port'] = serverAddress.port;
+
+        // Make an attempt, if that fails, schedule a new attempt with a delay.
+        self.cnapiClient.post({
+            path: urlPath
+        }, {
+            sysinfo: self.sysinfo
+        }, function _afterPost(err, req, res, obj) {
+            var delay;
+
+            if (err) {
+                if (err.statusCode === 404 &&
+                    err.restCode === 'ResourceNotFound') {
+
+                    // If we get a 404, that means we've got an old CNAPI that
+                    // doesn't support registering sysinfo. So we'll not keep
+                    // retrying in this case.
+                    self.log.warn({
+                        err: err
+                    }, 'CNAPI does not seem to support sysinfo ' +
+                        'registration. Skipping.');
 
-                callback();
-                return;
-            }
+                    callback();
+                    return;
+                }
 
-            delay = self.registerBackoff.duration();
+                delay = self.registerBackoff.duration();
 
-            self.log.warn({
-                err: err,
-                retryInMs: delay
-            }, 'Error posting sysinfo to CNAPI, will retry.');
+                self.log.warn({
+                    err: err,
+                    retryInMs: delay
+                }, 'Error posting sysinfo to CNAPI, will retry.');
 
-            setTimeout(function _registerAgain() {
-                // The .call() is necessary here because we want the
-                // registerServer function to have the correct `self`, so that
-                // it has self.log, and the same self.registerBackoff that we
-                // do.
-                registerServer.call(self, callback);
-            }, delay);
+                setTimeout(function _registerAgain() {
+                    // The .call() is necessary here because we want the
+                    // registerServer function to have the correct `self`, so
+                    // that it has self.log, and the same self.registerBackoff
+                    // that we do.
+                    registerServer.call(self, callback);
+                }, delay);
 
-            // Note: we don't call callback() because we wait until we're
-            // successful.
+                // Note: we don't call callback() because we wait until we're
+                // successful.
 
-            return;
-        }
+                return;
+            }
 
-        self.log.info({
-            headers: res.headers,
-            statusCode: res.statusCode
-        }, 'Posted sysinfo to CNAPI');
+            callback();
 
-        callback();
+            self.log.info({
+                headers: res.headers,
+                statusCode: res.statusCode,
+                sysinfoCount: self.sysinfoCount
+            }, 'Posted sysinfo to CNAPI');
+        });
     });
 };
 
@@ -425,10 +467,17 @@ App.prototype.start = function () {
         funcs: [
             function _createCnapiConnection(_, cb) {
                 self.createCnapiConnection(cb);
-            }, function _registerServer(_, cb) {
-                // We only call cb() once the 'sysinfo' has been handled by
-                // the cnapiQueue.
-                self.cnapiQueue.push('sysinfo', cb);
+            }, function _startSysinfoFileWatcher(_, cb) {
+                self.backend.watchSysinfo({serverUuid: self.uuid},
+                    function _onSysinfoChange() {
+                        // This function (_onSysinfoChange) is called once on
+                        // startup and then again any time the sysinfo changes.
+                        // On the *first* call, we want to call cb() only after
+                        // we've updated CNAPI.
+                        self.log.info('Saw sysinfo change, updating to CNAPI');
+                        self.queueSysinfoUpdateIfNotAlreadyQueued(
+                            self.sysinfoCount === 0 ? cb : undefined);
+                    });
             }, function _startHeartbeater(_, cb) {
                 self.startHeartbeater();
                 cb();
diff --git a/lib/backends/common.js b/lib/backends/common.js
index 6f161da..d9bcb85 100644
--- a/lib/backends/common.js
+++ b/lib/backends/common.js
@@ -74,7 +74,7 @@ function getAgentImage(imageUuid, opts, callback) {
         function getImgapiManifest(_, cb) {
             var args = ['-f', '-sS', manifestUrl];
 
-            log.debug({cmdline: CURL_CMD + ' ' + args.join(' ')}, 'executing');
+            log.debug({cmdline: CURL_CMD + ' ' + args.join(' ')}, 'Executing');
             execFile(CURL_CMD, args, function (err, stdout, stderr) {
                 if (err) {
                     log.error({
@@ -82,7 +82,7 @@ function getAgentImage(imageUuid, opts, callback) {
                         stdout: stdout,
                         stderr: stderr,
                         url: manifestUrl
-                    }, 'failed to download manifest');
+                    }, 'Failed to download manifest');
                     if (err.message.match(/404 Not Found/)) {
                         cb(new Error('Image not found at ' + manifestUrl));
                     } else {
@@ -96,9 +96,9 @@ function getAgentImage(imageUuid, opts, callback) {
                     log.debug({
                         manifest: manifest,
                         url: manifestUrl
-                    }, 'got imgapi manifest');
+                    }, 'Got imgapi manifest');
                 } catch (e) {
-                    log.error(e, 'failed to parse manifest');
+                    log.error(e, 'Failed to parse manifest');
                     cb(e);
                     return;
                 }
@@ -120,7 +120,7 @@ function getAgentImage(imageUuid, opts, callback) {
                         stdout: stdout,
                         stderr: stderr,
                         url: fileUrl
-                    }, 'failed to download file');
+                    }, 'Failed to download file');
                     if (err.message.match(/404 Not Found/)) {
                         cb(new Error('Image not found at ' + fileUrl));
                     } else {
@@ -131,7 +131,7 @@ function getAgentImage(imageUuid, opts, callback) {
                 log.debug({
                     filename: outputFullBasename + '.file',
                     url: fileUrl
-                }, 'got imgapi file');
+                }, 'Got imgapi file');
                 cb();
             });
         }, function checkSize(_, cb) {
@@ -141,12 +141,12 @@ function getAgentImage(imageUuid, opts, callback) {
 
             fs.stat(filename, function (err, stat) {
                 if (err) {
-                    log.error('failed to stat ' + filename);
+                    log.error('Failed to stat ' + filename);
                     cb(err);
                     return;
                 }
                 if (stat.size !== expected_size) {
-                    message = 'unexpected file size (' + expected_size +
+                    message = 'Unexpected file size (' + expected_size +
                         ' vs ' + stat.size + ')';
                     log.error({
                         actual: stat.size,
@@ -172,7 +172,7 @@ function getAgentImage(imageUuid, opts, callback) {
 
             args = ['sha1', filename];
 
-            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'Executing');
             execFile(cmd, args, function (err, stdout, stderr) {
                 var parts;
                 var sha1;
@@ -182,7 +182,7 @@ function getAgentImage(imageUuid, opts, callback) {
                         err: err,
                         stdout: stdout,
                         stderr: stderr
-                    }, 'failed to identify sha1');
+                    }, 'Failed to identify sha1');
                     cb(err);
                     return;
                 }
@@ -194,7 +194,7 @@ function getAgentImage(imageUuid, opts, callback) {
                     log.error({
                         stdout: stdout,
                         stderr: stderr
-                    }, 'unable to parse sha1');
+                    }, 'Unable to parse sha1');
                     cb(new Error('unable to parse sha1: ' + stdout));
                     return;
                 }
@@ -204,7 +204,7 @@ function getAgentImage(imageUuid, opts, callback) {
                         actual_sha1: sha1,
                         expected_sha1: expected_sha1,
                         filename: filename
-                    }, 'invalid sha1');
+                    }, 'Invalid sha1');
                     cb(new Error('sha1 does not match: (' + sha1 + ' vs ' +
                         expected_sha1 + ')'));
                     return;
@@ -229,14 +229,14 @@ function getAgentImage(imageUuid, opts, callback) {
                 return;
             }
 
-            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'Executing');
             execFile(cmd, args, function (err, stdout, stderr) {
                 if (err) {
                     log.error({
                         err: err,
                         stdout: stdout,
                         stderr: stderr
-                    }, 'failed to identify file magic');
+                    }, 'Failed to identify file magic');
                     cb(err);
                     return;
                 }
@@ -251,7 +251,7 @@ function getAgentImage(imageUuid, opts, callback) {
                     log.error({
                         stdout: stdout,
                         stderr: stderr
-                    }, 'unhandled file type');
+                    }, 'Unhandled file type');
                     cb(new Error('unhandled file type: ' + stdout));
                 }
             });
@@ -264,12 +264,12 @@ function getAgentImage(imageUuid, opts, callback) {
             } else if (compression === 'bzip2') {
                 newname = outputFullBasename + '.tar.bz2';
             } else {
-                log.error('unknown compression: ' + compression);
+                log.error('Unknown compression: ' + compression);
                 cb(new Error('unknown compression: ' + compression));
                 return;
             }
 
-            log.debug({oldname: oldname, newname: newname}, 'renaming file');
+            log.debug({oldname: oldname, newname: newname}, 'Renaming file');
             fs.rename(oldname, newname, function (err) {
                 if (err) {
                     cb(err);
@@ -287,7 +287,7 @@ function getAgentImage(imageUuid, opts, callback) {
             var message;
 
             if (!agentName) {
-                message = 'manifest is missing "name"';
+                message = 'Manifest is missing "name"';
                 log.error({manifest: manifest}, message);
                 cb(new Error(message));
                 return;
@@ -299,7 +299,7 @@ function getAgentImage(imageUuid, opts, callback) {
             } else if (compression === 'bzip2') {
                 args.push('-jtf');
             } else {
-                message = 'invalid compression type: ' + compression;
+                message = 'Invalid compression type: ' + compression;
                 log.error({manifest: manifest, compression: compression},
                     message);
                 cb(new Error(message));
@@ -309,23 +309,23 @@ function getAgentImage(imageUuid, opts, callback) {
             args.push(outputFilename);
             args.push(filename);
 
-            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing');
+            log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'Executing');
             execFile(cmd, args, function (err, stdout) {
                 var trimmed;
 
                 if (err) {
                     log.error({err: err, file: outputFilename},
-                        'failed to list file from image');
+                        'Failed to list file from image');
                     cb(err);
                     return;
                 }
 
                 trimmed = stdout.replace(new RegExp('[\\s]+$', 'g'), '');
                 if (trimmed === filename) {
-                    log.debug('found ' + filename + ' in ' + outputFilename);
+                    log.debug('Found ' + filename + ' in ' + outputFilename);
                     cb();
                 } else {
-                    message = 'could not find ' + filename + ' in ' +
+                    message = 'Could not find ' + filename + ' in ' +
                         outputFilename;
                     log.error({stdout: stdout}, message);
                     cb(new Error(message));
@@ -418,7 +418,7 @@ function adoptInstanceInSapi(opts, callback) {
                         // Something's broken if we have more than one service
                         // for this agent.
                         assert.equal(services.length, 1,
-                            'expected exactly 1 service');
+                            'Expected exactly 1 service');
 
                         service = services[0];
 
@@ -488,7 +488,122 @@ function adoptInstanceInSapi(opts, callback) {
     attemptAdoption();
 }
 
+//
+// This is designed to watch a "sysinfo" file whether it exists or not, and call
+// opts.callback() whenever that file is changed (or created). If the fs.watch()
+// is broken for any reason (e.g. file is deleted) this will retry creating the
+// watch every retryWatchDelay ms until the watch is reestablished.
+//
+// To use, create a SysinfoFileWatcher passing in options specifying the
+// filename and callback, and then call:
+//
+//   sfw.watch();
+//
+// to start watching.
+//
+// Note: callback will always be called right after the .watch() is run the
+// first time. Since we don't have a previous mtime to compare to so we don't
+// know when the last update was.
+//
+function SysinfoFileWatcher(opts) {
+    assert.object(opts, 'opts');
+    assert.func(opts.callback, 'opts.callback');
+    assert.string(opts.filename, 'opts.filename');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalNumber(opts.retryWatchDelay, 'opts.retryWatchDelay');
+
+    var self = this;
+
+    self.callback = opts.callback;
+    self.filename = opts.filename;
+    self.log = opts.log;
+
+    self.prevMtime = 0;
+    self.retryTimer = null;
+    self.retryWatchDelay = opts.retryWatchDelay || 5000;
+    self.watcher = null;
+    self.watching = false;
+}
+
+SysinfoFileWatcher.prototype.watch = function watch() {
+    var self = this;
+
+    // ensure we only call .watch() once.
+    assert.equal(self.watching, false, 'Cannot call .watch() twice');
+    self.watching = true;
+
+    self.retryTimer = null;
+
+    function _onError(err) {
+        self.log.trace({
+            err: err,
+            retryTimer: (self.retryTimer === null)
+        }, 'Error attempting to watch sysinfo file, will try again');
+
+        if (self.retryTimer === null) {
+            self.retryTimer = setTimeout(self.watch.bind(self),
+                self.retryWatchDelay);
+        }
+    }
+
+    function _onEvt(evt) {
+        self.log.trace({evt: evt, filename: self.filename},
+            'Saw fs.watch() event for sysinfo file');
+        _checkMtime();
+    }
+
+    function _checkMtime() {
+        fs.stat(self.filename, function _onStat(err, stats) {
+            var mtime;
+
+            if (err) {
+                _onError(err);
+                return;
+            }
+
+            mtime = stats.mtime.getTime();
+            if (mtime > self.prevMtime) {
+                // We've detected a change!
+                self.callback();
+            }
+
+            self.prevMtime = mtime;
+        });
+    }
+
+    // This happens in a try{} block, because if for some reason the file
+    // doesn't exist, we'll get an exception rather than an error. Unfortunately
+    // in some cases we'll get both an error and an exception (e.g. when the
+    // file is deleted we get an error then we'll get an exception when
+    // fs.watch() internally tries to re-watch the file and gets ENOENT.
+    // We work around this in _onError() by only doing a retry if we're not
+    // already retrying.
+    try {
+        self.watcher = fs.watch(self.filename, _onEvt);
+    } catch (e) {
+        _onError(e);
+        return;
+    }
+
+    self.log.debug('Watching sysinfo file %s', self.filename);
+
+    // We check the mtime here because if we are a retry, the sysinfo might have
+    // changed since it was last checked and this way we'll catch that. In the
+    // case that this is the first ever run, we'll just end up setting the
+    // prevMtime and sending an initial sysinfo update.
+    //
+    // Note: part of the expected interface here is that .watch() will always
+    // call callback when it's started up. This is because we don't know whether
+    // any changes happened since we were last running, and it allows cn-agent
+    // to just startup this watcher at startup and know we'll send the initial
+    // sysinfo, and all subsequent changes.
+    _checkMtime();
+
+    self.watcher.on('error', _onError);
+};
+
 module.exports = {
     adoptInstanceInSapi: adoptInstanceInSapi,
-    getAgentImage: getAgentImage
+    getAgentImage: getAgentImage,
+    SysinfoFileWatcher: SysinfoFileWatcher
 };
diff --git a/lib/backends/dummy/index.js b/lib/backends/dummy/index.js
index 6dbb3e1..3294b8f 100644
--- a/lib/backends/dummy/index.js
+++ b/lib/backends/dummy/index.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var jsprim = require('jsprim');
 var vasync = require('vasync');
 
+var backends_common = require('../common');
 var common = require('./common');
 var sysinfoGetter = require('./lib/sysinfo');
 
@@ -130,6 +131,26 @@ DummyBackend.prototype.getSysinfo = function getSysinfo(opts, callback) {
     });
 };
 
+// This will call callback() every time sysinfo has changed.
+DummyBackend.prototype.watchSysinfo = function watchSysinfo(opts, callback) {
+    assert.func(callback, 'callback');
+    assert.object(opts, 'opts');
+    assert.optionalUuid(opts.serverUuid, 'opts.serverUuid');
+
+    var self = this;
+    var getter = new sysinfoGetter();
+    var serverUuid = opts.serverUuid || self.serverUuid;
+
+    var watcher = new backends_common.SysinfoFileWatcher({
+        callback: callback,
+        filename: getter.filename({serverUuid: serverUuid}),
+        log: self.log
+    });
+
+    watcher.watch();
+};
+
+
 function _getAdminIpSysinfo(sysinfo_object, callback) {
     var adminIp = netconfig.adminIpFromSysinfo(sysinfo_object);
 
diff --git a/lib/backends/dummy/lib/sysinfo.js b/lib/backends/dummy/lib/sysinfo.js
index 8bcf1bc..eac69ba 100644
--- a/lib/backends/dummy/lib/sysinfo.js
+++ b/lib/backends/dummy/lib/sysinfo.js
@@ -23,9 +23,10 @@ sysinfo.prototype.get = function get(opts, callback) {
     assert.object(opts.serverAddress, 'opts.serverAddress');
     assert.func(callback, 'callback');
 
-    var filename = common.SERVER_ROOT + '/' + opts.serverUuid + '/sysinfo.json';
+    var self = this;
+    var _filename = self.filename(opts);
 
-    fs.readFile(filename, function onData(err, data) {
+    fs.readFile(_filename, function onData(err, data) {
         var sinfo;
 
         if (err) {
@@ -41,6 +42,16 @@ sysinfo.prototype.get = function get(opts, callback) {
     });
 };
 
+sysinfo.prototype.filename = function filename(opts) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.serverUuid, 'opts.serverUuid');
+
+    var _filename = common.SERVER_ROOT + '/' + opts.serverUuid +
+        '/sysinfo.json';
+
+    return (_filename);
+};
+
 module.exports = sysinfo;
 
 if (require.main === module) {
diff --git a/lib/backends/smartos/index.js b/lib/backends/smartos/index.js
index 6d23d77..4d70ffd 100644
--- a/lib/backends/smartos/index.js
+++ b/lib/backends/smartos/index.js
@@ -5,11 +5,10 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
-// This file serves as an example of the minimum required in order to implement
-// a cn-agent backend.
+// This file is the main file for the SmartOS cn-agent backend.
 
 var cp = require('child_process');
 var EventEmitter = require('events').EventEmitter;
@@ -30,6 +29,7 @@ var vmadm = require('vmadm');
 var zfs = require('zfs').zfs;
 var zpool = require('zfs').zpool;
 
+var backends_common = require('../common');
 var imgadm = require('./imgadm');
 var smartdc_config = require('./smartdc-config');
 
@@ -668,6 +668,28 @@ SmartosBackend.prototype.getFirstAdminIp = function getFirstAdminIp(_, sysinfo,
     return smartdc_config.getFirstAdminIp(sysinfo, callback);
 };
 
+// This will call callback() every time sysinfo has changed.
+SmartosBackend.prototype.watchSysinfo = function watchSysinfo(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    //
+    // Note: This uses /tmp/.sysinfo.json which like much of SmartOS is not a
+    //       promised interface. If the platform changes how sysinfo works,
+    //       we'll need to rewrite this. Or at least add support for both the
+    //       old and new way to detect sysinfo changes.
+    //
+
+    var self = this;
+    var watcher = new backends_common.SysinfoFileWatcher({
+        callback: callback,
+        filename: '/tmp/.sysinfo.json',
+        log: self.log
+    });
+
+    watcher.watch();
+};
+
 SmartosBackend.prototype.getBootTime = function getBootTime(_, callback) {
     // sysinfo will have the 'Boot Time' cached, so we use that
     smartdc_config.sysinfo(function onSysinfo(err, sysinfo) {
diff --git a/lib/task_agent/task_runner.js b/lib/task_agent/task_runner.js
index 6584afe..31e1186 100644
--- a/lib/task_agent/task_runner.js
+++ b/lib/task_agent/task_runner.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,7 @@
  * process.
  */
 
+var EventEmitter = require('events');
 var fork = require('child_process').fork;
 var fs = require('fs');
 var path = require('path');
@@ -47,7 +48,7 @@ function TaskRunner(options) {
 }
 
 
-util.inherits(TaskRunner, process.EventEmitter);
+util.inherits(TaskRunner, EventEmitter);
 
 var MAXIMUM_MESSAGE_STRING_LENGTH = 1000;
 
diff --git a/package.json b/package.json
index acb351d..2ccc38d 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cn-agent",
   "description": "Triton Compute Node Agent",
-  "version": "2.8.3",
+  "version": "2.9.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
