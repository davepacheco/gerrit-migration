From a33456a4484d68a46270c8d2624647fa1b7daf37 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Mon, 26 Jun 2017 18:07:13 -0400
Subject: [PATCH] joyent/node-vasync#33 want filterEachPipeline and
 filterEachParallel

---
 README.md       | 44 ++++++++++++++++++++++++++++++++++++++++
 lib/vasync.js   | 53 +++++++++++++++++++++++++++++++++++++++++++++++++
 tests/filter.js | 40 +++++++++++++++++++++++++++++++++++++
 3 files changed, 137 insertions(+)
 create mode 100644 tests/filter.js

diff --git a/README.md b/README.md
index 170be46..e3e2c3b 100644
--- a/README.md
+++ b/README.md
@@ -39,10 +39,14 @@ have several ways of getting at this state:
   parallel (and merge the results)
 * [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):
   invoke the same function on N inputs in parallel
+* [filterEachParallel](#filtereachparallel-filter-n-inputs-in-parallel):
+  invoke the same function on N inputs to filter them in parallel
 * [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke
   N functions in series (and stop on failure)
 * [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):
   invoke the same function on N inputs in series (and stop on failure)
+* [filterEachPipeline](#filtereachpipeline-filter-n-inputs-in-series):
+  invoke the same function on N inputs to filter them in series
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
   like pipeline, but propagating results between stages
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
@@ -176,6 +180,26 @@ console.log(mod_vasync.forEachParallel({
 }));
 ```
 
+### filterEachParallel: filter N inputs in parallel
+
+Synopsis: `filterEachParallel(args, callback)`
+
+This function is exactly like `forEachParallel`, except that the value returned
+in the final callback is an array that contains a subset of the original inputs
+array.  The function is invoked on each input in parallel.  The original inputs
+array given as an argument is not modified.
+
+```js
+mod_vasync.filterEachParallel({
+    inputs: [0, 1, 2, 3, 4, 5],
+    func: function filterInputs(input, cb) {
+        cb(input < 2 || input === 4);
+    }
+}, function (results) {
+    // results => [0, 1, 4]
+});
+```
+
 ### pipeline: invoke N functions in series (and stop on failure)
 
 Synopsis: `pipeline(args, callback)`
@@ -246,6 +270,26 @@ console.log(mod_vasync.forEachPipeline({
 }));
 ```
 
+### filterEachPipeline: filter N inputs in series
+
+Synopsis: `filterEachPipeline(args, callback)`
+
+This function is exactly like `forEachPipeline`, except that the value returned
+in the final callback is an array that contains a subset of the original inputs
+array.  The function is invoked on each input in series.  The original inputs
+array given as an argument is not modified.
+
+```js
+mod_vasync.filterEachPipeline({
+    inputs: [0, 1, 2, 3, 4, 5],
+    func: function filterInputs(input, cb) {
+        cb(input < 2 || input === 4);
+    }
+}, function (results) {
+    // results => [0, 1, 4]
+});
+```
+
 ### waterfall: invoke N functions in series, stop on failure, and propagate results
 
 Synopsis: `waterfall(funcs, callback)`
diff --git a/lib/vasync.js b/lib/vasync.js
index ccc3e2a..1dbf6cf 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -12,8 +12,10 @@ var mod_verror = require('verror');
  */
 exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
+exports.filterEachParallel = filterEachParallel;
 exports.pipeline = pipeline;
 exports.forEachPipeline = forEachPipeline;
+exports.filterEachPipeline = filterEachPipeline;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -250,6 +252,57 @@ function forEachPipeline(args, callback) {
     return (pipeline({'funcs': funcs}, callback));
 }
 
+/*
+ * Analogous to async.filter or async.filterSeries, this takes an input array
+ * and a single function to filter an array, and will callback with a new
+ * filtered array. This is effectively an asynchronous version of
+ * Array.prototype.filter. "args" must have the following fields:
+ *
+ *	func		asynchronous function to invoke on each input value
+ *			that calls back with true or false
+ *	inputs		array of input values
+ */
+function filterEachPipeline(args, callback) {
+	return filterEach(forEachPipeline, args, callback);
+}
+
+function filterEachParallel(args, callback) {
+	return filterEach(forEachParallel, args, callback);
+}
+
+/* private */
+function filterEach(vasyncFunc, args, callback) {
+	mod_assert.equal(typeof (vasyncFunc), 'function',
+			'"vasyncFunc" must be a function');
+	mod_assert.equal(typeof (args), 'object',
+			'"args" must be an object');
+	mod_assert.ok(Array.isArray(args.inputs),
+			'"args.inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (args.func), 'function',
+			'"args.func" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+			'"callback" argument must be specified as a function');
+
+	var results = [];
+
+	return vasyncFunc({
+		inputs: args.inputs,
+		func: function iterateSingleInput(input, cb) {
+			args.func(input, function filterSingleInput(ans) {
+				mod_assert.equal(typeof (ans), 'boolean',
+					'"ans" must be a boolean');
+
+				if (ans === true) {
+					results.push(input);
+				}
+
+				cb();
+			});
+		}
+	}, function () {
+		callback(results);
+	});
+}
 
 /*
  * async-compatible "queue" function.
diff --git a/tests/filter.js b/tests/filter.js
new file mode 100644
index 0000000..2400a9b
--- /dev/null
+++ b/tests/filter.js
@@ -0,0 +1,40 @@
+/*
+ * Tests the "filterEachPipeline" and "filterEachParallel" functions
+ */
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+var st;
+
+mod_tap.test('filterEachPipeline', function (test) {
+	mod_vasync.filterEachPipeline({
+		inputs: [0, 1, 2, 3, 4, 5],
+		func: function filterPipelineSingleInput(input, cb) {
+			cb(input < 2 || input === 4);
+		}
+	}, function filterPipelineDone(results) {
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 2');
+		test.end();
+	});
+});
+
+mod_tap.test('filterEachParallel', function (test) {
+	mod_vasync.filterEachParallel({
+		inputs: [0, 1, 2, 3, 4, 5],
+		func: function filterParallelSingleInput(input, cb) {
+			cb(input < 2 || input === 4);
+		}
+	}, function filterParallelDone(results) {
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 2');
+		test.end();
+	});
+});
-- 
2.21.0

