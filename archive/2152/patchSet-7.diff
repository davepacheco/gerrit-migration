commit cb63e8fec631a5f1025a6459ec78f2b258efcaca (refs/changes/52/2152/7)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-07-20T15:13:38-04:00 (2 years, 3 months ago)
    
    joyent/node-vasync#33 want filterEachPipeline and filterEachParallel

diff --git a/README.md b/README.md
index 170be46..95073e5 100644
--- a/README.md
+++ b/README.md
@@ -39,10 +39,14 @@ have several ways of getting at this state:
   parallel (and merge the results)
 * [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):
   invoke the same function on N inputs in parallel
+* [filterParallel](#filterparallel-filter-n-inputs-in-parallel):
+  invoke the same function on N inputs to filter them in parallel
 * [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke
   N functions in series (and stop on failure)
 * [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):
   invoke the same function on N inputs in series (and stop on failure)
+* [filterPipeline](#filterpipeline-filter-n-inputs-in-series):
+  invoke the same function on N inputs to filter them in series
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
   like pipeline, but propagating results between stages
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
@@ -292,6 +296,47 @@ func2 got "37" from func1
 better stop early
 ```
 
+### filter/filterLimit/filterSeries: filter N inputs serially or concurrently
+
+Synopsis: `filter(inputs, filterFunc, callback)`
+
+Synopsis: `filterSeries(inputs, filterFunc, callback)`
+
+Synopsis: `filterLimit(inputs, limit, filterFunc, callback)`
+
+These functions take an array (of anything) and a function to call on each
+element of the array.  The function must callback with a true or false value as
+the second argument or an error object as the first argument.  False values
+will result in the element being filtered out of the results array.  An error
+object passed as the first argument will cause the filter function to stop
+processing new elements and callback to the caller with the error immediately.
+Original input array order is maintained.
+
+`filter` and `filterSeries` are analogous to calling `filterLimit` with
+a limit of `Infinity` and `1` respectively.
+
+
+```js
+var inputs = [
+    'joyent.com',
+    'github.com',
+    'asdfaqsdfj.com'
+];
+function filterFunc(input, cb) {
+    mod_dns.resolve(input, function (err, results) {
+        if (err) {
+            cb(null, false);
+        } else {
+            cb(null, true);
+        }
+    }
+}
+mod_vasync.filter(inputs, filterFunc, function (err, results) {
+    // err => undefined
+    // results => ['joyent.com', 'github.com']
+});
+```
+
 ### barrier: coordinate multiple concurrent operations
 
 Synopsis: `barrier([args])`
diff --git a/lib/vasync.js b/lib/vasync.js
index ccc3e2a..ab3b3be 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -14,6 +14,9 @@ exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
 exports.pipeline = pipeline;
 exports.forEachPipeline = forEachPipeline;
+exports.filter = filter;
+exports.filterLimit = filterLimit;
+exports.filterSeries = filterSeries;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -250,6 +253,86 @@ function forEachPipeline(args, callback) {
     return (pipeline({'funcs': funcs}, callback));
 }
 
+/*
+ * async.js compatible filter, filterLimit, and filterSeries.  Takes an input
+ * array, optionally a limit, and a single function to filter an array and will
+ * callback with a new filtered array. This is effectively an asynchronous
+ * version of Array.prototype.filter.
+ */
+function filter(inputs, filterFunc, callback) {
+	return (filterLimit(inputs, Infinity, filterFunc, callback));
+}
+
+function filterSeries(inputs, filterFunc, callback) {
+	return (filterLimit(inputs, 1, filterFunc, callback));
+}
+
+function filterLimit(inputs, limit, filterFunc, callback) {
+	mod_assert.ok(Array.isArray(inputs),
+	    '"inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (limit), 'number',
+	    '"limit" must be a number');
+	mod_assert.equal(typeof (filterFunc), 'function',
+	    '"filterFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+	    '"callback" argument must be specified as a function');
+
+	var results = [];
+	var q = queue(processInput, limit);
+
+	function processInput(input, cb) {
+		filterFunc(input.elem, function inputFiltered(err, ans) {
+			/*
+			 * To be consistent with async.js, any error
+			 * encountered will immediately short-circuit the queue
+			 * and callback with an error to the caller.
+			 */
+			if (err) {
+				q.kill();
+				callback(err);
+				return;
+			}
+
+			// store the element and the answer "ans" (truth value).
+			results[input.idx] = {
+				elem: input.elem,
+				ans: !!ans
+			};
+			cb();
+		});
+	}
+
+	q.once('drain', function queueDrained() {
+		/*
+		 * results is now an array of objects in the same order of the
+		 * inputs array, where each object looks like:
+		 *
+		 * {
+		 *     "ans": <true|false>,
+		 *     "elem": <original input element>
+		 * }
+		 *
+		 * we filter out elements that have a false "ans" value, and
+		 * then map the array to contain only the input elements.
+		 */
+		results = results.filter(function filterFalseInputs(input) {
+			return (input.ans);
+		}).map(function mapInputElements(input) {
+			return (input.elem);
+		});
+		callback(null, results);
+	});
+
+	inputs.forEach(function iterateInput(elem, idx) {
+		// we retain the array index to ensure that order is maintained.
+		q.push({
+			elem: elem,
+			idx: idx
+		});
+	});
+
+	return q;
+}
 
 /*
  * async-compatible "queue" function.
diff --git a/tests/filter.js b/tests/filter.js
new file mode 100644
index 0000000..f8f311a
--- /dev/null
+++ b/tests/filter.js
@@ -0,0 +1,95 @@
+/*
+ * Tests the "filterPipeline" and "filterParallel" functions
+ */
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+mod_tap.test('filterSeries', function (test) {
+	var inputs = [0, 1, 2, 3, 4, 5];
+	function filterFunc(input, cb) {
+		cb(null, input < 2 || input === 4);
+	}
+
+	mod_vasync.filterSeries(inputs, filterFunc,
+	    function filterDone(err, results) {
+
+		test.ok(!err, 'error unset');
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
+
+mod_tap.test('filterLimit', function (test) {
+	var inputs = [0, 1, 2, 3, 4, 5];
+	function filterFunc(input, cb) {
+		cb(null, input < 2 || input === 4);
+	}
+
+	mod_vasync.filterLimit(inputs, 2, filterFunc,
+	    function filterDone(err, results) {
+
+		test.ok(!err, 'error unset');
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
+
+mod_tap.test('filter (maintain order)', function (test) {
+	var inputs = [0, 1, 2, 3, 4, 5];
+	function filterFunc(input, cb) {
+		var timeout = Math.floor(Math.random() * 100);
+		setTimeout(function () {
+			cb(null, input < 2 || input === 4);
+		}, timeout);
+	}
+
+	mod_vasync.filter(inputs, filterFunc,
+	    function filterDone(err, results) {
+
+		test.ok(!err, 'error unset');
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
+
+mod_tap.test('filterSeries error handling', function (test) {
+	/*
+	 * We will error half way through the list of inputs to ensure that
+	 * first half are processed while the second half are ignored.
+	 */
+
+	var inputs = [0, 1, 2, 3, 4, 5];
+	function filterFunc(input, cb) {
+		if (input < 3) {
+			cb(null, true);
+		} else {
+			cb(new Error('error on ' + input));
+
+			if (input > 3) {
+				t.ok(false, 'processed too many inputs');
+			}
+		}
+	}
+
+	mod_vasync.filterSeries(inputs, filterFunc,
+	    function filterDone(err, results) {
+
+		test.ok(err, 'error set');
+		test.ok(err.message === 'error on 3', 'error on input 3');
+		test.ok(results === undefined, 'results is unset');
+		test.end();
+	});
+});
