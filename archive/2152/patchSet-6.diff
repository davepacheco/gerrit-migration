commit 442cd8aa980e1e9bcf1a94d278fb5b4b137434c6 (refs/changes/52/2152/6)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-07-18T11:58:59-04:00 (2 years, 3 months ago)
    
    joyent/node-vasync#33 want filterEachPipeline and filterEachParallel

diff --git a/README.md b/README.md
index 170be46..1ac72c7 100644
--- a/README.md
+++ b/README.md
@@ -39,10 +39,14 @@ have several ways of getting at this state:
   parallel (and merge the results)
 * [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):
   invoke the same function on N inputs in parallel
+* [filterParallel](#filterparallel-filter-n-inputs-in-parallel):
+  invoke the same function on N inputs to filter them in parallel
 * [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke
   N functions in series (and stop on failure)
 * [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):
   invoke the same function on N inputs in series (and stop on failure)
+* [filterPipeline](#filterpipeline-filter-n-inputs-in-series):
+  invoke the same function on N inputs to filter them in series
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
   like pipeline, but propagating results between stages
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
@@ -176,6 +180,26 @@ console.log(mod_vasync.forEachParallel({
 }));
 ```
 
+### filterParallel: filter N inputs in parallel
+
+Synopsis: `filterParallel(args, callback)`
+
+This function is exactly like `forEachParallel`, except that the value returned
+in the final callback is an array that contains a subset of the original inputs
+array.  The function is invoked on each input in parallel.  The original inputs
+array given as an argument is not modified.
+
+```js
+mod_vasync.filterParallel({
+    inputs: [0, 1, 2, 3, 4, 5],
+    func: function filterInput(input, cb) {
+        cb(input < 2 || input === 4);
+    }
+}, function (results) {
+    // results => [0, 1, 4]
+});
+```
+
 ### pipeline: invoke N functions in series (and stop on failure)
 
 Synopsis: `pipeline(args, callback)`
@@ -246,6 +270,26 @@ console.log(mod_vasync.forEachPipeline({
 }));
 ```
 
+### filterPipeline: filter N inputs in series
+
+Synopsis: `filterPipeline(args, callback)`
+
+This function is exactly like `forEachPipeline`, except that the value returned
+in the final callback is an array that contains a subset of the original inputs
+array.  The function is invoked on each input in series.  The original inputs
+array given as an argument is not modified.
+
+```js
+mod_vasync.filterPipeline({
+    inputs: [0, 1, 2, 3, 4, 5],
+    func: function filterInput(input, cb) {
+        cb(input < 2 || input === 4);
+    }
+}, function (results) {
+    // results => [0, 1, 4]
+});
+```
+
 ### waterfall: invoke N functions in series, stop on failure, and propagate results
 
 Synopsis: `waterfall(funcs, callback)`
diff --git a/lib/vasync.js b/lib/vasync.js
index ccc3e2a..f81c3db 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -12,8 +12,10 @@ var mod_verror = require('verror');
  */
 exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
+exports.filterParallel = filterParallel;
 exports.pipeline = pipeline;
 exports.forEachPipeline = forEachPipeline;
+exports.filterPipeline = filterPipeline;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -250,6 +252,59 @@ function forEachPipeline(args, callback) {
     return (pipeline({'funcs': funcs}, callback));
 }
 
+/*
+ * Analogous to async.filter or async.filterSeries, this takes an input array
+ * and a single function to filter an array, and will callback with a new
+ * filtered array. This is effectively an asynchronous version of
+ * Array.prototype.filter. "args" must have the following fields:
+ *
+ *	func		asynchronous function to invoke on each input value
+ *			that calls back with true or false
+ *	inputs		array of input values
+ */
+function filterPipeline(args, callback) {
+	return (filter(forEachPipeline, args, callback));
+}
+
+function filterParallel(args, callback) {
+	return (filter(forEachParallel, args, callback));
+}
+
+/* private */
+function filter(vasyncFunc, args, callback) {
+	mod_assert.equal(typeof (vasyncFunc), 'function',
+			'"vasyncFunc" must be a function');
+	mod_assert.equal(typeof (args), 'object',
+			'"args" must be an object');
+	mod_assert.ok(Array.isArray(args.inputs),
+			'"args.inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (args.func), 'function',
+			'"args.func" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+			'"callback" argument must be specified as a function');
+
+	return (vasyncFunc({
+		inputs: args.inputs,
+		func: function iterateSingleInput(input, cb) {
+			args.func(input, function filterSingleInput(ans) {
+				var obj = {
+					input: input,
+					ans: !!ans
+				};
+
+				cb(null, obj);
+			});
+		}
+	}, function filterResultsReady(err, results) {
+		var ret = [];
+		results.operations.forEach(function (op) {
+			if (op.result.ans) {
+				ret.push(op.result.input);
+			}
+		});
+		callback(ret);
+	}));
+}
 
 /*
  * async-compatible "queue" function.
diff --git a/tests/filter.js b/tests/filter.js
new file mode 100644
index 0000000..cbf8354
--- /dev/null
+++ b/tests/filter.js
@@ -0,0 +1,57 @@
+/*
+ * Tests the "filterPipeline" and "filterParallel" functions
+ */
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+mod_tap.test('filterPipeline', function (test) {
+	mod_vasync.filterPipeline({
+		inputs: [0, 1, 2, 3, 4, 5],
+		func: function filterPipelineSingleInput(input, cb) {
+			cb(input < 2 || input === 4);
+		}
+	}, function filterPipelineDone(results) {
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
+
+mod_tap.test('filterParallel', function (test) {
+	mod_vasync.filterParallel({
+		inputs: [0, 1, 2, 3, 4, 5],
+		func: function filterParallelSingleInput(input, cb) {
+			cb(input < 2 || input === 4);
+		}
+	}, function filterParallelDone(results) {
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
+
+mod_tap.test('filterParallel maintain order', function (test) {
+	mod_vasync.filterParallel({
+		inputs: [0, 1, 2, 3, 4, 5],
+		func: function filterParallelSingleInput(input, cb) {
+			var timeout = Math.floor(Math.random() * 100);
+			setTimeout(function () {
+				cb(input < 2 || input === 4);
+			}, timeout);
+		}
+	}, function filterParallelDone(results) {
+		test.ok(Array.isArray(results), 'results is an array');
+		test.ok(results.length === 3, 'results length is 3');
+		test.ok(results[0] === 0, 'result[0] === 0');
+		test.ok(results[1] === 1, 'result[1] === 1');
+		test.ok(results[2] === 4, 'result[2] === 4');
+		test.end();
+	});
+});
