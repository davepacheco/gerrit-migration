From 7c46751ac9ccc41610c35680bf4bd541981fb1aa Mon Sep 17 00:00:00 2001
From: Jared Morrow <jm@joyent.com>
Date: Wed, 23 May 2018 08:31:00 -0600
Subject: [PATCH] MANTA-3730 Add event port support to HAProxy 1.8.8

---
 Makefile               |  14 +-
 VERSION                |   2 +-
 doc/configuration.txt  |  11 +-
 doc/haproxy.1          |   8 +-
 include/types/global.h |  17 +-
 src/cfgparse.c         |  17 +-
 src/ev_evports.c       | 375 +++++++++++++++++++++++++++++++++++++++++
 src/haproxy.c          |  13 ++
 8 files changed, 436 insertions(+), 21 deletions(-)
 create mode 100644 src/ev_evports.c

diff --git a/Makefile b/Makefile
index 5d170041..ef782ef8 100644
--- a/Makefile
+++ b/Makefile
@@ -38,6 +38,7 @@
 #   USE_SLZ              : enable slz library instead of zlib (pick at most one).
 #   USE_CPU_AFFINITY     : enable pinning processes to CPU on Linux. Automatic.
 #   USE_TFO              : enable TCP fast open. Supported on Linux >= 3.7.
+#   USE_EVPORTS          : enable event ports on SunOS systems. Automatic.
 #   USE_NS               : enable network namespace support. Supported on Linux >= 2.6.24.
 #   USE_DL               : enable it if your system requires -ldl. Automatic on Linux.
 #   USE_DEVICEATLAS      : enable DeviceAtlas api.
@@ -310,7 +311,8 @@ ifeq ($(TARGET),solaris)
   # This is for Solaris 8
   # We also enable getaddrinfo() which works since solaris 8.
   USE_POLL       = implicit
-  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT -D_XOPEN_SOURCE=500 -D__EXTENSIONS__
+  USE_EVPORTS    = implicit
+  TARGET_CFLAGS  = -fno-omit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT -D_XOPEN_SOURCE=500 -D__EXTENSIONS__
   TARGET_LDFLAGS = -lnsl -lsocket
   USE_TPROXY     = implicit
   USE_LIBCRYPT    = implicit
@@ -364,7 +366,7 @@ ifeq ($(TARGET),aix52)
 else
 ifeq ($(TARGET),cygwin)
   # This is for Cygwin
-  # Cygwin adds IPv6 support only in version 1.7 (in beta right now). 
+  # Cygwin adds IPv6 support only in version 1.7 (in beta right now).
   USE_POLL   = implicit
   USE_TPROXY = implicit
   TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )
@@ -447,7 +449,7 @@ OPTIONS_OBJS    =
 BUILD_OPTIONS =
 
 # Return USE_xxx=$(USE_xxx) unless $(USE_xxx) = "implicit"
-# Usage: 
+# Usage:
 #   BUILD_OPTIONS += $(call ignore_implicit,USE_xxx)
 ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))
 
@@ -521,6 +523,12 @@ OPTIONS_CFLAGS += -DUSE_MY_EPOLL
 BUILD_OPTIONS  += $(call ignore_implicit,USE_MY_EPOLL)
 endif
 
+ifneq ($(USE_EVPORTS),)
+OPTIONS_CFLAGS += -DENABLE_EVPORTS
+OPTIONS_OBJS   += src/ev_evports.o
+BUILD_OPTIONS  += $(call ignore_implicit,USE_EVPORTS)
+endif
+
 ifneq ($(USE_KQUEUE),)
 OPTIONS_CFLAGS += -DENABLE_KQUEUE
 OPTIONS_OBJS   += src/ev_kqueue.o
diff --git a/VERSION b/VERSION
index 1790d359..39c9450d 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-1.8.8
+1.8.8-joyent1
diff --git a/doc/configuration.txt b/doc/configuration.txt
index 03130583..b65bc10f 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -610,6 +610,7 @@ The following keywords are supported in the "global" section :
    - maxsslrate
    - maxzlibmem
    - noepoll
+   - noevports
    - nokqueue
    - nopoll
    - nosplice
@@ -1339,6 +1340,13 @@ noepoll
   equivalent to the command-line argument "-de". The next polling system
   used will generally be "poll". See also "nopoll".
 
+
+noevports
+  Disables the use of the event ports event polling system on SunOS systems
+  derived from Solaris 10 and later. It is equivalent to the command-line
+  argument "-dv". The next polling system used will generally be "poll". See
+  also "nopoll".
+
 nokqueue
   Disables the use of the "kqueue" event polling system on BSD. It is
   equivalent to the command-line argument "-dk". The next polling system
@@ -1348,7 +1356,8 @@ nopoll
   Disables the use of the "poll" event polling system. It is equivalent to the
   command-line argument "-dp". The next polling system used will be "select".
   It should never be needed to disable "poll" since it's available on all
-  platforms supported by HAProxy. See also "nokqueue" and "noepoll".
+  platforms supported by HAProxy. See also "nokqueue" and "noepoll", and
+  "noevports".
 
 nosplice
   Disables the use of kernel tcp splicing between sockets on Linux. It is
diff --git a/doc/haproxy.1 b/doc/haproxy.1
index 91f58a3b..e41e1bfc 100644
--- a/doc/haproxy.1
+++ b/doc/haproxy.1
@@ -1,4 +1,4 @@
-.TH HAPROXY 1 "17 August 2007" 
+.TH HAPROXY 1 "17 August 2007"
 
 .SH NAME
 
@@ -104,6 +104,11 @@ in daemon mode.
 \fB\-dk\fP
 Disable use of \fBkqueue\fP(2). \fBkqueue\fP(2) is available only on BSD systems.
 
+.TP
+\fB\-dv\fP
+Disable use of event ports. Event ports are available only on SunOS systems
+derived from Solaris 10 and later (including illumos systems).
+
 .TP
 \fB\-ds\fP
 Disable use of speculative \fBepoll\fP(7). \fBepoll\fP(7) is available only on
@@ -202,4 +207,3 @@ systems, you can find this file in /usr/share/doc/haproxy/configuration.txt.gz.
 .SH AUTHOR
 
 HAProxy was written by Willy Tarreau. This man page was written by Arnaud Cornet and Willy Tarreau.
-
diff --git a/include/types/global.h b/include/types/global.h
index bd7761cd..2ac78f3f 100644
--- a/include/types/global.h
+++ b/include/types/global.h
@@ -58,15 +58,16 @@
 #define GTUNE_USE_POLL           (1<<1)
 #define GTUNE_USE_EPOLL          (1<<2)
 #define GTUNE_USE_KQUEUE         (1<<3)
+#define GTUNE_USE_EVPORTS        (1<<4)
 /* platform-specific options */
-#define GTUNE_USE_SPLICE         (1<<4)
-#define GTUNE_USE_GAI            (1<<5)
-#define GTUNE_USE_REUSEPORT      (1<<6)
-#define GTUNE_RESOLVE_DONTFAIL   (1<<7)
-
-#define GTUNE_SOCKET_TRANSFER	 (1<<8)
-#define GTUNE_NOEXIT_ONFAILURE   (1<<9)
-#define GTUNE_USE_SYSTEMD        (1<<10)
+#define GTUNE_USE_SPLICE         (1<<5)
+#define GTUNE_USE_GAI            (1<<6)
+#define GTUNE_USE_REUSEPORT      (1<<7)
+#define GTUNE_RESOLVE_DONTFAIL   (1<<8)
+
+#define GTUNE_SOCKET_TRANSFER    (1<<9)
+#define GTUNE_NOEXIT_ONFAILURE   (1<<10)
+#define GTUNE_USE_SYSTEMD        (1<<11)
 
 /* Access level for a stats socket */
 #define ACCESS_LVL_NONE     0
diff --git a/src/cfgparse.c b/src/cfgparse.c
index 5a460381..64244607 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -744,6 +744,11 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 			goto out;
 		global.tune.options &= ~GTUNE_USE_KQUEUE;
 	}
+	else if (!strcmp(args[0], "noevports")) {
+		if (alertif_too_many_args(0, file, linenum, args, &err_code))
+			goto out;
+		global.tune.options &= ~GTUNE_USE_EVPORTS;
+	}
 	else if (!strcmp(args[0], "nopoll")) {
 		if (alertif_too_many_args(0, file, linenum, args, &err_code))
 			goto out;
@@ -1897,7 +1902,7 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 				}
 			}
 		}
-		
+
 		ha_alert("parsing [%s:%d] : unknown keyword '%s' in '%s' section\n", file, linenum, args[0], "global");
 		err_code |= ERR_ALERT | ERR_FATAL;
 	}
@@ -4883,7 +4888,7 @@ stats_error_parsing:
 					reqlen += strlen(args[4]);
 				else
 					reqlen += strlen("HTTP/1.0");
-		    
+
 				curproxy->check_req = malloc(reqlen);
 				curproxy->check_len = snprintf(curproxy->check_req, reqlen,
 							       "%s %s %s\r\n", args[2], args[3], *args[4]?args[4]:"HTTP/1.0");
@@ -5192,7 +5197,7 @@ stats_error_parsing:
 			int cur_arg;
 
 			/* insert x-forwarded-for field, but not for the IP address listed as an except.
-			 * set default options (ie: bitfield, header name, etc) 
+			 * set default options (ie: bitfield, header name, etc)
 			 */
 
 			curproxy->options |= PR_O_FWDFOR | PR_O_FF_ALWAYS;
@@ -6223,7 +6228,7 @@ stats_error_parsing:
 				goto out;
 
 			}
-	    
+
 			logsrv->level = 7; /* max syslog level = debug */
 			if (*(args[arg+3])) {
 				logsrv->level = get_log_level(args[arg+3]);
@@ -6292,7 +6297,7 @@ stats_error_parsing:
 			goto out;
 		}
 
-		/* we must first clear any optional default setting */	
+		/* we must first clear any optional default setting */
 		curproxy->conn_src.opts &= ~CO_SRC_TPROXY_MASK;
 		free(curproxy->conn_src.iface_name);
 		curproxy->conn_src.iface_name = NULL;
@@ -6663,7 +6668,7 @@ stats_error_parsing:
 			err_code |= ERR_ALERT | ERR_FATAL;
 			goto out;
 		}
-	
+
 		if ((strcmp(args[2], "if") == 0 || strcmp(args[2], "unless") == 0)) {
 			if ((cond = build_acl_cond(file, linenum, &curproxy->acl, curproxy, (const char **)args+2, &errmsg)) == NULL) {
 				ha_alert("parsing [%s:%d] : error detected while parsing a '%s' condition : %s.\n",
diff --git a/src/ev_evports.c b/src/ev_evports.c
new file mode 100644
index 00000000..b9556ed3
--- /dev/null
+++ b/src/ev_evports.c
@@ -0,0 +1,375 @@
+/*
+ * FD polling functions for SunOS event ports.
+ *
+ * Copyright 2018 Joyent, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ * The assertions in this file are cheap and we always want them enabled.
+ */
+#ifdef NDEBUG
+#undef NDEBUG
+#include <assert.h>
+#define NDEBUG
+#else
+#include <assert.h>
+#endif
+
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <poll.h>
+#include <port.h>
+#include <errno.h>
+#include <syslog.h>
+
+#include <common/compat.h>
+#include <common/config.h>
+#include <common/ticks.h>
+#include <common/time.h>
+
+#include <types/global.h>
+
+#include <proto/fd.h>
+#include <proto/log.h>
+
+/*
+ * Private data:
+ */
+static int evports_fd = -1;
+static port_event_t *evports_evlist = NULL;
+static int evports_evlist_max = 0;
+static int volatile evports_panic_errno = 0;
+
+/*
+ * Convert the "state" member of "fdtab" into an event ports event mask.
+ */
+static int evports_state_to_events(int state)
+{
+	int events = 0;
+
+	if (state & FD_EV_POLLED_W)
+		events |= POLLOUT;
+	if (state & FD_EV_POLLED_R)
+		events |= POLLIN;
+
+	return (events);
+}
+
+/*
+ * Associate or dissociate this file descriptor with the event port, using the
+ * specified event mask.  We are strict with failures, to ensure that we're not
+ * doing extra work.
+ */
+static void evports_resync_fd(int fd, int events)
+{
+	if (events == 0) {
+		if (port_dissociate(evports_fd, PORT_SOURCE_FD, fd) != 0) {
+			evports_panic_errno = errno;
+			send_log(NULL, LOG_EMERG,
+			    "port_dissociate failure: fd %d: %s\n",
+			    fd, strerror(errno));
+			abort();
+		}
+	} else {
+		if (port_associate(evports_fd, PORT_SOURCE_FD, fd, events,
+		    NULL) != 0) {
+			evports_panic_errno = errno;
+			send_log(NULL, LOG_EMERG,
+			    "port_associate failure: fd %d: %s\n",
+			    fd, strerror(errno));
+			abort();
+		}
+	}
+}
+
+/*
+ * Event Ports poller.  This routine interacts with the file descriptor
+ * management data structures and routines; see the large block comment in
+ * "src/fd.c" for more information.
+ */
+REGPRM2 static void evports_do_poll(struct poller *p, int exp)
+{
+	int i;
+	int wait_time;
+	struct timespec timeout;
+	int r;
+	int e = 0;
+	unsigned int nevlist;
+	int interrupted = 0;
+
+	/*
+	 * Scan the list of file descriptors with an updated status:
+	 */
+	for (i = 0; i < fd_nbupdt; i++) {
+		int stateold, statenew;
+		int fd = fd_updt[i];
+
+		HA_SPIN_LOCK(FD_LOCK, &fdtab[fd].lock);
+		fdtab[fd].update_mask &= ~tid_bit;
+
+		if (fdtab[fd].owner == NULL) {
+		    activity[tid].poll_drop++;
+		    HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+		    continue;
+		}
+
+		fdtab[fd].new = 0;
+
+		stateold = fdtab[fd].state;
+		statenew = fd_compute_new_polled_status(stateold);
+		fdtab[fd].state = statenew;
+		HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+
+		/*
+		 * Check if the poll status has changed.  If it has, we need to
+		 * reassociate now to update the event mask for this file
+		 * descriptor.
+		 */
+		if ((stateold & FD_EV_POLLED_RW) !=
+		    (statenew & FD_EV_POLLED_RW)) {
+			int events;
+			HA_SPIN_LOCK(POLL_LOCK, &poll_lock);
+			events = evports_state_to_events(statenew);
+			evports_resync_fd(fd, events);
+			fdtab[fd].state = statenew;
+			HA_SPIN_UNLOCK(POLL_LOCK, &poll_lock);
+		}
+	}
+	fd_nbupdt = 0;
+
+	/*
+	 * Determine how long to wait for events to materialise on the port.
+	 */
+	if (!exp) {
+		wait_time = MAX_DELAY_MS;
+	} else if (tick_is_expired(exp, now_ms)) {
+		activity[tid].poll_exp++;
+		wait_time = 0;
+	} else {
+		wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
+		if (wait_time > MAX_DELAY_MS) {
+			wait_time = MAX_DELAY_MS;
+		}
+	}
+
+	timeout.tv_sec = wait_time / 1000;
+	timeout.tv_nsec = (wait_time % 1000) * 1000000;
+
+	gettimeofday(&before_poll, NULL);
+	nevlist = 1;
+	if ((r = port_getn(evports_fd, evports_evlist, evports_evlist_max,
+	    &nevlist, &timeout)) != 0) {
+		switch (e = errno) {
+		case ETIME:
+			/*
+			 * Though the manual page has not historically made it
+			 * clear, port_getn() can return -1 with an errno of
+			 * ETIME and still have returned some number of events.
+			 */
+			e = 0;
+			r = 0;
+			if (nevlist == 0)
+				interrupted = 1;
+			break;
+
+		case EINTR:
+			nevlist = 0;
+			interrupted = 1;
+			break;
+
+		default:
+			evports_panic_errno = e;
+			send_log(NULL, LOG_EMERG,
+			    "port_getn failure: fd %d: %s\n",
+			    evports_fd, strerror(e));
+			abort();
+		}
+	}
+	tv_update_date(wait_time, interrupted);
+	measure_idle();
+
+	for (i = 0; i < nevlist; i++) {
+		unsigned int n = 0;
+                int fd, events, rebind_events;
+		fd = evports_evlist[i].portev_object;
+		events = evports_evlist[i].portev_events;
+
+		if (fdtab[fd].owner == NULL) {
+			activity[tid].poll_dead++;
+			continue;
+		}
+
+		/*
+		 * By virtue of receiving an event for this file descriptor, it
+		 * is no longer associated with the port in question.  Store
+		 * the previous event mask so that we may reassociate after
+		 * processing is complete.
+		 */
+		rebind_events = evports_state_to_events(fdtab[fd].state);
+		assert(rebind_events != 0);
+
+		/*
+		 * Set bits based on the events we received from the port:
+		 */
+		n &= FD_POLL_STICKY;
+		if (events & POLLIN)
+			n |= FD_POLL_IN;
+		if (events & POLLOUT)
+			n |= FD_POLL_OUT;
+		if (events & POLLERR)
+			n |= FD_POLL_ERR;
+		if (events & POLLHUP)
+			n |= FD_POLL_HUP;
+
+		/*
+		 * Call connection processing callbacks.  Note that it's
+		 * possible for this processing to alter the required event
+		 * port assocation; i.e., the "state" member of the "fdtab"
+		 * entry.  If it changes, the fd will be placed on the updated
+		 * list for processing the next time we are called.
+		 */
+		fd_update_events(fd, n);
+
+		/*
+		 * This file descriptor was closed during the processing of
+		 * polled events.  No need to reassociate.
+		 */
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		/*
+		 * Reassociate with the port, using the same event mask as
+		 * before.  This call will not result in a dissociation as we
+		 * asserted that _some_ events needed to be rebound above.
+		 *
+		 * Reassociating with the same mask allows us to mimic the
+		 * level-triggered behaviour of poll(2).  In the event that we
+		 * are interested in the same events on the next turn of the
+		 * loop, this represents no extra work.
+		 *
+		 * If this additional port_associate(3C) call becomes a
+		 * performance problem, we would need to verify that we can
+		 * correctly interact with the file descriptor cache and update
+		 * list (see "src/fd.c") to avoid reassociating here, or to use
+		 * a different events mask.
+		 */
+		evports_resync_fd(fd, rebind_events);
+	}
+}
+
+/*
+ * Initialisation of the event ports poller.
+ * Returns 0 in case of failure, non-zero in case of success.
+ */
+REGPRM1 static int evports_do_init(struct poller *p)
+{
+	p->private = NULL;
+
+	evports_evlist_max = global.tune.maxpollevents;
+	evports_evlist = calloc(evports_evlist_max, sizeof (port_event_t));
+	if (evports_evlist == NULL) {
+		goto fail;
+	}
+
+	if ((evports_fd = port_create()) == -1) {
+		goto fail;
+	}
+
+	return 1;
+
+fail:
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+	return 0;
+}
+
+/*
+ * Termination of the event ports poller.
+ * All resources are released and the poller is marked as inoperative.
+ */
+REGPRM1 static void evports_do_term(struct poller *p)
+{
+	if (evports_fd != -1) {
+		assert(close(evports_fd) == 0);
+		evports_fd = -1;
+	}
+
+	p->private = NULL;
+	p->pref = 0;
+
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+}
+
+/*
+ * Run-time check to make sure we can allocate the resources needed for
+ * the poller to function correctly.
+ * Returns 1 on success, otherwise 0.
+ */
+REGPRM1 static int evports_do_test(struct poller *p)
+{
+	int fd;
+
+	if ((fd = port_create()) == -1) {
+		return 0;
+	}
+
+	assert(close(fd) == 0);
+	return 1;
+}
+
+/*
+ * Close and recreate the event port after fork().  Returns 1 on success,
+ * otherwise 0.  If this function fails, "evports_do_term()" must be called to
+ * clean up the poller.
+ */
+REGPRM1 static int evports_do_fork(struct poller *p)
+{
+	if (evports_fd != -1) {
+		assert(close(evports_fd) == 0);
+	}
+
+	if ((evports_fd = port_create()) == -1) {
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * This constructor must be called before main() to register the event ports
+ * poller.
+ */
+__attribute__((constructor))
+static void evports_do_register(void)
+{
+	struct poller *p;
+
+	if (nbpollers >= MAX_POLLERS)
+		return;
+
+	assert(evports_fd == -1);
+	assert(evports_evlist == NULL);
+	assert(evports_evlist_max == 0);
+
+	p = &pollers[nbpollers++];
+
+	p->name = "evports";
+	p->pref = 300;
+	p->private = NULL;
+
+	p->init = evports_do_init;
+	p->term = evports_do_term;
+	p->test = evports_do_test;
+	p->fork = evports_do_fork;
+	p->poll = evports_do_poll;
+}
diff --git a/src/haproxy.c b/src/haproxy.c
index 4628d829..265d1721 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -426,6 +426,9 @@ static void usage(char *name)
 #if defined(ENABLE_KQUEUE)
 		"        -dk disables kqueue() usage even when available\n"
 #endif
+#if defined(ENABLE_EVPORTS)
+		"        -dv disables event ports usage even when available\n"
+#endif
 #if defined(ENABLE_POLL)
 		"        -dp disables poll() usage even when available\n"
 #endif
@@ -1340,6 +1343,9 @@ static void init(int argc, char **argv)
 #if defined(ENABLE_KQUEUE)
 	global.tune.options |= GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+	global.tune.options |= GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 	global.tune.options |= GTUNE_USE_SPLICE;
 #endif
@@ -1384,6 +1390,10 @@ static void init(int argc, char **argv)
 			else if (*flag == 'd' && flag[1] == 'k')
 				global.tune.options &= ~GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+			else if (*flag == 'd' && flag[1] == 'v')
+				global.tune.options &= ~GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 			else if (*flag == 'd' && flag[1] == 'S')
 				global.tune.options &= ~GTUNE_USE_SPLICE;
@@ -1908,6 +1918,9 @@ static void init(int argc, char **argv)
 	if (!(global.tune.options & GTUNE_USE_KQUEUE))
 		disable_poller("kqueue");
 
+	if (!(global.tune.options & GTUNE_USE_EVPORTS))
+		disable_poller("evports");
+
 	if (!(global.tune.options & GTUNE_USE_EPOLL))
 		disable_poller("epoll");
 
-- 
2.21.0

