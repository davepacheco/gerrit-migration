commit 0fdbccead93d36d3c924479e65d539d2f915ca9c (refs/changes/27/4727/7)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-08-23T21:14:36+00:00 (1 year, 2 months ago)
    
    MORAY-420 Moray's database setup logic in boot/setup.sh is brittle

diff --git a/Makefile b/Makefile
index 46aefb5..36d406c 100644
--- a/Makefile
+++ b/Makefile
@@ -32,7 +32,7 @@ JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSSTYLE_FLAGS    = -C -f ./tools/jsstyle.conf
-SMF_MANIFESTS_IN = smf/manifests/haproxy.xml.in
+SMF_MANIFESTS_IN =	smf/manifests/haproxy.xml.in
 BOOTSTRAP_MANIFESTS = 	sapi_manifests/registrar/template \
 			sdc/sapi_manifests/registrar/template
 
@@ -108,6 +108,7 @@ release: all docs $(SMF_MANIFESTS) $(BOOTSTRAP_MANIFESTS)
 		$(ROOT)/build \
 		$(ROOT)/lib \
 		$(ROOT)/main.js \
+		$(ROOT)/pg-setup.js \
 		$(ROOT)/node_modules \
 		$(ROOT)/package.json \
 		$(ROOT)/sapi_manifests \
diff --git a/boot/setup.sh b/boot/setup.sh
index 5477f9d..84b2695 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -153,6 +153,14 @@ function setup_moray {
         fatal "unable to import haproxy"
     svcadm enable "manta/haproxy" || fatal "unable to start haproxy"
 
+    sed -e "s#@@MORAY_FLAVOR@@#$FLAVOR#g" \
+        $SVC_ROOT/smf/manifests/pg-setup.xml.in > \
+        $SVC_ROOT/smf/manifests/pg-setup.xml
+
+    svccfg import $SVC_ROOT/smf/manifests/pg-setup.xml || \
+        fatal "unable to import pg-setup"
+    svcadm enable "smartdc/pg-setup" || fatal "unable to start pg-setup"
+
     #moray instances
     local moray_xml_in=$SVC_ROOT/smf/manifests/moray.xml.in
     for (( i=1; i<=$moray_instances; i++ )); do
@@ -204,72 +212,6 @@ function sdc_moray_setup {
 
 }
 
-function manta_set_moray_role_connlimit {
-    # Having 18 reserve connections ensures that the maximum possible number of
-    # Moray postgres connections does not exceed the imposed "moray"
-    # rolconnlimit in any of the default deployment sizes: coal, lab,
-    # production.
-    #
-    #       pg_max_conns  procs_per_zone      num_zones  max_conns_per_proc
-    # coal  100           1                   1          16
-    # lab   210           4                   3          16
-    # prod  1000          4                   3          16
-    #
-    # pg_max_conns - the default value of the postgres parameter
-    # max_connections set in postgres.conf for each deployment size.
-    #
-    # procs_per_zone - the default number of processes per Moray zone for the
-    # given deployment size.
-    #
-    # num_zones - the default number of Moray zones per shard for the
-    # deployment size.
-    #
-    # max_conns_per_proc - the default value of the SAPI tunable
-    # MORAY_MAX_PG_CONNS.
-    #
-    # Reserving 18 connections imposes an upper bound of 82, 192, and 982 moray
-    # role connections in coal, lab, and production deployments. These upper
-    # bounds are fine because with their default configurations, coal, lab, and
-    # production deployment Morays may have (in aggregate) a maximum of 16,
-    # 192, and 192 total connections to postgres, respectively.
-    local pg_max_conns
-    local rolconnlimit
-    local sql
-
-    local reserve_conns=18
-    local primary_ip="$1"
-
-    pg_max_conns=$(psql -t -P format=unaligned -U postgres -h "$primary_ip" \
-            -p 5432 -c 'SHOW max_connections')
-    if [[ $? -ne 0 ]]; then
-        warn "Unable to retrieve postgres max_connections. " \
-             "Role property \'rolconnlimit\' not applied to \'moray\'."
-        return
-    fi
-
-    if ! [[ $pg_max_conns =~ ^[0-9]+$ ]]; then
-        warn "Maximum allowed postgres connections value ($pg_max_conns) is " \
-             "not a positive integer. Role property \'rolconnlimit\' not " \
-             "applied to \'moray\'."
-        return
-    fi
-
-    if [[ $pg_max_conns -le $reserve_conns ]]; then
-        warn "Maximum allowed postgres connections ($pg_max_conns) is lower" \
-             "than the number of reserve connections ($reserve_conns). Role " \
-             "property \'rolconnlimit\' not applied to \'moray\'."
-        return
-    fi
-
-    rolconnlimit="$(($pg_max_conns - $reserve_conns))"
-    sql="ALTER ROLE $PG_USER WITH CONNECTION LIMIT $rolconnlimit"
-    psql -U postgres -h $primary_ip -p 5432 -c "$sql"
-    if [[ $? -ne 0 ]]; then
-        warn "Unable to set \'moray\' role property rolconnlimit\'."
-        return
-    fi
-}
-
 function manta_setup_moray_config {
     #.bashrc
     echo 'function req() { grep "$@" `svcs -L moray` | bunyan ;}' >> $PROFILE
@@ -281,213 +223,8 @@ function manta_setup_moray_config {
     local moray_cfg=$SVC_ROOT/etc/config.json
     local svc_name=$(json -f ${METADATA} SERVICE_NAME)
     [[ $? -eq 0 ]] || fatal "Unable to retrieve service name"
-    local primary_ip=`/opt/smartdc/moray/node_modules/node-manatee/bin/manatee-primary-ip $moray_cfg`
-    [[ $? -eq 0 ]] || fatal "Unable to retrieve postgres primary ip"
-
-    # create the moray user which isn't a super user but can create tables and
-    # can't create rolse. Creating the user will fail if the user alredy
-    # exists, so we don't check error, subsequent pg requests will fail with
-    # this user if it dne.
-    createuser -U postgres -h $primary_ip -p 5432 -d -S -R $PG_USER
-    manta_set_moray_role_connlimit $primary_ip
-
-    # Postgres sucks at return codes, so we basically have no choice but to
-    # ignore the error code here since we can't conditionally create the DB
-    createdb -h $primary_ip -p 5432 -U $PG_USER -T template0 --locale=C moray
-    psql -U $PG_USER -h $primary_ip -p 5432 \
-        -c 'CREATE TABLE IF NOT EXISTS buckets_config (name text PRIMARY KEY, index text NOT NULL, pre text NOT NULL, post text NOT NULL, options text, mtime timestamp without time zone DEFAULT now() NOT NULL);' \
-        moray
-    [[ $? -eq 0 ]] || fatal "Unable to create moray database"
-
-    echo "alias manatee-stat='/opt/smartdc/moray/node_modules/.bin/manatee-stat -s $svc_name -p $zk'" >> $PROFILE
-    echo "alias psql='/opt/local/bin/psql -h $primary_ip -U $PG_USER moray'" >> $PROFILE
-}
-
-function sdc_moray_createdb {
-
-    local moray_cfg=$SVC_ROOT/etc/config.json
-    local shard_name=$(json -f ${METADATA} manatee_shard)
-    [[ $? -eq 0 ]] || fatal "Unable to retrieve shard name"
-
-    # Try to connect to manatee PostgreSQL instance. If we can connect, create the
-    # moray db when required. If we cannot connect after 10 retries, fail and exit.
-    #
-    # FIXME: Actually, we're manually overriding manatee's PG Password and setting
-    # the PG user to the default one. These should be configuration values:
-    POSTGRES_HOST=`/opt/smartdc/moray/node_modules/node-manatee/bin/manatee-primary-ip $moray_cfg`
-    [[ $? -eq 0 ]] || fatal "Unable to retrieve postgres primary ip"
-    POSTGRES_PW='PgresPass123'
-    for i in 0 1 2 3 4 5 6 7 8 9
-    do
-        if ! PGPASSWORD=PgresPass123 /opt/local/bin/psql -U postgres \
-            -h ${POSTGRES_HOST} -c "\l" 2>/dev/null; then
-            sleep 5
-            if [[ "$i" == "9" ]]; then
-                echo "Connecting to manatee PostgreSQL failed. Exiting."
-                exit 1
-            else
-                continue
-            fi
-        else
-          if [[ -z $(PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-              -U postgres \
-              -h ${POSTGRES_HOST} -c "\l"|grep $role) ]]; then
-                echo "Creating $role database"
-                PGPASSWORD=PgresPass123 /opt/local/bin/createdb \
-                    -U postgres \
-                    -T template0 --locale=C \
-                    -h ${POSTGRES_HOST} $role
-              if [[ -z $(PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-                    -U postgres \
-                    -h ${POSTGRES_HOST} ${role} -c "\dt"|grep buckets_config) ]]; then
-                  echo "Creating table buckets_config"
-                  PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-                    -U postgres \
-                    -h ${POSTGRES_HOST} $role -c "CREATE TABLE buckets_config (
-                        name text PRIMARY KEY,
-                        index text NOT NULL,
-                        pre text NOT NULL,
-                        post text NOT NULL,
-                        options text,
-                        mtime timestamp without time zone DEFAULT now() NOT NULL
-                    );"
-                  break
-              else
-                  break
-              fi
-          else
-              break
-          fi
-        fi
-    done
-    # MORAY-156: Create "moray" user and grant all privileges into "moray"
-    # database. This way we can upgrade existing setups and switch to
-    # "moray" user instead of "postgres"
-    if [[ -z $(PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-      -U postgres \
-      -h ${POSTGRES_HOST} ${role} -c "\du"|grep ${role}) ]]; then
-      echo "User ${role} does not exist. Creating it"
-      /opt/local/bin/createuser -U postgres -h ${POSTGRES_HOST} -d -S -R $PG_USER
-    else
-      echo "User ${role} already exists."
-    fi
-
-    # We can safely execute this as many times as we want to:
-    PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-      -U postgres \
-      -h ${POSTGRES_HOST} ${role} \
-      -c "GRANT ALL PRIVILEGES ON DATABASE $role to $role;">/dev/null
-    PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-      -U postgres \
-      -h ${POSTGRES_HOST} ${role} \
-      -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $role;">/dev/null
-    PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-      -U postgres \
-      -h ${POSTGRES_HOST} ${role} \
-      -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $role;">/dev/null
-    # The following is needed in order to be able to update buckets:
-    PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-      -U postgres \
-      -h ${POSTGRES_HOST} \
-      -c 'alter database moray owner to moray;' moray
-
-    for tbl in `PGPASSWORD=PgresPass123 /opt/local/bin/psql -h ${POSTGRES_HOST} -U postgres -qAt -c "select tablename from pg_tables where schemaname = 'public' and tableowner != 'moray';" moray`; do
-      PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-        -h ${POSTGRES_HOST} \
-        -U postgres \
-        -c "alter table $tbl owner to moray" moray;>/dev/null
-    done
-
-    for tbl in `PGPASSWORD=PgresPass123 /opt/local/bin/psql -h ${POSTGRES_HOST} -U postgres -qAt -c "SELECT iss.sequence_name FROM pg_class pgc, information_schema.sequences iss, pg_user pgu WHERE pgu.usesysid = pgc.relowner AND pgu.usename != 'moray' AND pgc.relname = iss.sequence_name AND iss.sequence_schema = 'public' AND pgc.relkind = 'S';" moray`; do
-      PGPASSWORD=PgresPass123 /opt/local/bin/psql \
-        -U postgres \
-        -h ${POSTGRES_HOST} \
-        -c "alter table $tbl owner to moray" moray;>/dev/null
-    done
-
-}
-
-
-#
-# ensure_manatee: waits up to about 90 seconds for the zookeeper cluster
-# to come online and for the local manatee cluster to come online.  It's a fatal
-# error if this doesn't happen within the alloted timeout.
-#
-function ensure_manatee {
-    local SHARD_KEY=$1
-
-    [[ -n ${SHARD_KEY} ]] || fatal "ensure_manatee: must specify shard key!"
-
-    local attempt=0
-    local isok=0
-    local pgok
-    local zkok
-
-    local zonename=$(zonename)
-
-    local shard=$(json -f ${METADATA} ${SHARD_KEY})
-    local zk_ips=$(json -f ${METADATA} ZK_HA_SERVERS | json -d: -a host port \
-        | tr '\n' ',')
-
-    if [[ -z ${zk_ips} ]]; then
-        zk_ips=$(json -f ${METADATA} ZK_SERVERS | json -d: -a host port \
-            | tr '\n' ',')
-    fi
-
-    if [[ $? -ne 0 ]] ; then
-        zk_ips=127.0.0.1
-    fi
-
-    while [[ $attempt -lt 90 ]]; do
-        if /opt/smartdc/moray/node_modules/.bin/manatee-adm pg-status \
-            -s $shard -z $zk_ips --role=primary -H -o pg-online | grep ok; then
-            isok=1
-            break
-        fi
-
-        let attempt=attempt+1
-        sleep 1
-    done
-    [[ $isok -eq 1 ]] || fatal "manatee is not up"
 }
 
-
-function sdc_ensure_zk {
-    local attempt=0
-    local isok=0
-    local zkok
-
-    local zonename=$(zonename)
-
-    local zk_ips=$(json -f ${METADATA} ZK_SERVERS | json -a host)
-    if [[ $? -ne 0 ]] ; then
-        zk_ips=127.0.0.1
-    fi
-
-    while [[ $attempt -lt 60 ]]
-    do
-        for ip in $zk_ips
-        do
-            zkok=$(echo "ruok" | nc -w 1 $ip 2181)
-            if [[ $? -eq 0 ]] && [[ "$zkok" == "imok" ]]
-            then
-                isok=1
-                break
-            fi
-        done
-
-        if [[ $isok -eq 1 ]]
-        then
-            break
-        fi
-
-        let attempt=attempt+1
-        sleep 1
-    done
-    [[ $isok -eq 1 ]] || fatal "ZooKeeper is not running"
-}
-
-
 if [[ ${FLAVOR} == "manta" ]]; then
 
     source ${DIR}/scripts/util.sh
@@ -507,7 +244,6 @@ if [[ ${FLAVOR} == "manta" ]]; then
     manta_common_setup "moray" 0
 
     manta_ensure_zk
-    ensure_manatee SERVICE_NAME
 
     echo "Setting up Moray"
     manta_setup_moray_config
@@ -534,12 +270,6 @@ else # ${FLAVOR} == "sdc"
     # SDC-specific moray setup
     sdc_moray_setup
 
-    sdc_ensure_zk
-    ensure_manatee manatee_shard
-
-    # Create the DB for moray
-    sdc_moray_createdb
-
     # All done, run boilerplate end-of-setup
     sdc_setup_complete
 fi
diff --git a/lib/cmd.js b/lib/cmd.js
new file mode 100644
index 0000000..deef5ef
--- /dev/null
+++ b/lib/cmd.js
@@ -0,0 +1,79 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_fs = require('fs');
+var mod_jsprim = require('jsprim');
+var VError = require('verror');
+
+
+// --- Globals
+
+var DEFAULTS = {
+    file: process.cwd() + '/etc/config.json',
+    monitorPort: 3020,
+    port: 2020,
+    bindip: '0.0.0.0'
+};
+
+var LOG_SERIALIZERS = {
+    err: mod_bunyan.stdSerializers.err,
+    pg: function (client) {
+        return (client ? client._moray_id : undefined);
+    }
+};
+
+
+// --- Exports
+
+/**
+ * Allows us to increase the verbosity with each additional -v without
+ * ever dropping below the TRACE log level.
+ */
+function increaseVerbosity(log) {
+    log.level(Math.max(mod_bunyan.TRACE, (log.level() - 10)));
+    if (log.level() <= mod_bunyan.DEBUG) {
+        log = log.child({src: true});
+    }
+    return log;
+}
+
+function readConfig(options) {
+    assert.object(options);
+
+    var cfg;
+
+    try {
+        cfg = JSON.parse(mod_fs.readFileSync(options.file, 'utf8'));
+    } catch (e) {
+        throw new VError(e,
+            'Unable to parse configuration file %s', options.file);
+    }
+
+    return mod_jsprim.mergeObjects(cfg, options, DEFAULTS);
+}
+
+function setupLogger(name) {
+    return mod_bunyan.createLogger({
+        name: name,
+        level: (process.env.LOG_LEVEL || 'info'),
+        stream: process.stderr,
+        serializers: LOG_SERIALIZERS
+    });
+}
+
+module.exports = {
+    LOG_SERIALIZERS: LOG_SERIALIZERS,
+
+    increaseVerbosity: increaseVerbosity,
+    readConfig: readConfig,
+    setupLogger: setupLogger
+};
diff --git a/main.js b/main.js
index e36ed2a..1e92a17 100644
--- a/main.js
+++ b/main.js
@@ -12,9 +12,9 @@ var assert = require('assert-plus');
 var bsyslog = require('bunyan-syslog');
 var bunyan = require('bunyan');
 var clone = require('clone');
-var fs = require('fs');
 var getopt = require('posix-getopt');
 var jsprim = require('jsprim');
+var mod_cmd = require('./lib/cmd');
 var VError = require('verror').VError;
 
 
@@ -26,26 +26,9 @@ var app = require('./lib');
 
 var MIN_PORT = 1;
 var MAX_PORT = 65535;
-var DEFAULTS = {
-    file: process.cwd() + '/etc/config.json',
-    monitorPort: 3020,
-    port: 2020,
-    bindip: '0.0.0.0'
-};
 var NAME = 'moray';
-var LOG_SERIALIZERS = {
-    err: bunyan.stdSerializers.err,
-    pg: function (client) {
-        return (client ? client._moray_id : undefined);
-    }
-};
 // We'll replace this with the syslog later, if applicable
-var LOG = bunyan.createLogger({
-    name: NAME,
-    level: (process.env.LOG_LEVEL || 'info'),
-    stream: process.stderr,
-    serializers: LOG_SERIALIZERS
-});
+var LOG = mod_cmd.setupLogger(NAME);
 var LOG_LEVEL_OVERRIDE = false;
 
 
@@ -68,7 +51,7 @@ function setupLogger(config) {
         var facility = bsyslog.facility[cfg_b.syslog.facility];
         LOG = bunyan.createLogger({
             name: NAME,
-            serializers: LOG_SERIALIZERS,
+            serializers: mod_cmd.LOG_SERIALIZERS,
             streams: [ {
                 level: level,
                 type: 'raw',
@@ -84,8 +67,9 @@ function setupLogger(config) {
     }
 
     if (cfg_b.level && !LOG_LEVEL_OVERRIDE) {
-        if (bunyan.resolveLevel(cfg_b.level))
+        if (bunyan.resolveLevel(cfg_b.level)) {
             LOG.level(cfg_b.level);
+        }
     }
 }
 
@@ -130,12 +114,8 @@ function parseOptions() {
             break;
 
         case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
             LOG_LEVEL_OVERRIDE = true;
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            LOG = mod_cmd.increaseVerbosity(LOG);
             break;
 
         case ':':
@@ -160,27 +140,6 @@ function parseOptions() {
     return (opts);
 }
 
-
-function readConfig(options) {
-    assert.object(options);
-
-    var cfg;
-
-    try {
-        cfg = JSON.parse(fs.readFileSync(options.file, 'utf8'));
-    } catch (e) {
-        LOG.fatal({
-            err: e,
-            file: options.file
-        }, 'Unable to read/parse configuration file');
-        throw new VError(e,
-            'Unable to parse configuration file %s', options.file);
-    }
-
-    return (jsprim.mergeObjects(cfg, options, DEFAULTS));
-}
-
-
 function run(options) {
     assert.object(options);
 
@@ -198,7 +157,7 @@ function run(options) {
 
 (function main() {
     var options = parseOptions();
-    var config = readConfig(options);
+    var config = mod_cmd.readConfig(options);
 
     LOG.debug({
         config: config,
diff --git a/package.json b/package.json
index 9e5bc23..4e02e94 100644
--- a/package.json
+++ b/package.json
@@ -16,7 +16,9 @@
         "cueball": "~2.7.1",
         "dtrace-provider": "~0.8",
         "deep-equal": "0.0.0",
+        "exeunt": "1.1.1",
         "fast": "2.3.2",
+        "forkexec": "1.1.0",
         "ip6addr": "0.2.2",
         "jsprim": "1.4.0",
         "kang": "1.2.0",
@@ -25,7 +27,6 @@
         "libuuid": "0.1.3",
         "lru-cache": "2.5.0",
         "node-manatee": "git+https://github.com/joyent/node-manatee.git#019e9ca0",
-        "manatee": "git+https://github.com/joyent/manatee.git#86ae52d",
         "moray": "3.1.1",
         "microtime": "0.5.1",
         "once": "1.3.0",
diff --git a/pg-setup.js b/pg-setup.js
new file mode 100644
index 0000000..469f1bd
--- /dev/null
+++ b/pg-setup.js
@@ -0,0 +1,394 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var exeunt = require('exeunt');
+var libuuid = require('libuuid');
+var mod_artedi = require('artedi');
+var mod_cmd = require('./lib/cmd');
+var mod_forkexec = require('forkexec');
+var mod_fs = require('fs');
+var mod_getopt = require('posix-getopt');
+var mod_jsprim = require('jsprim');
+var mod_manatee = require('node-manatee');
+var mod_pg = require('./lib/pg');
+var mod_schema = require('./lib/schema');
+var vasync = require('vasync');
+var VError = require('verror');
+
+// --- Globals
+
+var FLAVOR = 'sdc';
+var DBNAME = process.env.MORAY_DB_NAME || 'moray';
+var MORAY_USER = 'moray';
+var RESERVE_CONNS = 18;
+var SMF_EXIT_NODAEMON = 94;
+var SUCCESSFUL_SETUP_SENTINEL = '/var/tmp/.moray-pg-setup-done';
+
+var CREATE_TABLE_SQL = 'CREATE TABLE IF NOT EXISTS buckets_config (' +
+    'name text PRIMARY KEY, ' +
+    'index text NOT NULL, ' +
+    'pre text NOT NULL, ' +
+    'post text NOT NULL, ' +
+    'options text, ' +
+    'mtime timestamp without time zone DEFAULT now() NOT NULL' +
+');';
+
+var ALTER_TABLE_SQL = 'ALTER TABLE buckets_config OWNER TO ' + MORAY_USER + ';';
+
+
+var NAME = 'pg-setup';
+var LOG = mod_cmd.setupLogger(NAME);
+
+
+// --- Helpers
+
+function query(opts, sql, args, callback) {
+    opts.db.pg(function (cErr, pg) {
+        if (cErr) {
+            callback(cErr);
+            return;
+        }
+
+        var reqid = libuuid.create();
+        pg.setRequestId(reqid);
+
+        var req = pg.query(sql, args);
+        var results = [];
+
+        LOG.info({
+            req_id: reqid,
+            sql: sql,
+            args: args
+        }, 'running postgres query');
+
+        req.on('error', function (qErr) {
+            pg.release();
+
+            callback(qErr);
+        });
+
+        req.on('row', function (r) {
+            results.push(r);
+        });
+
+        req.on('end', function (_) {
+            pg.release();
+
+            callback(null, results);
+        });
+    });
+}
+
+// --- Postgres Setup
+
+/**
+ * Repeat a simple query until we get a result back, to confirm that the
+ * database is now ready.
+ */
+function waitUntilReady(opts, callback) {
+    var args = [
+        'psql',
+        '-U', 'postgres',
+        '-d', 'postgres',
+        '-h', opts.primary.address,
+        '-p', opts.primary.port.toString(),
+        '-c', 'SELECT now() AS when;'
+    ];
+
+    LOG.info({ cmd: 'psql', argv: args }, 'Executing command');
+
+    mod_forkexec.forkExecWait({ argv: args },
+        function (err, info) {
+        if (err) {
+            LOG.warn(info, 'database not yet ready');
+            setImmediate(waitUntilReady, opts, callback);
+            return;
+        }
+
+        LOG.info({ info: info }, 'database is now ready');
+
+        callback();
+    });
+}
+
+/**
+ * We create a non-superuser account for Moray to use, not just to help with
+ * locking down its capabilities but also so that the reserved connections are
+ * actually useful.
+ */
+function createUser(opts, callback) {
+    var args = [
+        'createuser',
+        '-U', 'postgres',
+        '-h', opts.primary.address,
+        '-p', opts.primary.port.toString(),
+        '-d', '-S', '-R',
+        MORAY_USER
+    ];
+
+    LOG.info({ cmd: 'createuser', argv: args }, 'Executing command');
+
+    mod_forkexec.forkExecWait({ argv: args },
+        function (err, info) {
+        if (err) {
+            LOG.warn(info, 'failed to create %s user', MORAY_USER);
+        } else {
+            LOG.info('created new %s user', MORAY_USER);
+        }
+
+        /*
+         * We may have already created the user, so we don't propagate the
+         * error.
+         */
+        callback();
+    });
+}
+
+
+/**
+ * Having 18 reserve connections ensures that the maximum possible number of
+ * Moray postgres connections does not exceed the imposed "moray"
+ * rolconnlimit in any of the default deployment sizes: coal, lab,
+ * production.
+ *
+ *       pg_max_conns  procs_per_zone      num_zones  max_conns_per_proc
+ * coal  100           1                   1          16
+ * lab   210           4                   3          16
+ * prod  1000          4                   3          16
+ *
+ * pg_max_conns - the default value of the postgres parameter
+ * max_connections set in postgres.conf for each deployment size.
+ *
+ * procs_per_zone - the default number of processes per Moray zone for the
+ * given deployment size.
+ *
+ * num_zones - the default number of Moray zones per shard for the
+ * deployment size.
+ *
+ * max_conns_per_proc - the default value of the SAPI tunable
+ * MORAY_MAX_PG_CONNS.
+ *
+ * Reserving 18 connections imposes an upper bound of 82, 192, and 982 moray
+ * role connections in coal, lab, and production deployments. These upper
+ * bounds are fine because with their default configurations, coal, lab, and
+ * production deployment Morays may have (in aggregate) a maximum of 16,
+ * 192, and 192 total connections to postgres, respectively.
+ */
+function setConnLimit(opts, callback) {
+    if (FLAVOR !== 'manta') {
+        callback();
+        return;
+    }
+
+    query(opts, 'SHOW max_connections;', [], function (sErr, results) {
+        if (sErr) {
+            LOG.warn(sErr, 'Unable to retrieve postgres max_connections; ' +
+                'role property \'rolconnlimit\' not applied to \'moray\'');
+            callback();
+            return;
+        }
+
+        if (results.length < 1) {
+            LOG.warn('no "max_connections" results returned; ' +
+                'role property \'rolconnlimit\' not applied to \'moray\'');
+            callback();
+            return;
+        }
+
+        var maxconns = results[0].max_connections;
+        if (maxconns <= RESERVE_CONNS) {
+            LOG.warn({
+                max_connections: maxconns,
+                reserve_connections: RESERVE_CONNS
+            }, 'Maximum allowed Postgres connections is lower than the ' +
+               'number of reserve connections; ' +
+               'role property \'rolconnlimit\' not applied to \'moray\'');
+            callback();
+            return;
+        }
+
+
+        var limit = maxconns - RESERVE_CONNS;
+        var sql = 'ALTER ROLE ' +
+            MORAY_USER + ' WITH CONNECTION LIMIT ' + limit;
+
+        query(opts, sql, [], function (aErr) {
+            if (aErr) {
+                callback(new VError(aErr, 'failed to set connection limit'));
+                return;
+            }
+
+            LOG.info('Successfully set %s user connection limit to %d',
+                MORAY_USER, limit);
+
+            callback();
+        });
+    });
+}
+
+/**
+ * Setup the database for Moray to use. Since we can't conditionally create the
+ * database like we can tables, we ignore any errors here, since it likely
+ * already exists.
+ */
+function createDB(opts, callback) {
+    var args = [
+        'createdb',
+        '-U', 'postgres',
+        '-T', 'template0',
+        '--locale=C',
+        '-E', 'UNICODE',
+        '-O', MORAY_USER,
+        '-h', opts.primary.address,
+        '-p', opts.primary.port.toString(),
+        DBNAME
+    ];
+
+    LOG.info({ cmd: 'createdb', argv: args }, 'Executing command');
+
+    mod_forkexec.forkExecWait({ argv: args }, function (err, info) {
+        if (err) {
+            LOG.warn(info, 'failed to create moray database');
+        }
+
+        /*
+         * We may have already created the database, so we don't propagate the
+         * error.
+         */
+        callback();
+    });
+}
+
+function createTable(opts, callback) {
+    query(opts, CREATE_TABLE_SQL, [], callback);
+}
+
+function changeTableOwner(opts, callback) {
+    query(opts, ALTER_TABLE_SQL, [], callback);
+}
+
+/**
+ * While this script is designed to be idempotent, there's really no need for
+ * us to always try it. Once we've done everything, we write out a file so that
+ * we won't retry on future reboots. (Reprovisions will wipe the file though,
+ * and we'll run again then.)
+ */
+function writeSentinel(_, callback) {
+    mod_fs.writeFile(SUCCESSFUL_SETUP_SENTINEL, '', callback);
+}
+
+function setupPostgres(opts, callback) {
+    if (mod_fs.existsSync(SUCCESSFUL_SETUP_SENTINEL)) {
+        LOG.info('Found %j, skipping setup', SUCCESSFUL_SETUP_SENTINEL);
+        setImmediate(callback);
+        return;
+    }
+
+    vasync.pipeline({
+        arg: opts,
+        funcs: [
+            waitUntilReady,
+            createUser,
+            setConnLimit,
+            createDB,
+            createTable,
+            changeTableOwner,
+            writeSentinel
+        ]
+    }, callback);
+}
+
+function parseOptions() {
+    var parser = new mod_getopt.BasicParser(':vf:r:', process.argv);
+    var option;
+    var opts = {};
+
+    while ((option = parser.getopt()) !== undefined) {
+        switch (option.option) {
+        case 'f':
+            opts.file = option.optarg;
+            break;
+
+        case 'v':
+            LOG = mod_cmd.increaseVerbosity(LOG);
+            break;
+
+        case 'r':
+            FLAVOR = option.optarg;
+            break;
+
+        case ':':
+            throw new VError('Expected argument for -%s', option.optopt);
+
+        default:
+            throw new VError('Invalid option: -%s', option.optopt);
+        }
+    }
+
+    if (parser.optind() !== process.argv.length) {
+        throw new VError(
+            'Positional arguments found when none were expected: %s',
+            process.argv.slice(parser.optind()).join(' '));
+    }
+
+    if (!opts.file) {
+        LOG.fatal({ opts: opts }, 'No config file specified.');
+        throw new Error('No config file specified');
+    }
+
+    return (opts);
+}
+
+function main() {
+    var options = parseOptions();
+    var config = mod_cmd.readConfig(options);
+
+    config.log = LOG;
+    mod_schema.validateConfig(config);
+    assert.object(config.manatee, 'config.manatee');
+
+    var dbopts = config.manatee;
+    dbopts.manatee.log = LOG;
+
+    var dbresolver = mod_manatee.createPrimaryResolver(dbopts.manatee);
+
+    dbresolver.once('added', function (_, primary) {
+        var collector = mod_artedi.createCollector({ labels: {} });
+        var db = mod_pg.createPool(mod_jsprim.mergeObjects(dbopts.pg, {
+            log: LOG,
+            domain: 'manatee',
+            user: 'postgres',
+            collector: collector,
+            resolver: dbresolver
+        }));
+
+        setupPostgres({
+            resolver: dbresolver,
+            primary: primary,
+            config: config,
+            db: db
+        }, function (err) {
+            db.close();
+
+            if (err) {
+                LOG.error(err, 'failed to set up postgres');
+                exeunt(1);
+            } else {
+                LOG.info('successfully set up postgres');
+                exeunt(SMF_EXIT_NODAEMON);
+            }
+        });
+    });
+
+    dbresolver.start();
+}
+
+main();
diff --git a/smf/manifests/pg-setup.xml.in b/smf/manifests/pg-setup.xml.in
new file mode 100644
index 0000000..cc4ba49
--- /dev/null
+++ b/smf/manifests/pg-setup.xml.in
@@ -0,0 +1,76 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2018, Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="pg-setup">
+  <service name="smartdc/pg-setup" type="service" version="1">
+
+    <create_default_instance enabled="true" />
+    <single_instance/>
+
+    <dependency name="network" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/milestone/network:default" />
+    </dependency>
+
+    <dependency name="filesystem" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/system/filesystem/local" />
+    </dependency>
+
+    <dependency name="mdata" grouping="require_all" restart_on="none" type="service">
+      <service_fmri value="svc:/smartdc/mdata:execute" />
+    </dependency>
+
+    <dependency name="config-agent" grouping="optional_all" restart_on="none" type="service">
+      <service_fmri value="svc:/smartdc/application/config-agent" />
+    </dependency>
+
+    <exec_method
+      type="method"
+      name="start"
+      exec="/usr/bin/ctrun -l child -o noorphan node --abort-on-uncaught-exception pg-setup.js -f etc/config.json -r @@MORAY_FLAVOR@@"
+      timeout_seconds="600">
+      <method_context working_directory="/opt/smartdc/moray">
+        <method_credential user="nobody"
+                   group="nobody"
+                   privileges="basic,net_privaddr"/>
+        <method_environment>
+          <envvar name="PATH"
+              value="/opt/smartdc/moray/build/node/bin:/opt/local/bin:/usr/bin:/usr/sbin:/bin"/>
+          <envvar name="LD_PRELOAD_32"
+              value="/usr/lib/extendedFILE.so.1" />
+        </method_environment>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <property_group name="application" type="application" />
+
+    <stability value="Evolving" />
+
+    <template>
+      <common_name>
+        <loctext xml:lang="C">Joyent Postgres Setup Service</loctext>
+      </common_name>
+    </template>
+
+  </service>
+</service_bundle>
