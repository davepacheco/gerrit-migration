From 5a6e62cc5f7bc642fbf177758e3b74b3b7ddde3e Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 31 Jan 2017 02:57:15 +0000
Subject: [PATCH] MORAY-394 Add limited support for batch operations to
 electric-moray

---
 Makefile             |   1 +
 lib/dtrace.js        |   8 +-
 lib/ring.js          |  50 +++-
 lib/schema/manta.js  |  75 ++++--
 lib/server.js        |  88 ++++++-
 package.json         |   5 +-
 test/batch.test.js   | 575 +++++++++++++++++++++++++++++++++++++++++++
 test/objects.test.js | 262 +-------------------
 tools/jsl.node.conf  |   1 +
 9 files changed, 777 insertions(+), 288 deletions(-)
 create mode 100644 test/batch.test.js

diff --git a/Makefile b/Makefile
index 2f7b001..36aeca0 100644
--- a/Makefile
+++ b/Makefile
@@ -89,6 +89,7 @@ manta-scripts: deps/manta-scripts/.git
 test: $(NODEUNIT)
 	$(NODEUNIT) test/buckets.test.js | $(BUNYAN)
 	$(NODEUNIT) test/objects.test.js | $(BUNYAN)
+	$(NODEUNIT) test/batch.test.js | $(BUNYAN)
 	$(NODEUNIT) test/sql.test.js | $(BUNYAN)
 	$(NODEUNIT) test/integ.test.js | $(BUNYAN)
 
diff --git a/lib/dtrace.js b/lib/dtrace.js
index 2b8b3ba..a715f45 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var dtrace = require('dtrace-provider');
@@ -23,6 +23,12 @@ var PROBES = {
     // msgid, req_id
     'putobject-done': ['int'],
 
+    // msgid, req_id
+    'batch-start': ['int', 'char *'],
+
+    // msgid
+    'batch-done': ['int'],
+
     // msgid, req_id, bucket, key
     'getobject-start': ['int', 'char *', 'char *', 'char *'],
 
diff --git a/lib/ring.js b/lib/ring.js
index a7cd958..c6cbb10 100644
--- a/lib/ring.js
+++ b/lib/ring.js
@@ -5,13 +5,11 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var fash = require('fash');
-var verror = require('verror');
-
 var schema = require('./schema/index');
 
 
@@ -97,6 +95,52 @@ Ring.prototype.getNode = function getNode(bucket, key, callback) {
     });
 };
 
+/**
+ * Gets the hashed node given a series of batch operations.
+ *
+ * @param {Array} requests An array of {bucket,key} objects which must all
+ * transform to the same key to determine which node a series of operations
+ * will performed on.
+ * @param {Function} callback The callback of the type f(err, hashedNode).
+ */
+Ring.prototype.getNodeBatch = function getNodeBatch(origRequests, callback) {
+    var self = this;
+    var log = self.log_;
+    var requests = origRequests.slice();
+
+    log.debug({
+        requests: requests
+    }, 'Ring.getNodeBatch: entered');
+
+    var request = requests.shift();
+    var tkey = schema.transformKey(request.bucket, request.key);
+
+    for (var i = 0; i < requests.length; i++) {
+        var currKey = schema.transformKey(requests[i].bucket, requests[i].key);
+        if (tkey !== currKey) {
+            setImmediate(callback,
+                new Error('all requests must transform to the same key'));
+            return;
+        }
+    }
+
+    log.debug({
+        requests: requests,
+        tkey: tkey
+    }, 'Ring.getNodeBatch: key transformed');
+
+    self.chash_.getNode(tkey, function (err, hashedNode) {
+        log.debug({
+            err: err,
+            requests: requests,
+            tkey: tkey,
+            hashedNode: hashedNode
+        }, 'Ring.getNodeBatch: exiting');
+
+        callback(err, hashedNode);
+    });
+};
+
 /**
  * Gets the hashed node given only a key. The key is not transformed in anyway.
  * @param {String} key The key.
diff --git a/lib/schema/manta.js b/lib/schema/manta.js
index 1a3816a..ca33156 100644
--- a/lib/schema/manta.js
+++ b/lib/schema/manta.js
@@ -5,37 +5,74 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * These functions take care of transforming keys for some of the buckets
+ * used through electric-moray. The keys are transformed so that some keys
+ * will become the same value and always live on the same Moray shard. For
+ * example, the "manta" bucket would transform these two keys prior to
+ * hashing:
+ *
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir/myobj1
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir/myobj2
+ *
+ * Into the value:
+ *
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir
+ *
+ * This ensures that all objects in a directory have their information
+ * stored on the same Moray shard, which is necessary for performing
+ * a findObjects() call on the bucket's "dirname" index successfully.
  */
 
 var path = require('path');
+var strsplit = require('strsplit');
+
+/*
+ * Return the dirname of the key. If dirname === '.', then there was no
+ * dir, so we just return the key as is.
+ */
+function dirnameOrKey(key) {
+    /* JSSTYLED */
+    var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
+    var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
+    if (tkey === '.') {
+        return key;
+    } else {
+        return tkey;
+    }
+}
+
+
+/*
+ * "manta_uploads" has keys of the form <uuid>:<path>, and are hashed by
+ * the dirname of the <path> component. Since a path could potentially
+ * contain colons, we use strsplit to make sure we only split at the
+ * first occurrence.
+ */
+function mpuDirnameOrKey(key) {
+    var split = strsplit(key, ':', 2);
+    if (split.length < 2) {
+        return (key);
+    }
+    return (dirnameOrKey(split[1]));
+}
 
 
 ///--- Exports
 
 module.exports = {
-    // return the dirname of the key, if dirname === '.' this means there was
-    // no dir, then just return the key as is
     manta: function manta(key) {
-        /* JSSTYLED */
-        var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
-        var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
-        if (tkey === '.') {
-            return key;
-        } else {
-            return tkey;
-        }
+        return (dirnameOrKey(key));
+    },
+    manta_uploads: function manta_uploads(key) {
+        return (mpuDirnameOrKey(key));
     },
     // same as the manta bucket, used for unit tests so they don't stomp all
     // over the actual manta bucket
     testmanta: function testmanta(key) {
-        /* JSSTYLED */
-        var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
-        var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
-        if (tkey === '.') {
-            return key;
-        } else {
-            return tkey;
-        }
+        return (dirnameOrKey(key));
     }
 };
diff --git a/lib/server.js b/lib/server.js
index bff3b77..1ecf56b 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -18,6 +18,7 @@ var vasync = require('vasync');
 var verror = require('verror');
 
 var dtrace = require('./dtrace');
+var schema = require('./schema');
 var ring = require('./ring');
 require('./errors');
 
@@ -25,6 +26,11 @@ require('./errors');
 
 ///--- GLOBALS
 
+var ALLOWED_BATCH_OPS = [
+    'put',
+    'delete'
+];
+
 var READ_ONLY = 'ro';
 
 
@@ -862,7 +868,16 @@ function updateObjects(options) {
     return _updateObjects;
 }
 
-// we don't support batch operations
+
+/*
+ * Batching is only supported in a very limited case: when all of the requests
+ * have keys with the same value after transformation (if appropriate for their
+ * bucket), which allows us to be sure that all of the values live on the same
+ * shard.
+ *
+ * Operations like 'update' and 'deleteMany' are not allowed since they cannot
+ * be guaranteed to only affect values on a single shard.
+ */
 function batch(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -879,7 +894,76 @@ function batch(options) {
             opts: opts
         }, 'batch: entered');
 
-        res.end(new Error('Operation not supported'));
+        dtrace['batch-start'].fire(function () {
+            return ([res.msgid, id]);
+        });
+
+        function done(err, meta) {
+            dtrace['batch-done'].fire(function () {
+                return ([res.msgid]);
+            });
+
+            if (err) {
+                log.debug(err, 'batch: failed');
+                res.end(err);
+            } else {
+                log.debug({ meta: meta }, 'batch: done');
+                res.end(meta);
+            }
+        }
+
+        if (!Array.isArray(requests) || requests.length === 0) {
+            done(new Error('must specify an array with at least one request'));
+            return;
+        }
+
+        for (var i = 0; i < requests.length; i++) {
+            var request = requests[i];
+
+            if (request.operation !== undefined && request.operation !== null &&
+                ALLOWED_BATCH_OPS.indexOf(request.operation) === -1) {
+                done(new Error(JSON.stringify(request.operation) +
+                    ' is not an allowed batch operation'));
+                return;
+            }
+
+            if (typeof (request.key) !== 'string') {
+                done(new Error('all batch requests must have a "key"'));
+                return;
+            }
+
+            if (typeof (request.bucket) !== 'string') {
+                done(new Error('all batch requests must have a "bucket"'));
+                return;
+            }
+        }
+
+        options.ring.getNodeBatch(requests, function (err, node) {
+            if (err) {
+                done(err);
+                return;
+            }
+
+            if (node.data && node.data === READ_ONLY) {
+                log.debug({
+                    requests: requests,
+                    opts: opts,
+                    node: node
+                }, 'batch: failed vnode is read only');
+
+                dtrace['batch-done'].fire(function () {
+                    return ([res.msgid]);
+                });
+
+                res.end(new ReadOnlyError());
+                return;
+            }
+
+            var pnode = node.pnode;
+            var client = options.clients.map[pnode];
+
+            client.batch(requests, opts, done);
+        });
     }
 
     return _batch;
diff --git a/package.json b/package.json
index 03f618d..c7bb04d 100644
--- a/package.json
+++ b/package.json
@@ -21,13 +21,14 @@
         "moray": "^3.0.0",
         "node-uuid": "1.4.0",
         "posix-getopt": "^1.0.0",
+        "strsplit": "1.0.0",
         "vasync": "^1.4.3",
-        "verror": "^1.3.5",
+        "verror": "1.9.0",
         "xtend": "2.0.6"
     },
     "devDependencies": {
         "deep-equal": "0.0.0",
-        "nodeunit": "0.8.1"
+        "nodeunit": "0.9.1"
     },
     "sdcDependencies": {
         "config-agent": ">=1.2.0"
diff --git a/test/batch.test.js b/test/batch.test.js
new file mode 100644
index 0000000..7a74526
--- /dev/null
+++ b/test/batch.test.js
@@ -0,0 +1,575 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+var path = require('path');
+var uuid = require('node-uuid');
+var vasync = require('vasync');
+var VError = require('verror');
+
+if (require.cache[__dirname + '/helper.js'])
+    delete require.cache[__dirname + '/helper.js'];
+var helper = require('./helper.js');
+
+
+
+// --- Globals
+
+var after = helper.after;
+var before = helper.before;
+var test = helper.test;
+
+var BUCKET_CFG = {
+    index: {
+        str: {
+            type: 'string'
+        },
+        str_u: {
+            type: 'string',
+            unique: true
+        },
+        str_2: {
+            type: 'string'
+        },
+        num: {
+            type: 'number'
+        },
+        num_u: {
+            type: 'number',
+            unique: true
+        },
+        bool: {
+            type: 'boolean'
+        },
+        bool_u: {
+            type: 'boolean',
+            unique: true
+        }
+    },
+    pre: [function (req, cb) {
+        var v = req.value;
+        if (v.pre)
+            v.pre = 'pre_overwrite';
+
+        cb();
+    }],
+    post: [function (req, cb) {
+        cb();
+    }],
+    options: {
+        trackModification: true,
+        guaranteeOrder: true
+    }
+};
+
+
+
+///--- Helpers
+
+/*
+ * Run a batch request that should result in an error and check its
+ * message.
+ */
+function runBadBatch(c, t, requests, expMsg) {
+    c.batch(requests, function (bErr, meta) {
+        t.ok(bErr, 'error expected');
+        if (bErr) {
+            t.equal(bErr.message, expMsg, 'correct error message');
+        }
+
+        t.equal(meta, null, 'no return value');
+
+        t.end();
+    });
+}
+
+
+/*
+ * Initialize an empty object to be manipulated by a 'delete' request.
+ */
+function initEmptyObject(c, r, cb) {
+    c.putObject(r.bucket, r.key, {}, { etag: null }, cb);
+}
+
+
+/*
+ * Get an object that was created by a 'put' request, and verify that
+ * it has the expected value.
+ */
+function checkObject(c, t, r, cb) {
+    c.getObject(r.bucket, r.key, function (err, obj) {
+        t.ifError(err);
+        t.ok(obj);
+        if (obj) {
+            t.deepEqual(obj.value, r.value);
+        }
+
+        cb();
+    });
+}
+
+
+/*
+ * Assert that an object doesn't exist.
+ */
+function checkNoObject(c, t, r, cb) {
+    c.getObject(r.bucket, r.key, function (gErr, obj) {
+        t.ok(gErr, 'error expected');
+        if (gErr) {
+            t.ok(VError.hasCauseWithName(gErr, 'ObjectNotFoundError'),
+                'Object not found');
+        }
+
+        t.equal(obj, null, 'no object returned');
+
+        cb();
+    });
+}
+
+
+///--- Tests
+
+/*
+ * Set up two buckets before every test: one which transforms keys,
+ * and one which doesn't.
+ */
+before(function (cb) {
+    var self = this;
+    this.bucket1 = 'testmanta';
+    this.bucket2 = 'notransform';
+    this.client = helper.createClient();
+    this.client.on('connect', function () {
+        self.client.createBucket(self.bucket1, BUCKET_CFG, function (err1) {
+            if (err1) {
+                console.error(err1.stack);
+                cb(err1);
+                return;
+            }
+
+            self.client.createBucket(self.bucket2, BUCKET_CFG, function (err2) {
+                if (err2) {
+                    console.error(err2.stack);
+                }
+
+                cb(err2);
+            });
+        });
+    });
+});
+
+
+after(function (cb) {
+    var self = this;
+    self.client.delBucket(self.bucket1, function (err1) {
+        if (err1) {
+            console.error(err1.stack);
+        }
+
+        self.client.delBucket(self.bucket2, function (err2) {
+            if (err2) {
+                console.error(err2.stack);
+            }
+
+            self.client.close();
+            cb(err1 || err2);
+        });
+    });
+});
+
+
+test('single operation: "put"', function (t) {
+    var self = this;
+    var requests = [
+        {
+            operation: 'put',
+            bucket: self.bucket1,
+            key: path.join('/', uuid.v4(), 'stor', uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        }
+    ];
+
+    self.client.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                t.equal(requests[0].bucket, e.bucket);
+                t.ok(e.etag, 'has etag');
+            });
+        }
+
+        checkObject(self.client, t, requests[0], function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('single operation: "delete"', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            operation: 'delete',
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4())
+        }
+    ];
+
+    vasync.pipeline({ funcs: [
+        function (_, cb) {
+            initEmptyObject(c, requests[0], cb);
+        },
+        function (_, cb) {
+            c.batch(requests, function (bErr, meta) {
+                if (bErr) {
+                    cb(bErr);
+                    return;
+                }
+
+                t.ok(meta);
+                t.ok(meta.etags);
+                if (meta.etags) {
+                    t.ok(Array.isArray(meta.etags));
+                    t.equal(meta.etags.length, requests.length);
+                    meta.etags.forEach(function (e) {
+                        t.equal(requests[0].key, e.key);
+                        t.equal(requests[0].bucket, e.bucket);
+                        t.equal(undefined, e.etag, 'no etag');
+                    });
+                }
+
+                cb();
+            });
+        },
+        function (_, cb) {
+            checkNoObject(c, t, requests[0], cb);
+        }
+    ] }, function (err) {
+        t.ifError(err, 'pipeline should succeed');
+        t.end();
+    });
+});
+
+
+test('keys in batch transform to same value (1 bucket)', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    c.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                switch (e.key) {
+                case requests[0].key:
+                    t.equal(requests[0].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                case requests[1].key:
+                    t.equal(requests[1].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                default:
+                    t.fail('unrecognized key: ' + JSON.stringify(e));
+                    return;
+                }
+            });
+        }
+
+        vasync.forEachPipeline({
+            inputs: requests,
+            func: checkObject.bind(null, c, t)
+        }, function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('keys in batch transform to same value (2 buckets)', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: self.bucket2,
+            key: prefixdir,
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    c.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                switch (e.key) {
+                case requests[0].key:
+                    t.equal(requests[0].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                case requests[1].key:
+                    t.equal(requests[1].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                default:
+                    t.fail('unrecognized key: ' + JSON.stringify(e));
+                    return;
+                }
+            });
+        }
+
+        vasync.forEachPipeline({
+            inputs: requests,
+            func: checkObject.bind(null, c, t)
+        }, function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('keys in batch transform to different value', function (t) {
+    var prefixdir1 = path.join('/', uuid.v4(), 'stor');
+    var prefixdir2 = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: path.join(prefixdir1, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: this.bucket1,
+            key: path.join(prefixdir2, uuid.v4()),
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        'all requests must transform to the same key');
+});
+
+
+test('same key transforms to different values', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: this.bucket2,
+            key: key,
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        'all requests must transform to the same key');
+});
+
+
+test('bad requests array: empty array', function (t) {
+    runBadBatch(this.client, t, [],
+        'must specify an array with at least one request');
+});
+
+
+test('unsupported batch operation: "update"', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'update',
+            bucket: this.bucket1,
+            filter: '(num=5)',
+            fields: { str: 'hello' }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        '"update" is not an allowed batch operation');
+});
+
+
+test('unsupported batch operation: "deleteMany"', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'deleteMany',
+            bucket: this.bucket1,
+            filter: '(num=5)'
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        '"deleteMany" is not an allowed batch operation');
+});
+
+
+test('mix of all valid operations', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            operation: 'delete',
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4())
+        },
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'put',
+            bucket: self.bucket2,
+            key: prefixdir,
+            value: {
+                foo: 'bar'
+            }
+        }
+    ];
+
+    vasync.pipeline({ funcs: [
+        function (_, cb) {
+            initEmptyObject(c, requests[0], cb);
+        },
+        function (_, cb) {
+            c.batch(requests, function (bErr, meta) {
+                if (bErr) {
+                    cb(bErr);
+                    return;
+                }
+
+                t.ok(meta);
+                t.ok(meta.etags);
+                if (meta.etags) {
+                    t.ok(Array.isArray(meta.etags));
+                    t.equal(meta.etags.length, requests.length);
+                    meta.etags.forEach(function (e) {
+                        switch (e.key) {
+                        case requests[0].key:
+                            t.equal(requests[0].bucket, e.bucket);
+                            t.equal(undefined, e.etag, 'no etag');
+                            return;
+                        case requests[1].key:
+                            t.equal(requests[1].bucket, e.bucket);
+                            t.ok(e.etag, 'has etag');
+                            return;
+                        case requests[2].key:
+                            t.equal(requests[2].bucket, e.bucket);
+                            t.ok(e.etag, 'has etag');
+                            return;
+                        default:
+                            t.fail('unrecognized key: ' + JSON.stringify(e));
+                            return;
+                        }
+                    });
+                }
+
+                cb();
+            });
+        },
+        function (_, cb) {
+            checkNoObject(c, t, requests[0], cb);
+        },
+        function (_, cb) {
+            vasync.forEachPipeline({
+                inputs: requests.slice(1),
+                func: checkObject.bind(null, c, t)
+            }, cb);
+        }
+    ] }, function (err) {
+        t.ifError(err, 'pipeline should succeed');
+        t.end();
+    });
+});
diff --git a/test/objects.test.js b/test/objects.test.js
index cc97d72..9a31d51 100644
--- a/test/objects.test.js
+++ b/test/objects.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var clone = require('clone');
@@ -962,263 +962,3 @@ test('unsupported deletemany', function (t) {
             t.end();
         });
 });
-
-//test('batch put objects', function (t) {
-    //var c = this.client;
-    //var self = this;
-    //var requests = [
-        //{
-            //bucket: self.bucket,
-            //key: uuid.v4(),
-            //value: {
-                //foo: 'bar'
-            //}
-        //},
-        //{
-            //bucket: self.bucket,
-            //key: uuid.v4(),
-            //value: {
-                //bar: 'baz'
-            //}
-        //}
-    //];
-    //c.getTokens(function(err, res) {
-        //t.ifError(err);
-        //var tokens = res.tokens;
-        //c.batch(requests, {token: tokens[0]}, function (err, meta) {
-            //t.ifError(err);
-            //t.ok(meta);
-            //if (meta) {
-                //t.ok(meta.etags);
-                //if (meta.etags) {
-                    //t.ok(Array.isArray(meta.etags));
-                    //t.equal(meta.etags.length, 2);
-                    //meta.etags.forEach(function (e) {
-                        //t.equal(self.bucket, e.bucket);
-                        //t.ok(e.key);
-                        //t.ok(e.etag);
-                    //});
-                //}
-            //}
-            //c.getObject(self.bucket, requests[0].key, function (er2, obj) {
-                //t.ifError(er2);
-                //t.ok(obj);
-                //if (obj)
-                    //t.deepEqual(obj.value, requests[0].value);
-
-                //var b = self.bucket;
-                //var r = requests[1];
-                //c.getObject(b, r.key, function (err3, obj2) {
-                    //t.ifError(err3);
-                    //t.ok(obj2);
-                    //if (obj2)
-                        //t.deepEqual(obj2.value, r.value);
-                    //t.end();
-                //});
-            //});
-        //});
-    //});
-//});
-
-
-//test('update objects no keys', function (t) {
-    //var b = this.bucket;
-    //var c = this.client;
-    //var self = this;
-    //var requests = [];
-    //for (var i = 0; i < 10; i++) {
-        //requests.push({
-            //bucket: self.bucket,
-            //key: uuid.v4().substr(0, 7),
-            //value: {
-                //num: 20,
-                //num_u: i,
-                //str: 'foo',
-                //str_u: uuid.v4().substr(0, 7)
-            //}
-        //});
-    //}
-
-    //c.batch(requests, function (put_err) {
-        //t.ifError(put_err);
-        //if (put_err) {
-            //t.end();
-            //return;
-        //}
-
-        //c.updateObjects(b, {}, '(num>=20)', function (err) {
-            //t.ok(err);
-            //t.equal(err.name, 'FieldUpdateError');
-            //t.end();
-        //});
-    //});
-//});
-
-
-//test('update objects ok', function (t) {
-    //var b = this.bucket;
-    //var c = this.client;
-    //var self = this;
-    //var requests = [];
-    //for (var i = 0; i < 10; i++) {
-        //requests.push({
-            //bucket: self.bucket,
-            //key: uuid.v4().substr(0, 7),
-            //value: {
-                //num: 20,
-                //num_u: i,
-                //str: 'foo',
-                //str_u: uuid.v4().substr(0, 7)
-            //}
-        //});
-    //}
-
-    //c.batch(requests, function (put_err) {
-        //t.ifError(put_err);
-        //if (put_err) {
-            //t.end();
-            //return;
-        //}
-
-        //var fields = {str: 'bar'};
-        //c.updateObjects(b, fields, '(num>=20)', function (err, meta) {
-            //t.ifError(err);
-            //t.ok(meta);
-            //if (!meta) {
-                //t.end();
-                //return;
-            //}
-            //t.ok(meta.etag);
-
-            //c.getObject(b, requests[0].key, function (err2, obj) {
-                //t.ifError(err2);
-                //t.ok(obj);
-                //if (obj) {
-                    //t.equal(obj.value.str, 'bar');
-                    //t.equal(obj._etag, meta.etag);
-                //}
-
-                //t.end();
-            //});
-        //});
-    //});
-//});
-
-
-//test('update objects w/array (ufds - no effect)', function (t) {
-    //var b = this.bucket;
-    //var c = this.client;
-    //var self = this;
-    //var requests = [];
-    //for (var i = 0; i < 10; i++) {
-        //requests.push({
-            //bucket: self.bucket,
-            //key: uuid.v4().substr(0, 7),
-            //value: {
-                //str: ['foo']
-            //}
-        //});
-    //}
-
-    //c.batch(requests, function (put_err) {
-        //t.ifError(put_err);
-        //if (put_err) {
-            //t.end();
-            //return;
-        //}
-
-        //var fields = {str: 'bar'};
-        //c.updateObjects(b, fields, '(str=foo)', function (err, meta) {
-            //t.ifError(err);
-            //t.ok(meta);
-            //if (!meta) {
-                //t.end();
-                //return;
-            //}
-            //t.ok(meta.etag);
-
-            //var k = requests[0].key;
-            //var o = {noCache: true};
-            //c.getObject(b, k, o, function (err2, obj) {
-                //t.ifError(err2);
-                //t.ok(obj);
-                //if (obj) {
-                    //t.ok(Array.isArray(obj.value.str));
-                    //t.notOk(obj.value.str_u);
-                    //t.equal(obj.value.str[0], 'foo');
-                    //t.equal(obj._etag, meta.etag);
-                //}
-
-                //t.end();
-            //});
-        //});
-    //});
-//});
-
-
-// batch not supported
-//test('batch put/update', function (t) {
-    //var b = this.bucket;
-    //var c = this.client;
-    //var requests = [];
-    //for (var i = 0; i < 10; i++) {
-        //requests.push({
-            //bucket: b,
-            //key: uuid.v4().substr(0, 7),
-            //value: {
-                //num: 20,
-                //num_u: i,
-                //str: 'foo',
-                //str_u: uuid.v4().substr(0, 7)
-            //}
-        //});
-    //}
-
-    //c.batch(requests, function (init_err) {
-        //t.ifError(init_err);
-
-        //var ops = [
-            //{
-                //bucket: b,
-                //key: requests[0].key,
-                //value: {
-                    //num: 10,
-                    //str: 'baz'
-                //}
-            //},
-            //{
-                //bucket: b,
-                //operation: 'update',
-                //fields: {
-                    //str: 'bar'
-                //},
-                //filter: '(num_u>=5)'
-            //}
-        //];
-        //c.batch(ops, function (err, meta) {
-            //t.ifError(err);
-            //t.ok(meta);
-            //t.ok(meta.etags);
-            //var req = c.findObjects(b, '(num_u>=0)');
-            //req.once('error', function (e) {
-                //t.ifError(e);
-                //t.end();
-            //});
-            //req.once('end', function () {
-                //t.end();
-            //});
-            //req.on('record', function (r) {
-                //t.equal(r.bucket, b);
-                //t.ok(r.key);
-                //var v = r.value;
-                //if (v.num_u >= 5) {
-                    //t.equal(v.str, 'bar');
-                //} else if (r.key === requests[0].key) {
-                    //t.equal(v.str, 'baz');
-                //} else {
-                    //t.equal(v.str, 'foo');
-                //}
-            //});
-        //});
-    //});
-//});
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 23c0e4f..097beee 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -119,6 +119,7 @@
 +define module
 +define process
 +define require
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
-- 
2.21.0

