commit c15d05041b04a6b6a65b1a6343e11204a1610642 (refs/changes/93/1393/1)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-02-01T21:51:10+00:00 (2 years, 8 months ago)
    
    MORAY-394 Add limited support for batch operations to electric-moray

diff --git a/Makefile b/Makefile
index 2f7b001..36aeca0 100644
--- a/Makefile
+++ b/Makefile
@@ -89,6 +89,7 @@ manta-scripts: deps/manta-scripts/.git
 test: $(NODEUNIT)
 	$(NODEUNIT) test/buckets.test.js | $(BUNYAN)
 	$(NODEUNIT) test/objects.test.js | $(BUNYAN)
+	$(NODEUNIT) test/batch.test.js | $(BUNYAN)
 	$(NODEUNIT) test/sql.test.js | $(BUNYAN)
 	$(NODEUNIT) test/integ.test.js | $(BUNYAN)
 
diff --git a/lib/dtrace.js b/lib/dtrace.js
index 2b8b3ba..a715f45 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var dtrace = require('dtrace-provider');
@@ -23,6 +23,12 @@ var PROBES = {
     // msgid, req_id
     'putobject-done': ['int'],
 
+    // msgid, req_id
+    'batch-start': ['int', 'char *'],
+
+    // msgid
+    'batch-done': ['int'],
+
     // msgid, req_id, bucket, key
     'getobject-start': ['int', 'char *', 'char *', 'char *'],
 
diff --git a/lib/ring.js b/lib/ring.js
index a7cd958..d15b9af 100644
--- a/lib/ring.js
+++ b/lib/ring.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -97,6 +97,51 @@ Ring.prototype.getNode = function getNode(bucket, key, callback) {
     });
 };
 
+/**
+ * Gets the hashed node given a series of batch operations.
+ *
+ * @param {Array} requests An array of {bucket,key} objects which must all
+ * transform to the same key to determine which node a series of operations
+ * will performed on.
+ * @param {Function} callback The callback of the type f(err, hashedNode).
+ */
+Ring.prototype.getNodeBatch = function getNodeBatch(origRequests, callback) {
+    var self = this;
+    var log = self.log_;
+    var requests = origRequests.slice();
+
+    log.debug({
+        requests: requests
+    }, 'Ring.getNodeBatch: entered');
+
+    var request = requests.shift();
+    var tkey = schema.transformKey(request.bucket, request.key);
+
+    for (var i = 0; i < requests.length; i++) {
+        var currKey = schema.transformKey(requests[i].bucket, requests[i].key);
+        if (tkey !== currKey) {
+            callback(new Error('All requests must transform to the same key'));
+            return;
+        }
+    }
+
+    log.debug({
+        requests: requests,
+        tkey: tkey
+    }, 'Ring.getNodeBatch: key transformed');
+
+    self.chash_.getNode(tkey, function (err, hashedNode) {
+        log.debug({
+            err: err,
+            requests: requests,
+            tkey: tkey,
+            hashedNode: hashedNode
+        }, 'Ring.getNodeBatch: exiting');
+
+        callback(err, hashedNode);
+    });
+};
+
 /**
  * Gets the hashed node given only a key. The key is not transformed in anyway.
  * @param {String} key The key.
diff --git a/lib/schema/manta.js b/lib/schema/manta.js
index 1a3816a..a0e2ed4 100644
--- a/lib/schema/manta.js
+++ b/lib/schema/manta.js
@@ -5,37 +5,73 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * These functions take care of transforming keys for some of the buckets
+ * used through electric-moray. The keys are transformed so that they end
+ * up being hashed to the same value. For example, the "manta" bucket
+ * transforms the two keys:
+ *
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir/myobj1
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir/myobj2
+ *
+ * Into the value:
+ *
+ *     /a3829ca2-0966-60ce-9dc3-e4e9060f0950/stor/mydir
+ *
+ * This ensures that all objects in a directory have their information
+ * stored on the same Moray shard, which is necessary for performing
+ * a findObjects() call on the bucket's "dirname" index successfully.
  */
 
 var path = require('path');
+var strsplit = require('strsplit');
+
+/*
+ * Return the dirname of the key. If dirname === '.', then there was no
+ * dir, so we just return the key as is.
+ */
+function dirnameOrKey(key) {
+    /* JSSTYLED */
+    var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
+    var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
+    if (tkey === '.') {
+        return key;
+    } else {
+        return tkey;
+    }
+}
+
+
+/*
+ * "manta_uploads" has keys of the form <uuid>:<path>, and are hashed by
+ * the dirname of the <path> component. Since a path could potentially
+ * contain colons, we use strsplit to make sure we only split at the
+ * first occurrence.
+ */
+function mpuDirnameOrKey(key) {
+    var split = strsplit(key, ':', 2);
+    if (split.length < 2) {
+        return (key);
+    }
+    return (dirnameOrKey(split[1]));
+}
 
 
 ///--- Exports
 
 module.exports = {
-    // return the dirname of the key, if dirname === '.' this means there was
-    // no dir, then just return the key as is
     manta: function manta(key) {
-        /* JSSTYLED */
-        var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
-        var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
-        if (tkey === '.') {
-            return key;
-        } else {
-            return tkey;
-        }
+        return (dirnameOrKey(key));
+    },
+    manta_uploads: function manta_uploads(key) {
+        return (mpuDirnameOrKey(key));
     },
     // same as the manta bucket, used for unit tests so they don't stomp all
     // over the actual manta bucket
     testmanta: function testmanta(key) {
-        /* JSSTYLED */
-        var ROOT_RE = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\/stor$/;
-        var tkey = ROOT_RE.test(key) ? key : path.dirname(key);
-        if (tkey === '.') {
-            return key;
-        } else {
-            return tkey;
-        }
+        return (dirnameOrKey(key));
     }
 };
diff --git a/lib/server.js b/lib/server.js
index bff3b77..454a2f3 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -18,6 +18,7 @@ var vasync = require('vasync');
 var verror = require('verror');
 
 var dtrace = require('./dtrace');
+var schema = require('./schema');
 var ring = require('./ring');
 require('./errors');
 
@@ -25,6 +26,11 @@ require('./errors');
 
 ///--- GLOBALS
 
+var BAD_BATCH_OPS = [
+    'update',
+    'deleteMany'
+];
+
 var READ_ONLY = 'ro';
 
 
@@ -862,7 +868,16 @@ function updateObjects(options) {
     return _updateObjects;
 }
 
-// we don't support batch operations
+
+/*
+ * Batching is only supported in a very limited case: when all of the requests
+ * have keys with the same value after transformation (if appropriate for their
+ * bucket), which allows us to be sure that all of the values live on the same
+ * shard.
+ *
+ * Operations like 'update' and 'deleteMany' are not allowed since they cannot
+ * be guaranteed to only affect values on a single shard.
+ */
 function batch(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -879,7 +894,75 @@ function batch(options) {
             opts: opts
         }, 'batch: entered');
 
-        res.end(new Error('Operation not supported'));
+        dtrace['batch-start'].fire(function () {
+            return ([res.msgid, id]);
+        });
+
+        function done(err, meta) {
+            dtrace['batch-done'].fire(function () {
+                return ([res.msgid]);
+            });
+
+            if (err) {
+                log.debug(err, 'batch: failed');
+                res.end(err);
+            } else {
+                log.debug({ meta: meta }, 'batch: done');
+                res.end(meta);
+            }
+        }
+
+        if (!Array.isArray(requests) || requests.length === 0) {
+            done(new Error('Must specify an array with at least one request'));
+            return;
+        }
+
+        for (var i = 0; i < requests.length; i++) {
+            var request = requests[i];
+
+            if (BAD_BATCH_OPS.indexOf(request.operation) !== -1) {
+                done(new Error('"' + request.operation +
+                    '" is not an allowed batch operation'));
+                return;
+            }
+
+            if (typeof (request.key) !== 'string') {
+                done(new Error('All batch requests must have a "key"'));
+                return;
+            }
+
+            if (typeof (request.bucket) !== 'string') {
+                done(new Error('All batch requests must have a "bucket"'));
+                return;
+            }
+        }
+
+        options.ring.getNodeBatch(requests, function (err, node) {
+            if (err) {
+                done(err);
+                return;
+            }
+
+            if (node.data && node.data === READ_ONLY) {
+                log.debug({
+                    requests: requests,
+                    opts: opts,
+                    node: node
+                }, 'batch: failed vnode is read only');
+
+                dtrace['batch-done'].fire(function () {
+                    return ([res.msgid]);
+                });
+
+                res.end(new ReadOnlyError());
+                return;
+            }
+
+            var pnode = node.pnode;
+            var client = options.clients.map[pnode];
+
+            client.batch(requests, opts, done);
+        });
     }
 
     return _batch;
diff --git a/package.json b/package.json
index 03f618d..c7bb04d 100644
--- a/package.json
+++ b/package.json
@@ -21,13 +21,14 @@
         "moray": "^3.0.0",
         "node-uuid": "1.4.0",
         "posix-getopt": "^1.0.0",
+        "strsplit": "1.0.0",
         "vasync": "^1.4.3",
-        "verror": "^1.3.5",
+        "verror": "1.9.0",
         "xtend": "2.0.6"
     },
     "devDependencies": {
         "deep-equal": "0.0.0",
-        "nodeunit": "0.8.1"
+        "nodeunit": "0.9.1"
     },
     "sdcDependencies": {
         "config-agent": ">=1.2.0"
diff --git a/test/batch.test.js b/test/batch.test.js
new file mode 100644
index 0000000..50e2458
--- /dev/null
+++ b/test/batch.test.js
@@ -0,0 +1,575 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+var path = require('path');
+var uuid = require('node-uuid');
+var vasync = require('vasync');
+var VError = require('verror');
+
+if (require.cache[__dirname + '/helper.js'])
+    delete require.cache[__dirname + '/helper.js'];
+var helper = require('./helper.js');
+
+
+
+// --- Globals
+
+var after = helper.after;
+var before = helper.before;
+var test = helper.test;
+
+var BUCKET_CFG = {
+    index: {
+        str: {
+            type: 'string'
+        },
+        str_u: {
+            type: 'string',
+            unique: true
+        },
+        str_2: {
+            type: 'string'
+        },
+        num: {
+            type: 'number'
+        },
+        num_u: {
+            type: 'number',
+            unique: true
+        },
+        bool: {
+            type: 'boolean'
+        },
+        bool_u: {
+            type: 'boolean',
+            unique: true
+        }
+    },
+    pre: [function (req, cb) {
+        var v = req.value;
+        if (v.pre)
+            v.pre = 'pre_overwrite';
+
+        cb();
+    }],
+    post: [function (req, cb) {
+        cb();
+    }],
+    options: {
+        trackModification: true,
+        guaranteeOrder: true
+    }
+};
+
+
+
+///--- Helpers
+
+/*
+ * Run a batch request that should result in an error and check its
+ * message.
+ */
+function runBadBatch(c, t, requests, expMsg) {
+    c.batch(requests, function (bErr, meta) {
+        t.ok(bErr, 'error expected');
+        if (bErr) {
+            t.equal(bErr.message, expMsg, 'correct error message');
+        }
+
+        t.equal(meta, null, 'no return value');
+
+        t.end();
+    });
+}
+
+
+/*
+ * Initialize an empty object to be manipulated by a 'delete' request.
+ */
+function initEmptyObject(c, r, cb) {
+    c.putObject(r.bucket, r.key, {}, { etag: null }, cb);
+}
+
+
+/*
+ * Get an object that was created by a 'put' request, and verify that
+ * it has the expected value.
+ */
+function checkObject(c, t, r, cb) {
+    c.getObject(r.bucket, r.key, function (err, obj) {
+        t.ifError(err);
+        t.ok(obj);
+        if (obj) {
+            t.deepEqual(obj.value, r.value);
+        }
+
+        cb();
+    });
+}
+
+
+/*
+ * Assert that an object doesn't exist.
+ */
+function checkNoObject(c, t, r, cb) {
+    c.getObject(r.bucket, r.key, function (gErr, obj) {
+        t.ok(gErr, 'error expected');
+        if (gErr) {
+            t.ok(VError.hasCauseWithName(gErr, 'ObjectNotFoundError'),
+                'Object not found');
+        }
+
+        t.equal(obj, null, 'no object returned');
+
+        cb();
+    });
+}
+
+
+///--- Tests
+
+/*
+ * Set up two buckets before every test: one which transforms keys,
+ * and one which doesn't.
+ */
+before(function (cb) {
+    var self = this;
+    this.bucket1 = 'testmanta';
+    this.bucket2 = 'notransform';
+    this.client = helper.createClient();
+    this.client.on('connect', function () {
+        self.client.createBucket(self.bucket1, BUCKET_CFG, function (err1) {
+            if (err1) {
+                console.error(err1.stack);
+                cb(err1);
+                return;
+            }
+
+            self.client.createBucket(self.bucket2, BUCKET_CFG, function (err2) {
+                if (err2) {
+                    console.error(err2.stack);
+                }
+
+                cb(err2);
+            });
+        });
+    });
+});
+
+
+after(function (cb) {
+    var self = this;
+    self.client.delBucket(self.bucket1, function (err1) {
+        if (err1) {
+            console.error(err1.stack);
+        }
+
+        self.client.delBucket(self.bucket2, function (err2) {
+            if (err2) {
+                console.error(err2.stack);
+            }
+
+            self.client.close();
+            cb(err1 || err2);
+        });
+    });
+});
+
+
+test('single operation: "put"', function (t) {
+    var self = this;
+    var requests = [
+        {
+            operation: 'put',
+            bucket: self.bucket1,
+            key: path.join('/', uuid.v4(), 'stor', uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        }
+    ];
+
+    self.client.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                t.equal(requests[0].bucket, e.bucket);
+                t.ok(e.etag, 'has etag');
+            });
+        }
+
+        checkObject(self.client, t, requests[0], function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('single operation: "delete"', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            operation: 'delete',
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4())
+        }
+    ];
+
+    vasync.pipeline({ funcs: [
+        function (_, cb) {
+            initEmptyObject(c, requests[0], cb);
+        },
+        function (_, cb) {
+            c.batch(requests, function (bErr, meta) {
+                if (bErr) {
+                    cb(bErr);
+                    return;
+                }
+
+                t.ok(meta);
+                t.ok(meta.etags);
+                if (meta.etags) {
+                    t.ok(Array.isArray(meta.etags));
+                    t.equal(meta.etags.length, requests.length);
+                    meta.etags.forEach(function (e) {
+                        t.equal(requests[0].key, e.key);
+                        t.equal(requests[0].bucket, e.bucket);
+                        t.equal(undefined, e.etag, 'no etag');
+                    });
+                }
+
+                cb();
+            });
+        },
+        function (_, cb) {
+            checkNoObject(c, t, requests[0], cb);
+        }
+    ] }, function (err) {
+        t.ifError(err, 'pipeline should succeed');
+        t.end();
+    });
+});
+
+
+test('keys in batch transform to same value (1 bucket)', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    c.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                switch (e.key) {
+                case requests[0].key:
+                    t.equal(requests[0].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                case requests[1].key:
+                    t.equal(requests[1].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                default:
+                    t.fail('unrecognized key: ' + JSON.stringify(e));
+                    return;
+                }
+            });
+        }
+
+        vasync.forEachPipeline({
+            inputs: requests,
+            func: checkObject.bind(null, c, t)
+        }, function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('keys in batch transform to same value (2 buckets)', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: self.bucket2,
+            key: prefixdir,
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    c.batch(requests, function (bErr, meta) {
+        if (bErr) {
+            t.ifError(bErr, 'batch()');
+            t.end();
+            return;
+        }
+
+        t.ok(meta);
+        t.ok(meta.etags);
+        if (meta.etags) {
+            t.ok(Array.isArray(meta.etags));
+            t.equal(meta.etags.length, requests.length);
+            meta.etags.forEach(function (e) {
+                switch (e.key) {
+                case requests[0].key:
+                    t.equal(requests[0].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                case requests[1].key:
+                    t.equal(requests[1].bucket, e.bucket);
+                    t.ok(e.etag, 'has etag');
+                    return;
+                default:
+                    t.fail('unrecognized key: ' + JSON.stringify(e));
+                    return;
+                }
+            });
+        }
+
+        vasync.forEachPipeline({
+            inputs: requests,
+            func: checkObject.bind(null, c, t)
+        }, function (err) {
+            t.ifError(err, 'pipeline should succeed');
+            t.end();
+        });
+    });
+});
+
+
+test('keys in batch transform to different value', function (t) {
+    var prefixdir1 = path.join('/', uuid.v4(), 'stor');
+    var prefixdir2 = path.join('/', uuid.v4(), 'stor');
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: path.join(prefixdir1, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: this.bucket1,
+            key: path.join(prefixdir2, uuid.v4()),
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        'All requests must transform to the same key');
+});
+
+
+test('same key transforms to different values', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: this.bucket2,
+            key: key,
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        'All requests must transform to the same key');
+});
+
+
+test('bad requests array: empty array', function (t) {
+    runBadBatch(this.client, t, [],
+        'Must specify an array with at least one request');
+});
+
+
+test('unsupported batch operation: "update"', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'update',
+            bucket: this.bucket1,
+            filter: '(num=5)',
+            fields: { str: 'hello' }
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        '"update" is not an allowed batch operation');
+});
+
+
+test('unsupported batch operation: "deleteMany"', function (t) {
+    var key = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            bucket: this.bucket1,
+            key: key,
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'deleteMany',
+            bucket: this.bucket1,
+            filter: '(num=5)'
+        }
+    ];
+
+    runBadBatch(this.client, t, requests,
+        '"deleteMany" is not an allowed batch operation');
+});
+
+
+test('mix of all valid operations', function (t) {
+    var c = this.client;
+    var self = this;
+    var prefixdir = path.join('/', uuid.v4(), 'stor', uuid.v4());
+    var requests = [
+        {
+            operation: 'delete',
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4())
+        },
+        {
+            bucket: self.bucket1,
+            key: path.join(prefixdir, uuid.v4()),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            operation: 'put',
+            bucket: self.bucket2,
+            key: prefixdir,
+            value: {
+                foo: 'bar'
+            }
+        }
+    ];
+
+    vasync.pipeline({ funcs: [
+        function (_, cb) {
+            initEmptyObject(c, requests[0], cb);
+        },
+        function (_, cb) {
+            c.batch(requests, function (bErr, meta) {
+                if (bErr) {
+                    cb(bErr);
+                    return;
+                }
+
+                t.ok(meta);
+                t.ok(meta.etags);
+                if (meta.etags) {
+                    t.ok(Array.isArray(meta.etags));
+                    t.equal(meta.etags.length, requests.length);
+                    meta.etags.forEach(function (e) {
+                        switch (e.key) {
+                        case requests[0].key:
+                            t.equal(requests[0].bucket, e.bucket);
+                            t.equal(undefined, e.etag, 'no etag');
+                            return;
+                        case requests[1].key:
+                            t.equal(requests[1].bucket, e.bucket);
+                            t.ok(e.etag, 'has etag');
+                            return;
+                        case requests[2].key:
+                            t.equal(requests[2].bucket, e.bucket);
+                            t.ok(e.etag, 'has etag');
+                            return;
+                        default:
+                            t.fail('unrecognized key: ' + JSON.stringify(e));
+                            return;
+                        }
+                    });
+                }
+
+                cb();
+            });
+        },
+        function (_, cb) {
+            checkNoObject(c, t, requests[0], cb);
+        },
+        function (_, cb) {
+            vasync.forEachPipeline({
+                inputs: requests.slice(1),
+                func: checkObject.bind(null, c, t)
+            }, cb);
+        }
+    ] }, function (err) {
+        t.ifError(err, 'pipeline should succeed');
+        t.end();
+    });
+});
diff --git a/test/objects.test.js b/test/objects.test.js
index cc97d72..cc2b93b 100644
--- a/test/objects.test.js
+++ b/test/objects.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 var clone = require('clone');
@@ -963,63 +963,6 @@ test('unsupported deletemany', function (t) {
         });
 });
 
-//test('batch put objects', function (t) {
-    //var c = this.client;
-    //var self = this;
-    //var requests = [
-        //{
-            //bucket: self.bucket,
-            //key: uuid.v4(),
-            //value: {
-                //foo: 'bar'
-            //}
-        //},
-        //{
-            //bucket: self.bucket,
-            //key: uuid.v4(),
-            //value: {
-                //bar: 'baz'
-            //}
-        //}
-    //];
-    //c.getTokens(function(err, res) {
-        //t.ifError(err);
-        //var tokens = res.tokens;
-        //c.batch(requests, {token: tokens[0]}, function (err, meta) {
-            //t.ifError(err);
-            //t.ok(meta);
-            //if (meta) {
-                //t.ok(meta.etags);
-                //if (meta.etags) {
-                    //t.ok(Array.isArray(meta.etags));
-                    //t.equal(meta.etags.length, 2);
-                    //meta.etags.forEach(function (e) {
-                        //t.equal(self.bucket, e.bucket);
-                        //t.ok(e.key);
-                        //t.ok(e.etag);
-                    //});
-                //}
-            //}
-            //c.getObject(self.bucket, requests[0].key, function (er2, obj) {
-                //t.ifError(er2);
-                //t.ok(obj);
-                //if (obj)
-                    //t.deepEqual(obj.value, requests[0].value);
-
-                //var b = self.bucket;
-                //var r = requests[1];
-                //c.getObject(b, r.key, function (err3, obj2) {
-                    //t.ifError(err3);
-                    //t.ok(obj2);
-                    //if (obj2)
-                        //t.deepEqual(obj2.value, r.value);
-                    //t.end();
-                //});
-            //});
-        //});
-    //});
-//});
-
 
 //test('update objects no keys', function (t) {
     //var b = this.bucket;
