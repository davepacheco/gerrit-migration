commit 792f98bd3ddca3fd2b43ec6eabf44c41d0257641 (refs/changes/25/4725/7)
Author: Robert Mustacchi <rm@joyent.com>
Date:   2018-11-09T23:09:52+00:00 (11 months ago)
    
    pbchk

diff --git a/usr/src/uts/common/io/usb/hcd/xhci/xhci.c b/usr/src/uts/common/io/usb/hcd/xhci/xhci.c
index 3c37f2433e..eabdd4fd9e 100644
--- a/usr/src/uts/common/io/usb/hcd/xhci/xhci.c
+++ b/usr/src/uts/common/io/usb/hcd/xhci/xhci.c
@@ -86,39 +86,39 @@
  *
  * There are four different kinds of endpoints:
  *
- * 	BULK		These transfers are large transfers of data to or from
- * 			a device. The most common use for bulk transfers is for
- * 			mass storage devices. Though they are often also used by
- * 			network devices and more. Bulk endpoints do not have an
- * 			explicit time component to them. They are always used
- * 			for one-shot transfers.
- *
- * 	CONTROL		These transfers are used to manipulate devices
- * 			themselves and are used for USB protocol level
- * 			operations (whether device-specific, class-specific, or
- * 			generic across all of USB). Unlike other transfers,
- * 			control transfers are always bi-directional and use
- * 			different kinds of transfers.
- *
- * 	INTERRUPT	Interrupt transfers are used for small transfers that
- * 			happen infrequently, but need reasonable latency. A good
- * 			example of interrupt transfers is to receive input from
- * 			a USB keyboard. Interrupt-IN transfers are generally
- * 			polled. Meaning that a client (device driver) opens up
- * 			an interrupt-IN pipe to poll on it, and receives
- * 			periodic updates whenever there is information
- * 			available. However, Interrupt transfers can be used
- * 			as one-shot transfers both going IN and OUT.
- *
- * 	ISOCHRONOUS	These transfers are things that happen once per
- * 			time-interval at a very regular rate. A good example of
- * 			these transfers are for audio and video. A device may
- * 			describe an interval as 10ms at which point it will read
- * 			or write the next batch of data every 10ms and transform
- * 			it for the user. There are no one-shot Isochronous-IN
- * 			transfers. There are one-shot Isochronous-OUT transfers,
- * 			but these are used by device drivers to always provide
- * 			the system with sufficient data.
+ *	BULK		These transfers are large transfers of data to or from
+ *			a device. The most common use for bulk transfers is for
+ *			mass storage devices. Though they are often also used by
+ *			network devices and more. Bulk endpoints do not have an
+ *			explicit time component to them. They are always used
+ *			for one-shot transfers.
+ *
+ *	CONTROL		These transfers are used to manipulate devices
+ *			themselves and are used for USB protocol level
+ *			operations (whether device-specific, class-specific, or
+ *			generic across all of USB). Unlike other transfers,
+ *			control transfers are always bi-directional and use
+ *			different kinds of transfers.
+ *
+ *	INTERRUPT	Interrupt transfers are used for small transfers that
+ *			happen infrequently, but need reasonable latency. A good
+ *			example of interrupt transfers is to receive input from
+ *			a USB keyboard. Interrupt-IN transfers are generally
+ *			polled. Meaning that a client (device driver) opens up
+ *			an interrupt-IN pipe to poll on it, and receives
+ *			periodic updates whenever there is information
+ *			available. However, Interrupt transfers can be used
+ *			as one-shot transfers both going IN and OUT.
+ *
+ *	ISOCHRONOUS	These transfers are things that happen once per
+ *			time-interval at a very regular rate. A good example of
+ *			these transfers are for audio and video. A device may
+ *			describe an interval as 10ms at which point it will read
+ *			or write the next batch of data every 10ms and transform
+ *			it for the user. There are no one-shot Isochronous-IN
+ *			transfers. There are one-shot Isochronous-OUT transfers,
+ *			but these are used by device drivers to always provide
+ *			the system with sufficient data.
  *
  * To find out information about the endpoints, USB devices have a series of
  * descriptors that cover different aspects of the device. For example, there
@@ -220,67 +220,67 @@
  * purpose of each of these files.
  *
  * xhci_command.c:	This file contains the logic to issue commands to the
- * 			controller as well as the actual functions that the
- * 			other parts of the driver use to cause those commands.
+ *			controller as well as the actual functions that the
+ *			other parts of the driver use to cause those commands.
  *
  * xhci_context.c:	This file manages various data structures used by the
- * 			controller to manage the controller's and device's
- * 			context data structures. See more in the xHCI Overview
- * 			and General Design for more information.
+ *			controller to manage the controller's and device's
+ *			context data structures. See more in the xHCI Overview
+ *			and General Design for more information.
  *
  * xhci_dma.c:		This manages the allocation of DMA memory and DMA
- * 			attributes for controller, whether memory is for a
- * 			transfer or something else. This file also deals with
- * 			all the logic of getting data in and out of DMA buffers.
+ *			attributes for controller, whether memory is for a
+ *			transfer or something else. This file also deals with
+ *			all the logic of getting data in and out of DMA buffers.
  *
  * xhci_endpoint.c:	This manages all of the logic of handling endpoints or
- * 			pipes. It deals with endpoint configuration, I/O
- * 			scheduling, timeouts, and callbacks to USBA.
+ *			pipes. It deals with endpoint configuration, I/O
+ *			scheduling, timeouts, and callbacks to USBA.
  *
  * xhci_event.c:	This manages callbacks from the hardware to the driver.
- * 			This covers command completion notifications and I/O
- * 			notifications.
+ *			This covers command completion notifications and I/O
+ *			notifications.
  *
  * xhci_hub.c:		This manages the virtual root-hub. It basically
- * 			implements and translates all of the USB level requests
- * 			into xhci specific implements. It also contains the
- * 			functions to register this hub with USBA.
+ *			implements and translates all of the USB level requests
+ *			into xhci specific implements. It also contains the
+ *			functions to register this hub with USBA.
  *
  * xhci_intr.c:		This manages the underlying interrupt allocation,
- * 			interrupt moderation, and interrupt routines.
+ *			interrupt moderation, and interrupt routines.
  *
  * xhci_quirks.c:	This manages information about buggy hardware that's
- * 			been collected and experienced primarily from other
- * 			systems.
+ *			been collected and experienced primarily from other
+ *			systems.
  *
  * xhci_ring.c:		This manages the abstraction of a ring in xhci, which is
- * 			the primary of communication between the driver and the
- * 			hardware, whether for the controller or a device.
+ *			the primary of communication between the driver and the
+ *			hardware, whether for the controller or a device.
  *
  * xhci_usba.c:		This implements all of the HCDI functions required by
- * 			USBA. This is the main entry point that drivers and the
- * 			kernel frameworks will reach to start any operation.
- * 			Many functions here will end up in the command and
- * 			endpoint code.
+ *			USBA. This is the main entry point that drivers and the
+ *			kernel frameworks will reach to start any operation.
+ *			Many functions here will end up in the command and
+ *			endpoint code.
  *
  * xhci.c:		This provides the main kernel DDI interfaces and
- * 			performs device initialization.
+ *			performs device initialization.
  *
  * xhci.h:		This is the primary header file which defines
- * 			illumos-specific data structures and constants to manage
- * 			the system.
+ *			illumos-specific data structures and constants to manage
+ *			the system.
  *
  * xhcireg.h:		This header file defines all of the register offsets,
- * 			masks, and related macros. It also contains all of the
- * 			constants that are used in various structures as defined
- * 			by the specification, such as command offsets, etc.
+ *			masks, and related macros. It also contains all of the
+ *			constants that are used in various structures as defined
+ *			by the specification, such as command offsets, etc.
  *
  * xhci_ioctl.h:	This contains a few private ioctls that are used by a
- * 			private debugging command. These are private.
+ *			private debugging command. These are private.
  *
  * cmd/xhci/xhci_portsc:	This is a private utility that can be useful for
- * 				debugging xhci state. It is the only consumer of
- * 				xhci_ioctl.h and the private ioctls.
+ *				debugging xhci state. It is the only consumer of
+ *				xhci_ioctl.h and the private ioctls.
  *
  * ----------------------------------
  * xHCI Overview and Structure Layout
@@ -2211,7 +2211,7 @@ static struct dev_ops xhci_dev_ops = {
 	&xhci_cb_ops,			/* devo_cb_ops */
 	&usba_hubdi_busops,		/* devo_bus_ops */
 	usba_hubdi_root_hub_power,	/* devo_power */
-	ddi_quiesce_not_supported 	/* devo_quiesce */
+	ddi_quiesce_not_supported	/* devo_quiesce */
 };
 
 static struct modldrv xhci_modldrv = {
diff --git a/usr/src/uts/common/sys/usb/hcd/xhci/xhcireg.h b/usr/src/uts/common/sys/usb/hcd/xhci/xhcireg.h
index 8b5bc3916d..384705d481 100644
--- a/usr/src/uts/common/sys/usb/hcd/xhci/xhcireg.h
+++ b/usr/src/uts/common/sys/usb/hcd/xhci/xhcireg.h
@@ -398,7 +398,7 @@ extern "C" {
 /*
  * TRB flags that are used between different different TRB types.
  */
-#define	XHCI_TRB_CYCLE		(1 << 0) 	/* Enqueue point of xfer ring */
+#define	XHCI_TRB_CYCLE		(1 << 0)	/* Enqueue point of xfer ring */
 #define	XHCI_TRB_ENT		(1 << 1)	/* Evaluate next TRB */
 #define	XHCI_TRB_LINKSEG	XHCI_TRB_ENT	/* Link to next segment */
 #define	XHCI_TRB_ISP		(1 << 2)	/* Interrupt on short packet */
@@ -461,7 +461,7 @@ extern "C" {
 #define	XHCI_CMD_RESET_DEV	(17 << 10)
 #define	XHCI_CMD_FEVENT		(18 << 10)
 #define	XHCI_CMD_NEG_BW		(19 << 10)
-#define	XHCI_CMD_SET_LT  	(20 << 10)
+#define	XHCI_CMD_SET_LT		(20 << 10)
 #define	XHCI_CMD_GET_BW		(21 << 10)
 #define	XHCI_CMD_FHEADER	(22 << 10)
 #define	XHCI_CMD_NOOP		(23 << 10)
@@ -499,25 +499,25 @@ extern "C" {
 #define	XHCI_CODE_RING_OVERRUN	15	/* Empty ring when receiving isoc */
 #define	XHCI_CODE_VF_RING_FULL	16	/* VF's event ring is full */
 #define	XHCI_CODE_PARAMETER	17	/* Context parameter is invalid */
-#define	XHCI_CODE_BW_OVERRUN	18 	/* TD exceeds the bandwidth */
+#define	XHCI_CODE_BW_OVERRUN	18	/* TD exceeds the bandwidth */
 #define	XHCI_CODE_CONTEXT_STATE	19	/* Transition from illegal ctx state */
 #define	XHCI_CODE_NO_PING_RESP	20	/* Unable to complete periodic xfer */
 #define	XHCI_CODE_EV_RING_FULL	21	/* Unable to post an evt to the ring */
 #define	XHCI_CODE_INCOMPAT_DEV	22	/* Device cannot be accessed */
 #define	XHCI_CODE_MISSED_SRV	23	/* Unable to service isoc EP in ESIT */
-#define	XHCI_CODE_CMD_RING_STOP	24 	/* Command Stop (CS) requested */
-#define	XHCI_CODE_CMD_ABORTED	25 	/* Command Abort (CA) operation */
-#define	XHCI_CODE_XFER_STOPPED	26 	/* xfer terminated by a stop endpoint */
-#define	XHCI_CODE_XFER_STOPINV	27 	/* TRB transfer length invalid */
+#define	XHCI_CODE_CMD_RING_STOP	24	/* Command Stop (CS) requested */
+#define	XHCI_CODE_CMD_ABORTED	25	/* Command Abort (CA) operation */
+#define	XHCI_CODE_XFER_STOPPED	26	/* xfer terminated by a stop endpoint */
+#define	XHCI_CODE_XFER_STOPINV	27	/* TRB transfer length invalid */
 #define	XHCI_CODE_XFER_STOPSHORT	28 	/* Stopped before end of TD */
 #define	XHCI_CODE_MELAT		29	/* Max Exit Latency too large */
 #define	XHCI_CODE_RESERVED	30
 #define	XHCI_CODE_ISOC_OVERRUN	31	/* IN data buffer < Max ESIT Payload */
-#define	XHCI_CODE_EVENT_LOST	32 	/* Internal overrun - impl. specific */
-#define	XHCI_CODE_UNDEFINED	33 	/* Fatal error - impl. specific */
-#define	XHCI_CODE_INVALID_SID	34 	/* Invalid stream ID received */
-#define	XHCI_CODE_SEC_BW	35 	/* Cannot alloc secondary BW Domain */
-#define	XHCI_CODE_SPLITERR	36 	/* USB2 split transaction */
+#define	XHCI_CODE_EVENT_LOST	32	/* Internal overrun - impl. specific */
+#define	XHCI_CODE_UNDEFINED	33	/* Fatal error - impl. specific */
+#define	XHCI_CODE_INVALID_SID	34	/* Invalid stream ID received */
+#define	XHCI_CODE_SEC_BW	35	/* Cannot alloc secondary BW Domain */
+#define	XHCI_CODE_SPLITERR	36	/* USB2 split transaction */
 
 #ifdef __cplusplus
 }
