commit d165f72f81882e39e63f50410819a0aba974ac98 (refs/changes/58/1958/1)
Author: Richard Bradley <richard.bradley@joyent.com>
Date:   2017-05-16T09:23:00+00:00 (2 years, 5 months ago)
    
    RFD 84 Support additional properties in update config

diff --git a/lib/adm.js b/lib/adm.js
index 984a7e0..c897855 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -1177,6 +1177,9 @@ maAdm.prototype.dumpDeployedConfigByServiceJson = function (sout, conf)
 	});
 
 	rv = {};
+	rv['metadata'] = {
+	    'v': 2
+	};
 	svcuuids.forEach(function (svcid) {
 		var svcname, cnid, sc;
 
@@ -1356,6 +1359,8 @@ maAdm.prototype.loadInstances = function ()
 
 	var services, rv, svcid, i, svcname, svckey;
 	var instance, metadata, server, gz, image, row, ip, version;
+	var default_untrusted, untrusted_networks, untrusted_nics,
+	    nondefault_untrusted_nics;
 
 	services = this.ma_services;
 	rv = [];
@@ -1364,7 +1369,15 @@ maAdm.prototype.loadInstances = function ()
 
 	for (svcid in this.ma_instances) {
 		svcname = services[svcid]['name'];
-		svckey = svcs.serviceConfigProperties(svcname);
+		svckey = this.keyForService(svcname);
+
+		/*
+		 * XXX shouldn't assume services has these properties
+		 */
+		default_untrusted = services[svcid]['params']['networks']
+		    .filter(function (n) {
+			return (n !== 'manta' && n !== 'admin');
+		});
 
 		this.ma_config_bycfg[svcid] =
 		    new svcs.ServiceConfiguration(svckey);
@@ -1386,6 +1399,44 @@ maAdm.prototype.loadInstances = function ()
 			ip = this.primaryIpForZone(instance['uuid']) || '-';
 			version = this.ma_images.hasOwnProperty(image) ?
 			    this.ma_images[image]['version'] : '-';
+			if (this.ma_vms.hasOwnProperty(instance['uuid'])) {
+				untrusted_nics = this.ma_vms[
+				    instance['uuid']].nics
+				    .filter(function (n) {
+					if (n.nic_tag !== 'manta' &&
+					    n.nic_tag !== 'admin') {
+						return (n);
+					}
+				});
+
+				nondefault_untrusted_nics = untrusted_nics.
+				    filter(function (n) {
+					/*
+					 * XXX Assumes tag names match net names
+					 */
+					return (default_untrusted.indexOf(
+					    n.nic_tag) < 0);
+				});
+
+				if (nondefault_untrusted_nics.length) {
+					untrusted_networks = untrusted_nics.map(
+					    function (n) {
+						var itf = {
+						    'ipv4_uuid': n.network_uuid
+						};
+						if (n.primary)
+							itf.primary = n.primary;
+						return (itf);
+					});
+				} else if (!untrusted_nics.length &&
+				    default_untrusted.length) {
+					untrusted_networks = [];
+				} else {
+					untrusted_networks = '-';
+				}
+			} else {
+				untrusted_networks = '-';
+			}
 
 			if (gz && svcname == 'storage') {
 				gz['storage'] = true;
@@ -1412,7 +1463,8 @@ maAdm.prototype.loadInstances = function ()
 			    'ZONEABBR': instance['uuid'].substr(0, 8),
 			    'IMAGE': image,
 			    'STORAGE ID': metadata['MANTA_STORAGE_ID'] || '-',
-			    'VERSION': version
+			    'VERSION': version,
+			    'NETWORKS': untrusted_networks
 			};
 			rv.push(row);
 
@@ -1506,7 +1558,7 @@ maAdm.prototype.readConfigFromFile = function (filename, callback)
 
 maAdm.prototype.readConfigRaw = function (contents)
 {
-	var json, cnid, svcname, svckey, cfgs, sc;
+	var json, cnid, svcname, svckey, sc;
 
 	try {
 		json = JSON.parse(contents);
@@ -1516,19 +1568,21 @@ maAdm.prototype.readConfigRaw = function (contents)
 
 	this.ma_instances_wanted = {};
 	for (cnid in json) {
+		if (cnid === 'metadata')
+			continue;
 		this.ma_instances_wanted[cnid] = {};
 		for (svcname in json[cnid]) {
 			svckey = this.keyForService(svcname);
 			this.ma_instances_wanted[cnid][svcname] = sc =
 			    new svcs.ServiceConfiguration(svckey);
-			cfgs = jsprim.flattenObject(
-			    json[cnid][svcname], svckey.length);
-			cfgs.forEach(function (c) {
+			json[cnid][svcname].forEach(function (c) {
 				var row = {};
 				svckey.forEach(function (k, i) {
-					row[k] = c[i];
+					var t =
+					    svcs.mSvcPropertyTranslations[k];
+					row[k] = c[t] || '-';
 				});
-				sc.incr(row, c[c.length - 1]);
+				sc.incr(row, c['count']);
 			});
 		}
 	}
@@ -1632,10 +1686,10 @@ maAdm.prototype.generatePlan = function (callback, service, noreprovision)
 				    'service': svcname,
 				    'config': key,
 				    'delta': -config['count']
-				}, 'image not present in new config');
+				}, 'layout not present in new config');
 				self.plan(cnid, svcname, key,
 				    'deprovision', config['count'],
-				    'image no longer used');
+				    'layout no longer used');
 			});
 		}
 
@@ -1764,8 +1818,11 @@ maAdm.prototype.plan = function (cnid, service, configkey,
 maAdm.prototype.planSort = function (svcid, cnid, plan, allowreprovision)
 {
 	/*
-	 * Filter operations into buckets by the entire svckey, up to but
-	 * excluding the image.
+	 * Filter operations into sharded and non-sharded buckets. The reason
+	 * for this is because when we attempt to group provisions and
+	 * deprovisions later we never want to group based on a different
+	 * shard. We might, however, choose to group on another key, such as
+	 * IMAGE or NETWORKS.
 	 */
 	var planbyconfig = {};
 	var svcname = this.ma_services[svcid]['name'];
@@ -1773,8 +1830,7 @@ maAdm.prototype.planSort = function (svcid, cnid, plan, allowreprovision)
 	var rv = [];
 	var key;
 
-	assert.equal(svckey[svckey.length - 1], 'IMAGE');
-	svckey = svckey.slice(0, svckey.length - 1);
+	svckey = (svckey.indexOf('SH') !== -1) ? [ 'SH' ] : [];
 	plan.forEach(function (pe) {
 		var rawpartialkey = svckey.map(
 		    function (_, i) { return (pe['config'][i]); });
@@ -1861,18 +1917,30 @@ maAdm.prototype.planSortPartial = function (svcid, cnid, plan, allowreprovision)
 		assert.equal(p['service'], d['service']);
 		assert.ok(d['zonename']);
 		assert.ok(p['SH'] === d['SH']);
-		entry = {
-		    'cnid': p['cnid'],
-		    'service': p['service'],
-		    'action': 'reprovision',
-		    'zonename': d['zonename'],
-		    'shard': p['SH'],
-		    'old_image': d['IMAGE'],
-		    'new_image': p['IMAGE'],
-		    'old_reason': d['reason'],
-		    'new_reason': p['reason']
-		};
-		rv.push(entry);
+		/*
+		 * Today we only care if the image has changed, in which case,
+		 * if we're allowed, we'll combine the {,de}provision pair into
+		 * a single reprovision entry. In the future, we may want to
+		 * consider pairing based on some other part of the svckey (such
+		 * as NETWORKS) so that we can modify existing zones.
+		 */
+		if (p['IMAGE'] === d['IMAGE']) {
+			rv.push(p);
+			rv.push(d);
+		} else {
+			entry = {
+			    'cnid': p['cnid'],
+			    'service': p['service'],
+			    'action': 'reprovision',
+			    'zonename': d['zonename'],
+			    'shard': p['SH'],
+			    'old_image': d['IMAGE'],
+			    'new_image': p['IMAGE'],
+			    'old_reason': d['reason'],
+			    'new_reason': p['reason']
+			};
+			rv.push(entry);
+		}
 	}
 
 	/*
@@ -2024,6 +2092,8 @@ maAdm.prototype.execPlanSvcCn = function (sout, serr, cnid, svcname,
 				options.server_uuid = cnid;
 			if (p['SH'])
 				options.shard = p['SH'];
+			if (p['NETWORKS'] && p['NETWORKS'] !== '-')
+				options.networks = p['NETWORKS'];
 			assert(p['IMAGE'], 'image must be part of plan');
 			options.image_uuid = p['IMAGE'];
 
@@ -2034,7 +2104,8 @@ maAdm.prototype.execPlanSvcCn = function (sout, serr, cnid, svcname,
 			}, 'provisioning');
 			fprintf(serr, 'service "%s": provisioning\n', svcname);
 			for (k in options)
-				fprintf(serr, '    %11s: %s\n', k, options[k]);
+				fprintf(serr, '    %11s: %s\n', k,
+				    JSON.stringify(options[k]));
 			self.ma_deployer.deploy(options, svcname,
 			    function (err, zonename) {
 				if (err) {
@@ -2135,12 +2206,33 @@ maAdm.prototype.execPrintAction = function (sout, p)
 	} else if (p['action'] == 'provision') {
 		fprintf(sout, '    %sprovision (image %s)\n',
 		    p['SH'] ? 'shard ' + p['SH'] + ': ' : '', p['IMAGE']);
+		this.printActionOptions(sout, p);
 	} else {
 		assert.equal(p['action'], 'deprovision');
 		fprintf(sout, '    %sdeprovision zone %s\n' +
 		    '        (image: %s)\n',
 		    p['SH'] ? 'shard ' + p['SH'] + ': ' : '',
 		    p['zonename'], p['IMAGE']);
+		this.printActionOptions(sout, p);
+	}
+};
+
+maAdm.prototype.printActionOptions = function (sout, p)
+{
+	if (p.hasOwnProperty('NETWORKS')) {
+		if (p['NETWORKS'] === '-') {
+			fprintf(sout, '      networks: default\n');
+		} else if (p['NETWORKS'].length < 1) {
+			fprintf(sout, '      networks: none\n');
+		} else {
+			fprintf(sout, '      networks:\n');
+			p['NETWORKS'].forEach(function (n) {
+				Object.keys(n).forEach(function (k) {
+					fprintf(sout, '        %s: %s\n',
+					    k, n[k]);
+				});
+			});
+		}
 	}
 };
 
diff --git a/lib/deploy.js b/lib/deploy.js
index 9d3142f..7cd0d1f 100644
--- a/lib/deploy.js
+++ b/lib/deploy.js
@@ -28,6 +28,7 @@ var VError = require('verror').VError;
 exports.deploy = deploy;
 exports.createDeployer = createDeployer;
 
+var TRUSTED_NETWORKS = [ 'admin', 'manta' ];
 /*
  * Storage zone deployments cannot be done concurrently, so we funnel all
  * storage zone deployments through a vasync Queue with concurrency 1.  This is
@@ -773,13 +774,11 @@ function createInstance(self, app, svc, cb) {
 	if (self.options.image_uuid)
 		params.image_uuid = self.options.image_uuid;
 
-	if (self.options.networks) {
-		var networks = [];
-		self.options.networks.forEach(function (token) {
-			networks.push({ uuid: token });
-		});
-		params.networks = networks;
-	}
+	/*
+	 * XXX change here breaks existing usage in at least manta-deploy
+	 */
+	if (self.options.networks)
+		params.networks = self.options.networks;
 
 	var metadata = {};
 	metadata.DATACENTER = self.config.datacenter_name;
@@ -909,6 +908,56 @@ function createInstance(self, app, svc, cb) {
 				return (subcb(null));
 			});
 		},
+		function fetchTrustedNetworks(subcb) {
+			/*
+			 * SAPI will only provision instances with either their
+			 * default networks, OR a specific set of networks.
+			 * Because we only want operators to specify the
+			 * untrusted networks we must pad out their networks
+			 * with the trusted networks that SAPI would usually
+			 * default to.
+			 */
+			if (!params.networks) {
+				subcb(null);
+				return;
+			}
+
+			if (!svc.params || !svc.params.networks) {
+				subcb(new Error('no params.networks ' +
+				    'in service definition for ' + svc.name));
+				return;
+			}
+
+			var networks = [];
+			vasync.forEachParallel({
+				'func': function fetchNetworks(name, _cb) {
+					self.NAPI.listNetworks({
+					    'name': name
+					}, _cb);
+				},
+				'inputs': svc.params.networks
+			}, function (err, results) {
+				if (err) {
+					subcb(err);
+					return;
+				}
+
+				results.successes.forEach(function (n) {
+					networks = networks.concat(n);
+				});
+
+				params.networks = params.networks.concat(
+				    networks.filter(function (n) {
+					return (TRUSTED_NETWORKS.indexOf(
+					    n.name) !== -1);
+				}).map(function (n) {
+					return ({
+					    ipv4_uuid: n.uuid
+					});
+				}));
+				subcb(null);
+			});
+		},
 		function (subcb) {
 			var opts = {};
 			opts.params = params;
diff --git a/lib/services.js b/lib/services.js
index 06cd613..2b0a1a5 100644
--- a/lib/services.js
+++ b/lib/services.js
@@ -75,7 +75,21 @@ var mSvcConfigs = {
     'propeller':	{ 'oneach': true,  'sharded': false }
 };
 
+/*
+ * Properties differ slightly depending on whether they are the internal
+ * representation of the service or the definition from the config, so here we
+ * provide the translations.
+ */
+var mSvcPropertyTranslations = {
+    'SH': 'shard',
+    'NETWORKS': 'untrusted_networks',
+    'IMAGE': 'image_uuid'
+};
+
+var mSvcProperties = Object.keys(mSvcPropertyTranslations);
+
 exports.mSvcNames = mSvcNames;
+exports.mSvcPropertyTranslations = mSvcPropertyTranslations;
 
 /*
  * This is exposed for testing only!  There are functional interfaces for
@@ -166,7 +180,13 @@ ServiceConfiguration.prototype.get = function (config)
 		row = this.sc_counts[i];
 		for (k = 0; k < this.sc_keys.length; k++) {
 			key = this.sc_keys[k];
-			if (config[key] != row[key])
+			/*
+			 * XXX Assumes same order for NETWORKS
+			 *
+			 * This might be OK so long as the values we get
+			 * are sorted/normalised.
+			 */
+			if (!jsprim.deepEqual(config[key], row[key]))
 				break;
 		}
 
@@ -188,8 +208,9 @@ ServiceConfiguration.prototype.has = function (config)
 		row = this.sc_counts[i];
 		for (k = 0; k < this.sc_keys.length; k++) {
 			key = this.sc_keys[k];
-			if (config[key] != row[key])
+			if (!jsprim.deepEqual(config[key], row[key])) {
 				break;
+			}
 		}
 
 		if (k == this.sc_keys.length)
@@ -215,7 +236,7 @@ ServiceConfiguration.prototype.incr = function (config, count)
 		row = this.sc_counts[i];
 		for (k = 0; k < this.sc_keys.length; k++) {
 			key = this.sc_keys[k];
-			if (config[key] != row[key])
+			if (!jsprim.deepEqual(config[key], row[key]))
 				break;
 		}
 
@@ -237,9 +258,20 @@ ServiceConfiguration.prototype.incr = function (config, count)
  */
 ServiceConfiguration.prototype.summary = function ()
 {
-	var rv = {};
+	var rv, entry;
+	var self = this;
+
+	rv = [];
+
 	this.each(function (row, rowkey) {
-		common.insert(rv, row['count'], rowkey);
+		entry = {};
+		self.sc_keys.forEach(function (k) {
+			var t = mSvcPropertyTranslations[k];
+			if (row[k] !== '-')
+				entry[t] = row[k];
+		});
+		entry['count'] = row['count'];
+		rv.push(entry);
 	});
 	return (rv);
 };
@@ -261,7 +293,14 @@ function serviceIsSharded(svcname)
  */
 function serviceConfigProperties(svcname)
 {
-	return (serviceIsSharded(svcname) ? [ 'SH', 'IMAGE' ] : [ 'IMAGE' ]);
+	var properties;
+
+	if (serviceIsSharded(svcname))
+		return (mSvcProperties);
+
+	properties = mSvcProperties.slice();
+	properties.splice(mSvcProperties.indexOf('SH'), 1);
+	return (properties);
 }
 
 /*
