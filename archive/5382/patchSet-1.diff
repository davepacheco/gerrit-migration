commit f26fbf440b2a1673e342a512b1e6e1484c977559 (refs/changes/82/5382/1)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2019-01-17T23:22:57+00:00 (9 months ago)
    
    OS-5872 Need to handle SLOG failure better when the SLOG dies
    OS-6462 System hangs when slog device is removed from zpool

diff --git a/usr/src/test/zfs-tests/runfiles/smartos.run b/usr/src/test/zfs-tests/runfiles/smartos.run
index 0dc0bff43f..5eac753cde 100644
--- a/usr/src/test/zfs-tests/runfiles/smartos.run
+++ b/usr/src/test/zfs-tests/runfiles/smartos.run
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 [DEFAULT]
@@ -241,6 +241,12 @@ tests = ['rsend_001_pos', 'rsend_002_pos', 'rsend_003_pos', 'rsend_006_pos',
 tests = ['scrub_mirror_001_pos', 'scrub_mirror_002_pos',
     'scrub_mirror_003_pos', 'scrub_mirror_004_pos']
 
+[/opt/zfs-tests/tests/functional/slog]
+tests = ['slog_001_pos', 'slog_002_pos', 'slog_003_pos', 'slog_004_pos',
+    'slog_005_pos', 'slog_006_pos', 'slog_007_pos', 'slog_008_neg',
+    'slog_009_neg', 'slog_010_neg', 'slog_011_neg', 'slog_012_neg',
+    'slog_013_pos', 'slog_014_pos']
+
 [/opt/zfs-tests/tests/functional/snapshot]
 tests = ['clone_001_pos', 'rollback_001_pos', 'rollback_002_pos',
     'rollback_003_pos', 'snapshot_001_pos', 'snapshot_002_pos',
diff --git a/usr/src/test/zfs-tests/tests/functional/slog/slog.cfg b/usr/src/test/zfs-tests/tests/functional/slog/slog.cfg
index 6a28880ade..17f28abaac 100644
--- a/usr/src/test/zfs-tests/tests/functional/slog/slog.cfg
+++ b/usr/src/test/zfs-tests/tests/functional/slog/slog.cfg
@@ -26,10 +26,11 @@
 
 #
 # Copyright (c) 2013, 2015 by Delphix. All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
-export VDIR=/disk-slog
-export VDIR2=/disk2-slog
+export VDIR=/var/tmp/disk-slog
+export VDIR2=/var/tmp/disk2-slog
 
 export VDEV="$VDIR/a $VDIR/b $VDIR/c"
 export SDEV="$VDIR/d"
diff --git a/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh b/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
index 0190479e44..02e99fac45 100644
--- a/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
@@ -27,6 +27,7 @@
 
 #
 # Copyright (c) 2013, 2018 by Delphix. All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 . $STF_SUITE/tests/functional/slog/slog.kshlib
@@ -47,7 +48,7 @@ log_assert "log device can survive when one of the pool device get corrupted."
 
 for type in "mirror" "raidz" "raidz2"; do
 	for spare in "" "spare"; do
-		log_must $ZPOOL create $TESTPOOL $type $VDEV $spare $SDEV \
+		log_must zpool create $TESTPOOL $type $VDEV $spare $SDEV \
 			log $LDEV
 
                 # Create a file to be corrupted
diff --git a/usr/src/uts/common/fs/zfs/sys/zio.h b/usr/src/uts/common/fs/zfs/sys/zio.h
index c12cb70906..b998f6e229 100644
--- a/usr/src/uts/common/fs/zfs/sys/zio.h
+++ b/usr/src/uts/common/fs/zfs/sys/zio.h
@@ -24,7 +24,7 @@
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2012, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2019, Joyent, Inc. All rights reserved.
  * Copyright 2016 Toomas Soome <tsoome@me.com>
  */
 
@@ -371,8 +371,11 @@ typedef int zio_pipe_stage_t(zio_t *zio);
  * the reexecute flags are protected by io_lock, modifiable by children,
  * and always propagated -- even when ZIO_FLAG_DONT_PROPAGATE is set.
  */
-#define	ZIO_REEXECUTE_NOW	0x01
-#define	ZIO_REEXECUTE_SUSPEND	0x02
+#define	ZIO_REEXECUTE_NOW		0x01
+#define	ZIO_REEXECUTE_SUSPEND		0x02
+#define	ZIO_REEXECUTE_NO_SUSPEND	0x04
+
+#define	ZIO_REEXECUTE_MASK	(ZIO_REEXECUTE_SUSPEND | ZIO_REEXECUTE_NOW)
 
 typedef struct zio_alloc_list {
 	list_t  zal_list;
diff --git a/usr/src/uts/common/fs/zfs/zio.c b/usr/src/uts/common/fs/zfs/zio.c
index f9a6d52657..62e4506511 100644
--- a/usr/src/uts/common/fs/zfs/zio.c
+++ b/usr/src/uts/common/fs/zfs/zio.c
@@ -24,6 +24,7 @@
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
+ * Copyright (c) 2019 Joyent, Inc.
  */
 
 #include <sys/sysmacros.h>
@@ -3774,6 +3775,24 @@ zio_done(zio_t *zio)
 		}
 	}
 
+	/*
+	 * When we have an error on a slog vdev, we must ensure that the
+	 * zio is not suspended. Suspending the zio will cause dataset deletion
+	 * or an attempt to remove the slog to hang. In both cases, the code
+	 * might be trying to clean up the zil blocks on the slog, but because
+	 * the slog is dead, the suspended zio causes this to hang indefinitely.
+	 * The system properly switches over to using zils on regular storage
+	 * when the slog dies.
+	 *
+	 * This is a reasonable point in the stack to detect that the vdev is
+	 * a slog. The 'no_suspend' flag will propagate up to the logical zio
+	 * via zio_notify_parent.
+	 */
+	if (zio->io_error && vd != NULL && vd->vdev_islog &&
+	    !vdev_accessible(vd, zio)) {
+		zio->io_reexecute |= ZIO_REEXECUTE_NO_SUSPEND;
+	}
+
 	if (zio->io_error && zio == lio) {
 		/*
 		 * Determine whether zio should be reexecuted.  This will
@@ -3801,6 +3820,14 @@ zio_done(zio_t *zio)
 		if (!(zio->io_flags & ZIO_FLAG_CANFAIL) && !zio->io_reexecute)
 			zio->io_reexecute |= ZIO_REEXECUTE_SUSPEND;
 
+		/*
+		 * It is possible that we've set the 'suspend' bit above, but
+		 * if we're not supposed to suspend this zio because it is on
+		 * a failed slog, clear this bit.
+		 */
+		if (zio->io_reexecute & ZIO_REEXECUTE_NO_SUSPEND)
+			zio->io_reexecute &= ~ZIO_REEXECUTE_SUSPEND;
+
 		/*
 		 * Here is a possibly good place to attempt to do
 		 * either combinatorial reconstruction or error correction
@@ -3818,7 +3845,7 @@ zio_done(zio_t *zio)
 	 */
 	zio_inherit_child_errors(zio, ZIO_CHILD_LOGICAL);
 
-	if ((zio->io_error || zio->io_reexecute) &&
+	if ((zio->io_error || (zio->io_reexecute & ZIO_REEXECUTE_MASK)) &&
 	    IO_IS_ALLOCATING(zio) && zio->io_gang_leader == zio &&
 	    !(zio->io_flags & (ZIO_FLAG_IO_REWRITE | ZIO_FLAG_NOPWRITE)))
 		zio_dva_unallocate(zio, zio->io_gang_tree, bp);
@@ -3832,7 +3859,7 @@ zio_done(zio_t *zio)
 	    (zio->io_reexecute & ZIO_REEXECUTE_SUSPEND))
 		zio->io_reexecute = 0;
 
-	if (zio->io_reexecute) {
+	if (zio->io_reexecute & ZIO_REEXECUTE_MASK) {
 		/*
 		 * This is a logical I/O that wants to reexecute.
 		 *
@@ -3903,7 +3930,7 @@ zio_done(zio_t *zio)
 	}
 
 	ASSERT(zio->io_child_count == 0);
-	ASSERT(zio->io_reexecute == 0);
+	ASSERT((zio->io_reexecute & ZIO_REEXECUTE_MASK) == 0);
 	ASSERT(zio->io_error == 0 || (zio->io_flags & ZIO_FLAG_CANFAIL));
 
 	/*
