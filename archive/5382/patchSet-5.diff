From 1279be0c34f003e6e7b56292886b1d50a3e7beaf Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Wed, 23 Jan 2019 16:14:01 +0000
Subject: [PATCH] OS-5872 Need to handle SLOG failure better when the SLOG dies
 OS-6462 System hangs when slog device is removed from zpool

---
 usr/src/uts/common/fs/zfs/sys/zio.h | 12 +++++++++---
 usr/src/uts/common/fs/zfs/zio.c     | 25 ++++++++++++++++++++++---
 2 files changed, 31 insertions(+), 6 deletions(-)

diff --git a/usr/src/uts/common/fs/zfs/sys/zio.h b/usr/src/uts/common/fs/zfs/sys/zio.h
index c12cb70906..f702cf1337 100644
--- a/usr/src/uts/common/fs/zfs/sys/zio.h
+++ b/usr/src/uts/common/fs/zfs/sys/zio.h
@@ -24,7 +24,7 @@
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2012, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2019, Joyent, Inc. All rights reserved.
  * Copyright 2016 Toomas Soome <tsoome@me.com>
  */
 
@@ -371,8 +371,14 @@ typedef int zio_pipe_stage_t(zio_t *zio);
  * the reexecute flags are protected by io_lock, modifiable by children,
  * and always propagated -- even when ZIO_FLAG_DONT_PROPAGATE is set.
  */
-#define	ZIO_REEXECUTE_NOW	0x01
-#define	ZIO_REEXECUTE_SUSPEND	0x02
+#define	ZIO_REEXECUTE_NOW		0x01
+#define	ZIO_REEXECUTE_SUSPEND		0x02
+#define	ZIO_REEXECUTE_NO_SUSPEND	0x04
+
+#define	ZIO_SHOULD_REEXECUTE(x)		\
+	((x)->io_reexecute & ZIO_REEXECUTE_NOW || \
+	((x)->io_reexecute & ZIO_REEXECUTE_SUSPEND && \
+	(((x)->io_reexecute & ZIO_REEXECUTE_NO_SUSPEND) == 0)))
 
 typedef struct zio_alloc_list {
 	list_t  zal_list;
diff --git a/usr/src/uts/common/fs/zfs/zio.c b/usr/src/uts/common/fs/zfs/zio.c
index f9a6d52657..e56498e32d 100644
--- a/usr/src/uts/common/fs/zfs/zio.c
+++ b/usr/src/uts/common/fs/zfs/zio.c
@@ -24,6 +24,7 @@
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
+ * Copyright (c) 2019 Joyent, Inc.
  */
 
 #include <sys/sysmacros.h>
@@ -3774,6 +3775,24 @@ zio_done(zio_t *zio)
 		}
 	}
 
+	/*
+	 * When we have an error on a slog vdev, we must ensure that the
+	 * zio is not suspended. Suspending the zio will cause dataset deletion
+	 * or an attempt to remove the slog to hang. In both cases, the code
+	 * might be trying to clean up the zil blocks on the slog, but because
+	 * the slog is dead, the suspended zio causes this to hang indefinitely.
+	 * The system properly switches over to using zils on regular storage
+	 * when the slog dies.
+	 *
+	 * This is a reasonable point in the stack to detect that the vdev is
+	 * a slog. The 'no_suspend' flag will propagate up to the logical zio
+	 * via zio_notify_parent.
+	 */
+	if (zio->io_error && vd != NULL && vd->vdev_islog &&
+	    !vdev_accessible(vd, zio)) {
+		zio->io_reexecute |= ZIO_REEXECUTE_NO_SUSPEND;
+	}
+
 	if (zio->io_error && zio == lio) {
 		/*
 		 * Determine whether zio should be reexecuted.  This will
@@ -3818,7 +3837,7 @@ zio_done(zio_t *zio)
 	 */
 	zio_inherit_child_errors(zio, ZIO_CHILD_LOGICAL);
 
-	if ((zio->io_error || zio->io_reexecute) &&
+	if ((zio->io_error || ZIO_SHOULD_REEXECUTE(zio)) &&
 	    IO_IS_ALLOCATING(zio) && zio->io_gang_leader == zio &&
 	    !(zio->io_flags & (ZIO_FLAG_IO_REWRITE | ZIO_FLAG_NOPWRITE)))
 		zio_dva_unallocate(zio, zio->io_gang_tree, bp);
@@ -3832,7 +3851,7 @@ zio_done(zio_t *zio)
 	    (zio->io_reexecute & ZIO_REEXECUTE_SUSPEND))
 		zio->io_reexecute = 0;
 
-	if (zio->io_reexecute) {
+	if (ZIO_SHOULD_REEXECUTE(zio)) {
 		/*
 		 * This is a logical I/O that wants to reexecute.
 		 *
@@ -3903,7 +3922,7 @@ zio_done(zio_t *zio)
 	}
 
 	ASSERT(zio->io_child_count == 0);
-	ASSERT(zio->io_reexecute == 0);
+	ASSERT(!ZIO_SHOULD_REEXECUTE(zio));
 	ASSERT(zio->io_error == 0 || (zio->io_flags & ZIO_FLAG_CANFAIL));
 
 	/*
-- 
2.21.0

