commit 6f3e524fcdacd0f0bd906fd1b07dd24332353029 (refs/changes/92/3592/3)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2018-03-13T16:59:53-07:00 (1 year, 7 months ago)
    
    TRITON-53 x-account image clone

diff --git a/docs/index.md b/docs/index.md
index 3247168..10f1838 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -3791,6 +3791,75 @@ ResourceNotFound | If `:login` or `:id` does not exist
 
 
 
+## CloneImage (POST /:login/images/:id?action=clone)
+
+Clones a shared image.
+
+### Inputs
+
+None.
+
+### Returns
+
+A cloned image object. See [GetImage](#GetImage) docs for the image fields
+returned.
+
+### Errors
+
+For general errors, see [CloudAPI HTTP Responses](#cloudapi-http-responses).
+Some typical and specific errors for this endpoint:
+
+**Error Code**     | **Description**
+------------------ | ---------------
+ResourceNotFound   | If `:login` or `:id` does not exist.
+NotImageOwnerError | If your account is not the owner of the image.
+ImageNotShared     | When the given image is not shared with your account.
+
+### Example CLI Command
+
+    $ triton clone eca995fe-b904-11e3-b05a-83a4899322dc
+
+#### Example HTTP Request
+
+    POST /my/images/eca995fe-b904-11e3-b05a-83a4899322dc?action=clone HTTP/1.1
+    Authorization: ...
+    Host: api.example.com
+    Accept: application/json
+    Api-Version: ~8
+
+#### Example HTTP Response
+
+    HTTP/1.1 200 OK
+    Content-Type: application/json
+    Content-Length: 125
+    Access-Control-Allow-Origin: *
+    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, Api-Version, Response-Time
+    Access-Control-Allow-Methods: GET, HEAD, POST
+    Access-Control-Expose-Headers: Api-Version, Request-Id, Response-Time
+    Connection: Keep-Alive
+    Content-MD5: 2sEZ45LmhRiretMPn5sqVA==
+    Date: Thu, 21 Jan 2016 08:00:09 GMT
+    Server: Joyent Triton 8.0.0
+    Api-Version: 8.0.0
+    Request-Id: f8e43c60-b904-11e3-93b7-1f685001b0c3
+    Response-Time: 135
+
+    {
+      "id": "4ca995fe-b904-11e3-b05a-83a4899322dc",
+      "name": "some-image",
+      "version": "1.0.0",
+      "os": "smartos",
+      "requirements": {},
+      "type": "zone-dataset",
+      "published_at": "2017-11-25T17:44:54Z",
+      "owner": "77034e57-42d1-0342-b302-00db733e8c8a",
+      "public": true,
+      "state": "active"
+    }
+
+
+
+
 # Packages
 
 [Packages](#packages-description) are named collections of resources that are
@@ -4380,6 +4449,7 @@ metadata.$name | String | An arbitrary set of metadata key/value pairs can be se
 tag.$name | String   | An arbitrary set of tags can be set at provision time, but they must be prefixed with "tag."
 firewall_enabled | Boolean | Completely enable or disable firewall for this instance. Default is false
 deletion_protection | Boolean | Whether an instance is destroyable. See [Deletion Protection](#deletion-protection). Default is false
+allow_shared_images | Boolean | Whether to allow provisioning from a shared image. Default is false
 volumes   | Array    | A list of objects representing volumes to mount when the newly created machine boots
 
 #### volumes
@@ -10220,6 +10290,7 @@ Sample code for generating the `Authorization` header (and `Date` header):
 ------------------- | ------------------ | ---------------
 [sdc-addmachinetags](#AddMachineTags)|[triton instance tag set](#AddMachineTags)|Allows you to add additional tags, other than those set at provisioning time.
 [sdc-chmod](#SetRoleTags)|-|Add role tags to CloudAPI resources.
+[sdc-cloneimage](#CloneImage)|-|Clone a shared image.
 [sdc-createfirewallrule](#CreateFirewallRule)|[triton fwrule create](#CreateFirewallRule)|Add a new firewall rule.
 [sdc-createimagefrommachine](#CreateImageFromMachine)|[triton image create](#CreateImageFromMachine)|Create a new custom image from an instance.
 [sdc-createinstrumentation](#CreateInstrumentation)|-|Creates an instrumentation.
diff --git a/lib/datasets.js b/lib/datasets.js
index 1a0520c..d9d8e47 100644
--- a/lib/datasets.js
+++ b/lib/datasets.js
@@ -587,6 +587,35 @@ function exportImage(req, res, next) {
 }
 
 
+function clone(req, res, next) {
+    var log = req.log;
+    var action = req.params.action;
+    var account = req.account.uuid;
+
+    if (action !== 'clone') {
+        return next();
+    }
+
+    var imageUUID = req.params.image || req.params.dataset;
+    var opts = {
+        headers: {
+            'x-request-id': req.getId()
+        }
+    };
+
+    return req.sdc.imgapi.cloneImage(imageUUID, account, opts,
+            function (err, img) {
+        if (err) {
+            return next(err);
+        }
+
+        log.debug('CloneImage(%s) => %j %s', req.account.login, img);
+        res.send(translate(req, img));
+        return next(false);
+    });
+}
+
+
 function del(req, res, next) {
     return req.sdc.imgapi.deleteImage(
         req.dataset.uuid,
@@ -649,7 +678,7 @@ function mount(server, before, config) {
         path: '/:account/images/:dataset',
         name: 'UpdateImage',
         version: ['7.0.0', '7.1.0', '7.2.0', '7.3.0', '8.0.0']
-    }, before, update, exportImage,
+    }, before, update, exportImage, clone,
         function invalidUpdateAction(req, res, next) {
             if (req.query.action) {
                 return next(new InvalidArgumentError(
diff --git a/lib/machines.js b/lib/machines.js
index f1c548a..6cc03f4 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -1130,6 +1130,15 @@ function ensureDataset(req, res, next) {
         return next(new InvalidArgumentError('image %s is not active',
                                                 req.params.dataset));
     }
+    // TRITON-53 Shared images are not provisionable by default.
+    if (!req.dataset.public && req.dataset.owner !== req.account.uuid &&
+            (!req.params ||
+            req.params['allow_shared_images'] !== true)) {
+        return next(new InvalidArgumentError(
+            '%s is a shared image - to provision a shared image you can ' +
+            'either clone the image or set "allow_shared_images" to true.',
+            req.params.dataset));
+    }
     return next();
 }
 
diff --git a/package.json b/package.json
index 7299888..ed50d5a 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "cloudapi",
     "description": "SmartDataCenter CloudAPI",
-    "version": "8.8.0",
+    "version": "8.9.0",
     "author": "Joyent (joyent.com)",
     "private": true,
     "engines": {
@@ -34,7 +34,7 @@
         "nodemailer": "0.3.29",
         "nopt": "2.0.0",
         "restify": "4.3.0",
-        "sdc-clients": "10.4.0",
+        "sdc-clients": "10.6.0",
         "semver": "5.4.1",
         "strsplit": "1.0.0",
         "ufds": "1.3.0",
diff --git a/test/images.80.test.js b/test/images.80.test.js
index 03bf04f..7eca4f3 100644
--- a/test/images.80.test.js
+++ b/test/images.80.test.js
@@ -147,6 +147,10 @@ test('Search image type, results', function (t) {
     });
 });
 
+test('Image cloning', function (t) {
+    var imageCloneTestSuite = require('./images/clone.js');
+    imageCloneTestSuite(t, CLIENTS);
+});
 
 test('teardown', function (t) {
     common.teardown(CLIENTS, SERVER, function (err) {
diff --git a/test/images/clone.js b/test/images/clone.js
new file mode 100644
index 0000000..018dac4
--- /dev/null
+++ b/test/images/clone.js
@@ -0,0 +1,212 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var jsprim = require('jsprim');
+var libuuid = require('libuuid');
+var util = require('util');
+var vasync = require('vasync');
+
+var common = require('../common');
+var machinesCommon = require('../machines/common');
+
+
+// --- Globals
+
+// --- Tests for image sharing and image cloning.
+
+module.exports = function ImageCloneTestSuite(suite, clients) {
+    var client = clients.user;
+    var clonedImg;
+    var customImg;
+    var other = clients.other;
+    var setupWasSuccessful = false;
+    var test = suite.test;
+    var testImg;
+
+    /**
+     * Test setup
+     *
+     * In order to test image sharing - we first need to create an imgapi image
+     * that is owned by our test user (and make it a private image). We do this
+     * by taking an existing public image and manually copy it into the users
+     * own custom image.
+     */
+
+    test('Image clone setup', function (t) {
+        vasync.pipeline({ arg: {}, funcs: [
+            function getImage(_, next) {
+                common.getTestImage(client, function (err, img) {
+                    t.ifError(err, 'Image sharing: getTestImage');
+                    testImg = img;
+                    next(err);
+                });
+            },
+            function getImageFileStream(ctx, next) {
+                client.imgapi.getImageFileStream(testImg.id,
+                        function (err, stream) {
+                    t.ifError(err, 'Image sharing: getImageFileStream');
+                    // Stream has to be paused, for addImageFile call.
+                    if (stream) {
+                        stream.pause();
+                        ctx.filestream = stream;
+                    }
+                    next(err);
+                });
+            },
+            function createCustomImage(ctx, next) {
+                var newImgManifest = jsprim.deepCopy(testImg);
+                newImgManifest.owner = client.account.uuid;
+                newImgManifest.public = false;
+                delete newImgManifest.id;
+                delete newImgManifest.state;
+                delete newImgManifest.files;
+                delete newImgManifest.published_at;
+                client.imgapi.createImage(newImgManifest,
+                        function (err, newImg) {
+                    t.ifError(err, 'Image sharing: createCustomImage');
+                    customImg = newImg;
+                    next(err);
+                });
+            },
+            function imgapiImportImageFile(ctx, next) {
+                var file = testImg.files[0];
+                var opts = {
+                    compression: file.compression,
+                    file: ctx.filestream,
+                    sha1: file.sha1,
+                    size: file.size,
+                    storage: 'local',
+                    uuid: customImg.uuid
+                };
+                client.imgapi.addImageFile(opts, next);
+            },
+            function imgapiActivateImage(ctx, next) {
+                client.imgapi.activateImage(customImg.uuid, next);
+            }
+        ]}, function (err) {
+            if (err) {
+                t.fail('Image clone setup unsuccessful: ' + err);
+            } else {
+                setupWasSuccessful = true;
+            }
+            t.end();
+        });
+    });
+
+    function checkSetupSuccessful(t) {
+        if (!setupWasSuccessful) {
+            t.fail('Image sharing setup was unsuccessful');
+            t.end();
+            return false;
+        }
+        return true;
+    }
+
+    test('Image share', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        var data = {
+            acl: [ other.account.uuid ]
+        };
+        client.post(util.format('/my/images/%s?action=update', customImg.uuid),
+                data, function (err, req, res, img) {
+            t.ifError(err, 'no err on image share with other user');
+            t.equal(res.statusCode, 200, 'res.statusCode');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.ok(Array.isArray(img.acl), 'image has an ACL array');
+                t.ok(img.acl.indexOf(other.account.uuid) >= 0,
+                    'image ACL now contains other account');
+            }
+            t.end();
+        });
+    });
+
+    test('Image clone', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        var data = {};
+        other.post(util.format('/my/images/%s?action=clone', customImg.uuid),
+                data, function (err, req, res, img) {
+            t.ifError(err, 'no err on image share with other user');
+            t.equal(res.statusCode, 200, 'res.statusCode');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.notEqual(img.id, customImg.uuid, 'cloned image has own id');
+                t.ok(!(img.acl), 'image has an ACL array');
+                clonedImg = img;
+            }
+            t.end();
+        });
+    });
+
+    test('Image ACL no longer contains other', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.get(util.format('/my/images/%s', customImg.uuid),
+                function (err, req, res, img) {
+            t.ifError(err, 'no err on image get');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.equal(img.id, customImg.uuid, 'original image has same id');
+                if (!img.acl || img.acl.length === 0) {
+                    t.ok(true, 'image now has no ACL - good');
+                } else {
+                    t.equal(img.acl.indexOf(other.account.uuid), -1,
+                        'image ACL should not contain other account');
+                }
+            }
+            t.end();
+        });
+    });
+
+    test('Delete the cloned image as original user', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.del(util.format('/my/images/%s', clonedImg.id),
+                function (err) {
+            t.ok(err, 'should be an error trying to delete');
+            t.end();
+        });
+    });
+
+    test('Delete the cloned image as clone user', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        other.del(util.format('/my/images/%s', clonedImg.id),
+                function (err) {
+            t.ifError(err, 'check for delete cloned image err');
+            t.end();
+        });
+    });
+
+    test('Recheck original image', function (t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.get(util.format('/my/images/%s', customImg.uuid),
+                function (err, req, res, img) {
+            t.ifError(err, 'should be no err on image get');
+            t.ok(img, 'expect an image response object');
+            t.end();
+        });
+    });
+};
