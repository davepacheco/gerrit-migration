From 23a14ea20c230c11bbcffae43ed605387c95ac65 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Wed, 11 Apr 2018 12:27:47 -0700
Subject: [PATCH] TRITON-53 x-account image clone

---
 docs/index.md          |  75 ++++++++++++
 lib/datasets.js        |  31 ++++-
 lib/machines.js        |   8 ++
 package.json           |   4 +-
 test/images.80.test.js |   4 +
 test/images/clone.js   | 257 +++++++++++++++++++++++++++++++++++++++++
 6 files changed, 376 insertions(+), 3 deletions(-)
 create mode 100644 test/images/clone.js

diff --git a/docs/index.md b/docs/index.md
index 40a9222..56c95a5 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -908,6 +908,10 @@ The set of supported *API versions* is given in the ping endpoint:
 
 The section describes API changes in CloudAPI versions.
 
+## 8.11.0
+
+- Added [Clone Image](#CloneImage). Used to create a copy of a shared image.
+
 ## 8.10.0
 
 - GetImage now includes information about the brand requirements in the
@@ -3812,6 +3816,75 @@ ResourceNotFound | If `:login` or `:id` does not exist
 
 
 
+## CloneImage (POST /:login/images/:id?action=clone)
+
+Clones a shared image.
+
+### Inputs
+
+None.
+
+### Returns
+
+A cloned image object. See [GetImage](#GetImage) docs for the image fields
+returned.
+
+### Errors
+
+For general errors, see [CloudAPI HTTP Responses](#cloudapi-http-responses).
+Some typical and specific errors for this endpoint:
+
+**Error Code**     | **Description**
+------------------ | ---------------
+ResourceNotFound   | If `:login` or `:id` does not exist.
+NotImageOwnerError | If your account is not the owner of the image.
+ImageNotShared     | When the given image is not shared with your account.
+
+### Example CLI Command
+
+    $ triton clone eca995fe-b904-11e3-b05a-83a4899322dc
+
+#### Example HTTP Request
+
+    POST /my/images/eca995fe-b904-11e3-b05a-83a4899322dc?action=clone HTTP/1.1
+    Authorization: ...
+    Host: api.example.com
+    Accept: application/json
+    Api-Version: ~8
+
+#### Example HTTP Response
+
+    HTTP/1.1 200 OK
+    Content-Type: application/json
+    Content-Length: 125
+    Access-Control-Allow-Origin: *
+    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, Api-Version, Response-Time
+    Access-Control-Allow-Methods: GET, HEAD, POST
+    Access-Control-Expose-Headers: Api-Version, Request-Id, Response-Time
+    Connection: Keep-Alive
+    Content-MD5: 2sEZ45LmhRiretMPn5sqVA==
+    Date: Thu, 21 Jan 2016 08:00:09 GMT
+    Server: Joyent Triton 8.0.0
+    Api-Version: 8.0.0
+    Request-Id: f8e43c60-b904-11e3-93b7-1f685001b0c3
+    Response-Time: 135
+
+    {
+      "id": "4ca995fe-b904-11e3-b05a-83a4899322dc",
+      "name": "some-image",
+      "version": "1.0.0",
+      "os": "smartos",
+      "requirements": {},
+      "type": "zone-dataset",
+      "published_at": "2017-11-25T17:44:54Z",
+      "owner": "77034e57-42d1-0342-b302-00db733e8c8a",
+      "public": true,
+      "state": "active"
+    }
+
+
+
+
 # Packages
 
 [Packages](#packages-description) are named collections of resources that are
@@ -4401,6 +4474,7 @@ metadata.$name | String | An arbitrary set of metadata key/value pairs can be se
 tag.$name | String   | An arbitrary set of tags can be set at provision time, but they must be prefixed with "tag."
 firewall_enabled | Boolean | Completely enable or disable firewall for this instance. Default is false
 deletion_protection | Boolean | Whether an instance is destroyable. See [Deletion Protection](#deletion-protection). Default is false
+allow_shared_images | Boolean | Whether to allow provisioning from a shared image. Default is false
 volumes   | Array    | A list of objects representing volumes to mount when the newly created machine boots
 
 #### volumes
@@ -10241,6 +10315,7 @@ Sample code for generating the `Authorization` header (and `Date` header):
 ------------------- | ------------------ | ---------------
 [sdc-addmachinetags](#AddMachineTags)|[triton instance tag set](#AddMachineTags)|Allows you to add additional tags, other than those set at provisioning time.
 [sdc-chmod](#SetRoleTags)|-|Add role tags to CloudAPI resources.
+[sdc-cloneimage](#CloneImage)|-|Clone a shared image.
 [sdc-createfirewallrule](#CreateFirewallRule)|[triton fwrule create](#CreateFirewallRule)|Add a new firewall rule.
 [sdc-createimagefrommachine](#CreateImageFromMachine)|[triton image create](#CreateImageFromMachine)|Create a new custom image from an instance.
 [sdc-createinstrumentation](#CreateInstrumentation)|-|Creates an instrumentation.
diff --git a/lib/datasets.js b/lib/datasets.js
index dbd3705..a295b81 100644
--- a/lib/datasets.js
+++ b/lib/datasets.js
@@ -591,6 +591,35 @@ function exportImage(req, res, next) {
 }
 
 
+function clone(req, res, next) {
+    var log = req.log;
+    var action = req.params.action;
+    var account = req.account.uuid;
+
+    if (action !== 'clone') {
+        return next();
+    }
+
+    var imageUUID = req.params.dataset;
+    var opts = {
+        headers: {
+            'x-request-id': req.getId()
+        }
+    };
+
+    return req.sdc.imgapi.cloneImage(imageUUID, account, opts,
+            function _imgapiCloneImageCb(err, img) {
+        if (err) {
+            return next(err);
+        }
+
+        log.debug('CloneImage(%s) => %j %s', req.account.login, img);
+        res.send(translate(req, img));
+        return next(false);
+    });
+}
+
+
 function del(req, res, next) {
     return req.sdc.imgapi.deleteImage(
         req.dataset.uuid,
@@ -653,7 +682,7 @@ function mount(server, before, config) {
         path: '/:account/images/:dataset',
         name: 'UpdateImage',
         version: ['7.0.0', '7.1.0', '7.2.0', '7.3.0', '8.0.0']
-    }, before, update, exportImage,
+    }, before, update, exportImage, clone,
         function invalidUpdateAction(req, res, next) {
             if (req.query.action) {
                 return next(new InvalidArgumentError(
diff --git a/lib/machines.js b/lib/machines.js
index 14e5f92..2866b42 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -1130,6 +1130,14 @@ function ensureDataset(req, res, next) {
         return next(new InvalidArgumentError('image %s is not active',
                                                 req.params.dataset));
     }
+    // TRITON-53 Shared images are not provisionable by default.
+    if (!req.dataset.public && req.dataset.owner !== req.account.uuid &&
+            req.params.allow_shared_images !== true) {
+        return next(new InvalidArgumentError(
+            '%s is a shared image - to provision a shared image you can ' +
+            'either clone the image or set "allow_shared_images" to true.',
+            req.params.dataset));
+    }
     return next();
 }
 
diff --git a/package.json b/package.json
index dd20a5a..e65c88c 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "cloudapi",
     "description": "SmartDataCenter CloudAPI",
-    "version": "8.10.0",
+    "version": "8.11.0",
     "author": "Joyent (joyent.com)",
     "private": true,
     "engines": {
@@ -34,7 +34,7 @@
         "nodemailer": "0.7.1",
         "nopt": "2.0.0",
         "restify": "4.3.0",
-        "sdc-clients": "10.4.0",
+        "sdc-clients": "10.6.0",
         "semver": "5.4.1",
         "strsplit": "1.0.0",
         "triton-metrics": "0.1.0",
diff --git a/test/images.80.test.js b/test/images.80.test.js
index 03bf04f..7eca4f3 100644
--- a/test/images.80.test.js
+++ b/test/images.80.test.js
@@ -147,6 +147,10 @@ test('Search image type, results', function (t) {
     });
 });
 
+test('Image cloning', function (t) {
+    var imageCloneTestSuite = require('./images/clone.js');
+    imageCloneTestSuite(t, CLIENTS);
+});
 
 test('teardown', function (t) {
     common.teardown(CLIENTS, SERVER, function (err) {
diff --git a/test/images/clone.js b/test/images/clone.js
new file mode 100644
index 0000000..36cc7bb
--- /dev/null
+++ b/test/images/clone.js
@@ -0,0 +1,257 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var jsprim = require('jsprim');
+var libuuid = require('libuuid');
+var util = require('util');
+var vasync = require('vasync');
+
+var common = require('../common');
+var machinesCommon = require('../machines/common');
+
+
+// --- Globals
+
+// --- Tests for image sharing and image cloning.
+
+module.exports = function ImageCloneTestSuite(suite, clients) {
+    var client = clients.user;
+    var clonedImg;
+    var customImg;
+    var other = clients.other;
+    var setupWasSuccessful = false;
+    var test = suite.test;
+    var testImg;
+
+    /**
+     * Test setup
+     *
+     * In order to test image sharing - we first need to create an imgapi image
+     * that is owned by our test user (and make it a private image). We do this
+     * by taking an existing public image and manually copy it into the users
+     * own custom image.
+     */
+
+    test('Image clone setup', function (t) {
+        vasync.pipeline({ arg: {}, funcs: [
+            function getImage(_, next) {
+                common.getTestImage(client, function (err, img) {
+                    t.ifError(err, 'Image sharing: getTestImage');
+                    testImg = img;
+                    next(err);
+                });
+            },
+            function getImageFileStream(ctx, next) {
+                client.imgapi.getImageFileStream(testImg.id,
+                        function (err, stream) {
+                    t.ifError(err, 'Image sharing: getImageFileStream');
+                    // Stream has to be paused, for addImageFile call.
+                    if (stream) {
+                        stream.pause();
+                        ctx.filestream = stream;
+                    }
+                    next(err);
+                });
+            },
+            function createCustomImage(ctx, next) {
+                var newImgManifest = jsprim.deepCopy(testImg);
+                newImgManifest.owner = client.account.uuid;
+                newImgManifest.public = false;
+                delete newImgManifest.id;
+                delete newImgManifest.state;
+                delete newImgManifest.files;
+                delete newImgManifest.published_at;
+                client.imgapi.createImage(newImgManifest,
+                        function (err, newImg) {
+                    t.ifError(err, 'Image sharing: createCustomImage');
+                    customImg = newImg;
+                    next(err);
+                });
+            },
+            function imgapiImportImageFile(ctx, next) {
+                var file = testImg.files[0];
+                var opts = {
+                    compression: file.compression,
+                    file: ctx.filestream,
+                    sha1: file.sha1,
+                    size: file.size,
+                    storage: 'local',
+                    uuid: customImg.uuid
+                };
+                client.imgapi.addImageFile(opts, next);
+            },
+            function imgapiActivateImage(ctx, next) {
+                client.imgapi.activateImage(customImg.uuid, next);
+            }
+        ]}, function (err) {
+            if (err) {
+                t.fail('Image clone setup unsuccessful: ' + err);
+            } else {
+                setupWasSuccessful = true;
+            }
+            t.end();
+        });
+    });
+
+    function checkSetupSuccessful(t) {
+        if (!setupWasSuccessful) {
+            t.fail('Image sharing setup was unsuccessful');
+            t.end();
+            return false;
+        }
+        return true;
+    }
+
+    /* Before the image is shared - other user should not be able to clone it */
+    test('Image clone no access', function testImageCloneNoAccess(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        var data = {};
+        other.post(util.format('/my/images/%s?action=clone', customImg.uuid),
+                data, function _testImageCloneNoAccessCb(err, req, res, img) {
+            t.ok(err, 'should get an err on image clone without access');
+            t.equal(res.statusCode, 404, 'res.statusCode');
+            t.end();
+        });
+    });
+
+    test('Image share', function testImageShare(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        var data = {
+            acl: [ other.account.uuid ]
+        };
+        client.post(util.format('/my/images/%s?action=update', customImg.uuid),
+                data, function _testImageShareCb(err, req, res, img) {
+            t.ifError(err, 'no err on image share with other user');
+            t.equal(res.statusCode, 200, 'res.statusCode');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.ok(Array.isArray(img.acl), 'image has an ACL array');
+                t.ok(img.acl.indexOf(other.account.uuid) >= 0,
+                    'image ACL now contains other account');
+            }
+            t.end();
+        });
+    });
+
+    test('Image clone', function testImageClone(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        var data = {};
+        other.post(util.format('/my/images/%s?action=clone', customImg.uuid),
+                data, function _testImageCloneCb(err, req, res, img) {
+            t.ifError(err, 'no err on image share with other user');
+            t.equal(res.statusCode, 200, 'res.statusCode');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.notEqual(img.id, customImg.uuid, 'cloned image has own id');
+                t.ok(!(img.acl), 'image has an ACL array');
+                clonedImg = img;
+            }
+            t.end();
+        });
+    });
+
+    test('Image ACL no longer contains other', function testImageACL(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.get(util.format('/my/images/%s', customImg.uuid),
+                function _testImageACLCb(err, req, res, img) {
+            t.ifError(err, 'no err on image get');
+            t.ok(img, 'expect an image response object');
+            if (img) {
+                t.equal(img.id, customImg.uuid, 'original image has same id');
+                if (!img.acl || img.acl.length === 0) {
+                    t.ok(true, 'image now has no ACL - good');
+                } else {
+                    t.equal(img.acl.indexOf(other.account.uuid), -1,
+                        'image ACL should not contain other account');
+                }
+            }
+            t.end();
+        });
+    });
+
+    test('No access original image',
+            function testCloneNoAccessOriginalImage(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        other.post(util.format('/my/images/%s?action=clone', customImg.uuid),
+                {}, function _testCloneNoAccessOriginalImageCb(err, req, res) {
+            t.ok(err, 'should get an err on image clone without access');
+            t.equal(res.statusCode, 404, 'res.statusCode');
+            t.end();
+        });
+    });
+
+    test('No access cloned image',
+            function testCloneNoAccessClonedImage(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.post(util.format('/my/images/%s?action=clone', clonedImg.uuid),
+                {}, function _testCloneNoAccessClonedImageCb(err, req, res) {
+            t.ok(err, 'should get an err on image clone without access');
+            t.equal(res.statusCode, 404, 'res.statusCode');
+            t.end();
+        });
+    });
+
+    test('Delete the cloned image as original user',
+            function testCloneDeleteAsOther(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.del(util.format('/my/images/%s', clonedImg.id),
+                function _testCloneDeleteAsOtherCb(err) {
+            t.ok(err, 'should be an error trying to delete');
+            t.end();
+        });
+    });
+
+    test('Delete the cloned image as clone user',
+            function testCloneDeleteAsOwner(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        other.del(util.format('/my/images/%s', clonedImg.id),
+                function _testCloneDeleteAsOwnerCb(err) {
+            t.ifError(err, 'check for delete cloned image err');
+            t.end();
+        });
+    });
+
+    test('Recheck original image', function testCheckOriginalImage(t) {
+        if (!checkSetupSuccessful(t)) {
+            return;
+        }
+
+        client.get(util.format('/my/images/%s', customImg.uuid),
+                function _testCheckOriginalImageCb(err, req, res, img) {
+            t.ifError(err, 'should be no err on image get');
+            t.ok(img, 'expect an image response object');
+            t.end();
+        });
+    });
+};
-- 
2.21.0

