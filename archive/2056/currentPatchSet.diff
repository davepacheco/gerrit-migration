commit 79791d5e4fccecb6f9b32a71b05999c4fd9b0667 (refs/changes/56/2056/1)
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2017-06-07T20:31:50-07:00 (2 years, 4 months ago)
    
    AGENT-1077 vm-agent tests broken by OS-5975

diff --git a/lib/watchers/fs-watcher.js b/lib/watchers/fs-watcher.js
index 92fe7f3..b75ac94 100644
--- a/lib/watchers/fs-watcher.js
+++ b/lib/watchers/fs-watcher.js
@@ -5,13 +5,19 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var fs = require('fs');
 var vasync = require('vasync');
 
+// When the /config directory disappears, these control how frequently (in ms)
+// we poll to check for config to come back and how long before we give up (also
+// in ms)
+var configPollRecreateDelay = 300;
+var configPollRecreateTimeout = 60000;
+
 // when to retry if startup fails (in ms)
 var retryDelay = 10000;
 
@@ -185,6 +191,109 @@ function getConfigTimestamp(vmUuid, callback) {
     });
 };
 
+/*
+ * With OS-5975 we delete the config directory as part of provisioning. This
+ * means it's now possible for the config to be deleted out from under us
+ * without the VM also going away. When the watcher notices the config directory
+ * disappear, it will call this function to wait until either:
+ *
+ *  1. the VM is deleted (in which case, it will do nothing further)
+ *  2. the config directory shows back up (in which case we'll watch again)
+ *  3. we've tried for some amount of time and neither of the above is true (in
+ *     which case we'll log an error and then give up)
+ */
+FsWatcher.prototype.waitThenWatch = function waitThenWatch(vmUuid) {
+    var self = this;
+    var waitTime = 0;
+
+    function checkPathExists(path, callback) {
+        fs.stat(path, function _onStat(statErr) {
+            if (statErr) {
+                if (statErr.code === 'ENOENT') {
+                    callback(null, false);
+                    return;
+                }
+                callback(statErr);
+                return;
+            }
+
+            callback(null, true);
+        });
+    }
+
+    // checkExists looks for VM with uuid 'vm_uuid' then calls:
+    //
+    //  callback(err, xmlExists, configExists);
+    //
+    // where err is an error (in which case, ignore the *Exists values),
+    // and:
+    //
+    //  xmlExists is a boolean indicating whether /etc/zones/<uuid>.xml exists
+    //  configExists is a boolean indicating whether /zones/<uuid>/config exists
+    //
+    function checkExists(_vmUuid, callback) {
+        checkPathExists('/etc/zones/' + _vmUuid + '.xml',
+            function xmlExistsCb(xmlErr, xmlExists) {
+                if (xmlErr) {
+                    callback(xmlErr);
+                    return;
+                }
+
+                checkPathExists('/zones/' + _vmUuid + '/config',
+                    function checkConfigExists(configErr, configExists) {
+                        callback(configErr, xmlExists, configExists);
+                    }
+                );
+            }
+        );
+    }
+
+    function tryWatchingLater() {
+        setTimeout(function tryWatching() {
+            waitTime += configPollRecreateDelay;
+
+            // If we're past our timeout, give up without resetting timer.
+            if (waitTime > configPollRecreateTimeout) {
+                self.log.error({vmUuid: vmUuid}, 'timed out waiting for '
+                    + 'config directory to be recreated');
+                return;
+            }
+
+            self.log.trace({waitTime: waitTime},
+                'checking whether config dir was recreated');
+
+            checkExists(vmUuid,
+                function existsCallback(err, xmlExists, configExists) {
+                    if (err || (xmlExists && !configExists)) {
+                        // schedule a retry
+                        tryWatchingLater();
+                        return;
+                    }
+
+                    if (!xmlExists) {
+                        // the VM is gone altogether
+                        self.log.info({waitTime: waitTime, vmUuid: vmUuid},
+                            'VM with missing config dir disappeared');
+                        return;
+                    }
+
+                    self.log.info({waitTime: waitTime, vmUuid: vmUuid},
+                        'missing config dir reappeared');
+
+                    // It exists, so we'll start watching again. Note: this
+                    // function is expected to be idempotent, so if the watcher
+                    // was already created because of the /etc/zones watch
+                    // noticing some change and a run through the processState
+                    // pipeline, this will be a noop which is fine.
+                    self.watchConfig(vmUuid);
+                }
+            );
+        }, configPollRecreateDelay);
+    }
+
+    tryWatchingLater();
+};
+
 /*
  * For config we only watch for change events because when a VM is created we'll
  * always see the .xml file but we may or may not see config. Since xml is
@@ -197,7 +306,8 @@ FsWatcher.prototype.watchConfig = function watchConfig(vmUuid) {
 
     assert.uuid(vmUuid, 'vmUuid');
 
-    if (self.configWatchers.hasOwnProperty(vmUuid)) {
+    if (self.configWatchers.hasOwnProperty(vmUuid)
+        && self.configWatchers[vmUuid] !== null) {
         // already watching
         return;
     }
@@ -206,10 +316,9 @@ FsWatcher.prototype.watchConfig = function watchConfig(vmUuid) {
     try {
         self.configWatchers[vmUuid] = fs.watch(path,
             function _watchHandler(evt) {
-                if (evt === 'error' || evt === 'rename') {
-                    // 'rename' happens when the directory is deleted, so we
-                    // just remove. We'll attempt to re-add on next event if VM
-                    // exists.
+                if (evt === 'rename') {
+                    // If a directory is renamed, we remove the watcher.
+                    // We'll attempt to re-add on next event if VM exists.
                     if (self.configWatchers[vmUuid]) {
                         self.configWatchers[vmUuid].close();
                         self.configWatchers[vmUuid] = null;
@@ -249,15 +358,47 @@ FsWatcher.prototype.watchConfig = function watchConfig(vmUuid) {
                 }
             }
         );
+
+        // If a directory is renamed, we remove the watcher.
+        // We'll attempt to re-add on next event if VM exists.
+        self.configWatchers[vmUuid].on('error', function onWatcherError(err) {
+            // We'll try again if we can, so cleanup the current watcher (which
+            // is now useless).
+            if (self.configWatchers[vmUuid]) {
+                self.configWatchers[vmUuid].close();
+                self.configWatchers[vmUuid] = null;
+            }
+
+            self.log.warn({err: err, vmUuid: vmUuid},
+                'caught error in configWatcher');
+
+            // When the directory is removed, we'll get an ENOENT error.
+            // In that case we want to remove the watcher and when the
+            if (err.code === 'ENOENT') {
+                setImmediate(function callWaitThenWatch() {
+                    self.waitThenWatch(vmUuid);
+                });
+            }
+        });
     } catch (e) {
-        // we'll try again next time anyway
-        if (!e.code === 'ENOENT') {
-            self.log.error(e, 'FAILED to watch ' + path);
-        }
+        // we'll try again next time processState runs anyway, so just clear the
+        // current watcher.
         if (self.configWatchers[vmUuid]) {
             self.configWatchers[vmUuid].close();
             self.configWatchers[vmUuid] = null;
         }
+
+        if (e.code === 'ENOENT') {
+            // config dir doesn't exist. This could happen if a VM is in the
+            // middle of provisioning when we happen to start up. We will try
+            // again just as we do when the directory disappears.
+            setImmediate(function callWaitThenWatch() {
+                self.waitThenWatch(vmUuid);
+            });
+            return;
+        }
+
+        self.log.error(e, 'FAILED to watch ' + path);
     }
 };
 
