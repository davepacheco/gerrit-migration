From b18c19b1bd935ca8b13e0168c84e47d55529408a Mon Sep 17 00:00:00 2001
From: David Pacheco <dap@joyent.com>
Date: Tue, 20 Sep 2016 16:31:26 -0700
Subject: [PATCH] MANTA-2872 marlin agent dns resolver doesn't support tcp

---
 Makefile                        |   2 +-
 agent/etc/agentconfig.coal.json |   7 +
 agent/lib/agent/adnscache.js    | 280 --------------------------------
 agent/lib/agent/agent.js        | 215 +++++++++++++++---------
 agent/lib/agent/schema.js       |  28 +++-
 common/lib/schema.js            |   6 +
 dev/package.json                |  18 +-
 dev/test/util/tst.adnscache.js  | 140 ----------------
 8 files changed, 185 insertions(+), 511 deletions(-)
 delete mode 100644 agent/lib/agent/adnscache.js
 delete mode 100644 dev/test/util/tst.adnscache.js

diff --git a/Makefile b/Makefile
index 6d39a70..dce7b7f 100644
--- a/Makefile
+++ b/Makefile
@@ -145,7 +145,7 @@ include ./dev/tools/mk/Makefile.defs
 include ./dev/tools/mk/Makefile.smf.defs
 
 ifneq ($(USE_LOCAL_NODE),true)
-    NODE_PREBUILT_VERSION = v0.10.32
+    NODE_PREBUILT_VERSION = v0.10.48
     NODE_PREBUILT_TAG = zone
     NODE_PREBUILT_IMAGE = fd2cc906-8938-11e3-beab-4359c665ac99
 
diff --git a/agent/etc/agentconfig.coal.json b/agent/etc/agentconfig.coal.json
index ed0decb..a97491b 100644
--- a/agent/etc/agentconfig.coal.json
+++ b/agent/etc/agentconfig.coal.json
@@ -31,7 +31,14 @@
 	},
 
 	"tunables": {
+		"cueballDefaultTimeout": 500,
+		"cueballDefaultMaxTimeout": 30000,
+		"cueballDefaultRetries": 5,
+		"cueballDefaultDelay": 50,
+		"cueballDefaultMaxDelay": 60000,
 		"httpMaxSockets": 512,
+		"httpSpareSockets": 16,
+		"httpTcpKeepAliveDelay": 15000,
 		"maxPendingOutputsPerTask": 25,
 		"maxPendingPuts": 25,
 		"timeHeartbeat": 3000,
diff --git a/agent/lib/agent/adnscache.js b/agent/lib/agent/adnscache.js
deleted file mode 100644
index 250fdb8..0000000
--- a/agent/lib/agent/adnscache.js
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * adnscache.js: asynchronously-updating DNS cache
- */
-
-var mod_assert = require('assert');
-
-var mod_jsprim = require('jsprim');
-var mod_nativedns = require('native-dns');
-var mod_verror = require('verror');
-
-var VError = mod_verror.VError;
-
-/* Public interface. */
-exports.AsyncDnsCache = AsyncDnsCache;
-
-/*
- * Implements a DNS cache mapping the given hostname to its A (IPv4) record.
- * Unlike a traditional DNS cache, which is populated when a hostname is first
- * used and falls back on a traditional DNS lookup on cache miss, the requested
- * DNS names are specified up front and the records for these names are
- * automatically, asynchronously kept up to date.  Requests for records that are
- * unavailable or expired simply fail; they never result in another DNS request
- * (since the presumption is that a recent asynchronous request failed, so it
- * likely won't resolve now anyway).
- *
- * This is intended for applications which continually use a small number of
- * hostnames.
- *
- * This implementation doesn't kick off any requests on its own; it leaves that
- * under the control of the consumer.  You must call update() periodically, as
- * from an interval timer, to keep the cache up to date.  You can do this as
- * frequently as you like.  Requests will not be made unless cache entries are
- * missing or will soon become stale (as determined by triggerInterval).
- *
- * The following arguments are required:
- *
- *    log		Bunyan-style logger
- *
- *    nameServers	Array of IP addresses of nameservers to use.  If more
- *    			than one nameserver is specified, one will be selected
- *    			uniformly at random for each request.
- *
- *    triggerInterval	how long (in milliseconds) before a DNS record expires
- *			before we start attempting to refresh it
- *
- *    graceInterval	how long (in milliseconds) after a record has
- *    			technically expired before we'll stop serving it
- *
- * To be completely consistent with the DNS TTL (that is, to avoid ever using a
- * record after its TTL has expired), you might set triggerInterval = 10000 and
- * graceInterval = 0, which says to never use an expired record, and attempt to
- * update a record no sooner than10 seconds before it will expire.
- *
- * If such strictness is not required, you could just as well set
- * triggerInterval = 0 and graceInterval = 10000, which says to update a record
- * only after the existing one has expired, but continue serving the expired
- * record for up to 10 seconds.
- *
- * These two configurations have the same properties with respect to DNS server
- * failure (i.e., will tolerate failures of up to 10 seconds in the worst case),
- * but the former will make more DNS requests since it's updating more
- * frequently.
- */
-function AsyncDnsCache(args)
-{
-	mod_assert.ok(args.hasOwnProperty('triggerInterval') &&
-	    typeof (args['triggerInterval']) == 'number',
-	    'must specify a numeric "triggerInterval"');
-	mod_assert.ok(args.hasOwnProperty('graceInterval') &&
-	    typeof (args['graceInterval']) == 'number',
-	    'must specify a numeric "graceInterval"');
-	mod_assert.ok(args.hasOwnProperty('nameServers') &&
-	    Array.isArray(args['nameServers']) &&
-	    args['nameServers'].length > 0,
-	    'must specify non-empty array of "nameServers"');
-
-	args['nameServers'].forEach(function (n, i) {
-	    mod_assert.equal(typeof (n), 'string',
-		'nameserver ' + i + ' must be a string');
-	});
-
-	this.dns_nameservers = args['nameServers'].slice(0);
-	this.dns_interval = args['triggerInterval'];
-	this.dns_grace = args['graceInterval'];
-	this.dns_hosts = {};
-	this.dns_log = args['log'];
-
-	/* for testing only */
-	if (args['ttlOverride'])
-		this.dns_ttl_override = args['ttlOverride'];
-
-	if (args['onResolve'])
-		this.dns_onresolve = args['onResolve'];
-}
-
-/*
- * Add the given host to the cache.
- */
-AsyncDnsCache.prototype.add = function (hostname)
-{
-	/*
-	 * Like most DNS resolution facilities, we resolve an IPv4 address to
-	 * itself, even though that's not technically what DNS does.  We can
-	 * check for this case reliably because per RFC1123 S2.1, an IPv4
-	 * address in dot-delimited form is not a valid hostname, since the last
-	 * component of a DNS name must have letters.
-	 */
-	if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(hostname)) {
-		this.dns_hosts[hostname] = {
-			'records': [ {
-			    'addr': hostname,
-			    'expires': Infinity
-			} ],
-			'expires': Infinity
-		};
-
-		return;
-	}
-
-	this.dns_hosts[hostname] = {
-	    'records': [],
-	    'expires': undefined,
-	    'pending': undefined
-	};
-
-	this.dns_log.trace('adding hostname "%s"', hostname);
-};
-
-/*
- * Kick off an asynchronous update for each hostname whose entry may become
- * stale soon.
- */
-AsyncDnsCache.prototype.update = function ()
-{
-	var now, hostname, entry, count;
-
-	now = Date.now();
-	count = 0;
-
-	for (hostname in this.dns_hosts) {
-		entry = this.dns_hosts[hostname];
-
-		if (entry['pending'])
-			continue;
-
-		if (entry['records'].length > 0 &&
-		    entry['expires'] !== undefined &&
-		    entry['expires'] > now &&
-		    entry['expires'] - now > this.dns_interval)
-			continue;
-
-		this.kickEntry(hostname);
-		count++;
-	}
-
-	return (count);
-};
-
-AsyncDnsCache.prototype.kickEntry = function (hostname)
-{
-	var cache, now, entry, which, s, q, r, onerr;
-
-	cache = this;
-	now = Date.now();
-	entry = this.dns_hosts[hostname];
-	which = Math.floor(Math.random() * this.dns_nameservers.length);
-	s = this.dns_nameservers[which];
-
-	q = mod_nativedns.Question({ 'name': hostname });
-	r = mod_nativedns.Request({
-	    'question': q,
-	    'server': { 'address': s, 'port': 53, 'type': 'udp' },
-	    'timeout': 1000
-	});
-
-	onerr = function (err) {
-		cache.dns_log.warn(err,
-		    'failed to resolve "%s" from nameserver "%s"', hostname, s);
-	};
-
-	r.on('timeout', function () { onerr(new VError('timed out')); });
-
-	r.on('message', function (err, answer) {
-		if (!err && answer.answer.length === 0)
-			err = new VError('request returned 0 results');
-
-		if (err) {
-			onerr(err);
-			return;
-		}
-
-		cache.dns_log.trace('answers for hostname "%s" from "%s"',
-		    hostname, s, answer.answer);
-
-		var msgtime = Date.now();
-		var i, a, e;
-
-		entry['expires'] = Number.MIN_VALUE;
-		entry['records'] = new Array(answer.answer.length);
-
-		for (i = 0; i < answer.answer.length; i++) {
-			a = answer.answer[i];
-
-			if (cache.dns_ttl_override)
-				e = msgtime + cache.dns_ttl_override;
-			else
-				e = msgtime + a.ttl * 1000;
-
-			entry['records'][i] = {
-			    'addr': a.address,
-			    'expires': e
-			};
-
-			if (e > entry['expires'])
-				entry['expires'] = e;
-		}
-	});
-
-	r.on('end', function () {
-		mod_assert.equal(entry['pending'], now);
-		entry['pending'] = undefined;
-		if (cache.dns_onresolve)
-			cache.dns_onresolve();
-	});
-
-	this.dns_log.trace('attempting to resolve "%s" from "%s"', hostname, s);
-	mod_assert.ok(entry['pending'] === undefined);
-	entry['pending'] = now;
-	r.send();
-};
-
-/*
- * Returns a known, valid IPv4 address for the given hostname, or null if no
- * such address exists.
- */
-AsyncDnsCache.prototype.lookupv4 = function (hostname)
-{
-	mod_assert.ok(hostname in this.dns_hosts,
-	    'hostname "' + hostname + '" is unknown to this cache');
-
-	var now, entry, grace, valid;
-
-	now = Date.now();
-	entry = this.dns_hosts[hostname];
-	grace = this.dns_grace;
-	valid = entry['records'].filter(function (p) {
-		return (p['expires'] + grace >= now);
-	});
-
-	if (valid.length === 0)
-		return (null);
-
-	return (valid[Math.floor(Math.random() * valid.length)]['addr']);
-};
-
-/*
- * This is an unfortunate consequence of native-dns's global "platform" object.
- */
-if (mod_nativedns.platform.ready)
-	initNativeDns();
-else
-	mod_nativedns.platform.once('ready', initNativeDns);
-
-function initNativeDns()
-{
-	/* Clear global nameservers so that we always use ours. */
-	mod_nativedns.platform.name_servers = [];
-	mod_nativedns.platform.attempts = 1;
-	mod_nativedns.platform.cache = false;
-}
diff --git a/agent/lib/agent/agent.js b/agent/lib/agent/agent.js
index 274a935..6c2f675 100644
--- a/agent/lib/agent/agent.js
+++ b/agent/lib/agent/agent.js
@@ -193,6 +193,7 @@ var mod_url = require('url');
 var mod_uuid = require('node-uuid');
 
 var mod_bunyan = require('bunyan');
+var mod_cueball = require('cueball');
 var mod_extsprintf = require('extsprintf');
 var mod_getopt = require('posix-getopt');
 var mod_jsprim = require('jsprim');
@@ -210,7 +211,6 @@ var sprintf = mod_extsprintf.sprintf;
 var statvfs = require('statvfs');
 var VError = mod_verror.VError;
 
-var mod_adnscache = require('./adnscache');
 var mod_bus = require('../bus');
 var mod_libmanta = require('libmanta');
 var mod_mautil = require('../util');
@@ -250,6 +250,15 @@ var maZoneLogRoot 		= '/var/smartdc/marlin/log/zones';
 var maMorayMaxRecords 		= 1000;		/* max results per request */
 var maRequestTimeout 		= 300000;	/* local long poll timeout */
 
+/*
+ * Cueball agent default configuration (for communicating with Manta front
+ * door).  These values may be overridden in the configuration file.
+ */
+var maUpstreamSpareConnsDefault		= 16;
+var maUpstreamMaxConnsDefault		= 512;
+var maUpstreamTcpKeepAliveDelayDefault	= 15000;
+var maUpstreamSrvMaxTimeout		= 5000;
+
 var maLogStreams = [ {
     'stream': process.stdout,
     'level': process.env['LOG_LEVEL'] || 'info'
@@ -394,7 +403,7 @@ function usage(errmsg)
 function mAgent(filename)
 {
 	var agent = this;
-	var url;
+	var url, tunables, defaults, srv;
 
 	this.ma_log = new mod_bunyan({
 	    'name': maServerName,
@@ -409,21 +418,71 @@ function mAgent(filename)
 	 * Configuration
 	 */
 	this.ma_conf = mod_mautil.readConf(this.ma_log, maConfSchema, filename);
-	this.ma_log.info('configuration', this.ma_conf);
+	tunables = this.ma_conf['tunables'];
+	defaults = {
+	    'timeout': 500,
+	    'maxTimeout': 30000,
+	    'delay': 50,
+	    'retries': 5,
+	    'maxDelay': 60000
+	};
+
+	[
+	    { 'tunable': 'cueballDefaultTimeout',    'param': 'timeout'    },
+	    { 'tunable': 'cueballDefaultMaxTimeout', 'param': 'maxTimeout' },
+	    { 'tunable': 'cueballDefaultRetries',    'param': 'retries'    },
+	    { 'tunable': 'cueballDefaultDelay',      'param': 'delay'      },
+	    { 'tunable': 'cueballDefaultMaxDelay',   'param': 'maxDelay'   }
+	].forEach(function (p) {
+		if (tunables[p.tunable] !== undefined &&
+		    tunables[p.tunable] !== null) {
+			defaults[p.param] = tunables[p.tunable];
+		}
+	});
+
+	/*
+	 * We specify an aggressive set of values for "dns_srv" because some
+	 * deployments (e.g., us-east Manta) don't support them yet and we don't
+	 * want to be waiting for a long time after startup to fetch these
+	 * results.
+	 */
+	srv = mod_jsprim.deepCopy(defaults);
+	srv.retries = 0;
+	srv.maxTimeout = maUpstreamSrvMaxTimeout;
+	if (srv.timeout > srv.maxTimeout) {
+		srv.timeout = srv.maxTimeout;
+	}
+	this.ma_cueball_recovery = {
+	    'default': defaults,
+	    'dns_srv': srv
+	};
+
+	this.ma_http_nmaxconns = tunables['httpMaxSockets'] ||
+	    maUpstreamMaxConnsDefault;
+	this.ma_http_nspares = tunables['httpSpareSockets'] ||
+	    maUpstreamSpareConnsDefault;
+	this.ma_http_keepalive_delay = tunables['httpTcpKeepAliveDelay'] ||
+	    maUpstreamTcpKeepAliveDelayDefault;
+	this.ma_log.info({
+	    'config': this.ma_conf,
+	    'http_nmaxconns': this.ma_http_nmaxconns,
+	    'http_nspares': this.ma_http_nspares,
+	    'http_keepalive_delay': this.ma_http_keepalive_delay,
+	    'cueball_recovery': this.ma_cueball_recovery
+	}, 'configuration');
 
 	this.ma_hostname = mod_os.hostname();
 	this.ma_dcname = '';
 	this.ma_server_uuid = this.ma_conf['instanceUuid'];
 	this.ma_manta_compute_id = this.ma_conf['mantaComputeId'];
 	this.ma_buckets = this.ma_conf['buckets'];
-	this.ma_liveness_interval =
-		this.ma_conf['tunables']['zoneLivenessCheck'];
+	this.ma_liveness_interval = tunables['zoneLivenessCheck'];
 	this.ma_bucketnames = {};
 	mod_jsprim.forEachKey(this.ma_buckets, function (name, bucket) {
 		agent.ma_bucketnames[bucket] = name;
 	});
-	this.ma_zone_idle_min = this.ma_conf['tunables']['timeZoneIdleMin'];
-	this.ma_zone_idle_max = this.ma_conf['tunables']['timeZoneIdleMax'];
+	this.ma_zone_idle_min = tunables['timeZoneIdleMin'];
+	this.ma_zone_idle_max = tunables['timeZoneIdleMax'];
 	mod_assert.ok(this.ma_zone_idle_max >= this.ma_zone_idle_min,
 	    'timeZoneIdleMax cannot be less than timeZoneIdleMin');
 
@@ -436,32 +495,32 @@ function mAgent(filename)
 		agent.ma_kstat_readers[name] = new mod_kstat.Reader(filter);
 	});
 
-	mod_http.globalAgent.maxSockets =
-	    this.ma_conf['tunables']['httpMaxSockets'] || 512;
-
 	/*
 	 * Helper objects
 	 */
 	this.ma_logthrottle = new mod_mautil.EventThrottler(60 * 1000);
 	this.ma_task_checkpoint = new mod_mautil.Throttler(
-	    this.ma_conf['tunables']['timeTasksCheckpoint']);
+	    tunables['timeTasksCheckpoint']);
 	this.ma_task_checkpoint_freq = new mod_mautil.Throttler(5000);
 	this.ma_dtrace = mod_provider.createProvider(maProviderDefinition);
 
 	/*
-	 * Availability of Manta services relies on locating them via DNS as
-	 * they're used.  Since this agent runs in the global zone of SDC
-	 * compute nodes where DNS is not available, we do our own DNS lookups.
+	 * We use cueball to manage a connection pool to the Manta frontend
+	 * loadbalancers so that we can proxy user HTTP requests back to Manta.
+	 * We could in principle use the system resolver, but it does not
+	 * generally tolerate nameserver failure very well, and the system is
+	 * generally not configured with Manta's nameservers anyway.
 	 */
-	this.ma_dns_waiters = [];	/* queue of streams waiting on DNS */
-	this.ma_dns_cache = new mod_adnscache.AsyncDnsCache({
-	    'log': this.ma_log.child({ 'component': 'DnsCache' }),
-	    'nameServers': this.ma_conf['dns']['nameservers'].slice(0),
-	    'triggerInterval': this.ma_conf['dns']['triggerInterval'],
-	    'graceInterval': this.ma_conf['dns']['graceInterval'],
-	    'onResolve': this.onDnsResolve.bind(this)
+	this.ma_http_agent = new mod_cueball.HttpAgent({
+	    'recovery': this.ma_cueball_recovery,
+	    'resolvers': this.ma_conf['dns']['nameservers'].slice(0),
+	    'log': this.ma_log.child({ 'component': 'CueballAgent' }),
+	    'spares': this.ma_http_nspares,
+	    'maximum': this.ma_http_nmaxconns,
+	    'initialDomains': [ this.ma_manta_host ],
+	    'tcpKeepAliveInitialDelay': this.ma_http_keepalive_delay
 	});
-	this.ma_dns_cache.add(this.ma_manta_host);
+	this.ma_cueball_kang = mod_cueball.poolMonitor.toKangOptions();
 
 	this.ma_bus = new mod_bus.createBus(this.ma_conf, {
 	    'log': this.ma_log.child({ 'component': 'MorayBus' })
@@ -521,8 +580,7 @@ function mAgent(filename)
 
 	this.ma_requests = {};		/* pending HTTP requests, by req_id */
 	this.ma_init_barrier = mod_vasync.barrier();
-	this.ma_heartbeat = new mod_mautil.Throttler(
-	    this.ma_conf['tunables']['timeHeartbeat']);
+	this.ma_heartbeat = new mod_mautil.Throttler(tunables['timeHeartbeat']);
 
 	/*
 	 * See the block comment above for information on tasks, jobs, task
@@ -542,7 +600,7 @@ function mAgent(filename)
 	 * pool is allocated to zones whose tasks request it (by specifying the
 	 * "memory" property on the job phase).
 	 */
-	var pct = this.ma_conf['tunables']['zoneMemorySlopPercent'] / 100;
+	var pct = tunables['zoneMemorySlopPercent'] / 100;
 	this.ma_slopmem = Math.floor(pct * mod_os.totalmem() / 1024 / 1024);
 	this.ma_slopmem_used = 0;
 
@@ -796,7 +854,6 @@ mAgent.prototype.tick = function ()
 	this.ma_tick_start = new Date();
 	timestamp = this.ma_tick_start.getTime();
 
-	this.ma_dns_cache.update();
 	this.ma_bus.poll(timestamp);
 	this.ma_logthrottle.flush(timestamp);
 
@@ -1070,19 +1127,6 @@ mAgent.prototype.checkTaskCount = function ()
  * Event handlers
  */
 
-mAgent.prototype.onDnsResolve = function ()
-{
-	if (this.ma_dns_waiters.length === 0)
-		return;
-
-	this.ma_log.info('unblocking %d streams waiting on DNS',
-	    this.ma_dns_waiters.length);
-
-	var waiters = this.ma_dns_waiters;
-	this.ma_dns_waiters = [];
-	waiters.forEach(function (callback) { callback(); });
-};
-
 mAgent.prototype.onRecord = function (record, barrier)
 {
 	var schema, error;
@@ -2567,7 +2611,6 @@ mAgent.prototype.schedDispatch = function (group, zone)
 
 var maTaskStreamStagesDispatch = [
 	maTaskStreamSetProperties,
-	maTaskStreamWaitDns,
 	maTaskStreamLoadAssets,
 	maTaskStreamDispatch
 ];
@@ -2597,27 +2640,6 @@ function maTaskStreamSetProperties(arg, callback)
 		mod_agent_zone.maZoneSet(zone, options, callback);
 }
 
-/*
- * Waits until we have valid IPs for any DNS names we need in order to process
- * the task.  We need these in order to fetch assets, to fetch remote input
- * files, and to save output.
- */
-function maTaskStreamWaitDns(arg, callback)
-{
-	var agent = arg.agent;
-
-	if (agent.ma_dns_cache.lookupv4(agent.ma_manta_host)) {
-		callback();
-		return;
-	}
-
-	agent.ma_log.warn('delaying stream dispatch because host "%s" has ' +
-	    'not been resolved', agent.ma_manta_host);
-	agent.ma_dns_waiters.push(function () {
-		maTaskStreamWaitDns(arg, callback);
-	});
-}
-
 /*
  * Loads the task's assets into its assigned zone.  "next" is invoked only if
  * there are no errors.
@@ -2684,8 +2706,8 @@ function maTaskStreamLoadAsset(agent, stream, asset, callback)
 
 		output.on('open', function onAssetOpen() {
 			var request = mod_http.get({
-			    'host': agent.ma_dns_cache.lookupv4(
-				agent.ma_manta_host),
+			    'agent': agent.ma_http_agent,
+			    'host': agent.ma_manta_host,
 			    'port': agent.ma_manta_port,
 			    'path': uripath,
 			    'headers': {
@@ -4161,8 +4183,8 @@ function maTaskApiManta(request, response, next)
 			'headers': {
 			    'authorization': sprintf('Token %s', group.g_token)
 			},
-			'host': agent.ma_dns_cache.lookupv4(
-			    agent.ma_manta_host),
+			'agent': agent.ma_http_agent,
+			'host': agent.ma_manta_host,
 			'port': agent.ma_manta_port
 		    }
 		};
@@ -4552,19 +4574,25 @@ maTaskStream.prototype.streamState = function (agent)
 
 /*
  * Kang (introspection) entry points
+ *
+ * Kang really needs a way to compose multiple kang-providing components, but in
+ * the meantime, we do this ourselves.
  */
 
+var maKangTypesAgent = [
+    'agent', 'job', 'request', 'taskgroup', 'taskstream', 'zone', 'zonepool'
+];
+
 function maKangListTypes()
 {
-	return ([
-	    'agent',
-	    'job',
-	    'request',
-	    'taskgroup',
-	    'taskstream',
-	    'zone',
-	    'zonepool'
-	].concat(maAgent.ma_bus.kangListTypes()));
+	var bus_types, cueball_types;
+	bus_types = maAgent.ma_bus.kangListTypes().map(function (n) {
+		return ('bus_' + n);
+	});
+	cueball_types = maAgent.ma_cueball_kang.list_types().map(function (n) {
+		return ('cueball_' + n);
+	});
+	return (maKangTypesAgent.concat(bus_types).concat(cueball_types));
 }
 
 function maKangSchema(type)
@@ -4643,7 +4671,16 @@ function maKangSchema(type)
 	if (type == 'zonepool')
 		return ({ 'summaryFields': [] });
 
-	return (maAgent.ma_bus.kangSchema(type));
+	if (mod_jsprim.startsWith(type, 'bus_')) {
+		return (maAgent.ma_bus.kangSchema(type.substr('bus_'.length)));
+	}
+
+	/*
+	 * Cueball does not currently provide a schema (which is fine, because
+	 * this isn't really used anyway).
+	 */
+	mod_assert.ok(mod_jsprim.startsWith(type, 'cueball_'));
+	return ({ 'summaryFields': [] });
 }
 
 function maKangListObjects(type)
@@ -4680,7 +4717,14 @@ function maKangListObjects(type)
 	if (type == 'zonepool')
 		return (Object.keys(agent.ma_zonepools));
 
-	return (maAgent.ma_bus.kangListObjects(type));
+	if (mod_jsprim.startsWith(type, 'bus_')) {
+		return (maAgent.ma_bus.kangListObjects(
+		    type.substr('bus_'.length)));
+	}
+
+	mod_assert.ok(mod_jsprim.startsWith(type, 'cueball_'));
+	return (maAgent.ma_cueball_kang.list_objects(
+	    type.substr('cueball_'.length)));
 }
 
 function maKangGetObject(type, id)
@@ -4732,12 +4776,27 @@ function maKangGetObject(type, id)
 	if (type == 'zonepool')
 		return (agent.ma_zonepools[id].kangState());
 
-	return (agent.ma_bus.kangGetObject(type, id));
+	if (mod_jsprim.startsWith(type, 'bus_')) {
+		return (maAgent.ma_bus.kangGetObject(
+		    type.substr('bus_'.length), id));
+	}
+
+	mod_assert.ok(mod_jsprim.startsWith(type, 'cueball_'));
+	return (maAgent.ma_cueball_kang.get(
+	    type.substr('cueball_'.length), id));
 }
 
 function maKangStats()
 {
-	return (maAgent.ma_counters);
+	var rv, cueball_stats;
+
+	rv = mod_jsprim.deepCopy(maAgent.ma_counters);
+	cueball_stats = maAgent.ma_cueball_kang.stats();
+	mod_jsprim.forEachKey(cueball_stats, function (k, v) {
+		rv[k] = v;
+	});
+
+	return (rv);
 }
 
 main();
diff --git a/agent/lib/agent/schema.js b/agent/lib/agent/schema.js
index 38a6893..84a873f 100644
--- a/agent/lib/agent/schema.js
+++ b/agent/lib/agent/schema.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,12 @@
 
 var mod_schema = require('../schema');
 
+/*
+ * Properties that have been around since early versions of the agent are
+ * required.  Properties added since then are optional so that it's easier for
+ * administrators to upgrade and rollback agents without having to muck with
+ * configuration files in the common cases.
+ */
 module.exports = {
     'type': 'object',
     'properties': {
@@ -54,8 +60,17 @@ module.exports = {
 		    'items': mod_schema.sStringRequiredNonEmpty,
 		    'minItems': 1
 		},
-		'triggerInterval': mod_schema.sIntervalRequired,
-		'graceInterval':   mod_schema.sIntervalRequired
+
+		/*
+		 * These two properties are no longer used, but they're still
+		 * allowed in the configuration file so that the file itself can
+		 * be backwards-compatible.  (They don't need to be here in the
+		 * schema, but it's easier to keep this schema in sync with the
+		 * template, and affords us a place to document this fact, which
+		 * we cannot do in the JSON file.)
+		 */
+		'triggerInterval': mod_schema.sInterval,
+		'graceInterval':   mod_schema.sInterval
 	    }
 	},
 
@@ -76,7 +91,14 @@ module.exports = {
 	    'type': 'object',
 	    'required': true,
 	    'properties': {
+		'cueballDefaultTimeout': mod_schema.sNonNegativeInteger,
+		'cueballDefaultMaxTimeout': mod_schema.sNonNegativeInteger,
+		'cueballDefaultRetries': mod_schema.sNonNegativeInteger,
+		'cueballDefaultDelay': mod_schema.sNonNegativeInteger,
+		'cueballDefaultMaxDelay': mod_schema.sNonNegativeInteger,
 		'httpMaxSockets': mod_schema.sNonNegativeInteger,
+		'httpSpareSockets': mod_schema.sNonNegativeInteger,
+		'httpTcpKeepAliveDelay': mod_schema.sNonNegativeInteger,
 		'maxPendingOutputsPerTask': mod_schema.sIntervalRequired,
 		'maxPendingPuts': mod_schema.sIntervalRequired,
 		'timeHeartbeat': mod_schema.sIntervalRequired,
diff --git a/common/lib/schema.js b/common/lib/schema.js
index ac15430..029080d 100644
--- a/common/lib/schema.js
+++ b/common/lib/schema.js
@@ -100,6 +100,11 @@ var sTcpPortRequired = {
 	'maximum': 65535
 };
 
+var sInterval = {
+	'type': 'integer',
+	'minimum': 0
+};
+
 var sIntervalRequired = {
 	'required': true,
 	'type': 'integer',
@@ -904,6 +909,7 @@ exports.sBktConfigs = sBktConfigs;
 exports.sJobStates = sJobStates;
 exports.sMaxReducers = sMaxReducers;
 
+exports.sInterval = sInterval;
 exports.sIntervalRequired = sIntervalRequired;
 exports.sNonNegativeInteger = sNonNegativeInteger;
 exports.sNonNegativeIntegerRequired = sNonNegativeIntegerRequired;
diff --git a/dev/package.json b/dev/package.json
index a15ad63..262019a 100644
--- a/dev/package.json
+++ b/dev/package.json
@@ -13,16 +13,17 @@
 	},
 	"dependencies": {
 		"aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
-		"assert-plus": "0.1.2",
+		"assert-plus": "^1.0.0",
 		"bunyan": "0.20.0",
 		"catstreams": "0.5.0",
-		"dtrace-provider": "0.2.8",
-		"extsprintf": "1.3.0",
+		"cueball": "^1.1.4",
+		"dtrace-provider": "0.6.0",
+		"extsprintf": "^1.3.0",
 		"fuzzstream": "0.0.1",
 		"httpstream": "0.1.1",
 		"hyprlofs": "0.0.3",
 		"illumos_contract": "1.0.1",
-		"jsprim": "0.5.0",
+		"jsprim": "^1.3.1",
 		"kang": "0.0.5",
 		"kstat": "0.5.0",
 		"libmanta": "git+https://github.com/joyent/node-libmanta.git#master",
@@ -33,20 +34,19 @@
 		"memorystream": "0.2.0",
 		"mkdirp": "0.3.1",
 		"moray": "^2.0.0",
-		"native-dns": "0.2.1",
 		"node-uuid": "1.4.0",
 		"panic": "0.2.1",
-		"posix-getopt": "1.0.0",
+		"posix-getopt": "^1.0.0",
 		"restify": "2.3.5",
 		"retry": "0.6.0",
 		"semver": "1.1.4",
 		"ufds": "1.2.0",
 		"spawn-async": "0.0.1",
 		"statvfs": "2.0.0",
-		"strsplit": "1.0.0",
+		"strsplit": "^1.0.0",
 		"tab": "0.0.2",
-		"vasync": "1.6.2",
-		"verror": "1.4.0",
+		"vasync": "^1.6.2",
+		"verror": "^1.4.0",
 		"wordwrap": "0.0.2",
 		"zoneid": "0.2.0",
 		"zsock-async": "0.0.2"
diff --git a/dev/test/util/tst.adnscache.js b/dev/test/util/tst.adnscache.js
deleted file mode 100644
index d51a116..0000000
--- a/dev/test/util/tst.adnscache.js
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * tst.adnscache.js: tests the asynchronous DNS cache
- */
-
-var mod_assert = require('assert');
-
-var mod_bunyan = require('bunyan');
-var mod_vasync = require('vasync');
-
-var mod_adnscache = require('../../lib/agent/adnscache');
-
-var log, cache, ip, advanced;
-
-function looksLikeIp4(inip)
-{
-	if (!inip || typeof (inip) != 'string')
-		return (false);
-
-	return (/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(inip));
-}
-
-mod_vasync.pipeline({ 'funcs': [
-    setup,
-    checkResolved,
-    forceUpdate,
-    checkResolvedAgain,
-    checkGrace,
-    checkGraceExpired
-] }, function (err) {
-	if (err) {
-		log.fatal(err, 'test failed');
-		throw (err);
-	}
-
-	log.info('test passed');
-});
-
-function setup(_, next)
-{
-	log = new mod_bunyan({
-	    'name': 'tst.adnscache.js',
-	    'level': process.env['LOG_LEVEL'] || 'debug'
-	});
-
-	log.info('setup');
-
-	cache = new mod_adnscache.AsyncDnsCache({
-	    'log': log,
-	    'nameServers': [ '8.8.8.8' ],
-	    'triggerInterval': 1000,
-	    'graceInterval': 2000,
-	    'ttlOverride': 3000,
-	    'onResolve': function () {
-		if (advanced)
-			return;
-
-		advanced = true;
-		next();
-	    }
-	});
-
-	mod_assert.throws(function () {
-		cache.lookupv4('us-east.manta.joyent.com');
-	}, '"us-east.manta.joyent.com" is not known to this cache');
-
-	cache.add('us-east.manta.joyent.com');
-	mod_assert.ok(cache.lookupv4('us-east.manta.joyent.com') === null);
-	cache.update();
-	mod_assert.ok(cache.lookupv4('us-east.manta.joyent.com') === null);
-
-	cache.add('127.0.0.1');
-	mod_assert.equal(cache.lookupv4('127.0.0.1'), '127.0.0.1');
-}
-
-function checkResolved(_, next)
-{
-	log.info('checkResolved');
-
-	/*
-	 * Check that we've resolved the IP, and an immediate "update" doesn't
-	 * bother making a new request.
-	 */
-	ip = cache.lookupv4('us-east.manta.joyent.com');
-	mod_assert.ok(looksLikeIp4(ip));
-	mod_assert.equal(0, cache.update());
-	setTimeout(function () { next(); }, 2500);
-}
-
-function forceUpdate(_, next)
-{
-	/*
-	 * Check that we properly update inside the triggerInterval, but we
-	 * still get a valid address and we only make one request.
-	 */
-	log.info('forceUpdate');
-	advanced = false;
-	mod_assert.equal(1, cache.update());
-	mod_assert.equal(0, cache.update());
-	ip = cache.lookupv4('us-east.manta.joyent.com');
-	mod_assert.ok(looksLikeIp4(ip));
-}
-
-function checkResolvedAgain(_, next)
-{
-	/*
-	 * Check that we got an updated request, then check that we serve inside
-	 * the grace period.
-	 */
-	log.info('checkResolved');
-	ip = cache.lookupv4('us-east.manta.joyent.com');
-	mod_assert.ok(looksLikeIp4(ip));
-	mod_assert.equal(0, cache.update());
-	setTimeout(function () { next(); }, 4000);
-}
-
-function checkGrace(_, next)
-{
-	log.info('checkGrace');
-	ip = cache.lookupv4('us-east.manta.joyent.com');
-	mod_assert.ok(looksLikeIp4(ip));
-	setTimeout(function () { next(); }, 2000);
-}
-
-function checkGraceExpired(_, next)
-{
-	log.info('checkGraceExpired');
-	ip = cache.lookupv4('us-east.manta.joyent.com');
-	mod_assert.ok(ip === null);
-	next();
-}
-- 
2.21.0

