From dd877ddbd8d7e0ddfd2cf57c00f564f2a300247c Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <jwilsdon@joyent.com>
Date: Thu, 8 Sep 2016 16:52:49 -0700
Subject: [PATCH] OS-5643 Rebooting KVM VMs sometimes causes vmadmd to leak
 zoneevent processes

---
 src/vm/node_modules/VM.js | 49 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 43 insertions(+), 6 deletions(-)

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 5f4bd40c..6f3fa8d9 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -3631,6 +3631,7 @@ function watchZoneTransitions(handler, log) {
     var buffer = '';
     var chunks;
     var cleanup;
+    var reaperTimeout;
     var watcher;
     var watcher_pid;
 
@@ -3646,6 +3647,44 @@ function watchZoneTransitions(handler, log) {
         log.debug('zoneevent running with pid ' + watcher.pid);
         watcher_pid = watcher.pid;
 
+        // This should be called prior to shutting down a zoneevent watcher
+        // in order to prevent any more data from being returned and preventing
+        // the 'exit' handlers from being called when it dies.
+        function _stopWatching(_watcher) {
+            assert.object(_watcher, '_watcher');
+            assert.object(_watcher.stdout, '_watcher.stdout');
+            assert.object(_watcher.stderr, '_watcher.stderr');
+
+            _watcher.stdout.destroy(); // so we don't send more 'data'
+            _watcher.stderr.destroy();
+            _watcher.removeAllListeners('exit'); // so don't fail on kill
+        }
+
+        // This exists to ensure that all zoneevent processes are eventually
+        // cleaned up. See OS-5643 for some more details. This should eventually
+        // go away once OS-2647 is completed since vmadmd won't need to create
+        // zoneevent children when it can talk to vminfod instead.
+        function _watcherReaper() {
+            if (zoneevent) {
+                // still have a zoneevent, assume someone will call cleanup
+                reaperTimeout = setTimeout(_watcherReaper, 30 * 1000);
+                return;
+            }
+
+            // Our zoneevent was destroyed but we're still here? That means
+            // cleanup failed to happen somehow. Kill the child so we don't
+            // break zone sysevents for everybody else.
+            if (watcher && watcher.pid) {
+                _stopWatching(watcher);
+                log.warn({watcher_pid: watcher.pid}, 'reaping stale zoneevent');
+                process.kill(watcher.pid);
+                watcher = null;
+            } else {
+                log.error('wanted to reap zoneevent, but watcher disappeared');
+            }
+        }
+        reaperTimeout = setTimeout(_watcherReaper, 30 * 1000);
+
         watcher.stdout.on('data', function (data) {
             var chunk;
             var obj;
@@ -3698,20 +3737,18 @@ function watchZoneTransitions(handler, log) {
                     + ' cleanup called');
                 zoneevent = null;
                 if (watcher) {
-                    watcher.stdout.destroy(); // so we don't send more 'data'
-                    watcher.stderr.destroy();
-                    watcher.removeAllListeners('exit'); // so don't fail on kill
+                    _stopWatching(watcher);
                     log.debug('killing watcher');
                     watcher.kill();
+                    clearTimeout(reaperTimeout);
                     watcher = null;
                 }
             }
         } else if (watcher) {
-            watcher.stdout.destroy(); // so we don't send more 'data'
-            watcher.stderr.destroy();
-            watcher.removeAllListeners('exit'); // so don't fail on our kill
+            _stopWatching(watcher);
             log.debug('killing watcher (no zoneevent)');
             watcher.kill();
+            clearTimeout(reaperTimeout);
             watcher = null;
         }
     };
-- 
2.21.0

