From c8155c6116d8969adb3b32f3de66dbbaf5426dcd Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Wed, 3 May 2017 14:13:06 -0700
Subject: [PATCH] TOOLS-1763 sdcadm: TOOLS-1634 change to DownloadImages
 procedure mishandles theoretical custom-source-with-image-origins case

---
 lib/procedures/download-images.js | 44 ++++++++++++++++++++++++++++---
 1 file changed, 40 insertions(+), 4 deletions(-)

diff --git a/lib/procedures/download-images.js b/lib/procedures/download-images.js
index d855cac..99cf226 100644
--- a/lib/procedures/download-images.js
+++ b/lib/procedures/download-images.js
@@ -26,6 +26,10 @@ function DownloadImages(options) {
 }
 util.inherits(DownloadImages, Procedure);
 
+/*
+ * Limitation: This doesn't list or include the size of *origin* images that
+ * might also need to be downloaded.
+ */
 DownloadImages.prototype.summarize = function diSummarize() {
     var size = this.images.map(function (img) {
         return (img.files.length ? img.files[0].size : 0);
@@ -65,6 +69,33 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
         }
     }
 
+    /*
+     * Limitation: Origin/ancestry handling (`getAncestorsForImages`) doesn't
+     * properly handle a custom `options.source`. Instead it assumes it can
+     * look up an origin image on updates.joyent.com. For example,
+     * `sdcadm post-setup dev-sample-data` uses `options.source` to import
+     * some images from images.joyent.com. However, it gets lucky because the
+     * images it is pulling do not have origins (they aren't incremental).
+     *
+     * A *workaround* for this is to (a) avoid looking up origin images (b/c
+     * we are using the wrong source) and (b) only import images *serially*
+     * (which allows IMGAPI to handle importing the origin ancestry without
+     * a race).
+     *
+     * Dev Note: A better fix (for another time) would be to create an IMGAPI
+     * client for the given custom source and use that instead of
+     * `sdcadm.updates` when looking up origins.
+     */
+    var useCustomSourceCountermeasures = false;
+    if (options.source) {
+        var imgsWithAnOrigin = self.images.filter(function (img) {
+            return Boolean(img.origin);
+        });
+        if (imgsWithAnOrigin.length) {
+            useCustomSourceCountermeasures = true;
+        }
+    }
+
     /*
      * Keep track of errors during parallel image imports
      */
@@ -85,7 +116,7 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
         vasync.forEachParallel({
             inputs: currCol,
             func: function checkImgOrigin(img, nextImg) {
-                if (!img.origin) {
+                if (!img.origin || useCustomSourceCountermeasures) {
                     nextImg();
                     return;
                 }
@@ -168,12 +199,17 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
 
 
     function importCollectionOfImages(collection, nextCollection) {
+        var concurrency = 4;
+        if (useCustomSourceCountermeasures) {
+            concurrency = 1;
+        }
+
         var q = vasync.queuev({
-            concurrency: 4,
+            concurrency: concurrency,
             worker: function importUpdateImage(image, next) {
                 /*
-                 * Need to be verified here b/c there sdcadm parts other than
-                 * procedures index calling DownloadImages.
+                 * Need to be verified here b/c there are callers other than
+                 * procedures/index.js calling DownloadImages.
                  */
                 function checkIfImageIsUnactivated(_, nextStep) {
                     if (image.state === 'unactivated') {
-- 
2.21.0

