From 2096a7f91e8fa3feb8f54d51c3e0e107a4430dd9 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Mon, 6 Mar 2017 22:12:47 +0000
Subject: [PATCH] OS-5994 lx_proc overzealous about readlink access checks

---
 .../uts/common/brand/lx/procfs/lx_prvnops.c   | 26 ++++++++++++++++---
 1 file changed, 22 insertions(+), 4 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
index 57c22690d4..62abbe785f 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
@@ -123,6 +123,9 @@ static int lxpr_poll(vnode_t *, short, int, short *, pollhead_t **,
 static int lxpr_sync(void);
 static void lxpr_inactive(vnode_t *, cred_t *, caller_context_t *);
 
+static int lxpr_doaccess(lxpr_node_t *, boolean_t, int, int, cred_t *,
+    caller_context_t *);
+
 static vnode_t *lxpr_lookup_procdir(vnode_t *, char *);
 static vnode_t *lxpr_lookup_piddir(vnode_t *, char *);
 static vnode_t *lxpr_lookup_not_a_dir(vnode_t *, char *);
@@ -5603,7 +5606,19 @@ lxpr_getattr(vnode_t *vp, vattr_t *vap, int flags, cred_t *cr,
 static int
 lxpr_access(vnode_t *vp, int mode, int flags, cred_t *cr, caller_context_t *ct)
 {
-	lxpr_node_t *lxpnp = VTOLXP(vp);
+	return (lxpr_doaccess(VTOLXP(vp), B_FALSE, mode, flags, cr, ct));
+}
+
+/*
+ * This makes up the bulk of the logic for lxpr_access.  An extra parameter
+ * ('shallow') is present to differentiate checks that must pass muster against
+ * an underlying resource (lxpr_realvp) and those that are only concerned with
+ * permission to the process.
+ */
+static int
+lxpr_doaccess(lxpr_node_t *lxpnp, boolean_t shallow, int mode, int flags,
+    cred_t *cr, caller_context_t *ct)
+{
 	lxpr_nodetype_t type = lxpnp->lxpr_type;
 	boolean_t allow_pid_access = B_FALSE;
 	int shift = 0;
@@ -5669,8 +5684,9 @@ lxpr_access(vnode_t *vp, int mode, int flags, cred_t *cr, caller_context_t *ct)
 
 	/*
 	 * If this entry has an underlying vnode, rely upon its access checks.
+	 * Skip this if a shallow check has been requested.
 	 */
-	if (lxpnp->lxpr_realvp != NULL) {
+	if (lxpnp->lxpr_realvp != NULL && !shallow) {
 		return (VOP_ACCESS(lxpnp->lxpr_realvp, mode, flags, cr, ct));
 	}
 
@@ -7285,9 +7301,11 @@ lxpr_readlink(vnode_t *vp, uio_t *uiop, cred_t *cr, caller_context_t *ct)
 
 	/* Try to produce a symlink name for anything that has a realvp */
 	if (rvp != NULL) {
-		if ((error = lxpr_access(vp, VREAD, 0, CRED(), ct)) != 0)
+		error = lxpr_doaccess(lxpnp, B_TRUE, VREAD, 0, cr, ct);
+		if (error != 0)
 			return (error);
-		if ((error = vnodetopath(NULL, rvp, bp, buflen, CRED())) != 0) {
+
+		if ((error = vnodetopath(NULL, rvp, bp, buflen, cr)) != 0) {
 			/*
 			 * Special handling possible for /proc/<pid>/fd/<num>
 			 * Generate <type>:[<inode>] links, if allowed.
-- 
2.21.0

