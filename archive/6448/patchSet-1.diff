commit 780b0e2c354dcdb345af97b768f010a670d13f51
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2019-06-12T17:11:53+00:00 (4 months ago)
    
    joyent/bugview#33 support files backend for testing purposes

diff --git a/jirapub.js b/jirapub.js
index 8fd3116..6155efc 100644
--- a/jirapub.js
+++ b/jirapub.js
@@ -11,6 +11,12 @@ var mod_path = require('path');
 var mod_ent = require('ent');
 var mod_url = require('url');
 var mod_vasync = require('vasync');
+var mod_verror = require('verror');
+
+var lib_backend_jira = require('./lib/backend_jira');
+var lib_backend_files = require('./lib/backend_files');
+
+var VE = mod_verror.VError;
 
 var LOG = mod_bunyan.createLogger({
 	name: 'jirapub',
@@ -23,12 +29,13 @@ var HEADING_LEVELS = [ 1, 2, 3, 4, 5, 6 ].map(function (l) {
 
 var TEMPLATES = {};
 
+var UNRESTRICTED = false;
 var CONFIG = read_config(LOG);
 
 var ALLOWED_DOMAINS = CONFIG.allowed_domains;
 var ALLOWED_LABELS = CONFIG.allowed_labels;
 
-var JIRA;
+var BACKEND;
 var SERVER; // eslint-disable-line
 
 /*
@@ -165,7 +172,8 @@ handle_issue_index(req, res, next)
 		issue_index: true
 	});
 
-	make_issue_index(log, CONFIG.label, req, res, next);
+	make_issue_index(log, UNRESTRICTED ? null : CONFIG.label, req, res,
+	    next);
 }
 
 
@@ -182,7 +190,7 @@ handle_label_index(req, res, next)
 	});
 	var label = req.params.key;
 
-	if (ALLOWED_LABELS.indexOf(label) === -1) {
+	if (!UNRESTRICTED && ALLOWED_LABELS.indexOf(label) === -1) {
 		log.error({label: label}, 'request for non-public label');
 		res.send(403, 'Sorry, this label does not exist.\n');
 		next(false);
@@ -197,10 +205,10 @@ function
 make_issue_index(log, label, req, res, next)
 {
 	var offset;
-	var url;
 
 	mod_assert.ok(label === CONFIG.label ||
-	    ALLOWED_LABELS.indexOf(label) !== -1);
+	    ALLOWED_LABELS.indexOf(label) !== -1 ||
+	    UNRESTRICTED);
 
 	if (req.query && req.query.offset) {
 		offset = parseInt(req.query.offset, 10);
@@ -210,20 +218,22 @@ make_issue_index(log, label, req, res, next)
 	}
 	offset = Math.floor(offset / 50) * 50;
 
-	url = CONFIG.url.path +
-	    '/search?jql=labels%20%3D%20%22' + label + '%22';
-	if (label !== CONFIG.label) {
-		url += '%20AND%20labels%20%3D%20%22' + CONFIG.label + '%22';
+	var labels = [];
+	if (!UNRESTRICTED) {
+		labels.push(CONFIG.label);
+	}
+	if (label !== null && labels.indexOf(label) === -1) {
+		labels.push(label);
 	}
-	url += '&fields=summary,resolution&startAt=' + offset;
 
 	log.info({
-		url: url,
+		labels: labels,
 		offset: offset
-	}, 'fetch from JIRA');
-	JIRA.get(url, function (_err, _req, _res, results) {
-		if (_err) {
-			log.error(_err, 'error communicating with JIRA');
+	}, 'fetch from %s', BACKEND.be_name);
+
+	BACKEND.be_issue_list(labels, offset, function (err, results) {
+		if (err) {
+			log.error(err, 'error communicating with JIRA');
 			res.send(500);
 			next(false);
 			return;
@@ -349,37 +359,31 @@ handle_issue_json(req, res, next)
 		return;
 	}
 
-	var url = CONFIG.url.path + '/issue/' + req.params.key;
-
-	JIRA.get(url, function (_err, _req, _res, issue) {
-		if (_err) {
-			if (_err && _err.name === 'NotFoundError') {
-				log.error(_err, 'could not find issue');
+	BACKEND.be_issue_get(req.params.key, function (err, issue) {
+		if (err) {
+			if (VE.info(err).notfound) {
+				log.error(err, 'could not find issue');
 				res.send(404);
 				next(false);
 				return;
 			}
-			log.error(_err, 'error communicating with JIRA');
+			log.error(err, 'error communicating with JIRA');
 			res.send(500);
 			next(false);
 			return;
 		}
 
-		if (!issue || !issue || !issue.fields || !issue.fields.labels) {
-			log.error('JIRA issue did not have expected format');
-			res.send(500);
-			next(false);
-			return;
-		}
+		mod_assert.arrayOfStrings(issue.fields.labels, 'labels');
 
-		if (issue.fields.labels.indexOf(CONFIG.label) === -1) {
+		if (!UNRESTRICTED &&
+		    issue.fields.labels.indexOf(CONFIG.label) === -1) {
 			log.error('request for non-public issue');
 			res.send(403);
 			next(false);
 			return;
 		}
 
-		log.info('serving issue');
+		log.info({ issue_id: issue.id }, 'serving issue');
 
 		/*
 		 * Construct our page from the primary template with the
@@ -421,47 +425,41 @@ handle_issue(req, res, next)
 		return;
 	}
 
-	var url = CONFIG.url.path + '/issue/' + req.params.key;
-
-	JIRA.get(url, function (_err, _req, _res, issue) {
-		if (_err) {
-			if (_err && _err.name === 'NotFoundError') {
-				log.error(_err, 'could not find issue');
+	BACKEND.be_issue_get(req.params.key, function (err, issue) {
+		if (err) {
+			if (VE.info(err).notfound) {
+				log.error(err, 'could not find issue');
 				res.send(404,
 				    'Sorry, that issue does not exist.\n');
 				next(false);
 				return;
 			}
-			log.error(_err, 'error communicating with JIRA');
+			log.error(err, 'error communicating with JIRA');
 			res.send(500);
 			next(false);
 			return;
 		}
 
-		if (!issue || !issue || !issue.fields || !issue.fields.labels) {
-			log.error('JIRA issue did not have expected format');
-			res.send(500);
-			next(false);
-			return;
-		}
+		mod_assert.arrayOfString(issue.fields.labels, 'labels');
 
-		if (issue.fields.labels.indexOf(CONFIG.label) === -1) {
+		if (!UNRESTRICTED &&
+		    issue.fields.labels.indexOf(CONFIG.label) === -1) {
 			log.error('request for non-public issue');
 			res.send(403, 'Sorry, this issue is not public.\n');
 			next(false);
 			return;
 		}
 
-		log.info('serving issue');
+		log.info({ issue_id: issue.id }, 'serving issue');
 
 		/*
 		 * Construct our page from the primary template with the
 		 * formatted issue in the container:
 		 */
 		format_issue({ issue: issue, log: log },
-		    function (err, formatted) {
-			if (err) {
-				log.error(err, 'format issue failed');
+		    function (_err, formatted) {
+			if (_err) {
+				log.error(_err, 'format issue failed');
 				res.send(500);
 				next(false);
 				return;
@@ -510,7 +508,8 @@ allow_issue(key, other_issues)
 		return (false);
 	}
 
-	if (other_issues[key].fields.labels.indexOf(CONFIG.label) === -1) {
+	if (!UNRESTRICTED &&
+	    other_issues[key].fields.labels.indexOf(CONFIG.label) === -1) {
 		return (false);
 	}
 
@@ -991,10 +990,8 @@ format_issue(opts, callback)
 
 		mod_vasync.forEachParallel({ inputs: Object.keys(other_issues),
 		    func: function lookup_linked_issue_one(key, done) {
-			var url = CONFIG.url.path + '/issue/' + key;
-
-			JIRA.get(url, function (_err, _req, _res, other) {
-				if (_err) {
+			BACKEND.be_issue_get(key, function (err, other) {
+				if (err) {
 					/*
 					 * In this particular case, we ignore
 					 * the failure to retrieve a related
@@ -1004,7 +1001,7 @@ format_issue(opts, callback)
 					 * itself, even if we cannot fetch
 					 * all of the Related Issues.
 					 */
-					log.warn(_err, 'could not fetch ' +
+					log.warn(err, 'could not fetch ' +
 					    'related issue ' + key);
 					done();
 					return;
@@ -1013,7 +1010,8 @@ format_issue(opts, callback)
 				/*
 				 * Include only issues marked "public".
 				 */
-				if (other.fields.labels.indexOf(
+				if (UNRESTRICTED ||
+				    other.fields.labels.indexOf(
 				    CONFIG.label) !== -1) {
 					other_issues[key] = other;
 				} else {
@@ -1028,18 +1026,15 @@ format_issue(opts, callback)
 			next(err);
 		});
 	}, function get_remote_links(next) {
-		var url = CONFIG.url.path +
-		    '/issue/' + issue.id + '/remotelink';
-
 		/*
 		 * A ticket can have "remote links" attached to it, which are
 		 * URLs to resources outside of JIRA. We primarily use these to
 		 * link to code reviews, but they can also be to relevant bugs
 		 * on other sites, such as illumos.org.
 		 */
-		JIRA.get(url, function (_err, _req, _res, links) {
-			if (_err) {
-				next(_err);
+		BACKEND.be_remotelink_get(issue.id, function (err, links) {
+			if (err) {
+				next(err);
 				return;
 			}
 
@@ -1257,19 +1252,20 @@ function
 main() {
 	read_templates(LOG);
 
+	if (process.env.UNRESTRICTED === 'yes') {
+		LOG.warn('unrestricted operation enabled');
+		UNRESTRICTED = true;
+	}
+
+	if (process.env.LOCAL_STORE) {
+		BACKEND = lib_backend_files.files_backend_init(CONFIG, LOG);
+	} else {
+		BACKEND = lib_backend_jira.jira_backend_init(CONFIG, LOG);
+	}
+
 	create_http_server(LOG, function (s) {
 		SERVER = s;
 	});
-
-	JIRA = mod_restify.createJsonClient({
-		url: CONFIG.url.base,
-		connectTimeout: 15000,
-		userAgent: 'JoyentJIRAPublicAccess',
-		log: LOG.child({
-			component: 'jira'
-		})
-	});
-	JIRA.basicAuth(CONFIG.username, CONFIG.password);
 }
 
 main();
diff --git a/lib/backend_files.js b/lib/backend_files.js
new file mode 100644
index 0000000..e044498
--- /dev/null
+++ b/lib/backend_files.js
@@ -0,0 +1,204 @@
+/* vim: set ts=8 sts=8 sw=8 noet: */
+
+'use strict';
+
+var mod_assert = require('assert-plus');
+var mod_fs = require('fs');
+var mod_path = require('path');
+var mod_verror = require('verror');
+
+var VE = mod_verror.VError;
+
+var DIR;
+var ISSUES;
+var ISSUES_LIST;
+var CONFIG;
+
+
+function
+read_file(type, key)
+{
+	var path = mod_path.join(DIR, type, key + '.json');
+
+	try {
+		return (JSON.parse(mod_fs.readFileSync(path).toString('utf8')));
+	} catch (ex) {
+		if (ex.code === 'ENOENT') {
+			return (null);
+		}
+
+		throw (new VE(ex, 'could not parse "%s"', path));
+	}
+}
+
+function
+list_files(type)
+{
+	var path = mod_path.join(DIR, type);
+	var ents = mod_fs.readdirSync(path);
+
+	var out = [];
+
+	for (var i = 0; i < ents.length; i++) {
+		var m = ents[i].match(/^(.+).json$/);
+
+		if (m === null) {
+			continue;
+		}
+
+		out.push(m[1]);
+	}
+
+	return (out.sort());
+}
+
+
+function
+files_issue_list(labels, offset, done)
+{
+	mod_assert.arrayOfString(labels, 'labels');
+	mod_assert.number(offset, 'offset');
+	mod_assert.ok(!isNaN(offset) && offset >= 0, 'offset >= 0');
+	mod_assert.func(done, 'done');
+
+	var maxResults = 50;
+
+	var keys = ISSUES_LIST.filter(function (key) {
+		var issue = ISSUES[key];
+
+		for (var i = 0; i < labels.length; i++) {
+			if (issue.fields.labels.indexOf(labels[i]) === -1) {
+				return (false);
+			}
+		}
+
+		return (true);
+	});
+
+	var res = {
+		total: keys.length,
+		issues: keys.slice(offset, offset + maxResults).map(
+		    function (key) {
+			return (ISSUES[key]);
+		}),
+	};
+
+	setImmediate(done, null, res);
+}
+
+function
+files_issue_get(key, done)
+{
+	mod_assert.string(key, 'key');
+	mod_assert.func(done, 'done');
+
+	if (!key.match(/-/)) {
+		setImmediate(done, new VE('issue key "%s" not valid', key));
+		return;
+	}
+
+	var id = ISSUES[key].id;
+	var issue;
+	if (!id || (issue = read_file('issue', id)) === null) {
+		setImmediate(done, new VE({ info: { notfound: true }},
+		    'get issue "%s": not found'));
+		return;
+	}
+
+	if (!issue || !issue.fields || !issue.fields.labels) {
+		setImmediate(done, new VE(
+		    'issue "%s" did not have expected format', key));
+		return;
+	}
+
+	setImmediate(done, null, issue);
+}
+
+function
+files_remotelink_get(id, done)
+{
+	mod_assert.string(id, 'id');
+	mod_assert.func(done, 'done');
+
+	var rlink = read_file('remotelink', id);
+	if (rlink === null) {
+		/*
+		 * If there is no remote link list for this issue, just return
+		 * an empty list.
+		 */
+		setImmediate(done, null, []);
+		return;
+	}
+
+	if (!Array.isArray(rlink)) {
+		setImmediate(done, new VE(
+		    'issue "%s" remotelink did not have expected format', id));
+		return;
+	}
+
+	setImmediate(done, null, rlink);
+}
+
+function
+files_backend_init(config, log)
+{
+	CONFIG = config;
+
+	mod_assert.string(process.env.LOCAL_STORE, 'LOCAL_STORE');
+	DIR = process.env.LOCAL_STORE;
+
+	log.info('loading issue cache from "%s"', DIR);
+
+	ISSUES = {};
+	var ids = list_files('issue');
+	for (var i = 0; i < ids.length; i++) {
+		var io = read_file('issue', ids[i]);
+
+		/*
+		 * Mock up an object like the one returned from the JIRA search
+		 * we use to construct the issue list.  Needs to match with
+		 * what jira_issue_list() returns.
+		 */
+		ISSUES[io.key] = {
+			key: io.key,
+			id: ids[i],
+			fields: {
+				labels: io.fields.labels,
+				summary: io.fields.summary,
+				resolution: io.fields.resolution,
+			}
+		};
+	}
+	ISSUES_LIST = Object.keys(ISSUES).sort(function (a, b) {
+		var ma = a.split('-');
+		var mb = b.split('-');
+
+		if (ma[0] < mb[0]) {
+			return (-1);
+		} else if (ma[0] > mb[0]) {
+			return (1);
+		}
+
+		if (+ma[1] < +mb[1]) {
+			return (-1);
+		} else if (+ma[1] > +mb[1]) {
+			return (1);
+		}
+
+		return (0);
+	}).reverse();
+
+	log.info('loading issue cache from "%s" complete: %d issues', DIR,
+	    Object.keys(ISSUES).length);
+
+	return ({
+		be_name: 'files',
+		be_issue_list: files_issue_list,
+		be_issue_get: files_issue_get,
+		be_remotelink_get: files_remotelink_get,
+	});
+}
+
+module.exports = {
+	files_backend_init: files_backend_init,
+};
diff --git a/lib/backend_jira.js b/lib/backend_jira.js
new file mode 100644
index 0000000..4a85fde
--- /dev/null
+++ b/lib/backend_jira.js
@@ -0,0 +1,144 @@
+/* vim: set ts=8 sts=8 sw=8 noet: */
+
+'use strict';
+
+var mod_assert = require('assert-plus');
+var mod_restify = require('restify');
+var mod_verror = require('verror');
+var mod_querystring = require('querystring');
+
+var VE = mod_verror.VError;
+
+var JIRA;
+var CONFIG;
+
+
+function
+jira_issue_list(labels, offset, done)
+{
+	mod_assert.arrayOfString(labels, 'labels');
+	mod_assert.number(offset, 'offset');
+	mod_assert.ok(!isNaN(offset) && offset >= 0, 'offset >= 0');
+	mod_assert.func(done, 'done');
+
+	var maxResults = 50;
+
+	var jql = labels.map(function (label) {
+		return ('labels = "' + label + '"');
+	}).join(' AND ');
+
+	var qopts = {
+		maxResults: maxResults,
+		startAt: offset,
+		fields: [ 'summary', 'resolution' ].join(','),
+		jql: jql,
+	};
+
+	var url = CONFIG.url.path + '/search?' +
+	    mod_querystring.stringify(qopts);
+
+	JIRA.get(url, function (err, req, res, results) {
+		if (err) {
+			done(new VE(err, 'communicating with JIRA'));
+			return;
+		}
+
+		if (!Array.isArray(results.issues)) {
+			done(new VE('"issues" not an array in response'));
+			return;
+		}
+
+		done(null, {
+			total: Number(results.total) || 10000000,
+			issues: results.issues
+		});
+	});
+}
+
+function
+jira_issue_get(key, done)
+{
+	mod_assert.string(key, 'key');
+	mod_assert.func(done, 'done');
+
+	if (!key.match(/-/)) {
+		setImmediate(done, new VE('issue key "%s" not valid', key));
+		return;
+	}
+
+	var url = CONFIG.url.path + '/issue/' + key;
+
+	JIRA.get(url, function (err, req, res, issue) {
+		if (err) {
+			var info = {};
+
+			if (err.name === 'NotFoundError') {
+				info.notfound = true;
+			}
+
+			done(new VE({ cause: err, info: info },
+			    'get issue "%s"', key));
+			return;
+		}
+
+		if (!issue || !issue.fields || !issue.fields.labels) {
+			done(new VE('issue "%s" did not have expected format',
+			    key));
+			return;
+		}
+
+		done(null, issue);
+	});
+}
+
+function
+jira_remotelink_get(id, done)
+{
+	mod_assert.string(id, 'id');
+	mod_assert.func(done, 'done');
+
+	if (id.match(/-/)) {
+		setImmediate(done, new VE('issue ID "%s" not valid', id));
+		return;
+	}
+
+	var url = CONFIG.url.path + '/issue/' + id + '/remotelink';
+
+	JIRA.get(url, function (err, req, res, links) {
+		if (err) {
+			done(new VE(err, 'get issue links "%s"', id));
+			return;
+		}
+
+		mod_assert.array(links, 'links');
+
+		done(null, links);
+	});
+}
+
+function
+jira_backend_init(config, log)
+{
+	CONFIG = config;
+
+	JIRA = mod_restify.createJsonClient({
+		url: config.url.base,
+		connectTimeout: 15000,
+		userAgent: 'JoyentJIRAPublicAccess',
+		log: log.child({
+			component: 'jira'
+		})
+	});
+	JIRA.basicAuth(CONFIG.username, CONFIG.password);
+
+	return ({
+		be_name: 'jira',
+		be_issue_list: jira_issue_list,
+		be_issue_get: jira_issue_get,
+		be_remotelink_get: jira_remotelink_get,
+	});
+}
+
+module.exports = {
+	jira_backend_init: jira_backend_init,
+};
diff --git a/package.json b/package.json
index 3cf033d..441ca3b 100644
--- a/package.json
+++ b/package.json
@@ -11,7 +11,8 @@
     "bunyan": "~0.22.1",
     "ent": "~2.0.0",
     "restify": "~2.6.1",
-    "vasync": "^1.6.4"
+    "vasync": "^2.2.0",
+    "verror": "^1.10.0"
   },
   "devDependencies": {
     "eslint": "4.13.1",
