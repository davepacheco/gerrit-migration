From 90612a3ff305c53b7563b6c15fd01b91a79f1665 Mon Sep 17 00:00:00 2001
From: Mike Zeller <mike.zeller@joyent.com>
Date: Mon, 11 Dec 2017 22:03:44 -0800
Subject: [PATCH] ZAPI-816 vmapi should pre provision nics

---
 lib/apis/napi.js            | 335 ------------------------------------
 lib/apis/wfapi.js           |   3 +
 lib/endpoints/vms.js        | 326 +++++++++++++++++++++++++++++++++--
 lib/workflows/job-common.js | 293 ++++++++++++-------------------
 server.js                   |  12 +-
 5 files changed, 437 insertions(+), 532 deletions(-)
 delete mode 100644 lib/apis/napi.js

diff --git a/lib/apis/napi.js b/lib/apis/napi.js
deleted file mode 100644
index 1906804..0000000
--- a/lib/apis/napi.js
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2017, Joyent, Inc.
- */
-
-/*
- * Functions for dealing with NAPI (the SDC Network API)
- */
-
-
-var restify = require('restify');
-var common = require('./../common');
-var async = require('async');
-
-
-/*
- * NAPI Constructor
- */
-function Napi(options) {
-    this.log = options.log;
-
-    this.client = restify.createJsonClient({
-        url: options.url,
-        version: '*',
-        log: options.log,
-        agent: options.agent
-    });
-}
-
-
-
-/*
- * Pings NAPI
- */
-Napi.prototype.ping = function (callback) {
-    this.client.get('/ping', function (err, req, res) {
-        return callback(err);
-    });
-};
-
-
-
-/*
- * Retrieves NIC information from NAPI
- */
-Napi.prototype.getNics = function (params, callback) {
-    var getParams = {
-        path: '/nics',
-        query: params
-    };
-
-    return this.client.get(getParams, function (err, req, res, nics) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nics);
-    });
-};
-
-
-
-/*
- * Retrieves NIC information from NAPI
- */
-Napi.prototype.getNic = function (mac, callback) {
-    var theMac = mac.replace(/:/g, '');
-
-    return this.client.get('/nics/' + theMac, function (err, req, res, nic) {
-        // 404 is also an error object
-        if (err) {
-            if (res && (res.statusCode === 404)) {
-                return callback(null, null);
-            } else {
-                return callback(err, null);
-            }
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Adds a new NIC on NAPI
- */
-Napi.prototype.addNic = function (params, callback) {
-    return this.client.post('/nics', params, function (err, req, res, nic) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Updates a NIC on NAPI
- */
-Napi.prototype.updateNic = function (mac, params, callback) {
-    var path = '/nics/' + mac.replace(/:/g, '');
-    return this.client.put(path, params, function (err, req, res, nic) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Adds NICs to NAPI only when they don't exist yet
- */
-Napi.prototype.addNics = function (vm, extra, callback) {
-    var self = this;
-
-    if (!vm.nics.length) {
-        self.log.info('VM %s didn\'t have any NICs to add', vm.uuid);
-        return callback();
-    }
-
-    var antiSpoofFields = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
-        'allow_mac_spoofing', 'allow_restricted_traffic',
-        'allow_unfiltered_promisc'];
-
-    var postParams = {
-        owner_uuid: vm.owner_uuid,
-        belongs_to_uuid: vm.uuid,
-        belongs_to_type: 'zone'
-    };
-
-    for (var p in extra) {
-        postParams[p] = extra[p];
-    }
-
-    function nicChanged(cur, old) {
-        var fields = [ 'vlan_id', 'nic_tag', 'primary', 'ip',
-            'netmask', 'state' ].concat(antiSpoofFields);
-        var field;
-        var diff = false;
-
-        for (var i = 0; i < fields.length; i++) {
-            field = fields[i];
-            if (cur[field] !== old[field]) {
-                diff = true;
-                break;
-            }
-        }
-
-        return diff;
-    }
-
-    function sanitizeBooleanAntiSpoof(params) {
-        function booleanFromValue(value) {
-            if (value === 'false' || value === '0') {
-                return false;
-            } else if (value === 'true' || value === '1') {
-                return true;
-            } else {
-                // else should be boolean
-                return value;
-            }
-        }
-
-        antiSpoofFields.forEach(function (field) {
-            if (params[field] !== undefined) {
-                params[field] = booleanFromValue(params[field]);
-            }
-        });
-    }
-
-    async.mapSeries(vm.nics, function (nic, next) {
-        self.getNic(nic.mac, function (err, oldNic) {
-            if (err) {
-                self.log.error('Error getting NIC %s', nic.mac);
-                return next(err);
-            } else {
-                // ZAPI-525: we need to manually add nic.state because this
-                // property doesn't live in the 'nics' attribute in the VM
-                nic.state = (vm.state === 'running' ? 'running' : 'stopped');
-
-                var allParams = common.simpleMerge(nic, postParams);
-                if (allParams.vlan_id === undefined) {
-                    allParams.vlan_id = 0;
-                }
-                allParams.vlan = allParams.vlan_id;
-
-                sanitizeBooleanAntiSpoof(allParams);
-
-                if (!oldNic) {
-                    self.addNic(allParams, function (addErr) {
-                        if (addErr) {
-                            self.log.error('Could not add NIC %s for VM %s',
-                                nic.mac, vm.uuid);
-                        } else {
-                            self.log.info('NIC %s added for VM %s',
-                                nic.mac,  vm.uuid);
-                        }
-                        return next(addErr);
-                    });
-                } else {
-                    // Only update NICs when they haven't changed
-                    if (!nicChanged(nic, oldNic)) {
-                        self.log.info('NIC %s for VM %s unchanged on NAPI',
-                            nic.mac, vm.uuid);
-                        return next();
-                    }
-
-                    // For boolean nic fields, if the value is set in NAPI
-                    // but not in the update, unset it in NAPI.
-                    for (var i = 0; i < antiSpoofFields.length; i++) {
-                        var field = antiSpoofFields[i];
-                        if (oldNic.hasOwnProperty(field) &&
-                                !nic.hasOwnProperty(field)) {
-                            allParams[field] = false;
-                        }
-                    }
-
-                    self.updateNic(nic.mac, allParams, function (addErr) {
-                        if (addErr) {
-                            self.log.error('Could not update NIC %s for VM %s',
-                                nic.mac, vm.uuid);
-                        } else {
-                            self.log.info('NIC %s updated for VM %s',
-                                nic.mac,  vm.uuid);
-                        }
-                        return next(addErr);
-                    });
-                }
-            }
-        });
-
-    }, function (err) {
-        return callback(err);
-    });
-};
-
-
-
-/*
- * Changes the states of NICs based on the VM's state.
- */
-Napi.prototype.updateNicsState = function (vmUuid, vmState, callback) {
-    var self = this;
-
-    var nicState = (vmState === 'running' ? 'running' : 'stopped');
-
-    self.getNics({
-        belongs_to_uuid: vmUuid,
-        belongs_to_type: 'zone'
-    }, function (err, nics) {
-        if (err) {
-            return callback(err);
-        }
-
-        return async.mapSeries(nics, function (nic, next) {
-            if (nic.state === nicState) {
-                next();
-            }
-
-            self.updateNic(nic.mac, { state: nicState }, function (err2) {
-                if (err2) {
-                    self.log.error(err2, 'Could not update NIC %s for VM %s',
-                        nic.mac, vmUuid);
-                } else {
-                    self.log.info('NIC %s updated for VM %s', nic.mac,  vmUuid);
-                }
-
-                return next(err2);
-            });
-        }, callback);
-    });
-};
-
-
-
-/*
- * Adds a new NIC on NAPI
- */
-Napi.prototype.deleteNic = function (mac, callback) {
-    this.client.del('/nics/' + mac.replace(/:/g, ''),
-        function (err, req, res, nic) {
-        if (err) {
-            callback(err, null);
-            return;
-        }
-
-        callback(null, nic);
-    });
-};
-
-
-
-/*
- * Deletes NICs from NAPI only when a VM is deleted
- */
-Napi.prototype.deleteNics = function (vm, callback) {
-    var self = this;
-
-    if (!vm.nics || !vm.nics.length) {
-        self.log.info('VM %s didn\'t have any NICs to destroy', vm.uuid);
-        if (callback !== undefined) {
-            callback();
-        }
-        return;
-    }
-
-    async.mapSeries(vm.nics, function (nic, next) {
-        self.deleteNic(nic.mac, function (err) {
-            if (err) {
-                self.log.error('Could not delete NIC %s for VM %s', nic.mac,
-                    vm.uuid);
-            } else {
-                self.log.info('NIC %s for VM %s deleted from NAPI',
-                    nic.mac, vm.uuid);
-            }
-            return next(err);
-        });
-    }, function (err) {
-        return callback(err);
-    });
-};
-
-
-module.exports = Napi;
diff --git a/lib/apis/wfapi.js b/lib/apis/wfapi.js
index ad7f3e6..3fcf8dd 100644
--- a/lib/apis/wfapi.js
+++ b/lib/apis/wfapi.js
@@ -17,6 +17,7 @@ var async = require('async');
 var sprintf = require('sprintf').sprintf;
 var uuid = require('libuuid');
 var WfClient = require('wf-client');
+var jsprim = require('jsprim');
 
 var common = require('./../common');
 var clone = common.clone;
@@ -152,6 +153,7 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     var params = clone(req.params);
     var vm_uuid = params.uuid;
     var options = { headers: { 'x-request-id': req.getId() } };
+    var filteredNetworks = jsprim.deepCopy(req.filteredNetworks);
 
     params.task = 'provision';
     params.target = '/provision-' + vm_uuid;
@@ -159,6 +161,7 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     params.current_state = 'provisioning';
     params['x-request-id'] = req.getId();
     delete params.uuid;
+    params.filteredNetworks = filteredNetworks;
 
     setContext(req, params);
 
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 7f0df10..8e8d451 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -868,6 +868,157 @@ function createRoleTags(req, cb) {
     req.app.moray.putVmRoleTags(req.params.uuid, roleTags, cb);
 }
 
+/*
+ * XXX document me!
+ *
+ * filteredNetworks:
+ *  - netInfo: all of the napi infor for each network
+ *  - networks: resolved networks
+ */
+function preFilterNetworks(req, res, next) {
+    req.filteredNetworks = {};
+
+    var filteredNetworks = req.filteredNetworks;
+    filteredNetworks.netInfo = [];
+    filteredNetworks.networks = [];
+    filteredNetworks.fabrics = [];
+    filteredNetworks.pools = [];
+
+    /*JSSTYLED*/
+    var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
+
+    var napi = req.app.napi;
+
+    try {
+        common.validateNetworks(req.params);
+    } catch (err) {
+        return next(err);
+    }
+
+    var networks = req.params.networks;
+    var owner_uuid = req.params.owner_uuid;
+
+    function findNetwork(netId, cb) {
+        var params;
+
+        if (UUID_RE.test(netId)) {
+            params = { params: { provisionable_by: owner_uuid }};
+            napi.getNetwork(netId, params, cb);
+        } else {
+            params = { name: netId };
+            napi.listNetworks(params, cb);
+        }
+    }
+
+    function findNetworkPool(netId, cb) {
+        var params;
+
+        if (UUID_RE.test(netId)) {
+            params = { params: { provisionable_by: owner_uuid }};
+            napi.getNetworkPool(netId, params, cb);
+        } else {
+            params = { name: netId };
+            napi.listNetworkPools(params, cb);
+        }
+    }
+
+    /*
+     * We need to get all of the networks so we know the following:
+     * - the account can own a nic on the network
+     * - if the network is a fabric
+     * - if the network is a pool
+     */
+    function getNetworkInfo(netId, callback) {
+            findNetwork(netId, function (err, nets) {
+            // If network is not found then it might be a network pool
+            if (err && err.name !== 'ResourceNotFoundError') {
+                callback(err);
+                return;
+            }
+
+            // Did we get the network from list or get?
+            var net = (Array.isArray(nets) ? nets[0] : nets);
+
+            // No net if NAPI returns an empty array or if we got a 404
+            if (net) {
+                if (net.fabric) {
+                    filteredNetworks.fabrics.push(net.uuid);
+                }
+                filteredNetworks.netInfo.push(net);
+                callback(null, net.uuid);
+                return;
+            }
+
+            // We might be trying to provision on a network pool, so
+            // try that instead
+            findNetworkPool(netId, function (err2, pools) {
+                if (err2) {
+                    callback(err2);
+                    return;
+                }
+
+                /*
+                 * Prior to NAPI-121, using a "name" filter for a network pool
+                 * would either be silently ignored (or rejected post NAPI-343).
+                 * In case we're talking to a NAPI that's ignored our parameter,
+                 * we filter the results to avoid using an incorrect pool.
+                 */
+                if (Array.isArray(pools)) {
+                    pools = pools.filter(function (pool) {
+                        return pool.name === netId;
+                    });
+                    if (pools.length === 0) {
+                        callback(new Error(
+                            'No such Network Pool with name: ' + netId));
+                    } else if (pools.length === 1) {
+                        filteredNetworks.pools.push(pools[0].uuid);
+                        filteredNetworks.netInfo.push(pools[0]);
+                        callback(null, pools[0].uuid);
+                    } else {
+                        callback(new Error(
+                            'Multiple Network Pools with name: ' + netId));
+                    }
+                } else {
+                    filteredNetworks.pools.push(pools.uuid);
+                    filteredNetworks.netInfo.push(pools);
+                    callback(null, pools.uuid);
+                }
+            });
+        });
+    }
+
+    async.mapSeries(networks, function (network, cb) {
+        var netId;
+        if (network.ipv4_uuid !== undefined) {
+            netId = network.ipv4_uuid;
+        } else if (network.name !== undefined) {
+            netId = network.name;
+        }
+
+        getNetworkInfo(netId, function (err, uuid) {
+            if (err) {
+                cb(err);
+            } else {
+                network.ipv4_uuid = uuid;
+                delete network.name;
+                filteredNetworks.networks.push(network);
+                cb();
+            }
+        });
+
+    }, function (err2) {
+        if (err2) {
+            next(err2);
+            return;
+        } else {
+            req.log.info({filterdNetworks: filteredNetworks},
+                'filteredNetworks complete');
+            next();
+            return;
+        }
+    });
+
+}
 
 
 /*
@@ -879,23 +1030,177 @@ function createVm(req, res, next) {
 
     var sync = req.params.sync;
 
-    common.validateCreateVmParams(req.app, req.params, function (err) {
+    var napi = req.app.napi;
+
+    // Provisioned NICs are added to this array
+    var nics = [];
+
+    // ZAPI-816
+    vasync.pipeline({
+        'funcs': [
+            validateCreateVmParams,
+            preProvisionNics
+        ]
+    }, function (err, results) {
         if (err) {
+            cleanUpNics();
             return next(err);
         }
 
-        common.setDefaultValues(req.params, {config: req.app.options});
+        createProvisionJob();
+    });
 
-        if (sync && ['true', 'false'].indexOf(sync) === -1) {
-            var error = [ errors.invalidParamErr('sync') ];
-            return next(new errors.ValidationFailedError('Invalid Parameters',
-                error));
-        } else {
-            req.params.sync = (sync === 'true' ? true : false);
+
+    function validateCreateVmParams(_, done) {
+        common.validateCreateVmParams(req.app, req.params, function (err) {
+            if (err) {
+                return done(err);
+            }
+
+            common.setDefaultValues(req.params, {config: req.app.options});
+
+            if (sync && ['true', 'false'].indexOf(sync) === -1) {
+                var error = [ errors.invalidParamErr('sync') ];
+                return done(new errors.ValidationFailedError('Invalid' +
+                    ' Parameters',
+                    error));
+            } else {
+                req.params.sync = (sync === 'true' ? true : false);
+            }
+
+            done();
+        });
+    }
+
+    /*
+     * ZAPI-816 - Its better to pre-provision NIC's up front so that any issues
+     * can be reported back to the createVm caller before a workflow job is
+     * kicked off.
+     *
+     * - Keep track of all NIC's created in case we hit an error and need to
+     *   cleanup.
+     * - Keep track of fabric NIC's so we can properly backfill the NIC object
+     *   with important fields such as cn_uuid as a part of the workflow job.
+     * - Save network pool NICs for later creation as we need to get a
+     *   list of server NIC tags which already happens as a part of the
+     *   workflow.
+     */
+    function preProvisionNics(_, done) {
+        var inst_uuid = req.params.uuid;
+
+        var filteredNetworks = req.filteredNetworks;
+        var networks = filteredNetworks.networks;
+        var owner_uuid = req.params.owner_uuid;
+
+        // Filter out pool networks, which will be handled later in workflow
+        networks = networks.filter(function filterOutPoolNets(net) {
+            if (filteredNetworks.pools.indexOf(net.ipv4_uuid) >= 0) {
+                return false;
+            }
+            return true;
+        });
+
+        networks.forEach(function (net) {
+            // Make absolutely sure we're never overriding NAPI's network
+            // owner checks:
+            delete net.check_owner;
+        });
+
+        // Return a new copy for every time we provision a new NIC and avoid
+        // accidentally reusing an object
+        function nicParams() {
+            var fakeUuid = '00000000-dead-beef-badd-cafe00000000';
+            return {
+                owner_uuid: owner_uuid,
+                belongs_to_uuid: fakeUuid,
+                belongs_to_type: 'zone',
+                state: 'provisioning',
+                cn_uuid: fakeUuid
+            };
         }
 
-        createProvisionJob();
-    });
+        var antiSpoofParams = [
+            'allow_dhcp_spoofing',
+            'allow_ip_spoofing',
+            'allow_mac_spoofing',
+            'allow_restricted_traffic'
+        ];
+
+        /*
+         * Get current list of NICs that might have been provisioned ahead of
+         * time. This is done in some places when an IP address needs to be
+         * known ahead of time. For example, Zookeeper instances in Manta have
+         * their NICs created before provisioning instances, so that they can be
+         * configured to know each other's addresses before booting.
+         */
+        napi.listNics({
+            owner_uuid: owner_uuid,
+            belongs_to_uuid: inst_uuid,
+            belongs_to_type: 'zone'
+        }, function asyncProvisionNics(err, currentNics) {
+            if (err) {
+                done(err);
+                return;
+            }
+
+            async.mapSeries(networks, function (network, cb) {
+                // If there is at least one provisioned NIC in one of the
+                // networks provided, skip napi.provisionNic for this network
+                var netNics = currentNics.filter(function (nic) {
+                    return (nic.network_uuid && nic.network_uuid ===
+                        network.ipv4_uuid);
+                });
+
+                if (netNics.length > 0) {
+                    nics = nics.concat(netNics);
+                    cb();
+                    return;
+                }
+
+                var params = nicParams();
+                if (network.ipv4_ips !== undefined)
+                    params.ip = network.ipv4_ips[0];
+
+                antiSpoofParams.forEach(function (spoofParam) {
+                    if (network.hasOwnProperty(spoofParam)) {
+                        params[spoofParam] = network[spoofParam];
+                    }
+                });
+
+                napi.provisionNic(network.ipv4_uuid, params,
+                    function (suberr, nic) {
+                    if (suberr) {
+                        cb(suberr);
+                    } else {
+                        nics.push(nic);
+                        cb();
+                    }
+                });
+            }, function (err2) {
+                if (err2) {
+                    done(err2);
+                } else {
+                    req.filteredNetworks.nics = nics;
+                    req.log.info({ nics: req.filteredNetworks.nics },
+                        'NICs allocated');
+                    done();
+                }
+            });
+        });
+
+
+    }
+
+    function cleanUpNics() {
+        nics.forEach(function deleteNic(nic) {
+            napi.deleteNic(nic.mac, function (napiErr) {
+                if (napiErr) {
+                    req.log.error({ err: napiErr, nic: nic },
+                        'Error deleting pre-provisioned NIC %s', nic.mac);
+                }
+            });
+        });
+    }
 
     function createProvisionJob() {
         if (req.params.role_tags === undefined) {
@@ -1227,6 +1532,7 @@ function mount(server) {
 
     server.post({ path: '/vms', name: 'CreateVm' },
         interceptors.checkWfapi,
+        preFilterNetworks,
         createVm);
 
     server.get({ path: '/vms/:uuid/proc', name: 'GetVmProc' },
diff --git a/lib/workflows/job-common.js b/lib/workflows/job-common.js
index b5dd881..abda5af 100644
--- a/lib/workflows/job-common.js
+++ b/lib/workflows/job-common.js
@@ -556,10 +556,12 @@ function postBack(job, cb) {
 
 
 /*
+ * XXX update comment
  * Gets a list of NIC tags after validating every network provided
  */
 function validateNetworks(job, cb) {
     var networks = job.params.networks;
+    var filteredNetworks = job.params.filteredNetworks;
 
     // add-nics also calls this function, but if macs are provided we don't
     // necessarily need to progress further
@@ -567,128 +569,21 @@ function validateNetworks(job, cb) {
         return cb();
     }
 
-    var newNetworks = [];
-    if (!networks) {
-        return cb('Networks are required');
-    }
-
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
     job.nicTagReqs = [];
 
-    function pushPoolTags(pool) {
-        if (pool.nic_tags_present) {
-            job.nicTagReqs.push(pool.nic_tags_present);
+    function pushTags(net) {
+        if (net.nic_tags_present) {
+            job.nicTagReqs.push(net.nic_tags_present);
         } else {
-            job.nicTagReqs.push([ pool.nic_tag ]);
+            job.nicTagReqs.push([ net.nic_tag ]);
         }
     }
 
-    // - Resolve network names to uuids when applicable
-    // - Repopulate job.params.networks
-    // - Returns cb(err, uuid). uuid is present when name was resolved to uuid
-    function getNetwork(netId, callback) {
-        /*JSSTYLED*/
-        var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-        var netFn, poolFn;
-        var params;
-
-        // Network can be either by name or uuid
-        if (UUID_RE.test(netId)) {
-            params = netId;
-            netFn = napi.getNetwork;
-            poolFn = napi.getNetworkPool;
-        } else {
-            params = { name: netId };
-            netFn = napi.listNetworks;
-            poolFn = napi.listNetworkPools;
-        }
-
-        netFn.call(napi, params, function (err, nets) {
-            // If network is not found then it might be a network pool
-            if (err && err.name !== 'ResourceNotFoundError') {
-                callback(err);
-                return;
-            }
-
-            // Did we get the network from list or get?
-            var net = (Array.isArray(nets) ? nets[0] : nets);
-
-            // No net if NAPI returns an empty array or if we got a 404
-            if (net) {
-                job.nicTagReqs.push([ net.nic_tag ]);
-                callback(null, net.uuid);
-                return;
-            }
-
-            // We might be trying to provision on a network pool, so
-            // try that instead
-            poolFn.call(napi, params, function (err2, pools) {
-                if (err2) {
-                    callback(err2);
-                    return;
-                }
-
-                /*
-                 * Prior to NAPI-121, using a "name" filter for a network pool
-                 * would either be silently ignored (or rejected post NAPI-343).
-                 * In case we're talking to a NAPI that's ignored our parameter,
-                 * we filter the results to avoid using an incorrect pool.
-                 */
-                if (Array.isArray(pools)) {
-                    pools = pools.filter(function (pool) {
-                        return pool.name === netId;
-                    });
-                    if (pools.length === 0) {
-                        callback(new Error(
-                            'No such Network Pool with name: ' + netId));
-                    } else if (pools.length === 1) {
-                        pushPoolTags(pools[0]);
-                        callback(null, pools[0].uuid);
-                    } else {
-                        callback(new Error(
-                            'Multiple Network Pools with name: ' + netId));
-                    }
-                } else {
-                    pushPoolTags(pools);
-                    callback(null, pools.uuid);
-                }
-            });
-        });
-    }
-
-    async.mapSeries(networks, function (network, next) {
-        var netId;
-        if (network.ipv4_uuid !== undefined) {
-            netId = network.ipv4_uuid;
-        } else if (network.name !== undefined) {
-            netId = network.name;
-        }
-
-        getNetwork(netId, function (err, uuid) {
-            if (err) {
-                next(err);
-            } else {
-                network.uuid = uuid;
-                network.ipv4_uuid = uuid;
-                newNetworks.push(network);
-                next();
-            }
-        });
-
-    }, function (err2) {
-        if (err2) {
-            cb(err2);
-        } else {
-            job.params.networks = newNetworks;
-            job.log.info({ nicTagReqs: job.nicTagReqs },
-                'NIC Tag requirements retrieved');
-            cb(null, 'Networks are valid');
-        }
+    filteredNetworks.netInfo.forEach(function (net) {
+        pushTags(net);
     });
+
+    cb();
 }
 
 
@@ -856,21 +751,13 @@ function provisionNics(job, cb) {
     var inst_uuid = job.params.uuid || job.params.vm_uuid;
     var owner_uuid = job.params.owner_uuid;
 
-    var networks = job.params.networks;
-    if (networks === undefined) {
-        cb('Networks are required');
+    var filteredNetworks = job.params.filteredNetworks;
+    if (filteredNetworks === undefined) {
+        cb('Networks should be populated already');
         return;
     }
 
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    // Every NIC we provision is added to this array
-    var nics = [];
-    var primaryFound = false;
-    job.params.fabricNatNics = [];
+    var networks = filteredNetworks.networks;
 
     networks.forEach(function (net) {
         if (net.primary)
@@ -883,6 +770,25 @@ function provisionNics(job, cb) {
     if (!primaryFound && networks.length > 0)
         networks[0].primary = true;
 
+    var poolNetworks = filteredNetworks.networks.filter(function
+        filterOutPoolNets(net) {
+        if (filteredNetworks.pools.indexOf(net.ipv4_uuid) >= 0) {
+            return true;
+        }
+        return false;
+    });
+
+    var napi = new sdcClients.NAPI({
+        url: napiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    // Every NIC we provision or updated is added to this array
+    var nics = [];
+    var primaryFound = false;
+    job.params.fabricNatNics = [];
+
+
     // Return a new copy for every time we provision a new NIC and avoid
     // accidentally reusing an object
     function nicParams() {
@@ -890,6 +796,7 @@ function provisionNics(job, cb) {
             owner_uuid: owner_uuid,
             belongs_to_uuid: inst_uuid,
             belongs_to_type: 'zone',
+            state: 'running',
             nic_tags_available: job.serverNicTags,
             cn_uuid: job.params.server_uuid
         };
@@ -911,71 +818,93 @@ function provisionNics(job, cb) {
         'allow_restricted_traffic'
     ];
 
-    /*
-     * Get current list of NICs that might have been provisioned ahead of time.
-     * This is done in some places when an IP address needs to be known ahead
-     * of time. For example, Zookeeper instances in Manta have their NICs
-     * created before provisioning instances, so that they can be configured
-     * to know each other's addresses before booting.
-     */
-    napi.listNics({
-        owner_uuid: owner_uuid,
-        belongs_to_uuid: inst_uuid,
-        belongs_to_type: 'zone'
-    }, function asyncProvisionNics(err, currentNics) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        async.mapSeries(networks, function (network, next) {
-            // If there is at least one provisioned NIC in one of the networks
-            // provided, skip napi.provisionNic for this network
-            var netNics = currentNics.filter(function (nic) {
-                return (nic.network_uuid && nic.network_uuid ===
-                    network.ipv4_uuid);
-            });
+    job.params.nics = nics;
 
-            if (netNics.length > 0) {
-                nics = nics.concat(netNics);
-                next();
-                return;
-            }
+    async.series([
+        function provisionPoolNicss(callback) {
+            async.mapSeries(poolNetworks, function (network, next) {
+                var params = nicParams();
+                if (network.ipv4_ips !== undefined)
+                    params.ip = network.ipv4_ips[0];
+                if (network.primary !== undefined)
+                    params.primary = network.primary;
 
-            var params = nicParams();
-            if (network.ipv4_ips !== undefined)
-                params.ip = network.ipv4_ips[0];
-            if (network.primary !== undefined)
-                params.primary = network.primary;
+                antiSpoofParams.forEach(function (spoofParam) {
+                    if (network.hasOwnProperty(spoofParam)) {
+                        params[spoofParam] = network[spoofParam];
+                    }
+                });
 
-            antiSpoofParams.forEach(function (spoofParam) {
-                if (network.hasOwnProperty(spoofParam)) {
-                    params[spoofParam] = network[spoofParam];
+                napi.provisionNic(network.ipv4_uuid, params,
+                    function (suberr, nic) {
+                    if (suberr) {
+                        next(suberr);
+                    } else {
+                        nics.push(nic);
+                        // pools may contain fabric networks someday
+                        addFabricNatNic(nic);
+                        next();
+                    }
+                });
+            }, function (err) {
+                if (err) {
+                    callback(err);
+                    return;
                 }
+                callback();
             });
+        },
+        function updateExistingNics(callback) {
+            // Update existing nics
+            async.mapSeries(filteredNetworks.nics, function (nic, next) {
+                var params = nicParams();
+
+                var network;
+                var netClone = networks.slice();
+                while (netClone.length > 0) {
+                    var net = netClone.shift();
+                    if (net.ipv4_uuid === nic.network_uuid) {
+                        network = net;
+                        break;
+                    }
+                }
 
-            napi.provisionNic(network.ipv4_uuid, params,
-                function (suberr, nic) {
-                if (suberr) {
-                    next(suberr);
-                } else {
-                    nics.push(nic);
-                    addFabricNatNic(nic);
-                    next();
+                if (network.primary !== undefined)
+                    params.primary = network.primary;
+
+                antiSpoofParams.forEach(function (spoofParam) {
+                    if (network.hasOwnProperty(spoofParam)) {
+                        params[spoofParam] = network[spoofParam];
+                    }
+                });
+
+                napi.updateNic(nic.mac, params,
+                    function (suberr, updatedNic) {
+                    if (suberr) {
+                        next(suberr);
+                    } else {
+                        nics.push(updatedNic);
+                        addFabricNatNic(updatedNic);
+                        next();
+                    }
+                });
+            }, function (err) {
+                if (err) {
+                    callback(err);
+                    return;
                 }
+                callback();
             });
-        }, function (err2) {
-            if (err2) {
-                cb(err2);
-            } else {
-                job.params.nics = nics;
-                job.log.info({ nics: job.params.nics }, 'NICs allocated');
+        }
+    ], function (err, results) {
+        if (err) {
+            cb(err);
+        } else {
+            job.log.info({ nics: job.params.nics }, 'NICs allocated');
 
-                cb(null, 'NICs allocated');
-            }
-        });
+            cb(null, 'NICs allocated and updated');
+        }
     });
-
 }
 
 
diff --git a/server.js b/server.js
index 5c2e567..f31de30 100644
--- a/server.js
+++ b/server.js
@@ -26,9 +26,9 @@ var sigyan = require('sigyan');
 var util = require('util');
 var vasync = require('vasync');
 
+var sdc = require('sdc-clients');
 var CNAPI = require('./lib/apis/cnapi');
 var IMGAPI = require('./lib/apis/imgapi');
-var NAPI = require('./lib/apis/napi');
 var PAPI = require('./lib/apis/papi');
 var VmapiApp = require('./lib/vmapi');
 var WFAPI = require('./lib/apis/wfapi');
@@ -96,10 +96,12 @@ function createApiClients(config, parentLog) {
     var imgapiClient = new IMGAPI(imgapiClientOpts);
 
     assert.object(config.napi, 'config.napi');
-    var napiClientOpts = jsprim.deepCopy(config.napi);
-    napiClientOpts.log = parentLog.child({ component: 'napi' }, true);
-    napiClientOpts.agent = agent;
-    var napiClient = new NAPI(napiClientOpts);
+    var napiLog = parentLog.child({ component: 'napi' }, true);
+    var napiClient = new sdc.NAPI({
+        log: napiLog,
+        url: config.napi.url,
+        agent: false
+    });
 
     assert.object(config.papi, 'config.papi');
     var papiClientOpts = jsprim.deepCopy(config.papi);
-- 
2.21.0

