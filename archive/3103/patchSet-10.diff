commit a9d1a9ab22ee2a9f90de293e267ffc7502653202 (refs/changes/03/3103/10)
Author: Mike Zeller <mike.zeller@joyent.com>
Date:   2017-12-22T20:54:04-08:00 (1 year, 10 months ago)
    
    ZAPI-816 vmapi should pre provision nics
    ZAPI-765 Adding a fabric NIC to a VM doesn't provision a fabric NAT

diff --git a/lib/apis/napi.js b/lib/apis/napi.js
deleted file mode 100644
index 1906804..0000000
--- a/lib/apis/napi.js
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2017, Joyent, Inc.
- */
-
-/*
- * Functions for dealing with NAPI (the SDC Network API)
- */
-
-
-var restify = require('restify');
-var common = require('./../common');
-var async = require('async');
-
-
-/*
- * NAPI Constructor
- */
-function Napi(options) {
-    this.log = options.log;
-
-    this.client = restify.createJsonClient({
-        url: options.url,
-        version: '*',
-        log: options.log,
-        agent: options.agent
-    });
-}
-
-
-
-/*
- * Pings NAPI
- */
-Napi.prototype.ping = function (callback) {
-    this.client.get('/ping', function (err, req, res) {
-        return callback(err);
-    });
-};
-
-
-
-/*
- * Retrieves NIC information from NAPI
- */
-Napi.prototype.getNics = function (params, callback) {
-    var getParams = {
-        path: '/nics',
-        query: params
-    };
-
-    return this.client.get(getParams, function (err, req, res, nics) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nics);
-    });
-};
-
-
-
-/*
- * Retrieves NIC information from NAPI
- */
-Napi.prototype.getNic = function (mac, callback) {
-    var theMac = mac.replace(/:/g, '');
-
-    return this.client.get('/nics/' + theMac, function (err, req, res, nic) {
-        // 404 is also an error object
-        if (err) {
-            if (res && (res.statusCode === 404)) {
-                return callback(null, null);
-            } else {
-                return callback(err, null);
-            }
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Adds a new NIC on NAPI
- */
-Napi.prototype.addNic = function (params, callback) {
-    return this.client.post('/nics', params, function (err, req, res, nic) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Updates a NIC on NAPI
- */
-Napi.prototype.updateNic = function (mac, params, callback) {
-    var path = '/nics/' + mac.replace(/:/g, '');
-    return this.client.put(path, params, function (err, req, res, nic) {
-        if (err) {
-            return callback(err, null);
-        }
-
-        return callback(null, nic);
-    });
-};
-
-
-
-/*
- * Adds NICs to NAPI only when they don't exist yet
- */
-Napi.prototype.addNics = function (vm, extra, callback) {
-    var self = this;
-
-    if (!vm.nics.length) {
-        self.log.info('VM %s didn\'t have any NICs to add', vm.uuid);
-        return callback();
-    }
-
-    var antiSpoofFields = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
-        'allow_mac_spoofing', 'allow_restricted_traffic',
-        'allow_unfiltered_promisc'];
-
-    var postParams = {
-        owner_uuid: vm.owner_uuid,
-        belongs_to_uuid: vm.uuid,
-        belongs_to_type: 'zone'
-    };
-
-    for (var p in extra) {
-        postParams[p] = extra[p];
-    }
-
-    function nicChanged(cur, old) {
-        var fields = [ 'vlan_id', 'nic_tag', 'primary', 'ip',
-            'netmask', 'state' ].concat(antiSpoofFields);
-        var field;
-        var diff = false;
-
-        for (var i = 0; i < fields.length; i++) {
-            field = fields[i];
-            if (cur[field] !== old[field]) {
-                diff = true;
-                break;
-            }
-        }
-
-        return diff;
-    }
-
-    function sanitizeBooleanAntiSpoof(params) {
-        function booleanFromValue(value) {
-            if (value === 'false' || value === '0') {
-                return false;
-            } else if (value === 'true' || value === '1') {
-                return true;
-            } else {
-                // else should be boolean
-                return value;
-            }
-        }
-
-        antiSpoofFields.forEach(function (field) {
-            if (params[field] !== undefined) {
-                params[field] = booleanFromValue(params[field]);
-            }
-        });
-    }
-
-    async.mapSeries(vm.nics, function (nic, next) {
-        self.getNic(nic.mac, function (err, oldNic) {
-            if (err) {
-                self.log.error('Error getting NIC %s', nic.mac);
-                return next(err);
-            } else {
-                // ZAPI-525: we need to manually add nic.state because this
-                // property doesn't live in the 'nics' attribute in the VM
-                nic.state = (vm.state === 'running' ? 'running' : 'stopped');
-
-                var allParams = common.simpleMerge(nic, postParams);
-                if (allParams.vlan_id === undefined) {
-                    allParams.vlan_id = 0;
-                }
-                allParams.vlan = allParams.vlan_id;
-
-                sanitizeBooleanAntiSpoof(allParams);
-
-                if (!oldNic) {
-                    self.addNic(allParams, function (addErr) {
-                        if (addErr) {
-                            self.log.error('Could not add NIC %s for VM %s',
-                                nic.mac, vm.uuid);
-                        } else {
-                            self.log.info('NIC %s added for VM %s',
-                                nic.mac,  vm.uuid);
-                        }
-                        return next(addErr);
-                    });
-                } else {
-                    // Only update NICs when they haven't changed
-                    if (!nicChanged(nic, oldNic)) {
-                        self.log.info('NIC %s for VM %s unchanged on NAPI',
-                            nic.mac, vm.uuid);
-                        return next();
-                    }
-
-                    // For boolean nic fields, if the value is set in NAPI
-                    // but not in the update, unset it in NAPI.
-                    for (var i = 0; i < antiSpoofFields.length; i++) {
-                        var field = antiSpoofFields[i];
-                        if (oldNic.hasOwnProperty(field) &&
-                                !nic.hasOwnProperty(field)) {
-                            allParams[field] = false;
-                        }
-                    }
-
-                    self.updateNic(nic.mac, allParams, function (addErr) {
-                        if (addErr) {
-                            self.log.error('Could not update NIC %s for VM %s',
-                                nic.mac, vm.uuid);
-                        } else {
-                            self.log.info('NIC %s updated for VM %s',
-                                nic.mac,  vm.uuid);
-                        }
-                        return next(addErr);
-                    });
-                }
-            }
-        });
-
-    }, function (err) {
-        return callback(err);
-    });
-};
-
-
-
-/*
- * Changes the states of NICs based on the VM's state.
- */
-Napi.prototype.updateNicsState = function (vmUuid, vmState, callback) {
-    var self = this;
-
-    var nicState = (vmState === 'running' ? 'running' : 'stopped');
-
-    self.getNics({
-        belongs_to_uuid: vmUuid,
-        belongs_to_type: 'zone'
-    }, function (err, nics) {
-        if (err) {
-            return callback(err);
-        }
-
-        return async.mapSeries(nics, function (nic, next) {
-            if (nic.state === nicState) {
-                next();
-            }
-
-            self.updateNic(nic.mac, { state: nicState }, function (err2) {
-                if (err2) {
-                    self.log.error(err2, 'Could not update NIC %s for VM %s',
-                        nic.mac, vmUuid);
-                } else {
-                    self.log.info('NIC %s updated for VM %s', nic.mac,  vmUuid);
-                }
-
-                return next(err2);
-            });
-        }, callback);
-    });
-};
-
-
-
-/*
- * Adds a new NIC on NAPI
- */
-Napi.prototype.deleteNic = function (mac, callback) {
-    this.client.del('/nics/' + mac.replace(/:/g, ''),
-        function (err, req, res, nic) {
-        if (err) {
-            callback(err, null);
-            return;
-        }
-
-        callback(null, nic);
-    });
-};
-
-
-
-/*
- * Deletes NICs from NAPI only when a VM is deleted
- */
-Napi.prototype.deleteNics = function (vm, callback) {
-    var self = this;
-
-    if (!vm.nics || !vm.nics.length) {
-        self.log.info('VM %s didn\'t have any NICs to destroy', vm.uuid);
-        if (callback !== undefined) {
-            callback();
-        }
-        return;
-    }
-
-    async.mapSeries(vm.nics, function (nic, next) {
-        self.deleteNic(nic.mac, function (err) {
-            if (err) {
-                self.log.error('Could not delete NIC %s for VM %s', nic.mac,
-                    vm.uuid);
-            } else {
-                self.log.info('NIC %s for VM %s deleted from NAPI',
-                    nic.mac, vm.uuid);
-            }
-            return next(err);
-        });
-    }, function (err) {
-        return callback(err);
-    });
-};
-
-
-module.exports = Napi;
diff --git a/lib/apis/wfapi.js b/lib/apis/wfapi.js
index ad7f3e6..cc0861a 100644
--- a/lib/apis/wfapi.js
+++ b/lib/apis/wfapi.js
@@ -17,6 +17,7 @@ var async = require('async');
 var sprintf = require('sprintf').sprintf;
 var uuid = require('libuuid');
 var WfClient = require('wf-client');
+var jsprim = require('jsprim');
 
 var common = require('./../common');
 var clone = common.clone;
@@ -152,6 +153,7 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     var params = clone(req.params);
     var vm_uuid = params.uuid;
     var options = { headers: { 'x-request-id': req.getId() } };
+    var filteredNetworks = jsprim.deepCopy(req.filteredNetworks);
 
     params.task = 'provision';
     params.target = '/provision-' + vm_uuid;
@@ -159,6 +161,7 @@ Wfapi.prototype.createProvisionJob = function (req, cb) {
     params.current_state = 'provisioning';
     params['x-request-id'] = req.getId();
     delete params.uuid;
+    params.filteredNetworks = filteredNetworks;
 
     setContext(req, params);
 
@@ -500,6 +503,7 @@ Wfapi.prototype.createAddNicsJob = function (req, params, cb) {
     var self = this;
     var vm_uuid = req.vm.uuid;
     var options = { headers: { 'x-request-id': req.getId() } };
+    var filteredNetworks = jsprim.deepCopy(req.filteredNetworks);
 
     params.task = 'add_nics';
     params.target = '/add-nics-' + vm_uuid;
@@ -510,6 +514,8 @@ Wfapi.prototype.createAddNicsJob = function (req, params, cb) {
     params.oldResolvers = req.vm.resolvers;
     params.wantResolvers = true;
     params['x-request-id'] = req.getId();
+    params.sdc_nat_pool = req.params.sdc_nat_pool;
+    params.filteredNetworks = filteredNetworks;
 
     setContext(req, params);
 
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 7f0df10..eda81b0 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -16,6 +16,7 @@ var util = require('util');
 
 var async = require('async');
 var vasync = require('vasync');
+var VError = require('verror');
 var assert = require('assert-plus');
 var restify = require('restify');
 
@@ -712,19 +713,22 @@ function changeVm(req, res, next) {
  */
 function addNics(req, res, next) {
     var params = req.params;
+    var networks = req.filteredNetworks.networks;
+
     req.log.trace({ vm_uuid: params.uuid }, 'AddNics start');
 
-    var creationArgs;
+    var args;
 
     // we must receive either networks or mac as param
-    if (params.networks) {
-        try {
-            common.validateNetworks(params);
-        } catch (err) {
-            return next(err);
-        }
-
-        creationArgs = { networks: params.networks };
+    if (networks.length > 0) {
+        preProvisionNics(req, function onPreProvisionNics(err, results) {
+            if (err) {
+                next(err);
+                return;
+            }
+            args = { networks: params.networks };
+            doAddNics(args);
+        });
     } else {
         try {
             common.validateMacs(params);
@@ -732,10 +736,21 @@ function addNics(req, res, next) {
             return next(err);
         }
 
-        creationArgs = { macs: params.macs };
+        args = { macs: params.macs };
+        doAddNics(args);
     }
 
-    req.app.wfapi.createAddNicsJob(req, creationArgs, onAddNicsJob);
+    function doAddNics(creationArgs) {
+        var config = req.app.options;
+
+        // When adding a nic if a fabric nat is wanted but hasn't been setup yet
+        // we will need to pass in sdc_nat_pool to the workflow job
+        if (config.overlay && config.overlay.enabled) {
+            params.sdc_nat_pool = config.overlay.natPool;
+        }
+
+        req.app.wfapi.createAddNicsJob(req, creationArgs, onAddNicsJob);
+    }
 
     function onAddNicsJob(err, juuid) {
         if (err) {
@@ -868,6 +883,371 @@ function createRoleTags(req, cb) {
     req.app.moray.putVmRoleTags(req.params.uuid, roleTags, cb);
 }
 
+/*
+ * preFilterNetworks will gather network info ahead of time for each of
+ * the networks passed into vmapi. This avoids looking up the same info
+ * in napi more than once.
+ *
+ * filteredNetworks fields:
+ *  - netInfo: all of the napi info for each network
+ *  - networks: validated and transformed req.params.networks
+ *  - fabrics: array of fabric network uuids if any were passed in
+ *  - pools: array of pool network uuids if any were passed in
+ *  - nics: eventual storage for nics as they are provisioned
+ */
+function preFilterNetworks(req, res, next) {
+    req.filteredNetworks = {};
+
+    var filteredNetworks = req.filteredNetworks;
+    filteredNetworks.netInfo = [];
+    filteredNetworks.networks = [];
+    filteredNetworks.fabrics = [];
+    filteredNetworks.pools = [];
+    filteredNetworks.nics = [];
+
+    // If we came in via addNics we might not have any networks to process
+    if (!req.params.networks) {
+        req.log.info({params: req.params}, 'no need to preFilterNetworks');
+        next();
+        return;
+    }
+
+    var napi = req.app.napi;
+
+    try {
+        common.validateNetworks(req.params);
+    } catch (err) {
+        next(err);
+        return;
+    }
+
+    var networks = req.params.networks;
+    var owner_uuid = req.params.owner_uuid || req.vm.owner_uuid;
+
+    assert.uuid(owner_uuid, 'owner_uuid');
+
+    function findNetwork(netId, cb) {
+        var params;
+
+        if (common.validUUID(netId)) {
+            params = { params: { provisionable_by: owner_uuid }};
+            napi.getNetwork(netId, params, cb);
+        } else {
+            params = { name: netId };
+            napi.listNetworks(params, cb);
+        }
+    }
+
+    function findNetworkPool(netId, cb) {
+        var params;
+
+        if (common.validUUID(netId)) {
+            params = { params: { provisionable_by: owner_uuid }};
+            napi.getNetworkPool(netId, params, cb);
+        } else {
+            params = { name: netId };
+            napi.listNetworkPools(params, cb);
+        }
+    }
+
+    /*
+     * We need to get all of the networks so we know the following:
+     * - the account can own a nic on the network
+     * - if the network is a fabric
+     * - if the network is a pool
+     */
+    function getNetworkInfo(network, callback) {
+        var netId;
+        if (network.ipv4_uuid !== undefined) {
+            netId = network.ipv4_uuid;
+        } else if (network.name !== undefined) {
+            netId = network.name;
+        }
+
+        assert.string(netId, 'netId');
+
+        findNetwork(netId, function (err, nets) {
+            // If network is not found then it might be a network pool
+            if (err && !VError.hasCauseWithName(err, 'ResourceNotFoundError')) {
+                callback(new VError(err, 'Failed to find network "%s"', netId));
+                return;
+            }
+
+            // Did we get the network from list or get?
+            var net = (Array.isArray(nets) ? nets[0] : nets);
+
+            // No net if NAPI returns an empty array or if we got a 404
+            if (net) {
+                if (net.fabric) {
+                    filteredNetworks.fabrics.push(net.uuid);
+                }
+                filteredNetworks.netInfo.push(net);
+                callback(null, net.uuid);
+                return;
+            }
+
+            // We might be trying to provision on a network pool, so
+            // try that instead
+            findNetworkPool(netId, function (err2, pools) {
+                if (err2) {
+                    if (!VError.hasCauseWithName(err2,
+                        'ResourceNotFoundError')) {
+                            callback(new VError(err,
+                                'Failed to find network pool "%s"', netId));
+                        return;
+                    }
+                    callback(new restify.UnprocessableEntityError('No such'
+                        + ' Network/Pool with id: "%s"',
+                        netId));
+                    return;
+                }
+
+                /*
+                 * Prior to NAPI-121, using a "name" filter for a network pool
+                 * would either be silently ignored (or rejected post NAPI-343).
+                 * In case we're talking to a NAPI that's ignored our parameter,
+                 * we filter the results to avoid using an incorrect pool.
+                 */
+                if (Array.isArray(pools)) {
+                    pools = pools.filter(function (pool) {
+                        return pool.name === netId;
+                    });
+                    if (pools.length === 0) {
+                        callback(new restify.UnprocessableEntityError(
+                            'No such Network or Pool with name: ' + netId));
+                    } else if (pools.length === 1) {
+                        filteredNetworks.pools.push(pools[0].uuid);
+                        filteredNetworks.netInfo.push(pools[0]);
+                        callback(null, pools[0].uuid);
+                    } else {
+                        callback(new restify.UnprocessableEntityError(
+                            'Multiple Network Pools with name: ' + netId));
+                    }
+                } else {
+                    filteredNetworks.pools.push(pools.uuid);
+                    filteredNetworks.netInfo.push(pools);
+                    callback(null, pools.uuid);
+                }
+            });
+        });
+    }
+
+    function lookupNetwork(network, cb) {
+        getNetworkInfo(network, function (err, uuid) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            network.ipv4_uuid = uuid;
+            delete network.name;
+            filteredNetworks.networks.push(network);
+            cb();
+        });
+    }
+
+    vasync.forEachPipeline({
+        func: lookupNetwork,
+        inputs: networks
+    }, function (err, results) {
+        if (err) {
+            next(err);
+            return;
+        }
+        req.log.info({filterdNetworks: filteredNetworks},
+            'filteredNetworks complete');
+
+        next();
+        return;
+    });
+}
+
+/*
+ * Used in the createVm path to assign a primary nic
+ * if the user did not already define one.
+ */
+function setPrimaryNic(req, res, next) {
+    var filteredNetworks = req.filteredNetworks;
+    assert.object(filteredNetworks, 'filteredNetworks');
+
+    var networks = filteredNetworks.networks;
+    assert.arrayOfObject(networks, 'networks');
+
+    // set the primary nic
+    var primaryFound = networks.some(function (net) {
+        return net.primary;
+    });
+
+    if (!primaryFound && networks.length > 0)
+        networks[0].primary = true;
+
+    next();
+}
+
+/*
+ * Its better to pre-provision NICs up front so that any issues
+ * can be reported back to the createVm caller before a workflow job is
+ * kicked off.
+ *
+ * - Keep track of all NICs created in case we hit an error and need to
+ *   cleanup.
+ * - Keep track of fabric NICs so we can properly backfill the NIC object
+ *   with important fields such as cn_uuid as a part of the workflow job.
+ * - Save network pool NICs for later creation as we need to get a
+ *   list of server NIC tags which happens today as a part of the
+ *   workflow. If and when server selection is moved out of workflow, we will
+ *   be able to handle network pools here as well.
+ */
+function preProvisionNics(req, cb) {
+    var napi = req.app.napi;
+    var inst_uuid = req.params.uuid;
+
+    var filteredNetworks = req.filteredNetworks;
+    var networks = filteredNetworks.networks;
+    var owner_uuid = req.params.owner_uuid || req.vm.owner_uuid;
+    var nics = filteredNetworks.nics;
+
+    // Filter out pool networks, which will be handled later in workflow
+    networks = networks.filter(function filterOutPoolNets(net) {
+        return (filteredNetworks.pools.indexOf(net.ipv4_uuid) === -1);
+    });
+
+    networks.forEach(function (net) {
+        // Make absolutely sure we're never overriding NAPI's network
+        // owner checks:
+        delete net.check_owner;
+    });
+
+    // Return a new copy for every time we provision a new NIC and avoid
+    // accidentally reusing an object
+    function nicParams() {
+        // Once server selection has been moved out of workflow we will be able
+        // to use the real cn_uuid here
+        var fakeUuid = '00000000-dead-beef-badd-cafe00000000';
+        return {
+            owner_uuid: owner_uuid,
+            belongs_to_uuid: inst_uuid,
+            belongs_to_type: 'zone',
+            state: 'provisioning',
+            cn_uuid: fakeUuid
+        };
+    }
+
+    var antiSpoofParams = [
+        'allow_dhcp_spoofing',
+        'allow_ip_spoofing',
+        'allow_mac_spoofing',
+        'allow_restricted_traffic'
+    ];
+
+    /*
+     * Get current list of NICs that might have been provisioned ahead of
+     * time. This is done in some places when an IP address needs to be
+     * known ahead of time. For example, Zookeeper instances in Manta have
+     * their NICs created before provisioning instances, so that they can be
+     * configured to know each other's addresses before booting.
+     */
+    napi.listNics({
+        owner_uuid: owner_uuid,
+        belongs_to_uuid: inst_uuid,
+        belongs_to_type: 'zone'
+    }, function asyncProvisionNics(err, currentNics) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        function createNic(network, done) {
+            // If there is at least one provisioned NIC in one of the
+            // networks provided, skip napi.provisionNic for this network
+            var netNics = currentNics.filter(function (nic) {
+                return (nic.network_uuid && nic.network_uuid ===
+                    network.ipv4_uuid);
+            });
+
+            if (netNics.length > 0) {
+                nics = nics.concat(netNics);
+                done();
+                return;
+            }
+
+            var params = nicParams();
+            if (network.ipv4_ips !== undefined)
+                params.ip = network.ipv4_ips[0];
+
+            if (network.primary !== undefined)
+                params.primary = network.primary;
+
+            antiSpoofParams.forEach(function (spoofParam) {
+                if (network.hasOwnProperty(spoofParam)) {
+                    params[spoofParam] = network[spoofParam];
+                }
+            });
+
+            napi.provisionNic(network.ipv4_uuid, params,
+                function (suberr, nic) {
+                if (suberr) {
+                    done(suberr);
+                } else {
+                    nics.push(nic);
+                    done();
+                }
+            });
+        }
+
+        vasync.forEachPipeline({
+            func: createNic,
+            inputs: networks
+        }, function (err2, results) {
+            if (err2) {
+                cb(err2);
+            } else {
+                req.log.info({ nics: req.filteredNetworks.nics },
+                    'NICs allocated');
+                cb();
+            }
+        });
+    });
+}
+
+// Cleanup nics provisioned by preProvisionNics
+function cleanupNics(req, cb) {
+    var napi = req.app.napi;
+    assert.ok(napi, 'napi');
+
+    assert.object(req.filteredNetworks);
+    var nics = req.filteredNetworks.nics;
+
+    // If we never provisioned any nics we should return early
+    if (nics.length === 0) {
+        cb();
+        return;
+    }
+
+    assert.arrayOfObject(nics, 'nics');
+
+    function deleteNic(nic, done) {
+        napi.deleteNic(nic.mac, function (napiErr) {
+            if (napiErr) {
+                req.log.error({ err: napiErr, nic: nic },
+                    'Error deleting pre-provisioned NIC %s', nic.mac);
+                done(napiErr);
+                return;
+            }
+            req.log.info({ nic: nic },
+                'successfully cleaned up pre-provisioned NIC %s', nic.mac);
+            done();
+        });
+    }
+
+    vasync.forEachParallel({
+        func: deleteNic,
+        inputs: nics
+    }, function (err, results) {
+        // We ignore all errors in this case and let the caller
+        // return the original error
+        cb();
+    });
+}
 
 
 /*
@@ -879,23 +1259,44 @@ function createVm(req, res, next) {
 
     var sync = req.params.sync;
 
-    common.validateCreateVmParams(req.app, req.params, function (err) {
+    vasync.pipeline({
+        arg: req,
+        funcs: [
+            validateCreateVmParams,
+            preProvisionNics
+        ]
+    }, function (err, results) {
         if (err) {
-            return next(err);
+            return cleanupNics(req, function nicCleanupAttempt() {
+                next(err);
+            });
         }
+        createProvisionJob();
+    });
 
-        common.setDefaultValues(req.params, {config: req.app.options});
 
-        if (sync && ['true', 'false'].indexOf(sync) === -1) {
-            var error = [ errors.invalidParamErr('sync') ];
-            return next(new errors.ValidationFailedError('Invalid Parameters',
-                error));
-        } else {
-            req.params.sync = (sync === 'true' ? true : false);
-        }
+    function validateCreateVmParams(_, done) {
+        common.validateCreateVmParams(req.app, req.params, function (err) {
+            if (err) {
+                return done(err);
+            }
+
+            common.setDefaultValues(req.params, {config: req.app.options});
+
+            if (sync && ['true', 'false'].indexOf(sync) === -1) {
+                var error = [ errors.invalidParamErr('sync') ];
+                return done(new errors.ValidationFailedError('Invalid' +
+                    ' Parameters',
+                    error));
+            } else {
+                req.params.sync = (sync === 'true' ? true : false);
+            }
+
+            done();
+        });
+    }
+
 
-        createProvisionJob();
-    });
 
     function createProvisionJob() {
         if (req.params.role_tags === undefined) {
@@ -1227,6 +1628,8 @@ function mount(server) {
 
     server.post({ path: '/vms', name: 'CreateVm' },
         interceptors.checkWfapi,
+        preFilterNetworks,
+        setPrimaryNic,
         createVm);
 
     server.get({ path: '/vms/:uuid/proc', name: 'GetVmProc' },
@@ -1251,6 +1654,7 @@ function mount(server) {
     server.post({ path: '/vms/:uuid', name: 'UpdateVm' },
         interceptors.checkWfapi,
         interceptors.loadVm,
+        preFilterNetworks,
         updateVm);
 
     server.put({ path: '/vms/:uuid', name: 'PutVm' },
diff --git a/lib/workflows/add-nics.js b/lib/workflows/add-nics.js
index d25f328..3254120 100644
--- a/lib/workflows/add-nics.js
+++ b/lib/workflows/add-nics.js
@@ -21,6 +21,8 @@
 
 var async;  // stub to keep jsl happy
 var common = require('./job-common');
+var fabricCommon = require('./fabric-common');
+
 var VERSION = '7.2.0';
 
 
@@ -80,12 +82,25 @@ var workflow = module.exports = {
         body: common.checkServerNicTags,
         modules: { sdcClients: 'sdc-clients', async: 'async' }
     }, {
-        name: 'napi.provision_nics',
+        name: 'napi.add_nics_by_mac',
         timeout: 20,
         retry: 1,
-        body: common.addNics,
+        body: common.addNicsByMac,
         modules: { sdcClients: 'sdc-clients', async: 'async' }
     }, {
+        name: 'napi.provision_nics',
+        timeout: 20,
+        retry: 1,
+        body: common.provisionNics,
+        modules: { sdcClients: 'sdc-clients', async: 'async' }
+    }
+
+    /**
+     * Fabric NAT provisioning
+     */
+    ].concat(
+        fabricCommon.provisionChain).concat([
+    {
         name: 'common.update_network_params',
         timeout: 10,
         retry: 1,
@@ -103,7 +118,13 @@ var workflow = module.exports = {
         retry: 1,
         body: common.waitOnVMTicket,
         modules: { sdcClients: 'sdc-clients' }
-    }, {
+    },
+    /*
+     * If we've provisioned fabric NAT zones for this VM, wait until
+     * they've finished before updating the VM.
+     */
+    fabricCommon.provisionWaitTask
+    ]).concat([ {
         name: 'cnapi.update_vm',
         timeout: 10,
         retry: 1,
@@ -139,7 +160,12 @@ var workflow = module.exports = {
         retry: 1,
         body: common.releaseVMTicket,
         modules: { sdcClients: 'sdc-clients' }
-    }],
+    },
+
+    // If this was a fabric nat provision, clean up the ticket
+    fabricCommon.releaseTicketTask
+
+    ]),
     timeout: 300,
     onerror: [ {
         name: 'napi.cleanup_nics',
@@ -147,32 +173,25 @@ var workflow = module.exports = {
         retry: 1,
         body: common.cleanupNics,
         modules: { sdcClients: 'sdc-clients', async: 'async' }
-    }, {
+    },
+    {
         name: 'on_error.release_vm_ticket',
         modules: { sdcClients: 'sdc-clients' },
+        body: common.releaseVMTicket
+    },
+    fabricCommon.releaseTicketTask,
+    {
+        name: 'On error',
         body: function (job, cb) {
-            var cnapi = new sdcClients.CNAPI({
-                url: cnapiUrl,
-                headers: { 'x-request-id': job.params['x-request-id'] }
-            });
-            cnapi.waitlistTicketRelease(job.ticket.uuid, function (err) {
-                cb('Error executing job');
-                return;
-            });
+            return cb('Error executing job');
         }
     }],
-    oncancel: [ {
+    oncancel: [
+    {
         name: 'on_cancel.release_vm_ticket',
         modules: { sdcClients: 'sdc-clients' },
-        body: function (job, cb) {
-            var cnapi = new sdcClients.CNAPI({
-                url: cnapiUrl,
-                headers: { 'x-request-id': job.params['x-request-id'] }
-            });
-            cnapi.waitlistTicketRelease(job.ticket.uuid, function (err) {
-                cb();
-                return;
-            });
-        }
-    } ]
+        body: common.releaseVMTicket
+    },
+        fabricCommon.releaseTicketTask
+    ]
 };
diff --git a/lib/workflows/job-common.js b/lib/workflows/job-common.js
index b5dd881..d7018fb 100644
--- a/lib/workflows/job-common.js
+++ b/lib/workflows/job-common.js
@@ -556,10 +556,12 @@ function postBack(job, cb) {
 
 
 /*
- * Gets a list of NIC tags after validating every network provided
+ * Finish the validation of networks previously done by getting a
+ * list of NIC tags.
  */
 function validateNetworks(job, cb) {
     var networks = job.params.networks;
+    var filteredNetworks = job.params.filteredNetworks;
 
     // add-nics also calls this function, but if macs are provided we don't
     // necessarily need to progress further
@@ -567,128 +569,24 @@ function validateNetworks(job, cb) {
         return cb();
     }
 
-    var newNetworks = [];
-    if (!networks) {
-        return cb('Networks are required');
-    }
-
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
     job.nicTagReqs = [];
 
-    function pushPoolTags(pool) {
-        if (pool.nic_tags_present) {
-            job.nicTagReqs.push(pool.nic_tags_present);
+    function pushTags(net) {
+        if (net.nic_tags_present) {
+            job.nicTagReqs.push(net.nic_tags_present);
         } else {
-            job.nicTagReqs.push([ pool.nic_tag ]);
+            job.nicTagReqs.push([ net.nic_tag ]);
         }
     }
 
-    // - Resolve network names to uuids when applicable
-    // - Repopulate job.params.networks
-    // - Returns cb(err, uuid). uuid is present when name was resolved to uuid
-    function getNetwork(netId, callback) {
-        /*JSSTYLED*/
-        var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-        var netFn, poolFn;
-        var params;
-
-        // Network can be either by name or uuid
-        if (UUID_RE.test(netId)) {
-            params = netId;
-            netFn = napi.getNetwork;
-            poolFn = napi.getNetworkPool;
-        } else {
-            params = { name: netId };
-            netFn = napi.listNetworks;
-            poolFn = napi.listNetworkPools;
-        }
-
-        netFn.call(napi, params, function (err, nets) {
-            // If network is not found then it might be a network pool
-            if (err && err.name !== 'ResourceNotFoundError') {
-                callback(err);
-                return;
-            }
-
-            // Did we get the network from list or get?
-            var net = (Array.isArray(nets) ? nets[0] : nets);
-
-            // No net if NAPI returns an empty array or if we got a 404
-            if (net) {
-                job.nicTagReqs.push([ net.nic_tag ]);
-                callback(null, net.uuid);
-                return;
-            }
-
-            // We might be trying to provision on a network pool, so
-            // try that instead
-            poolFn.call(napi, params, function (err2, pools) {
-                if (err2) {
-                    callback(err2);
-                    return;
-                }
-
-                /*
-                 * Prior to NAPI-121, using a "name" filter for a network pool
-                 * would either be silently ignored (or rejected post NAPI-343).
-                 * In case we're talking to a NAPI that's ignored our parameter,
-                 * we filter the results to avoid using an incorrect pool.
-                 */
-                if (Array.isArray(pools)) {
-                    pools = pools.filter(function (pool) {
-                        return pool.name === netId;
-                    });
-                    if (pools.length === 0) {
-                        callback(new Error(
-                            'No such Network Pool with name: ' + netId));
-                    } else if (pools.length === 1) {
-                        pushPoolTags(pools[0]);
-                        callback(null, pools[0].uuid);
-                    } else {
-                        callback(new Error(
-                            'Multiple Network Pools with name: ' + netId));
-                    }
-                } else {
-                    pushPoolTags(pools);
-                    callback(null, pools.uuid);
-                }
-            });
-        });
-    }
-
-    async.mapSeries(networks, function (network, next) {
-        var netId;
-        if (network.ipv4_uuid !== undefined) {
-            netId = network.ipv4_uuid;
-        } else if (network.name !== undefined) {
-            netId = network.name;
-        }
+    filteredNetworks.netInfo.forEach(function (net) {
+        pushTags(net);
+    });
 
-        getNetwork(netId, function (err, uuid) {
-            if (err) {
-                next(err);
-            } else {
-                network.uuid = uuid;
-                network.ipv4_uuid = uuid;
-                newNetworks.push(network);
-                next();
-            }
-        });
+    job.log.info({ nicTagReqs: job.nicTagReqs },
+        'NIC Tag requirements retrieved');
 
-    }, function (err2) {
-        if (err2) {
-            cb(err2);
-        } else {
-            job.params.networks = newNetworks;
-            job.log.info({ nicTagReqs: job.nicTagReqs },
-                'NIC Tag requirements retrieved');
-            cb(null, 'Networks are valid');
-        }
-    });
+    cb(null, 'NIC Tag requirements retrieved');
 }
 
 
@@ -853,35 +751,45 @@ function checkServerNicTags(job, cb) {
  * don't provision any new NICs.
  */
 function provisionNics(job, cb) {
+    var macs = job.params.macs;
+
+    if (macs) {
+        cb(null, 'AddNics called with macs -- skipping');
+        return;
+    }
     var inst_uuid = job.params.uuid || job.params.vm_uuid;
     var owner_uuid = job.params.owner_uuid;
 
-    var networks = job.params.networks;
-    if (networks === undefined) {
-        cb('Networks are required');
+    var filteredNetworks = job.params.filteredNetworks;
+    if (filteredNetworks === undefined) {
+        cb('Networks should be populated already');
         return;
     }
 
+    var networks = filteredNetworks.networks;
+    networks.forEach(function (net) {
+        // Make absolutely sure we're never overriding NAPI's network
+        // owner checks:
+        delete net.check_owner;
+    });
+
+    var poolNetworks = filteredNetworks.networks.filter(function
+        filterOutPoolNets(net) {
+        if (filteredNetworks.pools.indexOf(net.ipv4_uuid) >= 0) {
+            return true;
+        }
+        return false;
+    });
+
     var napi = new sdcClients.NAPI({
         url: napiUrl,
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
 
-    // Every NIC we provision is added to this array
-    var nics = [];
-    var primaryFound = false;
+    // Every NIC we provision or updated is added to this array
+    var nics = filteredNetworks.nics.slice();
     job.params.fabricNatNics = [];
 
-    networks.forEach(function (net) {
-        if (net.primary)
-            primaryFound = true;
-        // Make absolutely sure we're never overriding NAPI's network
-        // owner checks:
-        delete net.check_owner;
-    });
-
-    if (!primaryFound && networks.length > 0)
-        networks[0].primary = true;
 
     // Return a new copy for every time we provision a new NIC and avoid
     // accidentally reusing an object
@@ -890,6 +798,7 @@ function provisionNics(job, cb) {
             owner_uuid: owner_uuid,
             belongs_to_uuid: inst_uuid,
             belongs_to_type: 'zone',
+            state: 'provisioning',
             nic_tags_available: job.serverNicTags,
             cn_uuid: job.params.server_uuid
         };
@@ -911,69 +820,66 @@ function provisionNics(job, cb) {
         'allow_restricted_traffic'
     ];
 
-    /*
-     * Get current list of NICs that might have been provisioned ahead of time.
-     * This is done in some places when an IP address needs to be known ahead
-     * of time. For example, Zookeeper instances in Manta have their NICs
-     * created before provisioning instances, so that they can be configured
-     * to know each other's addresses before booting.
-     */
-    napi.listNics({
-        owner_uuid: owner_uuid,
-        belongs_to_uuid: inst_uuid,
-        belongs_to_type: 'zone'
-    }, function asyncProvisionNics(err, currentNics) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        async.mapSeries(networks, function (network, next) {
-            // If there is at least one provisioned NIC in one of the networks
-            // provided, skip napi.provisionNic for this network
-            var netNics = currentNics.filter(function (nic) {
-                return (nic.network_uuid && nic.network_uuid ===
-                    network.ipv4_uuid);
-            });
-
-            if (netNics.length > 0) {
-                nics = nics.concat(netNics);
-                next();
-                return;
-            }
+    job.params.nics = nics;
 
-            var params = nicParams();
-            if (network.ipv4_ips !== undefined)
-                params.ip = network.ipv4_ips[0];
-            if (network.primary !== undefined)
-                params.primary = network.primary;
+    async.series([
+        function provisionPoolNicss(callback) {
+            async.mapSeries(poolNetworks, function (network, next) {
+                var params = nicParams();
+                if (network.ipv4_ips !== undefined)
+                    params.ip = network.ipv4_ips[0];
+                if (network.primary !== undefined)
+                    params.primary = network.primary;
 
-            antiSpoofParams.forEach(function (spoofParam) {
-                if (network.hasOwnProperty(spoofParam)) {
-                    params[spoofParam] = network[spoofParam];
-                }
-            });
+                antiSpoofParams.forEach(function (spoofParam) {
+                    if (network.hasOwnProperty(spoofParam)) {
+                        params[spoofParam] = network[spoofParam];
+                    }
+                });
 
-            napi.provisionNic(network.ipv4_uuid, params,
-                function (suberr, nic) {
-                if (suberr) {
-                    next(suberr);
-                } else {
-                    nics.push(nic);
-                    addFabricNatNic(nic);
-                    next();
-                }
-            });
-        }, function (err2) {
-            if (err2) {
-                cb(err2);
-            } else {
-                job.params.nics = nics;
-                job.log.info({ nics: job.params.nics }, 'NICs allocated');
+                napi.provisionNic(network.ipv4_uuid, params,
+                    function (suberr, nic) {
+                    if (suberr) {
+                        next(suberr);
+                    } else {
+                        nics.push(nic);
+                        // pools may contain fabric networks someday
+                        addFabricNatNic(nic);
+                        next();
+                    }
+                });
+            }, callback);
+        },
+        function updateExistingNics(callback) {
+            // Update existing nics
+            async.mapSeries(filteredNetworks.nics, function (nic, next) {
+                var params = nicParams();
+
+                napi.updateNic(nic.mac, params,
+                    function (suberr, updatedNic) {
+                    if (suberr) {
+                        next(suberr);
+                    } else {
+                        addFabricNatNic(updatedNic);
+                        next();
+                    }
+                });
+            }, callback);
+        }
+    ], function (err, results) {
+        if (err) {
+            cb(err);
+        } else {
+            job.log.info({ nics: job.params.nics }, 'NICs allocated');
 
-                cb(null, 'NICs allocated');
+            // If we hit this due to add_nics setup params so that we call
+            // common.update_network_params properly
+            if (job.task === 'add_nics') {
+                job.params['add_nics'] = nics;
             }
-        });
+
+            cb(null, 'NICs allocated and updated');
+        }
     });
 
 }
@@ -987,15 +893,32 @@ function provisionNics(job, cb) {
  * The networks list can contain a not null ip attribute on each object, which
  * denotes that we want to allocate that given IP for the correspondent network.
  */
-function addNics(job, cb) {
-    var networks = job.params.networks;
+function addNicsByMac(job, cb) {
+    var filteredNetworks = job.params.filteredNetworks;
+    var networks = filteredNetworks.networks;
     var macs     = job.params.macs;
 
+    job.params.fabricNatNics = [];
+
+    // If this is a nic on a fabric, has no gateway provisioned, and the network
+    // requests an internet NAT, add it
+    function addFabricNatNic(fNic) {
+        if (fNic && fNic.fabric && fNic.gateway && !fNic.gateway_provisioned &&
+                fNic.ip !== fNic.gateway && fNic.internet_nat) {
+            job.params.fabricNatNics.push(fNic);
+        }
+    }
+
     if (networks === undefined && macs === undefined) {
         cb('Networks or mac are required');
         return;
     }
 
+    if (!macs) {
+        cb(null, 'AddNics not called with macs -- skipping');
+        return;
+    }
+
     var napi = new sdcClients.NAPI({
         url: napiUrl,
         headers: { 'x-request-id': job.params['x-request-id'] }
@@ -1013,52 +936,17 @@ function addNics(job, cb) {
             cb(null, 'NICs looked up or allocated');
         }
     }
-
-    if (macs) {
-        async.mapSeries(macs, function (mac, next) {
-            napi.getNic(mac, function (err, nic) {
-                if (err) {
-                    return next(err);
-                }
-
-                nics.push(nic);
-                next();
-            });
-        }, done);
-    } else {
-        async.mapSeries(networks, function (network, next) {
-            var params = {
-                owner_uuid: job.params.owner_uuid,
-                belongs_to_uuid: job.params.uuid || job.params.vm_uuid,
-                belongs_to_type: 'zone',
-                cn_uuid: job.params.server_uuid,
-                state: 'provisioning'
-            };
-
-            var antiSpoofParams = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
-                'allow_mac_spoofing', 'allow_restricted_traffic'];
-            if (network.ip !== undefined) {
-                params.ip = network.ip;
-            } else if (network.primary !== undefined) {
-                params.primary = network.primary;
+    async.mapSeries(macs, function (mac, next) {
+        napi.getNic(mac, function (err, nic) {
+            if (err) {
+                return next(err);
             }
 
-            antiSpoofParams.forEach(function (spoofParam) {
-                if (network.hasOwnProperty(spoofParam)) {
-                    params[spoofParam] = network[spoofParam];
-                }
-            });
-
-            napi.provisionNic(network.uuid, params, function (err, nic) {
-                if (err) {
-                    next(err);
-                } else {
-                    nics.push(nic);
-                    next();
-                }
-            });
-        }, done);
-    }
+            nics.push(nic);
+            addFabricNatNic(nic);
+            next();
+        });
+    }, done);
 }
 
 
@@ -1589,7 +1477,7 @@ module.exports = {
     getServerNicTags: getServerNicTags,
     checkServerNicTags: checkServerNicTags,
     provisionNics: provisionNics,
-    addNics: addNics,
+    addNicsByMac: addNicsByMac,
     cleanupNics: cleanupNics,
     validateNetworks: validateNetworks,
     updateNetworkParams: updateNetworkParams,
diff --git a/server.js b/server.js
index 5c2e567..d5baf41 100644
--- a/server.js
+++ b/server.js
@@ -26,9 +26,9 @@ var sigyan = require('sigyan');
 var util = require('util');
 var vasync = require('vasync');
 
+var sdc = require('sdc-clients');
 var CNAPI = require('./lib/apis/cnapi');
 var IMGAPI = require('./lib/apis/imgapi');
-var NAPI = require('./lib/apis/napi');
 var PAPI = require('./lib/apis/papi');
 var VmapiApp = require('./lib/vmapi');
 var WFAPI = require('./lib/apis/wfapi');
@@ -96,10 +96,12 @@ function createApiClients(config, parentLog) {
     var imgapiClient = new IMGAPI(imgapiClientOpts);
 
     assert.object(config.napi, 'config.napi');
-    var napiClientOpts = jsprim.deepCopy(config.napi);
-    napiClientOpts.log = parentLog.child({ component: 'napi' }, true);
-    napiClientOpts.agent = agent;
-    var napiClient = new NAPI(napiClientOpts);
+    var napiLog = parentLog.child({ component: 'napi' }, true);
+    var napiClient = new sdc.NAPI({
+        log: napiLog,
+        url: config.napi.url,
+        agent: agent
+    });
 
     assert.object(config.papi, 'config.papi');
     var papiClientOpts = jsprim.deepCopy(config.papi);
diff --git a/test/vms.changefeed.test.js b/test/vms.changefeed.test.js
index d03aa44..dbf688c 100644
--- a/test/vms.changefeed.test.js
+++ b/test/vms.changefeed.test.js
@@ -639,115 +639,3 @@ exports.put_new_vms = function (t) {
     });
 
 };
-
-/*
- * This test is a regression test for https://smartos.org/bugview/ZAPI-770. It
- * purposely provisions a VM on a non-existent network so that the provisioning
- * workflow fails. It then tests that at least one changefeed event is emitted
- * and that after this event was emitted the newly created VM's state is
- * 'failed'. Before the fix for https://smartos.org/bugview/ZAPI-770, no
- * changefeed event would be emitted for this VM.
- *
- * Unfortunately this test relies on the implementation detail that sending a
- * request to VMAPI's CreateVm endpoint with a non-existent network creates a
- * workflow and doesn't error right away. As a result, this test might not work
- * as expected in the future, and might not prevent further regressions.
- */
-exports.create_vm_that_fails_provisioning_workflow = function (t) {
-
-    var listener = changefeed.createListener(listenerOpts);
-    var nonExistentNetworkUuid = uuid.create();
-    var testDone = false;
-    var vmParams = {
-        alias: 'sdcvmapitest_vm_that_fails_provisioning_workflow',
-        owner_uuid: CUSTOMER,
-        image_uuid: IMAGE,
-        server_uuid: SERVER.uuid,
-        networks: [ { uuid: nonExistentNetworkUuid } ],
-        brand: 'joyent-minimal',
-        billing_id: '00000000-0000-0000-0000-000000000000',
-        ram: 64,
-        quota: 10,
-        creator_uuid: CUSTOMER
-    };
-    var vmLocation;
-
-    var vmCreationOpts = createOpts('/vms', vmParams);
-
-    VM = null;
-
-    listener.register();
-
-    listener.on('bootstrap', onCfBootstrap);
-    listener.on('readable', onCfListenerReadable);
-
-    function onCfBootstrap() {
-        client.post(vmCreationOpts, vmParams,
-            function onVmCreated(vmCreateErr, req, res, vmCreationObj) {
-                common.ifError(t, vmCreateErr);
-
-                t.equal(res.statusCode, 202, '202 Accepted');
-                common.checkHeaders(t, res.headers);
-
-                t.ok(vmCreationObj, 'vm ok');
-
-                vmLocation = '/vms/' + vmCreationObj.vm_uuid;
-
-                // GetVm should not fail after provision has been queued
-                client.get(vmLocation,
-                    function onGetVm(vmGetErr, vmGetReq, vmGetRes, vm) {
-                        if (testDone) {
-                            return;
-                        }
-
-                        common.ifError(t, vmGetErr);
-                        t.equal(vmGetRes.statusCode, 200, '200 OK');
-                        common.checkHeaders(t, vmGetRes.headers);
-                        t.ok(vm, 'provisioning vm ok');
-                        VM = vm;
-                    });
-            });
-    }
-
-    function onCfListenerReadable() {
-        var changeItem;
-        var changeKind;
-        var expectedStates = ['provisioning', 'failed'];
-
-        while ((changeItem = listener.read()) !== null) {
-            changeKind = changeItem.changeKind;
-            if (VM && changeItem.changedResourceId === VM.uuid &&
-                changeKind.subResources &&
-                changeKind.subResources.indexOf('state') !== -1) {
-                t.ok(true, 'state received');
-
-                client.get(vmLocation,
-                    function onGetVm(vmGetErr, vmGetReq, vmGetRes, vm) {
-                        if (testDone) {
-                            return;
-                        }
-
-                        common.ifError(t, vmGetErr);
-                        t.equal(vmGetRes.statusCode, 200, '200 OK');
-                        common.checkHeaders(t, vmGetRes.headers);
-
-                        t.ok(vm, 'provisioning vm ok');
-                        t.ok(expectedStates.indexOf(vm.state) !== -1,
-                            'VM is in one of the following states: ' +
-                                expectedStates.join(', '));
-                        if (vm.state === 'failed') {
-                            t.ok(true, 'VM eventually reached state failed');
-                            listener._endSocket();
-
-                            testDone = true;
-                            listener.removeListener('readable',
-                                onCfListenerReadable);
-                            listener.removeListener('bootStrap', onCfBootstrap);
-
-                            t.done();
-                        }
-                    });
-            }
-        }
-    }
-};
diff --git a/test/vms.full.test.js b/test/vms.full.test.js
index e925bad..b237f3f 100644
--- a/test/vms.full.test.js
+++ b/test/vms.full.test.js
@@ -14,6 +14,7 @@ var uuid = require('libuuid');
 var qs = require('querystring');
 var async = require('async');
 var util = require('util');
+var jsprim = require('jsprim');
 
 var common = require('./common');
 var testUuid = require('./lib/uuid');
@@ -32,6 +33,8 @@ var pkgId;
 var IMAGE = 'fd2cc906-8938-11e3-beab-4359c665ac99';
 var CUSTOMER = common.config.ufdsAdminUuid;
 var NETWORKS = null;
+var FAKE_NETWORK_UUID = 'caaaf10c-a587-49c6-9cf6-9b0a14ba960b';
+var FAKE_NETWORK_NAME = 'fakeNetworkName';
 var SERVER = null;
 var CALLER = {
     type: 'signature',
@@ -578,6 +581,68 @@ exports.create_vm_tags_not_ok = function (t) {
 };
 
 
+exports.create_vm_with_unknown_network = function (t) {
+    var vm = {
+        owner_uuid: CUSTOMER,
+        image_uuid: IMAGE,
+        server_uuid: SERVER.uuid,
+        networks: [ { uuid: FAKE_NETWORK_UUID } ],
+        brand: 'joyent-minimal',
+        billing_id: '00000000-0000-0000-0000-000000000000',
+        ram: 64,
+        quota: 10,
+        creator_uuid: CUSTOMER,
+        origin: 'cloudapi'
+    };
+
+    var opts = createOpts('/vms', vm);
+
+    client.post(opts, vm, function (err, req, res, body) {
+        t.ok(err, 'error set');
+        t.equal(err.restCode, 'UnprocessableEntityError', 'err.restCode');
+        t.equal(res.statusCode, 422, '422 UnprocessableEntityError');
+
+        t.deepEqual(body, {
+            code: 'UnprocessableEntityError',
+            message: 'No such Network/Pool with id: "' + FAKE_NETWORK_UUID + '"'
+        });
+
+        t.done();
+    });
+};
+
+
+exports.create_vm_with_unknown_network_name = function (t) {
+    var vm = {
+        owner_uuid: CUSTOMER,
+        image_uuid: IMAGE,
+        server_uuid: SERVER.uuid,
+        networks: [ { name: FAKE_NETWORK_NAME } ],
+        brand: 'joyent-minimal',
+        billing_id: '00000000-0000-0000-0000-000000000000',
+        ram: 64,
+        quota: 10,
+        creator_uuid: CUSTOMER,
+        origin: 'cloudapi'
+    };
+
+    var opts = createOpts('/vms', vm);
+
+    client.post(opts, vm, function (err, req, res, body) {
+        t.ok(err, 'error set');
+        t.equal(err.restCode, 'UnprocessableEntityError', 'err.restCode');
+        t.equal(res.statusCode, 422, '422 UnprocessableEntityError');
+
+        t.deepEqual(body, {
+            code: 'UnprocessableEntityError',
+            message: 'No such Network or Pool with name: ' + FAKE_NETWORK_NAME
+        });
+
+        t.done();
+    });
+};
+
+
 exports.create_vm = function (t) {
     var md = {
         foo: 'bar',
@@ -811,6 +876,133 @@ exports.undefined_vm_action = function (t) {
 };
 
 
+exports.add_nics_with_unknown_network = function (t) {
+    var params = {
+        action: 'add_nics',
+        networks: [ { uuid: FAKE_NETWORK_UUID } ]
+    };
+
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        t.ok(err, 'error set');
+        t.equal(err.restCode, 'UnprocessableEntityError', 'err.restCode');
+        t.equal(res.statusCode, 422, '422 UnprocessableEntityError');
+
+        t.deepEqual(body, {
+            code: 'UnprocessableEntityError',
+            message: 'No such Network/Pool with id: "' + FAKE_NETWORK_UUID + '"'
+        });
+
+        t.done();
+    });
+};
+
+
+exports.add_nics_with_unknown_network_name = function (t) {
+    var params = {
+        action: 'add_nics',
+        networks: [ { name: FAKE_NETWORK_NAME } ]
+    };
+
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        t.ok(err, 'error set');
+        t.equal(err.restCode, 'UnprocessableEntityError', 'err.restCode');
+        t.equal(res.statusCode, 422, '422 UnprocessableEntityError');
+
+        t.deepEqual(body, {
+            code: 'UnprocessableEntityError',
+            message: 'No such Network or Pool with name: ' + FAKE_NETWORK_NAME
+        });
+
+        t.done();
+    });
+};
+
+
+exports.create_vm_with_already_provisioned_ip = function (t) {
+    var zoneUuid;
+    var ips;
+
+    client.get(vmLocation, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 200, '200 OK');
+        common.checkHeaders(t, res.headers);
+        t.ok(body, 'got provisioned vm');
+
+        // This is depending on NETWORKS[0] being the admin network
+        ips = body.nics.filter(function (nic) {
+            return nic.nic_tag === NETWORKS[0].nic_tag;
+        }).map(function (nic) {
+            return nic.ip;
+        });
+        t.ok(ips[0], 'found ip on the admin network');
+
+        zoneUuid = body.uuid;
+
+        var vm = {
+            alias: 'vmapitest-full-' + testUuid.generateShortUuid(),
+            owner_uuid: CUSTOMER,
+            image_uuid: IMAGE,
+            server_uuid: SERVER.uuid,
+            brand: 'joyent-minimal',
+            billing_id: '00000000-0000-0000-0000-000000000000',
+            ram: 64,
+            quota: 10,
+            creator_uuid: CUSTOMER,
+            origin: 'cloudapi',
+            role_tags: ['fd48177c-d7c3-11e3-9330-28cfe91a33c9']
+        };
+
+        vm.networks = [
+            {
+                ipv4_uuid: NETWORKS[0].uuid,
+                ipv4_ips: [ ips[0] ]
+            }
+        ];
+
+        var opts = createOpts('/vms', vm);
+
+        client.post(opts, vm, function (err2, req2, res2, body2) {
+            t.ok(err2, 'error set');
+            t.equal(err2.restCode, 'InvalidParameters', 'err.restCode');
+            t.equal(res2.statusCode, 422, '409 InvalidParametersError');
+
+            /*
+             * Since this test is relying on an error from napi we are going
+             * to delete the message associated with the error to not trip
+             * up the test when a change in napi gets made.
+             * For example: NAPI-438
+             *
+             * Also we check for the presence of an errors array first so we are
+             * careful not to crash the entire test suite.
+             */
+            var modifiedBody = jsprim.deepCopy(body2);
+            if (modifiedBody.errors) {
+                modifiedBody.errors.forEach(function deleteMessage(error) {
+                    delete error.message;
+                });
+            }
+
+            t.deepEqual(modifiedBody, {
+                code: 'InvalidParameters',
+                message: 'Invalid parameters',
+                errors: [ {
+                    type: 'zone',
+                    id: zoneUuid,
+                    code: 'UsedBy',
+                    field: 'ip'
+                } ]
+            }, 'expected error matches');
+
+            t.done();
+        });
+    });
+};
+
+
 exports.add_nics_with_networks = function (t) {
     var params = {
         action: 'add_nics',
