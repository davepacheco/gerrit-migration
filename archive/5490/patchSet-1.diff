From 0a47ed44230781dcc3207fc8d88eb8db5409b922 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 5 Feb 2019 17:16:59 -0800
Subject: [PATCH] MANTA-4106 want tool for parsing ZK txn logs

---
 Makefile    |  17 ++
 src/zklog.c | 567 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 584 insertions(+)
 create mode 100644 src/zklog.c

diff --git a/Makefile b/Makefile
index 3b204f0..1f7613e 100644
--- a/Makefile
+++ b/Makefile
@@ -125,6 +125,20 @@ $(SMF_ADJUST_OBJDIR)/%.o: src/%.c
 	@mkdir -p $(@D)
 	gcc -o $@ -c $(SMF_ADJUST_CFLAGS) $<
 
+ZKLOG_OBJS =		zklog.o
+ZKLOG_LIBS =
+ZKLOG_CFLAGS =		-gdwarf-2 -m32 -Wall -Wextra -Werror -O2
+ZKLOG_OBJDIR =		tmp/zklog.obj
+CLEAN_FILES +=		tmp/zklog.obj zklog
+
+zklog: $(ZKLOG_OBJS:%=$(ZKLOG_OBJDIR)/%) | $(STAMP_CTF)
+	gcc -o $@ $^ $(ZKLOG_CFLAGS) $(ZKLOG_LIBS)
+	$(CTFCONVERT) -l $@ $@
+
+$(ZKLOG_OBJDIR)/%.o: src/%.c
+	@mkdir -p $(@D)
+	gcc -o $@ -c $(ZKLOG_CFLAGS) $<
+
 .PHONY: test
 test: $(NODE_EXEC) all
 	$(NODEUNIT) test/*.test.js 2>&1 | $(BUNYAN)
@@ -154,6 +168,9 @@ release: all $(SMF_MANIFESTS) balancer smf_adjust
 	    $(ROOT)/test \
 	    $(ROOT)/bin \
 	    $(RELSTAGEDIR)/root/opt/smartdc/binder
+	cp \
+	    $(ROOT)/zklog \
+	    $(RELSTAGEDIR)/root/opt/smartdc/binder/bin/
 	cp \
 	    $(ROOT)/balancer \
 	    $(ROOT)/smf_adjust \
diff --git a/src/zklog.c b/src/zklog.c
new file mode 100644
index 0000000..cbbbd0d
--- /dev/null
+++ b/src/zklog.c
@@ -0,0 +1,567 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <endian.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/time.h>
+#include <errno.h>
+
+const uint32_t ZKLOG_MAGIC = 0x5A4B4C47;
+const uint8_t ZKTXN_TERMINATOR = 0x42;
+
+static int dumpdata = 0;
+
+enum zktxn_type {
+	ZK_NOTIFICATION = 0,
+	ZK_CREATE = 1,
+	ZK_DELETE = 2,
+	ZK_EXISTS = 3,
+	ZK_GETDATA = 4,
+	ZK_SETDATA = 5,
+	ZK_GETACL = 6,
+	ZK_SETACL = 7,
+	ZK_GETCHILDREN = 8,
+	ZK_SYNC = 9,
+	ZK_CHECK = 13,
+	ZK_MULTI = 14,
+	ZK_CREATESESSION = -10,
+	ZK_CLOSESESSION = -11,
+	ZK_ERROR = -1
+};
+
+enum zkerr {
+	ERR_SYSTEM_ERROR = -1,
+	ERR_RUNTIME_INCONSIST = -2,
+	ERR_DATA_INCONSIST = -3,
+	ERR_CONNECTION_LOSS = -4,
+	ERR_UNIMPL = -6,
+	ERR_TIMEOUT = -7,
+	ERR_BAD_ARGS = -8,
+	ERR_NO_NODE = -101,
+	ERR_NODE_EXISTS = -110,
+	ERR_SESSION_EXPIRED = -112,
+	ERR_NOT_EMPTY = -111,
+};
+
+const char *
+zktxn_type_to_name(enum zktxn_type type)
+{
+	switch (type) {
+	case ZK_NOTIFICATION:
+		return ("NOTIFICATION");
+	case ZK_CREATE:
+		return ("CREATE");
+	case ZK_DELETE:
+		return ("DELETE");
+	case ZK_CHECK:
+		return ("CHECK");
+	case ZK_EXISTS:
+		return ("EXISTS");
+	case ZK_GETDATA:
+		return ("GETDATA");
+	case ZK_SETDATA:
+		return ("SETDATA");
+	case ZK_GETACL:
+		return ("GETACL");
+	case ZK_SETACL:
+		return ("SETACL");
+	case ZK_GETCHILDREN:
+		return ("GETCHILDREN");
+	case ZK_SYNC:
+		return ("SYNC");
+	case ZK_CREATESESSION:
+		return ("CREATESESSION");
+	case ZK_CLOSESESSION:
+		return ("CLOSESESSION");
+	case ZK_MULTI:
+		return ("MULTI");
+	case ZK_ERROR:
+		return ("ERROR");
+	default:
+		return ("???");
+	}
+}
+
+const char *
+zkerr_to_name(enum zkerr err)
+{
+	switch (err) {
+	case ERR_SYSTEM_ERROR:
+		return ("SYSTEM_ERROR");
+	case ERR_RUNTIME_INCONSIST:
+		return ("RUNTIME_INCONSIST");
+	case ERR_DATA_INCONSIST:
+		return ("DATA_INCONSIST");
+	case ERR_CONNECTION_LOSS:
+		return ("CONNECTION_LOSS");
+	case ERR_UNIMPL:
+		return ("UNIMPL");
+	case ERR_TIMEOUT:
+		return ("TIMEOUT");
+	case ERR_BAD_ARGS:
+		return ("BAD_ARGS");
+	case ERR_NO_NODE:
+		return ("NO_NODE");
+	case ERR_NODE_EXISTS:
+		return ("NODE_EXISTS");
+	case ERR_SESSION_EXPIRED:
+		return ("SESSION_EXPIRED");
+	case ERR_NOT_EMPTY:
+		return ("NOT_EMPTY");
+	default:
+		return ("???");
+	}
+}
+
+struct zktxn_err {
+	uint32_t ze_err;
+} __attribute__((packed));
+
+struct zktxn_createsess {
+	uint32_t zcs_timeout;
+} __attribute__((packed));
+
+struct zktxn_multitxn {
+	uint32_t zmt_type;
+	uint32_t zmt_len;
+	union {
+		struct zktxn_err zti_err;
+		struct zktxn_createsess zti_createsess;
+	} zmt_inner;
+} __attribute__((packed));
+
+struct zktxn_multi {
+	uint32_t zm_ntxns;
+	struct zktxn_multitxn zm_txns[1];
+} __attribute__((packed));
+
+struct zk_string {
+	uint32_t zs_len;
+	char zs_str[1];
+} __attribute__((packed));
+
+struct zktxn {
+	uint64_t zt_checksum;
+	uint32_t zt_len;
+	uint64_t zt_sessionid;
+	uint32_t zt_cxid;
+	uint64_t zt_zxid;
+	uint64_t zt_time;
+	uint32_t zt_type;
+	union {
+		struct zktxn_err zti_err;
+		struct zktxn_createsess zti_createsess;
+		struct zktxn_multi zti_multi;
+	} zt_inner;
+} __attribute__((packed));
+
+struct zklog {
+	uint32_t zl_magic;
+	uint32_t zl_version;
+	uint64_t zl_dbid;
+	struct zktxn zl_txns[1];
+} __attribute__((packed));
+
+static void
+print_inner(struct zktxn *txn, const char *timebuf, enum zktxn_type type,
+    void *inner, size_t len)
+{
+	if (type == ZK_ERROR) {
+		if (len < sizeof (struct zktxn_err)) {
+			fprintf(stderr, "error: txn too short for ZK_ERROR\n");
+			exit(3);
+		}
+		struct zktxn_err *err = (struct zktxn_err *)inner;
+		err->ze_err = be32toh(err->ze_err);
+		printf(",\"error\":\"%s\",\"errid\":%d",
+		    zkerr_to_name((int32_t)err->ze_err),
+		    (int32_t)err->ze_err);
+
+	} else if (type == ZK_CREATESESSION) {
+		if (len < sizeof (struct zktxn_createsess)) {
+			fprintf(stderr, "error: txn too short for "
+			    "ZK_CREATESESSION\n");
+			exit(3);
+		}
+		struct zktxn_createsess *cs = (struct zktxn_createsess *)inner;
+		cs->zcs_timeout = be32toh(cs->zcs_timeout);
+		printf(",\"timeout\":\"%d\"", (int32_t)cs->zcs_timeout);
+
+	} else if (type == ZK_CREATE || type == ZK_SETDATA ||
+	    type == ZK_DELETE || type == ZK_CHECK || type == ZK_SETACL) {
+		size_t offset = 0;
+		struct zk_string *name = (struct zk_string *)(inner + offset);
+		offset += sizeof (struct zk_string);
+		if (offset > len) {
+			fprintf(stderr, "error: txn too short for %s\n",
+			    zktxn_type_to_name(type));
+			exit(3);
+		}
+		name->zs_len = be32toh(name->zs_len);
+		offset += name->zs_len - 1;
+		if (offset > len) {
+			fprintf(stderr, "error: txn too short for %s\n",
+			    zktxn_type_to_name(type));
+			exit(3);
+		}
+		char *namestr = strndup(name->zs_str, name->zs_len);
+		printf(",\"path\":\"%s\"", namestr);
+		free(namestr);
+
+		if (!dumpdata)
+			return;
+
+		struct zk_string *data = (struct zk_string *)(inner + offset);
+		offset += sizeof (struct zk_string);
+		if (offset > len) {
+			fprintf(stderr, "error: txn too short for %s\n",
+			    zktxn_type_to_name(type));
+			exit(3);
+		}
+		data->zs_len = be32toh(data->zs_len);
+		offset += data->zs_len - 1;
+		if (offset > len) {
+			fprintf(stderr, "error: txn too short for %s\n",
+			    zktxn_type_to_name(type));
+			exit(3);
+		}
+		uint i;
+		printf(",\"data\":\"");
+		for (i = 0; i < data->zs_len; ++i)
+			printf("%02x", data->zs_str[i]);
+		printf("\"");
+
+	} else if (type == ZK_MULTI) {
+		size_t offset = 0;
+		uint i;
+		if (len < sizeof (struct zktxn_multi)) {
+			fprintf(stderr, "error: txn too short for "
+			    "ZK_MULTI\n");
+			exit(3);
+		}
+		struct zktxn_multi *m = &txn->zt_inner.zti_multi;
+		m->zm_ntxns = be32toh(m->zm_ntxns);
+		printf(",\"count\":%d}\n", m->zm_ntxns);
+
+		offset += offsetof(struct zktxn_multi, zm_txns);
+		for (i = 0; i < m->zm_ntxns; ++i) {
+			struct zktxn_multitxn *mt =
+			    (struct zktxn_multitxn *)(inner + offset);
+			mt->zmt_type = be32toh(mt->zmt_type);
+			mt->zmt_len = be32toh(mt->zmt_len);
+			offset += offsetof(struct zktxn_multitxn,
+			    zmt_inner) + mt->zmt_len;
+			if (offset > len) {
+				fprintf(stderr, "error: txn too short for "
+				    "ZK_MULTI (in child %d)\n", i);
+				exit(3);
+			}
+
+			printf("{\"time\":\"%s\",\"type\":\"%s\",\"typeid\":%d,"
+			    "\"sessionid\":\"%llx\","
+			    "\"cxid\":\"%x\",\"zxid\":\"%llx\"",
+			    timebuf, zktxn_type_to_name((int32_t)mt->zmt_type),
+			    (int32_t)mt->zmt_type, txn->zt_sessionid,
+			    txn->zt_cxid, txn->zt_zxid);
+
+			print_inner(txn, timebuf, (int32_t)mt->zmt_type,
+			    &mt->zmt_inner, mt->zmt_len);
+
+			if (i + 1 < m->zm_ntxns)
+				printf("}\n");
+		}
+	}
+}
+
+struct session_state {
+	struct session_state *ss_next;
+	struct session_state *ss_prev;
+	uint64_t ss_sid;
+	uint64_t ss_start;
+};
+struct session_state *sessions[256] = { NULL };
+
+static time_t mintime = 0;
+static uint64_t sid = 0;
+static uint8_t srvid = 0;
+
+static void
+do_file(const char *fname)
+{
+	int fd;
+	uint8_t *data;
+	struct zklog *log;
+	struct zktxn *txn;
+	struct stat stat;
+	size_t len;
+	size_t offset;
+	char timebuf[64];
+	time_t t, tms;
+	struct tm *tm;
+	struct session_state *sess, **head;
+	uint64_t duration;
+
+	fd = open(fname, O_RDONLY);
+	if (fd < 0) {
+		fprintf(stderr, "error: open(%s): %s\n", fname,
+		    strerror(errno));
+		exit(2);
+	}
+
+	if (fstat(fd, &stat)) {
+		fprintf(stderr, "error: fstat(%s): %s\n", fname,
+		    strerror(errno));
+		exit(2);
+	}
+
+	len = stat.st_size;
+	if (len < sizeof (struct zklog)) {
+		fprintf(stderr, "error: file %s too small to be a txnlog\n",
+		    fname);
+		exit(3);
+	}
+
+	data = (uint8_t *)mmap(NULL, len,
+	    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FILE, fd, 0);
+	if (data == MAP_FAILED) {
+		fprintf(stderr, "error: mmap(%s): %s\n", fname,
+		    strerror(errno));
+		exit(2);
+	}
+	log = (struct zklog *)data;
+
+	log->zl_magic = be32toh(log->zl_magic);
+	if (log->zl_magic != ZKLOG_MAGIC) {
+		fprintf(stderr, "error: %s: bad magic number\n", fname);
+		exit(3);
+	}
+	log->zl_version = be32toh(log->zl_version);
+	if (log->zl_version != 2) {
+		fprintf(stderr, "error: %s: unknown log version (%u)\n",
+		    fname, log->zl_version);
+		exit(3);
+	}
+
+	offset = (uint8_t *)log->zl_txns - data;
+	while (offset < len) {
+		txn = (struct zktxn *)(data + offset);
+		txn->zt_len = be32toh(txn->zt_len);
+
+		if (txn->zt_len == 0)
+			break;
+
+		offset += offsetof(struct zktxn, zt_len) +
+		    sizeof (txn->zt_len) + txn->zt_len;
+
+		if (offset > len || data[offset] != ZKTXN_TERMINATOR) {
+			fprintf(stderr, "error: bad txn entry in %s around "
+			    "+0x%x\n", fname, offset);
+			exit(3);
+		}
+		++offset;
+
+		txn->zt_sessionid = be64toh(txn->zt_sessionid);
+		txn->zt_cxid = be32toh(txn->zt_cxid);
+		txn->zt_zxid = be64toh(txn->zt_zxid);
+		txn->zt_time = be64toh(txn->zt_time);
+		txn->zt_type = be32toh(txn->zt_type);
+
+		tms = txn->zt_time % 1000;
+		t = txn->zt_time / 1000;
+
+		duration = 0;
+
+		head = &sessions[txn->zt_sessionid & 0xFF];
+		for (sess = *head; sess != NULL; sess = sess->ss_next) {
+			if (sess->ss_sid == txn->zt_sessionid)
+				break;
+		}
+
+		if (sess == NULL && (int32_t)txn->zt_type == ZK_CREATESESSION) {
+			sess = calloc(1, sizeof (struct session_state));
+			sess->ss_next = *head;
+			sess->ss_sid = txn->zt_sessionid;
+			sess->ss_start = txn->zt_time;
+			if (*head != NULL)
+				(*head)->ss_prev = sess;
+			*head = sess;
+		}
+
+		if (sess != NULL && (int32_t)txn->zt_type == ZK_CLOSESESSION) {
+			duration = txn->zt_time - sess->ss_start;
+			if (sess->ss_next)
+				sess->ss_next->ss_prev = sess->ss_prev;
+			if (sess->ss_prev)
+				sess->ss_prev->ss_next = sess->ss_next;
+			if (*head == sess)
+				*head = sess->ss_next;
+			free(sess);
+		}
+
+		if (t < mintime)
+			continue;
+		if (sid != 0 && sid != txn->zt_sessionid)
+			continue;
+		if (srvid != 0 && ((txn->zt_sessionid >> 56) & 0xFF) != srvid)
+			continue;
+
+		tm = gmtime(&t);
+		snprintf(timebuf, sizeof (timebuf),
+		    "%04d-%02d-%02dT%02d:%02d:%02d.%03uZ",
+		    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+		    tm->tm_hour, tm->tm_min, tm->tm_sec, (uint)tms);
+
+		printf("{\"time\":\"%s\",\"type\":\"%s\",\"typeid\":%d,"
+		    "\"sessionid\":\"%llx\","
+		    "\"cxid\":\"%x\",\"zxid\":\"%llx\"",
+		    timebuf, zktxn_type_to_name((int32_t)txn->zt_type),
+		    (int32_t)txn->zt_type, txn->zt_sessionid, txn->zt_cxid,
+		    txn->zt_zxid);
+
+		if ((int32_t)txn->zt_type == ZK_CLOSESESSION && duration != 0) {
+			printf(",\"duration\":%llu", duration);
+		}
+
+		void *inner = &txn->zt_inner;
+		size_t innerlen = txn->zt_len -
+		    (offsetof(struct zktxn, zt_inner) - (
+		    offsetof(struct zktxn, zt_len) + sizeof (txn->zt_len)));
+
+		print_inner(txn, timebuf, (int32_t)txn->zt_type, inner,
+		    innerlen);
+
+		printf("}\n");
+	}
+
+	if (munmap((void *)data, len)) {
+		fprintf(stderr, "error: munmap(%s): %s\n", fname,
+		    strerror(errno));
+		exit(1);
+	}
+
+	close(fd);
+}
+
+static void
+usage(void)
+{
+	fprintf(stderr, "usage: zklog [-Sd] [-t secs] [-s sid] [-z srvid] "
+	    "<txnlog> [txnlog2 ...]\n");
+	fprintf(stderr, "converts ZK replicated txn log files into JSON\n");
+	fprintf(stderr, "options:\n"
+	    "    -S        dumps _SESSION records about all still-active\n"
+	    "              sessions at the end of the log\n"
+	    "    -d        include node data in the output (e.g. actual\n"
+	    "              contents of nodes)\n"
+	    "\n"
+	    "filter options:\n"
+	    "    -t secs   output only records that were timestamped within\n"
+	    "              the last <secs> seconds\n"
+	    "    -s sid    output only records matching the given zk session\n"
+	    "              id (in hex)\n"
+	    "    -z srvid  output only records recorded by the given server\n"
+	    "              id (in decimal)\n"
+	    "\n"
+	    "example:\n"
+	    "  find .../zookeeper/version-2 -name 'log.*' | "
+	    "sort -n | tail -n 10 | xargs ./zklog -d\n");
+	exit(1);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int opt;
+	struct timeval now;
+	char *p;
+	int dumpsess = 0;
+
+	if (gettimeofday(&now, NULL)) {
+		perror("gettimeofday");
+		return (1);
+	}
+
+	while ((opt = getopt(argc, argv, "Sdt:s:z:")) != -1) {
+		switch (opt) {
+		case 'S':
+			dumpsess++;
+			break;
+		case 't':
+			mintime = now.tv_sec - atoi(optarg);
+			break;
+		case 's':
+			p = optarg;
+			sid = strtoull(p, &p, 16);
+			if ((size_t)(p - optarg) < strlen(optarg)) {
+				fprintf(stderr, "error: invalid session id "
+				    "'%s'\n", optarg);
+				exit(1);
+			}
+			break;
+		case 'd':
+			dumpdata = 1;
+			break;
+		case 'z':
+			srvid = atoi(optarg);
+			break;
+		default:
+			usage();
+		}
+	}
+
+	if (optind >= argc)
+		usage();
+
+	while (optind < argc)
+		do_file(argv[optind++]);
+
+	if (dumpsess) {
+		struct session_state *sess;
+		uint sidlow;
+		uint64_t nowms, duration;
+
+		if (gettimeofday(&now, NULL)) {
+			perror("gettimeofday");
+			return (1);
+		}
+		nowms = now.tv_sec * 1000 + (now.tv_usec / 1000);
+
+		for (sidlow = 0; sidlow <= 0xFF; ++sidlow) {
+			sess = sessions[sidlow];
+			for (; sess != NULL; sess = sess->ss_next) {
+				if (sid != 0 && sid != sess->ss_sid)
+					continue;
+				if (srvid != 0 &&
+				    ((sess->ss_sid >> 56) & 0xFF) != srvid) {
+					continue;
+				}
+				duration = nowms - sess->ss_start;
+				if (sess->ss_start > nowms)
+					duration = 0;
+				printf("{\"type\":\"_SESSION\",\"sid\":\"%llx\""
+				    ",\"duration\":%llu}\n", sess->ss_sid,
+				    duration);
+			}
+		}
+	}
+
+	return (0);
+}
-- 
2.21.0

