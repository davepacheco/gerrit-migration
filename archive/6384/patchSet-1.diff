From 21525d58e65478ee0a85222f75622cc2fa34ce4e Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Sat, 16 Mar 2019 13:26:23 +0000
Subject: [PATCH] OS-7668 fwadm needs to selectively add new syntax

---
 overlay/generic/etc/ipf/smartos_version |   1 +
 src/fw/lib/fw.js                        | 148 ++++++++++++++----------
 src/fw/node_modules/fwrule/rule.js      |  17 ++-
 src/fw/package.json                     |   4 +-
 4 files changed, 104 insertions(+), 66 deletions(-)
 create mode 100644 overlay/generic/etc/ipf/smartos_version

diff --git a/overlay/generic/etc/ipf/smartos_version b/overlay/generic/etc/ipf/smartos_version
new file mode 100644
index 00000000..0cfbf088
--- /dev/null
+++ b/overlay/generic/etc/ipf/smartos_version
@@ -0,0 +1 @@
+2
diff --git a/src/fw/lib/fw.js b/src/fw/lib/fw.js
index 1ee415f4..3bb34948 100644
--- a/src/fw/lib/fw.js
+++ b/src/fw/lib/fw.js
@@ -21,7 +21,7 @@
  * CDDL HEADER END
  *
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  *
  * fwadm: Main entry points
@@ -105,6 +105,9 @@ var v6fallbacks = fallbacks.concat([
     'pass out quick proto ipv6-icmp from any to any keep state',
     'pass out proto ipv6-icmp from any to any']);
 
+// Do not use directly - use haveIpfEventLogger() instead.
+var haveDevIpfEv = undefined;
+var DEV_IPFEV = '/dev/ipfev';
 
 // --- Internal helper functions
 
@@ -120,6 +123,17 @@ function assertStringOrObject(obj, name) {
 }
 
 
+/**
+ * Determine if /dev/ipfev exists, caching the result for future calls in the
+ * global variable haveDevIpfEv.
+ */
+function haveIpfEventLogger() {
+    if (haveDevIpfEv === undefined) {
+        haveDevIpfEv = fs.existsSync(DEV_IPFEV);
+    }
+    return haveDevIpfEv;
+}
+
 /**
  * For a rule and a direction, return whether or not we actually need to
  * write ipf rules. FROM+ALLOW and TO+BLOCK are essentially no-ops, as
@@ -133,8 +147,8 @@ function noRulesNeeded(dir, rule) {
         return false;
     }
 
-    if ((dir === 'from' && rule.action === 'allow')
-        || (dir === 'to' && rule.action === 'block')) {
+    if ((dir === 'from' && rule.action === 'allow') ||
+        (dir === 'to' && rule.action === 'block')) {
         return true;
     }
     return false;
@@ -226,16 +240,16 @@ function getChangingRules(rules, existingRules, cb) {
  */
 function getAffectedRules(new_vms, log) {
     return function _isAffectedRule(rule) {
-        if (rule.action === 'allow'
-            && vmsOnSide(new_vms, rule, 'from', log).length > 0) {
-            return rule.to.wildcards.indexOf('vmall') !== -1
-                || rule.to.tags.length > 0
-                || rule.to.vms.length > 0;
-        } else if (rule.action === 'block'
-            && vmsOnSide(new_vms, rule, 'to', log).length > 0) {
-            return rule.from.wildcards.indexOf('vmall') !== -1
-                || rule.from.tags.length > 0
-                || rule.from.vms.length > 0;
+        if (rule.action === 'allow' &&
+            vmsOnSide(new_vms, rule, 'from', log).length > 0) {
+            return rule.to.wildcards.indexOf('vmall') !== -1 ||
+                rule.to.tags.length > 0 ||
+                rule.to.vms.length > 0;
+        } else if (rule.action === 'block' &&
+            vmsOnSide(new_vms, rule, 'to', log).length > 0) {
+            return rule.from.wildcards.indexOf('vmall') !== -1 ||
+                rule.from.tags.length > 0 ||
+                rule.from.vms.length > 0;
         }
         return false;
     };
@@ -354,19 +368,19 @@ function createUpdatedRules(opts, log, callback) {
             origRule = originals[rule.uuid].serialize();
             mergedRule = mergeObjects(rule, origRule);
 
-            if (!(hasKey(rule, 'owner_uuid')
-                && hasKey(rule, 'global'))) {
+            if (!(hasKey(rule, 'owner_uuid') &&
+                hasKey(rule, 'global'))) {
                 // If both owner_uuid and global are set - let
                 // this bubble up the appropriate error in createRules()
 
-                if (hasKey(rule, 'owner_uuid')
-                    && hasKey(origRule, 'global')) {
+                if (hasKey(rule, 'owner_uuid') &&
+                    hasKey(origRule, 'global')) {
                     // Updating from global -> owner_uuid rule
                     delete mergedRule.global;
                 }
 
-                if (hasKey(rule, 'global')
-                    && hasKey(origRule, 'owner_uuid')) {
+                if (hasKey(rule, 'global') &&
+                    hasKey(origRule, 'owner_uuid')) {
                     // Updating from owner_uuid -> global rule
                     delete mergedRule.owner_uuid;
                 }
@@ -841,10 +855,8 @@ function validateRules(vms, rvms, rules, log, callback) {
                 sideData[rule.uuid][dir].vms[vm] = 1;
             }
             delete rulesLeft[rule.uuid];
-
         } else if (hasKey(rvms[type], t)) {
             delete rulesLeft[rule.uuid];
-
         } else {
             sideData[rule.uuid][dir].missing[type][t] = 1;
         }
@@ -865,8 +877,8 @@ function validateRules(vms, rvms, rules, log, callback) {
         DIRECTIONS.forEach(function (dir) {
             var otherSide = (dir == 'to' ? 'from' : 'to');
 
-            if (!hasKey(missing, dir) || objEmpty(missing[dir].vms)
-                || !hasKey(missing, otherSide)) {
+            if (!hasKey(missing, dir) || objEmpty(missing[dir].vms) ||
+                !hasKey(missing, otherSide)) {
                 return;
             }
 
@@ -899,9 +911,8 @@ function protoTarget(rule, target) {
         return 'icmp-type ' + typeArr[0]
             + (typeArr.length === 1 ? '' : ' code ' + typeArr[1]);
     } else {
-        if (hasKey(target, 'start')
-            && hasKey(target, 'end')) {
-
+        if (hasKey(target, 'start') &&
+            hasKey(target, 'end')) {
             return 'port ' + target.start + ' : ' + target.end;
         } else {
             return 'port = ' + target;
@@ -1083,6 +1094,16 @@ function ipfRuleObj(opts) {
     // ipfilter uses /etc/protocols which calls ICMPv6 'ipv6-icmp'
     var ipfProto = (rule.protocol === 'icmp6') ? 'ipv6-icmp' : rule.protocol;
 
+    var readtags = [];
+    if (haveIpfEventLogger()) {
+        if (rule.uuid) {
+            readtags.push(util.format('uuid=%s', rule.uuid));
+        }
+        if (rule.log) {
+            readtags.push('cfwlog');
+        }
+    }
+
     var sortObj = {
         action: rule.action,
         direction: dir,
@@ -1097,7 +1118,9 @@ function ipfRuleObj(opts) {
         type: opts.type,
         uuid: rule.uuid,
         value: opts.value,
-        version: rule.version
+        version: rule.version,
+        allTags: readtags.length !== 0 ?
+            util.format(' set-tag(%s)', readtags.join(', ')) : ''
     };
 
     if (opts.type === 'wildcard' && opts.value === 'any') {
@@ -1107,10 +1130,8 @@ function ipfRuleObj(opts) {
                 dir === 'from' ? 'out' : 'in',
                 ipfProto,
                 protoTarget(rule, t));
-            if (rule.protocol !== 'icmp6')
-                sortObj.v4text.push(wild);
-            if (rule.protocol !== 'icmp')
-                sortObj.v6text.push(wild);
+            if (rule.protocol !== 'icmp6') { sortObj.v4text.push(wild); }
+            if (rule.protocol !== 'icmp') { sortObj.v6text.push(wild); }
         });
 
         return sortObj;
@@ -1120,8 +1141,8 @@ function ipfRuleObj(opts) {
         var isv6 = target.indexOf(':') !== -1;
 
         // Don't generate rules for ICMPv4/IPv6 or ICMPv6/IPv4
-        if ((isv6 && rule.protocol === 'icmp')
-            || (!isv6 && rule.protocol === 'icmp6')) {
+        if ((isv6 && rule.protocol === 'icmp') ||
+            (!isv6 && rule.protocol === 'icmp6')) {
             return;
         }
 
@@ -1252,16 +1273,21 @@ function prepareIPFdata(opts, log, callback) {
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
-            '#',
-            ''];
+            '#'
+        ];
+        if (haveIpfEventLogger()) {
+            ipf4Conf.push('# smartos_ipf_version 2');
+        }
+        ipf4Conf.push('#', '');
         var ipf6Conf = ipf4Conf.slice();
         var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
         conf[vm].sort(compareRules).forEach(function (sortObj) {
             var ktxt = KEEP_FRAGS;
-            if ((sortObj.direction === 'from' && sortObj.action === 'allow')
-                || (sortObj.direction === 'to' && iks[sortObj.protocol])) {
-                ktxt += KEEP_STATE;
+            if (sortObj.allTags !== '' ||
+                (sortObj.direction === 'from' && sortObj.action === 'allow') ||
+                (sortObj.direction === 'to' && iks[sortObj.protocol])) {
+                ktxt += KEEP_STATE + sortObj.allTags;
             }
 
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
@@ -1331,8 +1357,8 @@ function vmsOnSide(allVMs, rule, dir, log) {
             }
 
             Object.keys(vmList).forEach(function (uuid) {
-                if (hasKey(rule, 'owner_uuid')
-                    && (rule.owner_uuid != vmList[uuid].owner_uuid)) {
+                if (hasKey(rule, 'owner_uuid') &&
+                    (rule.owner_uuid != vmList[uuid].owner_uuid)) {
                     return;
                 }
 
@@ -1399,8 +1425,8 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
             }
 
             [localVMs, remoteVMs].forEach(function (lookup) {
-                if (!hasKey(lookup, lookupTypePlural)
-                    || !hasKey(lookup[lookupTypePlural], value)) {
+                if (!hasKey(lookup, lookupTypePlural) ||
+                    !hasKey(lookup[lookupTypePlural], value)) {
                     return;
                 }
 
@@ -1413,8 +1439,8 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
                 }
 
                 forEachKey(vmList, function (uuid, vm) {
-                    if (rule.owner_uuid && vm.owner_uuid
-                        && vm.owner_uuid != rule.owner_uuid) {
+                    if (rule.owner_uuid && vm.owner_uuid &&
+                        vm.owner_uuid != rule.owner_uuid) {
                         return;
                     }
 
@@ -1700,8 +1726,8 @@ function applyChanges(opts, log, callback) {
 
         // Save the remote VMs
         function saveVMs(res, cb) {
-            if (opts.dryrun || !opts.save || !opts.save.remoteVMs
-                || objEmpty(opts.save.remoteVMs)) {
+            if (opts.dryrun || !opts.save || !opts.save.remoteVMs ||
+                objEmpty(opts.save.remoteVMs)) {
                 return cb(null);
             }
             mod_rvm.save(opts.save.remoteVMs, log, cb);
@@ -1709,8 +1735,8 @@ function applyChanges(opts, log, callback) {
 
         // Save rule files (if specified)
         function save(res, cb) {
-            if (opts.dryrun || !opts.save || !opts.save.rules
-                || opts.save.rules.length === 0) {
+            if (opts.dryrun || !opts.save || !opts.save.rules ||
+                opts.save.rules.length === 0) {
                 return cb(null);
             }
             saveRules(opts.save.rules, log, cb);
@@ -1718,8 +1744,8 @@ function applyChanges(opts, log, callback) {
 
         // Delete rule files (if specified)
         function delRules(res, cb) {
-            if (opts.dryrun || !opts.del || !opts.del.rules
-                || opts.del.rules.length === 0) {
+            if (opts.dryrun || !opts.del || !opts.del.rules ||
+                opts.del.rules.length === 0) {
                 return cb(null);
             }
             deleteRules(opts.del.rules, log, cb);
@@ -1727,8 +1753,8 @@ function applyChanges(opts, log, callback) {
 
         // Delete remote VMs (if specified)
         function delRVMs(res, cb) {
-            if (opts.dryrun || !opts.del || !opts.del.rvms
-                || opts.del.rvms.length === 0) {
+            if (opts.dryrun || !opts.del || !opts.del.rvms ||
+                opts.del.rvms.length === 0) {
                 return cb(null);
             }
             mod_rvm.del(opts.del.rvms, log, cb);
@@ -1827,8 +1853,8 @@ function add(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
@@ -1981,7 +2007,6 @@ function del(opts, callback) {
             throw new Error(
                 'Payload must contain one of: rvmUUIDs, uuids');
         }
-
     } catch (err) {
         return callback(err);
     }
@@ -2183,7 +2208,7 @@ function listRemoteVMs(opts, callback) {
 
             // XXX: support sorting by other fields, filtering
             var sortFn = function _sort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
 
             log.debug('listRemoteVMs: finish');
@@ -2238,7 +2263,7 @@ function listRules(opts, callback) {
             // XXX: support sorting by other fields, filtering
             // (eg: enabled=true vm=<uuid>)
             var sortFn = function _defaultSort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
             var mapFn = function _defaultMap(r) {
                 return r.serialize();
@@ -2524,8 +2549,8 @@ function update(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
@@ -2709,7 +2734,6 @@ function getRemoteTargets(opts, callback) {
         if (opts.rules.length === 0) {
             throw new Error('Must specify rules');
         }
-
     } catch (err) {
         return callback(err);
     }
@@ -2958,8 +2982,8 @@ function validatePayload(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
diff --git a/src/fw/node_modules/fwrule/rule.js b/src/fw/node_modules/fwrule/rule.js
index 8032a3ff..c75fc9ea 100644
--- a/src/fw/node_modules/fwrule/rule.js
+++ b/src/fw/node_modules/fwrule/rule.js
@@ -51,7 +51,8 @@ var FIELDS = [
     'owner_uuid',
     'rule',
     'uuid',
-    'version'
+    'version',
+    'log'
 ];
 // Maximum number of targets per side:
 var MAX_TARGETS_PER_SIDE = 24;
@@ -379,6 +380,17 @@ function FwRule(data, opts) {
         this.enabled = false;
     }
 
+    if (hasOwnProperty(data, 'log')) {
+        if (!validators.bool(data.log)) {
+            errs.push(new validators.InvalidParamError('log',
+                'log must be true or false'));
+        }
+
+        this.log = data.log;
+    } else {
+        this.log = false;
+    }
+
     for (var s in STRING_PROPS) {
         var str = STRING_PROPS[s];
         if (hasOwnProperty(data, str)) {
@@ -596,7 +608,8 @@ FwRule.prototype.raw = function () {
         protocol: this.protocol,
         to: this.to,
         uuid: this.uuid,
-        version: this.version
+        version: this.version,
+        log: this.log
     };
 
     if (this.owner_uuid) {
diff --git a/src/fw/package.json b/src/fw/package.json
index 91311202..7e828eae 100644
--- a/src/fw/package.json
+++ b/src/fw/package.json
@@ -1,7 +1,7 @@
 {
   "name": "fw",
   "description": "Administrative tool for managing SmartOS VM firewalls",
-  "version": "1.1.1",
+  "version": "1.2.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "main": "./lib/fw.js",
@@ -16,7 +16,7 @@
     "clone": "0.1.4",
     "cmdln": "4.1.1",
     "extsprintf": "1.0.2",
-    "fwrule": "2.0.0",
+    "fwrule": "2.1.0",
     "ip6addr": "0.2.2",
     "mkdirp": "0.3.4",
     "uuid": "3.2.1",
-- 
2.21.0

