From b9e78e2638d17fc03705ddb83e34ef4e9daaa036 Mon Sep 17 00:00:00 2001
From: Ryan Zezeski <rpz@joyent.com>
Date: Thu, 17 Nov 2016 21:51:06 -0700
Subject: [PATCH] OS-5363 dlmgmtd forking with write locks results in deadlock
 chaos

---
 usr/src/cmd/dlmgmtd/dlmgmt_db.c         |  67 +------------
 usr/src/cmd/dlmgmtd/dlmgmt_door.c       |  61 +++++++-----
 usr/src/cmd/dlmgmtd/dlmgmt_impl.h       |   2 +-
 usr/src/cmd/dlmgmtd/dlmgmt_util.c       |  23 ++++-
 usr/src/cmd/zoneadmd/Makefile.com       |   3 +
 usr/src/cmd/zoneadmd/vplat.c            | 120 ++++++++++++++++++++++++
 usr/src/lib/libdladm/common/libdlmgmt.c |   6 +-
 usr/src/uts/common/io/dls/dls_mgmt.c    |   3 +
 usr/src/uts/common/sys/dls_mgmt.h       |  21 ++++-
 9 files changed, 211 insertions(+), 95 deletions(-)

diff --git a/usr/src/cmd/dlmgmtd/dlmgmt_db.c b/usr/src/cmd/dlmgmtd/dlmgmt_db.c
index 8eecc807e5..919714ae1e 100644
--- a/usr/src/cmd/dlmgmtd/dlmgmt_db.c
+++ b/usr/src/cmd/dlmgmtd/dlmgmt_db.c
@@ -44,7 +44,6 @@
 #include <libcontract.h>
 #include <libcontract_priv.h>
 #include <sys/contract/process.h>
-#include <sys/vnic.h>
 #include <zone.h>
 #include "dlmgmt_impl.h"
 
@@ -1533,11 +1532,6 @@ done:
 
 /*
  * Remove all links in the given zoneid.
- *
- * We do this work in two different passes. In the first pass, we remove any
- * entry that hasn't been loaned and mark every entry that has been loaned as
- * something that is going to be tombstomed. In the second pass, we drop the
- * table lock for every entry and remove the tombstombed entry for our zone.
  */
 void
 dlmgmt_db_fini(zoneid_t zoneid)
@@ -1547,66 +1541,9 @@ dlmgmt_db_fini(zoneid_t zoneid)
 	while (linkp != NULL) {
 		next_linkp = AVL_NEXT(&dlmgmt_name_avl, linkp);
 		if (linkp->ll_zoneid == zoneid) {
-			boolean_t onloan = linkp->ll_onloan;
-
-			/*
-			 * Cleanup any VNICs that were loaned to the zone
-			 * before the zone goes away and we can no longer
-			 * refer to the VNIC by the name/zoneid.
-			 */
-			if (onloan) {
-				(void) dlmgmt_delete_db_entry(linkp,
-				    DLMGMT_ACTIVE);
-				linkp->ll_tomb = B_TRUE;
-			} else {
-				(void) dlmgmt_destroy_common(linkp,
-				    DLMGMT_ACTIVE | DLMGMT_PERSIST);
-			}
-
+			(void) dlmgmt_destroy_common(linkp,
+			    DLMGMT_ACTIVE | DLMGMT_PERSIST);
 		}
 		linkp = next_linkp;
 	}
-
-again:
-	linkp = avl_first(&dlmgmt_name_avl);
-	while (linkp != NULL) {
-		vnic_ioc_delete_t ioc;
-
-		next_linkp = AVL_NEXT(&dlmgmt_name_avl, linkp);
-
-		if (linkp->ll_zoneid != zoneid) {
-			linkp = next_linkp;
-			continue;
-		}
-		ioc.vd_vnic_id = linkp->ll_linkid;
-		if (linkp->ll_tomb != B_TRUE)
-			abort();
-
-		/*
-		 * We have to drop the table lock while going up into the
-		 * kernel. If we hold the table lock while deleting a vnic, we
-		 * may get blocked on the mac perimeter and the holder of it may
-		 * want something from dlmgmtd.
-		 */
-		dlmgmt_table_unlock();
-
-		if (ioctl(dladm_dld_fd(dld_handle),
-		    VNIC_IOC_DELETE, &ioc) < 0)
-			dlmgmt_log(LOG_WARNING, "dlmgmt_db_fini "
-			    "delete VNIC ioctl failed %d %d",
-			    ioc.vd_vnic_id, errno);
-
-		/*
-		 * Even though we've dropped the lock, we know that nothing else
-		 * could have removed us. Therefore, it should be safe to go
-		 * through and delete ourselves, but do nothing else. We'll have
-		 * to restart iteration from the beginning. This can be painful.
-		 */
-		dlmgmt_table_lock(B_TRUE);
-
-		(void) dlmgmt_destroy_common(linkp,
-		    DLMGMT_ACTIVE | DLMGMT_PERSIST);
-		goto again;
-	}
-
 }
diff --git a/usr/src/cmd/dlmgmtd/dlmgmt_door.c b/usr/src/cmd/dlmgmtd/dlmgmt_door.c
index 137c2a6fb3..3306b2b9aa 100644
--- a/usr/src/cmd/dlmgmtd/dlmgmt_door.c
+++ b/usr/src/cmd/dlmgmtd/dlmgmt_door.c
@@ -384,11 +384,6 @@ dlmgmt_upcall_destroy(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 	if ((err = dlmgmt_checkprivs(linkp->ll_class, cred)) != 0)
 		goto done;
 
-	if (linkp->ll_tomb == B_TRUE) {
-		err = EINPROGRESS;
-		goto done;
-	}
-
 	if (((linkp->ll_flags & flags) & DLMGMT_ACTIVE) != 0) {
 		if ((err = dlmgmt_delete_db_entry(linkp, DLMGMT_ACTIVE)) != 0)
 			goto done;
@@ -433,8 +428,11 @@ dlmgmt_getname(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 		retvalp->lr_flags = linkp->ll_flags;
 		retvalp->lr_class = linkp->ll_class;
 		retvalp->lr_media = linkp->ll_media;
+		retvalp->lr_flags |= (linkp->ll_trans == B_TRUE) ?
+		    DLMGMT_TRANSIENT : 0;
 	}
 
+
 	dlmgmt_table_unlock();
 	retvalp->lr_err = err;
 }
@@ -662,11 +660,6 @@ dlmgmt_remapid(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 	if ((err = dlmgmt_checkprivs(linkp->ll_class, cred)) != 0)
 		goto done;
 
-	if (linkp->ll_tomb == B_TRUE) {
-		err = EBUSY;
-		goto done;
-	}
-
 
 	if (link_by_name(remapid->ld_link, linkp->ll_zoneid) != NULL) {
 		err = EEXIST;
@@ -729,11 +722,6 @@ dlmgmt_upid(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 	if ((err = dlmgmt_checkprivs(linkp->ll_class, cred)) != 0)
 		goto done;
 
-	if (linkp->ll_tomb == B_TRUE) {
-		err = EBUSY;
-		goto done;
-	}
-
 	if (linkp->ll_flags & DLMGMT_ACTIVE) {
 		err = EINVAL;
 		goto done;
@@ -1241,11 +1229,6 @@ dlmgmt_setzoneid(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 	if ((err = dlmgmt_checkprivs(linkp->ll_class, cred)) != 0)
 		goto done;
 
-	if (linkp->ll_tomb == B_TRUE) {
-		err = EBUSY;
-		goto done;
-	}
-
 	/* We can only assign an active link to a zone. */
 	if (!(linkp->ll_flags & DLMGMT_ACTIVE)) {
 		err = EINVAL;
@@ -1278,12 +1261,36 @@ dlmgmt_setzoneid(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 
 		if (newzoneid == GLOBAL_ZONEID && linkp->ll_onloan) {
 			/*
-			 * We can only reassign a loaned VNIC back to the
-			 * global zone when the zone is shutting down, since
-			 * otherwise the VNIC is in use by the zone and will be
-			 * busy.  Leave the VNIC assigned to the zone so we can
-			 * still see it and delete it when dlmgmt_zonehalt()
-			 * runs.
+			 * RPZ: upstream doesn't make this check, it
+			 * simply removes the link from
+			 * dlmgmt_loan_avl -- but we remove this map
+			 * in SmartOS for some reason.
+			 *
+			 * RPZ: I think we can remove this special
+			 * case here because we will no longer delete
+			 * form dlmgmt_zonehalt()? Although, we need
+			 * to read the link list of the zone from dlmgmt.
+			 *
+			 * RPZ: Atually, we don't even ever get here
+			 * during zone shutdown. I verified this by
+			 * tracing calls to this function -- they
+			 * never occur during shutdown. By the time
+			 * dls_devnet_unset() is called the dd_zid of
+			 * the link must have already been changed to
+			 * 0.
+			 *
+			 * RPZ: Now that I've thought about it more I
+			 * believe this case should return EBUSY. If
+			 * you are here it means something is trying
+			 * to reassign the link to the GZ before the
+			 * NGZ is done with it.
+			 *
+			 * We can only reassign a loaned VNIC back to
+			 * the global zone when the zone is shutting
+			 * down, since otherwise the VNIC is in use by
+			 * the zone and will be busy. Leave the VNIC
+			 * assigned to the zone so we can still see it
+			 * and delete it when dlmgmt_zonehalt() runs.
 			 */
 			goto done;
 		}
@@ -1367,6 +1374,8 @@ dlmgmt_zonehalt(void *argp, void *retp, size_t *sz, zoneid_t zoneid,
 			 * to happen, we try to serialize some of the zone
 			 * activity here between dlmgmtd and the brands on
 			 * /etc/dladm/zone.lck
+			 *
+			 * RPZ need to delete this.
 			 */
 			int fd;
 
diff --git a/usr/src/cmd/dlmgmtd/dlmgmt_impl.h b/usr/src/cmd/dlmgmtd/dlmgmt_impl.h
index dde27ef66e..693dc563b4 100644
--- a/usr/src/cmd/dlmgmtd/dlmgmt_impl.h
+++ b/usr/src/cmd/dlmgmtd/dlmgmt_impl.h
@@ -68,7 +68,7 @@ typedef struct dlmgmt_link_s {
 	avl_node_t		ll_loan_node;
 	uint32_t		ll_flags;
 	uint32_t		ll_gen;		/* generation number */
-	boolean_t		ll_tomb;	/* tombstombed */
+	boolean_t		ll_trans;	/* transient link */
 } dlmgmt_link_t;
 
 /*
diff --git a/usr/src/cmd/dlmgmtd/dlmgmt_util.c b/usr/src/cmd/dlmgmtd/dlmgmt_util.c
index 7493ee3577..c1ea7d8e08 100644
--- a/usr/src/cmd/dlmgmtd/dlmgmt_util.c
+++ b/usr/src/cmd/dlmgmtd/dlmgmt_util.c
@@ -383,6 +383,10 @@ link_activate(dlmgmt_link_t *linkp)
 			linkp->ll_onloan = B_TRUE;
 		}
 	} else if (linkp->ll_zoneid != GLOBAL_ZONEID) {
+		/*
+		 * RPZ: zone_add_datalink() doesn't set onloan, I
+		 * think onloan needs to be set here.
+		 */
 		err = zone_add_datalink(linkp->ll_zoneid, linkp->ll_linkid);
 	}
 done:
@@ -439,6 +443,9 @@ dlmgmt_create_common(const char *name, datalink_class_t class, uint32_t media,
 		return (EINVAL);
 	if (dlmgmt_nextlinkid == DATALINK_INVALID_LINKID)
 		return (ENOSPC);
+	if (flags & ~(DLMGMT_ACTIVE | DLMGMT_PERSIST | DLMGMT_TRANSIENT) ||
+	    flags == 0)
+		return (EINVAL);
 
 	if ((linkp = calloc(1, sizeof (dlmgmt_link_t))) == NULL) {
 		err = ENOMEM;
@@ -451,7 +458,15 @@ dlmgmt_create_common(const char *name, datalink_class_t class, uint32_t media,
 	linkp->ll_linkid = dlmgmt_nextlinkid;
 	linkp->ll_zoneid = zoneid;
 	linkp->ll_gen = 0;
-	linkp->ll_tomb = B_FALSE;
+
+	/*
+	 * While DLMGMT_TRANSIENT starts off as a flag it is converted
+	 * into a link field since it is really a substate of
+	 * DLMGMT_ACTIVE -- it should not survive as a flag beyond
+	 * this point.
+	 */
+	linkp->ll_trans = (flags & DLMGMT_TRANSIENT) ? B_TRUE : B_FALSE;
+	flags &= ~DLMGMT_TRANSIENT;
 
 	if (avl_find(&dlmgmt_name_avl, linkp, &name_where) != NULL ||
 	    avl_find(&dlmgmt_id_avl, linkp, &id_where) != NULL) {
@@ -481,6 +496,12 @@ done:
 int
 dlmgmt_destroy_common(dlmgmt_link_t *linkp, uint32_t flags)
 {
+	/*
+	 * After dlmgmt_create_common() the link flags should only
+	 * ever include ACTIVE or PERSIST.
+	 */
+	assert((linkp->ll_flags & ~(DLMGMT_ACTIVE | DLMGMT_PERSIST)) == 0);
+
 	if ((linkp->ll_flags & flags) == 0) {
 		/*
 		 * The link does not exist in the specified space.
diff --git a/usr/src/cmd/zoneadmd/Makefile.com b/usr/src/cmd/zoneadmd/Makefile.com
index c8becc3e8c..4c83fec964 100644
--- a/usr/src/cmd/zoneadmd/Makefile.com
+++ b/usr/src/cmd/zoneadmd/Makefile.com
@@ -37,6 +37,9 @@ LDLIBS += -lsocket -lzonecfg -lnsl -ldevinfo -ldevice -lnvpair \
 	-lgen -lbsm -lcontract -lzfs -luuid -lbrand -ldladm -ltsnet -ltsol \
 	-linetutil -lproc -lscf
 
+C99MODE=	-xc99=%all
+C99LMODE=	-Xc99=%all
+
 .KEEP_STATE:
 
 %.o:    ../%.c
diff --git a/usr/src/cmd/zoneadmd/vplat.c b/usr/src/cmd/zoneadmd/vplat.c
index 9a6f0ceb87..cc0838face 100644
--- a/usr/src/cmd/zoneadmd/vplat.c
+++ b/usr/src/cmd/zoneadmd/vplat.c
@@ -78,6 +78,7 @@
 #include <sys/conf.h>
 #include <sys/systeminfo.h>
 #include <sys/secflags.h>
+#include <sys/vnic.h>
 
 #include <libdlpi.h>
 #include <libdllink.h>
@@ -5151,6 +5152,110 @@ unmounted:
 	}
 }
 
+/*
+ * Delete all the transient VNICs belonging to a zone. A transient
+ * VNIC is one that is created and destroyed along with the lifetime
+ * of the zone. Non-transient VNICs, ones that are assigned from GZ to
+ * NGZ, are reassigned to GZ in zone_shutdown() via the zsd callbacks.
+ *
+ * RPZ: currently this always returns success and just logs an error
+ * when failing to delete a vnic, should we instead stop walking and
+ * return error?
+ */
+static int
+delete_transient_vnics(zlog_t *zlogp, zoneid_t zoneid)
+{
+	/*
+	 * RPZ test what happens if this ioctl fails.
+	 *
+	 * RPZ: using dladm_vnic_up() as inspirection.
+	 *
+	 * RPZ: should I restrain class?
+	 *
+	 * RPZ: restrain media type?
+	 *
+	 * RPZ: is opt persist correct? Probably not, I think this is
+	 * where I want transient?
+	 *
+	 * RPZ: would be nice if dladm_walk_datalink_id had an option
+	 * to specify zone.
+	 *
+	 */
+
+	dladm_status_t status;
+	int num_links = 0;
+	datalink_id_t *links, link;
+	uint32_t link_flags;
+	datalink_class_t link_class;
+	char link_name[MAXLINKNAMELEN];
+	vnic_ioc_delete_t ioc;
+
+	if (zone_list_datalink(zoneid, &num_links, NULL) != 0) {
+		zerror(zlogp, B_TRUE, "unable to determine"
+		    " number of network interfaces");
+	}
+
+	/*
+	 * RPZ: There has to be at least one interface
+	 * if exclusive. Right?
+	 */
+	assert(num_links >= 1);
+
+	links = malloc(num_links * sizeof (datalink_id_t));
+
+	if (links == NULL) {
+		zerror(zlogp, B_TRUE, "failed to delete"
+		    "network interfaces because of alloc fail");
+	}
+
+	if (zone_list_datalink(zoneid, &num_links, links) != 0) {
+		zerror(zlogp, B_TRUE, "failed to delete"
+		    " network interfaces because of failure"
+		    " to list them");
+	}
+
+	for (int i = 0; i < num_links; i++) {
+		link = links[i];
+		/*
+		 * RPZ: This is the code I would use if transient was
+		 * just kept in link_flags.
+		 */
+		status = dladm_datalink_id2info(dld_handle, link, &link_flags,
+		    &link_class, NULL, link_name, sizeof (link_name));
+
+		/*
+		 * RPZ VNIC delete can only delete VNIC, VLAN, or
+		 * ETHERSTUB classes, see dladm_vnic_delete().
+		 */
+		assert(link_class & (DATALINK_CLASS_VLAN | DATALINK_CLASS_VNIC
+			| DATALINK_CLASS_ETHERSTUB));
+
+
+		if (status != DLADM_STATUS_OK) {
+			zerror(zlogp, B_FALSE, "failed to "
+			    "delete network interface "
+			    "due to failure to get link info");
+		}
+
+		if (link_flags & DLADM_OPT_TRANSIENT) {
+			ioc.vd_vnic_id = link;
+
+			if (ioctl(dladm_dld_fd(dld_handle), VNIC_IOC_DELETE,
+				&ioc) < 0) {
+				zerror(zlogp, B_TRUE,
+				    "delete VNIC ioctl failed %d %d", link,
+				    errno);
+			}
+		}
+	}
+
+
+	/*
+	 * RPZ: should this return errnos?
+	 */
+	return (0);
+}
+
 int
 vplat_teardown(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting,
     boolean_t debug)
@@ -5210,6 +5315,7 @@ vplat_teardown(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting,
 		goto error;
 	}
 
+
 	/* Get a handle to the brand info for this zone */
 	if ((bh = brand_open(brand_name)) == NULL) {
 		zerror(zlogp, B_FALSE, "unable to determine zone brand");
@@ -5262,6 +5368,20 @@ vplat_teardown(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting,
 			}
 			break;
 		case ZS_EXCLUSIVE:
+
+			/*
+			 * RPZ: currently always returns success.
+			 */
+			(void) delete_transient_vnics(zlogp, zoneid);
+
+
+			/*
+			 * RPZ: Should we goto error on failure? The original
+			 * call to dladm_zone_halt presses on in the face of
+			 * failure but I wonder if that was an oversight
+			 * because the rest of vplat_teardown() jumps to error
+			 * on failure.
+			 */
 			status = dladm_zone_halt(dld_handle, zoneid);
 			if (status != DLADM_STATUS_OK) {
 				zerror(zlogp, B_FALSE, "unable to notify "
diff --git a/usr/src/lib/libdladm/common/libdlmgmt.c b/usr/src/lib/libdladm/common/libdlmgmt.c
index c9c7906934..b2fd038e8e 100644
--- a/usr/src/lib/libdladm/common/libdlmgmt.c
+++ b/usr/src/lib/libdladm/common/libdlmgmt.c
@@ -125,6 +125,7 @@ dladm_create_datalink_id(dladm_handle_t handle, const char *link,
 
 	dlmgmt_flags = (flags & DLADM_OPT_ACTIVE) ? DLMGMT_ACTIVE : 0;
 	dlmgmt_flags |= (flags & DLADM_OPT_PERSIST) ? DLMGMT_PERSIST : 0;
+	dlmgmt_flags |= (flags & DLADM_OPT_TRANSIENT) ? DLMGMT_TRANSIENT : 0;
 
 	(void) strlcpy(createid.ld_link, link, MAXLINKNAMELEN);
 	createid.ld_class = class;
@@ -286,6 +287,7 @@ dladm_walk_datalink_id(int (*fn)(dladm_handle_t, datalink_id_t, void *),
 
 	dlmgmt_flags = (flags & DLADM_OPT_ACTIVE) ? DLMGMT_ACTIVE : 0;
 	dlmgmt_flags |= ((flags & DLADM_OPT_PERSIST) ? DLMGMT_PERSIST : 0);
+	dlmgmt_flags |= ((flags & DLADM_OPT_TRANSIENT) ? DLMGMT_TRANSIENT : 0);
 
 	getnext.ld_cmd = DLMGMT_CMD_GETNEXT;
 	getnext.ld_class = class;
@@ -638,10 +640,12 @@ dladm_datalink_id2info(dladm_handle_t handle, datalink_id_t linkid,
 	if (mediap != NULL)
 		*mediap = retval.lr_media;
 	if (flagp != NULL) {
-		*flagp = retval.lr_flags & DLMGMT_ACTIVE ?
+		*flagp = (retval.lr_flags & DLMGMT_ACTIVE) ?
 		    DLADM_OPT_ACTIVE : 0;
 		*flagp |= (retval.lr_flags & DLMGMT_PERSIST) ?
 		    DLADM_OPT_PERSIST : 0;
+		*flagp |= (retval.lr_flags & DLMGMT_TRANSIENT) ?
+		    DLADM_OPT_TRANSIENT : 0;
 	}
 	return (DLADM_STATUS_OK);
 }
diff --git a/usr/src/uts/common/io/dls/dls_mgmt.c b/usr/src/uts/common/io/dls/dls_mgmt.c
index 105c55c7ce..d885bd5599 100644
--- a/usr/src/uts/common/io/dls/dls_mgmt.c
+++ b/usr/src/uts/common/io/dls/dls_mgmt.c
@@ -177,6 +177,9 @@ dls_stack_shutdown(netstackid_t stackid, void *arg)
 
 	/* Move remaining datalinks in this zone back to the global zone. */
 	(void) zone_datalink_walk(dlss->dlss_zoneid, dls_zone_remove, NULL);
+	/*
+	 * RPZ should I put the vnic delete in here?
+	 */
 }
 
 /* ARGSUSED */
diff --git a/usr/src/uts/common/sys/dls_mgmt.h b/usr/src/uts/common/sys/dls_mgmt.h
index 214e225ac9..9f7586e79b 100644
--- a/usr/src/uts/common/sys/dls_mgmt.h
+++ b/usr/src/uts/common/sys/dls_mgmt.h
@@ -114,10 +114,29 @@ typedef uint64_t	datalink_media_t;
 #define	DLMGMT_CMD_BASE			128
 
 /*
- * Indicate the link mapping is active or persistent
+ * Indicate if the link mapping is active, persistent, or transient.
+ *
+ * ACTIVE: A link that doesn't persist across reboot.
+ *
+ * PERSIST: A link that persists across reboot.
+ *
+ * TRANSIENT: A link that is created and destroyed with the lifetime
+ * of its owning zone.
+ *
+ * Valid bitwise flag combinations are:
+ *
+ * RPZ: Does PERSIST assume ACTIVE?
+ *
+ * o ACTIVE
+ * o PERSIST
+ * o ACTIVE | TRANSIENT
+ *
+ * A list is either ACTIVE of PERSIST and you cannot have a persistent
+ * transient link.
  */
 #define	DLMGMT_ACTIVE		0x01
 #define	DLMGMT_PERSIST		0x02
+#define	DLMGMT_TRANSIENT	0x04
 
 /* upcall argument */
 typedef struct dlmgmt_door_arg {
-- 
2.21.0

