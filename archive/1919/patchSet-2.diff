commit 97cb363b9b7f4569af2f7d363956e383d77c30d2 (refs/changes/19/1919/2)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-05-09T17:42:21+02:00 (2 years, 5 months ago)
    
    TOOLS-1762 sdcadm update binder should determine instances to update before executing the update procedure

diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index b40e7d8..99f94ce 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -571,7 +571,12 @@ function coordinatePlan(opts, cb) {
                 {
                     var svcInsts = instsFromSvcName[change.service.name] || [];
                     if (svcInsts.length && svcInsts.length > 1) {
-                        change.insts = svcInsts;
+                        var chInsts = forceSameImage ? svcInsts :
+                                svcInsts.filter(function (ins) {
+                                    return (ins.image !==
+                                        change.image.uuid);
+                                });
+                        change.insts = chInsts;
                     } else {
                         change.inst = svcInsts[0];
                     }
diff --git a/lib/procedures/update-binder-v2.js b/lib/procedures/update-binder-v2.js
index 4958d88..0a79ff2 100644
--- a/lib/procedures/update-binder-v2.js
+++ b/lib/procedures/update-binder-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -35,26 +35,33 @@ function UpdateBinderV2(options) {
 util.inherits(UpdateBinderV2, Procedure);
 
 UpdateBinderV2.prototype.summarize = function ushiSummarize() {
-    var word = (this.changes[0].type === 'rollback-service') ?
-        'rollback' : 'update';
-    var c0 = this.changes[0];
-    var img = c0.image;
-    var out = [sprintf('%s "%s" service to image %s', word,
-                    c0.service.name, img.uuid),
-                common.indent(sprintf('(%s@%s)', img.name, img.version))];
-    if (c0.insts) {
-        out[0] += ':';
-        out = out.concat(c0.insts.map(function (inst) {
-            if (inst.image === img.uuid) {
-                return common.indent(sprintf(
-                    'instance "%s" (%s) is already at version %s',
-                    inst.zonename, inst.alias, img.version));
-            } else {
-                return common.indent(sprintf('instance "%s" (%s) in server %s',
-                    inst.zonename, inst.alias, inst.server));
-            }
-        }));
-    }
+    var self = this;
+    var out = [];
+
+    self.changes.forEach(function printSummary(change) {
+        var insts = change.insts || [change.inst];
+        var word = (change.type === 'rollback-service') ?
+            'rollback' : 'update';
+        var img = change.image;
+        var output = [sprintf('%s "%s" service to image %s', word,
+                        change.service.name, img.uuid),
+                    common.indent(sprintf('(%s@%s)', img.name, img.version))];
+        if (insts && insts.length) {
+            output[0] += ':';
+            output = output.concat(insts.map(function (inst) {
+                if (inst.image === img.uuid) {
+                    return common.indent(sprintf(
+                        'instance "%s" (%s) is already at version %s',
+                        inst.zonename, inst.alias, img.version));
+                } else {
+                    return common.indent(sprintf(
+                        'instance "%s" (%s) in server %s',
+                        inst.zonename, inst.alias, inst.server));
+                }
+            }));
+        }
+        out.push(output.join('\n'));
+    });
     return out.join('\n');
 };
 
@@ -67,21 +74,41 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
     assert.string(opts.wrkDir, 'opts.wrkDir');
     assert.func(cb, 'cb');
     var self = this;
+    var sdcadm = opts.sdcadm;
     var log = opts.log;
     var progress = opts.progress;
     var rollback = opts.plan.rollback ||Â false;
 
     function updateBinder(change, nextSvc) {
         var insts = change.insts || [change.inst];
-        var leader;
-        var standalone = false;
-        var followers = [];
 
         var arg = {
             change: change,
             opts: opts,
             userScript: false,
-            HA: false
+            HA: false,
+            /*
+             * UUIDs of of binder instances with a zookeeper role of followers
+             */
+            followers: [],
+            /*
+             * UUID of the binder instance with zookeeper role of leader
+             */
+            leader: null,
+            /*
+             * Instance Object. Leader instance, in case that it will be
+             * updated during the current process.
+             */
+            leaderInst: null,
+            /*
+             * Array of Instance Objects. Follower instances that will be
+             * updated. Note that it might not be all of them.
+             */
+            followerInsts: [],
+            /*
+             * Is zookeeper running in standalone mode?
+             */
+            standalone: false
         };
 
         if (insts && insts.length > 1) {
@@ -94,13 +121,42 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
         }
 
         var funcs = [
-            function findZkLeader(_, next) {
+            /*
+             * Do not rely into instances provided by change, make sure we get
+             * all the binder instances from VMAPI to find ZK leader.
+             */
+            function getAllBinderVms(ctx, next) {
+                progress('Getting Triton\'s binder vms from VMAPI');
+                sdcadm.vmapi.listVms({
+                    'tag.smartdc_role': 'binder',
+                    state: 'running'
+                }, function (vmsErr, vms_) {
+                    if (vmsErr) {
+                        next(vmsErr);
+                        return;
+                    }
+                    vms_.forEach(function (vm) {
+                        vm.ip = vm.nics.filter(function (nic) {
+                            return (nic.nic_tag === 'admin');
+                        })[0].ip;
+                    });
+                    ctx.binderVms = vms_;
+                    next();
+                });
+            },
+            /*
+             * We'll take advantage of this function to fill ctx.binderIps
+             * variable, since we'll need it for several steps below.
+             */
+            function findZkLeader(ctx, next) {
+                ctx.binderIps = [];
                 progress('Looking for zk leader');
                 vasync.forEachParallel({
-                    inputs: insts,
-                    func: function zkInstStatus(inst, next_) {
+                    inputs: ctx.binderVms,
+                    func: function zkInstStatus(vm, next_) {
+                        ctx.binderIps.push(vm.ip);
                         var c = format(
-                            'echo stat | nc %s 2181 | grep -i "mode"', inst.ip);
+                            'echo stat | nc %s 2181 | grep -i "mode"', vm.ip);
                         common.execPlus({
                             cmd: c,
                             log: opts.log
@@ -109,12 +165,12 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                                 // The command throws an error while ZK is
                                 // transitioning from standalone to cluster
                                 next_(null, {
-                                    instance: inst,
+                                    instance: vm.uuid,
                                     mode: 'transitioning'
                                 });
                             } else {
                                 next_(null, {
-                                    instance: inst,
+                                    instance: vm.uuid,
                                     mode: stdout.trim().replace(/^Mode:\s/, '')
                                 });
                             }
@@ -122,22 +178,36 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                     }
                 }, function (err, res) {
                     if (err) {
-                        return next(err);
+                        next(err);
+                        return;
                     }
 
                     res.successes.filter(function (r) {
                         if (r.mode === 'leader') {
-                            leader = r.instance;
+                            ctx.leader = r.instance;
                         } else if (r.mode === 'standalone') {
-                            leader = r.instance;
-                            standalone = true;
+                            ctx.leader = r.instance;
+                            ctx.standalone = true;
                         } else {
-                            followers.push(r.instance);
+                            ctx.followers.push(r.instance);
                         }
                     });
-
-                    return next();
+                    next();
                 });
+            },
+            /*
+             * Once we know zookeeper roles, we can populate the variables
+             * ctx.leaderInst and ctx.followerInsts appropriately.
+             */
+            function classifyInstances(ctx, next) {
+                insts.forEach(function (ins) {
+                    if (ins.zonename === ctx.leader) {
+                        ctx.leaderInst = ins;
+                    } else {
+                        ctx.followerInsts.push(ins);
+                    }
+                });
+                next();
             }
         ];
 
@@ -177,10 +247,11 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                                 '\tstdout:\n%s\n' +
                                 '\tstderr:\n%s', inst.alias,
                                 argv, err.code, stdout.trim(), stderr.trim());
-                            return next_(new errors.InternalError({
+                            next_(new errors.InternalError({
                                 message: msg,
                                 cause: err
                             }));
+                            return;
                         }
 
                         var expectedDs = sprintf('zones/%s/data',
@@ -193,10 +264,11 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                         }, 'binder vm');
 
                         if (vm.datasets.indexOf(expectedDs) === -1) {
-                            return next_(new errors.UpdateError(format(
+                            next_(new errors.UpdateError(format(
                                 'binder vm %s has no "%s" delegate dataset, ' +
                                 'upgrading it would lose image file data',
                                 vm.uuid, expectedDs)));
+                            return;
                         }
                         next_();
 
@@ -246,12 +318,13 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
 
             // Update everything but leader:
 
-            function reprovisionFollowers(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function reprovisionFollowers(ctx, next) {
+                if (!ctx.HA || !ctx.followers.length) {
+                    next();
+                    return;
                 }
                 vasync.forEachPipeline({
-                    inputs: followers,
+                    inputs: ctx.followerInsts,
                     func: function reprovFollower(inst, next_) {
                         if (inst.image === change.image.uuid) {
                             next_();
@@ -269,12 +342,13 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                 }, next);
             },
 
-            function waitFollowers(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function waitFollowers(ctx, next) {
+                if (!ctx.HA || !ctx.followers.length) {
+                    next();
+                    return;
                 }
                 vasync.forEachPipeline({
-                    inputs: followers,
+                    inputs: ctx.followerInsts,
                     func: function waitFollower(inst, next_) {
                         progress('Wait (sleep) for %s instance %s to come up',
                             change.service.name, inst.zonename);
@@ -283,87 +357,79 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                 }, next);
             },
 
-            function checkAllInstancesJoinedZkCluster(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function checkAllInstancesJoinedZkCluster(ctx, next) {
+                if (!ctx.HA) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk instances to re-join ZK cluster');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkCluster({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function waitForZkClusterOk(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function waitForZkClusterOk(ctx, next) {
+                if (!ctx.HA) {
+                    next();
+                    return;
                 }
                 progress('Waiting for ZK cluster to reach a steady state');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkOk({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function reprovisionLeader(_, next) {
-                if (!leader || leader.image === change.image.uuid) {
+            function reprovisionLeader(ctx, next) {
+                if (!ctx.leader) {
                     next();
                     return;
                 }
                 progress('Updating ZK leader');
                 s.reprovisionRemote({
-                    server: leader.server,
+                    server: ctx.leaderInst.server,
                     img: change.image,
-                    zonename: leader.zonename,
+                    zonename: ctx.leaderInst.zonename,
                     progress: progress,
                     log: opts.log,
                     sdcadm: opts.sdcadm
                 }, next);
             },
 
-            function waitForLeader(_, next) {
-                if (!leader) {
+            function waitForLeader(ctx, next) {
+                if (!ctx.leader) {
                     return next();
                 }
                 progress('Wait (sleep) for %s instance %s to come up',
-                    change.service.name, leader.zonename);
+                    change.service.name, ctx.leader);
                 setTimeout(next, 60 * 1000);
             },
 
-            function checkAgainAllInstancesJoinedZkCluster(_, next) {
-                if (!leader || standalone) {
-                    return next();
+            function checkAgainAllInstancesJoinedZkCluster(ctx, next) {
+                if (!ctx.leader || ctx.standalone) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk leader to re-join ZK cluster');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkCluster({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function waitAgainForZkClusterOk(_, next) {
-                if (!leader || standalone) {
-                    return next();
+            function waitAgainForZkClusterOk(ctx, next) {
+                if (!ctx.leader || ctx.standalone) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk leader to reach a steady state');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkOk({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             }
