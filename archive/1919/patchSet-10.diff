commit 5a18a53988f7c0b302b10a4a9e3b1680dd9d7141 (refs/changes/19/1919/10)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-10-03T16:30:01+02:00 (2 years ago)
    
    TOOLS-1762 sdcadm update binder should determine instances to update before executing the update procedure

diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index 94780c0..ef21044 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -520,13 +520,13 @@ function coordinatePlan(opts, cb) {
         function updateManatees(_, next) {
             var handle = [];
             var remaining = [];
-
+            var errs = [];
             changes.forEach(function (change) {
                 if (change.type === 'update-instance' &&
                     change.service.name === 'manatee') {
-                    return cb(new UsageError(
-                        'Individual update of manatee instances ' +
-                        'is not allowed'));
+                    errs.push(new UpdateError('Individual update of manatee' +
+                        ' instances is not allowed'));
+                    return;
                 }
 
                 if ((change.type === 'update-service' ||
@@ -557,27 +557,42 @@ function coordinatePlan(opts, cb) {
                     changes: handle
                 }));
             }
-            next();
+            var err;
+            if (errs.length) {
+                err = (errs.length === 1 ? errs[0] : new MultiError(errs));
+            }
+            next(err);
         },
 
         function updateBinder(_, next) {
             var handle = [];
             var remaining = [];
+            var errs = [];
             changes.forEach(function (change) {
                 if (change.type === 'update-instance' &&
                     change.service.name === 'binder') {
-                    return cb(new UsageError(
-                        'Individual update of binder instances ' +
-                        'is not allowed'));
-                }
-
-                if ((change.type === 'update-service' ||
+                    if (opts.servers && opts.servers.length &&
+                        opts.servers.indexOf(change.instance.server) === -1) {
+                        errs.push(new UpdateError(format(
+                            'Instance "%s" is not on server(s) "%s"',
+                            change.instance.instance,
+                            opts.servers.join(', '))));
+                    } else {
+                        change.inst = change.instance;
+                        handle.push(change);
+                    }
+                } else if ((change.type === 'update-service' ||
                     change.type === 'rollback-service') &&
                     change.service.name === 'binder')
                 {
                     var svcInsts = instsFromSvcName[change.service.name] || [];
                     if (svcInsts.length && svcInsts.length > 1) {
-                        change.insts = svcInsts;
+                        var chInsts = forceSameImage ? svcInsts :
+                                svcInsts.filter(function (ins) {
+                                    return (ins.image !==
+                                        change.image.uuid);
+                                });
+                        change.insts = chInsts;
                     } else {
                         change.inst = svcInsts[0];
                     }
@@ -594,7 +609,11 @@ function coordinatePlan(opts, cb) {
                     handle.length);
                 procs.push(new UpdateBinderV2({ changes: handle }));
             }
-            next();
+            var err;
+            if (errs.length) {
+                err = (errs.length === 1 ? errs[0] : new MultiError(errs));
+            }
+            next(err);
         },
 
 
diff --git a/lib/procedures/update-binder-v2.js b/lib/procedures/update-binder-v2.js
index 4958d88..c4a54f0 100644
--- a/lib/procedures/update-binder-v2.js
+++ b/lib/procedures/update-binder-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -27,6 +27,7 @@ var s = require('./shared');
  *
  * This is the second replacement for "upgrade-binder.sh" from the
  * incr-upgrade scripts.
+ *
  */
 function UpdateBinderV2(options) {
     assert.arrayOfObject(options.changes, 'options.changes');
@@ -35,27 +36,40 @@ function UpdateBinderV2(options) {
 util.inherits(UpdateBinderV2, Procedure);
 
 UpdateBinderV2.prototype.summarize = function ushiSummarize() {
-    var word = (this.changes[0].type === 'rollback-service') ?
-        'rollback' : 'update';
-    var c0 = this.changes[0];
-    var img = c0.image;
-    var out = [sprintf('%s "%s" service to image %s', word,
-                    c0.service.name, img.uuid),
-                common.indent(sprintf('(%s@%s)', img.name, img.version))];
-    if (c0.insts) {
-        out[0] += ':';
-        out = out.concat(c0.insts.map(function (inst) {
-            if (inst.image === img.uuid) {
-                return common.indent(sprintf(
-                    'instance "%s" (%s) is already at version %s',
-                    inst.zonename, inst.alias, img.version));
-            } else {
-                return common.indent(sprintf('instance "%s" (%s) in server %s',
-                    inst.zonename, inst.alias, inst.server));
+    return this.changes.map(function (ch) {
+        var out;
+        if (ch.type === 'update-instance') {
+            out = [sprintf('update instance "%s" (%s)\n' +
+                        'of service "%s" to image %s\n', ch.inst.instance,
+                        ch.inst.alias, ch.service.name, ch.image.uuid),
+                    common.indent(sprintf('(%s@%s)',
+                        ch.image.name, ch.image.version))];
+        } else {
+            var img = ch.image;
+            var word = (ch.type === 'rollback-service') ?
+                'rollback' : 'update';
+
+            out = [sprintf('%s "%s" service to image %s', word,
+                            ch.service.name, img.uuid),
+                        common.indent(sprintf('(%s@%s)',
+                            img.name, img.version))];
+            if (ch.insts) {
+                out[0] += ':';
+                out = out.concat(ch.insts.map(function (inst) {
+                    if (inst.image === img.uuid) {
+                        return common.indent(sprintf(
+                            'instance "%s" (%s) is already at version %s',
+                            inst.zonename, inst.alias, img.version));
+                    } else {
+                        return common.indent(sprintf(
+                            'instance "%s" (%s) on server %s',
+                            inst.zonename, inst.alias, inst.server));
+                    }
+                }));
             }
-        }));
-    }
-    return out.join('\n');
+        }
+        return out.join('\n');
+    }).join('\n');
 };
 
 UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
@@ -67,40 +81,80 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
     assert.string(opts.wrkDir, 'opts.wrkDir');
     assert.func(cb, 'cb');
     var self = this;
+    var sdcadm = opts.sdcadm;
     var log = opts.log;
     var progress = opts.progress;
     var rollback = opts.plan.rollback ||Â false;
 
     function updateBinder(change, nextSvc) {
         var insts = change.insts || [change.inst];
-        var leader;
-        var standalone = false;
-        var followers = [];
 
         var arg = {
             change: change,
             opts: opts,
             userScript: false,
-            HA: false
+            HA: true,
+            /*
+             * UUIDs of the binder instances with a zookeeper role of followers
+             *
+             */
+            followers: [],
+            /*
+             * UUID of the binder instance with zookeeper role of leader
+             */
+            leader: null,
+            /*
+             * Instance Object. Leader instance, in case that it will be
+             * updated during the current process.
+             */
+            leaderInst: null,
+            /*
+             * Array of Instance Objects. Follower instances that will be
+             * updated. Note that it might not be all of them.
+             */
+            followerInsts: [],
+            /*
+             * Is zookeeper running in standalone mode?
+             */
+            standalone: false
         };
 
-        if (insts && insts.length > 1) {
-            arg.HA = true;
-        }
-
         if (opts.plan.changes.length > 1) {
             progress('');
             progress('--- Updating %s ...', change.service.name);
         }
 
         var funcs = [
-            function findZkLeader(_, next) {
+            /*
+             * Do not rely into instances provided by change, make sure we get
+             * all the binder instances from VMAPI to find ZK leader.
+             */
+            function getAllBinderVms(ctx, next) {
+                progress('Getting Triton\'s binder instances');
+                sdcadm.listInsts({
+                    svcs: ['binder']
+                }, function (instsErr, instances) {
+                    if (instsErr) {
+                        next(instsErr);
+                        return;
+                    }
+                    ctx.allInsts = instances;
+                    next();
+                });
+            },
+            /*
+             * We'll take advantage of this function to fill ctx.binderIps
+             * variable, since we'll need it for several steps below.
+             */
+            function findZkLeader(ctx, next) {
+                ctx.binderIps = [];
                 progress('Looking for zk leader');
                 vasync.forEachParallel({
-                    inputs: insts,
-                    func: function zkInstStatus(inst, next_) {
+                    inputs: ctx.allInsts,
+                    func: function zkInstStatus(vm, next_) {
+                        ctx.binderIps.push(vm.ip);
                         var c = format(
-                            'echo stat | nc %s 2181 | grep -i "mode"', inst.ip);
+                            'echo stat | nc %s 2181 | grep -i "mode"', vm.ip);
                         common.execPlus({
                             cmd: c,
                             log: opts.log
@@ -109,12 +163,12 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                                 // The command throws an error while ZK is
                                 // transitioning from standalone to cluster
                                 next_(null, {
-                                    instance: inst,
+                                    instance: vm.zonename,
                                     mode: 'transitioning'
                                 });
                             } else {
                                 next_(null, {
-                                    instance: inst,
+                                    instance: vm.zonename,
                                     mode: stdout.trim().replace(/^Mode:\s/, '')
                                 });
                             }
@@ -122,22 +176,37 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                     }
                 }, function (err, res) {
                     if (err) {
-                        return next(err);
+                        next(err);
+                        return;
                     }
 
                     res.successes.filter(function (r) {
                         if (r.mode === 'leader') {
-                            leader = r.instance;
+                            ctx.leader = r.instance;
                         } else if (r.mode === 'standalone') {
-                            leader = r.instance;
-                            standalone = true;
+                            ctx.leader = r.instance;
+                            ctx.standalone = true;
+                            ctx.HA = false;
                         } else {
-                            followers.push(r.instance);
+                            ctx.followers.push(r.instance);
                         }
                     });
-
-                    return next();
+                    next();
+                });
+            },
+            /*
+             * Once we know zookeeper roles, we can populate the variables
+             * ctx.leaderInst and ctx.followerInsts appropriately.
+             */
+            function classifyInstances(ctx, next) {
+                insts.forEach(function (ins) {
+                    if (ins.zonename === ctx.leader) {
+                        ctx.leaderInst = ins;
+                    } else {
+                        ctx.followerInsts.push(ins);
+                    }
                 });
+                next();
             }
         ];
 
@@ -177,10 +246,11 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                                 '\tstdout:\n%s\n' +
                                 '\tstderr:\n%s', inst.alias,
                                 argv, err.code, stdout.trim(), stderr.trim());
-                            return next_(new errors.InternalError({
+                            next_(new errors.InternalError({
                                 message: msg,
                                 cause: err
                             }));
+                            return;
                         }
 
                         var expectedDs = sprintf('zones/%s/data',
@@ -193,10 +263,11 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                         }, 'binder vm');
 
                         if (vm.datasets.indexOf(expectedDs) === -1) {
-                            return next_(new errors.UpdateError(format(
+                            next_(new errors.UpdateError(format(
                                 'binder vm %s has no "%s" delegate dataset, ' +
                                 'upgrading it would lose image file data',
                                 vm.uuid, expectedDs)));
+                            return;
                         }
                         next_();
 
@@ -210,11 +281,11 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
         funcs = funcs.concat([
             s.updateSvcUserScript,
 
-            function updateVmsUserScript(_, next) {
+            function updateVmsUserScript(ctx, next) {
                 vasync.forEachParallel({
                     func: function (inst, next_) {
                         s.updateVmUserScriptRemote({
-                            service: change.service,
+                            service: ctx.change.service,
                             progress: progress,
                             zonename: inst.zonename,
                             log: opts.log,
@@ -228,7 +299,7 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
 
             s.updateSapiSvc,
 
-            function installVmsImg(_, next) {
+            function installVmsImg(ctx, next) {
                 // Pipeline, not parallel, just in case we have several
                 // instances on the same server:
                 vasync.forEachPipeline({
@@ -236,7 +307,7 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                     func: function installVmImg(inst, next_) {
                         s.imgadmInstallRemote({
                             progress: progress,
-                            img: change.image,
+                            img: ctx.change.image,
                             log: opts.log,
                             server: inst.server
                         }, next_);
@@ -246,20 +317,17 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
 
             // Update everything but leader:
 
-            function reprovisionFollowers(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function reprovisionFollowers(ctx, next) {
+                if (!ctx.HA || !ctx.followerInsts.length) {
+                    next();
+                    return;
                 }
                 vasync.forEachPipeline({
-                    inputs: followers,
+                    inputs: ctx.followerInsts,
                     func: function reprovFollower(inst, next_) {
-                        if (inst.image === change.image.uuid) {
-                            next_();
-                            return;
-                        }
                         s.reprovisionRemote({
                             server: inst.server,
-                            img: change.image,
+                            img: ctx.change.image,
                             zonename: inst.zonename,
                             progress: progress,
                             log: opts.log,
@@ -269,101 +337,94 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                 }, next);
             },
 
-            function waitFollowers(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function waitFollowers(ctx, next) {
+                if (!ctx.HA || !ctx.followerInsts.length) {
+                    next();
+                    return;
                 }
                 vasync.forEachPipeline({
-                    inputs: followers,
+                    inputs: ctx.followerInsts,
                     func: function waitFollower(inst, next_) {
                         progress('Wait (sleep) for %s instance %s to come up',
-                            change.service.name, inst.zonename);
+                            ctx.change.service.name, inst.zonename);
                         setTimeout(next_, 60 * 1000);
                     }
                 }, next);
             },
 
-            function checkAllInstancesJoinedZkCluster(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function checkAllInstancesJoinedZkCluster(ctx, next) {
+                if (!ctx.HA || !ctx.followerInsts.length) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk instances to re-join ZK cluster');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkCluster({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function waitForZkClusterOk(_, next) {
-                if (!arg.HA) {
-                    return next();
+            function waitForZkClusterOk(ctx, next) {
+                if (!ctx.HA || !ctx.followerInsts.length) {
+                    next();
+                    return;
                 }
                 progress('Waiting for ZK cluster to reach a steady state');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkOk({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function reprovisionLeader(_, next) {
-                if (!leader || leader.image === change.image.uuid) {
+            function reprovisionLeader(ctx, next) {
+                if (!ctx.leaderInst) {
                     next();
                     return;
                 }
                 progress('Updating ZK leader');
                 s.reprovisionRemote({
-                    server: leader.server,
-                    img: change.image,
-                    zonename: leader.zonename,
+                    server: ctx.leaderInst.server,
+                    img: ctx.change.image,
+                    zonename: ctx.leaderInst.zonename,
                     progress: progress,
                     log: opts.log,
                     sdcadm: opts.sdcadm
                 }, next);
             },
 
-            function waitForLeader(_, next) {
-                if (!leader) {
+            function waitForLeader(ctx, next) {
+                if (!ctx.leaderInst) {
                     return next();
                 }
                 progress('Wait (sleep) for %s instance %s to come up',
-                    change.service.name, leader.zonename);
+                    ctx.change.service.name, ctx.leader);
                 setTimeout(next, 60 * 1000);
             },
 
-            function checkAgainAllInstancesJoinedZkCluster(_, next) {
-                if (!leader || standalone) {
-                    return next();
+            function checkAgainAllInstancesJoinedZkCluster(ctx, next) {
+                if (!ctx.leaderInst || ctx.standalone) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk leader to re-join ZK cluster');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkCluster({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             },
 
-            function waitAgainForZkClusterOk(_, next) {
-                if (!leader || standalone) {
-                    return next();
+            function waitAgainForZkClusterOk(ctx, next) {
+                if (!ctx.leaderInst || ctx.standalone) {
+                    next();
+                    return;
                 }
                 progress('Waiting for zk leader to reach a steady state');
-                var ips = insts.map(function (inst) {
-                    return (inst.ip);
-                });
 
                 s.wait4ZkOk({
-                    ips: ips,
+                    ips: ctx.binderIps,
                     log: opts.log
                 }, next);
             }
@@ -375,6 +436,7 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
         inputs: self.changes,
         func: updateBinder
     }, cb);
+
 };
 //---- exports
 
