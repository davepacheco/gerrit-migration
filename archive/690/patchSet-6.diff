From 2559820b45b29d643e29d0b9e9bbf05e28c6e590 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Fri, 30 Sep 2016 23:51:40 +0000
Subject: [PATCH] FWAPI-260 Tag names and values in rules need to be unescaped
 for comparisons

---
 .npmignore          |  10 ++
 README.md           |   8 +-
 lib/index.js        |   2 +
 lib/parser.js       |   4 +-
 lib/rule.js         | 146 ++++++++++++++++++++-----
 package.json        |   7 +-
 src/fwrule.jison    |   3 +-
 test/parser.test.js |  50 +++++++++
 test/rule.test.js   | 256 +++++++++++++++++++++++++++++++++++++++++---
 9 files changed, 432 insertions(+), 54 deletions(-)
 create mode 100644 .npmignore

diff --git a/.npmignore b/.npmignore
new file mode 100644
index 0000000..f0fbb1e
--- /dev/null
+++ b/.npmignore
@@ -0,0 +1,10 @@
+/.gitmodules
+/.npmignore
+/Makefile
+/coverage
+/deps
+/docs
+/etc
+/src
+/test
+/tools
diff --git a/README.md b/README.md
index 69bd8c7..b18535e 100644
--- a/README.md
+++ b/README.md
@@ -19,14 +19,12 @@ in order to use this package.
 After making changes to this repo, repos which depend on it should be updated
 and tested appropriately:
 
-* [sdc-fwapi](https://github.com/joyent/sdc-fwapi) should have the sdc-fwrule
-  Git commit bumped in its `package.json`.
+* [sdc-fwapi](https://github.com/joyent/sdc-fwapi) should have the `fwrule`
+  dependency bumped as needed in its `package.json`. When a new version of the
+  rule language is released, `FWRULE_VERSION` should be bumped as needed.
 * [smartos-live](https://github.com/joyent/smartos-live) contains a copy in
   `src/fw/tools/fwrule` which gets copied into other locations in the repo by
   the `src/fw/tools/bin/rebuild-node-modules` script.
-* [sdc-cn-agent](https://github.com/joyent/sdc-cn-agent) keeps a checked-in copy
-  of fwadm and therefore fwrule in `node\_modules/fw` which should be kept in
-  sync with fwadm.
 * [sdc-firewaller-agent](https://github.com/joyent/sdc-firewaller-agent) keeps a
   checked-in copy of fwadm and therefore fwrule in `deps/fw` which should be
   kept in sync with fwadm.
diff --git a/lib/index.js b/lib/index.js
index 6e17be2..f42f6a9 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -216,6 +216,8 @@ parser.yy.parseError = function parseError(_, details) {
 };
 
 
+parser.yy.tagUnescape = rule.tagUnescape;
+
 
 // --- Exports
 
diff --git a/lib/parser.js b/lib/parser.js
index 4e7b590..f50b0ab 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -522,7 +522,7 @@ case 47:return 63;
 break;
 case 48:return 63;
 break;
-case 49:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 37;
+case 49:yy_.yytext = yy.tagUnescape(yy_.yytext.substr(1,yy_.yyleng-2)); return 37;
 break;
 case 50:return 27;
 break;
@@ -534,7 +534,7 @@ case 53:return 33
 break;
 }
 },
-rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:"(?:(\\)["bfnrt/(\\)]|(\\)u[a-fA-F0-9]{4}|[^"(\\)])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
+rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:"(?:\\["bfnrt/()\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
 conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"inclusive":true}}
 };
 return lexer;
diff --git a/lib/rule.js b/lib/rule.js
index 8bd441c..263f8ef 100644
--- a/lib/rule.js
+++ b/lib/rule.js
@@ -65,19 +65,26 @@ var icmpr = /^icmp6?$/;
 // --- Internal functions
 
 
+/**
+ * Safely check if an object has a property
+ */
+function hasOwnProperty(obj, prop) {
+    return Object.prototype.hasOwnProperty.call(obj, prop);
+}
+
 
 /**
  * Calls callback for all of the firewall target types
  */
 function forEachTarget(obj, callback) {
     DIRECTIONS.forEach(function (dir) {
-        if (!obj.hasOwnProperty(dir)) {
+        if (!hasOwnProperty(obj, dir)) {
             return;
         }
 
         TARGET_TYPES.forEach(function (type) {
             var name = type + 's';
-            if (!obj[dir].hasOwnProperty(name)) {
+            if (!hasOwnProperty(obj[dir], name)) {
                 return;
             }
 
@@ -107,7 +114,7 @@ function icmpTypeSort(types) {
  * Adds a tag to an object
  */
 function addTag(obj, tag, val) {
-    if (!obj.hasOwnProperty(tag)) {
+    if (!hasOwnProperty(obj, tag)) {
         obj[tag] = {};
     }
 
@@ -116,7 +123,7 @@ function addTag(obj, tag, val) {
         return;
     }
 
-    if (!obj[tag].hasOwnProperty('values')) {
+    if (!hasOwnProperty(obj[tag], 'values')) {
         obj[tag].values = {};
     }
 
@@ -130,7 +137,7 @@ function addTag(obj, tag, val) {
 function tagList(obj) {
     var tags = [];
     Object.keys(obj).sort().forEach(function (tag) {
-        if (obj[tag].hasOwnProperty('all')) {
+        if (hasOwnProperty(obj[tag], 'all')) {
             tags.push(tag);
         } else {
             Object.keys(obj[tag].values).sort().forEach(function (val) {
@@ -143,15 +150,96 @@ function tagList(obj) {
 
 
 /**
- * Quotes a string if it contains non-alphanumeric characters
+ * The following characters are allowed to come after an escape, and get
+ * escaped when producing rule text.
+ *
+ * Parentheses don't need to be escaped with newer parsers, but will cause
+ * errors with older parsers which expect them to be escaped. We therefore
+ * always escape them when generating rule text, to make sure we don't
+ * cause issues for older parsers.
  */
-function quote(str) {
-    var WORD_RE = /[^-a-zA-Z0-9_]/;
-    if (str.search(WORD_RE) !== -1) {
-        return '"' + str + '"';
+var escapes = {
+    '"': '"',
+    'b': '\b',
+    'f': '\f',
+    'n': '\n',
+    'r': '\r',
+    't': '\t',
+    '/': '/',
+    '(': '(',
+    ')': ')',
+    '\\': '\\'
+};
+
+
+var unescapes = {};
+Object.keys(escapes).forEach(function (key) {
+    if (key === '/') {
+        return;
     }
 
-    return str;
+    unescapes[escapes[key]] = key;
+});
+
+
+/**
+ * Unescape a string that's been escaped so that it can be used
+ * in a firewall rule.
+ */
+function tagUnescape(ostr) {
+    var nstr = '';
+    var len = ostr.length;
+
+    for (var cur = 0; cur < len; cur += 1) {
+        var val = ostr[cur];
+        if (val === '\\') {
+            var escaped = ostr[cur + 1];
+            if (escaped === 'u') {
+                nstr += String.fromCharCode(
+                    parseInt(ostr.substring(cur + 2, cur + 6), 16));
+                cur += 5;
+            } else if (escapes[escaped] !== undefined) {
+                nstr += escapes[escaped];
+                cur += 1;
+            } else {
+                throw new Error('Invalid escape sequence "\\' + escaped + '"!');
+            }
+        } else {
+            nstr += val;
+        }
+    }
+
+    return nstr;
+}
+
+
+/**
+ * Escape a string so that it can be placed, quoted, into a
+ * firewall rule.
+ */
+function tagEscape(ostr) {
+    var nstr = '';
+    var len = ostr.length;
+
+    for (var cur = 0; cur < len; cur += 1) {
+        var val = ostr[cur];
+        if (unescapes[val] !== undefined) {
+            nstr += '\\' + unescapes[val];
+        } else {
+            nstr += val;
+        }
+    }
+
+    return nstr;
+}
+
+
+/**
+ * Quotes a string in case it contains non-alphanumeric
+ * characters or keywords for firewall rules.
+ */
+function quote(str) {
+    return '"' + tagEscape(str) + '"';
 }
 
 
@@ -184,7 +272,7 @@ function FwRule(data, opts) {
         }
     }
 
-    if (data.hasOwnProperty('uuid')) {
+    if (hasOwnProperty(data, 'uuid')) {
         if (!validators.validateUUID(data.uuid)) {
             errs.push(new validators.InvalidParamError('uuid',
                 'Invalid rule UUID'));
@@ -197,7 +285,7 @@ function FwRule(data, opts) {
 
     this.version = data.version || generateVersion();
 
-    if (data.hasOwnProperty('owner_uuid')) {
+    if (hasOwnProperty(data, 'owner_uuid')) {
         if (!validators.validateUUID(data.owner_uuid)) {
             errs.push(new validators.InvalidParamError('owner_uuid',
                 'Invalid owner UUID'));
@@ -208,7 +296,7 @@ function FwRule(data, opts) {
         this.global = true;
     }
 
-    if (data.hasOwnProperty('enabled')) {
+    if (hasOwnProperty(data, 'enabled')) {
         if (!validators.bool(data.enabled)) {
             errs.push(new validators.InvalidParamError('enabled',
                 'enabled must be true or false'));
@@ -221,7 +309,7 @@ function FwRule(data, opts) {
 
     for (var s in STRING_PROPS) {
         var str = STRING_PROPS[s];
-        if (data.hasOwnProperty(str)) {
+        if (hasOwnProperty(data, str)) {
             try {
                 validators.validateString(str, data[str]);
                 this[str] = data[str];
@@ -232,19 +320,19 @@ function FwRule(data, opts) {
     }
 
     if (opts.enforceGlobal) {
-        if (data.hasOwnProperty('global') && !validators.bool(data.global)) {
+        if (hasOwnProperty(data, 'global') && !validators.bool(data.global)) {
             errs.push(new validators.InvalidParamError('global',
                 'global must be true or false'));
         }
 
-        if (data.hasOwnProperty('global')
-            && data.hasOwnProperty('owner_uuid') && data.global) {
+        if (hasOwnProperty(data, 'global')
+            && hasOwnProperty(data, 'owner_uuid') && data.global) {
             errs.push(new validators.InvalidParamError('global',
                 'cannot specify both global and owner_uuid'));
         }
 
-        if (!data.hasOwnProperty('global')
-            && !data.hasOwnProperty('owner_uuid')) {
+        if (!hasOwnProperty(data, 'global')
+            && !hasOwnProperty(data, 'owner_uuid')) {
             errs.push(new validators.InvalidParamError('owner_uuid',
                 'owner_uuid required'));
         }
@@ -271,8 +359,8 @@ function FwRule(data, opts) {
         this.protoTargets = this.types;
     } else {
         this.ports = parsed.protocol.targets.sort(function (a, b) {
-            var first = a.hasOwnProperty('start') ? a.start : a;
-            var second = b.hasOwnProperty('start') ? b.start : b;
+            var first = hasOwnProperty(a, 'start') ? a.start : a;
+            var second = hasOwnProperty(b, 'start') ? b.start : b;
             return Number(first) - Number(second);
         });
         this.protoTargets = this.ports;
@@ -310,7 +398,7 @@ function FwRule(data, opts) {
             var name = target[0] + 's';
 
             numTargets++;
-            if (!dirs[dir].hasOwnProperty(name)) {
+            if (!hasOwnProperty(dirs[dir], name)) {
                 dirs[dir][name] = {};
             }
 
@@ -345,7 +433,7 @@ function FwRule(data, opts) {
         dir = DIRECTIONS[d];
         for (var t in TARGET_TYPES) {
             var type = TARGET_TYPES[t] + 's';
-            if (dirs[dir].hasOwnProperty(type)) {
+            if (hasOwnProperty(dirs[dir], type)) {
                 if (type === 'tags') {
                     this[dir][type] = tagList(dirs[dir][type]);
 
@@ -432,7 +520,7 @@ FwRule.prototype.raw = function () {
 
     for (var s in STRING_PROPS) {
         var str = STRING_PROPS[s];
-        if (this.hasOwnProperty(str)) {
+        if (hasOwnProperty(this, str)) {
             raw[str] = this[str];
         }
     }
@@ -462,7 +550,7 @@ FwRule.prototype.serialize = function (fields) {
                 ser.global = true;
             }
         } else {
-            if (this.hasOwnProperty(field)) {
+            if (hasOwnProperty(this, field)) {
                 ser[field] = this[field];
             }
         }
@@ -515,8 +603,8 @@ FwRule.prototype.text = function () {
         );
     } else {
         ports = this.ports.map(function (port) {
-            if (port.hasOwnProperty('start')
-                && port.hasOwnProperty('end')) {
+            if (hasOwnProperty(port, 'start')
+                && hasOwnProperty(port, 'end')) {
                 /*
                  * We only output PORTS when we have a range, since we don't
                  * distinguish PORTS 1, 2 from (PORT 1 AND PORT 2) after
@@ -583,6 +671,8 @@ function generateVersion() {
 module.exports = {
     create: createRule,
     generateVersion: generateVersion,
+    tagEscape: tagEscape,
+    tagUnescape: tagUnescape,
     DIRECTIONS: DIRECTIONS,
     FIELDS: FIELDS,
     FwRule: FwRule,
diff --git a/package.json b/package.json
index 3d7542f..c068281 100644
--- a/package.json
+++ b/package.json
@@ -1,8 +1,13 @@
 {
   "name": "fwrule",
   "description": "Parser for Joyent firewall rules",
-  "version": "1.0.0",
+  "version": "1.3.0",
   "author": "Joyent (joyent.com)",
+  "keywords": [ "smartos", "triton" ],
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/sdc-fwrule.git"
+  },
   "dependencies": {
     "node-uuid": "1.2.0",
     "extsprintf": "1.0.1",
diff --git a/src/fwrule.jison b/src/fwrule.jison
index b94118f..cc6140a 100644
--- a/src/fwrule.jison
+++ b/src/fwrule.jison
@@ -30,7 +30,6 @@
 
 digit                   [0-9]
 hex                     [0-9a-f]
-esc                     "\\"
 t                       {digit}{1,3}
 
 %%
@@ -89,7 +88,7 @@ t                       {digit}{1,3}
 "CODE"                  return 'CODE';
 "code"                  return 'CODE';
 
-\"(?:{esc}["bfnrt/{esc}]|{esc}"u"[a-fA-F0-9]{4}|[^"{esc}])*\"  yytext = yytext.substr(1,yyleng-2); return 'STRING';
+\"(?:\\["bfnrt/()\\]|\\"u"[a-fA-F0-9]{4}|[^"\\])*\"  yytext = yy.tagUnescape(yytext.substr(1,yyleng-2)); return 'STRING';
 {t}'.'{t}'.'{t}'.'{t}          return 'IPV4ADDR';
 {hex}*':'{hex}*':'[:0-9a-f]*   return 'IPV6ADDR';
 '/'{digit}{1,3}                return 'CIDRSUFFIX';
diff --git a/test/parser.test.js b/test/parser.test.js
index 2859407..55373eb 100644
--- a/test/parser.test.js
+++ b/test/parser.test.js
@@ -530,6 +530,56 @@ test('Tags: Quoted name and value', function (t) {
 });
 
 
+test('Tags: Escaped characters', function (t) {
+    var ruleTxt = 'FROM (tag "\\"" = "\\)" OR tag "\\n" = "\\b") TO tag "\\(" '
+        + 'BLOCK udp PORT 53';
+
+    t.deepEqual(parser.parse(ruleTxt), {
+        from: [ [ 'tag', [ '"', ')' ] ],
+                [ 'tag', [ '\n', '\b' ] ] ],
+        to: [ [ 'tag', '(' ] ],
+        action: 'block',
+        protocol: {
+            name: 'udp',
+            targets: [ 53 ]
+        }
+    });
+
+    t.end();
+});
+
+
+test('Tags: Parens shouldn\'t have to be escaped', function (t) {
+    var ruleTxt = 'FROM tag "(" = "(" TO tag ")" = ")" '
+        + 'BLOCK udp PORT 53';
+
+    t.deepEqual(parser.parse(ruleTxt), {
+        from: [ [ 'tag', [ '(', '(' ] ] ],
+        to: [ [ 'tag', [ ')', ')' ] ] ],
+        action: 'block',
+        protocol: {
+            name: 'udp',
+            targets: [ 53 ]
+        }
+    });
+
+    t.end();
+});
+
+
+test('Tags: UTF-8 characters can be written using \\u', function (t) {
+    var escapedTxt = 'FROM tag "\\u2603" = "\\u0631\\u062c\\u0644 '
+        + '\\u0627\\u0644\\u062b\\u0644\\u062c" TO tag "\\u26C4" '
+        + 'BLOCK udp PORT 53';
+    var unicodeTxt = 'FROM tag "☃" = "رجل الثلج" TO tag "⛄" '
+        + 'BLOCK udp PORT 53';
+
+    t.deepEqual(parser.parse(escapedTxt), parser.parse(unicodeTxt));
+
+    t.end();
+});
+
+
 test('Tags: Unicode characters', function (t) {
     var ruleTxt = 'FROM (tag "☂" = "ທ" OR '
         + 'tag "삼겹살" = "불고기")'
diff --git a/test/rule.test.js b/test/rule.test.js
index e89bde7..f510945 100644
--- a/test/rule.test.js
+++ b/test/rule.test.js
@@ -32,9 +32,84 @@ var fwrule = require('../lib/index');
 var util = require('util');
 var test = require('tape');
 
+var TAG_TEST =
+    'FROM tag "%s" = "%s" TO tag "%s" = "%s" ALLOW tcp PORT 80';
+var TAG_TEST_UNQUOTED = 'FROM tag %s = %s TO tag %s = %s ALLOW tcp PORT 80';
+
+function testTagInRules(t, unquotedOK, txtIn, txtOut, val) {
+    var desc = util.format('txtIn=%j, txtOut=%j, val=%j', txtIn, txtOut, val);
+    var ruleOut = util.format(TAG_TEST, txtOut, txtOut, txtOut, txtOut);
+    var toParse = [ util.format(TAG_TEST, txtIn, txtIn, txtIn, txtIn) ];
+
+    if (unquotedOK) {
+        toParse.push(
+            util.format(TAG_TEST_UNQUOTED, txtIn, txtIn, txtIn, txtIn));
+    }
+
+    toParse.forEach(function (ruleIn) {
+        var rule = fwrule.create({
+            rule: ruleIn,
+            created_by: 'fwadm',
+            description: desc,
+            enabled: true,
+            version: fwrule.generateVersion()
+        });
+
+        var raw = {
+            from: {
+                ips: [],
+                subnets: [],
+                vms: [],
+                tags: [ [ val, val ] ],
+                wildcards: []
+            },
+            to: {
+                ips: [],
+                subnets: [],
+                vms: [],
+                tags: [ [ val, val ] ],
+                wildcards: []
+            },
+            created_by: 'fwadm',
+            description: desc,
+            enabled: true,
+            ports: [ 80 ],
+            action: 'allow',
+            protocol: 'tcp',
+            uuid: rule.uuid,
+            version: rule.version
+        };
+
+        t.deepEqual(rule.raw(), raw, desc + ': rule.raw()');
+        t.deepEqual(rule.from, raw.from, desc + ': rule.from');
+        t.deepEqual(rule.to, raw.to, desc + ': rule.to');
+        t.ok(!rule.allVMs, desc + ': rule.allVMs');
+
+        var ser = {
+            created_by: 'fwadm',
+            description: desc,
+            enabled: true,
+            global: true,
+            rule: ruleOut,
+            uuid: rule.uuid,
+            version: rule.version
+        };
 
+        t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
+        t.deepEqual(rule.serialize(['enabled', 'version']),
+            { enabled: ser.enabled, version: ser.version },
+            'rule.serialize(): enabled, version');
+    });
+}
 
 
+function checkTagsInRules(t, toCheck) {
+    toCheck.forEach(function (cfg) {
+        testTagInRules(t, cfg.unquotedOK, cfg.in, cfg.out, cfg.val);
+    });
+
+    t.end();
+}
 
 
 // --- Tests
@@ -107,8 +182,8 @@ test('all target types', function (t) {
         description: desc,
         enabled: true,
         global: true,
-        rule: util.format('FROM (ip %s OR subnet %s OR tag %s OR vm %s) '
-            + 'TO (ip %s OR subnet %s OR tag %s OR vm %s) ALLOW tcp PORT 80',
+        rule: util.format('FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) '
+            + 'TO (ip %s OR subnet %s OR tag "%s" OR vm %s) ALLOW tcp PORT 80',
             ips[0], subnets[0], tags[0], vms[0],
             ips[1], subnets[1], tags[1], vms[1]),
         uuid: rule.uuid,
@@ -131,8 +206,8 @@ test('any', function (t) {
     var subnet = '192.168.0.0/16';
 
     var ruleTxt = util.format(
-        'FROM (ip %s OR subnet %s OR tag %s OR vm %s) TO any ALLOW tcp PORT 80',
-        ip, subnet, tag, vm);
+        'FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) TO any'
+        + ' ALLOW tcp PORT 80', ip, subnet, tag, vm);
 
     var rule = fwrule.create({
         rule: ruleTxt,
@@ -270,7 +345,53 @@ test('tags', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: false,
         global: true,
+        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" ALLOW tcp PORT 80',
+        uuid: rule.uuid,
+        version: rule.version
+    }, 'rule.serialize()');
+    t.ok(!rule.allVMs, 'rule.allVMs');
+
+    t.end();
+});
+
+
+test('tag "hasOwnProperty"', function (t) {
+    var ruleTxt = 'FROM ip 1.2.3.4 TO (tag hasOwnProperty OR tag some-tag) '
+        + 'ALLOW tcp PORT 80';
+    var rule = new fwrule.create({
         rule: ruleTxt,
+        version: fwrule.generateVersion()
+    });
+
+    var raw = {
+        action: 'allow',
+        enabled: false,
+        from: {
+            ips: [ '1.2.3.4' ],
+            vms: [],
+            subnets: [],
+            tags: [],
+            wildcards: []
+        },
+        protocol: 'tcp',
+        ports: [ 80 ],
+        to: {
+            ips: [],
+            vms: [],
+            subnets: [],
+            tags: [ 'hasOwnProperty', 'some-tag' ],
+            wildcards: []
+        },
+        uuid: rule.uuid,
+        version: rule.version
+    };
+    t.deepEqual(rule.raw(), raw, 'rule.raw()');
+
+    t.deepEqual(rule.serialize(), {
+        enabled: false,
+        global: true,
+        rule: 'FROM ip 1.2.3.4 TO (tag "hasOwnProperty" OR tag "some-tag") '
+            + 'ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
     }, 'rule.serialize()');
@@ -282,14 +403,14 @@ test('tags', function (t) {
 
 test('multiple ports and owner_uuid', function (t) {
     var inRule1 = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
+        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
             + '(PORT 1002 AND PORT 1052)',
         enabled: true,
         owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
         version: fwrule.generateVersion()
     };
     var inRule2 = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
+        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
             + 'PORTS 1002, 1052',
         enabled: true,
         owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
@@ -662,7 +783,7 @@ test('sorting: ports', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: true,
         global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
+        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
             + '(PORT 6 AND PORT 10 AND PORT 80 AND PORT 1002 AND PORT 1052 '
             + 'AND PORT 30245)',
         uuid: rule.uuid,
@@ -715,7 +836,7 @@ test('sorting: port ranges', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: true,
         global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
+        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
             + 'PORTS 6 - 11, 10, 20 - 40, 80, 1002, 1052, 30245',
         uuid: rule.uuid,
         version: rule.version
@@ -762,7 +883,7 @@ test('single port range', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: true,
         global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
+        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
             + 'PORTS 50 - 50',
         uuid: rule.uuid,
         version: rule.version
@@ -773,8 +894,8 @@ test('single port range', function (t) {
 
 
 test('port ALL', function (t) {
-    var normalText = 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp PORT all';
-    var parenText = 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp ( PORT all )';
+    var normalText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp PORT all';
+    var parenText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp ( PORT all )';
     var ruleTexts = [ normalText, parenText ];
 
     ruleTexts.forEach(function (ruleText) {
@@ -860,7 +981,7 @@ test('tags: equal', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: false,
         global: true,
-        rule: ruleTxt,
+        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" = "value" ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
     }, 'rule.serialize()');
@@ -910,7 +1031,9 @@ test('multiple tags: equal', function (t) {
     t.deepEqual(rule.serialize(), {
         enabled: false,
         global: true,
-        rule: ruleTxt,
+        rule: 'FROM ip 1.2.3.4 TO '
+            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2")'
+            + ' ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
     }, 'rule.serialize()');
@@ -962,8 +1085,8 @@ test('multiple tags: multiple values', function (t) {
         global: true,
         // 'some-tag = value0' is a subset of 'tag some-tag', so it is not
         // included in the rule text
-        rule: 'FROM tag some-tag TO '
-            + '(tag some-tag = value OR tag some-tag = value2) '
+        rule: 'FROM tag "some-tag" TO '
+            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2") '
             + 'ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
@@ -1025,7 +1148,7 @@ test('multiple tags: multiple quoted values', function (t) {
         owner_uuid: owner,
         rule: 'FROM (tag "김치" = "白김치" '
             + 'OR tag "김치" = "백김치") TO '
-            + '(tag "some tag" = value OR tag some-tag = "another value") '
+            + '(tag "some tag" = "value" OR tag "some-tag" = "another value") '
             + 'ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
@@ -1363,3 +1486,104 @@ test('Mixed IPv4 and IPv6', function (t) {
 
     t.end();
 });
+
+
+test('Tag names and values: Normal', function (t) {
+    var tags = [ 'foo', 'foo-bar', 'foo_bar', 'db2', 'foo_bar-baz', '_' ];
+
+    var check = [];
+    tags.forEach(function (tag) {
+        check.push({ unquotedOK: true, in: tag, out: tag, val: tag });
+        var tagUpper = tag.toUpperCase();
+        check.push({
+            unquotedOK: true,
+            in: tagUpper,
+            out: tagUpper,
+            val: tagUpper
+        });
+    });
+
+    checkTagsInRules(t, check);
+});
+
+
+test('Tag names and values: IP addresses and subnets', function (t) {
+    checkTagsInRules(t, [
+        { in: '1.2.3.4', out: '1.2.3.4', val: '1.2.3.4' },
+        { in: '1.2.3.0/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
+        { in: '1.2.3.0\\/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
+        { in: 'fd00::a:b:c:5', out: 'fd00::a:b:c:5', val: 'fd00::a:b:c:5' },
+        { in: 'fc00::/7', out: 'fc00::/7', val: 'fc00::/7' },
+        { in: 'fc00::\\/7', out: 'fc00::/7', val: 'fc00::/7' }
+    ]);
+});
+
+
+test('Tag names and values: Numeric', function (t) {
+    var numbers = [
+        '0', '1', '5', '2000', '1234567890', '987654321', '23', '00000', '0',
+        '01', '10', '111111111'
+    ];
+
+    var check = [];
+    numbers.forEach(function (num) {
+        check.push({ unquotedOK: true, in: num, out: num, val: num });
+    });
+
+    checkTagsInRules(t, check);
+});
+
+
+test('Tag names and values: Keywords', function (t) {
+    var kws = [
+        'tag', 'from', 'to', 'ip', 'subnet', 'vm', 'any', 'all', 'all vms',
+        'vms', 'or', 'and', 'block', 'allow', 'port', 'ports', 'tcp', 'udp',
+        'icmp', 'icmp6', 'type', 'code'
+    ];
+
+    var check = [];
+    kws.forEach(function (kw) {
+        check.push({ in: kw, out: kw, val: kw });
+        var kwUpper = kw.toUpperCase();
+        check.push({ in: kwUpper, out: kwUpper, val: kwUpper });
+    });
+
+    checkTagsInRules(t, check);
+});
+
+
+test('Tag names and values: Escaped characters', function (t) {
+    checkTagsInRules(t, [
+        { val: '\t', in: '\t', out: '\\t' },
+        { val: '\t', in: '\\t', out: '\\t' },
+        { val: '\n', in: '\n', out: '\\n' },
+        { val: '\n', in: '\\n', out: '\\n' },
+        { val: '\b', in: '\b', out: '\\b' },
+        { val: '\b', in: '\\b', out: '\\b' },
+        { val: '\f', in: '\f', out: '\\f' },
+        { val: '\f', in: '\\f', out: '\\f' },
+        { val: '/', in: '/', out: '/' },
+        { val: '/', in: '\\/', out: '/' },
+        { val: '(', in: '(', out: '\\(' },
+        { val: '(', in: '\\(', out: '\\(' },
+        { val: ')', in: ')', out: '\\)' },
+        { val: ')', in: '\\)', out: '\\)' },
+        { val: '"', in: '\\"', out: '\\"' },
+        { val: '\\', in: '\\\\', out: '\\\\' }
+    ]);
+});
+
+
+test('Tag names and values: Odd characters', function (t) {
+    var chars = [
+        '!', '@', '#', '$', '%', '^', '&', '*', ',', '.', '<', '>', '?', ';',
+        ':', '\'', '[', ']', '{', '}', '|', '=', '+', '~', '`', '-', '_'
+    ];
+
+    var check = [];
+    chars.forEach(function (c) {
+        check.push({ in: c, out: c, val: c });
+    });
+
+    checkTagsInRules(t, check);
+});
-- 
2.21.0

