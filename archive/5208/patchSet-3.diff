commit 06e7168f4fb76c2ba9622162178a6b589914ba02 (refs/changes/08/5208/3)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-12-17T14:07:03-08:00 (10 months ago)
    
    joyent/node-cueball#150 the great VError-ification

diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 3637e3b..b768750 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -277,31 +277,36 @@ SocketMgrFSM.prototype.state_connecting = function (S) {
 	});
 
 	S.on(this.sm_socket, 'error', function socketMgrErrorListener(err) {
-		self.sm_lastError = err;
+		self.sm_lastError = new mod_errors.ConnectionError(
+		    self.sm_backend, 'error', 'connect', err);
 		S.gotoState('error');
 		self.sm_log.trace(err, 'emitted error while connecting');
 		self.sm_pool._incrCounter('error-during-connect');
 	});
 	S.on(this.sm_socket, 'connectError', function (err) {
-		self.sm_lastError = err;
+		self.sm_lastError = new mod_errors.ConnectionError(
+		    self.sm_backend, 'connectError', 'connect', err);
 		S.gotoState('error');
 		self.sm_log.trace(err, 'emitted connectError while connecting');
 		self.sm_pool._incrCounter('error-during-connect');
 	});
 	S.on(this.sm_socket, 'close', function () {
-		self.sm_lastError = new mod_errors.ConnectionClosedError(self);
+		self.sm_lastError = new mod_errors.ConnectionClosedError(
+		    self.sm_backend);
 		S.gotoState('error');
 		self.sm_log.trace('closed while connecting');
 		self.sm_pool._incrCounter('close-during-connect');
 	});
 	S.on(this.sm_socket, 'timeout', function () {
-		self.sm_lastError = new mod_errors.ConnectionTimeoutError(self);
+		self.sm_lastError = new mod_errors.ConnectionTimeoutError(
+		    self.sm_backend);
 		S.gotoState('error');
 		self.sm_log.trace('timed out while connecting');
 		self.sm_pool._incrCounter('timeout-during-connect');
 	});
 	S.on(this.sm_socket, 'connectTimeout', function () {
-		self.sm_lastError = new mod_errors.ConnectionTimeoutError(self);
+		self.sm_lastError = new mod_errors.ConnectionTimeoutError(
+		    self.sm_backend);
 		S.gotoState('error');
 		self.sm_log.trace('timed out while connecting');
 		self.sm_pool._incrCounter('timeout-during-connect');
@@ -323,7 +328,8 @@ SocketMgrFSM.prototype.state_connected = function (S) {
 	this.resetBackoff();
 
 	S.on(this.sm_socket, 'error', function socketMgrErrorListener(err) {
-		self.sm_lastError = err;
+		self.sm_lastError = new mod_errors.ConnectionError(
+		    self.sm_backend, 'error', 'operation', err);
 		S.gotoState('error');
 		self.sm_pool._incrCounter('error-while-connected');
 		self.sm_log.trace(err, 'emitted error while connected');
diff --git a/lib/errors.js b/lib/errors.js
index 13da0d5..3a519e7 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -13,80 +13,99 @@ module.exports = {
 	ConnectionClosedError: ConnectionClosedError,
 	PoolFailedError: PoolFailedError,
 	PoolStoppingError: PoolStoppingError,
-	ClaimHandleMisusedError: ClaimHandleMisusedError
+	ClaimHandleMisusedError: ClaimHandleMisusedError,
+	ConnectionError: ConnectionError
 };
 
 const mod_util = require('util');
 const mod_assert = require('assert-plus');
+const mod_verror = require('verror');
+const VError = mod_verror.VError;
 
 function ClaimHandleMisusedError() {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, ClaimHandleMisusedError);
-	this.name = 'ClaimHandleMisusedError';
-	this.message = 'CueBall claim handle used as if it was a ' +
-	    'socket. Check the order and number of arguments in ' +
-	    'your claim callbacks.';
+	var opts = {};
+	opts.constructorOpt = ClaimHandleMisusedError;
+	VError.call(this, opts, 'CueBall claim handle used as if it was a ' +
+	    'socket (Check the order and number of arguments in ' +
+	    'your claim callbacks)');
 }
-mod_util.inherits(ClaimHandleMisusedError, Error);
+mod_util.inherits(ClaimHandleMisusedError, VError);
+ClaimHandleMisusedError.prototype.name = 'ClaimHandleMisusedError';
 
 function ClaimTimeoutError(pool) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, ClaimTimeoutError);
+	var opts = {};
+	opts.constructorOpt = ClaimTimeoutError;
 	this.pool = pool;
-	this.name = 'ClaimTimeoutError';
-	this.message = 'Timed out while waiting for connection in pool ' +
-	    pool.p_uuid + ' (' + pool.p_domain + ')';
+	VError.call(this, opts, 'Timed out while waiting for connection in ' +
+	    'pool %s (%s)', pool.p_uuid, pool.p_domain);
 }
-mod_util.inherits(ClaimTimeoutError, Error);
+mod_util.inherits(ClaimTimeoutError, VError);
+ClaimTimeoutError.prototype.name = 'ClaimTimeoutError';
 
-function NoBackendsError(pool) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, NoBackendsError);
+function NoBackendsError(pool, cause) {
+	var opts = {};
+	opts.constructorOpt = NoBackendsError;
+	opts.cause = cause;
 	this.pool = pool;
-	this.name = 'NoBackendsError';
-	this.message = 'No backends available in pool ' + pool.p_uuid +
-	    ' (' + pool.p_domain + ')';
+	VError.call(this, opts, 'No backends available in pool %s (%s)',
+	    pool.p_uuid, pool.p_domain);
 }
-mod_util.inherits(NoBackendsError, Error);
+mod_util.inherits(NoBackendsError, VError);
+NoBackendsError.prototype.name = 'NoBackendsError';
 
-function PoolFailedError(pool) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, PoolFailedError);
+function PoolFailedError(pool, cause) {
+	var opts = {};
+	opts.constructorOpt = PoolFailedError;
+	opts.cause = cause;
 	this.pool = pool;
-	this.name = 'PoolFailedError';
-	this.message = 'Pool ' + pool.p_uuid + ' (' + pool.p_domain + ') ' +
-	    'has failed and cannot take new requests.';
+	var dead = Object.keys(pool.p_dead).length;
+	var avail = pool.p_keys.length;
+	VError.call(this, opts, 'Pool %s (%s) is in the "failed" state (%d ' +
+	    'of %d backends declared dead)',
+	    pool.p_uuid.split('-')[0], pool.p_domain, dead, avail);
 }
-mod_util.inherits(PoolFailedError, Error);
+mod_util.inherits(PoolFailedError, VError);
+PoolFailedError.prototype.name = 'PoolFailedError';
 
 function PoolStoppingError(pool) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, PoolStoppingError);
+	var opts = {};
+	opts.constructorOpt = PoolStoppingError;
 	this.pool = pool;
-	this.name = 'PoolStoppingError';
-	this.message = 'Pool ' + pool.p_uuid + ' (' + pool.p_domain + ') ' +
-	    'is stopping and cannot take new requests.';
+	VError.call(this, opts, 'Pool %s (%s) is stopping and cannot take ' +
+	    'new requests', pool.p_uuid.split('-')[0], pool.p_domain);
 }
-mod_util.inherits(PoolStoppingError, Error);
+mod_util.inherits(PoolStoppingError, VError);
+PoolStoppingError.prototype.name = 'PoolStoppingError';
 
-function ConnectionTimeoutError(fsm) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, ConnectionTimeoutError);
-	this.fsm = fsm;
-	this.backend = fsm.cf_backend;
-	this.name = 'ConnectionTimeoutError';
-	this.message = 'Connection timed out to backend ' +
-	    JSON.stringify(this.backend);
+function ConnectionError(backend, event, state, cause) {
+	var opts = {};
+	opts.constructorOpt = ConnectionError;
+	opts.cause = cause;
+	this.backend = backend;
+	VError.call(this, opts, 'Connection to backend %s (%s:%d) emitted ' +
+	    '"%s" during %s', backend.name || backend.key, backend.address,
+	    backend.port, event, state);
 }
-mod_util.inherits(ConnectionTimeoutError, Error);
+mod_util.inherits(ConnectionError, VError);
+ConnectionError.prototype.name = 'ConnectionError';
 
-function ConnectionClosedError(fsm) {
-	if (Error.captureStackTrace)
-		Error.captureStackTrace(this, ConnectionClosedError);
-	this.fsm = fsm;
-	this.backend = fsm.cf_backend;
-	this.name = 'ConnectionClosedError';
-	this.message = 'Connection closed unexpectedly to backend ' +
-	    JSON.stringify(this.backend);
+function ConnectionTimeoutError(backend) {
+	var opts = {};
+	opts.constructorOpt = ConnectionTimeoutError;
+	this.backend = backend;
+	VError.call(this, opts, 'Connection timed out to backend %s (%s:%d)',
+	    backend.name || backend.key, backend.address, backend.port);
 }
-mod_util.inherits(ConnectionClosedError, Error);
+mod_util.inherits(ConnectionTimeoutError, VError);
+ConnectionTimeoutError.prototype.name = 'ConnectionTimeoutError';
+
+function ConnectionClosedError(backend) {
+	var opts = {};
+	opts.constructorOpt = ConnectionClosedError;
+	this.backend = backend;
+	VError.call(this, opts, 'Connection closed unexpectedly to backend ' +
+	    '%s (%s:%d)', backend.name || backend.key, backend.address,
+	    backend.port);
+}
+mod_util.inherits(ConnectionClosedError, VError);
+ConnectionClosedError.prototype.name = 'ConnectionClosedError';
diff --git a/lib/pool.js b/lib/pool.js
index effa229..24cae9a 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -21,6 +21,7 @@ const mod_bunyan = require('bunyan');
 const mod_resolver = require('./resolver');
 const mod_uuid = require('uuid');
 const mod_errors = require('./errors');
+const mod_verror = require('verror');
 
 const mod_codel = require('./codel');
 const mod_monitor = require('./pool-monitor');
@@ -323,7 +324,9 @@ CueBallConnectionPool.prototype.state_starting = function (S) {
 	if (this.p_resolver.isInState('failed')) {
 		this.p_log.warn('pre-provided resolver has already failed, ' +
 		    'pool will start up in "failed" state');
-		this.p_lastError = this.p_resolver.getLastError();
+		this.p_lastError = new mod_verror.VError(
+		    this.p_resolver.getLastError(),
+		    'Pool resolver entered state "failed"');
 		S.gotoState('failed');
 		return;
 	}
@@ -332,7 +335,9 @@ CueBallConnectionPool.prototype.state_starting = function (S) {
 		if (state === 'failed') {
 			self.p_log.warn('underlying resolver failed, moving ' +
 			    'pool to "failed" state');
-			self.p_lastError = self.p_resolver.getLastError();
+			self.p_lastError = new mod_verror.VError(
+			    self.p_resolver.getLastError(),
+			    'Pool resolver entered state "failed"');
 			S.gotoState('failed');
 		}
 	});
@@ -393,8 +398,10 @@ CueBallConnectionPool.prototype.state_failed = function (S) {
 	/* Fail all outstanding claims that are waiting for a connection. */
 	while (!this.p_waiters.isEmpty()) {
 		var hdl = this.p_waiters.shift();
-		if (hdl.isInState('waiting'))
-			hdl.fail(new mod_errors.PoolFailedError(self));
+		if (hdl.isInState('waiting')) {
+			hdl.fail(new mod_errors.PoolFailedError(self,
+			    self.p_lastError));
+		}
 	}
 };
 
@@ -891,8 +898,10 @@ CueBallConnectionPool.prototype.claim = function (options, cb) {
 	}
 	if (this.isInState('failed')) {
 		setImmediate(function () {
-			if (!done)
-				cb(new mod_errors.PoolFailedError(self));
+			if (!done) {
+				cb(new mod_errors.PoolFailedError(self,
+				    self.p_lastError));
+			}
 			done = true;
 		});
 		return ({
@@ -942,7 +951,8 @@ CueBallConnectionPool.prototype.claim = function (options, cb) {
 		}
 
 		if (errOnEmpty && self.p_resolver.count() < 1) {
-			var err = new mod_errors.NoBackendsError(self);
+			var err = new mod_errors.NoBackendsError(self,
+			    self.p_resolver.getLastError());
 			handle.fail(err);
 		}
 
diff --git a/lib/resolver.js b/lib/resolver.js
index 62c3c23..aaf13ec 100644
--- a/lib/resolver.js
+++ b/lib/resolver.js
@@ -554,7 +554,8 @@ CueBallDNSResolver.prototype.state_srv_try = function (S) {
 		S.gotoState('aaaa');
 	});
 	S.on(req, 'error', function (err) {
-		self.r_lastError = err;
+		self.r_lastError = new mod_verror.VError(err,
+		    'SRV lookup for "%s" failed', name);
 
 		if (NoRecordsError.isInstance(err) ||
 		    NoNameError.isInstance(err) || err.code === 'NOTIMP') {
@@ -625,7 +626,7 @@ CueBallDNSResolver.prototype.state_srv_error = function (S) {
 			r.delay = r.maxDelay;
 
 	} else {
-		self.r_log.trace({ err: self.r_lastError },
+		self.r_log.trace(self.r_lastError,
 		    'repeated error during SRV resolution for service %s, ' +
 		    'will retry in %d sec', self.r_service, self.r_lastSrvTtl);
 
@@ -809,7 +810,8 @@ CueBallDNSResolver.prototype.state_aaaa_try = function (S) {
 			 */
 			self.r_retry.count = 0;
 		}
-		self.r_lastError = err;
+		self.r_lastError = new mod_verror.VError(err,
+		     'IPv6 (AAAA) lookup failed for "%s"', srv.name);
 		S.gotoState('aaaa_error');
 	});
 	req.send();
@@ -828,7 +830,7 @@ CueBallDNSResolver.prototype.state_aaaa_error = function (S) {
 			r.delay = r.maxDelay;
 
 	} else {
-		self.r_log.trace({ err: self.r_lastError },
+		self.r_log.trace(self.r_lastError,
 		    'repeated error during AAAA resolution for name %s, ' +
 		    'proceeding', self.r_srv.name);
 
@@ -932,7 +934,8 @@ CueBallDNSResolver.prototype.state_a_try = function (S) {
 			 */
 			self.r_retry.count = 0;
 		}
-		self.r_lastError = err;
+		self.r_lastError = new mod_verror.VError(err,
+		    'IPv4 (A) lookup for "%s" failed', srv.name);
 		S.gotoState('a_error');
 	});
 	req.send();
@@ -951,7 +954,7 @@ CueBallDNSResolver.prototype.state_a_error = function (S) {
 			r.delay = r.maxDelay;
 
 	} else {
-		self.r_log.debug({ err: self.r_lastError },
+		self.r_log.debug(self.r_lastError,
 		    'repeated error during A resolution for name %s, ' +
 		    'proceeding', self.r_srv.name);
 
diff --git a/package.json b/package.json
index 35fab39..5ca9f08 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.9.0",
+  "version": "2.10.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/pool.test.js b/test/pool.test.js
index d35ce63..3ae0d39 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -12,6 +12,7 @@ const mod_events = require('events');
 const mod_util = require('util');
 const mod_assert = require('assert-plus');
 const mod_bunyan = require('bunyan');
+const mod_verror = require('verror');
 
 const mod_pool = require('../lib/pool');
 const mod_resolver = require('../lib/resolver');
@@ -513,9 +514,8 @@ mod_tape.test('pool failure', function (t) {
 					t.ok(sawErr);
 					t.notStrictEqual(pool.getLastError(),
 					    undefined);
-					t.strictEqual(
-					    pool.getLastError().message,
-					    'test');
+					t.ok(/ test$/.test(
+					    pool.getLastError().message));
 
 					t.equal(connections.length, 1);
 					summarize();
