From 17d4b84b86071b4737509dfdfc7e893bc3abdaf5 Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Thu, 22 Sep 2016 16:42:44 -0700
Subject: [PATCH] IMGAPI-567 Update stud for OpenSSL 1.0.1t/1.0.2h
 vulnerability fixes Reviewed by: Josh Wilsdon <josh@wilsdon.ca>

---
 CHANGES.md                                    |  50 ++
 Makefile                                      | 108 +--
 README.md                                     |  63 +-
 bin/coal-setup-dc-for-image-mgmt              | 142 ----
 bin/hash-basic-auth-password                  | 115 ---
 bin/imgapi-amon-install                       | 190 -----
 bin/imgapi-external-manta-setup               |   2 +-
 bin/imgapi-manta-setup                        |   2 +-
 bin/imgapi-standalone-backup                  | 152 ++++
 bin/imgapi-standalone-create                  | 263 +++++++
 bin/imgapi-standalone-gen-setup-config        | 204 ++++++
 bin/imgapi-standalone-reprovision             | 239 +++++++
 bin/imgapi-standalone-restore                 | 184 +++++
 bin/imgapi-standalone-status                  | 444 ++++++++++++
 bin/manta-config                              |  59 --
 bin/manta-env                                 |  61 ++
 boot/setup.sh                                 |  15 +-
 boot/standalone/configure.sh                  |  27 +
 boot/standalone/setup.sh                      | 153 ++++
 boot/standalone/user-script                   |  48 ++
 docs/design.md                                | 536 --------------
 docs/index.md                                 | 298 +-------
 docs/operator-guide.md                        | 661 ++++++++++++++++++
 etc/defaults.json                             |   7 +
 etc/imgapi.config.json.in                     |  42 --
 etc/nginx.conf.in                             |  73 --
 .../haproxy.cfg}                              |   4 +-
 etc/standalone/imgapi.config.json.handlebars  |  21 +
 etc/{stud.conf.in => standalone/stud.conf}    |  18 +-
 lib/adm.js                                    |   8 +-
 lib/app.js                                    | 125 ++--
 lib/authkeys.js                               | 300 ++++++++
 lib/config.js                                 | 325 +++++++++
 lib/constants.js                              | 115 +++
 lib/database.js                               |  14 +-
 lib/images.js                                 |  10 +-
 .../migration-001-file-compression.js         | 243 -------
 lib/migrations/migration-002-billing-tags.js  | 237 -------
 lib/migrations/migration-003-tags.js          | 251 -------
 lib/migrations/migration-004-tag-and-tags.js  | 253 -------
 lib/migrations/migration-005-guid.js          | 301 --------
 .../migration-006-cleanup-manta-storage.js    | 243 -------
 lib/migrations/migration-007-ufds-to-moray.js | 353 ----------
 .../migration-008-new-storage-layout.js       | 109 ++-
 .../migration-009-backfill-archive.js         |  66 +-
 .../migration-010-backfill-billing_tags.js    |  66 +-
 .../migration-011-backfill-published_at.js    |  66 +-
 ...migration-012-update-docker-image-uuids.js |  63 +-
 lib/storage.js                                |  42 +-
 main.js                                       | 257 +++----
 package.json                                  |  22 +-
 sapi_manifests/imgapi/manifest.json           |   2 +-
 sapi_manifests/imgapi/template                |  38 +-
 ...{haproxy.xml.in => haproxy-standalone.xml} |  20 +-
 smf/manifests/{imgapi.xml.in => imgapi.xml}   |   6 +-
 smf/manifests/stud-standalone.xml             |  29 +
 test/access.public-test.js                    |   5 +-
 test/admincreateimagefromvm.dc-test.js        |   8 +-
 test/api-versions.public-test.js              |   5 +-
 test/channels.public-test.js                  |   5 +-
 test/imgapi-config-local-dc.json              |  11 +-
 test/imgapi-config-local-public.json          |  21 +-
 test/ping.test.js                             |   5 +-
 test/reload-test-data.sh                      |   7 +-
 test/rm-test-data.sh                          |   6 +-
 test/runtests                                 |  18 +-
 test/sdc-ldap                                 |   6 +-
 tools/beware-rsync-to-images                  |  41 --
 tools/imgapi.config.local-signature-auth.json |  28 -
 tools/migrate-storage-local-to-manta.js       |  24 +-
 tools/standalone/README.md                    |   2 +
 tools/standalone/tritonlogupload.sh           | 183 +++++
 tools/standalone/tritonpostlogrotate.sh       | 135 ++++
 73 files changed, 4097 insertions(+), 4158 deletions(-)
 create mode 100644 CHANGES.md
 delete mode 100755 bin/coal-setup-dc-for-image-mgmt
 delete mode 100755 bin/hash-basic-auth-password
 delete mode 100755 bin/imgapi-amon-install
 create mode 100755 bin/imgapi-standalone-backup
 create mode 100755 bin/imgapi-standalone-create
 create mode 100755 bin/imgapi-standalone-gen-setup-config
 create mode 100755 bin/imgapi-standalone-reprovision
 create mode 100755 bin/imgapi-standalone-restore
 create mode 100755 bin/imgapi-standalone-status
 delete mode 100755 bin/manta-config
 create mode 100755 bin/manta-env
 create mode 100755 boot/standalone/configure.sh
 create mode 100755 boot/standalone/setup.sh
 create mode 100755 boot/standalone/user-script
 delete mode 100644 docs/design.md
 create mode 100644 docs/operator-guide.md
 delete mode 100644 etc/imgapi.config.json.in
 delete mode 100644 etc/nginx.conf.in
 rename etc/{haproxy.cfg.in => standalone/haproxy.cfg} (91%)
 create mode 100644 etc/standalone/imgapi.config.json.handlebars
 rename etc/{stud.conf.in => standalone/stud.conf} (73%)
 create mode 100644 lib/authkeys.js
 create mode 100644 lib/config.js
 create mode 100644 lib/constants.js
 delete mode 100644 lib/migrations/migration-001-file-compression.js
 delete mode 100644 lib/migrations/migration-002-billing-tags.js
 delete mode 100644 lib/migrations/migration-003-tags.js
 delete mode 100644 lib/migrations/migration-004-tag-and-tags.js
 delete mode 100755 lib/migrations/migration-005-guid.js
 delete mode 100644 lib/migrations/migration-006-cleanup-manta-storage.js
 delete mode 100644 lib/migrations/migration-007-ufds-to-moray.js
 rename smf/manifests/{haproxy.xml.in => haproxy-standalone.xml} (63%)
 rename smf/manifests/{imgapi.xml.in => imgapi.xml} (87%)
 create mode 100644 smf/manifests/stud-standalone.xml
 delete mode 100755 tools/beware-rsync-to-images
 delete mode 100644 tools/imgapi.config.local-signature-auth.json
 create mode 100644 tools/standalone/README.md
 create mode 100755 tools/standalone/tritonlogupload.sh
 create mode 100755 tools/standalone/tritonpostlogrotate.sh

diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..e1a7d35
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,50 @@
+# IMGAPI changelog
+
+## 3.0.0
+
+This is a major ver bump because there was a significant re-write of
+deployment/operational details for standalone IMGAPI (see the RFD 40 "M0"
+section, IMGAPI-571, and the added Operator Guide at docs/operator-guide.md).
+The REST API has *not* changed incompatibly.
+
+- Many changes to support stock 'imgapi' image builds being usable for
+  both DC-mode (i.e. a core instance in a Triton DC) and standalone
+  IMGAPI deployments. Some of these affect DC-mode IMGAPI instances as
+  well. Highlights:
+    - The origin image is changing from the venerable sdc-smartos@1.6.3
+      (fd2cc906-8938-11e3-beab-4359c665ac99) to the modern
+      sdc-minimal-multiarch-lts@15.4.1 (18b094b0-eb01-11e5-80c1-175dac7ddf02).
+      This follows plans from RFD 46 to move to origin images based on
+      this. When "triton-origin" images are produced, it is the intent
+      to switch imgapi to use those.
+    - The node version has moved from node 0.10 to 0.12.
+    - "bin/imgapi-standalone-*" scripts are provided for sane deployment,
+      and an Operator Guide was written.
+    - A standalone IMGAPI uses "boot/standalone/*" for booting,
+      "etc/standalone/*" for config, "smf/manifests/*-standalone.xml" for extra
+      services, and "tools/standalone" for extra scripts.
+    - The config file is now always at "/data/imgapi/etc/imgapi.config.json".
+      This is differs from most core Triton instances that render their
+      config file to somewhere under "/opt/smartdc/$name/...". Having
+      it under "/data/imgapi" means it is on the delegate dataset
+      for the instance, which is necessary for standalone deployments.
+      It doesn't hurt DC-mode deployments to have it there.
+    - Some config file changes: "manta" object at the top level (Manta
+      usage by IMGAPI isn't just about image storage), "databaseType"
+      instead of "database.type", "authType" instead of "auth.type",
+      etc. Generally, absolute paths have been removed from the *config*
+      and added to a "lib/constants.js" to simplify code and remove
+      clutter/featuritis from the config.
+- "basic" auth support has been dropped. It hasn't been used for years
+  and need not be supported.
+- Update stud dependency for OpenSSL update (IMGAPI-567). This was mainly
+  facilitated by the origin image update discussed above.
+- "authkeys" refactor for signature auth, including the new `AdminReloadAuthKeys`
+  endpoint (IMGAPI-586). Initial client support for this endpoint was added
+  in IMGAPI-579: `imgapi-cli reload-auth-keys`.
+- Dropped long obsolete, non-working, old migration scripts.
+
+
+## 2.2.0
+
+First version before I started a changelog.
diff --git a/Makefile b/Makefile
index afd93ed..1e5cce7 100644
--- a/Makefile
+++ b/Makefile
@@ -17,31 +17,28 @@
 #
 NAME		:= imgapi
 
-DOC_FILES	 = index.md design.md search.md
+DOC_FILES	 = index.md operator-guide.md search.md
 EXTRA_DOC_DEPS += deps/restdown-brand-remora/.git
 RESTDOWN_FLAGS   = --brand-dir=deps/restdown-brand-remora
 
 JS_FILES	:= $(shell ls *.js) \
 	$(shell find lib test -name '*.js' | grep -v '/tmp/') \
 	bin/imgapi-external-manta-setup \
-	bin/imgapi-manta-setup \
-	bin/hash-basic-auth-password
+	bin/imgapi-manta-setup
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE	 = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSSTYLE_FLAGS	 = -f tools/jsstyle.conf
-SMF_MANIFESTS_IN = smf/manifests/imgapi.xml.in
+SMF_MANIFESTS = $(shell ls smf/manifests/*.xml)
 NODEUNIT	:= ./node_modules/.bin/nodeunit
 CLEAN_FILES += ./node_modules
 
-NODE_PREBUILT_VERSION=v0.10.46
+NODE_PREBUILT_VERSION=v0.12.15
 ifeq ($(shell uname -s),SunOS)
 	NODE_PREBUILT_TAG=zone
-	# Allow building on a SmartOS image other than sdc-smartos@1.6.3.
-	NODE_PREBUILT_IMAGE=fd2cc906-8938-11e3-beab-4359c665ac99
+	# Allow building on other than image sdc-minimal-multiarch-lts@15.4.1.
+	NODE_PREBUILT_IMAGE=18b094b0-eb01-11e5-80c1-175dac7ddf02
 endif
-IMAGES_JOYENT_COM_NODE=/root/opt/node-0.10.45
-UPDATES_JOYENT_COM_NODE=/root/opt/node-0.10.45
 
 
 include ./tools/mk/Makefile.defs
@@ -64,55 +61,18 @@ RELSTAGEDIR       := /tmp/$(STAMP)
 # Targets
 #
 .PHONY: all
-all: $(SMF_MANIFESTS) images.joyent.com-node-hack updates.joyent.com-node-hack docs | $(NODEUNIT) $(REPO_DEPS) sdc-scripts
+all: $(SMF_MANIFESTS) docs | $(NPM_EXEC) $(REPO_DEPS) sdc-scripts
 	$(NPM) install
 
-# Node hack for images.joyent.com and updates.joyent.com
-#
-# Fake out 'Makefile.node_prebuilt.*' by symlinking build/node
-# to the node we want to use. We can't use sdcnode here because
-# of GCC mismatch with current sdcnode builds.
-.PHONY: images.joyent.com-node-hack
-images.joyent.com-node-hack:
-	if [[ -f "$(HOME)/THIS-IS-IMAGES.JOYENT.COM.txt" ]]; then \
-		if [[ ! -d "$(TOP)/build/node" ]]; then \
-			mkdir -p $(TOP)/build; \
-			(cd $(TOP)/build && ln -s $(IMAGES_JOYENT_COM_NODE) node); \
-			touch $(NODE_EXEC); \
-			touch $(NPM_EXEC); \
-		fi; \
-	fi
-.PHONY: updates.joyent.com-node-hack
-updates.joyent.com-node-hack:
-	if [[ -f "$(HOME)/THIS-IS-UPDATES.JOYENT.COM.txt" ]]; then \
-		if [[ ! -d "$(TOP)/build/node" ]]; then \
-			mkdir -p $(TOP)/build; \
-			(cd $(TOP)/build && ln -s $(UPDATES_JOYENT_COM_NODE) node); \
-			touch $(NODE_EXEC); \
-			touch $(NPM_EXEC); \
-		fi; \
-	fi
-
 $(NODEUNIT) node_modules/restify: | $(NPM_EXEC)
 	$(NPM) install
 
-.PHONY: test test-kvm7 test-images.joyent.com
+.PHONY: test
 test: | $(NODEUNIT)
-	./test/runtests -lp  # test local 'public' mode
-	./test/runtests -l   # test local 'dc' mode
-test-kvm7: | $(NODEUNIT)
-	./tools/rsync-to-kvm7
-	./tools/runtests-on-kvm7
-test-images.joyent.com: | $(NODEUNIT)
-	./test/runtests -p -r default
-
-
-.PHONY: test-coal
-COAL=root@10.99.99.7
-test-coal:
-	./tools/rsync-to $(COAL)
-	ssh $(COAL) "/opt/smartdc/bin/sdc-login imgapi /opt/smartdc/imgapi/test/runtests"
-
+	echo "error: standalone test suite is currently broken"
+	exit 1
+	#./test/runtests -lp  # test local 'public' mode
+	#./test/runtests -l   # test local 'dc' mode
 
 # We get the IMGAPI errors table from "lib/errors.js". This should be re-run
 # for "lib/errors.js" changes!
@@ -141,7 +101,7 @@ doc-update-error-table: lib/errors.js | node_modules/restify $(NODE_EXEC)
 	    fs.writeFileSync("docs/index.md", index, enc);'
 	@echo "'docs/index.md' updated"
 
-DOC_CLEAN_FILES = docs/{index,design}.{html,json} \
+DOC_CLEAN_FILES = docs/{index,operator-guide}.{html,json} \
 	build/errors.md \
 	build/docs
 .PHONY: clean-docs
@@ -177,6 +137,7 @@ release: all
 		$(RELSTAGEDIR)/root/opt/smartdc/$(NAME)
 	mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/$(NAME)/tools
 	cp -r \
+		$(TOP)/tools/standalone \
 		$(TOP)/tools/seed-packages \
 		$(TOP)/tools/prepare-image \
 		$(TOP)/tools/get-image-dataset-guid.sh \
@@ -217,47 +178,6 @@ publish: release
 	mkdir -p $(BITS_DIR)/$(NAME)
 	cp $(TOP)/$(RELEASE_TARBALL) $(BITS_DIR)/$(NAME)/$(RELEASE_TARBALL)
 
-.PHONY: deploy-images.joyent.com
-deploy-images.joyent.com:
-	@echo '# Deploy to images.joyent.com. This is a *production* server.'
-	@echo '# Press <Enter> to continue, <Ctrl+C> to cancel.'
-	@read
-	ssh root@images.joyent.com ' \
-		set -x \
-		&& export PATH=$(IMAGES_JOYENT_COM_NODE)/bin:$$PATH \
-		&& which node && node --version && npm --version \
-		&& test ! -d /root/services/imgapi.deploying \
-		&& cd /root/services \
-		&& cp -PR imgapi imgapi.deploying \
-		&& cd /root/services/imgapi.deploying \
-		&& git fetch origin \
-		&& git pull --rebase origin master \
-		&& git submodule update --init \
-		&& PATH=/opt/local/gnu/bin:$$PATH make distclean all \
-		&& mv /root/services/imgapi /root/services/imgapi.`date "+%Y%m%dT%H%M%SZ"` \
-		&& mv /root/services/imgapi.deploying /root/services/imgapi \
-		&& svcadm clear imgapi 2>/dev/null || svcadm restart imgapi'
-
-.PHONY: deploy-updates.joyent.com
-deploy-updates.joyent.com:
-	@echo '# Deploy to updates.joyent.com. This is a *production* server.'
-	@echo '# Press <Enter> to continue, <Ctrl+C> to cancel.'
-	@read
-	ssh root@updates.joyent.com ' \
-		set -x \
-		&& export PATH=$(UPDATES_JOYENT_COM_NODE)/bin:$$PATH \
-		&& test ! -d /root/services/imgapi.deploying \
-		&& cd /root/services \
-		&& cp -PR imgapi imgapi.deploying \
-		&& cd /root/services/imgapi.deploying \
-		&& git fetch origin \
-		&& git pull --rebase origin master \
-		&& git submodule update --init \
-		&& PATH=/opt/local/gnu/bin:$$PATH make distclean all \
-		&& mv /root/services/imgapi /root/services/imgapi.`date "+%Y%m%dT%H%M%SZ"` \
-		&& mv /root/services/imgapi.deploying /root/services/imgapi \
-		&& svcadm clear imgapi 2>/dev/null || svcadm restart imgapi'
-
 .PHONY: devrun
 devrun:
 	node-dev main.js -f etc/imgapi.config.json | bunyan -o short
diff --git a/README.md b/README.md
index eb7e43a..443379c 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright (c) 2016, Joyent, Inc.
+    Copyright 2016 Joyent, Inc.
 -->
 
 # sdc-imgapi
@@ -16,58 +16,53 @@ guidelines](https://github.com/joyent/triton/blob/master/CONTRIBUTING.md) --
 [Triton project](https://github.com/joyent/triton) page.
 
 The Image API (IMGAPI) is the API in each Triton data center for managing
-VM (i.e. KVM and Zones) images.
+instance images. It is also the software behind standalone IMGAPI services
+like <https://images.joyent.com> and <https://updates.joyent.com>.
+
 
 # Development
 
+For an IMGAPI running as part of a Triton DataCenter, please start with a
+[CoaL setup](https://github.com/joyent/triton#getting-started). Then a common
+dev cycle goes something like this:
+
+    # Make local changes:
     git clone git@github.com:joyent/sdc-imgapi.git
     cd sdc-imgapi
-    git submodule update --init
-    make all
-    node main.js [OPTIONS]
-
-
-# Testing
-
-There are two common flavours of IMGAPI server:
+    make
 
-- DC: `config.mode === "dc"` E.g. the IMGAPI in an SDC datacenter.
-- Public: `config.mode === "public"` E.g. <https://images.joyent.com>.
+    # Sync local changes to the "imgapi0" zone in CoaL:
+    ./tools/rsync-to root@10.99.99.7
 
-There are different testing entry points for testing these.
+Note that this has limitations in that binary modules from, say, a Mac
+laptop obviously cannot be sync'd to the SmartOS imgapi0 zone.
 
-1. Test a COAL SDC standup's IMGAPI.:
+* * *
 
-        make test-coal
+For a standalone IMGAPI, see the [Operator Guide](./docs/operator-guide.md)
+for deployment and update details.
 
-2. Test an SDC standup's IMGAPI.
 
-        $ ssh HEADNODE
-        [root@headnode]# IMGAPI_ZONE=$(vmadm lookup -1 alias=imgapi0)
-        [root@headnode]# /zones/$IMGAPI_ZONE/root/opt/smartdc/imgapi/test/runtests
-
-    This will not run in a production system (guard on the
-    '/lib/sdc/.sdc-test-no-production-data' file). It leaves some test data
-    lieing around for faster re-runs of the test suite. You can clean up via:
+# Testing
 
-        [root@headnode]# /zones/$IMGAPI_ZONE/root/opt/smartdc/imgapi/test/runtests -c
+A `mode=dc` IMGAPI's test suite is run as follows:
 
-3. Test public-flavour locally:
+    ssh HEADNODE   # e.g. ssh root@10.99.99.7
 
-        ./test/runtests -p -l
+    # Indicate that this is a non-production DC.
+    touch /lib/sdc/.sdc-test-no-production-data
 
-4. Test the *production* <https://images.joyent.com>:
+    sdc-login -l imgapi
+    /opt/smartdc/imgapi/test/runtests
 
-        ./test/runtests -p
+The test suite leaves some test data lying around for faster re-runs of the
+test suite. You can clean up via:
 
-    To successfully run this, you also need to have the follow env setup
-    (the same env setup for using the `joyent-imgadm` tool):
+    sdc-login -l imgapi /opt/smartdc/imgapi/test/runtests -c
 
-        JOYENT_IMGADM_USER=<username>
-        JOYENT_IMGADM_IDENTITY=<signature-of-configured-key-for-username>
+* * *
 
-    These are required to authenticate with image.joyent.com's HTTP signature
-    auth.
+For standalone IMGAPI instances the test suite is currently broken.
 
 
 # Related Repositories
diff --git a/bin/coal-setup-dc-for-image-mgmt b/bin/coal-setup-dc-for-image-mgmt
deleted file mode 100755
index 808796a..0000000
--- a/bin/coal-setup-dc-for-image-mgmt
+++ /dev/null
@@ -1,142 +0,0 @@
-#!/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-#
-# Setup this COAL DC for custom image management.
-# See step by step at
-# <https://mo.joyent.com/docs/imgapi/master/#use-case-5-user-creates-a-custom-image>.
-#
-
-if [[ -n "$TRACE" ]]; then
-    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-    set -o xtrace
-fi
-set -o errexit
-set -o pipefail
-
-export PATH=/usr/bin:/usr/sbin:/smartdc/bin:/opt/smartdc/bin:/opt/local/bin:/opt/local/sbin:/opt/smartdc/agents/bin
-
-
-
-#---- support stuff
-
-function fatal {
-    echo "$0: fatal error: $*"
-    exit 1
-}
-
-function cleanup {
-    true
-}
-
-function errexit {
-    cleanup
-    [[ $1 -ne 0 ]] || exit 0
-    fatal "error exit status $1"
-}
-
-
-function provision_cloudapi {
-    vmadm lookup -1 alias=cloudapi0 2>/dev/null >/dev/null && return
-    echo "# Provision cloudapi"
-    cat <<EOM | sapiadm provision
-{
-    "service_uuid": "$(sdc-sapi /services?name=cloudapi | json -H 0.uuid)",
-    "params": {
-        "alias": "cloudapi0",
-        "networks": [
-            {
-                "uuid": "$(sdc-napi /networks?name=admin | json -H 0.uuid)"
-            },
-            {
-                "uuid": "$(sdc-napi /networks?name=external | json -H 0.uuid)",
-                "primary": true
-            }
-        ]
-    }
-}
-EOM
-}
-
-function hack_dapi_for_headnode_provisioning {
-    local cnapi_zone=$(vmadm lookup -1 alias=cnapi0)
-    # TODO: don't change if already done
-    echo "# Hack DAPI to allow headnode provisioning"
-    local config_path=/zones/$cnapi_zone/root/opt/smartdc/cnapi/sapi_manifests/cnapi/template
-    sed -e "
-        s:hard-filter-headnode:identity:g;
-        s:hard-filter-min-ram:identity:g;
-        s:hard-filter-min-disk:identity:g;
-        s:hard-filter-min-cpu:identity:g;
-        " $config_path >$config_path.new
-    mv $config_path.new $config_path
-    svcadm -z $cnapi_zone restart config-agent
-}
-
-function add_external_nic_to_some_core_zones {
-    local external_uuid=$(sdc-napi /networks?name=external | json -H 0.uuid)
-
-    for alias in adminui0 imgapi0 amon0 sdc0; do
-        local zone_uuid=$(vmadm lookup -1 alias=$alias)
-        local have_external=$(sdc-vmapi /vms/$zone_uuid \
-            | json -H nics | json -c 'this.nic_tag=="external"' length)
-        if [[ "$have_external" == "0" ]]; then
-            echo "# Add external nic to $alias"
-            sdc-vmapi /vms/$zone_uuid?action=add_nics -X POST -d@- <<EOP | sdc sdc-waitforjob || true
-            {
-                "networks": [{"uuid": "$external_uuid", "primary": true}]
-            }
-EOP
-            echo ""
-            echo "sleep for 30 for zone to reboot"
-            sleep 30  # necessary for when we're rebooting zones hosting this process
-        fi
-    done
-}
-
-function install_base_image {
-    # TODO: Use a local cache to avoid slow downloads.
-    local uuid=2b683a82-a066-11e3-97ab-2faa44701c5a # base 13.4.0
-    sdc-imgadm get $uuid >/dev/null 2>/dev/null && return
-    echo "# Install base image"
-    sdc-imgadm import $uuid -S https://images.joyent.com --skip-owner-check
-}
-
-function imgapi_to_allow_local_custom_images {
-    echo '{"metadata": {"IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM": true}}' \
-        | sapiadm update $(sdc-sapi /services?name=imgapi | json -H 0.uuid)
-}
-
-
-
-#---- mainline
-
-trap 'errexit $?' EXIT
-START=$(date +%s)
-
-echo "# Prepare this COAL DC for custom image management."
-
-[[ $(zonename) == "global" ]] || fatal "must run this from the global zone"
-[[ $(bash /lib/sdc/config.sh -json | json datacenter_name) == "coal" ]] \
-    || fatal "datacenter_name is not COAL, refusing to run"
-
-provision_cloudapi
-hack_dapi_for_headnode_provisioning
-# TODO: how to offer alternative to hook up to remote Manta?
-imgapi_to_allow_local_custom_images
-add_external_nic_to_some_core_zones
-install_base_image
-
-
-
-END=$(date +%s)
-echo "$0 finished in $(($END - $START)) seconds"
-
diff --git a/bin/hash-basic-auth-password b/bin/hash-basic-auth-password
deleted file mode 100755
index f82c9f2..0000000
--- a/bin/hash-basic-auth-password
+++ /dev/null
@@ -1,115 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * Hash (with bcrypt) a password for use in IMGAPI's basic authentication
- * auth.
- *
- * Usage:
- *      $ ./bin/hash-basic-auth-password
- *      Password: <enter password>
- *      &F@JHdls
- *
- * Now enter that password into the 'auth.users' object of your IMGAPI config.
- * E.g.:
- *      {
- *          ...
- *          'auth': {
- *              'type': 'basic',
- *              'users': {
- *                  'joe': '&F@JHdls',
- *                  ...
- *              }
- *          },
- *          ...
- *      }
- */
-
-var path = require('path');
-var bcrypt = require('bcrypt');
-
-
-
-//---- support stuff
-
-/**
- * Get a password from stdin.
- *
- * Adapted from <http://stackoverflow.com/a/10357818/122384>.
- *
- * @param prompt {String} Optional prompt. Default 'Password: '.
- * @param callback {Function} `function (cancelled, password)` where
- *      `cancelled` is true if the user aborted (Ctrl+C).
- *
- * Limitations: Not sure if backspace is handled properly.
- */
-function getPassword(prompt, callback) {
-    if (callback === undefined) {
-        callback = prompt;
-        prompt = undefined;
-    }
-    if (prompt === undefined) {
-        prompt = 'Password: ';
-    }
-    if (prompt) {
-        process.stdout.write(prompt);
-    }
-
-    var stdin = process.stdin;
-    stdin.resume();
-    stdin.setRawMode(true);
-    stdin.resume();
-    stdin.setEncoding('utf8');
-
-    var password = '';
-    stdin.on('data', function (ch) {
-        ch = ch + '';
-
-        switch (ch) {
-        case '\n':
-        case '\r':
-        case '\u0004':
-            // They've finished typing their password
-            process.stdout.write('\n');
-            stdin.setRawMode(false);
-            stdin.pause();
-            callback(false, password);
-            break;
-        case '\u0003':
-            // Ctrl-C
-            callback(true);
-            break;
-        default:
-            // More passsword characters
-            process.stdout.write('*');
-            password += ch;
-            break;
-        }
-    });
-}
-
-
-
-//---- mainline
-
-getPassword(function (cancelled, password) {
-    if (cancelled) {
-        process.exit(1);
-    }
-    bcrypt.hash(password, 10, function (err, hash) {
-        if (err) {
-            console.error('%s: error hashing: %s',
-                path.basename(process.argv[1]), err);
-            process.exit(2);
-        }
-        console.log(hash);
-    });
-});
diff --git a/bin/imgapi-amon-install b/bin/imgapi-amon-install
deleted file mode 100755
index f6f6fc1..0000000
--- a/bin/imgapi-amon-install
+++ /dev/null
@@ -1,190 +0,0 @@
-#!/usr/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-# vi: expandtab sw=4 ts=4
-#
-# Install Amon probes for IMGAPI.
-#
-
-if [[ -n "$TRACE" ]]; then
-    export PS4='${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-    set -o xtrace
-fi
-set -o errexit
-
-
-#---- globals, config
-
-res_status=
-res_body=
-
-AMON_ADMIN_IPS=$(json amon_admin_ips < /var/tmp/metadata.json)
-UFDS_ADMIN_UUID=$(json ufds_admin_uuid < /var/tmp/metadata.json)
-AMON_URL=http://$(echo $AMON_ADMIN_IPS | cut -d, -f1)
-
-
-#---- functions
-
-function fatal {
-    echo "$(basename $0): error: $1"
-    exit 1
-}
-
-# Call the amon master.
-function amon() {
-    local path=$1
-    shift
-    local curl_args="-sS -i -H accept:application/json -H content-type:application/json"
-    local res=$(curl $curl_args --url "$AMON_URL$path" "$@")
-    res_status=$(echo "$res" | head -1 | awk '{print $2}')
-    res_body=$(echo "$res" | json -Hq)
-}
-
-function putprobe() {
-    local account=$1
-    local payload=$2
-    local pname=$(echo "$payload" | json name)
-    if [[ -z "$pname" ]]; then
-        fatal "No 'name' for probe: $payload"
-    fi
-    amon /pub/$account/probes
-    local probe_uuid=$(echo "$res_body" | json -H -c "this.name == '$pname'" -a uuid)
-    if [[ "$res_status" != "200" ]]; then
-        fatal "Error looking for probe '$pname': $res_status $res_body"
-    elif [[ -n "$probe_uuid" ]]; then
-        echo "Probe '$pname' already exists: $probe_uuid"
-    else
-        echo "Create probe '$pname'."
-        amon /pub/$account/probes -X POST -f --data "$payload"
-    fi
-}
-
-
-
-#---- mainline
-
-zonename=$(zonename)
-account=$UFDS_ADMIN_UUID
-
-# Sanity check that amon-master is up.
-amon /ping -f || fatal "amon-master ping failed: $res_status $res_body"
-
-# We'll create a single probe group for this imgapi zone.
-# It would be nice to name it after the zone *alias*, but
-# we'd need to depend on VMAPI to get that: overkill.
-group_name=imgapi-$zonename
-amon /pub/$account/probegroups
-group_uuid=$(echo "$res_body" | json -H -c "this.name == '$group_name'" -a uuid)
-if [[ "$res_status" != "200" ]]; then
-    fatal "Error looking for '$group_name' probe group: $res_status $res_body"
-elif [[ -n "$group_uuid" ]]; then
-    echo "Probe group '$group_name' already exists: $group_uuid"
-else
-    echo "Create probe group '$group_name'."
-    amon /pub/$account/probegroups -X POST -f -d "{
-      \"name\": \"$group_name\",
-      \"contacts\": [\"email\"]
-    }"
-    group_uuid=$(echo "$res_body" | json -H uuid)
-fi
-
-
-# Probe: Monitor the zone going down/up.
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi zone up\",
-    \"type\": \"machine-up\",
-    \"agent\": \"$zonename\"
-}"
-
-
-# Probe: Monitor FATALs in the imgapi service log.
-# TODO: It is silly to have three probes for this. Amon should support
-# rolling these up.
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi log fatal\",
-    \"type\": \"bunyan-log-scan\",
-    \"agent\": \"$zonename\",
-    \"config\": {
-        \"smfServiceName\": \"imgapi\",
-        \"fields\": {
-            \"level\": \"fatal\"
-        }
-    }
-}"
-
-# Probe: Monitor ERRORs in the imgapi service log.
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi log error\",
-    \"type\": \"bunyan-log-scan\",
-    \"agent\": \"$zonename\",
-    \"config\": {
-        \"smfServiceName\": \"imgapi\",
-        \"fields\": {
-            \"level\": \"error\"
-        }
-    }
-}"
-
-# Probe: Monitor WARNs in the imgapi service log.
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi log warn\",
-    \"type\": \"bunyan-log-scan\",
-    \"agent\": \"$zonename\",
-    \"config\": {
-        \"smfServiceName\": \"imgapi\",
-        \"fields\": {
-            \"level\": \"warn\"
-        }
-    }
-}"
-
-# Probe: Monitor the imgapi service stopping.
-# TODO: use an smf probe type when available.
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi service stopped\",
-    \"type\": \"log-scan\",
-    \"agent\": \"$zonename\",
-    \"config\": {
-        \"smfServiceName\": \"imgapi\",
-        \"match\": {
-            \"pattern\": \"Stopping because\"
-        }
-    }
-}"
-
-# Probe: Monitor failres of images being created. This will detect when an
-# image's state is  being update with an error message
-putprobe $account "{
-    \"skipauthz\": true,
-    \"group\": \"$group_uuid\",
-    \"name\": \"imgapi image creation failure\",
-    \"type\": \"bunyan-log-scan\",
-    \"agent\": \"$zonename\",
-    \"config\": {
-        \"smfServiceName\": \"imgapi\",
-        \"fields\": {
-            \"route\": \"updateimage\"
-        },
-        \"match\": {
-            \"pattern\": \"error\"
-        }
-    }
-}"
diff --git a/bin/imgapi-external-manta-setup b/bin/imgapi-external-manta-setup
index 798fc19..fad5875 100755
--- a/bin/imgapi-external-manta-setup
+++ b/bin/imgapi-external-manta-setup
@@ -93,7 +93,7 @@ var OPTIONS = [
 ];
 
 
-var config = require('../etc/imgapi.config.json');
+var config = require('/data/imgapi/etc/imgapi.config.json');
 
 
 
diff --git a/bin/imgapi-manta-setup b/bin/imgapi-manta-setup
index f656fc6..cf4f5b6 100755
--- a/bin/imgapi-manta-setup
+++ b/bin/imgapi-manta-setup
@@ -101,7 +101,7 @@ var OPTIONS = [
 ];
 
 
-var CONFIG = require('../etc/imgapi.config.json');
+var CONFIG = require('/data/imgapi/etc/imgapi.config.json');
 
 
 
diff --git a/bin/imgapi-standalone-backup b/bin/imgapi-standalone-backup
new file mode 100755
index 0000000..26c34d4
--- /dev/null
+++ b/bin/imgapi-standalone-backup
@@ -0,0 +1,152 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Backup local IMGAPI data to Manta.
+#
+# This is typically run hourly in cron (see "./setup.sh" for cron entries).
+#
+# Note that "local IMGAPI data" isn't *all* IMGAPI data. For example, with
+# "manta" in "config.storageTypes", some or all image files might be stored
+# in Manta. This backup will backup the other bits, to
+#       ${manta.rootDir}/backup/...
+#
+# Coordinating backup and restore: One bad scenario would be for a new
+# instance, which hasn't yet restored data from backup, to run this script and
+# wipe the backup in Manta. To guard against that, this script will fail unless
+# `imgapi-standalone-restore` has been successfully run. That is noted by the
+# "/data/imgapi/run/restored.marker" file.
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+# ---- globals and config
+
+export PATH=/opt/smartdc/imgapi/build/node/bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin
+
+MANTASYNC=/opt/smartdc/imgapi/node_modules/.bin/manta-sync
+CONFIG=/data/imgapi/etc/imgapi.config.json
+RESTORED_MARKER=/data/imgapi/run/restored.marker
+BACKUP_STATUS=/data/imgapi/run/backup.status
+
+
+# ---- support functions
+
+function usage () {
+    echo "Usage:"
+    echo "  imgapi-standalone-backup [OPTIONS]"
+    echo ""
+    echo "Options:"
+    echo "  -h          Show this help and exit."
+    echo "  -y          Skip the confirmation before backing up."
+}
+
+function fatal
+{
+    echo "$0: fatal error: $*" >&2
+    exit 1
+}
+
+function onexit
+{
+    mkdir -p $(dirname $BACKUP_STATUS)
+    echo "$1" > $BACKUP_STATUS
+
+    [[ $1 -ne 0 ]] || exit 0
+    echo "$0: error exit status $1"
+    exit $1
+}
+
+
+#---- mainline
+
+optYes=no
+while getopts "hy" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        y)
+            optYes=yes
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+# Bail if haven't run restore yet.
+if [[ ! -f $RESTORED_MARKER ]]; then
+    fatal "cannot run backup, because 'imgapi-standalone-restore' has not run"
+fi
+
+config="$(node /opt/smartdc/imgapi/lib/config.js)"
+
+# Guard that this is run only in a standalone IMGAPI.
+mode=$(echo "$config" | json mode)
+if [[ $mode == "dc" ]]; then
+    fatal "cannot run in a 'mode=dc' IMGAPI instance"
+fi
+
+# Get manta info from config
+export MANTA_URL=$(echo "$config" | json manta.url)
+[[ -n "$MANTA_URL" ]] || fatal "not configured to use Manta: no 'manta.url' in config"
+export MANTA_USER=$(echo "$config" | json manta.user)
+[[ -n "$MANTA_USER" ]] || fatal "not configured to use Manta: no 'manta.user' in config"
+# Current manta-sync doesn't support the newer KEY_ID's, so we'll rebuild it
+# from the key path.
+mantaKeyPath=$(echo "$config" | json manta.key)
+[[ -n "$mantaKeyPath" ]] || fatal "not configured to use Manta: no 'manta.key' in config"
+export MANTA_KEY_ID=$(ssh-keygen -E md5 -lf $mantaKeyPath | awk '{print $2}' | cut -c5-)
+if [[ "$(echo "$config" | json manta.insecure)" == "true" ]]; then
+    export MANTA_TLS_INSECURE=1
+fi
+bakDir=$(echo "$config" | json manta.rootDir)/backup
+
+echo "[$(date '+%Y%m%dT%H%M%S')] Backup local IMGAPI data to Manta:"
+echo "              local: /data/imgapi/{images,manifests}"
+echo "  backup (in Manta): $bakDir/{images,manifests}"
+echo ""
+if [[ $optYes != "yes" ]]; then
+    echo "Hit enter to continue / Ctrl+C to abort."
+    read
+fi
+
+trap 'onexit $?' EXIT
+
+startTimeSec=$(date -u +%s)
+startTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+echo $MANTASYNC --delete /data/imgapi/images $bakDir/images
+$MANTASYNC --delete /data/imgapi/images $bakDir/images \
+    | (grep -v "size same as source file, skipping" || true)
+echo $MANTASYNC --delete /data/imgapi/manifests $bakDir/manifests
+$MANTASYNC --delete /data/imgapi/manifests $bakDir/manifests \
+    | (grep -v "size same as source file, skipping" || true)
+
+endTimeSec=$(date -u +%s)
+endTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+echo ""
+echo "Successfully backed up local IMGAPI data to Manta"
+echo "   started: $startTimestamp"
+echo "  finished: $endTimestamp"
+echo "   elapsed: $(( $endTimeSec - $startTimeSec ))s"
+
+#
+# vim: set softtabstop=4 shiftwidth=4:
+#
diff --git a/bin/imgapi-standalone-create b/bin/imgapi-standalone-create
new file mode 100755
index 0000000..e6f3b49
--- /dev/null
+++ b/bin/imgapi-standalone-create
@@ -0,0 +1,263 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Provision a standalone IMGAPI instance.
+#
+# This is meant to be run from the headnode GZ. See notes in
+# "docs/operator-guide.md".
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+PATH=/usr/bin:/usr/sbin:/smartdc/bin:/opt/smartdc/bin:/opt/local/bin:/opt/local/sbin
+
+#---- support stuff
+
+function usage () {
+    echo "Usage:"
+    echo "  imgapi-standalone-create [OPTIONS] OWNER IMAGE PACKAGE ALIAS"
+    echo ""
+    echo "Options:"
+    echo "  -h          Show this help and exit."
+    echo "  -C CHANNEL  Updates channel in which to look for the given IMAGE."
+    echo "  -m KEY=VAL  Setup config var to add to metadata (used by initial "
+    echo "              setup to configure IMGAPI)."
+    echo "  -t TAG=VAL  Tag to add to created instance."
+    echo ""
+    echo "Where OWNER is an account UUID or login; IMAGE is an 'imgapi' image"
+    echo "UUID or 'latest' to get the latest from the current (or given) "
+    echo "channel of updates.joyent.com; PACKAGE is a package UUID or name; and"
+    echo "ALIAS is an alias for the new instance (try to avoid '.' so the name"
+    echo "will work as part of a DNS name)."
+    echo ""
+    echo "Examples:"
+    echo ""
+    echo "- First you'll need to get the create script to your headnode GZ:"
+    echo "    cd /var/tmp && curl -O https://raw.githubusercontent.com/joyent/sdc-imgapi/IMGAPI-567/bin/imgapi-standalone-create"
+    echo ""
+    echo "- A play IMGAPI in COAL using a local 'trentm' COAL account and"
+    echo "  /trent.mick/stor/tmp/images in Manta:"
+    echo "    /var/tmp/imgapi-standalone-create -C experimental \\"
+    echo "        -m mantaUrl=https://us-east.manta.joyent.com \\"
+    echo "        -m mantaUser=trent.mick -m mantaBaseDir=tmp/images \\"
+    echo "        trentm latest sample-2G img0"
+    echo ""
+
+}
+
+function fatal {
+    echo "$0: fatal error: $*"
+    exit 1
+}
+
+function errexit {
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+[[ $(zonename) == "global" ]] || fatal "must run this from the global zone"
+
+optChannel=
+optMetadata="{}"
+optTags="{}"
+while getopts "hC:m:t:" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        C)
+            optChannel=$OPTARG
+            ;;
+        m)
+            arg=$OPTARG
+            k="${OPTARG%%=*}"
+            v="${OPTARG#*=}"
+            optMetadata=$(echo "$optMetadata" | json -e "this.$k = '$v'")
+            ;;
+        t)
+            arg=$OPTARG
+            k="${OPTARG%%=*}"
+            v="${OPTARG#*=}"
+            optTags=$(echo "$optTags" | json -e "this['$k'] = '$v'")
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+OWNER=$1
+[[ -n $OWNER ]] || fatal 'no OWNER arg given'
+IMAGE=$2
+[[ -n $IMAGE ]] || fatal 'no IMAGE arg given'
+PACKAGE=$3
+[[ -n $PACKAGE ]] || fatal 'no PACKAGE arg given'
+ALIAS=$4
+[[ -n $ALIAS ]] || fatal 'no ALIAS arg given'
+
+echo "Looking up owner $OWNER"
+ownerJson=$(sdc-useradm get $OWNER)
+ownerUuid=$(echo "$ownerJson" | json uuid)
+ownerLogin=$(echo "$ownerJson" | json login)
+
+echo "Looking up package $PACKAGE"
+packageJson=$(sdc-papi /packages?active=true \
+    | json -c "this.name==='$PACKAGE' || this.uuid==='$PACKAGE'" -H 0)
+[[ -n "$packageJson" ]] || fatal "could not find package '$PACKAGE'"
+packageUuid=$(echo "$packageJson" | json uuid)
+packageName=$(echo "$packageJson" | json name)
+
+if [[ -n "$optChannel" ]]; then
+    channel=$optChannel
+else
+    channel=$(sdcadm channel get)
+fi
+if [[ "$IMAGE" == "latest" ]]; then
+    echo "Finding latest imgapi image (in '$channel' channel) on updates.jo"
+    imageUuid=$(updates-imgadm -C $channel list name=imgapi --latest -H -o uuid)
+    [[ -n "$imageUuid" ]] || fatal "no imgapi image in $channel change"
+else
+    imageUuid=$IMAGE
+fi
+imageJson=$(sdc-imgadm get $imageUuid 2>/dev/null || true)
+if [[ -z "$imageJson" ]]; then
+    echo "Importing image $imageUuid from updates.jo"
+    sdc-imgadm import $imageUuid -S https://updates.joyent.com?channel=$channel
+    imageJson=$(sdc-imgadm get $imageUuid)
+else
+    echo "Already have image $imageUuid in local IMGAPI"
+fi
+imageName=$(echo "$imageJson" | json name)
+[[ "$imageName" == "imgapi" ]] \
+    || fatal "image $imageUuid is name=$imageName (expected 'name=imgapi')"
+imageVersion=$(echo "$imageJson" | json version)
+
+# Ensure OWNER is on image ACL.
+onAcl=$(echo "$imageJson" | json acl | json -a | (grep $ownerUuid || true))
+if [[ -z "$onAcl" ]]; then
+    echo "Adding owner ($ownerUuid) to image ACL"
+    sdc-imgadm add-acl $imageUuid $ownerUuid
+else
+    echo "Owner ($ownerUuid) is already on the image ACL"
+fi
+
+# Network
+echo "Find a suitable external network"
+networkPoolJson=$(sdc-napi /network_pools?provisionable_by=$ownerUuid | json -Hc 'this.nic_tag==="external"' 0)
+if [[ -z "$networkPoolJson" ]]; then
+    networkJson=$(sdc-napi /networks?provisionable_by=$ownerUuid\&fabric=false | json -Hc 'this.nic_tag==="external"' 0)
+    [[ -n "$networkJson" ]] || fatal "could not find a suitable network"
+    netJson="$networkJson"
+else
+    netJson="$networkPoolJson"
+fi
+netUuid=$(echo "$netJson" | json uuid)
+netName=$(echo "$netJson" | json name)
+
+# Create the VM
+vmUuid=$(uuid)
+optMetadata=$(echo "$optMetadata" \
+    | json -e "this['user-script'] = '/opt/smartdc/boot/standalone/user-script'")
+echo ""
+echo "Creating standalone imgapi VM:"
+echo "       uuid: $vmUuid"
+echo "      alias: $ALIAS"
+echo "      owner: $ownerUuid ($ownerLogin)"
+echo "      image: $imageUuid ($imageName@$imageVersion)"
+echo "    package: $packageUuid ($packageName)"
+echo "    network: $netUuid ($netName)"
+echo "       tags: $(echo "$optTags" | json -o json-0)"
+echo "   metadata:"
+echo "$optMetadata" | sed  's/^/        /'
+echo ""
+sdc-vmapi /vms -X POST -d@- <<EOP | json -H | sdc-waitforjob
+{
+    "uuid": "$vmUuid",
+    "alias": "$ALIAS",
+    "owner_uuid": "$ownerUuid",
+    "billing_id": "$packageUuid",
+    "networks": [{"uuid": "$netUuid"}],
+    "brand": "joyent",
+    "image_uuid": "$imageUuid",
+    "delegate_dataset": true,
+    "tags": $optTags,
+    "customer_metadata": $optMetadata
+}
+EOP
+
+# ^^^ does that exit non-zero on job failure? It would be nice.
+
+# Poll until get a 200 status ping (give it up to 2 minutes)
+echo ""
+echo "Waiting for IMGAPI service ping to respond with a 200"
+MAX_TRIES=40
+instIp=$(sdc-vmadm get $vmUuid | json nics | json -c 'this.primary' 0.ip)
+[[ -n $instIp ]] || fatal "could not determine VM $vmUuid primary IP"
+nTries=0
+pingResponse=
+pingStatus=
+while [[ nTries -lt $MAX_TRIES ]]; do
+    sleep 3
+    echo -n '.'
+    pingResponse=$(curl -ski --connect-timeout 2 --max-time 5 https://$instIp/ping || true)
+    pingStatus=$(echo "$pingResponse" | head -1 | awk '{print $2}')
+    if [[ $pingStatus == "200" ]]; then
+        break
+    fi
+    nTries=$(( $nTries + 1 ))
+done
+if [[ $pingStatus != "200" ]]; then
+    fatal "timeout waiting for IMGAPI ping to respond with 200:
+--
+$pingResponse
+--"
+fi
+echo ""
+
+mantaUser=$(echo "$optMetadata" | json mantaUser)
+if [[ -n "$mantaUser" ]]; then
+    # Configured for Manta: show the command needed to get the imgapi instance
+    # key on the user.
+    echo ""
+    echo "* * *"
+    echo "For this IMGAPI instance to talk to Manta, its instance SSH key"
+    echo "needs to be added to the '$mantaUser' account. If the Manta being"
+    echo "used is part of this Triton cloud, then this should work:"
+    echo ""
+    echo "    sdc-vmadm get $vmUuid \\"
+    echo "        | json customer_metadata.instPubKey > /tmp/imgapi.id_rsa.pub"
+    echo "    keyname=\$(cat /tmp/imgapi.id_rsa.pub | head -1 | awk '{print \$3}')"
+    echo "    sdc-useradm add-key -n \$keyname $mantaUser /tmp/imgapi.id_rsa.pub"
+    echo ""
+    echo "If the Manta is part of a separate cloud then, for an appropriate"
+    echo "Triton CLI profile, the following might work:"
+    echo ""
+    echo "    triton inst get $ALIAS | json metadata.instPubKey \\"
+    echo "        | triton -p PROFILE key add -"
+    echo "* * *"
+fi
+
+# TODO: Would like to have ping be 503 if cannot connect to Manta (if
+# configured for Manta. Then have this script gracefully handle that.
+
+exit 0
diff --git a/bin/imgapi-standalone-gen-setup-config b/bin/imgapi-standalone-gen-setup-config
new file mode 100755
index 0000000..7fe57d9
--- /dev/null
+++ b/bin/imgapi-standalone-gen-setup-config
@@ -0,0 +1,204 @@
+#!/opt/smartdc/imgapi/build/node/bin/node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * Generate config for a standalone IMGAPI setup.
+ *
+ * Usage (from within a standalone IMGAPI zone):
+ *      imgapi-standalone-gen-setup-config >/data/imgapi/etc/imgapi.config.json
+ *
+ * This will emit JSON content on stdout that is suitable for a standalone
+ * IMGAPI config file. It comes from rendering
+ * "etc/standalone/imgapi.config.json.handlebars" with "setup config vars"
+ * from the instance's metadata (i.e. from `mdata-get`). Typically the setup
+ * config vars are given as arguments to `imgapi-standalone-create`, e.g.
+ *
+ *      /opt/smartdc/imgapi/bin/imgapi-standalone-create \
+ *          -m mode=public -m serverName="Joyent Public Images Repo" \
+ *          ...
+ */
+
+var assert = require('assert-plus');
+var forkExecWait = require('forkexec').forkExecWait;
+var fs = require('fs');
+var handlebars = require('handlebars');
+var path = require('path');
+var sshpk = require('sshpk');
+var vasync = require('vasync');
+var VError = require('verror').VError;
+
+
+//---- globals
+
+var NAME = path.basename(__filename);
+
+var topDir = path.resolve(__dirname, '..');
+var templatePath = path.resolve(topDir, 'etc', 'standalone',
+        'imgapi.config.json.handlebars');
+
+var setupConfigVars = [
+    'mode',
+    'serverName',
+    'mantaUrl',
+    'mantaUser',
+    'mantaBaseDir',
+
+    // Not really a setup config var. It is set by setup.sh rather than being
+    // a var that can be passed in via instance metadata at creation time.
+    'instPubKey'
+];
+
+
+//---- internal support stuff
+
+function forkExecWaitAndLog(opts, cb) {
+    assert.arrayOfString(opts.argv, 'opts.argv');
+    assert.object(opts.log, 'opts.log');
+    forkExecWait({argv: opts.argv}, function (err, info) {
+        opts.log.trace({argv: opts.argv, err: err, info: info}, 'forkExecWait');
+        cb(err, info);
+    });
+}
+
+/*
+ * Get a metadata key, with a default. I.e. it is not an error if the key
+ * is not found (`mdata-get` exits with status=1 for that case).
+ */
+function mdataGet(key, def, cb) {
+    assert.string(key, 'key');
+    assert.func(cb, 'cb');
+
+    var KEY_NOT_FOUND_STATUS = 1;
+
+    var argv = ['/usr/sbin/mdata-get', key];
+    forkExecWait({argv: argv}, function (err, info) {
+        if (err) {
+            if (info.status === KEY_NOT_FOUND_STATUS) {
+                cb(null, def);
+            } else {
+                cb(err);
+            }
+        } else {
+            // `mdata-get` appends a single '\n'. Drop it.
+            assert.ok(info.stdout.length > 0);
+            assert.equal(info.stdout[info.stdout.length - 1], '\n');
+            var val = info.stdout.slice(0, -1);
+            cb(null, val);
+        }
+    });
+}
+
+function mainFinish(err) {
+    if (err) {
+        var exitStatus = err.exitStatus || 1;
+        console.error('%s: error: %s', NAME, err.stack);
+
+        // Use a soft exit (i.e. just set `process.exitCode`) if supported.
+        var supportsProcessExitCode = true;
+        var nodeVer = process.versions.node.split('.').map(Number);
+        if (nodeVer[0] === 0 && nodeVer[1] <= 10) {
+            supportsProcessExitCode = false;
+        }
+        if (supportsProcessExitCode) {
+            process.exitCode = exitStatus;
+        } else if (exitStatus !== 0) {
+            process.exit(exitStatus);
+        }
+    }
+}
+
+
+//---- mainline
+
+function main() {
+    vasync.pipeline({arg: {}, funcs: [
+        function loadTemplate(arg, next) {
+            fs.readFile(templatePath, 'utf8', function (err, content) {
+                arg.template = content;
+                next(err);
+            });
+        },
+
+        function gatherSetupConfig(arg, next) {
+            arg.setupConfig = {};
+            vasync.forEachPipeline({
+                inputs: setupConfigVars,
+                func: function getSetupConfigVar(key, nextVar) {
+                    mdataGet(key, null, function (err, val) {
+                        if (val !== null && val !== undefined) {
+                            arg.setupConfig[key] = val;
+                        }
+                        nextVar(err);
+                    });
+                }
+            }, next);
+        },
+
+        /*
+         * If 'mantaUser' is in setup config, that indicates that we are setting
+         * up to use a Manta (for file storage, for backups, for log upload).
+         * We then need to fill in `mantaKey` and `mantaKeyId`: using the key
+         * written to /data/imgapi/etc (generated by setup.sh).
+         */
+        function getMantaKeyAndKeyId(arg, next) {
+            if (!arg.setupConfig.mantaUser) {
+                next();
+                return;
+            }
+
+            /*
+             * `instPubKey` is set by setup.sh to the pubkey to use. The
+             * pubkey comment is meant to be the keyname that we can use to
+             * find the path to the privkey.
+             */
+            assert.string(arg.setupConfig.instPubKey,
+                'arg.setupConfig.instPubKey');
+
+            var pubKey = sshpk.parseKey(arg.setupConfig.instPubKey);
+            arg.setupConfig.mantaKeyId
+                = pubKey.fingerprint('sha256').toString();
+
+            var privKeyPath = '/data/imgapi/etc/' + pubKey.comment + '.id_rsa';
+            fs.exists(privKeyPath, function (exists) {
+                if (!exists) {
+                    next(new VError('expected IMGAPI instance private key '
+                        + '"%s" does not exist', privKeyPath));
+                } else {
+                    arg.setupConfig.mantaKey = privKeyPath;
+                    next();
+                }
+            });
+        },
+
+        function render(arg, next) {
+            var compiled = handlebars.compile(arg.template);
+            arg.rendered = compiled(arg.setupConfig);
+            next();
+        },
+        function validateConfigIsJson(arg, next) {
+            try {
+                JSON.parse(arg.rendered);
+            } catch (parseErr) {
+                next(new VError(parseErr,
+                    'rendered setup config is not valid JSON: %s',
+                    JSON.stringify(arg.rendered)));
+                return;
+            }
+            next();
+        },
+        function emit(arg, next) {
+            process.stdout.write(arg.rendered);
+        }
+    ]}, mainFinish);
+}
+
+main();
diff --git a/bin/imgapi-standalone-reprovision b/bin/imgapi-standalone-reprovision
new file mode 100755
index 0000000..2e5c0df
--- /dev/null
+++ b/bin/imgapi-standalone-reprovision
@@ -0,0 +1,239 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# *Re*-provision a standalone IMGAPI instance with a new image.
+#
+# This is meant to be run from the headnode GZ. See notes in
+# "docs/standalone.md".
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+PATH=/usr/bin:/usr/sbin:/smartdc/bin:/opt/smartdc/bin:/opt/local/bin:/opt/local/sbin
+
+
+#---- support stuff
+
+function usage () {
+    echo "Usage:"
+    echo "  imgapi-standalone-reprovision [OPTIONS] INSTANCE IMAGE"
+    echo ""
+    echo "Options:"
+    echo "  -h          Show this help and exit."
+    echo "  -y          Skip the confirmation before reprovisioning."
+    echo "  -I          Allow reprovision with same image."
+    echo "  -C CHANNEL  Updates channel in which to look for the given IMAGE."
+    echo ""
+    echo "Where INSTANCE is an existing standalone IMGAPI instance UUID, and"
+    echo "IMAGE is an 'imgapi' image UUID or 'latest' to get the latest from"
+    echo "the current (or given) channel of updates.joyent.com."
+    echo ""
+    echo "Examples:"
+    echo ""
+    echo "- First you'll need to get the create script to your headnode GZ:"
+    echo "    cd /var/tmp && curl -O https://raw.githubusercontent.com/joyent/sdc-imgapi/IMGAPI-567/bin/imgapi-standalone-reprovision"
+    echo ""
+    echo "- Reprovision an images.joyent.com inst with the latest experimental"
+    echo "  'imgapi' image:"
+    echo "    /var/tmp/imgapi-standalone-reprovision -C experimental \\"
+    echo "        205c49c8-715e-11e6-9134-239a750f414c latest"
+    echo ""
+
+}
+
+function fatal {
+    echo "$0: fatal error: $*"
+    exit 1
+}
+
+function errexit {
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+[[ $(zonename) == "global" ]] || fatal "must run this from the global zone"
+
+optAllowSameImage=
+optYes=
+optChannel=
+while getopts "hyIC:" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        y)
+            optYes=yes
+            ;;
+        I)
+            optAllowSameImage=yes
+            ;;
+        C)
+            optChannel=$OPTARG
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+INSTANCE=$1
+[[ -n $INSTANCE ]] || fatal 'no INSTANCE arg given'
+IMAGE=$2
+[[ -n $IMAGE ]] || fatal 'no IMAGE arg given'
+
+echo "Looking up instance $INSTANCE"
+instJson=$(sdc-vmadm get $INSTANCE)
+instUuid=$(echo "$instJson" | json uuid)
+instImageUuid=$(echo "$instJson" | json image_uuid)
+instAlias=$(echo "$instJson" | json alias)
+instDelegateDataset=$(echo "$instJson" | json datasets | json -a)
+ownerUuid=$(echo "$instJson" | json owner_uuid)
+
+if [[ -z "$instDelegateDataset" ]]; then
+    fatal "Instance $INSTANCE ($instAlias) does not have a delegate dataset: reprovisioning could lose IMGAPI data"
+fi
+
+echo "Looking up owner $ownerUuid"
+ownerJson=$(sdc-useradm get $ownerUuid)
+ownerLogin=$(echo "$ownerJson" | json login)
+ownerCompany=$(echo "$ownerJson" | json company)
+
+# Guard against a possible accidental reprovisioning a *core* IMGAPI zone
+# for this DC (which will be owned by 'admin').
+if [[ $ownerLogin == "admin" ]]; then
+    fatal "instance $INSTANCE ($instAlias) is owned by 'admin': are you accidentally trying to reprovision a core DC IMGAPI?"
+fi
+
+if [[ -n "$optChannel" ]]; then
+    channel=$optChannel
+else
+    channel=$(sdcadm channel get)
+fi
+if [[ "$IMAGE" == "latest" ]]; then
+    echo "Finding latest imgapi image (in '$channel' channel) on updates.jo"
+    imageUuid=$(updates-imgadm -C $channel list name=imgapi --latest -H -o uuid)
+    [[ -n "$imageUuid" ]] || fatal "no imgapi image in $channel change"
+else
+    imageUuid=$IMAGE
+fi
+
+if [[ $optAllowSameImage != "yes" ]]; then
+if [[ $imageUuid == "$instImageUuid" ]]; then
+    echo "Instance $INSTANCE ($instAlias) is already using image $imageUuid: skipping"
+    exit 0
+fi
+fi
+
+imageJson=$(sdc-imgadm get $imageUuid 2>/dev/null || true)
+if [[ -z "$imageJson" ]]; then
+    echo "Importing image $imageUuid from updates.jo"
+    sdc-imgadm import $imageUuid -S https://updates.joyent.com?channel=$channel
+    imageJson=$(sdc-imgadm get $imageUuid)
+else
+    echo "Already have image $imageUuid in local IMGAPI"
+fi
+imageName=$(echo "$imageJson" | json name)
+[[ "$imageName" == "imgapi" ]] \
+    || fatal "image $imageUuid is name=$imageName (expected 'name=imgapi')"
+imageVersion=$(echo "$imageJson" | json version)
+
+# Ensure OWNER is on image ACL.
+onAcl=$(echo "$imageJson" | json acl | json -a | (grep $ownerUuid || true))
+if [[ -z "$onAcl" ]]; then
+    echo "Adding owner ($ownerUuid) to image ACL"
+    sdc-imgadm add-acl $imageUuid $ownerUuid
+else
+    echo "Owner ($ownerUuid) is already on the image ACL"
+fi
+
+# Current image details.
+fromImageJson=$(sdc-imgadm get $instImageUuid 2>/dev/null || true)
+if [[ -n "$fromImageJson" ]]; then
+    fromImageName=$(echo "$fromImageJson" | json name)
+    fromImageVersion=$(echo "$fromImageJson" | json version)
+else
+    fromImageName="???"
+    fromImageVersion="???"
+fi
+
+# Confirm data
+echo ""
+echo "Reprovision standalone IMGAPI instance:"
+echo "       uuid: $instUuid"
+echo "      alias: $instAlias"
+echo "      owner: $ownerUuid ($ownerLogin, company=$ownerCompany)"
+echo " from image: $instImageUuid ($fromImageName@$fromImageVersion)"
+echo "   to image: $imageUuid ($imageName@$imageVersion)"
+echo ""
+if [[ $optYes != "yes" ]]; then
+    echo "Hit enter to continue / Ctrl+C to abort."
+    read
+fi
+
+# Reprovision
+# Not using 'sdc-vmadm reprovision $instUuid $imageUuid' because it doesn't
+# have a way to wait.
+startTimeSec=$(date -u +%s)
+startTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+sdc-vmapi /vms/$instUuid?action=reprovision -X POST -d@- <<EOP | json -H | sdc-waitforjob
+{
+    "image_uuid": "$imageUuid"
+}
+EOP
+# TODO: ^^^ does that exit non-zero on job failure? It would be nice.
+
+# Poll until get a 200 status ping (give it up to 2 minutes)
+echo ""
+echo "Waiting for IMGAPI service ping to respond with a 200"
+MAX_TRIES=40
+instIp=$(sdc-vmadm get $instUuid | json nics | json -c 'this.primary' 0.ip)
+[[ -n $instIp ]] || fatal "could not determine VM $instUuid primary IP"
+nTries=0
+pingResponse=
+pingStatus=
+while [[ nTries -lt $MAX_TRIES ]]; do
+    sleep 3
+    echo -n '.'
+    pingResponse=$(curl -ski --connect-timeout 2 --max-time 5 https://$instIp/ping || true)
+    pingStatus=$(echo "$pingResponse" | head -1 | awk '{print $2}')
+    if [[ $pingStatus == "200" ]]; then
+        break
+    fi
+    nTries=$(( $nTries + 1 ))
+done
+if [[ $pingStatus != "200" ]]; then
+    fatal "timeout waiting for IMGAPI ping to respond with 200:
+--
+$pingResponse
+--"
+else
+    echo ""
+    endTimeSec=$(date -u +%s)
+    endTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+    echo "Successfully reprovisioned IMGAPI instance $instUuid ($instAlias)"
+    echo "   started: $startTimestamp"
+    echo "  finished: $endTimestamp"
+    echo "   elapsed: $(( $endTimeSec - $startTimeSec ))s"
+fi
+
+exit 0
diff --git a/bin/imgapi-standalone-restore b/bin/imgapi-standalone-restore
new file mode 100755
index 0000000..a2bfe29
--- /dev/null
+++ b/bin/imgapi-standalone-restore
@@ -0,0 +1,184 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Restore IMGAPI data from a Manta backup.
+#
+# This is meant to be run from a created standalone IMGAPI zone.
+# See notes in "docs/operator-script.md".
+#
+#
+# As part of normal operation, a standalone IMGAPI that is configured to use
+# Manta will backup local data to Manta (see "imgapi-standalone-backup"). To
+# recover an IMGAPI one can do the following:
+#   - create a new standalone IMGAPI instance with `imgapi-standalone-create`
+#   - add the new instance's SSH key to the configured Manta user
+#   - ssh in to that instance and run `imgapi-standalone-restore`
+#
+# Eventually (when RFD 40 is more complete), when standalone IMGAPI deployments
+# support storing all data in remotely and/or HA, this restore process will
+# be unnecessary.
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+# ---- globals and config
+
+export PATH=/opt/smartdc/imgapi/build/node/bin:/opt/smartdc/imgapi/node_modules/.bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin
+
+MANTASYNC=/opt/smartdc/imgapi/node_modules/.bin/manta-sync
+CONFIG=/data/imgapi/etc/imgapi.config.json
+RESTORED_MARKER=/data/imgapi/run/restored.marker
+
+
+#---- support stuff
+
+function usage () {
+    echo "Usage:"
+    echo "  imgapi-standalone-restore [OPTIONS]"
+    echo ""
+    echo "Options:"
+    echo "  -h          Show this help and exit."
+    echo "  -y          Skip the confirmation before restoring."
+}
+
+function fatal {
+    echo "$0: fatal error: $*"
+    exit 1
+}
+
+function errexit {
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+optYes=no
+while getopts "hy" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        y)
+            optYes=yes
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+config="$(node /opt/smartdc/imgapi/lib/config.js)"
+
+# Guard that this is run only in a standalone IMGAPI.
+mode=$(echo "$config" | json mode)
+if [[ $mode == "dc" ]]; then
+    fatal "cannot run in a 'mode=dc' IMGAPI instance"
+fi
+
+# Get manta info from config
+export MANTA_URL=$(echo "$config" | json manta.url)
+[[ -n "$MANTA_URL" ]] || fatal "not configured to use Manta: no 'manta.url' in config"
+export MANTA_USER=$(echo "$config" | json manta.user)
+[[ -n "$MANTA_USER" ]] || fatal "not configured to use Manta: no 'manta.user' in config"
+# Current manta-sync doesn't support the newer KEY_ID's, so we'll rebuild it
+# from the key path.
+mantaKeyPath=$(echo "$config" | json manta.key)
+[[ -n "$mantaKeyPath" ]] || fatal "not configured to use Manta: no 'manta.key' in config"
+export MANTA_KEY_ID=$(ssh-keygen -E md5 -lf $mantaKeyPath | awk '{print $2}' | cut -c5-)
+if [[ "$(echo "$config" | json manta.insecure)" == "true" ]]; then
+    export MANTA_TLS_INSECURE=1
+else
+    unset MANTA_TLS_INSECURE
+fi
+
+bakDir=$(echo "$config" | json manta.rootDir)/backup
+echo "Restore IMGAPI data from Manta backup:"
+echo "    backup (in Manta): $bakDir/{images,manifests}"
+echo "       target (local): /data/imgapi/{images,manifests}"
+echo ""
+if [[ $optYes != "yes" ]]; then
+    echo "Hit enter to continue / Ctrl+C to abort."
+    read
+fi
+
+# Access check, to ensure a clear error message if our IMGAPI instance key
+# isn't working to get to Manta.
+accessCheckStatus=$(minfo $bakDir | head -1 | awk '{print $2}')
+if [[ $accessCheckStatus == "403" ]]; then
+    echo "* * *" >&2
+    echo "error: Cannot access the backup dir with the following credentials:" >&2
+    echo "    MANTA_URL=$MANTA_URL" >&2
+    echo "    MANTA_USER=$MANTA_USER" >&2
+    echo "    MANTA_KEY_ID=$MANTA_KEY_ID" >&2
+    if [[ -n "$MANTA_TLS_INSECURE" ]]; then
+        echo "    MANTA_TLS_INSECURE=$MANTA_TLS_INSECURE" >&2
+    fi
+    echo "" >&2
+    echo "A likely reason is that this IMGAPI's instance pubkey was not added to" >&2
+    echo "the '$MANTA_USER' Manta account. Depending on your Triton CLI profiles" >&2
+    echo "the following might help:" >&2
+    echo "" >&2
+    echo "    triton inst get $(mdata-get sdc:alias) | json metadata.instPubKey \\" >&2
+    echo "        | triton -a $MANTA_USER key add -" >&2
+    echo "* * *" >&2
+    exit 1
+fi
+
+echo ""
+infoStatus=$(minfo $bakDir/images | head -1 | awk '{print $2}')
+if [[ $infoStatus == "404" ]]; then
+    echo "Nothing in $bakDir/images to restore."
+    echo "This means either (a) all image files for this IMGAPI are stored in "
+    echo "Manta, which is a good thing; or (b) this is a brand new IMGAPI repo."
+elif [[ $infoStatus != "200" ]]; then
+    fatal "unexpected status code getting `minfo $bakDir/images`: $infoStatus"
+else
+    echo "Restore /data/imgapi/images"
+    $MANTASYNC -r $bakDir/images /data/imgapi/images
+fi
+
+echo ""
+infoStatus=$(minfo $bakDir/manifests | head -1 | awk '{print $2}')
+if [[ $infoStatus == "404" ]]; then
+    echo "Nothing in $bakDir/manifests to restore."
+    echo "This means either that this is a brand new IMGAPI repo."
+elif [[ $infoStatus != "200" ]]; then
+    fatal "unexpected status code getting `minfo $bakDir/manifests`: $infoStatus"
+else
+    echo "Restore /data/imgapi/manifests"
+    $MANTASYNC -r $bakDir/manifests /data/imgapi/manifests
+fi
+
+# The restored.marker file is used to tell 'imgapi-standalone-backup' that it
+# is okay to run. Else an unrestored IMGAPI instance could wipe out existing
+# backup data from an earlier instance.
+echo ""
+restoredTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+echo "Mark restoration ($RESTORED_MARKER)"
+mkdir -p $(dirname $RESTORED_MARKER)
+echo "restored at $restoredTimestamp" >>$RESTORED_MARKER
+
+echo ""
+echo "Restarting imgapi service"
+svcadm restart imgapi
diff --git a/bin/imgapi-standalone-status b/bin/imgapi-standalone-status
new file mode 100755
index 0000000..9386c55
--- /dev/null
+++ b/bin/imgapi-standalone-status
@@ -0,0 +1,444 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Check the status of this standalone IMGAPI instance.
+# (This is meant to be inside an IMGAPI INSTANCE.)
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+#---- env and globals
+
+export PATH=/opt/smartdc/imgapi/build/node/bin:/opt/smartdc/imgapi/node_modules/.bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin
+
+optVerbose=no
+nFaults=0
+config=
+
+
+#---- support stuff
+
+function usage () {
+    echo "Usage:"
+    echo "  imgapi-standalone-status [OPTIONS]"
+    echo ""
+    echo "Options:"
+    echo "  -h      Show this help and exit."
+    echo "  -v      Verbose. Emit output for each step. By default there is"
+    echo "          only output for failures."
+}
+
+function fatal {
+    echo "$0: fatal error: $*"
+    exit 1
+}
+
+function verbose {
+    if [[ $optVerbose == "yes" ]]; then
+        echo "$@" >&2
+    fi
+}
+
+
+#---- checks
+
+# Example:
+# svc:/site/imgapi:default (Triton Image API)
+#  State: disabled since Tue Sep  6 22:05:49 2016
+# Reason: Disabled by an administrator.
+#    See: http://illumos.org/msg/SMF-8000-05
+#    See: /var/svc/log/site-imgapi:default.log
+# Impact: This service is not running.
+function check_svcs {
+    local retval
+
+    verbose "Checking svcs ..."
+
+    set +o errexit
+    svcs -x
+    retval=$?
+    set -o errexit
+
+    if [[ $retval -ne 0 ]]; then
+        nFaults=$(( $nFaults + 1 ))
+    fi
+}
+
+function check_imgapi_http_ping {
+    local port
+    local cmd
+    local output
+    local retval
+    local status
+
+    verbose "Checking imgapi http ping ..."
+
+    port=$(echo "$config" | json port)
+    cmd="curl -is --connect-timeout 2 --max-time 5 http://localhost:$port/ping"
+    set +o errexit
+    output=$($cmd)
+    retval=$?
+    set -o errexit
+
+    if [[ $retval -ne 0 ]]; then
+        echo ""
+        echo "imgapi http ping"
+        echo " State: failed"
+        echo "   Cmd: $cmd"
+        echo "  Info: curl exit status: $retval"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    status=$(echo "$output" | head -1 | awk '{print $2}')
+    if [[ $status != "200" ]]; then
+        echo ""
+        echo "imgapi http ping"
+        echo " State: non-200 HTTP status"
+        echo "   Cmd: $cmd"
+        echo "Status: $status"
+        nFaults=$(( $nFaults + 1 ))
+    fi
+}
+
+function check_imgapi_https_ping {
+    local cmd
+    local output
+    local retval
+    local status
+
+    verbose "Checking imgapi https ping ..."
+
+    cmd="curl -kis --connect-timeout 2 --max-time 5 https://localhost/ping"
+    set +o errexit
+    output=$($cmd)
+    retval=$?
+    set -o errexit
+
+    if [[ $retval -ne 0 ]]; then
+        echo ""
+        echo "imgapi https ping"
+        echo " State: failed"
+        echo "   Cmd: $cmd"
+        echo "  Info: curl exit status: $retval"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    status=$(echo "$output" | head -1 | awk '{print $2}')
+    if [[ $status != "200" ]]; then
+        echo ""
+        echo "imgapi https ping"
+        echo " State: non-200 HTTP status"
+        echo "   Cmd: $cmd"
+        echo "Status: $status"
+        nFaults=$(( $nFaults + 1 ))
+    fi
+}
+
+function check_imgapi_https_images {
+    local cmd
+    local output
+    local retval
+    local status
+
+    verbose "Checking imgapi https images ..."
+
+    cmd="curl -kis --connect-timeout 2 --max-time 5 https://localhost/images?limit=1"
+    set +o errexit
+    output=$($cmd)
+    retval=$?
+    set -o errexit
+
+    if [[ $retval -ne 0 ]]; then
+        echo ""
+        echo "imgapi https images"
+        echo " State: failed"
+        echo "   Cmd: $cmd"
+        echo "  Info: curl exit status: $retval"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    status=$(echo "$output" | head -1 | awk '{print $2}')
+    if [[ $status != "200" ]]; then
+        echo ""
+        echo "imgapi https images"
+        echo " State: non-200 HTTP status"
+        echo "   Cmd: $cmd"
+        echo "Status: $status"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    if [[ $(echo "$output" | json -H -o json-0 | cut -c1) != "[" ]]; then
+        echo ""
+        echo "imgapi https images"
+        echo " State: ListImages body does not look like an array"
+        echo "   Cmd: $cmd"
+        nFaults=$(( $nFaults + 1 ))
+    fi
+}
+
+
+# 'imgapi-standalone-restore' must be run once, otherwise
+# 'imgapi-standalone-backup' can't run.
+function check_restore_has_run {
+    local mtime
+    local now
+    local hourago
+    local lastStatus
+
+    # imgapi-standalone-restore writes this file on successful completion.
+    local RESTORED_MARKER=/data/imgapi/run/restored.marker
+
+    verbose "Checking restore has run ..."
+
+    if [[ ! -f $RESTORED_MARKER ]]; then
+        echo ""
+        echo "restore run at least once"
+        echo " State: imgapi-standalone-restore has never been run"
+        echo "  Info: This must be run once manually by an operator after creation."
+        echo "   See: $RESTORED_MARKER"
+        nFaults=$(( $nFaults + 1 ))
+    fi
+}
+
+
+function check_log_rotation {
+    local expect
+    local output
+    local retval
+    local name
+
+    verbose "Checking log rotation ..."
+
+    for name in imgapi imgapi-backup; do
+        expect="/var/log/triton/${name}_$(hostname)_$(date -u "+%Y%m%dT%H")*.log"
+
+        set +o errexit
+        output=$(ls $expect 2>&1)
+        retval=$?
+        set -o errexit
+
+        if [[ $retval -ne 0 ]]; then
+            echo ""
+            echo "log rotation"
+            echo " State: no rotated '$name' log file for current hour was found"
+            echo "Expect: $expect"
+            echo "  Note: This is expected if you reprovisioned within the last hour"
+            nFaults=$(( $nFaults + 1 ))
+        fi
+    done
+}
+
+
+function check_manta_connection {
+    verbose "Checking Manta connection ..."
+
+    local mantaRootDir
+    local mOpts
+    local output
+    local retval
+    local status
+
+    mOpts="--url=$(echo "$config" | json manta.url)"
+    mOpts="$mOpts -a $(echo "$config" | json manta.user)"
+    mOpts="$mOpts -k $(echo "$config" | json manta.keyId)"
+    if [[ "$(echo "$config" | json manta.insecure)" == "true" ]]; then
+        mOpts="$mOpts -i"
+    fi
+    mantaRootDir=$(echo "$config" | json manta.rootDir)
+
+    cmd="minfo $mOpts $mantaRootDir"
+    set +o errexit
+    output=$($cmd)
+    retval=$?
+    set -o errexit
+
+    if [[ $retval -ne 0 ]]; then
+        echo ""
+        echo "manta connection"
+        echo " State: could not get info on Manta root dir: $mantaRootDir"
+        echo "   Cmd: $cmd"
+        echo "  Info: minfo exit status was $retval"
+        nFaults=$(( $nFaults + 1 ))
+    fi
+
+    status=$(echo "$output" | head -1 | awk '{print $2}')
+    if [[ $status != "200" ]]; then
+        echo ""
+        echo "manta connection"
+        echo " State: non-200 HTTP status attempting to minfo Manta root dir: $mantaRootDir"
+        echo "   Cmd: $cmd"
+        echo "Status: $status"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+}
+
+
+function check_backup {
+    local mtime
+    local now
+    local hourago
+    local lastStatus
+
+    # imgapi-standalone-backup writes its last status to this file. Fault if
+    # that doesn't exist, was last run more than an hour ago, or is non-zero.
+    local BACKUP_STATUS=/data/imgapi/run/backup.status
+
+    verbose "Checking backup ..."
+
+    if [[ ! -f $BACKUP_STATUS ]]; then
+        echo ""
+        echo "backup"
+        echo " State: imgapi-status-backup has never been run"
+        echo "  Info: Typically this is run via cron. Setup by setup.sh."
+        echo "   See: crontab -l"
+        echo "   See: $(svcs -L mdata:execute)"
+        echo "   See: $BACKUP_STATUS"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    mtime=$(stat --printf=%Y $BACKUP_STATUS)
+    now=$(date '+%s')
+    hourago=$(( now - 3600 ))
+    if [[ $mtime -lt $hourago ]]; then
+        echo ""
+        echo "backup"
+        echo " State: imgapi-status-backup has not run in the last hour"
+        echo "  Info: $BACKUP_STATUS mtime is $mtime"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    lastStatus=$(cat $BACKUP_STATUS)
+    if [[ $lastStatus != "0" ]]; then
+        echo ""
+        echo "backup"
+        echo " State: last 'imgapi-status-backup' failed"
+        echo "  Info: exit status from $BACKUP_STATUS is $lastStatus"
+        echo "   See: /var/log/triton/imgapi-backup.log"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+}
+
+
+function check_log_upload {
+    local mtime
+    local now
+    local hourago
+    local lastStatus
+
+    # tritonlogupload.sh writes its last status to this file. Fault if
+    # that doesn't exist, was last run more than an hour ago, or is non-zero.
+    local LOGUPLOAD_STATUS=/data/imgapi/run/logupload.status
+
+    verbose "Checking log upload ..."
+
+    if [[ ! -f $LOGUPLOAD_STATUS ]]; then
+        echo ""
+        echo "log upload"
+        echo " State: log upload has never run"
+        echo "  Info: Typically this is run via cron. Setup by setup.sh."
+        echo "   See: crontab -l"
+        echo "   See: $(svcs -L mdata:execute)"
+        echo "   See: $LOGUPLOAD_STATUS"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    mtime=$(stat --printf=%Y $LOGUPLOAD_STATUS)
+    now=$(date '+%s')
+    hourago=$(( now - 3600 ))
+    if [[ $mtime -lt $hourago ]]; then
+        echo ""
+        echo "backup"
+        echo " State: log upload not run in the last hour"
+        echo "  Info: $LOGUPLOAD_STATUS mtime is $mtime"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+
+    lastStatus=$(cat $LOGUPLOAD_STATUS)
+    if [[ $lastStatus != "0" ]]; then
+        echo ""
+        echo "backup"
+        echo " State: last log upload failed"
+        echo "  Info: exit status from $LOGUPLOAD_STATUS is $lastStatus"
+        echo "   See: /var/log/tritonlogupload.log"
+        nFaults=$(( $nFaults + 1 ))
+        return
+    fi
+}
+
+
+#---- mainline
+
+while getopts "hv" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        v)
+            optVerbose=yes
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+startTimeSec=$(date -u +%s)
+startTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+
+config="$(node /opt/smartdc/imgapi/lib/config.js)"
+
+# Guard that this is run only in a standalone IMGAPI.
+mode=$(echo "$config" | json mode)
+if [[ $mode == "dc" ]]; then
+    fatal "cannot run in a 'mode=dc' IMGAPI instance"
+fi
+
+check_svcs
+check_imgapi_http_ping
+check_imgapi_https_ping
+check_imgapi_https_images
+check_restore_has_run
+check_log_rotation
+if [[ -n "$(echo "$config" | json manta)" ]]; then
+    check_manta_connection
+    check_backup
+    check_log_upload
+fi
+
+endTimeSec=$(date -u +%s)
+endTimestamp=$(date -u '+%Y-%m-%dT%H:%M:%S')
+if [[ $nFaults -eq 0 ]]; then
+    verbose ""
+    verbose "Successful check"
+    verbose "   started: $startTimestamp"
+    verbose "  finished: $endTimestamp"
+    verbose "   elapsed: $(( $endTimeSec - $startTimeSec ))s"
+fi
+
+exit $nFaults
diff --git a/bin/manta-config b/bin/manta-config
deleted file mode 100755
index 51e57ff..0000000
--- a/bin/manta-config
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/bin/bash
-#
-# Emit appropriate node-manta CLI options for the current imgapi's
-# Manta storage configuration.
-#
-# Usage:
-#       ./node_modules/.bin/mls `./bin/manta-config` ~~/stor
-#
-
-
-if [[ -n "$TRACE" ]]; then
-    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-    set -o xtrace
-fi
-set -o errexit
-set -o pipefail
-
-
-TOP=$(cd $(dirname $0)/../ 2>/dev/null; pwd)
-JSON=json
-
-
-# ---- support stuff
-
-function fatal {
-    echo "$0: fatal error: $*"
-    exit 1
-}
-
-function errexit {
-    [[ $1 -ne 0 ]] || exit 0
-    fatal "error exit status $1"
-}
-
-# ---- mainline
-
-trap 'errexit $?' EXIT
-
-if [[ -f /opt/smartdc/imgapi/etc/imgapi.config.json ]]; then
-    CONFIG=/opt/smartdc/imgapi/etc/imgapi.config.json
-elif [[ -f /root/config/imgapi.config.json ]]; then
-    CONFIG=/root/config/imgapi.config.json
-else
-    fatal "could not find imgapi.config.json"
-fi
-
-mantaConfig="$($JSON -f $CONFIG storage.manta)"
-if [[ -z "$mantaConfig" ]]; then
-    fatal "no 'storage.manta' in $CONFIG"
-fi
-
-if [[ "$(echo "$mantaConfig" | $JSON insecure)" == "true" ]]; then
-    insecureOpt="--insecure"
-fi
-echo -n \
-    --url=$(echo "$mantaConfig" | $JSON url) \
-    --account=$(echo "$mantaConfig" | $JSON user) \
-    --keyId=$(echo "$mantaConfig" | $JSON keyId) \
-    $insecureOpt
diff --git a/bin/manta-env b/bin/manta-env
new file mode 100755
index 0000000..d30bb27
--- /dev/null
+++ b/bin/manta-env
@@ -0,0 +1,61 @@
+#!/bin/bash
+#
+# Emit bash commands to set your environment (i.e. 'export MANTA_URL=' et al)
+# for using Manta tooling for the IMGAPI's configured Manta.
+#
+# If there is no "storage.manta" block in the config, then it silented emits
+# nothing (i.e. that isn't an error).
+#
+# Usage:
+#       eval $(manta-env)
+#       mls ~~/stor
+#
+
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+export PATH=/opt/smartdc/imgapi/build/node/bin:/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin
+TOP=$(cd $(dirname $0)/../ 2>/dev/null; pwd)
+JSON=json
+
+
+# ---- support stuff
+
+function fatal {
+    echo "$0: fatal error: $*" >&2
+    exit 1
+}
+
+function errexit {
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1" >&2
+}
+
+
+# ---- mainline
+
+trap 'errexit $?' EXIT
+
+if [[ -f /data/imgapi/etc/imgapi.config.json ]]; then
+    CONFIG=/data/imgapi/etc/imgapi.config.json
+else
+    fatal "could not find imgapi.config.json"
+fi
+
+mantaConfig="$(node /opt/smartdc/imgapi/lib/config.js manta)"
+if [[ -z "$mantaConfig" ]]; then
+    exit 0
+fi
+
+echo "export MANTA_URL=$(echo "$mantaConfig" | $JSON url)"
+echo "export MANTA_USER=$(echo "$mantaConfig" | $JSON user)"
+echo "export MANTA_KEY_ID=$(echo "$mantaConfig" | $JSON keyId)"
+if [[ "$(echo "$mantaConfig" | $JSON insecure)" == "true" ]]; then
+    echo "export MANTA_TLS_INSECURE=1"
+fi
diff --git a/boot/setup.sh b/boot/setup.sh
index 6d858c6..565a253 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -17,6 +17,10 @@ set -o errexit
 PATH=/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin
 role=imgapi
 
+# Mount our delegated dataset at '/data' (before common setup, because
+# our config-agent-written config file is under /data).
+zfs set mountpoint=/data zones/$(zonename)/data
+
 # Include common utility functions (then run the boilerplate)
 source /opt/smartdc/boot/lib/util.sh
 CONFIG_AGENT_LOCAL_MANIFESTS_DIRS=/opt/smartdc/$role
@@ -25,19 +29,16 @@ sdc_common_setup
 # Cookie to identify this as a SmartDC zone and its role
 mkdir -p /var/smartdc/$role
 
-# Mount our delegate dataset at '/data'.
-zfs set mountpoint=/data zones/$(zonename)/data
-
 # Add build/node/bin and node_modules/.bin to PATH
 echo "" >>/root/.profile
 echo "export PATH=/opt/smartdc/$role/bin:/opt/smartdc/$role/build/node/bin:/opt/smartdc/$role/node_modules/.bin:\$PATH" >>/root/.profile
 echo '[[ -f $HOME/.mantaprofile ]] && source $HOME/.mantaprofile' >>/root/.profile
 
-STORAGE_LOCAL_BASEDIR=$(json -f /opt/smartdc/imgapi/etc/imgapi.config.json storage.local.baseDir)
-if [[ ! -d $STORAGE_LOCAL_BASEDIR ]]; then
-    mkdir -p $STORAGE_LOCAL_BASEDIR
+LOCAL_BASE_DIR=$(/opt/smartdc/imgapi/build/node/bin/node /opt/smartdc/imgapi/lib/constants.js LOCAL_BASE_DIR)
+if [[ ! -d $LOCAL_BASE_DIR ]]; then
+    mkdir -p $LOCAL_BASE_DIR
 fi
-chown nobody:nobody $STORAGE_LOCAL_BASEDIR
+chown nobody:nobody $LOCAL_BASE_DIR
 
 $(/opt/local/bin/gsed -i"" -e "s/@@PREFIX@@/\/opt\/smartdc\/imgapi/g" /opt/smartdc/imgapi/smf/manifests/imgapi.xml)
 /usr/sbin/svccfg import /opt/smartdc/imgapi/smf/manifests/imgapi.xml
diff --git a/boot/standalone/configure.sh b/boot/standalone/configure.sh
new file mode 100755
index 0000000..cb49ac3
--- /dev/null
+++ b/boot/standalone/configure.sh
@@ -0,0 +1,27 @@
+#!/usr/bin/bash
+# -*- mode: shell-script; fill-column: 80; -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+set -o xtrace
+set -o errexit
+set -o pipefail
+
+# Tune TCP so IMGAPI will work better with Manta
+# '|| true' because this 'ipadm set-prop' is necessary on some platform versions
+# and breaks on older ones.
+ipadm set-prop -t -p max_buf=2097152 tcp || true
+ndd -set /dev/tcp tcp_recv_hiwat 2097152
+ndd -set /dev/tcp tcp_xmit_hiwat 2097152
+ndd -set /dev/tcp tcp_conn_req_max_q 2048
+ndd -set /dev/tcp tcp_conn_req_max_q0 8192
+
+exit 0
diff --git a/boot/standalone/setup.sh b/boot/standalone/setup.sh
new file mode 100755
index 0000000..8ff28aa
--- /dev/null
+++ b/boot/standalone/setup.sh
@@ -0,0 +1,153 @@
+#!/usr/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Setup a new zone for a standalone IMGAPI.
+#
+# Typically this is run via the user-script for this instance (which should
+# be the content of "./user-script") and logs are in "/var/log/setup.log".
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+# The same path as used by core IMGAPI (from sdc-scripts.git).
+SETUP_COMPLETE_FILE=/var/svc/setup_complete
+
+if [[ -f $SETUP_COMPLETE_FILE ]]; then
+    # Already setup.
+    exit 0
+fi
+
+# Mount our delegated dataset at /data if we have one.
+dataset=zones/$(zonename)/data
+if zfs list | grep $dataset; then
+    mountpoint=$(zfs get -Hp mountpoint $dataset | awk '{print $3}')
+    if [[ $mountpoint != "/data" ]]; then
+        zfs set mountpoint=/data $dataset
+    fi
+else
+    mkdir /data
+fi
+
+# Set nodename/hostname to something that is nice to see in PS1.
+NODENAME=imgapi-$(mdata-get sdc:alias)-$(zonename | cut -d- -f1)
+/opt/local/bin/sm-set-hostname $NODENAME
+
+# Bash profile:
+# - set PATH, even for non-login sessions
+# - set MANTA_ envvars, but only for login sessions
+IMGAPI_PREFIX=/opt/smartdc/imgapi
+echo "" >>/root/.profile
+echo "export PATH=$IMGAPI_PREFIX/bin:$IMGAPI_PREFIX/build/node/bin:$IMGAPI_PREFIX/node_modules/.bin:\$PATH" >>/root/.profile
+echo 'if [ "$PS1" ]; then eval $(/opt/smartdc/imgapi/bin/manta-env 2>/dev/null || true); fi' >>/root/.profile
+
+# Data dir setup. For reprovisions on delegate datasets, this should already
+# be done.
+if [[ ! -d /data/imgapi ]]; then
+    # etc/ and instance ssh key
+    mkdir -p /data/imgapi/etc
+    [[ ! -f /data/imgapi/etc/imgapi-*.id_rsa ]] \
+        || fatal "unexpected existing IMGAPI instance key files: /data/imgapi/etc/imgapi-*.id_rsa"
+    keyName=$NODENAME-$(date -u '+%Y%m%d')
+    ssh-keygen -t rsa -b 4096 -N "" \
+        -C "$keyName" -f /data/imgapi/etc/$keyName.id_rsa
+    # Write pubkey to mdata so outside tooling can use it for setup.
+    mdata-put instPubKey < /data/imgapi/etc/$keyName.id_rsa.pub
+
+    # Self-signed cert
+    /opt/local/bin/openssl req -x509 -nodes -subj '/CN=*' -newkey rsa:2048 \
+        -keyout /data/imgapi/etc/key.pem \
+        -out /data/imgapi/etc/cert.pem -days 365
+    cat /data/imgapi/etc/key.pem >> /data/imgapi/etc/cert.pem
+    rm /data/imgapi/etc/key.pem
+
+    # Generate config file.
+    /opt/smartdc/imgapi/bin/imgapi-standalone-gen-setup-config \
+        >/data/imgapi/etc/imgapi.config.json
+
+    # Dir for local auth keys (really only needed for authType=signature).
+    mkdir -p /data/imgapi/etc/authkeys/local
+
+    # imgapi SMF service runs as 'nobody'
+    chown nobody:nobody /data/imgapi
+    chown nobody:nobody /data/imgapi/etc
+    chown nobody:nobody /data/imgapi/etc/$keyName.id_rsa{,.pub}
+    chown nobody:nobody /data/imgapi/etc/cert.pem
+    chown nobody:nobody /data/imgapi/etc/imgapi.config.json
+    chown nobody:nobody /data/imgapi/etc/authkeys
+    chown nobody:nobody /data/imgapi/etc/authkeys/local
+else
+    keyName=$(mdata-get instPubKey | awk '{print $3}')
+fi
+
+# Manta CLI tools require that key be in ~/.ssh
+ln -s /data/imgapi/etc/$keyName.id_rsa ~/.ssh/
+ln -s /data/imgapi/etc/$keyName.id_rsa.pub ~/.ssh/
+
+# Log rotation
+mkdir -p /var/log/triton/upload
+touch /var/log/triton/imgapi-backup.log  # avoid a warning in logadm.log
+echo '
+imgapi /var/svc/log/*imgapi*.log
+imgapi-backup /var/log/triton/imgapi-backup.log
+' | while read logname logpat size; do
+    [[ -n "$logname" ]] || continue
+    # 168 == 1 week of hours
+    logadm -w $logname -C 168 -c -p 1h \
+        -t "/var/log/triton/${logname}_\$nodename_%Y%m%dT%H%M%S.log" \
+        -a "/opt/smartdc/imgapi/tools/standalone/tritonpostlogrotate.sh ${logname}" \
+        "$logpat" || fatal "unable to create $logname logadm entry"
+done
+logadm -r smf_logs   # smf_logs competes with 'imgapi' SMF log, put it last
+logadm -w smf_logs -C 3 -c -s 1m '/var/svc/log/*.log'
+
+# crons: logadm, manta backup, manta log upload
+crontab=/tmp/imgapi-$$.cron
+rm -f $crontab
+touch $crontab
+echo '0 5 * * * /opt/local/sbin/pkg_admin fetch-pkg-vulnerabilities >/dev/null 2>&1' >>$crontab
+echo '0 * * * * /usr/sbin/logadm -v >>/var/log/logadm.log 2>&1' >>$crontab
+echo '1 * * * * /opt/smartdc/imgapi/tools/standalone/tritonlogupload.sh -a 5 >>/var/log/tritonlogupload.log 2>&1' >>$crontab
+echo '17 * * * * /opt/smartdc/imgapi/bin/imgapi-standalone-backup -y >>/var/log/triton/imgapi-backup.log 2>&1' >>$crontab
+crontab $crontab
+[[ $? -eq 0 ]] || fatal "Unable import crontab"
+rm -f $crontab
+
+# MOTD
+# TODO: 'manta rootDir' will be out of date if Manta details are configured
+# after initial setup.
+cat <<EMOTD >/etc/motd
+** This is a standalone IMGAPI instance.
+**            uuid: $(zonename) ($(mdata-get sdc:alias))
+**              dc: $(mdata-get sdc:datacenter_name)
+**           owner: $(mdata-get sdc:owner_uuid)
+**           image: $(mdata-get sdc:image_uuid)
+**   manta rootDir: $(/opt/smartdc/imgapi/build/node/bin/node /opt/smartdc/imgapi/lib/config.js | json manta.rootDir)
+EMOTD
+
+# SMF services
+/usr/sbin/svccfg import /opt/smartdc/imgapi/smf/manifests/imgapi.xml
+/usr/sbin/svccfg delete pkgsrc/haproxy  # avoid 'haproxy' FMRI collison
+/usr/sbin/svccfg import /opt/smartdc/imgapi/smf/manifests/haproxy-standalone.xml
+/usr/sbin/svccfg delete pkgsrc/stud  # avoid 'stud' FMRI collison
+/usr/sbin/svccfg import /opt/smartdc/imgapi/smf/manifests/stud-standalone.xml
+
+# Note completion
+touch $SETUP_COMPLETE_FILE
+echo "Setup completed successfully"
+
+exit 0
diff --git a/boot/standalone/user-script b/boot/standalone/user-script
new file mode 100755
index 0000000..2b0c6c1
--- /dev/null
+++ b/boot/standalone/user-script
@@ -0,0 +1,48 @@
+#!/usr/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# A user-script for a standalone IMGAPI instance.
+#
+# (This is derived from, but slightly different to the stock user-script
+# used for core Triton zones.)
+#
+
+export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+
+set -o xtrace
+set -o errexit
+set -o pipefail
+
+#
+# The presence of the /var/svc/.ran-user-script file indicates that the
+# instance has already been setup (i.e. the instance has booted previously).
+#
+# Upon first boot, run the setup.sh script if present. On all boots including
+# the first one, run the configure.sh script if present.
+#
+
+SENTINEL=/var/svc/.ran-user-script
+
+DIR=/opt/smartdc/boot/standalone
+
+if [[ ! -e ${SENTINEL} ]]; then
+    if [[ -f ${DIR}/setup.sh ]]; then
+        TRACE=1 ${DIR}/setup.sh 2>&1 | tee -a /var/log/setup.log
+    fi
+
+    touch ${SENTINEL}
+fi
+
+if [[ ! -f ${DIR}/configure.sh ]]; then
+    echo "Missing ${DIR}/configure.sh cannot configure." >&2
+    exit 1
+fi
+
+exec ${DIR}/configure.sh
diff --git a/docs/design.md b/docs/design.md
deleted file mode 100644
index aea15d9..0000000
--- a/docs/design.md
+++ /dev/null
@@ -1,536 +0,0 @@
----
-title: Image API Design Discussions
-markdown2extras: tables, cuddled-lists
-apisections:
----
-<!--
-    This Source Code Form is subject to the terms of the Mozilla Public
-    License, v. 2.0. If a copy of the MPL was not distributed with this
-    file, You can obtain one at http://mozilla.org/MPL/2.0/.
--->
-
-<!--
-    Copyright (c) 2014, Joyent, Inc.
--->
-
-# Image API Design Discussions
-
-Here-in some design discussions for Image API, collected here because they
-might be helpful to understand why the Image API is the way it is. Each section
-is dated to give context if reading this in the future when IMGAPI design might
-have moved on. *Add new sections to the top.*
-
-
-# CreateImage, ImportImage, etc. (2-Oct-2012)
-
-from 19-Sep-2012 discussion:
-
-    2:55:02 PM mark.cavage@eng.joyent.com: no i meant "create image looks like 'post to some url all the metadata' , imgapi validates then says 'ok, here's a place you can go write the bytes to'"
-    2:55:27 PM trent: I understood that. I was questioning the need for two steps there.
-    2:55:56 PM mark.cavage@eng.joyent.com: ok. well, up to you i suppose.
-    2:57:10 PM trent: no, seriously, did you have a reason? :)
-    2:57:34 PM mark.cavage@eng.joyent.com: i just don't understand how easy it is to combine the manifest and the byte stream in one call.
-    2:57:39 PM mark.cavage@eng.joyent.com: they feel hard to "merge"
-    2:57:44 PM trent: curl https://datasets.joyent.com/datasets/cc707720-359e-4d84-89a7-e50959ecba43 \
-        -X PUT \
-        -u joe:password \
-        -F manifest=@nodejs-1.0.0.dsmanifest \
-        -F nodejs-1.0.0.zfs.bz2=@nodejs-1.0.0.zfs.bz2
-    2:58:07 PM trent: only reason I could think to separate is that you want validation done early
-    2:58:16 PM mark.cavage@eng.joyent.com: yeah, if the image is big that's painful.
-    2:58:19 PM mark.cavage@eng.joyent.com: is all i meant.
-    2:58:20 PM trent: i.e. don't want to pay for the huge upload and ultimately fail because of a missing comma
-    2:58:22 PM mark.cavage@eng.joyent.com: but, meh. ok.
-
-So something like
-
-    POST /images -u AUTH \
-        -d name=foo
-        -d description=...
-        -d type=...
-        -d os=...
-        -d requirements=...
-        -d tag=bar
-        -d tag=baz
-    --
-    201 Created
-    Location: http://n.n.n.n/images/$uuid
-    ...
-
-    {
-        "name": "foo",
-        ...
-        "active": false,
-        "state": "unactivated"   // or whatever
-    }
-
-Warning (TODO): watch out when proxying this 'Location' header via cloudapi.
-Make it relative? No, still should be absolute.
-
-Then add the file:
-
-    PUT /images/$uuid/file -u AUTH -T foo.zfs.bz2    // curl's `-T FILE` option
-    --
-    200 OK
-    ...
-
-    {... the updated image serialization, state is 'unactivated' ...}
-
-Not active yet, need to end file input -- this allows for future addition
-of support for multiple files.
-
-    POST /images/$uuid/activate
-    --
-    200 OK
-
-    {... active image serialization ...}
-
-Then can later stream the file out via:
-
-    GET /images/$uuid/file
-
-Note that here we are implicitly using "file" as an alias for "file0". The
-latter will only be exposed if/when we support multi-file images.
-
-
-## manta storage
-
-IMGAPI is running with a configured Manta. The PUT stores the file in
-"/imgapi/stor/images/$uuid/file0", where "imgapi" is actually the imgapi
-UFDS user's UUID.
-
-Note that possibly (need to understand the authn story) the GetImageFile
-could just redirect to the Manta download URL.
-
-
-## local storage
-
-The image file to be stored is requested to be stored in local storage:
-
-    POST /images/$uuid/file?storage=local
-
-Authz: only allow for operators and a configured whitelist of user UUIDs
-(config var `authzLocalStorateUuids`).
-
-Note: the HA limitation here: this IMGAPI can only be on the headnode.
-
-Physically the local storage is in "/usbkey/imgapi/images/$uuid/file0".
-"/usbkey/imgapi" is mounted into the (headnode) imgapi zone.
-
-
-## dcls storage
-
-TODO: determine how this works and revisit. However, likely this will
-be similar to 'local' storage:
-
-    POST /images/$uuid/file?storage=dcls
-
-Also, the HA limitation should *not* apply here.
-
-
-## bootstrapping an image from /usbkey/datasets
-
-    # ImportImage
-    POST /images/$uuid -H content-type:application/json \
-        --data-binary @/usbkey/datasets/smartos-1.6.3.dsmanifest
-    POST /images/$uuid/file -T /usbkey/datasets/smartos-1.6.3.zfs.bz2
-
-Authz: only allow for operators.
-
-See the "CopyImageFromDC" below:
-
-    POST /images?dc=us-west-1&uuid=:uuid
-
-Perhaps those should both be the same:
-
-    # ImportImage (only for operators)
-    POST /images/$uuid -H content-type:application/json \
-        --data-binary @/usbkey/datasets/smartos-1.6.3.dsmanifest
-
-    # ImportImage (limited to moving one's *own* images from another DC to
-    # this one).
-    POST /images/$uuid?dc=us-west-1
-
-
-## aside on multiple files
-
-The 'PUT /images/$uuid/file' works well as long as only one file is ever
-allowed. If we allow more, do we want to future proof with, say:
-
-    POST /images/$uuid/file0 -u AUTH -T foo1.zfs.bz2
-    POST /images/$uuid/file1 -u AUTH -T foo2.zfs.bz2
-    ...
-    POST /images/$uuid/end
-
-`curl -T` isn't as convenient here because it defaults to "PUT". Not sure
-if `-X POST` can just make that easy.
-
-Could then stream the files via:
-
-    GET /images/$uuid/file0
-    GET /images/$uuid/file1
-    ...
-
-Anyway, we'll cross the "multiple files" bridge if/when we come to it.
-
-
-
-
-
-# General IMGAPI plan (Sep-2012)
-
-- https://datasets.joyent.com will live until all SDC 6.x are done.
-  This needs to move to JPC2 soonish. Remains to be seen if this will be
-  handled by imgapi code in a compat mode. Probably not.
-
-- https://images.joyent.com is the replacement for SDC 7+. It is the central
-  repository of base images for SmartOS usage. All images here are published
-  and vetted by Joyent. (Images from software vendors may exist here, but
-  are still vetted by Joyent.) All images here are public -- no read auth,
-  no private images.
-
-  `imgadm` in smartos is set to use this image repo by default, hence this is
-  the main repository to which base smartos users are exposed. This is also
-  the default repository from which an SDC operator can import new
-  datasets (via adminui).
-
-  The trust question: How can a user trust that a particular image is from
-  Joyent and hence safe? Any images on images.joyent.com are vetted by
-  Joyent, so SDC customers can trust those UUIDs. No guarantees on any other
-  images.
-
-  How does images.joyent.com differ from IMGAPI in a DC?
-
-    - (maybe) images.joyent.com can host its docs
-    - (maybe) perhaps an HTML webview of all the datasets?
-    - it only allows addition of images from Joyent. It isn't tied to a
-      UFDS perhaps? IOW, special cased auth.
-
-- There is an IMGAPI in each DC: the imgapi zone(s). This is the authority
-  for which images are available for provisioning in that DC.
-  The provisioning process will lazily 'zfs receive' images on CNs as
-  necessary -- streaming from the IMGAPI (imgadm on that machine handles
-  that).
-
-- IMGAPI image manifest data are stored in UFDS and replicated across all
-  DCs, along with fields saying what DCs
-
-- DC 'name' immutable in UFDS? Not currently. Could we enforce that? Else
-  we can't use the "datacenter" name field in DBs. Could use a datacenter
-  uuid as a reference.
-
-  If neither, then need image-presence-in-a-dc to be a separate UFDS node
-  under the datacenter DN.
-
-  TODO: get a plan here
-
-- IMGAPI endpoints:
-
-        GET /images (ListImages)
-        POST /images (CreateImage)
-        GET /images/:uuid (GetImage)
-        DELETE /images/:uuid (DeleteImage)
-        PUT /images/:uuid (PutImage) - allows update of *some* fields, not of file
-        GET /images/:uuid/:path (GetImageFile)
-        GET /assets/:path         # REMOVED
-        PUT /images/:uuid         # REMOVED (the old meaning for adding a dataset)
-
-        POST /images/:uuid?from=https://api.us-west-1.joyent.com/my/images/:uuid (CopyImageFromDC)
-
-  Misc:
-
-        GET / (GetApi) - json view of the API, or redir to the /docs. Meh. Punt for now.
-        GET /ping (Ping) - used for testing, health checking
-
-  Also want ability to copy one of "my" images from one DC to another within
-  the same cloud with the same UUID.
-
-        POST /images?dc=us-west-1&uuid=:uuid
-
-  Look-up us-west-1 in UFDS set of DCs, get an endpoint from which
-  to stream internally.
-
-  Duplicate this image to my own account
-
-        POST /images?duplicate=$uuid (DuplicateImage)
-
-  This is to optionally copy a public image to one's own account. It *does*
-  mean paying for the storage and a new UUID, but guarantees it won't get
-  deleted away from you.
-
-- Requirement (from laurel): support being able to update some metadata
-  fields (e.g. description) without requiring a change to its UUID.
-
-  Updates to metadata fields that don't matter, like "description" will be
-  supported. There will be an explicit list of fields that will be allowed
-  to change in the UpdateImage (PUT /images/:uuid) endpoint. (TODO: come
-  up with this list.) Manifest data is in UFDS and replicated, so shouldn't
-  have a worry about replication. The "CopyImageFromDC" endpoint
-  (which copies an image file to a new DC) persists the UUID will need to
-  make sure to update the list of DCs in which an image is provisionable
-  (or "present" or whatever the verb is).
-
-  Plan: feel this out after have minimal manifest items in place. Walk through
-  scenario.
-
-    - scenario: User adds img in us-east-1. Moves it to us-west-1. Changes
-      the "alias" (or whatever name field) in us-east-1. Now what? UFDS WAN
-      replication should say this is fine.
-    - design constraint: there is no built-in mechanism for moving an img
-      to another SDC cloud (e.g. GCN case). It has a separate UUID in the
-      other cloud. This would mean that UUID implies the same set of
-      metadata.
-
-        -> what about "core" images from images.joyent.com? Can we make that
-           metadata immutable? Or just allow it... but you are on your
-           own. Gentleman's agreement. These are owned by operators only,
-           after all.
-
-- TODO: URN eol of life plan.
-  Notes:
-    - drop URNs?  Yes. GCN WTFs with two bobs... tho the cloud_name *does* help
-      still not worth it
-        - drop version -> confusion, it can be duplicated (and is), so already
-          lost the battle for URN as unique identifier
-        - **** UUID is generated on the server side
-        - cloudapi GetMachine/CreateMachine uses dataset URN. Fuck.
-          Josh suggestion: need to support the old URNs (snapshot of that
-          URN -> UUID mapping at the time of upgrade).
-          use X-Api-Version header to distinguish
-
-- Q: how are the storage mechanisms handled? Does it all stream through the
-  API -- even if in Manta? How does this work in AWS?
-
-    storage: manta, dcls, local
-
-  TODO: plan out how these are handled.
-
-- Q: do we need to support an SDC 6.5 headnode adminui speaking to
-  images.joyent.com? Not sure. I hope not.
-
-  What other tools speak to datasets.joyent.com?
-
-  - imgadm/dsadm. Do we need to support existing imgadm's being converted to
-    talk to images.joyent.com without getting the latest imgadm code?
-  - The internal docs for pushing new datasets. No problem to update those.
-  - ... others?
-
-- Fine-grained access: discuss with Manta folks to have consistency.
-  IOW, defer.
-  The request for IMGAPI here is: groups or restricted_to_uuid *array*.
-  I.e. being able to expose a private img to a number of people.
-
-
-
-
-# Image manifest fields (12-Sep-2012)
-
-Additional or clarified manifest fields from multiple discussions here
-and there. Note: This list is being culled as fields are implemented or
-dropped.
-
-- josh: console_type.
-  This was whether the image is setup for console to be on serial or vga.
-  Josh: "I think we'll want it eventually, but it's probably something that
-  can wait some more." -- Jan 2013
-
-
-# Multi-DC images and the Portal (18-Jun-2012)
-
-Discussion with Trent, Drew and Josh:
-
-- the 6.5 portal page for provisioning requires getting the datasets for
-  the current user availalbe in *each* data center. That is dog slow. Would
-  be good if 7 didn't have this prob.
-- reason for IMGAPI design of having the images be specific to a datacenter
-  is that currently most customer don't provision to multiple datacenters
-  so automatically copying to all DCs is a huge waste. Also there is a cost
-  (time, space, is there a real space cost with Manta as well?) for getting
-  the image data in every DC. That might be billable, so can't automatically
-  push every where.
-- a thought is to have the provisioning process lazily fetch the image from
-  the source datacenter as required. Note that this should be reflected up
-  in the portal UI for users, to explain possible cost and slower first
-  provision, etc.
-
-A design help here would then be to have IMGAPI store sufficient data on
-images and which DCs the images are in **in the replicated part of UFDS**.
-
-
-# Zoneinit and 6.5 <-> 7.x compat (13-Jun-2012)
-
-Discussion with Trent and JoshW.
-
-- Q: What would there be about a "datasets we built for SDC7-only"? Is this
-  just about a more up-to-date platform? "netN" network name changes?
-  Other things? Zoneinit reboot (need to understand that again)?
-  TODO: ask josh
-- Q: is there a backward compat issue here: do we have to worry about a given
-  dataset *only* being provisioned on an SDC 6.5 CN and *not* on a SDC 7 CN?
-  IOW, this would require a *maximum* version on the image manifest.
-
-
-Requirements from the full discussion below:
-
-- Image metadata to express a minimum (platform? sdc?) version needed on the
-  CN to deploy to it.
-  Q: How is this value used?
-- If deemed necessary, we could guard against SDC 6.5 installations getting
-  "only works on SDC 7+" images with a change in SDC 6.5.next MAPI to
-  "refuse to import any dataset that has a minimum_sdc_version at all".
-  Not sure if this is necessary, tho. An SDC 6.5 data center nominally only
-  gets new datasets via (a) operator action and (b) typically from
-  datasets.joyent.com. So if we just never add SDC7 datasets to
-  datasets.joyent.com, then we should be good.
-
-
-Full discussion:
-
-    joshw: yeah.  The other thing we should consider is a flag on datasets "only works with versions newer than X"
-    trent: versions of what? Of the CNAPI ? or of the platform (i.e. the compute node version)
-    joshw: Yeah, I don't know that either (which version should win).  But I don't want people trying to install datasets we built for SDC7-only on SDC6.5
-    trent: do we try to get in a change to 6.5.5 that will recognize this flag on datasets and give a nice error message?
-    joshw: If we have to always make all our new datasets work on 6.5 we're digging ourselves an even bigger hole.
-    joshw: I think we should.
-    joshw: This also might help us encourage people to upgrade to SDC7. :)
-    trent: k, so we need to spec that... and get it into (at least) provisioner-v2 (?) and cloudapi maybe
-    joshw: Might need to involve MAPI. :(
-    joshw: Actually that's one way.
-    trent: also... the cloudapi endpoint to list available datasets should then exclude those datasets?
-    trent: that'll be gross.
-    joshw: We could just have MAPI refuse to import any dataset that has a minimum_sdc_version at all. :)
-    joshw: Since MAPI only exists in 6.5
-    trent: Hrm. My point is that the "encouragement" is at the wrong level: the customer is out of luck, but it is the operator that needs to upgrade.
-    trent: ah, yah. dataset can't import. That's better.
-    joshw: yeah, that puts the pain on the operator.
-    joshw: I can't offer this dataset to my customers until I upgrade.
-    trent: *but* this only works for MAPIs running sdc 6.5.5
-    trent: so perhaps we update adminui's calling to datasets.joyent.com to pass in its version (the X-Api-Version header)
-    trent: and the DSAPI doesn't show those datasets unless X-Api-Version >= 6.5.5
-    trent: (actually would be a different header)
-    joshw: I thought we actually added something for this already now that we're discussing it.
-    joshw: Perhaps an even easier option!
-    joshw: I just thought of. :)
-    trent: no :(    We discussed it, but didn't happen.
-    joshw: how about we only show SDC7 dataset if you *DO* pass the X-API-Version header. :D
-    trent: yah... that was what we'd originally discussed
-    joshw: That way we don't need to modify sdc 6.5 at all.
-    joshw: It'll just not see the new datasets.
-    trent: oh, you mean we keep running the same server for datasets.joyent.com and whatever SDC7's adminui looks at?
-    joshw: Well, that's true too. If we have the new imgapi it won't even matter I suppose.
-    joshw: Since you'll not get those datasets in your list.
-    joshw: (ones that are only in our imgapi)
-    trent: I'm flailing a little bit here. I need to think about it.
-    trent: Will sdc7's vmadm always support running the older datasets (from sdc6 era)?
-    trent: i.e. it'll look at this manifest attribute and presume the zoneinit-reboot-shit if it doesn't say "this is an sdc7 zoneinit-free dataset".
-    joshw: That's another open question.
-    joshw: And one of the reasons I don't like that all this logic is in the dataset. :(
-    joshw: I guess that's something I need to ask bryan.
-    trent: i think that's going to be a requirement
-    joshw: Probably.
-    joshw: But for how long?
-    trent: I meant, zoneinit is going to live on.
-    joshw: Oh, yeah.
-    trent: s/meant/mean/
-    joshw: We rev all our datasets every once in a while and I don't think old versions stay available now either though.
-    joshw: Right?
-    joshw: if I go to https://datasets.joyent.com/datasets/ I only get the latest.
-    trent: (so, I'm guessing the requirement will be: and SDC7 compute node must support SDC6-era datasets. The only exception woudl be *platform* incompat. Zoneinit incompat wouldn't be acceptable.)
-    trent: dataset revs: two things at play here
-    joshw: or maybe not.  I see some older ones there too.
-    trent: datasets.joyent.com *does* delete obsolete dataset every so often yes.
-    trent: that's for ops tho
-    joshw: ok.
-    trent: the question is what ops are doing in the MAPI list of datasets
-    trent: in *JPC* I believe they are "hiding" older datasets, yes.
-    trent: where "hiding" is a disable attribute on the MAPI Dataset model (or something)
-    trent: so, currently I *think* we could get away with rev'ing everything. But you'd still have to have datasets that can provision fine to either CN-1 (which is running sdc 6.5 platform) or CN-2 (which is running sdc 7 platform).
-    trent: or is that wrong? To migrate to having images that provision with*out* the zoneinit reboot, you have to disallow provisioning those on a CN running sdc 6.5 platform.
-    trent: gah. we should talk face to face tomorrow. Yah?
-    joshw: Yeah. Maybe what I have to do is have vmadm grep zoneinit and see if it's going to try a reboot. :)
-    trent: lol
-    joshw: I'm only half kidding.
-
-
-# Manta or not to manta (01-Jun-2012)
-
-Manta is optional. So IMGAPI needs to support DCL as a backup or alternative
-or both. DCL === Bill's datacenter local storage.
-
-MarkC: "besides, manta is deployed via images, so it sort of needs imgapi in
-the first place to get going :\ this is complicated, i fear."
-
-Bryan req: allow non-op images to be on local storage (i.e. non-manta) Have a
-whitelist of UUIDs.
-
-
-
-# Design, Requirements, etc from Trevor (09-Mar-2012)
-
-Design & Requirements:
-
-* DSAPI is "per datacenter" which means no automatic updates between
-  datacenters. One potential caveat with that is having different names
-  or UUIDs for the same dataset if they are pushed to different locations.
-  Amazon currently does this, but I think we can do better.
-* We should never prevent someone from deleting an image
-* To maintain a "guarantee" that an image is always available, a user has
-  to create their own from an existing image using the "Creating & Publishing
-  Datasets" instructions / flow
-* Customers should be billed for how much storage space they are using
-  (not intended to be your problem at all!)
-* No charge for creating an image, but a cost associated with keeping that
-  image in some storage location
-* If someone wants to deploy an image to a second datacenter, then they have to
-  manually issue a "deploy to DC" / "copy to DC" request which will copy the image
-  over the WAN
-  [See "CopyImageFromDC" endpoint above.]
-
-
-
-Creating and Publishing Datasets. The workflow is written from an end-users
-perspective:
-
-* The user provisions a machine using cloudAPI
-* They log into the machine and customize the machine to their
-  liking. There is no telling what someone will do, but they will have
-  access to all of the services / apis that a machine normally would,
-  and will have to take that into account when "prepping" their machine.
-* After customizing their machine, they can run the "prepare-image"
-  tool which will reset and remove things like
-    - ssh keys
-    - ssh host keys
-    - ipaddress/hostname values
-    - dhcp leases / etc
-    - other config settings we know need to change if we're to deploy
-      numerous times
-* They can then shutdown the machine elegantly
-* After the machine is shutdown, they can take a snapshot
-* After the snapshot is complete, they can turn the snapshot into an
-  image. Whatever tools they use for this will ask them for manifest
-  information that is not automatically populated by the server.
-* When a snapshot is turned into an image, it is sent off of the CN
-  using zfs send | compression | transport mechanism > destination,
-  where destination is some storage location / LOCAL DSAPI endpoint.
-* The Local DSAPI is the only system to receive the Dataset. Datasets
-  are not to be automatically replicated to different datacenters.
-* After the manifest is uploaded, then it is immediately available to the
-  OWNER. The OWNER is initially defined as the user that uploaded the
-  dataset.
-* At any time, the OWNER can change the SCOPE of of the dataset to
-  "public" so that anyone can provision the dataset.
-* If a dataset is "public" then anyone with access to the DSAPI can
-  view and launch instances using that dataset.
-
-Role Based Access Control - RBAC:
-
-* The owner of a manifest is the only one who can delete or modify the manifest
-  or image
-
-Manifests:
-
-* Manifests should include an optional "icon" key which has a URL of an icon as
-  its value. The size of an icon is one of 512x512, 256x256, or 128x126. This
-  suggests DSAPI needs to actually store these icons, so that they can be
-  validated for size. It should be possible for a user to change this icon
-  after the manifest has been created.
diff --git a/docs/index.md b/docs/index.md
index 23ce9f5..c05284b 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -11,7 +11,7 @@ apisections: Images, Channels, Miscellaneous API
 -->
 
 <!--
-    Copyright (c) 2015, Joyent, Inc.
+    Copyright (c) 2016, Joyent, Inc.
 -->
 
 # Image API (IMGAPI)
@@ -631,6 +631,7 @@ and relevant for images in an IMGAPI server that uses [channels](#channels).
 | [ListChannels](#ListChannels)                     | GET /channels                                              | List image channels (if the server uses channels).                            |
 | [ChannelAddImage](#ChannelAddImage)               | POST /images/:uuid?action=channel-all                      | Add an existing image to another channel.                                     |
 | [Ping](#Ping)                                     | GET /ping                                                  | Ping if the server is up.                                                     |
+| [AdminReloadAuthKeys](#AdminReloadAuthKeys)       | POST /authkeys/reload                                          | (Added in v2.3.0.) Tell server to reload its auth keys. This is only relevant for servers using HTTP Signature auth. |
 
 
 
@@ -688,15 +689,16 @@ There are two typical calling styles to this endpoint: with 'account=$UUID' and
 without. The former is what cloudapi uses to ask on behalf of a particular
 authenticated account. The latter is for operator-only querying.
 
+
 ### Inputs
 
 | Field                 | Type       | Required? | Notes |
 | --------------------- | ---------- | --------- | ----- |
 | account (query param) | UUID       | No        | Only allow access to images visible to this account. A user can see: (a) their own images, (b) activated public images, and (c) activated private images for which they are on the ACL. Note that "activated" is different than "active" (see [state](#manifest-state)). This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
 | channel (query param) | String     | No        | The image channel to use. If not provided the server-side default channel is used. Use '*' to list in all channels. (Only relevant for servers using [channels](#channels).) |
-| inclAdminFields (query param) | Bool | No      | Pass `true` to include administrative fields (e.g. `files.*.stor`) in the returned image objects. For IMGAPI servers using ['mode'](#configuration) other than `dc`, auth is required to use `admin=true`. Otherwise, `UnauthorizedError` is returned. |
+| inclAdminFields (query param) | Bool | No      | Pass `true` to include administrative fields (e.g. `files.*.stor`) in the returned image objects. For IMGAPI servers using ['mode'](./operator-guide.md#configuration) other than `dc`, auth is required to use `admin=true`. Otherwise, `UnauthorizedError` is returned. |
 | owner                 | UUID       | No        | Only list images owned by this account.                                                                                                                                                                                                                            |
-| state                 | String     | No        | List images with the given state. Can be one of 'active' (the default), 'disabled', 'unactivated' or 'all'.                                                                                                                                                        |
+| state                 | String     | No        | List images with the given state. Can be one of 'active' (the default), 'disabled', 'unactivated' or 'all'. Note that for standalone IMGAPI instances, unauthenticated requests are limited to 'active' images. |
 | name                  | String     | No        | List images with the given name. Prefix with `~` to do a substring match (case-*sensitive*). E.g., `~foo`.                                                                                                                                                         |
 | version               | String     | No        | List images with the given version. Prefix with `~` to do a substring match (case-*sensitive*). E.g., `~foo`.                                                                                                                                                      |
 | public                | Boolean    | No        | List just public or just private images.                                                                                                                                                                                                                           |
@@ -867,7 +869,7 @@ authenticated account. The latter is for operator-only querying.
 | --------------------- | ------ | --------- | ----- |
 | account (query param) | UUID   | No        | Only allow access to images visible to this account. A user can see: (a) their own images, (b) activated public images, and (c) activated private images for which they are on the ACL. Note that "activated" is different than "active" (see [state](#manifest-state)). This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                 |
-| inclAdminFields (query param) | Bool | No  | Pass `true` to include administrative fields (e.g. `files.*.stor`) in the returned image objects. For IMGAPI servers using ['mode'](#configuration) other than `dc`, auth is required to use `admin=true`. Otherwise, `UnauthorizedError` is returned. |
+| inclAdminFields (query param) | Bool | No  | Pass `true` to include administrative fields (e.g. `files.*.stor`) in the returned image objects. For IMGAPI servers using ['mode'](./operator-guide.md#configuration) other than `dc`, auth is required to use `admin=true`. Otherwise, `UnauthorizedError` is returned. |
 
 ### Returns
 
@@ -953,7 +955,7 @@ Get the image file.
 
 | Field                 | Type   | Required? | Notes                                                                                                                                                                                                                                                                |
 | --------------------- | ------ | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 
 ### Returns
@@ -999,7 +1001,7 @@ Get the image icon file.
 
 | Field                 | Type   | Required? | Notes                                                                                                                                                                                                                                                                |
 | --------------------- | ------ | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 
 ### Returns
@@ -1044,7 +1046,7 @@ authenticated account. The latter is for operator-only querying.
 
 | Field                 | Type   | Required? | Notes                                                                                                                               |
 | --------------------- | ------ | --------- | ----------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow deletion for images *owned* by this account. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow deletion for images *owned* by this account. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                  |
 
 ### Returns
@@ -1082,7 +1084,7 @@ For IMGAPI servers that support image channels (e.g. updates.joyent.com)
 
 | Field                            | Type    | Required? | Notes                                                                                                                                        |
 | -------------------------------- | ------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param)            | UUID    | No        | Only allow deletion for images *owned* by this account. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers.          |
+| account (query param)            | UUID    | No        | Only allow deletion for images *owned* by this account. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers.          |
 | channel (query param)            | String  | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                           |
 | force_all_channels (query_param) | Boolean | No        | Set this true to force deletion even if the image exists in multiple channels. Only relevant for IMGAPI servers using [channels](#channels). |
 
@@ -1126,7 +1128,7 @@ provisioning.
 
 | Field                                                    | Type    | Required?                | Notes                                                                                                                                                                                                                                                                                                                                                                       |
 | -------------------------------------------------------- | ------- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param)                                    | UUID    | Yes\*                    | The account UUID on behalf of whom this request is being made. If given and if relevant, authorization will be done for this account. At least one of `account` or `owner` is required. It is expected that all calls originating from a user (e.g. from cloudapi) will provide this parameter. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param)                                    | UUID    | Yes\*                    | The account UUID on behalf of whom this request is being made. If given and if relevant, authorization will be done for this account. At least one of `account` or `owner` is required. It is expected that all calls originating from a user (e.g. from cloudapi) will provide this parameter. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param)                                    | String  | No                       | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                                                                                                                          |
 | [owner](#manifest-owner)                                 | UUID    | Yes\*                    | The UUID of the owner of this image (the account that created it). If not given, the given `account` is used. At least one of `account` or `owner` is required.                                                                                                                                                                                                             |
 | [name](#manifest-name)                                   | String  | Yes                      | A short name (and optionally version) for this image. Max 512 characters. No uniqueness guantee.                                                                                                                                                                                                                                                                            |
@@ -1520,7 +1522,7 @@ or [*deleted*](#DeleteImage) permanently.
 
 | Field                 | Type   | Required? | Notes                                                                                                                                                                                                                                                                |
 | --------------------- | ------ | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 
 ### Returns
@@ -1582,7 +1584,7 @@ Disables the image. This makes the image unavailable for provisioning -- the
 
 | Field                 | Type   | Required? | Notes                                                                                                                                                                                                                                                                |
 | --------------------- | ------ | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 
 ### Returns
@@ -1644,7 +1646,7 @@ the `state` field will be "active".
 
 | Field                 | Type   | Required? | Notes                                                                                                                                                                                                                                                                |
 | --------------------- | ------ | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param) | UUID   | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param) | String | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 
 ### Returns
@@ -1846,7 +1848,7 @@ Any input is optional but at least one attribute must be updated.
 
 | Field                                                    | Type    | Required? | Notes                                                                                                                                                                                                                                                                |
 | -------------------------------------------------------- | ------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| account (query param)                                    | UUID    | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](#configuration) IMGAPI servers. |
+| account (query param)                                    | UUID    | No        | Only allow access to an image visible to this account. A user can only see: (a) active public images, (b) active private images for which they are on the ACL, and (c) their own images. This field is only relevant for ['mode=dc'](./operator-guide.md#configuration) IMGAPI servers. |
 | channel (query param)                                    | String  | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                   |
 | [description](#manifest-description)                     | String  | No        | A short description of the image.                                                                                                                                                                                                                                    |
 | [homepage](#manifest-homepage)                           | URL     | No        | Homepage URL where users can find more information about the image.                                                                                                                                                                                                  |
@@ -2095,7 +2097,7 @@ Raw `curl`:
 (Added in IMGAPI v2.2.0.)
 
 Change which storage is used to store an image's file. An IMGAPI server is
-[configured](#configuration) with one or more storage backends (e.g. "local"
+[configured](./operator-guide.md#configuration) with one or more storage backends (e.g. "local"
 and "manta"). This endpoint allows operators (servers in modes other
 than "dc" require auth to use this endpoint), to control where image files
 are stored. One use case is an operator of a "public" IMGAPI server moving
@@ -2111,7 +2113,7 @@ Query params:
 | Field   | Type    | Required? | Notes |
 | ------  | ------- | --------- | ----- |
 | action  | String  | Yes       | "change-stor" |
-| stor    | String  | Yes       | The new storage type (see "storage.*" fields in the IMGAPI server [config](#configuration)). |
+| stor    | String  | Yes       | The new storage type (see "storage.*" fields in the IMGAPI server [config](./operator-guide.md#configuration)). |
 
 
 ### Returns
@@ -2210,7 +2212,7 @@ See [Errors](#errors) section above.
 
 An IMGAPI server can use "channels". Each channel is an independent set of
 images in the same server. The set of channels is a [static
-configured](#configuration) set of channel names, optionally with a default
+configured](./operator-guide.md#configuration) set of channel names, optionally with a default
 channel. Use [ListChannels](#ListChannels) to see the server's configured
 channels.
 
@@ -2361,9 +2363,10 @@ When not simulating an error response, a "pong" object is returned:
 | Field   | Type    | Description                                                                         |
 | ------- | ------- | ----------------------------------------------------------------------------------- |
 | ping    | String  | "pong"                                                                              |
-| pid     | String  | The PID of IMGAPI server process. Only for non-"public" mode IMGAPI configurations. |
 | version | String  | The version of the IMGAPI app.                                                      |
-| imgapi  | Boolean | true                                                                                |
+| imgapi  | Boolean | Always set `true`. This is to distinguish the server from the old Datasets API that IMGAPI replaced. |
+| pid     | String  | The PID of IMGAPI server process. Only for "dc" mode IMGAPI configurations, or when providing auth. |
+| user    | String  | Set to the authenticated username, if relevant. Note that "dc" mode servers don't use auth. |
 
 When simulating an error, the HTTP response code depends on the error type
 and the response body is an JSON object with:
@@ -2438,259 +2441,30 @@ A JSON representation of some internal state.
       ...
     }
 
+## AdminReloadAuthKeys (POST /authkeys/reload)
 
-# Image file storage
-
-There are two possible storage mechanisms for the (large) image files (and image
-icon files). Which are in use depend on the IMGAPI configuration (and
-availability in the DC).
-
-1. manta: Requires an available Manta. All files are stored in the configured
-   user's Manta area (e.g. under "/a-dc-operator/stor/imgapi/"), as opposed
-   to storing images own by Bob under Bob's area in Manta.
-   Manta storage may be local (i.e. within the same region, this is preferred)
-   or remote (a Manta across the WAN).
-2. local: A local dir (or locally mounted dir). Only really meant for testing,
-   development and bootstrapping. Generally 'local' usage is insufficient
-   for producion usage because a locally mounted dir can't handle HA (imgapi
-   zones on more than one server).
-
-The set of available storages is set in the [configuration](#configuration).
-For example:
-
-    "storage": {
-        "manta": {
-            "url": "https://us-east.manta.joyent.com",
-            "user": "admin",
-            "insecure": false,
-            "remote": true,
-            "key": "/root/.ssh/imgapi.id_rsa",
-            "keyId": "59:8a:63:3f:9d:5d:69:5f:cf:37:2e:0d:84:80:91:da"
-        },
-        "local": {
-            "baseDir": "/data/imgapi"
-        }
-    }
-
-The [`<imgapi-zone>:/opt/smartdc/imgapi/bin/imgapi-manta-setup`](https://github.com/joyent/sdc-imgapi/blob/master/bin/imgapi-manta-setup)
-and [`<imgapi-zone>:/opt/smartdc/imgapi/bin/imgapi-external-manta-setup`](https://github.com/joyent/sdc-imgapi/blob/master/bin/imgapi-external-manta-setup)
-scripts are intended for use in setting up an IMGAPI to use a Manta.
-
-Local Manta storage, if available, is used in preference to "local" storage.
-Manta storage is *required* for user custom image creation, i.e. CloudAPI's
-[CreateImageFromMachine](http://apidocs.joyent.com/cloudapi/#CreateImageFromMachine),
-unless [overriden](howto-enable-custom-image-creation-without-manta).
-
-If Manta storage is available *but is remote*, then which storage is used is a
-little more complicated. The intention is that user-created custom images
-(i.e. IMGAPI's CreateImageFromVm, aka CreateImageFromMachine on cloudapi) go
-to Manta. However, admin-managed public images for the DC are typically large
-and can't practically live in a remote Manta. Therefore the algorithm is that
-"admin"-owned images prefer local storage to "remote Manta" storage. Images
-owned by others prefer remote Manta storage to local storage.
-
-
-# Configuration
-
-Reference docs on configuration vars to imgapi. Default values are in
-"etc/defaults.json". Custom values are provided in a JSON file passed in with
-the "-f CFG-FILE" command-line option. By default this is
-"./etc/imgapi.config.json". Note that given custom values override full
-top-level keys in the factory settings. For example: if providing
-'ufds', one must provide the whole 'ufds' object.
-
-| var | type | default | description |
-| --- | ---- | ------- | ----------- |
-| port | Number | 8080 | Port number on which to listen. |
-| serverName | String | IMGAPI/$version | Name of the HTTP server. This value is present on every HTTP response in the 'server' header. |
-| logLevel | String/Number | debug | Level at which to log. One of the supported Bunyan log levels. This is overridden by the `-d,--debug` switch. |
-| maxSockets | Number | 100 | Maximum number of sockets for external API calls |
-| mode | String | public | One of 'public' (default, running as a public server e.g. images.joyent.com), 'private' (a ironically "public" server that only houses images marked `public=false`), or 'dc' (running as the IMGAPI in an SDC datacenter). |
-| datacenterName | String | - | Name of the SDC datacenter on which IMGAPI is running. |
-| adminUuid | String | - | The UUID of the admin user in this SDC. |
-| channels | Array | - | Set this make this IMGAPI server support [channels](#channels). It must be an array of channel definition objects of the form `{"name": "<name>", "description": "<desc>"[, "default": true]}`. See the example in "etc/imgapi.config.json.in". |
-| placeholderImageLifespanDays | Number | 7 | The number of days after which a "placeholder" image (one with state 'failed' or 'creating') is purged from the database. |
-| allowLocalCreateImageFromVm | Boolean | false | Whether to allow CreateImageFromVm using local storage (i.e. if no manta storage is configured). This should only be enabled for testing. For SDC installations of IMGAPI `"IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM": true` can be set on the metadata for the 'imgapi' SAPI service to enable this. |
-| minImageCreationPlatform | Array | see defaults.json | The minimum platform version, `["<sdc version>", "<platform build timestamp>"]`, on which the proto VM for image creation must reside. This is about the minimum platform with sufficient `imgadm` tooling. This is used as an early failure guard for [CreateImageFromVm](#CreateImageFromVm). |
-| ufds.url | String | - | LDAP URL to connect to UFDS. Required if `mode === 'dc'`. |
-| ufds.bindDN | String | - | UFDS root dn. Required if `mode === 'dc'`. |
-| ufds.bindPassword | String | - | UFDS root dn password. Required if `mode === 'dc'`. |
-| auth | Object | - | If in 'public' mode, then auth details are required. 'dc' mode does no auth. |
-| auth.type | String | - | One of 'basic' (HTTP Basic Auth) or 'signature' ([HTTP Signature auth](https://github.com/joyent/node-http-signature)). |
-| auth.users | Object | - | Required if `auth.type === 'basic'`. A mapping of username to bcrypt-hashed password. Use the `bin/hash-basic-auth-password` tool to create the hash. |
-| auth.keys | Object | - | Required if `auth.type === 'signature'`. A mapping of username to an array of ssh public keys. |
-| database | Object | - | Database info. The "database" is how the image manifest data is stored. |
-| database.type | String | ufds | One of 'ufds' (the default, i.e. use an SDC UFDS directory service) or 'local'. The 'local' type is a quick implementation appropriate only for smallish numbers of images. |
-| database.dir | String | - | The base directory for the database `database.type === 'local'`. |
-| storage | Object | - | The set of available storage mechanisms for the image *files*. There must be at least one. See the [Image file storage](#image-file-storage) section for discussion. |
-| storage.local | Object | - | Object holding config information for "local" disk storage. |
-| storage.local.baseDir | String | - | The base directory in which to store image files and archived manifests for "local" storage. This is required even if "storage.manta" is setup for primary storage, because image manifest archives are first staged locally before upload to manta. |
-| storage.manta | Object | - | Object holding config information for Manta storage. |
-| storage.manta.baseDir | String | - | The base directory, relative to '/${storage.manta.user}/stor', under which image files are stored in Manta. |
-| storage.manta.url | String | - | The Manta API URL. |
-| storage.manta.insecure | Boolean | false | Ignore SSL certs on the Manta URL. |
-| storage.manta.remote | Boolean | - | Whether this Manta is remote to this IMGAPI. This helps IMGAPI determine practical issues on whether manta or local storage is used for large files. |
-| storage.manta.user | String | - | The Manta user under which to store data. |
-| storage.manta.key | String | - | Path to the SSH private key file with which to authenticate to Manta. |
-| storage.manta.keyId | String | - | The SSH public key ID (signature). |
-| wfapi.url | String | - | The Workflow API URL. |
-| wfapi.workflows | String | - | Array of workflows to load. |
-| wfapi.forceReplace | Boolean | - | Wether to replace all workflows loaded every time the IMGAPI service is started. Ideal for development environments |
-
-
-
-# Operator Guide
-
-This section is intended to give necessary information for diagnosing and
-dealing with issues with Image API in a SmartDataCenter installation.
-
-There is one IMGAPI service per datacenter. There might actually be more than
-one "imgapi" zone for HA. Use this to list the imgapi zones in a DC:
-
-    sdc-vmapi /vms?owner_uuid=$(bash /lib/sdc/config.sh -json | json ufds_admin_uuid) \
-        | json -H -c "this.tags.smartdc_role=='imgapi'"
-
-
-## Logs
-
-| service/path | where | format | tail -f |
-| ------------ | ----- | ------ | ------- |
-| imgapi | in each "imgapi" zone | [Bunyan](https://github.com/trentm/node-bunyan) | `` sdc-login imgapi; tail -f `svcs -L imgapi` | bunyan `` |
-
-
-## HOWTO: Enable custom image creation without Manta
-
-By default, an IMGAPI in SDC only allows custom image creation (via the
-CreateImageFromVm endpoint) if it is configured with Manta storage for
-custom image files. However for *test* SDC standups you can hack IMGAPI
-to allow local custom image storage.
-
-The symptom of needing to do this from cloudapi or the node-smartdc CLI is:
-
-    $ sdc-createimagefrommachine --machine 3d68ee48-d1fa-685c-9c33-e23064141138 --imageVersion 1.0.0 --name image1 --description "Does this work"
-    sdc-createimagefrommachine: error (NotAvailable): custom image creation is not currently available
-
+Tells the IMGAPI server to reload its auth keys, if the server is using HTTP Signature auth
+(`config.authType === "signature"`). This is an authenticated endpoint. This allows a
+server administrator to add keys for users and have the server load those key changes
+without having to restart.
 
-To allow custom images using *local* storage, run the following in your
-SDC headnode global zone:
+Note that when this endpoint returns, the reload is not guaranteed to have completed.
 
-    echo '{"metadata": {"IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM": true}}' \
-      | sapiadm update $(sdc-sapi /services?name=imgapi | json -H 0.uuid)
 
-When the 'config-agent' running in the imgapi zone picks up this change
-(after about 30s), the imgapi service will be restarted with
-`"allowLocalCreateImageFromVm": true` (see [the Configuration
-section](#configuration) above).
-
-
-## HOWTO: Dig into IMGAPI's Manta storage
-
-If this IMGAPI is setup to use Manta.
-
-        HN=stage2    # my SDC headnode login
-
-        # Get one of the Manta LB IPs:
-        export MANTA_URL=https://$(ssh $HN "/opt/smartdc/bin/sdc-vmapi /vms?tag.manta_role=loadbalancer | json -H -c 'this.state==\"running\"' 0.nics | json -c 'this.nic_tag==\"external\"' 0.ip" 2>/dev/null)
-
-        # Get a local copy of the admin SSH key being used for Manta access
-        # (or add your own to the admin user).
-        ZONENAME=$(ssh $HN vmadm lookup -1 alias=imgapi0)
-        mkdir -p /var/tmp/$HN
-        cd /var/tmp/$HN
-        scp $HN:/zones/$ZONENAME/root/root/.ssh/id_rsa* .
-
-        # This would be sufficient for python-manta and mantash:
-        #    export MANTA_KEY_ID=`pwd`/id_rsa
-        # However, node-manta tools are a little more picky. You need to
-        # have your id_rsa in ~/.ssh or in your agent. So we'll do the
-        # latter:
-        chmod 0600 id_rsa*
-        ssh-add `pwd`/id_rsa
-        MANTA_KEY_ID=$(ssh-keygen -l -f id_rsa.pub | awk '{print $2}')
-
-        export MANTA_USER=admin
-        set | grep MANTA_
-
-        # With mantash from python-manta:
-        mantash -k find /admin/stor/imgapi
-
-        # With node-manta tools:
-        # TODO: I think node-manta tools don't support a non-default path
-        # to the ssh key?
-
-
-## Configuring IMGAPI for HTTPS
-
-This section is for setting up an IMGAPI that lives *outside* of an SDC
-installation. Examples of this are for <https://images.joyent.com> and
-<https://updates.joyent.com>.
-
-On SmartOS, IMGAPI can be deployed to support HTTPS with the use of Stud
-(https://github.com/bumptech/stud) as a SSL/TLS termination proxy. Because of the
-way Stud works we need to put an additional reverse proxy between Stud and IMGAPI:
-HAProxy. The only caveat here is that the latest version of HAProxy doesn't
-fully understand the traffic coming from Stud, so we use a patched version of
-the package.
-
-### Prerequisites and Assumptions
-
-* IMGAPI running on an Image with at least a 2012Q2 release of pkgsrc
-* IMGAPI running on port 8080 if using configuration defaults
-* Generated certficate file
-* gmake
-
-### Installing and Configuring HAProxy
-
-The IMGAPI repository contains the patched copy of HAProxy under the deps/
-directory. cd to that directory and proceed to compile HAProxy as follows:
-
-    cd $IMGAPI_REPO/deps/haproxy-1.4.21/
-    gmake TARGET=solaris
-
-It's not necessary to move the resulting binary to another location. Now, we need
-to configure HAProxy. This repository contains a sample configuration file (on
-etc/haproxy.cfg.in) that will make the proxy listen on port 8443 and redirect
-its traffic to port 8080.
-
-The final step is to import the HAProxy SMF file in order to run the proxy as a
-service. The IMGAPI repository contains a sample service definition file that
-can be imported after updating the exec_method tag and config_file values to
-reflect the current install setup. With a valid SMF file we can proceed to
-import it and start running HAProxy:
-
-    cp $IMGAPI_REPO/smf/manifests/haproxy.xml.in $IMGAPI_REPO/smf/manifests/haproxy.xml
-    # --- Replace variables ---
-    svccfg import $IMGAPI_REPO/smf/manifests/haproxy.xml
-    svcadm enable haproxy:default
+### Inputs
 
-### Installing and configuring Stud
+None.
 
-Configuring Stud is easier since it doesn't require a custom binary, we use the
-version provided by pksrc. Additionally, pkgsrc provides a sample SMF and
-configuration file to use for Stud. Begin by installing the package:
+### Returns
 
-    # Install Stud
-    pkgin -y in stud-0nb20120827
+An empty object: `{}`.
 
-This package will write a sample configuration file to /opt/local/etc/stud.conf.
-For this guide we assume that Stud will terminate and redirect its traffic to a
-service listening on port 8443. The only additional value we need to modify
-is pem-file, which specifies the location of the SSL certificate to use. After
-updating the configuration file we enable the Stud SMF service, since the sample
-SMF file was already imported (assuming we are OK with using
-/opt/local/etc/stud.conf as the location for our configuration file):
+### Examples
 
-    svcadm enable stud:default
+    $ updates-imgadm reload-auth-keys
 
-At this point Stud, HAProxy and IMGAPI should all be running correctly. We can
-confirm this with the help of the netstat command:
 
-    netstat -f inet -an
+# Configuration
 
-    TCP: IPv4
-       Local Address        Remote Address    Swind Send-Q Rwind Recv-Q    State
-    -------------------- -------------------- ----- ------ ----- ------ -----------
-          *.8080               *.*                0      0 128000      0 LISTEN
-          *.8443               *.*                0      0 128000      0 LISTEN
-    127.0.0.1.8081             *.*                0      0 128000      0 LISTEN
-          *.443                *.*                0      0 128000      0 LISTEN
+Details on IMGAPI instance configuration was moved to the [Operator
+Guide](./operator-guide.md@configuration).
diff --git a/docs/operator-guide.md b/docs/operator-guide.md
new file mode 100644
index 0000000..cd5c78f
--- /dev/null
+++ b/docs/operator-guide.md
@@ -0,0 +1,661 @@
+---
+title: IMGAPI Operator Guide
+markdown2extras: tables, code-friendly, cuddled-lists
+apisections:
+---
+
+# IMGAPI Operator Guide
+
+This document is a guide for operators of an IMGAPI. Users of IMGAPI can
+refer to the [User Guide](./index.md).
+
+There are two main types of IMGAPI:
+
+1. `DC-mode`: An instance that is part of the core "imgapi" service in a Triton
+   DataCenter. An in-DC IMGAPI is configured with `mode === "dc"`. It serves
+   HTTP over the DC's "admin" network. It optionally has a firewalled (external
+   connections only) NIC on an external network to be able to reach out (to
+   import from standalone IMGAPIs, or pull from Docker registries).
+
+2. `standalone`: A standalone IMGAPI, that runs independent of a Triton
+   DataCenter. These are configured with `mode === "public"` (for public images,
+   example "images.joyent.com") or `mode === "private"` (for repos with private
+   images, example "updates.joyent.com"). These server HTTPS over a public
+   network (via stud for SSL termination, to HAproxy for possible load
+   balancing, to one or more node.js IMGAPI processes). They are typically
+   configured to use HTTP Signature auth (like Triton's CloudAPI and Manta's web
+   API) for any write endpoints.
+
+# Image
+
+Both types of IMGAPI instances use "imgapi" images built from sdc-imgapi.git and
+mountain-gorilla.git on Joyent's internal CI build system and released to
+[Joyent's Updates Image repository](https://updates.joyent.com).
+
+
+# DC-Mode Setup
+
+A DC-mode IMGAPI instance is setup via standard Triton DataCenter headnode
+setup. See
+[headnode.sh](https://github.com/joyent/sdc-headnode/blob/master/scripts/headnode.sh).
+
+## DC-mode setup: add an external NIC
+
+For a DC-mode IMGAPI to import images -- e.g. from images.joyent.com to add base
+images for users of the DC, or from updates.joyent.com for updating the Triton
+DC -- the IMGAPI instance requires an external NIC. The instance is firewalled
+to only allow outgoing connections. The external NIC can be added (and to the
+adminui instance) via:
+
+    sdcadm post-setup common-external-nics
+
+
+## DC-mode setup: connect to Manta
+
+For durable image storage (and to enable image creation which intentionally
+fails without durable storage), a DC-mode IMGAPI instance needs to be given
+Manta connection details.
+
+This can be done by running one of the following scripts (they must be run
+from inside the imgapi zone):
+
+    # Use a Manta that is part of this same Triton cloud (i.e. shares the
+    # same account database):
+    imgapi-manta-setup MANTA_URL [OPTIONS] | bunyan
+
+    # Use a Manta that is not part of this Triton cloud:
+    imgapi-external-manta-setup MANTA_URL MANTA_USER PATH_TO_PRIV_KEY | bunyan
+
+(Dev Note: Longer term this responsibility should move to a `sdcadm post-setup ...` command.)
+
+
+## DC-mode setup: enable custom image creation without Manta
+
+(This step is optional, and typically solely for development.)
+
+By default, a DC-mode IMGAPI only allows custom image creation (i.e. the
+[CreateImageFromVm](./index.md#CreateImageFromVm] endpoint) if it is configured
+with Manta storage for custom image files. However for *test* Triton DataCenter
+standups you can hack IMGAPI to allow local custom image storage.
+
+The symptom of needing to do this from cloudapi or the node-smartdc CLI is:
+
+    $ triton image create 3d68ee48-d1fa-685c-9c33-e23064141138 myimage 1.0.0
+    triton image create: error (NotAvailable): custom image creation is not currently available
+
+To allow custom images using *local* storage, run the following in your
+SDC headnode global zone:
+
+    echo '{"metadata": {"IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM": true}}' \
+      | sapiadm update $(sdc-sapi /services?name=imgapi | json -H 0.uuid)
+
+When the 'config-agent' running in the imgapi zone picks up this change
+(after about 30s), the imgapi service will be restarted with
+`"allowLocalCreateImageFromVm": true` (see [the Configuration
+section](#configuration) above).
+
+# Standalone Setup
+
+A standalone IMGAPI instance is just a regular instance. However two reasons
+mean we can't use stock `triton` to provision one:
+
+- We use 'imgapi' images from updates.joyent.com, which can only be imported
+  to a DC by an operator.
+  Dev Note: Eventually this could move to custom image builds by the user that
+  owns the imgapi instance. Preferably this would be via a `triton build`
+  that automates this.
+- We want (for good updating we currently require) a delegated dataset, which
+  isn't yet an exported feature of CloudAPI's CreateMachine.
+
+*Warning:* Currently, standalone IMGAPI code does not support multiple instances
+using the same Manta area. It is up to the operator to guard against this. If
+two instances are writing to the same Manta area, they could cause conflicts
+in the image files and backups stored there.
+
+
+## Standalone Setup Step 1: create instance
+
+To create new standalone IMGAPI instance, use
+[imgapi-standalone-create](../bin/imgapi-standalone-create). It needs to be
+run from the DC's headnode global zone.
+
+    imgapi-standalone-create [OPTIONS] ACCOUNT IMAGE PACKAGE ALIAS
+
+For example:
+
+    cd /var/tmp
+    curl -kO https://raw.githubusercontent.com/joyent/sdc-imgapi/master/bin/imgapi-standalone-create
+
+    # A play IMGAPI in COAL using a local 'trentm' COAL account and
+    # /trent.mick/stor/tmp/images in Manta:
+    bash ./imgapi-standalone-create \
+        -m mantaUrl=https://us-east.manta.joyent.com \
+        -m mantaUser=trent.mick -m mantaBaseDir=tmp/images \
+        trentm latest sample-2G myimages0
+
+    # An deployment of images.joyent.com might look like this:
+    bash ./imgapi-standalone-create \
+        -m mantaUrl=https://us-east.manta.joyent.com \
+        -m mantaUser=joyops -m mantaBaseDir=images.joyent.com \
+        -t triton.cns.services=imagesjo \
+        joyops latest g4-highcpu-2G imagesjo0
+
+The `-m` option adds metadata. A set of metadata keys are supported setup config
+vars (see [Standalone Setup Configuration](#standalone-setup-configuration)
+below). The `-t` option adds an instance tag -- in this case to use
+[CNS](https://docs.joyent.com/public-cloud/network/cns).
+
+
+## Standalone Setup Step 2: edit config
+
+After creation one may edit the generated config file at
+"/data/imgapi/etc/imgapi.config.json" manually. Afterwards, remember to
+restart the imgapi service:
+
+    vi /data/imgapi/etc/imgapi.config.json
+    svcadm restart imgapi
+
+
+## Standalone Setup Step 3: add imgapi instance key to account
+
+Every standalone IMGAPI instance creates its own "instance key" -- an SSH key
+to be used for authenticated access to Manta, if relevant. If configuring
+this IMGAPI instance for Manta access (strongly suggested), then one needs
+to add this instance's SSH public key to the Manta account to being used.
+
+For convenience the instance public key is published on the instance's metadata,
+so that a command like the following can work to add the key to one's account:
+
+    triton inst get ALIAS | json metadata.instPubKey | triton key add -
+
+The key is typically named "imgapi-$alias-$zonenameprefix-$date", so when
+listing keys it to check, it will look something like this:
+
+    $ triton keys
+    FINGERPRINT                                      NAME
+    b5:cb:80:c0:5e:d9:2b:6f:63:a3:44:eb:ac:39:db:fa  imgapi-imagesjo0-ef4a1442-20160907
+    b3:f0:a1:6c:32:3b:47:63:ae:6e:57:22:74:71:d4:bd  trentm
+
+
+## Standalone Setup Step 4: restore data from backup
+
+The setup is not complete until
+[imgapi-standalone-restore](../bin/imgapi-standalone-restore) is run. This will
+restore "local" data from the backup in the IMGAPI's Manta area, if any. It must
+be run even if it is a no-op (not configured to use Manta, empty Manta area).
+
+    ssh root@$(triton ip ALIAS)
+    imgapi-standalone-restore [OPTIONS]
+
+Dev note: It must always be run because it leaves a marker file indicating that
+it is safe for the background imgapi-standalone-backup process to run and write
+data *to* the backup. Even if not backing up `imgapi-standalone-status` will
+report a problem if it hasn't been successfully run once.
+
+
+## Standalone Setup Step 5: set TLS cert
+
+This step is optional.
+
+Initial setup will create a self-signed TLS certificate. If you have a signed
+certificate you'd like to use, it can be installed as follows:
+
+    cp /var/tmp/your-cert.pem /data/imgapi/etc/cert.pem
+    svcadm restart stud   # restart stud, the TLS terminator
+
+Dev note: Eventually we hope to support Let's Encrypt.
+
+
+## Standalone Setup Step 6: add authkeys for signature auth
+
+This step is optional.
+
+Typically (and by default) a standalone IMGAPI will use HTTP Signature auth
+(`config.authType === "signature"`). Authentication is only done on endpoints
+that modify things (CreateImage, DeleteImage, UpdateImage, etc.) and on the
+Ping endpoint for testing.
+
+For signature auth you need a mapping of usernames to SSH public keys. A good
+way to do that is to add "$username.keys" files in the IMGAPI's Manta area at:
+
+    /${manta.user}/stor/${manta.baseDir}/authkeys/
+
+For example:
+
+    $ mget /joyops/stor/images.joyent.com/authkeys/trentm.keys
+    ssh-rsa AAAAB3NzaC1yc2EAAAABIwAA...
+
+The IMGAPI server periodically (once per hour) syncs changes from that Manta
+area and updates its auth info. Or for the lazy one can do either of:
+
+    ssh root@$(triton ip ALIAS) svcadm restart imgapi
+
+    # The following require already being setup for auth.
+    IMGAPI_CLI_URL=https://myimages.com imgapi-cli reload-auth-keys
+    joyent-imgadm reload-auth-keys      # custom CLI for images.joyent.com
+    updates-imgadm reload-auth-keys     # custom CLI for updates.joyent.com
+
+This isn't the only place that authkeys can be added. See the
+[Authentication](#authentication) section below for full details.
+
+
+## Standalone Setup Step 6: set CNS service tag
+
+This step is optional.
+
+A nice way to setup DNS for a standalone IMGAPI instance is to use
+[CNS](https://docs.joyent.com/public-cloud/network/cns), if available in
+your Triton DC. Set the `triton.cns.services` tag on your instance:
+
+    triton inst tag set -w myimages0 triton.cns.services=myimages
+
+and CNS will create a service ("svc") DNS name:
+
+    $ triton -p joyentsw-sw1 inst get imagesjo0 | json dns_names
+    [
+      "0370c8fc-7f73-11e6-a160-7f089df626c7.inst.f3fabce8-7f72-11e6-98f8-6f6f85da7472.us-sw-1.triton.zone",
+      "myimages0.inst.f3fabce8-7f72-11e6-98f8-6f6f85da7472.us-west-1.triton.zone",
+      "myimages.svc.f3fabce8-7f72-11e6-98f8-6f6f85da7472.us-west-1.triton.zone"
+    ]
+
+Then create a CNAME in your DNS provider mapping, say, "myimages.com"
+to the service name:
+
+    myimages.com -> myimages.svc.f3fabce8-7f72-11e6-98f8-6f6f85da7472.us-west-1.triton.zone
+
+Then, even if your instance is recycled and replaced, DNS will still work.
+And when imgapi supports multiple instances (for HA), DNS will map to all your
+instances using the "myimages" cns tag.
+
+# Update
+
+DC-mode:
+
+    sdcadm up imgapi
+
+* * *
+
+Standalone: To update a standalone IMGAPI instance use
+[imgapi-standalone-reprovision](../bin/imgapi-standalone-reprovision). It needs
+to be run from the DC's headnode global zone (dev note: because reprovision
+isn't yet a part of CloudAPI).
+
+    imgapi-standalone-reprovision [OPTIONS] INSTANCE IMAGE
+
+This will handle importing the identified 'imgapi' image to the DC, tweaking
+its permissions, and reprovisioning the instance to the new image.
+
+
+# Health
+
+DC-mode:
+
+    sdcadm check-health
+    sdc-healthcheck
+
+(Dev note: Yes, currently there are both of those things. Eventually when
+`sdcadm check-health` improves, the latter can be deprecated.)
+
+* * *
+
+Standalone:
+
+    ssh root@$(triton ip ALIAS)
+    imgapi-standalone-status [-h] [-v]
+
+
+# Backup and Recovery
+
+DC-mode: nothing currently
+
+* * *
+
+Standalone: A regular part of a standalone IMGAPI is a background process
+(see "Background processes" section below) that periodically backs up local data
+to Manta, to `/${manta.user}/stor/${manta.baseDir}/backup/...`. This, of course,
+requires that the config file have manta access (see "Setup" steps above).
+
+Recovery from backup is exactly the setup process described above: read the
+"Setup" section from the start. In particular the 'imgapi-standalone-restore'
+script is the part that restores the local data from backup.
+
+
+# Background processes
+
+DC-mode IMGAPI has the following background processes:
+
+1. A node.js "config-agent" SMF service that handles updating config files
+   (in particular the imgapi service config) from "sapi_templates/..." and
+   SAPI data.
+2. A node.js "registrar" SMF service agent that handles registering this
+   imgapi instance in the Triton DataCenter's "binder".
+3. A node.js "amon-agent" SMF service that handles monitoring.
+   (Dev Note: Current amon usage for imgapi monitoring is not significant.)
+4. An hourly cronjob runs "logadm" to handle log rotation.
+5. A "hermes" SMF service agent runs from the GZ to handle rotated log file
+   upload to Manta (if the Triton DC is so configured).
+
+* * *
+
+Along with the usual 'imgapi' service, HAproxy, and stud; a standalone IMGAPI
+has the following background processes:
+
+1. An hourly cronjob runs "logadm" to handle log rotation.
+2. An hourly cronjob runs
+   [tritonlogupload.sh](../tools/standalone/tritonlogupload.sh) to upload
+   rotated files to manta.
+3. An hourly cronjob runs "imgapi-standalone-backup" to backup local data to
+   Manta.
+
+
+# Configuration
+
+An IMGAPI process is configured via two files:
+
+1.  A defaults JSON file: "etc/defaults.json" in the repository,
+    "/opt/smartdc/imgapi/etc/defaults.json" in an IMGAPI instance.
+
+2.  An instance-specific JSON config file, typically
+    "/data/imgapi/etc/imgapi.config.json" (can be overridden with the `node
+    main.js -f CONFIG-PATH` option). An explicit config file must exist, but
+    it can be the empty `{}` to just use the defaults.
+
+    A DC-mode config file is rendered by the `config-agent` service -- rendered
+    from the template at "sapi_templates/imgapi/template" and instance config
+    from the SAPI GetConfig endpoint
+    (https://github.com/joyent/sdc-sapi/blob/master/docs/index.md). See
+    "SAPI Configuration" below.
+
+    A standalone IMGAPI's config file is initially rendered by the
+    "boot/standalone/setup.sh" setup process from the template at
+    "etc/standalone/imgapi.config.json.handlebars" and setup config vars on
+    instance metadata, if any. See "Standalone Setup Configuration" below
+
+Currently the defaults give you a public-mode standalone IMGAPI,
+that listens at "https://127.0.0.1:8080", uses the local database and local
+storage backends, and uses signature auth for endpoints that
+create/update/delete resources.
+
+Note that given custom values override full top-level keys in the defaults.
+For example: if providing `manta`, one must provide the whole `manta` object.
+
+| var                          | type          | default           | description |
+| ---------------------------- | ------------- | ----------------- | ----------- |
+| port                         | Number        | 8080              | Port number on which to listen. |
+| address                      | String        | 127.0.0.1         | Address on which to listen. |
+| serverName                   | String        | IMGAPI/$version   | Name of the HTTP server. This value is present on every HTTP response in the 'server' header. |
+| logLevel                     | String/Number | debug             | Level at which to log. One of the supported Bunyan log levels. This is overridden by the `-d,--debug` switch. |
+| maxSockets                   | Number        | 100               | Maximum number of sockets for external API calls |
+| mode                         | String        | public            | One of 'public' (default, running as a public server e.g. images.joyent.com), 'private' (a ironically "public" server that only houses images marked `public=false`), or 'dc' (running as the IMGAPI in a Triton DataCenter). |
+| datacenterName               | String        | -                 | Name of the Triton DataCenter on which IMGAPI is running. Only relevant if `mode === "dc"`. |
+| adminUuid                    | String        | -                 | The UUID of the admin user in this Triton DataCenter. Only relevant if `mode === "dc"`. |
+| channels                     | Array         | -                 | Set this make this IMGAPI server support [channels](#channels). It must be an array of channel definition objects of the form `{"name": "<name>", "description": "<desc>"[, "default": true]}`. |
+| placeholderImageLifespanDays | Number        | 7                 | The number of days after which a "placeholder" image (one with state 'failed' or 'creating') is purged from the database. |
+| allowLocalCreateImageFromVm  | Boolean       | false             | Whether to allow CreateImageFromVm using local storage (i.e. if no manta storage is configured). This should only be enabled for testing. For SDC installations of IMGAPI `"IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM": true` can be set on the metadata for the 'imgapi' SAPI service to enable this. |
+| minImageCreationPlatform     | Array         | see defaults.json | The minimum platform version, `["<sdc version>", "<platform build timestamp>"]`, on which the proto VM for image creation must reside. This is about the minimum platform with sufficient `imgadm` tooling. This is used as an early failure guard for [CreateImageFromVm](#CreateImageFromVm). |
+| authType                     | String        | signature         | One of 'none' or 'signature' ([HTTP Signature auth](https://github.com/joyent/node-http-signature)). |
+| authKeys                     | Object        | -                 | Optional. A mapping of username to an array of ssh public keys. Only used for HTTP signature auth (`config.authType === "signature"`). |
+| databaseType                 | String        | local             | The database backend type to use. One of "local" or "moray". The latter is what is typically used in-DC. |
+| storageTypes                 | Array         | ["local"]         | The set of available storage mechanisms for the image *files*. There must be at least one. Supported values are "local" and "manta". See the [Image file storage](#image-file-storage) section for discussion. |
+| manta                        | Object        | -                 | Object holding config information for Manta storage. |
+| manta.baseDir                | String        | imgapi            | The base directory, relative to '/${manta.user}/stor', under which image files are stored in Manta. |
+| manta.url                    | String        | -                 | The Manta API URL. |
+| manta.insecure               | Boolean       | false             | Ignore SSL certs on the Manta URL. |
+| manta.remote                 | Boolean       | -                 | Whether this Manta is remote to this IMGAPI. This helps IMGAPI determine practical issues on whether manta or local storage is used for large files. |
+| manta.user                   | String        | -                 | The Manta user under which to store data. |
+| manta.key                    | String        | -                 | Path to the SSH private key file with which to authenticate to Manta. |
+| manta.keyId                  | String        | -                 | The SSH public key ID (signature). |
+| manta.rootDir                | String        | *<computed>*      | (This is automatically computed from other config vars.) The Manta full path under which IMGAPI uses. |
+| ufds.url                     | String        | -                 | LDAP URL to connect to UFDS. Required if `mode === 'dc'`. |
+| ufds.bindDN                  | String        | -                 | UFDS root dn. Required if `mode === 'dc'`. |
+| ufds.bindPassword            | String        | -                 | UFDS root dn password. Required if `mode === 'dc'`. |
+| wfapi.url                    | String        | -                 | The Workflow API URL. |
+| wfapi.workflows              | String        | -                 | Array of workflows to load. |
+| wfapi.forceReplace           | Boolean       | -                 | Whether to replace all workflows loaded every time the IMGAPI service is started. Ideal for development environments |
+
+For operational scripts, development, and debugging, one can look at the full
+merged and computed config by calling "lib/config.js" as a script. This should
+always be used in preference to looking at the config files directly to get
+the merged and computed config object values. Examples:
+
+    $ node lib/config.js -h
+    usage: node .../lib/config.js [OPTIONS] [KEY]
+    options:
+        -h, --help                          Print this help and exit.
+        -f CONFIG-PATH, --file=CONFIG-PATH  Config file path.
+
+    $ node lib/config.js -f foo.json authType
+    signature
+
+    $ node lib/config.js -f foo.json
+    {
+        "port": 8080,
+        "address": "127.0.0.1",
+        "maxSockets": 100,
+        "logLevel": "debug",
+        "mode": "public",
+        "authType": "signature",
+    ...
+
+## SAPI Configuration
+
+DC-mode IMGAPI is configured via "metadata" on the "imgapi" SAPI service.
+See [the config template](../sapi_manifests/imgapi/template) for the
+authoritative details.
+
+| Key                                     | Type    | Default | Description |
+| --------------------------------------- | ------- | ------- | ----------- |
+| IMGAPI_ALLOW_LOCAL_CREATE_IMAGE_FROM_VM | Boolean | false   | Set this to allow image creation even when the DC is not setup to use a Manta. This is useful for development. See [the setup section](#dc-mode-setup-enable-custom-image-creation-without-manta). |
+| IMGAPI_MANTA_\*                         | various | -       | These are typically setup by the `imgapi[-external]-manta-setup` scripts. See the [DC-mode setup: connect to Manta](#dc-mode-setup-connect-to-manta) section |
+| docker_registry_insecure                | Boolean | false   | See <https://github.com/joyent/triton/blob/master/docs/operator-guide/configuration.md#sdc-application-configuration> |
+| http_proxy                              | String  | -       | See <https://github.com/joyent/triton/blob/master/docs/operator-guide/configuration.md#sdc-application-configuration> |
+
+
+## Standalone Setup Configuration
+
+A standalone IMGAPI instance's config is first written at initial setup by
+[imgapi-standalone-gen-setup-config](../bin/imgapi-standalone-gen-setup-config)
+by rendering a [template](../etc/standalone/imgapi.config.json.handlebars). A
+number of keys can be provided on instance metadata for this initial rendering.
+These are called "setup config vars". At time of writing they are (see
+`setupConfigVars` in imgapi-standalone-gen-setup-config):
+
+| Key          | Corresponds to this key from the "Configuration" table |
+| ------------ | ------------------------------------------------------ |
+| mode         | mode |
+| serverName   | serverName |
+| mantaUrl     | manta.url |
+| mantaUser    | manta.user |
+| mantaBaseDir | manta.baseDir |
+
+
+# Storage
+
+There are two possible storage mechanisms for the (possibly large) image files
+(and image icon files). The storage mechanisms used are configured via
+the `storageTypes` config var. For example:
+
+    "storageTypes": ["manta", "local"],
+    "mode": "dc",
+    "datacenterName": "us-test-1",
+    "manta": {
+        "url": "https://us-east.manta.joyent.com",
+        "user": "alice",
+        "key": "/data/imgapi/etc/imgapi-img7-37591570-20160831.id_rsa",
+        "keyId": "SHA256:UlGQ8CXT0BIvJXq2IoPllUHUOTJUCwNLhsKMzdc8/30",
+        "baseDir": "imgapi",
+        "insecure": false,
+        "remote": true,
+    },
+
+
+Storage types are:
+
+1. `manta`: Requires an available Manta and that IMGAPI be configured to use it.
+   All files are stored in the configured Manta user's area (under
+   "/${manta.user}/stor/"), as opposed to storing images own by Bob under
+   Bob's area in Manta. Manta storage may be local (i.e. within the same region,
+   this is preferred) or remote (a Manta across the WAN).
+
+   The Manta root directory used by an IMGAPI (called the Manta `rootDir`) is
+   as follows. If in DC mode (`mode === "dc"`), then the additional
+   "${datacenterName}/" dir component is added.
+
+        /${manta.user}/stor/${manta.baseDir}/[${datacenterName}/]...
+
+   Examples:
+
+        /jim/stor/images.joyent.com/...
+        /cloudops/stor/imgapi/us-test-1/...
+
+2. `local`: Files are stored at the local "/data/imgapi/images/..." (possibly
+   a delegate dataset or NFS mount or whatever). All IMGAPI instances will have
+   at least "local" storage.
+
+Configuring for Manta storage is preferred because file storage is then durable.
+For in-DC IMGAPI instances, Manta storage is *required* for user custom image
+creation, i.e. CloudAPI's
+[CreateImageFromMachine](http://apidocs.joyent.com/cloudapi/#CreateImageFromMachine),
+unless [overriden](#dc-mode-setup-enable-custom-image-creation-without-manta).
+
+For DC-mode imgapi instances, the
+[`<imgapi-zone>:/opt/smartdc/imgapi/bin/imgapi-manta-setup`](https://github.com/joyent/sdc-imgapi/blob/master/bin/imgapi-manta-setup)
+and [`<imgapi-zone>:/opt/smartdc/imgapi/bin/imgapi-external-manta-setup`](https://github.com/joyent/sdc-imgapi/blob/master/bin/imgapi-external-manta-setup)
+scripts are intended for use in setting up to use a Manta. (Longer term this
+responsibility should move to a `sdcadm post-setup ...` command.)
+
+At runtime, when a file is added (via `AddImageFile`) a storage backend must be
+selected. Non-remote Manta storage, if available, is used in preference to
+"local" storage. If Manta storage is available *but is remote*, then which
+storage is used is a little more complicated. The intention is that user-created
+custom images (i.e. IMGAPI's CreateImageFromVm, aka CreateImageFromMachine on
+cloudapi) go to Manta. However, admin-managed public images for the DC are
+typically large and can't practically live in a remote Manta. Therefore the
+algorithm is that "admin"-owned images prefer local storage to "remote Manta"
+storage. Images owned by others prefer remote Manta storage to local storage.
+
+The login shell of an IMGAPI instance should be setup to access its configured
+Manta (useful for development and debugging):
+
+    sdc-login -l imgapi
+    rootDir=$(node /opt/smartdc/imgapi/lib/config.json manta.rootDir)
+    mls $rootDir
+
+# Authentication
+
+IMGAPI supports two authentication modes:
+
+1. HTTP Signature auth (`config.authType === "signature"). This is the default
+   and suggested auth mode for standalone IMGAPI instances.
+2. No auth (`config.authType === "none"`). This is the typical configuration for
+   DC-mode IMGAPI instances, which run on the "admin" network.
+
+## HTTP Signature auth
+
+To support HTTP signature authentication the server needs a mapping of
+usernames to an array of SSH public keys. There are three places those keys
+can come from:
+
+1. `config.authKeys`. For example:
+
+        ...
+        "authType": "signature",
+        "authKeys": {
+            "trentm": ["ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPLIC/hQIyd3gvIteBVOIrhZJ8KJHdZe3O/eb7wZL3yoEAOSQeC5yIZINLyZElFeDjKrgsshhPRnWV0QrPPPfkgnpiHTXbTPU0p5aEqekMgMUVVblGmtKr1QRxuQYW2S1r3HBZkoVC8LnbPBR4xWgtCx8LuVOOwCtYc9+E+e+Yl9EjW415KZyVtMVhpzR7ja8Le+SiapJOUejy7CuO73XS9A9xXDHGw81lQtoDJASgJhJKj8/64tgGFxkNERjBtA/hG/9bofHD/Zw4kxAoR1kjtF49sDop5UKEBT3WlejWedQ/fZqyHCNk+YOpmIt+aM0jF49vNMM+QhQotTN5iYHb DESCRIPTION"]
+        }
+
+2. Local ".keys" files in `/data/imgapi/etc/authkeys/local/$username.keys`. E.g.
+
+        $ cat /data/imgapi/etc/authkeys/local/trentm.keys
+        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPLIC/hQIyd3gvIteBVOIrhZJ8KJHdZe3O/eb7wZL3yoEAOSQeC5yIZINLyZElFeDjKrgsshhPRnWV0QrPPPfkgnpiHTXbTPU0p5aEqekMgMUVVblGmtKr1QRxuQYW2S1r3HBZkoVC8LnbPBR4xWgtCx8LuVOOwCtYc9+E+e+Yl9EjW415KZyVtMVhpzR7ja8Le+SiapJOUejy7CuO73XS9A9xXDHGw81lQtoDJASgJhJKj8/64tgGFxkNERjBtA/hG/9bofHD/Zw4kxAoR1kjtF49sDop5UKEBT3WlejWedQ/fZqyHCNk+YOpmIt+aM0jF49vNMM+QhQotTN5iYHb DESCRIPTION
+
+3. ".keys" files in *Manta* at `${manta.rootDir}/authkeys/$username.keys`:
+
+        $ mls /trent.mick/stor/imgapi/authkeys
+        trentm.keys
+
+    This, of course, requires `config.manta.*` be set. IMGAPI will periodically
+    (once per hour) sync `${manta.rootDir}/authkeys/*.keys` files in Manta to
+    `/data/imgapi/etc/authkeys/manta/` locally and load from there. Use the
+    [AdminReloadAuthKeys](#AdminReloadAuthKeys) endpoint to trigger a reload.
+
+
+# Logs
+
+| service/path         | where                  | notes |
+| -------------------- | ---------------------- | ----- |
+| imgapi SMF log       | `svcs -L imgapi`       | \*    |
+| config-agent SMF log | `svcs -L config-agent` | \*, DC-mode only |
+| registrar SMF log    | `svcs -L registrar`    | \*, DC-mode only |
+| amon-agent SMF log   | `svcs -L amon-agent`   | \*, DC-mode only    |
+| backup to Manta      | /var/log/triton/imgapi-backup.log | \*, standalone-mode only |
+| log upload to Manta  | /var/log/tritonlogupload.log      | standalone-mode only |
+| logadm               | /var/log/logadm.log               | standalone-mode only |
+
+
+## Log rotation and upload to Manta
+
+Logs marked with an asterisk (\*) are rotated and uploaded to Manta.
+
+DC-mode IMGAPIs' `logadm` rotates logs hourly to:
+
+    /var/log/sdc/upload/$svc_$zonename_$timestamp.log
+
+and the [hermes](https://github.com/joyent/sdc-hermes) global zone agent
+periodically uploads from there to Manta per [this
+configuration](https://github.com/joyent/sdc-sdc/blob/master/etc/logsets.json#L198),
+removing files after a period after upload.
+
+* * *
+
+Standalone IMGAPIs' `logadm` rotates logs hourly to:
+
+    /var/log/triton/$svc_$nodename_$timestamp.log
+
+The [tritonpostlogrotate.sh](../tools/standalone/tritonpostlogrotate.sh) script
+links those files to:
+
+    /var/log/triton/upload/$svc_$nodename_$normtimestamp.log
+
+From there the [tritonlogupload.sh](../tools/standalone/tritonlogupload.sh)
+script uploads (via an hourly cron job) to Manta:
+
+    /${manta.user}/stor/${manta.baseDir}/logs/$svc/$YYYY/$MM/$DD/$HH/$nodename.log
+
+Dev Note: The result with standalone IMGAPIs' log rotation and upload has
+a few properties different to DC-mode IMGAPIs. These are intentional and
+I (Trent) would like to propagate this pattern to all Triton core services.
+The improvements are:
+
+- Rotated logs for local use are in /var/log/triton/*.log and are retained
+  for the period listed in the /etc/logadm.conf config. Typically that is
+  a week of hourly logs. One common problem of in-prod debugging is that
+  after a few hours (the hermes `retain_time`), the log files may have been
+  uploaded to Manta and deleted from the local instance. Retaining them
+  according to logadm config also means that log space usage behaviour is
+  similar for DCs setup for Manta log upload and those that are not, which is
+  beneficial for dogfooding.
+- The log files in the "upload/" subdir can be deleted immediately after
+  successful upload. This simplifies the log upload script.
+- The basename of uploaded logs is the `$nodename` -- which is the zone's
+  alias. This allows for a predictable name in Manta (rather than an instance
+  zonename UUID) which can allow avoiding an extra `mfind` for Manta jobs
+  for analysis.
+
+
+## Log-related commands
+
+Some possibly useful commands follow.
+Tail the imgapi log:
+
+    tail -f `svcs -L imgapi` | bunyan
+
+Restart the IMGAPI service and tail the log:
+
+    svcadm restart imgapi && tail -f `svcs -L imgapi` | bunyan
+
+Use the [Bunyan dtrace
+facility](https://github.com/trentm/node-bunyan/#runtime-log-snooping-via-dtrace)
+to tail *trace*-level logs of the imgapi service:
+
+    bunyan -p imgapi
diff --git a/etc/defaults.json b/etc/defaults.json
index 9c16fdb..6d937d0 100644
--- a/etc/defaults.json
+++ b/etc/defaults.json
@@ -1,7 +1,14 @@
 {
     "port": 8080,
+    "address": "127.0.0.1",
     "maxSockets": 100,
     "logLevel": "debug",
+
+    "mode": "public",
+    "authType": "signature",
+    "databaseType": "local",
+    "storageTypes": ["local"],
+
     "placeholderImageLifespanDays": 7,
     "allowLocalCreateImageFromVm": false,
     "minImageCreationPlatform": ["7.0", "20130917T001310Z"]
diff --git a/etc/imgapi.config.json.in b/etc/imgapi.config.json.in
deleted file mode 100644
index 1fb7453..0000000
--- a/etc/imgapi.config.json.in
+++ /dev/null
@@ -1,42 +0,0 @@
-{
-    "// notes": "This is an example IMGAPI config for example only.",
-
-    "serverName": "{{NAME}}",
-
-    "mode": "dc",
-    "ufds": {
-        "url": "ldaps://{{{UFDS_SERVICE}}}",
-        "bindDN": "{{{ufds_ldap_root_dn}}}",
-        "bindPassword": "{{{ufds_ldap_root_pw}}}",
-        "failFast": true
-    },
-
-    "// mode": "public",
-    "// mode": "private",
-    "// auth": {
-        "type": "signature",
-        "keys": {
-            "bob": ["ssh-rsa ...== comment"]
-        }
-    },
-
-    "// channels": [
-        {"name": "dev", "description": "all development builds", "default": true},
-        {"name": "staging", "description": "builds for testing in staging in prep for production release"},
-        {"name": "release", "description": "release gold bits"}
-    ],
-
-    "storage": {
-        "local": {
-            "baseDir": "/var/tmp/imgapi"
-        }
-    },
-    "database": {
-        "type": "local",
-        "dir": "/var/tmp/imgapi/manifests"
-    },
-    "wfapi": {
-        "workflows": [ "create-from-vm", "import-remote-image" ],
-        "url": "{{{workflow_api_url}}}"
-    },
-}
diff --git a/etc/nginx.conf.in b/etc/nginx.conf.in
deleted file mode 100644
index 1066d68..0000000
--- a/etc/nginx.conf.in
+++ /dev/null
@@ -1,73 +0,0 @@
-# An nginx.conf template for use as a proxy and HTTPS terminator for
-# an IMGAPI server running as the root user on SmartOS.
-#
-# You need to:
-# - update paths as appropriate, e.g. '/root/services/imgapi/public'
-# - replace "FOO" values as appropriate
-#
-
-
-user www www;
-worker_processes 1;
-error_log /var/log/nginx/error.log;
-
-events {
-    worker_connections  1024;
-    #use /dev/poll; # important on Solaris
-}
-
-
-http {
-    include       mime.types;
-    default_type application/octet-stream;
-    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
-                    '$status $body_bytes_sent "$http_referer" '
-                    '"$http_user_agent" "$http_x_forwarded_for"';
-    access_log /var/log/nginx/access.log main;
-    sendfile off; # important on Solaris
-    keepalive_timeout  65;
-    server_tokens off;
-
-    upstream nodeserver {
-        server 127.0.0.1:8080;
-    }
-
-    #TODO: make this include the path
-    server {
-        listen 80;
-        # Only redirect the root for HTTP. Want to discourage non-HTTPS access.
-        rewrite ^(.*) https://$host$1 permanent;
-    }
-
-    server {
-        listen 443;
-        server_name localhost;
-
-        ssl on;
-        ssl_certificate /root/config/FOO.pem;
-        ssl_certificate_key /root/config/FOO.pem;
-        ssl_prefer_server_ciphers on;
-        #ssl_protocols  SSLv2 SSLv3 TLSv1;
-        #ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
-
-        client_max_body_size 4000M;
-
-        location / {
-            root /root/services/imgapi/public;
-            proxy_set_header X-Real-IP  $remote_addr;
-            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
-            proxy_set_header Host $http_host;
-            proxy_redirect off;
-            proxy_max_temp_file_size 102400m;  # 100GB, see IMGAPI-127
-            proxy_pass_header Server;
-            proxy_pass http://nodeserver;
-            break;
-        }
-
-        #error_page  404              /404.html;
-        error_page   500 502 503 504  /50x.html;
-        location = /50x.html {
-            root   html;
-        }
-    }
-}
diff --git a/etc/haproxy.cfg.in b/etc/standalone/haproxy.cfg
similarity index 91%
rename from etc/haproxy.cfg.in
rename to etc/standalone/haproxy.cfg
index 0b8720d..a975891 100644
--- a/etc/haproxy.cfg.in
+++ b/etc/standalone/haproxy.cfg
@@ -34,5 +34,5 @@ frontend https
         default_backend api
 
 frontend stats_http
-         bind 127.0.0.1:8081
-         default_backend haproxy-stats_http
+        bind 127.0.0.1:8081
+        default_backend haproxy-stats_http
diff --git a/etc/standalone/imgapi.config.json.handlebars b/etc/standalone/imgapi.config.json.handlebars
new file mode 100644
index 0000000..80f5d80
--- /dev/null
+++ b/etc/standalone/imgapi.config.json.handlebars
@@ -0,0 +1,21 @@
+{
+    {{#if mode}}"mode": "{{{mode}}}",{{/if}}
+    {{#if serverName}}"serverName": "{{{serverName}}}",{{/if}}
+
+    {{#if mantaUser}}
+    "manta": {
+        "url": "{{{mantaUrl}}}",
+        "user": "{{{mantaUser}}}",
+        "key": "{{{mantaKey}}}",
+        "keyId": "{{{mantaKeyId}}}",
+        "baseDir": "{{{mantaBaseDir}}}"
+    },
+    {{/if}}
+
+    "authType": "signature",
+    "databaseType": "local",
+    "storageTypes": [
+        {{#if mantaUser}}"manta",{{/if}}
+        "local"
+    ]
+}
diff --git a/etc/stud.conf.in b/etc/standalone/stud.conf
similarity index 73%
rename from etc/stud.conf.in
rename to etc/standalone/stud.conf
index 5e27fa2..ddd6f05 100644
--- a/etc/stud.conf.in
+++ b/etc/standalone/stud.conf
@@ -22,12 +22,24 @@ backend = "[127.0.0.1]:8443"
 # are listed; the last cert listed will be used if none of the others match
 #
 # type: string
-pem-file = "/opt/smartdc/imgapi/etc/ssl/cert.pem"
+pem-file = "/data/imgapi/etc/cert.pem"
 
 # SSL protocol.
 #
+# Per <https://github.com/bumptech/stud/blob/master/configuration.c#L540-L545>
+# as long as 'tls=on', having 'ssl=on' should be ignored, but why tempt
+# fate. Ultimately the test is that standalone IMGAPIs don't support
+# SSL negotiation (requiring TLS). You can test that via either of:
+#
+# 1. get an "A" on <https://www.ssllabs.com/ssltest/>
+# 2. a failure connecting with openssl s_client like so:
+#
+#       $ openssl s_client -no_tls1 -ssl3 -connect updates.joyent.com:443
+#       CONNECTED(00000003)
+#       10151:error:14094410:SSL routines:SSL3_READ_BYTES:sslv3 alert handshake failure:...
+#       10151:error:1409E0E5:SSL routines:SSL3_WRITE_BYTES:ssl handshake failure:...
 tls = on
-ssl = on
+ssl = off
 
 # List of allowed SSL ciphers.
 #
@@ -118,4 +130,4 @@ write-proxy = on
 # type: boolean
 proxy-proxy = off
 
-# EOF
\ No newline at end of file
+# EOF
diff --git a/lib/adm.js b/lib/adm.js
index 71d1b7b..391a520 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -19,7 +19,7 @@ var cmdln = require('cmdln'),
     Cmdln = cmdln.Cmdln;
 var crypto = require('crypto');
 var fs = require('fs');
-var libuuid = require('libuuid');
+var lib_uuid = require('uuid');
 var mkdirp = require('mkdirp');
 var path = require('path');
 var ProgressBar = require('progbar').ProgressBar;
@@ -45,7 +45,7 @@ var utils = require('./utils'),
 var p = console.log;
 var pkg = require('../package.json');
 
-var CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
+var CONFIG_PATH = '/data/imgapi/etc/imgapi.config.json';
 var UA = format('imgapiadm/%s', pkg.version);
 
 
@@ -106,7 +106,7 @@ Adm.prototype.init = function init(opts, args, callback) {
         return callback(false);
     }
 
-    var req_id = libuuid.create();
+    var req_id = lib_uuid.v4();
     Object.defineProperty(this, 'imgapi', {
         get: function () {
             if (self._imgapi === undefined) {
@@ -334,7 +334,7 @@ function do_check_files(subcmd, opts, args, cb) {
             ctx.todos = [];
             var localStor = new storage.local({
                 log: self.log,
-                config: self.config.storage.local
+                config: self.config
             });
             for (var i = 0; i < ctx.imgs.length; i++) {
                 var img = ctx.imgs[i];
diff --git a/lib/app.js b/lib/app.js
index b07c9f6..c23cfc5 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -32,6 +32,7 @@ var moray = require('moray');
 
 var channels = require('./channels');
 var database = require('./database');
+var authkeys = require('./authkeys');
 var storage = require('./storage');
 var utils = require('./utils');
 var errors = require('./errors');
@@ -136,6 +137,9 @@ function apiPing(req, res, next) {
         if (req._app.mode === 'dc' || req.remoteUser) {
             data.pid = process.pid;
         }
+        if (req.remoteUser) {
+            data.user = req.remoteUser;
+        }
         res.send(data);
         next();
     }
@@ -152,78 +156,15 @@ function apiPing(req, res, next) {
  *      header.
  */
 function getAuthMiddleware(app, config, passive) {
-    if (config.mode === 'dc') {
-        // No auth when using in 'dc' mode. Security is via only being
-        // on a private network (the 'admin' network in SDC parlance).
-        return function reqNoAuth(req, res, next) {
-            next();
-        };
-    }
-    assert.ok(~['public', 'private'].indexOf(config.mode), 'config.mode');
-    assert.object(config.auth, 'config.auth');
-    assert.ok(['basic', 'signature'].indexOf(config.auth.type) !== -1,
-        'config.auth.type');
+    assert.string(config.authType, 'config.authType');
     assert.bool(passive, 'passive');
 
-    if (config.auth.type === 'basic') {
-        // Adapted from Connect's "lib/middleware/basicAuth.js".
-        var bcrypt = require('bcrypt');
-
-        assert.optionalString(config.auth.realm, 'config.auth.realm');
-        assert.object(config.auth.users, 'config.auth.users');
-
-        var realm = config.realm || 'IMGAPI';
-        var users = config.auth.users;
-        // var salt = bcrypt.genSaltSync(10);
-
-        return function reqBasicAuth(req, res, next) {
-            var authorization = req.headers.authorization;
-            req.log.trace({authorization: authorization}, 'basicAuth');
-
-            if (req.remoteUser) {
-                return next();
-            }
-            if (!authorization) {
-                if (passive) {
-                    //XXX
-                    return next();
-                } else {
-                    res.setHeader('WWW-Authenticate',
-                        'Basic realm="' + realm + '"');
-                    return next(new errors.UnauthorizedError('Unauthorized'));
-                }
-            }
-
-            var parts = authorization.split(' ');
-            var scheme = parts[0];
-            var creds = new Buffer(parts[1], 'base64').toString().split(':');
-
-            if (scheme != 'Basic') {
-                return next(new errors.BadRequestError(
-                    'Unsupported Authorization scheme: "%s"', scheme));
-            }
-
-            var expectedPassHash = users[creds[0]];
-            if (expectedPassHash === undefined) {
-                return next(new errors.UnauthorizedError('Unauthorized'));
-            }
-            bcrypt.compare(creds[1], expectedPassHash, function (err, ok) {
-                if (err) {
-                    next(new errors.InternalError(err, 'error authorizing'));
-                } else if (ok) {
-                    req.remoteUser = creds[0];
-                    req.log.debug({remoteUser: req.remoteUser},
-                        'auth: basic creds verified');
-                    next();
-                } else {
-                    next(new errors.UnauthorizedError('Unauthorized'));
-                }
-            });
+    if (config.authType === 'none') {
+        return function reqNoAuth(req, res, next) {
+            next();
         };
-    } else if (config.auth.type === 'signature') {
+    } else if (config.authType === 'signature') {
         var httpSig = require('http-signature');
-        assert.object(config.auth.keys, 'config.auth.keys');
-        var keys = config.auth.keys;
 
         // Disallow HMAC key type to avoid joyent/node-http-signature#40
         var VALID_ALGS = ['RSA-SHA1', 'RSA-SHA256', 'DSA-SHA1'];
@@ -254,12 +195,13 @@ function getAuthMiddleware(app, config, passive) {
                     '" is not a supported http-signature signing algorithm)'));
             }
 
-            var sshKeys = keys[sigInfo.keyId];
+            var sshKeys = (req._app.authKeys &&
+                req._app.authKeys[sigInfo.keyId]);
             if (sshKeys === undefined) {
                 return next(new errors.UnauthorizedError('Unauthorized'));
             }
 
-            assert.arrayOfString(sshKeys, 'config.auth.keys.'+sigInfo.keyId);
+            assert.arrayOfString(sshKeys, 'authKeys["' + sigInfo.keyId + '"]');
             // TODO: improve caching here: sshKeyToPEM, preferred key first
             for (var i = 0; i < sshKeys.length; i++) {
                 try {
@@ -326,9 +268,8 @@ function App(config, log) {
     this.config = config;
     this.mode = config.mode;
     this.log = log;
-    this.port = config.port;
     this.serverName = config.serverName || 'imgapi/' + App.version;
-    this.db = new database[config.database.type](this, config.database, log);
+    this.db = new database[config.databaseType](this, log);
     // Allow tuning the max number of sockets for external API calls
     http.globalAgent.maxSockets = this.config.maxSockets;
     https.globalAgent.maxSockets = this.config.maxSockets;
@@ -489,14 +430,14 @@ function App(config, log) {
     server.get({path: '/ping', name: 'Ping'},
         reqPassiveAuth, apiPing);
     // TODO Kang-ify (https://github.com/davepacheco/kang)
-    server.get({path: '/state', name: 'GetState'},
+    server.get({path: '/state', name: 'AdminGetState'},
         reqAuth,
         function (req, res, next) {
             res.send(self.getStateSnapshot());
             next();
         }
     );
-    server.post({path: '/state', name: 'UpdateState'},
+    server.post({path: '/state', name: 'AdminUpdateState'},
         reqAuth,
         function apiDropCaches(req, res, next) {
             if (req.query.action !== 'dropcaches')
@@ -519,6 +460,7 @@ function App(config, log) {
     channels.mountApi(server, self, reqAuth, reqPassiveAuth);
     images.mountApi(server, reqAuth, reqPassiveAuth);
     datasets.mountApi(server);
+    authkeys.mountApi(server, reqAuth);
 }
 
 
@@ -568,7 +510,7 @@ App.prototype.setup = function (callback) {
         });
     }
 
-    if (self.config.database.type === 'moray' && self.config.moray) {
+    if (self.config.databaseType === 'moray' && self.config.moray) {
         var retry = self.config.moray.retry || {};
         log.debug('Connecting to moray...');
 
@@ -608,17 +550,14 @@ App.prototype.setup = function (callback) {
         }
 
         self.storage = {};
-        var types = Object.keys(self.config.storage);
-        for (var i = 0; i < types.length; i++) {
-            var type = types[i];
-            var config = self.config.storage[type];
-            config.datacenterName = self.config.datacenterName;
+        for (var i = 0; i < self.config.storageTypes.length; i++) {
+            var type = self.config.storageTypes[i];
             var StorageClass = storage[type];
-            log.info({type: type, config: config}, 'create storage handler');
+            log.info({type: type}, 'create storage handler');
             try {
                 self.storage[type] = new StorageClass({
                     log: log,
-                    config: config
+                    config: self.config
                 });
             } catch (ctorErr) {
                 return callback(ctorErr);
@@ -635,6 +574,15 @@ App.prototype.setup = function (callback) {
         );
     });
 
+    /*
+     * If using "signature" auth, then a mapping of usernames to SSH keys
+     * is needed at `<app>.authKeys`. AuthKeysLoader handles that.
+     */
+    if (self.config.authType === 'signature') {
+        this.authKeysLoader = new authkeys.AuthKeysLoader(this);
+        this.authKeysLoader.start();
+    }
+
     // NOTE Do not enforce it yet
     // Separate to db.setup
     // - We want to keep trying to create the workflows on init but we don't
@@ -816,7 +764,7 @@ App.prototype.setupRemoteArchiveInterval = function () {
  * @param callback {Function} `function (err)`.
  */
 App.prototype.listen = function (callback) {
-    this.server.listen(this.port, '0.0.0.0', callback);
+    this.server.listen(this.config.port, this.config.address, callback);
 };
 
 
@@ -897,12 +845,12 @@ App.prototype.getStateSnapshot = function () {
     var snapshot = {
         cache: {},
         log: { level: this.log.level() },
-        storageTypes: Object.keys(this.config.storage)
+        storageTypes: this.config.storageTypes
     };
     Object.keys(this._cacheFromScope).forEach(function (scope) {
         snapshot.cache[scope] = self._cacheFromScope[scope].dump();
     });
-    if (this.config.database.type === 'local') {
+    if (this.config.databaseType === 'local') {
         snapshot.db = {};
         snapshot.db.manifestFromUuid = this.db.manifestFromUuid;
     }
@@ -968,6 +916,11 @@ App.prototype.getStor = function getStor(type) {
  * @param {Function} callback called when closed. Takes no arguments.
  */
 App.prototype.close = function (callback) {
+    if (this.authKeysLoader) {
+        this.authKeysLoader.close();
+        delete this.authKeysLoader;
+    }
+
     this.server.on('close', function () {
         callback();
     });
diff --git a/lib/authkeys.js b/lib/authkeys.js
new file mode 100644
index 0000000..921e78d
--- /dev/null
+++ b/lib/authkeys.js
@@ -0,0 +1,300 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+/*
+ * Handling for "auth keys" for HTTP Signature auth (if `config.authType ===
+ * "signature"`). "Auth keys" is a mapping of username to an array of SSH
+ * public keys. This file includes the restify endpoints for working with
+ * auth keys, and a background `AuthKeysLoader` that handles setting
+ * `app.authKeys` (used in the auth middleware).
+ *
+ * Auth keys can come from a few places:
+ *
+ * 1. From `config.authKeys`.
+ * 2. Loaded from "/data/imgapi/etc/authkeys/local/$username.keys".
+ *    This is loaded once on startup and when `AdminReloadAuthKeys` is
+ *    called.
+ * 3. If setup with Manta (via `config.manta`), then keys
+ *    are sync'd from "/${manta.rootDir}/authkeys/$username.keys"
+ *    to "/data/imgapi/etc/authkeys/manta/$username.keys" and loaded from
+ *    there. These are loaded (a) at startup, (b) periodically, and
+ *    (c) when `AdminReloadAuthKeys` is called.
+ *
+ * The format for a "$username.keys" file is a subset of a
+ * "~/.ssh/authorized_keys" file:
+ * - one SSH public key per line
+ * - blank lines and lines beginning with a '#' are ignored (comment lines)
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var glob = require('glob');
+var MantaDirWatcher = require('manta-dir-watcher');
+var mod_path = require('path');
+var util = require('util');
+var vasync = require('vasync');
+
+var constants = require('./constants');
+var errors = require('./errors');
+
+
+//---- globals
+
+/*
+ * Every *hour*. We don't expect this to change frequently, so why bother
+ * with logs of polling. The desperate can call the AdminReloadAuthKeys
+ * endpoint.
+ */
+var POLL_INTERVAL = 60 * 60;
+
+
+// ---- internal helpers
+
+/*
+ * Load a "$username.keys" file from the given local path.
+ *
+ * @param {String} keysFile: Existing local path to the keys file to load.
+ *      The path basename will be "$username.keys".
+ * @param {Function} cb: `function (err, username, keys)`.
+ */
+function loadKeysFile(keysFile, cb) {
+    assert.string(keysFile, 'keysFile');
+    assert.func(cb, 'cb');
+
+    var base = mod_path.basename(keysFile);
+    var username = base.slice(0, base.lastIndexOf('.'));
+
+    /*
+     * Dev Note: when base node ver is 0.12, use 'readline' to stream
+     * read line-by-line:
+     * https://nodejs.org/docs/latest/api/all.html#readline_readline
+     */
+    fs.readFile(keysFile, {encoding: 'utf8'}, function (err, text) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        var keys = [];
+        var lines = text.split(/\r?\n/g);
+        for (var i = 0; i < lines.length; i++) {
+            var line = lines[i];
+            var trimmed = line.trim();
+            if (!trimmed) {
+                continue;
+            } else if (trimmed[0] === '#') {
+                continue; // comment line
+            }
+            keys.push(trimmed);
+        }
+        cb(null, username, keys);
+    });
+}
+
+
+//---- endpoints
+
+/**
+ * AdminReloadAuthKeys
+ */
+function apiAdminReloadAuthKeys(req, res, cb) {
+    if (req._app.authKeysLoader) {
+        req._app.authKeysLoader.reload();
+    }
+    res.send({});
+    cb();
+}
+
+
+/**
+ * Mount API endpoints
+ *
+ * @param server {restify.Server}
+ * @param reqAuth {Function} A request middleware for strict
+ *      authentication of some endpoints (typically those that can make
+ *      changes) of the IMGAPI.
+ */
+function mountApi(server, reqAuth) {
+    server.post(
+        {path: '/authkeys/reload', name: 'AdminReloadAuthKeys'},
+        reqAuth,
+        apiAdminReloadAuthKeys);
+}
+
+
+//---- AuthKeysLoader
+
+function AuthKeysLoader(app) {
+    assert.object(app, 'app');
+    assert.optionalObject(app.config.authKeys, 'app.config.authKeys');
+
+    this.app = app;
+    this.configAuthKeys = app.config.authKeys;
+    this.log = app.log.child({component: 'authkeys'}, true);
+    this.mantaConfig = null;
+    this.loadDirs = [
+        mod_path.join(constants.AUTHKEYS_BASE_DIR, 'local')
+    ];
+    if (app.config.manta) {
+        this.mantaConfig = app.config.manta;
+        this.mantaDir = mod_path.resolve(this.mantaConfig.rootDir, 'authkeys');
+        this.mantaSyncDir = mod_path.join(constants.AUTHKEYS_BASE_DIR, 'manta');
+        this.loadDirs.push(this.mantaSyncDir);
+    }
+    this.mantaWatcher = null;
+}
+
+AuthKeysLoader.prototype.start = function start() {
+    var self = this;
+
+    if (this.mantaConfig) {
+        this.mantaWatcher = new MantaDirWatcher({
+            clientOpts: {
+                url: this.mantaConfig.url,
+                user: this.mantaConfig.user,
+                sign: {
+                    keyId: this.mantaConfig.keyId,
+                    key: this.mantaConfig.key
+                },
+                insecure: this.mantaConfig.insecure
+            },
+            log: this.log,
+
+            dir: this.mantaDir,
+            interval: POLL_INTERVAL,
+            filter: {
+                type: 'object',
+                name: '*.keys'
+            },
+            syncDir: this.mantaSyncDir,
+            syncDelete: true
+        });
+        this.mantaWatcher.on('data', function onMantaKeysUpdate(group) {
+            self.log.debug({group: group, mantaDir: self.mantaDir},
+                'manta keys update');
+            self._load();
+        });
+        this.mantaWatcher.on('error', function onMantaKeysErr(err) {
+            self.log.warn({err: err, mantaDir: self.mantaDir},
+                'error polling manta for auth keys');
+        });
+    }
+
+    // First load of keys.
+    this._load();
+};
+
+AuthKeysLoader.prototype.close = function close() {
+    if (this.mantaWatcher) {
+        this.mantaWatcher.close();
+    }
+};
+
+AuthKeysLoader.prototype.reload = function reload() {
+    /*
+     * Reload keys now. Here we will poke the Manta watcher, if any, and
+     * also load locally. If there is a Manta key dir change, then we'll
+     * end up loading the local keys files twice, which is a bit wasteful.
+     */
+    if (this.mantaWatcher) {
+        this.mantaWatcher.poke();
+    }
+    this._load();
+};
+
+AuthKeysLoader.prototype._load = function _load(cb) {
+    assert.optionalFunc(cb, 'cb');
+
+    var self = this;
+    var log = this.log;
+
+    var context = {
+        keysFiles: [],
+        authKeys: {}
+    };
+
+    vasync.pipeline({arg: context, funcs: [
+        function authKeysFromConfig(arg, next) {
+            if (self.configAuthKeys) {
+                Object.keys(self.configAuthKeys).forEach(function (u) {
+                    arg.authKeys[u] = self.configAuthKeys[u].slice();
+                });
+            }
+            next();
+        },
+        function getKeysFiles(arg, next) {
+            vasync.forEachPipeline({
+                inputs: self.loadDirs,
+                func: function readLoadDir(dir, nextDir) {
+                    glob(mod_path.join(dir, '*.keys'), function (err, files) {
+                        log.trace({err: err, files: files, dir: dir},
+                            'readLoadDir');
+                        if (err) {
+                            nextDir(err);
+                            return;
+                        }
+                        arg.keysFiles = arg.keysFiles.concat(files);
+                        nextDir();
+                    });
+                }
+            }, next);
+        },
+        function getAuthKeys(arg, next) {
+            // Sort input files so we have a stable `app.authKeys`.
+            arg.keysFiles.sort();
+            vasync.forEachPipeline({
+                inputs: arg.keysFiles,
+                func: function loadOneKeysFile(keysFile, nextKeysFile) {
+                    loadKeysFile(keysFile, function (err, u, keys) {
+                        if (err) {
+                            nextKeysFile(err);
+                            return;
+                        }
+                        if (!arg.authKeys[u]) {
+                            arg.authKeys[u] = keys;
+                        } else {
+                            arg.authKeys[u] = arg.authKeys[u].concat(keys);
+                        }
+                        nextKeysFile();
+                    });
+                }
+            }, next);
+        },
+        function setIt(arg, next) {
+            /*
+             * Only log.info if there is a change in the keys.
+             */
+            var oldSerial = JSON.stringify(self.app.authKeys);
+            var newSerial = JSON.stringify(arg.authKeys);
+            var isDiff = Boolean(oldSerial !== newSerial);
+
+            self.app.authKeys = arg.authKeys;
+
+            if (isDiff) {
+                log.info({authKeys: self.app.authKeys}, 'updated app.authKeys');
+            } else {
+                log.trace({authKeys: arg.authKeys}, 'loaded authKeys');
+            }
+
+            next();
+        }
+    ]}, function doneLoad(err) {
+        if (cb) {
+            cb(err);
+        }
+    });
+};
+
+
+//---- exports
+
+module.exports = {
+    mountApi: mountApi,
+    AuthKeysLoader: AuthKeysLoader
+};
diff --git a/lib/config.js b/lib/config.js
new file mode 100644
index 0000000..88a0ee7
--- /dev/null
+++ b/lib/config.js
@@ -0,0 +1,325 @@
+#!/usr/bin/env node
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+/*
+ * Config loading and validation for IMGAPI.
+ * See the "Configuration" section of the operator-guide.md for details.
+ *
+ * Module usage:
+ *      var mod_config = require('./config');
+ *      mod_config.loadConfig({...}, function (err, config) {
+ *          // ...
+ *      });
+ *
+ * CLI usage:
+ *      $ node lib/config.js
+ *      ... emits the full merged and computed config ...
+ *      $ node lib/config.js KEY
+ *      ... emits the value of KEY (in json-y form, i.e. quotes removed from a
+ *      string) ...
+ */
+
+var assert = require('assert-plus');
+var dashdash = require('dashdash');
+var format = require('util').format;
+var fs = require('fs');
+var mod_path = require('path');
+var vasync = require('vasync');
+var VError = require('verror').VError;
+
+
+// ---- globals
+
+var DEFAULT_PATH = '/data/imgapi/etc/imgapi.config.json';
+
+
+// ---- internal support
+
+/*
+ * lookup the property "str" (given in dot-notation) in the object "obj".
+ * "c" is optional and may be set to any delimiter (defaults to dot: ".")
+ *
+ * Note: lifted from node-tabula.
+ */
+function dottedLookup(obj, str, c) {
+    if (c === undefined)
+        c = '.';
+    var o = obj;
+    var dots = str.split(c);
+    var s = [];
+    for (var i = 0; i < dots.length; i++) {
+        var dot = dots[i];
+        s.push(dot);
+        if (!o.hasOwnProperty(dot))
+            throw new Error('no property ' + s.join(c) + ' found');
+        o = o[dot];
+    }
+    return o;
+}
+
+
+function validateConfigSync(config) {
+    assert.number(config.port, 'config.port');
+    assert.string(config.address, 'config.address');
+    assert.number(config.maxSockets, 'config.maxSockets');
+    assert.optionalString(config.serverName, 'config.serverName');
+
+    assert.string(config.mode, 'config.mode');
+    var validModes = ['public', 'private', 'dc'];
+    assert.ok(validModes.indexOf(config.mode) !== -1,
+        'invalid config.mode: ' + config.mode);
+
+    if (config.mode === 'dc') {
+        assert.string(config.datacenterName, 'config.datacenterName');
+
+        assert.object(config.ufds, 'config.ufds');
+        assert.string(config.ufds.url, 'config.ufds.url');
+        assert.string(config.ufds.bindDN, 'config.ufds.bindDN');
+        assert.string(config.ufds.bindPassword, 'config.ufds.bindPassword');
+
+        assert.object(config.moray, 'config.moray');
+        assert.string(config.moray.host, 'config.moray.host');
+        assert.number(config.moray.port, 'config.moray.port');
+
+        assert.object(config.wfapi, 'config.wfapi');
+        assert.string(config.wfapi.url, 'config.wfapi.url');
+        assert.arrayOfString(config.wfapi.workflows, 'config.wfapi.workflows');
+    }
+
+    assert.string(config.authType, 'config.authType');
+    var validAuthTypes = ['none', 'signature'];
+    assert.ok(validAuthTypes.indexOf(config.authType) !== -1,
+        'invalid config.authType: ' + config.authType);
+
+    assert.arrayOfString(config.storageTypes, 'config.storageTypes');
+    var validStorageTypes = ['local', 'manta'];
+    config.storageTypes.forEach(function (st) {
+        assert.ok(validStorageTypes.indexOf(st) !== -1,
+            'invalid storage type: ' + st);
+    });
+    if (config.storageTypes.indexOf('manta') !== -1) {
+        assert.object(config.manta, 'config.manta');
+    }
+
+    if (config.manta) {
+        assert.string(config.manta.url, 'config.manta.url');
+        assert.string(config.manta.user, 'config.manta.user');
+        assert.string(config.manta.key, 'config.manta.key');
+        assert.string(config.manta.keyId, 'config.manta.keyId');
+        assert.string(config.manta.baseDir, 'config.manta.baseDir');
+        assert.string(config.manta.rootDir, 'config.manta.rootDir'); // computed
+    }
+
+    assert.string(config.databaseType, 'config.databaseType');
+    var validDatabaseTypes = ['local', 'moray'];
+    assert.ok(validDatabaseTypes.indexOf(config.databaseType) !== -1,
+        'invalid config.databaseType: ' + config.databaseType);
+
+    assert.optionalNumber(config.placeholderImageLifespanDays,
+        'config.placeholderImageLifespanDays');
+    assert.optionalBool(config.allowLocalCreateImageFromVm,
+        'config.allowLocalCreateImageFromVm');
+}
+
+
+// ---- config loading
+
+/**
+ * Load config.
+ *
+ * This loads factory settings (etc/defaults.json) and any given `configPath`.
+ *
+ * @param opts.log {Bunyan Logger} Optional.
+ * @param opts.path {String} Optional. Path to JSON config file to load.
+ *      If not given, then the default config path (DEFAULT_PATH) is used.
+ * @param cb {Function} `function (err, config)`
+ */
+function loadConfig(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.optionalString(opts.path, 'opts.path');
+
+    var configPath = opts.path || DEFAULT_PATH;
+    var config;
+
+    vasync.pipeline({funcs: [
+        function loadDefaults(_, next) {
+            var defaultsPath = mod_path.resolve(__dirname, '..', 'etc',
+                'defaults.json');
+            if (opts.log) {
+                opts.log.info({defaultsPath: defaultsPath},
+                    'load config defaults');
+            }
+            fs.readFile(defaultsPath, {encoding: 'utf8'}, function (err, data) {
+                if (err) {
+                    next(err);
+                } else {
+                    try {
+                        config = JSON.parse(data);
+                    } catch (parseErr) {
+                        next(VError(parseErr,
+                            'could not parse ' + defaultsPath));
+                        return;
+                    }
+                    next();
+                }
+            });
+        },
+
+        function loadConfigPath(_, next) {
+            if (opts.log) {
+                opts.log.info({configPath: configPath},
+                    'load config path');
+            }
+            fs.readFile(configPath, {encoding: 'utf8'}, function (err, data) {
+                if (err) {
+                    next(err);
+                } else {
+                    try {
+                        var extraConfig = JSON.parse(data);
+                    } catch (parseErr) {
+                        next(VError(parseErr,
+                            'could not parse ' + configPath));
+                        return;
+                    }
+                    for (var key in extraConfig) {
+                        config[key] = extraConfig[key];
+                    }
+                    next();
+                }
+            });
+        },
+
+        /*
+         * There is some "computed" config: i.e. values that fully defined
+         * by other config values, but are useful to have processed in one
+         * place (here) and added to the config for IMGAPI code to use.
+         *
+         * We also use this to squeeze in defaults that are nested. Normally
+         * we'd put these in "defaults.json", but if the given config sets
+         * `manta`, then a `manta.baseDir === "imgapi"` default gets lost.
+         */
+        function computeConfig(_, next) {
+            // default: manta.baseDir
+            if (config.manta && !config.manta.baseDir) {
+                config.manta.baseDir = 'imgapi';
+            }
+
+            // compute: manta.rootDir
+            if (config.manta) {
+                assert.string(config.mode, 'config.mode');
+                assert.string(config.manta.user, 'config.manta.user');
+                assert.string(config.manta.baseDir, 'config.manta.baseDir');
+                var rootDir = format('/%s/stor/%s', config.manta.user,
+                    config.manta.baseDir);
+                if (config.mode === 'dc') {
+                    assert.string(config.datacenterName,
+                        'config.datacenterName');
+                    rootDir += '/' + config.datacenterName;
+                }
+                config.manta.rootDir = rootDir;
+            }
+            next();
+        },
+
+        function validate(_, next) {
+            try {
+                validateConfigSync(config);
+            } catch (err) {
+                next(VError(err, 'invalid IMGAPI config'));
+                return;
+            }
+            next();
+        }
+
+    ]}, function (err) {
+        cb(err, config);
+    });
+}
+
+
+
+// ---- mainline
+
+function main(argv) {
+    assert.arrayOfString(argv, 'argv');
+
+    var options = [
+        {
+            names: ['help', 'h'],
+            type: 'bool',
+            help: 'Print this help and exit.'
+        },
+        {
+            names: ['file', 'f'],
+            type: 'string',
+            help: 'Config file path.',
+            helpArg: 'CONFIG-PATH'
+        }
+    ];
+    var parser = dashdash.createParser({options: options});
+    try {
+        var opts = parser.parse(argv);
+    } catch (e) {
+        console.error('lib/config.js: error: %s', e.message);
+        process.exit(1);
+    }
+
+    if (opts.help) {
+        console.log([
+            'usage: node .../lib/config.js [OPTIONS] [KEY]',
+            'options:',
+            parser.help().trimRight()
+        ].join('\n'));
+        process.exit(0);
+    }
+
+    var key;
+    if (opts._args.length === 1) {
+        key = opts._args[0];
+    } else if (opts._args.length === 0) {
+        key = null;
+    } else {
+        console.error('lib/config.js: error: too many args: %s',
+            opts._args.join(' '));
+        process.exit(1);
+    }
+
+    loadConfig({path: opts.file}, function (err, config) {
+        if (err) {
+            console.error('lib/config.js: error: %s', err.stack);
+            process.exit(1);
+        }
+        if (key) {
+            var val = dottedLookup(config, key);
+            if (typeof (val) === 'string') {
+                console.log(val);
+            } else {
+                console.log(JSON.stringify(val, null, 4));
+            }
+        } else {
+            console.log(JSON.stringify(config, null, 4));
+        }
+    });
+}
+
+if (require.main === module) {
+    main(process.argv);
+}
+
+
+// ---- exports
+
+module.exports = {
+    DEFAULT_PATH: DEFAULT_PATH,
+    loadConfig: loadConfig
+};
diff --git a/lib/constants.js b/lib/constants.js
new file mode 100644
index 0000000..1b7c84c
--- /dev/null
+++ b/lib/constants.js
@@ -0,0 +1,115 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+/*
+ * IMGAPI constants.
+ *
+ * CLI usage:
+ *      $ node lib/constants.js
+ *      ... emits all the constants as a JSON object ...
+ *      $ node lib/constants.js KEY
+ *      ... emits the value of KEY (in json-y form, i.e. quotes removed from a
+ *      string) ...
+ */
+
+
+// ---- exports
+
+/*
+ * All files written locally by IMGAPI (with the exception of logs) are stored
+ * under this dir.
+ *
+ * For *testing* only, we allow override of this dir. Note that for this to
+ * work, it relies on test code using `node lib/constants.js ...` to get
+ * this path.
+ */
+var LOCAL_BASE_DIR = '/data/imgapi';
+if (process.env.IMGAPITEST_LOCAL_BASE_DIR) {
+    LOCAL_BASE_DIR = process.env.IMGAPITEST_LOCAL_BASE_DIR;
+}
+
+
+module.exports = {
+    LOCAL_BASE_DIR: LOCAL_BASE_DIR,
+
+    /*
+     * Dir used by the 'local' database backend to store manifests.
+     */
+    DATABASE_LOCAL_DIR: LOCAL_BASE_DIR + '/manifests',
+
+    /*
+     * Dir used by the 'local' storage backend to store images and archive
+     * files.
+     */
+    STORAGE_LOCAL_IMAGES_DIR: LOCAL_BASE_DIR + '/images',
+    STORAGE_LOCAL_ARCHIVE_DIR: LOCAL_BASE_DIR + '/archive',
+
+    AUTHKEYS_BASE_DIR: LOCAL_BASE_DIR + '/etc/authkeys'
+};
+
+
+// ---- mainline
+
+function main(argv) {
+    var assert = require('assert-plus');
+    var dashdash = require('dashdash');
+
+    assert.arrayOfString(argv, 'argv');
+
+    var options = [
+        {
+            names: ['help', 'h'],
+            type: 'bool',
+            help: 'Print this help and exit.'
+        }
+    ];
+    var parser = dashdash.createParser({options: options});
+    try {
+        var opts = parser.parse(argv);
+    } catch (e) {
+        console.error('lib/constants.js: error: %s', e.message);
+        process.exit(1);
+    }
+
+    if (opts.help) {
+        console.log([
+            'usage: node .../lib/constants.js [OPTIONS] [KEY]',
+            'options:',
+            parser.help().trimRight()
+        ].join('\n'));
+        process.exit(0);
+    }
+
+    var key;
+    if (opts._args.length === 1) {
+        key = opts._args[0];
+    } else if (opts._args.length === 0) {
+        key = null;
+    } else {
+        console.error('lib/constants.js: error: too many args: %s',
+            opts._args.join(' '));
+        process.exit(1);
+    }
+
+    if (key) {
+        var val = module.exports[key];
+        if (typeof (val) === 'string') {
+            console.log(val);
+        } else {
+            console.log(JSON.stringify(val, null, 4));
+        }
+    } else {
+        console.log(JSON.stringify(module.exports, null, 4));
+    }
+}
+
+if (require.main === module) {
+    main(process.argv);
+}
diff --git a/lib/database.js b/lib/database.js
index b6d889c..8732f69 100644
--- a/lib/database.js
+++ b/lib/database.js
@@ -68,10 +68,9 @@ var SEARCH_TYPE_FROM_FIELD = {
  * Create a Database handler.
  *
  * @param app {App}
- * @params config {Object} The 'database' section of the IMGAPI config.
  * @params log {Bunyan Logger}
  */
-function Database(config, log) {
+function Database(log) {
     this.type = null;
 }
 
@@ -151,16 +150,14 @@ Database.prototype.del = function (uuid, callback) {};
 // is stored in memory. Therefore this is only appropriate for small numbers
 // of images (e.g. dev, testing and limited IMGAPI deployments).
 
-function LocalDatabase(app, config, log) {
+function LocalDatabase(app, log) {
     assert.object(app, 'app');
-    assert.object(config, 'config');
-    assert.string(config.dir, 'config.dir');
     assert.object(log, 'log');
 
     this.type = 'local';
     this.app = app;
     this.log = log.child({component: 'db'}, true);
-    this.dir = config.dir;
+    this.dir = '/data/imgapi/manifests';
 }
 util.inherits(LocalDatabase, Database);
 
@@ -522,17 +519,14 @@ LocalDatabase.prototype.del = function (uuid, callback) {
  * Create a MorayDatabase handler.
  *
  * @param app {App}
- * @params config {Object} The 'database' section of the IMGAPI config.
  * @params log {Bunyan Logger}
  */
-function MorayDatabase(app, config, log) {
+function MorayDatabase(app, log) {
     assert.object(app, 'app');
-    assert.object(config, 'config');
     assert.object(log, 'log');
 
     this.type = 'moray';
     this.app = app;
-    this.config = config;
     this.log = log.child({component: 'db'}, true);
 }
 util.inherits(MorayDatabase, Database);
diff --git a/lib/images.js b/lib/images.js
index bec2ce7..75aabbc 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -23,8 +23,8 @@ var path = require('path');
 var assert = require('assert-plus');
 var async = require('async');
 var drc = require('docker-registry-client');
-var genUuid = require('libuuid');
 var imgmanifest = require('imgmanifest');
+var lib_uuid = require('uuid');
 var once = require('once');
 var restify = require('restify');
 var sdc = require('sdc-clients');
@@ -1044,7 +1044,7 @@ Image.create = function createImage(app, data, isImport, isPlaceholder, cb) {
         raw.state = 'creating';
         delete data.uuid;
     } else {
-        raw.uuid = genUuid.create();
+        raw.uuid = lib_uuid.v4();
     }
 
     // Error on extra spurious fields.
@@ -1761,7 +1761,7 @@ function apiCreateImageFromVm(req, res, callback) {
     }
 
     if (manifest.uuid === undefined) {
-        manifest.uuid = genUuid.create();
+        manifest.uuid = lib_uuid.v4();
     }
     // Workaround IMGAPI-251: see note above.
     if (incremental && !(manifest.requirements &&
@@ -4418,6 +4418,8 @@ function apiExportImage(req, res, callback) {
     var account = req.query.account;
     // account is given:
     //      Call from CloudAPI, account must be the same as the manta user
+    // TODO: with RBAC v2 work this should be a check with secapi that the
+    //      account can write to that area.
     if (account) {
         app.ufdsClient.getUser(account, function (err, user) {
             if (err) {
@@ -4512,7 +4514,7 @@ function apiExportImage(req, res, callback) {
                 return callback(err);
             }
             res.send({
-                'manta_url': app.config.storage.manta.url,
+                'manta_url': app.config.manta.url,
                 'image_path': fileStorPath,
                 'manifest_path': manifestStorPath
             });
diff --git a/lib/migrations/migration-001-file-compression.js b/lib/migrations/migration-001-file-compression.js
deleted file mode 100644
index e6c5000..0000000
--- a/lib/migrations/migration-001-file-compression.js
+++ /dev/null
@@ -1,243 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI UFDS db migration: add required files.*.compression field
- */
-
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.database.url,
-        connectTimeout: 2 * 1000
-    });
-    client.bind(config.database.bindDN, config.database.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        filter: 'objectclass=sdcimage',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-var _nobodyCache = undefined;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-function migrateImage(image, callback) {
-    var id = (config.database.type === 'ufds' ? image.dn
-        : image.uuid + '.raw');
-    var files = image.files;
-    if (!files)
-        return callback();
-    try {
-        files = JSON.parse(files);
-    } catch (ex) {
-        warn('cannot migrate "%s": "files" is invalid JSON: %s', id, files);
-        return callback();
-    }
-    var file = files[0];
-    if (!file)
-        return callback();
-    if (file.compression)
-        return callback();
-    info('migrate "%s"', id);
-    // This is a bad *HACK*: just presuming 'bzip2' because most (all?) our
-    // current ones use bzip2 compression. Right answer is to sniff the magic
-    // number of the actual file.
-    file.compression = 'bzip2';
-    image.files = JSON.stringify(files);
-
-    if (config.database.type === 'ufds') {
-        var changes = {
-            operation: 'replace',
-            modification: {
-                files: image.files
-            }
-        };
-        ufdsClient.modify(image.dn, changes, callback);
-    } else {
-        assert.equal(config.database.type, 'local');
-        var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-        var content = JSON.stringify(image, null, 2);
-        fs.writeFile(dbPath, content, 'utf8', function (err) {
-            if (err)
-                return callback(err);
-            // chmod to 'nobody' user so the imgapi service (running as
-            // 'nobody') can change it.
-            getNobody(function (nobody) {
-                if (!nobody) {
-                    return callback(new Error('could not get nobody user'));
-                }
-                fs.chown(dbPath, Number(nobody.userId), Number(nobody.groupId),
-                    callback);
-            });
-        });
-    }
-}
-
-function ufdsMigrate(callback) {
-    assert.equal(config.database.type, 'ufds');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-        ufdsListImages(function (err2, images) {
-            if (err2)
-                return callback(err2);
-            async.forEachSeries(images, migrateImage, callback);
-        });
-    });
-}
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var p = path.resolve(config.database.dir, file);
-                fs.readFile(p, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'ufds'
-        ? ufdsMigrate : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-002-billing-tags.js b/lib/migrations/migration-002-billing-tags.js
deleted file mode 100644
index 3c2f761..0000000
--- a/lib/migrations/migration-002-billing-tags.js
+++ /dev/null
@@ -1,237 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI UFDS db migration: renames billing_tags field to billingtag
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.ufds.url,
-        connectTimeout: 2 * 1000
-    });
-    client.bind(config.ufds.bindDN, config.ufds.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        filter: 'objectclass=sdcimage',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-
-var _nobodyCache = undefined;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-
-function migrateImage(image, callback) {
-    var id = (config.database.type === 'ufds' ? image.dn
-        : image.uuid + '.raw');
-    var billingTags = image.billing_tags;
-    if (!billingTags)
-        return callback();
-    info('migrate "%s"', id);
-
-    // Basically rename the property. It stays billing_tags for the JSON
-    // version of the Image (API, local database) because that's the API
-    // representation
-    if (config.database.type === 'ufds') {
-        var changes = [ {
-            operation: 'add',
-            modification: { billingtag: billingTags }
-        }, {
-            operation: 'delete',
-            modification: { billing_tags: billingTags }
-        } ];
-        ufdsClient.modify(image.dn, changes, callback);
-    } else {
-        if (billingTags.length > 0) {
-            image.billingtag = image.billing_tags;
-        }
-        delete image.billing_tags;
-        var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-        var content = JSON.stringify(image, null, 2);
-        fs.writeFile(dbPath, content, 'utf8', function (err) {
-            if (err)
-                return callback(err);
-            // chmod to 'nobody' user so the imgapi service (running as
-            // 'nobody') can change it.
-            getNobody(function (nobody) {
-                if (!nobody) {
-                    return callback(new Error('could not get nobody user'));
-                }
-                fs.chown(dbPath, Number(nobody.userId), Number(nobody.groupId),
-                    callback);
-            });
-        });
-    }
-}
-
-function ufdsMigrate(callback) {
-    assert.equal(config.database.type, 'ufds');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-        ufdsListImages(function (err2, images) {
-            if (err2)
-                return callback(err2);
-            async.forEachSeries(images, migrateImage, callback);
-        });
-    });
-}
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var path_ = path.resolve(config.database.dir, file);
-                fs.readFile(path_, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'ufds'
-        ? ufdsMigrate : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-003-tags.js b/lib/migrations/migration-003-tags.js
deleted file mode 100644
index b38eeab..0000000
--- a/lib/migrations/migration-003-tags.js
+++ /dev/null
@@ -1,251 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI db migration: renames the 'tags' field to separate flag 'tag'
- * fields.
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.ufds.url,
-        connectTimeout: 2 * 1000
-    });
-    client.bind(config.ufds.bindDN, config.ufds.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        filter: 'objectclass=sdcimage',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-
-function objectToTag(obj) {
-    if (typeof (obj) === 'string') {
-        obj = JSON.parse(obj);
-    }
-
-    var values = [];
-    Object.keys(obj).forEach(function (key) {
-        var value = key + '=' + obj[key];
-        values.push(value);
-    });
-
-    return values;
-}
-
-
-var _nobodyCache = undefined;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-
-function migrateImage(image, callback) {
-    var id = (config.database.type === 'ufds' ? image.dn
-        : image.uuid + '.raw');
-    var tags = image.tags;
-    if (!tags)
-        return callback();
-    info('migrate "%s"', id);
-
-    // Rename it to tags and make it an array and not a stringified object
-    if (config.database.type === 'ufds') {
-        var changes = [ {
-            operation: 'add',
-            modification: { tag: objectToTag(tags) }
-        }, {
-            operation: 'delete',
-            modification: { tags: tags }
-        } ];
-        ufdsClient.modify(image.dn, changes, callback);
-    } else {
-        if (tags.length > 0) {
-            image.tag = objectToTag(image.tags);
-        }
-        delete image.tags;
-        var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-        var content = JSON.stringify(image, null, 2);
-        fs.writeFile(dbPath, content, 'utf8', function (err) {
-            if (err)
-                return callback(err);
-            // chmod to 'nobody' user so the imgapi service (running as
-            // 'nobody') can change it.
-            getNobody(function (nobody) {
-                if (!nobody) {
-                    return callback(new Error('could not get nobody user'));
-                }
-                fs.chown(dbPath, Number(nobody.userId), Number(nobody.groupId),
-                    callback);
-            });
-        });
-    }
-}
-
-function ufdsMigrate(callback) {
-    assert.equal(config.database.type, 'ufds');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-        ufdsListImages(function (err2, images) {
-            if (err2)
-                return callback(err2);
-            async.forEachSeries(images, migrateImage, callback);
-        });
-    });
-}
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var path_ = path.resolve(config.database.dir, file);
-                fs.readFile(path_, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'ufds'
-        ? ufdsMigrate : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-004-tag-and-tags.js b/lib/migrations/migration-004-tag-and-tags.js
deleted file mode 100644
index ade20d5..0000000
--- a/lib/migrations/migration-004-tag-and-tags.js
+++ /dev/null
@@ -1,253 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI db migration: adds a 'tags' field (the JSON object to return in
- * image objects) in *addition* to the flat 'tag' fields used for indexing and
- * searching.
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.ufds.url,
-        connectTimeout: 2 * 1000
-    });
-    client.bind(config.ufds.bindDN, config.ufds.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        filter: 'objectclass=sdcimage',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-
-function keyValueToObject(array) {
-    if (!array) {
-        throw new TypeError('Array of key/values required');
-    } else if (typeof (array) === 'string') {
-        array = [array];
-    }
-
-    var obj = {};
-    array.forEach(function (keyvalue) {
-        var kv = keyvalue.split('=');
-
-        if (kv.length != 2) {
-            throw new TypeError('Key/value string expected');
-        }
-
-        obj[kv[0]] = kv[1];
-    });
-
-    return obj;
-}
-
-
-var _nobodyCache = undefined;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-
-function migrateImage(image, callback) {
-    var id = (config.database.type === 'ufds' ? image.dn
-        : image.uuid + '.raw');
-    var tag = image.tag;
-    if (!tag)
-        return callback();
-    info('migrate "%s"', id);
-
-    var tags = keyValueToObject(tag);
-    if (config.database.type === 'ufds') {
-        var changes = [ {
-            operation: 'add',
-            modification: { tags: JSON.stringify(tags) }
-        } ];
-        ufdsClient.modify(image.dn, changes, callback);
-    } else {
-        image.tags = JSON.stringify(tags);
-        var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-        var content = JSON.stringify(image, null, 2);
-        fs.writeFile(dbPath, content, 'utf8', function (err) {
-            if (err)
-                return callback(err);
-            // chmod to 'nobody' user so the imgapi service (running as
-            // 'nobody') can change it.
-            getNobody(function (nobody) {
-                if (!nobody) {
-                    return callback(new Error('could not get nobody user'));
-                }
-                fs.chown(dbPath, Number(nobody.userId), Number(nobody.groupId),
-                    callback);
-            });
-        });
-    }
-}
-
-function ufdsMigrate(callback) {
-    assert.equal(config.database.type, 'ufds');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-        ufdsListImages(function (err2, images) {
-            if (err2)
-                return callback(err2);
-            async.forEachSeries(images, migrateImage, callback);
-        });
-    });
-}
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var path_ = path.resolve(config.database.dir, file);
-                fs.readFile(path_, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'ufds'
-        ? ufdsMigrate : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-005-guid.js b/lib/migrations/migration-005-guid.js
deleted file mode 100755
index ea312e0..0000000
--- a/lib/migrations/migration-005-guid.js
+++ /dev/null
@@ -1,301 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI db migration: adds guid field to every image files object.
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-var format = require('util').format;
-var execFile = require('child_process').execFile;
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-var GUID_SCRIPT = path.resolve(__dirname +
-    '/../../tools/get-image-dataset-guid.sh');
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.ufds.url,
-        connectTimeout: 2 * 1000
-    });
-    client.bind(config.ufds.bindDN, config.ufds.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        // Use this filter to only do (or perhaps on do *first*) public images:
-        //  filter:'(&(objectclass=sdcimage)(disabled=false)\
-        //          (!(tag=smartdc_service=true))(public=true))',
-        /*JSSTYLED*/
-        filter: '(&(objectclass=sdcimage)(disabled=false)(!(tag=smartdc_service=true)))',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-
-var _nobodyCache = undefined;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-
-function getDatasetGuid(image, files, callback) {
-    var guid;
-    var execArgs = [IMGAPI_URL, image.uuid, files[0].compression || 'none'];
-
-    execFile(GUID_SCRIPT, execArgs, function (err, stdout, stderr) {
-        if (err) {
-            return callback(err);
-        } else {
-            guid = bigDecimalFromHex(stdout.toString().replace(/\n|\r/g, ''));
-            return callback(null, guid);
-        }
-    });
-}
-
-
-/**
- * From <http://stackoverflow.com/questions/12532871>
- * "How to convert a very large hex number to decimal in javascript"
- */
-function bigDecimalFromHex(inputHex) {
-    function add(x, y) {
-        var c = 0, r = [];
-        x = x.split('').map(Number);
-        y = y.split('').map(Number);
-        while (x.length || y.length) {
-            var hex = (x.pop() || 0) + (y.pop() || 0) + c;
-            r.unshift(hex < 10 ? hex : hex - 10);
-            c = hex < 10 ? 0 : 1;
-        }
-        if (c) r.unshift(c);
-        return r.join('');
-    }
-
-    var dec = '0';
-    inputHex.split('').forEach(function (chr) {
-        var n = parseInt(chr, 16);
-        for (var t = 8; t; t >>= 1) {
-            dec = add(dec, dec);
-            if (n & t) dec = add(dec, '1');
-        }
-    });
-
-    return dec;
-}
-
-
-function migrateImage(image, callback) {
-    var id = (config.database.type === 'ufds' ? image.dn
-        : image.uuid + '.raw');
-    var files = image.files;
-    if (!files)
-        return callback();
-    files = JSON.parse(files);
-    if (files && files[0] && files[0].dataset_guid)
-        return callback();
-
-    info('migrate "%s"', id);
-    getDatasetGuid(image, files, function (gerr, guid) {
-        if (gerr) {
-            warn('could not get dataset_guid for image "%s": %s', image.uuid,
-                gerr.toString().replace('\n', ' '));
-            return callback();
-        } else if (!guid) {
-            return callback();
-        }
-
-        files[0].dataset_guid = guid;
-        // Rename it to tags and make it an array and not a stringified object
-        if (config.database.type === 'ufds') {
-            var changes = [ {
-                operation: 'replace',
-                modification: { files: JSON.stringify(files) }
-            } ];
-            ufdsClient.modify(image.dn, changes, callback);
-        } else {
-            image.files = JSON.stringify(files);
-            var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-            var content = JSON.stringify(image, null, 2);
-            fs.writeFile(dbPath, content, 'utf8', function (err) {
-                if (err)
-                    return callback(err);
-                // chmod to 'nobody' user so the imgapi service (running as
-                // 'nobody') can change it.
-                getNobody(function (nobody) {
-                    if (!nobody) {
-                        return callback(new Error('could not get nobody user'));
-                    }
-                    fs.chown(dbPath, Number(nobody.userId),
-                        Number(nobody.groupId), callback);
-                });
-            });
-        }
-    });
-}
-
-function ufdsMigrate(callback) {
-    assert.equal(config.database.type, 'ufds');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-        ufdsListImages(function (err2, images) {
-            if (err2)
-                return callback(err2);
-            info('%d images to potentially migrate', images.length);
-            async.forEachSeries(images, migrateImage, callback);
-        });
-    });
-}
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var path_ = path.resolve(config.database.dir, file);
-                fs.readFile(path_, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'ufds'
-        ? ufdsMigrate : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-006-cleanup-manta-storage.js b/lib/migrations/migration-006-cleanup-manta-storage.js
deleted file mode 100644
index f799d0d..0000000
--- a/lib/migrations/migration-006-cleanup-manta-storage.js
+++ /dev/null
@@ -1,243 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI db migration: TODO: describe
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var manta = require('manta');
-var assert = require('assert-plus');
-var async = require('async');
-var format = require('util').format;
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-
-var UUID_REGEX =
-    /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-
-var mantaClient, imagesDir, newImagesDir;
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-
-function moveImages(callback) {
-    mantaClient.ls(imagesDir, function (lsErr, res) {
-        if (lsErr) {
-            return callback(lsErr);
-        }
-
-        var dirs = [];
-        res.on('object', function (obj) {
-            // Ignore objects
-        });
-        res.on('directory', function (dir) {
-            if (UUID_REGEX.test(dir.name)) {
-                dirs.push(dir.name);
-            } else {
-                info('directory %s is not a UUID, ignoring', dir.name);
-            }
-        });
-        // Only remove directory if it's empty
-        res.once('end', function () {
-            async.forEachSeries(dirs, moveImage, callback);
-        });
-    });
-
-    function moveImage(dir, next) {
-        var dirPath = path.join(imagesDir, dir);
-
-        mantaClient.ls(dirPath, function (lsErr, res) {
-            if (lsErr) {
-                return next(lsErr);
-            }
-
-            var files = [];
-            res.on('object', function (obj) {
-                // $uuid/file0
-                // $uuid/icon
-                files.push(path.join(dir, obj.name));
-            });
-            res.on('directory', function (aDir) {
-                // There should not be any directories here
-            });
-            // Only remove directory if it's empty
-            res.once('end', function () {
-                if (files.length) {
-                    // Remove dir after move
-                    async.forEachSeries(files, moveFile, function (aErr) {
-                        if (aErr) {
-                            return next(aErr);
-                        }
-                        return removeDir(dirPath, next);
-                    });
-                } else {
-                    return removeDir(dirPath, next);
-                }
-            });
-        });
-    }
-
-    function removeDir(dirPath, next) {
-        mantaClient.rmr(dirPath, function (rmErr) {
-            if (rmErr) {
-                return next(rmErr);
-            }
-            info('directory "%s" has been removed',
-                dirPath);
-            return next();
-        });
-    }
-
-    function moveFile(file, next) {
-        var oldPath = path.join(imagesDir, file);
-        var newPath = path.join(newImagesDir, file);
-        var newDir = path.dirname(newPath);
-
-        mantaClient.info(oldPath, function (infoErr, fInfo) {
-            if (infoErr) {
-                return next(infoErr);
-            }
-
-            // Make sure new directory exists first
-            mantaClient.mkdirp(newDir, function (mkErr) {
-                if (mkErr) {
-                    return callback(mkErr);
-                }
-                return moveAndRemove(fInfo.md5);
-            });
-        });
-
-        function moveAndRemove(oldMd5) {
-            mantaClient.ln(oldPath, newPath, function (lnErr) {
-                if (lnErr) {
-                    return next(lnErr);
-                }
-
-                // Now, make sure both md5's match before removing the source
-                mantaClient.info(newPath, function (info2Err, info2) {
-                    if (info2Err) {
-                        return next(info2Err);
-                    }
-
-                    if (oldMd5 !== info2.md5) {
-                        warn('md5 for "%s" doesn\'t match old md5 (%s vs %s)',
-                            newPath, oldMd5, info2.md5);
-                        return next();
-                    }
-                    // If it matches, delete the old file
-                    mantaClient.unlink(oldPath, function (ulErr) {
-                        if (ulErr) {
-                            return next(ulErr);
-                        }
-
-                        info('directory "%s" successfully moved', newPath);
-                        return next();
-                    });
-                });
-            });
-        }
-    }
-}
-
-
-function mantaMigrate(callback) {
-    var mantaCfg = config.storage.manta;
-    assert.string(config.datacenterName, 'config.datacenterName');
-    assert.string(mantaCfg.url, 'manta.url');
-    assert.string(mantaCfg.user, 'manta.user');
-    assert.string(mantaCfg.key, 'manta.key');
-    assert.string(mantaCfg.keyId, 'manta.keyId');
-    assert.optionalBool(mantaCfg.insecure, 'manta.insecure');
-
-    var insecure = mantaCfg.hasOwnProperty('insecure') ?
-        mantaCfg.insecure : false;
-    var user = mantaCfg.user;
-    imagesDir = format('/%s/stor/imgapi/%s', user, config.datacenterName);
-    newImagesDir = format('/%s/stor/imgapi/%s/images',
-        user, config.datacenterName);
-
-    mantaClient = manta.createClient({
-        sign: {
-            key: mantaCfg.key,
-            keyId: mantaCfg.keyId,
-            user: user
-        },
-        user: user,
-        url: mantaCfg.url,
-        rejectUnauthorized: !insecure
-    });
-
-    return moveImages(callback);
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.storage, 'config.storage');
-    if (config.storage.manta) {
-        mantaMigrate(function (err) {
-            if (err) {
-                errexit(err);
-            } else {
-                process.exit(0);
-            }
-        });
-    } else {
-        info('IMGAPI instance not configured to use Manta');
-        process.exit(0);
-    }
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-007-ufds-to-moray.js b/lib/migrations/migration-007-ufds-to-moray.js
deleted file mode 100644
index 0d28d11..0000000
--- a/lib/migrations/migration-007-ufds-to-moray.js
+++ /dev/null
@@ -1,353 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * IMGAPI db migration: migrates every image from ufds to moray.
- */
-
-var p = console.log;
-var fs = require('fs');
-var path = require('path');
-var ldap = require('ldapjs');
-var moray = require('moray');
-var bunyan = require('bunyan');
-var errors = require('../errors');
-var assert = require('assert-plus');
-var async = require('async');
-var passwd = require('passwd');
-var format = require('util').format;
-var execFile = require('child_process').execFile;
-
-
-//---- globals
-
-var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
-var ufdsClient = null;  // set in `getUfdsClient()`
-var morayClient = null;  // set in `getMorayClient()`
-var GUID_SCRIPT = path.resolve(
-    __dirname + '/../../tools/get-image-dataset-guid.sh');
-
-
-
-//---- support functions
-
-function errexit(err) {
-    console.error(NAME + ' error: ' + err);
-    process.exit(1);
-}
-
-function warn() {
-    arguments[0] = NAME + ' warn: ' + arguments[0];
-    console.warn.apply(null, arguments);
-}
-
-function info() {
-    arguments[0] = NAME + ' info: ' + arguments[0];
-    console.log.apply(null, arguments);
-}
-
-function getUfdsClient(callback) {
-    var client = ldap.createClient({
-        url: config.ufds.url,
-        connectTimeout: 2 * 1000,
-        tlsOptions: {
-            rejectUnauthorized: false
-        }
-    });
-    client.bind(config.ufds.bindDN, config.ufds.bindPassword,
-        function (bErr) {
-            if (bErr) {
-                return callback(bErr);
-            }
-            return callback(null, client);
-        }
-    );
-}
-
-function getMorayClient(callback) {
-    var client = moray.createClient({
-        connectTimeout: config.moray.connectTimeout || 200,
-        host: config.moray.host,
-        port: config.moray.port,
-        log: bunyan.createLogger({
-            name: 'moray',
-            level: 'INFO',
-            stream: process.stdout,
-            serializers: bunyan.stdSerializers
-        }),
-        reconnect: true,
-        retry: (config.moray.retry === false ? false : {
-            retries: Infinity,
-            minTimeout: 1000,
-            maxTimeout: 16000
-        })
-    });
-
-    client.on('connect', function () {
-        return callback(client);
-    });
-}
-
-function ufdsListImages(callback) {
-    var base = 'ou=images, o=smartdc';
-    var opts = {
-        filter: 'objectclass=sdcimage',
-        scope: 'one'
-    };
-    ufdsClient.search(base, opts, function (sErr, result) {
-        if (sErr) {
-            return callback(sErr);
-        }
-
-        var images = [];
-        result.on('searchEntry', function (entry) {
-            images.push(entry.object);
-        });
-
-        result.on('error', function (err) {
-            // When NoSuchObjectError is returned it means that we are migrating
-            // on a datacenter that is new enough such that it never had an
-            // IMGAPI that was based on UFDS
-            if (err.name === 'NoSuchObjectError') {
-                info('"ou=images, o=smartdc" tree does not seem to exist');
-                info('no migration needed');
-                return callback(null, []);
-            }
-            return callback(err);
-        });
-
-        result.on('end', function (res) {
-            if (res.status !== 0) {
-                return callback(new errors.InternalError(
-                    'non-zero status from LDAP search: ' + res));
-            }
-            callback(null, images);
-        });
-    });
-}
-
-
-var _nobodyCache;
-function getNobody(callback) {
-    if (_nobodyCache !== undefined)
-        return callback(_nobodyCache);
-
-    passwd.get('nobody', function (nobody) {
-        _nobodyCache = nobody;
-        callback(_nobodyCache);
-    });
-}
-
-
-function boolFromString(value) {
-    if (value === 'false') {
-        return false;
-    } else if (value === 'true') {
-        return true;
-    } else if (typeof (value) === 'boolean') {
-        return value;
-    }
-}
-
-
-function objectToArray(string) {
-    var object = JSON.parse(string);
-    var array = [];
-    for (var key in object) {
-        array.push(key + '=' + object[key]);
-    }
-    return array;
-}
-
-
-function toNewImage(image) {
-    delete image.dn;
-    delete image.controls;
-    delete image.objectclass;
-
-    if (image.activated !== undefined) {
-        image.activated = boolFromString(image.activated);
-    }
-    if (image.disabled !== undefined) {
-        image.disabled = boolFromString(image.disabled);
-    }
-    if (image['public'] !== undefined) {
-        image['public'] = boolFromString(image['public']);
-    }
-    if (image.generate_passwords !== undefined) {
-        image.generate_passwords = boolFromString(image.generate_passwords);
-    }
-    if (image.image_size) {
-        image.image_size = Number(image.image_size);
-    }
-
-    ['files', 'requirements', 'error', 'traits', 'icon', 'users'].
-    forEach(function (key) {
-        if (image[key] !== undefined && typeof (image[key]) === 'string') {
-            image[key] = JSON.parse(image[key]);
-        }
-    });
-
-    if (image.tags) {
-        image.tags = objectToArray(image.tags);
-        delete image.tag;
-    }
-    if (image.billingtag) {
-        image.billing_tags = image.billingtag;
-        delete image.billingtag;
-    }
-
-    return image;
-}
-
-
-function migrateImage(image, callback) {
-    image = toNewImage(image);
-
-    if (config.database.type === 'moray') {
-        morayClient.getObject('imgapi_images', image.uuid, function (err, obj) {
-            if (err) {
-                // Only migrate images that don't exist on moray
-                if (err.name === 'ObjectNotFoundError') {
-                    info('migrate "%s"', image.uuid);
-                    return morayClient.putObject('imgapi_images', image.uuid,
-                        image, callback);
-                } else {
-                    return callback(err);
-                }
-            }
-
-            //info('image "%s" already exists on moray', image.uuid);
-            return callback();
-        });
-    } else {
-        info('migrate "%s"', image.uuid);
-        var dbPath = path.resolve(config.database.dir, image.uuid + '.raw');
-        var content = JSON.stringify(image, null, 2);
-        fs.writeFile(dbPath, content, 'utf8', function (err) {
-            if (err) {
-                return callback(err);
-            }
-
-            if (config.mode !== 'dc') {
-                return callback();
-            }
-            // chmod to 'nobody' user so the imgapi service (running as
-            // 'nobody') can change it.
-            getNobody(function (nobody) {
-                if (!nobody) {
-                    return callback(new Error('could not get nobody user'));
-                }
-                fs.chown(dbPath, Number(nobody.userId), Number(nobody.groupId),
-                    callback);
-            });
-        });
-    }
-}
-
-function morayMigrate(callback) {
-    assert.equal(config.database.type, 'moray');
-    getUfdsClient(function (err, client) {
-        if (err)
-            return callback(err);
-        ufdsClient = client; // intentionally global
-
-        getMorayClient(function (mclient) {
-            morayClient = mclient;
-
-            ufdsListImages(function (err2, images) {
-                if (err2)
-                    return callback(err2);
-                info('%d images to potentially migrate', images.length);
-                async.forEachSeries(images, migrateImage, callback);
-            });
-        });
-    });
-}
-
-
-function localListImages(callback) {
-    /*JSSTYLED*/
-    var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
-        var images = [];
-        async.forEachSeries(
-            files,
-            function oneFile(file, next) {
-                if (!RAW_FILE_RE.test(file))
-                    return next();
-                var path_ = path.resolve(config.database.dir, file);
-                fs.readFile(path_, 'utf8', function (readErr, content) {
-                    if (readErr)
-                        return next(readErr);
-                    try {
-                        images.push(JSON.parse(content));
-                    } catch (ex) {
-                        return next(ex);
-                    }
-                    next();
-                });
-            },
-            function done(err2) {
-                callback(err2, images);
-            }
-        );
-    });
-}
-
-
-function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
-    localListImages(function (err, images) {
-        if (err)
-            return callback(err);
-        async.forEachSeries(images, migrateImage, callback);
-    });
-}
-
-
-
-//---- mainline
-
-function main(argv) {
-    assert.object(config.database, 'config.database');
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'moray' ? morayMigrate
-                                                     : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
-        }
-    });
-}
-
-if (require.main === module) {
-    main(process.argv);
-}
diff --git a/lib/migrations/migration-008-new-storage-layout.js b/lib/migrations/migration-008-new-storage-layout.js
index 832eb45..2726731 100644
--- a/lib/migrations/migration-008-new-storage-layout.js
+++ b/lib/migrations/migration-008-new-storage-layout.js
@@ -6,48 +6,35 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
- * IMGAPI db migration: TODO: describe
+ * IMGAPI db migration: Move to new storage layout for image files, from:
+ *      .../images/$uuid
+ * to:
+ *      .../images/$uuid3charprefix/$uuid
  */
 
-var p = console.log;
 var fs = require('fs');
 var path = require('path');
 var manta = require('manta');
 var assert = require('assert-plus');
 var async = require('async');
 var mkdirp = require('mkdirp');
-var format = require('util').format;
 var passwd = require('passwd');
 
+var lib_config = require('../config');
+var constants = require('../constants');
+
 
 //---- globals
 
 var NAME = path.basename(__filename);
-
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-
 var UUID_REGEX =
     /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
 
+var config;
 var mantaClient;
 var mantaDir, localDir;
 
@@ -210,36 +197,25 @@ function moveMantaImages(callback) {
 
 
 function mantaMigrate(callback) {
-    var mantaCfg = config.storage.manta;
-    assert.string(mantaCfg.url, 'manta.url');
-    assert.string(mantaCfg.user, 'manta.user');
-    assert.string(mantaCfg.key, 'manta.key');
-    assert.string(mantaCfg.keyId, 'manta.keyId');
-    assert.optionalBool(mantaCfg.insecure, 'manta.insecure');
-    assert.optionalString(manta.baseDir, 'config.storage.manta.baseDir');
-
-    var insecure = mantaCfg.hasOwnProperty('insecure') ?
-        mantaCfg.insecure : false;
-    var user = mantaCfg.user;
-
-    var baseDir = mantaCfg.baseDir || 'imgapi';
-    var rootDir = format('/%s/stor/', mantaCfg.user);
-    if (config.mode === 'dc') {
-        assert.string(config.datacenterName, 'config.datacenterName');
-        baseDir = path.join(rootDir, baseDir, config.datacenterName);
-    } else {
-        baseDir = path.join(rootDir, baseDir);
-    }
+    assert.string(config.manta.url, 'config.manta.url');
+    assert.string(config.manta.user, 'config.manta.user');
+    assert.string(config.manta.key, 'config.manta.key');
+    assert.string(config.manta.keyId, 'config.manta.keyId');
+    assert.optionalBool(config.manta.insecure, 'config.manta.insecure');
+    assert.string(config.manta.rootDir, 'config.manta.rootDir');
+
+    var insecure = config.manta.hasOwnProperty('insecure') ?
+        config.manta.insecure : false;
+    mantaDir = path.join(config.manta.rootDir, 'images');  // global
 
-    mantaDir = path.join(baseDir, 'images');
     mantaClient = manta.createClient({
         sign: {
-            key: mantaCfg.key,
-            keyId: mantaCfg.keyId,
-            user: user
+            key: config.manta.key,
+            keyId: config.manta.keyId,
+            user: config.manta.user
         },
-        user: user,
-        url: mantaCfg.url,
+        user: config.manta.user,
+        url: config.manta.url,
         rejectUnauthorized: !insecure
     });
 
@@ -317,12 +293,7 @@ function moveLocalImages(callback) {
 
 
 function localMigrate(callback) {
-    var localCfg = config.storage.local;
-    assert.string(localCfg.baseDir, 'local.baseDir');
-
-    var baseDir = path.resolve(localCfg.baseDir);
-    localDir = path.join(baseDir, 'images');
-
+    localDir = constants.STORAGE_LOCAL_IMAGES_DIR;  // global
     assert.ok(localDir !== '/',
         'cannot have empty or root dir for local storage');
 
@@ -334,20 +305,28 @@ function localMigrate(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.storage, 'config.storage');
+    lib_config.loadConfig({}, function (confErr, config_) {
+        if (confErr) {
+            errexit(confErr);
+            return;
+        }
 
-    // Because all IMGAPI instances have local storage
-    var functions = [ localMigrate ];
-    if (config.storage.manta) {
-        functions.push(mantaMigrate);
-    }
+        config = config_;
+        assert.object(config.storageTypes, 'config.storageTypes');
 
-    async.series(functions, function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
+        // Because all IMGAPI instances have local storage
+        var functions = [ localMigrate ];
+        if (config.storageTypes.indexOf('manta') !== -1) {
+            functions.push(mantaMigrate);
         }
+
+        async.series(functions, function (err) {
+            if (err) {
+                errexit(err);
+            } else {
+                process.exit(0);
+            }
+        });
     });
 }
 
diff --git a/lib/migrations/migration-009-backfill-archive.js b/lib/migrations/migration-009-backfill-archive.js
index 98a9000..5a368cb 100644
--- a/lib/migrations/migration-009-backfill-archive.js
+++ b/lib/migrations/migration-009-backfill-archive.js
@@ -6,19 +6,17 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
  * IMGAPI db migration: TODO: describe
  */
 
-var p = console.log;
 var fs = require('fs');
 var path = require('path');
 var moray = require('moray');
 var bunyan = require('bunyan');
-var errors = require('../errors');
 var assert = require('assert-plus');
 var async = require('async');
 var passwd = require('passwd');
@@ -27,31 +25,19 @@ var execFile = require('child_process').execFile;
 var mkdirp = require('mkdirp');
 var rimraf = require('rimraf');
 
+var lib_config = require('../config');
+var constants = require('../constants');
+var errors = require('../errors');
+
 
 //---- globals
 
 var NAME = path.basename(__filename);
 
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
+var config;
 var morayClient = null;  // set in `getMorayClient()`
 
 
-
 //---- support functions
 
 function errexit(err) {
@@ -192,8 +178,7 @@ function toManifest(image) {
 
 
 function migrateImage(image, callback) {
-    var baseDir = path.resolve(config.storage.local.baseDir);
-    var archiveDir = path.join(baseDir, 'archive');
+    var archiveDir = constants.STORAGE_LOCAL_ARCHIVE_DIR;
 
     info('migrate "%s"', image.uuid);
     var manifest = toManifest(image);
@@ -243,7 +228,7 @@ function migrateImage(image, callback) {
 }
 
 function morayMigrate(callback) {
-    assert.equal(config.database.type, 'moray');
+    assert.equal(config.databaseType, 'moray');
     getMorayClient(function (mclient) {
         morayClient = mclient;
 
@@ -260,14 +245,14 @@ function morayMigrate(callback) {
 function localListImages(callback) {
     /*JSSTYLED*/
     var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
+    fs.readdir(constants.DATABASE_LOCAL_DIR, function (err, files) {
         var images = [];
         async.forEachSeries(
             files,
             function oneFile(file, next) {
                 if (!RAW_FILE_RE.test(file))
                     return next();
-                var path_ = path.resolve(config.database.dir, file);
+                var path_ = path.resolve(constants.DATABASE_LOCAL_DIR, file);
                 fs.readFile(path_, 'utf8', function (readErr, content) {
                     if (readErr)
                         return next(readErr);
@@ -288,7 +273,7 @@ function localListImages(callback) {
 
 
 function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
+    assert.equal(config.databaseType, 'local');
     localListImages(function (err, images) {
         if (err)
             return callback(err);
@@ -301,19 +286,24 @@ function localMigrate(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.storage, 'config.storage');
-    assert.object(config.storage.local, 'config.storage.local');
-    assert.string(config.storage.local.baseDir, 'config.storage.local.baseDir');
-    assert.object(config.database, 'config.database');
-    assert.object(config.database, 'config.database');
-    var migrator = (config.database.type === 'moray' ? morayMigrate
-                                                     : localMigrate);
-    migrator(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            process.exit(0);
+    lib_config.loadConfig({}, function (confErr, config_) {
+        if (confErr) {
+            errexit(confErr);
+            return;
         }
+
+        config = config_;
+        assert.string(config.databaseType, 'config.databaseType');
+
+        var migrator = (config.databaseType === 'moray'
+            ? morayMigrate : localMigrate);
+        migrator(function (err) {
+            if (err) {
+                errexit(err);
+            } else {
+                process.exit(0);
+            }
+        });
     });
 }
 
diff --git a/lib/migrations/migration-010-backfill-billing_tags.js b/lib/migrations/migration-010-backfill-billing_tags.js
index 3701e52..452def9 100644
--- a/lib/migrations/migration-010-backfill-billing_tags.js
+++ b/lib/migrations/migration-010-backfill-billing_tags.js
@@ -6,14 +6,13 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
  * IMGAPI db migration: TODO: describe
  */
 
-var p = console.log;
 var fs = require('fs');
 var path = require('path');
 var moray = require('moray');
@@ -27,27 +26,14 @@ var execFile = require('child_process').execFile;
 var mkdirp = require('mkdirp');
 var rimraf = require('rimraf');
 
+var lib_config = require('../config');
+
 
 //---- globals
 
 var NAME = path.basename(__filename);
 
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
+var config;
 var morayClient = null;  // set in `getMorayClient()`
 
 var BUCKET = {
@@ -172,7 +158,7 @@ function migrateImage(uuid, callback) {
 }
 
 function morayMigrate(callback) {
-    assert.equal(config.database.type, 'moray');
+    assert.equal(config.databaseType, 'moray');
     morayListImages(function (err2) {
         if (err2) {
             return callback(err2);
@@ -207,29 +193,33 @@ function updateBucket(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.storage, 'config.storage');
-    assert.object(config.storage.local, 'config.storage.local');
-    assert.string(config.storage.local.baseDir, 'config.storage.local.baseDir');
-    assert.object(config.database, 'config.database');
-    assert.object(config.database, 'config.database');
-
-    if (config.database.type !== 'moray') {
-        info('migration not needed, databases type is not moray');
-        process.exit(0);
-    }
-
-    updateBucket(function (updateErr) {
-        if (updateErr) {
-            errexit(updateErr);
+    lib_config.loadConfig({}, function (confErr, config_) {
+        if (confErr) {
+            errexit(confErr);
             return;
         }
 
-        morayMigrate(function (err) {
-            if (err) {
-                errexit(err);
-            } else {
-                process.exit(0);
+        config = config_;
+        assert.string(config.databaseType, 'config.databaseType');
+
+        if (config.databaseType !== 'moray') {
+            info('migration not needed, databases type is not moray');
+            process.exit(0);
+        }
+
+        updateBucket(function (updateErr) {
+            if (updateErr) {
+                errexit(updateErr);
+                return;
             }
+
+            morayMigrate(function (err) {
+                if (err) {
+                    errexit(err);
+                } else {
+                    process.exit(0);
+                }
+            });
         });
     });
 }
diff --git a/lib/migrations/migration-011-backfill-published_at.js b/lib/migrations/migration-011-backfill-published_at.js
index 799a017..d849349 100644
--- a/lib/migrations/migration-011-backfill-published_at.js
+++ b/lib/migrations/migration-011-backfill-published_at.js
@@ -6,14 +6,13 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
  * IMGAPI db migration: TODO: describe
  */
 
-var p = console.log;
 var fs = require('fs');
 var path = require('path');
 var moray = require('moray');
@@ -27,27 +26,14 @@ var execFile = require('child_process').execFile;
 var mkdirp = require('mkdirp');
 var rimraf = require('rimraf');
 
+var lib_config = require('../config');
+
 
 //---- globals
 
 var NAME = path.basename(__filename);
 
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
+var config;
 var morayClient = null;  // set in `getMorayClient()`
 
 var BUCKET = {
@@ -184,7 +170,7 @@ function migrateImage(uuid, callback) {
 }
 
 function morayMigrate(callback) {
-    assert.equal(config.database.type, 'moray');
+    assert.equal(config.databaseType, 'moray');
     morayListImages(function (err2) {
         if (err2) {
             return callback(err2);
@@ -219,29 +205,33 @@ function updateBucket(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.storage, 'config.storage');
-    assert.object(config.storage.local, 'config.storage.local');
-    assert.string(config.storage.local.baseDir, 'config.storage.local.baseDir');
-    assert.object(config.database, 'config.database');
-    assert.object(config.database, 'config.database');
-
-    if (config.database.type !== 'moray') {
-        info('migration not needed, databases type is not moray');
-        process.exit(0);
-    }
-
-    updateBucket(function (updateErr) {
-        if (updateErr) {
-            errexit(updateErr);
+    lib_config.loadConfig({}, function (confErr, config_) {
+        if (confErr) {
+            errexit(confErr);
             return;
         }
 
-        morayMigrate(function (err) {
-            if (err) {
-                errexit(err);
-            } else {
-                process.exit(0);
+        config = config_;
+        assert.string(config.databaseType, 'config.databaseType');
+
+        if (config.databaseType !== 'moray') {
+            info('migration not needed, databases type is not moray');
+            process.exit(0);
+        }
+
+        updateBucket(function (updateErr) {
+            if (updateErr) {
+                errexit(updateErr);
+                return;
             }
+
+            morayMigrate(function (err) {
+                if (err) {
+                    errexit(err);
+                } else {
+                    process.exit(0);
+                }
+            });
         });
     });
 }
diff --git a/lib/migrations/migration-012-update-docker-image-uuids.js b/lib/migrations/migration-012-update-docker-image-uuids.js
index c7710bc..327e914 100644
--- a/lib/migrations/migration-012-update-docker-image-uuids.js
+++ b/lib/migrations/migration-012-update-docker-image-uuids.js
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -41,6 +41,8 @@ var imgmanifest = require('imgmanifest');
 var drc = require('docker-registry-client');
 var vasync = require('vasync');
 
+var lib_config = require('../config');
+var constants = require('../constants');
 var errors = require('../errors');
 var utils = require('../utils');
 
@@ -49,22 +51,7 @@ var utils = require('../utils');
 
 var NAME = path.basename(__filename);
 
-var CONFIG_PATH;
-if (fs.existsSync('/opt/smartdc/imgapi')) {
-    CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-} else if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-} else {
-    CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc',
-        'imgapi.config.json');
-}
-var IMGAPI_URL = 'http://127.0.0.1';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    IMGAPI_URL = 'https://127.0.0.1';
-}
-var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
+var config;
 var morayClient = null;  // set in `getMorayClient()`
 
 
@@ -413,31 +400,31 @@ function morayMigrate(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.storage, 'config.storage');
-    assert.object(config.storage.local, 'config.storage.local');
-    assert.string(config.storage.local.baseDir, 'config.storage.local.baseDir');
-    assert.object(config.database, 'config.database');
-
-    if (config.database.type !== 'moray') {
-        errexit('migration not supported, database type is not moray');
-    }
+    lib_config.loadConfig({}, function (confErr, config_) {
+        if (confErr) {
+            errexit(confErr);
+            return;
+        }
 
-    var localCfg = config.storage.local;
-    assert.string(localCfg.baseDir, 'local.baseDir');
+        config = config_;
+        assert.string(config.databaseType, 'config.databaseType');
 
-    var baseDir = path.resolve(localCfg.baseDir);
-    localDir = path.join(baseDir, 'images');
+        if (config.databaseType !== 'moray') {
+            errexit('migration not supported, database type is not moray');
+        }
 
-    assert.ok(localDir !== '/',
-        'cannot have empty or root dir for local storage');
+        localDir = constants.STORAGE_LOCAL_IMAGES_DIR;
+        assert.ok(localDir !== '/',
+            'cannot have empty or root dir for local storage');
 
-    morayMigrate(function (err) {
-        if (err) {
-            errexit(err);
-        } else {
-            info('finished sucessfully');
-            process.exit(0);
-        }
+        morayMigrate(function (err) {
+            if (err) {
+                errexit(err);
+            } else {
+                info('finished sucessfully');
+                process.exit(0);
+            }
+        });
     });
 }
 
diff --git a/lib/storage.js b/lib/storage.js
index 902334e..09b17dd 100644
--- a/lib/storage.js
+++ b/lib/storage.js
@@ -26,6 +26,7 @@ var crypto = require('crypto');
 var MemoryStream = require('memorystream');
 var once = require('once');
 
+var constants = require('./constants');
 var errors = require('./errors');
 var utils = require('./utils');
 
@@ -37,7 +38,7 @@ var utils = require('./utils');
  *
  * @params options {Object} with:
  *      - log {Bunyan Logger}
- *      - config {Object} The relevant section from the IMGAPI config.
+ *      - config {Object} The full IMGAPI config.
  */
 function Storage(options) {
     this.type = null;
@@ -150,16 +151,12 @@ Storage.prototype._archivePathFromImageUuid = function (uuid) {};
 
 function LocalStorage(options) {
     assert.object(options.log, 'options.log');
-    assert.object(options.config, 'options.config');
-    var config = options.config;
-    assert.string(config.baseDir, 'options.config.baseDir');
 
     this.type = 'local';
     this.log = options.log.child({stor: this.type}, true);
 
-    this.baseDir = path.resolve(config.baseDir);
-    this.dir = path.join(this.baseDir, 'images');
-    this.archiveDir = path.join(this.baseDir, 'archive');
+    this.dir = constants.STORAGE_LOCAL_IMAGES_DIR;
+    this.archiveDir = constants.STORAGE_LOCAL_ARCHIVE_DIR;
 
     assert.ok(this.dir && this.dir !== '/',
         'cannot have empty or root dir for local storage');
@@ -469,29 +466,30 @@ LocalStorage.prototype.archiveImageManifest = function (manifest, callback) {
 function MantaStorage(options) {
     assert.object(options.log, 'options.log');
     assert.object(options.config, 'options.config');
-    var config = options.config;
-    assert.string(config.url, 'options.config.url');
-    assert.string(config.user, 'options.config.user');
-    assert.string(config.key, 'options.config.key');
-    assert.string(config.keyId, 'options.config.keyId');
-    assert.optionalBool(config.insecure, 'options.config.insecure');
-    assert.string(config.baseDir, 'options.config.baseDir');
+    var mantaConfig = options.config.manta;
+    assert.object(mantaConfig, 'options.config.manta');
+    assert.string(mantaConfig.url, 'options.config.manta.url');
+    assert.string(mantaConfig.user, 'options.config.manta.user');
+    assert.string(mantaConfig.key, 'options.config.manta.key');
+    assert.string(mantaConfig.keyId, 'options.config.manta.keyId');
+    assert.optionalBool(mantaConfig.insecure, 'options.config.manta.insecure');
+    assert.string(mantaConfig.rootDir, 'options.config.manta.rootDir');
 
     this.type = 'manta';
     this.log = options.log.child({stor: this.type}, true);
 
     // Manta variables
-    this.url = config.url;
-    this.user = config.user;
-    this.baseDir = config.baseDir;
-    this.dir = path.join(this.baseDir, 'images');
-    this.archiveDir = path.join(this.baseDir, 'archive');
-    var insecure = config.hasOwnProperty('insecure') ? config.insecure : false;
+    this.url = mantaConfig.url;
+    this.user = mantaConfig.user;
+    this.dir = path.join(mantaConfig.rootDir, 'images');
+    this.archiveDir = path.join(mantaConfig.rootDir, 'archive');
+    var insecure = mantaConfig.hasOwnProperty('insecure')
+        ? mantaConfig.insecure : false;
     this.client = manta.createClient({
         log: this.log,
         sign: {
-            key: config.key,
-            keyId: config.keyId,
+            key: mantaConfig.key,
+            keyId: mantaConfig.keyId,
             user: this.user
         },
         user: this.user,
diff --git a/main.js b/main.js
index 773b40c..af31a19 100644
--- a/main.js
+++ b/main.js
@@ -6,11 +6,11 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
- * Main entry-point for the Image API (IMGAPI) for SmartDataCenter (SDC).
+ * Main entry-point for the Image API (IMGAPI) for Triton.
  */
 
 var util = require('util');
@@ -21,10 +21,10 @@ var EffluentLogger = require('effluent-logger');
 var nopt = require('nopt');
 var restify = require('restify');
 var bunyan = require('bunyan');
-var async = require('async');
 var assert = require('assert-plus');
-var format = require('util').format;
+var vasync = require('vasync');
 
+var mod_config = require('./lib/config');
 var createApp = require('./lib/app').createApp;
 var objCopy = require('./lib/utils').objCopy;
 var images = require('./lib/images');
@@ -35,13 +35,8 @@ var images = require('./lib/images');
 
 var NAME = 'imgapi';
 var VERSION = require('./package.json').version;
-var DEFAULT_CFG = path.resolve(__dirname, 'etc', NAME + '.config.json');
 
-var theConfig;
-var theApp;
 var log;
-var serviceUnavailable = false;
-var serviceUnavailableDetails = [];
 
 
 
@@ -70,109 +65,6 @@ function printHelp() {
     util.puts('                 Specify config file to load.');
 }
 
-
-/**
- * Load config.
- *
- * This loads factory settings (etc/defaults.json) and any given `configPath`.
- * Note that this is synchronous.
- *
- * @param configPath {String} Optional. Path to JSON config file to load.
- */
-function loadConfigSync(configPath) {
-    var defaultsPath = path.resolve(__dirname, 'etc', 'defaults.json');
-    log.info('Loading default config from "%s".', defaultsPath);
-    var config = JSON.parse(fs.readFileSync(defaultsPath, 'utf-8'));
-
-    if (configPath) {
-        if (! fs.existsSync(configPath)) {
-            usage(1, 'Config file not found: "' + configPath +
-              '" does not exist. Aborting.');
-        }
-        log.info('Loading additional config from "%s".', configPath);
-        var extraConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
-        for (var name in extraConfig) {
-            config[name] = extraConfig[name];
-        }
-    } else {
-        config.configPath = null;
-    }
-
-    // Validation and defaults.
-    assert.number(config.port, 'config.port');
-    if (config.mode === undefined) {
-        config.mode = 'public';
-    }
-    assert.string(config.mode, 'config.mode');
-    assert.optionalNumber(config.placeholderImageLifespanDays,
-        'config.placeholderImageLifespanDays');
-    assert.optionalString(config.serverName, 'config.serverName');
-    assert.ok(['public', 'private', 'dc'].indexOf(config.mode) !== -1,
-        'invalid config.mode');
-    if (config.mode === 'dc') {
-        // Temporary while migrations get un on all DCs
-        assert.object(config.ufds, 'config.ufds');
-        assert.string(config.ufds.url, 'config.ufds.url');
-        assert.string(config.ufds.bindDN, 'config.ufds.bindDN');
-        assert.string(config.ufds.bindPassword, 'config.ufds.bindPassword');
-        // New database
-        assert.object(config.moray, 'config.moray');
-        assert.string(config.moray.host, 'config.moray.host');
-        assert.number(config.moray.port, 'config.moray.port');
-    }
-    assert.object(config.storage, 'config.storage');
-    if (config.storage.manta) {
-        var manta = config.storage.manta;
-        assert.string(manta.url, 'config.storage.manta.url');
-        assert.string(manta.user, 'config.storage.manta.user');
-        assert.string(manta.key, 'config.storage.manta.key');
-        assert.string(manta.keyId, 'config.storage.manta.keyId');
-        assert.optionalString(manta.baseDir, 'config.storage.manta.baseDir');
-        manta.baseDir = manta.baseDir || 'imgapi';
-
-        // If using Manta in dc mode, datacenterName is required in order to
-        // follow a consistent images storage structure. baseDir is what comes
-        // after /stor/$username, so if baseDir is 'images' or '/images' then
-        // the new MantaStore baseDir will be
-        //      /$username/stor/imgapi/$dcname for dc config mode and
-        //      /$username/stor/imgapi         for public/private config mode
-        var rootDir = format('/%s/stor/', manta.user);
-        if (config.mode === 'dc') {
-            assert.string(config.datacenterName, 'config.datacenterName');
-            manta.baseDir = path.join(rootDir, manta.baseDir,
-                config.datacenterName);
-        } else {
-            manta.baseDir = path.join(rootDir, manta.baseDir);
-        }
-    }
-    if (config.storage.dcls) {
-        var dcls = config.storage.dcls;
-        assert.string(dcls.dir, 'config.storage.dcls.dir');
-    }
-    if (config.storage.local) {
-        var local = config.storage.local;
-        assert.string(local.baseDir, 'config.storage.local.baseDir');
-    }
-    assert.object(config.database, 'config.database');
-    if (!config.database.type) {
-        config.database.type = 'ufds';
-    }
-    assert.notEqual(['ufds', 'local', 'moray'].
-        indexOf(config.database.type), -1,
-        'config.database.type not "ufds" or "local"');
-    if (config.database.type === 'local') {
-        assert.string(config.database.dir, 'config.database.dir');
-    }
-    if (config.wfapi) {
-        assert.object(config.wfapi, 'config.wfapi');
-        assert.string(config.wfapi.url, 'config.wfapi.url');
-        assert.arrayOfString(config.wfapi.workflows, 'config.wfapi.workflows');
-    }
-
-    return config;
-}
-
-
 function handleArgv() {
     var longOpts = {
         'help': Boolean,
@@ -193,9 +85,6 @@ function handleArgv() {
         util.puts('IMGAPI ' + VERSION);
         process.exit(0);
     }
-    if (! opts.file) {
-        opts.file = DEFAULT_CFG;
-    }
     var logSrc = false,
         logLevel = 'info';
     if (opts.debug) {
@@ -247,32 +136,87 @@ function addFluentdHost(log_, host) {
 //---- mainline
 
 function main() {
+    var app;
+    var config;
     var opts = handleArgv();
-    theConfig = loadConfigSync(opts.file);
-    if (!opts.debug && theConfig.logLevel) {
-        log.level(theConfig.logLevel);
-        if (log.level() <= bunyan.TRACE) {
-          log.src = true;
-        }
-    }
-
-    // EXPERIMENTAL
-    if (theConfig.fluentd_host) {
-        addFluentdHost(log, theConfig.fluentd_host);
-    }
 
-    // Log config (but don't put passwords in the log file).
-    var censorKeys = {'password': '***', 'authToken': '***', 'pass': '***'};
-    function censor(key, value) {
-        var censored = censorKeys[key];
-        return (censored === undefined ? value : censored);
-    }
-    log.info('config: %s', JSON.stringify(theConfig, censor, 2));
+    vasync.pipeline({funcs: [
+        function getConfig(_, next) {
+            var loadOpts = {log: log, path: opts.file};
+            mod_config.loadConfig(loadOpts, function (err, config_) {
+                config = config_;
+                next(err);
+            });
+        },
+
+        function setupWithConfig(_, next) {
+            if (!opts.debug && config.logLevel) {
+                log.level(config.logLevel);
+                if (log.level() <= bunyan.TRACE) {
+                    log.src = true;
+                }
+            }
+
+            // EXPERIMENTAL
+            if (config.fluentd_host) {
+                addFluentdHost(log, config.fluentd_host);
+            }
+
+            // Log config (but don't put passwords in the log file).
+            var censorKeys = {
+                'password': '***',
+                'authToken': '***',
+                'pass': '***'
+            };
+            function censor(key, value) {
+                var censored = censorKeys[key];
+                return (censored === undefined ? value : censored);
+            }
+            log.info({config: JSON.stringify(config, censor, 2)},
+                'loaded config');
+            next();
+        },
+
+        function createAndStartTheApp(_, next) {
+            createApp(config, log, function (err, app_) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                app = app_;
+                app.setupPlaceholderCleanupInterval();
+                app.setupRemoteArchiveInterval();
+                app.listen(function () {
+                    var addr = app.server.address();
+                    log.info('Image API listening on <http://%s:%s>.',
+                        addr.address, addr.port);
+                    next();
+                });
+            });
+        },
+
+        function setupSignalHandlers(_, next) {
+            // Try to ensure we clean up properly on exit.
+            function closeApp(callback) {
+                if (app) {
+                    log.info('Closing app.');
+                    app.close(callback);
+                } else {
+                    log.debug('No app to close.');
+                    callback();
+                }
+            }
+
+            process.on('SIGINT', function () {
+                log.debug('SIGINT. Cleaning up.');
+                closeApp(function () {
+                    process.exit(1);
+                });
+            });
+            next();
+        }
 
-    async.series([
-        createAndStartTheApp,   // sets `theApp` global
-        setupSignalHandlers
-    ], function (err) {
+    ]}, function (err) {
         if (err) {
             log.error(err, 'error starting up');
             process.exit(2);
@@ -281,41 +225,4 @@ function main() {
     });
 }
 
-function createAndStartTheApp(next) {
-    createApp(theConfig, log, function (err, app) {
-        if (err)
-            return next(err);
-        theApp = app;  // `theApp` is intentionally global
-        theApp.setupPlaceholderCleanupInterval();
-        theApp.setupRemoteArchiveInterval();
-        theApp.listen(function () {
-            var addr = theApp.server.address();
-            log.info('Image API listening on <http://%s:%s>.',
-                addr.address, addr.port);
-            next();
-        });
-    });
-}
-
-function setupSignalHandlers(next) {
-    // Try to ensure we clean up properly on exit.
-    function closeApp(callback) {
-        if (theApp) {
-            log.info('Closing app.');
-            theApp.close(callback);
-        } else {
-            log.debug('No app to close.');
-            callback();
-        }
-    }
-    process.on('SIGINT', function () {
-        log.debug('SIGINT. Cleaning up.');
-        closeApp(function () {
-            process.exit(1);
-        });
-    });
-    next();
-}
-
-
 main();
diff --git a/package.json b/package.json
index 7d5d5e5..f9787f2 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "imgapi",
   "description": "Image API to manage images for SDC 7",
-  "version": "2.3.0",
+  "version": "3.0.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -14,10 +14,16 @@
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "expiring-lru-cache": "2.1.0",
     "extsprintf": "1.2.0",
+    "forkexec": "1.1.0",
+    "glob": "7.0.5",
+    "handlebars": "4.0.5",
     "imgmanifest": "git+ssh://git@github.com:joyent/node-imgmanifest.git#91e5d80",
+    "json": "9.0.4",
     "ldapjs": "git+ssh://git@github.com:mcavage/node-ldapjs.git#3edf9de5786170b22581ddc87386b78e9dd5bb6a",
-    "libuuid": "0.1.2",
-    "manta": "git+ssh://git@github.com:joyent/node-manta.git#56e8761",
+    "uuid": "2.0.2",
+    "manta": "2.0.7",
+    "manta-dir-watcher": "1.1.0",
+    "manta-sync": "0.3.4",
     "memorystream": "0.2.0",
     "mkdirp": "0.3.5",
     "moray": "git+ssh://git@github.com:joyent/node-moray.git#b84ef0e",
@@ -28,21 +34,21 @@
     "progbar": "git+ssh://git@github.com:trentm/node-progbar.git#a4c56e6",
     "restify": "git://github.com/joyent/node-restify.git#fd5d5b5",
     "rimraf": "2.2.6",
-    "sdc-clients": "9.3.0",
+    "sdc-clients": "9.5.0",
     "semver": "3.0.1",
+    "sshpk": "1.10.0",
     "trace-event": "1.2.0",
     "ufds": "git+ssh://git@github.com:joyent/node-ufds.git#a7c674b76696fe7ab0fff1e2486f20d3af6a0d1a",
     "vasync": "1.6.3",
     "verror": "1.6.0",
-    "wf-client": "git+ssh://git@github.com:joyent/sdc-wf-client.git#9bcb3a0ebec7cd5b4052acaacde8fd6e3e2dfcf9"
+    "wf-client": "git+ssh://git@github.com:joyent/sdc-wf-client.git#adb8803"
   },
   "optionalDependencies": {
-    "http-signature": "0.10.0",
-    "bcrypt": "0.7.6"
+    "http-signature": "0.10.0"
   },
   "devDependencies": {
     "jshint": "2.1",
-    "nodeunit": "0.8.1"
+    "nodeunit": "0.10.2"
   },
   "scripts": {
     "test": "make test"
diff --git a/sapi_manifests/imgapi/manifest.json b/sapi_manifests/imgapi/manifest.json
index 871c182..3c27eb3 100644
--- a/sapi_manifests/imgapi/manifest.json
+++ b/sapi_manifests/imgapi/manifest.json
@@ -1,5 +1,5 @@
 {
     "name": "imgapi",
-    "path": "/opt/smartdc/imgapi/etc/imgapi.config.json",
+    "path": "/data/imgapi/etc/imgapi.config.json",
     "post_cmd": "/usr/sbin/svcadm refresh imgapi"
 }
diff --git a/sapi_manifests/imgapi/template b/sapi_manifests/imgapi/template
index e388590..d720b38 100644
--- a/sapi_manifests/imgapi/template
+++ b/sapi_manifests/imgapi/template
@@ -1,5 +1,6 @@
 {
     "port": 80,
+    "address": "0.0.0.0",
     "logLevel": "info",
     "mode": "dc",
     "datacenterName": "{{{datacenter_name}}}",
@@ -24,30 +25,25 @@
             "minTimeout": 500
         }
     },
-    "database": {
-        "type": "moray"
+    "authType": "none",
+    "databaseType": "moray",
+{{#IMGAPI_MANTA_URL}}
+    "manta": {
+        "url": "{{IMGAPI_MANTA_URL}}",
+        "user": "{{IMGAPI_MANTA_USER}}",
+        "key": "/root/.ssh/imgapi.id_rsa",
+        "keyId": "{{IMGAPI_KEY_ID}}",
+        "insecure": {{IMGAPI_MANTA_INSECURE}},
+        "remote": {{IMGAPI_MANTA_REMOTE}},
+        "baseDir": "{{{STORAGE_MANTA_BASEDIR}}}"
     },
-    "storage": {
+{{/IMGAPI_MANTA_URL}}
+    "storageTypes": [
 {{#IMGAPI_MANTA_URL}}
-        "manta": {
-            "url": "{{IMGAPI_MANTA_URL}}",
-            "user": "{{IMGAPI_MANTA_USER}}",
-            "key": "/root/.ssh/imgapi.id_rsa",
-            "keyId": "{{IMGAPI_KEY_ID}}",
-            "insecure": {{IMGAPI_MANTA_INSECURE}},
-            "remote": {{IMGAPI_MANTA_REMOTE}},
-            "baseDir": "{{{STORAGE_MANTA_BASEDIR}}}"
-        },
+        "manta",
 {{/IMGAPI_MANTA_URL}}
-        "local": {
-{{#STORAGE_LOCAL_BASEDIR}}
-            "baseDir": "{{{STORAGE_LOCAL_BASEDIR}}}"
-{{/STORAGE_LOCAL_BASEDIR}}
-{{^STORAGE_LOCAL_BASEDIR}}
-            "baseDir": "/data/imgapi"
-{{/STORAGE_LOCAL_BASEDIR}}
-        }
-    },
+        "local"
+    ],
     "wfapi": {
         "forceMd5Check": true,
         "workflows": ["create-from-vm", "import-remote-image"],
diff --git a/smf/manifests/haproxy.xml.in b/smf/manifests/haproxy-standalone.xml
similarity index 63%
rename from smf/manifests/haproxy.xml.in
rename to smf/manifests/haproxy-standalone.xml
index d699432..e3780c7 100644
--- a/smf/manifests/haproxy.xml.in
+++ b/smf/manifests/haproxy-standalone.xml
@@ -1,18 +1,8 @@
 <?xml version='1.0'?>
 <!DOCTYPE service_bundle SYSTEM '/usr/share/lib/xml/dtd/service_bundle.dtd.1'>
-<!--
-    This Source Code Form is subject to the terms of the Mozilla Public
-    License, v. 2.0. If a copy of the MPL was not distributed with this
-    file, You can obtain one at http://mozilla.org/MPL/2.0/.
--->
-
-<!--
-    Copyright (c) 2014, Joyent, Inc.
--->
-
 <service_bundle type='manifest' name='export'>
-  <service name='pkgsrc/haproxy' type='service' version='0'>
-    <create_default_instance enabled='false'/>
+  <service name='site/haproxy' type='service' version='0'>
+    <create_default_instance enabled='true'/>
     <single_instance/>
     <dependency name='network' grouping='require_all' restart_on='error' type='service'>
       <service_fmri value='svc:/milestone/network:default'/>
@@ -20,14 +10,14 @@
     <dependency name='filesystem' grouping='require_all' restart_on='error' type='service'>
       <service_fmri value='svc:/system/filesystem/local'/>
     </dependency>
-    <exec_method name='start' type='method' exec='@@PREFIX@@/haproxy-1.4.21/haproxy -f %{config_file} -D' timeout_seconds='60'/>
+    <exec_method name='start' type='method' exec='/opt/local/sbin/haproxy -f %{config_file} -D' timeout_seconds='60'/>
     <exec_method name='stop' type='method' exec=':kill' timeout_seconds='60'/>
     <property_group name='startd' type='framework'>
       <propval name='duration' type='astring' value='contract'/>
       <propval name='ignore_error' type='astring' value='core,signal'/>
     </property_group>
     <property_group name='application' type='application'>
-      <propval name='config_file' type='astring' value='@@PREFIX@@/etc/haproxy.cfg'/>
+      <propval name='config_file' type='astring' value='/opt/smartdc/imgapi/etc/standalone/haproxy.cfg'/>
     </property_group>
     <stability value='Evolving'/>
     <template>
@@ -36,4 +26,4 @@
       </common_name>
     </template>
   </service>
-</service_bundle>
\ No newline at end of file
+</service_bundle>
diff --git a/smf/manifests/imgapi.xml.in b/smf/manifests/imgapi.xml
similarity index 87%
rename from smf/manifests/imgapi.xml.in
rename to smf/manifests/imgapi.xml
index 84a833f..7452e98 100644
--- a/smf/manifests/imgapi.xml.in
+++ b/smf/manifests/imgapi.xml
@@ -7,7 +7,7 @@
 -->
 
 <!--
-    Copyright (c) 2014, Joyent, Inc.
+    Copyright 2016 Joyent, Inc.
 -->
 
 <service_bundle type="manifest" name="imgapi">
@@ -23,7 +23,7 @@
     </dependency>
 
     <exec_method type="method" name="start"
-        exec="@@NODE@@ --abort-on-uncaught-exception @@PREFIX@@/main.js &amp;" timeout_seconds="30">
+        exec="/opt/smartdc/imgapi/build/node/bin/node --abort-on-uncaught-exception /opt/smartdc/imgapi/main.js &amp;" timeout_seconds="30">
       <method_context working_directory="/opt/smartdc/imgapi">
         <method_credential user="nobody" group="nobody" privileges="basic,net_privaddr"/>
         <method_environment>
@@ -41,7 +41,7 @@
     <stability value="Unstable" />
     <template>
       <common_name>
-        <loctext xml:lang="C">SDC Image API</loctext>
+        <loctext xml:lang="C">Triton Image API</loctext>
       </common_name>
     </template>
 
diff --git a/smf/manifests/stud-standalone.xml b/smf/manifests/stud-standalone.xml
new file mode 100644
index 0000000..5eeb9b4
--- /dev/null
+++ b/smf/manifests/stud-standalone.xml
@@ -0,0 +1,29 @@
+<?xml version='1.0'?>
+<!DOCTYPE service_bundle SYSTEM '/usr/share/lib/xml/dtd/service_bundle.dtd.1'>
+<service_bundle type='manifest' name='export'>
+  <service name='site/stud' type='service' version='0'>
+    <create_default_instance enabled='true'/>
+    <single_instance/>
+    <dependency name='network' grouping='require_all' restart_on='error' type='service'>
+      <service_fmri value='svc:/milestone/network:default'/>
+    </dependency>
+    <dependency name='filesystem' grouping='require_all' restart_on='error' type='service'>
+      <service_fmri value='svc:/system/filesystem/local'/>
+    </dependency>
+    <exec_method name='start' type='method' exec='/opt/local/bin/stud --config=%{config_file}' timeout_seconds='60'/>
+    <exec_method name='stop' type='method' exec=':kill' timeout_seconds='60'/>
+    <property_group name='startd' type='framework'>
+      <propval name='duration' type='astring' value='contract'/>
+      <propval name='ignore_error' type='astring' value='core,signal'/>
+    </property_group>
+    <property_group name='application' type='application'>
+      <propval name='config_file' type='astring' value='/opt/smartdc/imgapi/etc/standalone/stud.conf'/>
+    </property_group>
+    <stability value='Evolving'/>
+    <template>
+      <common_name>
+        <loctext xml:lang='C'>stud daemon</loctext>
+      </common_name>
+    </template>
+  </service>
+</service_bundle>
diff --git a/test/access.public-test.js b/test/access.public-test.js
index d19cca0..c470e0f 100644
--- a/test/access.public-test.js
+++ b/test/access.public-test.js
@@ -37,10 +37,7 @@ before(function (next) {
         url: process.env.IMGAPI_URL,
         agent: false
     };
-    if (process.env.IMGAPI_PASSWORD) {
-        options.user = process.env.IMGAPI_USER;
-        options.password = process.env.IMGAPI_PASSWORD;
-    } else if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
+    if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
         assert.ok(process.env.JOYENT_IMGADM_USER,
             'JOYENT_IMGADM_USER envvar is not set');
         assert.ok(process.env.JOYENT_IMGADM_IDENTITY,
diff --git a/test/admincreateimagefromvm.dc-test.js b/test/admincreateimagefromvm.dc-test.js
index 06ccb24..86e165f 100644
--- a/test/admincreateimagefromvm.dc-test.js
+++ b/test/admincreateimagefromvm.dc-test.js
@@ -21,7 +21,7 @@ var dns = require('dns');
 var https = require('https');
 var async = require('async');
 var restify = require('restify');
-var genUuid = require('libuuid');
+var lib_uuid = require('uuid');
 
 var IMGAPI = require('sdc-clients').IMGAPI;
 var DSAPI = require('sdc-clients/lib/dsapi');
@@ -65,7 +65,7 @@ if (!CAN_RUN_TEST) {
 }
 
 function createManifest() {
-    var uuid = genUuid.create();
+    var uuid = lib_uuid.v4();
     return {
         name: 'custom-image-' + uuid,
         version: '1.0.0',
@@ -158,7 +158,7 @@ before(function (next) {
         },
         function createVm(cb) {
             var payload = {
-                alias: 'imgapi-test-' + genUuid.create(),
+                alias: 'imgapi-test-' + lib_uuid.v4(),
                 owner_uuid: process.env.UFDS_ADMIN_UUID,
                 image_uuid: TEST_IMAGE_UUID,
                 networks: NETWORK,
@@ -195,7 +195,7 @@ before(function (next) {
 if (CAN_RUN_TEST)
 test('CreateImageFromVm should not work for an nonexistent VM', function (t) {
     this.client.createImageFromVmAndWait(createManifest(),
-        { vm_uuid: genUuid.create() },
+        { vm_uuid: lib_uuid.v4() },
       function (err, image) {
         t.ok(err, 'got an error as expected');
         t.end();
diff --git a/test/api-versions.public-test.js b/test/api-versions.public-test.js
index d1eb608..41c3e12 100644
--- a/test/api-versions.public-test.js
+++ b/test/api-versions.public-test.js
@@ -64,10 +64,7 @@ before(function (next) {
         url: process.env.IMGAPI_URL,
         agent: false
     };
-    if (process.env.IMGAPI_PASSWORD) {
-        opts.user = process.env.IMGAPI_USER;
-        opts.password = process.env.IMGAPI_PASSWORD;
-    } else if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
+    if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
         assert.fail('Do not run the channels tests against images.jo.');
     }
     this.clients = {
diff --git a/test/channels.public-test.js b/test/channels.public-test.js
index b33cfa2..3a899f3 100644
--- a/test/channels.public-test.js
+++ b/test/channels.public-test.js
@@ -68,10 +68,7 @@ before(function (next) {
         url: process.env.IMGAPI_URL,
         agent: false
     };
-    if (process.env.IMGAPI_PASSWORD) {
-        opts.user = process.env.IMGAPI_USER;
-        opts.password = process.env.IMGAPI_PASSWORD;
-    } else if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
+    if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
         assert.fail('Do not run the channels tests against images.jo.');
     } else {
         assert.fail('What no auth info!?');
diff --git a/test/imgapi-config-local-dc.json b/test/imgapi-config-local-dc.json
index 68829f4..411d717 100644
--- a/test/imgapi-config-local-dc.json
+++ b/test/imgapi-config-local-dc.json
@@ -2,13 +2,6 @@
     "port": 8081,
     "logLevel": "debug",
     "mode": "dc",
-    "database": {
-        "type": "local",
-        "dir": "/var/tmp/imgapi/db/manifests"
-    },
-    "storage": {
-        "local": {
-            "baseDir": "/var/tmp/imgapi/db/images"
-        }
-    }
+    "databaseType": "local",
+    "storageTypes": ["local"]
 }
diff --git a/test/imgapi-config-local-public.json b/test/imgapi-config-local-public.json
index da8c23f..baa7bae 100644
--- a/test/imgapi-config-local-public.json
+++ b/test/imgapi-config-local-public.json
@@ -2,25 +2,12 @@
     "port": 8081,
     "logLevel": "debug",
     "mode": "public",
-    "auth": {
-        "type": "basic",
-        "realm": "IMGAPI",
-        "users": {
-            "guest": "$2a$10$Mqn0lKFw2XI6GbUbI5S8vekyMgpcXe2yimmzoaEmIQeYycP.K9oEW"
-        }
-    },
+    "databaseType": "local",
+    "storageTypes": ["local"],
+    "authType": "none",
     "channels": [
         {"name": "dev", "description": "all development builds", "default": true},
         {"name": "staging", "description": "builds for testing in staging in prep for production release"},
         {"name": "release", "description": "release gold bits"}
-    ],
-    "database": {
-        "type": "local",
-        "dir": "/var/tmp/imgapi-test-public/manifests"
-    },
-    "storage": {
-        "local": {
-            "baseDir": "/var/tmp/imgapi-test-public"
-        }
-    }
+    ]
 }
diff --git a/test/ping.test.js b/test/ping.test.js
index a743880..504c366 100644
--- a/test/ping.test.js
+++ b/test/ping.test.js
@@ -33,10 +33,7 @@ before(function (next) {
         url: process.env.IMGAPI_URL,
         agent: false
     };
-    if (process.env.IMGAPI_PASSWORD) {
-        options.user = process.env.IMGAPI_USER;
-        options.password = process.env.IMGAPI_PASSWORD;
-    } else if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
+    if (process.env.IMGAPI_URL === 'https://images.joyent.com') {
         assert.ok(process.env.JOYENT_IMGADM_USER,
             'JOYENT_IMGADM_USER envvar is not set');
         assert.ok(process.env.JOYENT_IMGADM_IDENTITY,
diff --git a/test/reload-test-data.sh b/test/reload-test-data.sh
index 3e8480d..1b05051 100755
--- a/test/reload-test-data.sh
+++ b/test/reload-test-data.sh
@@ -78,12 +78,11 @@ $TOP/test/rm-test-data.sh $*
 if [[ -n "$opt_local" ]]; then
     # Hack in $manifestsDatabaseDir/$uuid.raw for each image
     # in MODE-test-images.json.
-    CFG_FILE=$TOP/test/imgapi-config-local-$opt_mode.json
-    manifest_dir=$(json database.dir <$CFG_FILE)
+    manifest_dir=/data/imgapi/manifests
     if [[ ! -d $manifest_dir ]]; then
         mkdir -p $manifest_dir
     fi
-    stor_dir=$(json storage.local.baseDir <$CFG_FILE)
+    stor_dir=$(node $TOP/lib/constants.js LOCAL_BASE_DIR)
     if [[ ! -d $stor_dir ]]; then
         mkdir -p $stor_dir
     fi
@@ -107,7 +106,7 @@ elif [[ "$opt_mode" == "dc" ]]; then
     $TOP/test/sdc-ldap modify -f $TOP/test/dc-test-users.ldif
 
     # Load image into moray with putobject
-    CFG_FILE=$TOP/etc/imgapi.config.json
+    CFG_FILE=/data/imgapi/etc/imgapi.config.json
     test_images=$TOP/test/dc-test-images.json
     num_test_images=$(json length <$test_images)
     i=0
diff --git a/test/rm-test-data.sh b/test/rm-test-data.sh
index 801a488..3735bc6 100755
--- a/test/rm-test-data.sh
+++ b/test/rm-test-data.sh
@@ -74,12 +74,10 @@ done
 
 
 if [[ -n "$opt_local" ]]; then
-    CFG_FILE=$TOP/test/imgapi-config-local-$opt_mode.json
-    rm -rf $(json database.dir <$CFG_FILE)
-    rm -rf $(json storage.local.dir <$CFG_FILE)
+    rm -rf /var/tmp/imgapitest-local-base-dir
 elif [[ "$opt_mode" == "dc" ]]; then
     # Load image into moray with putobject
-    CFG_FILE=$TOP/etc/imgapi.config.json
+    CFG_FILE=/data/imgapi/etc/imgapi.config.json
     uuids="c58161c0-2547-11e2-a75e-9fdca1940570"
     uuids+=" 47e6af92-daf0-11e0-ac11-473ca1173ab0"
     uuids+=" 1fc068b0-13b0-11e2-9f4e-2f3f6a96d9bc"
diff --git a/test/runtests b/test/runtests
index 937bffe..cbd2841 100755
--- a/test/runtests
+++ b/test/runtests
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright 2016 Joyent, Inc.
 #
 
 #
@@ -63,7 +63,7 @@ function usage () {
 
 function imgapi_is_running () {
     local imgapi_url=$1
-    local response=$(curl $CURL_IMGAPI_AUTH -iSs -H accept:application/json \
+    local response=$(curl -iSs -H accept:application/json \
         $imgapi_url/ping?caller=runtests)
     if [[ $(echo "$response" | json -qH ping) == "pong" ]]; then
         return 0
@@ -74,8 +74,8 @@ function imgapi_is_running () {
 
 function imgapi_stop () {
     local imgapi_url=$1
-    local pid=$(curl $CURL_IMGAPI_AUTH -iSs -H accept:application/json \
-        $imgapi_url/ping | json -H pid)
+    local pid=$(curl -iSs -H accept:application/json $imgapi_url/ping \
+        | json -H pid)
     kill $pid
 }
 
@@ -173,11 +173,12 @@ fi
 # Gather IMGAPI/datacenter data to be used by the test suite.
 if [[ "$opt_mode" == "dc" ]]; then
     if [[ -n "$opt_local" ]]; then
+        export IMGAPITEST_LOCAL_BASE_DIR=/var/tmp/imgapitest-local-base-dir
         CFG_FILE=$TOP/test/imgapi-config-local-dc.json
         export IMGAPI_URL=http://localhost:$(json port <$CFG_FILE)
     else
         export PATH=/opt/smartdc/bin:$PATH
-        CFG_FILE=$TOP/etc/imgapi.config.json
+        CFG_FILE=/data/imgapi/etc/imgapi.config.json
         [[ ! -f "$CFG_FILE" ]] && fatal "'$CFG_FILE' does not exist"
         export UFDS_URL=$(json ufds.url <$CFG_FILE)
         export UFDS_ROOT_DN=$(json ufds.bindDN <$CFG_FILE)
@@ -208,11 +209,9 @@ if [[ "$opt_mode" == "dc" ]]; then
 else
     # "public" mode
     if [[ -n "$opt_local" ]]; then
+        export IMGAPITEST_LOCAL_BASE_DIR=/var/tmp/imgapitest-local-base-dir
         CFG_FILE=$TOP/test/imgapi-config-local-public.json
         export IMGAPI_URL=http://localhost:$(json port <$CFG_FILE)
-        export IMGAPI_USER=guest
-        export IMGAPI_PASSWORD=guest
-        export CURL_IMGAPI_AUTH="-u $IMGAPI_USER:$IMGAPI_PASSWORD"
     else
         echo "runtests: error: use '-l' (local imgapi server) if using '-p'"
         exit 1
@@ -275,8 +274,7 @@ fi
 # Clear caches.
 if [[ -n $opt_local || "$opt_mode" != "public" ]]; then
     echo "# Drop IMGAPI caches."
-    curl $CURL_IMGAPI_AUTH -isS $IMGAPI_URL/state?action=dropcaches \
-        -X POST >/dev/null
+    curl -isS $IMGAPI_URL/state?action=dropcaches -X POST >/dev/null
 fi
 
 
diff --git a/test/sdc-ldap b/test/sdc-ldap
index 3a80d0b..bd20d6f 100755
--- a/test/sdc-ldap
+++ b/test/sdc-ldap
@@ -51,9 +51,9 @@ shift;
 
 
 # Determine connection and auth info.
-UFDS_URL=$(json ufds.url <$TOP/etc/imgapi.config.json)
-ufds_dn=$(json ufds.bindDN <$TOP/etc/imgapi.config.json)
-ufds_pw=$(json ufds.bindPassword <$TOP/etc/imgapi.config.json)
+UFDS_URL=$(json ufds.url </data/imgapi/etc/imgapi.config.json)
+ufds_dn=$(json ufds.bindDN </data/imgapi/etc/imgapi.config.json)
+ufds_pw=$(json ufds.bindPassword </data/imgapi/etc/imgapi.config.json)
 if [[ -z "$UFDS_URL" ]]; then
     echo "Unable to find UFDS URL." >&2
     exit 1
diff --git a/tools/beware-rsync-to-images b/tools/beware-rsync-to-images
deleted file mode 100755
index 70f5b6a..0000000
--- a/tools/beware-rsync-to-images
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-#
-# Rsync the master in this working copy to the *production* install on
-# images.joyent.com.
-#
-
-#set -x
-set -e
-TOP=$(cd $(dirname $0)/../; pwd)
-# Using Trent's "~/.ssh/config" entry.
-NODE=images
-
-rsync -av ${TOP}/ \
-    $NODE:/root/services/imgapi/ \
-    --exclude "*.node" \
-    --include "test/*.zfs.bz2" \
-    --exclude "*.zfs.bz2" \
-    --exclude .git/ \
-    --exclude etc/imgapi.config.json \
-    --exclude deps/ \
-    --exclude doc/ \
-    --exclude tools/ \
-    --exclude tmp/ \
-    --exclude build/
-
-state=$(ssh ${NODE} svcs -H -o state imgapi)
-if [[ "$state" == "maintenance" ]]; then
-    ssh ${NODE} svcadm clear imgapi
-else
-    ssh ${NODE} svcadm restart imgapi
-fi
diff --git a/tools/imgapi.config.local-signature-auth.json b/tools/imgapi.config.local-signature-auth.json
deleted file mode 100644
index fb84e44..0000000
--- a/tools/imgapi.config.local-signature-auth.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "port": 8080,
-    "logLevel": "debug",
-    "mode": "public",
-    "// auth": {
-        "type": "basic",
-        "realm": "IMGAPI",
-        "users": {
-            "guest": "$2a$10$Mqn0lKFw2XI6GbUbI5S8vekyMgpcXe2yimmzoaEmIQeYycP.K9oEW"
-        }
-    },
-    "auth": {
-        "type": "signature",
-        "keys": {
-            "automation": ["bogus key", "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA2s5twaK3yK3iEW1Ka1rCoE7pENen2ijsZpSCDTxeKL9gzXE/W5Hm7VEp2AY+POWE3sTVmLf+b+mc3+ABCq3UnZgMGgsfZuTmmzQYuWI3yH1m1m3PzOjxF4n+2jWwwZ9JAyuzxQFfch8WPzhoylHEbuIsLc8QKUkr+26VYEA4o3ztK3vwNQ6WqSIfl9zGEak2u6laSQH8AFwodZfamEXfgj4YfM23gDz382aJOVa5q6EnDK01/8yveOM9AxK52y4+40mpQJiBwUTRMtP1irB6sT/zXJCVBkwKAiZnYlb9jHEwU1sN2QOe9rh0LwxO3j0wQuy7FmAtFOqZQlDN5Bki7Q== automation@lab-www-00"],
-            "trentm": ["ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAn6QHOqxWJr9Ice+fsqGPiURLgEOSWPt7slo1JkfncBLTlEswk/QpI36zepystMfrYq5kHNdgml3IivPgGLzLX3faNGup5z9dhFxv0Q9sX7WpDhtQNBhd9JZHX9x5PEDHq+bHpHmtJ6zDNfTkeH7Z+3pd9szVKxsSrRB96I2tB5hF4QQo4uv5H1Ljbk7+2mBlzEHxBnW3SYHgppLiADIaMolosYSPG/iIqORx9PRhAPXvu1pvvp5CTiWwvepq/S9/2dX/9acYvOo/0Ub0PY7uG+Do8dA1Nea7i4qH9L+iFNdpE95SQMPlNBSXU20YpMvKdrIUpnk4ojHw2l24uq9Lfw== trent.mick@joyent.com (take 2)"]
-        }
-    },
-    "database": {
-        "type": "local",
-        "dir": "/var/tmp/imgapi/db/manifests"
-    },
-    "storage": {
-        "local": {
-            "dir": "/var/tmp/imgapi/db/images"
-        }
-    }
-}
diff --git a/tools/migrate-storage-local-to-manta.js b/tools/migrate-storage-local-to-manta.js
index 1c370de..a6106ff 100644
--- a/tools/migrate-storage-local-to-manta.js
+++ b/tools/migrate-storage-local-to-manta.js
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /**
@@ -26,26 +26,22 @@ var p = console.log;
 var fs = require('fs');
 var path = require('path');
 var ldap = require('ldapjs');
-var errors = require('../errors');
 var assert = require('assert-plus');
 var async = require('async');
 var passwd = require('passwd');
 
+var constants = require('../lib/constants');
+var errors = require('../lib/errors');
 
 
 //---- globals
 
 var NAME = path.basename(__filename);
 
-var CONFIG_PATH = '/opt/smartdc/imgapi/etc/imgapi.config.json';
-if (fs.existsSync('/root/THIS-IS-IMAGES.JOYENT.COM.txt') ||
-    fs.existsSync('/root/THIS-IS-UPDATES.JOYENT.COM.txt')) {
-    CONFIG_PATH = '/root/config/imgapi.config.json';
-}
+var CONFIG_PATH = '/data/imgapi/etc/imgapi.config.json';
 var config = JSON.parse(fs.readFileSync(CONFIG_PATH));
 
 
-
 //---- support functions
 
 function errexit(err) {
@@ -89,7 +85,7 @@ function migrateImage(image, callback) {
     info('migrate "%s"', uuid);
     file.stor = 'manta';
 
-    var dbPath = path.resolve(config.database.dir, uuid + '.raw');
+    var dbPath = path.resolve(constants.DATABASE_LOCAL_DIR, uuid + '.raw');
     var content = JSON.stringify(image, null, 2);
     fs.writeFile(dbPath, content, 'utf8', function (err) {
         if (err)
@@ -110,14 +106,14 @@ function migrateImage(image, callback) {
 function localListImages(callback) {
     /*JSSTYLED*/
     var RAW_FILE_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.raw$/;
-    fs.readdir(config.database.dir, function (err, files) {
+    fs.readdir(constants.DATABASE_LOCAL_DIR, function (err, files) {
         var images = [];
         async.forEachSeries(
             files,
             function oneFile(file, next) {
                 if (!RAW_FILE_RE.test(file))
                     return next();
-                var path_ = path.resolve(config.database.dir, file);
+                var path_ = path.resolve(constants.DATABASE_LOCAL_DIR, file);
                 fs.readFile(path_, 'utf8', function (readErr, content) {
                     if (readErr)
                         return next(readErr);
@@ -138,7 +134,7 @@ function localListImages(callback) {
 
 
 function localMigrate(callback) {
-    assert.equal(config.database.type, 'local');
+    assert.equal(config.databaseType, 'local');
     localListImages(function (err, images) {
         if (err)
             return callback(err);
@@ -151,8 +147,8 @@ function localMigrate(callback) {
 //---- mainline
 
 function main(argv) {
-    assert.object(config.database, 'config.database');
-    if (config.database.type === 'local') {
+    assert.object(config.databaseType, 'config.databaseType');
+    if (config.databaseType === 'local') {
         localMigrate(function (err) {
             if (err) {
                 errexit(err);
diff --git a/tools/standalone/README.md b/tools/standalone/README.md
new file mode 100644
index 0000000..fe36b3c
--- /dev/null
+++ b/tools/standalone/README.md
@@ -0,0 +1,2 @@
+Tooling for running a standalone IMGAPI instance (e.g. images.joyent.com
+and updates.joyent.com are examples). See notes in "docs/operator-guide.md".
diff --git a/tools/standalone/tritonlogupload.sh b/tools/standalone/tritonlogupload.sh
new file mode 100755
index 0000000..39e4e11
--- /dev/null
+++ b/tools/standalone/tritonlogupload.sh
@@ -0,0 +1,183 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+#
+# Upload Triton log files in /var/log/triton/upload/ to Manta.
+#
+# Typically "setup.sh" sets cron to run this script run after logadm does its
+# rotations. For example, the following make *5* upload attempts with 60s gaps.
+# This is to allow log rotation to complete.
+#
+#       0 * * * * /usr/sbin/logadm -v >>/var/log/logadm.log 2>&1
+#       1 * * * * /.../tritonlogupload.sh -a 5 >>/var/log/tritonlogupload.log 2>&1
+#
+# Currently this is hardcoded for standalone IMGAPI usage, getting
+# manta config info from $CONFIG. TODO: generalize this.
+#
+# Based on https://github.com/joyent/manta-scripts/blob/master/backup.sh
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+export PATH=/opt/local/bin:/opt/smartdc/imgapi/build/node/bin:/opt/smartdc/imgapi/node_modules/.bin:$PATH
+
+SRCDIR=/var/log/triton/upload
+CONFIG=/data/imgapi/etc/imgapi.config.json
+DATE=/opt/local/bin/date
+LOGUPLOAD_STATUS=/data/imgapi/run/logupload.status
+
+
+#---- support functions
+
+function fatal
+{
+    echo "$0: error: $*" >&2
+    exit 1
+}
+
+function onexit
+{
+    mkdir -p $(dirname $LOGUPLOAD_STATUS)
+    echo "$1" > $LOGUPLOAD_STATUS
+
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+function usage () {
+    echo 'Upload Triton log files in /var/log/triton/upload to Manta.'
+    echo ''
+    echo 'Requirements:'
+    echo '1. The log files are expected to be of the form:'
+    echo '       $logname_$nodename_YYYYMMDDTHH0000.log'
+    echo '2. The '$logname' cannot contain an underscore.'
+    echo ''
+    echo 'The files are uploaded to:'
+    echo '    /$account/stor/$baseDir/logs/$logname/YYYY/MM/DD/HH/$nodename.log'
+    echo 'where the hour dir is an hour *previous*.'
+    echo ''
+    echo 'Usage:'
+    echo '    tritonlogupload.sh [-h]'
+    echo ''
+    echo 'Options:'
+    echo '     -h       Print this help and exit.'
+    echo '     -n       Dry-run.'
+    echo '     -a N     Number of attempts (with 60s gap between attempts).'
+    echo '              Multiple attempts can be useful to run this once but'
+    echo '              give time to logadm to finish rotating logs.'
+}
+
+function upload_files() {
+    local dryrun
+    dryrun=$1
+
+    # Looking for $logname_$nodename_YYYYMMDDTHHMMSS.log files.
+    files=$(ls -1 $SRCDIR/ | (egrep '.*_.*_........T......\.log' || true))
+    if [[ -z "$files" ]]; then
+        echo "no files to upload"
+        return
+    fi
+
+    nfiles=$(echo "$files" | wc -l)
+    echo "upload $nfiles file(s) from $SRCDIR to $dstMdir"
+    for f in $files
+    do
+        base=$(basename $f)
+        logname=$(echo $base | cut -d _ -f 1)
+        # Assume no '_' in nodename for now.
+        nodename=$(echo $base | cut -d _ -f 2)
+        datestr=$(echo $base | awk '{ FS="_"; print $NF }' | cut -d. -f1)
+        isotime=$(echo $datestr | strptime -i '%Y%m%dT%H%M%S' -f '%Y-%m-%dT%H:%M:%S')
+        # Note: GZ /usr/bin/date doesn't support -d.
+        hourdir=$($DATE -d \@$(( $($DATE -d $isotime "+%s") - 3600 )) "+%Y/%m/%d/%H")
+        targ="$dstMdir/$logname/$hourdir/$nodename.log"
+
+        upload_text_file $SRCDIR/$f $targ $dryrun
+        echo "rm $SRCDIR/$f"
+        if [[ $dryrun == "no" ]]; then
+            rm $SRCDIR/$f
+        fi
+    done
+}
+
+function upload_text_file() {
+    local src dst dryrun
+    src=$1
+    dst=$2
+    dryrun=$3
+    echo "upload $src to $dst"
+    if [[ $dryrun == "no" ]]; then
+        mput -q -p -H "Content-Type: text/plain" -f $src $dst
+    fi
+}
+
+
+#---- mainline
+
+# Options.
+opt_dryrun=no
+opt_numattempts=1
+while getopts "hna:" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        n)
+            opt_dryrun=yes
+            ;;
+        a)
+            opt_numattempts=$OPTARG
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+
+trap 'onexit $?' EXIT
+
+# Get manta info from config
+config="$(node /opt/smartdc/imgapi/lib/config.js)"
+export MANTA_URL=$(echo "$config" | json manta.url)
+[[ -n "$MANTA_URL" ]] || fatal "not configured to use Manta: no 'manta.url' in config"
+export MANTA_USER=$(echo "$config" | json manta.user)
+[[ -n "$MANTA_USER" ]] || fatal "not configured to use Manta: no 'manta.user' in config"
+export MANTA_KEY_ID=$(echo "$config" | json manta.keyId)
+[[ -n "$MANTA_KEY_ID" ]] || fatal "not configured to use Manta: no 'manta.keyId' in config"
+if [[ "$(echo "$config" | json manta.insecure)" == "true" ]]; then
+    export MANTA_TLS_INSECURE=1
+fi
+dstMdir=$(echo "$config" | json manta.rootDir)/logs
+
+
+echo ""
+n=1
+while true; do
+    echo "[$(date '+%Y%m%dT%H%M%S')] upload_files attempt $n (dryrun=$opt_dryrun)"
+    upload_files $opt_dryrun
+    echo "[$(date '+%Y%m%dT%H%M%S')] done upload_files attempt $n"
+    n=$(( $n + 1 ))
+    if [[ $n -gt $opt_numattempts ]]; then
+        break
+    fi
+    sleep 60
+done
diff --git a/tools/standalone/tritonpostlogrotate.sh b/tools/standalone/tritonpostlogrotate.sh
new file mode 100755
index 0000000..829a5de
--- /dev/null
+++ b/tools/standalone/tritonpostlogrotate.sh
@@ -0,0 +1,135 @@
+#!/usr/bin/bash
+# vi: sw=4 ts=4 et
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016 Joyent, Inc.
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+export PATH=/opt/local/bin:$PATH
+
+SRCDIR=/var/log/triton
+DSTDIR=/var/log/triton/upload
+DATE=/opt/local/bin/date
+
+
+#---- support functions
+
+function fatal() {
+    echo "$0: error: $*" >&2
+    exit 1
+}
+
+function errexit
+{
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+
+function usage () {
+    echo "Move a just rotated-by-logadm Triton log file from /var/log/triton to"
+    echo "/var/log/triton/upload (possibly renaming the timestamp)."
+    echo ""
+    echo "Requirements:"
+    echo "1. The 'just rotated' log file is expected to be of the form:"
+    echo "       \$logname_\$nodename_YYYYMMDDTHHMMSS.log"
+    echo "2. The '\$logname' cannot contain an underscore."
+    echo ""
+    echo "Usage:"
+    echo "    tritonpostrotatelog.sh [-q] [-f] [-m] LOGNAME"
+    echo ""
+    echo "Options:"
+    echo "     -h   Print this help and exit."
+    echo "     -q   Quiet output."
+    echo "     -m   Move ('mv') rotated files from /var/log/triton/*.log"
+    echo "          to /var/log/triton/upload/*.log, rather than the default"
+    echo "          to hardlink ('ln'). This allows one to delete logs as"
+    echo "          as soon as they are uploaded, e.g. if you never want to"
+    echo "          look at them locally and size is a potential constraint."
+    echo "     -f   Roll the latest rotated log file *forward* to the next"
+    echo "          hour. E.g., '...T091234.log' will be rolled to"
+    echo "          '...T100000.log'. This is to support more-than-once-per-hour"
+    echo "          rotations ending up as one correct hourly log file in"
+    echo "          Manta -- which is needed to not lose log data through a"
+    echo "          'vmadm reprovision'."
+    echo ""
+    echo "Example: 'tritonpostrotatelog.sh imgapi' might rotate this:"
+    echo "    /var/log/triton/imgapi_imagesjo0_20151225T110003.log"
+    echo "to this:"
+    echo "    /var/log/triton/upload/imgapi_imagesjo0_20151225T110000.log"
+}
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+# Options.
+opt_verbose=yes
+opt_action=ln
+opt_rolldir=bwd
+while getopts "hqfm" opt
+do
+    case "$opt" in
+        h)
+            usage
+            exit 0
+            ;;
+        q)
+            opt_verbose=
+            ;;
+        f)
+            opt_rolldir=fwd
+            ;;
+        m)
+            opt_action=mv
+            ;;
+        *)
+            usage
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+logname=$1
+[[ -z "$logname" ]] && fatal "LOGNAME argument not given"
+if [[ -n "$(echo "$logname" | (grep _ || true))" ]]; then
+    fatal "a logname may not contain an underscore: $logname"
+fi
+
+
+lastlog=$(ls -1t /var/log/triton/${logname}_*_????????T??????.log | head -1)
+if [[ "$opt_rolldir" == "bwd" ]]; then
+    base=$(echo $lastlog | cut -d: -f1)   # '/var/log/sdc/upload/$logname...T23'
+    targ=$DSTDIR/$(basename $lastlog | sed -E 's/[0-9][0-9]\.log$/00.log/')
+else
+    # Roll forward.
+    base=$(basename $lastlog | sed -E 's/_[0-9T]+\.log$//')
+    datestr=$(echo $lastlog | awk '{ FS="_"; print $NF }' | cut -d. -f1)
+    isotime=$(echo $datestr | strptime -i '%Y%m%dT%H%M%S' -f '%Y-%m-%dT%H:%M:%S')
+    # Note: GZ /usr/bin/date doesn't support -d.
+    hourfwd=$($DATE -d \@$(( $($DATE -d $isotime "+%s") + 3600 )) "+%Y%m%dT%H0000")
+    targ="$DSTDIR/${base}_${hourfwd}.log"
+fi
+
+[[ -z "$opt_verbose" ]] || echo "$opt_action $lastlog $targ"
+if [[ "$opt_action" == "mv" ]]; then
+    mv $lastlog $targ
+elif [[ "$opt_action" == "ln" ]]; then
+    ln $lastlog $targ
+else
+    fatal "unknown action: $opt_action"
+fi
-- 
2.21.0

