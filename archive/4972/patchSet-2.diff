commit 2f2e4952909c145b547a35577d974964ce81d302 (refs/changes/72/4972/2)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2018-10-24T22:31:33+00:00 (12 months ago)
    
    MANTA-3957 reshard delete phase stuck on single vnode
    Reviewed by: Kody A Kantor <kody.kantor@joyent.com>
    Approved by: Alex Wilson <alex.wilson@joyent.com>

diff --git a/lib/phase_delete_data.js b/lib/phase_delete_data.js
index 71a8764..95b3f17 100644
--- a/lib/phase_delete_data.js
+++ b/lib/phase_delete_data.js
@@ -743,7 +743,8 @@ delete_one_table(ctl, pg_set, table, vnodes, status, callback)
 		return ({
 			vq_vnode: vnode,
 			vq_count: 0,
-			vq_ordinal: idx + 1
+			vq_ordinal: idx + 1,
+			vq_column: '_id',
 		});
 	});
 
@@ -841,30 +842,30 @@ delete_one_table(ctl, pg_set, table, vnodes, status, callback)
 		 * Delete a limited quantity of rows in this batch.  As
 		 * PostgreSQL does not support a LIMIT clause on a DELETE
 		 * statement, we first assemble the list of rows in a subquery.
-		 * We use the Common Table Expression (CTE) feature so that we
-		 * can refer to up to two columns from the subquery separately.
 		 */
-		mod_assert.bool(extended_id, 'extended_id');
+		mod_assert.ok(vq.vq_column === '_id' || vq.vq_column === '_idx',
+		    'vq_column not _id[x]');
+		var sq = [
+			'SELECT', vq.vq_column, 'FROM', table,
+			'WHERE _vnode = $1 AND', vq.vq_column, 'IS NOT NULL',
+			'LIMIT $2'
+		].join(' ');
 		var q = [
-			'WITH row_set AS (SELECT',
-			extended_id ? '_id, _idx' : '_id',
-			'FROM', table, 'WHERE _vnode = $1 LIMIT $2)',
 			'DELETE FROM', table, 'WHERE',
-			'(_id IN (SELECT _id FROM row_set WHERE _id',
-			'IS NOT NULL)',
-		];
-		if (extended_id) {
-			q.push('OR _idx IN (SELECT _idx FROM row_set WHERE',
-			    '_idx IS NOT NULL)');
-		}
-		q.push(') AND _vnode = $1');
-
-		q = q.join(' ');
+			vq.vq_column, 'IS NOT NULL AND',
+			vq.vq_column, 'IN (', sq, ') AND',
+			'_vnode = $1'
+		].join(' ');
 
 		var p = [ vq.vq_vnode, delete_batch_size ];
 
-		dot.dot_status.update('vnode %10d: deleted %d rows (#%d)',
-		    vq.vq_vnode, vq.vq_count, vq.vq_ordinal);
+		var update_status = function () {
+			dot.dot_status.update(
+			    'vnode %10d: deleted %d rows (#%d) column "%s"',
+			    vq.vq_vnode, vq.vq_count, vq.vq_ordinal,
+			    vq.vq_column);
+		};
+		update_status();
 
 		ctl.log.info({ extended_id: extended_id },
 		    'checking table %s vnode %d', table,
@@ -884,27 +885,50 @@ delete_one_table(ctl, pg_set, table, vnodes, status, callback)
 				delete_batch_size: delete_batch_size,
 				row_count: res.rowCount,
 				table: table,
-				vnode: vq.vq_vnode
+				vnode: vq.vq_vnode,
+				column: vq.vq_column
 			};
 
+			mod_assert.ok(vq.vq_column === '_id' ||
+			    vq.vq_column === '_idx', 'vq_column not _id[x]');
+			if (res.rowCount === 0 && vq.vq_column === '_id' &&
+			    extended_id) {
+				/*
+				 * If we have exhausted rows with an "_id"
+				 * value, but extended identifiers are in use,
+				 * then we need to continue deleting using the
+				 * "_idx" column.
+				 */
+				ctl.log.info(log_props,
+				    '"_id" rows exhausted, moving to ' +
+				    '"_idx" rows (table %s, vnode %d)',
+				    table, vq.vq_vnode);
+				vq.vq_column = '_idx';
+				setImmediate(worker, dot, worker_cb);
+				return;
+			}
+
 			if (res.rowCount === 0) {
 				/*
-				 * There are no more rows to delete for this
-				 * vnode.
+				 * Otherwise, there are no more rows to delete
+				 * for this vnode.
 				 */
 				dot.dot_vq = null;
 				ctl.log.info(log_props,
-				    'no match (table %s, vnode %d)',
-				    table, vq.vq_vnode);
+				    'no match (table %s, vnode %d, column %s)',
+				    table, vq.vq_vnode, vq.vq_column);
+				vq.vq_column = null;
 				setImmediate(worker, dot, worker_cb);
 				return;
 			}
 
+			mod_assert.number(vq.vq_count, 'vq_count');
 			vq.vq_count += res.rowCount;
 			ctl.log.info(log_props,
-			    'deleted %d rows for table %s vnode %d',
-			    res.rowCount, table, vq.vq_vnode);
+			    'deleted %d rows for table %s vnode %d column %s',
+			    res.rowCount, table, vq.vq_vnode, vq.vq_column);
 
+			update_status();
 			record_deletes(res.rowCount);
 
 			if (ctl.pausing(done)) {
