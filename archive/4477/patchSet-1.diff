From 86211fe4f92bc5f2702bcb030ee2ad99623e56f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?K=C3=A9vin=20Berthommier?= <kevin.bertho@gmail.com>
Date: Tue, 3 Jul 2018 23:05:31 +0200
Subject: [PATCH] lint

---
 lib/verror.js | 78 +++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 57 insertions(+), 21 deletions(-)

diff --git a/lib/verror.js b/lib/verror.js
index 1d6e16c..9a68afe 100644
--- a/lib/verror.js
+++ b/lib/verror.js
@@ -52,9 +52,15 @@ function parseConstructorArguments(args)
 {
 	var argv, options, sprintf_args, shortmessage, k;
 
-	if (!isObject(args)) throw new mod_AssertionError('args (object) is required');
-	if (!isBoolean(args.strict)) throw new mod_AssertionError('args.strict (bool) is required');
-	if (!Array.isArray(args.argv)) throw new mod_AssertionError('args.argv (array) is required');
+	if (!isObject(args)) {
+		throw new mod_AssertionError('args (object) is required');
+	}
+	if (!isBoolean(args.strict)) {
+		throw new mod_AssertionError('args.strict (bool) is required');
+	}
+	if (!Array.isArray(args.argv)) {
+		throw new mod_AssertionError('args.argv (array) is required');
+	}
 	argv = args.argv;
 
 	/*
@@ -109,7 +115,9 @@ function parseConstructorArguments(args)
 	 * desiring the strict behavior can use the SError class or pass the
 	 * "strict" option to the VError constructor.
 	 */
-	if (!isObject(options)) throw new mod_AssertionError('options (object) is required');
+	if (!isObject(options)) {
+		throw new mod_AssertionError('options (object) is required');
+	}
 	if (!options.strict && !args.strict) {
 		sprintf_args = sprintf_args.map(function (a) {
 			return (a === null ? 'null' :
@@ -162,7 +170,9 @@ function VError()
 	 * If we've been given a name, apply it now.
 	 */
 	if (parsed.options.name) {
-		if (!isString(parsed.options.name)) throw new mod_AssertionError('error\'s "name" must be a string');
+		if (!isString(parsed.options.name)) {
+			throw new mod_AssertionError('error\'s "name" must be a string');
+		}
 		this.name = parsed.options.name;
 	}
 
@@ -180,7 +190,9 @@ function VError()
 	 */
 	cause = parsed.options.cause;
 	if (cause) {
-		if (!isError(cause)) throw new mod_AssertionError('cause must be an Error');
+		if (!isError(cause)) {
+			throw new mod_AssertionError('cause must be an Error');
+		}
 		this.jse_cause = cause;
 
 		if (!parsed.options.skipCauseMessage) {
@@ -247,7 +259,9 @@ VError.prototype.cause = function ve_cause()
 
 VError.cause = function (err)
 {
-	if (!isError(err)) throw new mod_AssertionError('err must be an Error');
+	if (!isError(err)) {
+		throw new mod_AssertionError('err must be an Error');
+	}
 	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
 };
 
@@ -255,7 +269,9 @@ VError.info = function (err)
 {
 	var rv, cause, k;
 
-	if (!isError(err)) throw new mod_AssertionError('err must be an Error');
+	if (!isError(err)) {
+		throw new mod_AssertionError('err must be an Error');
+	}
 	cause = VError.cause(err);
 	if (cause !== null) {
 		rv = VError.info(cause);
@@ -276,9 +292,15 @@ VError.findCauseByName = function (err, name)
 {
 	var cause;
 
-	if (!isError(err)) throw new mod_AssertionError('err must be an Error');
-	if (!isString(name)) throw new mod_AssertionError('name (string) is required');
-	if (name.length <= 0) throw new mod_AssertionError('name cannot be empty');
+	if (!isError(err)) {
+		throw new mod_AssertionError('err must be an Error');
+	}
+	if (!isString(name)) {
+		throw new mod_AssertionError('name (string) is required');
+	}
+	if (name.length <= 0) {
+		throw new mod_AssertionError('name cannot be empty');
+	}
 
 	for (cause = err; cause !== null; cause = VError.cause(cause)) {
 		if (!isError(cause)) throw new mod_AssertionError('cause must be an Error');
@@ -320,7 +342,9 @@ VError.errorFromList = function (errors)
 	}
 
 	errors.forEach(function (e) {
-		if (!isError(e)) throw new mod_AssertionError('err must be an Error');
+		if (!isError(e)) {
+			throw new mod_AssertionError('err must be an Error');
+		}
 	});
 
 	if (errors.length == 1) {
@@ -332,8 +356,12 @@ VError.errorFromList = function (errors)
 
 VError.errorForEach = function (err, func)
 {
-	if (!isError(err)) throw new mod_AssertionError('err must be an Error');
-	if (!isFunc(func)) throw new mod_AssertionError('func (func) is required');
+	if (!isError(err)) {
+		throw new mod_AssertionError('err must be an Error');
+	}
+	if (!isFunc(func)) {
+		throw new mod_AssertionError('func (func) is required');
+	}
 
 	if (err instanceof MultiError) {
 		err.errors().forEach(function iterError(e) { func(e); });
@@ -384,8 +412,12 @@ mod_util.inherits(SError, VError);
  */
 function MultiError(errors)
 {
-	if (!Array.isArray(errors)) throw new mod_AssertionError('list of errors (array) is required');
-	if (!(errors.length > 0)) throw new mod_AssertionError('must be at least one error');
+	if (!Array.isArray(errors)) {
+		throw new mod_AssertionError('list of errors (array) is required');
+	}
+	if (!(errors.length > 0)) {
+		throw new mod_AssertionError('must be at least one error');
+	}
 	this.ase_errors = errors;
 
 	VError.call(this, {
@@ -458,21 +490,25 @@ WError.prototype.cause = function we_cause(c)
 // Assertion test functions
 
 function isBoolean(arg) {
-  return typeof arg === 'boolean';
+	return (typeof arg === 'boolean');
 }
 
 function isString(arg) {
-  return typeof arg === 'string';
+	return (typeof arg === 'string');
 }
 
 function isObject(arg) {
-  return typeof arg === 'object' && arg !== null;
+	return (typeof arg === 'object' && arg !== null);
 }
 
 function isError(arg) {
-  return isObject(arg) && (Object.prototype.toString.call(arg) === '[object Error]' || arg instanceof Error);
+	return (
+		isObject(arg)
+		&& (Object.prototype.toString.call(arg) === '[object Error]'
+			|| arg instanceof Error)
+	);
 }
 
 function isFunc(arg) {
-  return typeof arg === 'function';
+	return (typeof arg === 'function');
 }
-- 
2.21.0

