From a6a17a2d916a6a586d7547e451115c998e39654b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Sat, 23 Apr 2016 23:32:23 +0000
Subject: [PATCH] NAPI-361 Switch to using node-ip6addr Reviewed by: Patrick
 Mooney <patrick.mooney@joyent.com> Approved by: Matt Smillie
 <matt.smillie@joyent.com>

---
 lib/endpoints/networks/ips.js |   9 +-
 lib/endpoints/search.js       |   2 +-
 lib/models/ip/common.js       |  20 ++---
 lib/models/ip/index.js        |   4 +-
 lib/models/ip/provision.js    |   8 +-
 lib/models/network.js         | 121 ++++++++++---------------
 lib/models/nic/common.js      |   3 +-
 lib/models/nic/obj.js         |   4 +-
 lib/util/ip.js                | 161 +++++++---------------------------
 lib/util/validate.js          |   7 ++
 package.json                  |   2 +-
 test/lib/mock-moray.js        |  12 ++-
 test/lib/portolan.js          |   4 +-
 test/unit/helpers.js          |   8 +-
 test/unit/ips.test.js         | 139 ++++++++++++++++++-----------
 test/unit/nics.test.js        |   2 +-
 test/unit/util-ip.test.js     |  21 ++++-
 17 files changed, 235 insertions(+), 292 deletions(-)

diff --git a/lib/endpoints/networks/ips.js b/lib/endpoints/networks/ips.js
index 4bd53e6..2db4997 100644
--- a/lib/endpoints/networks/ips.js
+++ b/lib/endpoints/networks/ips.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -35,7 +35,12 @@ function validateIP(req, res, next) {
             'Invalid IP address'));
     }
 
-    if (!ip.match(req._network.subnetStart, req._network.subnetBits)) {
+    if (ip.kind() !== req._network.subnetType) {
+        return next(new restify.ResourceNotFoundError(
+            'IP and subnet are of different address families'));
+    }
+
+    if (!req._network.subnet.contains(ip)) {
         return next(new restify.ResourceNotFoundError(
             'IP is not in subnet'));
 
diff --git a/lib/endpoints/search.js b/lib/endpoints/search.js
index 0f31337..c248e01 100644
--- a/lib/endpoints/search.js
+++ b/lib/endpoints/search.js
@@ -89,7 +89,7 @@ SearchIPNetworkStream.prototype._transform = function (net, _enc, done) {
         return done();
     }
 
-    if (!self.sipn_ip.match(net.subnetStart, net.subnetBits)) {
+    if (!net.subnet.contains(self.sipn_ip)) {
         return done();
     }
 
diff --git a/lib/models/ip/common.js b/lib/models/ip/common.js
index 5726482..009ab51 100644
--- a/lib/models/ip/common.js
+++ b/lib/models/ip/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -107,13 +107,7 @@ Object.defineProperty(IP.prototype, 'type', {
 
 Object.defineProperty(IP.prototype, 'v6address', {
     get: function () {
-        var ipObj = this.params.ip;
-
-        if (ipObj.kind() === 'ipv4') {
-            ipObj = ipObj.toIPv4MappedAddress();
-        }
-
-        return ipObj.toString();
+        return this.params.ip.toString({ format: 'v6' });
     }
 });
 
@@ -133,16 +127,14 @@ IP.prototype.batch = function ipBatch(opts) {
     };
 
     if (opts && opts.free) {
-        var value = this.params.ip.toString();
-
         batchObj.value = {
             reserved: false
         };
 
         if (this.use_strings) {
-            batchObj.value.ipaddr = util_ip.aton(value).toString();
+            batchObj.value.ipaddr = this.params.ip.toString();
         } else {
-            batchObj.value.ip = util_ip.aton(value).toString();
+            batchObj.value.ip = this.params.ip.toLong();
         }
     }
 
@@ -218,7 +210,7 @@ IP.prototype.raw = function ipRaw() {
         raw.ipaddr = this.params.ip.toString();
         raw.v = BUCKET.version;
     } else {
-        raw.ip = util_ip.addressToNumber(this.params.ip.toString()).toString();
+        raw.ip = this.params.ip.toLong();
     }
 
     OPTIONAL_PARAMS.forEach(function (param) {
@@ -240,7 +232,7 @@ IP.prototype.raw = function ipRaw() {
  */
 function getIPKey(use_strings, ipaddr) {
     if (!use_strings) {
-        return util_ip.addressToNumber(ipaddr.toString()).toString();
+        return ipaddr.toLong().toString();
     } else {
         return ipaddr.toString();
     }
diff --git a/lib/models/ip/index.js b/lib/models/ip/index.js
index f99f1ec..c273986 100644
--- a/lib/models/ip/index.js
+++ b/lib/models/ip/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -535,7 +535,7 @@ function deleteIP(app, log, params, callback) {
     if (use_strings) {
         val.ipaddr = ip.toString();
     } else {
-        val.ip = util_ip.aton(ip.toString());
+        val.ip = ip.toLong();
     }
 
     log.info(params, 'deleteIP: deleting IP %s', ip.toString());
diff --git a/lib/models/ip/provision.js b/lib/models/ip/provision.js
index 4508e8a..ff52bc4 100644
--- a/lib/models/ip/provision.js
+++ b/lib/models/ip/provision.js
@@ -253,8 +253,8 @@ function nextGapIPsOnNetwork(opts, callback) {
             'over(order by ip) - ip - 1 gap_length from %s ' +
             'where ip >= %d AND ip <= %d) t where gap_length > 0 limit 1',
             bucket.name,
-            util_ip.addressToNumber(min.toString()),
-            util_ip.addressToNumber(max.toString()));
+            min.toLong(),
+            max.toLong());
     }
 
     log.debug({
@@ -343,8 +343,8 @@ function nextFreedIPsonNetwork(opts, callback) {
     if (!params.network.ip_use_strings) {
         filter = util.format(
             '(&(ip>=%d)(ip<=%d)(!(belongs_to_uuid=*))(reserved=false))',
-            util_ip.addressToNumber(params.network.provisionMin.toString()),
-            util_ip.addressToNumber(params.network.provisionMax.toString()));
+            params.network.provisionMin.toLong(),
+            params.network.provisionMax.toLong());
     }
 
     log.debug({
diff --git a/lib/models/network.js b/lib/models/network.js
index 4dda955..9213db0 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var constants = require('../util/constants');
 var errors = require('../util/errors');
 var fmt = require('util').format;
+var ipaddr = require('ip6addr');
 var jsprim = require('jsprim');
 var lomstream = require('lomstream');
 var mod_ip = require('./ip');
@@ -132,7 +133,7 @@ function adminReservedIP(network, ipNum, ufdsAdminUuid) {
     if (network.ip_use_strings) {
         params.ipaddr = ipNum.toString();
     } else {
-        params.ip = util_ip.aton(ipNum.toString());
+        params.ip = ipNum.toLong();
     }
     return params;
 }
@@ -155,7 +156,7 @@ function userReservedIP(network, ipNum, userUuid) {
     if (network.ip_use_strings) {
         params.ipaddr = ipNum.toString();
     } else {
-        params.ip = util_ip.aton(ipNum.toString());
+        params.ip = ipNum.toLong();
     }
     return params;
 }
@@ -217,7 +218,7 @@ function placeholderIP(network, num) {
     if (network.ip_use_strings) {
         params.ipaddr = num.toString();
     } else {
-        params.ip = util_ip.aton(num.toString());
+        params.ip = num.toLong();
     }
 
     return params;
@@ -248,8 +249,8 @@ function provisionRangeUpdates(app, log, network, update, callback) {
     var toMove = [];
 
     if (update.hasOwnProperty('provision_start_ip') &&
-        (update.provision_start_ip.toString() !==
-        network.params.provision_start_ip.toString())) {
+        update.provision_start_ip.compare(network.params.provision_start_ip)
+        !== 0) {
         toMove.push({
             before: util_ip.ipAddrMinus(network.params.provision_start_ip, 1),
             after: util_ip.ipAddrMinus(update.provision_start_ip, 1)
@@ -257,8 +258,8 @@ function provisionRangeUpdates(app, log, network, update, callback) {
     }
 
     if (update.hasOwnProperty('provision_end_ip') &&
-        (update.provision_end_ip.toString() !==
-        network.params.provision_end_ip.toString())) {
+        update.provision_end_ip.compare(network.params.provision_end_ip)
+        !== 0) {
         toMove.push({
             before: util_ip.ipAddrPlus(network.params.provision_end_ip, 1),
             after: util_ip.ipAddrPlus(update.provision_end_ip, 1)
@@ -369,25 +370,6 @@ function routeNumbers(routes) {
 }
 
 
-/**
- * Return the subnet end IP based on the start and number of bits
- */
-function subnetEnd(start, bits) {
-    /*
-     * Since we only use this to find the broadcast address, and broadcast
-     * addresses only make sense in the land of IPv4 networks, this function
-     * only works on IPv4 subnets.
-     */
-    if (start.kind() !== 'ipv4') {
-        return null;
-    }
-
-    start = util_ip.addressToNumber(start.toString());
-    var end = start + Math.pow(2, 32 - bits) - 1;
-    return util_ip.toIPAddr(util_ip.numberToAddress(end));
-}
-
-
 /**
  * Validate gateway - allow it to be empty or a valid IP
  */
@@ -503,11 +485,11 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
     var provisionStart = parsedParams.provision_start_ip;
     var subnetBits = parsedParams.subnet_bits;
     var subnetStart = parsedParams.subnet_start;
-    var subnet = util.format('%s/%d', subnetStart, subnetBits);
+    var subnet = ipaddr.createCIDR(subnetStart, subnetBits);
     var subnetType = subnetStart.kind();
-    parsedParams.subnet = parsedParams.subnet || subnet;
 
-    var maxIP = subnetEnd(subnetStart, subnetBits); // IPv4 only, for broadcast
+    assert.ok(subnet, 'subnet');
+    parsedParams.subnet = subnet.toString();
 
     // check that provisioning ranges match subnet type
     // if they don't match, set variable to null and skip later checks
@@ -536,16 +518,14 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
     }
 
     // check if provision range is within the subnet
-    if (provisionStart !== null &&
-            !provisionStart.match(subnetStart, subnetBits)) {
+    if (provisionStart !== null && !subnet.contains(provisionStart)) {
         errs.push(errors.invalidParam('provision_start_ip',
             constants.msg.PROV_START_IP_OUTSIDE));
 
         provisionStart = null;
         delete parsedParams.provision_start_ip;
     }
-    if (provisionEnd !== null &&
-            !provisionEnd.match(subnetStart, subnetBits)) {
+    if (provisionEnd !== null && !subnet.contains(provisionEnd)) {
         errs.push(errors.invalidParam('provision_end_ip',
             constants.msg.PROV_END_IP_OUTSIDE));
 
@@ -563,7 +543,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
     }
 
     // check if gateway is within the subnet
-    if (gateway && !gateway.match(subnetStart, subnetBits)) {
+    if (gateway && !subnet.contains(gateway)) {
         errs.push(errors.invalidParam('gateway', constants.GATEWAY_SUBNET_MSG));
 
         gateway = null;
@@ -610,7 +590,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
 
     // IPv4-only checks - broadcast address is reserved
     if (provisionStart && provisionStart.kind() === 'ipv4' &&
-        provisionStart.toString() === maxIP.toString()) {
+        provisionStart.compare(subnet.broadcast()) === 0) {
 
         errs.push(errors.invalidParam('provision_start_ip',
             constants.msg.PROV_START_IP_BCAST));
@@ -619,7 +599,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
         delete parsedParams.provision_start_ip;
     }
     if (provisionEnd && provisionEnd.kind() === 'ipv4' &&
-        provisionEnd.toString() === maxIP.toString()) {
+        provisionEnd.compare(subnet.broadcast()) === 0) {
 
         errs.push(errors.invalidParam('provision_end_ip',
             constants.msg.PROV_END_IP_BCAST));
@@ -630,7 +610,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
 
     // check if provision start is before provision end
     if (provisionStart && provisionEnd &&
-        util_ip.compareTo(provisionStart, provisionEnd) >= 0) {
+        provisionStart.compare(provisionEnd) >= 0) {
 
         errs.push(errors.invalidParam('provision_end_ip',
                     constants.PROV_RANGE_ORDER_MSG));
@@ -660,7 +640,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
         'subnet_start << inet(\'%s\')) %s',
         BUCKET.name,
         subnetStart.toString(),
-        subnet,
+        subnet.toString(),
         opts.owner_uuid ?
             fmt(' AND \'%s\' = ANY(owner_uuids_arr) AND fabric = true',
                 opts.owner_uuid)
@@ -668,7 +648,7 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
 
     opts.log.debug({
         sql: overlapSQL,
-        subnet: subnet
+        subnet: subnet.toString()
     }, 'validateProvisionRange: finding overlapping subnets');
 
     var req = opts.app.moray.sql(overlapSQL);
@@ -918,8 +898,14 @@ function validateNicTagMTU(opts, params, parsed, callback) {
  * Network model constructor
  */
 function Network(params) {
-    var subnet = params.subnet ? params.subnet.split('/') :
-        [params.subnet_start || params.subnet_start_ip, params.subnet_bits];
+    var subnet_start = util_ip.toIPAddr(
+        params.subnet_start || params.subnet_start_ip);
+
+    assert.ok(subnet_start, 'subnet_start');
+
+    var subnet = ipaddr.createCIDR(subnet_start, params.subnet_bits);
+
+    assert.ok(subnet, 'subnet');
 
     // Note on address fields: Previously, addresses were stored as numbers in
     // moray, which only works for IPv4. Addresses are now sent as strings, and
@@ -936,8 +922,9 @@ function Network(params) {
                 params.provision_start_ip_addr || params.provision_start_ip),
         provision_end_ip: util_ip.toIPAddr(
                 params.provision_end_ip_addr || params.provision_end_ip),
-        subnet_start: util_ip.toIPAddr(subnet[0]),
-        subnet_bits: Number(subnet[1]),
+        subnet: subnet,
+        subnet_start: subnet_start,
+        subnet_bits: subnet.prefixLength(),
         uuid: params.uuid,
         vlan_id: Number(params.vlan_id),
         mtu: Number(params.mtu) || constants.MTU_DEFAULT
@@ -1022,6 +1009,7 @@ function Network(params) {
     this.subnetBits = this.params.subnet_bits;
     this.subnetStart = this.params.subnet_start;
     this.subnetType = this.params.subnet_type;
+    this.subnet = this.params.subnet;
 
 
     // XXX: rename this something different!?
@@ -1097,9 +1085,8 @@ Network.prototype.raw = function networkRaw(opts) {
         provision_start_ip_addr:
             this.params.provision_start_ip.toString(),
         subnet_start: this.params.subnet_start.toString(),
-        subnet: util.format('%s/%d',
-            this.params.subnet_start.toString(),
-            this.params.subnet_bits),
+        subnet_bits: this.params.subnet_bits,
+        subnet: this.subnet.toString(),
         subnet_type: this.params.subnet_type,
         nic_tag: this.params.nic_tag,
         uuid: this.params.uuid,
@@ -1115,10 +1102,9 @@ Network.prototype.raw = function networkRaw(opts) {
 
     // Backward-compatibility (for rollback)
     if (this.params.subnet_type === 'ipv4') {
-        raw.subnet_bits = this.params.subnet_bits;
-        raw.provision_end_ip = util_ip.aton(raw.provision_end_ip_addr);
-        raw.provision_start_ip = util_ip.aton(raw.provision_start_ip_addr);
-        raw.subnet_start_ip = util_ip.aton(raw.subnet_start);
+        raw.provision_end_ip = this.params.provision_end_ip.toLong();
+        raw.provision_start_ip = this.params.provision_start_ip.toLong();
+        raw.subnet_start_ip = this.params.subnet_start.toLong();
         raw.subnet_end_ip = raw.subnet_start_ip +
             Math.pow(2, 32 - raw.subnet_bits) - 1;
     }
@@ -1127,7 +1113,7 @@ Network.prototype.raw = function networkRaw(opts) {
         raw.gateway_addr = this.params.gateway.toString();
 
         if (this.params.subnet_type === 'ipv4') {
-            raw.gateway = util_ip.aton(raw.gateway_addr);
+            raw.gateway = this.params.gateway.toLong();
         }
 
         if (this.params.fabric) {
@@ -1148,7 +1134,7 @@ Network.prototype.raw = function networkRaw(opts) {
         // Rollback-compatibility:
         if (this.params.subnet_type === 'ipv4') {
             raw.resolvers = this.params.resolvers.map(function (r) {
-                return util_ip.aton(r.toString());
+                return r.toLong();
             });
         }
     }
@@ -1187,9 +1173,7 @@ Network.prototype.serialize = function networkSerialize(opts) {
         name: this.params.name,
         provision_end_ip: this.params.provision_end_ip.toString(),
         provision_start_ip: this.params.provision_start_ip.toString(),
-        subnet: util.format('%s/%d',
-            this.params.subnet_start.toString(),
-            this.params.subnet_bits),
+        subnet: this.subnet.toString(),
         uuid: this.params.uuid,
         vlan_id: this.params.vlan_id
     };
@@ -1332,15 +1316,6 @@ function createNetwork(opts, callback) {
                             [ errors.duplicateParam('name') ]));
                     }
 
-                    if (err.message.match(/invalid cidr value/)) {
-                        // The only CIDR value that we have that's enforced by
-                        // Postgres is subnet:
-                        return cb(new errors.InvalidParamsError(
-                            constants.msg.INVALID_PARAMS,
-                            [ errors.invalidParam('subnet',
-                                constants.msg.CIDR_INVALID) ]));
-                    }
-
                     return cb(err);
                 }
 
@@ -1375,7 +1350,7 @@ function createNetwork(opts, callback) {
 
             for (var r in network.params.resolvers) {
                 var num = network.params.resolvers[r];
-                if (num.match(network.subnetStart, network.subnetBits) &&
+                if (network.subnet.contains(num) &&
                     !ipsToCreate.hasOwnProperty(num.toString())) {
 
                     ipsToCreate[num.toString()] = adminReservedIP(network, num,
@@ -1385,7 +1360,7 @@ function createNetwork(opts, callback) {
 
             // IPv4 only: Don't allow provisioning on the broadcast address.
             if (network.subnetType === 'ipv4') {
-                var maxIP = subnetEnd(network.subnetStart, network.subnetBits);
+                var maxIP = network.subnet.broadcast();
                 if (!ipsToCreate.hasOwnProperty(maxIP.toString())) {
                     ipsToCreate[maxIP.toString()] = adminReservedIP(network,
                         maxIP, app.config.ufdsAdminUuid);
@@ -1540,12 +1515,12 @@ function updateNetwork(opts, callback) {
         ['provision_start_ip', 'provision_end_ip'].forEach(function (p) {
             if (validated.hasOwnProperty(p)) {
                 var p_addr = p + '_addr';
-                var ip_str = validated[p].toString();
-                batch[0].value[p_addr] = ip_str;
+                var addr = validated[p];
+                batch[0].value[p_addr] = addr.toString();
 
                 // Backward-compatibility (for rollback)
                 if (isIPv4) {
-                    batch[0].value[p] = util_ip.aton(ip_str);
+                    batch[0].value[p] = addr.toLong();
                 }
             }
         });
@@ -1571,12 +1546,11 @@ function updateNetwork(opts, callback) {
             if (!validated.gateway) {
                 delete batch[0].value.gateway;
             } else {
-                var gateway_str = validated.gateway.toString();
-                batch[0].value.gateway_addr = gateway_str;
+                batch[0].value.gateway_addr = validated.gateway.toString();
 
                 // Backward-compatibility (for rollback)
                 if (isIPv4) {
-                    batch[0].value.gateway = util_ip.aton(gateway_str);
+                    batch[0].value.gateway = validated.gateway.toLong();
                 }
             }
 
@@ -1592,7 +1566,8 @@ function updateNetwork(opts, callback) {
             batch[0].value.resolver_addrs = resolvers;
 
             if (isIPv4) {
-                batch[0].value.resolvers = resolvers.map(util_ip.aton);
+                batch[0].value.resolvers = validated.resolvers.map(
+                    function (r) { return r.toLong(); });
             }
         }
 
diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index 22f9374..9f709ac 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -92,8 +92,7 @@ function validateSubnetContainsIP(opts, parsedParams, callback) {
     var app = opts.app;
     var log = opts.log;
 
-    if (!parsedParams.ip.match(
-        parsedParams.network.subnetStart, parsedParams.network.subnetBits)) {
+    if (!parsedParams.network.subnet.contains(parsedParams.ip)) {
 
         return callback(errors.invalidParam('ip', util.format(
             constants.fmt.IP_OUTSIDE, parsedParams.ip,
diff --git a/lib/models/nic/obj.js b/lib/models/nic/obj.js
index 9aebc73..acb7e87 100644
--- a/lib/models/nic/obj.js
+++ b/lib/models/nic/obj.js
@@ -523,8 +523,8 @@ Nic.prototype.raw = function nicRaw() {
         }
 
         if (this.params.ipaddr) {
-            raw.ip = util_ip.aton(this.params.ipaddr.toString());
-            raw.ipaddr = this.params.ipaddr;
+            raw.ip = this.params.ipaddr.toLong();
+            raw.ipaddr = this.params.ipaddr.toString();
         } else if (this.params.ip) {
             raw.ip = this.params.ip;
             raw.ipaddr = util_ip.ntoa(raw.ip);
diff --git a/lib/util/ip.js b/lib/util/ip.js
index 9bb58f3..91302e1 100644
--- a/lib/util/ip.js
+++ b/lib/util/ip.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -14,11 +14,11 @@
 
 'use strict';
 
-var ipaddr = require('ipaddr.js');
+var ipaddr = require('ip6addr');
 var net = require('net');
 
 
-var MAX_IP = 4294967295;
+var MAX_IPV4 = 4294967295;
 
 
 /*
@@ -38,88 +38,33 @@ function addressToNumber(addr) {
 
 
 /*
- * Idempotent conversion from strings (and numbers) to ipaddr.js objects
+ * Idempotent conversion from strings (and numbers) to ip6addr objects
  */
 function toIPAddr(addr) {
-    if (addr instanceof ipaddr.IPv4 || addr instanceof ipaddr.IPv6) {
-        return addr;
-    }
-    if (typeof (addr) === 'object' && addr !== null) {
-        if (addr.octets)
-            return ipaddr.parse(addr.octets.join('.'));
-        else if (addr.parts)
-            return ipaddr.parse(addr.parts.join(':'));
-    }
-    // XXX We want to be able to parse numbers as IP addresses to support the
-    // legacy IP tables where addresses were stored as numbers. ipaddr.js will
-    // parse decimal numbers (in string form) as IP addresses for IPv4 (see
-    // https://github.com/whitequark/ipaddr.js/issues/7)
-    // However, since ipaddr.js parses strings, when previously an IP address
-    // parameter like '1' would not be accepted, it is now parsed as 0.0.0.1
-    if (typeof (addr) === 'number') {
-        addr = addr.toString();
+    // If the address passed in is just a series of numbers,
+    // convert it to a long that can be parsed by ip6addr
+    if (/^[0-9]+$/.test(addr)) {
+        addr = Number(addr);
     }
 
-    if (!ipaddr.isValid(addr)) {
+    try {
+        return ipaddr.parse(addr);
+    } catch (_) {
         return null;
     }
-
-    return ipaddr.parse(addr);
-}
-
-
-/**
- * Return an IPv6 address object, regardless of whether it's a v4 or v6
- * input address
- */
-function toIP6Addr(addr) {
-    if (addr instanceof ipaddr.IPv4 || addr instanceof ipaddr.IPv6) {
-        return addr;
-    }
-
-    var ipObj = ipaddr.process(addr);
-    if (ipObj.kind() === 'ipv4') {
-        ipObj = ipObj.toIPv4MappedAddress();
-    }
-
-    return ipObj;
 }
 
 
 function ipAddrPlus(addr, summand) {
-    // clone since we'll be modifying the underlying representation
-    addr = ipaddr.parse(toIPAddr(addr).toString());
-
-    // ipaddr.js uses arrays of numbers for its underlying representation of
-    // IPs.
-    // For IPv4, the 'octets' array has four numbers up to and including 255.
-    // For IPv6, the 'parts' array has eight numbers up to and including 65535.
-    var max, under;
-    if (addr.kind() === 'ipv4') {
-        max = Math.pow(2, 8);
-        under = 'octets';
-    } else {
-        max = Math.pow(2, 16);
-        under = 'parts';
-    }
-
-    var place = addr[under].length - 1;
-    addr[under][place] += summand;
-    var carry = Math.floor(addr[under][place] / max);
-    while (carry !== 0 && place >= 1) {
-        addr[under][place - 1] += carry;
-        addr[under][place] -= carry * max;
-        carry = Math.floor(addr[under][place - 1] / max);
-        place--;
-    }
-
-    // TODO better errors
-    if (carry > 0) {
-        throw new Error('overflow!');
-    } else if (carry < 0) {
-        throw new Error('underflow!');
+    var changed = addr.offset(summand);
+    if (changed === null) {
+        if (summand > 0) {
+            throw new Error('Address overflow!');
+        } else {
+            throw new Error('Address underflow!');
+        }
     }
-    return (addr);
+    return changed;
 }
 
 
@@ -128,37 +73,21 @@ function ipAddrMinus(addr, minuend) {
 }
 
 
+var RFC1918Subnets = [
+    ipaddr.createCIDR('10.0.0.0', 8),
+    ipaddr.createCIDR('172.16.0.0', 12),
+    ipaddr.createCIDR('192.168.0.0', 16)
+];
+
+
 /*
  * Returns true if the IP passed in is in any of the RFC1918 private
  * address spaces
  */
 function isRFC1918(ip) {
-    var num = ip;
-
-    if (net.isIPv6(ip)) {
-        return false;
-    }
-
-    if (isNaN(num)) {
-        num = addressToNumber(ip);
-    }
-
-    // 10.0.0.0/8: 10.0.0.0 - 10.255.255.255
-    if (num >= 167772160 && num <= 184549375) {
-        return true;
-    }
-
-    // 172.16.0.0/12: 172.16.0.0 - 172.31.255.255
-    if (num >= 2886729728 && num <= 2887778303) {
-        return true;
-    }
-
-    // 192.168.0.0/16: 192.168.0.0 - 192.168.255.255
-    if (num >= 3232235520 && num <= 3232301055) {
-        return true;
-    }
-
-    return false;
+    return RFC1918Subnets.some(function (subnet) {
+        return subnet.contains(ip);
+    });
 }
 
 
@@ -166,32 +95,7 @@ function isRFC1918(ip) {
  * Compares two IP addresses
  */
 function compareTo(a, b) {
-    a = toIPAddr(a);
-    b = toIPAddr(b);
-
-    if (!a || !b) {
-        return null;
-    }
-
-    if (a.kind() !== b.kind()) {
-        if (a.kind() === 'ipv4') {
-            a = a.toIPv4MappedAddress();
-        } else {
-            b = b.toIPv4MappedAddress();
-        }
-    }
-
-    var abytes = a.toByteArray();
-    var bbytes = b.toByteArray();
-    var i;
-
-    // big-endian arrays
-    for (i = 0; i < abytes.length; i++) {
-        if (abytes[i] !== bbytes[i]) {
-            return abytes[i] - bbytes[i];
-        }
-    }
-    return 0;
+    return ipaddr.compare(a, b);
 }
 
 
@@ -223,7 +127,7 @@ function bitsToNetmask(bits) {
     for (var i = 0; i < (32 - bits); i++) {
         n |= 1 << i;
     }
-    return numberToAddress(MAX_IP - n);
+    return numberToAddress(MAX_IPV4 - (n >>> 0));
 }
 
 
@@ -254,6 +158,5 @@ module.exports = {
     netmaskToBits: netmaskToBits,
     numberToAddress: numberToAddress,
     ntoa: numberToAddress,
-    toIPAddr: toIPAddr,
-    toIP6Addr: toIP6Addr
+    toIPAddr: toIPAddr
 };
diff --git a/lib/util/validate.js b/lib/util/validate.js
index 16c93b5..93ee32a 100644
--- a/lib/util/validate.js
+++ b/lib/util/validate.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var constants = require('../util/constants');
 var errors = require('./errors');
 var fmt = require('util').format;
+var ipaddr = require('ip6addr');
 var jsprim = require('jsprim');
 var restify = require('restify');
 var util = require('util');
@@ -388,6 +389,12 @@ function validateSubnet(name, subnetTxt, callback) {
         return callback(errors.invalidParam(name, constants.msg.CIDR_BITS));
     }
 
+    var cidr = ipaddr.createCIDR(ip, params.subnet_bits);
+
+    if (cidr.address().compare(ip) !== 0) {
+        return callback(errors.invalidParam(name, constants.msg.CIDR_INVALID));
+    }
+
     return callback(null, null, params);
 }
 
diff --git a/package.json b/package.json
index 6d197e8..57b3b1f 100644
--- a/package.json
+++ b/package.json
@@ -11,7 +11,7 @@
     "cmdln": "3.0.2",
     "dashdash": "1.7.3",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
-    "ipaddr.js": "0.1.8",
+    "ip6addr": "0.2.1",
     "jsprim": "1.2.2",
     "lomstream": "1.1.0",
     "moray": "git+https://github.com/joyent/node-moray.git#b84ef0e",
diff --git a/test/lib/mock-moray.js b/test/lib/mock-moray.js
index af1eca9..b1bbf23 100644
--- a/test/lib/mock-moray.js
+++ b/test/lib/mock-moray.js
@@ -355,7 +355,17 @@ FakeMoray.prototype.findObjects = function findObjects(bucket, filter, opts) {
         if (typeof (a) === 'number') {
             return a - b;
         } else {
-            return util_ip.compareTo(a, b);
+            try {
+                return util_ip.compareTo(a, b);
+            } catch (_) {
+                if (a < b) {
+                    return -1;
+                } else if (a > b) {
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
         }
     }
 
diff --git a/test/lib/portolan.js b/test/lib/portolan.js
index 28c0346..18f45b0 100644
--- a/test/lib/portolan.js
+++ b/test/lib/portolan.js
@@ -73,7 +73,7 @@ function afterMoray(t, opts, callback, err, realObj) {
     if (opts.exp) {
         exp = clone(opts.exp);
         if (exp.ip) {
-            exp.ip = util_ip.toIP6Addr(exp.ip).toString();
+            exp.ip = util_ip.toIPAddr(exp.ip).toString({ format: 'v6' });
         }
 
         t.deepEqual(obj, exp, 'expected object');
@@ -189,7 +189,7 @@ function overlayMapping(t, opts, callback) {
                 log: log,
                 moray: client,
                 noCache: true,
-                vl3_ip: util_ip.toIP6Addr(nic.ip).toString(),
+                vl3_ip: util_ip.toIPAddr(nic.ip).toString({ format: 'v6' }),
                 vl3_vnet_id: vnetID
             };
 
diff --git a/test/unit/helpers.js b/test/unit/helpers.js
index 4c2275c..38edc50 100644
--- a/test/unit/helpers.js
+++ b/test/unit/helpers.js
@@ -111,11 +111,13 @@ function nextProvisionableIP(net) {
     assert.object(net, 'net');
     if (!NET_IPS.hasOwnProperty(net.uuid)) {
         assert.string(net.provision_start_ip, 'net.provision_start_ip');
-        NET_IPS[net.uuid] = util_ip.aton(net.provision_start_ip);
-        assert.number(NET_IPS[net.uuid], 'NET_IPS[net.uuid]');
+        NET_IPS[net.uuid] = util_ip.toIPAddr(net.provision_start_ip);
+        assert.ok(NET_IPS[net.uuid], 'NET_IPS[net.uuid]');
     }
 
-    return util_ip.ntoa(NET_IPS[net.uuid]++);
+    var curr = NET_IPS[net.uuid];
+    NET_IPS[net.uuid] = util_ip.ipAddrPlus(curr, 1);
+    return curr.toString();
 }
 
 
diff --git a/test/unit/ips.test.js b/test/unit/ips.test.js
index 81ca326..900a971 100644
--- a/test/unit/ips.test.js
+++ b/test/unit/ips.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -30,10 +30,10 @@ var vasync = require('vasync');
 
 
 
-var MORAY_IP = '10.0.2.15';
-var NON_MORAY_IP = '10.0.2.115';
+var MORAY_IPV4 = '10.0.2.15';
+var NON_MORAY_IPV4 = '10.0.2.115';
 var NAPI;
-var NET;
+var NETV4;
 var INVALID_PARAMS = [
     ['belongs_to_uuid', 'a', 'invalid UUID'],
     ['belongs_to_type', '', 'must not be empty'],
@@ -57,7 +57,7 @@ var MULTIPLE_PARAMS_REQ = [
 
 test('Initial setup', function (t) {
     t.plan(4);
-    var netParams = h.validNetworkParams();
+    var v4netParams = h.validNetworkParams();
 
     t.test('create client and server', function (t2) {
         h.createClientAndServer(function (err, res) {
@@ -71,23 +71,24 @@ test('Initial setup', function (t) {
 
     t.test('create nic tag', function (t2) {
 
-        NAPI.createNicTag(netParams.nic_tag, function (err) {
+        NAPI.createNicTag(v4netParams.nic_tag, function (err) {
             h.ifErr(t2, err, 'create nic tag');
             return t2.end();
         });
     });
 
-    t.test('create network', function (t2) {
-        NAPI.createNetwork(netParams, function (err, res) {
+    t.test('create v4 network', function (t2) {
+        NAPI.createNetwork(v4netParams, function (err, res) {
             h.ifErr(t2, err, 'create network');
-            NET = res;
+            NETV4 = res;
 
             return t2.end();
         });
     });
 
-    t.test('add IP to moray', function (t2) {
-        NAPI.updateIP(NET.uuid, MORAY_IP, { reserved: true }, function (err) {
+    t.test('add IPv4 address to moray', function (t2) {
+        NAPI.updateIP(NETV4.uuid, MORAY_IPV4, { reserved: true },
+            function (err) {
             h.ifErr(t2, err, 'add IP to moray');
 
             return t2.end();
@@ -100,7 +101,7 @@ test('Initial setup', function (t) {
 
 
 
-test('Get IP - non-existent network', function (t) {
+test('Get IPv4 - non-existent network', function (t) {
     NAPI.getIP(mod_uuid.v4(), '1.2.3.4', function (err, res) {
         t.ok(err, 'error returned');
         if (!err) {
@@ -118,7 +119,7 @@ test('Get IP - non-existent network', function (t) {
 });
 
 
-test('Get IP - outside subnet', function (t) {
+test('Get IPv4 - outside subnet', function (t) {
     var invalid = [
         '10.0.3.1',
         '10.0.1.255',
@@ -128,7 +129,7 @@ test('Get IP - outside subnet', function (t) {
     vasync.forEachParallel({
         inputs: invalid,
         func: function (ip, cb) {
-            NAPI.getIP(NET.uuid, ip, function (err, res) {
+            NAPI.getIP(NETV4.uuid, ip, function (err, res) {
                 t.ok(err, 'error returned: ' + ip);
                 if (!err) {
                     return cb();
@@ -149,6 +150,37 @@ test('Get IP - outside subnet', function (t) {
 });
 
 
+test('Get IPv6 - subnet has different address family', function (t) {
+    var invalid = [
+        'fd00::1',
+        'fe80::92b8:d0ff:fe4b:c73b',
+        '2001:4860:4860::8888'
+    ];
+
+    vasync.forEachParallel({
+        inputs: invalid,
+        func: function (ip, cb) {
+            NAPI.getIP(NETV4.uuid, ip, function (err, res) {
+                t.ok(err, 'error returned: ' + ip);
+                if (!err) {
+                    return cb();
+                }
+
+                t.equal(err.statusCode, 404, 'status code');
+                t.deepEqual(err.body, {
+                    code: 'ResourceNotFound',
+                    message: 'IP and subnet are of different address families'
+                }, 'Error body');
+
+                return cb();
+            });
+        }
+    }, function () {
+        return t.end();
+    });
+});
+
+
 test('Get IP - invalid', function (t) {
     var invalid = [
         'a',
@@ -158,7 +190,7 @@ test('Get IP - invalid', function (t) {
     vasync.forEachParallel({
         inputs: invalid,
         func: function (ip, cb) {
-            NAPI.getIP(NET.uuid, ip, function (err, res) {
+            NAPI.getIP(NETV4.uuid, ip, function (err, res) {
                 t.ok(err, 'error returned: ' + ip);
                 if (!err) {
                     return cb();
@@ -179,8 +211,8 @@ test('Get IP - invalid', function (t) {
 });
 
 
-test('Get IP - record not in moray', function (t) {
-    NAPI.getIP(NET.uuid, NON_MORAY_IP, function (err, obj, req, res) {
+test('Get IPv4 - record not in moray', function (t) {
+    NAPI.getIP(NETV4.uuid, NON_MORAY_IPV4, function (err, obj, req, res) {
         t.ifError(err, 'error returned');
         if (err) {
             return t.end();
@@ -188,8 +220,8 @@ test('Get IP - record not in moray', function (t) {
 
         t.equal(res.statusCode, 200, 'status code');
         t.deepEqual(obj, {
-            ip: NON_MORAY_IP,
-            network_uuid: NET.uuid,
+            ip: NON_MORAY_IPV4,
+            network_uuid: NETV4.uuid,
             reserved: false,
             free: true
         }, 'response');
@@ -199,8 +231,8 @@ test('Get IP - record not in moray', function (t) {
 });
 
 
-test('Get IP - record in moray', function (t) {
-    NAPI.getIP(NET.uuid, MORAY_IP, function (err, obj, req, res) {
+test('Get IPv4 - record in moray', function (t) {
+    NAPI.getIP(NETV4.uuid, MORAY_IPV4, function (err, obj, req, res) {
         t.ifError(err, 'error returned');
         if (err) {
             return t.end();
@@ -208,8 +240,8 @@ test('Get IP - record in moray', function (t) {
 
         t.equal(res.statusCode, 200, 'status code');
         t.deepEqual(obj, {
-            ip: MORAY_IP,
-            network_uuid: NET.uuid,
+            ip: MORAY_IPV4,
+            network_uuid: NETV4.uuid,
             reserved: true,
             free: false
         }, 'response');
@@ -262,18 +294,19 @@ test('Update IP - non-existent network', function (t) {
 });
 
 
-test('Update IP - outside subnet', function (t) {
+test('Update IPv4 - outside subnet', function (t) {
     var invalid = [
         '10.0.3.1',
         '10.0.1.255',
         '32',
+        '0.0.0.0',
         '8.8.8.8'
     ];
 
     vasync.forEachParallel({
         inputs: invalid,
         func: function (ip, cb) {
-            NAPI.updateIP(NET.uuid, ip, { reserved: true },
+            NAPI.updateIP(NETV4.uuid, ip, { reserved: true },
                 function (err, res) {
                 t.ok(err, 'error returned: ' + ip);
                 if (!err) {
@@ -304,7 +337,7 @@ test('Update IP - invalid', function (t) {
     vasync.forEachParallel({
         inputs: invalid,
         func: function (ip, cb) {
-            NAPI.updateIP(NET.uuid, ip, { reserved: true },
+            NAPI.updateIP(NETV4.uuid, ip, { reserved: true },
                 function (err, res) {
                 t.ok(err, 'error returned: ' + ip);
                 if (!err) {
@@ -332,7 +365,7 @@ test('Update IP - invalid params (IP not in moray)', function (t) {
         func: function (data, cb) {
             var params = h.validIPparams();
             params[data[0]] = data[1];
-            NAPI.updateIP(NET.uuid, '10.0.2.14', params, function (err, res) {
+            NAPI.updateIP(NETV4.uuid, '10.0.2.14', params, function (err, res) {
                 t.ok(err, util.format('error returned: %s="%s"',
                     data[0], data[1]));
                 if (!err) {
@@ -363,7 +396,7 @@ test('Update IP - invalid params (IP in moray)', function (t) {
         func: function (data, cb) {
             var params = h.validIPparams();
             params[data[0]] = data[1];
-            NAPI.updateIP(NET.uuid, MORAY_IP, params, function (err2) {
+            NAPI.updateIP(NETV4.uuid, MORAY_IPV4, params, function (err2) {
                 t.ok(err2, util.format('error returned: %s="%s"',
                     data[0], data[1]));
                 if (!err2) {
@@ -397,7 +430,7 @@ test('Update IP - invalid param combinations (IP not in moray)', function (t) {
     vasync.forEachParallel({
         inputs: MULTIPLE_PARAMS_REQ,
         func: function (params, cb) {
-            NAPI.updateIP(NET.uuid, '10.0.2.4', params, function (err, res) {
+            NAPI.updateIP(NETV4.uuid, '10.0.2.4', params, function (err, res) {
                 t.ok(err, 'error returned: ' + JSON.stringify(params));
                 if (!err) {
                     return cb();
@@ -428,7 +461,7 @@ test('Update IP - invalid param combinations (IP in moray)', function (t) {
     vasync.forEachParallel({
         inputs: MULTIPLE_PARAMS_REQ,
         func: function (params, cb) {
-            NAPI.updateIP(NET.uuid, MORAY_IP, params, function (err, res) {
+            NAPI.updateIP(NETV4.uuid, MORAY_IPV4, params, function (err, res) {
                 t.ok(err, 'error returned: ' + JSON.stringify(params));
                 if (!err) {
                     return cb();
@@ -456,7 +489,7 @@ test('Update IP - invalid param combinations (IP in moray)', function (t) {
 
 test('Update IP - both missing and invalid params (IP not in moray)',
     function (t) {
-    NAPI.updateIP(NET.uuid, '10.0.2.4', { belongs_to_uuid: 'asdf' },
+    NAPI.updateIP(NETV4.uuid, '10.0.2.4', { belongs_to_uuid: 'asdf' },
         function (err, res) {
         t.ok(err, 'error returned');
         if (!err) {
@@ -478,7 +511,7 @@ test('Update IP - both missing and invalid params (IP not in moray)',
 
 
 test('Update IP - both missing and invalid params (IP in moray)', function (t) {
-    NAPI.updateIP(NET.uuid, MORAY_IP, { belongs_to_uuid: 'asdf' },
+    NAPI.updateIP(NETV4.uuid, MORAY_IPV4, { belongs_to_uuid: 'asdf' },
         function (err, res) {
         t.ok(err, 'error returned');
         if (!err) {
@@ -511,10 +544,10 @@ test('Update IP - valid param combinations (IP in moray)', function (t) {
         reserved: true
     };
 
-    NAPI.updateIP(NET.uuid, '10.0.2.25', ipParams, function (err, ipRes) {
+    NAPI.updateIP(NETV4.uuid, '10.0.2.25', ipParams, function (err, ipRes) {
         t.ifError(err);
         ipParams.free = false;
-        ipParams.network_uuid = NET.uuid;
+        ipParams.network_uuid = NETV4.uuid;
 
         t.deepEqual(ipRes, ipParams, 'response');
 
@@ -525,7 +558,7 @@ test('Update IP - valid param combinations (IP in moray)', function (t) {
         vasync.forEachPipeline({
             'inputs': updateList,
             'func': function (params, cb) {
-                NAPI.updateIP(NET.uuid, '10.0.2.25', params,
+                NAPI.updateIP(NETV4.uuid, '10.0.2.25', params,
                     function (err2, obj, req, res) {
                     if (h.ifErr(t, err2, 'update IP')) {
                         cb();
@@ -566,7 +599,7 @@ test('Update IP - valid param combinations (IP not in moray)', function (t) {
         'func': function (updateData, cb) {
             var ip = '10.0.2.22' + i;
 
-            NAPI.updateIP(NET.uuid, ip, updateData,
+            NAPI.updateIP(NETV4.uuid, ip, updateData,
                 function (err, obj, req, res) {
                 if (h.ifErr(t, err, 'update IP')) {
                     t.deepEqual(err.body, {}, 'error body: ' +
@@ -580,7 +613,7 @@ test('Update IP - valid param combinations (IP not in moray)', function (t) {
                 updateData.free =
                     updateData.hasOwnProperty('reserved') ? true : false;
                 updateData.reserved = false;
-                updateData.network_uuid = NET.uuid;
+                updateData.network_uuid = NETV4.uuid;
                 updateData.ip = ip;
                 t.deepEqual(obj, updateData, 'Response');
 
@@ -602,10 +635,10 @@ test('Update IP - free (IP in moray)', function (t) {
         reserved: true
     };
 
-    NAPI.updateIP(NET.uuid, '10.0.2.55', params, function (err) {
+    NAPI.updateIP(NETV4.uuid, '10.0.2.55', params, function (err) {
         t.ifError(err);
 
-        NAPI.updateIP(NET.uuid, '10.0.2.55', { free: 'true' },
+        NAPI.updateIP(NETV4.uuid, '10.0.2.55', { free: 'true' },
             function (err2, obj, req, res) {
             t.ifError(err2);
             if (err2) {
@@ -617,7 +650,7 @@ test('Update IP - free (IP in moray)', function (t) {
             t.deepEqual(obj, {
                 free: true,
                 ip: '10.0.2.55',
-                network_uuid: NET.uuid,
+                network_uuid: NETV4.uuid,
                 reserved: false
             }, 'Response');
 
@@ -628,7 +661,7 @@ test('Update IP - free (IP in moray)', function (t) {
 
 
 test('Update IP - free (IP not in moray)', function (t) {
-    NAPI.updateIP(NET.uuid, '10.0.2.4', { free: 'true' },
+    NAPI.updateIP(NETV4.uuid, '10.0.2.4', { free: 'true' },
         function (err, obj, req, res) {
         t.ifError(err);
         if (err) {
@@ -640,7 +673,7 @@ test('Update IP - free (IP not in moray)', function (t) {
         t.deepEqual(obj, {
             free: true,
             ip: '10.0.2.4',
-            network_uuid: NET.uuid,
+            network_uuid: NETV4.uuid,
             reserved: false
         }, 'Response');
 
@@ -649,17 +682,17 @@ test('Update IP - free (IP not in moray)', function (t) {
 });
 
 
-test('Update IP - unassign (IP in moray)', function (t) {
+test('Update IPv4 - unassign (IP in moray)', function (t) {
     var params = {
         belongs_to_type: 'server',
         belongs_to_uuid: mod_uuid.v4(),
         owner_uuid: mod_uuid.v4()
     };
 
-    NAPI.updateIP(NET.uuid, '10.0.2.34', params, function (err) {
+    NAPI.updateIP(NETV4.uuid, '10.0.2.34', params, function (err) {
         t.ifError(err);
 
-        NAPI.updateIP(NET.uuid, '10.0.2.34', { unassign: 'true' },
+        NAPI.updateIP(NETV4.uuid, '10.0.2.34', { unassign: 'true' },
             function (err2, obj, req, res) {
             t.ifError(err2);
             if (err2) {
@@ -671,7 +704,7 @@ test('Update IP - unassign (IP in moray)', function (t) {
             t.deepEqual(obj, {
                 ip: '10.0.2.34',
                 free: false,
-                network_uuid: NET.uuid,
+                network_uuid: NETV4.uuid,
                 owner_uuid: params.owner_uuid,
                 reserved: false
             }, 'Response');
@@ -682,8 +715,8 @@ test('Update IP - unassign (IP in moray)', function (t) {
 });
 
 
-test('Update IP - unassign (IP not in moray)', function (t) {
-    NAPI.updateIP(NET.uuid, '10.0.2.35', { unassign: 'true' },
+test('Update IPv4 - unassign (IP not in moray)', function (t) {
+    NAPI.updateIP(NETV4.uuid, '10.0.2.35', { unassign: 'true' },
         function (err, obj, req, res) {
         t.ifError(err);
         if (err) {
@@ -695,7 +728,7 @@ test('Update IP - unassign (IP not in moray)', function (t) {
         t.deepEqual(obj, {
             ip: '10.0.2.35',
             free: true,
-            network_uuid: NET.uuid,
+            network_uuid: NETV4.uuid,
             reserved: false
         }, 'Response');
 
@@ -706,21 +739,21 @@ test('Update IP - unassign (IP not in moray)', function (t) {
 
 // --- List Tests
 
-function testIPList(t, opts, callback) {
+function testIPv4List(t, opts, callback) {
     assert.object(t, 't');
     opts.type = 'ip';
     opts.reqType = 'list';
-    NAPI.listIPs(NET.uuid, opts.params,
+    NAPI.listIPs(NETV4.uuid, opts.params,
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
-test('Listing IP failures', function (t) {
+test('Listing IPv4 failures', function (t) {
     t.plan(common.badLimitOffTests.length);
 
      for (var i = 0; i < common.badLimitOffTests.length; i++) {
         var blot = common.badLimitOffTests[i];
         t.test(blot.bc_name, function (t2) {
-            testIPList(t2, {
+            testIPv4List(t2, {
                 params: blot.bc_params,
                 expCode: blot.bc_expcode,
                 expErr: blot.bc_experr
diff --git a/test/unit/nics.test.js b/test/unit/nics.test.js
index 36e9dae..457fa8d 100644
--- a/test/unit/nics.test.js
+++ b/test/unit/nics.test.js
@@ -134,7 +134,7 @@ test('Initial setup', function (t) {
 
     t.test('create mac provision network', function (t2) {
         num = h.NET_NUM;
-        var params = h.validNetworkParams({ name: 'admin' });
+        var params = h.validNetworkParams();
         mod_net.create(t2, {
             params: params,
             partialExp: params
diff --git a/test/unit/util-ip.test.js b/test/unit/util-ip.test.js
index a0e42af..2eab28f 100644
--- a/test/unit/util-ip.test.js
+++ b/test/unit/util-ip.test.js
@@ -55,6 +55,9 @@ test('addressToNumber - invalid', function (t) {
 
 test('bitsToNetmask / netmaskToBits', function (t) {
     var bits = {
+        '0': '0.0.0.0',
+        '1': '128.0.0.0',
+        '2': '192.0.0.0',
         '8': '255.0.0.0',
         '16': '255.255.0.0',
         '24': '255.255.255.0',
@@ -172,8 +175,23 @@ test('ipAddrPlus / ipAddrMinus', function (t) {
 
 
 test('ipAddrPlus / ipAddrMinus - overflow, underflow', function (t) {
-    var over = [
+    var largeOffsets = [
         ['0.0.0.0', 4294967296],
+        ['0.0.0.0', -4294967296],
+        ['255.255.255.255', 4294967296],
+        ['255.255.255.255', -4294967296]
+    ];
+
+    largeOffsets.forEach(function (terms) {
+        var ip = IP.toIPAddr(terms[0]);
+        var scalar = terms[1];
+        t.throws(function () {
+            IP.ipAddrPlus(ip, scalar);
+        }, /offsets should be between -4294967295 and 4294967295/,
+        util.format('%s + %d overflows', ip, scalar));
+    });
+
+    var over = [
         ['255.255.255.255', 1],
         ['ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff', 1]
     ];
@@ -187,7 +205,6 @@ test('ipAddrPlus / ipAddrMinus - overflow, underflow', function (t) {
     });
 
     var under = [
-        ['255.255.255.255', 4294967296],
         ['0.0.0.0', 1],
         ['::0', 1]
     ];
-- 
2.21.0

