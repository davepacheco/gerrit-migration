From 74a081d11952b196daf9aa4228fcada3a54f8e1b Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Thu, 5 Jul 2018 15:13:04 -0500
Subject: [PATCH] Fix removal of VL3 entries on unattach

---
 .../uts/common/io/overlay/overlay_target.c    | 140 +++++++-----------
 1 file changed, 51 insertions(+), 89 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 45ad86df06..66bb918ee3 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -2230,20 +2230,49 @@ overlay_in6_to_subnet(const struct in6_addr *src, struct in6_addr *dst,
 }
 
 /*
- * Take an IPv6 address + prefix length, and turn it into the last address
- * within that subnet.  E.g. ::ffff:10.0.21.12/120 -> ::ffff:10.0.21.255
+ * Find the first target entry whose source IP falls within the source subnet
+ * given by otcne.  If no entries match, NULL is returned.
  */
-static void
-overlay_in6_to_lastaddr(const struct in6_addr *src, struct in6_addr *dst,
-    uint8_t prefixlen)
+static overlay_target_entry_t *
+overlay_target_cache_first_net(overlay_target_t *ott,
+    const overlay_targ_cache_net_entry_t *otcne)
 {
-	uint32_t val;
+	avl_tree_t *avl;
+	overlay_target_entry_t *ote;
+	struct in6_addr *start;
+	overlay_target_entry_t cmp = { 0 };
+	avl_index_t where = { 0 };
 
-	for (size_t i = 0; i < 4; i++) {
-		val = ntohl(src->_S6_un._S6_u32[i]);
-		val |= ~IN6_MASK_FROM_PREFIX(i, prefixlen);
-		dst->_S6_un._S6_u32[i] = htonl(val);
-	}
+	ASSERT(MUTEX_HELD(&ott->ott_lock));
+
+	avl = &ott->ott_u.ott_dyn.ott_l3tree;
+	start = &cmp.ote_u.ote_vl3.otvl3_src;
+
+	/*
+	 * We never store target entries containing the network address
+	 * (e.g. for 192.168.10.0/24, 192.168.10.0 should never appear as
+	 * a source or target IP).  However, the network address will
+	 * compare less than any entries within the subnet.  If there are any
+	 * entries in the L3 tree whose source IP is within that subnet, they
+	 * will start with the first entry after where the network address
+	 * would exist in the tree.
+	 */
+	overlay_in6_to_subnet(&otcne->otcne_src, start,
+	    otcne->otcne_src_prefixlen);
+
+	VERIFY3P(avl_find(avl, &cmp, &where), ==, NULL);
+	ote = avl_nearest(avl, where, AVL_BEFORE);
+
+	if (ote == NULL)
+		ote = avl_first(avl);
+	else
+		ote = AVL_NEXT(avl, ote);
+
+	if (!IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_src,
+	    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen))
+		return (NULL);
+
+	return (ote);
 }
 
 /* ARGSUSED */
@@ -2256,8 +2285,6 @@ overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
 	overlay_target_t *ott = NULL;
 	overlay_target_entry_t *ote = NULL, *ote_next = NULL;
 	avl_tree_t *avl = NULL;
-	avl_index_t where = { 0 };
-	overlay_target_entry_t cmp = { 0 };
 
 	odd = overlay_hold_by_dlid(otcn->otcn_linkid);
 	if (odd == NULL)
@@ -2278,94 +2305,29 @@ overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
 	mutex_enter(&ott->ott_lock);
 	mutex_exit(&odd->odd_lock);
 
-	/*
-	 * Entries are sorted in the AVL tree by src ip, dst ip, src vlan.
-	 * To find the entries to delete, we search for the source subnet (w
-	 * use the prefix length to guarantee we have a network address) with
-	 * the dst ip and src vlan fields set to 0 (cmp is initialized to 0).
-	 * Since we do not store network addresses as entries, this should fail,
-	 * By noting the location where such an entry would reside, the nearest
-	 * neighbor prior to that location will be the entry that immediately
-	 * preceeds any possible entries in the source subnet.  We use that
-	 * entry to skip into the tree as close to any entries that need to
-	 * be removed as we can.  However there might be entries with a
-	 * destination subnet that is less than (as a bytewise comparison)
-	 * the subnet we are interested in.  Similarly, as we could have
-	 * duplicate src subnet values but with different vlan values.  We
-	 * skip past any entries whose destination ip is less than (as a
-	 * per-byte comparison) the destination subnet we're interested as
-	 * well as any entries whose source subnet is less than the one we're
-	 * interested in.  Once we reach any entries whose src ip doesn't match,
-	 * or whose dst ip is greater than the last IP in the subnet, or whose
-	 * src vlan is not the one we're interested in, we are past where any
-	 * possible matching entries can reside, and can stop iterating through
-	 * the tree.
-	 */
 	avl = &ott->ott_u.ott_dyn.ott_l3tree;
-	overlay_in6_to_subnet(&otcne->otcne_src, &cmp.ote_u.ote_vl3.otvl3_src,
-	    otcne->otcne_src_prefixlen);
-	VERIFY3P(avl_find(avl, &cmp, &where), ==, NULL);
 
-	ote = avl_nearest(avl, where, AVL_BEFORE);
-	if (ote == NULL)
-		ote = avl_first(avl);
-	else
-		ote = AVL_NEXT(avl, ote);
-
-	overlay_in6_to_lastaddr(&otcne->otcne_dst, &cmp.ote_u.ote_vl3.otvl3_dst,
-	    otcne->otcne_dst_prefixlen);
-	cmp.ote_u.ote_vl3.otvl3_src_vlan = otcne->otcne_vlan;
-
-#define	IN_RANGE(_cmp, _ote)						\
-    ((memcmp(&(_cmp)->ote_u.ote_vl3.otvl3_src,				\
-    &(_ote)->ote_u.ote_vl3.otvl3_src,					\
-    sizeof (struct in6_addr)) < 0) &&					\
-    (memcmp(&(_cmp)->ote_u.ote_vl3.otvl3_dst,				\
-    &(_ote)->ote_u.ote_vl3.otvl3_dst,					\
-    sizeof (struct in6_addr)) >= 0) &&					\
-    (_ote)->ote_u.ote_vl3.otvl3_src_vlan <=				\
-    (_cmp)->ote_u.ote_vl3.otvl3_src_vlan)
-
-	for (; ote != NULL && IN_RANGE(&cmp, ote); ote = ote_next) {
+	for (ote = overlay_target_cache_first_net(ott, otcne);
+	    ote != NULL && IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_src,
+	    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen);
+	    ote = ote_next) {
 		ote_next = AVL_NEXT(avl, ote);
 
 		/*
-		 * Since entries are ordered first by src address, once we
-		 * see entries not in the subnet, there are no further entries
-		 * to remove.
+		 * Entries are sorted by src ip, dst ip, src vlan, there can
+		 * be entries from this src ip to destinations on other
+		 * subnets besides the one we are removing that will need to
+		 * be skipped over.
 		 */
-		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&cmp.ote_u.ote_vl3.otvl3_src,
-		    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen))
-			break;
-
-		/*
-		 * IN_RANGE() guarantees that the dst ip is <= the last IP
-		 * in the subnet we are interested in.  If it's not within
-		 * the subnet, it means we haven't reached any potential
-		 * entries yet.
-		 */
-		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&cmp.ote_u.ote_vl3.otvl3_dst,
-		    &ote->ote_u.ote_vl3.otvl3_dst,
-		    otcne->otcne_dst_prefixlen)) {
-			ASSERT3S(memcmp(&cmp.ote_u.ote_vl3.otvl3_dst,
-			    &ote->ote_u.ote_vl3.otvl3_dst,
-			    sizeof (struct in6_addr)), <, 0);
+		if (ote->ote_u.ote_vl3.otvl3_src_vlan != otcne->otcne_vlan)
 			continue;
-		}
 
-		if (ote->ote_u.ote_vl3.otvl3_src_vlan < otcne->otcne_vlan)
+		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_dst,
+		    &ote->ote_u.ote_vl3.otvl3_dst, otcne->otcne_dst_prefixlen))
 			continue;
 
-		ASSERT(IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_src,
-		    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen));
-		ASSERT(IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_dst,
-		    &ote->ote_u.ote_vl3.otvl3_dst, otcne->otcne_dst_prefixlen));
-		ASSERT3U(ote->ote_u.ote_vl3.otvl3_src_vlan, ==,
-		    otcne->otcne_vlan);
-
 		sarc_remove(ott->ott_u.ott_dyn.ott_l3dhash, ote);
 	}
-#undef	IN_RANGE
 
 	mutex_exit(&ott->ott_lock);
 	overlay_hold_rele(odd);
-- 
2.21.0

