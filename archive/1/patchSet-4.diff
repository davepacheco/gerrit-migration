From 70eea9a3cec24c2efaa5d7017cf037a1d77ee7a6 Mon Sep 17 00:00:00 2001
From: Dave Pacheco <dap@joyent.com>
Date: Tue, 14 Jun 2016 16:53:11 -0700
Subject: [PATCH] arekinath/node-cueball#4 add support for static IP resolvers

---
 Makefile                     |   2 +-
 README.md                    | 160 +++++++++++++++-
 bin/cbresolve                | 351 +++++++++++++++++++++++++++++++++++
 lib/index.js                 |   2 +
 lib/pool.js                  |  50 +++--
 lib/resolver.js              | 237 +++++++++++++++++++++--
 package.json                 |   7 +-
 test/resolver_for.test.js    | 232 +++++++++++++++++++++++
 test/resolver_static.test.js | 159 ++++++++++++++++
 9 files changed, 1168 insertions(+), 32 deletions(-)
 create mode 100755 bin/cbresolve
 create mode 100644 test/resolver_for.test.js
 create mode 100644 test/resolver_static.test.js

diff --git a/Makefile b/Makefile
index c4788b3..1bbc681 100644
--- a/Makefile
+++ b/Makefile
@@ -25,7 +25,7 @@ include ./tools/mk/Makefile.defs
 #
 DOC_FILES	 = index.md boilerplateapi.md
 JSON_FILES	 = package.json
-JS_FILES	:= $(shell find lib test -name '*.js')
+JS_FILES	:= bin/cbresolve $(shell find lib test -name '*.js')
 JSL_FILES_NODE	 = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 
diff --git a/README.md b/README.md
index b1f9795..c491a72 100644
--- a/README.md
+++ b/README.md
@@ -84,14 +84,16 @@ Parameters
 
 ### `new mod_cueball.ConnectionPool(options)`
 
-Creates a new pool of connections.
+Creates a new pool of connections.  There are two ways of using a
+ConnectionPool.  You can either provide your own resolver directly, or provide
+parameters with which to create the default, DNS-based resolver.
 
 Parameters
 
 - `options` -- Object, with keys:
   - `constructor` -- Function(backend) -> object, must open a new connection 
     to the given backend and return it
-  - `domain` -- String, name to look up to find backends
+  - `domain` -- String, name to look up to find backends.
   - `recovery` -- Object, a recovery spec (see below)
   - `service` -- optional String, name of SRV service (e.g. `_http._tcp`)
   - `defaultPort` -- optional Number, port to use for plain A/AAAA records
@@ -107,6 +109,21 @@ Parameters
     running `checker` on a connection
   - `checker` -- optional Function(handle, connection), to be run on idle
     connections
+  - `resolver` -- optional instance of an object meeting the Resolver interface
+    below.  You would typically obtain this object by either creating your own
+    Resolver directly or using the `resolverForIpOrDomain` function.
+
+Do not confuse `resolvers` (the list of IP addresses for the DNS resolvers to
+contact) with `resolver` (a custom object meeting the Resolver interface below).
+
+If you want to use a custom resolver, then you must specify the `resolver`
+property.  In that case, the `resolvers`, `maxDNSConcurrency`, `defaultPort`,
+and `recovery` options are ignored, and the `domain` and `service` properties
+are used only for logging.
+
+Otherwise, if want to use the default DNS-based resolver, do not specify the
+`resolver` property.  A resolver instance will be created based on the other
+configuration properties.
 
 ### `ConnectionPool#stop()`
 
@@ -149,7 +166,7 @@ Returns an Object with keys:
  - `handle` -- Object, handle to be used to release the connection
  - `connection` -- Object, actual connection
 
-## Resolver
+## DNS-based Resolver
 
 ### `new mod_cueball.Resolver(options)`
 
@@ -199,6 +216,95 @@ Emitted when an existing backend has been removed from DNS.
 Parameters
  - `key` -- String, unique key for this backend
 
+## Static IP resolver
+
+### `new mod_cueball.StaticIpResolver(options)`
+
+Creates a new static IP resolver.  This object matches the Resolver interface
+above, but emits a fixed list of IP addresses when started.  This list never
+changes.  This is intended for development environments and debugging tools,
+where a user may have provided an explicit IP address rather than a DNS name to
+contact.  See also: `resolverForIpOrDomain()`.
+
+Parameters
+
+- `options` -- Object, with keys:
+  - `backends` -- Array of objects, each having properties:
+    - `address` -- String, an IP address to emit as a backend
+    - `port` -- Number, a port number for this backend
+
+This object provides the same `start()` and `stop()` methods as the Resolver
+class, as well as the same `added` and `removed` events.
+
+## Picking the right resolver
+
+### `resolverForIpOrDomain(options)`
+
+Services that use DNS for service discovery would typically use a DNS-based
+resolver.  But in development environments or with debugging tools, it's useful
+to be able to point a cueball-using program at an instance located at a specific
+IP address and port.  That's what the Static IP resolver is for.
+
+To make this easy for programs that want to support connecting to either
+hostnames or IP addresses, this function is provided to take configuration
+(expected to come from a user, via an environment variable, command-line
+option, or other configuration source), determine whether an IP address or DNS
+name was specified, and return either a DNS-based or static resolver.  If the
+input appears to be neither a valid IPv4 nor IPv6 address nor DNS name, or the
+port number is not valid, then an Error is returned (not thrown).  (If the
+input is missing or has the wrong type, an Error object is thrown, since this
+is a programmer error.)
+
+Parameters
+
+- `options` -- Object, with keys:
+  - `input` -- String, either an IP address or DNS name, with optional port
+    suffix
+  - `resolverConfig` -- Object, a set of additional properties to pass to
+    the resolver constructor.
+
+The `input` string has the form `HOSTNAME[:PORT]`, where the `[:PORT]` suffix is
+optional, and `HOSTNAME` may be either an IP address or DNS name.
+
+**Example:** create a resolver that will emit one backend for an instance at IP
+127.0.0.1 port 2020:
+
+    var resolver = mod_cueball.resolverForIpOrDomain({
+        'input': '127.0.0.1:2020',
+        'resolverConfig': {
+            'recovery': {
+                'default': {
+                    'retries': 1,
+                    'timeout': 1000,
+                    'delay': 1000,
+                    'maxDelay': 1000
+                }
+            }
+        }
+    })
+    /* check whether resolver is an Error */
+
+**Example:** create a resolver that will track instances associated with DNS
+name `mydomain.example.com`:
+
+    var resolver = mod_cueball.resolverForIpOrDomain({
+        'input': 'mydomain.example.com',
+        'resolverConfig': {
+            'recovery': {
+                'default': {
+                    'retries': 1,
+                    'timeout': 1000,
+                    'delay': 1000,
+                    'maxDelay': 1000
+                }
+            }
+        }
+    });
+    /* check whether resolver is an Error */
+
+In these examples, the `input` string is assumed to come from a user
+cueball does the expected thing when given an IP address or DNS name.
+
 ## Errors
 
 ### `ClaimTimeoutError`
@@ -284,6 +390,7 @@ And the available operations:
 
 If a given operation has no specification given, it will use `default` instead.
 
+
 Dynamic Resolver mode
 ---------------------
 
@@ -333,3 +440,50 @@ When the TTL expires on the records for `binder.coal.joyent.us`, we will use
 the records from the previous lookup as the list of nameservers to query in
 order to find out what the new records should be. Then, we will use any new
 nameservers we find for the next `napi.coal.joyent.us` lookup as well.
+
+
+Tools
+-----
+
+The `cbresolve` tool is provided to show how cueball would resolve a given
+configuration.  The output format is not committed.  It may change in the
+future.
+
+    usage: cbresolve HOSTNAME[:PORT]                # for DNS-based lookup
+           cbresolve -S | --static IP[:PORT]...     # for static IPs
+    Locate services in DNS using Cueball resolver.
+
+    The following options are available for DNS-based lookups:
+    
+        -f, --follow                periodically re-resolve and report changes
+        -p, --port PORT             default backend port
+        -r, --resolvers IP[,IP...]  list of DNS resolvers
+        -s, --service SERVICE       "service" name (for SRV)
+        -t, --timeout TIMEOUT       timeout for lookups
+    
+**Example:** resolve DNS name "1.moray.us-east.joyent.us":
+
+    $ cbresolve 1.moray.emy-10.joyent.us
+    domain: 1.moray.emy-10.joyent.us
+    timeout: 5000 milliseconds
+    172.27.10.218       80 lLbminikNKjfy+iwDobYBuod7Hs=
+    172.27.10.219       80 iJMaVRehJ2zKfiS55H/lUUFPb9o=
+
+**Example:** resolve IP/port "127.0.0.1:2020".  This is only useful for seeing
+how cueball would parse your input:
+
+    $ cbresolve --static 127.0.0.1:2020
+    using static IP resolver
+    127.0.0.1         2020 xBut/f1D52k1TpDN/miW82qXw6k=
+
+**Example: resolve DNS name "1.moray.us-east.joyent.us" and watch for changes:
+
+    $ cbresolve --follow 1.moray.emy-10.joyent.us
+    domain: 1.moray.emy-10.joyent.us
+    timeout: 5000 milliseconds
+    2016-06-23T00:45:00.312Z added      172.27.10.218:80    (lLbminikNKjfy+iwDobYBuod7Hs=)
+    2016-06-23T00:45:00.314Z added      172.27.10.219:80    (iJMaVRehJ2zKfiS55H/lUUFPb9o=)
+    2016-06-23T00:49:00.478Z removed    172.27.10.218:80    (lLbminikNKjfy+iwDobYBuod7Hs=)
+
+In this example, one of the DNS entries was removed a few minutes after the
+program was started.
diff --git a/bin/cbresolve b/bin/cbresolve
new file mode 100755
index 0000000..0931766
--- /dev/null
+++ b/bin/cbresolve
@@ -0,0 +1,351 @@
+#!/usr/bin/env node
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+const mod_assert = require('assert-plus');
+const mod_bunyan = require('bunyan');
+const mod_cmdutil = require('cmdutil');
+const mod_cueball = require('..');
+const mod_extsprintf = require('extsprintf');
+const mod_getopt = require('posix-getopt');
+const mod_net = require('net');
+const mod_verror = require('verror');
+const mod_util = require('util');
+
+const VError = mod_verror.VError;
+const printf = mod_extsprintf.printf;
+
+var cbrForceStatic = false;
+var cbrFollow = false;
+var cbrBackends = {};
+var cbrNbackends = 0;
+var cbrDone = false;
+var cbrLog;
+var cbrResolver;
+
+function main()
+{
+	var optstr, parser, option, args;
+	var timeout, resolverConf;
+
+	resolverConf = {};
+	timeout = 5000;
+
+	mod_cmdutil.configure({
+	    'synopses': [
+		'HOSTNAME[:PORT]                # for DNS-based lookup',
+		'-S | --static IP[:PORT]...     # for static IPs'
+	    ],
+
+	    'usageMessage': [
+	        'Locate services in DNS using Cueball resolver.',
+		'',
+		'The following options are available for DNS-based lookups:',
+		'',
+		'    -f, --follow                periodically re-resolve ' +
+		'and report changes',
+		'    -p, --port PORT             default backend port',
+		'    -r, --resolvers IP[,IP...]  list of DNS resolvers',
+		'    -s, --service SERVICE       "service" name (for SRV)',
+		'    -t, --timeout TIMEOUT       timeout for lookups',
+		''
+	    ].join('\n')
+	});
+
+	/*
+	 * By default, we don't log anything, but users can enable logging by
+	 * setting LOG_LEVEL in the environment.
+	 */
+	cbrLog = new mod_bunyan({
+	    'name': 'cbresolve',
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	optstr = [
+	    /* general options */
+	    'S(static)',
+
+	    /* DNS-specific options */
+	    'f(follow)',
+	    'p:(port)',
+	    'r:(resolvers)',
+	    's:(service)',
+	    't:(timeout)'
+	].join('');
+	parser = new mod_getopt.BasicParser(optstr, process.argv);
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+		case 'S':
+			cbrForceStatic = true;
+			break;
+
+		case 'f':
+			cbrFollow = true;
+			break;
+
+		case 'p':
+			resolverConf['defaultPort'] =
+			    parseInt(option.optarg, 10);
+			if (isNaN(resolverConf['defaultPort']) ||
+			    resolverConf['defaultPort'] < 0 ||
+			    resolverConf['defaultPort'] > 65535) {
+				mod_cmdutil.usage('bad value for -p/--port: %s',
+				    option.optarg);
+			}
+			break;
+
+		case 'r':
+			if (!resolverConf.hasOwnProperty('resolvers')) {
+				resolverConf['resolvers'] = [];
+			}
+
+			option.optarg.split(',').forEach(function (ip) {
+				if (ip.length === 0) {
+					return;
+				}
+
+				resolverConf['resolvers'].push(ip);
+			});
+			break;
+
+		case 's':
+			resolverConf['service'] = option.optarg;
+			break;
+
+		case 't':
+			timeout = parseTimeInterval(option.optarg);
+			if (timeout instanceof Error) {
+				mod_cmdutil.usage(timeout);
+			}
+			break;
+
+		default:
+			/* error message already emitted */
+			mod_cmdutil.usage();
+			break;
+		}
+	}
+
+	args = process.argv.slice(parser.optind());
+	resolverConf['log'] = cbrLog;
+	if (cbrForceStatic) {
+		resolverConf['backends'] = args.map(function (pair) {
+			var parsed = parseIpPort(pair);
+
+			if (parsed instanceof Error) {
+				mod_cmdutil.usage(parsed);
+			}
+
+			return (parsed);
+		});
+
+		if (resolverConf['backends'].length === 0) {
+			mod_cmdutil.usage();
+		}
+
+		console.error('using static IP resolver');
+
+		if (resolverConf['service'] !== undefined ||
+		    resolverConf['defaultPort'] !== undefined ||
+		    resolverConf['resolvers'] !== undefined) {
+			console.error('note: the -s/--service, -p/--port, ' +
+			    'and -r/--resolvers options are not used with ' +
+			    '-S/--static.');
+		}
+
+		cbrResolver = new mod_cueball.StaticIpResolver(resolverConf);
+	} else {
+		if (args.length != 1) {
+			mod_cmdutil.usage();
+		}
+
+		console.error('domain: %s', args[0]);
+		console.error('timeout: %s millisecond%s', timeout,
+		    timeout == 1 ? '' : 's');
+
+		if (resolverConf['service'] !== undefined) {
+			console.error('service: %s',
+			    resolverConf['service']);
+		}
+
+		if (resolverConf['defaultPort'] !== undefined) {
+			console.error('port: %s',
+			    resolverConf['defaultPort']);
+		}
+
+		if (resolverConf['resolvers'] !== undefined) {
+			console.error('resolvers: %s',
+			    resolverConf['resolvers'].join(', '));
+		}
+
+		resolverConf['recovery'] = {
+		    'default': {
+			'retries': 0,
+			'timeout': timeout,
+			'maxTimeout': timeout,
+			'delay': 0,
+			'maxDelay': 0
+		    }
+		};
+
+		cbrResolver = mod_cueball.resolverForIpOrDomain({
+		    'input': args[0],
+		    'resolverConfig': resolverConf
+		});
+
+		if (cbrResolver instanceof Error) {
+			mod_cmdutil.usage(cbrResolver);
+		}
+	}
+
+	cbrResolver.start();
+	cbrResolver.on('added', cbrPrintAdded);
+	cbrResolver.on('removed', cbrPrintRemoved);
+
+	if (!cbrFollow) {
+		cbrResolver.on('updated', cbrUpdated);
+		process.on('exit', function (code) {
+			if (code === 0) {
+				mod_assert.ok(cbrDone, 'premature exit');
+			}
+		});
+	} else {
+		if (cbrForceStatic) {
+			mod_cmdutil.fail('-f/--follow cannot be used with ' +
+			    '-S/--static');
+		}
+
+		/*
+		 * XXX It's not ideal that cueball unref's its timer here.
+		 * This is the maximum allowed timeout value, according to the
+		 * MDN documentation.
+		 */
+		setInterval(function () {}, Math.pow(2, 31) - 1);
+	}
+}
+
+/*
+ * Given a string of the from "IP_ADDRESS:PORT", returns either:
+ *
+ *    o an object with properties "address" (a valid IP address, as a string)
+ *      and "port" (an integer), if the string has the expected form; or
+ *
+ *    o an error indicating that the string does not have the expected form
+ */
+function parseIpPort(str)
+{
+	var colon, ip, port;
+
+	mod_assert.string(str, 'str');
+	colon = str.lastIndexOf(':');
+	if (colon == -1) {
+		return (new VError('not an "IP:port" pair: %s', str));
+	}
+
+	ip = str.substr(0, colon);
+	port = parseInt(str.substr(colon + 1), 10);
+	if (!mod_net.isIP(ip) || isNaN(port)) {
+		return (new VError('not an "IP:port pair: %s"', str));
+	}
+
+	return ({
+	    'address': ip,
+	    'port': port
+	});
+}
+
+/*
+ * Given a string describing a time interval, return the corresponding number of
+ * milliseconds.  Time intervals consist of a non-negative integer followed by
+ * one of the suffixes "ms" (for milliseconds), "s" (for seconds), or "m" (for
+ * minutes).  The suffix can be omitted, in which case the unit is milliseconds.
+ * If the given string is invalid, an Error is returned.
+ */
+function parseTimeInterval(str)
+{
+	var match, ret;
+
+	match = str.match(/^([1-9][0-9]*)(s|ms|m)?$/);
+	if (match === null) {
+		return (new VError('invalid time interval: %s', str));
+	}
+
+	ret = parseInt(match[1], 10);
+	mod_assert.ok(!isNaN(ret) && ret > 0);
+	if (match[2] == 's') {
+		ret *= 1000;
+	} else if (match[2] == 'm') {
+		ret *= 60000;
+	} else {
+		mod_assert.ok(match[2] === undefined || match[2] == 'ms');
+	}
+
+	return (ret);
+}
+
+/*
+ * Respond to the resolver's "added" event by printing out information about the
+ * instance that was found.
+ */
+function cbrPrintAdded(key, backend)
+{
+	mod_assert.ok(!cbrBackends.hasOwnProperty(key),
+	    'received "added" event for already-existing backend');
+	cbrBackends[key] = backend;
+	cbrNbackends++;
+
+	if (cbrFollow) {
+		printf('%s added   %16s:%-5d (%s)\n',
+		    new Date().toISOString(),
+		    backend.address, backend.port, key);
+	} else {
+		printf('%-16s %5d %s\n', backend.address, backend.port, key);
+	}
+}
+
+/*
+ * Respond to the resolver's "removed" event by printing out information about
+ * the instance that has been removed.
+ */
+function cbrPrintRemoved(key)
+{
+	var old;
+
+	mod_assert.ok(cbrBackends.hasOwnProperty(key),
+	    'received "removed" event for non-existent backend');
+	old = cbrBackends[key];
+	delete (cbrBackends[key]);
+
+	if (!cbrFollow) {
+		/*
+		 * This is extremely unlikely, but ignore if this happens.
+		 */
+		return;
+	}
+
+	printf('%s removed %16s:%-5d (%s)\n', new Date().toISOString(),
+	    old.address, old.port, key);
+}
+
+/*
+ * Invoked in non-follow mode once the resolver has finished emitting the first
+ * set of backends.
+ */
+function cbrUpdated()
+{
+	mod_assert.ok(!cbrFollow);
+	cbrResolver.stop();
+	cbrDone = true;
+
+	if (cbrNbackends === 0) {
+		console.error('error: no backends found');
+		process.exit(1);
+	}
+}
+
+main();
diff --git a/lib/index.js b/lib/index.js
index 1bd39b3..f02f864 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -17,6 +17,8 @@ module.exports = {
 	HttpsAgent: mod_agent.HttpsAgent,
 	ConnectionPool: mod_pool.ConnectionPool,
 	Resolver: mod_resolver.Resolver,
+	StaticIpResolver: mod_resolver.StaticIpResolver,
+	resolverForIpOrDomain: mod_resolver.resolverForIpOrDomain,
 
 	poolMonitor: mod_pmonitor.monitor,
 
diff --git a/lib/pool.js b/lib/pool.js
index 4df766f..84ef370 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -535,6 +535,7 @@ function CueBallConnectionPool(options) {
 
 	mod_assert.optionalArrayOfString(options.resolvers,
 	    'options.resolvers');
+	mod_assert.optionalObject(options.resolver, 'options.resolver');
 	mod_assert.string(options.domain, 'options.domain');
 	mod_assert.optionalString(options.service, 'options.service');
 	mod_assert.optionalNumber(options.maxDNSConcurrency,
@@ -576,23 +577,32 @@ function CueBallConnectionPool(options) {
 	this.p_waiters = new Queue();
 
 	var self = this;
-	this.p_resolver = new mod_resolver.Resolver({
-		resolvers: options.resolvers,
-		domain: options.domain,
-		service: options.service,
-		maxDNSConcurrency: options.maxDNSConcurrency,
-		defaultPort: options.defaultPort,
-		log: this.p_log,
-		recovery: options.recovery
-	});
-	this.p_resolver.on('added', function (k, backend) {
+	if (options.resolver !== undefined && options.resolver !== null) {
+		this.p_resolver = options.resolver;
+		this.p_resolver_custom = true;
+	} else {
+		this.p_resolver = new mod_resolver.Resolver({
+			resolvers: options.resolvers,
+			domain: options.domain,
+			service: options.service,
+			maxDNSConcurrency: options.maxDNSConcurrency,
+			defaultPort: options.defaultPort,
+			log: this.p_log,
+			recovery: options.recovery
+		});
+		this.p_resolver_custom = false;
+	}
+
+	this.p_resolver_onadded = function (k, backend) {
 		backend.key = k;
 		self.p_keys.push(k);
 		mod_utils.shuffle(self.p_keys);
 		self.p_backends[k] = backend;
 		self.rebalance();
-	});
-	this.p_resolver.on('removed', function (k) {
+	};
+	this.p_resolver.on('added', this.p_resolver_onadded);
+
+	this.p_resolver_onremoved = function (k) {
 		var idx = self.p_keys.indexOf(k);
 		if (idx !== -1)
 			self.p_keys.splice(idx, 1);
@@ -603,7 +613,9 @@ function CueBallConnectionPool(options) {
 		});
 		delete (self.p_connections[k]);
 		self.rebalance();
-	});
+	};
+	this.p_resolver.on('removed', this.p_resolver_onremoved);
+
 	/*
 	 * Periodically rebalance() so that we catch any connections that
 	 * come off "busy" (we're lazy about these and don't rebalance every
@@ -614,7 +626,9 @@ function CueBallConnectionPool(options) {
 	}, 10000);
 	this.p_rebalTimer.unref();
 
-	this.p_resolver.start();
+	if (!this.p_resolver_custom) {
+		this.p_resolver.start();
+	}
 
 	mod_monitor.monitor.registerPool(this);
 }
@@ -625,7 +639,13 @@ CueBallConnectionPool.prototype.stop = function () {
 	mod_monitor.monitor.unregisterPool(this);
 
 	clearInterval(this.p_rebalTimer);
-	this.p_resolver.stop();
+	if (!this.p_resolver_custom) {
+		this.p_resolver.stop();
+		this.p_resolver.removeListener('added',
+		    this.p_resolver_onadded);
+		this.p_resolver.removeListener('removed',
+		    this.p_resolver_onremoved);
+	}
 	var conns = this.p_connections;
 	Object.keys(conns).forEach(function (k) {
 		conns[k].forEach(function (fsm) {
diff --git a/lib/resolver.js b/lib/resolver.js
index a6eaa3f..35586a5 100644
--- a/lib/resolver.js
+++ b/lib/resolver.js
@@ -7,7 +7,13 @@
  */
 
 module.exports = {
-	Resolver: CueBallResolver
+	Resolver: CueBallResolver,
+	StaticIpResolver: CueBallStaticResolver,
+	resolverForIpOrDomain: resolverForIpOrDomain,
+
+	/* exposed for testing only */
+	configForIpOrDomain: configForIpOrDomain,
+	parseIpOrDomain: parseIpOrDomain
 };
 
 const mod_nsc = require('named-client');
@@ -27,23 +33,38 @@ const FSM = mod_mooremachine.FSM;
 const EventEmitter = mod_events.EventEmitter;
 
 /*
- * The CueBallResolver takes a domain (plus service name and default port) and
- * resolves it, emitting events 'added' and 'removed' as new hosts behind this
- * domain + service are added or removed from DNS.
+ * Cueball provides two types of resolvers: the primary interface is the
+ * DNS-based resolver (called just "Resolver" for historical reasons) that
+ * uses DNS servers to locate backends.  This is appropriate for most server
+ * deployments.  The static resolver emits a pre-configured set of IP addresses
+ * and is intended for development environments and debugging tools where the
+ * user may want to target specific instances.
  *
- * Its basic workflow is to query for SRV records, then AAAA, then A, then
- * work out which events to emit (if any). After this it sleeps.
- * At each step it records the TTL for the information collected, and when a
- * TTL expires, we resume the workflow at the point where the expiring
- * information was gathered (e.g. if an SRV record expired we would re-query
- * all the AAAA and A records, but if an A record expired, only that stage
- * would be re-run).
+ * Resolvers take a domain (plus service name and default port) and resolve it,
+ * emitting events 'added' and 'removed' as new hosts behind this domain +
+ * service are discovered (or discovered to be gone).
  *
  * The 'added' event receives both a key and an object. The key is a unique
  * string to identify this particular backend host (and will be provided again
  * on the 'removed' event if this backend later goes away). The object contains
  * the address and port to connect to to reach this backend.
  *
+ * The factory method resolverForDomain can be used for programs that intend to
+ * support both DNS-based resolution or static IP resolution, depending on
+ * whether the user provides a DNS hostname or an IP address.
+ */
+
+/*
+ * DNS-based Resolver
+ *
+ * The basic workflow for the DNS-based resolver is to query for SRV records,
+ * then AAAA, then A, then work out which events to emit (if any). After this it
+ * sleeps.  At each step it records the TTL for the information collected, and
+ * when a TTL expires, we resume the workflow at the point where the expiring
+ * information was gathered (e.g. if an SRV record expired we would re-query all
+ * the AAAA and A records, but if an A record expired, only that stage would be
+ * re-run).
+ *
  * When SRV record lookup succeeds, the ports will be set based on the contents
  * of these records. If SRV records are not available, then the 'domain' will
  * be looked up as a plain A/AAAA name, and the defaultPort option will
@@ -62,7 +83,6 @@ const EventEmitter = mod_events.EventEmitter;
  * zero impact just like any other service, by removing them from DNS and
  * waiting until traffic subsides.
  */
-
 function CueBallResolver(options) {
 	mod_assert.object(options);
 	mod_assert.optionalArrayOfString(options.resolvers,
@@ -531,6 +551,7 @@ CueBallResolver.prototype.state_process = function () {
 		this.r_log.warn(this.r_lastError, 'failed to find any ' +
 		    'backend records for (%s.)%s (more details in TRACE)',
 		    this.r_service, this.r_domain);
+		this.emit('updated');
 		this.gotoState('sleep');
 		return;
 	}
@@ -555,6 +576,7 @@ CueBallResolver.prototype.state_process = function () {
 		self.emit('added', k, newBackends[k]);
 	});
 
+	this.emit('updated');
 	this.gotoState('sleep');
 };
 
@@ -700,3 +722,194 @@ CueBallResolver.prototype.resolve = function (domain, type, timeout) {
 		em.emit('answers', ans, minTTL);
 	}
 };
+
+
+/*
+ * Static IP Resolver
+ *
+ * This Resolver implementation emits a fixed list of IP addresses.  This is
+ * useful in development environments and debugging tools, where users may want
+ * to target specific service instances.
+ */
+function CueBallStaticResolver(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.arrayOfObject(options.backends, 'options.backends');
+
+	this.sr_backends = options.backends.map(function (backend, i) {
+		mod_assert.string(backend.address,
+		    'options.backends[' + i + '].address');
+		mod_assert.ok(mod_net.isIP(backend.address),
+		    'options.backends[' + i +
+		    '].address must be an IP address');
+		mod_assert.number(backend.port,
+		    'options.backends[' + i + '].port');
+
+		return ({
+		    'name': backend.address + ':' + backend.port,
+		    'address': backend.address,
+		    'port': backend.port
+		});
+	});
+	this.sr_state = 'idle';
+
+	EventEmitter.call(this);
+}
+
+mod_util.inherits(CueBallStaticResolver, EventEmitter);
+
+CueBallStaticResolver.prototype.start = function ()
+{
+	var self = this;
+
+	mod_assert.equal(this.sr_state, 'idle',
+	    'cannot call start() again without calling stop()');
+	this.sr_state = 'started';
+
+	setImmediate(function () {
+		self.sr_backends.forEach(function (be) {
+			self.emit('added', srvKey(be), be);
+		});
+
+		self.emit('updated');
+	});
+};
+
+CueBallStaticResolver.prototype.stop = function ()
+{
+	mod_assert.equal(this.sr_state, 'started',
+	    'cannot call stop() again without calling start()');
+	this.sr_state = 'idle';
+};
+
+CueBallStaticResolver.prototype.count = function ()
+{
+	return (this.sr_backends.length);
+};
+
+CueBallStaticResolver.prototype.list = function ()
+{
+	var ret = {};
+
+	this.sr_backends.forEach(function (be) {
+		ret[srvKey(be)] = be;
+	});
+
+	return (ret);
+};
+
+
+/*
+ * resolverForIpOrDomain(args): given an input string of the form:
+ *
+ *     HOSTNAME[:PORT]
+ *
+ * where HOSTNAME may be either a DNS domain or IP address and PORT is an
+ * integer representing a TCP port, return an appropriate resolver instance that
+ * either uses the static IP resolver (if HOSTNAME is determined to be an IP
+ * address) or the DNS-based Resolver class (otherwise).
+ *
+ * Named arguments include:
+ *
+ *    input           the input string (described above)
+ *
+ *    resolverConfig  configuration properties passed to the resolver's
+ *                    constructor
+ *
+ * This is the appropriate interface for constructing a resolver from
+ * user-specified configuration because it allows users to specify IP addresses
+ * or DNS names interchangeably, which is what most users expect.
+ *
+ * If the input is well-formed but invalid (e.g., has the correct JavaScript
+ * types, but the port number is out of range, or the HOSTNAME portion cannot be
+ * interpreted as either an IP address or a DNS domain), then an Error object is
+ * returned.
+ */
+function resolverForIpOrDomain(args)
+{
+	var speccfg, cons, rcfg;
+
+	speccfg = configForIpOrDomain(args);
+	if (speccfg instanceof Error) {
+		return (speccfg);
+	}
+
+	cons = speccfg.cons;
+	rcfg = speccfg.mergedConfig;
+	return (new cons(rcfg));
+}
+
+/*
+ * Implements the guts of resolverForIpOrDomain().
+ */
+function configForIpOrDomain(args)
+{
+	var rcfg, speccfg, k;
+
+	mod_assert.object(args, 'args');
+	mod_assert.string(args.input, 'args.input');
+	mod_assert.optionalObject(args.resolverConfig, 'args.resolverConfig');
+
+	rcfg = {};
+	if (args.resolverConfig) {
+		for (k in args.resolverConfig) {
+			rcfg[k] = args.resolverConfig[k];
+		}
+	}
+
+	speccfg = parseIpOrDomain(args.input);
+	if (speccfg instanceof Error) {
+		return (speccfg);
+	}
+
+	for (k in speccfg.config) {
+		rcfg[k] = speccfg.config[k];
+	}
+
+	speccfg.mergedConfig = rcfg;
+	return (speccfg);
+}
+
+/*
+ * Implements the parsing part of resolverForIpOrDomain().
+ */
+function parseIpOrDomain(str)
+{
+	var colon, first, port, ret;
+
+	colon = str.lastIndexOf(':');
+	if (colon == -1) {
+		first = str;
+		port = undefined;
+	} else {
+		first = str.substr(0, colon);
+		port = parseInt(str.substr(colon + 1), 10);
+		if (isNaN(port) || port < 0 || port > 65535) {
+			return (new Error('unsupported port in input: ' + str));
+		}
+	}
+
+	ret = {};
+	if (mod_net.isIP(first) === 0) {
+		ret['kind'] = 'dns';
+		ret['cons'] = CueBallResolver;
+		/* XXX validate DNS domain? */
+		ret['config'] = {
+		    'domain': first
+		};
+
+		if (port !== undefined) {
+			ret['config']['defaultPort'] = port;
+		}
+	} else {
+		ret['kind'] = 'static';
+		ret['cons'] = CueBallStaticResolver;
+		ret['config'] = {
+		    'backends': [ {
+			'address': first,
+			'port': port
+		    } ]
+		};
+	}
+
+	return (ret);
+}
diff --git a/package.json b/package.json
index 992b851..f956582 100644
--- a/package.json
+++ b/package.json
@@ -6,14 +6,19 @@
   "dependencies": {
     "assert-plus": ">=1.0.0 <2.0.0",
     "bunyan": ">=1.5.1 <2.0.0",
+    "cmdutil": ">=1.0.0 <2.0.0",
+    "extsprintf": ">=1.3.0 <2.0.0",
     "ipaddr.js": ">=1.1.0 <2.0.0",
     "mooremachine": ">=1.2.0 <2.0.0",
     "named-client": "git://github.com/arekinath/node-named-client#v0.3.3",
     "node-uuid": ">=1.4.7 <2.0.0",
+    "posix-getopt": ">=1.2.0 <2.0.0",
     "restify-clients": ">=1.1.2 <2.0.0",
-    "vasync": ">=1.6.3 <2.0.0"
+    "vasync": ">=1.6.3 <2.0.0",
+    "verror": ">=1.6.1 <2.0.0"
   },
   "devDependencies": {
+    "jsprim": ">=1.3.0 <2.0.0",
     "tape": ">=4.4.0 <5.0.0",
     "sinon": ">=1.17.3 <2.0.0",
     "json": ">=9.0.3 <10.0.0"
diff --git a/test/resolver_for.test.js b/test/resolver_for.test.js
new file mode 100644
index 0000000..7a2c694
--- /dev/null
+++ b/test/resolver_for.test.js
@@ -0,0 +1,232 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+const mod_resolver = require('../lib/resolver');
+const mod_tape = require('tape');
+
+/*
+ * Test the resolverForIpOrDomain() factory function and related interfaces.
+ */
+
+mod_tape.test('resolverForIpOrDomain: bad arguments', function (t) {
+	t.throws(function () {
+		mod_resolver.resolverForIpOrDomain({});
+	}, /args\.input/);
+
+	t.throws(function () {
+		mod_resolver.resolverForIpOrDomain('foobar');
+	}, /args/);
+
+	t.throws(function () {
+		mod_resolver.resolverForIpOrDomain({
+		    'input': 1234
+		});
+	}, /args\.input/);
+
+	t.throws(function () {
+		mod_resolver.resolverForIpOrDomain({
+		    'input': 'foobar',
+		    'resolverConfig': 17
+		});
+	}, /args\.resolverConfig/);
+
+	t.end();
+});
+
+/*
+ * parseIpOrDomain(): this is the lowest-level function.  It's responsible for
+ * parsing the input string and determining what kind of Resolver to create.
+ */
+
+mod_tape.test('parseIpOrDomain: ipv4', function (t) {
+	var result;
+
+	result = mod_resolver.parseIpOrDomain('127.0.0.1');
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'static');
+	t.equal(result.cons.name, 'CueBallStaticResolver');
+	t.deepEqual(result.config, {
+	    'backends': [ { 'address': '127.0.0.1', 'port': undefined } ]
+	});
+	result = mod_resolver.parseIpOrDomain('127.0.0.1:1234');
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'static');
+	t.equal(result.cons.name, 'CueBallStaticResolver');
+	t.deepEqual(result.config, {
+	    'backends': [ { 'address': '127.0.0.1', 'port': 1234 } ]
+	});
+
+	result = mod_resolver.parseIpOrDomain('127.0.0.1:-3');
+	t.ok(result instanceof Error);
+	t.ok(/unsupported port in input:/.test(result.message));
+
+	result = mod_resolver.parseIpOrDomain('127.0.0.1:ab123');
+	t.ok(result instanceof Error);
+	t.ok(/unsupported port in input:/.test(result.message));
+
+	t.end();
+});
+
+mod_tape.test('parseIpOrDomain: hostname', function (t) {
+	var result;
+
+	result = mod_resolver.parseIpOrDomain('1.moray.emy-10.joyent.us');
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'dns');
+	t.equal(result.cons.name, 'CueBallResolver');
+	t.deepEqual(result.config, {
+	    'domain': '1.moray.emy-10.joyent.us'
+	});
+
+	result = mod_resolver.parseIpOrDomain('myservice');
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'dns');
+	t.equal(result.cons.name, 'CueBallResolver');
+	t.deepEqual(result.config, {
+	    'domain': 'myservice'
+	});
+
+	result = mod_resolver.parseIpOrDomain('myservice:1234');
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'dns');
+	t.equal(result.cons.name, 'CueBallResolver');
+	t.deepEqual(result.config, {
+	    'domain': 'myservice',
+	    'defaultPort': 1234
+	});
+
+	result = mod_resolver.parseIpOrDomain('myservice:-3');
+	t.ok(result instanceof Error);
+	t.ok(/unsupported port in input:/.test(result.message));
+
+	t.end();
+});
+
+/*
+ * configForIpOrDomain: takes the result of parseIpOrDomain() and merges the
+ * user-provided configuration.
+ */
+
+mod_tape.test('configForIpOrDomain: static IP', function (t) {
+	var result;
+
+	/*
+	 * For static resolvers, there's no additional configuration.
+	 */
+	result = mod_resolver.configForIpOrDomain({
+	    'input': '127.0.0.1:2020'
+	});
+	t.ok(!(result instanceof Error));
+	t.equal(result.kind, 'static');
+	t.deepEqual(result.config, {
+	    'backends': [ { 'address': '127.0.0.1', 'port': 2020 } ]
+	});
+	t.deepEqual(result.mergedConfig, result.config);
+
+	/*
+	 * With DNS-based resolvers, additional properties are typically
+	 * specified, but the port provided in the input should override the
+	 * default port.
+	 */
+	result = mod_resolver.configForIpOrDomain({
+	    'input': '1.moray:4567',
+	    'resolverConfig': {
+		'defaultPort': 1234,
+		'service': '_moray_.tcp',
+		'resolvers': [ '192.168.0.1', '192.168.0.3' ]
+	    }
+	});
+	t.equal(result.kind, 'dns');
+	t.deepEqual(result.mergedConfig, {
+	    'domain': '1.moray',
+	    'defaultPort': 4567,
+	    'service': '_moray_.tcp',
+	    'resolvers': [ '192.168.0.1', '192.168.0.3' ]
+	});
+
+	/*
+	 * If there's no port in the input, then we should use the default port.
+	 */
+	result = mod_resolver.configForIpOrDomain({
+	    'input': '1.moray',
+	    'resolverConfig': {
+		'defaultPort': 1234,
+		'service': '_moray_.tcp',
+		'resolvers': [ '192.168.0.1', '192.168.0.3' ]
+	    }
+	});
+	t.equal(result.kind, 'dns');
+	t.deepEqual(result.mergedConfig, {
+	    'domain': '1.moray',
+	    'defaultPort': 1234,
+	    'service': '_moray_.tcp',
+	    'resolvers': [ '192.168.0.1', '192.168.0.3' ]
+	});
+
+	t.end();
+});
+
+
+/*
+ * resolverForIpOrDomain: takes the result of configForIpOrDomain and simply
+ * instantiates the resolver.  Given that we've tested everything above, there's
+ * less that needs to be checked here.
+ */
+
+mod_tape.test('resolverForIpOrDomain: static IP', function (t) {
+	var result, list;
+
+	result = mod_resolver.resolverForIpOrDomain({
+	    'input': '127.0.0.1:2020'
+	});
+	t.ok(!(result instanceof Error));
+	t.ok(result instanceof mod_resolver.StaticIpResolver);
+	list = result.list();
+	t.equal(1, Object.keys(list).length);
+	t.deepEqual(list[Object.keys(list)[0]], {
+	    'name': '127.0.0.1:2020',
+	    'address': '127.0.0.1',
+	    'port': 2020
+	});
+
+	result = mod_resolver.resolverForIpOrDomain({
+	    'input': '127.0.0.1:70000'
+	});
+	t.ok(result instanceof Error);
+	t.ok(/unsupported port in input:/.test(result.message));
+
+	t.end();
+});
+
+mod_tape.test('resolverForIpOrDomain: hostname', function (t) {
+	var result;
+
+	result = mod_resolver.resolverForIpOrDomain({
+	    'input': '1.moray.emy-10.joyent.us',
+	    'resolverConfig': {
+		'recovery': {
+		    'default': {
+			'retries': 1,
+			'timeout': 1000,
+			'delay': 1000,
+			'maxDelay': 1000
+		    }
+		}
+	    }
+	});
+	t.ok(!(result instanceof Error));
+	t.ok(result instanceof mod_resolver.Resolver);
+
+	result = mod_resolver.resolverForIpOrDomain({
+	    'input': '1.moray.emy-10.joyent.us:70000'
+	});
+	t.ok(result instanceof Error);
+	t.ok(/unsupported port in input:/.test(result.message));
+
+	t.end();
+});
diff --git a/test/resolver_static.test.js b/test/resolver_static.test.js
new file mode 100644
index 0000000..2b950d1
--- /dev/null
+++ b/test/resolver_static.test.js
@@ -0,0 +1,159 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+const mod_jsprim = require('jsprim');
+const mod_resolver = require('../lib/resolver');
+const mod_tape = require('tape');
+
+/*
+ * Test the static resolver.
+ */
+
+mod_tape.test('static resolver: bad arguments', function (t) {
+	/*
+	 * javascriptlint (rightfully) doesn't like invoking a constructor and
+	 * ignoring the result.  It also (rightfully) doesn't like assigning it
+	 * to a variable that itself is never used.  This is an unusual case,
+	 * since we're essentially testing the constructor's behavior.
+	 */
+	/* jsl:ignore */
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver();
+	}, /options/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({});
+	}, /options.backends/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': null
+		});
+	}, /options.backends/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': [ null ]
+		});
+	}, /options.backends/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': [ {
+		        'address': '127.0.0.1',
+			'port': 1234
+		    }, {} ]
+		});
+	}, /options.backends\[1\].address/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': [ {
+		        'address': '127.0.0.1',
+			'port': 1234
+		    }, {
+		        'address': 1234,
+			'port': 'foobar'
+		    } ]
+		});
+	}, /options.backends\[1\].address/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': [ {
+		        'address': '127.0.0.1',
+			'port': 1234
+		    }, {
+		        'address': '127.0.0.1'
+		    } ]
+		});
+	}, /options.backends\[1\].port/);
+
+	t.throws(function () {
+		new mod_resolver.StaticIpResolver({
+		    'backends': [ {
+		        'address': '127.0.0.1',
+			'port': 1234
+		    }, {
+		        'address': '127.0.0.1',
+			'port': 'foobar'
+		    } ]
+		});
+	}, /options.backends\[1\].port/);
+	/* jsl:end */
+
+	t.end();
+});
+
+mod_tape.test('static resolver: no backends', function (t) {
+	var resolver, nadded;
+
+	resolver = new mod_resolver.StaticIpResolver({ 'backends': [] });
+	resolver.start();
+
+	nadded = 0;
+	resolver.on('added', function () { nadded++; });
+	resolver.on('updated', function () {
+		t.equal(nadded, 0);
+		t.deepEqual(resolver.list(), {});
+		t.equal(resolver.count(), 0);
+		resolver.stop();
+		t.end();
+	});
+});
+
+mod_tape.test('static resolver: several backends', function (t) {
+	var resolver, found;
+
+	resolver = new mod_resolver.StaticIpResolver({
+	    'backends': [ {
+		'address': '10.0.0.3',
+		'port': 2021
+	    }, {
+		'address': '10.0.0.3',
+		'port': 2020
+	    }, {
+		'address': '10.0.0.7',
+		'port': 2020
+	    } ]
+	});
+
+	resolver.start();
+
+	found = [];
+	resolver.on('added', function (key, backend) { found.push(backend); });
+	resolver.on('updated', function () {
+		var expected;
+
+		t.equal(resolver.count(), 3);
+		t.deepEqual(found, [ {
+		    'name': '10.0.0.3:2021',
+		    'address': '10.0.0.3',
+		    'port': 2021
+		}, {
+		    'name': '10.0.0.3:2020',
+		    'address': '10.0.0.3',
+		    'port': 2020
+		}, {
+		    'name': '10.0.0.7:2020',
+		    'address': '10.0.0.7',
+		    'port': 2020
+		} ]);
+
+		expected = {};
+		found.forEach(function (be) { expected[be['name']] = true; });
+		mod_jsprim.forEachKey(resolver.list(), function (k, reported) {
+			t.ok(expected.hasOwnProperty(reported['name']));
+			delete (expected[reported['name']]);
+		});
+
+		t.equal(Object.keys(expected).length, 0);
+		resolver.stop();
+		t.end();
+	});
+});
-- 
2.21.0

