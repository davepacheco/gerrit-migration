commit ac17b74c385e5d9e365d502bdfeab8d2f34bf1c3
Author: rhb2 <robert.bogart@joyent.com>
Date:   2019-08-30T05:33:18+00:00 (6 weeks ago)
    
    MANTA-4523 Rebalancer Agent requires uuid to accompany list of tasks when posting an assignment.

diff --git a/src/agent.rs b/src/agent.rs
index 6eccf73..b5f8b2b 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -34,6 +34,7 @@ use crate::jobs::TaskStatus;
 
 use reqwest::StatusCode;
 use rusqlite;
+use serde_json::Value;
 use serde_derive::{Deserialize, Serialize};
 use threadpool::ThreadPool;
 use uuid::Uuid;
@@ -372,8 +373,15 @@ fn post(agent: Agent, mut state: State) -> Box<HandlerFuture> {
             Ok(valid_body) => {
                 // Ceremony for parsing the information needed to create an
                 // an assignent out of the message body.
-                let v = validate_assignment(&valid_body).unwrap();
-                let uuid = Uuid::new_v4().to_hyphenated().to_string();
+                let (uuid, v) = match validate_assignment(&valid_body) {
+                    Ok(uv) => uv,
+                    Err(_e) => {
+                        let res = create_empty_response(&state,
+                            StatusCode::BAD_REQUEST);
+                        return future::ok((state, res));
+                    },
+                };
+
                 let assignment =
                     Arc::new(RwLock::new(Assignment::new(v, &uuid)));
 
@@ -478,16 +486,49 @@ fn get_assignment(
     Box::new(future::ok((state, res)))
 }
 
-fn validate_assignment(body: &Chunk) -> Result<Vec<Task>, String> {
+// This function extracts the message body of a POST request.  The message body
+// is a serialized json object continaing two strings: the uuid of the
+// assignment itself and serialized Vec<Task> (encoded as a string).  Once the
+// entire body has been converted from a string to a Value (see serde_json for
+// a definition of the Value enum), we must then deserialize the string in the
+// "tasks" field.  The uuid field is a simple string that does not require
+// further deserialization.  If either of these two fields is not present in
+// the message body, we will flag the failure and return.  It is the
+// responsibility of the caller to check the result returned by this function
+// and let the client that sent the request know whether or not the request
+// had any problems.
+//
+// Side note: You will notice that fields within the serde_json::Value object
+// are suffixed with a call to as_str().  This is necessary in order to convert
+// the value from a JSON string to a Rust string.  For more information on this,
+// see the section titled "Operating on untyped JSON values" in the serde_json
+// documentation.
+fn validate_assignment(body: &Chunk) -> Result<(String, Vec<Task>), String> {
     let data = String::from_utf8(body.to_vec()).unwrap();
 
-    let v = match serde_json::from_str(&data) {
+    // v is a serde_json::Value.  It should have two fields: v["tasks"] and
+    // v["uuid"].
+    let v: Value = match serde_json::from_str(&data) {
         Ok(v) => v,
         Err(e) => return Err(format!("Failed to deserialize: {}", e)),
     };
 
-    let assignment: Vec<Task> = serde_json::from_value(v).unwrap();
-    Ok(assignment)
+    // v["tasks"] itself happens to be a serialized json object.  Run it through
+    // the deserialization process now.  If all goes well, we get a Vec<Task>.
+    let assignment: Vec<Task> = match serde_json::from_str(
+        v["tasks"].as_str().unwrap()) {
+        Ok(tasks) => tasks,
+        Err(e) => return Err(format!("Task list: {}", e)),
+    };
+
+    // As stated above, no further deserialization required for a uuid.  We
+    // can just take it directly.
+    let uuid : String = match v["uuid"].as_str() {
+        Some(u) => u.to_string(),
+        _ => return Err(format!("Missing uuid in assignment.")),
+    };
+
+    Ok((uuid, assignment))
 }
 
 impl Handler for Agent {
@@ -828,8 +869,28 @@ mod tests {
         assignment: Arc<RwLock<Assignment>>,
     ) -> String {
         let tasks = &assignment.read().unwrap().tasks;
+
+        // Encode our list of tasks as one monolithic string representing a
+        // JSON object.
+        let ser_tasks = serde_json::to_string(&tasks)
+            .expect("serialized tasks");
+
+        // Generate a uuid to accompany the assignment that we are about to
+        // send to the agent.
+        let uuid = Uuid::new_v4().to_hyphenated().to_string();
+
+        // Instantiate a HashMap that will contain two parts.  One, the uuid
+        // of the the assignment (indexed by the field "uuid") and the
+        // encoded list of tasks for our assignment (indexed by the field
+        // "tasks".
+        let mut obj = HashMap::new();
+        obj.insert("tasks".to_string(), ser_tasks);
+        obj.insert("uuid".to_string(), uuid.clone());
+
+        // Finally, serialize the entire HashMap before stuffing it in the
+        // message body.
         let body: Vec<u8> =
-            serde_json::to_vec(tasks).expect("Serialized assignment");
+            serde_json::to_vec(&obj).expect("Serialized assignment");
 
         let response = test_server
             .client()
@@ -845,13 +906,17 @@ mod tests {
 
         let body = response.read_body().unwrap();
         let data = String::from_utf8(body.to_vec()).unwrap();
-        let uuid: String = match serde_json::from_str(&data) {
+        let resp_uuid: String = match serde_json::from_str(&data) {
             Ok(s) => s,
             Err(e) => panic!(format!("Error: {}", e)),
         };
 
-        println!("response: {:?}", uuid);
-        uuid.to_string()
+        println!("Response: {:?}", resp_uuid);
+
+        // Perhaps it is overkill, but check to ensure that the uuid given
+        // back to us matches what we actually sent.
+        assert_eq!(uuid, resp_uuid);
+        resp_uuid.to_string()
     }
 
     // Given a path of an assignment on disk, load it in to memory.  If for
