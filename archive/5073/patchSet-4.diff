commit 8a53b52438a53d661577a290a5f786736bf7d717 (refs/changes/73/5073/4)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2018-11-21T13:52:43-05:00 (11 months ago)
    
    OS-7383 vminfod watchForChanges timeout when setting brand in vmadm update
    Reviewed by: John Levon <john.levon@joyent.com>
    Reviewed by: Josh Wilsdon <josh@wilsdon.ca>
    Approved by: Josh Wilsdon <josh@wilsdon.ca>

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 46ee41bf..2403d984 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -15464,11 +15464,12 @@ exports.update = function (uuid, payload, options, callback)
                 // XXX: maybe there's a list of these somewhere?
                 var IGNORE_KEYS = [
                     // these cannot be changed
-                    'zonename',
-                    'uuid',
+                    'brand',
+                    'hvm',
                     'last_modified',
                     'server_uuid',
-                    'hvm',
+                    'uuid',
+                    'zonename',
 
                     // these are modified via set/remove/add/update
                     'nics',
diff --git a/src/vm/tests/test-update.js b/src/vm/tests/test-update.js
index 8174b935..93f0f549 100644
--- a/src/vm/tests/test-update.js
+++ b/src/vm/tests/test-update.js
@@ -30,10 +30,13 @@
  * which case it can be changed to some other non-Private address.
  */
 
-var async = require('/usr/node/node_modules/async');
+var assert = require('/usr/node/node_modules/assert-plus');
+var common = require('./common');
 var execFile = require('child_process').execFile;
+var f = require('util').format;
 var fs = require('fs');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -250,6 +253,21 @@ var simple_properties = [
     ['package_version', 'XP']
 ];
 
+/*
+ * An array of properties that cannot be changed (but are still validated).  In
+ * each array item is another array, and inside that the first item is the
+ * property name, and the second item is a bogus property value that will pass
+ * validation.
+ */
+var UNMODIFIABLE_PROPS = [
+    ['brand', 'bogus-brand'],
+    ['hvm', 'bogus-hvm'],
+    ['last_modified', 'bogus-last-modified'],
+    ['server_uuid', '00000000-0000-0000-0000-000000000000'],
+    ['uuid', '00000000-0000-0000-0000-000000000000'],
+    ['zonename', 'bogus-zonename']
+];
+
 test('create VM', function (t) {
     VM.create(PAYLOADS.create, function (err, vmobj) {
         if (err) {
@@ -701,8 +719,9 @@ test('add NIC with minimal properties', function (t) {
 });
 
 test('set then unset simple properties', function (t) {
-    async.forEachSeries(simple_properties,
-        function (item, cb) {
+    vasync.forEachPipeline({
+        inputs: simple_properties,
+        func: function (item, cb) {
             var prop = item[0];
             var value = item[1];
             var payload = {};
@@ -749,11 +768,10 @@ test('set then unset simple properties', function (t) {
                     });
                 }
             });
-        },
-        function (err) {
-            t.end();
         }
-    );
+    }, function (err) {
+        t.end();
+    });
 });
 
 test('update quota', function (t) {
@@ -1318,6 +1336,82 @@ test('get vmobj for full VM after modifications', function (t) {
     });
 });
 
+/*
+ * Attempt to update the unmodifiable properties to a generic value.
+ *
+ * These properties should be silently ignored and return success even though
+ * nothing was modified.  This is useful in situations such as reprovisioning,
+ * or updating from an old VM where all the properties from `vmadm get` would be
+ * present.  This test ensures that `VM.update` silently ignores any keys that
+ * cannot be changed.
+ */
+test('attempt to modify unmodifiable properties', function (t) {
+    VM.load(vm_uuid, function (loadErr, vmobj) {
+        common.ifError(t, loadErr, 'load VM');
+
+        if (loadErr) {
+            t.end();
+            return;
+        }
+
+        vasync.forEachPipeline({
+            inputs: UNMODIFIABLE_PROPS,
+            func: function (item, cb) {
+                var prop = item[0];
+                var value = item[1];
+
+                var payload = {};
+                payload[prop] = value;
+
+                /*
+                 * Update the property (should be a success but nothing should
+                 * change).
+                 */
+                VM.update(vm_uuid, payload, function (updateErr) {
+                    common.ifError(t, updateErr,
+                        f('update unmodifiable VM property "%s" to %j',
+                        prop, value));
+
+                    if (updateErr) {
+                        cb(updateErr);
+                        return;
+                    }
+
+                    /*
+                     * Ensure the property hasn't changed.  The exception here
+                     * is the "last_modified" property that will get updated
+                     * under a variety of conditions.  We just skip looking it
+                     * up here and move on.
+                     */
+                    if (prop === 'last_modified') {
+                        cb();
+                        return;
+                    }
+
+                    VM.load(vm_uuid, function (loadErr2, obj) {
+                        common.ifError(t, loadErr2, 'load VM');
+
+                        if (loadErr2) {
+                            cb(loadErr2);
+                            return;
+                        }
+
+                        t.equal(obj[prop], vmobj[prop],
+                            f('value has not been modified '
+                            + '(original: %j, found %j)',
+                            vmobj[prop], obj[prop]));
+
+                        cb();
+                    });
+                });
+            }
+        }, function (err) {
+            common.ifError(t, err, 'unmodifiable properties');
+            t.end();
+        });
+    });
+});
+
 test('delete zone', function (t) {
     if (vm_uuid) {
         VM.delete(vm_uuid, function (err) {
