commit 7905bbf234948845bce2bd67cea083f9e6ef0607 (refs/changes/17/4917/4)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-10-12T20:34:55+00:00 (12 months ago)
    
    TRITON-825 cns-server not forgiving enough of slow updates on replicas
    Reviewed by: Richard Kiene <richard.kiene@joyent.com>
    Approved by: Richard Kiene <richard.kiene@joyent.com>

diff --git a/lib/dns-server.js b/lib/dns-server.js
index ce099cf..7a0b064 100644
--- a/lib/dns-server.js
+++ b/lib/dns-server.js
@@ -59,6 +59,7 @@ function DNSServer(opts) {
 		this.notifyInterval = consts.DEFAULT_MIN_NOTIFY_INT;
 	this.checkAndNotify();
 	this.unblacklistTimers = {};
+	this.checkTimers = {};
 
 	this.peerCounters = {};
 
@@ -1039,6 +1040,8 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 	var r = q.redis;
 	var i;
 	var addr = q.src.address;
+	var addrKey = normalizeIP(addr);
+	var addrZoneKey = addrKey + ':' + z;
 
 	/* Check this is one of our registered peers. */
 	if (this.checkPeer(addr) === false) {
@@ -1072,20 +1075,38 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 			q.addAnswer(z, soa, TTL);
 
 			var log  = q.log;
-			setTimeout(function () {
+			if (addr !== '127.0.0.1' && addr !== '::1')
+				ensurePeerCheckTimer();
+			q.send();
+			cb();
+			q.log.info('responded ok');
+
+			function ensurePeerCheckTimer() {
+				if (!self.checkTimers[addrZoneKey]) {
+					log.trace('set peer check timer for ' +
+					    '%s', addrZoneKey);
+					self.checkTimers[addrZoneKey] =
+					    setTimeout(doPeerChecks, 2000);
+				} else {
+					log.trace('peer check timer for %s ' +
+					    'already set', addrZoneKey);
+				}
+			}
+
+			function doPeerChecks() {
 				var arg = {};
 				vasync.pipeline({
 					funcs: [claim, checkSOA, checkVer],
 					arg: arg
-				}, function () {
+				}, function (pcerr) {
+					log.trace(pcerr, 'peer check finished');
+					delete (self.checkTimers[addrZoneKey]);
+					if (arg.rearm)
+						ensurePeerCheckTimer();
 					if (arg.handle)
 						arg.handle.release();
 				});
-			}, 1000);
-
-			q.send();
-			cb();
-			q.log.info('responded ok');
+			}
 
 			function claim(_, ccb) {
 				self.redisPool.claim(
@@ -1113,14 +1134,21 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 						    'xfer follow-up showed ' +
 						    'peer still stuck on ' +
 						    'serial %d', qsoa.serial);
-						ccb(new Error('Stuck'));
+						_.rearm = true;
+						_.redis.hset(
+						    'peer:' + addrKey,
+						    z, String(qsoa.serial),
+						    ccb);
 						return;
 					}
+					log.debug({ serial: qsoa.serial },
+					     'confirmed new SOA for %s on %s',
+					     z, addr);
 					self.incrPeerCounter(addr, 'goodxfer');
 					self.startUnblacklist(addr);
 					/* Write down the transfer in redis. */
 					_.redis.hset(
-					    'peer:' + normalizeIP(addr),
+					    'peer:' + addrKey,
 					    z, String(qsoa.serial), ccb);
 				});
 			}
@@ -1135,7 +1163,7 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 						return;
 					}
 					_.redis.set('peer:' +
-					    normalizeIP(addr) + ':version',
+					    addrKey + ':version',
 					    pver, ccb);
 				});
 			}
