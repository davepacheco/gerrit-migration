From 6908d2d0b932e92851d4a01784714300bda3c64e Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Thu, 12 Jan 2017 10:19:13 -0800
Subject: [PATCH] PUBAPI-1300 Implement CRUD volumes endpoints PUBAPI-1366
 Volume objects should use the name "id" for the property that stores their
 ID, not "uuid" PUBAPI-1373 Add support for passing a JSON predicate to the
 ListVolumes endpoint PUBAPI-1369 GET volume should return 404 for a
 non-existing volume name/uuid PUBAPI-1377 vm_uuid property should not be
 present in responses for endpoints rendering NFS shared volumes PUBAPI-1374
 Want user-friendly timestamp for volume details PUBAPI-1379 CreateVolume
 endpoint should accept size as number, not as string with complex format
 rules PUBAPI-1384 Machines endpoint should not expose NFS volumes' storage
 VMs PUBAPI-1376 Create volume errors out when the network parameter is passed
 PUBAPI-1372 CreateVolume endpoint should generate volume name if not provided
 in input parameters PUBAPI-1371 List volumes should not return deleted or
 failed instances VOLAPI-49 DELETE should delete PUBAPI-1387 Add
 ListVolumeSizes endpoint to list available volume sizes PUBAPI-1408
 ListVolumes endpoint should validate the "predicate" parameter PUBAPI-1407
 Error message should be clearer when provisioning a NFS volume in a DC
 without fabric networks enabled VOLAPI-54 Custom errors' rest codes should
 follow engineering guide's guidelines PUBAPI-1416 cloudapi ListVolumes
 validation should match volapi VOLAPI-62 Remove all references to state
 `rolling_back` in current implementation TOOLS-1824 sdcadm update-other
 should not do anything for VOLAPI VOLAPI-64 rename smartdc_role nfsserver to
 nfsvolumestorage TOOLS-1830 replace sdcadm experimental nfs-volumes with
 cloudapi-nfs-volumes/docker-nfs-volumes subcommands VOLAPI-72 creating volume
 with unsupported size should result in error, not in volume being created
 with closest matching size PUBAPI-1420 Add ability to mount NFS volumes with
 CreateMachine endpoint

---
 Makefile                                      |   5 +-
 etc/cloudapi.coal.cfg                         | 184 -----
 lib/app.js                                    |  32 +-
 lib/endpoints/networks.js                     |   5 +-
 lib/endpoints/volumes.js                      | 737 ++++++++++++++++++
 lib/errors.js                                 |  49 +-
 lib/machines.js                               | 150 +++-
 lib/middlewares/networks.js                   | 134 ++++
 lib/units.js                                  |  13 +
 lib/validation/predicate.js                   |  87 +++
 lib/validation/volumes.js                     | 197 +++++
 package.json                                  |   5 +-
 sapi_manifests/cloudapi/template              |  18 +-
 test/auth.test.js                             |   4 +
 test/common.js                                |  34 +-
 test/fabrics.test.js                          |  41 +-
 test/keys.test.js                             |   2 +
 test/lib/config.js                            |  46 ++
 test/lib/networks.js                          |  43 +
 test/lib/volumes.js                           |  84 ++
 test/nics.test.js                             |  50 ++
 test/volumes-automount.test.js                | 695 +++++++++++++++++
 test/volumes-basic.test.js                    | 334 ++++++++
 test/volumes-create-name.test.js              | 147 ++++
 test/volumes-create-validation.test.js        | 176 +++++
 test/volumes-get.test.js                      |  59 ++
 test/volumes-list-params-validation.test.js   | 533 +++++++++++++
 .../volumes-list-predicate-validation.test.js | 210 +++++
 test/volumes-list-sizes.test.js               | 116 +++
 test/volumes-no-fabric-network.test.js        | 113 +++
 test/volumes-size.test.js                     | 229 ++++++
 test/volumes-update-name.test.js              | 166 ++++
 test/volumes.unavailable-size.test.js         | 122 +++
 33 files changed, 4580 insertions(+), 240 deletions(-)
 delete mode 100644 etc/cloudapi.coal.cfg
 create mode 100644 lib/endpoints/volumes.js
 create mode 100644 lib/middlewares/networks.js
 create mode 100644 lib/units.js
 create mode 100644 lib/validation/predicate.js
 create mode 100644 lib/validation/volumes.js
 create mode 100644 test/lib/config.js
 create mode 100644 test/lib/networks.js
 create mode 100644 test/lib/volumes.js
 create mode 100644 test/volumes-automount.test.js
 create mode 100644 test/volumes-basic.test.js
 create mode 100644 test/volumes-create-name.test.js
 create mode 100644 test/volumes-create-validation.test.js
 create mode 100644 test/volumes-get.test.js
 create mode 100644 test/volumes-list-params-validation.test.js
 create mode 100644 test/volumes-list-predicate-validation.test.js
 create mode 100644 test/volumes-list-sizes.test.js
 create mode 100644 test/volumes-no-fabric-network.test.js
 create mode 100644 test/volumes-size.test.js
 create mode 100644 test/volumes-update-name.test.js
 create mode 100644 test/volumes.unavailable-size.test.js

diff --git a/Makefile b/Makefile
index 3878729..5fc501e 100644
--- a/Makefile
+++ b/Makefile
@@ -33,7 +33,10 @@ TAP		:= ./node_modules/.bin/tape
 DOC_FILES	 = index.md admin.md dev.md
 RESTDOWN_FLAGS   = --brand-dir=deps/restdown-brand-remora
 EXTRA_DOC_DEPS += deps/restdown-brand-remora/.git
-JS_FILES	:= $(shell ls *.js) $(shell find lib -maxdepth 1 -name '*.js') \
+# We explicitly don't want to lint node-http-signature, as it's an external
+# repository that is exceptionally bundled in this repo to ensure backward
+# compatibilty when handling different signature formats.
+JS_FILES	:= $(shell ls *.js) $(shell find lib -name '*.js' | grep -v node-http-signature) \
 	$(shell find test -name '*.js') $(shell find bench -name '*.js') \
 	$(shell find plugins -name '*.js') \
 	$(shell find test -name '*.javascript')
diff --git a/etc/cloudapi.coal.cfg b/etc/cloudapi.coal.cfg
deleted file mode 100644
index 1773ada..0000000
--- a/etc/cloudapi.coal.cfg
+++ /dev/null
@@ -1,184 +0,0 @@
-{
-    "port": 8080,
-    "read_only": false,
-    "fabrics_enabled": true,
-    "fabric_package_prefixes": [],
-    "datacenter_name": "coal",
-    "bunyan": {
-        "level": "info"
-    },
-    "bleeding_edge_features": {
-         "": false,
-         "account_mgmt": true,
-         "img_mgmt": true
-    },
-    "bleeding_edge_login_whitelist": {
-         "admin": true,
-         "*": true
-    },
-    "ufds": {
-        "url": "ldaps://ufds.coal.joyent.us",
-        "bindDN": "cn=root",
-        "bindPassword": "secret",
-        "cache": {
-            "size": 1000,
-            "age": 300
-        },
-        "clientTimeout": 10000,
-        "maxConnections": 1,
-        "retry": {
-            "initialDelay": 1000
-        }
-    },
-    "ufds_master": {
-        "url": "ldaps://",
-        "bindDN": "",
-        "bindPassword": "",
-        "cache": {
-            "size": 5000,
-            "age": 60
-        },
-        "clientTimeout": 10000,
-        "maxConnections": 1,
-        "retry": {
-            "initialDelay": 1000
-        }
-    },
-    "wfapi": {
-        "url": "http://workflow.coal.joyent.us"
-    },
-    "vmapi": {
-        "url": "http://vmapi.coal.joyent.us"
-    },
-    "cnapi": {
-        "url": "http://cnapi.coal.joyent.us"
-    },
-    "napi": {
-        "url": "http://napi.coal.joyent.us"
-    },
-    "fwapi": {
-        "url": "http://fwapi.coal.joyent.us"
-    },
-    "imgapi": {
-        "url": "http://imgapi.coal.joyent.us"
-    },
-    "papi": {
-        "url": "http://papi.coal.joyent.us"
-    },
-    "ca": {
-        "url": "http://ca.coal.joyent.us:23181"
-    },
-    "cueballHttpAgent": {
-        "resolvers": ["binder.coal.joyent.us"],
-        "initialDomains": [
-            "mahi.coal.joyent.us"
-        ],
-        "spares": 4,
-        "maximum": 10,
-        "recovery": {
-            "default": {
-                "timeout": 2000,
-                "maxTimeout": 8000,
-                "retries": 5,
-                "delay": 250,
-                "maxDelay": 1000
-            }
-        }
-    },
-    "mahi": {
-        "url": "http://mahi.coal.joyent.us",
-        "maxAuthCacheSize": 1000,
-        "maxAuthCacheAgeMs": 300,
-        "maxTranslationCacheSize": 1000,
-        "maxTranslationCacheAgeMs": 300,
-        "typeTable": {
-          "ip": "ip",
-          "requestip": "ip",
-          "tag": "string"
-        }
-    },
-    "maxHttpSockets": 100,
-    "datacenters": {
-        "coal": "https://cloudapi.coal.joyent.us"
-    },
-    "plugins": [
-        {
-            "name": "provision_limits",
-            "enabled": true,
-            "config": {
-                "datacenter": "coal",
-                "defaults":[{
-                   "image": "any",
-                   "check": "image",
-                   "by": "machines",
-                   "value": 2
-                }, {
-                   "image": "windows",
-                   "check": "image",
-                   "by": "machines",
-                   "value": -1
-                }]
-            }
-        }, 
-        {
-            "name": "capi_limits",
-            "enabled": false,
-            "config": {
-                "datacenter": "coal",
-                "defaults": {
-                    "smartos": 1,
-                    "nodejs": 1,
-                    "ubuntu": 1
-                }
-            }
-        }, {
-            "name": "machine_email",
-            "enabled": false,
-            "config": {
-                "datacenter": "coal",
-                "smtp": {
-                    "host": "127.0.0.1",
-                    "port": 25,
-                    "use_authentication": false,
-                    "user": "",
-                    "pass": ""
-                },
-                "from": "nobody@joyent.com",
-                "subject": "Your SmartDataCenter machine is provisioning",
-                "body": "Check /my/machines for updates"
-            }
-        }
-    ],
-    "ipThrottles": {
-        "all": {
-            "ip": true,
-            "burst": 9,
-            "rate": 3,
-            "overrides": {
-                "10.99.99.14": {
-                    "burst": 0,
-                    "rate": 0
-                },
-                "127.0.0.1": {
-                    "burst": 0,
-                    "rate": 0
-                }
-            }
-        },
-        "analytics": false
-    },
-    "userThrottles": {
-        "all": {
-            "username": true,
-            "burst": 30,
-            "rate": 10,
-            "overrides": {
-                "admin": {
-                    "burst": 0,
-                    "rate": 0
-                }
-            }
-        },
-        "analytics": false
-    }
-}
diff --git a/lib/app.js b/lib/app.js
index 10065bf..e11e02e 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -23,14 +23,15 @@ var https = require('https');
 var util = require('util');
 var path = require('path');
 
-var semver = require('semver');
+var cueball = require('cueball');
+var jsprim = require('jsprim');
+var kang = require('kang');
+var keyapi = require('keyapi');
+var mahi = require('mahi');
 var restify = require('restify');
 var SDC = require('sdc-clients');
+var semver = require('semver');
 var UFDS = require('ufds');
-var keyapi = require('keyapi');
-var mahi = require('mahi');
-var cueball = require('cueball');
-var kang = require('kang');
 
 var account = require('./account');
 var analytics = require('./analytics');
@@ -42,7 +43,6 @@ var docs = require('./docs');
 var keys = require('./keys');
 var machines = require('./machines');
 var metadata = require('./metadata');
-var mod_config = require('./config');
 var nics = require('./nics');
 var packages = require('./packages');
 var services = require('./services');
@@ -55,6 +55,7 @@ var audit = require('./audit');
 var auditLogger = require('./audit_logger');
 var rules = require('./rules');
 var tests = require('./tests');
+var volumeEndpoints = require('./endpoints/volumes');
 
 // Account users, roles and policies:
 var users = require('./users');
@@ -171,7 +172,7 @@ function createUfdsClient(options, callback) {
 
 
 function createHTTPClients(options) {
-    return {
+    var clients = {
         ca: new SDC.CA(options.ca),
         vmapi: new SDC.VMAPI(options.vmapi),
         napi: new SDC.NAPI(options.napi),
@@ -183,6 +184,18 @@ function createHTTPClients(options) {
         mahi: (options.mahi) ? mahi.createClient(options.mahi) : null,
         cns: (options.cns) ? (new SDC.CNS(options.cns)) : null
     };
+    var volapiConfig;
+
+    if (options.experimental_cloudapi_nfs_shared_volumes === true) {
+        volapiConfig = jsprim.deepCopy(options.volapi);
+
+        volapiConfig.version = '^1';
+        volapiConfig.userAgent = 'cloudapi';
+
+        clients.volapi = new SDC.VOLAPI(volapiConfig);
+    }
+
+    return clients;
 }
 
 
@@ -655,6 +668,11 @@ module.exports = {
                 resources.mount(server, userThrottle(config, 'resources'),
                         config);
 
+                if (config.experimental_cloudapi_nfs_shared_volumes === true) {
+                    volumeEndpoints.mount(server,
+                        userThrottle(config, 'volumes'));
+                }
+
                 if (config.test) {
                     tests.mount(server, emptyThrottle(), config);
                 }
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
index df124e3..9d5129f 100644
--- a/lib/endpoints/networks.js
+++ b/lib/endpoints/networks.js
@@ -454,7 +454,7 @@ function deleteFabricNetwork(req, res, next) {
 
         if (!defaultFabricNet) {
             return next(new InternalError('Could not find default fabric ' +
-                'network ' + 'for user'));
+                'network for user'));
         }
 
         req.log.info({
@@ -470,8 +470,7 @@ function deleteFabricNetwork(req, res, next) {
         return req.sdc.napi.deleteFabricNetwork(req.account.uuid,
                 params.vlan_id, params.id, {}, reqOpts(req), function (err) {
             if (err) {
-                next(translateErr(err));
-                return;
+                return next(translateErr(err));
             }
 
             res.send(204);
diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
new file mode 100644
index 0000000..f2a3c67
--- /dev/null
+++ b/lib/endpoints/volumes.js
@@ -0,0 +1,737 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var krill = require('krill');
+var restify = require('restify');
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var errors = require('../errors');
+var mod_networks = require('../networks');
+var predicateValidation = require('../validation/predicate');
+var volumesValidation = require('../validation/volumes');
+
+var DefaultFabricNetworkNotConfiguredError =
+    errors.DefaultFabricNetworkNotConfiguredError;
+
+// NOTE: This function also exists in sdc-volapi lib/endpoints/volumes.js
+//       someday the two should probably be merged into a library.
+function checkInvalidParams(params, validParamNames) {
+    assert.object(params, 'params');
+    assert.arrayOfString(validParamNames, 'validParamNames');
+
+    var errs = [];
+    var paramName;
+
+    for (paramName in params) {
+        if (!params.hasOwnProperty(paramName)) {
+            continue;
+        }
+
+        if (validParamNames.indexOf(paramName) === -1) {
+            errs.push(new Error('invalid parameter: ' + paramName));
+        }
+    }
+
+    return errs;
+}
+
+function validateGetVolumeInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var validationErrs = [];
+    var latestErr;
+
+    latestErr = volumesValidation.validateVolumeId(req.params.id);
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    if (validationErrs.length > 0) {
+        next(validationErrs);
+    } else {
+        next();
+    }
+}
+
+function getVolume(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var getVolumeParams = {
+        owner_uuid: req.account.uuid,
+        uuid: req.params.id
+    };
+    var log = req.log;
+
+    req.sdc.volapi.getVolume(getVolumeParams, {
+        log: req.log,
+        headers: {
+            'x-request-id': req.getId()
+        }
+    }, function onGetVolume(getVolumeErr, volume) {
+        var exposedErr;
+
+        if (getVolumeErr) {
+            log.error({err: getVolumeErr}, 'Error when getting volume');
+            exposedErr = new errors.volapiErrorWrap(getVolumeErr,
+                'Error when getting volume');
+            next(exposedErr);
+            return;
+        }
+
+        req.responseVolume = volume;
+        next();
+    });
+}
+
+//
+// NOTE: This will add the 'listVolumesPredicate' property to the 'req' object
+// if req.query.params.predicate can be turned into a valid predicate.
+//
+function validateListVolumesInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.object(req.query, 'req.query');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var invalidParamsErrs;
+    var latestErr;
+    var predFields;
+    var validationErrs = [];
+    var VALID_PARAM_NAMES = [
+        'name',
+        'predicate',
+        'size',
+        'state',
+        'type'
+    ];
+
+    // Use req.query since that doesn't include 'account' which comes from the
+    // URL rather than query parameters.
+    invalidParamsErrs = checkInvalidParams(req.query, VALID_PARAM_NAMES);
+    validationErrs = validationErrs.concat(invalidParamsErrs);
+
+    if (req.params.name !== undefined) {
+        latestErr =
+            volumesValidation.validateVolumeNameSearchParam(req.params.name);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    if (req.params.type !== undefined) {
+        latestErr = volumesValidation.validateVolumeType(req.params.type);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    if (req.params.size !== undefined) {
+        latestErr =
+            volumesValidation.validateVolumeSizeSearchParam(req.params.size);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    if (req.params.state !== undefined) {
+        latestErr = volumesValidation.validateVolumeState(req.params.state);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    if (req.query.predicate !== undefined) {
+        latestErr =
+            predicateValidation.validatePredicate(req.params.predicate);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        } else {
+            req.listVolumesPredicate =
+                krill.createPredicate(JSON.parse(req.query.predicate));
+
+            predFields = req.listVolumesPredicate.fields();
+            predFields.forEach(function validatePredField(field) {
+                if (req.query[field] !== undefined &&
+                    req.query[field] !== null) {
+
+                    // we have both query parameter and predicate field, invalid
+                    validationErrs.push(new Error('predicate has "' + field
+                        + '" which conflicts with query parameter with same'
+                        + ' name'));
+                }
+            });
+        }
+    }
+
+    if (validationErrs.length > 0) {
+        next(new restify.InvalidArgumentError(validationErrs.join(', ')));
+    } else {
+        next();
+    }
+}
+
+function listVolumes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var listVolumesParams = {
+        owner_uuid: req.account.uuid
+    };
+    var parsedPredicate;
+    var queryParamFields = Object.keys(req.query);
+
+    if (req.params.predicate !== undefined) {
+        // req.listVolumesPredicate must have been set in
+        // validateListVolumesInput
+        assert.object(req.listVolumesPredicate, 'req.listVolumesPredicate');
+
+        parsedPredicate = req.listVolumesPredicate;
+
+        if (parsedPredicate.fields().indexOf('id') !== -1) {
+            parsedPredicate = parsedPredicate.replaceFields({id: 'uuid'});
+        }
+
+        listVolumesParams.predicate = JSON.stringify(parsedPredicate.p_pred);
+    } else if (req.params.state === undefined) {
+        // PUBAPI-1371: When we have no state and no predicate, we should
+        // filter out failed volumes.
+        listVolumesParams.predicate = JSON.stringify({
+            ne: ['state', 'failed']
+        });
+    }
+
+    // We already validated in validateListVolumesInput that this only contains
+    // legitimate parameters, so add them to the listVolumesParams now.
+    queryParamFields.forEach(function addParam(field) {
+        if (field === 'predicate') {
+            // we already added predicate above if set
+            return;
+        }
+
+        listVolumesParams[field] = req.query[field];
+    });
+
+    req.sdc.volapi.listVolumes(listVolumesParams, {
+        log: req.log,
+        headers: {
+            'x-request-id': req.getId()
+        }
+    }, function onListVolumes(listVolumesErr, volumes) {
+        if (listVolumesErr) {
+            next(listVolumesErr);
+            return;
+        }
+
+        res.header('x-query-limit', req.limit);
+        res.header('x-resource-count', volumes.length);
+
+        req.responseVolumes = volumes;
+
+        next();
+    });
+}
+
+function validateCreateVolumeInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var latestErr;
+    var validationErrs = [];
+
+    latestErr = volumesValidation.validateVolumeName(req.params.name,
+        {allowEmpty: true});
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    latestErr = volumesValidation.validateVolumeType(req.params.type);
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    if (req.params.size !== undefined) {
+        latestErr = volumesValidation.validateVolumeSize(req.params.size);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    latestErr = volumesValidation.validateVolumeNetworks(req.params.networks);
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    if (validationErrs.length > 0) {
+        next(new restify.InvalidArgumentError(validationErrs.join(', ')));
+    } else {
+        next();
+    }
+}
+
+function validateListVolumeSizesInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var validationErr;
+
+    if (req.params.type !== undefined) {
+        validationErr = volumesValidation.validateVolumeType(req.params.type);
+    }
+
+    next(validationErr);
+}
+
+function listVolumeSizes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var listVolumeSizesParams = {};
+
+    if (req.params.type !== undefined) {
+        listVolumeSizesParams.type = req.params.type;
+    }
+
+    req.sdc.volapi.listVolumeSizes(listVolumeSizesParams, {
+        log: req.log,
+        headers: {
+            'x-request-id': req.getId()
+        }
+    }, function onListVolumeSizes(listVolumeSizesErr, volumeSizes) {
+        if (listVolumeSizesErr) {
+            next(listVolumeSizesErr);
+            return;
+        }
+
+        assert.arrayOfObject(volumeSizes, 'volumeSizes');
+
+        res.header('x-query-limit', req.limit);
+        res.header('x-resource-count', volumeSizes.length);
+
+        req.responseVolumeSizes = volumeSizes;
+
+        next();
+    });
+}
+
+function renderVolumeSizes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    assert.object(req.responseVolumeSizes, 'req.responseVolumeSizes');
+
+    // Since our response is exactly the same as what we get from volapi
+    // currently, we just return that verbatim.
+    req.renderedResponse = req.responseVolumeSizes;
+    next();
+}
+
+function createVolume(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var log = req.log;
+    var context = {};
+
+    vasync.pipeline({funcs: [
+        function getNetworksFromParams(ctx, done) {
+            if (req.params.networks !== undefined) {
+                mod_networks.checkFabricNetworks(req.sdc.napi,
+                    req.params.networks,
+                    req.account.uuid,
+                    function onFabricNetworksChecked(getFabricNetErr, valid) {
+                        var checkFabricNetworkErr;
+                        if (getFabricNetErr || !valid) {
+                            checkFabricNetworkErr =
+                                new restify.InvalidArgumentError('Invalid ' +
+                                    'networks: ' + req.params.networks);
+                        }
+
+                        ctx.networks = req.params.networks;
+
+                        done(checkFabricNetworkErr);
+                    });
+            } else {
+                log.info({
+                    dataCenterName: req.config.datacenter_name,
+                    accountUuid: req.account.uuid
+                }, 'Getting default fabric network...');
+                mod_networks.getDefaultFabricNetworkForUser(req.sdc.ufds,
+                    req.config.datacenter_name,
+                    req.account, {
+                        log: log
+                    },
+                    function onGetNetwork(getNetworkErr, network) {
+                        var err;
+
+                        if (getNetworkErr) {
+                            log.error({
+                                err: getNetworkErr
+                            }, 'Error when getting default fabric network');
+                        } else {
+                            log.info({
+                                network: network
+                            }, 'Retrieved default fabric network successfully');
+                        }
+
+                        if (network !== undefined) {
+                            ctx.networks = [network.uuid];
+                        } else {
+                            err = new DefaultFabricNetworkNotConfiguredError(
+                                getNetworkErr);
+                        }
+
+                        done(err);
+                    });
+            }
+        },
+        function _createVolume(ctx, done) {
+            assert.arrayOfUuid(ctx.networks, 'ctx.networks');
+
+            var createVolumeParams = {
+                owner_uuid: req.account.uuid,
+                name: req.params.name,
+                type: req.params.type,
+                networks: ctx.networks,
+                size: req.params.size
+            };
+
+            req.sdc.volapi.createVolume(createVolumeParams, {
+                log: req.log,
+                headers: {
+                    'x-request-id': req.getId()
+                }
+            }, function onVolCreated(volCreationErr, volume) {
+                var exposedErr;
+
+                if (volCreationErr) {
+                    log.error({err: volCreationErr},
+                        'Error when creating volume');
+                    exposedErr = new errors.volapiErrorWrap(volCreationErr,
+                        'Error when creating volume');
+                }
+
+                done(exposedErr, volume);
+            });
+        }
+    ], arg: context
+    }, function onVolumeCreationDone(volCreationErr, results) {
+        if (volCreationErr) {
+            req.log.error({
+                err: volCreationErr
+            }, 'Error when creating volume');
+            next(volCreationErr);
+            return;
+        }
+
+        req.responseVolume = results.operations[1].result;
+        next();
+    });
+}
+
+function validateDeleteVolumeInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var latestErr;
+    var validationErrs = [];
+
+    latestErr = volumesValidation.validateVolumeId(req.params.id);
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    if (validationErrs.length > 0) {
+        next(new restify.InvalidArgumentError(validationErrs.join(', ')));
+    } else {
+        next();
+    }
+}
+
+function deleteVolume(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var deleteVolumeParams = {
+        owner_uuid: req.account.uuid,
+        uuid: req.params.id
+    };
+    var log = req.log;
+
+    req.sdc.volapi.deleteVolume(deleteVolumeParams, {
+        log: req.log,
+        headers: {
+            'x-request-id': req.getId()
+        }
+    }, function onVolumeDeleted(volDeletionErr) {
+        var exposedErr;
+
+        if (volDeletionErr) {
+            log.error({err: volDeletionErr}, 'Error when deleting volume');
+            exposedErr = new errors.volapiErrorWrap(volDeletionErr,
+                'Error when deleting volume');
+            next(exposedErr);
+            return;
+        }
+
+        next();
+    });
+}
+
+function validateUpdateVolumeInput(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.query, 'req.query');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var latestErr;
+    var paramName;
+    var validationErrs = [];
+    var VALID_PARAM_NAMES = [ 'account', 'name'];
+
+    if (req.params.name !== undefined) {
+        latestErr = volumesValidation.validateVolumeName(req.params.name);
+        if (latestErr) {
+            validationErrs.push(latestErr);
+        }
+    }
+
+    latestErr = volumesValidation.validateVolumeId(req.params.id);
+
+    if (latestErr) {
+        validationErrs.push(latestErr);
+    }
+
+    for (paramName in req.query) {
+        if (!req.params.hasOwnProperty(paramName)) {
+            continue;
+        }
+
+        if (VALID_PARAM_NAMES.indexOf(paramName) === -1) {
+            validationErrs.push(new restify.InvalidArgumentError(paramName +
+                ' is an invalid parameter'));
+        }
+    }
+
+    if (validationErrs.length > 0) {
+        next(new restify.InvalidArgumentError(validationErrs.join(', ')));
+    } else {
+        next();
+    }
+}
+
+function updateVolume(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    /*
+     * We currently support updating only a volume's name. No other property can
+     * be updated through the UpdateVolume endpoint. Other properties can (or
+     * will be allowed to) be updated by using separate endpoints.
+     */
+    var updateVolumeParams = {
+        owner_uuid: req.account.uuid,
+        uuid: req.params.id,
+        name: req.params.name
+    };
+
+    req.sdc.volapi.updateVolume(updateVolumeParams,
+        function onVolUpdated(volUpdateErr, volume) {
+            var exposedErr;
+
+            if (volUpdateErr) {
+                exposedErr = new errors.volapiErrorWrap(volUpdateErr,
+                    'Error when updating volume');
+                next(exposedErr);
+                return;
+            }
+
+            next(exposedErr);
+        });
+}
+
+function translateVolumeFromVolApi(volapiVolume) {
+    assert.object(volapiVolume, 'volapiVolume');
+
+    var cloudApiVolume = jsprim.deepCopy(volapiVolume);
+
+    cloudApiVolume.id = cloudApiVolume.uuid;
+    delete cloudApiVolume.uuid;
+
+    /*
+     * The fact that a tritonnfs volume is associated with a storage VM is
+     * considered to be an implementation detail that is irrelevant to end
+     * users.
+     */
+    delete cloudApiVolume.vm_uuid;
+
+    return cloudApiVolume;
+}
+
+function renderVolume(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    assert.object(req.responseVolume, 'req.responseVolume');
+
+    req.renderedResponse = translateVolumeFromVolApi(req.responseVolume);
+    next();
+}
+
+function renderVolumes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    assert.object(req.responseVolumes, 'req.responseVolumes');
+
+    req.renderedResponse = req.responseVolumes.map(translateVolumeFromVolApi);
+    next();
+}
+
+function makeSendResponseHandler(options) {
+    assert.object(options, 'options');
+
+    var statusCode = options.statusCode || 200;
+
+    return function sendResponseHandler(req, res, next) {
+        assert.optionalObject(req.renderedResponse, 'req.renderedResponse');
+
+        res.send(statusCode, req.renderedResponse);
+        next();
+    };
+}
+
+function renderEmptyObject(req, res, next) {
+    req.renderedResponse = {};
+    next();
+}
+
+function mountVolumesEndpoints(server, beforeHandler) {
+    assert.object(server, 'server');
+    assert.func(beforeHandler, 'beforeHandler');
+
+    server.get({
+        path: '/:account/volumesizes',
+        name: 'ListVolumeSizes'
+    },
+    beforeHandler,
+    validateListVolumeSizesInput,
+    listVolumeSizes,
+    renderVolumeSizes,
+    makeSendResponseHandler({
+        statusCode: 200
+    }));
+
+    server.get({
+        path: '/:account/volumes/:id',
+        name: 'GetVolume'
+    },
+    beforeHandler,
+    validateGetVolumeInput,
+    getVolume,
+    renderVolume,
+    makeSendResponseHandler({
+        statusCode: 200
+    }));
+
+    server.get({
+        path: '/:account/volumes',
+        name: 'ListVolumes'
+    },
+    beforeHandler,
+    validateListVolumesInput,
+    listVolumes,
+    renderVolumes,
+    makeSendResponseHandler({
+        statusCode: 200
+    }));
+
+    server.post({
+        path: '/:account/volumes',
+        name: 'CreateVolume'
+    },
+    beforeHandler,
+    validateCreateVolumeInput,
+    createVolume,
+    renderVolume,
+    makeSendResponseHandler({
+        statusCode: 201
+    }));
+
+    server.del({
+        path: '/:account/volumes/:id',
+        name: 'DeleteVolume'
+    },
+    beforeHandler,
+    validateDeleteVolumeInput,
+    deleteVolume,
+    /*
+     * Sending an empty body is required for haproxy to forward the
+     * response.
+     */
+    renderEmptyObject,
+    makeSendResponseHandler({
+        statusCode: 204
+    }));
+
+    server.post({
+        path: '/:account/volumes/:id',
+        name: 'UpdateVolume'
+    },
+    beforeHandler,
+    validateUpdateVolumeInput,
+    updateVolume,
+    /*
+     * Sending an empty body is required for haproxy to forward the
+     * response.
+     */
+    renderEmptyObject,
+    /*
+     * We purposedly do _not_ render the updated volume, as we would need to
+     * either:
+     *
+     * 1. render the original volume, which is not useful when we try to update
+     * (change) it.
+     *
+     * 2. render the result of the update, which would require to load the
+     * volume object from moray, adding more latency to the request's response.
+     *
+     * Instead, we reply with a 204 HTTP status code (no content) and clients
+     * can send a GetVolume request if/when they want to get the representation
+     * of the modified volume.
+     */
+    makeSendResponseHandler({
+        statusCode: 204
+    }));
+}
+
+module.exports = {
+    mount: mountVolumesEndpoints
+};
diff --git a/lib/errors.js b/lib/errors.js
index 432192a..69184b0 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -303,7 +303,50 @@ function vmapiErrorWrap(cause, message) {
     }
 }
 
+/**
+ * Selectively expose some VOLAPI error details via a whitelist on restCode.
+ * Other VOLAPI error codes are wrapped such that the error is *logged*, but
+ * only the `statusCode` is exposed.
+ *
+ * Usage:
+ *      next(new errors.volapiErrorWrap(err, 'error deleting tag'));
+ */
+function volapiErrorWrap(cause, message) {
+    assert.object(cause, 'cause');
+    assert.string(message, 'message');
 
+    if (!cause) {
+        return cause;
+    } else if (!cause.restCode) {
+        return new CloudApiError(cause, message);
+    }
+
+    switch (cause.restCode) {
+        case 'VolumeAlreadyExists':
+        case 'VolumeInUse':
+        case 'VolumeNotFound':
+        case 'VolumeSizeNotAvailable':
+        case 'ValidationError':
+            return new ExposedSDCError(cause, message);
+
+        /* By default don't expose internal error message details. */
+        default:
+            return new CloudApiError(cause, message);
+    }
+}
+
+function DefaultFabricNetworkNotConfiguredError(cause) {
+    assert.optionalObject(cause, 'cause');
+
+    var errMsg = 'default_network is not configured for account';
+
+    _FriendlySigRestError.call(this, cause, errMsg);
+}
+
+util.inherits(DefaultFabricNetworkNotConfiguredError, _FriendlySigRestError);
+DefaultFabricNetworkNotConfiguredError.prototype.restCode =
+    'DefaultFabricNetworkNotConfiguredError';
+DefaultFabricNetworkNotConfiguredError.prototype.statusCode = 409;
 
 // ---- exports
 
@@ -315,7 +358,11 @@ module.exports = {
     // Custom error classes.
     CloudApiError: CloudApiError,
 
+    DefaultFabricNetworkNotConfiguredError:
+        DefaultFabricNetworkNotConfiguredError,
+
     // Internal SDC API wrappers
-    vmapiErrorWrap: vmapiErrorWrap
+    vmapiErrorWrap: vmapiErrorWrap,
+    volapiErrorWrap: volapiErrorWrap
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/machines.js b/lib/machines.js
index 954dcef..d9f573c 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -41,6 +41,7 @@ var RestError = restify.RestError;
 var MD_RE = /^metadata\.\w/;
 var TAG_RE = /^tag\..+/;
 var BEFORE_NETWORK_VERSION_RE = /^~?7\.0(\.\d+)?$/;
+var VOLUME_NAME_RE = /^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$/;
 
 var EXTERNAL_NIC_TAG = 'external';
 var INTERNAL_NIC_TAG = 'internal';
@@ -845,10 +846,27 @@ function loadMachine(req, res, next) {
                     }
                 }, function (err, m) {
                     if (err) {
-                        return cb(err);
+                        cb(err);
+                        return;
+                    }
+
+                    /*
+                     * NFS volumes' storage VMs are an implementation detail
+                     * that shouldn't be exposed to end users, so we return a
+                     * 'ResourceNotFoundError' in case a user sends a request
+                     * for such a machine. See RFD 26 at:
+                     * github.com/joyent/rfd/blob/master/rfd/0026/README.md for
+                     * more details.
+                     */
+                    if (m && m.tags && m.tags.smartdc_role &&
+                        m.tags.smartdc_role === 'nfsvolumestorage') {
+                        cb(new ResourceNotFoundError('VM not found'));
+                        return;
                     }
+
                     machine = m;
-                    return cb(null, m);
+                    cb(null, m);
+                    return;
                 });
             },
             function _getImg(_, cb) {
@@ -1106,6 +1124,95 @@ function dnsify(str) {
     return (str.toLowerCase().replace(/[^a-z0-9-]+/g, '-'));
 }
 
+// blatently stolen from sdc-vmapi lib/common/validation.js
+
+function validVolumeName(volumeName) {
+    var VALID_VOLUME_NAME_REGEXP = /^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$/;
+
+    if (typeof (volumeName) !== 'string' ||
+        !VALID_VOLUME_NAME_REGEXP.test(volumeName)) {
+
+        return false;
+    }
+
+    return true;
+}
+
+function validVolumeMountpoint(mountpoint) {
+    if (typeof (mountpoint) !== 'string') {
+        return false;
+    }
+
+    /*
+     * Must start with '/'.
+     */
+    if (mountpoint.length === 0 || mountpoint[0] !== '/') {
+        return false;
+    }
+
+    /*
+     * Must not contain the null character.
+     */
+    if (mountpoint.indexOf('\0') !== -1) {
+        return false;
+    }
+
+    /*
+     * Must contain at least one character that is not '/'.
+     */
+    if (mountpoint.search(/[^\/]/) === -1) {
+        return false;
+    }
+
+    return true;
+}
+
+// stops at first error
+function validateVolume(volume) {
+    var validationErrors = [];
+    var VALID_VOLUME_MODES = ['ro', 'rw'];
+
+    assert.object(volume, 'volume');
+
+    if (volume.type !== undefined && volume.type !== 'tritonnfs') {
+        validationErrors.push(new InvalidArgumentError('unknown volume type "'
+            + volume.type + '"'));
+    }
+
+    if (volume.mode !== undefined &&
+        VALID_VOLUME_MODES.indexOf(volume.mode) === -1) {
+
+        validationErrors.push(new InvalidArgumentError('volume mode for volume '
+            + util.inspect(volume) + ' must be one of '
+            + VALID_VOLUME_MODES.join(', ')));
+    }
+
+    if (!validVolumeName(volume.name)) {
+        validationErrors.push(new InvalidArgumentError('invalid volume name '
+            + 'for volume ' + util.inspect(volume)));
+    }
+
+    if (!validVolumeMountpoint(volume.mountpoint)) {
+        validationErrors.push(new InvalidArgumentError('invalid mount point for'
+            + ' volume ' + util.inspect(volume)));
+    }
+
+    return validationErrors;
+}
+
+function validateVolumes(volumes) {
+    var idx = 0;
+    var validationErrs = [];
+
+    assert.arrayOfObject(volumes, 'volumes');
+
+    for (idx = 0; idx < volumes.length; idx++) {
+        validationErrs = validationErrs.concat(validateVolume(volumes[idx]));
+    }
+
+    return (validationErrs);
+}
+
 function create(req, res, next) {
     assert.ok(req.sdc);
 
@@ -1116,6 +1223,7 @@ function create(req, res, next) {
     var name = req.params.machine;
     var opts;
     var datasetReqs = req.dataset.requirements;
+    var validationErrs;
 
     if (provisionPermission !== 'true' &&
         !req.config.ignore_approved_for_provisioning_flag) {
@@ -1157,6 +1265,28 @@ function create(req, res, next) {
         }
     }
 
+    if (req.params && req.params.volumes && req.params.volumes.length > 0) {
+        if (opts.brand === 'kvm') {
+            // At this time we do not support NFS volumes with KVM
+            return next(new InvalidArgumentError('volumes not yet supported ' +
+                'with brand "kvm"'));
+        }
+
+        if (!req.config.experimental_cloudapi_automount_nfs_shared_volumes) {
+            // If automounting volumes is not enabled, we'll not allow the user
+            // to add them since otherwise they'll be thinking it worked.
+            return next(new InvalidArgumentError('Support for automounting ' +
+                'volumes is not enabled'));
+        }
+
+        validationErrs = validateVolumes(req.params.volumes);
+        if (validationErrs.length > 0) {
+            return next(validationErrs);
+        }
+
+        opts.volumes = req.params.volumes;
+    }
+
     // If trying to provision using a network not provisionable by user,
     // fail early instead of queue and wait for the job to do:
     var networkUuids = req.networks.map(function (n) {
@@ -1440,6 +1570,22 @@ function list(req, res, next) {
         }
     }
 
+    /*
+     * NFS volumes' storage VMs are an implementation detail that shouldn't be
+     * exposed to end users, so we filter them out. See RFD 26 at
+     * https://github.com/joyent/rfd/blob/master/rfd/0026/README.md for more
+     * details.
+     */
+    if (opts && opts.predicate !== undefined) {
+        opts.predicate = JSON.stringify({ and: [
+            JSON.parse(opts.predicate),
+            {ne: ['tags', '*smartdc_role=nfsvolumestorage*']}
+        ]});
+    } else {
+        opts.predicate = JSON.stringify({ne: ['tags',
+            '*smartdc_role=nfsvolumestorage*']});
+    }
+
     opts.owner_uuid = customer;
     // Advanced search, to allow searching any tagged machine (note this
     // overrides any other option):
diff --git a/lib/middlewares/networks.js b/lib/middlewares/networks.js
new file mode 100644
index 0000000..8bc9951
--- /dev/null
+++ b/lib/middlewares/networks.js
@@ -0,0 +1,134 @@
+var assert = require('assert-plus');
+
+var mod_networks = require('../networks');
+
+function loadNetworks(req, res, next) {
+    var method = req.method.toUpperCase();
+    var pathname = req.getUrl().pathname;
+
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    if (pathname === '/--ping') {
+        return next();
+    }
+
+    assert.ok(req.account);
+    var accountUuid = req.account.uuid;
+    assert.ok(accountUuid);
+
+    var netFilterOpts = {
+        provisionable_by: accountUuid
+    };
+
+    if (req.query && req.query.fabric) {
+        netFilterOpts = {
+            fabric: true,
+            owner_uuid: accountUuid
+        };
+    }
+
+
+    // Skip network loading and filtering unless when a request is sent to:
+    //
+    // 1. networks end-points
+    // 2. create a machine
+    // 3. create a nic
+    // 4. update the user's config
+    // 5. create a volume
+    //
+    // As all of the items above require up-to-date networking information being
+    // loaded.
+    if (!/\/networks/.test(pathname) &&
+        !(/\/machines$/.test(pathname) && method === 'POST') &&
+        !(/\/nics$/.test(pathname) && method === 'POST') &&
+        !(/\/config/.test(pathname) && method === 'PUT') &&
+        !(/\/volumes$/.test(pathname) && method === 'POST')) {
+        return next();
+    }
+
+    return napi.listNetworkPools({
+        provisionable_by: accountUuid
+    }, {
+        'x-request-id': req.getId()
+    }, function (err, pools) {
+        if (err) {
+            return next(err);
+        }
+
+        var networks = [];
+        var externalNetworks = [];
+        var internalNetworks = [];
+        var networksInPools = {};
+
+        // Always skip admin network pools:
+        pools = pools.filter(function (pool) {
+            return (pool.nic_tag !== req.config.admin_nic_tag);
+        });
+
+        pools.forEach(function (pool) {
+            var isFabric = false;
+            networks.push(pool);
+
+            pool.networks.forEach(function (net) {
+                networksInPools[net.uuid] = true;
+                if (net.fabric === true) {
+                    isFabric = true;
+                }
+            });
+
+            if (pool.nic_tag === req.config.external_nic_tag) {
+                externalNetworks.push(pool.uuid);
+            } else if (pool.nic_tag === req.config.internal_nic_tag ||
+                isFabric === true) {
+                internalNetworks.push(pool.uuid);
+            }
+        });
+
+        return napi.listNetworks(netFilterOpts, {
+            'x-request-id': req.getId()
+        }, function (err2, nets) {
+            if (err2) {
+                return next(err2);
+            }
+
+            // Always skip admin networks, and don't add networks which are
+            // already in contained pools:
+            nets = nets.filter(function (net) {
+                return net.nic_tag !== req.config.admin_nic_tag &&
+                    !networksInPools[net.uuid];
+            });
+
+            networks = networks.concat(nets);
+
+            networks.forEach(function (net) {
+                if (net.nic_tag === req.config.external_nic_tag) {
+                    externalNetworks.push(net.uuid);
+                } else if (net.nic_tag === req.config.internal_nic_tag ||
+                    net.fabric === true) {
+                    internalNetworks.push(net.uuid);
+                }
+            });
+
+            // uuids of all publically-accessible networks accessible by user
+            req.external_nets = externalNetworks;
+
+            // uuids of all internally-accessible networks accessible by user
+            req.internal_nets = internalNetworks;
+
+            // objects of all networks accessible by user
+            req.networks = networks;
+
+            req.log.debug({
+                external: req.external_nets,
+                internal: req.internal_nets
+            }, 'networks loaded');
+
+            return next();
+        });
+    });
+}
+
+module.exports = {
+    loadNetworks: loadNetworks
+};
\ No newline at end of file
diff --git a/lib/units.js b/lib/units.js
new file mode 100644
index 0000000..702c1fd
--- /dev/null
+++ b/lib/units.js
@@ -0,0 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+module.exports = {
+    MIBS_IN_GB: 1024
+};
\ No newline at end of file
diff --git a/lib/validation/predicate.js b/lib/validation/predicate.js
new file mode 100644
index 0000000..ff7c6fb
--- /dev/null
+++ b/lib/validation/predicate.js
@@ -0,0 +1,87 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var krill = require('krill');
+var VError = require('verror');
+
+var volumesValidation = require('./volumes');
+
+var VOLUME_PREDICATE_TYPES = {
+    id: 'string',
+    name: 'string',
+    network: 'string',
+    size: 'number',
+    state: 'string',
+    type: 'string'
+};
+
+function validatePredicate(predicateString) {
+    assert.string(predicateString, 'predicateString');
+
+    var predicateObject;
+    var predicate;
+    var validationErrs = [];
+    var error;
+    var predicateFieldsAndValues;
+    var predicateField;
+    var VALIDATION_FUNCS = {
+        id: volumesValidation.validateVolumeId,
+        name: volumesValidation.validateVolumeName,
+        network: volumesValidation.validateVolumeNetwork,
+        size: volumesValidation.validateVolumeSize,
+        state: volumesValidation.validateVolumeState,
+        type: volumesValidation.validateVolumeType
+    };
+
+    try {
+        predicateObject = JSON.parse(predicateString);
+    } catch (parseErr) {
+        error = new VError(parseErr, 'Could not parse JSON predicate %s',
+            predicateString);
+    }
+
+    if (!error) {
+        try {
+            predicate = krill.createPredicate(predicateObject,
+                VOLUME_PREDICATE_TYPES);
+        } catch (predicateValidationErr) {
+            error = predicateValidationErr;
+        }
+    }
+
+    if (!error) {
+        predicateFieldsAndValues = predicate.fieldsAndValues();
+
+        for (predicateField in predicateFieldsAndValues) {
+            var validationFunc = VALIDATION_FUNCS[predicateField];
+            var predicateValues = predicateFieldsAndValues[predicateField];
+
+            assert.func(validationFunc, 'validationFunc');
+
+            predicateValues.forEach(function validatePredicateValue(value) {
+                var validationError = validationFunc(value);
+                if (validationError) {
+                    validationErrs.push(validationError);
+                }
+            });
+        }
+    }
+
+    if (validationErrs.length > 0) {
+        error = new Error('Invalid values in predicate: ' + validationErrs);
+    }
+
+    return error;
+}
+
+module.exports = {
+    validatePredicate: validatePredicate
+};
\ No newline at end of file
diff --git a/lib/validation/volumes.js b/lib/validation/volumes.js
new file mode 100644
index 0000000..a8a657f
--- /dev/null
+++ b/lib/validation/volumes.js
@@ -0,0 +1,197 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var restify = require('restify');
+
+
+var VALID_VOLUME_NAME_CHARS_REGEXP = /^[a-zA-Z0-9_\.\-]+$/;
+var VALID_VOLUME_NAME_REGEXP = /^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$/;
+var VALID_VOLUME_SIZE_REGEXP = /^[1-9][0-9]*$/;
+var VALID_VOLUME_TYPES = ['tritonnfs'];
+var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
+
+function validateVolumeId(volumeId) {
+    var err;
+    var validVolumeId = typeof (volumeId) === 'string' &&
+        UUID_RE.test(volumeId);
+
+    if (!validVolumeId) {
+        err = new Error('Invalid volume ID: ' + volumeId + '. Volume ' +
+            'ID should match ' + UUID_RE);
+    }
+
+    return err;
+}
+
+function validateVolumeName(volumeName, opts) {
+    var err;
+    var validVolumeName;
+
+    // Some actions allow non-existent names (empty or undefined), if
+    // opts.allowEmpty is truthy, we'll accept a missing name or empty string
+    // as valid.
+    if (opts && opts.allowEmpty && ((volumeName === undefined) ||
+        (typeof (volumeName) === 'string' && volumeName === ''))) {
+        validVolumeName = true;
+    } else {
+        validVolumeName = typeof (volumeName) === 'string' &&
+            volumeName !== '' &&
+            VALID_VOLUME_NAME_REGEXP.test(volumeName);
+    }
+
+    if (!validVolumeName) {
+        err = new Error('Invalid volume name: ' + volumeName + '. Volume ' +
+            'name should match ' + VALID_VOLUME_NAME_REGEXP);
+    }
+
+    return err;
+}
+
+// NOTE: This duplicates code from sdc-volapi's lib/validation/volumes.js and
+//       should probably eventually be put in a library shared between the two.
+function validateVolumeNameSearchParam(name) {
+    var coreName;
+    var err;
+    var nameBegin;
+    var nameLen;
+
+    if (typeof (name) !== 'string') {
+        err = new Error('name search parameter must be a string');
+        return err;
+    }
+
+    // 'name' is special because we allow '*' as a prefix or suffix for
+    // wildcard searching. As such, we need to validate that the name is
+    // valid whether or not it is surrounded by '*'s.
+    nameBegin = 0;
+    nameLen = name.length;
+
+    if (nameLen > 1 && name[0] === '*') {
+        nameBegin++;
+        nameLen--;
+    }
+
+    if (nameLen > 1 && name[nameBegin + nameLen - 1] === '*') {
+        nameLen--;
+    }
+
+    // coreName is the name w/o the (optional) '*' prefix or suffix
+    coreName = name.substr(nameBegin, nameLen);
+
+    if (!VALID_VOLUME_NAME_CHARS_REGEXP.test(coreName)) {
+        err = new Error('invalid value for name search parameter');
+    }
+
+    return err;
+}
+
+function validateVolumeType(volumeType) {
+    var err;
+    var validVolumeType = typeof (volumeType) === 'string' &&
+        VALID_VOLUME_TYPES.indexOf(volumeType) !== -1;
+
+    if (!validVolumeType) {
+        err = new Error('Invalid volume type: ' + volumeType + '. Volume ' +
+            'type should be one of: ' + VALID_VOLUME_TYPES.join(', '));
+    }
+
+    return err;
+}
+
+function validateVolumeSize(volumeSize) {
+    var err;
+    var validVolumeSize = typeof (volumeSize) === 'number' && volumeSize > 0;
+
+    if (!validVolumeSize) {
+        err = new Error('Invalid volume size: ' + volumeSize);
+    }
+
+    return err;
+}
+
+// NOTE: This duplicates code from sdc-volapi's lib/validation/volumes.js and
+//       should probably eventually be put in a library shared between the two.
+function validateVolumeSizeSearchParam(size) {
+    var err;
+
+    if (typeof (size) !== 'string') {
+        err = new Error('size search parameter must be a string');
+        return err;
+    }
+
+    if (!VALID_VOLUME_SIZE_REGEXP.test(size)) {
+        err = new Error('invalid value for size search parameter, must match '
+            + VALID_VOLUME_SIZE_REGEXP.toString());
+    }
+
+    return err;
+}
+
+function validateVolumeNetwork(volumeNetwork) {
+    var err;
+
+    if (typeof (volumeNetwork) !== 'string' || !UUID_RE.test(volumeNetwork)) {
+        err = new Error('Invalid volume network: ' + volumeNetwork);
+    }
+
+    return err;
+}
+
+function validateVolumeNetworks(volumeNetworks) {
+    var err;
+    var networkValidationErrors = [];
+    var volumeNetworksValid = false;
+
+    if (volumeNetworks === undefined) {
+        volumeNetworksValid = true;
+    } else {
+        if (Array.isArray(volumeNetworks)) {
+            volumeNetworks.forEach(function checkNetworkValidity(network) {
+                var networkValidationErr = validateVolumeNetwork(network);
+                if (networkValidationErr !== undefined) {
+                    networkValidationErrors.push(networkValidationErr);
+                }
+            });
+
+            if (networkValidationErrors.length === 0) {
+                volumeNetworksValid = true;
+            }
+        }
+    }
+
+    if (!volumeNetworksValid) {
+        err = new Error('Invalid networks: ' + volumeNetworks);
+    }
+
+    return err;
+}
+
+function validateVolumeState(state) {
+    var VALID_STATES = ['creating', 'ready', 'failed', 'deleting'];
+    var err;
+
+    if (VALID_STATES.indexOf(state) === -1) {
+        err = new Error('Volume state: ' + state + ' is invalid');
+    }
+
+    return err;
+}
+
+module.exports = {
+    validateVolumeId: validateVolumeId,
+    validateVolumeName: validateVolumeName,
+    validateVolumeNameSearchParam: validateVolumeNameSearchParam,
+    validateVolumeNetwork: validateVolumeNetwork,
+    validateVolumeNetworks: validateVolumeNetworks,
+    validateVolumeSize: validateVolumeSize,
+    validateVolumeSizeSearchParam: validateVolumeSizeSearchParam,
+    validateVolumeState: validateVolumeState,
+    validateVolumeType: validateVolumeType
+};
diff --git a/package.json b/package.json
index 9c037eb..5994491 100644
--- a/package.json
+++ b/package.json
@@ -23,7 +23,8 @@
         "bunyan": "1.8.1",
         "cueball": "2.1.1",
         "kang": "1.1.0",
-        "sdc-clients": "10.2.0",
+        "krill": "1.0.1",
+        "sdc-clients": "git+https://github.com/joyent/node-sdc-clients.git#tritonnfs",
         "ufds": "1.3.0",
         "semver": "2.2.1",
         "nodemailer": "0.3.29",
@@ -38,7 +39,7 @@
         "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
         "jsprim": "0.6.1",
         "strsplit": "1.0.0",
-        "verror": "1.6.1",
+        "verror": "1.10.0",
         "xregexp": "3.1.0"
     },
     "devDependencies": {
diff --git a/sapi_manifests/cloudapi/template b/sapi_manifests/cloudapi/template
index 107f0d5..db5f4fb 100644
--- a/sapi_manifests/cloudapi/template
+++ b/sapi_manifests/cloudapi/template
@@ -68,6 +68,11 @@
     "ca": {
         "url": "http://{{{ca_domain}}}:23181"
     },
+{{#experimental_cloudapi_nfs_shared_volumes}}
+    "volapi": {
+        "url": "http://volapi.{{{datacenter_name}}}.{{{dns_domain}}}"
+    },
+{{/experimental_cloudapi_nfs_shared_volumes}}
     "cueballHttpAgent": {
         "resolvers": ["{{{BINDER_SERVICE}}}"],
         "initialDomains": [
@@ -183,10 +188,19 @@
     {{#CLOUDAPI_IGNORE_APPROVED_FOR_PROVISIONING}}
     "ignore_approved_for_provisioning_flag": true,
     {{/CLOUDAPI_IGNORE_APPROVED_FOR_PROVISIONING}}
+    {{#experimental_cloudapi_nfs_shared_volumes}}
+    "experimental_cloudapi_nfs_shared_volumes": {{{experimental_cloudapi_nfs_shared_volumes}}},
+    {{/experimental_cloudapi_nfs_shared_volumes}}
+    {{#experimental_cloudapi_automount_nfs_shared_volumes}}
+    "experimental_cloudapi_automount_nfs_shared_volumes": {{{experimental_cloudapi_automount_nfs_shared_volumes}}},
+    {{/experimental_cloudapi_automount_nfs_shared_volumes}}
     {{^CLOUDAPI_TEST_MODE}}
-    "test": false
+    "test": false,
     {{/CLOUDAPI_TEST_MODE}}
     {{#CLOUDAPI_TEST_MODE}}
-    "test": {{{CLOUDAPI_TEST_MODE}}}
+    "test": {{{CLOUDAPI_TEST_MODE}}},
     {{/CLOUDAPI_TEST_MODE}}
+    "admin_nic_tag": "admin",
+    "external_nic_tag": "external",
+    "internal_nic_tag": "internal"
 }
diff --git a/test/auth.test.js b/test/auth.test.js
index 2ae9e3a..9684570 100644
--- a/test/auth.test.js
+++ b/test/auth.test.js
@@ -302,6 +302,8 @@ test('tag resource collection with non-existent role', function (t) {
         'role-tag': ['asdasdasdasd']
     }, function (err, req, res, body) {
         t.deepEqual(err, {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Role(s) asdasdasdasd not found',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -360,6 +362,8 @@ test('tag individual resource with non-existent role', function (t) {
         'role-tag': ['asdasdasdasd']
     }, function (err, req, res, body) {
         t.deepEqual(err, {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Role(s) asdasdasdasd not found',
             statusCode: 409,
             restCode: 'InvalidArgument',
diff --git a/test/common.js b/test/common.js
index ac03b25..40524d8 100644
--- a/test/common.js
+++ b/test/common.js
@@ -30,6 +30,7 @@ var NAPI = require('sdc-clients').NAPI;
 var IMGAPI = require('sdc-clients').IMGAPI;
 var PAPI = require('sdc-clients').PAPI;
 var MAHI = require('mahi');
+var VOLAPI = require('sdc-clients').VOLAPI;
 
 var app = require('../lib').app;
 var apertureConfig = require('aperture-config').config;
@@ -207,6 +208,20 @@ function _ufds() {
     });
 }
 
+function _volapi() {
+    return new VOLAPI({
+        version: '^1',
+        userAgent: 'cloudapi-tests',
+        url: process.env.VOLAPI_URL || CONFIG.volapi.url ||
+            'http://10.99.99.41',
+        retry: {
+            retries: 1,
+            minTimeout: 1000
+        },
+        log: LOG,
+        agent: false
+    });
+}
 
 /*
  * Destroy all data associated with a client.
@@ -260,7 +275,16 @@ function clientDataTeardown(client, cb) {
     }
 
     var pollConfigCount = 10;
-    function pollConfigDeletion() {
+    function pollConfigDeletion(err) {
+        if (err) {
+            if (err.restCode !== 'ResourceNotFound') {
+                cb(err);
+            } else {
+                ufds.deleteUser(account, cb);
+            }
+            return;
+        }
+
         --pollConfigCount;
         if (pollConfigCount === 0) {
             cb(new Error('Config failed to delete in time'));
@@ -432,6 +456,7 @@ function setupClient(version, serverUrl, user, keyId, keyPath, parentAcc, cb) {
     client.papi   = _papi();
     client.mahi   = _mahi();
     client.ufds   = _ufds();
+    client.volapi = _volapi();
 
     var ufds = client.ufds;
 
@@ -1004,6 +1029,9 @@ function napiDeleteNicTagByName(opts, cb) {
     });
 }
 
+function createResourceName(prefix) {
+    return prefix + '-' + libuuid.create();
+}
 
 // --- Library
 
@@ -1041,5 +1069,7 @@ module.exports = {
 
     getCfg: function () {
         return CONFIG;
-    }
+    },
+
+    createResourceName: createResourceName
 };
diff --git a/test/fabrics.test.js b/test/fabrics.test.js
index b7fe930..361217a 100644
--- a/test/fabrics.test.js
+++ b/test/fabrics.test.js
@@ -11,20 +11,17 @@
 var assert = require('assert-plus');
 var clone = require('clone');
 var fmt = require('util').format;
-var common = require('./common');
 var test = require('tape').test;
 var vasync = require('vasync');
 
+var common = require('./common');
+var mod_testNetworks = require('./lib/networks');
+
 var checkNotFound = common.checkNotFound;
 
 
 // --- Globals
 
-
-// How often to poll for VLAN / networks:
-var CHECK_INTERVAL = 500;
-// Maximum
-var CHECK_TIMEOUT = 30000;
 var CLIENT;
 var OTHER;
 var CLIENTS;
@@ -411,34 +408,6 @@ function typeMsg(prop, found, exp) {
 }
 
 
-/**
- * Poll for the creation of the default VLAN
- */
-function waitForDefaultVLAN(t) {
-    var start = Date.now();
-    t.pass('Waiting for default fabric VLAN to be created...');
-
-    function _checkVlan() {
-        CLIENT.get('/my/fabrics/default/vlans/2',
-                function (err, req, res, body) {
-            if (body && body.vlan_id) {
-                t.pass('found default vlan');
-                return t.end();
-            }
-
-            if ((Date.now() - start) > CHECK_TIMEOUT) {
-                t.pass('did not found default vlan before timeout');
-                return t.end();
-            }
-
-            return setTimeout(_checkVlan, CHECK_INTERVAL);
-        });
-    }
-
-    _checkVlan();
-}
-
-
 // --- Tests
 
 
@@ -1005,7 +974,7 @@ test('default fabric', TEST_OPTS, function (tt) {
 
     // The default vlan for a user is created
     tt.test('wait for default VLAN creation', function (t) {
-        waitForDefaultVLAN(t);
+        mod_testNetworks.waitForDefaultVLAN(CLIENT, t);
     });
 
 
@@ -1179,7 +1148,7 @@ test('teardown', TEST_OPTS, function (tt) {
         function _delNet(net, cb) {
             CLIENT.del(fmt('/my/fabrics/default/vlans/%d/networks/%s',
                     net.vlan_id, net.id), function (err, req, res, body) {
-                t.ifErr(err, 'delete network');
+                t.ifErr(err, 'delete network ' + net.id);
 
                 t.equal(res.statusCode, 204, 'delete fabric network');
                 common.checkHeaders(t, res.headers);
diff --git a/test/keys.test.js b/test/keys.test.js
index f35778c..16891b4 100644
--- a/test/keys.test.js
+++ b/test/keys.test.js
@@ -235,6 +235,8 @@ test('DeleteKey OK - other', function (t) {
                 code: 'ResourceNotFound',
                 message: 'id_rsa 1 does not exist'
             },
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'id_rsa 1 does not exist',
             name: 'ResourceNotFoundError',
             restCode: 'ResourceNotFound',
diff --git a/test/lib/config.js b/test/lib/config.js
new file mode 100644
index 0000000..39c1bb3
--- /dev/null
+++ b/test/lib/config.js
@@ -0,0 +1,46 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+
+function waitForAccountConfigReady(client, callback) {
+    assert.object(client, 'client');
+    assert.func(callback, 'callback');
+
+    var nbTries = 0;
+    var MAX_NB_TRIES = 20;
+    var TRY_DELAY_IN_MS = 1000;
+
+    function getConfig() {
+        ++nbTries;
+        client.get('/my/config',
+            function onGetConfig(getConfigErr, req, res, ufdsConfig) {
+                if (getConfigErr ||
+                    (ufdsConfig && ufdsConfig.default_network === undefined)) {
+                    if (nbTries >= MAX_NB_TRIES) {
+                        callback(new Error('max number of tries reached'));
+                        return;
+                    } else {
+                        setTimeout(getConfig, TRY_DELAY_IN_MS);
+                        return;
+                    }
+                } else {
+                    callback(null, ufdsConfig);
+                    return;
+                }
+            });
+    }
+
+    getConfig();
+}
+
+module.exports = {
+    waitForAccountConfigReady: waitForAccountConfigReady
+};
\ No newline at end of file
diff --git a/test/lib/networks.js b/test/lib/networks.js
new file mode 100644
index 0000000..749f016
--- /dev/null
+++ b/test/lib/networks.js
@@ -0,0 +1,43 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/**
+ * Poll for the creation of the default VLAN
+ */
+function waitForDefaultVLAN(CLIENT, t) {
+    var CHECK_INTERVAL = 500;
+    var CHECK_TIMEOUT = 30000;
+    var start = Date.now();
+    t.pass('Waiting for default fabric VLAN to be created...');
+
+    function _checkVlan() {
+        CLIENT.get('/my/fabrics/default/vlans/2',
+                function (err, req, res, body) {
+            if (body && body.vlan_id) {
+                t.pass('found default vlan');
+                return t.end();
+            }
+
+            if ((Date.now() - start) > CHECK_TIMEOUT) {
+                t.pass('did not found default vlan before timeout');
+                return t.end();
+            }
+
+            return setTimeout(_checkVlan, CHECK_INTERVAL);
+        });
+    }
+
+    _checkVlan();
+}
+
+
+module.exports = {
+    waitForDefaultVLAN: waitForDefaultVLAN
+};
\ No newline at end of file
diff --git a/test/lib/volumes.js b/test/lib/volumes.js
new file mode 100644
index 0000000..4e62646
--- /dev/null
+++ b/test/lib/volumes.js
@@ -0,0 +1,84 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var verror = require('verror');
+
+function waitForTransitionToState(cloudapiClient, volumeUuid, expectedState,
+    callback) {
+    assert.object(cloudapiClient, 'cloudapiClient');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.string(expectedState, 'expectedState');
+    assert.func(callback, 'callback');
+
+    var MAX_NB_RETRIES = 120;
+    var nbRetriesSoFar = 0;
+    var RETRY_DELAY_IN_MS = 1000;
+
+    function pollVolumeState() {
+        if (nbRetriesSoFar > MAX_NB_RETRIES) {
+            callback();
+        } else {
+            ++nbRetriesSoFar;
+
+            cloudapiClient.get('/my/volumes/' + volumeUuid,
+                function onGetVolume(getVolumeErr, req, res, volume) {
+                    if (!getVolumeErr && volume !== undefined &&
+                        volume.state === expectedState) {
+                        callback();
+                    } else {
+                        setTimeout(pollVolumeState, RETRY_DELAY_IN_MS);
+                    }
+                });
+        }
+    }
+
+    pollVolumeState();
+}
+
+function waitForDeletion(cloudapiClient, volumeUuid, callback) {
+    assert.object(cloudapiClient, 'cloudapiClient');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.func(callback, 'callback');
+
+    var MAX_NB_RETRIES = 120;
+    var nbRetriesSoFar = 0;
+    var RETRY_DELAY_IN_MS = 1000;
+
+    function pollVolumeState() {
+        if (nbRetriesSoFar > MAX_NB_RETRIES) {
+            callback();
+        } else {
+            ++nbRetriesSoFar;
+
+            cloudapiClient.get('/my/volumes/' + volumeUuid,
+                function onGetVolume(getVolumeErr, req, res, volume) {
+                    if (getVolumeErr) {
+                        if (verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError')) {
+
+                            callback();
+                            return;
+                        }
+                        callback(getVolumeErr);
+                    } else {
+                        setTimeout(pollVolumeState, RETRY_DELAY_IN_MS);
+                    }
+                });
+        }
+    }
+
+    pollVolumeState();
+}
+
+module.exports = {
+    waitForTransitionToState: waitForTransitionToState,
+    waitForDeletion: waitForDeletion
+};
diff --git a/test/nics.test.js b/test/nics.test.js
index b40b970..5e358de 100644
--- a/test/nics.test.js
+++ b/test/nics.test.js
@@ -901,6 +901,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.otherVm.uuid + '/nics';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -919,6 +921,8 @@ test('nics', function (tt) {
         var path = '/my/machines/fdc3cefd-1943-4050-ba59-af5680508481/nics';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -937,6 +941,8 @@ test('nics', function (tt) {
         var path = '/my/machines/wowzers/nics';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Invalid Parameters',
             statusCode: 409,
             restCode: 'ValidationFailed',
@@ -1002,6 +1008,8 @@ test('nics', function (tt) {
         // the err message must match the 'Get non-owner NIC from owner machine'
         // test below
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'nic not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1020,6 +1028,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.instId + '/nics/wowzers';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'mac has invalid format',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1039,6 +1049,8 @@ test('nics', function (tt) {
         var path = '/my/machines/wowzers/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Invalid Parameters',
             statusCode: 409,
             restCode: 'ValidationFailed',
@@ -1063,6 +1075,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.otherVm.uuid + '/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1083,6 +1097,8 @@ test('nics', function (tt) {
 
         // the err message must match the 'Get nonexistent NIC' test above
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'nic not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1102,6 +1118,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.otherVm.uuid + '/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1120,6 +1138,8 @@ test('nics', function (tt) {
         var path = '/my/machines/fa9e18e4-654a-43a8-918b-cce04bdbf461/nics/'
             + instNic.mac.replace(/\:/g, '');
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1204,6 +1224,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.otherNetwork.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'owner cannot provision on network',
             statusCode: 403,
             restCode: 'NotAuthorized',
@@ -1223,6 +1245,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.networks[0].network.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1242,6 +1266,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.otherNetwork.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1262,6 +1288,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.networks[1].network.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Server does not support that network',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1281,6 +1309,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.networks[1].pool.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Server does not support that network',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1300,6 +1330,8 @@ test('nics', function (tt) {
         var args = { network: 'wowzers' };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'network argument has invalid format',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1319,6 +1351,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.networks[0].network.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Invalid Parameters',
             statusCode: 409,
             restCode: 'ValidationFailed',
@@ -1343,6 +1377,8 @@ test('nics', function (tt) {
         var args = { network: '05cab1d4-f816-41c0-b45f-a4ffeda5a6b5' };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'network not found',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1362,6 +1398,8 @@ test('nics', function (tt) {
         var args = { network: fixtures.networks[0].network.uuid };
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1381,6 +1419,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.otherVm.uuid + '/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1400,6 +1440,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.instId + '/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'nic not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1419,6 +1461,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.otherVm.uuid + '/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'VM not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
@@ -1437,6 +1481,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.instId + '/nics/wowzers';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'mac has invalid format',
             statusCode: 409,
             restCode: 'InvalidArgument',
@@ -1456,6 +1502,8 @@ test('nics', function (tt) {
         var path = '/my/machines/wowzers/nics/' + mac;
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'Invalid Parameters',
             statusCode: 409,
             restCode: 'ValidationFailed',
@@ -1479,6 +1527,8 @@ test('nics', function (tt) {
         var path = '/my/machines/' + fixtures.instId + '/nics/012345678901';
 
         var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
             message: 'nic not found',
             statusCode: 404,
             restCode: 'ResourceNotFound',
diff --git a/test/volumes-automount.test.js b/test/volumes-automount.test.js
new file mode 100644
index 0000000..df877ce
--- /dev/null
+++ b/test/volumes-automount.test.js
@@ -0,0 +1,695 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var child_process = require('child_process');
+var fs = require('fs');
+var test = require('tape').test;
+var vasync = require('vasync');
+var verror = require('verror');
+
+var common = require('./common');
+var libuuid = require('libuuid');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var mod_testVolumes = require('./lib/volumes');
+
+var machinesCommon = require('./machines/common');
+
+var CONFIG = mod_config.configure();
+var IMGAPI_SOURCE = 'https://images.joyent.com';
+var KEY_FILENAME = '/tmp/cloudapi-test-key';
+var TEST_IMAGE_KVM =
+    'd472f84c-69cf-431c-b848-c5dce6bee153'; // ubuntu-certified-16.04
+var TEST_IMAGE_LX = '7b5981c4-1889-11e7-b4c5-3f3bdfc9b88b'; // ubuntu-16.04
+var TEST_IMAGE_SMARTOS =
+    'ede31770-e19c-11e5-bb6e-3b7de3cca9ce'; // minimal-multiarch-lts (15.4.1)
+var UFDS_ADMIN_UUID = CONFIG.ufds_admin_uuid;
+
+function deleteKeypair(cb) {
+    child_process.exec([
+        'rm',
+        '-f',
+        KEY_FILENAME,
+        KEY_FILENAME + '.pub'
+    ].join(' '), function onKeyPairDeleted(err, stdout, stderr) {
+        cb(err);
+    });
+}
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+    var SSH_PUBLIC_KEY;
+
+    var fooContents;
+    var lxIp;
+    var lxVmDelErr;
+    var lxVmUuid;
+    var networkUuidFabric;
+    var networkUuidSsh;
+    var smartosIp;
+    var smartosVmDelErr;
+    var smartosVmUuid;
+    var testPackage;
+    var testVolumeName = common.createResourceName('test-volumes-automount');
+    var testVolume;
+    var testVolumeStorageVmUuid;
+
+    function getMissingImages(t, missing, callback) {
+        if (missing.length === 0) {
+            callback();
+            return;
+        }
+
+        vasync.forEachParallel({
+            func: function importOneImage(imgUuid, cb) {
+                CLIENT.imgapi.adminImportRemoteImageAndWait(imgUuid,
+                    IMGAPI_SOURCE, {}, cb);
+            }, inputs: missing
+        }, function (err, results) {
+            callback(err);
+        });
+    }
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * We need to provision on a network we can reach from cloudapi, so we use
+     * the first non-admin NIC on this cloudapi instance. That way we know the
+     * VM will be on the same network.
+     */
+    test('find external network', function (t) {
+        child_process.execFile('/usr/sbin/mdata-get', ['sdc:nics'],
+            function onExecOutput(execErr, stdout, stderr) {
+                var idx;
+                var nics;
+
+                t.ifErr(execErr, 'should be able to load sdc:nics');
+                nics = JSON.parse(stdout);
+
+                for (idx = 0; idx < nics.length; idx++) {
+                    if (networkUuidSsh === undefined &&
+                        nics[idx].nic_tag !== 'admin') {
+
+                        networkUuidSsh = nics[idx].network_uuid;
+                    }
+                }
+
+                t.ok(networkUuidSsh, 'found external network: '
+                    + networkUuidSsh);
+                t.end();
+            });
+    });
+
+    /*
+     * Need a fabric network we can use to provision our containers for the NFS
+     * traffic to flow.
+     */
+    test('find fabric network', function (t) {
+        CLIENT.get('/my/networks',
+            function onGetNetworks(getNetworksErr, req, res, networks) {
+                t.ifErr(getNetworksErr, 'getting networks should succeed');
+                if (!getNetworksErr) {
+                    t.ok(Array.isArray(networks),
+                        'networks should be an array');
+                    t.ok(networks.length > 0,
+                        'should have at least one network');
+                    networks.forEach(function findFabric(net) {
+                        if (networkUuidFabric === undefined &&
+                            net.fabric === true) {
+
+                            networkUuidFabric = net.id;
+                        }
+                    });
+
+                    t.ok(networkUuidFabric, 'should have found fabric net, got:'
+                        + ' ' + JSON.stringify(networkUuidFabric));
+
+                    t.end();
+                }
+            });
+    });
+
+    // need a package we can use to provision our containers
+    test('find usable package', function (t) {
+        CLIENT.get('/my/packages',
+            function onGetPackages(getPackageErr, req, res, packages) {
+                t.ifErr(getPackageErr, 'getting packages should succeed');
+                if (!getPackageErr) {
+                    t.ok(Array.isArray(packages),
+                        'packages should be an array');
+                    t.ok(packages.length > 0,
+                        'should have at least one package');
+
+                    // choose the smallest package over 1024
+                    packages.forEach(function choosePackage(pkg) {
+                        if (pkg.memory >= 1024) {
+                            if (testPackage === undefined) {
+                                testPackage = pkg;
+                                return;
+                            }
+
+                            if (pkg.memory < testPackage.memory) {
+                                testPackage = pkg;
+                            }
+                        }
+                    });
+
+                    t.ok(testPackage && testPackage.id,
+                        'should have found package, got: '
+                        + JSON.stringify(testPackage));
+
+                    t.end();
+                }
+            });
+    });
+
+    // Ensure we have required images
+    test('ensure images', function (t) {
+        var foundKvm = false;
+        var foundLx = false;
+        var foundSmartOS = false;
+        var idx = 0;
+        var missing = [];
+
+        CLIENT.get('/my/images',
+            function onGetImages(getImagesErr, req, res, images) {
+                t.ifErr(getImagesErr, 'getting images should succeed');
+
+                if (!getImagesErr) {
+                    t.ok(Array.isArray(images),
+                        'images should be an array');
+                    t.ok(images.length >= 3,
+                        'should have at least three images');
+                }
+
+                for (idx = 0; idx < images.length; idx++) {
+                    if (images[idx].id === TEST_IMAGE_LX) {
+                        foundLx = true;
+                    }
+                    if (images[idx].id === TEST_IMAGE_SMARTOS) {
+                        foundSmartOS = true;
+                    }
+                    if (images[idx].id === TEST_IMAGE_KVM) {
+                        foundKvm = true;
+                    }
+                }
+
+                if (!foundLx) {
+                    missing.push(TEST_IMAGE_LX);
+                }
+
+                if (!foundSmartOS) {
+                    missing.push(TEST_IMAGE_SMARTOS);
+                }
+
+                if (!foundKvm) {
+                    missing.push(TEST_IMAGE_KVM);
+                }
+
+                getMissingImages(t, missing, function (getMissingErr) {
+                    t.ifErr(getMissingErr,
+                        'should have succeeded to get missing images');
+                    t.end();
+                });
+            });
+    });
+
+    // delete previous SSH keypair(s)
+    test('delete previous SSH keypair', function (t) {
+        deleteKeypair(function onDeleted(err) {
+            t.ifErr(err, 'removing keypair should succeed');
+            t.end();
+        });
+    });
+
+    // create an SSH keypair so we can use that to SSH into the test zone we're
+    // going to create.
+    test('create an SSH keypair', function (t) {
+        child_process.exec([
+            'ssh-keygen',
+            '-t rsa',
+            '-N ""',
+            '-f',
+            KEY_FILENAME
+        ].join(' '), function onKeyPairCreated(err, stdout, stderr) {
+            t.ifErr(err, 'ssh-keygen should succeed');
+
+            fs.readFile(KEY_FILENAME + '.pub',
+                function onReadKey(readErr, keyData) {
+                    t.ifErr(readErr, 'reading public key should succeed');
+                    SSH_PUBLIC_KEY = keyData.toString().trim();
+                    t.ok(SSH_PUBLIC_KEY, 'should have found pubic key, got: ' +
+                        SSH_PUBLIC_KEY.substr(0, 20) + '...' +
+                        SSH_PUBLIC_KEY.substr(SSH_PUBLIC_KEY.length - 20));
+                    t.end();
+                });
+
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('creating volume with default params should be successful',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeName,
+                type: 'tritonnfs'
+            }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+                testVolume = volume;
+
+                t.ifErr(volumeCreationErr,
+                    'creating a volume with default parameters should not ' +
+                        'error');
+                t.ok(volume.id, 'new volume has uuid: ' + volume.id);
+                t.end();
+            });
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            var expectedState = 'ready';
+
+            mod_testVolumes.waitForTransitionToState(CLIENT, testVolume.id,
+                expectedState, function onTransition() {
+                    CLIENT.get('/my/volumes/' + testVolume.id,
+                        function onGetVolume(getVolumeErr, req, res, volume) {
+                            t.ifErr(getVolumeErr,
+                                'getting newly created volume should not ' +
+                                    'error');
+                            t.ok(typeof (volume) === 'object' &&
+                                volume !== null,
+                                    'response should be a non-null object');
+                            t.equal(volume.name, testVolumeName,
+                                'volume name should be \'' + testVolumeName +
+                                    '\'');
+                            t.equal(volume.state, expectedState,
+                                'volume should have transitioned to state \'' +
+                                    expectedState + '\'');
+
+                            t.end();
+                        });
+            });
+    });
+
+    test('create an LX container using volume', function (t) {
+        var payload;
+
+        payload = {
+            metadata: {},
+            image: TEST_IMAGE_LX,
+            package: testPackage.id,
+            name: 'cloudapi-volume-lx-' + libuuid.create().split('-')[0],
+            firewall_enabled: false,
+            networks: [
+                {ipv4_uuid: networkUuidSsh, primary: true},
+                {ipv4_uuid: networkUuidFabric}
+            ],
+            volumes: [
+                {
+                    name: testVolumeName,
+                    type: 'tritonnfs',
+                    mode: 'rw',
+                    mountpoint: '/foo'
+                }
+            ]
+        };
+
+        payload['metadata.user-script'] = [
+            '#!/bin/bash',
+            '',
+            'cat > /root/.ssh/authorized_keys <<EOF',
+            SSH_PUBLIC_KEY,
+            'EOF',
+            'chmod 0700 /root/.ssh',
+            'chmod 0600 /root/.ssh/authorized_keys'
+        ].join('\n');
+
+        CLIENT.post('/my/machines', payload, function (err, req, res, body) {
+            t.ifErr(err, 'expect VM create success');
+
+            if (!err) {
+                lxVmUuid = body.id;
+                t.ok(lxVmUuid, 'New VM\'s UUID is ' + lxVmUuid);
+            }
+
+            t.end();
+        });
+    });
+
+    // Wait for container
+    test('waiting for container to go to "running"', function (t) {
+        machinesCommon.waitForRunningMachine(CLIENT, lxVmUuid,
+            function (err) {
+                t.ifError(err, 'waitForRunningMachine ' + lxVmUuid);
+                t.end();
+            });
+    });
+
+    // Get the container IP
+    test('get container IP', function (t) {
+        CLIENT.get('/my/machines/' + lxVmUuid,
+            function onGetMachine(getMachineErr, req, res, machine) {
+                t.ifErr(getMachineErr, 'getting machine should succeed');
+
+                if (!getMachineErr && machine) {
+                    t.ok(machine.primaryIp, 'should have primaryIp, got: '
+                        + machine.primaryIp);
+                    lxIp = machine.primaryIp;
+                }
+
+                t.end();
+            });
+    });
+
+    // write a file
+    test('write a file to volume from LX', function (t) {
+        fooContents = 'hello from ' + lxVmUuid;
+        child_process.execFile('/usr/bin/ssh', [
+            '-i', KEY_FILENAME,
+            '-o StrictHostKeyChecking=no',
+            '-o LogLevel=ERROR',
+            '-o UserKnownHostsFile=/dev/null',
+            'root@' + lxIp,
+            'echo "' + fooContents + '" > /foo/fooFile'
+        ], function onExecOutput(execErr, stdout, stderr) {
+            t.ifErr(execErr, 'write to file should succeed');
+
+            t.equal(stderr, '', 'stderr should be empty');
+
+            t.end();
+        });
+    });
+
+    test('deleting LX container should be successful', function (t) {
+        CLIENT.del('/my/machines/' + lxVmUuid,
+            function onDelVm(delVmErr) {
+                lxVmDelErr = delVmErr;
+                t.ifErr(delVmErr, 'deleting LX VM should succeed');
+                t.end();
+            });
+    });
+
+    // since restify clients don't allow us to get the DELETE body so that we
+    // could poll the job, we'll just poll the VM's state.
+    test('wait for container to be deleted', function (t) {
+        var attempt = 0;
+        var state;
+
+        function getState() {
+            CLIENT.get('/my/machines/' + lxVmUuid,
+                function onGetMachine(getMachineErr, req, res, machine) {
+                    // 410 means the VM was deleted
+                    if (getMachineErr) {
+                        if (getMachineErr.statusCode === 410 &&
+                            machine && machine.state === 'deleted') {
+
+                            // pretend like restify knows how to handle this
+                            getMachineErr = undefined;
+                        } else {
+                            t.ifErr(getMachineErr,
+                                'getting machine should succeed');
+                        }
+                    }
+
+                    if (!getMachineErr && machine) {
+                        attempt++;
+                        t.ok(machine.state, 'should have state, got: '
+                            + machine.state + ' (try ' + attempt + ')');
+                        state = machine.state;
+                        if (state === 'deleted') {
+                            t.end();
+                        } else {
+                            setTimeout(getState, 5000);
+                        }
+                    } else {
+                        t.end();
+                    }
+                });
+        }
+
+        if (lxVmDelErr) {
+            t.fail('DeleteVm request failed, so there is no point in waiting ' +
+                'for the container to be deleted');
+            t.end();
+        } else if (lxVmUuid === undefined) {
+            t.fail('LX container was not provisioned, marking test as failed ' +
+                'because it is not relevant to delete a container that was ' +
+                'not created');
+            t.end();
+        } else {
+            getState();
+        }
+    });
+
+    test('create a SmartOS container using volume', function (t) {
+        var payload;
+
+        payload = {
+            metadata: {},
+            image: TEST_IMAGE_SMARTOS,
+            package: testPackage.id,
+            name: 'cloudapi-volume-smartos-' + libuuid.create().split('-')[0],
+            firewall_enabled: false,
+            networks: [
+                {ipv4_uuid: networkUuidSsh, primary: true},
+                {ipv4_uuid: networkUuidFabric}
+            ],
+            volumes: [
+                {
+                    name: testVolumeName,
+                    type: 'tritonnfs',
+                    mode: 'rw',
+                    mountpoint: '/foo'
+                }
+            ]
+        };
+
+        payload['metadata.user-script'] = [
+            '#!/bin/bash',
+            '',
+            'cat > /root/.ssh/authorized_keys <<EOF',
+            SSH_PUBLIC_KEY,
+            'EOF',
+            'chmod 0700 /root/.ssh',
+            'chmod 0600 /root/.ssh/authorized_keys'
+        ].join('\n');
+
+        CLIENT.post('/my/machines', payload, function (err, req, res, body) {
+            t.ifErr(err, 'expect VM create success');
+
+            if (!err) {
+                smartosVmUuid = body.id;
+                t.ok(smartosVmUuid, 'New VM\'s UUID is ' + smartosVmUuid);
+            }
+
+            t.end();
+        });
+    });
+
+    // Wait for container
+    test('waiting for container to go to "running"', function (t) {
+        machinesCommon.waitForRunningMachine(CLIENT, smartosVmUuid,
+            function (err) {
+                t.ifError(err, 'waitForRunningMachine ' + smartosVmUuid);
+                t.end();
+            });
+    });
+
+    // Get the container IP
+    test('get container IP', function (t) {
+        CLIENT.get('/my/machines/' + smartosVmUuid,
+            function onGetMachine(getMachineErr, req, res, machine) {
+                t.ifErr(getMachineErr, 'getting machine should succeed');
+
+                if (!getMachineErr && machine) {
+                    t.ok(machine.primaryIp, 'should have primaryIp, got: '
+                        + machine.primaryIp);
+                    smartosIp = machine.primaryIp;
+                }
+
+                t.end();
+            });
+    });
+
+    // write a file
+    test('read the file created by LX container', function (t) {
+        child_process.execFile('/usr/bin/ssh', [
+            '-i', KEY_FILENAME,
+            '-o StrictHostKeyChecking=no',
+            '-o LogLevel=ERROR',
+            '-o UserKnownHostsFile=/dev/null',
+            'root@' + smartosIp,
+            'cat /foo/fooFile'
+        ], function onExecOutput(execErr, stdout, stderr) {
+            t.ifErr(execErr, 'write to file should succeed');
+
+            t.equal(stdout.trim(), fooContents,
+                '/foo/fooFile should have expected contents');
+            t.equal(stderr, '', 'stderr should be empty');
+
+            t.end();
+        });
+    });
+
+    test('deleting SmartOS container should be successful', function (t) {
+        CLIENT.del('/my/machines/' + smartosVmUuid,
+            function onDelVm(delVmErr) {
+                smartosVmDelErr = delVmErr;
+                t.ifErr(delVmErr, 'deleting SmartOS VM should succeed');
+                t.end();
+            });
+    });
+
+    // since restify clients don't allow us to get the DELETE body so that we
+    // could poll the job, we'll just poll the VM's state.
+    test('wait for container to be deleted', function (t) {
+        var attempt = 0;
+        var state;
+
+        function getState() {
+            CLIENT.get('/my/machines/' + smartosVmUuid,
+                function onGetMachine(getMachineErr, req, res, machine) {
+                    // 410 means the VM was deleted
+                    if (getMachineErr) {
+                        if (getMachineErr.statusCode === 410 &&
+                            machine && machine.state === 'deleted') {
+
+                            // pretend like restify knows how to handle this
+                            getMachineErr = undefined;
+                        } else {
+                            t.ifErr(getMachineErr,
+                                'getting machine should succeed');
+                        }
+                    }
+
+                    if (!getMachineErr && machine) {
+                        attempt++;
+                        t.ok(machine.state, 'should have state, got: '
+                            + machine.state + ' (try ' + attempt + ')');
+                        state = machine.state;
+                        if (state === 'deleted') {
+                            t.end();
+                        } else {
+                            setTimeout(getState, 5000);
+                        }
+                    } else {
+                        t.end();
+                    }
+                });
+        }
+
+        if (smartosVmUuid === undefined) {
+            t.fail('No SmartOS VM UUID, so there is no point in trying to ' +
+                'delete it');
+            t.end();
+        } else if (smartosVmDelErr) {
+            t.fail('Error when sending DeleteVM request, so there is no ' +
+                'point in waiting for the VM to be deleted');
+            t.end();
+        } else {
+            getState();
+        }
+    });
+
+    test('creating a KVM container using volume should fail', function (t) {
+        var payload;
+
+        payload = {
+            metadata: {},
+            image: TEST_IMAGE_KVM,
+            package: testPackage.id,
+            name: 'cloudapi-volume-kvm-' + libuuid.create().split('-')[0],
+            firewall_enabled: false,
+            networks: [
+                {ipv4_uuid: networkUuidSsh, primary: true},
+                {ipv4_uuid: networkUuidFabric}
+            ],
+            volumes: [
+                {
+                    name: testVolumeName,
+                    type: 'tritonnfs',
+                    mode: 'rw',
+                    mountpoint: '/foo'
+                }
+            ]
+        };
+
+        CLIENT.post('/my/machines', payload, function (err, req, res, body) {
+            t.ok(err, 'expect VM create failure');
+            t.equal(err.statusCode, 409, 'expected 409');
+            t.equal(err.message, 'volumes not yet supported with brand "kvm"',
+                'expected error due to unsupported kvm');
+
+            t.end();
+        });
+    });
+
+
+    test('deleting volume should be successful', function (t) {
+        CLIENT.del('/my/volumes/' + testVolume.id,
+            function onDelVolume(delVolumeErr) {
+                t.ifErr(delVolumeErr,
+                    'deleting newly created volume should not error');
+                t.end();
+            });
+    });
+
+    test('volume should eventually disappear', function (t) {
+        mod_testVolumes.waitForDeletion(CLIENT, testVolume.id,
+            function onDeleted() {
+                CLIENT.get('/my/volumes/' + testVolume.id,
+                    function onGetVolume(getVolumeErr) {
+                        t.ok(verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError'), 'expected ' +
+                            'VolumeNotFoundError error, got: ' +
+                            (getVolumeErr ? getVolumeErr.name :
+                            JSON.stringify(getVolumeErr)));
+
+                        t.end();
+                });
+        });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function onTeardown(err) {
+            t.ifErr(err, 'teardown should be successful, got: '
+                + (err ? err.message : 'SUCCESS'));
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-basic.test.js b/test/volumes-basic.test.js
new file mode 100644
index 0000000..dccbfec
--- /dev/null
+++ b/test/volumes-basic.test.js
@@ -0,0 +1,334 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var verror = require('verror');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var mod_testVolumes = require('./lib/volumes');
+
+var CONFIG = mod_config.configure();
+
+/*
+ * This regular expression is not meant to match the general ISO 8601 format,
+ * only the specific format outputted by new Date().toISOString().
+ */
+var ISO_DATE_STRING_RE = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/;
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    var testVolumeName = common.createResourceName('test-volumes-basic');
+    var testVolume;
+    var testVolumeStorageVmUuid;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('creating volume with default params should be successful',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeName,
+                type: 'tritonnfs'
+            }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+                var expectedState = 'creating';
+                var expectedType = 'tritonnfs';
+
+                testVolume = volume;
+
+                t.ifErr(volumeCreationErr,
+                    'creating a volume with default parameters should not ' +
+                        'error');
+                t.ok(testVolume, 'returned volume should be an object');
+                t.equal(testVolume.type, 'tritonnfs',
+                    'newly created volume should have type \'' + expectedType +
+                        '\'');
+                t.equal(testVolume.state, 'creating',
+                    'volume should have state \'' + expectedState + '\'');
+                t.equal(testVolume.vm_uuid, undefined,
+                    'vm_uuid property should not be present in the response');
+                t.ok(ISO_DATE_STRING_RE.test(testVolume.create_timestamp),
+                    'create_timestamp field should match ' +
+                        ISO_DATE_STRING_RE);
+
+                t.end();
+            });
+    });
+
+    test('listing volumes should include newly created volume', function (t) {
+        CLIENT.get('/my/volumes',
+            function onVolumesListed(volumesListErr, req, res, volumes) {
+                var volumesWithNewlyCreatedVolumeName;
+                var createTimestamp;
+
+                t.ifErr(volumesListErr, 'listing volumes shoult not error');
+                t.ok(Array.isArray(volumes),
+                    'response should be an array of volumes');
+                t.ok(volumes.length >= 1,
+                    'volumes array should have at least one item');
+                volumesWithNewlyCreatedVolumeName =
+                    volumes.filter(function hasNewlyCreatedVolumeName(volume) {
+                        return volume.name === testVolumeName;
+                    });
+                t.ok(volumesWithNewlyCreatedVolumeName.length, 1,
+                    'Only one volume should have name ' + testVolumeName);
+                t.equal(volumesWithNewlyCreatedVolumeName[0].vm_uuid, undefined,
+                    'vm_uuid property should not be present in the response');
+
+                createTimestamp =
+                    volumesWithNewlyCreatedVolumeName[0].create_timestamp;
+                t.ok(ISO_DATE_STRING_RE.test(createTimestamp),
+                    'create_timestamp field should match ' +
+                        ISO_DATE_STRING_RE);
+
+                t.end();
+            });
+    });
+
+    test('getting newly created volume should succeeded', function (t) {
+        CLIENT.get('/my/volumes/' + testVolume.id,
+            function onGetVolume(getVolumeErr, req, res, volume) {
+                t.ifErr(getVolumeErr,
+                    'getting newly created volume should not error');
+                t.ok(typeof (volume) === 'object' && volume !== null,
+                    'response should be a non-null object ');
+                t.equal(volume.name, testVolumeName,
+                    'volume name should be \'' + testVolumeName + '\'');
+                t.equal(testVolume.vm_uuid, undefined,
+                    'vm_uuid property should not be present in the response');
+                t.ok(ISO_DATE_STRING_RE.test(testVolume.create_timestamp),
+                    'create_timestamp field should match ' +
+                        ISO_DATE_STRING_RE);
+
+                t.end();
+            });
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            var expectedState = 'ready';
+
+            mod_testVolumes.waitForTransitionToState(CLIENT, testVolume.id,
+                expectedState, function onTransition() {
+                    CLIENT.get('/my/volumes/' + testVolume.id,
+                        function onGetVolume(getVolumeErr, req, res, volume) {
+                            t.ifErr(getVolumeErr,
+                                'getting newly created volume should not ' +
+                                    'error');
+                            t.ok(typeof (volume) === 'object' &&
+                                volume !== null,
+                                    'response should be a non-null object');
+                            t.equal(volume.name, testVolumeName,
+                                'volume name should be \'' + testVolumeName +
+                                    '\'');
+                            t.equal(volume.state, expectedState,
+                                'volume should have transitioned to state \'' +
+                                    expectedState + '\'');
+
+                            t.end();
+                        });
+            });
+    });
+
+    test('getting volume directly through VOLAPI', function (t) {
+        CLIENT.volapi.getVolume({
+            uuid: testVolume.id
+        }, function onGetVol(getVolErr, volume) {
+            t.ifErr(getVolErr,
+                'getting volume through VOLAPI should not error');
+            t.ok(volume, 'a volume should be found');
+            t.ok(volume.vm_uuid, 'volume should have a VM uuid');
+
+            testVolumeStorageVmUuid = volume.vm_uuid;
+
+            t.end();
+        });
+    });
+
+    test('listing machines should NOT include volume\'s storage VM',
+        function (t) {
+            CLIENT.get('/my/machines',
+                function onMachinesListed(machinesListErr, req, res, machines) {
+                    var machinesWithStorageVmUuid;
+
+                    t.ifErr(machinesListErr,
+                        'listing machines should not error');
+
+                    if (machines && machines.length > 0) {
+                        machinesWithStorageVmUuid =
+                            machines.filter(function hasStorageVmUuid(machine) {
+                                return machine.id === testVolumeStorageVmUuid;
+                            });
+
+                        t.ok(machinesWithStorageVmUuid.length, 0,
+                            'No machine should have uuid of a storage VM uuid');
+                    } else {
+                        t.ok(!machines || machines.length === 0,
+                            'listing machines returned an empty list');
+                    }
+
+                    t.end();
+                });
+        });
+
+    test('getting nfs volume\'s storage VM should error', function (t) {
+        CLIENT.get('/my/machines/' + testVolumeStorageVmUuid,
+            function onMachineGet(machineGetErr, req, res, machine) {
+                var expectedErrCode = 'ResourceNotFound';
+
+                t.ok(machineGetErr,
+                    'getting storage VM machine should error');
+                t.equal(machineGetErr.restCode, expectedErrCode,
+                    'error code should be: ' + expectedErrCode);
+
+                t.end();
+            });
+    });
+
+    test('sending HEAD req for nfs volume\'s storage VM should error',
+        function (t) {
+            CLIENT.head('/my/machines/' + testVolumeStorageVmUuid,
+                function onMachineHead(machineHeadErr, req, res, machine) {
+                    var expectedStatusCode = 404;
+
+                    t.ok(machineHeadErr,
+                        'sending HEAD request for storage VM machine should ' +
+                            'error');
+                    t.equal(machineHeadErr.statusCode, expectedStatusCode,
+                        'status code should be: ' + expectedStatusCode);
+
+                    t.end();
+                });
+        });
+
+    test('updating nfs volume\'s storage VM should error', function (t) {
+        CLIENT.post('/my/machines/' + testVolumeStorageVmUuid,
+            function onMachineUpdate(machineUpdateErr, req, res, machine) {
+                var expectedErrCode = 'ResourceNotFound';
+
+                t.ok(machineUpdateErr,
+                    'updating storage VM machine should error');
+                t.equal(machineUpdateErr.restCode, expectedErrCode,
+                    'error code should be: ' + expectedErrCode);
+
+                t.end();
+            });
+    });
+
+    test('deleting nfs volume\'s storage VM should error', function (t) {
+        CLIENT.del('/my/machines/' + testVolumeStorageVmUuid,
+            function onMachineDel(machineDelErr, req, res, machine) {
+                var expectedErrCode = 'ResourceNotFound';
+
+                t.ok(machineDelErr,
+                    'deleting storage VM machine should error');
+                t.equal(machineDelErr.restCode, expectedErrCode,
+                    'error code should be: ' + expectedErrCode);
+
+                t.end();
+            });
+    });
+
+    test('deleting volume should be successful', function (t) {
+        CLIENT.del('/my/volumes/' + testVolume.id,
+            function onDelVolume(delVolumeErr) {
+                t.ifErr(delVolumeErr,
+                    'deleting newly created volume should not error');
+                t.end();
+            });
+    });
+
+    test('volume should eventually disappear', function (t) {
+        mod_testVolumes.waitForDeletion(CLIENT, testVolume.id,
+            function onDeleted() {
+                CLIENT.get('/my/volumes/' + testVolume.id,
+                    function onGetVolume(getVolumeErr) {
+                        t.ok(verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError'), 'expected ' +
+                            'VolumeNotFoundError error, got: ' +
+                            (getVolumeErr ? getVolumeErr.name :
+                            JSON.stringify(getVolumeErr)));
+
+                        t.end();
+                });
+        });
+    });
+
+    // We created and deleted some VMs above. Without a predicate or a state
+    // filter, we should not see any 'deleted' or 'failed' in a default query.
+    test('/my/volumes should not include deleted or failed by default',
+        function (t) {
+
+            CLIENT.get('/my/volumes',
+                function onGetVolumes(getVolumesErr, req, res, volumes) {
+                    var idx;
+                    var state;
+                    var statesFound = {};
+
+                    t.ifErr(getVolumesErr, 'getting volumes should succeed');
+                    t.ok(typeof (volumes) === 'object' &&
+                    volumes !== null,
+                        'response should be a non-null object');
+
+                    for (idx = 0; idx < volumes.length; idx++) {
+                        state = volumes[idx].state;
+                        if (!statesFound.hasOwnProperty(state)) {
+                            statesFound[state] = 0;
+                        }
+                        statesFound[state]++;
+                    }
+
+                    t.equal(statesFound['failed'], undefined,
+                        'results should include no failed volumes');
+                    t.equal(statesFound['deleted'], undefined,
+                        'results should include no deleted volumes');
+
+                    t.end();
+                });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function onTeardown(err) {
+            t.ifErr(err, 'teardown should be successful, got: ' + err);
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-create-name.test.js b/test/volumes-create-name.test.js
new file mode 100644
index 0000000..4e6b779
--- /dev/null
+++ b/test/volumes-create-name.test.js
@@ -0,0 +1,147 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var vasync = require('vasync');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testVolumes = require('./lib/volumes');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    var createdVolumes = [];
+    var testVolume;
+    var testVolumeStorageVmUuid;
+
+    function onVolumeCreatedCreator(t) {
+        return function onVolumeCreated(volumeCreationErr, req, res, volume) {
+            if (!volumeCreationErr && volume) {
+                createdVolumes.push(volume);
+                testVolume = volume;
+            }
+
+            t.ifErr(volumeCreationErr,
+                'creating a volume with no name should succeed');
+            t.ok(testVolume, 'should have set testVolume');
+            t.ok((testVolume.name.length > 1),
+                'returned volume should have a name, got: '
+                + JSON.stringify(testVolume.name));
+
+            t.end();
+        };
+    }
+
+    function volumeReadyWaiter(t) {
+        var expectedState = 'ready';
+
+        mod_testVolumes.waitForTransitionToState(CLIENT, testVolume.id,
+            expectedState, function onTransition() {
+                CLIENT.get('/my/volumes/' + testVolume.id,
+                    function onGetVolume(getVolumeErr, req, res, volume) {
+                        t.ifErr(getVolumeErr,
+                            'getting newly created volume should succeed');
+                        t.equal(volume.state, expectedState,
+                            'volume should have transitioned to state \'' +
+                                expectedState + '\'');
+
+                        t.end();
+                    });
+        });
+    }
+
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    // first create with no name field passed at all
+
+    test('creating volume with no name',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                type: 'tritonnfs'
+            }, onVolumeCreatedCreator(t));
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            volumeReadyWaiter(t);
+    });
+
+    // second, create with empty string for a name (results should be same)
+
+    test('creating volume with no name',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: '',
+                type: 'tritonnfs'
+            }, onVolumeCreatedCreator(t));
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            volumeReadyWaiter(t);
+    });
+
+    test('deleting volumes should be successful', function (t) {
+        vasync.forEachParallel({
+            func: function deleteVolume(volume, done) {
+                CLIENT.del('/my/volumes/' + volume.id,
+                    function onDelVolume(delVolumeErr) {
+                        t.ifErr(delVolumeErr,
+                            'deleting volume ' + volume.name
+                            + ' should succeed');
+                        done();
+                    });
+            },
+            inputs: createdVolumes
+        }, function deleteDone(err) {
+            t.end();
+        });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-create-validation.test.js b/test/volumes-create-validation.test.js
new file mode 100644
index 0000000..df8dbe9
--- /dev/null
+++ b/test/volumes-create-validation.test.js
@@ -0,0 +1,176 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var libuuid = require('libuuid');
+var test = require('tape').test;
+var vasync = require('vasync');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var CONFIG = mod_config.configure();
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT  = clients.user;
+            SERVER  = server;
+
+            t.end();
+        });
+    });
+
+    test('creating volume with invalid name fails', function (t) {
+        var invalidVolumeName = '-invalid-volume-name';
+
+        CLIENT.post('/my/volumes', {
+            name: invalidVolumeName,
+            type: 'tritonnfs'
+        }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+            var expectedStatusCode = 409;
+            var expectedRestCode = 'InvalidArgument';
+            var expectedErrorMsg = 'Invalid volume name: ' + invalidVolumeName;
+
+            t.ok(volumeCreationErr,
+                'creating a volume with an invalid name should error');
+            t.equal(volumeCreationErr.restCode, expectedRestCode,
+                'rest code should be ' + expectedRestCode);
+            t.equal(volumeCreationErr.statusCode, expectedStatusCode,
+                'status code should be ' + expectedStatusCode);
+            t.ok(volumeCreationErr.message.indexOf(expectedErrorMsg) !== -1,
+                'error message should include: ' + expectedErrorMsg);
+
+            t.end();
+        });
+    });
+
+    test('creating volume with invalid type fails', function (t) {
+        var testVolumeName =
+            common.createResourceName('test-volumes-basic-invalid-type');
+        var invalidVolumeType = 'invalid-volume-type';
+
+        CLIENT.post('/my/volumes', {
+            name: testVolumeName,
+            type: invalidVolumeType
+        }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+            var expectedStatusCode = 409;
+            var expectedRestCode = 'InvalidArgument';
+            var expectedErrorMsg = 'Invalid volume type: ' + invalidVolumeType;
+
+            t.ok(volumeCreationErr,
+                'creating a volume with an invalid type should error');
+            t.equal(volumeCreationErr.restCode, expectedRestCode,
+                'rest code should be ' + expectedRestCode);
+            t.equal(volumeCreationErr.statusCode, expectedStatusCode,
+                'status code should be ' + expectedStatusCode);
+            t.ok(volumeCreationErr.message.indexOf(expectedErrorMsg) !== -1,
+                'error message should include: ' + expectedErrorMsg);
+
+            t.end();
+        });
+    });
+
+    test('creating volume with invalid size fails', function (t) {
+        var invalidVolumeSize = 'invalid-volume-size';
+        var testVolumeName =
+            common.createResourceName('test-volumes-basic-invalid-size');
+        var testVolumeType = 'tritonnfs';
+
+        CLIENT.post('/my/volumes', {
+            name: testVolumeName,
+            type: testVolumeType,
+            size: invalidVolumeSize
+        }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+            var expectedStatusCode = 409;
+            var expectedRestCode = 'InvalidArgument';
+            var expectedErrorMsg = 'Invalid volume size: ' + invalidVolumeSize;
+
+            t.ok(volumeCreationErr,
+                'creating a volume with an invalid type should error');
+            t.equal(volumeCreationErr.restCode, expectedRestCode,
+                'rest code should be ' + expectedRestCode);
+            t.equal(volumeCreationErr.statusCode, expectedStatusCode,
+                'status code should be ' + expectedStatusCode);
+            t.ok(volumeCreationErr.message.indexOf(expectedErrorMsg) !== -1,
+                'error message should include: ' + expectedErrorMsg);
+
+            t.end();
+        });
+    });
+
+    test('creating volume with invalid network fails', function (t) {
+        var invalidNetworksInputs = [
+            'invalid-network',
+            /*
+             * Passing random UUIDs as network input parameters should fail, as
+             * CloudAPI should check if they're valid fabric networks owner by
+             * the test user.
+             */
+            libuuid.create(),
+            [libuuid.create()],
+            ['invalid-network'],
+            {},
+            42
+        ];
+        var testContainerNamePrefix = 'test-volumes-basic-invalid-network';
+
+        vasync.forEachParallel({
+            func: function createVolWithInvalidNetworks(invalidNetworks, done) {
+                var testVolumeName =
+                    common.createResourceName(testContainerNamePrefix);
+                var testVolumeType = 'tritonnfs';
+
+                CLIENT.post('/my/volumes', {
+                    name: testVolumeName,
+                    type: testVolumeType,
+                    networks: invalidNetworks
+                }, function onVolumeCreated(volCreationErr, req, res, volume) {
+                    var expectedStatusCode = 409;
+                    var expectedRestCode = 'InvalidArgument';
+                    var expectedErrorMsg = 'Invalid networks: ' +
+                        invalidNetworks;
+                    var actualErrMsg;
+
+                    if (volCreationErr) {
+                        actualErrMsg = volCreationErr.message;
+                    }
+
+                    t.ok(volCreationErr,
+                        'creating a volume with a network input parameter ' +
+                            'of: ' + invalidNetworks + ' should error');
+                    t.equal(volCreationErr.restCode, expectedRestCode,
+                        'rest code should be ' + expectedRestCode);
+                    t.equal(volCreationErr.statusCode, expectedStatusCode,
+                        'status code should be ' + expectedStatusCode);
+                    t.ok(actualErrMsg.indexOf(expectedErrorMsg) !== -1,
+                        'error message should include: ' + expectedErrorMsg);
+
+                    done();
+                });
+            },
+            inputs: invalidNetworksInputs
+        }, function onAllTestsDone() {
+            t.end();
+        });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
\ No newline at end of file
diff --git a/test/volumes-get.test.js b/test/volumes-get.test.js
new file mode 100644
index 0000000..a527a93
--- /dev/null
+++ b/test/volumes-get.test.js
@@ -0,0 +1,59 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var test = require('tape').test;
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    test('getting non-existing volume should respond with 404 status code',
+        function (t) {
+            CLIENT.get('/my/volumes/' + libuuid.create(),
+                function onVolumeGet(volGetErr, req, res, volume) {
+                    var expectedErrCode = 'VolumeNotFound';
+                    var expectedStatusCode = 404;
+
+                    t.equal(res.statusCode, expectedStatusCode,
+                        'response status code should be ' + expectedStatusCode);
+                    t.equal(volGetErr.body.code, expectedErrCode,
+                        'error code should be: ' + expectedErrCode);
+                    t.end();
+                });
+        });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
\ No newline at end of file
diff --git a/test/volumes-list-params-validation.test.js b/test/volumes-list-params-validation.test.js
new file mode 100644
index 0000000..07daed5
--- /dev/null
+++ b/test/volumes-list-params-validation.test.js
@@ -0,0 +1,533 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var test = require('tape').test;
+var querystring = require('querystring');
+var vasync = require('vasync');
+
+var common = require('./common');
+var mod_config = require('../lib/config');
+var mod_testVolumes = require('./lib/volumes');
+
+var CONFIG = mod_config.configure();
+var VOLUMES_NAMES_PREFIX = 'cloudapi-test-volumes-list-params';
+
+function deleteAllTestVolumeObjects(t, client, callback) {
+    assert.object(t, 't');
+    assert.object(client, 'client');
+    assert.func(callback, 'callback');
+
+    var query = '/my/volumes?' + querystring.stringify({
+        name: '*' + VOLUMES_NAMES_PREFIX + '*'
+    });
+
+    client.get(query, function onListVolumes(err, req, res, volumes) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        vasync.forEachParallel({
+            func: function deleteTestVolumeObject(volumeUuid, cb) {
+                client.del('/my/volumes/' + volumeUuid,
+                    function onDeleted(delErr) {
+                        t.ifError(delErr, 'should have succeeded to delete '
+                            + 'volume ' + volumeUuid);
+                        cb(delErr);
+                    });
+            },
+            inputs: volumes.map(function getVolumeUuid(volume) {
+                assert.object(volume, 'volume');
+                return volume.id;
+            })
+        }, function allVolumesDeleted(deleteErr) {
+            callback(deleteErr);
+        });
+    });
+}
+
+function createTestVolume(client, volumeParams, callback) {
+    assert.object(client, 'client');
+    assert.object(volumeParams, 'volumeParams');
+    assert.func(callback, 'callback');
+
+    client.post('/my/volumes', volumeParams,
+        function onCreate(err, req, res, volume) {
+            callback(err, volume);
+        });
+}
+
+function waitTestVolume(client, volumeId, expectedState, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeId, 'volumeId');
+    assert.string(expectedState, 'expectedState');
+    assert.func(callback, 'callback');
+
+    mod_testVolumes.waitForTransitionToState(client, volumeId, expectedState,
+        function onTransition() {
+            client.get('/my/volumes/' + volumeId,
+                function onGetVolume(getVolumeErr, req, res, gotVolume) {
+                    callback(getVolumeErr, gotVolume);
+                });
+        });
+}
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+    var snowflakeName0 = 'dummy-' + VOLUMES_NAMES_PREFIX + '-empty0-foo';
+    var snowflakeName1 = VOLUMES_NAMES_PREFIX + '-empty1-foo';
+    var snowflakeName2 = VOLUMES_NAMES_PREFIX + '-empty2-foo';
+
+    test('setup', function (tt) {
+        tt.test('common setup', function (t) {
+            common.setup({clientApiVersion: '~8.0'},
+                function (_, clients, server) {
+                    CLIENTS = clients;
+                    CLIENT  = clients.user;
+                    SERVER  = server;
+
+                    t.end();
+                });
+        });
+    });
+
+    test('listing nfs shared volumes with invalid query parameters',
+        function (tt) {
+
+        var badParameters = [
+            [
+                'unknown query parameter should be rejected',
+                'unknown parameter',
+                {gorilla: 'king kong'}
+            ],
+            [
+                'wildcard should not be allowed in middle of name',
+                'wildcard',
+                {name: 'go*la'}
+            ],
+            [
+                'invalid size should fail',
+                'size',
+                {size: 'yuge'}
+            ],
+            [
+                'invalid state should fail',
+                'state',
+                {state: 'confusion'}
+            ],
+            [
+                // owner_uuid can't be passed to cloudapi
+                'owner_uuid should be rejected',
+                'owner_uuid',
+                {owner_uuid: libuuid.create()}
+            ]
+        ];
+        var idx;
+
+        function invalidShouldBeRejected(params) {
+            var invalidWhat = params[1];
+            var listArgs = params[2];
+            var testName = params[0];
+
+            tt.test(testName, function (t) {
+                var query = '/my/volumes?' + querystring.stringify(listArgs);
+
+                CLIENT.get(query,
+                    function onListVolumes(err, req, res, obj) {
+                        t.ok(err, 'listing volumes with invalid ' + invalidWhat
+                            + ' should error');
+                        t.equal(err.restCode, 'InvalidArgument',
+                            'error should be InvalidArgument');
+                        t.end();
+                    });
+            });
+        }
+
+        for (idx = 0; idx < badParameters.length; idx++) {
+            invalidShouldBeRejected(badParameters[idx]);
+        }
+
+        tt.test('conflicting predicate and query param should fail',
+            function (t) {
+                var predicate = {
+                    eq: ['name', 'mechagodzilla']
+                };
+                var query = '/my/volumes?' + querystring.stringify({
+                    name: 'godzilla',
+                    predicate: JSON.stringify(predicate)
+                });
+
+                CLIENT.get(query, function onListVolumes(err, req, res, obj) {
+                    t.ok(err,
+                        'listing volumes with invalid predicate should error');
+                    t.equal(err.restCode, 'InvalidArgument',
+                        'error should InvalidArgument');
+                    t.end();
+                });
+            });
+    });
+
+    // copied from sdc-volapi test/integration/list-with-params.test.js
+    function snowflakeName(strName) {
+        switch (strName) {
+            case 'snowflakeName0':
+                return snowflakeName0;
+            case 'snowflakeName1':
+                return snowflakeName1;
+            case 'snowflakeName2':
+                return snowflakeName2;
+            default:
+                return 'unknown volume';
+        }
+    }
+
+    // copied from sdc-volapi test/integration/list-with-params.test.js
+    function shouldFind(t, volumes, expected, notExpected, expectedNumber) {
+        var foundVolumes = [];
+        var idx;
+
+        t.ok(Array.isArray(volumes), 'response body should be an array');
+        if (expectedNumber !== undefined) {
+            t.equal(volumes.length, expectedNumber, expectedNumber +
+                ' volume(s) should be included in the response body');
+        }
+
+        volumes.forEach(function checkVolume(vol) {
+            switch (vol.name) {
+                case snowflakeName0:
+                    foundVolumes.push('snowflakeName0');
+                    break;
+                case snowflakeName1:
+                    foundVolumes.push('snowflakeName1');
+                    break;
+                case snowflakeName2:
+                    foundVolumes.push('snowflakeName2');
+                    break;
+                default:
+                    foundVolumes.push('unknownName');
+                    break;
+            }
+        });
+
+        for (idx = 0; idx < expected.length; idx++) {
+            t.ok(foundVolumes.indexOf(expected[idx]) !== -1,
+                'should have found ' + snowflakeName(expected[idx]));
+        }
+
+        for (idx = 0; idx < notExpected.length; idx++) {
+            t.ok(foundVolumes.indexOf(notExpected[idx]) === -1,
+                'should not have found ' + snowflakeName(notExpected[idx]));
+        }
+
+        return (foundVolumes);
+    }
+
+    test('create some test volumes', function (tt) {
+        var testVolumeObjects = [
+            {
+                name: snowflakeName0,
+                size: 10240,
+                type: 'tritonnfs'
+            },
+            {
+                name: snowflakeName1,
+                size: 102400,
+                type: 'tritonnfs'
+            },
+            {
+                name: snowflakeName2,
+                size: 1024000,
+                type: 'tritonnfs'
+            }
+        ];
+
+        vasync.forEachPipeline({
+            func: function createVolume(newVol, cb) {
+                // Can't use tt.comment because our version of tape doesn't have
+                // the fix for substack/tape#92 (See also PUBAPI-1418)
+                tt.ok(true, 'creating volume ' + newVol.name);
+                createTestVolume(CLIENT, newVol,
+                    function onCreated(err, createVol) {
+                        var expectedState = 'ready';
+
+                        tt.ifErr(err, 'should have created volume '
+                            + newVol.name);
+                        tt.ok(createVol, 'should have volume response');
+                        if (err) {
+                            cb(err);
+                            return;
+                        }
+                        if (!createVol) {
+                            cb(new Error('invalid created volume in response'));
+                            return;
+                        }
+                        tt.ok(createVol, 'volume should have an id, got: '
+                            + createVol.id);
+
+                        // We need to wait for the volume to go "ready" here
+                        // because volumes cannot be deleted when the
+                        // underlying VM does not yet have a server_uuid.
+
+                        waitTestVolume(CLIENT, createVol.id, expectedState,
+                            function onWait(waitErr, waitVol) {
+                                tt.ifErr(waitErr, 'getting newly created '
+                                    + 'volume should not error');
+                                tt.ok((typeof (waitVol) === 'object' &&
+                                    waitVol !== null),
+                                    'response should be a non-null object');
+                                tt.equal(waitVol.name, newVol.name,
+                                    'volume name should be \''
+                                    + newVol.name + '\'');
+                                tt.equal(waitVol.state, expectedState,
+                                    'volume should have transitioned to '
+                                    + 'state \'' + expectedState + '\'');
+                                cb();
+                            });
+                    });
+            }, inputs: testVolumeObjects
+        }, function pipelineComplete(err) {
+            tt.ifErr(err, 'should have created all volumes without error');
+            tt.end();
+        });
+    });
+
+    // The tests here are mostly the same as those in sdc-volapi
+    // test/integration/list-with-params.test.js
+
+    test('listing with empty predicate returns all volumes', function (tt) {
+        var predicate = {};
+        var query = '/my/volumes?' + querystring.stringify({
+            predicate: JSON.stringify(predicate)
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err,
+                'listing volumes with empty predicate should succeed');
+            if (volumes !== undefined) {
+                shouldFind(tt, volumes, [
+                    // expected to find
+                    'snowflakeName0',
+                    'snowflakeName1',
+                    'snowflakeName2'
+                ], [
+                    // expected to not find
+                    'unknownName'
+                ], 3);
+            } else {
+                tt.ok(false, 'no volumes returned');
+            }
+
+            tt.end();
+        });
+    });
+
+    test('list with exact name returns 1 volume', function (tt) {
+        var query = '/my/volumes?' + querystring.stringify({
+            name: snowflakeName1
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err, 'listing volumes with a name param should not '
+                + 'error');
+            if (volumes !== undefined) {
+                tt.ok(Array.isArray(volumes),
+                    'response body should be an array');
+                tt.equal(volumes.length, 1,
+                    'only one volume should be included in the response '
+                    + 'body');
+                tt.equal(volumes[0].name, snowflakeName1,
+                    'the name of the volume returned in the response '
+                    + 'should be: ' + snowflakeName1 + ', got: '
+                    + volumes[0].name);
+            } else {
+                tt.ok(false, 'no volumes returned by listVolumes');
+            }
+            tt.end();
+        });
+    });
+
+    test('list with state=ready returns 3 volumes', function (tt) {
+        var query = '/my/volumes?' + querystring.stringify({
+            state: 'ready'
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err, 'listing volumes with state=ready should '
+                + 'not error');
+
+            if (volumes !== undefined) {
+                shouldFind(tt, volumes, [
+                    // expected to find
+                    'snowflakeName0',
+                    'snowflakeName1',
+                    'snowflakeName2'
+                ], [
+                    // expected to not find
+                    'unknownName'
+                ], 3);
+            } else {
+                tt.ok(false, 'no volumes returned from listVolumes');
+            }
+
+            tt.end();
+        });
+    });
+
+    test('list with name=*-foo returns 3 volumes', function (tt) {
+        var query = '/my/volumes?' + querystring.stringify({
+            name: '*-foo'
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err, 'listing volumes with a wildcard name param should '
+                + 'not error');
+
+            if (volumes !== undefined) {
+                shouldFind(tt, volumes, [
+                    // expected to find
+                    'snowflakeName0',
+                    'snowflakeName1',
+                    'snowflakeName2'
+                ], [
+                    // expected to not find
+                    'unknownName'
+                ], 3);
+            } else {
+                tt.ok(false, 'no volumes returned from listVolumes');
+            }
+
+            tt.end();
+        });
+    });
+
+    test('list with name=' + VOLUMES_NAMES_PREFIX + '-* returns 2 volumes',
+        function (tt) {
+            var query = '/my/volumes?' + querystring.stringify({
+                name: VOLUMES_NAMES_PREFIX + '-*'
+            });
+            CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+                tt.ifErr(err, 'listing volumes with a prefix name param should '
+                    + 'not error');
+
+                if (volumes !== undefined) {
+                    shouldFind(tt, volumes, [
+                        // expected to find
+                        'snowflakeName1',
+                        'snowflakeName2'
+                    ], [
+                        // expected to not find
+                        'snowflakeName0',
+                        'unknownName'
+                    ], 2);
+                } else {
+                    tt.ok(false, 'no volumes returned from listVolumes');
+                }
+
+                tt.end();
+            });
+        });
+
+    test('list with type=tritonnfs returns volumes', function (tt) {
+        var query = '/my/volumes?' + querystring.stringify({
+            type: 'tritonnfs'
+        });
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err,
+                'listing volumes with type=tritonnfs should not error');
+            tt.ok(Array.isArray(volumes), 'response body should be an array');
+            tt.ok(volumes.length >= 3, 'should have at least 3 volumes, found: '
+                + volumes.length);
+
+            tt.end();
+        });
+    });
+
+    // NOTE: testing with both string and number here really doesn't do anything
+    // since the number will be stringified. But the two tests use different
+    // sizes and confirm that they get different results, so that's still
+    // valuable.
+
+    test('list with size=102400 (number) returns correct volume',
+        function (tt) {
+
+        var query = '/my/volumes?' + querystring.stringify({
+            size: 102400
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err, 'listing volumes with size=102400 should not error');
+
+            if (volumes !== undefined) {
+                shouldFind(tt, volumes, [
+                    // expected to find
+                    'snowflakeName1'
+                ], [
+                    // expected to not find
+                    'snowflakeName0',
+                    'snowflakeName2'
+                ]);
+            } else {
+                tt.ok(false, 'no volumes returned from listVolumes');
+            }
+
+            tt.end();
+        });
+    });
+
+    test('list with size=1024000 (string) returns correct volume',
+        function (tt) {
+
+        var query = '/my/volumes?' + querystring.stringify({
+            size: '1024000'
+        });
+
+        CLIENT.get(query, function onListVolumes(err, req, res, volumes) {
+            tt.ifErr(err, 'listing volumes with size=1024000 should not error');
+
+            if (volumes !== undefined) {
+                shouldFind(tt, volumes, [
+                    // expected to find
+                    'snowflakeName2'
+                ], [
+                    // expected to not find
+                    'snowflakeName0',
+                    'snowflakeName1'
+                ]);
+            } else {
+                tt.ok(false, 'no volumes returned from listVolumes');
+            }
+
+            tt.end();
+        });
+    });
+
+    test('teardown', function (tt) {
+        tt.test('delete volumes', function (t) {
+            deleteAllTestVolumeObjects(t, CLIENT, function (err) {
+                t.ifErr(err, 'should have succeeded in deleting volumes');
+                t.end();
+            });
+        });
+
+        tt.test('common teardown', function (t) {
+            common.teardown(CLIENTS, SERVER, function () {
+                t.end();
+            });
+        });
+    });
+}
diff --git a/test/volumes-list-predicate-validation.test.js b/test/volumes-list-predicate-validation.test.js
new file mode 100644
index 0000000..bbc78a6
--- /dev/null
+++ b/test/volumes-list-predicate-validation.test.js
@@ -0,0 +1,210 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var libuuid = require('libuuid');
+var test = require('tape').test;
+var vasync = require('vasync');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT  = clients.user;
+            SERVER  = server;
+
+            t.end();
+        });
+    });
+
+    test('listing volumes with malformed predicate fails', function (t) {
+        var MALFORMED_PREDICATE = 'malformed-predicate';
+
+        CLIENT.get('/my/volumes?predicate=' + MALFORMED_PREDICATE,
+            function onVolumesListed(listVolsErr, req, res, volumes) {
+                var expectedStatusCode = 409;
+                var expectedRestCode = 'InvalidArgument';
+                var expectedErrorMsg =
+                    'Could not parse JSON predicate malformed-predicate';
+
+                t.ok(listVolsErr,
+                    'listing volumes with a malformed predicate should error');
+                t.equal(listVolsErr.restCode, expectedRestCode,
+                    'rest code should be ' + expectedRestCode);
+                t.equal(listVolsErr.statusCode, expectedStatusCode,
+                    'status code should be ' + expectedStatusCode);
+                t.ok(listVolsErr.message.indexOf(expectedErrorMsg) !== -1,
+                    'error message should include: ' + expectedErrorMsg +
+                        ', was: ' + listVolsErr.message);
+
+                t.end();
+            });
+    });
+
+    test('listing volumes with null-valued predicate fails', function (t) {
+        var INVALID_PRED = JSON.stringify({
+            eq: ['invalid-pred', null]
+        });
+
+        CLIENT.get('/my/volumes?predicate=' + INVALID_PRED,
+            function onVolumesListed(listVolsErr, req, res, volumes) {
+                var expectedStatusCode = 409;
+                var expectedRestCode = 'InvalidArgument';
+                var expectedErrorMsg =
+                    'predicate { eq: [ \'invalid-pred\', null ] }: field ' +
+                        '\"invalid-pred\" is not a string, number, or boolean';
+
+                t.ok(listVolsErr,
+                    'listing volumes with a malformed predicate should error');
+                t.equal(listVolsErr.restCode, expectedRestCode,
+                    'rest code should be ' + expectedRestCode);
+                t.equal(listVolsErr.statusCode, expectedStatusCode,
+                    'status code should be ' + expectedStatusCode);
+                t.ok(listVolsErr.message.indexOf(expectedErrorMsg) !== -1,
+                    'error message should include: ' + expectedErrorMsg +
+                        ', was: ' + listVolsErr.message);
+
+                t.end();
+            });
+    });
+
+
+    test('listing volumes with valid predicates succeeds', function (t) {
+        var VALID_ID_PRED = JSON.stringify({
+            eq: ['id', libuuid.create()]
+        });
+
+        var VALID_NAME_PRED = JSON.stringify({
+            eq: ['name', 'foo']
+        });
+
+        var VALID_NETWORK_PRED = JSON.stringify({
+            eq: ['network', libuuid.create()]
+        });
+
+        var VALID_PREDS;
+
+        var VALID_SIZE_PRED = JSON.stringify({
+            eq: ['size', 42]
+        });
+
+        var VALID_STATE_PRED = JSON.stringify({
+            eq: ['state', 'deleting']
+        });
+
+        var VALID_TYPE_PRED = JSON.stringify({
+            eq: ['type', 'tritonnfs']
+        });
+
+        VALID_PREDS = [
+            VALID_ID_PRED,
+            VALID_NAME_PRED,
+            VALID_NETWORK_PRED,
+            VALID_SIZE_PRED,
+            VALID_STATE_PRED,
+            VALID_TYPE_PRED
+        ];
+
+        vasync.forEachParallel({
+            func: function testValidPred(validPred, done) {
+                CLIENT.get('/my/volumes?predicate=' + validPred,
+                    function onVolumesListed(listVolsErr, req, res, volumes) {
+                        var expectedStatusCode = 200;
+
+                        t.ok(!listVolsErr,
+                            'listing volumes with a valid predicate should ' +
+                                'not error, got: ' + listVolsErr);
+                        t.equal(res.statusCode, expectedStatusCode,
+                            'status code should be ' + expectedStatusCode);
+
+                        done();
+                    });
+            },
+            inputs: VALID_PREDS
+        }, function allValidPredsTested(err) {
+            t.end();
+        });
+    });
+
+    test('listing volumes with invalid predicates fails', function (t) {
+        var INVALID_ID_PRED = JSON.stringify({
+            eq: ['id', 'invalid-id']
+        });
+
+        var INVALID_NAME_PRED = JSON.stringify({
+            eq: ['name', '*;/-|']
+        });
+
+        var INVALID_NETWORK_PRED = JSON.stringify({
+            eq: ['network', 'foo']
+        });
+
+        var INVALID_PREDS;
+
+        var INVALID_SIZE_PRED = JSON.stringify({
+            eq: ['size', 'bar']
+        });
+
+        var INVALID_STATE_PRED = JSON.stringify({
+            eq: ['state', 'invalid-state']
+        });
+
+        var INVALID_TYPE_PRED = JSON.stringify({
+            eq: ['type', 'invalid-type']
+        });
+
+        INVALID_PREDS = [
+            INVALID_ID_PRED,
+            INVALID_NAME_PRED,
+            INVALID_NETWORK_PRED,
+            INVALID_SIZE_PRED,
+            INVALID_STATE_PRED,
+            INVALID_TYPE_PRED
+        ];
+
+        vasync.forEachParallel({
+            func: function testValidPred(invalidPred, done) {
+                CLIENT.get('/my/volumes?predicate=' + invalidPred,
+                    function onVolumesListed(listVolsErr, req, res, volumes) {
+                        var expectedStatusCode = 409;
+
+                        t.ok(listVolsErr,
+                            'listing volumes with a invalid predicate should ' +
+                                'error, got: ' + listVolsErr);
+                        t.equal(res.statusCode, expectedStatusCode,
+                            'status code should be ' + expectedStatusCode);
+
+                        done();
+                    });
+            },
+            inputs: INVALID_PREDS
+        }, function allValidPredsTested(err) {
+            t.end();
+        });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
\ No newline at end of file
diff --git a/test/volumes-list-sizes.test.js b/test/volumes-list-sizes.test.js
new file mode 100644
index 0000000..997deb0
--- /dev/null
+++ b/test/volumes-list-sizes.test.js
@@ -0,0 +1,116 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    var testVolumeName = common.createResourceName('test-volumes-basic');
+    var testVolume;
+    var testVolumeStorageVmUuid;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    test('should be able to get volume sizes w/ default type',
+        function (t) {
+            CLIENT.get('/my/volumesizes',
+                function onGetVolumeSizes(err, req, res, volumeSizes) {
+                    t.ifErr(err, 'GET /my/volumesizes should succeed');
+                    t.ok(volumeSizes,
+                        'returned volumeSizes should be an object');
+                    t.ok(Array.isArray(volumeSizes),
+                        'returned volumeSizes should also be an array');
+                    t.ok(volumeSizes.length > 0,
+                        'should have at least one volumeSize entry');
+
+                    t.end();
+                });
+    });
+
+    test('should be able to get volume sizes',
+        function (t) {
+            CLIENT.get('/my/volumesizes?type=tritonnfs',
+                function onGetVolumeSizes(err, req, res, volumeSizes) {
+                    var idx = 0;
+                    var sorted = true;
+
+                    t.ifErr(err, 'GET /my/volumesizes should succeed');
+                    t.ok(volumeSizes,
+                        'returned volumeSizes should be an object');
+                    t.ok(Array.isArray(volumeSizes),
+                        'returned volumeSizes should also be an array');
+                    t.ok(volumeSizes.length > 0,
+                        'should have at least one volumeSize entry');
+                    if (volumeSizes.length > 0) {
+                        t.ok(volumeSizes[0].size,
+                            'volumeSizes[0] should have "size", got: ' +
+                            volumeSizes[0].size);
+                        t.ok(volumeSizes[0].type,
+                            'volumeSizes[0] should have "type", got: ' +
+                            volumeSizes[0].type);
+                    }
+
+                    // check that volume sizes are in ascending order
+                    for (idx = 0; idx < volumeSizes.length; idx++) {
+                        if (idx > 0 &&
+                            volumeSizes[idx - 1] > volumeSizes[idx]) {
+
+                            sorted = false;
+                        }
+                    }
+                    t.ok(sorted, 'volume sizes should be in ascending order');
+
+                    t.end();
+                });
+    });
+
+    test(' GET /my/volumesizes?type=invalidType should fail', function (t) {
+        CLIENT.get('/my/volumesizes?type=invalidType',
+            function onGetVolumeSizes(err, req, res, body) {
+                t.ok(err, 'expected error listing volume sizes, got: ' +
+                    (err ? err.message : JSON.stringify(err)));
+                t.ok(body, 'expected to get a body');
+                if (body) {
+                    t.equal(body.message, 'Invalid volume type: invalidType. ' +
+                        'Volume type should be one of: tritonnfs',
+                        'expected body to be an invalid type error');
+                }
+                t.end();
+            });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-no-fabric-network.test.js b/test/volumes-no-fabric-network.test.js
new file mode 100644
index 0000000..a7e918c
--- /dev/null
+++ b/test/volumes-no-fabric-network.test.js
@@ -0,0 +1,113 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var verror = require('verror');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var mod_testVolumes = require('./lib/volumes');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+    var USER;
+
+    var testVolumeName =
+        common.createResourceName('test-volumes-no-fabric-network');
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'},
+            function onSetupDone(_, clients, server) {
+                CLIENTS = clients;
+                CLIENT = clients.user;
+                SERVER = server;
+
+                t.end();
+            });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr, ufdsConfig) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('getting user account from ufds', function (t) {
+        CLIENT.ufds.getUser(CLIENT.login, function onGetUser(getUserErr, user) {
+            USER = user;
+            t.end();
+        });
+    });
+
+    test('deleting user\'s dclocalconfig to remove default fabric network',
+        function (t) {
+            CLIENT.ufds.deleteDcLocalConfig(USER.uuid,
+                USER.dclocalconfig.dclocalconfig,
+                function onDcLocalCfgUpdated(err) {
+                    t.ifError(err, 'deleting dclocalconfig should succeed');
+                    t.end();
+                });
+        });
+
+    test('creating volume with default params should fail',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeName,
+                type: 'tritonnfs'
+            }, function onVolumeCreated(volumeCreationErr, req, res, body) {
+                var expectedStatusCode = 409;
+                var expectedErrMsg =
+                    'default_network is not configured for account';
+                var expectedErrorCode =
+                    'DefaultFabricNetworkNotConfiguredError';
+
+                t.ok(volumeCreationErr,
+                    'creating a volume with default parameters should error');
+                t.equal(volumeCreationErr.statusCode, expectedStatusCode,
+                    'response status code should be ' + expectedStatusCode +
+                        ', was' + volumeCreationErr.statusCode);
+                t.equal(body.code, expectedErrorCode,
+                    'body\'s code should be ' + expectedErrorCode + ', was ' +
+                        body.code);
+                t.equal(body.message, expectedErrMsg,
+                    'body\'s message should be ' + expectedErrMsg + ', was ' +
+                        body.message);
+
+                t.end();
+            });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function (teardownErr) {
+            t.ifError(teardownErr,
+                'tearing down test suite should not error, got: ' +
+                    teardownErr);
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-size.test.js b/test/volumes-size.test.js
new file mode 100644
index 0000000..7ea83a1
--- /dev/null
+++ b/test/volumes-size.test.js
@@ -0,0 +1,229 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var verror = require('verror');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var testVolumes = require('./lib/volumes');
+var units = require('../lib/units');
+
+var CONFIG = mod_config.configure();
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var DEFAULT_VOLUME_SIZE = 10 * units.MIBS_IN_GB;
+    var SERVER;
+    var testVolumeDefaultSize, testVolume20MibsSize;
+    var testVolumeNameDefaultSize =
+        common.createResourceName('test-volumes-size-default');
+    var testVolumeName20MibsSize =
+        common.createResourceName('test-volumes-size-20');
+    var VOLUME_SIZE_20_GiBs = 20 * units.MIBS_IN_GB;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT  = clients.user;
+            SERVER  = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('creating volume with default size should create volume with size ' +
+        'of ' + DEFAULT_VOLUME_SIZE + 'MiBs',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeNameDefaultSize,
+                type: 'tritonnfs'
+            }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+                var expectedState = 'creating';
+                var expectedType = 'tritonnfs';
+
+                testVolumeDefaultSize = volume;
+
+                t.ifErr(volumeCreationErr,
+                    'creating a volume with default parameters should not ' +
+                        'error');
+                t.ok(testVolumeDefaultSize,
+                    'returned volume should be an object');
+                t.equal(testVolumeDefaultSize.type, 'tritonnfs',
+                    'newly created volume should have type \'' + expectedType +
+                        '\'');
+                t.equal(testVolumeDefaultSize.state, 'creating',
+                    'volume should have state \'' + expectedState + '\'');
+                t.equal(testVolumeDefaultSize.size, DEFAULT_VOLUME_SIZE,
+                    'volume size should be ' + DEFAULT_VOLUME_SIZE + ' MiBs');
+                t.end();
+            });
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            var expectedState = 'ready';
+
+            testVolumes.waitForTransitionToState(CLIENT,
+                testVolumeDefaultSize.id,
+                expectedState, function onTransition() {
+                    CLIENT.get('/my/volumes/' + testVolumeDefaultSize.id,
+                        function onGetVolume(getVolumeErr, req, res, volume) {
+                            t.ifErr(getVolumeErr,
+                                'getting newly created volume should not ' +
+                                    'error');
+                            t.ok(typeof (volume) === 'object' &&
+                                volume !== null,
+                                    'response should be a non-null object');
+                            t.equal(volume.name, testVolumeNameDefaultSize,
+                                'volume name should be \'' +
+                                    testVolumeNameDefaultSize + '\'');
+                            t.equal(volume.state, expectedState,
+                                'volume should have transitioned to state \'' +
+                                    expectedState + '\'');
+
+                            t.end();
+                        });
+            });
+    });
+
+    test('deleting volume should be successful', function (t) {
+        CLIENT.del('/my/volumes/' + testVolumeDefaultSize.id,
+            function onDelVolume(delVolumeErr) {
+                t.ifErr(delVolumeErr,
+                    'deleting newly created volume should not error');
+                t.end();
+            });
+    });
+
+    test('volume should eventually disappear', function (t) {
+        testVolumes.waitForDeletion(CLIENT, testVolumeDefaultSize.id,
+            function onDeleted() {
+                CLIENT.get('/my/volumes/' + testVolumeDefaultSize.id,
+                    function onGetVolume(getVolumeErr) {
+                        t.ok(verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError'), 'expected ' +
+                            'VolumeNotFoundError error, got: ' +
+                            (getVolumeErr ? getVolumeErr.name :
+                            JSON.stringify(getVolumeErr)));
+
+                        t.end();
+                    });
+            });
+    });
+
+    test('creating volume with size 20 GiBs should create volume with size ' +
+        'of 20 GiBs',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeName20MibsSize,
+                type: 'tritonnfs',
+                size: VOLUME_SIZE_20_GiBs
+            }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+                var expectedState = 'creating';
+                var expectedType = 'tritonnfs';
+
+                testVolume20MibsSize = volume;
+
+                t.ifErr(volumeCreationErr,
+                    'creating a volume with default parameters should not ' +
+                        'error');
+                t.ok(testVolume20MibsSize,
+                    'returned volume should be an object');
+                t.equal(testVolume20MibsSize.type, 'tritonnfs',
+                    'newly created volume should have type \'' + expectedType +
+                        '\'');
+                t.equal(testVolume20MibsSize.state, 'creating',
+                    'volume should have state \'' + expectedState + '\'');
+                t.equal(testVolume20MibsSize.size, VOLUME_SIZE_20_GiBs,
+                    'volume size should be ' + VOLUME_SIZE_20_GiBs + ' MiBs');
+                t.end();
+            });
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            var expectedState = 'ready';
+
+            testVolumes.waitForTransitionToState(CLIENT,
+                testVolumeDefaultSize.id,
+                expectedState, function onTransition() {
+                    CLIENT.get('/my/volumes/' + testVolume20MibsSize.id,
+                        function onGetVolume(getVolumeErr, req, res, volume) {
+                            t.ifErr(getVolumeErr,
+                                'getting newly created volume should not ' +
+                                    'error');
+                            t.ok(typeof (volume) === 'object' &&
+                                volume !== null,
+                                    'response should be a non-null object');
+                            t.equal(volume.name, testVolumeName20MibsSize,
+                                'volume name should be \'' +
+                                    testVolumeName20MibsSize + '\'');
+                            t.equal(volume.state, expectedState,
+                                'volume should have transitioned to state \'' +
+                                    expectedState + '\'');
+
+                            t.end();
+                        });
+            });
+    });
+
+    test('deleting volume should be successful', function (t) {
+        CLIENT.del('/my/volumes/' + testVolume20MibsSize.id,
+            function onDelVolume(delVolumeErr) {
+                t.ifErr(delVolumeErr,
+                    'deleting newly created volume should not error');
+                t.end();
+            });
+    });
+
+    test('volume should eventually disappear', function (t) {
+        testVolumes.waitForDeletion(CLIENT, testVolume20MibsSize.id,
+            function onDeleted() {
+                CLIENT.get('/my/volumes/' + testVolume20MibsSize.id,
+                    function onGetVolume(getVolumeErr) {
+                        t.ok(verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError'), 'expected ' +
+                            'VolumeNotFoundError error, got: ' +
+                            (getVolumeErr ? getVolumeErr.name :
+                            JSON.stringify(getVolumeErr)));
+
+                        t.end();
+                    });
+            });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes-update-name.test.js b/test/volumes-update-name.test.js
new file mode 100644
index 0000000..a4e6724
--- /dev/null
+++ b/test/volumes-update-name.test.js
@@ -0,0 +1,166 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var verror = require('verror');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var mod_testVolumes = require('./lib/volumes');
+
+var CONFIG = mod_config.configure();
+
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+
+    var testVolumeName = common.createResourceName('test-volumes-basic');
+    var testVolumeSecondName =
+        common.createResourceName('test-volumes-basic-renamed');
+    var testVolume;
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT = clients.user;
+            SERVER = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('creating volume with default params should be successful',
+        function (t) {
+            CLIENT.post('/my/volumes', {
+                name: testVolumeName,
+                type: 'tritonnfs'
+            }, function onVolumeCreated(volumeCreationErr, req, res, volume) {
+                var expectedState = 'creating';
+                var expectedType = 'tritonnfs';
+
+                testVolume = volume;
+
+                t.ifErr(volumeCreationErr,
+                    'creating a volume with default parameters should not ' +
+                        'error');
+                t.ok(testVolume, 'returned volume should be an object');
+                t.equal(testVolume.type, 'tritonnfs',
+                    'newly created volume should have type \'' + expectedType +
+                        '\'');
+                t.equal(testVolume.state, 'creating',
+                    'volume should have state \'' + expectedState + '\'');
+
+                t.end();
+            });
+    });
+
+    test('volume should eventually transition to state \'ready\'',
+        function (t) {
+            var expectedState = 'ready';
+
+            mod_testVolumes.waitForTransitionToState(CLIENT, testVolume.id,
+                expectedState, function onTransition() {
+                    CLIENT.get('/my/volumes/' + testVolume.id,
+                        function onGetVolume(getVolumeErr, req, res, volume) {
+                            t.ifErr(getVolumeErr,
+                                'getting newly created volume should not ' +
+                                    'error');
+                            t.ok(typeof (volume) === 'object' &&
+                                volume !== null,
+                                    'response should be a non-null object');
+                            t.equal(volume.name, testVolumeName,
+                                'volume name should be \'' + testVolumeName +
+                                    '\'');
+                            t.equal(volume.state, expectedState,
+                                'volume should have transitioned to state \'' +
+                                    expectedState + '\'');
+
+                            t.end();
+                        });
+            });
+    });
+
+    test('updating newly created volume\'s name should succeed', function (t) {
+        CLIENT.post('/my/volumes/' + testVolume.id, {
+            name: testVolumeSecondName
+        }, function onVolumeRenamed(volUpdateErr) {
+            t.ifErr(volUpdateErr, 'renaming volume ' + testVolumeName + ' to ' +
+                testVolumeSecondName + ' should succeed');
+            t.end();
+        });
+    });
+
+    test('listing volumes should only include new name', function (t) {
+        CLIENT.get('/my/volumes',
+            function onVolumesListed(volGetErr, req, res, volumes) {
+                t.ifErr(volGetErr, 'listing volumes should be succeed');
+                t.ok(volumes, 'response should not be empty');
+                t.ok(Array.isArray(volumes), 'response should be an array');
+                t.equal(volumes.length, 1,
+                    'response should include only one volume');
+                t.equal(volumes[0].name, testVolumeSecondName,
+                    'only volume\'s name should be ' + testVolumeSecondName);
+                t.end();
+            });
+    });
+
+    test('deleting volume should be successful', function (t) {
+        CLIENT.del('/my/volumes/' + testVolume.id,
+            function onDelVolume(delVolumeErr) {
+                t.ifErr(delVolumeErr,
+                    'deleting newly created volume should not error');
+                t.end();
+            });
+    });
+
+    test('volume should eventually disappear', function (t) {
+        mod_testVolumes.waitForDeletion(CLIENT, testVolume.id,
+            function onDeleted() {
+                CLIENT.get('/my/volumes/' + testVolume.id,
+                    function onGetVolume(getVolumeErr) {
+                        t.ok(verror.hasCauseWithName(getVolumeErr,
+                            'VolumeNotFoundError'), 'expected ' +
+                            'VolumeNotFoundError error, got: ' +
+                            (getVolumeErr ? getVolumeErr.name :
+                            JSON.stringify(getVolumeErr)));
+
+                        t.end();
+                    });
+            });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
diff --git a/test/volumes.unavailable-size.test.js b/test/volumes.unavailable-size.test.js
new file mode 100644
index 0000000..e77b2ed
--- /dev/null
+++ b/test/volumes.unavailable-size.test.js
@@ -0,0 +1,122 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape').test;
+var vasync = require('vasync');
+var verror = require('verror');
+
+var common = require('./common');
+var mod_config = require('../lib/config.js');
+var mod_testConfig = require('./lib/config');
+var mod_testNetworks = require('./lib/networks');
+var testVolumes = require('./lib/volumes');
+var units = require('../lib/units');
+
+var CONFIG = mod_config.configure();
+if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
+    console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
+        'enabled, skipping tests');
+    process.exitCode = 0;
+} else {
+    var CLIENTS;
+    var CLIENT;
+    var SERVER;
+    var testVolumeNameUnavailableSize =
+        common.createResourceName('test-volumes-size-default');
+
+    test('setup', function (t) {
+        common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
+            CLIENTS = clients;
+            CLIENT  = clients.user;
+            SERVER  = server;
+
+            t.end();
+        });
+    });
+
+    /*
+     * This is necessary so that we proceed with the rest of the tests suite
+     * only after the entry for the newly added user (including its default
+     * fabric network used to provision volumes) is present in UFDS.
+     */
+    test('getting config from ufds', function (t) {
+        mod_testConfig.waitForAccountConfigReady(CLIENT,
+            function onConfigReady(configReadyErr) {
+                t.ifErr(configReadyErr, 'newly created user\'s config should ' +
+                    'eventually be created');
+                t.end();
+            });
+    });
+
+    test('creating volume with unavailable size should fail', function (t) {
+        var largestSize;
+
+        vasync.pipeline({arg: {}, funcs: [
+            function getVolumeSizes(ctx, next) {
+                CLIENT.volapi.listVolumeSizes(
+                    function onListVolSizes(listVolSizesErr, sizes) {
+                        t.ifErr(listVolSizesErr,
+                            'listing volume sizes should not error');
+                        if (listVolSizesErr) {
+                            next(listVolSizesErr);
+                            return;
+                        }
+
+                        t.ok(sizes,
+                            'listing volume sizes should not return an empty ' +
+                                'response');
+                        if (sizes) {
+                            t.ok(sizes.length > 0,
+                                'listing volume sizes should not return an ' +
+                                    'empty list of sizes');
+                        }
+
+                        largestSize = sizes[sizes.length - 1].size;
+
+                        next();
+                });
+            },
+            function createVolWithUnavailableSize(ctx, next) {
+                var unavailableSize = largestSize + 1;
+
+                CLIENT.post('/my/volumes', {
+                    name: testVolumeNameUnavailableSize,
+                    size: unavailableSize,
+                    type: 'tritonnfs'
+                }, function onVolCreated(volumeCreationErr, req, res, volume) {
+                    var expectedErrMsg = 'Volume size ' + unavailableSize +
+                        ' is not available';
+                    var actualErrMsg;
+
+                    t.ok(volumeCreationErr,
+                        'creating a volume with unavailable size should error');
+
+                    if (volumeCreationErr) {
+                        actualErrMsg = volumeCreationErr.message;
+                        t.notEqual(actualErrMsg.indexOf(expectedErrMsg), -1,
+                            'error message should include: ' + expectedErrMsg +
+                                ', got: ' + volumeCreationErr.message);
+                    }
+
+                    next();
+                });
+            }
+        ]}, function onTestDone(err) {
+            t.end();
+        });
+    });
+
+    test('teardown', function (t) {
+        common.teardown(CLIENTS, SERVER, function () {
+            t.end();
+        });
+    });
+}
-- 
2.21.0

