From 53f6ac8a0f13875f3a7e1acf80161d8317b6af30 Mon Sep 17 00:00:00 2001
From: Ryan Zezeski <rpz@joyent.com>
Date: Tue, 27 Mar 2018 12:34:47 -0600
Subject: [PATCH] OS-6846 want i40e multi-group support

---
 usr/src/uts/common/io/i40e/i40e_gld.c   |  69 ++--
 usr/src/uts/common/io/i40e/i40e_main.c  | 445 +++++++++++++++++++++---
 usr/src/uts/common/io/i40e/i40e_stats.c |   4 +-
 usr/src/uts/common/io/i40e/i40e_sw.h    |  28 +-
 4 files changed, 448 insertions(+), 98 deletions(-)

diff --git a/usr/src/uts/common/io/i40e/i40e_gld.c b/usr/src/uts/common/io/i40e/i40e_gld.c
index e2a5ef1541..89a1044691 100644
--- a/usr/src/uts/common/io/i40e/i40e_gld.c
+++ b/usr/src/uts/common/io/i40e/i40e_gld.c
@@ -39,7 +39,8 @@ char *i40e_priv_props[] = {
 static int
 i40e_group_remove_mac(void *arg, const uint8_t *mac_addr)
 {
-	i40e_t *i40e = arg;
+	i40e_rx_group_t *rxg = (i40e_rx_group_t *)arg;
+	i40e_t *i40e = rxg->irg_i40e;
 	struct i40e_aqc_remove_macvlan_element_data filt;
 	struct i40e_hw *hw = &i40e->i40e_hw_space;
 	int ret, i, last;
@@ -107,10 +108,11 @@ done:
 static int
 i40e_group_add_mac(void *arg, const uint8_t *mac_addr)
 {
-	i40e_t *i40e = arg;
-	struct i40e_hw *hw = &i40e->i40e_hw_space;
-	int i, ret;
-	i40e_uaddr_t *iua;
+	i40e_rx_group_t *rxg = (i40e_rx_group_t *)arg;
+	i40e_t		*i40e = rxg->irg_i40e;
+	struct i40e_hw	*hw = &i40e->i40e_hw_space;
+	int		i, ret;
+	i40e_uaddr_t	*iua;
 	struct i40e_aqc_add_macvlan_element_data filt;
 
 	if (I40E_IS_MULTICAST(mac_addr))
@@ -136,16 +138,12 @@ i40e_group_add_mac(void *arg, const uint8_t *mac_addr)
 		}
 	}
 
-	/*
-	 * Note, the general use of the i40e_vsi_id will have to be refactored
-	 * when we have proper group support.
-	 */
 	bzero(&filt, sizeof (filt));
 	bcopy(mac_addr, filt.mac_addr, ETHERADDRL);
 	filt.flags = I40E_AQC_MACVLAN_ADD_PERFECT_MATCH	|
 	    I40E_AQC_MACVLAN_ADD_IGNORE_VLAN;
 
-	if ((ret = i40e_aq_add_macvlan(hw, i40e->i40e_vsi_id, &filt, 1,
+	if ((ret = i40e_aq_add_macvlan(hw, rxg->irg_vsi_seid, &filt, 1,
 	    NULL)) != I40E_SUCCESS) {
 		i40e_error(i40e, "failed to add mac address "
 		    "%2x:%2x:%2x:%2x:%2x:%2x to unicast filter: %d",
@@ -157,7 +155,8 @@ i40e_group_add_mac(void *arg, const uint8_t *mac_addr)
 
 	iua = &i40e->i40e_uaddrs[i40e->i40e_resources.ifr_nmacfilt_used];
 	bcopy(mac_addr, iua->iua_mac, ETHERADDRL);
-	iua->iua_vsi = i40e->i40e_vsi_id;
+	/* RPZ: should iua have a group ref? */
+	iua->iua_vsi = rxg->irg_vsi_seid;
 	i40e->i40e_resources.ifr_nmacfilt_used++;
 	ASSERT(i40e->i40e_resources.ifr_nmacfilt_used <=
 	    i40e->i40e_resources.ifr_nmacfilt);
@@ -227,7 +226,7 @@ i40e_m_promisc(void *arg, boolean_t on)
 	}
 
 
-	ret = i40e_aq_set_vsi_unicast_promiscuous(hw, i40e->i40e_vsi_id,
+	ret = i40e_aq_set_vsi_unicast_promiscuous(hw, i40e->i40e_def_vsi_id,
 	    on, NULL, B_FALSE);
 	if (ret != I40E_SUCCESS) {
 		i40e_error(i40e, "failed to %s unicast promiscuity on "
@@ -246,7 +245,7 @@ i40e_m_promisc(void *arg, boolean_t on)
 		goto done;
 	}
 
-	ret = i40e_aq_set_vsi_multicast_promiscuous(hw, i40e->i40e_vsi_id,
+	ret = i40e_aq_set_vsi_multicast_promiscuous(hw, i40e->i40e_def_vsi_id,
 	    on, NULL);
 	if (ret != I40E_SUCCESS) {
 		i40e_error(i40e, "failed to %s multicast promiscuity on "
@@ -257,8 +256,8 @@ i40e_m_promisc(void *arg, boolean_t on)
 		 * Try our best to put us back into a state that MAC expects us
 		 * to be in.
 		 */
-		ret = i40e_aq_set_vsi_unicast_promiscuous(hw, i40e->i40e_vsi_id,
-		    !on, NULL, B_FALSE);
+		ret = i40e_aq_set_vsi_unicast_promiscuous(hw,
+		    i40e->i40e_def_vsi_id, !on, NULL, B_FALSE);
 		if (ret != I40E_SUCCESS) {
 			i40e_error(i40e, "failed to %s unicast promiscuity on "
 			    "the default VSI after toggling multicast failed: "
@@ -294,11 +293,11 @@ i40e_multicast_add(i40e_t *i40e, const uint8_t *multicast_address)
 		if (i40e->i40e_mcast_promisc_count == 0 &&
 		    i40e->i40e_promisc_on == B_FALSE) {
 			ret = i40e_aq_set_vsi_multicast_promiscuous(hw,
-			    i40e->i40e_vsi_id, B_TRUE, NULL);
+			    i40e->i40e_def_vsi_id, B_TRUE, NULL);
 			if (ret != I40E_SUCCESS) {
 				i40e_error(i40e, "failed to enable multicast "
 				    "promiscuous mode on VSI %d: %d",
-				    i40e->i40e_vsi_id, ret);
+				    i40e->i40e_def_vsi_id, ret);
 				return (EIO);
 			}
 		}
@@ -312,7 +311,7 @@ i40e_multicast_add(i40e_t *i40e, const uint8_t *multicast_address)
 	filt.flags = I40E_AQC_MACVLAN_ADD_HASH_MATCH |
 	    I40E_AQC_MACVLAN_ADD_IGNORE_VLAN;
 
-	if ((ret = i40e_aq_add_macvlan(hw, i40e->i40e_vsi_id, &filt, 1,
+	if ((ret = i40e_aq_add_macvlan(hw, i40e->i40e_def_vsi_id, &filt, 1,
 	    NULL)) != I40E_SUCCESS) {
 		i40e_error(i40e, "failed to add mac address "
 		    "%2x:%2x:%2x:%2x:%2x:%2x to multicast filter: %d",
@@ -353,7 +352,7 @@ i40e_multicast_remove(i40e_t *i40e, const uint8_t *multicast_address)
 		filt.flags = I40E_AQC_MACVLAN_DEL_HASH_MATCH |
 		    I40E_AQC_MACVLAN_DEL_IGNORE_VLAN;
 
-		if (i40e_aq_remove_macvlan(hw, i40e->i40e_vsi_id,
+		if (i40e_aq_remove_macvlan(hw, i40e->i40e_def_vsi_id,
 		    &filt, 1, NULL) != I40E_SUCCESS) {
 			i40e_error(i40e, "failed to remove mac address "
 			    "%2x:%2x:%2x:%2x:%2x:%2x from multicast "
@@ -381,11 +380,11 @@ i40e_multicast_remove(i40e_t *i40e, const uint8_t *multicast_address)
 		if (i40e->i40e_mcast_promisc_count == 1 &&
 		    i40e->i40e_promisc_on == B_FALSE) {
 			ret = i40e_aq_set_vsi_multicast_promiscuous(hw,
-			    i40e->i40e_vsi_id, B_FALSE, NULL);
+			    i40e->i40e_def_vsi_id, B_FALSE, NULL);
 			if (ret != I40E_SUCCESS) {
 				i40e_error(i40e, "failed to disable "
 				    "multicast promiscuous mode on VSI %d: %d",
-				    i40e->i40e_vsi_id, ret);
+				    i40e->i40e_def_vsi_id, ret);
 				return (EIO);
 			}
 		}
@@ -490,7 +489,7 @@ i40e_fill_tx_ring(void *arg, mac_ring_type_t rtype, const int group_index,
 	 * we're not actually grouping things tx-wise at this time.
 	 */
 	ASSERT(group_index == -1);
-	ASSERT(ring_index < i40e->i40e_num_trqpairs);
+	ASSERT(ring_index < i40e->i40e_num_trqpairs_per_vsi);
 
 	itrq->itrq_mactxring = rh;
 	infop->mri_driver = (mac_ring_driver_t)itrq;
@@ -518,12 +517,6 @@ i40e_fill_rx_ring(void *arg, mac_ring_type_t rtype, const int group_index,
 	mac_intr_t *mintr = &infop->mri_intr;
 	i40e_trqpair_t *itrq = &i40e->i40e_trqpairs[ring_index];
 
-	/*
-	 * We assert the group number and ring index to help sanity check
-	 * ourselves and mark that we'll need to rework this when we have
-	 * multiple groups.
-	 */
-	ASSERT3S(group_index, ==, 0);
 	ASSERT3S(ring_index, <, i40e->i40e_num_trqpairs);
 
 	itrq->itrq_macrxring = rh;
@@ -552,24 +545,22 @@ i40e_fill_rx_group(void *arg, mac_ring_type_t rtype, const int index,
     mac_group_info_t *infop, mac_group_handle_t gh)
 {
 	i40e_t *i40e = arg;
+	i40e_rx_group_t *rxg;
 
 	if (rtype != MAC_RING_TYPE_RX)
 		return;
 
-	/*
-	 * Note, this is a simplified view of a group, given that we only have a
-	 * single group and a single ring at the moment. We'll want to expand
-	 * upon this as we leverage more hardware functionality.
-	 */
-	i40e->i40e_rx_group_handle = gh;
-	infop->mgi_driver = (mac_group_driver_t)i40e;
+	rxg = &i40e->i40e_rx_groups[index];
+	rxg->irg_grp_hdl = gh;
+
+	infop->mgi_driver = (mac_group_driver_t)rxg;
 	infop->mgi_start = NULL;
 	infop->mgi_stop = NULL;
 	infop->mgi_addmac = i40e_group_add_mac;
 	infop->mgi_remmac = i40e_group_remove_mac;
 
-	ASSERT(i40e->i40e_num_rx_groups == I40E_GROUP_MAX);
-	infop->mgi_count = i40e->i40e_num_trqpairs;
+	ASSERT(i40e->i40e_num_rx_groups <= I40E_GROUP_MAX);
+	infop->mgi_count = i40e->i40e_num_trqpairs_per_vsi;
 }
 
 static int
@@ -757,7 +748,7 @@ i40e_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 			 * now.
 			 */
 			cap_rings->mr_gnum = 0;
-			cap_rings->mr_rnum = i40e->i40e_num_trqpairs;
+			cap_rings->mr_rnum = i40e->i40e_num_trqpairs_per_vsi;
 			cap_rings->mr_rget = i40e_fill_tx_ring;
 			cap_rings->mr_gget = NULL;
 			cap_rings->mr_gaddring = NULL;
@@ -766,7 +757,7 @@ i40e_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 		case MAC_RING_TYPE_RX:
 			cap_rings->mr_rnum = i40e->i40e_num_trqpairs;
 			cap_rings->mr_rget = i40e_fill_rx_ring;
-			cap_rings->mr_gnum = I40E_GROUP_MAX;
+			cap_rings->mr_gnum = i40e->i40e_num_rx_groups;
 			cap_rings->mr_gget = i40e_fill_rx_group;
 			cap_rings->mr_gaddring = NULL;
 			cap_rings->mr_gremring = NULL;
diff --git a/usr/src/uts/common/io/i40e/i40e_main.c b/usr/src/uts/common/io/i40e/i40e_main.c
index 4f6ef25600..b34aec65b0 100644
--- a/usr/src/uts/common/io/i40e/i40e_main.c
+++ b/usr/src/uts/common/io/i40e/i40e_main.c
@@ -11,7 +11,7 @@
 
 /*
  * Copyright 2015 OmniTI Computer Consulting, Inc. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright 2017 Tegile Systems, Inc.  All rights reserved.
  */
 
@@ -359,7 +359,6 @@
  * While bugs have been filed to cover this future work, the following gives an
  * overview of expected work:
  *
- *  o Multiple group support
  *  o DMA binding and breaking up the locking in ring recycling.
  *  o Enhanced detection of device errors
  *  o Participation in IRM
@@ -390,6 +389,10 @@ static ddi_device_acc_attr_t i40e_regs_acc_attr = {
 	DDI_FLAGERR_ACC
 };
 
+static int i40e_rpz_stuff(i40e_t *, i40e_hw_t *);
+static void i40e_set_shared_vsi_props(i40e_t *, i40e_hw_t *,
+    struct i40e_aqc_vsi_properties_data *, uint_t);
+
 /*
  * Logging function for this driver.
  */
@@ -764,7 +767,7 @@ i40e_fm_ereport(i40e_t *i40e, char *detail)
  * through and look at this shortly after attach, we expect there to only be a
  * single element present, which is the default VSI. Importantly, each PF seems
  * to not see any other devices, in part because of the simple switch mode that
- * we're using. If for some reason, we see more artifact, we'll need to revisit
+ * we're using. If for some reason, we see more artifacts, we'll need to revisit
  * what we're doing here.
  */
 static int
@@ -796,6 +799,31 @@ i40e_get_vsi_id(i40e_t *i40e)
 	return (sw_config->element[0].seid);
 }
 
+/*
+ * Get the ID of the uplink MAC.
+ */
+static int
+i40e_get_uplink_id(i40e_t *i40e)
+{
+	i40e_hw_t *hw = &i40e->i40e_hw_space;
+	struct i40e_aqc_get_switch_config_resp *sw_config;
+	uint8_t aq_buf[I40E_AQ_LARGE_BUF];
+	uint16_t next = 0;
+	int rc;
+
+	/* LINTED: E_BAD_PTR_CAST_ALIGN */
+	sw_config = (struct i40e_aqc_get_switch_config_resp *)aq_buf;
+	rc = i40e_aq_get_switch_config(hw, sw_config, sizeof (aq_buf), &next,
+	    NULL);
+	if (rc != I40E_SUCCESS) {
+		i40e_error(i40e, "i40e_aq_get_switch_config() failed %d: %d",
+		    rc, hw->aq.asq_last_status);
+		return (-1);
+	}
+
+	return (sw_config->element[0].uplink_seid);
+}
+
 /*
  * We need to fill the i40e_hw_t structure with the capabilities of this PF. We
  * must also provide the memory for it; however, we don't need to keep it around
@@ -1100,6 +1128,12 @@ i40e_free_trqpairs(i40e_t *i40e)
 	int i;
 	i40e_trqpair_t *itrq;
 
+	if (i40e->i40e_rx_groups != NULL) {
+		kmem_free(i40e->i40e_rx_groups,
+		    sizeof (i40e_rx_group_t) * i40e->i40e_num_rx_groups);
+		i40e->i40e_rx_groups = NULL;
+	}
+
 	if (i40e->i40e_trqpairs != NULL) {
 		for (i = 0; i < i40e->i40e_num_trqpairs; i++) {
 			itrq = &i40e->i40e_trqpairs[i];
@@ -1132,9 +1166,42 @@ i40e_free_trqpairs(i40e_t *i40e)
 static boolean_t
 i40e_alloc_trqpairs(i40e_t *i40e)
 {
-	int i;
+	int i, rc;
+	struct i40e_hw *hw = &i40e->i40e_hw_space;
 	void *mutexpri = DDI_INTR_PRI(i40e->i40e_intr_pri);
 
+	/*
+	 * Create a single VEB so we can create multiple VSIs to
+	 * support multiple MAC groups.
+	 *
+	 * RPZ: Probably want this code somehwere else?
+	 */
+	i40e->i40e_uplink_id = i40e_get_uplink_id(i40e);
+	if (i40e->i40e_uplink_id == -1) {
+		i40e_error(i40e, "failed to obtain MAC Uplink ID");
+		return (B_FALSE);
+	}
+
+	/*
+	 * RPZ: Should I enable statistics?
+	 */
+	rc = i40e_aq_add_veb(hw, i40e->i40e_uplink_id, i40e->i40e_def_vsi_id,
+	    0x1, B_TRUE, &i40e->i40e_veb_id, B_FALSE, NULL);
+	if (rc != I40E_SUCCESS) {
+		i40e_error(i40e, "i40e_aq_add_veb() failed %d: %d", rc,
+		    hw->aq.asq_last_status);
+		return (B_FALSE);
+	}
+
+	/* Get the Switch ID of the VEB. */
+	rc = i40e_aq_get_veb_parameters(hw, i40e->i40e_veb_id,
+	    &i40e->i40e_veb_sid, NULL, NULL, NULL, NULL, NULL);
+	if (rc != I40E_SUCCESS) {
+		i40e_error(i40e, "i40e_aq_get_veb_parameters() failed: %d: %d",
+		    rc, hw->aq.asq_last_status);
+		return (B_FALSE);
+	}
+
 	/*
 	 * Now that we have the priority for the interrupts, initialize
 	 * all relevant locks.
@@ -1155,6 +1222,20 @@ i40e_alloc_trqpairs(i40e_t *i40e)
 		itrq->itrq_index = i;
 	}
 
+	i40e->i40e_rx_groups = kmem_zalloc(sizeof (i40e_rx_group_t) *
+	    i40e->i40e_num_rx_groups, KM_SLEEP);
+
+	/*
+	 * RPZ: Probably want to put this somewhere else? In ixgbe the
+	 * same logic is found in ixgbe_init_driver_settings().
+	 */
+	for (i = 0; i < i40e->i40e_num_rx_groups; i++) {
+		i40e_rx_group_t *rxg = &i40e->i40e_rx_groups[i];
+
+		rxg->irg_index = i;
+		rxg->irg_i40e = i40e;
+	}
+
 	return (B_TRUE);
 }
 
@@ -1166,13 +1247,16 @@ i40e_alloc_trqpairs(i40e_t *i40e)
  *
  * However, at the moment, we cap all of these resources as we only support a
  * single receive ring and a single group.
+ *
+ * RPZ: need to change this comment and these max values. Perhaps this
+ * should still default them to 1 since we set these values later.
  */
 /* ARGSUSED */
 static void
 i40e_hw_to_instance(i40e_t *i40e, i40e_hw_t *hw)
 {
-	if (i40e->i40e_num_trqpairs == 0) {
-		i40e->i40e_num_trqpairs = I40E_TRQPAIR_MAX;
+	if (i40e->i40e_num_trqpairs_per_vsi == 0) {
+		i40e->i40e_num_trqpairs_per_vsi = I40E_TRQPAIR_MAX_PER_VSI;
 	}
 
 	if (i40e->i40e_num_rx_groups == 0) {
@@ -1207,6 +1291,7 @@ static boolean_t
 i40e_common_code_init(i40e_t *i40e, i40e_hw_t *hw)
 {
 	int rc;
+	uint32_t stat_val = 0;
 
 	i40e_clear_hw(hw);
 	rc = i40e_pf_reset(hw);
@@ -1311,12 +1396,15 @@ i40e_common_code_init(i40e_t *i40e, i40e_hw_t *hw)
 	 * We need to obtain the Virtual Station ID (VSI) before we can
 	 * perform other operations on the device.
 	 */
-	i40e->i40e_vsi_id = i40e_get_vsi_id(i40e);
-	if (i40e->i40e_vsi_id == -1) {
-		i40e_error(i40e, "failed to obtain VSI ID");
+	i40e->i40e_def_vsi_id = i40e_get_vsi_id(i40e);
+	if (i40e->i40e_def_vsi_id == -1) {
+		i40e_error(i40e, "failed to obtain Default VSI ID");
 		return (B_FALSE);
 	}
 
+	stat_val = rd32(hw, I40E_GLGEN_STAT);
+	i40e_error(i40e, "I40E_GLGEN_STAT: 0x%x", stat_val);
+
 	return (B_TRUE);
 }
 
@@ -1730,13 +1818,45 @@ i40e_alloc_intrs(i40e_t *i40e, dev_info_t *devinfo)
 	}
 
 	i40e->i40e_intr_type = 0;
+	i40e->i40e_num_rx_groups = I40E_GROUP_MAX;
 
+	/*
+	 * We need to determine the number of queue pairs per traffic
+	 * class. We only have one traffic class (TC0), so we'll base
+	 * this off the number of interrupts provided.
+	 */
 	if ((intr_types & DDI_INTR_TYPE_MSIX) &&
 	    i40e->i40e_intr_force <= I40E_INTR_MSIX) {
 		if (i40e_alloc_intr_handles(i40e, devinfo,
 		    DDI_INTR_TYPE_MSIX)) {
-			i40e->i40e_num_trqpairs =
+			i40e->i40e_num_trqpairs_per_vsi =
 			    MIN(i40e->i40e_intr_count - 1, max_trqpairs);
+
+			/*
+			 * RPZ: Since TCs must be allocated in powers
+			 * of 2 we must also set our VSI queue offsets
+			 * at multiples of powers of 2. If we don't do
+			 * this then our queue mapping section will
+			 * not align with our TC mapping. E.g., on my
+			 * test machine the PF gets 8 interrupts. We
+			 * set aside one interrupt for the admin QP;
+			 * the other 7 are used for TRQPs (data). But
+			 * TCs are sized in powers of 2 (from 1 to 64
+			 * queues) and it is the TC's size which is
+			 * used to determine the number of queues in
+			 * use by a VSI (see table 7-77). Therefore,
+			 * we must set the VSI's QBASE as a multiple
+			 * of the TC size. For now I'm assuming I'm on
+			 * my test machine and using 4 TRQPs per VSI
+			 * so that the Queue Mapping and QPs per TCs
+			 * VSI properties can match up. Obviously,
+			 * this needs to be smarter.
+			 */
+			i40e->i40e_num_trqpairs_per_vsi = 4;
+			ASSERT3U(i40e->i40e_num_rx_groups, >, 0);
+			i40e->i40e_num_trqpairs =
+			    i40e->i40e_num_trqpairs_per_vsi *
+			    i40e->i40e_num_rx_groups;
 			return (B_TRUE);
 		}
 	}
@@ -1747,6 +1867,7 @@ i40e_alloc_intrs(i40e_t *i40e, dev_info_t *devinfo)
 	 * single MSI interrupt.
 	 */
 	i40e->i40e_num_trqpairs = I40E_TRQPAIR_NOMSIX;
+	i40e->i40e_num_trqpairs_per_vsi = i40e->i40e_num_trqpairs;
 	i40e->i40e_num_rx_groups = I40E_GROUP_NOMSIX;
 
 	if ((intr_types & DDI_INTR_TYPE_MSI) &&
@@ -1769,8 +1890,6 @@ i40e_alloc_intrs(i40e_t *i40e, dev_info_t *devinfo)
 static boolean_t
 i40e_map_intrs_to_vectors(i40e_t *i40e)
 {
-	int i;
-
 	if (i40e->i40e_intr_type != DDI_INTR_TYPE_MSIX) {
 		return (B_TRUE);
 	}
@@ -1782,11 +1901,14 @@ i40e_map_intrs_to_vectors(i40e_t *i40e)
 	 * vectors and is assigned the vector one higher than its index.
 	 * Vector zero is reserved for the admin queue.
 	 */
-	ASSERT(i40e->i40e_intr_count == i40e->i40e_num_trqpairs + 1);
+	ASSERT(i40e->i40e_intr_count == i40e->i40e_num_trqpairs_per_vsi + 1);
 
-	for (i = 0; i < i40e->i40e_num_trqpairs; i++) {
-		i40e->i40e_trqpairs[i].itrq_rx_intrvec = i + 1;
-		i40e->i40e_trqpairs[i].itrq_tx_intrvec = i + 1;
+	for (uint_t i = 0; i < i40e->i40e_num_rx_groups; i++) {
+		for (uint_t j = 0; j < i40e->i40e_num_trqpairs_per_vsi; j++) {
+			uint_t idx = (i * i40e->i40e_num_trqpairs_per_vsi) + j;
+			i40e->i40e_trqpairs[idx].itrq_rx_intrvec = j + 1;
+			i40e->i40e_trqpairs[idx].itrq_tx_intrvec = j + 1;
+		}
 	}
 
 	return (B_TRUE);
@@ -1925,6 +2047,8 @@ i40e_init_macaddrs(i40e_t *i40e, i40e_hw_t *hw)
 }
 
 /*
+ * RPZ: update comment.
+ *
  * Configure the hardware for the Virtual Station Interface (VSI).  Currently
  * we only support one, but in the future we could instantiate more than one
  * per attach-point.
@@ -1933,10 +2057,12 @@ static boolean_t
 i40e_config_vsi(i40e_t *i40e, i40e_hw_t *hw)
 {
 	struct i40e_vsi_context	context;
-	int err, tc_queues;
+	i40e_rx_group_t *def_rxg;
+	int err;
 
 	bzero(&context, sizeof (struct i40e_vsi_context));
-	context.seid = i40e->i40e_vsi_id;
+	context.seid = i40e->i40e_def_vsi_id;
+	i40e->i40e_vsi_ids[0] = i40e->i40e_def_vsi_id;
 	context.pf_num = hw->pf_id;
 	err = i40e_aq_get_vsi_params(hw, &context, NULL);
 	if (err != I40E_SUCCESS) {
@@ -1947,37 +2073,19 @@ i40e_config_vsi(i40e_t *i40e, i40e_hw_t *hw)
 	i40e->i40e_vsi_num = context.vsi_number;
 
 	/*
-	 * Set the queue and traffic class bits.  Keep it simple for now.
+	 * The second argument is 0 because we are configuring the
+	 * default VSI.
 	 */
-	context.info.valid_sections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;
-	context.info.mapping_flags = I40E_AQ_VSI_QUE_MAP_CONTIG;
-	context.info.queue_mapping[0] = I40E_ASSIGN_ALL_QUEUES;
+	i40e_set_shared_vsi_props(i40e, hw, &context.info, 0);
+
+	context.connection_type = I40E_AQ_VSI_CONN_TYPE_DEFAULT;
+	context.flags = I40E_AQ_VSI_TYPE_PF;
+	/* RPZ: Try VMDq2? */
+	/* context.flags = I40E_AQ_VSI_TYPE_VMDQ2; */
 
 	/*
-	 * tc_queues determines the size of the traffic class, where the size is
-	 * 2^^tc_queues to a maximum of 64 for the X710 and 128 for the X722.
-	 *
-	 * Some examples:
-	 * 	i40e_num_trqpairs == 1 =>  tc_queues = 0, 2^^0 = 1.
-	 * 	i40e_num_trqpairs == 7 =>  tc_queues = 3, 2^^3 = 8.
-	 * 	i40e_num_trqpairs == 8 =>  tc_queues = 3, 2^^3 = 8.
-	 * 	i40e_num_trqpairs == 9 =>  tc_queues = 4, 2^^4 = 16.
-	 * 	i40e_num_trqpairs == 17 => tc_queues = 5, 2^^5 = 32.
-	 * 	i40e_num_trqpairs == 64 => tc_queues = 6, 2^^6 = 64.
+	 * RPZ: I need to implement stats per VSI.
 	 */
-	tc_queues = ddi_fls(i40e->i40e_num_trqpairs - 1);
-
-	context.info.tc_mapping[0] = ((0 << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) &
-	    I40E_AQ_VSI_TC_QUE_OFFSET_MASK) |
-	    ((tc_queues << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT) &
-	    I40E_AQ_VSI_TC_QUE_NUMBER_MASK);
-
-	context.info.valid_sections |= I40E_AQ_VSI_PROP_VLAN_VALID;
-	context.info.port_vlan_flags = I40E_AQ_VSI_PVLAN_MODE_ALL |
-	    I40E_AQ_VSI_PVLAN_EMOD_NOTHING;
-
-	context.flags = LE16_TO_CPU(I40E_AQ_VSI_TYPE_PF);
-
 	i40e->i40e_vsi_stat_id = LE16_TO_CPU(context.info.stat_counter_idx);
 	if (i40e_stat_vsi_init(i40e) == B_FALSE)
 		return (B_FALSE);
@@ -1988,7 +2096,9 @@ i40e_config_vsi(i40e_t *i40e, i40e_hw_t *hw)
 		return (B_FALSE);
 	}
 
-
+	ASSERT3U(context.seid, ==, i40e->i40e_def_vsi_id);
+	def_rxg = &i40e->i40e_rx_groups[0];
+	def_rxg->irg_vsi_seid = i40e->i40e_def_vsi_id;
 	return (B_TRUE);
 }
 
@@ -2040,7 +2150,7 @@ i40e_config_rss_key(i40e_t *i40e, i40e_hw_t *hw)
  * we use the PF setting as it is the primary VSI.
  *
  * We populate the LUT in a round robin fashion with the rx queue indices from 0
- * to i40e_num_trqpairs - 1.
+ * to i40e_num_trqpairs_per_vsi - 1.
  */
 static boolean_t
 i40e_config_rss_hlut(i40e_t *i40e, i40e_hw_t *hw)
@@ -2070,8 +2180,10 @@ i40e_config_rss_hlut(i40e_t *i40e, i40e_hw_t *hw)
 		lut_mask = (1 << hw->func_caps.rss_table_entry_width) - 1;
 	}
 
-	for (i = 0; i < I40E_HLUT_TABLE_SIZE; i++)
-		((uint8_t *)hlut)[i] = (i % i40e->i40e_num_trqpairs) & lut_mask;
+	for (i = 0; i < I40E_HLUT_TABLE_SIZE; i++) {
+		((uint8_t *)hlut)[i] =
+		    (i % i40e->i40e_num_trqpairs_per_vsi) & lut_mask;
+	}
 
 	if (i40e_is_x722(i40e)) {
 		enum i40e_status_code status;
@@ -2145,6 +2257,128 @@ i40e_config_rss(i40e_t *i40e, i40e_hw_t *hw)
 	return (i40e_config_rss_hlut(i40e, hw));
 }
 
+/*
+ * RPZ: move this helper function with other helpers.
+ */
+static void
+i40e_set_shared_vsi_props(i40e_t *i40e, i40e_hw_t *hw,
+    struct i40e_aqc_vsi_properties_data *info, uint_t vsi_idx)
+{
+	int tc_queues;
+	uint32_t pflan_qalloc;
+	uint16_t first_qp;
+	uint16_t last_qp;
+	uint16_t vsi_qp_base;
+
+	pflan_qalloc = rd32(hw, I40E_PFLAN_QALLOC);
+
+	/* Get the index of the first and last QPs for this PF. */
+	first_qp = (I40E_PFLAN_QALLOC_FIRSTQ_MASK & pflan_qalloc) >>
+	    I40E_PFLAN_QALLOC_FIRSTQ_SHIFT;
+	last_qp = (I40E_PFLAN_QALLOC_LASTQ_MASK & pflan_qalloc) >>
+	    I40E_PFLAN_QALLOC_LASTQ_SHIFT;
+
+	/* Calculate the starting QP index for this VSI. */
+	vsi_qp_base = first_qp + (vsi_idx * i40e->i40e_num_trqpairs_per_vsi);
+	ASSERT3U(vsi_qp_base, >=, first_qp);
+	ASSERT3U(vsi_qp_base, <=, last_qp);
+	ASSERT3U(vsi_qp_base + i40e->i40e_num_trqpairs_per_vsi, <=, last_qp);
+
+	/* See table 7-77. */
+	/* RPZ: section 7.4.9.5.2.2 makes me think I need to set
+	 * switch ID to the switch ID of the VEB (which runs counter
+	 * to what table 7-77 says, I fucking hate the X710 PG).
+	 */
+	info->valid_sections |= I40E_AQ_VSI_PROP_SWITCH_VALID;
+	info->switch_id = i40e->i40e_veb_sid;
+
+	/*
+	 * Set the queue and traffic class bits.  Keep it simple for now.
+	 */
+	info->valid_sections |= I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;
+	info->mapping_flags = I40E_AQ_VSI_QUE_MAP_CONTIG;
+	info->queue_mapping[0] = vsi_qp_base;
+
+	/*
+	 * tc_queues determines the size of the traffic class, where the size is
+	 * 2^^tc_queues to a maximum of 64 for the X710 and 128 for the X722.
+	 *
+	 * Some examples:
+	 * 	i40e_num_trqpairs_per_vsi == 1 =>  tc_queues = 0, 2^^0 = 1.
+	 * 	i40e_num_trqpairs_per_vsi == 7 =>  tc_queues = 3, 2^^3 = 8.
+	 * 	i40e_num_trqpairs_per_vsi == 8 =>  tc_queues = 3, 2^^3 = 8.
+	 * 	i40e_num_trqpairs_per_vsi == 9 =>  tc_queues = 4, 2^^4 = 16.
+	 * 	i40e_num_trqpairs_per_vsi == 17 => tc_queues = 5, 2^^5 = 32.
+	 * 	i40e_num_trqpairs_per_vsi == 64 => tc_queues = 6, 2^^6 = 64.
+	 */
+	tc_queues = ddi_fls(i40e->i40e_num_trqpairs_per_vsi - 1);
+
+	info->tc_mapping[0] =
+	    ((vsi_qp_base << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) &
+	    I40E_AQ_VSI_TC_QUE_OFFSET_MASK) |
+	    ((tc_queues << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT) &
+	    I40E_AQ_VSI_TC_QUE_NUMBER_MASK);
+
+	/*
+	 * I40E_AQ_VSI_PVLAN_MODE_ALL ("VLAN driver insertion mode")
+	 *
+	 *	Allow tagged and untagged packets to be sent to this
+	 *	VSI from the host.
+	 *
+	 * I40E_AQ_VSI_PVLAN_EMOD_NOTHING ("VLAN and UP expose mode")
+	 *
+	 *	Leave the tag on the frame and place no VLAN
+	 *	information in the descriptor. We want this mode
+	 *	because our MAC layer will take care of the VLAN tag,
+	 *	if there is one.
+	 */
+	info->valid_sections |= I40E_AQ_VSI_PROP_VLAN_VALID;
+	info->port_vlan_flags = I40E_AQ_VSI_PVLAN_MODE_ALL |
+	    I40E_AQ_VSI_PVLAN_EMOD_NOTHING;
+}
+
+/*
+ * Add a new VSI.
+ */
+static boolean_t
+i40e_add_vsi(i40e_t *i40e, i40e_hw_t *hw, uint_t idx)
+{
+	struct i40e_vsi_context	ctx;
+	i40e_rx_group_t		*rxg;
+	int			rc;
+
+	/* The default VSI always exist.
+	 *
+	 * RPZ: verify for dev, turn to assert later.
+	 */
+	VERIFY3U(idx, !=, 0);
+	rxg = &i40e->i40e_rx_groups[idx];
+	bzero(&ctx, sizeof (struct i40e_vsi_context));
+
+	ctx.uplink_seid = i40e->i40e_veb_id;
+	ctx.pf_num = hw->pf_id;
+	/* might need to use VMDq2? */
+	/* ctx.flags = I40E_AQ_VSI_TYPE_PF; */
+	ctx.flags = I40E_AQ_VSI_TYPE_VMDQ2;
+	ctx.connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;
+	i40e_set_shared_vsi_props(i40e, hw, &ctx.info, idx);
+
+	rc = i40e_aq_add_vsi(hw, &ctx, NULL);
+
+	if (rc != I40E_SUCCESS) {
+		i40e_error(i40e, "i40e_aq_add_vsi() failed %d: %d", rc,
+		    hw->aq.asq_last_status);
+		return (B_FALSE);
+	}
+
+	/*
+	 * RPZ: I think I can delete i40e_vsi_ids.
+	 */
+	rxg->irg_vsi_seid = ctx.seid;
+	i40e->i40e_vsi_ids[idx] = ctx.seid;
+	return (B_TRUE);
+}
+
 /*
  * Wrapper to kick the chipset on.
  */
@@ -2190,9 +2424,17 @@ i40e_chip_start(i40e_t *i40e)
 
 	i40e_intr_chip_init(i40e);
 
+	/* RPZ: perhaps the ADD VEB call should be here? */
 	if (!i40e_config_vsi(i40e, hw))
 		return (B_FALSE);
 
+	for (uint_t i = 1; i < i40e->i40e_num_rx_groups; i++) {
+		if (!i40e_add_vsi(i40e, hw, i))
+			return (B_FALSE);
+	}
+
+	(void) i40e_rpz_stuff(i40e, hw);
+
 	if (!i40e_config_rss(i40e, hw))
 		return (B_FALSE);
 
@@ -2551,7 +2793,7 @@ i40e_setup_tx_hmc(i40e_trqpair_t *itrq)
 	 * assigned to traffic class zero, because we don't actually use them.
 	 */
 	bzero(&context, sizeof (struct i40e_vsi_context));
-	context.seid = i40e->i40e_vsi_id;
+	context.seid = i40e->i40e_def_vsi_id;
 	context.pf_num = hw->pf_id;
 	err = i40e_aq_get_vsi_params(hw, &context, NULL);
 	if (err != I40E_SUCCESS) {
@@ -2785,7 +3027,8 @@ i40e_start(i40e_t *i40e, boolean_t alloc)
 	 * Enable broadcast traffic; however, do not enable multicast traffic.
 	 * That's handle exclusively through MAC's mc_multicst routines.
 	 */
-	err = i40e_aq_set_vsi_broadcast(hw, i40e->i40e_vsi_id, B_TRUE, NULL);
+	err = i40e_aq_set_vsi_broadcast(hw, i40e->i40e_def_vsi_id, B_TRUE,
+	    NULL);
 	if (err != I40E_SUCCESS) {
 		i40e_error(i40e, "failed to set default VSI: %d", err);
 		rc = B_FALSE;
@@ -2847,6 +3090,105 @@ i40e_drain_rx(i40e_t *i40e)
 	return (B_TRUE);
 }
 
+static int
+i40e_rpz_stuff(i40e_t *i40e, i40e_hw_t *hw)
+{
+	int rc;
+	struct i40e_aqc_switch_resource_alloc_element_resp elems[0x14];
+	struct i40e_aqc_switch_resource_alloc_element_resp vsi_alloc;
+	uint8_t num = 0;
+	uint32_t val = 0;
+	uint16_t first = 0, last = 0;
+	uint32_t genc = 0;
+	uint_t num_tc = 0;
+
+	val = rd32(hw, I40E_PFLAN_QALLOC);
+	/* rpz: use dev instance num */
+	i40e_error(i40e, "PFLAN_QALLOC: 0x%x", val);
+
+	first = (I40E_PFLAN_QALLOC_FIRSTQ_MASK & val) >>
+	    I40E_PFLAN_QALLOC_FIRSTQ_SHIFT;
+	last = (I40E_PFLAN_QALLOC_LASTQ_MASK & val) >>
+	    I40E_PFLAN_QALLOC_LASTQ_SHIFT;
+
+	i40e_error(i40e, "PFLAN_QALLOC.FIRSTQ: %u", first);
+	i40e_error(i40e, "PFLAN_QALLOC.LASTQ: %u", last);
+
+	genc = rd32(hw, I40E_PRTDCB_GENC);
+	i40e_error(i40e, "PRTDCB_GENC: 0x%x", genc);
+
+	num_tc = (genc & I40E_PRTDCB_GENC_NUMTC_MASK) >>
+	    I40E_PRTDCB_GENC_NUMTC_SHIFT;
+
+	i40e_error(i40e, "num_tc: %u", num_tc);
+
+	/*
+	 * RPZ: Not sure if I want to call this function here. I might
+	 * want to create helper functions like i40e_get_num_vsi() or
+	 * soemthing.
+	 *
+	 */
+	rc = i40e_aq_get_switch_resource_alloc(hw, &num, elems, 0x14, NULL);
+	if (rc != I40E_SUCCESS) {
+		i40e_error(i40e, "i40e_aq_get_switch_resource_alloc() failed"
+		    " %d: %d", rc, hw->aq.asq_last_status);
+		return (B_FALSE);
+	}
+	/* ASSERT3U(num, >=, 0xD); */
+	i40e_error(i40e, "switch elems: %u", num);
+
+	/*
+	 * For now only considering using VSIs dedicated to this PF.
+	 * There may be more VSIs available in the shared pool. We may
+	 * want to consider utilizing them in a future update to this
+	 * driver.
+	 *
+	 * RPZ: I was going to use this as our group number but now I
+	 * wonder if I should be using the "Pefect match MAC
+	 * addresses" number (resource type 0x2)? A VSI does us no
+	 * good without the HW filter.
+	 *
+	 * RPZ: I have to read the queued sets (0xC) too I think. I
+	 * think I also need to enable "multi-queue set mode".
+	 */
+	vsi_alloc = elems[0];	/* make compiler happy */
+	for (uint_t i = 0; i < num; i++) {
+		if (elems[i].resource_type == I40E_AQ_RESOURCE_TYPE_VSI) {
+			vsi_alloc = elems[i];
+			break;
+		}
+	}
+	ASSERT(vsi_alloc.resource_type == I40E_AQ_RESOURCE_TYPE_VSI);
+
+	i40e->i40e_vsi_avail = vsi_alloc.guaranteed;
+	i40e->i40e_vsi_used = vsi_alloc.used;
+
+	i40e_error(i40e, "guaranteed: %u", vsi_alloc.guaranteed);
+	i40e_error(i40e, "used: %u", vsi_alloc.used);
+	i40e_error(i40e, "total dedicated: %u", vsi_alloc.total);
+	i40e_error(i40e, "total unallocated: %u", vsi_alloc.total_unalloced);
+
+	/*
+	 * Use dtrace to read the value of ctx after get_vsi_params()
+	 * returns.
+	 */
+	for (uint_t i = 0; i < i40e->i40e_num_rx_groups; i++) {
+		struct i40e_vsi_context ctx;
+
+		bzero(&ctx, sizeof (struct i40e_vsi_context));
+		ctx.pf_num = hw->pf_id;
+		ctx.seid = i40e->i40e_rx_groups[i].irg_vsi_seid;
+
+		rc = i40e_aq_get_vsi_params(hw, &ctx, NULL);
+		if (rc != I40E_SUCCESS) {
+			i40e_error(i40e, "i40e_aq_get_vsi_params() failed"
+			    " %d: %d", rc, hw->aq.asq_last_status);
+		}
+	}
+
+	return (B_TRUE);
+}
+
 static int
 i40e_attach(dev_info_t *devinfo, ddi_attach_cmd_t cmd)
 {
@@ -2942,6 +3284,7 @@ i40e_attach(dev_info_t *devinfo, ddi_attach_cmd_t cmd)
 	}
 	i40e->i40e_attach_progress |= I40E_ATTACH_STATS;
 
+	/* RPZ: I _think_ we need to go all group setup before this call. */
 	if (!i40e_register_mac(i40e)) {
 		i40e_error(i40e, "Failed to register to MAC/GLDv3");
 		goto attach_fail;
diff --git a/usr/src/uts/common/io/i40e/i40e_stats.c b/usr/src/uts/common/io/i40e/i40e_stats.c
index e5f6de9f9f..afdbaea1d0 100644
--- a/usr/src/uts/common/io/i40e/i40e_stats.c
+++ b/usr/src/uts/common/io/i40e/i40e_stats.c
@@ -251,7 +251,7 @@ i40e_stat_vsi_init(i40e_t *i40e)
 	i40e_vsi_kstats_t *ivk;
 	char buf[64];
 
-	(void) snprintf(buf, sizeof (buf), "vsi_%d", i40e->i40e_vsi_id);
+	(void) snprintf(buf, sizeof (buf), "vsi_%d", i40e->i40e_def_vsi_id);
 
 	ksp = kstat_create(I40E_MODULE_NAME, ddi_get_instance(i40e->i40e_dip),
 	    buf, "net", KSTAT_TYPE_NAMED,
@@ -259,7 +259,7 @@ i40e_stat_vsi_init(i40e_t *i40e)
 
 	if (ksp == NULL) {
 		i40e_error(i40e, "Failed to create kstats for VSI %d",
-		    i40e->i40e_vsi_id);
+		    i40e->i40e_def_vsi_id);
 		return (B_FALSE);
 	}
 
diff --git a/usr/src/uts/common/io/i40e/i40e_sw.h b/usr/src/uts/common/io/i40e/i40e_sw.h
index 8e1d72a09e..fc26de2a6f 100644
--- a/usr/src/uts/common/io/i40e/i40e_sw.h
+++ b/usr/src/uts/common/io/i40e/i40e_sw.h
@@ -260,6 +260,8 @@ typedef enum i40e_itr_index {
  * queues that it's allowed to access from the PF. Because we only have a single
  * VSI per PF at this time, we assign it all the queues.
  *
+ * RPZ: Update this comment.
+ *
  * Many of the devices support what's called Data-center Bridging. Which is a
  * feature that we don't have much use of at this time. However, we still need
  * to fill in this information. We follow the guidance of the note in Table 7-80
@@ -288,8 +290,8 @@ typedef enum i40e_itr_index {
  * will be gone in the fullness of time, but as we're bringing up the device,
  * this is what we use.
  */
-#define	I40E_GROUP_MAX		1
-#define	I40E_TRQPAIR_MAX	1
+#define	I40E_GROUP_MAX			4
+#define	I40E_TRQPAIR_MAX_PER_VSI	64
 
 #define	I40E_GROUP_NOMSIX	1
 #define	I40E_TRQPAIR_NOMSIX	1
@@ -790,6 +792,13 @@ typedef struct i40e_func_rsrc {
 	uint_t	ifr_nmcastfilt_used;
 } i40e_func_rsrc_t;
 
+typedef struct i40e_rx_group {
+	uint32_t		irg_index;
+	uint16_t		irg_vsi_seid;
+	mac_group_handle_t	irg_grp_hdl;
+	struct i40e		*irg_i40e;
+} i40e_rx_group_t;
+
 /*
  * Main i40e per-instance state.
  */
@@ -821,8 +830,14 @@ typedef struct i40e {
 	/*
 	 * Device state, switch information, and resources.
 	 */
-	int			i40e_vsi_id;
-	uint16_t		i40e_vsi_num;
+	uint16_t		i40e_vsi_ids[I40E_GROUP_MAX]; /* RPZ: list_t */
+	int			i40e_def_vsi_id; /* for default group */
+	int			i40e_uplink_id;	 /* SEID of physical MAC */
+	uint16_t		i40e_veb_id;	 /* switch atop MAC (SEID) */
+	uint16_t		i40e_veb_sid;	 /* Switch ID for VEB */
+	uint16_t		i40e_vsi_avail;	 /* VSIs avail to this PF */
+	uint16_t		i40e_vsi_used;	 /* VSIs used by this PF */
+	uint16_t		i40e_vsi_num;	 /* RPZ: needs to be array */
 	struct i40e_device	*i40e_device;
 	i40e_func_rsrc_t	i40e_resources;
 	uint16_t		i40e_switch_rsrc_alloc;
@@ -843,12 +858,13 @@ typedef struct i40e {
 	 */
 	i40e_trqpair_t	*i40e_trqpairs;
 	boolean_t 	i40e_mr_enable;
-	int		i40e_num_trqpairs;
+	uint_t		i40e_num_trqpairs; /* total TRQPs (per PF) */
+	uint_t		i40e_num_trqpairs_per_vsi; /* TRQPs per VSI */
 	uint_t		i40e_other_itr;
 
+	i40e_rx_group_t	*i40e_rx_groups;
 	int		i40e_num_rx_groups;
 	int		i40e_num_rx_descs;
-	mac_group_handle_t i40e_rx_group_handle;
 	uint32_t	i40e_rx_ring_size;
 	uint32_t	i40e_rx_buf_size;
 	boolean_t	i40e_rx_hcksum_enable;
-- 
2.21.0

