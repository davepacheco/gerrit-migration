commit ae9d949e32b950972f37d0a75276558becbaed39 (refs/changes/66/5566/1)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2019-02-11T21:43:26+00:00 (8 months ago)
    
    NET-329 Container-specific firewall rules should be removed when deleting containers

diff --git a/lib/endpoints/firewalls/vms.js b/lib/endpoints/firewalls/vms.js
index b5be7d9..649738f 100644
--- a/lib/endpoints/firewalls/vms.js
+++ b/lib/endpoints/firewalls/vms.js
@@ -9,7 +9,7 @@
  */
 
 /*
- * Restify handlers for listing rules applied to vms
+ * Restify handlers for listing and deleting rules applied to vms
  */
 
 var mod_err = require('../../errors');
@@ -18,6 +18,11 @@ var restify = require('restify');
 var util = require('util');
 var validators = require('fwrule/lib/validators');
 
+var Rule = require('../../rule.js').Rule;
+var mod_vasync = require('vasync');
+
+var VError = require('verror').VError;
+
 
 
 // --- Internal helpers
@@ -79,7 +84,225 @@ function getVMrules(req, res, next) {
     });
 }
 
+function VMExistsError(vm) {
+    VError.apply(this, Array.prototype.slice.call(arguments, 1));
+    this.vm = vm;
+}
+
+/*
+ * This merely checks that `vm` does not exist. See `nextVmWrap()` for
+ * details on why we pass that instead of `nextVmCb` to `getVm`.
+ */
+function checkVMExists(targ, req, vm_uuid, nextVmCb)
+{
+    req._vmapi.getVm({uuid: vm_uuid}, function nextVmWrap(err, vm) {
+        if (err) {
+            if (err.statusCode == 404) {
+                nextVmCb(null);
+                return;
+            } else {
+                nextVmCb(err);
+                return;
+            }
+        }
+
+        if (vm.uuid == targ || vm.state == 'destroyed') {
+            nextVmCb(null);
+            return;
+        } else {
+            nextVmCb(new VMExistsError(vm));
+            return;
+        }
+    });
+}
+
+/*
+ * This function is called as part of the pipeline that processes the tuple of
+ * VM-arrays. It merely initiates a sub-pipeline that processes an array of
+ * VMs. We don't call `nextVmArr` from this function. We would not have all
+ * the information we need to advance the vm_tuple pipeline. So we call it from
+ * within the nextVm callback.
+ */
+function verifyVmsNonExistent(targ, req, vm_list, cb)
+{
+    mod_vasync.forEachPipeline({
+        'func': checkVMExists.bind(null, targ, req),
+        'inputs': vm_list
+    }, function nextVmCb(err, res) {
+        if (err) {
+            if (err instanceof VMExistsError) {
+                return cb(null, true);
+            } else {
+                return cb(err);
+            }
+        } else {
+            /* We only call the `cb` if we've finished all elements */
+            if (res.ndone == vm_list.length) {
+                return cb(null, false);
+            }
+        }
+    });
+}
+
+function sideActive(side, cb)
+{
+    if (side.wildcards.length > 0 || side.ips.length > 0 ||
+        side.subnets.length > 0) {
+
+        return cb(true);
+    }
+    return cb(false);
+}
 
+function vmSideActive(targ, req, side, cb)
+{
+    if (side.vms.length === 0) {
+        return cb(null, false);
+    }
+    verifyVmsNonExistent(targ, req, side.vms, cb);
+}
+
+/*
+ * If vm.uuid is singular source/destination in this rule,
+ * delete the rule. Otherwise, if either of the
+ * source/destination lists contain ONLY VMs that have been
+ * deleted, we delete the rule. For all other scenarios we do
+ * nothing.
+ */
+function maybeDeleteRule(targ, req, rule, nextRuleCb)
+{
+    if (rule.tags.length > 0) {
+        return nextRuleCb();
+    }
+    function ruleTryDelete(err2, active2) {
+        if (active2) {
+            return nextRuleCb();
+        }
+        if (err2) {
+            return nextRuleCb(err2);
+        }
+        var deleteCb = function (err3, res3) {
+            if (err3 && err3.statusCode != 404) {
+                return nextRuleCb(err3);
+            }
+
+            return nextRuleCb();
+        };
+
+        mod_persist.deleteRule(req._app, req.log, rule.uuid, deleteCb);
+    }
+
+    sideActive(rule.from, function isFromActive(active) {
+        if (active) {
+            sideActive(rule.to, function isToActiveToo(active2) {
+                /* both sides are active */
+                if (active2) {
+                    return nextRuleCb();
+                }
+                /*
+                 * Only the `from` side is active, so we go ahead check the
+                 * existence of the VMs in `to`.
+                 */
+                vmSideActive(targ, req, rule.to, ruleTryDelete);
+            });
+        } else {
+            sideActive(rule.to, function isToActive(active2) {
+
+                /*
+                 * Only the `to` side is active, so we go ahead check the
+                 * existence of the VMs in `from`.
+                 */
+                if (active2) {
+                    vmSideActive(targ, req, rule.from, ruleTryDelete);
+                    return;
+                }
+                /*
+                 * No sides are active so we check the VMs on both sides.
+                 */
+                vmSideActive(targ, req, rule.to,
+
+                    function isToVmActive(err, active3) {
+
+                    if (err) {
+                        return nextRuleCb(err);
+                    }
+                    if (active3) {
+                        vmSideActive(targ, req, rule.from, ruleTryDelete);
+                        return;
+                    }
+                    ruleTryDelete(null, false);
+                });
+            });
+        }
+    });
+}
+
+/*
+ * DELETE /firewalls/vms/:uuid
+ *
+ * Overview
+ * --------
+ *
+ * This endpoint is similar to the above except that it a) deletes rules
+ * instead of retrieving them, and b) deletes rules that affect no other VM
+ * than the one referenced by :uuid.
+ *
+ * If :uuid is the singular source or singular destination, we simply delete
+ * the rule. If :uuid is a member of a list, we check whether any of the VMs in
+ * that list still exist. If so, we do nothing. If they have all been
+ * destroyed, we delete the rule.
+ *
+ * There is another way to implement this. If :uuid is not the singular
+ * source/destination, one can simply update the rule to no longer include
+ * :uuid in it. If the VMs in that rule keep getting destroyed, then over time
+ * the rule will contain a VM that is a singular source/destination and it will
+ * be destroyed when that last VM is destroyed. This method generates fewer
+ * remote API calls than the former (we have to ask VMAPI about every single
+ * VM), but the former method appears to be less error prone. At some point, it
+ * may be desirable to switch to the latter method.
+ */
+function deleteVMrules(req, res, next)
+{
+    req._vmapi.getVm(req.params, function (err, vm) {
+        if (err) {
+            res.send(503);
+            return next();
+        }
+
+        var filter = {
+            owner_uuid: vm.owner_uuid,
+            tags: vm.tags,
+            vms: [ vm.uuid ]
+        };
+
+        var filterCb = function (err2, rules) {
+            if (err2) {
+                res.send(503);
+                return next();
+            }
+
+            /*
+             * We want to map over the rules and delete them. We could do this
+             * in parallel, however that would make the test suite useless
+             * (which assumes we are deleting in sequence).
+             */
+            mod_vasync.forEachPipeline({
+                'func': maybeDeleteRule.bind(null, vm.uuid, req),
+                'inputs': rules
+            }, function nextRule(err3, obj) {
+                if (err3) {
+                    res.send(503);
+                    next();
+                    return;
+                }
+                res.send(200);
+                next();
+            });
+        };
+
+        mod_persist.vmRules(req._app, req.log, filter, filterCb);
+    });
+}
 
 // --- Exports
 
@@ -91,6 +314,8 @@ function getVMrules(req, res, next) {
 function register(server, before) {
     server.get({ path: '/firewalls/vms/:uuid', name: 'getVMrules' },
         before.concat(validateParams), getVMrules);
+    server.del({ path: '/firewalls/vms/:uuid', name: 'deleteVMrules' },
+        before.concat(validateParams), deleteVMrules);
 }
 
 
diff --git a/package.json b/package.json
index b3d0598..9c2efc3 100644
--- a/package.json
+++ b/package.json
@@ -21,11 +21,11 @@
     "moray": "git+ssh://git@github.com:joyent/node-moray.git#b84ef0e",
     "tape": "4.2.2",
     "node-uuid": "1.2.0",
-    "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients.git#5b10072",
+    "sdc-clients": "git+ssh://git@github.com:joyent/node-sdc-clients#a6d007bd",
     "ufds": "git+ssh://git@github.com:joyent/node-ufds.git#a7c674b76696fe7ab0fff1e2486f20d3af6a0d1a",
     "restify": "git+ssh://git@github.com:mcavage/node-restify.git#0d7b4ba",
     "trace-event": "1.3.0",
-    "vasync": "1.3",
+    "vasync": "1.6.3",
     "verror": "1.3",
     "xtend": "4.0"
   },
diff --git a/test/bin/gen-uni-test-config b/test/bin/gen-uni-test-config
new file mode 100755
index 0000000..be69e05
--- /dev/null
+++ b/test/bin/gen-uni-test-config
@@ -0,0 +1,63 @@
+#!/usr/bin/env bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+#
+# Generate test/config.json for running multi-server integration tests.
+
+if [ "$TRACE" != "" ]; then
+    export PS4='${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+
+set -o errexit
+set -o pipefail
+
+
+
+#---- support functions
+
+function fatal
+{
+    echo "$(basename $0): fatal error: $*"
+    exit 1
+}
+
+#---- main
+
+dir=$(unset CDPATH; cd $(dirname $0); pwd)
+test_dir=$(unset CDPATH; cd $(dirname $0)/..; pwd)
+json_file=${test_dir}/config.json
+json_in_file=${test_dir}/config.json.in
+vmapi_url=$(json -f /opt/smartdc/fwapi/config.json vmapi.url)
+imgapi_url=${vmapi_url//vmapi/imgapi}
+cnapi_url=${vmapi_url//vmapi/cnapi}
+
+[[ -z ${vmapi_url} ]] && fatal "Could not get vmapi URL from fwapi's config.json"
+
+image_uuid=$(curl -sS ${imgapi_url}/images'?name=sdc-smartos' | json 0.uuid)
+[[ -z ${image_uuid} ]] && fatal "Could not find an image named sdc-smartos in IMGAPI"
+
+
+servers=( $(curl -sS ${cnapi_url}/servers | json -a uuid setup | grep true | awk '{ print $1 }' | head -n 1) )
+
+[[ -z ${servers[0]} ]] && fatal "Could not get server1 from CNAPI"
+
+${dir}/add-test-user
+
+echo "Writing single-server test config: ${json_file}"
+sed -e "s,{{PROVISION_IMAGE}},${image_uuid}," \
+    -e "s,{{SERVER1_UUID}},${servers[0]}," \
+    -e "s,{{SERVER2_UUID}},," \
+    -e "s,{{FWAPI_URL}},${vmapi_url//vmapi/fwapi}," \
+    -e "s,{{NAPI_URL}},${vmapi_url//vmapi/napi}," \
+    -e "s,{{VMAPI_URL}},${vmapi_url}," \
+    -e "s,{{WFAPI_URL}},${vmapi_url//vmapi/wfapi}," \
+    ${json_in_file} > ${json_file}
diff --git a/test/integration/firewalls.vms.test.js b/test/integration/firewalls.vms.test.js
new file mode 100644
index 0000000..72cdb98
--- /dev/null
+++ b/test/integration/firewalls.vms.test.js
@@ -0,0 +1,647 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for /firewalls/vms/:uuid endpoint.
+ */
+
+var test = require('tape');
+var assert = require('assert-plus');
+var fmt = require('util').format;
+var helpers = require('./helpers');
+var mod_rule = require('../lib/rule');
+var mod_vm = require('../lib/vm');
+var mod_uuid = require('node-uuid');
+var util = require('util');
+var config = require('../lib/config');
+var async = require('async');
+var mod_vasync = require('vasync');
+var mod_client = require('../lib/client');
+
+var OWNERS = [ config.test.owner_uuid ];
+
+var VMS = [];
+var delVMS = [];
+var NVM = 9;
+
+/*
+ * Create NVM number of VMs. Use them for our evil experiments.
+ */
+test('setup', function (t)
+{
+    var vms = [];
+    for (var vi = 0; vi < NVM; vi++) {
+        vms[vi] =
+            {
+                alias: mod_vm.alias(),
+                firewall_enabled: true,
+                owner_uuid: OWNERS[0],
+                server_uuid: config.test.server1_uuid,
+                tags: { }
+            };
+    }
+
+    mod_vm.provision(t, {
+        vms: vms
+    }, function (err, res) {
+        t.ok(err === null, 'Should have no provisioning errors');
+        if (res) {
+            VMS = res;
+        }
+
+        /* now we delete the last 2 vms. */
+        var di = 0;
+        for (vi = 8; vi < NVM; vi++) {
+            delVMS[di] = VMS[vi];
+            di++;
+        }
+
+        var doDelete = function (t2, vm, cb) {
+            mod_vm.delOneNoPoll(t2, { uuid: vm.uuid }, cb);
+        };
+
+        var count = 0;
+
+        mod_vasync.forEachParallel({
+            'func': doDelete.bind(null, t),
+            'inputs': delVMS
+        }, function delCb(err2, res2) {
+            count++;
+            if (err2) {
+                return;
+            }
+            if (count == delVMS.length) {
+                t.end();
+                return (t);
+            } else {
+                return;
+            }
+        });
+    });
+});
+
+
+/*
+ * After we've created the VMs and initialized the delete of the last VM, we
+ * want to sleep for 5 minutes, to give the system time to propagate the new VM
+ * state. This may seem like a hack, and like polling is a better solution. But
+ * it's not -- as that makes the tests unbearable slow.
+ */
+test('sleep', function (t)
+{
+    var destroyed = 0;
+    delVMS.forEach(function (vm) {
+        var checkState = function () {
+            console.log('Checking VM State...');
+            mod_vm.get(t, {uuid: vm.uuid}, function (err, vm2) {
+                if (err) {
+                    t.ok(false, 'Got error during VM state poll');
+                    t.end();
+                    return;
+                }
+                if (vm2.state == 'destroyed') {
+                    destroyed++;
+                    console.log('Destroyed...');
+                    if (destroyed == delVMS.length) {
+                        t.end();
+                        console.log('Stop Checking');
+                    }
+                    return;
+                } else {
+                    setTimeout(checkState, 1000);
+                }
+            });
+        };
+        setTimeout(checkState, 1000);
+    });
+});
+
+
+
+/*
+ * So we have $NVM VMs. For the singular rule case, we want to take the first
+ * VM and create 2 rules for it:
+ *      -In the first rule it is the only VM in the FROM clause.
+ *          -All other VMs are in TO clause.
+ *      -In the second rule it is the only VM in the TO clause.
+ *          -All other VMs are in FROM clause.
+ *
+ * The expectation is that if we call DELETE /firewalls/vms/:uuid on the first
+ * machine, the rules above will be deleted. We try this for both the case
+ * where the VM exists and where the VM is deleted. It should work for both,
+ * regardless.
+ *
+ * For the multi machine case, we place half the VMs in one of the clauses, and
+ * all of the VMs in the other clause. We delete each of the machine in the
+ * half-sized group and call the endpoint on it.
+ *
+ * The expectation is that the rule-deletion should fail until we get to the
+ * last call of the endpoint.
+ */
+
+/*
+ * Returns either all vms in the VMS array, or a limited number.
+ */
+function all_vm_list(limit)
+{
+    var N = NVM;
+    if (limit) {
+        N = limit;
+    }
+
+    assert.arrayOfObject(VMS, 'VMS');
+
+    var vm_map_cb = function (vm) {
+        assert.uuid(vm.uuid);
+        return 'VM ' + vm.uuid;
+    };
+
+    return '(' + VMS.slice(0, N).map(vm_map_cb).join(' OR ') + ')';
+}
+
+/*
+ * Prints two VMs from the VMS array, user's choice (by index).
+ */
+function two_vm_list(a, b)
+{
+    var ret = '';
+    assert.arrayOfObject(VMS, 'VMS');
+    assert.number(a, 'a');
+    assert.number(b, 'b');
+    ret = '( VM ' + VMS[a].uuid + ' OR VM ' + VMS[b].uuid + ')';
+    return (ret);
+}
+
+function singularCommon(t, rule_raw, deletable)
+{
+    var expErr = {
+        code: 'ResourceNotFound',
+        message: 'Rule not found'
+    };
+
+    /*
+     * This callback is meant to be run by the create-rule function. It does
+     * some basic checking, and then calls the FWAPI endpoint for deleting
+     * rules that affect a VM (VMS[0].uuid). The function that calls this
+     * endpoint (deleteVMrules), also take a callback which checks to see if
+     * these rules still exist.
+     */
+    var rule_create_cb = function (err, rule) {
+        t.ok(err === null, 'Should not err when creating rule.');
+        if (err) {
+            t.end();
+            return;
+        }
+
+        mod_rule.deleteVMrules(t, {
+            uuid: VMS[0].uuid,
+            params: { owner_uuid: OWNERS[0] }
+            }, function (err2, res2) {
+                var del_vm_args;
+                if (deletable) {
+                    del_vm_args = {uuid: rule.uuid, expErr: expErr,
+                        expCode: 404};
+                } else {
+                    del_vm_args = {uuid: rule.uuid};
+                }
+                mod_rule.get(t, del_vm_args, function (err3, res3) {
+
+                    if (deletable) {
+                        t.ok(err3 !== null, 'err3 !== null');
+                    } else {
+                        t.ok(err3 === null, 'err3 === null');
+                    }
+                    if (err3) {
+                        mod_rule.get(t, {uuid: rule.uuid, expErr: expErr,
+                            expCode: 404}, function (err4, res4) {
+                            /*
+                             * This GET should also return an error.
+                             */
+                            t.ok(err4 !== null, 'err4 !== null');
+                            t.end();
+                        });
+                    } else {
+                        mod_rule.get(t, {uuid: rule.uuid},
+                            function (err4, res4) {
+                            /*
+                             * This get-request should not return an error.
+                             */
+                            t.ok(err4 === null, 'err4 === null');
+                            t.end();
+                        });
+                    }
+                });
+             });
+    };
+
+    mod_rule.create(t, {rule: rule_raw}, rule_create_cb);
+
+    return (t);
+}
+
+test('singularFrom', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM VM %s TO %s ALLOW tcp PORT 22',
+                 VMS[0].uuid, all_vm_list(4))
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularTo', function (t)
+{
+    var rule_raw = {
+        description: 'Singular TO',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO VM %s ALLOW tcp PORT 22',
+                all_vm_list(4), VMS[0].uuid)
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularFromAny', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM Any',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO VM %s ALLOW tcp PORT 22',
+                'any', VMS[0].uuid)
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularToAny', function (t)
+{
+    var rule_raw = {
+        description: 'Singular TO Any',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM VM %s TO %s ALLOW tcp PORT 22',
+                VMS[0].uuid, 'any')
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularFromAnyToAll', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM Any TO All',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                'any', 'all vms')
+    };
+    t = singularCommon(t, rule_raw, 0);
+    return (t);
+});
+
+test('singularFromAll', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM All',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO VM %s ALLOW tcp PORT 22',
+                'all vms', VMS[0].uuid)
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularToAll', function (t)
+{
+    var rule_raw = {
+        description: 'Singular To All',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM VM %s TO %s ALLOW tcp PORT 22',
+                VMS[0].uuid, 'all vms')
+    };
+    t = singularCommon(t, rule_raw, 1);
+    return (t);
+});
+
+test('singularFromAllToAny', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM All TO Any',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                'all vms', 'any')
+    };
+    t = singularCommon(t, rule_raw, 0);
+    return (t);
+});
+
+test('singularFromTag', function (t)
+{
+    var rule_raw = {
+        description: 'Singular FROM Tag',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO VM %s ALLOW tcp PORT 22',
+                'tag mytag', VMS[0].uuid)
+    };
+    t = singularCommon(t, rule_raw, 0);
+    return (t);
+});
+
+test('singularToTag', function (t)
+{
+    var rule_raw = {
+        description: 'Singular TO Tag',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM VM %s TO %s ALLOW tcp PORT 22',
+                VMS[0].uuid, 'tag mytag')
+    };
+    t = singularCommon(t, rule_raw, 0);
+    return (t);
+});
+
+var pluralCaseCommon = function (t, rule1raw, targ_uuid, deletable)
+{
+    var expErr = {
+        code: 'ResourceNotFound',
+        message: 'Rule not found'
+    };
+
+    var created_rule;
+
+    var rule_get_cb = function (err, res) {
+        t.end();
+    };
+
+
+    var rule_create_cb = function (err, res) {
+        t.ok(err === null, 'Should not err when creating rule.');
+        if (err) {
+            t.end();
+            return;
+        }
+
+        created_rule = res;
+
+        var delete_vm_rules_opts;
+        if (deletable) {
+            delete_vm_rules_opts = {uuid: created_rule.uuid, expErr: expErr,
+                expCode: 404};
+        } else {
+            delete_vm_rules_opts = {uuid: created_rule.uuid};
+        }
+        var delete_vm_rules_cb = function (err2, res2) {
+            mod_rule.get(t, delete_vm_rules_opts, rule_get_cb);
+        };
+
+        /*
+         * Delete VM rules, and check if the rule is gone or not.
+         */
+        mod_rule.deleteVMrules(t, {
+            uuid: targ_uuid,
+            params: {
+                owner_uuid: OWNERS[0]
+            },
+            expCode: 204}, delete_vm_rules_cb);
+    };
+
+    var client = mod_client.get('vmapi');
+    client.getVm({ uuid: VMS[8].uuid }, function (err2, vm) {
+        if (err2) {
+            return;
+        }
+        if (vm.state != 'destroyed') {
+            return;
+        }
+        mod_rule.create(t, {rule: rule1raw}, rule_create_cb);
+    });
+};
+
+test('pluralToNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural TO Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                all_vm_list(4), two_vm_list(0, 1))
+    };
+    pluralCaseCommon(t, rule1raw, VMS[0].uuid, 0);
+});
+
+test('pluralToAllNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural TO All Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                all_vm_list(0, 1), 'ALL VMS')
+    };
+    pluralCaseCommon(t, rule1raw, VMS[0].uuid, 0);
+});
+
+test('pluralToDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural TO Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                all_vm_list(4), two_vm_list(0, 8))
+    };
+    pluralCaseCommon(t, rule1raw, VMS[0].uuid, 1);
+});
+
+test('pluralToAllDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural TO All Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(0, 8), 'ALL VMS')
+    };
+    pluralCaseCommon(t, rule1raw, VMS[0].uuid, 1);
+});
+
+test('pluralFromNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural FROM Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(2, 3), all_vm_list(4))
+    };
+    pluralCaseCommon(t, rule1raw, VMS[2].uuid, 0);
+});
+
+test('pluralFromAllNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural FROM All Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(2, 3), 'ALL VMS')
+    };
+    pluralCaseCommon(t, rule1raw, VMS[2].uuid, 0);
+});
+
+test('pluralFromDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural FROM Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(2, 8), all_vm_list(4))
+    };
+    pluralCaseCommon(t, rule1raw, VMS[2].uuid, 1);
+});
+
+test('pluralFromAllDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Plural FROM All Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(2, 8), 'ALL VMS')
+    };
+    pluralCaseCommon(t, rule1raw, VMS[2].uuid, 1);
+});
+
+/*
+ * We try this on a rule where the VM-lists are the same length (2). Target is
+ * in FROM.
+ */
+test('smallPluralFromNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Small Plural FROM Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(4, 5), two_vm_list(6, 7))
+    };
+
+    pluralCaseCommon(t, rule1raw, VMS[4].uuid, 0);
+});
+
+test('smallPluralFromDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Small Plural FROM Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(4, 8), two_vm_list(6, 7))
+    };
+
+    pluralCaseCommon(t, rule1raw, VMS[4].uuid, 1);
+});
+
+/*
+ * We try this on a rule where the VM-lists are the same length (2). Target is
+ * in TO.
+ */
+test('smallPluralToNotDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Small Plural TO Not Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(4, 5), two_vm_list(6, 7))
+    };
+
+    pluralCaseCommon(t, rule1raw, VMS[6].uuid, 0);
+});
+
+test('smallPluralToDeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Small Plural TO Deletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM %s TO %s ALLOW tcp PORT 22',
+                two_vm_list(4, 5), two_vm_list(6, 8))
+    };
+
+    pluralCaseCommon(t, rule1raw, VMS[6].uuid, 1);
+});
+
+test('mixedUndeletable', function (t)
+{
+    var rule1raw = {
+        description: 'Mixed TO Undeletable',
+        enabled: true,
+        owner_uuid: OWNERS[0],
+        rule: util.format(
+                'FROM ip 8.8.8.8 TO %s ALLOW tcp PORT 22',
+                two_vm_list(5, 6))
+    };
+    pluralCaseCommon(t, rule1raw, VMS[6].uuid, 0);
+});
+
+/*
+ * We want to destroy any remaining VMs.
+ */
+test('teardown VMs', function (t)
+{
+    mod_vm.delAllCreated(t, function (err, res) {
+        if (err) {
+            t.ok(err === null, 'Should not have errors when destroying VMs.');
+            t.end();
+            return;
+        }
+        t.end();
+    });
+});
+
+test('teardown Rules', function (t)
+{
+    mod_rule.delAllCreated(t, function (err, res) {
+        t.end();
+    });
+});
diff --git a/test/lib/rule.js b/test/lib/rule.js
index 90803ee..b35630d 100644
--- a/test/lib/rule.js
+++ b/test/lib/rule.js
@@ -216,6 +216,38 @@ function del(t, opts, callback) {
     });
 }
 
+/**
+ * Delete firewall rules that affect a specific machine (and only that
+ * machine).
+ */
+function deleteVMrules(t, opts, callback)
+{
+
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalFunc(callback, 'callback');
+
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalObject(opts.params, 'opts.params');
+
+    var client = opts.client || mod_client.get('fwapi');
+    var desc = fmt(' (del VM\'s Rules = %s)', opts.uuid);
+    var params = opts.params || {};
+
+    t.ok(opts.uuid, 'uuid ' + desc);
+    LOG.debug({opts: opts}, 'deleting VM\'s rules');
+    /*
+     * This endpoint may return an error if fwapi times out when making
+     * requests to either vmapi or ufds. This will trigger a test failure, and
+     * the dev may wish to re-run the test suite.
+     */
+    client.delVMrules(opts.uuid, params, function (err, res) {
+        t.ok(err === null, 'No error code, as expected.');
+        callback(err, res);
+    });
+}
+
 
 /**
  * Deletes all rules created
@@ -282,6 +314,8 @@ function get(t, opts, callback) {
                 var code = opts.expCode || 422;
                 t.equal(err.statusCode, code, 'status code');
                 t.deepEqual(err.body, opts.expErr, 'error body');
+                /* If this rule does not exist, it should not be in RULES */
+                delete RULES[opts.uuid];
             }
 
             if (obj && obj.rule) {
@@ -600,5 +634,6 @@ module.exports = {
     update: update,
     updateAndGet: updateAndGet,
     resolve: resolve,
-    vmRules: vmRules
+    vmRules: vmRules,
+    deleteVMrules: deleteVMrules
 };
diff --git a/test/lib/vm.js b/test/lib/vm.js
index c52a5a6..9a2d9cd 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -35,7 +35,7 @@ var VM_PARAMS = {
     image_uuid: config.test.provision_image,
     networks: [ { name: 'external' } ],
     brand: 'joyent',
-    ram: 128
+    ram: 512
 };
 var VM_NUM = 0;
 var LOG = mod_log.child({ component: 'vm' });
@@ -251,6 +251,37 @@ function delOne(t, opts, callback) {
     });
 }
 
+function get(t, opts, callback)
+{
+    var client = opts.client || mod_client.get('vmapi');
+
+    client.getVm(opts, callback);
+}
+
+/**
+ * Delete a single VM, just like delOne. However it does not poll the VM's
+ * state recursively. Which seems to be the source of much slowness.
+ */
+function delOneNoPoll(t, opts, callback) {
+    assert.string(opts.uuid, 'opts.uuid');
+
+    var client = opts.client || mod_client.get('vmapi');
+    var desc = fmt(' (vm=%s)', opts.uuid);
+
+    LOG.debug({ vm: opts.uuid }, 'deleting VM');
+
+    var delParams = { uuid: opts.uuid };
+
+    client.deleteVm(delParams, function (err, job) {
+        if (ifErr(t, err, 'delete VM' + desc)) {
+            t.deepEqual(delParams, {}, 'VM delete params');
+            return callback(err);
+        }
+        return callback();
+    });
+}
+
+
 
 /**
  * Provision VMs and wait for those provisions to complete.
@@ -379,5 +410,8 @@ module.exports = {
     del: del,
     delAllCreated: delAllCreated,
     provision: provision,
-    update: update
+    update: update,
+    delOne: delOne,
+    delOneNoPoll: delOneNoPoll,
+    get: get
 };
