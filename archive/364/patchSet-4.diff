commit 00c035661f6129e9770fe6c544cd8786ba630fb1 (refs/changes/64/364/4)
Author: Jordan Paige Hendricks <jordan.hendricks@joyent.com>
Date:   2016-08-31T00:49:13+00:00 (3 years, 1 month ago)
    
    MANTA-2910 muskie log entries could include shard, objectid, sharks

diff --git a/lib/audit.js b/lib/audit.js
index e504737..d9783bf 100644
--- a/lib/audit.js
+++ b/lib/audit.js
@@ -203,10 +203,11 @@ function auditLogger(options) {
         });
 
         var name = route ? (route.name || route) : 'unknown';
+        var op = billable(name, req);
         var obj = {
             _audit: true,
             operation: name,
-            billable_operation: billable(name, req),
+            billable_operation: op,
             bytesTransferred: req._size,
             remoteAddress: req.connection._xff,
             remotePort: req.connection.remotePort,
@@ -220,6 +221,30 @@ function auditLogger(options) {
             secure: req.secure
         };
 
+        /*
+         * Log some additional information for successful requests related
+         * only to Manta objects (excluding job-related requests).
+         * Specifically, we log: object ID, shard contacted for metadata,
+         * and the sharks contacted, in order for successful GET requests.
+         *
+         * This information isn't easily retrievable for some types of
+         * unsuccessful requests, so we are filtering them out for now.
+         * We also filter out job-related requests by checking for the string
+         * 'job' in the API call, as all job-related calls contain this string
+         * (and no non-job related calls do).
+         *
+         */
+        var successful = ((res.statusCode >= 200) && (res.statusCode < 300));
+        var validOp = op === 'GET' || op === 'PUT' || op === 'LIST' ||
+            op === 'HEAD' || op === 'DELETE';
+        var isJobRelated = name.indexOf('job') !== -1;
+
+        if (successful && validOp && !isJobRelated) {
+            obj.objectId = req.metadata.objectId;
+            obj.sharksContacted = req.sharksContacted;
+            obj.shard = req.shard;
+        }
+
         if (req._timeToLastByte !== undefined &&
             req._totalBytes !== undefined) {
             obj._auditData = true;
diff --git a/lib/common.js b/lib/common.js
index a116c53..d006e09 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -480,7 +480,15 @@ function loadMetadata(req, opts, callback) {
             } else {
                 return (callback(err, req));
             }
+        } else {
+            /*
+             * We want to save which shard the metadata was fetched from for
+             * logging purposes, but `wrap` will only contain this information
+             * if there wasn't an error, whether fatal or not.
+             */
+            req.shard = wrap._node.pnode;
         }
+
         if (md.roles) {
             md.headers = md.headers || {};
             req.mahi.getName({
diff --git a/lib/obj.js b/lib/obj.js
index 53f4a07..58662bb 100644
--- a/lib/obj.js
+++ b/lib/obj.js
@@ -596,7 +596,7 @@ function streamFromSharks(req, res, next) {
         requestId: req.getId()
     };
     var queue;
-    var saved_err = false;
+    var savedErr = false;
 
     if (req.headers.range)
         opts.range = req.headers.range;
@@ -616,7 +616,7 @@ function streamFromSharks(req, res, next) {
         return;
     }
 
-    function respond(shark, shark_req) {
+    function respond(shark, sharkReq, sharkInfo, startTime) {
         log.debug('streamFromSharks: streaming data');
         // Response headers
         var sh = shark.headers;
@@ -661,6 +661,10 @@ function streamFromSharks(req, res, next) {
             req._timeAtFirstByte = check.start;
             req._timeToLastByte = Date.now();
             req._totalBytes = check.bytes;
+
+            sharkInfo.timeToFirstByte = req._timeAtFirstByte - startTime;
+            sharkInfo.timeTotal = req._timeToLastByte - startTime;
+
             next();
         });
         shark.once('error', next);
@@ -692,7 +696,7 @@ function streamFromSharks(req, res, next) {
             check.removeAllListeners('done');
             shark.unpipe(check);
             shark.unpipe(res);
-            shark_req.abort();
+            sharkReq.abort();
             req._timeAtFirstByte = check.start;
             req._timeToLastByte = Date.now();
             req._totalBytes = check.bytes;
@@ -725,23 +729,39 @@ function streamFromSharks(req, res, next) {
         shark.pipe(res);
     }
 
+    req.sharksContacted = [];
+
     queue = libmanta.createQueue({
         limit: 1,
         worker: function start(s, cb) {
             if (connected) {
                 cb();
             } else {
-                s.get(opts, function (err, c_req, c_res) {
+                // Keep track of some information about which sharks
+                // we've contacted for logging purposes.
+                var sharkInfo = {
+                    shark: s.hostname,
+                    result: null, // 'ok' or 'fail'
+                    timeToFirstByte: null, // time until object starts streaming
+                    timeTotal: null // total request time contacting shark
+                 };
+                req.sharksContacted.push(sharkInfo);
+                var startTime = Date.now();
+
+                s.get(opts, function (err, cReq, cRes) {
                     if (err) {
+                        sharkInfo.result = 'fail';
+                        sharkInfo.timeTotal = Date.now() - startTime;
                         log.warn({
                             err: err,
                             shark: s.toString()
                         }, 'mako: connection failed');
-                        saved_err = err;
+                        savedErr = err;
                         cb();
                     } else {
+                        sharkInfo.result = 'ok';
                         connected = true;
-                        respond(c_res, c_req);
+                        respond(cRes, cReq, sharkInfo, startTime);
                         cb();
                     }
                 });
@@ -752,15 +772,15 @@ function streamFromSharks(req, res, next) {
     queue.once('end', function () {
         if (!connected) {
             // Honor Nginx handling Range GET requests
-            if (saved_err && saved_err._result) {
-                var rh = saved_err._result.headers;
+            if (savedErr && savedErr._result) {
+                var rh = savedErr._result.headers;
                 if (req.headers['range'] !== undefined && rh['content-range']) {
                     res.setHeader('content-range', rh['content-range']);
                     next(new restify.RequestedRangeNotSatisfiableError());
                     return;
                 }
             }
-            next(saved_err || new InternalError());
+            next(savedErr || new InternalError());
         }
     });
 
