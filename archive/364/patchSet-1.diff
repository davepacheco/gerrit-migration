From 4c5e0febb78a2605ad7b004aeef7e5830440486c Mon Sep 17 00:00:00 2001
From: Jordan Paige Hendricks <jordan.hendricks@joyent.com>
Date: Fri, 26 Aug 2016 22:44:43 +0000
Subject: [PATCH] MANTA 2910 muskie log entries could include shard, objectid,
 sharks

---
 lib/audit.js  | 11 ++++++++++-
 lib/common.js |  8 ++++++++
 lib/obj.js    | 23 +++++++++++++++++++++--
 3 files changed, 39 insertions(+), 3 deletions(-)

diff --git a/lib/audit.js b/lib/audit.js
index e504737..7ca9610 100644
--- a/lib/audit.js
+++ b/lib/audit.js
@@ -203,10 +203,11 @@ function auditLogger(options) {
         });
 
         var name = route ? (route.name || route) : 'unknown';
+        var op = billable(name, req);
         var obj = {
             _audit: true,
             operation: name,
-            billable_operation: billable(name, req),
+            billable_operation: op,
             bytesTransferred: req._size,
             remoteAddress: req.connection._xff,
             remotePort: req.connection.remotePort,
@@ -220,6 +221,14 @@ function auditLogger(options) {
             secure: req.secure
         };
 
+        // Log additional info if this was a successful GET/PUT of an object.
+        var successful = ((200 <= res.statusCode) && (res.statusCode < 300));
+        if (successful && (op === 'GET' || op === 'PUT')) {
+            obj.objectId = req.metadata.objectId;
+            obj.sharksContacted = req.sharksContacted;
+            obj.shard = req.shard;
+        }
+
         if (req._timeToLastByte !== undefined &&
             req._totalBytes !== undefined) {
             obj._auditData = true;
diff --git a/lib/common.js b/lib/common.js
index a116c53..e630e8c 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -480,7 +480,15 @@ function loadMetadata(req, opts, callback) {
             } else {
                 return (callback(err, req));
             }
+        } else {
+            /*
+             * We want to save which shard the metadata was fetched from for
+             * logging purposes (see MANTA-2910), but `wrap` will only contain
+             * this information if there wasn't an error, whether fatal or not.
+             */
+            req.shard = wrap._node.pnode;
         }
+
         if (md.roles) {
             md.headers = md.headers || {};
             req.mahi.getName({
diff --git a/lib/obj.js b/lib/obj.js
index 53f4a07..ceb55d6 100644
--- a/lib/obj.js
+++ b/lib/obj.js
@@ -306,6 +306,7 @@ function startSharkStreams(req, res, next) {
         sharks: req._sharks
     }, 'startSharkStreams: entered');
 
+
     var ndx = 0;
     var opts = {
         contentType: req.getContentType(),
@@ -616,7 +617,7 @@ function streamFromSharks(req, res, next) {
         return;
     }
 
-    function respond(shark, shark_req) {
+    function respond(shark, shark_req, sharkInfo) {
         log.debug('streamFromSharks: streaming data');
         // Response headers
         var sh = shark.headers;
@@ -661,6 +662,9 @@ function streamFromSharks(req, res, next) {
             req._timeAtFirstByte = check.start;
             req._timeToLastByte = Date.now();
             req._totalBytes = check.bytes;
+
+            sharkInfo.latency = req._timeToLastByte - req._timeAtFirstByte;
+
             next();
         });
         shark.once('error', next);
@@ -725,14 +729,28 @@ function streamFromSharks(req, res, next) {
         shark.pipe(res);
     }
 
+    req.sharksContacted = [];
+
     queue = libmanta.createQueue({
         limit: 1,
         worker: function start(s, cb) {
             if (connected) {
                 cb();
             } else {
+                // Keep track of some information about which sharks
+                // we've contacted for logging purposes.
+                var sharkInfo = {
+                    shark: s.hostname,
+                    result: null, // 'ok' or 'fail'
+                    latency: null // set below on error; in respond() on success
+                 };
+                req.sharksContacted.push(sharkInfo);
+                var startTime = Date.now();
+
                 s.get(opts, function (err, c_req, c_res) {
                     if (err) {
+                        sharkInfo.result = 'fail';
+                        sharkInfo.latency = Date.now() - startTime;
                         log.warn({
                             err: err,
                             shark: s.toString()
@@ -740,8 +758,9 @@ function streamFromSharks(req, res, next) {
                         saved_err = err;
                         cb();
                     } else {
+                        sharkInfo.result = 'ok';
                         connected = true;
-                        respond(c_res, c_req);
+                        respond(c_res, c_req, sharkInfo);
                         cb();
                     }
                 });
-- 
2.21.0

