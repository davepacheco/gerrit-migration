commit fd99ce86411139ca7529cdf6294d60052de1be02 (refs/changes/64/364/5)
Author: Jordan Paige Hendricks <jordan.hendricks@joyent.com>
Date:   2016-09-07T21:46:11+00:00 (3 years, 1 month ago)
    
    MANTA-2910 muskie log entries could include shard, objectid, sharks

diff --git a/lib/audit.js b/lib/audit.js
index e504737..50582d4 100644
--- a/lib/audit.js
+++ b/lib/audit.js
@@ -203,10 +203,11 @@ function auditLogger(options) {
         });
 
         var name = route ? (route.name || route) : 'unknown';
+        var op = billable(name, req);
         var obj = {
             _audit: true,
             operation: name,
-            billable_operation: billable(name, req),
+            billable_operation: op,
             bytesTransferred: req._size,
             remoteAddress: req.connection._xff,
             remotePort: req.connection.remotePort,
@@ -220,6 +221,12 @@ function auditLogger(options) {
             secure: req.secure
         };
 
+        if (req.metadata && req.metadata.objectId) {
+            obj.objectId = req.metadata.objectId;
+        }
+        obj.sharksContacted = req.sharksContacted;
+        obj.shard = req.shard;
+
         if (req._timeToLastByte !== undefined &&
             req._totalBytes !== undefined) {
             obj._auditData = true;
diff --git a/lib/common.js b/lib/common.js
index a116c53..d006e09 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -480,7 +480,15 @@ function loadMetadata(req, opts, callback) {
             } else {
                 return (callback(err, req));
             }
+        } else {
+            /*
+             * We want to save which shard the metadata was fetched from for
+             * logging purposes, but `wrap` will only contain this information
+             * if there wasn't an error, whether fatal or not.
+             */
+            req.shard = wrap._node.pnode;
         }
+
         if (md.roles) {
             md.headers = md.headers || {};
             req.mahi.getName({
diff --git a/lib/obj.js b/lib/obj.js
index 53f4a07..2b9710e 100644
--- a/lib/obj.js
+++ b/lib/obj.js
@@ -102,7 +102,7 @@ var DEF_MAX_LEN = 53687091200;
 //      requestId: req.getId()   // current request_id
 //   }
 //
-function sharkConnect(opts, cb) {
+function sharkConnect(opts, cb, sharkInfo) {
     var client = sharkClient.getClient({
         connectTimeout: opts.sharkConfig.connectTimeout,
         log: opts.log,
@@ -119,11 +119,50 @@ function sharkConnect(opts, cb) {
             opts.log.debug({
                 client_req: req
             }, 'SharkClient: put started');
+            sharkInfo.timeToFirstByte = Date.now() - sharkInfo._startTime;
             cb(null, req);
         }
     });
 }
 
+// Creates a 'sharkInfo' object, used for logging purposes,
+// and saves it on the input request object to log later.
+//
+// Input:
+//      req: the request object to save this shark on
+//      hostname: the name of the shark (e.g., '1.stor.emy-13.joyent.us')
+// Output:
+//      a sharkInfo object
+function createSharkInfo(req, hostname) {
+    var sharkInfo = {
+        shark: hostname,
+        result: null, // 'ok' or 'fail'
+        // time until streaming object to or from the shark begins
+        timeToFirstByte: null,
+        timeTotal: null, // total request time
+
+        // private: time request begins (used to calculate other time values)
+        _startTime: Date.now()
+    };
+
+    req.sharksContacted.push(sharkInfo);
+    return (sharkInfo);
+}
+
+// Given a request object and shark name, returns the matching sharkInfo object.
+// This is only meant to be used if we are certain the shark is in this request,
+// and will cause an assertion failure otherwise.
+function getSharkInfo(req, hostname) {
+    var sharks = req.sharksContacted.filter(function (sharkInfo) {
+        return (sharkInfo.shark === hostname);
+    });
+
+    assert.equal(sharks.length, 1, 'There should only be one sharkInfo ' +
+        'with hostname "' + hostname + '"');
+
+    return (sharks[0]);
+}
+
 
 
 ///-- Routes
@@ -293,6 +332,8 @@ function enforceDirectoryCount(req, res, next) {
 }
 
 
+
+
 function startSharkStreams(req, res, next) {
     if (req._zero || req.query.metadata) {
         next();
@@ -317,13 +358,17 @@ function startSharkStreams(req, res, next) {
         sharkConfig: req.sharkConfig
     };
 
+    req.sharksContacted = [];
+
     (function attempt(inputs) {
         vasync.forEachParallel({
             func: function shark_connect(shark, cb) {
                 var _opts = clone(opts);
                 _opts.log = req.log;
                 _opts.shark = shark;
-                sharkConnect(_opts, cb);
+
+                var sharkInfo = createSharkInfo(req, shark.manta_storage_id);
+                sharkConnect(_opts, cb, sharkInfo);
             },
             inputs: inputs
         }, function (err, results) {
@@ -440,6 +485,10 @@ function sharkStreams(req, res, next) {
                 client_res: sres
             }, 'mako: response received');
 
+            var sharkInfo = getSharkInfo(req, s._shark.manta_storage_id);
+            sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+            sharkInfo.result = 'fail'; // most cases below here are failures
+
             s.md5 = sres.headers['x-joyent-computed-content-md5'] ||
                 req._contentMD5;
             if (sres.statusCode === 469) {
@@ -464,6 +513,7 @@ function sharkStreams(req, res, next) {
                     next_err(new InternalError(err));
                 });
             } else {
+                sharkInfo.result = 'ok';
                 barrier.done(s._shark.manta_storage_id);
             }
         });
@@ -596,7 +646,7 @@ function streamFromSharks(req, res, next) {
         requestId: req.getId()
     };
     var queue;
-    var saved_err = false;
+    var savedErr = false;
 
     if (req.headers.range)
         opts.range = req.headers.range;
@@ -616,7 +666,9 @@ function streamFromSharks(req, res, next) {
         return;
     }
 
-    function respond(shark, shark_req) {
+    req.sharksContacted = [];
+
+    function respond(shark, sharkReq, sharkInfo) {
         log.debug('streamFromSharks: streaming data');
         // Response headers
         var sh = shark.headers;
@@ -661,6 +713,11 @@ function streamFromSharks(req, res, next) {
             req._timeAtFirstByte = check.start;
             req._timeToLastByte = Date.now();
             req._totalBytes = check.bytes;
+
+            sharkInfo.timeToFirstByte = req._timeAtFirstByte
+                - sharkInfo._startTime;
+            sharkInfo.timeTotal = req._timeToLastByte - sharkInfo._startTime;
+
             next();
         });
         shark.once('error', next);
@@ -692,7 +749,7 @@ function streamFromSharks(req, res, next) {
             check.removeAllListeners('done');
             shark.unpipe(check);
             shark.unpipe(res);
-            shark_req.abort();
+            sharkReq.abort();
             req._timeAtFirstByte = check.start;
             req._timeToLastByte = Date.now();
             req._totalBytes = check.bytes;
@@ -725,23 +782,29 @@ function streamFromSharks(req, res, next) {
         shark.pipe(res);
     }
 
+
     queue = libmanta.createQueue({
         limit: 1,
         worker: function start(s, cb) {
             if (connected) {
                 cb();
             } else {
-                s.get(opts, function (err, c_req, c_res) {
+                var sharkInfo = createSharkInfo(req, s.hostname);
+
+                s.get(opts, function (err, cReq, cRes) {
                     if (err) {
+                        sharkInfo.result = 'fail';
+                        sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
                         log.warn({
                             err: err,
                             shark: s.toString()
                         }, 'mako: connection failed');
-                        saved_err = err;
+                        savedErr = err;
                         cb();
                     } else {
+                        sharkInfo.result = 'ok';
                         connected = true;
-                        respond(c_res, c_req);
+                        respond(cRes, cReq, sharkInfo);
                         cb();
                     }
                 });
@@ -752,15 +815,15 @@ function streamFromSharks(req, res, next) {
     queue.once('end', function () {
         if (!connected) {
             // Honor Nginx handling Range GET requests
-            if (saved_err && saved_err._result) {
-                var rh = saved_err._result.headers;
+            if (savedErr && savedErr._result) {
+                var rh = savedErr._result.headers;
                 if (req.headers['range'] !== undefined && rh['content-range']) {
                     res.setHeader('content-range', rh['content-range']);
                     next(new restify.RequestedRangeNotSatisfiableError());
                     return;
                 }
             }
-            next(saved_err || new InternalError());
+            next(savedErr || new InternalError());
         }
     });
 
diff --git a/lib/server.js b/lib/server.js
index 909b91a..1bf8b7e 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -367,9 +367,7 @@ function createServer(options, clearProxy) {
         server.opts({
             path: _p,
             name: 'Options' + _n + 'Storage'
-        },  // common.ensureEntryExistsHandler(),
-            // common.assertMetadataHandler(),
-            other.corsHandler());
+        }, other.corsHandler());
 
         server.get({
             path: _p,
