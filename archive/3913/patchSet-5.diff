commit 21e2c666e809045ac5b02a65fa8b9c6708909804 (refs/changes/13/3913/5)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-05-29T19:10:25+00:00 (1 year, 4 months ago)
    
    OS-6930 bhyve PIR can still miss PIR wake-ups
    Reviewed by: John Levon <john.levon@joyent.com>
    Reviewed by: Bryan Cantrill <bryan@joyent.com>
    Approved by: Robert Mustacchi <rm@joyent.com>

diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index 94c588a5c3..eb33236013 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -310,6 +310,7 @@ static int vmx_getdesc(void *arg, int vcpu, int reg, struct seg_desc *desc);
 static int vmx_getreg(void *arg, int vcpu, int reg, uint64_t *retval);
 static int vmxctx_setreg(struct vmxctx *vmxctx, int reg, uint64_t val);
 static void vmx_inject_pir(struct vlapic *vlapic);
+static void vmx_flush_pir_prio(struct vlapic *vlapic);
 
 #ifdef KTR
 static const char *
@@ -3106,6 +3107,10 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 	if (!handled)
 		vmm_stat_incr(vm, vcpu, VMEXIT_USERSPACE, 1);
 
+	if (virtual_interrupt_delivery) {
+		vmx_flush_pir_prio(vlapic);
+	}
+
 	VCPU_CTR1(vm, vcpu, "returning from vmx_run: exitcode %d",
 	    vmexit->exitcode);
 
@@ -3590,16 +3595,19 @@ vmx_set_intr_ready(struct vlapic *vlapic, int vector, bool level)
 	 *
 	 * Those priority bits will be left unchanged, becoming effectively
 	 * stale, when the CPU delivers the posted interrupts to the guest and
-	 * clears the 'pending' bit.  This is acceptable since they are only
-	 * used to elide interrupt-is-ready wake-ups when the 'pending' bit is
-	 * not making a 0->1 transition _and_ the vCPU priority is elevated.
+	 * clears the 'pending' bit.  The presence of those stale bits is
+	 * harmless when the CPU is in guest context, since 0->1 transitions of
+	 * the 'pending' bit ensure reliable notifications.  They are cleared
+	 * by vmx_flush_pir_prio() prior to leaving vmx_run(), since accurate
+	 * priority information is necessary to prevent eliding necessary
+	 * wake-ups.
 	 *
 	 * When vmx_inject_pir() is called to inject any interrupts which were
-	 * posted while the CPU was outside VMX context, it will clear the
+	 * posted while the CPU was outside VMX context, it will also clear the
 	 * priority bitfield as part of querying the 'pending' field.
 	 */
-	old = atomic_load_acq_long(&pir_desc->pending);
-	if (atomic_cmpset_long(&pir_desc->pending, old, old|prio_mask) != 0) {
+	old = pir_desc->pending;
+	if (atomic_cmpset_long(&pir_desc->pending, old, old | prio_mask) != 0) {
 		/*
 		 * If there was no race in updating the pending field
 		 * (including the priority bitfield), then a notification is
@@ -3645,7 +3653,7 @@ vmx_pending_intr(struct vlapic *vlapic, int *vecptr)
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
 
-	pending = atomic_load_acq_long(&pir_desc->pending);
+	pending = pir_desc->pending;
 	if ((pending & PIR_MASK_PENDING) == 0) {
 		/*
 		 * While a virtual interrupt may have already been
@@ -3797,7 +3805,7 @@ vmx_inject_pir(struct vlapic *vlapic)
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
 
-	pending = atomic_swap_long(&pir_desc->pending, 0);
+	pending = atomic_readandclear_long(&pir_desc->pending);
 	if ((pending & PIR_MASK_PENDING) == 0) {
 		VCPU_CTR0(vlapic->vm, vlapic->vcpuid, "vmx_inject_pir: "
 		    "no posted interrupt pending");
@@ -3876,6 +3884,26 @@ vmx_inject_pir(struct vlapic *vlapic)
 	}
 }
 
+static void
+vmx_flush_pir_prio(struct vlapic *vlapic)
+{
+	struct vlapic_vtx *vlapic_vtx;
+	struct pir_desc *pir_desc;
+
+	vlapic_vtx = (struct vlapic_vtx *)vlapic;
+	pir_desc = vlapic_vtx->pir_desc;
+
+	/*
+	 * Clear all the reserved bits caching interrupt priority, leaving the
+	 * 'pending' bit, from the PIR descriptor.  Stale priority bits
+	 * representing interrupts which were posted to the guest while in the
+	 * VMX context must be cleared to ensure that priority-conditional
+	 * interrupt notification occurs properly until another VMX entry is
+	 * made.
+	 */
+	atomic_clear_long(&pir_desc->pending, ~PIR_MASK_PENDING);
+}
+
 static struct vlapic *
 vmx_vlapic_init(void *arg, int vcpuid)
 {
