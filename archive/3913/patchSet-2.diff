commit ee3f18655254b3fb9f4e5ef26656ac002932095d (refs/changes/13/3913/2)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-05-17T15:31:55+00:00 (1 year, 5 months ago)
    
    OS-6930 bhyve PIR can still miss PIR wake-ups

diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index af63e0a426..51d9e35203 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -234,6 +234,7 @@ static int vmx_getdesc(void *arg, int vcpu, int reg, struct seg_desc *desc);
 static int vmx_getreg(void *arg, int vcpu, int reg, uint64_t *retval);
 static int vmxctx_setreg(struct vmxctx *vmxctx, int reg, uint64_t val);
 static void vmx_inject_pir(struct vlapic *vlapic);
+static void vmx_flush_pir_prio(struct vlapic *vlapic);
 
 #ifdef KTR
 static const char *
@@ -2991,6 +2992,10 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 	if (!handled)
 		vmm_stat_incr(vm, vcpu, VMEXIT_USERSPACE, 1);
 
+	if (virtual_interrupt_delivery) {
+		vmx_flush_pir_prio(vlapic);
+	}
+
 	VCPU_CTR1(vm, vcpu, "returning from vmx_run: exitcode %d",
 	    vmexit->exitcode);
 
@@ -3475,16 +3480,19 @@ vmx_set_intr_ready(struct vlapic *vlapic, int vector, bool level)
 	 *
 	 * Those priority bits will be left unchanged, becoming effectively
 	 * stale, when the CPU delivers the posted interrupts to the guest and
-	 * clears the 'pending' bit.  This is acceptable since they are only
-	 * used to elide interrupt-is-ready wake-ups when the 'pending' bit is
-	 * not making a 0->1 transition _and_ the vCPU priority is elevated.
+	 * clears the 'pending' bit.  The presence of those stale bits is
+	 * harmless when the CPU is in guest context, since 0->1 transitions of
+	 * the 'pending' bit ensure reliable notifications.  They are cleared
+	 * by vmx_flush_pir_prio() prior to leaving vmx_run(), since accurate
+	 * priority information is necessary to prevent eliding necessary
+	 * wake-ups.
 	 *
 	 * When vmx_inject_pir() is called to inject any interrupts which were
-	 * posted while the CPU was outside VMX context, it will clear the
+	 * posted while the CPU was outside VMX context, it will also clear the
 	 * priority bitfield as part of querying the 'pending' field.
 	 */
-	old = atomic_load_acq_long(&pir_desc->pending);
-	if (atomic_cmpset_long(&pir_desc->pending, old, old|prio_mask) != 0) {
+	old = pir_desc->pending;
+	if (atomic_cmpset_long(&pir_desc->pending, old, old | prio_mask) != 0) {
 		/*
 		 * If there was no race in updating the pending field
 		 * (including the priority bitfield), then a notification is
@@ -3530,7 +3538,7 @@ vmx_pending_intr(struct vlapic *vlapic, int *vecptr)
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
 
-	pending = atomic_load_acq_long(&pir_desc->pending);
+	pending = pir_desc->pending;
 	if ((pending & PIR_MASK_PENDING) == 0) {
 		/*
 		 * While a virtual interrupt may have already been
@@ -3682,7 +3690,7 @@ vmx_inject_pir(struct vlapic *vlapic)
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
 
-	pending = atomic_swap_long(&pir_desc->pending, 0);
+	pending = atomic_readandclear_long(&pir_desc->pending);
 	if ((pending & PIR_MASK_PENDING) == 0) {
 		VCPU_CTR0(vlapic->vm, vlapic->vcpuid, "vmx_inject_pir: "
 		    "no posted interrupt pending");
@@ -3761,6 +3769,26 @@ vmx_inject_pir(struct vlapic *vlapic)
 	}
 }
 
+static void
+vmx_flush_pir_prio(struct vlapic *vlapic)
+{
+	struct vlapic_vtx *vlapic_vtx;
+	struct pir_desc *pir_desc;
+
+	vlapic_vtx = (struct vlapic_vtx *)vlapic;
+	pir_desc = vlapic_vtx->pir_desc;
+
+	/*
+	 * Clear all the reserved bits caching interrupt priority, leaving the
+	 * 'pending' bit, from the PIR descriptor.  Stale priority bits
+	 * representing interrupts which were posted to the guest while in the
+	 * VMX context must be cleared to ensure that priority-conditional
+	 * interrupt notification occurs properly until another VMX entry is
+	 * made.
+	 */
+	atomic_clear_long(&pir_desc->pending, ~PIR_MASK_PENDING);
+}
+
 static struct vlapic *
 vmx_vlapic_init(void *arg, int vcpuid)
 {
