From bc410252a07ffe1de3ca4434056c66520d90d70a Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Thu, 26 Oct 2017 17:14:27 -0400
Subject: [PATCH] AGENT-979 vm-agent needs vminfod watcher Reviewed by: Josh
 Wilsdon <josh@wilsdon.ca>

---
 lib/event-source.js                  |  51 ++++++
 lib/vm-agent.js                      |  86 ++++++----
 lib/vm-watcher.js                    | 108 +++++++++----
 lib/watchers/vmadm-events-watcher.js |  92 +++++++++++
 package.json                         |   2 +-
 tests/common.js                      |  38 ++++-
 tests/mocks.js                       |  12 +-
 tests/test.FsWatcher.js              |  35 +---
 tests/test.PeriodicWatcher.js        |  65 ++------
 tests/test.VmAgentRealVmadm.js       | 233 ++++++++++++++-------------
 tests/test.VmWatcher.js              |  82 +++++-----
 tests/test.VmadmEventsWatcher.js     | 174 ++++++++++++++++++++
 tests/test.ZoneeventWatcher.js       |  33 +---
 13 files changed, 674 insertions(+), 337 deletions(-)
 create mode 100644 lib/event-source.js
 create mode 100644 lib/watchers/vmadm-events-watcher.js
 create mode 100644 tests/test.VmadmEventsWatcher.js

diff --git a/lib/event-source.js b/lib/event-source.js
new file mode 100644
index 0000000..87ca331
--- /dev/null
+++ b/lib/event-source.js
@@ -0,0 +1,51 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var vmadm = require('vmadm');
+
+function determineEventSource(opts, cb) {
+    var vmadmEventsOpts;
+
+    assert.object(opts, 'opts');
+    assert(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    // Figure out the best event source for the system.  Basically, this checks
+    // to see if vminfod is supported by looking for `vmadm events` support.
+    vmadmEventsOpts = {
+        log: opts.log,
+        name: 'VM Agent determineEventSource'
+    };
+
+    vmadm.events(vmadmEventsOpts,
+        function vmadmEventsHandler() {
+            /*
+             * We don't care about any events seen here - we are only
+             * starting this event stream to see if it is supported on the
+             * current platform to best determine the event source to use for
+             * all events.
+             */
+        }, function vmadmEventsReady(err, obj) {
+            if (err) {
+                // vmadm events is not supported, use default eventSource.
+                cb(null, 'default');
+                return;
+            }
+
+            // vmadm events is supported! stop this stream and use the
+            // `vmadm-events` eventSource.
+            obj.stop();
+            cb(null, 'vmadm-events');
+        }
+    );
+}
+
+module.exports = determineEventSource;
diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index 5dc56f6..c093e15 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -123,6 +123,7 @@ var diff = require('deep-diff').diff;
 var vasync = require('vasync');
 var vmadm = require('vmadm');
 
+var determineEventSource = require('./event-source');
 var VmWatcher = require('./vm-watcher');
 var VMAPI = require('./vmapi-client');
 
@@ -528,15 +529,10 @@ VmAgent.prototype.queueVm = function queueVm(vmUuid) {
     }
 };
 
-VmAgent.prototype.setupWatcher = function setupWatcher() {
+VmAgent.prototype.setupWatcher = function setupWatcher(callback) {
     var self = this;
 
-    // Setup the watcher that will notice VM changes and add to the
-    // update-to-VMAPI queue.
-    self.watcher = new VmWatcher({
-        log: self.log,
-        periodicInterval: self.periodicInterval // may be undefined
-    });
+    assert.func(callback, 'callback');
 
     function _onVmEvent(vmUuid, name, watcher) {
         assert.uuid(vmUuid, 'vmUuid');
@@ -559,23 +555,44 @@ VmAgent.prototype.setupWatcher = function setupWatcher() {
         self.queueVm(vmUuid);
     }
 
-    self.watcher.on('VmCreated', function _onCreate(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'create', watcher);
-    });
+    determineEventSource({log: self.log},
+        function determinedEventSource(err, eventSource) {
+            if (err) {
+                callback(err);
+                return;
+            }
 
-    self.watcher.on('VmModified', function _onModify(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'modify', watcher);
-    });
+            // Setup the watcher that will notice VM changes and add to the
+            // update-to-VMAPI queue.
+            self.log.info('determined best eventSource: %s', eventSource);
 
-    self.watcher.on('VmDeleted', function _onDelete(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'delete', watcher);
-    });
+            self.watcher = new VmWatcher({
+                log: self.log,
+                eventSource: eventSource,
+                periodicInterval: self.periodicInterval // may be undefined
+            });
+
+            self.watcher.on('VmCreated', function _onCreate(vmUuid, watcher) {
+                assert.uuid(vmUuid, 'vmUuid');
+                assert.string(watcher, 'watcher');
+                _onVmEvent(vmUuid, 'create', watcher);
+            });
+
+            self.watcher.on('VmModified', function _onModify(vmUuid, watcher) {
+                assert.uuid(vmUuid, 'vmUuid');
+                assert.string(watcher, 'watcher');
+                _onVmEvent(vmUuid, 'modify', watcher);
+            });
+
+            self.watcher.on('VmDeleted', function _onDelete(vmUuid, watcher) {
+                assert.uuid(vmUuid, 'vmUuid');
+                assert.string(watcher, 'watcher');
+                _onVmEvent(vmUuid, 'delete', watcher);
+            });
+
+            callback();
+        }
+    );
 
     // NOTE: watcher gets started as part of initialUpdate
 };
@@ -670,13 +687,8 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
              * lookup we're about to do. If something fails in the
              * initialization here and we're going to do a new loop, we stop
              * the watcher and clear the existing queue.
-             *
-             * NOTE: This always succeeds because it just calls .start() on the
-             * appropriate watchers. The watchers themselves will retry if
-             * something goes wrong with their startup.
              */
-            self.watcher.start();
-            cb();
+            self.watcher.start(cb);
         }, function _getVmadmVms(stash, cb) {
             var ALL_VMS = {}; // no filter means: grab them all
             var opts = {log: self.log, include_dni: true};
@@ -825,16 +837,20 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
     });
 };
 
-VmAgent.prototype.start = function start() {
+VmAgent.prototype.start = function start(callback) {
     var self = this;
 
+    assert.optionalFunc(callback, 'callback');
+
     vasync.pipeline({arg: {}, funcs: [
         function _setupWatcher(stash, cb) {
-            if (!self.watcher) {
-                // initialize the watcher if we've not already done so
-                self.setupWatcher();
+            // initialize the watcher if we've not already done so
+            if (self.watcher) {
+                cb();
+                return;
             }
-            cb();
+
+            self.setupWatcher(cb);
         }, function _initialUpdate(stash, cb) {
             var startUpdate = (new Date()).getTime();
 
@@ -880,6 +896,10 @@ VmAgent.prototype.start = function start() {
         });
 
         self.log.info('startup complete');
+        if (callback) {
+            callback();
+            return;
+        }
     });
 };
 
diff --git a/lib/vm-watcher.js b/lib/vm-watcher.js
index a3403f6..07310dc 100644
--- a/lib/vm-watcher.js
+++ b/lib/vm-watcher.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -69,10 +69,6 @@
  *    our object at the same time that action completes since cn-agent will
  *    gather the VM object and the workflow will do a PUT.
  *
- *  - When vminfod is available, we should be able to use that watcher
- *    exclusively on those platforms, as vminfod already watches for all
- *    property changes.
- *
  */
 
 var EventEmitter = require('events').EventEmitter;
@@ -84,14 +80,13 @@ var diff = require('deep-diff').diff;
 var FsWatcher = require('../lib/watchers/fs-watcher');
 var PeriodicWatcher = require('../lib/watchers/periodic-watcher');
 var ZoneeventWatcher = require('../lib/watchers/zoneevent-watcher');
-
+var VmadmEventsWatcher = require('../lib/watchers/vmadm-events-watcher');
 
 /*
  * Globals
  */
 var MS_PER_SEC = 1000;
 
-
 /*
  * The VmWatcher will emit these events:
  *
@@ -109,6 +104,7 @@ function VmWatcher(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
     assert.optionalNumber(opts.periodicInterval, 'opts.periodicInterval');
+    assert.optionalString(opts.eventSource, 'opts.eventSource');
 
     // Initialize necessary properties from `EventEmitter` in this instance
     EventEmitter.call(this);
@@ -116,6 +112,9 @@ function VmWatcher(opts) {
     // Yay bunyan!
     self.log = opts.log;
 
+    // Event Source
+    self.eventSource = opts.eventSource;
+
     // This is used to try to avoid emitting the same event twice when just
     // noticed by different watchers. How it works is that when we see an update
     // via the updateVm() function, the watcher passes us a list of properties
@@ -124,24 +123,37 @@ function VmWatcher(opts) {
     // the same change.
     self.knownVms = {};
 
-    self.fsWatcher = new FsWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('fs')
-    });
-
-    self.zoneeventWatcher = new ZoneeventWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('zoneevent')
-    });
-
-    // FUTURE: If someone only wants last_modified, we can avoid starting up the
-    // periodic watcher?
-
-    self.periodicWatcher = new PeriodicWatcher({
-        log: opts.log,
-        periodicInterval: opts.periodicInterval, // might be undefined
-        updateVm: self.newUpdateHandler('periodic')
-    });
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher = new VmadmEventsWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('vmadm')
+            });
+            break;
+        case 'default':
+            self.fsWatcher = new FsWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('fs')
+            });
+
+            self.zoneeventWatcher = new ZoneeventWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('zoneevent')
+            });
+
+            // FUTURE: If someone only wants last_modified, we can avoid
+            // starting up the periodic watcher?
+
+            self.periodicWatcher = new PeriodicWatcher({
+                log: opts.log,
+                periodicInterval: opts.periodicInterval, // might be undefined
+                updateVm: self.newUpdateHandler('periodic')
+            });
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 }
 util.inherits(VmWatcher, EventEmitter);
 
@@ -354,27 +366,55 @@ VmWatcher.prototype.newUpdateHandler = function newUpdateHandler(watcher) {
     });
 };
 
-VmWatcher.prototype.start = function start() {
+VmWatcher.prototype.start = function start(cb) {
     var self = this;
 
-    self.fsWatcher.start();
-    self.periodicWatcher.start();
-    self.zoneeventWatcher.start();
-    // ... other watchers
+    assert.optionalFunc(cb, 'cb');
+
+    self.log.debug({eventSource: self.eventSource}, 'Starting VmWatcher');
+
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher.start(cb);
+            break;
+        case 'default':
+            self.fsWatcher.start();
+            self.periodicWatcher.start();
+            self.zoneeventWatcher.start();
+            if (cb) {
+                cb();
+                return;
+            }
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 };
 
 VmWatcher.prototype.stop = function stop(opts) {
     var self = this;
     var keepListeners = false;
 
+    self.log.debug({eventSource: self.eventSource}, 'Stopping VmWatcher');
+
     if (opts && opts.keepListeners) {
         keepListeners = true;
     }
 
-    self.fsWatcher.stop();
-    self.periodicWatcher.stop();
-    self.zoneeventWatcher.stop();
-    // ... other watchers
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher.stop();
+            break;
+        case 'default':
+            self.fsWatcher.stop();
+            self.periodicWatcher.stop();
+            self.zoneeventWatcher.stop();
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 
     if (!keepListeners) {
         self.removeAllListeners();
diff --git a/lib/watchers/vmadm-events-watcher.js b/lib/watchers/vmadm-events-watcher.js
new file mode 100644
index 0000000..63d3456
--- /dev/null
+++ b/lib/watchers/vmadm-events-watcher.js
@@ -0,0 +1,92 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var vmadm = require('vmadm');
+
+function noop() {}
+
+function VmadmEventsWatcher(opts) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.func(opts.updateVm, 'opts.updateVm');
+
+    self.log = opts.log.child({watcher: 'vmadm-events-watcher'});
+    self.updateVm = opts.updateVm;
+}
+
+VmadmEventsWatcher.prototype.start = function start(_cb) {
+    var self = this;
+
+    var opts;
+    var cb = _cb || noop;
+
+    assert.func(cb, 'cb');
+    assert(!self.stopWatcher, 'watcher already created');
+
+    opts = {
+        log: self.log,
+        name: 'VM Agent'
+    };
+
+    function handler(ev) {
+        assert.object(ev, 'ev');
+        assert.string(ev.type, 'ev.type');
+        assert.uuid(ev.zonename, 'ev.zonename');
+
+        switch (ev.type) {
+            case 'create':
+                assert.object(ev.vm, 'ev.vm');
+                self.updateVm(ev.zonename, 'create', ev.vm);
+                break;
+            case 'modify':
+                assert.object(ev.vm, 'ev.vm');
+                self.updateVm(ev.zonename, 'modify', ev.vm);
+                break;
+            case 'delete':
+                self.updateVm(ev.zonename, 'delete', {});
+                break;
+            default:
+                assert(false, 'unknown vmadm event type: ' + ev.type);
+                break;
+        }
+    }
+
+    function ready(err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        assert.object(obj, 'obj');
+        assert.func(obj.stop, 'obj.stop');
+        assert.object(obj.ev, 'obj.ev');
+
+        self.stopWatcher = obj.stop;
+        cb(null, obj.ev);
+    }
+
+    vmadm.events(opts, handler, ready);
+};
+
+VmadmEventsWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    if (self.stopWatcher) {
+        self.stopWatcher();
+        delete self.stopWatcher;
+    }
+};
+
+VmadmEventsWatcher.FIELDS = [];
+
+module.exports = VmadmEventsWatcher;
diff --git a/package.json b/package.json
index 9cd529f..a0f3171 100644
--- a/package.json
+++ b/package.json
@@ -17,7 +17,7 @@
         "restify-clients": "1.1.1",
         "tape": "4.2.2",
         "vasync": "1.6.3",
-        "vmadm": "git+https://github.com/joyent/node-vmadm.git#3cf878481d24c1bc1e74e85a95004a3dde6329f1"
+        "vmadm": "1.0.0"
     },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
diff --git a/tests/common.js b/tests/common.js
index faa7e41..72b4020 100644
--- a/tests/common.js
+++ b/tests/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -14,9 +14,14 @@
 
 var execFile = require('child_process').execFile;
 
+var assert = require('assert-plus');
+
 // GLOBAL
 var BUFFER_SIZE = 32 * 1024 * 1024; // eslint-disable-line
 
+// How frequently to poll the 'events' array when we're waiting for an event
+// in waitEvent.
+var EVENTS_POLL_FREQ = 100; // ms
 
 function testFindSmartosImage(t, callback) {
     var args = ['list', '-H', '-j', '-o', 'uuid,tags', 'os=smartos'];
@@ -57,6 +62,35 @@ function testFindSmartosImage(t, callback) {
     });
 }
 
+function waitEvent(t, evtWant, vmUuid, events, eventIdx) {
+    var loops = 0;
+
+    assert(t, 't');
+    assert.string(evtWant, 'evtWant');
+    assert.uuid(vmUuid, 'vmUuid');
+    assert.arrayOfObject(events, 'events');
+    assert.number(eventIdx, 'eventIdx');
+
+    function _waitEvent() {
+        var found = events.slice(eventIdx).some(function _findEvent(ev) {
+            return (ev.vmUuid === vmUuid && ev.event === evtWant);
+        });
+
+        if (found) {
+            t.ok(true, 'Watcher saw expected ' + evtWant
+                + ' (' + (loops * EVENTS_POLL_FREQ) + ' ms)');
+            t.end();
+            return;
+        }
+
+        loops++;
+        setTimeout(_waitEvent, EVENTS_POLL_FREQ);
+    }
+
+    _waitEvent();
+}
+
 module.exports = {
-    testFindSmartosImage: testFindSmartosImage
+    testFindSmartosImage: testFindSmartosImage,
+    waitEvent: waitEvent
 };
diff --git a/tests/mocks.js b/tests/mocks.js
index 7db4304..2c7567c 100644
--- a/tests/mocks.js
+++ b/tests/mocks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var util = require('util');
@@ -215,6 +215,10 @@ fakeVmadm.getError = function getError() {
     return (vmadmErr);
 };
 
+fakeVmadm.events = function vmadmEvents(opts, handler, cb) {
+    cb(new Error('Not Implemented'));
+};
+
 
 /*
  * Fake VMAPI for testing
@@ -344,8 +348,12 @@ function fakeVmWatcher() {
 }
 util.inherits(fakeVmWatcher, EventEmitter);
 
-fakeVmWatcher.prototype.start = function start() {
+fakeVmWatcher.prototype.start = function start(cb) {
     // console.error('vmwatcher.start');
+    if (cb) {
+        cb();
+        return;
+    }
 };
 
 fakeVmWatcher.prototype.stop = function stop() {
diff --git a/tests/test.FsWatcher.js b/tests/test.FsWatcher.js
index 41aeb5b..8897415 100644
--- a/tests/test.FsWatcher.js
+++ b/tests/test.FsWatcher.js
@@ -18,10 +18,6 @@ var common = require('./common');
 var mocks = require('./mocks');
 var FsWatcher = require('../lib/watchers/fs-watcher');
 
-
-// How frequently to poll the 'events' array when we're waiting for an event.
-var EVENTS_POLL_FREQ = 100; // ms
-
 var events = [];
 var existingVms = [];
 var smartosImageUUID;
@@ -29,31 +25,6 @@ var smartosVmUUID;
 var watcher;
 
 
-function waitEvent(t, evt, vmUuid, eventIdx) {
-    var loops = 0;
-
-    function _waitEvent() {
-        var i;
-
-        if (events.length > eventIdx) {
-            // we've had some new events, check for our create
-            for (i = eventIdx; i < events.length; i++) {
-                if (events[i].vmUuid === vmUuid && events[i].event === evt) {
-                    t.ok(true, 'FsWatcher saw expected ' + evt
-                        + ' (' + (loops * EVENTS_POLL_FREQ) + ' ms)');
-                    t.end();
-                    return;
-                }
-            }
-        }
-
-        loops++;
-        setTimeout(_waitEvent, EVENTS_POLL_FREQ);
-    }
-
-    _waitEvent();
-}
-
 test('find SmartOS image', function _test(t) {
     common.testFindSmartosImage(t, function _findSmartosCb(err, latest) {
         t.ifError(err, 'find SmartOS Image');
@@ -126,7 +97,7 @@ test('create VM', function _test(t) {
         if (!err && info) {
             t.ok(info.uuid, 'VM has uuid: ' + info.uuid);
             smartosVmUUID = info.uuid;
-            waitEvent(t, 'create', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'create', smartosVmUUID, events, eventIdx);
         } else {
             t.end();
         }
@@ -143,7 +114,7 @@ test('put metadata using mdata-put', function _test(t) {
             if (err) {
                 t.end();
             } else {
-                waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+                common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
             }
         }
     );
@@ -161,7 +132,7 @@ test('delete VM', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'delete', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'delete', smartosVmUUID, events, eventIdx);
         }
     });
 });
diff --git a/tests/test.PeriodicWatcher.js b/tests/test.PeriodicWatcher.js
index aa158d2..e336465 100644
--- a/tests/test.PeriodicWatcher.js
+++ b/tests/test.PeriodicWatcher.js
@@ -19,8 +19,6 @@ var mocks = require('./mocks');
 var PeriodicWatcher = require('../lib/watchers/periodic-watcher');
 
 
-// How frequently to poll the 'events' array when we're waiting for an event.
-var EVENTS_POLL_FREQ = 100; // ms
 var PERIODIC_INTERVAL = 1000; // ms, faster than usual because tests
 
 var events = [];
@@ -31,37 +29,6 @@ var smartosVmUUID;
 var watcher;
 
 
-// Waits for event 'evt' to happen for vmUuid starting at eventIdx
-function waitEvent(t, evt, vmUuid, eventIdx) {
-    var loops = 0;
-
-    assert.string(evt, 'evt');
-    assert.uuid(vmUuid, 'vmUuid');
-    assert.number(eventIdx, 'eventIdx');
-
-    function _waitEvent() {
-        var i;
-
-        if (events.length > eventIdx) {
-            // we've had some new events, check for our create
-            for (i = eventIdx; i < events.length; i++) {
-                if (events[i].vmUuid === vmUuid && events[i].event === evt) {
-                    t.ok(true, 'PeriodicWatcher saw expected ' + evt
-                        + ' (' + (loops * EVENTS_POLL_FREQ) + ' ms)');
-                    t.end();
-                    return;
-                }
-            }
-        }
-
-        loops++;
-        setTimeout(_waitEvent, EVENTS_POLL_FREQ);
-    }
-
-    _waitEvent();
-}
-
-
 test('find SmartOS image', function _test(t) {
     common.testFindSmartosImage(t, function _findSmartosCb(err, latest) {
         t.ifError(err, 'find SmartOS Image');
@@ -131,7 +98,7 @@ test('create VM', function _test(t) {
         if (!err && info) {
             t.ok(info.uuid, 'VM has uuid: ' + info.uuid);
             smartosVmUUID = info.uuid;
-            waitEvent(t, 'create', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'create', smartosVmUUID, events, eventIdx);
         } else {
             t.end();
         }
@@ -151,7 +118,7 @@ test('stop VM', function _test(t) {
             t.end();
         } else {
             // state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -169,7 +136,7 @@ test('start VM', function _test(t) {
             t.end();
         } else {
             // state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -183,7 +150,7 @@ test('modify quota using ZFS', function _test(t) {
             if (err) {
                 t.end();
             } else {
-                waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+                common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
             }
         }
     );
@@ -199,7 +166,7 @@ test('put metadata using mdata-put', function _test(t) {
             if (err) {
                 t.end();
             } else {
-                waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+                common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
             }
         }
     );
@@ -218,7 +185,7 @@ test('create snapshot', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -236,7 +203,7 @@ test('delete snapshot', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -258,7 +225,7 @@ test('set do_not_inventory', function _test(t) {
             // that's all we're testing here, we should see a modify. It's
             // VmAgent that should realize when it goes to update based on this
             // event that it should be ignored.
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -277,7 +244,7 @@ test('unset do_not_inventory', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -294,7 +261,7 @@ test('reboot VM', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -311,7 +278,7 @@ test('delete VM', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'delete', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'delete', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -335,7 +302,7 @@ test('create KVM VM', function _test(t) {
         if (!err && info) {
             t.ok(info.uuid, 'VM has uuid: ' + info.uuid);
             kvmVmUUID = info.uuid;
-            waitEvent(t, 'create', kvmVmUUID, eventIdx);
+            common.waitEvent(t, 'create', kvmVmUUID, events, eventIdx);
         } else {
             t.end();
         }
@@ -355,7 +322,7 @@ test('add KVM VM disk', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', kvmVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', kvmVmUUID, events, eventIdx);
         }
     });
 });
@@ -376,7 +343,7 @@ test('modify KVM VM disk', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', kvmVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', kvmVmUUID, events, eventIdx);
         }
     });
 });
@@ -396,7 +363,7 @@ test('remove KVM VM disk', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'modify', kvmVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', kvmVmUUID, events, eventIdx);
         }
     });
 });
@@ -413,7 +380,7 @@ test('delete KVM VM', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'delete', kvmVmUUID, eventIdx);
+            common.waitEvent(t, 'delete', kvmVmUUID, events, eventIdx);
         }
     });
 });
diff --git a/tests/test.VmAgentRealVmadm.js b/tests/test.VmAgentRealVmadm.js
index 253410a..438f5db 100644
--- a/tests/test.VmAgentRealVmadm.js
+++ b/tests/test.VmAgentRealVmadm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var execFile = require('child_process').execFile;
@@ -678,11 +678,6 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -706,6 +701,11 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                     cb();
                 }
             );
+
+            // start VmAgent
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _removeDNI(arg, cb) {
             // when we remove the DNI flag, the VM should show up at VMAPI
             performThenWait(function _performRemoveDNI(next) {
@@ -885,11 +885,6 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -901,6 +896,10 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                     cb();
                 }
             );
+
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _createDoNotInventoryVm2(arg, cb) {
             // creating a VM with DNI should not result in an update.
             vmadm.create(payload2, function _vmadmCreateCb(err, info) {
@@ -987,7 +986,7 @@ test('VmAgent works after initial errors', function _test(t) {
     var vmapiPutErr;
 
     vasync.pipeline({arg: {}, funcs: [
-        function _startVmAgent(arg, cb) {
+        function _createSimulatedErrors(arg, cb) {
             // simulate connection refused
             vmapiGetErr = new Error('Connection Refused');
             vmapiGetErr.code = 'ECONNREFUSED';
@@ -1002,121 +1001,137 @@ test('VmAgent works after initial errors', function _test(t) {
             mocks.Vmapi.setPutError(vmapiPutErr);
 
             t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
             cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             var seenGetAttempts = 0;
             var seenPutAttempts = 0;
-            // VmAgent should be initializing itself and it'll send the initial
-            // GET /vms, which will fail. We'll allow it to fail resolveAfter
-            // times and then remove the error. Then we should see the PUT /vms
-            // at which point we'll fail that resolveAfter times and then move
-            // on.
-
-            coordinator.on('vmapi.updateServerVms',
-                function _onUpdateVms(vmobjs, server_uuid, err) {
-                    var keys = Object.keys(vmobjs);
 
-                    seenPutAttempts++;
-                    t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
-                        + seenPutAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenPutAttempts === resolveAfter) {
-                        mocks.Vmapi.setPutError(null);
-                        cb();
-                        return;
-                    }
-                }
-            );
+            /*
+             * VmAgent should be initializing itself and it'll send the initial
+             * GET /vms, which will fail. We'll allow it to fail resolveAfter
+             * times and then remove the error. Then we should see the PUT /vms
+             * at which point we'll fail that resolveAfter times and then move
+             * on.
+             *
+             * This logic is handled by a call to vasync.parallel, because
+             * starting the VmAgent instance itself calls a callback when it is
+             * ready.  On top of that, we don't want to consider this portion
+             * of the test finished until 1. the VmAgent instance is ready and
+             * 2. The seenPutAttempts matches resolveAfter.  Though it's not
+             * currently the case, in the future it is possible that
+             * VmAgent#start could fail and callback with an error, in which
+             * case we'd want to bail out of the test early.
+             */
+            vasync.parallel({funcs: [
+                function _vmapiUpdateServerVms(cb2) {
+                    coordinator.on('vmapi.updateServerVms',
+                        function _onUpdateVms(vmobjs, server_uuid, err) {
+                            var keys = Object.keys(vmobjs);
+
+                            seenPutAttempts++;
+                            t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
+                                + seenPutAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
+
+                            if (seenPutAttempts === resolveAfter) {
+                                mocks.Vmapi.setPutError(null);
+                                cb2();
+                                return;
+                            }
+                        }
+                    );
 
-            coordinator.on('vmapi.getVms',
-                function _onVmapiGetVms(server_uuid, err) {
-                    seenGetAttempts++;
-                    t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenGetAttempts >= resolveAfter) {
-                        mocks.Vmapi.setGetError(null);
-                    }
+                    coordinator.on('vmapi.getVms',
+                        function _onVmapiGetVms(server_uuid, err) {
+                            seenGetAttempts++;
+                            t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
+
+                            if (seenGetAttempts >= resolveAfter) {
+                                mocks.Vmapi.setGetError(null);
+                            }
+                        }
+                    );
+                }, function _startVmAgent(cb2) {
+                    vmAgent = new VmAgent(config);
+                    vmAgent.start(cb2);
                 }
-            );
+            ]}, cb);
         }, function _createVm(arg, cb) {
             // now that init is complete, create a VM and make sure we see an
             // update.
 
             payload.log = config.log;
 
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                coordinator.removeAllListeners('vmapi.updateVm');
-                t.ok(true, 'VMAPI saw update for new VM.');
-                cb();
-            });
-
-            vmadm.create(payload, function _vmadmCreateCb(err, info) {
-                t.ifError(err, 'create VM');
-                if (!err && info) {
-                    t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
-                        + info.uuid);
+            /*
+             * Like above, we use vasync.parallel to ensure the test does not
+             * move on until `vmadm.create` is successful as well as the
+             * vmapi.updateVm event being seen for the new VM.  Because the
+             * event is typically  seen before `vmadm.create` finishes, it was
+             * possible (before vasync.parallel) for the test to print somewhat
+             * out-of-order results, resulting in the 'new VM has uuid: <uuid>'
+             * line appearing way lower than expected.
+             */
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            coordinator.removeAllListeners('vmapi.updateVm');
+                            t.ok(true, 'VMAPI saw update for new VM.');
+                            cb2();
+                        }
+                    );
+                }, function _vmadmCreate(cb2) {
+                    vmadm.create(payload, function _vmadmCreateCb(err, info) {
+                        t.ifError(err, 'create VM');
+                        if (!err && info) {
+                            t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
+                                + info.uuid);
+                        }
+                        cb2();
+                    });
                 }
-            });
+            ]}, cb);
         }, function _deleteVm(arg, cb) {
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                if (vmobj.state === 'destroyed'
-                    && vmobj.zone_state === 'destroyed') {
-                    // when we see destroyed, we'll move on
-                    t.ok(true, 'VMAPI saw destroy for VM');
-                    coordinator.removeAllListeners('vmapi.updateVm');
-                    cb();
-                    return;
-                }
-            });
-
-            vmadm.delete({log: config.log, uuid: payload.uuid},
-                function _vmadmDeleteCb(err) {
-                    t.ifError(err, 'delete VM: '
-                        + (err ? err.message : 'success'));
-                }
-            );
-        }, function _checkZoneeventChildren(arg, cb) {
-            execFile('/usr/bin/ptree', [process.pid],
-                function _scanPtree(err, stdout /* , stderr */) {
-                    var zoneevent_children = [];
-
-                    if (!err) {
-                        stdout.split('\n').forEach(function _onLine(line) {
-                            var proc = line.trim().match(/(\d+)\s+(.*)$/);
-
-                            /* eslint-disable no-magic-numbers */
-                            if (proc && proc[2]
-                                && proc[2] === '/usr/vm/sbin/zoneevent') {
-                                // track PIDs so we can kill them
-                                zoneevent_children.push(proc[1]);
+            /*
+             * Same logic applies for `vmadm.delete` as `vmadm.create` above
+             * re: vasync.parallel.
+             */
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            if (vmobj.state === 'destroyed'
+                                && vmobj.zone_state === 'destroyed') {
+                                // when we see destroyed, we'll move on
+                                t.ok(true, 'VMAPI saw destroy for VM');
+                                coordinator.removeAllListeners(
+                                    'vmapi.updateVm');
+                                cb2();
+                                return;
                             }
-
-                            /* eslint-enable no-magic-numbers */
-                        });
-
-                        t.equal(zoneevent_children.length, 1,
-                            'should have one zoneevent child');
-
-                        if (zoneevent_children.length > 1) {
-                            zoneevent_children.forEach(function _killPid(pid) {
-                                t.ok(true, 'killing extra zoneevent ' + pid);
-                                process.kill(pid, 'SIGKILL');
-                            });
                         }
-                    }
-                    cb(err);
+                    );
+                }, function _vmadmDelete(cb2) {
+                    vmadm.delete({log: config.log, uuid: payload.uuid},
+                        function _vmadmDeleteCb(err) {
+                            t.ifError(err, 'delete VM: '
+                                + (err ? err.message : 'success'));
+                            cb2();
+                        }
+                    );
                 }
-            );
+            ]}, cb);
         }
     ]}, function _pipelineComplete(err) {
         t.ifError(err, 'pipeline complete');
diff --git a/tests/test.VmWatcher.js b/tests/test.VmWatcher.js
index 1a5100a..2822bd1 100644
--- a/tests/test.VmWatcher.js
+++ b/tests/test.VmWatcher.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var execFile = require('child_process').execFile;
@@ -14,6 +14,7 @@ var test = require('tape');
 var vmadm = require('vmadm');
 
 var common = require('./common');
+var determineEventSource = require('../lib/event-source');
 var mocks = require('./mocks');
 var VmWatcher = require('../lib/vm-watcher');
 
@@ -21,41 +22,15 @@ var VmWatcher = require('../lib/vm-watcher');
 // For tests we can lower the frequency the periodic watcher polls so we finish
 // in more reasonable time.
 var PERIODIC_INTERVAL = 1000;
-// How frequently to poll the 'events' array when we're waiting for an event.
-var EVENTS_POLL_FREQ = 100; // ms
 
 var events = [];
 var existingVms = [];
+var eventSource;
 var smartosImageUUID;
 var smartosVmUUID;
 var watcher;
 
 
-function waitEvent(t, evt, vm_uuid, eventIdx) {
-    var loops = 0;
-
-    function _waitEvent() {
-        var i;
-
-        if (events.length > eventIdx) {
-            // we've had some new events, check for our create
-            for (i = eventIdx; i < events.length; i++) {
-                if (events[i].vm_uuid === vm_uuid && events[i].event === evt) {
-                    t.ok(true, 'VmWatcher saw expected ' + evt
-                        + ' (' + (loops * EVENTS_POLL_FREQ) + ' ms)');
-                    t.end();
-                    return;
-                }
-            }
-        }
-
-        loops++;
-        setTimeout(_waitEvent, EVENTS_POLL_FREQ);
-    }
-
-    _waitEvent();
-}
-
 test('find SmartOS image', function _test(t) {
     common.testFindSmartosImage(t, function _findSmartosCb(err, latest) {
         t.ifError(err, 'find SmartOS Image');
@@ -84,35 +59,54 @@ test('load existing VMs', function _test(t) {
     });
 });
 
+test('determine best event source', function _test(t) {
+    var opts = {
+        log: mocks.Logger
+    };
+
+    determineEventSource(opts,
+        function determinedEventSource(err, _eventSource) {
+            t.ifError(err, 'determineEventSource err');
+
+            eventSource = _eventSource;
+            t.ok(eventSource,
+                'determineEventSource eventSource: ' + eventSource);
+
+            t.end();
+        }
+    );
+});
+
 test('starting VmWatcher', function _test(t) {
     watcher = new VmWatcher({
         log: mocks.Logger,
+        eventSource: eventSource,
         periodicInterval: PERIODIC_INTERVAL
     });
 
     t.ok(watcher, 'created VmWatcher');
 
-    function _onVmEvent(vm_uuid, name) {
+    function _onVmEvent(vmUuid, name) {
         // ignore events from VMs that existed when we started
-        if (existingVms.indexOf(vm_uuid) === -1) {
+        if (existingVms.indexOf(vmUuid) === -1) {
             events.push({
                 event: name,
                 timestamp: (new Date()).toISOString(),
-                vm_uuid: vm_uuid
+                vmUuid: vmUuid
             });
         }
     }
 
-    watcher.on('VmCreated', function _onCreate(vm_uuid, watcherName) {
-        _onVmEvent(vm_uuid, 'create', watcherName);
+    watcher.on('VmCreated', function _onCreate(vmUuid, watcherName) {
+        _onVmEvent(vmUuid, 'create', watcherName);
     });
 
-    watcher.on('VmModified', function _onModify(vm_uuid, watcherName) {
-        _onVmEvent(vm_uuid, 'modify', watcherName);
+    watcher.on('VmModified', function _onModify(vmUuid, watcherName) {
+        _onVmEvent(vmUuid, 'modify', watcherName);
     });
 
-    watcher.on('VmDeleted', function _onDelete(vm_uuid, watcherName) {
-        _onVmEvent(vm_uuid, 'delete', watcherName);
+    watcher.on('VmDeleted', function _onDelete(vmUuid, watcherName) {
+        _onVmEvent(vmUuid, 'delete', watcherName);
     });
 
     watcher.start();
@@ -136,7 +130,7 @@ test('create VM', function _test(t) {
         if (!err && info) {
             t.ok(info.uuid, 'VM has uuid: ' + info.uuid);
             smartosVmUUID = info.uuid;
-            waitEvent(t, 'create', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'create', smartosVmUUID, events, eventIdx);
         } else {
             t.end();
         }
@@ -156,7 +150,7 @@ test('stop VM', function _test(t) {
             t.end();
         } else {
             // state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -174,7 +168,7 @@ test('start VM', function _test(t) {
             t.end();
         } else {
             // state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -188,7 +182,7 @@ test('modify quota using ZFS', function _test(t) {
             if (err) {
                 t.end();
             } else {
-                waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+                common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
             }
         }
     );
@@ -204,7 +198,7 @@ test('put metadata using mdata-put', function _test(t) {
             if (err) {
                 t.end();
             } else {
-                waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+                common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
             }
         }
     );
@@ -222,7 +216,7 @@ test('delete VM', function _test(t) {
         if (err) {
             t.end();
         } else {
-            waitEvent(t, 'delete', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'delete', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -237,7 +231,7 @@ test('check SmartOS VM\'s events', function _test(t) {
     var evts = [];
 
     events.forEach(function _pushEvent(evt) {
-        if (evt.vm_uuid === smartosVmUUID) {
+        if (evt.vmUuid === smartosVmUUID) {
             evts.push(evt.event);
         }
     });
diff --git a/tests/test.VmadmEventsWatcher.js b/tests/test.VmadmEventsWatcher.js
new file mode 100644
index 0000000..7e1bbf9
--- /dev/null
+++ b/tests/test.VmadmEventsWatcher.js
@@ -0,0 +1,174 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var execFile = require('child_process').execFile;
+
+var assert = require('assert-plus');
+var test = require('tape');
+var vmadm = require('vmadm');
+
+var common = require('./common');
+var mocks = require('./mocks');
+var determineEventSource = require('../lib/event-source');
+var VmadmEventsWatcher = require('../lib/watchers/vmadm-events-watcher');
+
+var eventSource;
+var events = [];
+var existingVms = [];
+var smartosImageUUID;
+var smartosVmUUID;
+var watcher;
+
+function main() {
+    test('find SmartOS image', function _test(t) {
+        common.testFindSmartosImage(t, function _findSmartosCb(err, latest) {
+            t.ifError(err, 'find SmartOS Image');
+            if (err) {
+                throw new Error('Cannot continue without SmartOS Image');
+            }
+            smartosImageUUID = latest;
+            t.end();
+        });
+    });
+
+    test('starting VmadmEventsWatcher', function _test(t) {
+        function _onVmUpdate(vmUuid, updateType /* , updateObj */) {
+            assert.uuid(vmUuid, 'vmUuid');
+            assert.string(updateType, 'updateType');
+
+            // ignore events from VMs that existed when we started
+            if (existingVms.indexOf(vmUuid) > -1) {
+                return;
+            }
+
+            events.push({
+                event: updateType,
+                timestamp: (new Date()).toISOString(),
+                vmUuid: vmUuid
+            });
+        }
+
+        watcher = new VmadmEventsWatcher({
+            log: mocks.Logger,
+            updateVm: _onVmUpdate
+        });
+
+        t.ok(watcher, 'created VmadmEventsWatcher');
+
+        watcher.start(function vmadmEventsWatcherStarted(err, ev) {
+            t.ifError(err, 'VmadmEventsWatcher start err');
+            t.equal(typeof (ev), 'object', 'ready event');
+            t.equal(typeof (ev.vms), 'object', 'ready event vms');
+
+            existingVms = Object.keys(ev.vms);
+
+            t.end();
+        });
+    });
+
+    test('create VM', function _test(t) {
+        var eventIdx = events.length;
+        var payload = {
+            alias: 'vm-agent_testvm',
+            brand: 'joyent-minimal',
+            image_uuid: smartosImageUUID,
+            quota: 10
+        };
+
+        payload.log = mocks.Logger;
+
+        vmadm.create(payload, function _vmadmCreateCb(err, info) {
+            t.ifError(err, 'create VM');
+            if (!err && info) {
+                t.ok(info.uuid, 'VM has uuid: ' + info.uuid);
+                smartosVmUUID = info.uuid;
+                common.waitEvent(t, 'create', smartosVmUUID, events, eventIdx);
+            } else {
+                t.end();
+            }
+        });
+    });
+
+    test('put metadata using mdata-put', function _test(t) {
+        var eventIdx = events.length;
+
+        execFile('/usr/sbin/zlogin',
+            [smartosVmUUID, '/usr/sbin/mdata-put', 'hello', 'world'],
+            function _mdataPutCb(err /* , stdout, stderr */) {
+                t.ifError(err, 'mdata-put');
+                if (err) {
+                    t.end();
+                } else {
+                    common.waitEvent(t, 'modify', smartosVmUUID, events,
+                        eventIdx);
+                }
+            }
+        );
+    });
+
+    test('delete VM', function _test(t) {
+        var eventIdx = events.length;
+        var opts = {};
+
+        opts.log = mocks.Logger;
+        opts.uuid = smartosVmUUID;
+
+        vmadm.delete(opts, function _vmadmDeleteCb(err) {
+            t.ifError(err, 'deleted VM ' + smartosVmUUID);
+            if (err) {
+                t.end();
+            } else {
+                common.waitEvent(t, 'delete', smartosVmUUID, events, eventIdx);
+            }
+        });
+    });
+
+    test('stop VmadmEventsWatcher', function _test(t) {
+        watcher.stop();
+        t.ok(true, 'stopped watcher');
+        t.end();
+    });
+
+    test('check SmartOS VM\'s events', function _test(t) {
+        var evts = events.filter(function filterEvent(evt) {
+            return (evt.vmUuid === smartosVmUUID);
+        }).map(function mapEvent(evt) {
+            return (evt.event);
+        });
+
+        t.ok(true, 'saw: ' + evts.join(','));
+        t.end();
+    });
+}
+
+test('determine best event source', function _test(t) {
+    var opts = {
+        log: mocks.Logger
+    };
+
+    determineEventSource(opts,
+        function determinedEventSource(err, _eventSource) {
+            t.ifError(err, 'event source err');
+
+            eventSource = _eventSource;
+            t.ok(eventSource,
+                'determineEventSource eventSource: ' + eventSource);
+
+            // Only run the rest of these tests if vmadm-events is supported
+            if (!err && eventSource === 'vmadm-events') {
+                t.end();
+                main();
+            } else {
+                t.ok(true, 'skipping tests: eventSource !== vmadm-events');
+                t.end();
+            }
+        }
+    );
+});
diff --git a/tests/test.ZoneeventWatcher.js b/tests/test.ZoneeventWatcher.js
index 36064d1..7f2c186 100644
--- a/tests/test.ZoneeventWatcher.js
+++ b/tests/test.ZoneeventWatcher.js
@@ -15,41 +15,12 @@ var common = require('./common');
 var mocks = require('./mocks');
 var ZoneeventWatcher = require('../lib/watchers/zoneevent-watcher');
 
-// How frequently to poll the 'events' array when we're waiting for an event.
-var EVENTS_POLL_FREQ = 100; // ms
-
 var events = [];
 var existingVms = [];
 var smartosImageUUID;
 var smartosVmUUID;
 var watcher;
 
-
-function waitEvent(t, evt, vmUuid, eventIdx) {
-    var loops = 0;
-
-    function _waitEvent() {
-        var i;
-
-        if (events.length > eventIdx) {
-            // we've had some new events, check for our create
-            for (i = eventIdx; i < events.length; i++) {
-                if (events[i].vmUuid === vmUuid && events[i].event === evt) {
-                    t.ok(true, 'ZoneeventWatcher saw expected ' + evt
-                        + ' (' + (loops * EVENTS_POLL_FREQ) + ' ms)');
-                    t.end();
-                    return;
-                }
-            }
-        }
-
-        loops++;
-        setTimeout(_waitEvent, EVENTS_POLL_FREQ);
-    }
-
-    _waitEvent();
-}
-
 test('find SmartOS image', function _test(t) {
     common.testFindSmartosImage(t, function _findSmartosCb(err, latest) {
         t.ifError(err, 'find SmartOS Image');
@@ -143,7 +114,7 @@ test('start VM', function _test(t) {
             t.end();
         } else {
             // state+zone_state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
@@ -174,7 +145,7 @@ test('stop VM', function _test(t) {
             t.end();
         } else {
             // state+zone_state should change
-            waitEvent(t, 'modify', smartosVmUUID, eventIdx);
+            common.waitEvent(t, 'modify', smartosVmUUID, events, eventIdx);
         }
     });
 });
-- 
2.21.0

