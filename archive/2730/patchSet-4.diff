From bec2b0658984aecc8c4c8fef7a566666d37f08a9 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Thu, 19 Oct 2017 13:13:16 -0400
Subject: [PATCH] AGENT-979 vm-agent needs vminfod watcher

---
 lib/vm-agent.js                      | 103 +++++++++-----
 lib/vm-watcher.js                    | 108 ++++++++++-----
 lib/watchers/vmadm-events-watcher.js |  79 +++++++++++
 tests/mocks.js                       |  12 +-
 tests/test.VmAgentRealVmadm.js       | 199 +++++++++++++--------------
 5 files changed, 328 insertions(+), 173 deletions(-)
 create mode 100644 lib/watchers/vmadm-events-watcher.js

diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index 5dc56f6..9e9a40b 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -528,15 +528,12 @@ VmAgent.prototype.queueVm = function queueVm(vmUuid) {
     }
 };
 
-VmAgent.prototype.setupWatcher = function setupWatcher() {
+VmAgent.prototype.setupWatcher = function setupWatcher(callback) {
     var self = this;
+    var vmadmEventsStop;
+    var vmadmEventsOpts;
 
-    // Setup the watcher that will notice VM changes and add to the
-    // update-to-VMAPI queue.
-    self.watcher = new VmWatcher({
-        log: self.log,
-        periodicInterval: self.periodicInterval // may be undefined
-    });
+    assert.func(callback, 'callback');
 
     function _onVmEvent(vmUuid, name, watcher) {
         assert.uuid(vmUuid, 'vmUuid');
@@ -559,23 +556,60 @@ VmAgent.prototype.setupWatcher = function setupWatcher() {
         self.queueVm(vmUuid);
     }
 
-    self.watcher.on('VmCreated', function _onCreate(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'create', watcher);
-    });
+    // Create the VmWatcher instance now that we know the best eventSource to
+    // use.
+    function finishSetup(eventSource) {
+        // Setup the watcher that will notice VM changes and add to the
+        // update-to-VMAPI queue.
+        self.log.info('determined best eventSource: %s', eventSource);
+
+        self.watcher = new VmWatcher({
+            log: self.log,
+            eventSource: eventSource,
+            periodicInterval: self.periodicInterval // may be undefined
+        });
 
-    self.watcher.on('VmModified', function _onModify(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'modify', watcher);
-    });
+        self.watcher.on('VmCreated', function _onCreate(vmUuid, watcher) {
+            assert.uuid(vmUuid, 'vmUuid');
+            assert.string(watcher, 'watcher');
+            _onVmEvent(vmUuid, 'create', watcher);
+        });
 
-    self.watcher.on('VmDeleted', function _onDelete(vmUuid, watcher) {
-        assert.uuid(vmUuid, 'vmUuid');
-        assert.string(watcher, 'watcher');
-        _onVmEvent(vmUuid, 'delete', watcher);
-    });
+        self.watcher.on('VmModified', function _onModify(vmUuid, watcher) {
+            assert.uuid(vmUuid, 'vmUuid');
+            assert.string(watcher, 'watcher');
+            _onVmEvent(vmUuid, 'modify', watcher);
+        });
+
+        self.watcher.on('VmDeleted', function _onDelete(vmUuid, watcher) {
+            assert.uuid(vmUuid, 'vmUuid');
+            assert.string(watcher, 'watcher');
+            _onVmEvent(vmUuid, 'delete', watcher);
+        });
+
+        callback();
+    }
+
+    // Figure out the best event source for the system.  Basically, this checks
+    // to see if vminfod is supported by looking for `vmadm events` support.
+    vmadmEventsOpts = {
+        log: self.log,
+        name: 'VM Agent setupWatcher eventSource test'
+    };
+    vmadmEventsStop = vmadm.events(vmadmEventsOpts,
+        function vmadmEventsHandler() {
+            // we don't care about any events
+        }, function vmadmEventsReady(err) {
+            if (err) {
+                // vmadm events is not supported, use default eventSource
+                finishSetup('default');
+                return;
+            }
+
+            vmadmEventsStop();
+            finishSetup('vmadm-events');
+        }
+    );
 
     // NOTE: watcher gets started as part of initialUpdate
 };
@@ -670,13 +704,8 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
              * lookup we're about to do. If something fails in the
              * initialization here and we're going to do a new loop, we stop
              * the watcher and clear the existing queue.
-             *
-             * NOTE: This always succeeds because it just calls .start() on the
-             * appropriate watchers. The watchers themselves will retry if
-             * something goes wrong with their startup.
              */
-            self.watcher.start();
-            cb();
+            self.watcher.start(cb);
         }, function _getVmadmVms(stash, cb) {
             var ALL_VMS = {}; // no filter means: grab them all
             var opts = {log: self.log, include_dni: true};
@@ -825,16 +854,20 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
     });
 };
 
-VmAgent.prototype.start = function start() {
+VmAgent.prototype.start = function start(callback) {
     var self = this;
 
+    assert.optionalFunc(callback, 'callback');
+
     vasync.pipeline({arg: {}, funcs: [
         function _setupWatcher(stash, cb) {
-            if (!self.watcher) {
-                // initialize the watcher if we've not already done so
-                self.setupWatcher();
+            // initialize the watcher if we've not already done so
+            if (self.watcher) {
+                cb();
+                return;
             }
-            cb();
+
+            self.setupWatcher(cb);
         }, function _initialUpdate(stash, cb) {
             var startUpdate = (new Date()).getTime();
 
@@ -880,6 +913,10 @@ VmAgent.prototype.start = function start() {
         });
 
         self.log.info('startup complete');
+        if (callback) {
+            callback();
+            return;
+        }
     });
 };
 
diff --git a/lib/vm-watcher.js b/lib/vm-watcher.js
index a3403f6..07310dc 100644
--- a/lib/vm-watcher.js
+++ b/lib/vm-watcher.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -69,10 +69,6 @@
  *    our object at the same time that action completes since cn-agent will
  *    gather the VM object and the workflow will do a PUT.
  *
- *  - When vminfod is available, we should be able to use that watcher
- *    exclusively on those platforms, as vminfod already watches for all
- *    property changes.
- *
  */
 
 var EventEmitter = require('events').EventEmitter;
@@ -84,14 +80,13 @@ var diff = require('deep-diff').diff;
 var FsWatcher = require('../lib/watchers/fs-watcher');
 var PeriodicWatcher = require('../lib/watchers/periodic-watcher');
 var ZoneeventWatcher = require('../lib/watchers/zoneevent-watcher');
-
+var VmadmEventsWatcher = require('../lib/watchers/vmadm-events-watcher');
 
 /*
  * Globals
  */
 var MS_PER_SEC = 1000;
 
-
 /*
  * The VmWatcher will emit these events:
  *
@@ -109,6 +104,7 @@ function VmWatcher(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
     assert.optionalNumber(opts.periodicInterval, 'opts.periodicInterval');
+    assert.optionalString(opts.eventSource, 'opts.eventSource');
 
     // Initialize necessary properties from `EventEmitter` in this instance
     EventEmitter.call(this);
@@ -116,6 +112,9 @@ function VmWatcher(opts) {
     // Yay bunyan!
     self.log = opts.log;
 
+    // Event Source
+    self.eventSource = opts.eventSource;
+
     // This is used to try to avoid emitting the same event twice when just
     // noticed by different watchers. How it works is that when we see an update
     // via the updateVm() function, the watcher passes us a list of properties
@@ -124,24 +123,37 @@ function VmWatcher(opts) {
     // the same change.
     self.knownVms = {};
 
-    self.fsWatcher = new FsWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('fs')
-    });
-
-    self.zoneeventWatcher = new ZoneeventWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('zoneevent')
-    });
-
-    // FUTURE: If someone only wants last_modified, we can avoid starting up the
-    // periodic watcher?
-
-    self.periodicWatcher = new PeriodicWatcher({
-        log: opts.log,
-        periodicInterval: opts.periodicInterval, // might be undefined
-        updateVm: self.newUpdateHandler('periodic')
-    });
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher = new VmadmEventsWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('vmadm')
+            });
+            break;
+        case 'default':
+            self.fsWatcher = new FsWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('fs')
+            });
+
+            self.zoneeventWatcher = new ZoneeventWatcher({
+                log: opts.log,
+                updateVm: self.newUpdateHandler('zoneevent')
+            });
+
+            // FUTURE: If someone only wants last_modified, we can avoid
+            // starting up the periodic watcher?
+
+            self.periodicWatcher = new PeriodicWatcher({
+                log: opts.log,
+                periodicInterval: opts.periodicInterval, // might be undefined
+                updateVm: self.newUpdateHandler('periodic')
+            });
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 }
 util.inherits(VmWatcher, EventEmitter);
 
@@ -354,27 +366,55 @@ VmWatcher.prototype.newUpdateHandler = function newUpdateHandler(watcher) {
     });
 };
 
-VmWatcher.prototype.start = function start() {
+VmWatcher.prototype.start = function start(cb) {
     var self = this;
 
-    self.fsWatcher.start();
-    self.periodicWatcher.start();
-    self.zoneeventWatcher.start();
-    // ... other watchers
+    assert.optionalFunc(cb, 'cb');
+
+    self.log.debug({eventSource: self.eventSource}, 'Starting VmWatcher');
+
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher.start(cb);
+            break;
+        case 'default':
+            self.fsWatcher.start();
+            self.periodicWatcher.start();
+            self.zoneeventWatcher.start();
+            if (cb) {
+                cb();
+                return;
+            }
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 };
 
 VmWatcher.prototype.stop = function stop(opts) {
     var self = this;
     var keepListeners = false;
 
+    self.log.debug({eventSource: self.eventSource}, 'Stopping VmWatcher');
+
     if (opts && opts.keepListeners) {
         keepListeners = true;
     }
 
-    self.fsWatcher.stop();
-    self.periodicWatcher.stop();
-    self.zoneeventWatcher.stop();
-    // ... other watchers
+    switch (self.eventSource) {
+        case 'vmadm-events':
+            self.vmadmEventsWatcher.stop();
+            break;
+        case 'default':
+            self.fsWatcher.stop();
+            self.periodicWatcher.stop();
+            self.zoneeventWatcher.stop();
+            break;
+        default:
+            assert(false, 'unknown eventSource: ' + self.eventSource);
+            break;
+    }
 
     if (!keepListeners) {
         self.removeAllListeners();
diff --git a/lib/watchers/vmadm-events-watcher.js b/lib/watchers/vmadm-events-watcher.js
new file mode 100644
index 0000000..9c631e1
--- /dev/null
+++ b/lib/watchers/vmadm-events-watcher.js
@@ -0,0 +1,79 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var vmadm = require('vmadm');
+
+function noop() {}
+
+function VmadmEventsWatcher(opts) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.func(opts.updateVm, 'opts.updateVm');
+
+    self.log = opts.log.child({watcher: 'vmadm-events-watcher'});
+    self.updateVm = opts.updateVm;
+}
+
+VmadmEventsWatcher.prototype.start = function start(cb) {
+    var self = this;
+
+    var opts;
+
+    cb = cb || noop;
+
+    assert.func(cb, 'cb');
+    assert(!self.stopWatcher, 'watcher already created');
+
+    opts = {
+        log: self.log,
+        name: 'VM Agent'
+    };
+
+    function handler(ev) {
+        assert.object(ev, 'ev');
+        assert.string(ev.type, 'ev.type');
+        assert.uuid(ev.zonename, 'ev.zonename');
+
+        switch (ev.type) {
+            case 'create':
+                assert.object(ev.vm, 'ev.vm');
+                self.updateVm(ev.zonename, 'create', ev.vm);
+                break;
+            case 'modify':
+                assert.object(ev.vm, 'ev.vm');
+                self.updateVm(ev.zonename, 'modify', ev.vm);
+                break;
+            case 'delete':
+                self.updateVm(ev.zonename, 'delete', {});
+                break;
+            default:
+                assert(false, 'unknown vmadm event type: ' + ev.type);
+                break;
+        }
+    }
+
+    self.stopWatcher = vmadm.events(opts, handler, cb);
+};
+
+VmadmEventsWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    if (self.stopWatcher) {
+        self.stopWatcher();
+        delete self.stopWatcher;
+    }
+};
+
+VmadmEventsWatcher.FIELDS = [];
+
+module.exports = VmadmEventsWatcher;
diff --git a/tests/mocks.js b/tests/mocks.js
index 7db4304..2c7567c 100644
--- a/tests/mocks.js
+++ b/tests/mocks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var util = require('util');
@@ -215,6 +215,10 @@ fakeVmadm.getError = function getError() {
     return (vmadmErr);
 };
 
+fakeVmadm.events = function vmadmEvents(opts, handler, cb) {
+    cb(new Error('Not Implemented'));
+};
+
 
 /*
  * Fake VMAPI for testing
@@ -344,8 +348,12 @@ function fakeVmWatcher() {
 }
 util.inherits(fakeVmWatcher, EventEmitter);
 
-fakeVmWatcher.prototype.start = function start() {
+fakeVmWatcher.prototype.start = function start(cb) {
     // console.error('vmwatcher.start');
+    if (cb) {
+        cb();
+        return;
+    }
 };
 
 fakeVmWatcher.prototype.stop = function stop() {
diff --git a/tests/test.VmAgentRealVmadm.js b/tests/test.VmAgentRealVmadm.js
index 253410a..cf5adb0 100644
--- a/tests/test.VmAgentRealVmadm.js
+++ b/tests/test.VmAgentRealVmadm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var execFile = require('child_process').execFile;
@@ -678,11 +678,6 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -706,6 +701,11 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                     cb();
                 }
             );
+
+            // start VmAgent
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _removeDNI(arg, cb) {
             // when we remove the DNI flag, the VM should show up at VMAPI
             performThenWait(function _performRemoveDNI(next) {
@@ -885,11 +885,6 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -901,6 +896,10 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                     cb();
                 }
             );
+
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _createDoNotInventoryVm2(arg, cb) {
             // creating a VM with DNI should not result in an update.
             vmadm.create(payload2, function _vmadmCreateCb(err, info) {
@@ -987,7 +986,7 @@ test('VmAgent works after initial errors', function _test(t) {
     var vmapiPutErr;
 
     vasync.pipeline({arg: {}, funcs: [
-        function _startVmAgent(arg, cb) {
+        function _createSimulatedErrors(arg, cb) {
             // simulate connection refused
             vmapiGetErr = new Error('Connection Refused');
             vmapiGetErr.code = 'ECONNREFUSED';
@@ -1002,121 +1001,113 @@ test('VmAgent works after initial errors', function _test(t) {
             mocks.Vmapi.setPutError(vmapiPutErr);
 
             t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
             cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             var seenGetAttempts = 0;
             var seenPutAttempts = 0;
+
             // VmAgent should be initializing itself and it'll send the initial
             // GET /vms, which will fail. We'll allow it to fail resolveAfter
             // times and then remove the error. Then we should see the PUT /vms
             // at which point we'll fail that resolveAfter times and then move
             // on.
+            vasync.parallel({funcs: [
+                function _vmapiUpdateServerVms(cb2) {
+                    coordinator.on('vmapi.updateServerVms',
+                        function _onUpdateVms(vmobjs, server_uuid, err) {
+                            var keys = Object.keys(vmobjs);
+
+                            seenPutAttempts++;
+                            t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
+                                + seenPutAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
+
+                            if (seenPutAttempts === resolveAfter) {
+                                mocks.Vmapi.setPutError(null);
+                                cb2();
+                                return;
+                            }
+                        }
+                    );
 
-            coordinator.on('vmapi.updateServerVms',
-                function _onUpdateVms(vmobjs, server_uuid, err) {
-                    var keys = Object.keys(vmobjs);
-
-                    seenPutAttempts++;
-                    t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
-                        + seenPutAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenPutAttempts === resolveAfter) {
-                        mocks.Vmapi.setPutError(null);
-                        cb();
-                        return;
-                    }
-                }
-            );
+                    coordinator.on('vmapi.getVms',
+                        function _onVmapiGetVms(server_uuid, err) {
+                            seenGetAttempts++;
+                            t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
 
-            coordinator.on('vmapi.getVms',
-                function _onVmapiGetVms(server_uuid, err) {
-                    seenGetAttempts++;
-                    t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenGetAttempts >= resolveAfter) {
-                        mocks.Vmapi.setGetError(null);
-                    }
+                            if (seenGetAttempts >= resolveAfter) {
+                                mocks.Vmapi.setGetError(null);
+                            }
+                        }
+                    );
+                }, function _startVmAgent(cb2) {
+                    vmAgent = new VmAgent(config);
+                    vmAgent.start(cb2);
                 }
-            );
+            ]}, cb);
         }, function _createVm(arg, cb) {
             // now that init is complete, create a VM and make sure we see an
             // update.
 
             payload.log = config.log;
 
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                coordinator.removeAllListeners('vmapi.updateVm');
-                t.ok(true, 'VMAPI saw update for new VM.');
-                cb();
-            });
-
-            vmadm.create(payload, function _vmadmCreateCb(err, info) {
-                t.ifError(err, 'create VM');
-                if (!err && info) {
-                    t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
-                        + info.uuid);
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            coordinator.removeAllListeners('vmapi.updateVm');
+                            t.ok(true, 'VMAPI saw update for new VM.');
+                            cb2();
+                        }
+                    );
+                }, function _vmadmCreate(cb2) {
+                    vmadm.create(payload, function _vmadmCreateCb(err, info) {
+                        t.ifError(err, 'create VM');
+                        if (!err && info) {
+                            t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
+                                + info.uuid);
+                        }
+                        cb2();
+                    });
                 }
-            });
+            ]}, cb);
         }, function _deleteVm(arg, cb) {
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                if (vmobj.state === 'destroyed'
-                    && vmobj.zone_state === 'destroyed') {
-                    // when we see destroyed, we'll move on
-                    t.ok(true, 'VMAPI saw destroy for VM');
-                    coordinator.removeAllListeners('vmapi.updateVm');
-                    cb();
-                    return;
-                }
-            });
-
-            vmadm.delete({log: config.log, uuid: payload.uuid},
-                function _vmadmDeleteCb(err) {
-                    t.ifError(err, 'delete VM: '
-                        + (err ? err.message : 'success'));
-                }
-            );
-        }, function _checkZoneeventChildren(arg, cb) {
-            execFile('/usr/bin/ptree', [process.pid],
-                function _scanPtree(err, stdout /* , stderr */) {
-                    var zoneevent_children = [];
-
-                    if (!err) {
-                        stdout.split('\n').forEach(function _onLine(line) {
-                            var proc = line.trim().match(/(\d+)\s+(.*)$/);
-
-                            /* eslint-disable no-magic-numbers */
-                            if (proc && proc[2]
-                                && proc[2] === '/usr/vm/sbin/zoneevent') {
-                                // track PIDs so we can kill them
-                                zoneevent_children.push(proc[1]);
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            if (vmobj.state === 'destroyed'
+                                && vmobj.zone_state === 'destroyed') {
+                                // when we see destroyed, we'll move on
+                                t.ok(true, 'VMAPI saw destroy for VM');
+                                coordinator.removeAllListeners(
+                                    'vmapi.updateVm');
+                                cb2();
+                                return;
                             }
-
-                            /* eslint-enable no-magic-numbers */
-                        });
-
-                        t.equal(zoneevent_children.length, 1,
-                            'should have one zoneevent child');
-
-                        if (zoneevent_children.length > 1) {
-                            zoneevent_children.forEach(function _killPid(pid) {
-                                t.ok(true, 'killing extra zoneevent ' + pid);
-                                process.kill(pid, 'SIGKILL');
-                            });
                         }
-                    }
-                    cb(err);
+                    );
+                }, function _vmadmDelete(cb2) {
+                    vmadm.delete({log: config.log, uuid: payload.uuid},
+                        function _vmadmDeleteCb(err) {
+                            t.ifError(err, 'delete VM: '
+                                + (err ? err.message : 'success'));
+                            cb2();
+                        }
+                    );
                 }
-            );
+            ]}, cb);
         }
     ]}, function _pipelineComplete(err) {
         t.ifError(err, 'pipeline complete');
-- 
2.21.0

