From 194be0004791d710eaf67d1ce37baaffee03f99f Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Thu, 5 Oct 2017 13:16:20 -0400
Subject: [PATCH] AGENT-979 vm-agent needs vminfod watcher

---
 lib/vm-agent.js                    |  17 +--
 lib/vm-watcher.js                  |  84 ++++++++----
 lib/watchers/vminfod-vm-watcher.js |  82 ++++++++++++
 tests/mocks.js                     |   8 +-
 tests/test.VmAgentRealVmadm.js     | 199 ++++++++++++++---------------
 5 files changed, 249 insertions(+), 141 deletions(-)
 create mode 100644 lib/watchers/vminfod-vm-watcher.js

diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index 5dc56f6..59ced5d 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -670,13 +670,8 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
              * lookup we're about to do. If something fails in the
              * initialization here and we're going to do a new loop, we stop
              * the watcher and clear the existing queue.
-             *
-             * NOTE: This always succeeds because it just calls .start() on the
-             * appropriate watchers. The watchers themselves will retry if
-             * something goes wrong with their startup.
              */
-            self.watcher.start();
-            cb();
+            self.watcher.start(cb);
         }, function _getVmadmVms(stash, cb) {
             var ALL_VMS = {}; // no filter means: grab them all
             var opts = {log: self.log, include_dni: true};
@@ -825,9 +820,11 @@ VmAgent.prototype.initialUpdate = function initialUpdate(callback) {
     });
 };
 
-VmAgent.prototype.start = function start() {
+VmAgent.prototype.start = function start(callback) {
     var self = this;
 
+    assert.optionalFunc(callback, 'callback');
+
     vasync.pipeline({arg: {}, funcs: [
         function _setupWatcher(stash, cb) {
             if (!self.watcher) {
@@ -880,6 +877,10 @@ VmAgent.prototype.start = function start() {
         });
 
         self.log.info('startup complete');
+        if (callback) {
+            callback();
+            return;
+        }
     });
 };
 
diff --git a/lib/vm-watcher.js b/lib/vm-watcher.js
index a3403f6..0a61290 100644
--- a/lib/vm-watcher.js
+++ b/lib/vm-watcher.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -84,14 +84,13 @@ var diff = require('deep-diff').diff;
 var FsWatcher = require('../lib/watchers/fs-watcher');
 var PeriodicWatcher = require('../lib/watchers/periodic-watcher');
 var ZoneeventWatcher = require('../lib/watchers/zoneevent-watcher');
-
+var VminfodVmWatcher = require('../lib/watchers/vminfod-vm-watcher');
 
 /*
  * Globals
  */
 var MS_PER_SEC = 1000;
 
-
 /*
  * The VmWatcher will emit these events:
  *
@@ -109,6 +108,7 @@ function VmWatcher(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
     assert.optionalNumber(opts.periodicInterval, 'opts.periodicInterval');
+    assert.optionalBool(opts.useVminfod, 'opts.useVminfod');
 
     // Initialize necessary properties from `EventEmitter` in this instance
     EventEmitter.call(this);
@@ -116,6 +116,13 @@ function VmWatcher(opts) {
     // Yay bunyan!
     self.log = opts.log;
 
+    // Check event source
+    self.useVminfod = opts.useVminfod;
+    if (self.useVminfod === undefined) {
+        self.useVminfod = VminfodVmWatcher.VMINFOD_AVAILABLE;
+    }
+    assert.bool(self.useVminfod, 'self.useVminfod');
+
     // This is used to try to avoid emitting the same event twice when just
     // noticed by different watchers. How it works is that when we see an update
     // via the updateVm() function, the watcher passes us a list of properties
@@ -124,24 +131,31 @@ function VmWatcher(opts) {
     // the same change.
     self.knownVms = {};
 
-    self.fsWatcher = new FsWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('fs')
-    });
+    if (self.useVminfod) {
+        self.vminfodVmWatcher = new VminfodVmWatcher({
+            log: opts.log,
+            updateVm: self.newUpdateHandler('vminfod')
+        });
+    } else {
+        self.fsWatcher = new FsWatcher({
+            log: opts.log,
+            updateVm: self.newUpdateHandler('fs')
+        });
 
-    self.zoneeventWatcher = new ZoneeventWatcher({
-        log: opts.log,
-        updateVm: self.newUpdateHandler('zoneevent')
-    });
+        self.zoneeventWatcher = new ZoneeventWatcher({
+            log: opts.log,
+            updateVm: self.newUpdateHandler('zoneevent')
+        });
 
-    // FUTURE: If someone only wants last_modified, we can avoid starting up the
-    // periodic watcher?
+        // FUTURE: If someone only wants last_modified, we can avoid starting
+        // up the periodic watcher?
 
-    self.periodicWatcher = new PeriodicWatcher({
-        log: opts.log,
-        periodicInterval: opts.periodicInterval, // might be undefined
-        updateVm: self.newUpdateHandler('periodic')
-    });
+        self.periodicWatcher = new PeriodicWatcher({
+            log: opts.log,
+            periodicInterval: opts.periodicInterval, // might be undefined
+            updateVm: self.newUpdateHandler('periodic')
+        });
+    }
 }
 util.inherits(VmWatcher, EventEmitter);
 
@@ -354,27 +368,43 @@ VmWatcher.prototype.newUpdateHandler = function newUpdateHandler(watcher) {
     });
 };
 
-VmWatcher.prototype.start = function start() {
+VmWatcher.prototype.start = function start(cb) {
     var self = this;
 
-    self.fsWatcher.start();
-    self.periodicWatcher.start();
-    self.zoneeventWatcher.start();
-    // ... other watchers
+    assert.optionalFunc(cb, 'cb');
+
+    self.log.debug({vminfod: self.useVminfod}, 'Starting VmWatcher');
+
+    if (self.useVminfod) {
+        self.vminfodVmWatcher.start(cb);
+    } else {
+        self.fsWatcher.start();
+        self.periodicWatcher.start();
+        self.zoneeventWatcher.start();
+        if (cb) {
+            cb();
+            return;
+        }
+    }
 };
 
 VmWatcher.prototype.stop = function stop(opts) {
     var self = this;
     var keepListeners = false;
 
+    self.log.debug({vminfod: self.useVminfod}, 'Stopping VmWatcher');
+
     if (opts && opts.keepListeners) {
         keepListeners = true;
     }
 
-    self.fsWatcher.stop();
-    self.periodicWatcher.stop();
-    self.zoneeventWatcher.stop();
-    // ... other watchers
+    if (self.useVminfod) {
+        self.vminfodVmWatcher.stop();
+    } else {
+        self.fsWatcher.stop();
+        self.periodicWatcher.stop();
+        self.zoneeventWatcher.stop();
+    }
 
     if (!keepListeners) {
         self.removeAllListeners();
diff --git a/lib/watchers/vminfod-vm-watcher.js b/lib/watchers/vminfod-vm-watcher.js
new file mode 100644
index 0000000..d0b6206
--- /dev/null
+++ b/lib/watchers/vminfod-vm-watcher.js
@@ -0,0 +1,82 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+
+var vminfod;
+var VMINFOD_AVAILABLE;
+
+try {
+    /* eslint-disable */
+    vminfod = require('/usr/vm/node_modules/vminfod/client');
+    /* eslint-enable */
+    VMINFOD_AVAILABLE = true;
+} catch (e) {
+    VMINFOD_AVAILABLE = false;
+}
+
+function VminfodVmWatcher(opts) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.func(opts.updateVm, 'opts.updateVm');
+
+    self.log = opts.log.child({watcher: 'vminfo-vm-watcher'});
+    self.updateVm = opts.updateVm;
+}
+
+VminfodVmWatcher.prototype.start = function start(cb) {
+    var self = this;
+
+    assert.optionalFunc(cb, 'cb');
+    assert(!self.vminfodWatcher, 'watcher already created');
+
+    self.vminfodWatcher = new vminfod.VminfodWatcher({
+        name: 'VM Agent - VminfodVMWatcher',
+        log: self.log
+    });
+
+    self.vminfodWatcher.on('create', function vmOnCreate(ev) {
+        assert.uuid(ev.zonename, 'ev.zonename');
+        assert.object(ev.vm, 'ev.vm');
+        self.updateVm(ev.zonename, 'create', ev.vm);
+    });
+    self.vminfodWatcher.on('modify', function vmOnModify(ev) {
+        assert.uuid(ev.zonename, 'ev.zonename');
+        assert.object(ev.vm, 'ev.vm');
+        self.updateVm(ev.zonename, 'modify', ev.vm);
+    });
+    self.vminfodWatcher.on('delete', function vmOnDelete(ev) {
+        assert.uuid(ev.zonename, 'ev.zonename');
+        self.updateVm(ev.zonename, 'delete', {});
+    });
+
+    self.vminfodWatcher.once('ready', function vmOnReady() {
+        if (cb) {
+            cb();
+            return;
+        }
+    });
+};
+
+VminfodVmWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    if (self.vminfodWatcher) {
+        self.vminfodWatcher.stop();
+        delete self.vminfodWatcher;
+    }
+};
+
+VminfodVmWatcher.FIELDS = [];
+VminfodVmWatcher.VMINFOD_AVAILABLE = VMINFOD_AVAILABLE;
+
+module.exports = VminfodVmWatcher;
diff --git a/tests/mocks.js b/tests/mocks.js
index 7db4304..005af95 100644
--- a/tests/mocks.js
+++ b/tests/mocks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var util = require('util');
@@ -344,8 +344,12 @@ function fakeVmWatcher() {
 }
 util.inherits(fakeVmWatcher, EventEmitter);
 
-fakeVmWatcher.prototype.start = function start() {
+fakeVmWatcher.prototype.start = function start(cb) {
     // console.error('vmwatcher.start');
+    if (cb) {
+        cb();
+        return;
+    }
 };
 
 fakeVmWatcher.prototype.stop = function stop() {
diff --git a/tests/test.VmAgentRealVmadm.js b/tests/test.VmAgentRealVmadm.js
index 253410a..a4da6d2 100644
--- a/tests/test.VmAgentRealVmadm.js
+++ b/tests/test.VmAgentRealVmadm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var execFile = require('child_process').execFile;
@@ -678,11 +678,6 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -706,6 +701,11 @@ test('Real vmadm, fake VMAPI: validate DNI', function _test(t) {
                     cb();
                 }
             );
+
+            // start VmAgent
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _removeDNI(arg, cb) {
             // when we remove the DNI flag, the VM should show up at VMAPI
             performThenWait(function _performRemoveDNI(next) {
@@ -885,11 +885,6 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                 }
                 cb(err);
             });
-        }, function _startVmAgent(arg, cb) {
-            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
-            cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             // Wait for VmAgent init and it'll send the initial PUT /vms, these
             // are real VMs on the node because we're not faking vmadm.
@@ -901,6 +896,10 @@ test('Real vmadm, fake VMAPI: new DNI VM', function _test(t) {
                     cb();
                 }
             );
+
+            t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
+            vmAgent = new VmAgent(config);
+            vmAgent.start();
         }, function _createDoNotInventoryVm2(arg, cb) {
             // creating a VM with DNI should not result in an update.
             vmadm.create(payload2, function _vmadmCreateCb(err, info) {
@@ -987,7 +986,7 @@ test('VmAgent works after initial errors', function _test(t) {
     var vmapiPutErr;
 
     vasync.pipeline({arg: {}, funcs: [
-        function _startVmAgent(arg, cb) {
+        function _createSimulatedErrors(arg, cb) {
             // simulate connection refused
             vmapiGetErr = new Error('Connection Refused');
             vmapiGetErr.code = 'ECONNREFUSED';
@@ -1002,121 +1001,113 @@ test('VmAgent works after initial errors', function _test(t) {
             mocks.Vmapi.setPutError(vmapiPutErr);
 
             t.ok(config.server_uuid, 'new CN ' + config.server_uuid);
-            vmAgent = new VmAgent(config);
-            vmAgent.start();
             cb();
         }, function _waitInitialUpdateVms(arg, cb) {
             var seenGetAttempts = 0;
             var seenPutAttempts = 0;
+
             // VmAgent should be initializing itself and it'll send the initial
             // GET /vms, which will fail. We'll allow it to fail resolveAfter
             // times and then remove the error. Then we should see the PUT /vms
             // at which point we'll fail that resolveAfter times and then move
             // on.
+            vasync.parallel({funcs: [
+                function _vmapiUpdateServerVms(cb2) {
+                    coordinator.on('vmapi.updateServerVms',
+                        function _onUpdateVms(vmobjs, server_uuid, err) {
+                            var keys = Object.keys(vmobjs);
+
+                            seenPutAttempts++;
+                            t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
+                                + seenPutAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
+
+                            if (seenPutAttempts === resolveAfter) {
+                                mocks.Vmapi.setPutError(null);
+                                cb2();
+                                return;
+                            }
+                        }
+                    );
 
-            coordinator.on('vmapi.updateServerVms',
-                function _onUpdateVms(vmobjs, server_uuid, err) {
-                    var keys = Object.keys(vmobjs);
-
-                    seenPutAttempts++;
-                    t.ok(true, 'saw PUT /vms: (' + keys.length + ') ['
-                        + seenPutAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenPutAttempts === resolveAfter) {
-                        mocks.Vmapi.setPutError(null);
-                        cb();
-                        return;
-                    }
-                }
-            );
+                    coordinator.on('vmapi.getVms',
+                        function _onVmapiGetVms(server_uuid, err) {
+                            seenGetAttempts++;
+                            t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
+                                + (err ? ' -- ' + err.code : ''));
 
-            coordinator.on('vmapi.getVms',
-                function _onVmapiGetVms(server_uuid, err) {
-                    seenGetAttempts++;
-                    t.ok(true, 'saw GET /vms [' + seenGetAttempts + ']'
-                        + (err ? ' -- ' + err.code : ''));
-                    if (seenGetAttempts >= resolveAfter) {
-                        mocks.Vmapi.setGetError(null);
-                    }
+                            if (seenGetAttempts >= resolveAfter) {
+                                mocks.Vmapi.setGetError(null);
+                            }
+                        }
+                    );
+                }, function _startVmAgent(cb2) {
+                    vmAgent = new VmAgent(config);
+                    vmAgent.start(cb2);
                 }
-            );
+            ]}, cb);
         }, function _createVm(arg, cb) {
             // now that init is complete, create a VM and make sure we see an
             // update.
 
             payload.log = config.log;
 
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                coordinator.removeAllListeners('vmapi.updateVm');
-                t.ok(true, 'VMAPI saw update for new VM.');
-                cb();
-            });
-
-            vmadm.create(payload, function _vmadmCreateCb(err, info) {
-                t.ifError(err, 'create VM');
-                if (!err && info) {
-                    t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
-                        + info.uuid);
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            coordinator.removeAllListeners('vmapi.updateVm');
+                            t.ok(true, 'VMAPI saw update for new VM.');
+                            cb2();
+                        }
+                    );
+                }, function _vmadmCreate(cb2) {
+                    vmadm.create(payload, function _vmadmCreateCb(err, info) {
+                        t.ifError(err, 'create VM');
+                        if (!err && info) {
+                            t.equal(info.uuid, payload.uuid, 'new VM has uuid: '
+                                + info.uuid);
+                        }
+                        cb2();
+                    });
                 }
-            });
+            ]}, cb);
         }, function _deleteVm(arg, cb) {
-            coordinator.on('vmapi.updateVm', function _onVmapiUpdateVm(vmobj) {
-                if (vmobj.uuid !== payload.uuid) {
-                    // ignore changes that are from other VMs on this system
-                    return;
-                }
-                if (vmobj.state === 'destroyed'
-                    && vmobj.zone_state === 'destroyed') {
-                    // when we see destroyed, we'll move on
-                    t.ok(true, 'VMAPI saw destroy for VM');
-                    coordinator.removeAllListeners('vmapi.updateVm');
-                    cb();
-                    return;
-                }
-            });
-
-            vmadm.delete({log: config.log, uuid: payload.uuid},
-                function _vmadmDeleteCb(err) {
-                    t.ifError(err, 'delete VM: '
-                        + (err ? err.message : 'success'));
-                }
-            );
-        }, function _checkZoneeventChildren(arg, cb) {
-            execFile('/usr/bin/ptree', [process.pid],
-                function _scanPtree(err, stdout /* , stderr */) {
-                    var zoneevent_children = [];
-
-                    if (!err) {
-                        stdout.split('\n').forEach(function _onLine(line) {
-                            var proc = line.trim().match(/(\d+)\s+(.*)$/);
-
-                            /* eslint-disable no-magic-numbers */
-                            if (proc && proc[2]
-                                && proc[2] === '/usr/vm/sbin/zoneevent') {
-                                // track PIDs so we can kill them
-                                zoneevent_children.push(proc[1]);
+            vasync.parallel({funcs: [
+                function _vmapiUpdateVmListener(cb2) {
+                    coordinator.on('vmapi.updateVm',
+                        function _onVmapiUpdateVm(vmobj) {
+                            if (vmobj.uuid !== payload.uuid) {
+                                // ignore changes that are from other VMs on
+                                // this system
+                                return;
+                            }
+                            if (vmobj.state === 'destroyed'
+                                && vmobj.zone_state === 'destroyed') {
+                                // when we see destroyed, we'll move on
+                                t.ok(true, 'VMAPI saw destroy for VM');
+                                coordinator.removeAllListeners(
+                                    'vmapi.updateVm');
+                                cb2();
+                                return;
                             }
-
-                            /* eslint-enable no-magic-numbers */
-                        });
-
-                        t.equal(zoneevent_children.length, 1,
-                            'should have one zoneevent child');
-
-                        if (zoneevent_children.length > 1) {
-                            zoneevent_children.forEach(function _killPid(pid) {
-                                t.ok(true, 'killing extra zoneevent ' + pid);
-                                process.kill(pid, 'SIGKILL');
-                            });
                         }
-                    }
-                    cb(err);
+                    );
+                }, function _vmadmDelete(cb2) {
+                    vmadm.delete({log: config.log, uuid: payload.uuid},
+                        function _vmadmDeleteCb(err) {
+                            t.ifError(err, 'delete VM: '
+                                + (err ? err.message : 'success'));
+                            cb2();
+                        }
+                    );
                 }
-            );
+            ]}, cb);
         }
     ]}, function _pipelineComplete(err) {
         t.ifError(err, 'pipeline complete');
-- 
2.21.0

