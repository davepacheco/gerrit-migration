commit 3ae0aaf710f827196203fd0037c28a96dc344894 (refs/changes/49/549/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2016-09-29T22:02:52+00:00 (3 years ago)
    
    MORAY-364 Want a better filter parser for Moray

diff --git a/CHANGES.md b/CHANGES.md
index 41f7f15..e152693 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,4 +1,12 @@
-# ldap-filter Changelog
+# moray-filter Changelog
+
+## 1.0.0
+
+- Initial release after forking from
+  [ldap-filter](https://github.com/pfmooney/node-ldap-filter) v0.3.3,
+  and adding back in behaviour from v0.2.0 that Moray clients expect.
+
+# ldap-filter Changelog (pre-fork)
 
 ## 0.3.3
 
diff --git a/README.md b/README.md
index 359337b..d804e21 100644
--- a/README.md
+++ b/README.md
@@ -1,9 +1,28 @@
-# ldap-filter
+<!--
+    Copyright (c) 2016, Joyent, Inc.
+-->
 
-API for handling LDAP-style filters
+# moray-filter
 
-Originally derived from the filter code in
-[LDAPjs](https://github.com/mcavage/node-ldapjs)
+This repository is part of the Joyent Triton and Joyent Manta projects. See the
+[Triton](https://github.com/joyent/triton/blob/master/CONTRIBUTING.md) and
+[Manta](https://github.com/joyent/manta/blob/master/CONTRIBUTING.md)
+contributing guidelines and general documentation at the main [Triton]
+(https://github.com/joyent/triton) and [Manta](http://github.com/joyent/manta)
+project pages. *Do not use GitHub PRs*.
+
+## Overview
+
+API for handling Moray-style filters, which are similar to LDAP filters, but
+with several differences:
+
+- Allow escaping `(`, `)`, `\`, `=`, and `*` with a backslash (`\`).
+- Don't require parentheses around a not (`!`) filter.
+
+This project is a fork of
+[ldap-filter](https://github.com/pfmooney/node-ldap-filter), which
+was originally derived from the filter code in
+[LDAPjs](https://github.com/mcavage/node-ldapjs).
 
 ## License
 
diff --git a/lib/helpers.js b/lib/helpers.js
index 025c735..9cdf02b 100644
--- a/lib/helpers.js
+++ b/lib/helpers.js
@@ -1,5 +1,6 @@
 // Copyright 2014 Mark Cavage, Inc.  All rights reserved.
 // Copyright 2014 Patrick Mooney.  All rights reserved.
+// Copyright 2016 Joyent, Inc.
 
 var assert = require('assert-plus');
 
@@ -7,16 +8,20 @@ var assert = require('assert-plus');
 ///--- API
 
 /**
- * RFC 2254 Escaping of filter strings
+ * Moray Escaping of filter strings
  *
  * Raw                     Escaped
- * (o=Parens (R Us))       (o=Parens \28R Us\29)
- * (cn=star*)              (cn=star\2A)
- * (filename=C:\MyFile)    (filename=C:\5cMyFile)
+ * (o=Parens (R Us))       (o=Parens \(R Us\))
+ * (cn=star*)              (cn=star\*)
+ * (filename=C:\MyFile)    (filename=C:\\MyFile)
  *
  * Use substr_filter to avoid having * ecsaped.
  *
- * @author [Austin King](https://github.com/ozten)
+ * In addition to escaping the characters laid out in section 4 of RFC 2254,
+ * we also escape '=' to work around parsing bugs in old Moray instances. We
+ * skip escaping the NUL character in the string, since old Moray instances
+ * don't have a way to parse their escaped versions. (NUL characters can
+ * still be used, though.)
  */
 function _escape(inp) {
   var esc = '';
@@ -25,19 +30,19 @@ function _escape(inp) {
     for (i = 0; i < inp.length; i++) {
       switch (inp[i]) {
         case '*':
-          esc += '\\2a';
+          esc += '\\*';
           break;
         case '(':
-          esc += '\\28';
+          esc += '\\(';
           break;
         case ')':
-          esc += '\\29';
+          esc += '\\)';
           break;
         case '\\':
-          esc += '\\5c';
+          esc += '\\\\';
           break;
-        case '\0':
-          esc += '\\00';
+        case '=':
+          esc += '\\=';
           break;
         default:
           esc += inp[i];
diff --git a/lib/index.js b/lib/index.js
index 076c937..0956af5 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -23,10 +23,25 @@ var SubstringFilter = require('./substr_filter');
 /* JSSTYLED */
 var attrRegex = /^[-_a-zA-Z0-9]+/;
 var hexRegex = /^[a-fA-F0-9]{2}$/;
+var morayChars = [ '(', ')', '*', '\\', '=' ];
 
 
 ///--- Internal
 
+function indexOfSkipEscapes(str, start, c)
+{
+  var len = str.length;
+  for (var end = start; end < len; end++) {
+    if (str[end] === '\\') {
+      end++;
+    } else if (str[end] === c) {
+      return end;
+    }
+  }
+
+  return -1;
+}
+
 function escapeValue(str)
 {
   var cur = 0;
@@ -52,10 +67,15 @@ function escapeValue(str)
       /* Parse a \XX hex escape value */
       var val = str.substr(cur + 1, 2);
       if (val.match(hexRegex) === null) {
-        throw new Error('invalid escaped char');
+        if (morayChars.indexOf(val[0]) === -1) {
+            throw new Error('invalid escape sequence: "\\' + val + '"');
+        }
+        out += val[0];
+        cur += 2;
+      } else {
+        out += String.fromCharCode(parseInt(val, 16));
+        cur += 3;
       }
-      out += String.fromCharCode(parseInt(val, 16));
-      cur += 3;
       break;
 
     default:
@@ -71,8 +91,17 @@ function escapeValue(str)
 
 function escapeSubstr(str)
 {
-  var fields = str.split('*');
+  var fields = [];
   var out = {};
+  var idx;
+
+  while ((idx = indexOfSkipEscapes(str, 0, '*')) !== -1) {
+    fields.push(str.substring(0, idx));
+    str = str.substring(idx + 1);
+  }
+
+  fields.push(str);
+
   assert.ok(fields.length > 1, 'wildcard missing');
 
   out.initial = escapeValue(fields.shift());
@@ -119,7 +148,7 @@ function parseExt(attr, str)
    * between '*' characters which are not escaped and any which are, we attempt
    * substring-style parsing on any value which contains the former.
    */
-  if (str.indexOf('*') !== -1) {
+  if (indexOfSkipEscapes(str, 0, '*') !== -1) {
     var subres = escapeSubstr(str);
     out.initial = subres.initial;
     out.any = subres.any;
@@ -153,7 +182,7 @@ function parseExpr(str)
     });
   } else if (remain[0] === '=') {
     remain = remain.substr(1);
-    if (remain.indexOf('*') !== -1) {
+    if (indexOfSkipEscapes(remain, 0, '*') !== -1) {
       var val = escapeSubstr(remain);
       return new SubstringFilter({
         attribute: attr,
@@ -190,12 +219,20 @@ function parseExpr(str)
 
 function parseFilter(str, start)
 {
+  var unwrappedbang = false;
   var cur = start;
   var len = str.length;
   var res, end, output, children = [];
 
-  if (str[cur++] !== '(') {
-      throw new Error('missing paren');
+  switch (str[cur]) {
+  case '(':
+    cur++;
+    break;
+  case '!':
+    unwrappedbang = true;
+    break;
+  default:
+    throw new Error('expected \'(\', but found \'' + str[cur] + '\'');
   }
 
   if (str[cur] === '&') {
@@ -219,10 +256,14 @@ function parseFilter(str, start)
   } else if (str[cur] === '!') {
     res = parseFilter(str, cur + 1);
     output = new NotFilter({filter: res.filter});
-    cur = res.end + 1;
-    assert.equal(str[cur], ')', 'unbalanced parens');
+    if (unwrappedbang) {
+      cur = res.end;
+    } else {
+      cur = res.end + 1;
+      assert.equal(str[cur], ')', 'unbalanced parens');
+    }
   } else {
-    end = str.indexOf(')', cur);
+    end = indexOfSkipEscapes(str, cur, ')');
     assert.notEqual(end, -1, 'unbalanced parens');
 
     output = parseExpr(str.substr(cur, end - cur));
diff --git a/package.json b/package.json
index 12cc8da..0a40e19 100644
--- a/package.json
+++ b/package.json
@@ -4,14 +4,15 @@
     "Mark Cavage <mcavage@gmail.com>",
     "Cody Peter Mello <cody.mello@joyent.com>"
   ],
-  "name": "ldap-filter",
-  "homepage": "http://ldapjs.org",
-  "description": "API for handling LDAP-style filters",
-  "version": "0.3.3",
+  "name": "moray-filter",
+  "homepage": "https://github.com/joyent/node-moray-filter",
+  "description": "API for handling Moray-style filters",
+  "keywords": [ "moray" ],
+  "version": "1.0.0",
   "license": "MIT",
   "repository": {
     "type": "git",
-    "url": "git://github.com/pfmooney/node-ldap-filter.git"
+    "url": "https://github.com/joyent/node-moray-filter.git"
   },
   "main": "lib/index.js",
   "directories": {
diff --git a/test/approx.test.js b/test/approx.test.js
index 0f41750..2c9183d 100644
--- a/test/approx.test.js
+++ b/test/approx.test.js
@@ -56,7 +56,7 @@ test('escape value only in toString()', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'ba(r)');
-  t.equal(f.toString(), '(foo~=ba\\28r\\29)');
+  t.equal(f.toString(), '(foo~=ba\\(r\\))');
   t.end();
 });
 
diff --git a/test/eq.test.js b/test/eq.test.js
index c5ec8b5..1cb2bbe 100644
--- a/test/eq.test.js
+++ b/test/eq.test.js
@@ -85,7 +85,7 @@ test('escape value only in toString()', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'ba(r)');
-  t.equal(f.toString(), '(foo=ba\\28r\\29)');
+  t.equal(f.toString(), '(foo=ba\\(r\\))');
   t.end();
 });
 
@@ -131,16 +131,16 @@ test('escape EqualityFilter inputs', function (t) {
 
   t.equal(f.attribute, '(|(foo');
   t.equal(f.value, 'bar))(');
-  t.equal(f.toString(), '(\\28|\\28foo=bar\\29\\29\\28)');
+  t.equal(f.toString(), '(\\(|\\(foo=bar\\)\\)\\()');
 
   f.value = new Buffer([97, 115, 100, 102, 41, 40, 0, 255]);
-  t.equal(f.toString(), '(\\28|\\28foo=\\61\\73\\64\\66\\29\\28\\00\\ff)');
+  t.equal(f.toString(), '(\\(|\\(foo=\\61\\73\\64\\66\\29\\28\\00\\ff)');
 
   f.value = new Buffer([195, 40]);
-  t.equal(f.toString(), '(\\28|\\28foo=\\c3\\28)');
+  t.equal(f.toString(), '(\\(|\\(foo=\\c3\\28)');
 
   f.value = new Buffer([195, 177]);
-  t.equal(f.toString(), '(\\28|\\28foo=ñ)');
+  t.equal(f.toString(), '(\\(|\\(foo=ñ)');
   t.end();
 });
 
diff --git a/test/ge.test.js b/test/ge.test.js
index c9ee976..1d4d162 100644
--- a/test/ge.test.js
+++ b/test/ge.test.js
@@ -56,7 +56,7 @@ test('escape value only in toString()', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'ba(r)');
-  t.equal(f.toString(), '(foo>=ba\\28r\\29)');
+  t.equal(f.toString(), '(foo>=ba\\(r\\))');
   t.end();
 });
 
diff --git a/test/le.test.js b/test/le.test.js
index 97a4bad..de945ca 100644
--- a/test/le.test.js
+++ b/test/le.test.js
@@ -56,7 +56,7 @@ test('escape value only in toString()', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'ba(r)');
-  t.equal(f.toString(), '(foo<=ba\\28r\\29)');
+  t.equal(f.toString(), '(foo<=ba\\(r\\))');
   t.end();
 });
 
diff --git a/test/parse.test.js b/test/parse.test.js
index dc48c7f..618a09d 100644
--- a/test/parse.test.js
+++ b/test/parse.test.js
@@ -44,8 +44,23 @@ test('= in filter', function (t) {
   t.equal(f.value,
     'uuid=930896af-bf8c-48d4-885c-6573a94b1853, ou=users, o=smartdc');
   t.equal(f.toString(),
-    '(uniquemember=uuid=930896af-bf8c-48d4-885c-6573a94b1853, ' +
-    'ou=users, o=smartdc)');
+    '(uniquemember=uuid\\=930896af-bf8c-48d4-885c-6573a94b1853, ' +
+    'ou\\=users, o\\=smartdc)');
+  t.end();
+});
+
+
+test('\\= in filter', function (t) {
+  var str = '(uniquemember=uuid\\=930896af-bf8c-48d4-885c-6573a94b1853, ' +
+    'ou\\=users, o\\=smartdc)';
+  var f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'uniquemember');
+  t.equal(f.value,
+    'uuid=930896af-bf8c-48d4-885c-6573a94b1853, ou=users, o=smartdc');
+  t.equal(f.toString(),
+    '(uniquemember=uuid\\=930896af-bf8c-48d4-885c-6573a94b1853, ' +
+    'ou\\=users, o\\=smartdc)');
   t.end();
 });
 
@@ -56,7 +71,15 @@ test('( in filter', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'bar(');
-  t.equal(f.toString(), '(foo=bar\\28)');
+  t.equal(f.toString(), '(foo=bar\\()');
+
+  str = 'foo=bar\\(';
+  f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'foo');
+  t.equal(f.value, 'bar(');
+  t.equal(f.toString(), '(foo=bar\\()');
+
   t.end();
 });
 
@@ -67,7 +90,15 @@ test(') in filter', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'bar)');
-  t.equal(f.toString(), '(foo=bar\\29)');
+  t.equal(f.toString(), '(foo=bar\\))');
+
+  str = '(foo=bar\\))';
+  f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'foo');
+  t.equal(f.value, 'bar)');
+  t.equal(f.toString(), '(foo=bar\\))');
+
   t.end();
 });
 
@@ -78,10 +109,15 @@ test('() in filter', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foobar');
   t.equal(f.value, 'baz()');
-  t.equal(f.toString(), '(foobar=baz\\28\\29)');
-  console.log(f.toString());
-  var f2 = parse(f.toString());
-  t.equal(f.toString(), f2.toString());
+  t.equal(f.toString(), '(foobar=baz\\(\\))');
+
+  str = 'foobar=baz\\(\\)';
+  f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'foobar');
+  t.equal(f.value, 'baz()');
+  t.equal(f.toString(), '(foobar=baz\\(\\))');
+
   t.end();
 });
 
@@ -92,7 +128,15 @@ test(')( in filter', function (t) {
   t.ok(f);
   t.equal(f.attribute, 'foobar');
   t.equal(f.value, 'baz)(');
-  t.equal(f.toString(), '(foobar=baz\\29\\28)');
+  t.equal(f.toString(), '(foobar=baz\\)\\()');
+
+  str = 'foobar=baz\\)\\(';
+  f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'foobar');
+  t.equal(f.value, 'baz)(');
+  t.equal(f.toString(), '(foobar=baz\\)\\()');
+
   t.end();
 });
 
@@ -210,29 +254,67 @@ test('literal \\ in filter', function (t) {
   var v2 = '\\bar\\baz\\';
   var v3 = '\\';
   checkFilters(t, [
-    { str: '(foo=bar\\5c)', type: 'equal', val: v1, output: '(foo=bar\\5c)' },
-    { str: '(foo<=bar\\5c)', type: 'le', val: v1, output: '(foo<=bar\\5c)' },
-    { str: '(foo>=bar\\5c)', type: 'ge', val: v1, output: '(foo>=bar\\5c)' },
+    { str: '(foo=bar\\5c)', type: 'equal', val: v1, output: '(foo=bar\\\\)' },
+    { str: '(foo<=bar\\5c)', type: 'le', val: v1, output: '(foo<=bar\\\\)' },
+    { str: '(foo>=bar\\5c)', type: 'ge', val: v1, output: '(foo>=bar\\\\)' },
+    { str: '(foo=bar\\\\)', type: 'equal', val: v1, output: '(foo=bar\\\\)' },
+    { str: '(foo<=bar\\\\)', type: 'le', val: v1, output: '(foo<=bar\\\\)' },
+    { str: '(foo>=bar\\\\)', type: 'ge', val: v1, output: '(foo>=bar\\\\)' },
     { str: '(foo=\\5cbar\\5cbaz\\5c)', type: 'equal', val: v2,
-      output: '(foo=\\5cbar\\5cbaz\\5c)' },
+      output: '(foo=\\\\bar\\\\baz\\\\)' },
     { str: '(foo>=\\5cbar\\5cbaz\\5c)', type: 'ge', val: v2,
-      output: '(foo>=\\5cbar\\5cbaz\\5c)' },
+      output: '(foo>=\\\\bar\\\\baz\\\\)' },
     { str: '(foo<=\\5cbar\\5cbaz\\5c)', type: 'le', val: v2,
-      output: '(foo<=\\5cbar\\5cbaz\\5c)' },
-    { str: '(foo=\\5c)', type: 'equal', val: v3, output: '(foo=\\5c)' },
-    { str: '(foo<=\\5c)', type: 'le', val: v3, output: '(foo<=\\5c)' },
-    { str: '(foo>=\\5c)', type: 'ge', val: v3, output: '(foo>=\\5c)' }
+      output: '(foo<=\\\\bar\\\\baz\\\\)' },
+    { str: '(foo=\\\\bar\\\\baz\\\\)', type: 'equal', val: v2,
+      output: '(foo=\\\\bar\\\\baz\\\\)' },
+    { str: '(foo>=\\\\bar\\\\baz\\\\)', type: 'ge', val: v2,
+      output: '(foo>=\\\\bar\\\\baz\\\\)' },
+    { str: '(foo<=\\\\bar\\\\baz\\\\)', type: 'le', val: v2,
+      output: '(foo<=\\\\bar\\\\baz\\\\)' },
+    { str: '(foo=\\5c)', type: 'equal', val: v3, output: '(foo=\\\\)' },
+    { str: '(foo<=\\5c)', type: 'le', val: v3, output: '(foo<=\\\\)' },
+    { str: '(foo>=\\5c)', type: 'ge', val: v3, output: '(foo>=\\\\)' },
+    { str: '(foo=\\\\)', type: 'equal', val: v3, output: '(foo=\\\\)' },
+    { str: '(foo<=\\\\)', type: 'le', val: v3, output: '(foo<=\\\\)' },
+    { str: '(foo>=\\\\)', type: 'ge', val: v3, output: '(foo>=\\\\)' }
   ]);
 });
 
 
+test('literal \\ at the end of subfilter', function (t) {
+  var and = parse('(&(foo=\\\\)(zig=\\)))');
+  t.ok(and);
+  t.equal(and.filters.length, 2, 'AndFilter has two parts');
+  t.equal(and.toString(), '(&(foo=\\\\)(zig=\\)))',
+    'Correctly parsed two separate equalities');
+  var or = parse('(|(&(foo=\\(\\\\)(zig=\\())(zag=\\())');
+  t.ok(or);
+  t.equal(or.filters.length, 2);
+  t.equal(or.type, 'or');
+  t.equal(or.filters[0].type, 'and');
+  t.equal(or.filters[0].filters.length, 2);
+  t.equal(or.filters[1].type, 'equal');
+  t.equal(or.toString(), '(|(&(foo=\\(\\\\)(zig=\\())(zag=\\())');
+  t.end();
+});
+
+
 test('\\0 in filter', function (t) {
   var str = '(foo=bar\\00)';
   var f = parse(str);
   t.ok(f);
   t.equal(f.attribute, 'foo');
   t.equal(f.value, 'bar\0');
-  t.equal(f.toString(), '(foo=bar\\00)');
+  t.equal(f.toString(), '(foo=bar\0)');
+
+  str = '(foo=bar\0)';
+  f = parse(str);
+  t.ok(f);
+  t.equal(f.attribute, 'foo');
+  t.equal(f.value, 'bar\0');
+  t.equal(f.toString(), '(foo=bar\0)');
+
   t.end();
 });
 
@@ -242,18 +324,30 @@ test('literal * in filters', function (t) {
   var v2 = '*bar*baz*';
   var v3 = '*';
   checkFilters(t, [
-    { str: '(foo=bar\\2a)', type: 'equal', val: v1, output: '(foo=bar\\2a)' },
-    { str: '(foo<=bar\\2a)', type: 'le', val: v1, output: '(foo<=bar\\2a)' },
-    { str: '(foo>=bar\\2a)', type: 'ge', val: v1, output: '(foo>=bar\\2a)' },
+    { str: '(foo=bar\\2a)', type: 'equal', val: v1, output: '(foo=bar\\*)' },
+    { str: '(foo<=bar\\2a)', type: 'le', val: v1, output: '(foo<=bar\\*)' },
+    { str: '(foo>=bar\\2a)', type: 'ge', val: v1, output: '(foo>=bar\\*)' },
+    { str: '(foo=bar\\*)', type: 'equal', val: v1, output: '(foo=bar\\*)' },
+    { str: '(foo<=bar\\*)', type: 'le', val: v1, output: '(foo<=bar\\*)' },
+    { str: '(foo>=bar\\*)', type: 'ge', val: v1, output: '(foo>=bar\\*)' },
     { str: '(foo=\\2abar\\2abaz\\2a)', type: 'equal', val: v2,
-      output: '(foo=\\2abar\\2abaz\\2a)' },
+      output: '(foo=\\*bar\\*baz\\*)' },
     { str: '(foo>=\\2abar\\2abaz\\2a)', type: 'ge', val: v2,
-      output: '(foo>=\\2abar\\2abaz\\2a)' },
+      output: '(foo>=\\*bar\\*baz\\*)' },
     { str: '(foo<=\\2abar\\2abaz\\2a)', type: 'le', val: v2,
-      output: '(foo<=\\2abar\\2abaz\\2a)' },
-    { str: '(foo=\\2a)', type: 'equal', val: v3, output: '(foo=\\2a)' },
-    { str: '(foo<=\\2a)', type: 'le', val: v3, output: '(foo<=\\2a)' },
-    { str: '(foo>=\\2a)', type: 'ge', val: v3, output: '(foo>=\\2a)' }
+      output: '(foo<=\\*bar\\*baz\\*)' },
+    { str: '(foo=\\*bar\\*baz\\*)', type: 'equal', val: v2,
+      output: '(foo=\\*bar\\*baz\\*)' },
+    { str: '(foo>=\\*bar\\*baz\\*)', type: 'ge', val: v2,
+      output: '(foo>=\\*bar\\*baz\\*)' },
+    { str: '(foo<=\\*bar\\*baz\\*)', type: 'le', val: v2,
+      output: '(foo<=\\*bar\\*baz\\*)' },
+    { str: '(foo=\\2a)', type: 'equal', val: v3, output: '(foo=\\*)' },
+    { str: '(foo<=\\2a)', type: 'le', val: v3, output: '(foo<=\\*)' },
+    { str: '(foo>=\\2a)', type: 'ge', val: v3, output: '(foo>=\\*)' },
+    { str: '(foo=\\*)', type: 'equal', val: v3, output: '(foo=\\*)' },
+    { str: '(foo<=\\*)', type: 'le', val: v3, output: '(foo<=\\*)' },
+    { str: '(foo>=\\*)', type: 'ge', val: v3, output: '(foo>=\\*)' }
   ]);
 });
 
@@ -287,7 +381,7 @@ test('* substr filter (suffix)', function (t) {
 
 
 test('escaped * in substr filter (prefix)', function (t) {
-  var str = '(foo=bar\\2a*)';
+  var str = '(foo=bar\\**)';
   var f = parse(str);
   t.ok(f);
   t.equal(f.type, 'substring');
@@ -295,13 +389,13 @@ test('escaped * in substr filter (prefix)', function (t) {
   t.equal(f.initial, 'bar*');
   t.equal(f.any.length, 0);
   t.equal(f.final, '');
-  t.equal(f.toString(), '(foo=bar\\2a*)');
+  t.equal(f.toString(), '(foo=bar\\**)');
   t.end();
 });
 
 
 test('escaped * in substr filter (suffix)', function (t) {
-  var str = '(foo=*bar\\2a)';
+  var str = '(foo=*bar\\*)';
   var f = parse(str);
   t.ok(f);
   t.equal(f.type, 'substring');
@@ -309,7 +403,18 @@ test('escaped * in substr filter (suffix)', function (t) {
   t.equal(f.initial, '');
   t.equal(f.any.length, 0);
   t.equal(f.final, 'bar*');
-  t.equal(f.toString(), '(foo=*bar\\2a)');
+  t.equal(f.toString(), '(foo=*bar\\*)');
+  t.end();
+});
+
+
+test('! subfilter without parens allowed', function (t) {
+  var str = '(&(foo=bar)!(baz=quux)(hello=world))';
+  var f = parse(str);
+  t.ok(f);
+  t.equal(f.type, 'and');
+  t.equal(f.filters.length, 3, 'three subfilters');
+  t.equal(f.toString(), '(&(foo=bar)(!(baz=quux))(hello=world))');
   t.end();
 });
 
@@ -360,37 +465,70 @@ test('approx filter', function (t) {
 
 test('<= in filters', function (t) {
   checkFilters(t, [
-    { str: '(foo=<=)', type: 'equal', val: '<=', output: '(foo=<=)' },
-    { str: '(foo<=<=)', type: 'le', val: '<=', output: '(foo<=<=)' },
-    { str: '(foo>=<=)', type: 'ge', val: '<=', output: '(foo>=<=)' },
+    { str: '(foo=<\\=)', type: 'equal', val: '<=', output: '(foo=<\\=)' },
+    { str: '(foo<=<\\=)', type: 'le', val: '<=', output: '(foo<=<\\=)' },
+    { str: '(foo>=<\\=)', type: 'ge', val: '<=', output: '(foo>=<\\=)' },
+    { str: '(foo=<=)', type: 'equal', val: '<=', output: '(foo=<\\=)' },
+    { str: '(foo<=<=)', type: 'le', val: '<=', output: '(foo<=<\\=)' },
+    { str: '(foo>=<=)', type: 'ge', val: '<=', output: '(foo>=<\\=)' },
+    { str: '(foo=bar<\\=baz)', type: 'equal', val: 'bar<=baz',
+      output: '(foo=bar<\\=baz)' },
+    { str: '(foo<=bar<\\=baz)', type: 'le', val: 'bar<=baz',
+      output: '(foo<=bar<\\=baz)' },
+    { str: '(foo>=bar<\\=baz)', type: 'ge', val: 'bar<=baz',
+      output: '(foo>=bar<\\=baz)' },
     { str: '(foo=bar<=baz)', type: 'equal', val: 'bar<=baz',
-      output: '(foo=bar<=baz)' },
+      output: '(foo=bar<\\=baz)' },
     { str: '(foo<=bar<=baz)', type: 'le', val: 'bar<=baz',
-      output: '(foo<=bar<=baz)' },
+      output: '(foo<=bar<\\=baz)' },
     { str: '(foo>=bar<=baz)', type: 'ge', val: 'bar<=baz',
-      output: '(foo>=bar<=baz)' },
+      output: '(foo>=bar<\\=baz)' },
+    { str: '(foo=bar<\\=)', type: 'equal', val: 'bar<=',
+      output: '(foo=bar<\\=)' },
+    { str: '(foo<=bar<\\=)', type: 'le', val: 'bar<=',
+      output: '(foo<=bar<\\=)' },
+    { str: '(foo>=bar<\\=)', type: 'ge', val: 'bar<=',
+      output: '(foo>=bar<\\=)' },
     { str: '(foo=bar<=)', type: 'equal', val: 'bar<=',
-      output: '(foo=bar<=)' },
-    { str: '(foo<=bar<=)', type: 'le', val: 'bar<=', output: '(foo<=bar<=)' },
-    { str: '(foo>=bar<=)', type: 'ge', val: 'bar<=', output: '(foo>=bar<=)' }
+      output: '(foo=bar<\\=)' },
+    { str: '(foo<=bar<=)', type: 'le', val: 'bar<=',
+      output: '(foo<=bar<\\=)' },
+    { str: '(foo>=bar<=)', type: 'ge', val: 'bar<=',
+      output: '(foo>=bar<\\=)' }
   ]);
 });
 
 
 test('>= in filters', function (t) {
   checkFilters(t, [
-    { str: '(foo=>=)', type: 'equal', val: '>=', output: '(foo=>=)' },
-    { str: '(foo<=>=)', type: 'le', val: '>=', output: '(foo<=>=)' },
-    { str: '(foo>=>=)', type: 'ge', val: '>=', output: '(foo>=>=)' },
+    { str: '(foo=>\\=)', type: 'equal', val: '>=', output: '(foo=>\\=)' },
+    { str: '(foo<=>\\=)', type: 'le', val: '>=', output: '(foo<=>\\=)' },
+    { str: '(foo>=>\\=)', type: 'ge', val: '>=', output: '(foo>=>\\=)' },
+    { str: '(foo=>=)', type: 'equal', val: '>=', output: '(foo=>\\=)' },
+    { str: '(foo<=>=)', type: 'le', val: '>=', output: '(foo<=>\\=)' },
+    { str: '(foo>=>=)', type: 'ge', val: '>=', output: '(foo>=>\\=)' },
+    { str: '(foo=bar>\\=baz)', type: 'equal', val: 'bar>=baz',
+      output: '(foo=bar>\\=baz)' },
+    { str: '(foo<=bar>\\=baz)', type: 'le', val: 'bar>=baz',
+      output: '(foo<=bar>\\=baz)' },
+    { str: '(foo>=bar>\\=baz)', type: 'ge', val: 'bar>=baz',
+      output: '(foo>=bar>\\=baz)' },
     { str: '(foo=bar>=baz)', type: 'equal', val: 'bar>=baz',
-      output: '(foo=bar>=baz)' },
+      output: '(foo=bar>\\=baz)' },
     { str: '(foo<=bar>=baz)', type: 'le', val: 'bar>=baz',
-      output: '(foo<=bar>=baz)' },
+      output: '(foo<=bar>\\=baz)' },
     { str: '(foo>=bar>=baz)', type: 'ge', val: 'bar>=baz',
-      output: '(foo>=bar>=baz)' },
-    { str: '(foo=bar>=)', type: 'equal', val: 'bar>=', output: '(foo=bar>=)' },
-    { str: '(foo<=bar>=)', type: 'le', val: 'bar>=', output: '(foo<=bar>=)' },
-    { str: '(foo>=bar>=)', type: 'ge', val: 'bar>=', output: '(foo>=bar>=)' }
+      output: '(foo>=bar>\\=baz)' },
+    { str: '(foo=bar>\\=)', type: 'equal', val: 'bar>=',
+      output: '(foo=bar>\\=)' },
+    { str: '(foo<=bar>\\=)', type: 'le', val: 'bar>=',
+      output: '(foo<=bar>\\=)' },
+    { str: '(foo>=bar>\\=)', type: 'ge', val: 'bar>=',
+      output: '(foo>=bar>\\=)' },
+    { str: '(foo=bar>=)', type: 'equal', val: 'bar>=',
+      output: '(foo=bar>\\=)' },
+    { str: '(foo<=bar>=)', type: 'le', val: 'bar>=', output: '(foo<=bar>\\=)' },
+    { str: '(foo>=bar>=)', type: 'ge', val: 'bar>=', output: '(foo>=bar>\\=)' }
   ]);
 });
 
@@ -525,6 +663,10 @@ test('mismatched parens', function (t) {
     parse('(foo=1');
   }, 'missing last paren');
 
+  t.throws(function () {
+    parse('(foo=1\\)');
+  }, 'missing last paren');
+
   t.throws(function () {
     parse('(foo=1\\29');
   }, 'missing last paren');
@@ -558,10 +700,6 @@ test('garbage in subfilter not allowed', function (t) {
     parse('(&(foo=bar)|(baz=quux)(hello=world))');
   }, '| subfilter without parens not allowed');
 
-  t.throws(function () {
-    parse('(&(foo=bar)!(baz=quux)(hello=world))');
-  }, '! subfilter without parens not allowed');
-
   t.throws(function () {
     parse('(&(foo=bar)&(baz=quux)(hello=world))');
   }, '& subfilter without parens not allowed');
diff --git a/test/presence.test.js b/test/presence.test.js
index e189f8c..330a9d0 100644
--- a/test/presence.test.js
+++ b/test/presence.test.js
@@ -50,7 +50,7 @@ test('escape value only in toString()', function (t) {
   });
   t.ok(f);
   t.equal(f.attribute, 'fo)o');
-  t.equal(f.toString(), '(fo\\29o=*)');
+  t.equal(f.toString(), '(fo\\)o=*)');
   t.end();
 });
 
diff --git a/test/substr.test.js b/test/substr.test.js
index 065b8e2..b4a8f1b 100644
--- a/test/substr.test.js
+++ b/test/substr.test.js
@@ -69,7 +69,7 @@ test('escape value only in toString()', function (t) {
   t.equal(f.any[0], 'zi)g');
   t.equal(f.any[1], 'z(ag');
   t.equal(f.final, '(baz)');
-  t.equal(f.toString(), '(fo\\28o=ba\\28r\\29*zi\\29g*z\\28ag*\\28baz\\29)');
+  t.equal(f.toString(), '(fo\\(o=ba\\(r\\)*zi\\)g*z\\(ag*\\(baz\\))');
   t.end();
 });
 
