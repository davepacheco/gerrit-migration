commit d9f7a15e98b3e442e8d918f2efd32a2d520023d2 (refs/changes/20/1820/4)
Author: Richard Bradley <richard.bradley@joyent.com>
Date:   2017-04-24T09:29:35+01:00 (2 years, 6 months ago)
    
    MANTA-3228 "mgenazconfig.js" should be able to create a Manta networking config file

diff --git a/bin/mgenazconfig.js b/bin/mgenazconfig.js
index 069fa61..c6df10d 100755
--- a/bin/mgenazconfig.js
+++ b/bin/mgenazconfig.js
@@ -41,7 +41,8 @@ var mod_triton = require('../lib/triton');
 var mgCmds = {
     'fetch-inventory': mgCmdFetchInventory,
     'fetch-triton': mgCmdFetchTriton,
-    'gen-manta': mgCmdGenManta
+    'gen-manta': mgCmdGenManta,
+    'gen-manta-net': mgCmdGenMantaNet
 };
 
 /* getopt option string for global options */
@@ -64,6 +65,15 @@ var mgHardwareToServerType = {
     'Joyent-Storage-Platform-7001': 'storage'
 };
 
+/*
+ * Networks required as part of `manta-net.sh`'s configuration file.
+ */
+var mgNetworkNames = [
+    'admin',
+    'manta',
+    'marlin'
+];
+
 function main()
 {
 	var mgopts, args, parser, option, funcs;
@@ -82,7 +92,9 @@ function main()
 	    'mgo_region_name': null,
 	    'mgo_password': null,
 	    'mgo_devices_by_az': null,
-	    'mgo_cns_by_az': null
+	    'mgo_cns_by_az': null,
+	    'mgo_config_az': null,
+	    'mgo_azs': null
 	};
 
 	mod_cmdutil.configure({
@@ -90,7 +102,8 @@ function main()
 	    'synopses': [
 	        '[-c CONFIG_FILE] [-d DATA_DIR] fetch-inventory REGION',
 	        '[-c CONFIG_FILE] [-d DATA_DIR] fetch-triton REGION',
-	        '[-c CONFIG_FILE] [-d DATA_DIR] gen-manta REGION'
+	        '[-c CONFIG_FILE] [-d DATA_DIR] gen-manta REGION',
+	        '[-c CONFIG_FILE] [-d DATA_DIR] gen-manta-net REGION AZ'
 	    ]
 	});
 
@@ -322,6 +335,37 @@ function mgRegionArg(mgopts, callback)
 	return (true);
 }
 
+/*
+ * Reads the second command-line argument as an az, validates it, and stores the
+ * value in "mgopts".
+ */
+function mgAzArg(mgopts, callback)
+{
+	var azName, azs;
+
+	mod_assertplus.strictEqual(null, mgopts.mgo_config_az);
+	mod_assertplus.string(mgopts.mgo_region_name,
+	    'region not specified');
+
+	azName = mgopts.mgo_cmdargs[1];
+	azs = mgopts.mgo_config_region.azs.map(function (az) {
+		return (az.name);
+	});
+
+	if (azs.indexOf(azName) < 0) {
+		setImmediate(callback,
+		    new VError('unknown az: "%s"', azName));
+		return (false);
+	}
+
+	mgopts.mgo_config_region.azs.forEach(function (az) {
+		if (az.name === azName)
+			mgopts.mgo_config_az = az;
+	});
+	mgopts.mgo_azs = azs;
+	return (true);
+}
+
 function mgInventoryFetchDevices(args, callback)
 {
 	var mgopts, building, outfile, devices, stream;
@@ -546,6 +590,63 @@ function mgCmdGenManta(mgopts, callback)
 	});
 }
 
+function mgCmdGenMantaNet(mgopts, callback)
+{
+	var funcs;
+
+	if (mgopts.mgo_cmdargs.length === 0) {
+		mod_cmdutil.usage('expected region name');
+	}
+
+	if (mgopts.mgo_cmdargs.length !== 2) {
+		mod_cmdutil.usage('expected az name');
+	}
+
+	if (mgopts.mgo_cmdargs.length > 2) {
+		mod_cmdutil.usage('extra arguments');
+	}
+
+	if (!mgRegionArg(mgopts, callback)) {
+		return;
+	}
+
+	if (!mgAzArg(mgopts, callback)) {
+		return;
+	}
+
+	funcs = [];
+	funcs.push(function findLatestInventory(_, subcallback) {
+		mgopts.mgo_devices_by_az = {};
+		mgFindLatest({
+		    'mgopts': mgopts,
+		    'type': 'inventory',
+		    'process': mgParseInventory,
+		    'required': true
+		}, subcallback);
+	});
+
+	funcs.push(function findLatestTriton(_, subcallback) {
+		mgopts.mgo_cns_by_az = {};
+		mgopts.mgo_networks_by_az = {};
+		mgFindLatest({
+		    'mgopts': mgopts,
+		    'type': 'triton',
+		    'process': mgParseTriton,
+		    'required': false
+		}, subcallback);
+	});
+
+	funcs.push(function genMantaNet(_, subcallback) {
+		mgGenMantaNet(mgopts, subcallback);
+	});
+
+	mod_vasync.pipeline({
+	    'funcs': funcs
+	}, function (err) {
+		callback(err);
+	});
+}
+
 function mgFindLatest(args, callback)
 {
 	var mgopts, type, processFunc, required;
@@ -934,6 +1035,153 @@ function mgGenManta(mgopts, callback)
 	mgGenMantaFinish(mgopts, rv, callback);
 }
 
+function mgGenMantaNet(mgopts, callback)
+{
+	var rv, counters, racks;
+	var errors, warnings;
+
+	rv = {};
+	rv.this_az = mgopts.mgo_config_az.name;
+	rv.azs = mgopts.mgo_azs;
+	rv.manta_nodes = [];
+	rv.marlin_nodes = [];
+	rv.nic_mappings = {};
+
+	errors = [];
+	counters = {
+	    'nMetadata': 0,
+	    'nStorage': 0,
+	    'nMantaVnics': 0,
+	    'nUsedMac': 0
+	};
+
+	/*
+	 * Here we check for the existence of the "networking" object in each
+	 * AZ's config. This is a hard failure in `gen-manta-net`, and the
+	 * reason it's not enforced in the schema is because we don't want to
+	 * have to define networking information if `gen-manta-net` isn't to be
+	 * used (e.g. the user only wants to make use of `gen-manta`).
+	 */
+	mgopts.mgo_config_region.azs.forEach(function (az) {
+		if (!az.hasOwnProperty('networking')) {
+			errors.push(new VError(
+			    '%s has no "networking" property', az.name));
+		}
+	});
+	if (errors.length > 0) {
+		setImmediate(callback, new VError.MultiError(errors));
+		return;
+	}
+
+	mgNetworkNames.forEach(function (n) {
+		rv[n] = {};
+		rv[n]['network'] =
+		    mgopts.mgo_config_az.networking[n].network.name;
+		rv[n]['nic_tag'] =
+		    mgopts.mgo_config_az.networking[n].network.nic_tag;
+		mgopts.mgo_config_region.azs.forEach(function (az) {
+			var network = az.networking[n].network;
+			var row = {};
+			row['subnet'] = network.subnet;
+			row['gateway'] = network.gateway;
+			if (n !== 'admin') {
+			    row['start'] = network.provision_start_ip;
+			    row['end'] = network.provision_end_ip;
+			    row['vlan_id'] = network.vlan_id;
+			}
+			rv[n][az.name] = row;
+		});
+	});
+
+	racks = mgopts.mgo_config_az.d42racks;
+
+	mgopts.mgo_devices_by_az[mgopts.mgo_config_az.name]
+	    .forEach(function (device) {
+		var type;
+
+		if (racks.indexOf(device.d42d_rack) < 0)
+		    return;
+
+		if (device.d42d_hardware === null ||
+		    !mod_jsprim.hasKey(mgHardwareToServerType,
+		    device.d42d_hardware))
+		    return;
+
+		type = mgHardwareToServerType[device.d42d_hardware];
+		if (type !== 'storage' && type !== 'metadata')
+		    return;
+
+		if (type === 'storage') {
+		    counters['nStorage']++;
+		    rv.marlin_nodes.push(device.d42d_uuid);
+		} else if (type === 'metadata') {
+		    counters['nMetadata']++;
+		}
+
+		rv.manta_nodes.push(device.d42d_uuid);
+		rv.nic_mappings[device.d42d_uuid] =
+		    mgGenNicMapping(mgopts, counters, device, type);
+	});
+
+	warnings = mgGenMantaNetCrossCheck(mgopts, rv, counters);
+	mgGenMantaNetSummarize(mgopts, warnings, counters);
+
+	if (errors.length > 0) {
+		setImmediate(callback, new VError.MultiError(errors));
+		return;
+	}
+
+	mgGenMantaNetFinish(mgopts, rv, callback);
+}
+
+/*
+ * Takes as input the Device 42 object for a device and the type of Manta
+ * server of this device and returns an object that is appropriate for use
+ * in the "nic_mappings" section in the networking config file.
+ */
+function mgGenNicMapping(mgopts, counters, device, type)
+{
+	var networking;
+	var mapping = {};
+
+	mod_assertplus.object(mgopts.mgo_config_az);
+	mod_assertplus.object(counters, 'counters');
+	mod_assertplus.number(counters.nUsedMac, 'counters.nUsedMac');
+	mod_assertplus.object(device, 'device');
+	mod_assertplus.string(device.d42d_uuid, 'device.d42d_uuid');
+	mod_assertplus.ok(type === 'metadata' || type === 'storage');
+
+	networking = mgopts.mgo_config_az.networking;
+
+	mgNetworkNames.forEach(function (n) {
+		/*
+		 * The "admin" network should already have a NIC tag, so
+		 * `manta-net.sh` doesn't attempt to tag it.
+		 */
+		if (n === 'admin')
+			return;
+		/*
+		 * Only storage nodes need to have a NIC tag for the marlin
+		 * network.
+		 */
+		if (type === 'metadata' && n === 'marlin')
+			return;
+
+		if (networking[n].nic_mapping === '<mac>') {
+			counters.nUsedMac++;
+			mapping[networking[n].network.nic_tag] = {
+			    'mac': device.d42d_uuid + '-MAC'
+			};
+		} else {
+			mapping[networking[n].network.nic_tag] = {
+			    'aggr': networking[n].nic_mapping
+			};
+		}
+	});
+
+	return (mapping);
+}
+
 /*
  * Run additional cross-checks using whatever data we have.  Returns an array of
  * warnings.
@@ -1089,6 +1337,23 @@ function mgGenMantaCrossCheck(mgopts, result, servers, counters)
 	return (warnings);
 }
 
+function mgGenMantaNetCrossCheck(mgopts, result, counters)
+{
+	var warnings;
+
+	warnings = [];
+
+	if (counters['nUsedMac'] > 0) {
+		warnings.push(new VError('Some servers have been configured ' +
+		    'to use a MAC address for either their "manta" or ' +
+		    '"marlin" network. These are represented in nic_mappings ' +
+		    'as { "mac": "$server_uuid-MAC" } which will need to be ' +
+		    'replaced with their real MAC address.'));
+	}
+
+	return (warnings);
+}
+
 /*
  * Print out a summary of the generated config.
  */
@@ -1123,6 +1388,34 @@ function mgGenMantaSummarize(mgopts, warnings, counters)
 	}
 }
 
+function mgGenMantaNetSummarize(mgopts, warnings, counters)
+{
+	/*
+	 * Some of these counters will use the same information, but it's
+	 * still useful to have these seemingly-duplicated counts across
+	 * different messages as it gives the user an idea of the tasks that
+	 * `manta-net.sh` will perform, along with some numbers to cross
+	 * reference against Triton's APIs after running `manta-net.sh` if they
+	 * choose.
+	 */
+	printf('    %-10s  %9s  %9s\n', 'AZ', 'NMETADATA', 'NSTORAGE');
+	printf('%-14s  %9d  %9d\n\n', mgopts.mgo_config_az.name,
+	    counters['nMetadata'], counters['nStorage']);
+	printf('%-38s  %5d\n', 'GZ VNICs on "manta" network',
+	    counters['nMetadata'] + counters['nStorage']);
+	printf('%-38s  %5d\n', 'NICs to tag with "manta" network',
+	    counters['nStorage'] + counters['nMetadata']);
+	printf('%-38s  %5d\n', 'NICs to tag with "marlin" network',
+	    counters['nStorage']);
+	if (warnings.length > 0) {
+		printf('\n');
+		warnings.forEach(function (w) {
+			console.error('WARN: %s', w.message);
+		});
+		printf('\n');
+	}
+}
+
 /*
  * Given an object representing the final output content, format it and write it
  * to an appropriate output file.
@@ -1174,6 +1467,38 @@ function mgGenMantaFinish(mgopts, result, callback)
 	    });
 }
 
+function mgGenMantaNetFinish(mgopts, result, callback)
+{
+	var outfile;
+
+	mod_assertplus.object(mgopts, 'mgopts');
+	mod_assertplus.object(result, 'result');
+	mod_assertplus.func(callback, 'callback');
+
+	result.manta_nodes.sort(function (s1, s2) {
+		return (s1.localeCompare(s2));
+	});
+	result.marlin_nodes.sort(function (s1, s2) {
+		return (s1.localeCompare(s2));
+	});
+	outfile = mgopts.mgo_region_name + '-' + mgopts.mgo_config_az.name +
+	    '-networking.json';
+	mod_fs.writeFile(outfile, JSON.stringify(result), { 'flag': 'wx' },
+	    function onOutputWriteDone(err) {
+		if (err) {
+			if (err.code == 'EEXIST') {
+				err = new VError('file already exists');
+			}
+
+			callback(new VError(err, 'write "%s"', outfile));
+			return;
+		}
+
+		console.log('wrote %s', outfile);
+		callback();
+	});
+}
+
 function log_start()
 {
 	var str = mod_extsprintf.sprintf.apply(null, arguments);
diff --git a/docs/gen-manta-net.md b/docs/gen-manta-net.md
new file mode 100644
index 0000000..2bfdf55
--- /dev/null
+++ b/docs/gen-manta-net.md
@@ -0,0 +1,77 @@
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2017, Joyent, Inc.
+-->
+
+# gen-manta-net
+
+This command can be used to generate a configuration file suitable for use by
+`manta-net.sh` on a per-AZ basis. It makes use of data from Device 42 and some
+local configuration options.
+
+## Usage
+
+`gen-manta-net` is used per-region and per-az. CLI usage is as follows.
+
+    $ mgenazconfig gen-manta-net myregion myaz
+
+## Prerequisites
+
+Device 42 data is required (`mgenazconfig fetch-inventory`).
+
+## Configuration
+
+To make use of this command the following configuration additions must be made.
+
+* In the list of AZs for a region, a "networking" object must be added that
+  contains NAPI network and NIC mapping information for the "admin", "manta",
+  and "mantanat" network. For example:
+
+
+    ...
+    }, {
+        "name": "east1c",
+        ...
+        "networking": {
+            "admin": {
+                "network": {
+                    "name": "admin",
+                    "nic_tag": "admin",
+                    "subnet": "10.99.99.0/24",
+                    "gateway": "10.99.99.1",
+                    "provision_start_ip": "10.99.99.38",
+                    "provision_end_ip": "10.99.99.253",
+                    "vlan_id": 0
+                },
+                "nic_mapping": "aggr1"
+            },
+            "manta": {
+                "network": {
+                ...
+    ...
+
+The "nic_mapping" value is assumed to be an aggregation name unless the
+special value of `<mac>` is used. When `<mac>` is used, the resulting
+configuration file will contain placeholder values (`$server_uuid-MAC"`) that
+need to be replaced with the appropriate MAC address for that server's "manta"
+and "mantanat" network.
+
+The per-network "nic_mapping" value is also assumed to be the same value across
+all servers in the AZ. That is, if you require a subset of storage servers to
+have a different aggregation tagged for "manta" usage, the resulting
+configuration file must be edited to reflect this.
+
+## Future
+
+* This tool should also fetch current NIC tag and VNIC information from NAPI,
+  which in turn can be used to only generate a config file that contains servers
+  that haven't yet had their networking configured for Manta. This is useful
+  because `manta-net.sh` will work through each server in series in order to
+  determine whether they're properly tagged and have VNICs, and for a large
+  list of servers this can take a long time when ultimately most servers might
+  not require action.
diff --git a/lib/schema.js b/lib/schema.js
index 0c664d5..4307c9f 100644
--- a/lib/schema.js
+++ b/lib/schema.js
@@ -44,6 +44,32 @@ var mgSchemaConfig = {
     }
 };
 
+var mgSchemaTritonNetwork = {
+    'type': 'object',
+    'required': true,
+    'properties': {
+	'name':               { 'type': 'string',  'required': true },
+	'nic_tag':            { 'type': 'string',  'required': true },
+	'subnet':             { 'type': 'string',  'required': true },
+	'gateway':            { 'type': 'string',  'required': true },
+	'provision_start_ip': { 'type': 'string',  'required': true },
+	'provision_end_ip':   { 'type': 'string',  'required': true },
+	'vlan_id':            { 'type': 'integer', 'required': true }
+    }
+};
+
+var mgSchemaConfigNetwork = {
+    'type': 'object',
+    'required': true,
+    'properties': {
+	'network': mgSchemaTritonNetwork,
+	'nic_mapping': {
+	    'type': 'string',
+	    'required': true
+	}
+    }
+};
+
 /*
  * If JSON schema v3 supports specifying schemas for values inside an object
  * whose properties themselves are not known ahead of time, the author cannot
@@ -91,6 +117,14 @@ var mgSchemaConfigRegion = {
 			    'type': 'string',
 			    'minLength': 1
 			}
+		    },
+		    'networking': {
+			'type': 'object',
+			'properties': {
+			    'admin':  mgSchemaConfigNetwork,
+			    'manta':  mgSchemaConfigNetwork,
+			    'marlin': mgSchemaConfigNetwork
+			}
 		    }
 		}
 	    }
