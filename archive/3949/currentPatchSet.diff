commit b71f2bdd4e3145c4ccc3c22eb4a9191ef6a669d2 (refs/changes/49/3949/8)
Author: John Levon <john.levon@joyent.com>
Date:   2018-05-18T15:12:25+00:00 (1 year, 5 months ago)
    
    OS-6921 vmadm reboot can leave bhyve VMs in stopped state
    Reviewed by: Josh Wilsdon <josh@wilsdon.ca>
    Reviewed by: Dave Eddy <dave.eddy@joyent.com>
    Approved by: Dave Eddy <dave.eddy@joyent.com>

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 2aa95e51..a475ba9f 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -14101,7 +14101,6 @@ function doTermStop(vmobj, options, callback)
     var err;
     var timer;
     var tracers_obj;
-    var waiter;
 
     assert(vmobj.pid);
 
@@ -14113,25 +14112,27 @@ function doTermStop(vmobj, options, callback)
 
     log.debug({vmobj_pid: vmobj.pid, timeout: options.timeout}, 'doTermStop');
 
-    // From options, we use:
-    // options.timeout
-    function haltZone() {
+    function haltZone(cb) {
+        assert.optionalFunc(cb, 'cb');
+
         zoneadm(['-u', vmobj.uuid, 'halt', '-X'], log, function (e, fds) {
             var msg = trim(fds.stderr);
 
             if (!e || msg.match(/zone is already halted$/)) {
                 // success
                 log.info('zone is halted');
-                callback();
-                return;
+                if (cb) {
+                    cb();
+                }
             } else if (e) {
                 log.error({
                     err: e,
                     stdout: fds.stdout,
                     stderr: fds.stderr
                 }, 'failed to halt zone');
-                callback(e);
-                return;
+                if (cb) {
+                    cb(e);
+                }
             }
         });
     }
@@ -14141,7 +14142,7 @@ function doTermStop(vmobj, options, callback)
     // zone.
     if (vmobj.pid === 4294967295) {
         log.warn('PID is 4294967295, halting zone instead of killing init');
-        haltZone();
+        haltZone(callback);
         return;
     }
 
@@ -14149,8 +14150,8 @@ function doTermStop(vmobj, options, callback)
     log.info({vmobj_pid: vmobj.pid}, 'Sending SIGTERM to VM\'s init PID');
     err = killSig(vmobj.pid, 'SIGTERM');
     if (err && err.code === 'ESRCH') {
-        // process already doesn't exist
-        callback();
+        // process already doesn't exist (but zone may still be on the way down)
+        haltZone(callback);
         return;
     } else if (err) {
         /*
@@ -14162,57 +14163,43 @@ function doTermStop(vmobj, options, callback)
     }
 
     /*
-     * We expect the stop to have completed within options.timeout seconds,
-     * if it hasn't we'll try SIGKILL and if that fails to kill the zone,
-     * we'll do a 'zoneadm halt'.
+     * We'll pwait on our init process. If it's not done by the timeout, we'll
+     * then force the matter via SIGKILL or halting the zone.  In any case, the
+     * pwait should eventually finish, so we'll make sure that's the only path
+     * out, in order to avoid accidentally invoking the callback twice.
      */
     timer = setTimeout(function _timeoutAfterTerm() {
-        function _doHaltZone() {
-            if (waiter) {
-                waiter.kill();
-                waiter = null;
-            }
+        log.warn({vmobj_pid: vmobj.pid}, 'timed out after SIGTERM');
 
-            haltZone(); // will call callback();
+        if (!options.killOnTimeout) {
+            haltZone();
+            return;
         }
 
-        if (options.killOnTimeout) {
-            /*
-             * Hit timeout, do kill -KILL, ignore error since either process
-             * is gone and doPwait will notice and exit, or we'll timeout a
-             * second time.
-             */
-            log.info({vmobj_pid: vmobj.pid},
-                'Sending SIGKILL to VM\'s init PID');
-            killSig(vmobj.pid, 'SIGKILL');
-            /*
-             * Sent kill -KILL, so process really should just exit. In case it
-             * doesn't though set one more timer. If that expires, halt the
-             * zone.
-             */
-            timer = setTimeout(function _timeoutAfterKill() {
-                log.warn({vmobj_pid: vmobj.pid}, 'SIGKILL does not seem to '
-                    + 'have stopped zone, attempting "zoneadm halt"');
-                _doHaltZone();
-            }, (10 * 1000));
-        } else {
-            _doHaltZone();
-        }
+        log.info({vmobj_pid: vmobj.pid}, 'Sending SIGKILL to VM\'s init PID');
+        killSig(vmobj.pid, 'SIGKILL');
+
+        // A last-ditch zone halt if even KILL didn't make progress...
+        timer = setTimeout(function _timeoutAfterKill() {
+            log.warn({vmobj_pid: vmobj.pid}, 'SIGKILL does not seem to '
+                + 'have stopped zone, attempting "zoneadm halt"');
+            haltZone();
+        }, (10 * 1000));
     }, (options.timeout * 1000));
 
-    /*
-     * This 'waiter' watches for the PID to exit and calls _onExit callback
-     * when it does. Can be immediately.
-     */
-    waiter = doPwait(vmobj.pid, log, function _onExit() {
+    doPwait(vmobj.pid, log, function _onExit() {
+        log.debug({vmobj_pid: vmobj.pid}, 'pwait reports that init exited');
+
         if (timer) {
             clearTimeout(timer);
             timer = null;
         }
 
-        // It's dead Jim!
-        log.debug({vmobj_pid: vmobj.pid}, 'pwait reports that init exited');
-        callback();
+        /*
+         * init is done, but the zone could still not quite be halted (e.g.
+         * still 'down'); so we need to ensure it's really halted.
+         */
+        haltZone(callback);
     });
 }
 
