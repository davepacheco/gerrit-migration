From e160d5becf4d0b0255a029faee2a05a5ab7085e5 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Mon, 13 Feb 2017 18:40:08 +0000
Subject: [PATCH] OS-5965 lxbrand move memcntl wrappers to IKE

---
 .../lib/brand/lx/lx_brand/common/lx_brand.c   |  30 +--
 usr/src/lib/brand/lx/lx_brand/common/mem.c    | 152 +-------------
 .../lib/brand/lx/lx_brand/sys/lx_syscall.h    |   9 +-
 usr/src/uts/common/brand/lx/os/lx_syscall.c   |  30 +--
 usr/src/uts/common/brand/lx/sys/lx_syscalls.h |   9 +-
 usr/src/uts/common/brand/lx/syscall/lx_mem.c  | 186 ++++++++++++++++++
 usr/src/uts/intel/Makefile.files              |   3 +-
 7 files changed, 228 insertions(+), 191 deletions(-)
 create mode 100644 usr/src/uts/common/brand/lx/syscall/lx_mem.c

diff --git a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
index c027cfed5e..a0c1223d3c 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -1021,7 +1021,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*   7: poll */
 	NULL,				/*   8: lseek */
 	lx_mmap,			/*   9: mmap */
-	lx_mprotect,			/*  10: mprotect */
+	NULL,				/*  10: mprotect */
 	NULL,				/*  11: munmap */
 	NULL,				/*  12: brk */
 	lx_rt_sigaction,		/*  13: rt_sigaction */
@@ -1037,9 +1037,9 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  23: select */
 	NULL,				/*  24: sched_yield */
 	lx_remap,			/*  25: mremap */
-	lx_msync,			/*  26: msync */
+	NULL,				/*  26: msync */
 	NULL,				/*  27: mincore */
-	lx_madvise,			/*  28: madvise */
+	NULL,				/*  28: madvise */
 	lx_shmget,			/*  29: shmget */
 	lx_shmat,			/*  30: shmat */
 	lx_shmctl,			/*  31: shmctl */
@@ -1160,10 +1160,10 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 146: sched_get_priority_max */
 	NULL,				/* 147: sched_get_priority_min */
 	NULL,				/* 148: sched_rr_get_interval */
-	lx_mlock,			/* 149: mlock */
-	lx_munlock,			/* 150: munlock */
-	lx_mlockall,			/* 151: mlockall */
-	lx_munlockall,			/* 152: munlockall */
+	NULL,				/* 149: mlock */
+	NULL,				/* 150: munlock */
+	NULL,				/* 151: mlockall */
+	NULL,				/* 152: munlockall */
 	NULL,				/* 153: vhangup */
 	NULL,				/* 154: modify_ldt */
 	NULL,				/* 155: pivot_root */
@@ -1467,7 +1467,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 122: uname */
 	NULL,				/* 123: modify_ldt */
 	lx_adjtimex,			/* 124: adjtimex */
-	lx_mprotect,			/* 125: mprotect */
+	NULL,				/* 125: mprotect */
 	lx_sigprocmask,			/* 126: sigprocmask */
 	NULL,				/* 127: create_module */
 	NULL,				/* 128: init_module */
@@ -1486,16 +1486,16 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 141: getdents */
 	NULL,				/* 142: select */
 	lx_flock,			/* 143: flock */
-	lx_msync,			/* 144: msync */
+	NULL,				/* 144: msync */
 	NULL,				/* 145: readv */
 	NULL,				/* 146: writev */
 	NULL,				/* 147: getsid */
 	lx_fdatasync,			/* 148: fdatasync */
 	lx_sysctl,			/* 149: sysctl */
-	lx_mlock,			/* 150: mlock */
-	lx_munlock,			/* 151: munlock */
-	lx_mlockall,			/* 152: mlockall */
-	lx_munlockall,			/* 153: munlockall */
+	NULL,				/* 150: mlock */
+	NULL,				/* 151: munlock */
+	NULL,				/* 152: mlockall */
+	NULL,				/* 153: munlockall */
 	NULL,				/* 154: sched_setparam */
 	NULL,				/* 155: sched_getparam */
 	NULL,				/* 156: sched_setscheduler */
@@ -1561,7 +1561,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 216: setfsgid */
 	NULL,				/* 217: pivot_root */
 	NULL,				/* 218: mincore */
-	lx_madvise,			/* 219: madvise */
+	NULL,				/* 219: madvise */
 	NULL,				/* 220: getdents64 */
 	NULL,				/* 221: fcntl64 */
 	NULL,				/* 222: tux */
diff --git a/usr/src/lib/brand/lx/lx_brand/common/mem.c b/usr/src/lib/brand/lx/lx_brand/common/mem.c
index d3550d5583..9632649091 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/mem.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/mem.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <errno.h>
@@ -54,16 +54,6 @@ int pagesize;	/* needed for mmap2() */
 #define	LX_MAP_NORESERVE	0x04000
 #define	LX_MAP_32BIT		0x00040
 
-#define	LX_MADV_REMOVE		9
-#define	LX_MADV_DONTFORK	10
-#define	LX_MADV_DOFORK		11
-#define	LX_MADV_MERGEABLE	12
-#define	LX_MADV_UNMERGEABLE	13
-#define	LX_MADV_HUGEPAGE	14
-#define	LX_MADV_NOHUGEPAGE	15
-#define	LX_MADV_DONTDUMP	16
-#define	LX_MADV_DODUMP		17
-
 #define	TWO_GB			0x80000000
 
 static void lx_remap_anoncache_invalidate(uintptr_t, size_t);
@@ -192,146 +182,6 @@ lx_mmap2(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4,
 }
 
 
-/*
- * The locking family of system calls, as well as msync(), are identical.  On
- * Solaris, they are layered on top of the memcntl syscall, so they cannot be
- * pass-thru.
- */
-long
-lx_mlock(uintptr_t addr, uintptr_t len)
-{
-	uintptr_t addr1 = addr & PAGEMASK;
-	uintptr_t len1 = len + (addr & PAGEOFFSET);
-
-	return (mlock((void *)addr1, (size_t)len1) ? -errno : 0);
-}
-
-long
-lx_mlockall(uintptr_t flags)
-{
-	return (mlockall(flags) ? -errno : 0);
-}
-
-long
-lx_munlock(uintptr_t addr, uintptr_t len)
-{
-	uintptr_t addr1 = addr & PAGEMASK;
-	uintptr_t len1 = len + (addr & PAGEOFFSET);
-
-	return (munlock((void *)addr1, (size_t)len1) ? -errno : 0);
-}
-
-long
-lx_munlockall(void)
-{
-	return (munlockall() ? -errno : 0);
-}
-
-long
-lx_msync(uintptr_t addr, uintptr_t len, uintptr_t flags)
-{
-	return (msync((void *)addr, (size_t)len, flags) ? -errno : 0);
-}
-
-/*
- * Illumos and Linux overlap on the basic flags, and are disjoint on the rest.
- * Linux also allows the length to be zero, while Illumos does not.
- */
-long
-lx_madvise(uintptr_t start, uintptr_t len, uintptr_t advice)
-{
-	int ret;
-
-	if (len == 0)
-		return (0);
-
-	/* approximately similar */
-	if (advice == LX_MADV_REMOVE)
-		advice = MADV_FREE;
-
-	switch (advice) {
-	case MADV_NORMAL:
-	case MADV_RANDOM:
-	case MADV_SEQUENTIAL:
-	case MADV_WILLNEED:
-	case MADV_FREE:
-	case MADV_DONTNEED:
-		if (advice == MADV_DONTNEED) {
-			/*
-			 * On Linux, MADV_DONTNEED implies an immediate purge
-			 * of the specified region.  This is spuriously
-			 * different from (nearly) every other Unix, having
-			 * apparently been done to mimic the semantics on
-			 * Digital Unix (!).  This is bad enough (MADV_FREE
-			 * both has better semantics and results in better
-			 * performance), but it gets worse:  Linux applications
-			 * (and notably, jemalloc) have managed to depend on
-			 * the busted semantics of MADV_DONTNEED on Linux.  We
-			 * implement these semantics via MADV_PURGE -- and
-			 * we translate our advice accordingly.
-			 */
-			advice = MADV_PURGE;
-		}
-
-		ret = madvise((void *)start, len, advice);
-		if (ret == -1) {
-			if (errno == EBUSY) {
-				if (advice != MADV_PURGE)
-					return (-EINVAL);
-
-				/*
-				 * If we got an EBUSY from a MADV_PURGE, we
-				 * will now try again with a MADV_DONTNEED:
-				 * there are conditions (namely, with locked
-				 * mappings that haven't yet been faulted in)
-				 * where MADV_PURGE will fail but MADV_DONTNEED
-				 * will succeed.  If this succeeds, we'll call
-				 * the operation successful; if not, we'll kick
-				 * back EINVAL.
-				 */
-				advice = MADV_DONTNEED;
-
-				if (madvise((void *)start, len, advice) == 0)
-					return (0);
-
-				return (-EINVAL);
-			}
-
-			return (-errno);
-		} else {
-			return (0);
-		}
-
-	/* harmless to pretend these work */
-	case LX_MADV_DONTFORK:
-	case LX_MADV_DOFORK:
-	case LX_MADV_HUGEPAGE:
-	case LX_MADV_NOHUGEPAGE:
-	case LX_MADV_DONTDUMP:
-	case LX_MADV_DODUMP:
-		return (0);
-
-	/* we'll return an error for the rest of the Linux flags */
-	default:
-		return (-EINVAL);
-	}
-}
-
-/*
- * mprotect() is identical except that we ignore the Linux flags PROT_GROWSDOWN
- * and PROT_GROWSUP, which have no equivalent on Solaris.
- */
-#define	LX_PROT_GROWSDOWN	0x01000000
-#define	LX_PROT_GROWSUP		0x02000000
-
-long
-lx_mprotect(uintptr_t start, uintptr_t len, uintptr_t prot)
-{
-	prot &= ~(LX_PROT_GROWSUP | LX_PROT_GROWSDOWN);
-
-	return (mprotect((void *)start, len, prot) ? -errno : 0);
-}
-
 #define	LX_MREMAP_MAYMOVE	1	/* mapping can be moved */
 #define	LX_MREMAP_FIXED		2	/* address is fixed */
 
diff --git a/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h b/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
index e26ff7333c..c3cebf8e81 100644
--- a/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
+++ b/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef _SYS_LX_SYSCALL_H
@@ -104,13 +104,6 @@ extern long lx_clone(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 extern long lx_exit(uintptr_t);
 extern long lx_group_exit(uintptr_t);
 
-extern long lx_mlock(uintptr_t, uintptr_t);
-extern long lx_mlockall(uintptr_t);
-extern long lx_munlock(uintptr_t, uintptr_t);
-extern long lx_munlockall(void);
-extern long lx_msync(uintptr_t, uintptr_t, uintptr_t);
-extern long lx_madvise(uintptr_t, uintptr_t, uintptr_t);
-extern long lx_mprotect(uintptr_t, uintptr_t, uintptr_t);
 extern long lx_mmap(uintptr_t, uintptr_t, uintptr_t, uintptr_t,
     uintptr_t, uintptr_t);
 extern long lx_mmap2(uintptr_t, uintptr_t, uintptr_t, uintptr_t,
diff --git a/usr/src/uts/common/brand/lx/os/lx_syscall.c b/usr/src/uts/common/brand/lx/os/lx_syscall.c
index c8824e6783..467e51dd2b 100644
--- a/usr/src/uts/common/brand/lx/os/lx_syscall.c
+++ b/usr/src/uts/common/brand/lx/os/lx_syscall.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/kmem.h>
@@ -644,7 +644,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"uname",	lx_uname,		0,		1}, /* 122 */
 	{"modify_ldt",	lx_modify_ldt,		0,		3}, /* 123 */
 	{"adjtimex",	NULL,			0,		1}, /* 124 */
-	{"mprotect",	NULL,			0,		3}, /* 125 */
+	{"mprotect",	lx_mprotect,		0,		3}, /* 125 */
 	{"sigprocmask",	NULL,			0,		3}, /* 126 */
 	{"create_module", NULL,			NOSYS_KERNEL,	0}, /* 127 */
 	{"init_module",	NULL,			NOSYS_KERNEL,	0}, /* 128 */
@@ -663,16 +663,16 @@ lx_sysent_t lx_sysent32[] = {
 	{"getdents",	lx_getdents_32,		0,		3}, /* 141 */
 	{"select",	lx_select,		0,		5}, /* 142 */
 	{"flock",	NULL,			0,		2}, /* 143 */
-	{"msync",	NULL,			0,		3}, /* 144 */
+	{"msync",	lx_msync,		0,		3}, /* 144 */
 	{"readv",	lx_readv,		0,		3}, /* 145 */
 	{"writev",	lx_writev,		0,		3}, /* 146 */
 	{"getsid",	lx_getsid,		0,		1}, /* 147 */
 	{"fdatasync",	NULL,			0,		1}, /* 148 */
 	{"sysctl",	NULL,			0,		1}, /* 149 */
-	{"mlock",	NULL,			0,		2}, /* 150 */
-	{"munlock",	NULL,			0,		2}, /* 151 */
-	{"mlockall",	NULL,			0,		1}, /* 152 */
-	{"munlockall",	NULL,			0,		0}, /* 153 */
+	{"mlock",	lx_mlock,		0,		2}, /* 150 */
+	{"munlock",	lx_munlock,		0,		2}, /* 151 */
+	{"mlockall",	lx_mlockall,		0,		1}, /* 152 */
+	{"munlockall",	lx_munlockall,		0,		0}, /* 153 */
 	{"sched_setparam", lx_sched_setparam,	0,		2}, /* 154 */
 	{"sched_getparam", lx_sched_getparam,	0,		2}, /* 155 */
 	{"sched_setscheduler", lx_sched_setscheduler, 0,	3}, /* 156 */
@@ -738,7 +738,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"setfsgid",	lx_setfsgid,		0,		1}, /* 216 */
 	{"pivot_root",	NULL,			NOSYS_KERNEL,	0}, /* 217 */
 	{"mincore",	lx_mincore,		0,		3}, /* 218 */
-	{"madvise",	NULL,			0,		3}, /* 219 */
+	{"madvise",	lx_madvise,		0,		3}, /* 219 */
 	{"getdents64",	lx_getdents64,		0,		3}, /* 220 */
 	{"fcntl64",	lx_fcntl64,		0,		3}, /* 221 */
 	{"tux",		NULL,			NOSYS_NO_EQUIV,	0}, /* 222 */
@@ -900,7 +900,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"poll",	lx_poll,		0,		3}, /* 7 */
 	{"lseek",	lx_lseek64,		0,		3}, /* 8 */
 	{"mmap",	NULL,			0,		6}, /* 9 */
-	{"mprotect",	NULL,			0,		3}, /* 10 */
+	{"mprotect",	lx_mprotect,		0,		3}, /* 10 */
 	{"munmap",	lx_munmap,		0,		2}, /* 11 */
 	{"brk",		lx_brk,			0,		1}, /* 12 */
 	{"rt_sigaction", NULL,			0,		4}, /* 13 */
@@ -916,9 +916,9 @@ lx_sysent_t lx_sysent64[] = {
 	{"select",	lx_select,		0,		5}, /* 23 */
 	{"sched_yield",	lx_sched_yield,		0,		0}, /* 24 */
 	{"mremap",	NULL,			0,		5}, /* 25 */
-	{"msync",	NULL,			0,		3}, /* 26 */
+	{"msync",	lx_msync,		0,		3}, /* 26 */
 	{"mincore",	lx_mincore,		0,		3}, /* 27 */
-	{"madvise",	NULL,			0,		3}, /* 28 */
+	{"madvise",	lx_madvise,		0,		3}, /* 28 */
 	{"shmget",	NULL,			0,		3}, /* 29 */
 	{"shmat",	NULL,			0,		4}, /* 30 */
 	{"shmctl",	NULL,			0,		3}, /* 31 */
@@ -1039,10 +1039,10 @@ lx_sysent_t lx_sysent64[] = {
 	{"sched_get_priority_max", lx_sched_get_priority_max, 0, 1}, /* 146 */
 	{"sched_get_priority_min", lx_sched_get_priority_min, 0, 1}, /* 147 */
 	{"sched_rr_get_interval", lx_sched_rr_get_interval, 0,	2}, /* 148 */
-	{"mlock",	NULL,			0,		2}, /* 149 */
-	{"munlock",	NULL,			0,		2}, /* 150 */
-	{"mlockall",	NULL,			0,		1}, /* 151 */
-	{"munlockall",	NULL,			0,		0}, /* 152 */
+	{"mlock",	lx_mlock,		0,		2}, /* 149 */
+	{"munlock",	lx_munlock,		0,		2}, /* 150 */
+	{"mlockall",	lx_mlockall,		0,		1}, /* 151 */
+	{"munlockall",	lx_munlockall,		0,		0}, /* 152 */
 	{"vhangup",	lx_vhangup,		0,		0}, /* 153 */
 	{"modify_ldt",	lx_modify_ldt,		0,		3}, /* 154 */
 	{"pivot_root",	NULL,			NOSYS_KERNEL,	0}, /* 155 */
diff --git a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
index 2784ed6919..925bf0399f 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
@@ -22,7 +22,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef _SYS_LINUX_SYSCALLS_H
@@ -137,11 +137,18 @@ extern long lx_lsetxattr();
 extern long lx_lstat32();
 extern long lx_lstat64();
 extern long lx_listxattr();
+extern long lx_madvise();
 extern long lx_mincore();
 extern long lx_mkdir();
 extern long lx_mkdirat();
+extern long lx_mlock();
+extern long lx_mlockall();
+extern long lx_mprotect();
 extern long lx_modify_ldt();
 extern long lx_mount();
+extern long lx_msync();
+extern long lx_munlock();
+extern long lx_munlockall();
 extern long lx_munmap();
 extern long lx_nanosleep();
 extern long lx_nice();
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_mem.c b/usr/src/uts/common/brand/lx/syscall/lx_mem.c
new file mode 100644
index 0000000000..6dca40aefa
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_mem.c
@@ -0,0 +1,186 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <sys/systm.h>
+#include <sys/errno.h>
+#include <sys/mman.h>
+#include <sys/debug.h>
+#include <sys/sysmacros.h>
+
+/* From uts/common/os/grow.c */
+extern int mprotect(caddr_t, size_t, int);
+/* From uts/common/syscall/memcntl.c */
+extern int memcntl(caddr_t, size_t, int, caddr_t, int, int);
+
+
+#define	ALIGN_ADDR(a)	((caddr_t)((a) & (uintptr_t)PAGEMASK))
+#define	ALIGN_LEN(l, a)	(size_t)(P2ROUNDUP((l) + ((a) & PAGEOFFSET), PAGESIZE))
+
+#define	LX_MADV_NORMAL		0
+#define	LX_MADV_RANDOM		1
+#define	LX_MADV_SEQUENTIAL	2
+#define	LX_MADV_WILLNEED	3
+#define	LX_MADV_DONTNEED	4
+#define	LX_MADV_FREE		8
+#define	LX_MADV_REMOVE		9
+#define	LX_MADV_DONTFORK	10
+#define	LX_MADV_DOFORK		11
+#define	LX_MADV_MERGEABLE	12
+#define	LX_MADV_UNMERGEABLE	13
+#define	LX_MADV_HUGEPAGE	14
+#define	LX_MADV_NOHUGEPAGE	15
+#define	LX_MADV_DONTDUMP	16
+#define	LX_MADV_DODUMP		17
+
+#define	LX_VALID_MSYNC	(MS_ASYNC|MS_INVALIDATE|MS_SYNC)
+
+#define	LX_PROT_GROWSDOWN	0x01000000
+#define	LX_PROT_GROWSUP		0x02000000
+
+int
+lx_mlock(uintptr_t addr, size_t len)
+{
+	caddr_t aaddr = ALIGN_ADDR(addr);
+	size_t alen = ALIGN_LEN(len, addr);
+
+	return (memcntl(aaddr, alen, MC_LOCK, 0, 0, 0));
+}
+
+int
+lx_mlockall(int flags)
+{
+	return (memcntl(0, 0, MC_LOCKAS, (caddr_t)(uintptr_t)flags, 0, 0));
+}
+
+int
+lx_munlock(uintptr_t addr, size_t len)
+{
+	caddr_t aaddr = ALIGN_ADDR(addr);
+	size_t alen = ALIGN_LEN(len, addr);
+
+	return (memcntl(aaddr, alen, MC_UNLOCK, 0, 0, 0));
+}
+
+int
+lx_munlockall(void)
+{
+	return (memcntl(0, 0, MC_UNLOCKAS, 0, 0, 0));
+}
+
+int
+lx_msync(uintptr_t addr, size_t len, int flags)
+{
+	if ((addr & PAGEOFFSET) != 0 ||
+	    (flags & ~LX_VALID_MSYNC) != 0) {
+		return (set_errno(EINVAL));
+	}
+	return (memcntl((caddr_t)addr, len, MC_SYNC, (caddr_t)(uintptr_t)flags,
+	    0, 0));
+}
+
+int
+lx_madvise(caddr_t addr, size_t len, int advice)
+{
+	klwp_t *lwp = ttolwp(curthread);
+
+	switch (advice) {
+	case LX_MADV_REMOVE:
+		/* approximately similar */
+		advice = MADV_FREE;
+		break;
+
+	case LX_MADV_DONTNEED:
+		/*
+		 * On Linux, MADV_DONTNEED implies an immediate purge of the
+		 * specified region.  This is spuriously different from
+		 * (nearly) every other Unix, having apparently been done to
+		 * mimic the semantics on Digital Unix (!).  This is bad enough
+		 * (MADV_FREE both has better semantics and results in better
+		 * performance), but it gets worse:  Linux applications (and
+		 * notably, jemalloc) have managed to depend on the busted
+		 * semantics of MADV_DONTNEED on Linux.  We implement these
+		 * semantics via MADV_PURGE -- and we translate our advice
+		 * accordingly.
+		 */
+		advice = MADV_PURGE;
+		break;
+
+	case LX_MADV_FREE:
+		advice = MADV_FREE;
+		break;
+
+	case LX_MADV_NORMAL:
+	case LX_MADV_RANDOM:
+	case LX_MADV_SEQUENTIAL:
+	case LX_MADV_WILLNEED:
+		/* These map directly to the illumos values */
+		break;
+
+	case LX_MADV_DONTFORK:
+	case LX_MADV_DOFORK:
+	case LX_MADV_HUGEPAGE:
+	case LX_MADV_NOHUGEPAGE:
+	case LX_MADV_DONTDUMP:
+	case LX_MADV_DODUMP:
+		/* harmless to pretend these work */
+		return (0);
+	default:
+		return (set_errno(EINVAL));
+	}
+
+	/* Linux allows the length to be zero while illumos does not. */
+	if (len == 0) {
+		return (0);
+	}
+
+	VERIFY(lwp->lwp_errno == 0);
+	(void) memcntl(addr, len, MC_ADVISE, (caddr_t)(intptr_t)advice, 0, 0);
+	if (lwp->lwp_errno == EBUSY) {
+		if (advice != MADV_PURGE) {
+			return (set_errno(EINVAL));
+		}
+		/*
+		 * If we received an EBUSY from a MADV_PURGE, we will now try
+		 * again with a MADV_DONTNEED: there are conditions (namely,
+		 * with locked mappings that haven't yet been faulted in) where
+		 * MADV_PURGE will fail but MADV_DONTNEED will succeed.  If
+		 * this succeeds, we'll call the operation a success; if not,
+		 * we'll kick back EINVAL.
+		 */
+		lwp->lwp_errno = 0;
+		advice = MADV_DONTNEED;
+		if (memcntl(addr, len, MC_ADVISE, (caddr_t)(intptr_t)advice,
+		    0, 0) != 0) {
+			return (set_errno(EINVAL));
+		}
+	}
+	return (lwp->lwp_errno);
+}
+
+int
+lx_mprotect(caddr_t start, size_t len, int prot)
+{
+	/*
+	 * Other than ignoring the Linux flags PROT_GROWSDOWN and PROT_GROWSUP,
+	 * for which have no equivalent, the LX mprotect(2) identical to the
+	 * native implementation.
+	 */
+	prot &= ~(LX_PROT_GROWSUP | LX_PROT_GROWSDOWN);
+
+	return (mprotect((void *)start, len, prot));
+}
diff --git a/usr/src/uts/intel/Makefile.files b/usr/src/uts/intel/Makefile.files
index 5e819809fd..24b930692d 100644
--- a/usr/src/uts/intel/Makefile.files
+++ b/usr/src/uts/intel/Makefile.files
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright 2016, Joyent, Inc.
+# Copyright 2017 Joyent, Inc.
 # Copyright 2016 Nexenta Systems, Inc.
 #
 
@@ -334,6 +334,7 @@ LX_BRAND_OBJS  =		\
 	lx_kill.o		\
 	lx_link.o		\
 	lx_lseek.o		\
+	lx_mem.o		\
 	lx_misc.o		\
 	lx_miscsys.o		\
 	lx_mkdir.o		\
-- 
2.21.0

