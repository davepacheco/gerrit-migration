From 5bd3b5b8a1609658903ccf2275621d536c7fb146 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Tue, 1 Aug 2017 14:59:25 -0700
Subject: [PATCH] DOCKER-524 Implement docker push

---
 CHANGES.md                      |   4 +
 examples/v2/putManifest.js      |  82 +++++++
 examples/v2/uploadBlob.js       |  93 +++++++
 lib/docker-json-client.js       |   4 +-
 lib/errors.js                   |  16 ++
 lib/registry-client-v2.js       | 416 +++++++++++++++++++++++++++++---
 package.json                    |   2 +-
 test/v2.amazonecr.test.js       | 107 +++++---
 test/v2.dockerioprivate.test.js | 104 +++++---
 test/v2.gcrio.test.js           |   3 +-
 test/v2.gcrioprivate.test.js    | 352 +++++++++++++++++++++++++++
 11 files changed, 1079 insertions(+), 104 deletions(-)
 create mode 100644 examples/v2/putManifest.js
 create mode 100644 examples/v2/uploadBlob.js
 create mode 100644 test/v2.gcrioprivate.test.js

diff --git a/CHANGES.md b/CHANGES.md
index da7d2e2..15e2e01 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,10 @@
 
 (nothing yet)
 
+## 3.3.0
+
+- DOCKER-524 Implement docker push. Adds uploadBlob and putManifest API methods.
+
 ## 3.2.7
 
 - joyent/node-docker-registry-client#16 Allow a repo name to have a '/', e.g.
diff --git a/examples/v2/putManifest.js b/examples/v2/putManifest.js
new file mode 100644
index 0000000..7f16d61
--- /dev/null
+++ b/examples/v2/putManifest.js
@@ -0,0 +1,82 @@
+#!/usr/bin/env node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var fs = require('fs');
+var vasync = require('vasync');
+
+var drc = require('../../');
+var mainline = require('../mainline');
+
+function getFileSha256(filepath, callback) {
+    var sha256 = crypto.createHash('sha256');
+    var stream = fs.createReadStream(filepath);
+
+    sha256.on('readable', function () {
+        callback(null, sha256.read().toString('hex'));
+    });
+
+    stream.on('error', function (streamErr) {
+        callback(streamErr);
+    });
+
+    stream.pipe(sha256);
+}
+
+// Shared mainline with examples/foo.js to get CLI opts.
+var cmd = 'putManifest';
+mainline({cmd: cmd}, function (log, parser, opts, args) {
+    if (!args[0] || (args[0].indexOf(':') === -1 && !args[1])) {
+        console.error('usage: node examples/v2/%s.js REPO[:TAG|@DIGEST] ' +
+            'manifest-file\n\n' +
+            'options:\n' +
+            '%s', cmd, parser.help().trimRight());
+        process.exit(2);
+    }
+
+    // The interesting stuff starts here.
+    var rar = drc.parseRepoAndRef(args[0]);
+    assert.ok(rar.canonicalName, 'must specify a repo');
+    var ref = rar.tag || rar.digest;
+    assert.ok(ref, 'must specify a tag or digest');
+
+    console.log('Repo:', rar.canonicalName + ':' + ref);
+
+    var filepath = args[1];
+    assert.string(filepath, 'must specify a blob filepath');
+    var contents = fs.readFileSync(filepath).toString();
+
+    var client = drc.createClientV2({
+        repo: rar,
+        log: log,
+        insecure: opts.insecure,
+        username: opts.username,
+        password: opts.password
+    });
+
+    console.log('Uploading manifest: %s', filepath);
+    var manifestOpts = {
+        manifest: contents,
+        ref: ref
+    };
+    client.putManifest(manifestOpts,
+            function (uploadErr, res, digest, location) {
+        if (uploadErr) {
+            mainline.fail(cmd, uploadErr, opts);
+        }
+
+        console.log('Upload successful => digest:', digest,
+            'location:', location);
+        client.close();
+    });
+});
diff --git a/examples/v2/uploadBlob.js b/examples/v2/uploadBlob.js
new file mode 100644
index 0000000..2f18e6f
--- /dev/null
+++ b/examples/v2/uploadBlob.js
@@ -0,0 +1,93 @@
+#!/usr/bin/env node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var fs = require('fs');
+var vasync = require('vasync');
+
+var drc = require('../../');
+var mainline = require('../mainline');
+
+function getFileSha256(filepath, callback) {
+    var sha256 = crypto.createHash('sha256');
+    var stream = fs.createReadStream(filepath);
+
+    sha256.on('readable', function () {
+        var digest = sha256.read();
+        if (digest) {
+            callback(null, digest.toString('hex'));
+        }
+    });
+
+    stream.on('error', function (streamErr) {
+        callback(streamErr);
+    });
+
+    stream.pipe(sha256);
+}
+
+// Shared mainline with examples/foo.js to get CLI opts.
+var cmd = 'uploadBlob';
+mainline({cmd: cmd}, function (log, parser, opts, args) {
+    if (!args[0] || (args[0].indexOf(':') === -1 && !args[1])) {
+        console.error('usage: node examples/v2/%s.js REPO blob-file\n' +
+            '\n' +
+            'options:\n' +
+            '%s', cmd, parser.help().trimRight());
+        process.exit(2);
+    }
+
+    // The interesting stuff starts here.
+    var rar = drc.parseRepoAndRef(args[0]);
+    assert.ok(rar.canonicalName, 'must specify a repo');
+    console.log('Repo:', rar.canonicalName);
+
+    var filepath = args[1];
+    assert.string(filepath, 'must specify a blob filepath');
+    var fileSize = fs.statSync(filepath).size;
+
+    getFileSha256(filepath, function (err, sha256) {
+        var client = drc.createClientV2({
+            insecure: opts.insecure,
+            log: log,
+            repo: rar,
+            username: opts.username,
+            password: opts.password
+        });
+
+        var digest = 'sha256:' + sha256;
+        var stream = fs.createReadStream(filepath);
+        var blobOpts = {
+            contentLength: fileSize,
+            digest: digest,
+            stream: stream
+        };
+        console.log('Uploading blob: %s, digest: %s', filepath, digest);
+        client.blobUpload(blobOpts, function (uploadErr, ress) {
+            if (uploadErr) {
+                mainline.fail(cmd, uploadErr, opts);
+            }
+
+            console.log('Response headers:');
+            console.log(JSON.stringify(ress.headers, null, 4));
+            if (ress.length > 1) {
+                console.log('Response headers (after redirects):');
+                console.log(JSON.stringify(ress[ress.length - 1].headers,
+                    null, 4));
+            }
+
+            console.log('Body:\n%s', ress.body);
+            client.close();
+        });
+    });
+});
diff --git a/lib/docker-json-client.js b/lib/docker-json-client.js
index e21f5ba..b3ff9aa 100644
--- a/lib/docker-json-client.js
+++ b/lib/docker-json-client.js
@@ -92,8 +92,8 @@ DockerJsonClient.prototype.parse = function parse(req, callback) {
 
         function finish() {
             var body = Buffer.concat(chunks, len);
-            if (res.log.trace()) {
-                res.log.trace({body: body.toString(), len: len},
+            if (res.log.trace) {
+                res.log.trace({body: body.toString(), len: len, url: req.path},
                     'body received');
             }
 
diff --git a/lib/errors.js b/lib/errors.js
index 6981c9d..c6ecb1b 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -136,6 +136,13 @@ util.inherits(ManifestVerificationError, _DockerRegistryClientBaseError);
 ManifestVerificationError.prototype.code = 'ManifestVerificationError';
 
 
+function InvalidManifestError() {
+    _DockerRegistryClientBaseError.apply(this, arguments);
+}
+util.inherits(InvalidManifestError, _DockerRegistryClientBaseError);
+InvalidManifestError.prototype.code = 'InvalidManifestError';
+
+
 function DownloadError() {
     _DockerRegistryClientBaseError.apply(this, arguments);
 }
@@ -143,6 +150,13 @@ util.inherits(DownloadError, _DockerRegistryClientBaseError);
 DownloadError.prototype.code = 'DownloadError';
 
 
+function UploadError() {
+    _DockerRegistryClientBaseError.apply(this, arguments);
+}
+util.inherits(UploadError, _DockerRegistryClientBaseError);
+UploadError.prototype.code = 'UploadError';
+
+
 function UnauthorizedError() {
     _DockerRegistryClientBaseError.apply(this, arguments);
 }
@@ -164,6 +178,8 @@ module.exports = {
     InternalError: InternalError,
     ManifestVerificationError: ManifestVerificationError,
     DownloadError: DownloadError,
+    UploadError: UploadError,
+    InvalidManifestError: InvalidManifestError,
     UnauthorizedError: UnauthorizedError,
     TooManyRedirectsError: TooManyRedirectsError
 };
diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 5c1946f..2362bde 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -37,6 +37,7 @@ var errors = require('./errors');
 
 // https://github.com/docker/docker/blob/77da5d8/registry/config_unix.go#L10
 var DEFAULT_V2_REGISTRY = 'https://registry-1.docker.io';
+var MAX_REGISTRY_ERROR_LENGTH = 10000;
 
 
 
@@ -86,27 +87,77 @@ function _setAuthHeaderFromAuthInfo(headers, authInfo) {
 }
 
 /**
- * XXX still true for v2?
- *
- * Special handling of errors from the registry server.
+ * Return a scope string to be used for an auth request. Example:
+ *   repository:library/nginx:pull
+ */
+function _makeAuthScope(resource, name, actions) {
+    return fmt('%s:%s:%s', resource, name, actions.join(','));
+}
+
+/**
+ * Special handling of JSON body errors from the registry server.
  *
- * When some of the endpoints get a 404, the response body is a largish dump
- * of test/html. We don't want to include that as an error "message". It
- * isn't useful.
+ * POST/PUT endpoints can return an error in the body of the response.
+ * We want to check for that and get the error body message and return it.
  *
  * Usage:
- *      cb(new _sanitizeErr(err, req, res[, errmsg]));
- *
- * where `errmsg` is an optional fallback error message to use for the
- * sanitized 404 err.message.
+ *      var regErr = _getRegistryErrMessage(body));
  */
-function _sanitizeErr(err, req, res, errmsg) {
-    if (err.statusCode === 404 && res && res.headers['content-type'] &&
-        res.headers['content-type'].split(';')[0] !== 'application/json')
-    {
-        err.message = errmsg || 'not found';
+function _getRegistryErrMessage(body) {
+    if (!body) {
+        return null;
     }
-    return err;
+    var obj = body;
+    if (typeof (obj) === 'string' && obj.length <= MAX_REGISTRY_ERROR_LENGTH) {
+        try {
+            obj = JSON.parse(obj);
+        } catch (ex) {
+            // Just return the error as a string.
+            return obj;
+        }
+    }
+    if (typeof (obj) !== 'object' || !obj.hasOwnProperty('errors')) {
+        return null;
+    }
+    if (!Array.isArray(obj.errors)) {
+        return null;
+    }
+    // Example obj:
+    // {
+    //     "errors": [
+    //         {
+    //             "code": "MANIFEST_INVALID",
+    //             "message": "manifest invalid",
+    //             "detail": {}
+    //         }
+    //     ]
+    // }
+    if (obj.errors.length === 1) {
+        return obj.errors[0].message;
+    } else {
+        return obj.errors.map(function (o) {
+            return o.message;
+        }).join(', ');
+    }
+}
+
+
+// The Docker Registry will usually provide a more detailed JSON error message
+// in the response body, so try to read that data in order to get a more
+// detailed error msg.
+function registryError(err, res, callback) {
+    var body = '';
+    res.on('data', function onResChunk(chunk) {
+        body += chunk;
+    });
+    res.on('end', function onResEnd() {
+        // Parse errors in the response body.
+        var message = _getRegistryErrMessage(body);
+        if (message) {
+            err.message = message;
+        }
+        callback(err);
+    });
 }
 
 /**
@@ -1015,6 +1066,7 @@ function RegistryClientV2(opts) {
     this.username = opts.username;
     this.password = opts.password;
     this._loggedIn = false;
+    this._loggedInScope = null; // Keeps track of the login type.
     this._authInfo = null;
     this._headers = {};
 
@@ -1054,6 +1106,18 @@ function RegistryClientV2(opts) {
             return this.__api;
         }
     });
+
+    Object.defineProperty(this, '_httpapi', {
+        get: function () {
+            if (self.__httpapi === undefined) {
+                self.__httpapi = new restifyClients.HttpClient(common.objMerge({
+                    url: self._url
+                }, self._commonHttpClientOpts));
+                self._clientsToClose.push(self.__httpapi);
+            }
+            return this.__httpapi;
+        }
+    });
 }
 
 
@@ -1103,10 +1167,11 @@ RegistryClientV2.prototype.ping = function regPing(cb) {
  *        `ping()` call. This can be used to save re-pinging.
  *      - opts.pingErr {Object} Required if `pingRes` given. The error
  *        object for `pingRes`.
+ *      - opts.scope {String} Optional. Scope to use in the auth Bearer token.
  * @param cb {Function} `function (err)`
  *
  * Side-effects:
- * - On success, all of `this._loggedIn`, `this._authInfo`, and
+ * - On success, all of `this._loggedIn*`, `this._authInfo`, and
  *   `this._headers.authorization` are set.
  */
 RegistryClientV2.prototype.login = function regLogin(opts, cb) {
@@ -1117,16 +1182,17 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
     assert.object(opts, 'opts');
     assert.func(cb, 'cb');
 
-    if (this._loggedIn) {
-        return cb();
+    var self = this;
+    var scope = opts.scope;
+    if (!scope) {
+        var resource = 'repository';
+        var actions = ['pull'];
+        scope = _makeAuthScope(resource, self.repo.remoteName, actions);
     }
 
-    // TODO: expose requested token actions to ctor
-    var self = this;
-    var resource = 'repository';
-    var actions = ['pull'];
-    var scope = fmt('%s:%s:%s', resource, self.repo.remoteName,
-        actions.join(','));
+    if (this._loggedIn && this._loggedInScope === scope) {
+        return cb();
+    }
 
     login(common.objMerge({
         index: self.repo.index,
@@ -1139,6 +1205,7 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
         if (!err) {
             assert.ok(result);
             self._loggedIn = true;
+            self._loggedInScope = scope;
             self._authInfo = result.authInfo;
             _setAuthHeaderFromAuthInfo(self._headers, self._authInfo);
         }
@@ -1183,10 +1250,6 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
  * Note that, at least, currently we are presuming things are fine with a 401.
  * I.e. defering auth to later calls.
  *
- * TODO: It would be nice to pass error/response info back here. For example,
- * a connection failure to the host could be used to not bother with v1
- * fallback.
- *
  * @param cb {Function} `function (err, supportsV2)`
  *      where `supportsV2` is a boolean indicating if V2 API is supported.
  */
@@ -1213,9 +1276,11 @@ RegistryClientV2.prototype.supportsV2 = function supportsV2(cb) {
                     return cb(null, true);
                 }
             }
+            cb(null, true);
+            return;
         }
         self.log.trace({err: err, res: res}, 'supportsV2 response');
-        cb(null, false);
+        cb(err, false);
     });
 };
 
@@ -1325,14 +1390,14 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
                             'history length not equal to layers length in ' +
                             '%s:%s manifest', self.repo.localName, opts.ref));
                     }
+                    if (layers.length === 0) {
+                        throw new restifyErrors.InvalidContentError(fmt(
+                            'no layers in %s:%s manifest', self.repo.localName,
+                            opts.ref));
+                    }
                 } else if (manifest_.schemaVersion === 2) {
                     layers = manifest_.layers;
                 }
-                if (layers.length === 0) {
-                    throw new restifyErrors.InvalidContentError(fmt(
-                        'no layers in %s:%s manifest', self.repo.localName,
-                        opts.ref));
-                }
 
                 // TODO: `verifyTrustedKeys` from
                 // docker/graph/pull_v2.go#validateManifest()
@@ -1398,7 +1463,7 @@ RegistryClientV2.prototype._headOrGetBlob = function _headOrGetBlob(opts, cb) {
                     req.on('result', function (err, res) {
                         ress.push(res);
                         if (err) {
-                            next(err);
+                            registryError(err, res, next);
                             return;
                         }
                         if (res.statusCode === 302 || res.statusCode === 307) {
@@ -1587,6 +1652,285 @@ RegistryClientV2.prototype.createBlobReadStream =
 
 
 
+/*
+ * Upload an image manifest. `ref` is either a tag or a digest.
+ * <https://docs.docker.com/registry/spec/api/#pushing-an-image>
+ *
+ *   client.putManifest({manifest: <string>, ref: <tag or digest>},
+ *   function (err, res, digest, location) {
+ *      // Digest is `res.headers['docker-content-digest']`.
+ *   });
+ */
+RegistryClientV2.prototype.putManifest = function putManifest(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.string(opts.manifest, 'opts.manifest');
+    assert.string(opts.ref, 'opts.ref');
+    assert.func(cb, 'cb');
+
+    // Working variables.
+    var schemaVersion = 1;
+    // Result variables.
+    var digest;
+    var location;
+    var res;
+
+    var log = _createLogger(opts.log);
+    log.trace({
+        digest: opts.digest
+    }, 'putManifest');
+
+    vasync.pipeline({
+        arg: this,
+        funcs: [
+            function _getManifestVersion(_, next) {
+                try {
+                    var manifest = JSON.parse(opts.manifest);
+                    if (manifest.hasOwnProperty('schemaVersion')) {
+                        schemaVersion = parseInt(manifest.schemaVersion, 10);
+                    }
+                } catch (ex) {
+                    next(new errors.InvalidManifestError(
+                        'Unable to parse manifest string: ' + ex));
+                    return;
+                }
+                next();
+            },
+            function doLogin(_, next) {
+                var resource = 'repository';
+                var actions = ['pull', 'push'];
+                var scope = _makeAuthScope(resource, self.repo.remoteName,
+                    actions);
+                self.login({
+                    scope: scope
+                }, next);
+            },
+            function _putManifest(_, next) {
+                var headers = {
+                    'content-type': fmt(
+                        'application/vnd.docker.distribution.manifest.v%d+json',
+                        schemaVersion)
+                };
+                if (self._authInfo) {
+                    _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                }
+                self._httpapi.put({
+                    path: fmt('/v2/%s/manifests/%s',
+                        encodeURI(self.repo.remoteName),
+                        encodeURIComponent(opts.ref)),
+                    headers: headers
+                }, function _afterCall(err, req) {
+                    if (err) {
+                        return next(err);
+                    }
+
+                    req.on('result', function onReqResult(reqErr, res_) {
+                        res = res_;
+                        if (reqErr) {
+                            registryError(reqErr, res, next);
+                            return;
+                        }
+
+                        var body = '';
+                        res.on('data', function onResChunk(chunk) {
+                            body += chunk;
+                        });
+
+                        res.on('end', function onResEnd() {
+                            var errMsg = _getRegistryErrMessage(body);
+                            if (errMsg) {
+                                next(new errors.UploadError(errMsg));
+                                return;
+                            }
+                            digest = res.headers['docker-content-digest'];
+                            location = res.headers.location;
+                            next();
+                        });
+                    });
+
+                    req.on('error', function onReqError(reqErr) {
+                        log.error({
+                            err: reqErr
+                        }, 'Error uploading manifest');
+                        return next(reqErr);
+                    });
+
+                    req.write(opts.manifest);
+                    req.end();
+                });
+            }
+        ]
+    }, function _putManifestCb(err) {
+        cb(err, res, digest, location);
+    });
+};
+
+
+/*
+ * Upload a blob. The request stream will be used to
+ * complete the upload in a single request.
+ *
+ * <https://docs.docker.com/registry/spec/api/#starting-an-upload>
+ *
+ *   client.blobUpload({digest: <string>, stream: <object>,
+ *      contentLength: <number>},
+ *   function (err, res) { });
+ */
+RegistryClientV2.prototype.blobUpload = function blobUpload(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.number(opts.contentLength, 'opts.contentLength');
+    assert.string(opts.digest, 'opts.digest');
+    assert.object(opts.stream, 'opts.stream');
+    assert.optionalString(opts.contentType, 'opts.contentType');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    var log = _createLogger(opts.log);
+    log.trace({
+        contentLength: opts.contentLength,
+        digest: opts.digest
+    }, 'blobUpload');
+
+    // Working variables
+    var uploadUrl;
+    // Result variables.
+    var res;
+
+    vasync.pipeline({
+        arg: this,
+        funcs: [
+            function doLogin(_, next) {
+                log.trace({digest: opts.digest}, 'blobUpload:: doLogin');
+                var resource = 'repository';
+                var actions = ['pull', 'push'];
+                var scope = _makeAuthScope(resource, self.repo.remoteName,
+                    actions);
+                self.login({
+                    scope: scope
+                }, next);
+            },
+            function _getUploadUuid(_, next) {
+                log.trace({digest: opts.digest}, 'blobUpload:: _getUploadUuid');
+                var path = fmt('/v2/%s/blobs/uploads/',
+                    encodeURI(self.repo.remoteName));
+                var headers = {};
+                if (self._authInfo) {
+                    _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                }
+                self._api.post({
+                    path: path,
+                    headers: headers
+                }, function _afterCall(err, req, res_) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    uploadUrl = res_.headers.location;
+                    if (!uploadUrl) {
+                        next(new errors.UploadError(
+                            'No registry upload location header returned'));
+                        return;
+                    }
+                    next();
+                });
+            },
+            function _putBlob(_, next) {
+                assert.string(uploadUrl, 'uploadUrl');
+                log.trace({digest: opts.digest}, 'blobUpload:: _putBlob');
+                var urlSep = '?';
+                if (uploadUrl.indexOf('?') > 0) {
+                    urlSep = '&';
+                }
+                var path = fmt('%s%sdigest=%s', uploadUrl, urlSep,
+                    encodeURIComponent(opts.digest));
+                var headers = {
+                    'content-length': opts.contentLength,
+                    'content-type': (opts.contentType ||
+                        'application/octet-stream')
+                };
+                _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                self._httpapi.put({
+                    path: path,
+                    headers: headers
+                }, function _afterCall(err, req) {
+                    log.trace({digest: opts.digest, err: err},
+                        'blobUpload:: put connected');
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    // Pipe through the stream data.
+                    var stream = opts.stream;
+
+                    function removeListeners() {
+                        stream.removeListener('error', onStreamPipeError);
+                        req.removeListener('result', onReqResult);
+                        req.removeListener('error', onReqError);
+                    }
+
+                    req.on('result', onReqResult);
+                    function onReqResult(reqErr, res_) {
+                        log.trace({digest: opts.digest},
+                            'blobUpload:: onResult');
+                        res = res_;
+                        if (reqErr) {
+                            removeListeners();
+                            registryError(reqErr, res, next);
+                            return;
+                        }
+
+                        var body = '';
+                        res.on('data', function onResChunk(chunk) {
+                            body += chunk;
+                        });
+
+                        res.on('end', function onResEnd() {
+                            removeListeners();
+                            var errMsg = _getRegistryErrMessage(body);
+                            if (errMsg) {
+                                next(new errors.UploadError(errMsg));
+                                return;
+                            }
+                            next();
+                        });
+                    }
+
+                    req.on('error', onReqError);
+                    function onReqError(reqErr) {
+                        log.error({
+                            digest: opts.digest,
+                            err: reqErr
+                        }, 'Error sending blob');
+                        removeListeners();
+                        return next(reqErr);
+                    }
+
+                    stream.on('error', onStreamPipeError);
+                    function onStreamPipeError(streamErr) {
+                        log.error({
+                            digest: opts.digest,
+                            err: streamErr
+                        }, 'Error piping blob');
+                        removeListeners();
+                        req.end();
+                        return next(streamErr);
+                    }
+
+                    log.trace({digest: opts.digest},
+                        'blobUpload:: piping stream to req');
+                    stream.pipe(req);
+                });
+            }
+        ]
+    }, function _blobUploadCb(err) {
+        cb(err, res);
+    });
+};
+
+
+
 // --- Exports
 
 function createClient(opts) {
diff --git a/package.json b/package.json
index dff7144..8b04fef 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "docker-registry-client",
-    "version": "3.2.7",
+    "version": "3.3.0",
     "description": "node.js client for the Docker Registry API",
     "author": "Joyent (joyent.com)",
     "main": "./lib/index.js",
diff --git a/test/v2.amazonecr.test.js b/test/v2.amazonecr.test.js
index 87da276..6818821 100644
--- a/test/v2.amazonecr.test.js
+++ b/test/v2.amazonecr.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -48,6 +48,7 @@ test('v2 amazonecr', function (tt) {
     tt.test('  createClient', function (t) {
         noauthClient = drc.createClientV2({
             name: CONFIG.repo,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(noauthClient);
@@ -84,7 +85,7 @@ test('v2 amazonecr', function (tt) {
         noauthClient.listTags(function (err) {
             t.ok(err);
             t.equal(err.statusCode, 401, 'Expect a 401 status code');
-            t.equal(String(err.message).trim(), 'Not Authorizied');
+            t.equal(String(err.message).trim(), 'Not Authorized');
             t.end();
         });
     });
@@ -97,6 +98,7 @@ test('v2 amazonecr', function (tt) {
             name: CONFIG.repo,
             username: CONFIG.username,
             password: CONFIG.password,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(client);
@@ -124,36 +126,43 @@ test('v2 amazonecr', function (tt) {
 
     /*
      *  {
-     *      "name": <name>,
-     *      "tag": <tag>,
-     *      "fsLayers": [
-     *         {
-     *            "blobSum": <tarsum>
-     *         },
-     *         ...
-     *      ],
-     *      "history": <v1 images>,
-     *      "signature": <JWS>
+     *      "schemaVersion": 2,
+     *      "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *      "config": {
+     *          "mediaType": "application/vnd.docker.container.image.v1+json",
+     *          "size": 1584,
+     *          "digest": "sha256:99e59f495ffaa2...545ab2bbe3b1b1ec3bd0b2"
+     *      },
+     *      "layers": [
+     *          {
+     *              "mediaType": "application/vnd.docker...diff.tar.gzip",
+     *              "size": 32,
+     *              "digest": "sha256:a3ed95caeb02ff...d00e8a7c22955b46d4"
+     *          }
+     *      ]
      *  }
      */
+    var blobDigest;
     var manifest;
-    var manifestDigest;
+    var manifestStr;
     tt.test('  getManifest', function (t) {
-        client.getManifest({ref: CONFIG.tag}, function (err, manifest_, res) {
+        client.getManifest({ref: CONFIG.tag},
+                function (err, manifest_, res, manifestStr_) {
             t.ifErr(err);
             manifest = manifest_;
+            manifestStr = manifestStr_;
             // Note that Amazon ECR does not return a docker-content-digest
             // header.
-            manifestDigest = res.headers['docker-content-digest'];
+            var manifestDigest = res.headers['docker-content-digest'];
             t.equal(manifestDigest, undefined, 'no docker-content-digest');
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, CONFIG.tag);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers[0]);
+            t.ok(manifest.layers[0].digest);
+            blobDigest = manifest.layers[0].digest;
             t.end();
         });
     });
@@ -168,7 +177,7 @@ test('v2 amazonecr', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = manifest.layers[0].digest;
         client.headBlob({digest: digest}, function (err, ress) {
             t.ifErr(err);
             t.ok(ress);
@@ -194,14 +203,10 @@ test('v2 amazonecr', function (tt) {
             var last = ress[ress.length - 1];
             t.ok(last);
             t.equal(last.statusCode, 200);
-
-            // Content-Type:
-            // - docker.io gives 'application/octet-stream', but amazon isn't so
-            //   nice for a HEAD request, it just returns text/plain.
             t.equal(last.headers['content-type'],
-                'text/plain; charset=utf-8');
-
+                'application/vnd.docker.image.rootfs.diff.tar.gzip');
             t.ok(last.headers['content-length']);
+
             t.end();
         });
     });
@@ -230,7 +235,7 @@ test('v2 amazonecr', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
+        var digest = manifest.layers[0].digest;
         client.createBlobReadStream({digest: digest},
                 function (err, stream, ress) {
             t.ifErr(err);
@@ -257,8 +262,7 @@ test('v2 amazonecr', function (tt) {
 
             t.ok(stream);
             t.equal(stream.statusCode, 200);
-            t.equal(stream.headers['content-type'],
-                'application/octet-stream');
+            t.equal(stream.headers['content-type'], 'application/octet-stream');
             t.ok(stream.headers['content-length']);
 
             var numBytes = 0;
@@ -300,6 +304,45 @@ test('v2 amazonecr', function (tt) {
         });
     });
 
+    tt.test('  blobUpload', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err, 'createBlobReadStream err');
+
+            var last = ress[ress.length - 1];
+            var uploadOpts = {
+                contentLength: parseInt(last.headers['content-length'], 10),
+                digest: blobDigest,
+                stream: stream
+            };
+            client.blobUpload(uploadOpts, function _uploadCb(uploadErr, res) {
+                t.ifErr(uploadErr, 'check blobUpload err');
+                t.equal(res.headers['docker-content-digest'], blobDigest,
+                    'Response header digest should match blob digest');
+                t.end();
+            });
+        });
+    });
+
+    tt.test('  putManifest', function (t) {
+        var uploadOpts = {
+            contentLength: manifestStr.length,
+            manifest: manifestStr,
+            ref: 'test_put_manifest'
+        };
+        // Calculate the existing manifest digest.
+        var manifestDigest = 'sha256:' + crypto.createHash('sha256')
+            .update(manifestStr, 'binary')
+            .digest('hex');
+
+        client.putManifest(uploadOpts, function _uploadCb(uploadErr, res) {
+            t.ifErr(uploadErr, 'check blobUpload err');
+            t.equal(res.headers['docker-content-digest'], manifestDigest,
+                'Response header digest should match manifest digest');
+            t.end();
+        });
+    });
+
     tt.test('  close', function (t) {
         client.close();
         t.end();
diff --git a/test/v2.dockerioprivate.test.js b/test/v2.dockerioprivate.test.js
index 5ef090d..4442148 100644
--- a/test/v2.dockerioprivate.test.js
+++ b/test/v2.dockerioprivate.test.js
@@ -65,6 +65,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             name: CONFIG.repo,
             username: CONFIG.username,
             password: CONFIG.password,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(client);
@@ -111,6 +112,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     tt.test('  noAuthClient: setup', function (t) {
         noAuthClient = drc.createClientV2({
             name: CONFIG.repo,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(noAuthClient);
@@ -143,33 +145,41 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
 
     /*
      *  {
-     *      "name": <name>,
-     *      "tag": <tag>,
-     *      "fsLayers": [
-     *         {
-     *            "blobSum": <tarsum>
-     *         },
-     *         ...
-     *      ],
-     *      "history": <v1 images>,
-     *      "signature": <JWS>
+     *      "schemaVersion": 2,
+     *      "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *      "config": {
+     *          "mediaType": "application/vnd.docker.container.image.v1+json",
+     *          "size": 1584,
+     *          "digest": "sha256:99e59f495ffaa2...545ab2bbe3b1b1ec3bd0b2"
+     *      },
+     *      "layers": [
+     *          {
+     *              "mediaType": "application/vnd.docker...diff.tar.gzip",
+     *              "size": 32,
+     *              "digest": "sha256:a3ed95caeb02ff...d00e8a7c22955b46d4"
+     *          }
+     *      ]
      *  }
      */
+    var blobDigest;
     var manifest;
     var manifestDigest;
+    var manifestStr;
     tt.test('  getManifest', function (t) {
-        client.getManifest({ref: CONFIG.tag}, function (err, manifest_, res) {
+        client.getManifest({ref: CONFIG.tag},
+                function (err, manifest_, res, manifestStr_) {
             t.ifErr(err);
             manifest = manifest_;
             manifestDigest = res.headers['docker-content-digest'];
+            manifestStr = manifestStr_;
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, CONFIG.tag);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers[0]);
+            t.ok(manifest.layers[0].digest);
+            blobDigest = manifest.layers[0].digest;
             t.end();
         });
     });
@@ -178,11 +188,11 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
         client.getManifest({ref: manifestDigest}, function (err, manifest_) {
             t.ifErr(err);
             t.ok(manifest);
-            ['schemaVersion',
-             'name',
-             'tag',
-             'architecture'].forEach(function (k) {
-                t.equal(manifest_[k], manifest[k], k);
+            ['config',
+             'layers',
+             'mediaType',
+             'schemaVersion'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
             });
             t.end();
         });
@@ -198,8 +208,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
-        client.headBlob({digest: digest}, function (err, ress) {
+        client.headBlob({digest: blobDigest}, function (err, ress) {
             t.ifErr(err, 'no headBlob err');
             t.ok(ress, 'got a "ress"');
             t.ok(Array.isArray(ress), '"ress" is an array');
@@ -207,7 +216,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             t.ok(first.statusCode === 200 || first.statusCode === 307,
                 'first response statusCode is 200 or 307');
             if (first.headers['docker-content-digest']) {
-                t.equal(first.headers['docker-content-digest'], digest,
+                t.equal(first.headers['docker-content-digest'], blobDigest,
                     '"docker-content-digest" header from first response is '
                     + 'the queried digest');
             }
@@ -240,8 +249,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
-        client.createBlobReadStream({digest: digest},
+        client.createBlobReadStream({digest: blobDigest},
                 function (err, stream, ress) {
             t.ifErr(err, 'createBlobReadStream err');
 
@@ -251,7 +259,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             t.ok(first.statusCode === 200 || first.statusCode === 307,
                 'createBlobReadStream first res statusCode is 200 or 307');
             if (first.headers['docker-content-digest']) {
-                t.equal(first.headers['docker-content-digest'], digest,
+                t.equal(first.headers['docker-content-digest'], blobDigest,
                     '"docker-content-digest" header from first response is '
                     + 'the queried digest');
             }
@@ -267,13 +275,13 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
 
 
             var numBytes = 0;
-            var hash = crypto.createHash(digest.split(':')[0]);
+            var hash = crypto.createHash(blobDigest.split(':')[0]);
             stream.on('data', function (chunk) {
                 hash.update(chunk);
                 numBytes += chunk.length;
             });
             stream.on('end', function () {
-                t.equal(hash.digest('hex'), digest.split(':')[1]);
+                t.equal(hash.digest('hex'), blobDigest.split(':')[1]);
                 t.equal(numBytes, Number(stream.headers['content-length']));
                 t.end();
             });
@@ -296,6 +304,40 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
         });
     });
 
+    tt.test('  blobUpload', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err, 'createBlobReadStream err');
+
+            var last = ress[ress.length - 1];
+            var uploadOpts = {
+                contentLength: parseInt(last.headers['content-length'], 10),
+                digest: blobDigest,
+                stream: stream
+            };
+            client.blobUpload(uploadOpts, function _uploadCb(uploadErr, res) {
+                t.ifErr(uploadErr, 'check blobUpload err');
+                t.equal(res.headers['docker-content-digest'], blobDigest,
+                    'Response header digest should match blob digest');
+                t.end();
+            });
+        });
+    });
+
+    tt.test('  putManifest', function (t) {
+        var uploadOpts = {
+            contentLength: manifestStr.length,
+            manifest: manifestStr,
+            ref: 'test_put_manifest'
+        };
+        client.putManifest(uploadOpts, function _uploadCb(uploadErr, res) {
+            t.ifErr(uploadErr, 'check blobUpload err');
+            t.equal(res.headers['docker-content-digest'], manifestDigest,
+                'Response header digest should match manifest digest');
+            t.end();
+        });
+    });
+
     tt.test('  close', function (t) {
         client.close();
         t.end();
diff --git a/test/v2.gcrio.test.js b/test/v2.gcrio.test.js
index 895352b..bf2f9f3 100644
--- a/test/v2.gcrio.test.js
+++ b/test/v2.gcrio.test.js
@@ -5,11 +5,10 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var crypto = require('crypto');
-var strsplit = require('strsplit');
 var test = require('tape');
 var util = require('util');
 
diff --git a/test/v2.gcrioprivate.test.js b/test/v2.gcrioprivate.test.js
new file mode 100644
index 0000000..cccc61c
--- /dev/null
+++ b/test/v2.gcrioprivate.test.js
@@ -0,0 +1,352 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * For Google Container Registry private tests, you'll need:
+ *  - the Google Cloud Platform Consol (gcloud) installed
+ *  - a Google Container Registry project configured (i.e. to push to)
+ *  - create the *short-lived* auth config for your gcr.io account
+ *    `gcloud docker -a -s gcr.io`
+ *  - split out username/password from the ~/.docker/config.json
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var test = require('tape');
+var util = require('util');
+
+var drc = require('..');
+
+
+// --- globals
+
+var format = util.format;
+var log = require('./lib/log');
+
+var CONFIG;
+try {
+    CONFIG = require(__dirname + '/config.json').gcrprivate;
+    assert.object(CONFIG, 'config.json#gcrprivate');
+    assert.string(CONFIG.repo, 'CONFIG.repo');
+    assert.string(CONFIG.tag, 'CONFIG.tag');
+    assert.string(CONFIG.username, 'CONFIG.username');
+    assert.string(CONFIG.password, 'CONFIG.password');
+} catch (e) {
+    CONFIG = null;
+    log.warn(e, 'skipping Google Container Registry private tests: ' +
+        'could not load "gcrprivate" key from test/config.json');
+    console.warn('# warning: skipping Google Registry private tests: %s',
+        e.message);
+}
+
+// --- Tests
+
+if (CONFIG)
+test('v2 gcr.io private', function (tt) {
+    var client;
+    var repo = drc.parseRepo(CONFIG.repo);
+
+    tt.test('  createClient', function (t) {
+        client = drc.createClientV2({
+            name: CONFIG.repo,
+            maxSchemaVersion: 2,
+            username: CONFIG.username,
+            password: CONFIG.password,
+            log: log
+        });
+        t.ok(client);
+        t.equal(client.version, 2);
+        t.end();
+    });
+
+    tt.test('  supportsV2', function (t) {
+        client.supportsV2(function (err, supportsV2) {
+            t.ifErr(err);
+            t.ok(supportsV2, 'supportsV2');
+            t.end();
+        });
+    });
+
+    tt.test('  ping', function (t) {
+        client.ping(function (err, body, res) {
+            t.ok(err);
+            t.ok(res, 'have a response');
+            if (res) {
+                t.equal(res.statusCode, 401);
+                t.ok(res.headers['www-authenticate']);
+            }
+            t.equal(res.headers['docker-distribution-api-version'],
+                'registry/2.0');
+            t.end();
+        });
+    });
+
+    /*
+     * Example expected output:
+     *  {
+     *      "name": "library/alpine",
+     *      "tags": [ "2.6", "2.7", "3.1", "3.2", "edge", "latest" ]
+     *  }
+     */
+    tt.test('  listTags', function (t) {
+        client.listTags(function (err, tags) {
+            t.ifErr(err);
+            t.ok(tags);
+            t.equal(tags.name, repo.remoteName);
+            t.ok(tags.tags.indexOf(CONFIG.tag) !== -1,
+                'no "'+CONFIG.tag+'" tag');
+            t.end();
+        });
+    });
+
+    /*
+     *  {
+     *      "schemaVersion": 2,
+     *      "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *      "config": {
+     *          "mediaType": "application/vnd.docker.container.image.v1+json",
+     *          "size": 1584,
+     *          "digest": "sha256:99e59f495ffaa2...545ab2bbe3b1b1ec3bd0b2"
+     *      },
+     *      "layers": [
+     *          {
+     *              "mediaType": "application/vnd.docker...diff.tar.gzip",
+     *              "size": 32,
+     *              "digest": "sha256:a3ed95caeb02ff...d00e8a7c22955b46d4"
+     *          }
+     *      ]
+     *  }
+     */
+    var blobDigest;
+    var manifest;
+    var manifestDigest;
+    var manifestStr;
+    tt.test('  getManifest', function (t) {
+        client.getManifest({ref: CONFIG.tag},
+                function (err, manifest_, res, manifestStr_) {
+            t.ifErr(err);
+            manifest = manifest_;
+            manifestDigest = res.headers['docker-content-digest'];
+            t.ok(manifestDigest, 'has a docker-content-digest header');
+            manifestStr = manifestStr_;
+            t.ok(manifest);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers[0]);
+            t.ok(manifest.layers[0].digest);
+            blobDigest = manifest.layers[0].digest;
+            t.end();
+        });
+    });
+
+    tt.test('  getManifest (by digest)', function (t) {
+        client.getManifest({ref: manifestDigest}, function (err, manifest_) {
+            t.ifErr(err);
+            t.ok(manifest_);
+            ['config',
+             'layers',
+             'mediaType',
+             'schemaVersion'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
+            });
+            t.end();
+        });
+    });
+
+    tt.test('  getManifest (unknown tag)', function (t) {
+        client.getManifest({ref: 'unknowntag'}, function (err, manifest_) {
+            t.ok(err);
+            t.notOk(manifest_);
+            t.equal(err.statusCode, 404);
+            t.end();
+        });
+    });
+
+    tt.test('  headBlob', function (t) {
+        client.headBlob({digest: blobDigest}, function (err, ress) {
+            t.ifErr(err);
+            t.ok(ress, 'got responses');
+            t.ok(Array.isArray(ress), 'responses is an array');
+            var first = ress[0];
+
+            // First request statusCode on a redirect:
+            // - gcr.io gives 302 (Found)
+            // - docker.io gives 307
+            t.ok([200, 302, 303, 307].indexOf(first.statusCode) !== -1,
+                'first response status code 200, 302 or 307: statusCode=' +
+                first.statusCode);
+
+            // No digest head is returned (it's using an earlier version of the
+            // registry API).
+            if (first.headers['docker-content-digest']) {
+                t.equal(first.headers['docker-content-digest'], blobDigest);
+            }
+
+            t.equal(first.headers['docker-distribution-api-version'],
+                'registry/2.0');
+
+            var last = ress[ress.length - 1];
+            t.ok(last);
+            t.equal(last.statusCode, 200,
+                'last response status code should be 200');
+
+            // Content-Type:
+            // - docker.io gives 'application/octet-stream', which is what
+            //   I'd expect for the GET response at least.
+            // - However gcr.io, at least for the iamge being tested, now
+            //   returns text/html.
+            t.equal(last.headers['content-type'],
+                'text/html',
+                format('expect specific Content-Type on last response; '
+                    + 'statusCode=%s headers=%j',
+                    last.statusCode, last.headers));
+
+            t.ok(last.headers['content-length']);
+            t.end();
+        });
+    });
+
+    tt.test('  headBlob (unknown digest)', function (t) {
+        client.headBlob({digest: 'cafebabe'}, function (err, ress) {
+            t.ok(err);
+            t.ok(ress);
+            t.ok(Array.isArray(ress));
+            t.equal(ress.length, 1);
+            // var res = ress[0];
+
+            // statusCode:
+            // - docker.io gives 404, which is what I'd expect
+            // - gcr.io gives 405 (Method Not Allowed). Hrm.
+            // The spec doesn't specify:
+            // https://docs.docker.com/registry/spec/api/#existing-layers
+            // t.equal(res.statusCode, 404);
+
+            // Docker-Distribution-Api-Version header:
+            // docker.io includes this header here, gcr.io does not.
+            // t.equal(res.headers['docker-distribution-api-version'],
+            //    'registry/2.0');
+
+            t.end();
+        });
+    });
+
+    tt.test('  createBlobReadStream', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err);
+
+            t.ok(ress);
+            t.ok(Array.isArray(ress));
+            var first = ress[0];
+            // First request statusCode on a redirect:
+            // - gcr.io gives 302 (Found)
+            // - docker.io gives 307
+            t.ok([200, 302, 307].indexOf(first.statusCode) !== -1,
+                'first request status code 200, 302 or 307: statusCode=' +
+                first.statusCode);
+
+            // No digest head is returned (it's using an earlier version of the
+            // registry API).
+            if (first.headers['docker-content-digest']) {
+                t.equal(first.headers['docker-content-digest'], blobDigest);
+            }
+
+            // Docker-Distribution-Api-Version header:
+            // docker.io includes this header here, gcr.io does not.
+            t.equal(first.headers['docker-distribution-api-version'],
+                'registry/2.0');
+
+            t.ok(stream);
+            t.equal(stream.statusCode, 200);
+            t.equal(stream.headers['content-type'],
+                'application/octet-stream');
+            t.ok(stream.headers['content-length']);
+
+            var numBytes = 0;
+            var hash = crypto.createHash(blobDigest.split(':')[0]);
+            stream.on('data', function (chunk) {
+                hash.update(chunk);
+                numBytes += chunk.length;
+            });
+            stream.on('end', function () {
+                t.equal(hash.digest('hex'), blobDigest.split(':')[1]);
+                t.equal(numBytes, Number(stream.headers['content-length']));
+                t.end();
+            });
+            stream.resume();
+        });
+    });
+
+    tt.test('  createBlobReadStream (unknown digest)', function (t) {
+        client.createBlobReadStream({digest: 'cafebabe'},
+                function (err, stream, ress) {
+            t.ok(err);
+            t.ok(ress);
+            t.ok(Array.isArray(ress));
+            t.equal(ress.length, 1);
+            // var res = ress[0];
+
+            // statusCode:
+            // - docker.io gives 404, which is what I'd expect
+            // - gcr.io gives 405 (Method Not Allowed). Hrm.
+            // The spec doesn't specify:
+            // https://docs.docker.com/registry/spec/api/#existing-layers
+            // t.equal(res.statusCode, 404);
+
+            // Docker-Distribution-Api-Version header:
+            // docker.io includes this header here, gcr.io does not.
+            // t.equal(res.headers['docker-distribution-api-version'],
+            //    'registry/2.0');
+
+            t.end();
+        });
+    });
+
+    tt.test('  blobUpload', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err, 'createBlobReadStream err');
+
+            var last = ress[ress.length - 1];
+            var uploadOpts = {
+                contentLength: parseInt(last.headers['content-length'], 10),
+                digest: blobDigest,
+                stream: stream
+            };
+            client.blobUpload(uploadOpts, function _uploadCb(uploadErr, res) {
+                t.ifErr(uploadErr, 'check blobUpload err');
+                t.equal(res.headers['docker-content-digest'], blobDigest,
+                    'Response header digest should match blob digest');
+                t.end();
+            });
+        });
+    });
+
+    tt.test('  putManifest', function (t) {
+        var uploadOpts = {
+            contentLength: manifestStr.length,
+            manifest: manifestStr,
+            ref: 'test_put_manifest'
+        };
+        client.putManifest(uploadOpts, function _uploadCb(uploadErr, res) {
+            t.ifErr(uploadErr, 'check blobUpload err');
+            //t.equal(res.headers['docker-content-digest'], manifestDigest,
+            //    'Response header digest should match manifest digest');
+            t.end();
+        });
+    });
+
+    tt.test('  close', function (t) {
+        client.close();
+        t.end();
+    });
+});
-- 
2.21.0

