From 2eb400ea0af51a323df362410adaa7f5ff7f64c1 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Fri, 23 Sep 2016 14:14:52 +0000
Subject: [PATCH] OS-5673 move some "simple" syscalls in-kernel

---
 usr/src/lib/brand/lx/lx_brand/Makefile.com    |   2 -
 usr/src/lib/brand/lx/lx_brand/common/fcntl.c  |  49 +--
 usr/src/lib/brand/lx/lx_brand/common/file.c   |  11 -
 usr/src/lib/brand/lx/lx_brand/common/id.c     |  68 ----
 .../lib/brand/lx/lx_brand/common/lx_brand.c   | 114 +++----
 usr/src/lib/brand/lx/lx_brand/common/misc.c   | 310 ------------------
 usr/src/lib/brand/lx/lx_brand/common/pgrp.c   | 172 ----------
 usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h   |  32 --
 .../lib/brand/lx/lx_brand/sys/lx_syscall.h    |  36 --
 usr/src/uts/common/brand/lx/os/lx_syscall.c   | 114 +++----
 usr/src/uts/common/brand/lx/sys/lx_syscalls.h |  32 ++
 .../uts/common/brand/lx/syscall/lx_fadvise.c  | 108 ++++++
 usr/src/uts/common/brand/lx/syscall/lx_id.c   |  38 +++
 .../uts/common/brand/lx/syscall/lx_miscsys.c  | 282 ++++++++++++++++
 usr/src/uts/common/brand/lx/syscall/lx_pgrp.c | 189 +++++++++++
 .../uts/common/brand/lx/syscall/lx_rename.c   |  39 +++
 usr/src/uts/intel/Makefile.files              |   4 +
 17 files changed, 807 insertions(+), 793 deletions(-)
 delete mode 100644 usr/src/lib/brand/lx/lx_brand/common/id.c
 delete mode 100644 usr/src/lib/brand/lx/lx_brand/common/pgrp.c
 create mode 100644 usr/src/uts/common/brand/lx/syscall/lx_fadvise.c
 create mode 100644 usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
 create mode 100644 usr/src/uts/common/brand/lx/syscall/lx_pgrp.c
 create mode 100644 usr/src/uts/common/brand/lx/syscall/lx_rename.c

diff --git a/usr/src/lib/brand/lx/lx_brand/Makefile.com b/usr/src/lib/brand/lx/lx_brand/Makefile.com
index 68df72849b..e653fecd58 100644
--- a/usr/src/lib/brand/lx/lx_brand/Makefile.com
+++ b/usr/src/lib/brand/lx/lx_brand/Makefile.com
@@ -37,14 +37,12 @@ COBJS	=	aio.o			\
 		file.o			\
 		fcntl.o			\
 		fork.o			\
-		id.o			\
 		lx_brand.o		\
 		mem.o			\
 		misc.o			\
 		module.o		\
 		mount.o			\
 		mount_nfs.o		\
-		pgrp.o			\
 		priority.o		\
 		ptrace.o		\
 		sched.o			\
diff --git a/usr/src/lib/brand/lx/lx_brand/common/fcntl.c b/usr/src/lib/brand/lx/lx_brand/common/fcntl.c
index 93738bf84f..4796d68855 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/fcntl.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/fcntl.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.  All rights reserved.
+ * Copyright 2016 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -86,50 +86,3 @@ lx_flock(uintptr_t p1, uintptr_t p2)
 
 	return ((ret == -1) ? -errno : ret);
 }
-
-/*
- * Based on Illumos posix_fadvise which does nothing. The only difference is
- * that on Linux an fd refering to a pipe or FIFO returns EINVAL.
- * The Linux POSIX_FADV_* values are the same as the Illumos values.
- * See how glibc calls fadvise64; the offeset is a 64bit value, but the length
- * is not, whereas fadvise64_64 passes both the offset and length as 64bit
- * values.
- */
-/* ARGSUSED */
-long
-lx_fadvise64(uintptr_t p1, off64_t p2, uintptr_t p3, uintptr_t p4)
-{
-	int fd = (int)p1;
-	int advice = (int)p4;
-	int32_t len = (int32_t)p3;
-	struct stat64 statb;
-
-	switch (advice) {
-	case POSIX_FADV_NORMAL:
-	case POSIX_FADV_RANDOM:
-	case POSIX_FADV_SEQUENTIAL:
-	case POSIX_FADV_WILLNEED:
-	case POSIX_FADV_DONTNEED:
-	case POSIX_FADV_NOREUSE:
-		break;
-	default:
-		return (-EINVAL);
-	}
-	if (len < 0)
-		return (-EINVAL);
-	if (fstat64(fd, &statb) != 0)
-		return (-EBADF);
-	if (S_ISFIFO(statb.st_mode))
-		return (-ESPIPE);
-	return (0);
-}
-
-long
-lx_fadvise64_64(uintptr_t p1, off64_t p2, off64_t p3, uintptr_t p4)
-{
-
-	if (p3 < 0)
-		return (-EINVAL);
-
-	return (lx_fadvise64(p1, p2, 0, p4));
-}
diff --git a/usr/src/lib/brand/lx/lx_brand/common/file.c b/usr/src/lib/brand/lx/lx_brand/common/file.c
index 0231eab58f..a1f55e2899 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/file.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/file.c
@@ -130,17 +130,6 @@ lx_utime(uintptr_t p1, uintptr_t p2)
 	return (0);
 }
 
-/*
- * Neither Illumos nor Linux actually returns anything to the caller, but glibc
- * expects to see SOME value returned, so placate it and return 0.
- */
-long
-lx_sync(void)
-{
-	sync();
-	return (0);
-}
-
 long
 lx_rmdir(uintptr_t p1)
 {
diff --git a/usr/src/lib/brand/lx/lx_brand/common/id.c b/usr/src/lib/brand/lx/lx_brand/common/id.c
deleted file mode 100644
index 9ab923270d..0000000000
--- a/usr/src/lib/brand/lx/lx_brand/common/id.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
- */
-
-#include <sys/types.h>
-#include <sys/lx_types.h>
-#include <unistd.h>
-
-/*
- * The lx brand cannot support the setfs[ug]id16/setfs[ug]id calls as that
- * would require significant rework of Solaris' privilege mechanisms, so
- * instead return the current effective [ug]id.
- *
- * In Linux, fsids track effective IDs, so returning the effective IDs works
- * as a substitute; returning the current value also denotes failure of the
- * call if the caller had specified something different.  We don't need to
- * worry about setting error codes because the Linux calls don't set any.
- */
-/*ARGSUSED*/
-long
-lx_setfsuid16(uintptr_t fsuid16)
-{
-	return ((int)LX_UID32_TO_UID16(geteuid()));
-}
-
-/*ARGSUSED*/
-long
-lx_setfsgid16(uintptr_t fsgid16)
-{
-	return ((int)LX_GID32_TO_GID16(getegid()));
-}
-
-/*ARGSUSED*/
-long
-lx_setfsuid(uintptr_t fsuid)
-{
-	return (geteuid());
-}
-
-/*ARGSUSED*/
-long
-lx_setfsgid(uintptr_t fsgid)
-{
-	return (getegid());
-}
diff --git a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
index 8824c5bfd8..2e0390fe4e 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
@@ -1022,7 +1022,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*   8: lseek */
 	lx_mmap,			/*   9: mmap */
 	lx_mprotect,			/*  10: mprotect */
-	lx_munmap,			/*  11: munmap */
+	NULL,				/*  11: munmap */
 	NULL,				/*  12: brk */
 	lx_rt_sigaction,		/*  13: rt_sigaction */
 	lx_rt_sigprocmask,		/*  14: rt_sigprocmask */
@@ -1038,17 +1038,17 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  24: sched_yield */
 	lx_remap,			/*  25: mremap */
 	lx_msync,			/*  26: msync */
-	lx_mincore,			/*  27: mincore */
+	NULL,				/*  27: mincore */
 	lx_madvise,			/*  28: madvise */
 	lx_shmget,			/*  29: shmget */
 	lx_shmat,			/*  30: shmat */
 	lx_shmctl,			/*  31: shmctl */
 	NULL,				/*  32: dup */
 	NULL,				/*  33: dup2 */
-	lx_pause,			/*  34: pause */
+	NULL,				/*  34: pause */
 	NULL,				/*  35: nanosleep */
-	lx_getitimer,			/*  36: getitimer */
-	lx_alarm,			/*  37: alarm */
+	NULL,				/*  36: getitimer */
+	NULL,				/*  37: alarm */
 	lx_setitimer,			/*  38: setitimer */
 	NULL,				/*  39: getpid */
 	lx_sendfile64,			/*  40: sendfile */
@@ -1091,12 +1091,12 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_ftruncate,			/*  77: ftruncate */
 	NULL,				/*  78: getdents */
 	NULL,				/*  79: getcwd */
-	lx_chdir,			/*  80: chdir */
-	lx_fchdir,			/*  81: fchdir */
-	lx_rename,			/*  82: rename */
+	NULL,				/*  80: chdir */
+	NULL,				/*  81: fchdir */
+	NULL,				/*  82: rename */
 	NULL,				/*  83: mkdir */
 	lx_rmdir,			/*  84: rmdir */
-	lx_creat,			/*  85: creat */
+	NULL,				/*  85: creat */
 	NULL,				/*  86: link */
 	NULL,				/*  87: unlink */
 	NULL,				/*  88: symlink */
@@ -1109,21 +1109,21 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  95: umask */
 	NULL,				/*  96: gettimeofday */
 	NULL,				/*  97: getrlimit */
-	lx_getrusage,			/*  98: getrusage */
+	NULL,				/*  98: getrusage */
 	NULL,				/*  99: sysinfo */
 	lx_times,			/* 100: times */
 	NULL,				/* 101: ptrace */
 	NULL,				/* 102: getuid */
-	lx_syslog,			/* 103: syslog */
+	NULL,				/* 103: syslog */
 	NULL,				/* 104: getgid */
 	NULL,				/* 105: setuid */
 	NULL,				/* 106: setgid */
 	NULL,				/* 107: geteuid */
 	NULL,				/* 108: getegid */
-	lx_setpgid,			/* 109: setpgid */
+	NULL,				/* 109: setpgid */
 	NULL,				/* 110: getppid */
-	lx_getpgrp,			/* 111: getpgrp */
-	lx_setsid,			/* 112: setsid */
+	NULL,				/* 111: getpgrp */
+	NULL,				/* 112: setsid */
 	NULL,				/* 113: setreuid */
 	NULL,				/* 114: setregid */
 	lx_getgroups,			/* 115: getgroups */
@@ -1132,10 +1132,10 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 118: getresuid */
 	NULL,				/* 119: setresgid */
 	NULL,				/* 120: getresgid */
-	lx_getpgid,			/* 121: getpgid */
-	lx_setfsuid,			/* 122: setfsuid */
-	lx_setfsgid,			/* 123: setfsgid */
-	lx_getsid,			/* 124: getsid */
+	NULL,				/* 121: getpgid */
+	NULL,				/* 122: setfsuid */
+	NULL,				/* 123: setfsgid */
+	NULL,				/* 124: getsid */
 	lx_capget,			/* 125: capget */
 	lx_capset,			/* 126: capset */
 	lx_rt_sigpending,		/* 127: rt_sigpending */
@@ -1164,7 +1164,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_munlock,			/* 150: munlock */
 	lx_mlockall,			/* 151: mlockall */
 	lx_munlockall,			/* 152: munlockall */
-	lx_vhangup,			/* 153: vhangup */
+	NULL,				/* 153: vhangup */
 	NULL,				/* 154: modify_ldt */
 	NULL,				/* 155: pivot_root */
 	lx_sysctl,			/* 156: sysctl */
@@ -1172,17 +1172,17 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 158: arch_prctl */
 	lx_adjtimex,			/* 159: adjtimex */
 	NULL,				/* 160: setrlimit */
-	lx_chroot,			/* 161: chroot */
-	lx_sync,			/* 162: sync */
+	NULL,				/* 161: chroot */
+	NULL,				/* 162: sync */
 	NULL,				/* 163: acct */
 	lx_settimeofday,		/* 164: settimeofday */
 	lx_mount,			/* 165: mount */
 	NULL,				/* 166: umount2 */
 	NULL,				/* 167: swapon */
 	NULL,				/* 168: swapoff */
-	lx_reboot,			/* 169: reboot */
-	lx_sethostname,			/* 170: sethostname */
-	lx_setdomainname,		/* 171: setdomainname */
+	NULL,				/* 169: reboot */
+	NULL,				/* 170: sethostname */
+	NULL,				/* 171: setdomainname */
 	NULL,				/* 172: iopl */
 	NULL,				/* 173: ioperm */
 	NULL,				/* 174: create_module */
@@ -1232,7 +1232,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 218: set_tid_address */
 	NULL,				/* 219: restart_syscall */
 	lx_semtimedop,			/* 220: semtimedop */
-	lx_fadvise64_64,		/* 221: fadvise64 */
+	NULL,				/* 221: fadvise64 */
 	lx_timer_create,		/* 222: timer_create */
 	lx_timer_settime,		/* 223: timer_settime */
 	lx_timer_gettime,		/* 224: timer_gettime */
@@ -1275,7 +1275,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_futimesat,			/* 261: futimesat */
 	NULL,				/* 262: fstatat64 */
 	NULL,				/* 263: unlinkat */
-	lx_renameat,			/* 264: renameat */
+	NULL,				/* 264: renameat */
 	NULL,				/* 265: linkat */
 	NULL,				/* 266: symlinkat */
 	NULL,				/* 267: readlinkat */
@@ -1350,11 +1350,11 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*   5: open */
 	lx_close,			/*   6: close */
 	NULL,				/*   7: waitpid */
-	lx_creat,			/*   8: creat */
+	NULL,				/*   8: creat */
 	NULL,				/*   9: link */
 	NULL,				/*  10: unlink */
 	lx_execve,			/*  11: execve */
-	lx_chdir,			/*  12: chdir */
+	NULL,				/*  12: chdir */
 	NULL,				/*  13: time */
 	lx_mknod,			/*  14: mknod */
 	NULL,				/*  15: chmod */
@@ -1367,20 +1367,20 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  22: umount */
 	NULL,				/*  23: setuid16 */
 	NULL,				/*  24: getuid16 */
-	lx_stime,			/*  25: stime */
+	NULL,				/*  25: stime */
 	NULL,				/*  26: ptrace */
-	lx_alarm,			/*  27: alarm */
+	NULL,				/*  27: alarm */
 	NULL,				/*  28: fstat */
-	lx_pause,			/*  29: pause */
+	NULL,				/*  29: pause */
 	lx_utime,			/*  30: utime */
 	NULL,				/*  31: stty */
 	NULL,				/*  32: gtty */
 	NULL,				/*  33: access */
-	lx_nice,			/*  34: nice */
+	NULL,				/*  34: nice */
 	NULL,				/*  35: ftime */
-	lx_sync,			/*  36: sync */
+	NULL,				/*  36: sync */
 	NULL,				/*  37: kill */
-	lx_rename,			/*  38: rename */
+	NULL,				/*  38: rename */
 	NULL,				/*  39: mkdir */
 	lx_rmdir,			/*  40: rmdir */
 	NULL,				/*  41: dup */
@@ -1399,16 +1399,16 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  54: ioctl */
 	NULL,				/*  55: fcntl */
 	NULL,				/*  56: mpx */
-	lx_setpgid,			/*  57: setpgid */
+	NULL,				/*  57: setpgid */
 	NULL,				/*  58: ulimit */
 	NULL,				/*  59: olduname */
 	NULL,				/*  60: umask */
-	lx_chroot,			/*  61: chroot */
+	NULL,				/*  61: chroot */
 	NULL,				/*  62: ustat */
 	NULL,				/*  63: dup2 */
 	NULL,				/*  64: getppid */
-	lx_getpgrp,			/*  65: getpgrp */
-	lx_setsid,			/*  66: setsid */
+	NULL,				/*  65: getpgrp */
+	NULL,				/*  66: setsid */
 	lx_sigaction,			/*  67: sigaction */
 	NULL,				/*  68: sgetmask */
 	NULL,				/*  69: ssetmask */
@@ -1416,10 +1416,10 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  71: setregid16 */
 	lx_sigsuspend,			/*  72: sigsuspend */
 	lx_sigpending,			/*  73: sigpending */
-	lx_sethostname,			/*  74: sethostname */
+	NULL,				/*  74: sethostname */
 	NULL,				/*  75: setrlimit */
 	NULL,				/*  76: getrlimit */
-	lx_getrusage,			/*  77: getrusage */
+	NULL,				/*  77: getrusage */
 	NULL,				/*  78: gettimeofday */
 	lx_settimeofday,		/*  79: settimeofday */
 	lx_getgroups16,			/*  80: getgroups16 */
@@ -1430,10 +1430,10 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/*  85: readlink */
 	NULL,				/*  86: uselib */
 	NULL,				/*  87: swapon */
-	lx_reboot,			/*  88: reboot */
+	NULL,				/*  88: reboot */
 	lx_readdir,			/*  89: readdir */
 	lx_mmap,			/*  90: mmap */
-	lx_munmap,			/*  91: munmap */
+	NULL,				/*  91: munmap */
 	lx_truncate,			/*  92: truncate */
 	lx_ftruncate,			/*  93: ftruncate */
 	NULL,				/*  94: fchmod */
@@ -1445,15 +1445,15 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_fstatfs,			/* 100: fstatfs */
 	NULL,				/* 101: ioperm */
 	NULL,				/* 102: socketcall */
-	lx_syslog,			/* 103: syslog */
+	NULL,				/* 103: syslog */
 	lx_setitimer,			/* 104: setitimer */
-	lx_getitimer,			/* 105: getitimer */
+	NULL,				/* 105: getitimer */
 	NULL,				/* 106: stat */
 	NULL,				/* 107: lstat */
 	NULL,				/* 108: fstat */
 	NULL,				/* 109: uname */
 	NULL,				/* 110: oldiopl */
-	lx_vhangup,			/* 111: vhangup */
+	NULL,				/* 111: vhangup */
 	NULL,				/* 112: idle */
 	NULL,				/* 113: vm86old */
 	NULL,				/* 114: wait4 */
@@ -1463,7 +1463,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_fsync,			/* 118: fsync */
 	lx_sigreturn,			/* 119: sigreturn */
 	lx_clone,			/* 120: clone */
-	lx_setdomainname,		/* 121: setdomainname */
+	NULL,				/* 121: setdomainname */
 	NULL,				/* 122: uname */
 	NULL,				/* 123: modify_ldt */
 	lx_adjtimex,			/* 124: adjtimex */
@@ -1474,14 +1474,14 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 129: delete_module */
 	NULL,				/* 130: get_kernel_syms */
 	NULL,				/* 131: quotactl */
-	lx_getpgid,			/* 132: getpgid */
-	lx_fchdir,			/* 133: fchdir */
+	NULL,				/* 132: getpgid */
+	NULL,				/* 133: fchdir */
 	NULL,				/* 134: bdflush */
 	lx_sysfs,			/* 135: sysfs */
 	NULL,				/* 136: personality */
 	NULL,				/* 137: afs_syscall */
-	lx_setfsuid16,			/* 138: setfsuid16 */
-	lx_setfsgid16,			/* 139: setfsgid16 */
+	NULL,				/* 138: setfsuid16 */
+	NULL,				/* 139: setfsgid16 */
 	NULL,				/* 140: llseek */
 	NULL,				/* 141: getdents */
 	NULL,				/* 142: select */
@@ -1489,7 +1489,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_msync,			/* 144: msync */
 	NULL,				/* 145: readv */
 	NULL,				/* 146: writev */
-	lx_getsid,			/* 147: getsid */
+	NULL,				/* 147: getsid */
 	lx_fdatasync,			/* 148: fdatasync */
 	lx_sysctl,			/* 149: sysctl */
 	lx_mlock,			/* 150: mlock */
@@ -1557,10 +1557,10 @@ static lx_syscall_handler_t lx_handlers[] = {
 	NULL,				/* 212: chown */
 	NULL,				/* 213: setuid */
 	NULL,				/* 214: setgid */
-	lx_setfsuid,			/* 215: setfsuid */
-	lx_setfsgid,			/* 216: setfsgid */
+	NULL,				/* 215: setfsuid */
+	NULL,				/* 216: setfsgid */
 	NULL,				/* 217: pivot_root */
-	lx_mincore,			/* 218: mincore */
+	NULL,				/* 218: mincore */
 	lx_madvise,			/* 219: madvise */
 	NULL,				/* 220: getdents64 */
 	NULL,				/* 221: fcntl64 */
@@ -1592,7 +1592,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_io_getevents,		/* 247: io_getevents */
 	lx_io_submit,			/* 248: io_submit */
 	lx_io_cancel,			/* 249: io_cancel */
-	lx_fadvise64,			/* 250: fadvise64 */
+	NULL,				/* 250: fadvise64 */
 	NULL,				/* 251: nosys */
 	lx_group_exit,			/* 252: group_exit */
 	NULL,				/* 253: lookup_dcookie */
@@ -1614,7 +1614,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_fstatfs64,			/* 269: fstatfs64 */
 	NULL,				/* 270: tgkill */
 	lx_utimes,			/* 271: utimes */
-	lx_fadvise64_64,		/* 272: fadvise64_64 */
+	NULL,			/* 272: fadvise64_64 */
 	NULL,				/* 273: vserver */
 	NULL,				/* 274: mbind */
 	NULL,				/* 275: get_mempolicy */
@@ -1644,7 +1644,7 @@ static lx_syscall_handler_t lx_handlers[] = {
 	lx_futimesat,			/* 299: futimesat */
 	NULL,				/* 300: fstatat64 */
 	NULL,				/* 301: unlinkat */
-	lx_renameat,			/* 302: renameat */
+	NULL,				/* 302: renameat */
 	NULL,				/* 303: linkat */
 	NULL,				/* 304: symlinkat */
 	NULL,				/* 305: readlinkat */
diff --git a/usr/src/lib/brand/lx/lx_brand/common/misc.c b/usr/src/lib/brand/lx/lx_brand/common/misc.c
index 4f5edb62f6..1969ac250c 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/misc.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/misc.c
@@ -45,119 +45,6 @@
 #include <sys/lx_syscall.h>
 #include <sys/lx_fcntl.h>
 
-extern int sethostname(char *, int);
-
-/* ARGUSED */
-long
-lx_rename(uintptr_t p1, uintptr_t p2)
-{
-	int ret;
-
-	ret = rename((const char *)p1, (const char *)p2);
-
-	if (ret < 0) {
-		/*
-		 * If rename(2) failed and we're in install mode, return
-		 * success if the the reason we failed was either because the
-		 * source file didn't actually exist or if it was because we
-		 * tried to rename it to be the name of a device currently in
-		 * use (resulting in an EBUSY.)
-		 *
-		 * To help install along further, if the failure was due
-		 * to an EBUSY, delete the original file so we don't leave
-		 * extra files lying around.
-		 */
-		if (lx_install != 0) {
-			if (errno == ENOENT)
-				return (0);
-
-			if (errno == EBUSY) {
-				(void) unlink((const char *)p1);
-				return (0);
-			}
-		}
-
-		return (-errno);
-	}
-
-	return (0);
-}
-
-long
-lx_renameat(uintptr_t ext1, uintptr_t p1, uintptr_t ext2, uintptr_t p2)
-{
-	int ret;
-	int atfd1 = (int)ext1;
-	int atfd2 = (int)ext2;
-
-	if (atfd1 == LX_AT_FDCWD)
-		atfd1 = AT_FDCWD;
-
-	if (atfd2 == LX_AT_FDCWD)
-		atfd2 = AT_FDCWD;
-
-	ret = renameat(atfd1, (const char *)p1, atfd2, (const char *)p2);
-
-	if (ret < 0) {
-		/* see lx_rename() for why we check lx_install */
-		if (lx_install != 0) {
-			if (errno == ENOENT)
-				return (0);
-
-			if (errno == EBUSY) {
-				(void) unlinkat(ext1, (const char *)p1, 0);
-				return (0);
-			}
-		}
-
-		return (-errno);
-	}
-
-	return (0);
-}
-
-/*ARGSUSED*/
-long
-lx_reboot(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4)
-{
-	int magic = (int)p1;
-	int magic2 = (int)p2;
-	uint_t flag = (int)p3;
-	int rc;
-
-	if (magic != LINUX_REBOOT_MAGIC1)
-		return (-EINVAL);
-	if (magic2 != LINUX_REBOOT_MAGIC2 && magic2 != LINUX_REBOOT_MAGIC2A &&
-	    magic2 != LINUX_REBOOT_MAGIC2B && magic2 != LINUX_REBOOT_MAGIC2C &&
-	    magic2 != LINUX_REBOOT_MAGIC2D)
-		return (-EINVAL);
-
-	if (geteuid() != 0)
-		return (-EPERM);
-
-	switch (flag) {
-	case LINUX_REBOOT_CMD_CAD_ON:
-	case LINUX_REBOOT_CMD_CAD_OFF:
-		/* ignored */
-		rc = 0;
-		break;
-	case LINUX_REBOOT_CMD_POWER_OFF:
-	case LINUX_REBOOT_CMD_HALT:
-		rc = reboot(RB_HALT, NULL);
-		break;
-	case LINUX_REBOOT_CMD_RESTART:
-	case LINUX_REBOOT_CMD_RESTART2:
-		/* RESTART2 may need more work */
-		lx_msg("Restarting system.\n");
-		rc = reboot(RB_AUTOBOOT, NULL);
-		break;
-	default:
-		return (-EINVAL);
-	}
-
-	return ((rc == -1) ? -errno : rc);
-}
-
 /*
  * {get,set}groups16() - Handle the conversion between 16-bit Linux gids and
  * 32-bit illumos gids.
@@ -344,30 +231,6 @@ lx_mknod(uintptr_t p1, uintptr_t p2, uintptr_t p3)
 	return (mknod(path, mode | type, dev) ? -errno : 0);
 }
 
-long
-lx_sethostname(uintptr_t p1, uintptr_t p2)
-{
-	char *name = (char *)p1;
-	int len = (size_t)p2;
-
-	return (sethostname(name, len) ? -errno : 0);
-}
-
-long
-lx_setdomainname(uintptr_t p1, uintptr_t p2)
-{
-	char *name = (char *)p1;
-	int len = (size_t)p2;
-	long rval;
-
-	if (len < 0 || len >= LX_SYS_UTS_LN)
-		return (-EINVAL);
-
-	rval = sysinfo(SI_SET_SRPC_DOMAIN, name, len);
-
-	return ((rval < 0) ? -errno : 0);
-}
-
 long
 lx_execve(uintptr_t p1, uintptr_t p2, uintptr_t p3)
 {
@@ -432,44 +295,6 @@ lx_setgroups(uintptr_t p1, uintptr_t p2)
 	return ((r == -1) ? -errno : r);
 }
 
-/*
- * For syslog(), as there is no kernel and nothing to log, we simply emulate a
- * kernel cyclic buffer (LOG_BUF_LEN) of 0 bytes, only handling errors for bad
- * input.  All actions except 3 and 10 require CAP_SYS_ADMIN or CAP_SYSLOG, in
- * lieu of full capabilities support for now we just perform an euid check.
- */
-long
-lx_syslog(int type, char *bufp, int len)
-{
-	if (type < 0 || type > 10)
-		return (-EINVAL);
-
-	if ((type != 3 && type != 10) && (geteuid() != 0))
-		return (-EPERM);
-
-	if ((type >= 2 && type <= 4) && (bufp == NULL || len < 0))
-		return (-EINVAL);
-
-	if ((type == 8) && (len < 1 || len > 8))
-		return (-EINVAL);
-
-	return (0);
-}
-
-/*
- * The following are pass-through functions but we need to return the correct
- * long so that the errno propagates back to the Linux code correctly.
- */
-
-long
-lx_alarm(unsigned int seconds)
-{
-	int r;
-
-	r = alarm(seconds);
-	return ((r == -1) ? -errno : r);
-}
-
 long
 lx_close(int fildes)
 {
@@ -479,42 +304,6 @@ lx_close(int fildes)
 	return ((r == -1) ? -errno : r);
 }
 
-long
-lx_chdir(const char *path)
-{
-	int r;
-
-	r = chdir(path);
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_chroot(const char *path)
-{
-	int r;
-
-	r = chroot(path);
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_creat(const char *path, mode_t mode)
-{
-	int r;
-
-	r = creat(path, mode);
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_fchdir(int fildes)
-{
-	int r;
-
-	r = fchdir(fildes);
-	return ((r == -1) ? -errno : r);
-}
-
 long
 lx_getgroups(int gidsetsize, gid_t *grouplist)
 {
@@ -524,15 +313,6 @@ lx_getgroups(int gidsetsize, gid_t *grouplist)
 	return ((r == -1) ? -errno : r);
 }
 
-long
-lx_getitimer(int which, struct itimerval *value)
-{
-	int r;
-
-	r = getitimer(which, value);
-	return ((r == -1) ? -errno : r);
-}
-
 long
 lx_inotify_add_watch(int fd, const char *pathname, uint32_t mask)
 {
@@ -569,51 +349,6 @@ lx_inotify_rm_watch(int fd, int wd)
 	return ((r == -1) ? -errno : r);
 }
 
-long
-lx_mincore(caddr_t addr, size_t len, char *vec)
-{
-	int r;
-
-	r = mincore(addr, len, vec);
-	if (r == -1 && errno == EINVAL) {
-		/*
-		 * LTP mincore01 expects mincore with a huge len to fail with
-		 * ENOMEM on a modern kernel but on Linux 2.6.11 and earlier it
-		 * returns EINVAL.
-		 */
-		if (strcmp(lx_release, "2.6.11") > 0 && (long)len < 0)
-			errno = ENOMEM;
-	}
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_munmap(void *addr, size_t len)
-{
-	int r;
-
-	r = munmap(addr, len);
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_nice(int incr)
-{
-	int r;
-
-	r = nice(incr);
-	return ((r == -1) ? -errno : r);
-}
-
-long
-lx_pause(void)
-{
-	int r;
-
-	r = pause();
-	return ((r == -1) ? -errno : r);
-}
-
 long
 lx_shmdt(char *shmaddr)
 {
@@ -623,15 +358,6 @@ lx_shmdt(char *shmaddr)
 	return ((r == -1) ? -errno : r);
 }
 
-long
-lx_stime(const time_t *tp)
-{
-	int r;
-
-	r = stime(tp);
-	return ((r == -1) ? -errno : r);
-}
-
 long
 lx_utimes(const char *path, const struct timeval times[2])
 {
@@ -641,17 +367,6 @@ lx_utimes(const char *path, const struct timeval times[2])
 	return ((r == -1) ? -errno : r);
 }
 
-long
-lx_vhangup(void)
-{
-	if (geteuid() != 0)
-		return (-EPERM);
-
-	vhangup();
-
-	return (0);
-}
-
 long
 lx_eventfd(unsigned int initval)
 {
@@ -674,28 +389,3 @@ lx_eventfd2(unsigned int initval, int flags)
 
 	return (r == -1 ? -errno : r);
 }
-
-/*
- * We lucked out here.  Linux and Solaris have exactly the same
- * rusage structures.
- */
-long
-lx_getrusage(uintptr_t p1, uintptr_t p2)
-{
-	int who = (int)p1;
-	struct rusage *rup = (struct rusage *)p2;
-	int rv, swho;
-
-	if (who == LX_RUSAGE_SELF)
-		swho = RUSAGE_SELF;
-	else if (who == LX_RUSAGE_CHILDREN)
-		swho = RUSAGE_CHILDREN;
-	else if (who == LX_RUSAGE_THREAD)
-		swho = RUSAGE_LWP;
-	else
-		return (-EINVAL);
-
-	rv = getrusage(swho, rup);
-
-	return (rv < 0 ? -errno : 0);
-}
diff --git a/usr/src/lib/brand/lx/lx_brand/common/pgrp.c b/usr/src/lib/brand/lx/lx_brand/common/pgrp.c
deleted file mode 100644
index 33b4bb7667..0000000000
--- a/usr/src/lib/brand/lx/lx_brand/common/pgrp.c
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- * Copyright 2014 Joyent, Inc.  All rights reserved.
- */
-
-#include <sys/types.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/lx_misc.h>
-#include <sys/lx_syscall.h>
-
-long
-lx_getpgrp(void)
-{
-	int ret;
-
-	ret = getpgrp();
-
-	/*
-	 * If the pgrp is that of the init process, return the value Linux
-	 * expects.
-	 */
-	if (ret == zoneinit_pid)
-		return (LX_INIT_PGID);
-
-	return ((ret == -1) ? -errno : ret);
-}
-
-long
-lx_getpgid(uintptr_t p1)
-{
-	pid_t spid;
-	int pid = (int)p1;
-	int ret;
-
-	if (pid < 0)
-		return (-ESRCH);
-
-	/*
-	 * If the supplied pid matches that of the init process, return
-	 * the pgid Linux expects.
-	 */
-	if (pid == zoneinit_pid)
-		return (LX_INIT_PGID);
-
-	if ((ret = lx_lpid_to_spid(pid, &spid)) < 0)
-		return (ret);
-
-	ret = getpgid(spid);
-
-	/*
-	 * If the pgid is that of the init process, return the value Linux
-	 * expects.
-	 */
-	if (ret == zoneinit_pid)
-		return (LX_INIT_PGID);
-
-	return ((ret == -1) ? -errno : ret);
-}
-
-long
-lx_setpgid(uintptr_t p1, uintptr_t p2)
-{
-	pid_t pid = (pid_t)p1;
-	pid_t pgid = (pid_t)p2;
-	pid_t spid, spgid;
-	int ret;
-
-	if (pid < 0)
-		return (-ESRCH);
-
-	if (pgid < 0)
-		return (-EINVAL);
-
-	if ((ret = lx_lpid_to_spid(pid, &spid)) < 0)
-		return (ret);
-
-	if (pgid == 0)
-		spgid = spid;
-	else if ((ret = lx_lpid_to_spid(pgid, &spgid)) < 0)
-		return (ret);
-
-	ret = setpgid(spid, spgid);
-
-	if (ret != 0 && errno == EPERM) {
-		/*
-		 * On Linux, calling setpgid with a desired pgid that is equal
-		 * to the current pgid of the process, no error is emitted.
-		 * This differs slightly from illumos which will return EPERM.
-		 *
-		 * To emulate the Linux behavior, we check specifically for
-		 * matching pgids if an EPERM is encountered.
-		 */
-		if (spgid == getpgid(spid))
-			return (0);
-		else
-			return (-EPERM);
-	}
-
-	return ((ret == 0) ? 0 : -errno);
-}
-
-long
-lx_getsid(uintptr_t p1)
-{
-	pid_t spid;
-	int pid = (int)p1;
-	int ret;
-
-	if (pid < 0)
-		return (-ESRCH);
-
-	/*
-	 * If the supplied matches that of the init process, return the value
-	 * Linux expects.
-	 */
-	if (pid == zoneinit_pid)
-		return (LX_INIT_SID);
-
-	if ((ret = lx_lpid_to_spid(pid, &spid)) < 0)
-		return (ret);
-
-	ret = getsid(spid);
-
-	/*
-	 * If the sid is that of the init process, return the value Linux
-	 * expects.
-	 */
-	if (ret == zoneinit_pid)
-		return (LX_INIT_SID);
-
-	return ((ret == -1) ? -errno : ret);
-}
-
-long
-lx_setsid(void)
-{
-	int ret;
-
-	ret = setsid();
-
-	/*
-	 * If the pgid is that of the init process, return the value Linux
-	 * expects.
-	 */
-	if (ret == zoneinit_pid)
-		return (LX_INIT_SID);
-
-	return ((ret == -1) ? -errno : ret);
-}
diff --git a/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h b/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
index 7b2cf5eb7d..4bbde06bff 100644
--- a/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
+++ b/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
@@ -56,32 +56,8 @@ extern boolean_t lx_no_abort_handler;
 /*
  * Values Linux expects for init
  */
-#define	LX_INIT_PGID	1
-#define	LX_INIT_SID	1
 #define	LX_INIT_PID	1
 
-/*
- * Codes to reboot(2).
- */
-#define	LINUX_REBOOT_MAGIC1		0xfee1dead
-#define	LINUX_REBOOT_MAGIC2		672274793
-#define	LINUX_REBOOT_MAGIC2A		85072278
-#define	LINUX_REBOOT_MAGIC2B		369367448
-#define	LINUX_REBOOT_MAGIC2C		537993216
-
-/*
- * This was observed as coming from Red Hat's init process, but it's not in
- * their reboot(2) man page.
- */
-#define	LINUX_REBOOT_MAGIC2D		0x28121969
-
-#define	LINUX_REBOOT_CMD_RESTART	0x1234567
-#define	LINUX_REBOOT_CMD_HALT		0xcdef0123
-#define	LINUX_REBOOT_CMD_POWER_OFF	0x4321fedc
-#define	LINUX_REBOOT_CMD_RESTART2	0xa1b2c3d4
-#define	LINUX_REBOOT_CMD_CAD_ON		0x89abcdef
-#define	LINUX_REBOOT_CMD_CAD_OFF	0
-
 /*
  * the maximum length of messages to be output with lx_msg(), lx_err(),
  * lx_debug(), or lx_unsupported().
@@ -96,14 +72,6 @@ extern boolean_t lx_no_abort_handler;
 #define	LX_SCHED_PRIORITY_MIN_RRFIFO	1
 #define	LX_SCHED_PRIORITY_MAX_RRFIFO	99
 
-/*
- * Constants to indicate who getrusage() should return information about.
- */
-#define	LX_RUSAGE_SELF		0
-#define	LX_RUSAGE_CHILDREN	(-1)
-#define	LX_RUSAGE_BOTH		(-2)
-#define	LX_RUSAGE_THREAD	1
-
 /*
  * Based on code from brand_misc.h, but use of that is incompatible with the
  * lx brand.
diff --git a/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h b/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
index caa56ba647..ed6f4c2bc4 100644
--- a/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
+++ b/usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
@@ -54,7 +54,6 @@ extern long lx_fstat(uintptr_t, uintptr_t);
 extern long lx_lstat(uintptr_t, uintptr_t);
 extern long lx_stat64(uintptr_t, uintptr_t);
 extern long lx_fstat64(uintptr_t, uintptr_t);
-extern long lx_renameat(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 extern long lx_lstat64(uintptr_t, uintptr_t);
 extern long lx_fcntl(uintptr_t, uintptr_t, uintptr_t);
 extern long lx_fcntl64(uintptr_t, uintptr_t, uintptr_t);
@@ -62,29 +61,13 @@ extern long lx_flock(uintptr_t, uintptr_t);
 extern long lx_readdir(uintptr_t, uintptr_t, uintptr_t);
 extern long lx_execve(uintptr_t, uintptr_t, uintptr_t);
 extern long lx_ioctl(uintptr_t, uintptr_t, uintptr_t);
-extern long lx_vhangup(void);
-extern long lx_fadvise64(uintptr_t, off64_t, uintptr_t, uintptr_t);
-extern long lx_fadvise64_64(uintptr_t, off64_t, off64_t, uintptr_t);
 
 extern long lx_settimeofday(uintptr_t, uintptr_t);
-extern long lx_getrusage(uintptr_t, uintptr_t);
 extern long lx_mknod(uintptr_t, uintptr_t, uintptr_t);
 
-extern long lx_getpgrp(void);
-extern long lx_getpgid(uintptr_t);
-extern long lx_setpgid(uintptr_t, uintptr_t);
-extern long lx_getsid(uintptr_t);
-extern long lx_setsid(void);
-
 extern long lx_capget(uintptr_t, uintptr_t);
 extern long lx_capset(uintptr_t, uintptr_t);
 
-extern long lx_setfsuid16(uintptr_t);
-extern long lx_setfsgid16(uintptr_t);
-
-extern long lx_setfsuid(uintptr_t);
-extern long lx_setfsgid(uintptr_t);
-
 extern long lx_clock_nanosleep(int, int flags, struct timespec *,
     struct timespec *);
 extern long lx_adjtimex(void *);
@@ -104,12 +87,10 @@ extern long lx_sysctl(uintptr_t);
 extern long lx_fsync(uintptr_t);
 extern long lx_fdatasync(uintptr_t);
 extern long lx_rmdir(uintptr_t);
-extern long lx_rename(uintptr_t, uintptr_t);
 extern long lx_utime(uintptr_t, uintptr_t);
 extern long lx_sysfs(uintptr_t, uintptr_t, uintptr_t);
 
 extern long lx_uname(uintptr_t);
-extern long lx_reboot(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 extern long lx_getgroups16(uintptr_t, uintptr_t);
 extern long lx_setgroups(uintptr_t, uintptr_t);
 extern long lx_setgroups16(uintptr_t, uintptr_t);
@@ -161,8 +142,6 @@ extern long lx_rt_sigtimedwait(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 extern long lx_rt_sigqueueinfo(uintptr_t, uintptr_t, uintptr_t);
 extern long lx_rt_tgsigqueueinfo(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
-extern long lx_sync(void);
-
 extern long lx_futex(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
     uintptr_t);
 
@@ -171,9 +150,6 @@ extern long lx_tkill(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
 extern long lx_tgkill(uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
     uintptr_t);
 
-extern long lx_sethostname(uintptr_t, uintptr_t);
-extern long lx_setdomainname(uintptr_t, uintptr_t);
-
 extern long lx_sendfile(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 extern long lx_sendfile64(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
@@ -215,29 +191,17 @@ extern long lx_shmget(key_t, size_t, int);
 extern long lx_shmat(int, void *, int);
 extern long lx_shmctl(int, int, void *);
 
-extern long lx_alarm(unsigned int);
 extern long lx_close(int);
-extern long lx_chdir(const char *);
-extern long lx_chroot(const char *);
-extern long lx_creat(const char *, mode_t);
 extern long lx_eventfd(unsigned int);
 extern long lx_eventfd2(unsigned int, int);
-extern long lx_fchdir(int);
 extern long lx_getgroups(int, gid_t *);
-extern long lx_getitimer(int, struct itimerval *);
 extern long lx_inotify_add_watch(int, const char *, uint32_t);
 extern long lx_inotify_init(void);
 extern long lx_inotify_init1(int);
 extern long lx_inotify_rm_watch(int, int);
-extern long lx_mincore(caddr_t, size_t, char *);
-extern long lx_munmap(void *, size_t);
-extern long lx_nice(int);
-extern long lx_pause(void);
 extern long lx_shmdt(char *);
 extern long lx_signalfd(int, uintptr_t, size_t);
 extern long lx_signalfd4(int, uintptr_t, size_t, int);
-extern long lx_stime(const time_t *);
-extern long lx_syslog(int, char *, int);
 extern long lx_timerfd_create(int, int);
 extern long lx_timerfd_settime(int, int,
     const struct itimerspec *, struct itimerspec *);
diff --git a/usr/src/uts/common/brand/lx/os/lx_syscall.c b/usr/src/uts/common/brand/lx/os/lx_syscall.c
index e2f3213ed1..037cdebcb9 100644
--- a/usr/src/uts/common/brand/lx/os/lx_syscall.c
+++ b/usr/src/uts/common/brand/lx/os/lx_syscall.c
@@ -529,11 +529,11 @@ lx_sysent_t lx_sysent32[] = {
 	{"open",	lx_open,		0,		3}, /*  5 */
 	{"close",	lx_close,		0,		1}, /*  6 */
 	{"waitpid",	lx_waitpid,		0,		3}, /*  7 */
-	{"creat",	NULL,			0,		2}, /*  8 */
+	{"creat",	lx_creat,		0,		2}, /*  8 */
 	{"link",	lx_link,		0,		2}, /*  9 */
 	{"unlink",	lx_unlink,		0,		1}, /* 10 */
 	{"execve",	NULL,			0,		3}, /* 11 */
-	{"chdir",	NULL,			0,		1}, /* 12 */
+	{"chdir",	lx_chdir,		0,		1}, /* 12 */
 	{"time",	lx_time,		0,		1}, /* 13 */
 	{"mknod",	NULL,			0,		3}, /* 14 */
 	{"chmod",	lx_chmod,		0,		2}, /* 15 */
@@ -546,20 +546,20 @@ lx_sysent_t lx_sysent32[] = {
 	{"umount",	lx_umount,		0,		1}, /* 22 */
 	{"setuid16",	lx_setuid16,		0,		1}, /* 23 */
 	{"getuid16",	lx_getuid16,		0,		0}, /* 24 */
-	{"stime",	NULL,			0,		1}, /* 25 */
+	{"stime",	lx_stime,		0,		1}, /* 25 */
 	{"ptrace",	lx_ptrace,		0,		4}, /* 26 */
-	{"alarm",	NULL,			0,		1}, /* 27 */
+	{"alarm",	lx_alarm,		0,		1}, /* 27 */
 	{"fstat",	NULL,			NOSYS_OBSOLETE,	0}, /* 28 */
-	{"pause",	NULL,			0,		0}, /* 29 */
+	{"pause",	lx_pause,		0,		0}, /* 29 */
 	{"utime",	NULL,			0,		2}, /* 30 */
 	{"stty",	NULL,			NOSYS_OBSOLETE,	0}, /* 31 */
 	{"gtty",	NULL,			NOSYS_OBSOLETE,	0}, /* 32 */
 	{"access",	lx_access,		0,		2}, /* 33 */
-	{"nice",	NULL,			0,		1}, /* 34 */
+	{"nice",	lx_nice,		0,		1}, /* 34 */
 	{"ftime",	NULL,			NOSYS_OBSOLETE,	0}, /* 35 */
-	{"sync",	NULL,			0, 		0}, /* 36 */
+	{"sync",	lx_sync,		0, 		0}, /* 36 */
 	{"kill",	lx_kill,		0,		2}, /* 37 */
-	{"rename",	NULL,			0,		2}, /* 38 */
+	{"rename",	lx_rename,		0,		2}, /* 38 */
 	{"mkdir",	lx_mkdir,		0,		2}, /* 39 */
 	{"rmdir",	NULL,			0,		1}, /* 40 */
 	{"dup",		lx_dup,			0,		1}, /* 41 */
@@ -578,16 +578,16 @@ lx_sysent_t lx_sysent32[] = {
 	{"ioctl",	lx_ioctl,		0,		3}, /* 54 */
 	{"fcntl",	lx_fcntl,		0,		3}, /* 55 */
 	{"mpx",		NULL,			NOSYS_OBSOLETE,	0}, /* 56 */
-	{"setpgid",	NULL,			0,		2}, /* 57 */
+	{"setpgid",	lx_setpgid,		0,		2}, /* 57 */
 	{"ulimit",	NULL,			NOSYS_OBSOLETE,	0}, /* 58 */
 	{"olduname",	NULL,			NOSYS_OBSOLETE,	0}, /* 59 */
 	{"umask",	lx_umask,		0,		1}, /* 60 */
-	{"chroot",	NULL,			0,		1}, /* 61 */
+	{"chroot",	lx_chroot,		0,		1}, /* 61 */
 	{"ustat",	NULL,			NOSYS_OBSOLETE,	2}, /* 62 */
 	{"dup2",	lx_dup2,		0,		2}, /* 63 */
 	{"getppid",	lx_getppid,		0,		0}, /* 64 */
-	{"getpgrp",	NULL,			0,		0}, /* 65 */
-	{"setsid",	NULL,			0,		0}, /* 66 */
+	{"getpgrp",	lx_getpgrp,		0,		0}, /* 65 */
+	{"setsid",	lx_setsid,		0,		0}, /* 66 */
 	{"sigaction",	NULL,			0,		3}, /* 67 */
 	{"sgetmask",	NULL,			NOSYS_OBSOLETE,	0}, /* 68 */
 	{"ssetmask",	NULL,			NOSYS_OBSOLETE,	0}, /* 69 */
@@ -595,10 +595,10 @@ lx_sysent_t lx_sysent32[] = {
 	{"setregid16",	lx_setregid16,		0,		2}, /* 71 */
 	{"sigsuspend",	NULL,			0,		1}, /* 72 */
 	{"sigpending",	NULL,			0,		1}, /* 73 */
-	{"sethostname",	NULL,			0,		2}, /* 74 */
+	{"sethostname",	lx_sethostname,		0,		2}, /* 74 */
 	{"setrlimit",	lx_setrlimit,		0,		2}, /* 75 */
 	{"getrlimit",	lx_oldgetrlimit,	0,		2}, /* 76 */
-	{"getrusage",	NULL,			0,		2}, /* 77 */
+	{"getrusage",	lx_getrusage,		0,		2}, /* 77 */
 	{"gettimeofday", lx_gettimeofday,	0,		2}, /* 78 */
 	{"settimeofday", NULL, 			0,		2}, /* 79 */
 	{"getgroups16",	NULL,			0,		2}, /* 80 */
@@ -609,10 +609,10 @@ lx_sysent_t lx_sysent32[] = {
 	{"readlink",	lx_readlink,		0,		3}, /* 85 */
 	{"uselib",	NULL,			NOSYS_KERNEL,	0}, /* 86 */
 	{"swapon",	NULL,			NOSYS_KERNEL,	0}, /* 87 */
-	{"reboot",	NULL,			0,		4}, /* 88 */
+	{"reboot",	lx_reboot,		0,		4}, /* 88 */
 	{"readdir",	NULL,			0,		3}, /* 89 */
 	{"mmap",	NULL,			0,		6}, /* 90 */
-	{"munmap",	NULL,			0,		2}, /* 91 */
+	{"munmap",	lx_munmap,		0,		2}, /* 91 */
 	{"truncate",	NULL,			0,		2}, /* 92 */
 	{"ftruncate",	NULL,			0,		2}, /* 93 */
 	{"fchmod",	lx_fchmod,		0,		2}, /* 94 */
@@ -624,15 +624,15 @@ lx_sysent_t lx_sysent32[] = {
 	{"fstatfs",	NULL,			0,		2}, /* 100 */
 	{"ioperm",	NULL,			NOSYS_NO_EQUIV,	0}, /* 101 */
 	{"socketcall",	lx_socketcall,		0,		2}, /* 102 */
-	{"syslog",	NULL,			0,		3}, /* 103 */
+	{"syslog",	lx_syslog,		0,		3}, /* 103 */
 	{"setitimer",	NULL,			0,		3}, /* 104 */
-	{"getitimer",	NULL,			0,		2}, /* 105 */
+	{"getitimer",	lx_getitimer,		0,		2}, /* 105 */
 	{"stat",	lx_stat32,		0,		2}, /* 106 */
 	{"lstat",	lx_lstat32,		0,		2}, /* 107 */
 	{"fstat",	lx_fstat32,		0,		2}, /* 108 */
 	{"uname",	NULL,			NOSYS_OBSOLETE,	0}, /* 109 */
 	{"oldiopl",	NULL,			NOSYS_NO_EQUIV,	0}, /* 110 */
-	{"vhangup",	NULL,			0,		0}, /* 111 */
+	{"vhangup",	lx_vhangup,		0,		0}, /* 111 */
 	{"idle",	NULL,			NOSYS_NO_EQUIV,	0}, /* 112 */
 	{"vm86old",	NULL,			NOSYS_OBSOLETE,	0}, /* 113 */
 	{"wait4",	lx_wait4,		0,		4}, /* 114 */
@@ -642,7 +642,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"fsync",	NULL,			0,		1}, /* 118 */
 	{"sigreturn",	NULL,			0,		1}, /* 119 */
 	{"clone",	NULL,			0,		5}, /* 120 */
-	{"setdomainname", NULL,			0,		2}, /* 121 */
+	{"setdomainname", lx_setdomainname,	0,		2}, /* 121 */
 	{"uname",	lx_uname,		0,		1}, /* 122 */
 	{"modify_ldt",	lx_modify_ldt,		0,		3}, /* 123 */
 	{"adjtimex",	NULL,			0,		1}, /* 124 */
@@ -653,14 +653,14 @@ lx_sysent_t lx_sysent32[] = {
 	{"delete_module", NULL,			NOSYS_KERNEL,	0}, /* 129 */
 	{"get_kernel_syms", NULL,		NOSYS_KERNEL,	0}, /* 130 */
 	{"quotactl",	NULL,			NOSYS_KERNEL,	0}, /* 131 */
-	{"getpgid",	NULL,			0,		1}, /* 132 */
-	{"fchdir",	NULL,			0,		1}, /* 133 */
+	{"getpgid",	lx_getpgid,		0,		1}, /* 132 */
+	{"fchdir",	lx_fchdir,		0,		1}, /* 133 */
 	{"bdflush",	NULL,			NOSYS_KERNEL,	0}, /* 134 */
 	{"sysfs",	NULL,			0,		3}, /* 135 */
 	{"personality",	lx_personality,		0,		1}, /* 136 */
 	{"afs_syscall",	NULL,			NOSYS_KERNEL,	0}, /* 137 */
-	{"setfsuid16",	NULL,			0,		1}, /* 138 */
-	{"setfsgid16",	NULL,			0,		1}, /* 139 */
+	{"setfsuid16",	lx_setfsuid16,		0,		1}, /* 138 */
+	{"setfsgid16",	lx_setfsgid16,		0,		1}, /* 139 */
 	{"llseek",	lx_llseek,		0,		5}, /* 140 */
 	{"getdents",	lx_getdents_32,		0,		3}, /* 141 */
 	{"select",	lx_select,		0,		5}, /* 142 */
@@ -668,7 +668,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"msync",	NULL,			0,		3}, /* 144 */
 	{"readv",	lx_readv,		0,		3}, /* 145 */
 	{"writev",	lx_writev,		0,		3}, /* 146 */
-	{"getsid",	NULL,			0,		1}, /* 147 */
+	{"getsid",	lx_getsid,		0,		1}, /* 147 */
 	{"fdatasync",	NULL,			0,		1}, /* 148 */
 	{"sysctl",	NULL,			0,		1}, /* 149 */
 	{"mlock",	NULL,			0,		2}, /* 150 */
@@ -736,10 +736,10 @@ lx_sysent_t lx_sysent32[] = {
 	{"chown",	lx_chown,		0,		3}, /* 212 */
 	{"setuid",	lx_setuid,		0,		1}, /* 213 */
 	{"setgid",	lx_setgid,		0,		1}, /* 214 */
-	{"setfsuid",	NULL,			0,		1}, /* 215 */
-	{"setfsgid",	NULL,			0,		1}, /* 216 */
+	{"setfsuid",	lx_setfsuid,		0,		1}, /* 215 */
+	{"setfsgid",	lx_setfsgid,		0,		1}, /* 216 */
 	{"pivot_root",	NULL,			NOSYS_KERNEL,	0}, /* 217 */
-	{"mincore",	NULL,			0,		3}, /* 218 */
+	{"mincore",	lx_mincore,		0,		3}, /* 218 */
 	{"madvise",	NULL,			0,		3}, /* 219 */
 	{"getdents64",	lx_getdents64,		0,		3}, /* 220 */
 	{"fcntl64",	lx_fcntl64,		0,		3}, /* 221 */
@@ -771,7 +771,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"io_getevents", NULL,			0,		5}, /* 247 */
 	{"io_submit",	NULL,			0,		3}, /* 248 */
 	{"io_cancel",	NULL,			0,		3}, /* 249 */
-	{"fadvise64",	NULL,			0,		4}, /* 250 */
+	{"fadvise64",	lx_fadvise64_32,	0,		5}, /* 250 */
 	{"nosys",	NULL,			0,		0}, /* 251 */
 	{"group_exit",	NULL,			0,		1}, /* 252 */
 	{"lookup_dcookie", NULL,		NOSYS_NO_EQUIV,	0}, /* 253 */
@@ -797,7 +797,7 @@ lx_sysent_t lx_sysent32[] = {
  * The following system calls only exist in kernel 2.6 and greater:
  */
 	{"utimes",	NULL,			0,		2}, /* 271 */
-	{"fadvise64_64", NULL, 			0,		4}, /* 272 */
+	{"fadvise64_64", lx_fadvise64_64,	LX_SYS_EBPARG6,	6}, /* 272 */
 	{"vserver",	NULL,			NOSYS_NULL,	0}, /* 273 */
 	{"mbind",	NULL,			NOSYS_NULL,	0}, /* 274 */
 	{"get_mempolicy", NULL,			NOSYS_NULL,	0}, /* 275 */
@@ -827,7 +827,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"futimesat",	NULL,			0,		3}, /* 299 */
 	{"fstatat64",	lx_fstatat64,		0,		4}, /* 300 */
 	{"unlinkat",	lx_unlinkat,		0,		3}, /* 301 */
-	{"renameat",	NULL,			0,		4}, /* 302 */
+	{"renameat",	lx_renameat,		0,		4}, /* 302 */
 	{"linkat",	lx_linkat,		0,		5}, /* 303 */
 	{"symlinkat",	lx_symlinkat,		0,		3}, /* 304 */
 	{"readlinkat",	lx_readlinkat,		0,		4}, /* 305 */
@@ -903,7 +903,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"lseek",	lx_lseek64,		0,		3}, /* 8 */
 	{"mmap",	NULL,			0,		6}, /* 9 */
 	{"mprotect",	NULL,			0,		3}, /* 10 */
-	{"munmap",	NULL,			0,		2}, /* 11 */
+	{"munmap",	lx_munmap,		0,		2}, /* 11 */
 	{"brk",		lx_brk,			0,		1}, /* 12 */
 	{"rt_sigaction", NULL,			0,		4}, /* 13 */
 	{"rt_sigprocmask", NULL,		0,		4}, /* 14 */
@@ -919,17 +919,17 @@ lx_sysent_t lx_sysent64[] = {
 	{"sched_yield",	lx_sched_yield,		0,		0}, /* 24 */
 	{"mremap",	NULL,			0,		5}, /* 25 */
 	{"msync",	NULL,			0,		3}, /* 26 */
-	{"mincore",	NULL,			0,		3}, /* 27 */
+	{"mincore",	lx_mincore,		0,		3}, /* 27 */
 	{"madvise",	NULL,			0,		3}, /* 28 */
 	{"shmget",	NULL,			0,		3}, /* 29 */
 	{"shmat",	NULL,			0,		4}, /* 30 */
 	{"shmctl",	NULL,			0,		3}, /* 31 */
 	{"dup",		lx_dup,			0,		1}, /* 32 */
 	{"dup2",	lx_dup2,		0,		2}, /* 33 */
-	{"pause",	NULL,			0,		0}, /* 34 */
+	{"pause",	lx_pause,		0,		0}, /* 34 */
 	{"nanosleep",	lx_nanosleep,		0,		2}, /* 35 */
-	{"getitimer",	NULL,			0,		2}, /* 36 */
-	{"alarm",	NULL,			0,		1}, /* 37 */
+	{"getitimer",	lx_getitimer,		0,		2}, /* 36 */
+	{"alarm",	lx_alarm,		0,		1}, /* 37 */
 	{"setitimer",	NULL,			0,		3}, /* 38 */
 	{"getpid",	lx_getpid,		0,		0}, /* 39 */
 	{"sendfile",	NULL,			0,		4}, /* 40 */
@@ -972,12 +972,12 @@ lx_sysent_t lx_sysent64[] = {
 	{"ftruncate",	NULL,			0,		2}, /* 77 */
 	{"getdents",	lx_getdents_64,		0,		3}, /* 78 */
 	{"getcwd",	lx_getcwd,		0,		2}, /* 79 */
-	{"chdir",	NULL,			0,		1}, /* 80 */
-	{"fchdir",	NULL,			0,		1}, /* 81 */
-	{"rename",	NULL,			0,		2}, /* 82 */
+	{"chdir",	lx_chdir,		0,		1}, /* 80 */
+	{"fchdir",	lx_fchdir,		0,		1}, /* 81 */
+	{"rename",	lx_rename,		0,		2}, /* 82 */
 	{"mkdir",	lx_mkdir,		0,		2}, /* 83 */
 	{"rmdir",	NULL,			0,		1}, /* 84 */
-	{"creat",	NULL,			0,		2}, /* 85 */
+	{"creat",	lx_creat,		0,		2}, /* 85 */
 	{"link",	lx_link,		0,		2}, /* 86 */
 	{"unlink",	lx_unlink,		0,		1}, /* 87 */
 	{"symlink",	lx_symlink,		0,		2}, /* 88 */
@@ -990,21 +990,21 @@ lx_sysent_t lx_sysent64[] = {
 	{"umask",	lx_umask,		0,		1}, /* 95 */
 	{"gettimeofday", lx_gettimeofday,	0,		2}, /* 96 */
 	{"getrlimit",	lx_getrlimit,		0,		2}, /* 97 */
-	{"getrusage",	NULL,			0,		2}, /* 98 */
+	{"getrusage",	lx_getrusage,		0,		2}, /* 98 */
 	{"sysinfo",	lx_sysinfo64,		0,		1}, /* 99 */
 	{"times",	NULL,			0,		1}, /* 100 */
 	{"ptrace",	lx_ptrace,		0,		4}, /* 101 */
 	{"getuid",	lx_getuid,		0,		0}, /* 102 */
-	{"syslog",	NULL,			0,		3}, /* 103 */
+	{"syslog",	lx_syslog,		0,		3}, /* 103 */
 	{"getgid",	lx_getgid,		0,		0}, /* 104 */
 	{"setuid",	lx_setuid,		0,		1}, /* 105 */
 	{"setgid",	lx_setgid,		0,		1}, /* 106 */
 	{"geteuid",	lx_geteuid,		0,		0}, /* 107 */
 	{"getegid",	lx_getegid,		0,		0}, /* 108 */
-	{"setpgid",	NULL,			0,		2}, /* 109 */
+	{"setpgid",	lx_setpgid,		0,		2}, /* 109 */
 	{"getppid",	lx_getppid,		0,		0}, /* 110 */
-	{"getpgrp",	NULL,			0,		0}, /* 111 */
-	{"setsid",	NULL,			0,		0}, /* 112 */
+	{"getpgrp",	lx_getpgrp,		0,		0}, /* 111 */
+	{"setsid",	lx_setsid,		0,		0}, /* 112 */
 	{"setreuid",	lx_setreuid,		0,		0}, /* 113 */
 	{"setregid",	lx_setregid,		0,		0}, /* 114 */
 	{"getgroups",	NULL,			0,		2}, /* 115 */
@@ -1013,10 +1013,10 @@ lx_sysent_t lx_sysent64[] = {
 	{"getresuid",	lx_getresuid,		0,		3}, /* 118 */
 	{"setresgid",	lx_setresgid,		0,		3}, /* 119 */
 	{"getresgid",	lx_getresgid,		0,		3}, /* 120 */
-	{"getpgid",	NULL,			0,		1}, /* 121 */
-	{"setfsuid",	NULL,			0,		1}, /* 122 */
-	{"setfsgid",	NULL,			0,		1}, /* 123 */
-	{"getsid",	NULL,			0,		1}, /* 124 */
+	{"getpgid",	lx_getpgid,		0,		1}, /* 121 */
+	{"setfsuid",	lx_setfsuid,		0,		1}, /* 122 */
+	{"setfsgid",	lx_setfsgid,		0,		1}, /* 123 */
+	{"getsid",	lx_getsid,		0,		1}, /* 124 */
 	{"capget",	NULL,			0,		2}, /* 125 */
 	{"capset",	NULL,			0,		2}, /* 126 */
 	{"rt_sigpending", NULL,			0,		2}, /* 127 */
@@ -1045,7 +1045,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"munlock",	NULL,			0,		2}, /* 150 */
 	{"mlockall",	NULL,			0,		1}, /* 151 */
 	{"munlockall",	NULL,			0,		0}, /* 152 */
-	{"vhangup",	NULL,			0,		0}, /* 153 */
+	{"vhangup",	lx_vhangup,		0,		0}, /* 153 */
 	{"modify_ldt",	lx_modify_ldt,		0,		3}, /* 154 */
 	{"pivot_root",	NULL,			NOSYS_KERNEL,	0}, /* 155 */
 	{"sysctl",	NULL,			0,		1}, /* 156 */
@@ -1053,17 +1053,17 @@ lx_sysent_t lx_sysent64[] = {
 	{"arch_prctl",	lx_arch_prctl,		0,		2}, /* 158 */
 	{"adjtimex",	NULL,			0,		1}, /* 159 */
 	{"setrlimit",	lx_setrlimit,		0,		2}, /* 160 */
-	{"chroot",	NULL,			0,		1}, /* 161 */
-	{"sync",	NULL,			0,		0}, /* 162 */
+	{"chroot",	lx_chroot,		0,		1}, /* 161 */
+	{"sync",	lx_sync,		0,		0}, /* 162 */
 	{"acct",	NULL,			NOSYS_NO_EQUIV,	0}, /* 163 */
 	{"settimeofday", NULL,			0,		2}, /* 164 */
 	{"mount",	lx_mount,		0,		5}, /* 165 */
 	{"umount2",	lx_umount2,		0,		2}, /* 166 */
 	{"swapon",	NULL,			NOSYS_KERNEL,	0}, /* 167 */
 	{"swapoff",	NULL,			NOSYS_KERNEL,	0}, /* 168 */
-	{"reboot",	NULL,			0,		4}, /* 169 */
-	{"sethostname",	NULL,			0,		2}, /* 170 */
-	{"setdomainname", NULL,			0,		2}, /* 171 */
+	{"reboot",	lx_reboot,		0,		4}, /* 169 */
+	{"sethostname",	lx_sethostname,		0,		2}, /* 170 */
+	{"setdomainname", lx_setdomainname,	0,		2}, /* 171 */
 	{"iopl",	NULL,			NOSYS_NO_EQUIV,	0}, /* 172 */
 	{"ioperm",	NULL,			NOSYS_NO_EQUIV,	0}, /* 173 */
 	{"create_module", NULL,			NOSYS_KERNEL,	0}, /* 174 */
@@ -1113,7 +1113,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"set_tid_address", lx_set_tid_address, 0,		1}, /* 218 */
 	{"restart_syscall", NULL,		NOSYS_NULL,	0}, /* 219 */
 	{"semtimedop",	NULL,			0,		4}, /* 220 */
-	{"fadvise64",	NULL,			0,		4}, /* 221 */
+	{"fadvise64",	lx_fadvise64,		0,		4}, /* 221 */
 	{"timer_create", NULL,			0,		3}, /* 222 */
 	{"timer_settime", NULL,			0,		4}, /* 223 */
 	{"timer_gettime", NULL,			0,		2}, /* 224 */
@@ -1156,7 +1156,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"futimesat",	NULL,			0,		3}, /* 261 */
 	{"fstatat64",	lx_fstatat64,		0,		4}, /* 262 */
 	{"unlinkat",	lx_unlinkat,		0,		3}, /* 263 */
-	{"renameat",	NULL,			0,		4}, /* 264 */
+	{"renameat",	lx_renameat,		0,		4}, /* 264 */
 	{"linkat",	lx_linkat,		0,		5}, /* 265 */
 	{"symlinkat",	lx_symlinkat,		0,		3}, /* 266 */
 	{"readlinkat",	lx_readlinkat,		0,		4}, /* 267 */
diff --git a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
index cbef125c98..0d4a74c900 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
@@ -37,17 +37,21 @@ extern "C" {
 extern long lx_accept();
 extern long lx_accept4();
 extern long lx_access();
+extern long lx_alarm();
 extern long lx_arch_prctl();
 extern long lx_bind();
 extern long lx_brk();
+extern long lx_chdir();
 extern long lx_chmod();
 extern long lx_chown();
 extern long lx_chown16();
+extern long lx_chroot();
 extern long lx_clock_getres();
 extern long lx_clock_gettime();
 extern long lx_clock_settime();
 extern long lx_close();
 extern long lx_connect();
+extern long lx_creat();
 extern long lx_dup();
 extern long lx_dup2();
 extern long lx_dup3();
@@ -57,8 +61,12 @@ extern long lx_epoll_ctl();
 extern long lx_epoll_pwait();
 extern long lx_epoll_wait();
 extern long lx_faccessat();
+extern long lx_fadvise64();
+extern long lx_fadvise64_32();
+extern long lx_fadvise64_64();
 extern long lx_fallocate();
 extern long lx_fallocate32();
+extern long lx_fchdir();
 extern long lx_fchmod();
 extern long lx_fchmodat();
 extern long lx_fchown();
@@ -87,7 +95,10 @@ extern long lx_geteuid();
 extern long lx_geteuid16();
 extern long lx_getgid();
 extern long lx_getgid16();
+extern long lx_getitimer();
 extern long lx_getpeername();
+extern long lx_getpgid();
+extern long lx_getpgrp();
 extern long lx_getsockname();
 extern long lx_getpid();
 extern long lx_getppid();
@@ -97,6 +108,8 @@ extern long lx_getresgid16();
 extern long lx_getresuid();
 extern long lx_getresuid16();
 extern long lx_getrlimit();
+extern long lx_getrusage();
+extern long lx_getsid();
 extern long lx_getsockopt();
 extern long lx_gettid();
 extern long lx_gettimeofday();
@@ -123,14 +136,18 @@ extern long lx_lsetxattr();
 extern long lx_lstat32();
 extern long lx_lstat64();
 extern long lx_listxattr();
+extern long lx_mincore();
 extern long lx_mkdir();
 extern long lx_mkdirat();
 extern long lx_modify_ldt();
 extern long lx_mount();
+extern long lx_munmap();
 extern long lx_nanosleep();
+extern long lx_nice();
 extern long lx_oldgetrlimit();
 extern long lx_open();
 extern long lx_openat();
+extern long lx_pause();
 extern long lx_personality();
 extern long lx_pipe();
 extern long lx_pipe2();
@@ -152,9 +169,12 @@ extern long lx_read();
 extern long lx_readlink();
 extern long lx_readlinkat();
 extern long lx_readv();
+extern long lx_reboot();
 extern long lx_recv();
 extern long lx_recvmsg();
 extern long lx_recvfrom();
+extern long lx_rename();
+extern long lx_renameat();
 extern long lx_sched_getparam();
 extern long lx_sched_getscheduler();
 extern long lx_sched_rr_get_interval();
@@ -168,8 +188,15 @@ extern long lx_sendto();
 extern long lx_set_robust_list();
 extern long lx_set_thread_area();
 extern long lx_set_tid_address();
+extern long lx_setdomainname();
+extern long lx_setfsuid();
+extern long lx_setfsuid16();
+extern long lx_setfsgid();
+extern long lx_setfsgid16();
 extern long lx_setgid();
 extern long lx_setgid16();
+extern long lx_sethostname();
+extern long lx_setpgid();
 extern long lx_setregid();
 extern long lx_setregid16();
 extern long lx_setresgid();
@@ -179,6 +206,7 @@ extern long lx_setresuid16();
 extern long lx_setreuid();
 extern long lx_setreuid16();
 extern long lx_setrlimit();
+extern long lx_setsid();
 extern long lx_setuid();
 extern long lx_setuid16();
 extern long lx_setxattr();
@@ -191,10 +219,13 @@ extern long lx_socketcall();
 extern long lx_socketpair();
 extern long lx_stat32();
 extern long lx_stat64();
+extern long lx_stime();
+extern long lx_sync();
 extern long lx_sync_file_range();
 extern long lx_syncfs();
 extern long lx_sysinfo32();
 extern long lx_sysinfo64();
+extern long lx_syslog();
 extern long lx_removexattr();
 extern long lx_tgkill();
 extern long lx_time();
@@ -205,6 +236,7 @@ extern long lx_umount2();
 extern long lx_uname();
 extern long lx_unlink();
 extern long lx_unlinkat();
+extern long lx_vhangup();
 extern long lx_wait4();
 extern long lx_waitid();
 extern long lx_waitpid();
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_fadvise.c b/usr/src/uts/common/brand/lx/syscall/lx_fadvise.c
new file mode 100644
index 0000000000..7b81702fcf
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_fadvise.c
@@ -0,0 +1,108 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+#include <sys/fcntl.h>
+#include <sys/lx_misc.h>
+
+/*
+ * Based on illumos posix_fadvise which does nothing. The only difference is
+ * that on Linux an fd refering to a pipe or FIFO returns EINVAL. The Linux
+ * POSIX_FADV_* values are the same as the illumos values. See how glibc calls
+ * fadvise64; the offeset is a 64bit value, but the length is not, whereas
+ * fadvise64_64 passes both the offset and length as 64bit values.
+ */
+
+/* ARGSUSED */
+static int
+lx_fadvise_com(int fd, off64_t offset, off64_t len, int advice)
+{
+	file_t *fp;
+	boolean_t is_fifo;
+
+	switch (advice) {
+	case POSIX_FADV_NORMAL:
+	case POSIX_FADV_RANDOM:
+	case POSIX_FADV_SEQUENTIAL:
+	case POSIX_FADV_WILLNEED:
+	case POSIX_FADV_DONTNEED:
+	case POSIX_FADV_NOREUSE:
+		break;
+	default:
+		return (set_errno(EINVAL));
+	}
+
+	if (len < 0)
+		return (set_errno(EINVAL));
+
+	if ((fp = getf(fd)) == NULL)
+		return (set_errno(EBADF));
+	is_fifo = (fp->f_vnode->v_type == VFIFO);
+	releasef(fd);
+
+	if (is_fifo)
+		return (set_errno(ESPIPE));
+
+	return (0);
+}
+
+#if defined(_LP64)
+/*
+ * This is the fadvise64 function used by 64-bit callers.
+ */
+long
+lx_fadvise64(int fd, off64_t offset, off64_t len, int advice)
+{
+	return (lx_fadvise_com(fd, offset, len, advice));
+}
+#endif
+
+/*
+ * This is the fadvise64 function used by 32-bit callers. Linux passes the
+ * 64-bit offset by concatenating consecutive arguments. We must perform the
+ * same conversion here.
+ */
+long
+lx_fadvise64_32(int fd, uintptr_t p1, uintptr_t p2, int32_t len, int advice)
+{
+	off64_t offset;
+
+	offset = p2;
+	offset = offset << 32;
+	offset |= p1;
+
+	return (lx_fadvise_com(fd, offset, (off64_t)len, advice));
+}
+
+/*
+ * This function is only used by 32-bit callers. Linux passes the 64-bit offset
+ * and length by concatenating consecutive arguments. We must perform the same
+ * conversion here.
+ */
+long
+lx_fadvise64_64(int fd, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4,
+    int advice)
+{
+	off64_t offset;
+	off64_t len;
+
+	offset = p2;
+	offset = offset << 32;
+	offset |= p1;
+	len = p4;
+	len = len << 32;
+	len |= p3;
+
+	return (lx_fadvise_com(fd, offset, len, advice));
+}
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_id.c b/usr/src/uts/common/brand/lx/syscall/lx_id.c
index 9bcd2dc8ad..67f0fc9e5e 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_id.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_id.c
@@ -469,3 +469,41 @@ lx_getresgid16(lx_gid16_t *rgid16, lx_gid16_t *egid16, lx_gid16_t *sgid16)
 
 	return (0);
 }
+
+/*
+ * The lx brand cannot support the setfs[ug]id16/setfs[ug]id calls as that
+ * would require significant rework of the illumos privilege mechanisms, so
+ * instead return the current effective [ug]id.
+ *
+ * In Linux, fsids track effective IDs, so returning the effective IDs works
+ * as a substitute; returning the current value also denotes failure of the
+ * call if the caller had specified something different.  We don't need to
+ * worry about setting error codes because the Linux calls don't set any.
+ */
+/*ARGSUSED*/
+long
+lx_setfsuid16(uid_t fsuid16)
+{
+	return ((int)LX_UID32_TO_UID16(crgetuid(CRED())));
+}
+
+/*ARGSUSED*/
+long
+lx_setfsgid16(gid_t fsgid16)
+{
+	return ((int)LX_GID32_TO_GID16(crgetgid(CRED())));
+}
+
+/*ARGSUSED*/
+long
+lx_setfsuid(uid_t fsuid)
+{
+	return (crgetuid(CRED()));
+}
+
+/*ARGSUSED*/
+long
+lx_setfsgid(gid_t fsgid)
+{
+	return (crgetgid(CRED()));
+}
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
new file mode 100644
index 0000000000..ba986e2742
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
@@ -0,0 +1,282 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+#include <sys/systeminfo.h>
+#include <sys/fcntl.h>
+#include <sys/resource.h>
+#include <sys/uadmin.h>
+#include <sys/lx_misc.h>
+
+#define	LINUX_REBOOT_MAGIC1		0xfee1dead
+#define	LINUX_REBOOT_MAGIC2		672274793
+#define	LINUX_REBOOT_MAGIC2A		85072278
+#define	LINUX_REBOOT_MAGIC2B		369367448
+#define	LINUX_REBOOT_MAGIC2C		537993216
+
+#define	LINUX_REBOOT_CMD_RESTART	0x1234567
+#define	LINUX_REBOOT_CMD_HALT		0xcdef0123
+#define	LINUX_REBOOT_CMD_CAD_ON		0x89abcdef
+#define	LINUX_REBOOT_CMD_CAD_OFF	0
+#define	LINUX_REBOOT_CMD_POWER_OFF	0x4321fedc
+#define	LINUX_REBOOT_CMD_RESTART2	0xa1b2c3d4
+#define	LINUX_REBOOT_CMD_SW_SUSPEND	0xD000FCE2
+#define	LINUX_REBOOT_CMD_KEXEC		0x45584543
+
+#define	LX_RUSAGE_SELF			0
+#define	LX_RUSAGE_CHILDREN		(-1)
+#define	LX_RUSAGE_BOTH			(-2)
+#define	LX_RUSAGE_THREAD		1
+
+/* From uts/common/fs/vfs.c */
+extern void vfs_sync(int);
+/* From uts/common/os/grow.c */
+extern int mincore(caddr_t, size_t, char *);
+extern int munmap(caddr_t, size_t);
+/* From uts/common/os/session.c */
+extern int vhangup();
+/* From uts/common/syscall/alarm.c */
+extern int alarm(int);
+/* From uts/common/syscall/chdir.c */
+extern int chdir(char *);
+extern int chroot(char *);
+extern int fchdir(int);
+/* From uts/common/syscall/nice.c */
+extern int nice(int);
+/* From uts/common/syscall/open.c */
+extern int open(char *, int, int);
+/* From uts/common/syscall/pause.c */
+extern int pause();
+/* From uts/common/syscall/rusagesys.c */
+extern int rusagesys(int, void *, void *, void *, void *);
+/* From uts/common/syscall/systeminfo.c */
+extern long systeminfo(int, char *, long);
+/* From uts/common/syscall/timers.c */
+extern int getitimer(uint_t, struct itimerval *);
+/* From uts/common/syscall/time.c */
+extern int stime(time_t);
+/* From uts/common/syscall/uadmin.c */
+extern int uadmin(int, int, uintptr_t);
+
+long
+lx_alarm(int seconds)
+{
+	return (alarm(seconds));
+}
+
+long
+lx_chdir(char *path)
+{
+	return (chdir(path));
+}
+
+long
+lx_chroot(char *path)
+{
+	return (chroot(path));
+}
+
+long
+lx_creat(char *path, mode_t mode)
+{
+	return (open(path, O_WRONLY | O_CREAT | O_TRUNC, mode));
+}
+
+long
+lx_fchdir(int fd)
+{
+	return (fchdir(fd));
+}
+
+long
+lx_getitimer(int which, struct itimerval *value)
+{
+	return (getitimer(which, value));
+}
+
+/* Linux and illumos have the same rusage structures. */
+long
+lx_getrusage(int who, struct rusage *rup)
+{
+	int code;
+
+	switch (who) {
+	case LX_RUSAGE_SELF:
+		code = _RUSAGESYS_GETRUSAGE;
+		break;
+	case LX_RUSAGE_CHILDREN:
+		code = _RUSAGESYS_GETRUSAGE_CHLD;
+		break;
+	case LX_RUSAGE_THREAD:
+		code = _RUSAGESYS_GETRUSAGE_LWP;
+		break;
+	default:
+		return (set_errno(EINVAL));
+	}
+
+	return (rusagesys(code, rup, NULL, NULL, NULL));
+}
+
+long
+lx_mincore(caddr_t addr, size_t len, char *vec)
+{
+	int r;
+
+	r = mincore(addr, len, vec);
+	if (r == EINVAL) {
+		/*
+		 * LTP mincore01 expects mincore with a huge len to fail with
+		 * ENOMEM on a modern kernel, although on Linux 2.6.11 and
+		 * earlier, it will return EINVAL.
+		 */
+		if (lx_kern_release_cmp(curzone, "2.6.11") > 0 && (long)len < 0)
+			return (set_errno(ENOMEM));
+	}
+	return (r);
+}
+
+long
+lx_munmap(void *addr, size_t len)
+{
+	return (munmap(addr, len));
+}
+
+long
+lx_nice(int incr)
+{
+	return (nice(incr));
+}
+
+long
+lx_pause(void)
+{
+	return (pause());
+}
+
+/*ARGSUSED*/
+long
+lx_reboot(int magic1, int magic2, uint_t flag, uintptr_t p4)
+{
+	if (magic1 != LINUX_REBOOT_MAGIC1)
+		return (set_errno(EINVAL));
+
+	switch (magic2) {
+	case LINUX_REBOOT_MAGIC2:
+	case LINUX_REBOOT_MAGIC2A:
+	case LINUX_REBOOT_MAGIC2B:
+	case LINUX_REBOOT_MAGIC2C:
+		break;
+	default:
+		return (set_errno(EINVAL));
+	}
+
+	/*
+	 * Once we have better Linux capabilities(7) support we should check
+	 * CAP_SYS_BOOT instead.
+	 */
+	if (crgetuid(CRED()) != 0)
+		return (set_errno(EPERM));
+
+	switch (flag) {
+	case LINUX_REBOOT_CMD_CAD_ON:
+	case LINUX_REBOOT_CMD_CAD_OFF:
+		/* ignored */
+		return (0);
+
+	case LINUX_REBOOT_CMD_POWER_OFF:
+	case LINUX_REBOOT_CMD_HALT:
+		return (uadmin(A_SHUTDOWN, AD_HALT, NULL));
+
+	case LINUX_REBOOT_CMD_RESTART:
+	case LINUX_REBOOT_CMD_RESTART2:
+		/* RESTART2 may need more work */
+		return (uadmin(A_SHUTDOWN, AD_BOOT, NULL));
+
+	default:
+		return (set_errno(EINVAL));
+	}
+}
+
+long
+lx_setdomainname(char *name, long len)
+{
+	if (len < 0 || len >= LX_SYS_UTS_LN)
+		return (set_errno(EINVAL));
+
+	ttolwp(curthread)->lwp_errno = 0;
+	(void) systeminfo(SI_SET_SRPC_DOMAIN, name, len);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+	return (0);
+}
+
+long
+lx_sethostname(char *name, size_t len)
+{
+	ttolwp(curthread)->lwp_errno = 0;
+	(void) systeminfo(SI_SET_HOSTNAME, name, len);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+	return (0);
+}
+
+long
+lx_stime(time_t *tp)
+{
+	time_t time;
+
+	if (copyin(tp, &time, sizeof (time)) != 0)
+		return (set_errno(EFAULT));
+
+	return (stime(time));
+}
+
+long
+lx_sync(void)
+{
+	vfs_sync(0);
+	return (0);
+}
+
+/*
+ * For syslog, since there is no Linux kernel and nothing to log, we simply
+ * emulate a kernel buffer (LOG_BUF_LEN) of 0 bytes and only handle errors for
+ * bad input. All actions except 3 and 10 require CAP_SYS_ADMIN or CAP_SYSLOG
+ * so without full capabilities support, for now we just perform an euid check.
+ */
+long
+lx_syslog(int type, char *bufp, int len)
+{
+	if (type < 0 || type > 10)
+		return (set_errno(EINVAL));
+
+	if (type != 3 && type != 10 && crgetuid(CRED()) != 0)
+		return (set_errno(EPERM));
+
+	if (type >= 2 && type <= 4 && (bufp == NULL || len < 0))
+		return (set_errno(EINVAL));
+
+	if (type == 8 && (len < 1 || len > 8))
+		return (set_errno(EINVAL));
+
+	return (0);
+}
+
+long
+lx_vhangup(void)
+{
+	if (crgetuid(CRED()) != 0)
+		return (set_errno(EPERM));
+	return (vhangup());
+}
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_pgrp.c b/usr/src/uts/common/brand/lx/syscall/lx_pgrp.c
new file mode 100644
index 0000000000..2acd9d431e
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_pgrp.c
@@ -0,0 +1,189 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+#include <sys/lx_misc.h>
+
+#define	LX_INIT_PGID	1
+#define	LX_INIT_SID	1
+
+/* From uts/common/syscall/pgrpsys.c */
+extern int setpgrp(int, int, int);
+
+long
+lx_getpgrp(void)
+{
+	int pg;
+
+	/* getpgrp() */
+	pg = setpgrp(0, 0, 0);
+
+	/*
+	 * If the pgrp is that of the init process, return the value Linux
+	 * expects.
+	 */
+	if (pg == curzone->zone_proc_initpid)
+		return (LX_INIT_PGID);
+
+	return (pg);
+}
+
+long
+lx_getpgid(int pid)
+{
+	pid_t spid;
+	int tid;
+	int pg;
+
+	if (pid < 0)
+		return (set_errno(ESRCH));
+
+	/*
+	 * If the supplied pid matches that of the init process, return the pgid
+	 * Linux expects.
+	 */
+	if (pid == curzone->zone_proc_initpid)
+		return (LX_INIT_PGID);
+
+	if (pid == 0) {
+		spid = curproc->p_pid;
+	} else if (lx_lpid_to_spair(pid, &spid, &tid) < 0) {
+		return (set_errno(ESRCH));
+	}
+
+	/* getpgid() */
+	ttolwp(curthread)->lwp_errno = 0;
+	pg = setpgrp(4, spid, 0);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+
+	/*
+	 * If the pgid is that of the init process, return the value Linux
+	 * expects.
+	 */
+	if (pg == curzone->zone_proc_initpid)
+		return (LX_INIT_PGID);
+
+	return (pg);
+}
+
+long
+lx_setpgid(pid_t pid, pid_t pgid)
+{
+	pid_t spid, spgid;
+	int tid;
+	int pg;
+	int ret;
+
+	if (pid < 0)
+		return (set_errno(ESRCH));
+
+	if (pgid < 0)
+		return (set_errno(EINVAL));
+
+	if (pid == 0) {
+		spid = curproc->p_pid;
+	} else if (lx_lpid_to_spair(pid, &spid, &tid) < 0) {
+		return (set_errno(ESRCH));
+	}
+
+	if (pgid == 0) {
+		spgid = spid;
+	} else if (lx_lpid_to_spair(pgid, &spgid, &tid) < 0) {
+		return (set_errno(ESRCH));
+	}
+
+	/* setpgid() */
+	ret = setpgrp(5, spid, spgid);
+
+	if (ret == EPERM) {
+		/*
+		 * On Linux, when calling setpgid with a desired pgid that is
+		 * equal to the current pgid of the process, no error is
+		 * emitted. This differs slightly from illumos which would
+		 * return EPERM. To emulate the Linux behavior, we check
+		 * specifically for matching pgids.
+		 */
+
+		/* getpgid() */
+		ttolwp(curthread)->lwp_errno = 0;
+		pg = setpgrp(4, spid, 0);
+		if (ttolwp(curthread)->lwp_errno == 0 && spgid == pg)
+			return (0);
+		return (set_errno(EPERM));
+	}
+
+	return (ret);
+}
+
+long
+lx_getsid(int pid)
+{
+	pid_t spid;
+	int tid;
+	int sid;
+
+	if (pid < 0)
+		return (set_errno(ESRCH));
+
+	/*
+	 * If the supplied pid matches that of the init process, return the sid
+	 * Linux expects.
+	 */
+	if (pid == curzone->zone_proc_initpid)
+		return (LX_INIT_SID);
+
+	if (pid == 0) {
+		spid = curproc->p_pid;
+	} else if (lx_lpid_to_spair(pid, &spid, &tid) < 0) {
+		return (set_errno(ESRCH));
+	}
+
+	/* getsid() */
+	ttolwp(curthread)->lwp_errno = 0;
+	sid = setpgrp(2, spid, 0);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+
+
+	/*
+	 * If the sid is that of the init process, return the value Linux
+	 * expects.
+	 */
+	if (sid == curzone->zone_proc_initpid)
+		return (LX_INIT_SID);
+
+	return (sid);
+}
+
+long
+lx_setsid(void)
+{
+	int sid;
+
+	/* setsid() */
+	ttolwp(curthread)->lwp_errno = 0;
+	sid = setpgrp(3, 0, 0);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+
+	/*
+	 * If the sid is that of the init process, return the value Linux
+	 * expects.
+	 */
+	if (sid == curzone->zone_proc_initpid)
+		return (LX_INIT_SID);
+
+	return (sid);
+}
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_rename.c b/usr/src/uts/common/brand/lx/syscall/lx_rename.c
new file mode 100644
index 0000000000..2fad627771
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_rename.c
@@ -0,0 +1,39 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+#include <sys/fcntl.h>
+#include <sys/lx_fcntl.h>
+
+/* From uts/common/syscall/rename.c */
+extern int rename(char *, char *);
+extern int renameat(int, char *, int, char *);
+
+long
+lx_rename(char *p1, char *p2)
+{
+	return (rename(p1, p2));
+}
+
+long
+lx_renameat(int atfd1, char *p1, int atfd2, char *p2)
+{
+	if (atfd1 == LX_AT_FDCWD)
+		atfd1 = AT_FDCWD;
+
+	if (atfd2 == LX_AT_FDCWD)
+		atfd2 = AT_FDCWD;
+
+	return (renameat(atfd1, p1, atfd2, p2));
+}
diff --git a/usr/src/uts/intel/Makefile.files b/usr/src/uts/intel/Makefile.files
index ff375b0c72..aeddaa9203 100644
--- a/usr/src/uts/intel/Makefile.files
+++ b/usr/src/uts/intel/Makefile.files
@@ -320,6 +320,7 @@ LX_BRAND_OBJS  =		\
 	lx_dup.o		\
 	lx_errno.o		\
 	lx_epoll.o		\
+	lx_fadvise.o		\
 	lx_fallocate.o		\
 	lx_fcntl.o		\
 	lx_futex.o		\
@@ -334,16 +335,19 @@ LX_BRAND_OBJS  =		\
 	lx_link.o		\
 	lx_lseek.o		\
 	lx_misc.o		\
+	lx_miscsys.o		\
 	lx_mkdir.o		\
 	lx_modify_ldt.o		\
 	lx_mount.o		\
 	lx_open.o		\
 	lx_personality.o	\
+	lx_pgrp.o		\
 	lx_pid.o		\
 	lx_pipe.o		\
 	lx_poll.o		\
 	lx_prctl.o		\
 	lx_ptrace.o		\
+	lx_rename.o		\
 	lx_rlimit.o		\
 	lx_rw.o			\
 	lx_sched.o		\
-- 
2.21.0

