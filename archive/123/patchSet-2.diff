From 74b2d9e80fb62500152db71cc345d0010d1204e0 Mon Sep 17 00:00:00 2001
From: Dave Pacheco <dap@joyent.com>
Date: Thu, 21 Jul 2016 10:55:36 -0700
Subject: [PATCH] MORAY-347 moray testing process could be improved, documented

---
 .gitignore                            |    3 +
 LICENSE                               |   19 +
 Makefile                              |   85 +
 Makefile.targ                         |  317 ++++
 README.md                             |   94 +-
 etc/moray-test-suite-custom-both.json |   10 +
 etc/moray-test-suite-remote.json      |    5 +
 etc/moray-test-suite-stock.json       |    5 +
 lib/envfile.js                        |  121 ++
 package.json                          |   27 +
 test/arrays.test.js                   |  787 +++++++++
 test/buckets.test.js                  |  409 +++++
 test/client.test.js                   |  138 ++
 test/helper.js                        |  177 ++
 test/integ.test.js                    |  669 ++++++++
 test/loop.test.js                     |  201 +++
 test/objects.test.js                  | 2171 +++++++++++++++++++++++++
 test/sql.test.js                      |  101 ++
 test/stress-client.js                 |  663 ++++++++
 test/version.test.js                  |   93 ++
 tools/bashstyle                       |  114 ++
 tools/configure                       |  747 +++++++++
 tools/jsl.node.conf                   |  142 ++
 tools/jsstyle.conf                    |   14 +
 24 files changed, 7111 insertions(+), 1 deletion(-)
 create mode 100644 .gitignore
 create mode 100644 LICENSE
 create mode 100644 Makefile
 create mode 100644 Makefile.targ
 create mode 100644 etc/moray-test-suite-custom-both.json
 create mode 100644 etc/moray-test-suite-remote.json
 create mode 100644 etc/moray-test-suite-stock.json
 create mode 100644 lib/envfile.js
 create mode 100644 package.json
 create mode 100644 test/arrays.test.js
 create mode 100644 test/buckets.test.js
 create mode 100644 test/client.test.js
 create mode 100644 test/helper.js
 create mode 100644 test/integ.test.js
 create mode 100644 test/loop.test.js
 create mode 100644 test/objects.test.js
 create mode 100644 test/sql.test.js
 create mode 100644 test/stress-client.js
 create mode 100644 test/version.test.js
 create mode 100755 tools/bashstyle
 create mode 100755 tools/configure
 create mode 100644 tools/jsl.node.conf
 create mode 100644 tools/jsstyle.conf

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..44815f2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+etc/moray-test-suite.json
+node_modules
+run
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..82a5cb8
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..7886aeb
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,85 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2016, Joyent, Inc. All rights reserved.
+#
+
+#
+# Makefile: top-level Makefile
+#
+# This Makefile contains only repo-specific logic and uses included makefiles
+# to supply common targets (javascriptlint, jsstyle, restdown, etc.), which are
+# used by other repos as well.
+#
+
+#
+# Tools
+#
+NPM		 = npm
+FAUCET		 = ./node_modules/.bin/faucet
+CONFIGURE	 = ./tools/configure
+
+#
+# We use ctrun(1) to ensure that child processes created by the test cases are
+# always cleaned up.  However, on systems that don't provide ctrun(1), this
+# could be commented out.
+#
+CTRUN		 = ctrun -o noorphan
+
+
+#
+# Files and other definitions
+#
+JSON_FILES	 = package.json \
+		   etc/moray-test-suite-stock.json \
+		   etc/moray-test-suite-custom-both.json
+JS_FILES	:= tools/configure $(shell find lib test -name '*.js')
+JSL_FILES_NODE	 = $(JS_FILES)
+JSSTYLE_FILES	 = $(JS_FILES)
+JSSTYLE_FLAGS    = -f ./tools/jsstyle.conf
+JSL_CONF_NODE	 = tools/jsl.node.conf
+
+MORAY_TEST_CONFIG_FILE	?= etc/moray-test-suite.json
+MORAY_TEST_RUNDIR        = run
+MORAY_TEST_ENV_FILE	 = $(MORAY_TEST_RUNDIR)/env.sh
+
+#
+# Targets
+#
+
+.PHONY: all
+all:
+	$(NPM) install
+CLEAN_FILES += node_modules
+
+.PHONY: test
+test: | $(FAUCET) $(MORAY_TEST_ENV_FILE)
+	(set -o pipefail; \
+	source $(MORAY_TEST_ENV_FILE) && \
+	$(CTRUN) node test/client.test.js | $(FAUCET) && \
+	$(CTRUN) node test/buckets.test.js | $(FAUCET) && \
+	$(CTRUN) node test/objects.test.js | $(FAUCET) && \
+	$(CTRUN) node test/sql.test.js | $(FAUCET) && \
+	$(CTRUN) node test/integ.test.js | $(FAUCET) && \
+	$(CTRUN) node test/arrays.test.js | $(FAUCET) && \
+	$(CTRUN) node test/version.test.js | $(FAUCET) && \
+	$(CTRUN) node test/loop.test.js | bunyan -lfatal )
+	@echo tests passed
+
+$(FAUCET): all
+
+$(MORAY_TEST_ENV_FILE): $(MORAY_TEST_CONFIG_FILE)
+	$(CONFIGURE) $^
+
+$(MORAY_TEST_CONFIG_FILE):
+	@echo
+	@echo You must create $(MORAY_TEST_CONFIG_FILE) first.  See README.md.
+	@exit 1
+
+CLEAN_FILES += run
+
+include ./Makefile.targ
diff --git a/Makefile.targ b/Makefile.targ
new file mode 100644
index 0000000..ea19000
--- /dev/null
+++ b/Makefile.targ
@@ -0,0 +1,317 @@
+# -*- mode: makefile -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+#
+# Makefile.targ: common targets.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This Makefile defines several useful targets and rules. You can use it by
+# including it from a Makefile that specifies some of the variables below.
+#
+# Targets defined in this Makefile:
+#
+#	check	Checks JavaScript files for lint and style
+#		Checks bash scripts for syntax
+#		Checks SMF manifests for validity against the SMF DTD
+#
+#	clean	Removes built files
+#
+#	docs	Builds restdown documentation in docs/
+#
+#	prepush	Depends on "check" and "test"
+#
+#	test	Does nothing (you should override this)
+#
+#	xref	Generates cscope (source cross-reference index)
+#
+# For details on what these targets are supposed to do, see the Joyent
+# Engineering Guide.
+#
+# To make use of these targets, you'll need to set some of these variables. Any
+# variables left unset will simply not be used.
+#
+#	BASH_FILES	Bash scripts to check for syntax
+#			(paths relative to top-level Makefile)
+#
+#	CLEAN_FILES	Files to remove as part of the "clean" target.  Note
+#			that files generated by targets in this Makefile are
+#			automatically included in CLEAN_FILES.  These include
+#			restdown-generated HTML and JSON files.
+#
+#	DOC_FILES	Restdown (documentation source) files. These are
+#			assumed to be contained in "docs/", and must NOT
+#			contain the "docs/" prefix.
+#
+#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
+#	JSL_CONF_WEB	(paths relative to top-level Makefile)
+#
+#			Node.js and Web configuration files are separate
+#			because you'll usually want different global variable
+#			configurations.  If no file is specified, none is given
+#			to jsl, which causes it to use a default configuration,
+#			which probably isn't what you want.
+#
+#	JSL_FILES_NODE	JavaScript files to check with Node config file.
+#	JSL_FILES_WEB	JavaScript files to check with Web config file.
+#
+#	JSON_FILES	JSON files to be validated
+#
+#	JSSTYLE_FILES	JavaScript files to be style-checked
+#
+# You can also override these variables:
+#
+#	BASH		Path to bash (default: "bash")
+#
+#	CSCOPE_DIRS	Directories to search for source files for the cscope
+#			index. (default: ".")
+#
+#	JSL		Path to JavaScriptLint (default: "jsl")
+#
+#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
+#	JSL_FLAGS_WEB
+#	JSL_FLAGS
+#
+#	JSON		Path to json tool (default: "json")
+#
+#	JSSTYLE		Path to jsstyle (default: "jsstyle")
+#
+#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
+#
+#	RESTDOWN_EXT	By default '.restdown' is required for DOC_FILES
+#			(see above). If you want to use, say, '.md' instead, then
+#			set 'RESTDOWN_EXT=.md' in your Makefile.
+#
+
+#
+# Defaults for the various tools we use.
+#
+BASH		?= bash
+BASHSTYLE	?= tools/bashstyle
+CP		?= cp
+CSCOPE		?= cscope
+CSCOPE_DIRS	?= .
+JSL		?= jsl
+JSON		?= json
+JSSTYLE		?= jsstyle
+MKDIR		?= mkdir -p
+MV		?= mv
+RESTDOWN_FLAGS	?=
+RESTDOWN_EXT	?= .restdown
+RMTREE		?= rm -rf
+JSL_FLAGS  	?= --nologo --nosummary
+
+ifeq ($(shell uname -s),SunOS)
+	TAR	?= gtar
+else
+	TAR	?= tar
+endif
+
+
+#
+# Defaults for other fixed values.
+#
+BUILD		= build
+DISTCLEAN_FILES += $(BUILD)
+DOC_BUILD	= $(BUILD)/docs/public
+
+#
+# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
+#
+ifneq ($(origin JSL_CONF_NODE), undefined)
+	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
+endif
+
+ifneq ($(origin JSL_CONF_WEB), undefined)
+	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
+endif
+
+#
+# Targets. For descriptions on what these are supposed to do, see the
+# Joyent Engineering Guide.
+#
+
+#
+# Instruct make to keep around temporary files. We have rules below that
+# automatically update git submodules as needed, but they employ a deps/*/.git
+# temporary file. Without this directive, make tries to remove these .git
+# directories after the build has completed.
+#
+.SECONDARY: $($(wildcard deps/*):%=%/.git)
+
+#
+# This rule enables other rules that use files from a git submodule to have
+# those files depend on deps/module/.git and have "make" automatically check
+# out the submodule as needed.
+#
+deps/%/.git:
+	git submodule update --init deps/$*
+
+#
+# These recipes make heavy use of dynamically-created phony targets. The parent
+# Makefile defines a list of input files like BASH_FILES. We then say that each
+# of these files depends on a fake target called filename.bashchk, and then we
+# define a pattern rule for those targets that runs bash in check-syntax-only
+# mode. This mechanism has the nice properties that if you specify zero files,
+# the rule becomes a noop (unlike a single rule to check all bash files, which
+# would invoke bash with zero files), and you can check individual files from
+# the command line with "make filename.bashchk".
+#
+.PHONY: check-bash
+check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
+
+%.bashchk: %
+	$(BASH) -n $^
+
+%.bashstyle: %
+	$(BASHSTYLE) $^
+
+.PHONY: check-json
+check-json: $(JSON_FILES:%=%.jsonchk)
+
+%.jsonchk: %
+	$(JSON) --validate -f $^
+
+#
+# The above approach can be slow when there are many files to check because it
+# requires that "make" invoke the check tool once for each file, rather than
+# passing in several files at once.  For the JavaScript check targets, we define
+# a variable for the target itself *only if* the list of input files is
+# non-empty.  This avoids invoking the tool if there are no files to check.
+#
+JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
+.PHONY: check-jsl-node
+check-jsl-node: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
+
+JSL_WEB_TARGET = $(if $(JSL_FILES_WEB), check-jsl-web)
+.PHONY: check-jsl-web
+check-jsl-web: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $(JSL_FILES_WEB)
+
+.PHONY: check-jsl
+check-jsl: $(JSL_NODE_TARGET) $(JSL_WEB_TARGET)
+
+JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
+.PHONY: check-jsstyle
+check-jsstyle:  $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
+
+.PHONY: check
+check: check-jsl check-json $(JSSTYLE_TARGET) check-bash
+	@echo check ok
+
+.PHONY: clean
+clean::
+	-$(RMTREE) $(CLEAN_FILES)
+
+.PHONY: distclean
+distclean:: clean
+	-$(RMTREE) $(DISTCLEAN_FILES)
+
+CSCOPE_FILES = cscope.in.out cscope.out cscope.po.out
+CLEAN_FILES += $(CSCOPE_FILES)
+
+.PHONY: xref
+xref: cscope.files
+	$(CSCOPE) -bqR
+
+.PHONY: cscope.files
+cscope.files:
+	find $(CSCOPE_DIRS) -name '*.c' -o -name '*.h' -o -name '*.cc' \
+	    -o -name '*.js' -o -name '*.s' -o -name '*.cpp' > $@
+
+#
+# The "docs" target is complicated because we do several things here:
+#
+#    (1) Use restdown to build HTML and JSON files from each of DOC_FILES.
+#
+#    (2) Copy these files into $(DOC_BUILD) (build/docs/public), which
+#        functions as a complete copy of the documentation that could be
+#        mirrored or served over HTTP.
+#
+#    (3) Then copy any directories and media from docs/media into
+#        $(DOC_BUILD)/media. This allows projects to include their own media,
+#        including files that will override same-named files provided by
+#        restdown.
+#
+# Step (3) is the surprisingly complex part: in order to do this, we need to
+# identify the subdirectories in docs/media, recreate them in
+# $(DOC_BUILD)/media, then do the same with the files.
+#
+DOC_MEDIA_DIRS := $(shell find docs/media -type d 2>/dev/null | grep -v "^docs/media$$")
+DOC_MEDIA_DIRS := $(DOC_MEDIA_DIRS:docs/media/%=%)
+DOC_MEDIA_DIRS_BUILD := $(DOC_MEDIA_DIRS:%=$(DOC_BUILD)/media/%)
+
+DOC_MEDIA_FILES := $(shell find docs/media -type f 2>/dev/null)
+DOC_MEDIA_FILES := $(DOC_MEDIA_FILES:docs/media/%=%)
+DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
+
+#
+# Like the other targets, "docs" just depends on the final files we want to
+# create in $(DOC_BUILD), leveraging other targets and recipes to define how
+# to get there.
+#
+.PHONY: docs
+docs:							\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.json)		\
+	$(DOC_MEDIA_FILES_BUILD)
+
+#
+# We keep the intermediate files so that the next build can see whether the
+# files in DOC_BUILD are up to date.
+#
+.PRECIOUS:					\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%json)
+
+#
+# We do clean those intermediate files, as well as all of DOC_BUILD.
+#
+CLEAN_FILES +=					\
+	$(DOC_BUILD)				\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.json)
+
+#
+# Before installing the files, we must make sure the directories exist. The |
+# syntax tells make that the dependency need only exist, not be up to date.
+# Otherwise, it might try to rebuild spuriously because the directory itself
+# appears out of date.
+#
+$(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
+
+$(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
+	$(CP) $< $@
+
+docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC)
+	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
+
+$(DOC_BUILD):
+	$(MKDIR) $@
+
+$(DOC_MEDIA_DIRS_BUILD):
+	$(MKDIR) $@
+
+#
+# The default "test" target does nothing. This should usually be overridden by
+# the parent Makefile. It's included here so we can define "prepush" without
+# requiring the repo to define "test".
+#
+.PHONY: test
+test:
+
+.PHONY: prepush
+prepush: check test
diff --git a/README.md b/README.md
index e64bfae..2b8ca26 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,93 @@
-This is a placeholder repository for now.
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2016, Joyent, Inc.
+-->
+
+# Moray test suite
+
+This repository is part of the Joyent SmartDataCenter project (SDC), and the
+Joyent Manta project.  For contribution guidelines, issues, and general
+documentation, visit the main [SDC](http://github.com/joyent/sdc) and
+[Manta](http://github.com/joyent/manta) project pages.
+
+This repository contains the test suite for the [Moray
+client](https://github.com/joyent/node-moray) and [Moray
+server](https://github.com/joyent/moray).
+
+
+## Quick start
+
+To run the tests, you typically:
+
+1. Clone this repository.
+2. Install the dependencies:
+
+    $ npm install
+
+3. Configure the test suite.  Start with one of the template configuration
+   files.  You'll need to fill in the path to a sample Moray server
+   configuration file appropriate for your environment:
+
+    $ cp etc/moray-test-suite-stock.json etc/moray-test-suite.json
+    $ vim etc/moray-test-suite.json
+
+   and then run configure using that file:
+
+    $ ./tools/configure etc/moray-test-suite.json
+
+4. Run the tests:
+
+    $ make test
+
+To run individual tests by hand, first configure the test suite (steps 1 through
+3 above), then source the generated environment file and run the test programs
+by hand:
+
+    $ source run/env.sh
+    $ node test/buckets.test.js
+
+## Configuration
+
+The configuration file specifies:
+
+Property          | Type   | Example         | Meaning
+--------          | ------ | --------------- | -------
+server            | object | (see below)     | Describes the server implementation used for the test suite and how to run the server.
+server.remote     | string | `'tcp://localhost:2020'` | If specified, then use the servers at the specified URLs instead of spinning up servers using the `server.node`, `server.path`, `server.start`, and `server.configBase` properties.
+server.node       | string | `node`          | Path to the node executable to use when running the server, or `node` to use executable on the path (not recommended).
+server.path       | string | `../moray`      | Path to the server implementation that you want to test.  This is usually a cloned copy of the moray repository, possibly with local changes.  If this path is not absolute, then it will be interpreted relative to the root of this repository.  If this is not specified, then the stock server will be cloned and used.
+server.start      | string | `$MORAY_NODE $MORAY_PATH main.js -f $MORAY_CONFIG -v 2>&1` | bash command to start the server, emitting logs to stdout.  $MORAY\_NODE expands to `server.node`, $MORAY\_PATH expands to `server.path`, and $MORAY\_CONFIG expands to the target configuration file, which will be based on the file `server.configBase`.
+server.configBase | string | `../moray/config.json` | Path to the configuration file to use for servers started by the test suite.  The test suite may need to modify configuration slightly (e.g., to adjust port numbers), so it will create new configuration files based on this one.
+client            | string | (see below)     | Describes the client implementation used for the test suite.
+client.path       | string | `../node-moray` | Path to the client implementation that you want to test.  This is usually a cloned copy of the node-moray repository, possibly with local changes.  If this path is not absolute, then it will be interpreted relative to the root of this repository.  If this is not specified, then the stock client will be cloned and used.
+
+The `configure` script takes this configuration file, fills in default values,
+and then validates the configuration.  The script then sets up a "run" directory
+that contains links to the installed client and server and a shell environment
+file that contains the above configuration.
+
+The test suite programs read the configuration out of the environment.  If you
+like, you can modify the environment file or even modify your environment
+directly,  but the intended workflow is that you modify the config file, re-run
+configure, and then source the new configuration file.  This keeps everything in
+sync and the result is repeatable.
+
+The environment variables are documented in the generated file.
+
+
+## A note on Node versions
+
+As of this writing, the server only works with Node 0.10.  The current client
+works on v0.10 and later, but imminent updates will eliminate support for v0.10.
+This test suite is designed with the assumption that the client and server may
+be running different versions of Node, with different dependencies (even for
+dependencies of the same package and version, since binaries differ across Node
+versions).  **The test suite and client always run with the version of Node on
+your PATH when you run the `configure` tool.**  The server runs with the Node
+version specified in the configuration file (which also defaults to the one on
+your PATH).
diff --git a/etc/moray-test-suite-custom-both.json b/etc/moray-test-suite-custom-both.json
new file mode 100644
index 0000000..e128830
--- /dev/null
+++ b/etc/moray-test-suite-custom-both.json
@@ -0,0 +1,10 @@
+{
+    "client": {
+        "path": "../node-moray"
+    },
+    "server": {
+        "node": "../node-versions/node-v0.10.43-sunos-x86/bin/node",
+    	"path": "../moray",
+        "configBase": "../moray/config.json"
+    }
+}
diff --git a/etc/moray-test-suite-remote.json b/etc/moray-test-suite-remote.json
new file mode 100644
index 0000000..d817e41
--- /dev/null
+++ b/etc/moray-test-suite-remote.json
@@ -0,0 +1,5 @@
+{
+    "server": {
+    	"remote": "tcp://127.0.0.1:2020"
+    }
+}
diff --git a/etc/moray-test-suite-stock.json b/etc/moray-test-suite-stock.json
new file mode 100644
index 0000000..b494b49
--- /dev/null
+++ b/etc/moray-test-suite-stock.json
@@ -0,0 +1,5 @@
+{
+    "server": {
+        "configBase": "../moray/config.json"
+    }
+}
diff --git a/lib/envfile.js b/lib/envfile.js
new file mode 100644
index 0000000..2dbf66b
--- /dev/null
+++ b/lib/envfile.js
@@ -0,0 +1,121 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * envfile.js: manage bash-compatible environment files
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var mod_stream = require('stream');
+var mod_wordwrap = require('wordwrap');
+var wrap78 = mod_wordwrap(78);
+
+/* exported interface */
+exports.Environment = Environment;
+
+/*
+ * An "Environment" instance encapsulates a collection of shell environment
+ * variables so that they can be written out to a file.
+ */
+function Environment()
+{
+    this.e_vars = {};
+}
+
+/*
+ * Set the given variable.  Named arguments include:
+ *
+ *     name      name of the environment variable
+ *     (string)
+ *
+ *     value     value of the environment variable
+ *     (string)
+ *
+ *     comment   optional comment to be inserted above the variable.  This
+ *     [string]  string will be automatically wrapped.
+ */
+Environment.prototype.setVar = function envSetVar(args)
+{
+    mod_assertplus.object(args, 'args');
+    mod_assertplus.string(args.name, 'args.name');
+    mod_assertplus.string(args.value, 'args.value');
+    mod_assertplus.optionalString(args.comment, 'args.comment');
+
+    mod_assertplus.ok(/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(args.name),
+        'not a valid shell identifier');
+    this.e_vars[args.name] = {
+        'ev_name': args.name,
+        'ev_value': args.value,
+        'ev_comment': args.comment || null
+    };
+};
+
+/*
+ * Similar to setVar(), but assumes that the given variable ("args.name")
+ * represents a shell path consisting of colon-delimited values (like PATH) and
+ * constructs the value by prepending "args.pathentry" to any previously-set
+ * value.
+ */
+Environment.prototype.prependPath = function envPrependPath(args)
+{
+    var evar, value, comment;
+
+    mod_assertplus.object(args, 'args');
+    mod_assertplus.string(args.name, 'args.name');
+    mod_assertplus.string(args.pathentry, 'args.pathentry');
+    mod_assertplus.optionalString(args.comment, 'args.comment');
+
+    if (this.e_vars.hasOwnProperty(args.name)) {
+        evar = this.e_vars[args.name];
+        value = args.pathentry + ':' + evar.ev_value;
+        if (!comment) {
+            comment = evar.ev_comment;
+        }
+    } else {
+        value = args.pathentry;
+        comment = args.comment;
+    }
+
+    this.setVar({
+        'name': args.name,
+        'value': value,
+        'comment': comment
+    });
+};
+
+/*
+ * Returns a Readable stream that emits the environment variables in shell
+ * format.
+ */
+Environment.prototype.readable = function envReadable()
+{
+    var stream = new mod_stream.PassThrough();
+
+    mod_jsprim.forEachKey(this.e_vars, function (_, evar) {
+        var c;
+        if (evar.ev_comment !== null) {
+            c = wrap78(evar.ev_comment).split(/\n/).map(
+                function (line) { return ('# ' + line + '\n'); });
+            if (c.length > 1) {
+                c.unshift('#\n');
+                c.push('#\n');
+            }
+
+            stream.write(c.join(''));
+        }
+
+        stream.write('export ' + evar.ev_name + '=\'' +
+            evar.ev_value + '\'\n\n');
+    });
+
+    stream.end();
+    return (stream);
+};
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..31cd805
--- /dev/null
+++ b/package.json
@@ -0,0 +1,27 @@
+{
+	"name": "moray-test-suite",
+	"description": "Test suite for Moray client and server",
+	"version": "1.0.0",
+	"private": "true",
+	"license": "MIT",
+	"repository": {
+		"type": "git",
+		"url": "git://github.com/joyent/moray-test-suite.git"
+	},
+	"dependencies": {
+		"assert-plus": "1.0.0",
+		"bunyan": "^1.8.1",
+		"cmdutil": "^1.0.0",
+		"faucet": "0.0.1",
+		"forkexec": "^1.1.0",
+		"kang": "1.0.1",
+		"libuuid": "0.2.1",
+		"jsprim": "^1.3.0",
+		"mkdirp": "0.5.1",
+		"once": "^1.3.3",
+		"tape": "^2.14.0",
+		"vasync": "^1.6.4",
+		"verror": "git+ssh://git@github.com/davepacheco/node-verror.git#dev-issue-10",
+		"wordwrap": "^1.0.0"
+	}
+}
diff --git a/test/arrays.test.js b/test/arrays.test.js
new file mode 100644
index 0000000..efa9bc4
--- /dev/null
+++ b/test/arrays.test.js
@@ -0,0 +1,787 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+var once = require('once');
+var tape = require('tape');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var uuid = {
+    v1: libuuid.create,
+    v4: libuuid.create
+};
+
+var c; // client
+var server;
+var b; // bucket
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+    // May or may not exist, just blindly ignore
+        c.delBucket(b, function () {
+            c.once('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+///--- Tests
+
+test('schema array, array value (string)', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            name: {
+                type: '[string]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        name: ['foo', 'bar', 'baz'],
+        ignoreme: 'foo'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function object(_, cb) {
+                c.putObject(b, k, data, cb);
+            },
+            function find(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(name=foo)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('schema array, scalar value (string)', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            name: {
+                type: '[string]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        name: 'foo',
+        ignoreme: 'foo'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function object(_, cb) {
+                c.putObject(b, k, data, cb);
+            },
+            function find(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(name=foo)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        // Moray converts back into an
+                        // array...
+                        data.name = [data.name];
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('schema array, array value (inet)', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            ips: {
+                type: '[ip]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        ips: ['192.168.0.1', 'fd00::45'],
+        ignoreme: 'foo'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function object(_, cb) {
+                c.putObject(b, k, data, cb);
+            },
+            function find4(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(ips=192.168.0.1)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            },
+            function find6(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(ips=fd00::045)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('schema array, array value (cidr)', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            networks: {
+                type: '[subnet]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        networks: ['10.10.0.0/16', 'fe80::/64'],
+        ignoreme: 'foo'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function object(_, cb) {
+                c.putObject(b, k, data, cb);
+            },
+            function find4(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(networks=10.10.0.0/16)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            },
+            function find6(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(networks=fe80::0/64)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, data);
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('schema array, array value (number)', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            id: {
+                type: '[number]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        id: [1, 2, 3],
+        ignoreme: 'foo'
+    };
+    var found = 0;
+
+    function checkObject(obj) {
+        t.ok(obj);
+        if (obj) {
+            t.equal(obj.bucket, b);
+            t.equal(obj.key, k);
+            t.deepEqual(obj.value, data);
+            t.ok(obj._id);
+            t.ok(obj._etag);
+            t.ok(obj._mtime);
+            found++;
+        }
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        c.putObject(b, k, data, cb);
+                    }
+                });
+            },
+            function eq(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id=1)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function gte(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id>=3)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function lte(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id<=1)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function presence(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id=*)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function and(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(&(id<=3)(id>=1))');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function or(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(|(id<=0)(id>=1))');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function not(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(!(id=0))');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        t.equal(found, results.operations.length - 1);
+        t.end();
+    });
+});
+
+
+test('schema array string, substring filter throws', function (t) {
+    var k = uuid.v4();
+    var cfg = {
+        index: {
+            name: {
+                type: '[string]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        name: ['foo', 'bar', 'baz'],
+        ignoreme: 'foo'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        c.putObject(b, k, data, cb);
+                    }
+                });
+            },
+            function substr(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(name=f*)');
+                req.once('error', function (err) {
+                    t.ok(err);
+                    cb(err);
+                });
+                req.once('end', cb);
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ok(err);
+        t.end();
+    });
+});
+
+
+test('schema array, array value (number), updates', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            id: {
+                type: '[number]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        id: [5, 6, 7],
+        ignoreme: 'foo'
+    };
+    var found = 0;
+
+    var objects = [];
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: data
+    });
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: {
+            id: [1, 2, 3]
+        }
+    });
+
+    function checkObject(obj) {
+        t.ok(obj);
+        if (obj) {
+            t.equal(obj.bucket, b);
+            t.equal(obj.key, k);
+            t.deepEqual(obj.value, {
+                id: [1, 2, 3]
+            });
+            t.ok(obj._id);
+            t.ok(obj._etag);
+            t.ok(obj._mtime);
+            found++;
+        }
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        c.batch(objects, cb);
+                    }
+                });
+            },
+            function eq(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id=1)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        t.equal(found, results.operations.length - 1);
+        t.end();
+    });
+});
+
+
+test('schema array, array value (string), updates', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            name: {
+                type: '[string]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        name: ['bar', 'foo', 'baz'],
+        ignoreme: 'foo'
+    };
+
+    var objects = [];
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: data
+    });
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: {
+            name: ['foo', 'bar', 'baz']
+        }
+    });
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        c.batch(objects, cb);
+                    }
+                });
+            },
+            function find(_, cb) {
+                cb = once(cb);
+
+                var found = false;
+                var req = c.findObjects(b, '(name=foo)');
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    if (obj) {
+                        t.equal(obj.bucket, b);
+                        t.equal(obj.key, k);
+                        t.deepEqual(obj.value, {
+                            name: ['foo', 'bar', 'baz']
+                        });
+                        t.ok(obj._id);
+                        t.ok(obj._etag);
+                        t.ok(obj._mtime);
+                        found = true;
+                    }
+                });
+                req.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('schema array, array value (boolean), updates', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            id: {
+                type: '[boolean]',
+                unique: false
+            }
+        }
+    };
+    var data = {
+        id: [true, false, true],
+        ignoreme: 'foo'
+    };
+    var found = 0;
+
+    var objects = [];
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: data
+    });
+
+    objects.push({
+        bucket: b,
+        key: k,
+        value: {
+            id: [false, false, false]
+        }
+    });
+
+    function checkObject(obj) {
+        t.ok(obj);
+        if (obj) {
+            t.equal(obj.bucket, b);
+            t.equal(obj.key, k);
+            t.deepEqual(obj.value, {
+                id: [false, false, false]
+            });
+            t.ok(obj._id);
+            t.ok(obj._etag);
+            t.ok(obj._mtime);
+            found++;
+        }
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        c.batch(objects, cb);
+                    }
+                });
+            },
+            function eq(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id=false)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        t.equal(found, results.operations.length - 1);
+        t.end();
+    });
+});
+
+
+test('schema array, value (string) includes commas/curly braces', function (t) {
+    var cfg = {
+        index: {
+            name: {
+                type: '[string]',
+                unique: false
+            }
+        }
+    };
+    var data = {};
+
+    data[libuuid.create()] = {
+        name: ['{foo}', '{bar}', 'baz']
+    };
+    data[libuuid.create()] = {
+        name: ['{"foo": {"baz": "bar", "with": "commas"}}']
+    };
+    data['quotedkey'] = {
+        name: ['foo == "bar"', '"quoted"', '"bar" = baz']
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function setup(_, cb) {
+                c.putBucket(b, cfg, function (err) {
+                    t.ifError(err);
+                    cb(err);
+                });
+            },
+            function putObjs(_, cb) {
+                var batchData = [];
+                Object.keys(data).forEach(function (key) {
+                    batchData.push({
+                        bucket: b,
+                        key: key,
+                        value: data[key]
+                    });
+                });
+                c.batch(batchData, function (err) {
+                    t.ifError(err);
+                    cb(err);
+                });
+            },
+            function checkObjs(_, cb) {
+                var count = 0;
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(name=*)');
+                req.once('error', cb);
+                req.on('record', function (row) {
+                    t.ok(data[row.key]);
+                    t.deepEqual(row.value, data[row.key]);
+                    count++;
+                });
+                req.once('end', function () {
+                    t.equal(count, Object.keys(data).length);
+                    cb();
+                });
+            },
+            function checkSearch(_, cb) {
+                var count = 0;
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(name="quoted")');
+                req.once('error', cb);
+                req.on('record', function (row) {
+                    t.equal(row.key, 'quotedkey');
+                    count++;
+                });
+                req.once('end', function () {
+                    t.equal(count, 1);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        t.end();
+    });
+
+});
diff --git a/test/buckets.test.js b/test/buckets.test.js
new file mode 100644
index 0000000..735a6db
--- /dev/null
+++ b/test/buckets.test.js
@@ -0,0 +1,409 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var jsprim = require('jsprim');
+var tape = require('tape');
+var uuid = require('libuuid').create;
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var FULL_CFG = {
+    index: {
+        str: {
+            type: 'string'
+        },
+        str_u: {
+            type: 'string',
+            unique: true
+        },
+        num: {
+            type: 'number'
+        },
+        num_u: {
+            type: 'number',
+            unique: true
+        },
+        bool: {
+            type: 'boolean'
+        },
+        bool_u: {
+            type: 'boolean',
+            unique: true
+        },
+        ip: {
+            type: 'ip'
+        },
+        ip_u: {
+            type: 'ip',
+            unique: true
+        },
+        subnet: {
+            type: 'subnet'
+        },
+        subnet_u: {
+            type: 'subnet',
+            unique: true
+        }
+    },
+    pre: [function onePre(req, cb) { cb(); }],
+    post: [function onePost(req, cb) { cb(); }],
+    options: {}
+};
+
+var c; // client
+var server;
+var b; // bucket
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + uuid().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        // May or may not exist, just blindly ignore
+        c.delBucket(b, function () {
+            c.once('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+
+///--- Helpers
+
+function assertBucket(t, bucket, cfg) {
+    t.ok(bucket);
+    if (!bucket)
+        return (undefined);
+    t.equal(bucket.name, b);
+    t.ok(bucket.mtime instanceof Date);
+    t.deepEqual(bucket.index, (cfg.index || {}));
+    t.ok(Array.isArray(bucket.pre));
+    t.ok(Array.isArray(bucket.post));
+    t.equal(bucket.pre.length, (cfg.pre || []).length);
+    t.equal(bucket.post.length, (cfg.post || []).length);
+
+    if (bucket.pre.length !== (cfg.pre || []).length ||
+        bucket.post.length !== (cfg.post || []).length)
+        return (undefined);
+    var i;
+    for (i = 0; i < bucket.pre.length; i++)
+        t.equal(bucket.pre[i].toString(), cfg.pre[i].toString());
+    for (i = 0; i < bucket.post.length; i++)
+        t.equal(bucket.post[i].toString(), cfg.post[i].toString());
+
+    return (undefined);
+}
+
+
+///--- tests
+
+
+test('create bucket stock config', function (t) {
+    c.createBucket(b, {}, function (err) {
+        t.ifError(err);
+        c.getBucket(b, function (err2, bucket) {
+            t.ifError(err2);
+            assertBucket(t, bucket, {});
+            c.listBuckets(function (err3, buckets) {
+                t.ifError(err3);
+                t.ok(buckets);
+                t.ok(buckets.length);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('create bucket loaded', function (t) {
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        c.getBucket(b, function (err2, bucket) {
+            t.ifError(err2);
+            assertBucket(t, bucket, FULL_CFG);
+            t.end();
+        });
+    });
+});
+
+
+test('update bucket', function (t) {
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        var cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (versioned ok 0->1)', function (t) {
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        var cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 1;
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (versioned ok 1->2)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+
+    cfg.options.version = 1;
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 2;
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (reindex tracked)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+
+    cfg.options.version = 1;
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 2;
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.ok(bucket.reindex_active);
+                t.ok(bucket.reindex_active['2']);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (reindex disabled)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+
+    cfg.options.version = 1;
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 2;
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        var opts = {
+            no_reindex: true
+        };
+        c.updateBucket(b, cfg, opts, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.notOk(bucket.reindex_active);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (null version, reindex disabled)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+
+    cfg.options.version = 0;
+    c.createBucket(b, FULL_CFG, function (err) {
+        t.ifError(err);
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 0;
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                assertBucket(t, bucket, cfg);
+                t.notOk(bucket.reindex_active);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update bucket (versioned not ok 1 -> 0)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.options.version = 1;
+
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 0;
+
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+
+        c.updateBucket(b, cfg, function (err2) {
+            t.ok(err2);
+            if (err2) {
+                t.ok(VError.findCauseByName(
+                    err2, 'BucketVersionError') !== null);
+                t.ok(err2.message);
+            }
+            t.end();
+        });
+    });
+});
+
+
+test('update bucket (versioned not ok 2 -> 1)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.options.version = 2;
+
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+
+        cfg = jsprim.deepCopy(FULL_CFG);
+        cfg.options.version = 1;
+
+        cfg.index.foo = {
+            type: 'string',
+            unique: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+
+        c.updateBucket(b, cfg, function (err2) {
+            t.ok(err2);
+            if (err2) {
+                t.ok(VError.findCauseByName(
+                    err2, 'BucketVersionError') !== null);
+                t.ok(err2.message);
+            }
+            t.end();
+        });
+    });
+});
+
+
+test('create bucket bad index type', function (t) {
+    c.createBucket(b, {index: {foo: 'foo'}}, function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'InvalidBucketConfigError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+
+test('create bucket triggers not function', function (t) {
+    c.createBucket(b, {pre: ['foo']}, function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'NotFunctionError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+
+test('get bucket 404', function (t) {
+    c.getBucket(uuid().substr(0, 7), function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'BucketNotFoundError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+
+test('delete missing bucket', function (t) {
+    c.delBucket(uuid().substr(0, 7), function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'BucketNotFoundError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
diff --git a/test/client.test.js b/test/client.test.js
new file mode 100644
index 0000000..c2982ff
--- /dev/null
+++ b/test/client.test.js
@@ -0,0 +1,138 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * client.test.js: test general client behavior (not related to specific Moray
+ * RPC calls).
+ */
+
+var tape = require('tape');
+var uuid = require('libuuid').create;
+var vasync = require('vasync');
+var helper = require('./helper.js');
+var VError = require('verror');
+
+var server;
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        helper.createServer(null, function (s) {
+            server = s;
+            t.end();
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        helper.cleanupServer(server, function () {
+            t.pass('closed');
+            t.end();
+        });
+    });
+}
+
+/*
+ * Tests the behavior of the "connected" property, which is part of the
+ * interface.
+ */
+test('"connected" property', function (t) {
+    var c2;
+
+    c2 = helper.createClient();
+    t.ok(c2.connected === false, '"connected" property (not connected)');
+
+    c2.on('connect', function onClientConnected() {
+        t.ok(c2.connected === true, '"connected" property (connected)');
+        c2.once('close', function () {
+            t.ok(c2.connected === false, '"connected property (closed)');
+            t.end();
+        });
+        c2.close();
+    });
+});
+
+/*
+ * Once connected, start a callback-based request.  Immediately close the client
+ * and make sure that the request fails as expected.
+ */
+test('close() with outstanding callback request', function (t) {
+    var c2;
+
+    c2 = helper.createClient();
+    c2.on('connect', function onClientConnected() {
+        c2.getBucket('badbucket', function (err) {
+            t.ok(err, '"getbucket" returned error');
+            err = VError.findCauseByName(err, 'FastTransportError');
+            t.ok(err !== null, '"getbucket" returned FastTransportError');
+            t.end();
+        });
+
+        setImmediate(function () { c2.close(); });
+    });
+});
+
+/*
+ * This is just like the previous test, but with an event-emitter-based request.
+ */
+test('close() with outstanding event-emitter request', function (t) {
+    var c2;
+
+    c2 = helper.createClient();
+    c2.on('connect', function onClientConnected() {
+        var rq;
+
+        rq = c2.findObjects('badbucket', 'a=*');
+        rq.once('record', function () {
+            t.ok(false, 'findobjects unexpectedly returned a record');
+        });
+        rq.once('end', function () {
+            t.ok(false, 'findobjects unexpectedly completed');
+        });
+        rq.once('error', function (err) {
+            t.ok(err, '"findobjects" returned error');
+            err = VError.findCauseByName(err, 'FastTransportError');
+            t.ok(err !== null, '"findobjects" returned FastTransportError');
+            t.end();
+        });
+
+        setImmediate(function () { c2.close(); });
+    });
+});
+
+/*
+ * Tests that requests issued before a connection is established or after the
+ * client is closed fail appropriately.
+ */
+test('requests issued before connected, after close', function (t) {
+    var c2;
+    var barrier = vasync.barrier();
+
+    c2 = helper.createClient();
+    c2.getBucket('badbucket', function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'NoBackendsError') !== null);
+
+        barrier.start('close');
+        c2.once('close', function () { barrier.done('close'); });
+        c2.close();
+
+        barrier.start('getbucket');
+        c2.getBucket('badbucket', function (err2) {
+            t.ok(err2);
+            t.ok(/has been closed/.test(err2.message));
+            barrier.done('getbucket');
+        });
+
+        barrier.on('drain', function () { t.end(); });
+    });
+});
diff --git a/test/helper.js b/test/helper.js
new file mode 100644
index 0000000..1013170
--- /dev/null
+++ b/test/helper.js
@@ -0,0 +1,177 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var assert = require('assert');
+var child = require('child_process');
+var forkexec = require('forkexec');
+var fs = require('fs');
+var jsprim = require('jsprim');
+var path = require('path');
+var stream = require('stream');
+var util = require('util');
+
+var bunyan = require('bunyan');
+var moray = require('moray'); // client
+
+var which = 0;
+
+///--- API
+
+function createLogger(name, logstream) {
+    var log = bunyan.createLogger({
+        level: (process.env.LOG_LEVEL || 'warn'),
+        name: name || process.argv[1],
+        stream: logstream || process.stdout,
+        src: true,
+        serializers: bunyan.stdSerializers
+    });
+    return (log);
+}
+
+function createClient(opts) {
+    /*
+     * It would be nice to use the mustCloseBeforeNormalProcessExit option to
+     * the Moray client, which would identify client leaks, but node-tape
+     * defeats that check by calling process.exit() from its own 'exit'
+     * listener.
+     */
+    var clientparams = {};
+
+    if (process.env['MORAY_TEST_SERVER_REMOTE']) {
+        clientparams.url = process.env['MORAY_TEST_SERVER_REMOTE'];
+    } else {
+        clientparams.host = '127.0.0.1';
+        clientparams.port = 2020;
+    }
+
+    clientparams.log = createLogger();
+
+    if (opts && opts.unwrapErrors) {
+    	clientparams.unwrapErrors = opts.unwrapErrors;
+    }
+
+    return (moray.createClient(clientparams));
+}
+
+function multipleServersSupported() {
+    return (!process.env['MORAY_TEST_SERVER_REMOTE']);
+}
+
+function createServer(opts, cb) {
+    var env, cp, pt, server, t, seen, ready;
+
+    opts = opts || {};
+    if (process.env['MORAY_TEST_SERVER_REMOTE']) {
+        if (opts.portOverride) {
+            throw (new Error('multiple servers are not supported in ' +
+                'this configuration'));
+        } else {
+            setImmediate(cb, { 'ts_remote': true });
+        }
+        return;
+    }
+
+    if (!process.env['MORAY_TEST_SERVER_RUN']) {
+        throw (new Error('not found in environment: MORAY_TEST_SERVER_RUN. ' +
+            '(have you already run configure and sourced the env file?)'));
+    }
+
+    env = jsprim.deepCopy(process.env);
+    if (opts.portOverride) {
+        env['MORAY_TEST_EXTRA_ARGS'] = '-p ' + opts.portOverride;
+    }
+
+    cp = child.spawn('bash', [ '-c', process.env['MORAY_TEST_SERVER_RUN'] ], {
+            'detached': true,
+            'stdio': [ 'ignore', 'pipe', process.stderr ],
+            'env': env
+        });
+
+    seen = '';
+    ready = false;
+    pt = new stream.PassThrough();
+    cp.stdout.pipe(process.stdout);
+    cp.stdout.pipe(pt);
+
+    pt.on('data', function (c) {
+        seen += c.toString('utf8');
+        if (!ready && /moray listening on \d+/.test(seen) &&
+            /manatee ready/.test(seen)) {
+            cp.stdout.unpipe(pt);
+            ready = true;
+            clearTimeout(t);
+            t = null;
+            cb(server);
+        }
+    });
+
+    t = setTimeout(function () {
+        throw (new Error('server did not start after 10 seconds'));
+    }, 10000);
+
+    server = {
+        'ts_remote': false,
+        'ts_child': cp,
+        'ts_cleanup_cb': null
+    };
+
+    cp.on('exit', function (code, signal) {
+        var err, info;
+
+        if (code === 0) {
+            /*
+             * This should never happen because the server should only exit when
+             * we kill it, and that won't be a clean exit.
+             */
+            throw (new Error('server unexpectedly exited with status 0'));
+        }
+
+        if (server.ts_cleanup_cb === null || signal != 'SIGKILL') {
+            err = new Error('child process exited');
+            err.code = code;
+            err.signal = signal;
+
+            info = forkexec.interpretChildProcessResult({
+                'label': 'test moray server',
+                'error': err
+            });
+
+            throw (info.error);
+        } else {
+            server.ts_cleanup_cb();
+        }
+    });
+}
+
+function cleanupServer(server, cb) {
+    if (server.ts_remote) {
+        setImmediate(cb);
+    } else {
+        assert.ok(server.ts_cleanup_cb === null,
+            'cannot call cleanupServer multiple times');
+        server.ts_cleanup_cb = cb;
+
+        /*
+         * Kill the entire process group, since there may have been more than
+         * one process created under bash.
+         */
+        process.kill(-server.ts_child.pid, 'SIGKILL');
+    }
+}
+
+///--- Exports
+
+module.exports = {
+    multipleServersSupported: multipleServersSupported,
+    createLogger: createLogger,
+    createClient: createClient,
+    createServer: createServer,
+    cleanupServer: cleanupServer
+};
diff --git a/test/integ.test.js b/test/integ.test.js
new file mode 100644
index 0000000..2b0a0e0
--- /dev/null
+++ b/test/integ.test.js
@@ -0,0 +1,669 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+var libuuid = require('libuuid');
+var tape = require('tape');
+var once = require('once');
+var vasync = require('vasync');
+
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var c; // client
+var server;
+var b; // bucket
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + libuuid.create().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        // May or may not exist, just blindly ignore
+        c.delBucket(b, function () {
+            c.on('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+
+///--- Tests
+
+
+test('MANTA-117 single quotes not being escaped', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            name: {
+                type: 'string',
+                unique: true
+            }
+        }
+    };
+    var data = {
+        name: libuuid.create(),
+        chain: [ {
+            name: 'A Task',
+            timeout: 30,
+            retry: 3,
+            body: function (job, cb) {
+                return cb(null);
+            }.toString()
+        }],
+        timeout: 180,
+        onerror: [ {
+            name: 'Fallback task',
+            body: function (job, cb) {
+                return cb('Workflow error');
+            }.toString()
+        }]
+    };
+
+    Object.keys(data).forEach(function (p) {
+        if (typeof (data[p]) === 'object')
+            data[p] = JSON.stringify(data[p]);
+    });
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            c.putObject(b, k, data, function (err3) {
+                t.ifError(err3);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('MANTA-328 numeric values in filters', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            num: {
+                type: 'number'
+            }
+        }
+    };
+    var data = {
+        num: 123
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var ok = false;
+            var f = '(num=123)';
+            var req = c.findObjects(b, f);
+            req.once('error', function (err) {
+                t.ifError(err);
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+            req.once('record', function (obj) {
+                t.ok(obj);
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, data);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                ok = true;
+            });
+        });
+    });
+});
+
+
+test('MANTA-328 numeric values in filters <=', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            num: {
+                type: 'number'
+            }
+        }
+    };
+    var data = {
+        num: 425
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var ok = false;
+            var f = '(num<=1024)';
+            var req = c.findObjects(b, f);
+            req.once('error', function (err) {
+                t.ifError(err);
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+            req.once('record', function (obj) {
+                t.ok(obj);
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, data);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                ok = true;
+            });
+        });
+    });
+});
+
+
+test('MANTA-328 numeric values in filters >=', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            num: {
+                type: 'number'
+            }
+        }
+    };
+    var data = {
+        num: 425
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var ok = false;
+            var f = '(num>=81)';
+            var req = c.findObjects(b, f);
+            req.once('error', function (err) {
+                t.ifError(err);
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+            req.once('record', function (obj) {
+                t.ok(obj);
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, data);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                ok = true;
+            });
+        });
+    });
+});
+
+
+test('MANTA-170 bogus filter', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            num: {
+                type: 'number'
+            }
+        }
+    };
+    var data = {
+        num: 425
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var f = '(num>81)';
+            var req = c.findObjects(b, f);
+            req.once('error', function (err) {
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(false);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('MANTA-680 boolean searches', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            b: {
+                type: 'boolean'
+            }
+        }
+    };
+    var data = {
+        b: true
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var f = '(b=true)';
+            var req = c.findObjects(b, f);
+            var ok = false;
+            req.once('record', function () {
+                ok = true;
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('some marlin query', function (t) {
+    var cfg = {
+        index: {
+            foo: {
+                type: 'string'
+            },
+            bar: {
+                type: 'string'
+            },
+            baz: {
+                type: 'string'
+            }
+        }
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function objects(_, cb) {
+                cb = once(cb);
+
+                var done = 0;
+                function _cb(err) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    if (++done === 10)
+                        cb();
+                }
+                for (var i = 0; i < 10; i++) {
+                    var data = {
+                        foo: '' + i,
+                        bar: '' + i,
+                        baz: '' + i
+                    };
+                    c.putObject(b, libuuid.create(), data, _cb);
+                }
+            },
+            function find(_, cb) {
+                cb = once(cb);
+                var f = '(&(!(|(foo=0)(foo=1)))(bar=8)(baz=8))';
+                var req = c.findObjects(b, f);
+                req.once('error', cb);
+                req.once('record', function (obj) {
+                    t.ok(obj);
+                    t.equal(obj.value.foo, '8');
+                    t.equal(obj.value.bar, '8');
+                    t.equal(obj.value.baz, '8');
+                    found = true;
+                });
+                req.once('end', cb);
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('MANTA-1726 batch+deleteMany+limit', function (t) {
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                var cfg = {
+                    index: {
+                        n: {
+                            type: 'number'
+                        }
+                    }
+                };
+                c.putBucket(b, cfg, once(cb));
+            },
+            function writeObjects(_, cb) {
+                cb = once(cb);
+
+                var done = 0;
+                for (var i = 0; i < 100; i++) {
+                    c.putObject(b, libuuid.create(), {n: i}, function (err) {
+                        if (err) {
+                            cb(err);
+                        } else if (++done === 100) {
+                            cb();
+                        }
+                    });
+                }
+            },
+            function batchDeleteMany(_, cb) {
+                cb = once(cb);
+
+                c.batch([
+                    {
+                        operation: 'deleteMany',
+                        bucket: b,
+                        filter: 'n>=0',
+                        options: {
+                            limit: 50
+                        }
+                    }
+                ], function (err, meta) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        t.ok(meta);
+                        meta = meta || {};
+                        t.ok((meta || {}).etags);
+                        meta.etags = meta.etags || [];
+                        t.ok(meta.etags.length);
+                        if (meta.etags.length)
+                            t.equal(meta.etags[0].count, 50);
+                        cb();
+                    }
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('MANTA-1726 batch+update+limit', function (t) {
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                var cfg = {
+                    index: {
+                        n: {
+                            type: 'number'
+                        }
+                    }
+                };
+                c.putBucket(b, cfg, once(cb));
+            },
+            function writeObjects(_, cb) {
+                cb = once(cb);
+
+                var done = 0;
+                for (var i = 0; i < 100; i++) {
+                    c.putObject(b, libuuid.create(), {n: i}, function (err) {
+                        if (err) {
+                            cb(err);
+                        } else if (++done === 100) {
+                            cb();
+                        }
+                    });
+                }
+            },
+            function batchUpdateMany(_, cb) {
+                cb = once(cb);
+
+                c.batch([
+                    {
+                        operation: 'update',
+                        bucket: b,
+                        filter: 'n>=0',
+                        options: {
+                            limit: 50
+                        },
+                        fields: {
+                            n: 10000
+                        }
+                    }
+                ], function (err, meta) {
+                    if (err) {
+                        cb(err);
+                    } else {
+                        t.ok(meta);
+                        meta = meta || {};
+                        t.ok((meta || {}).etags);
+                        meta.etags = meta.etags || [];
+                        t.ok(meta.etags.length);
+                        if (meta.etags.length)
+                            t.equal(meta.etags[0].count, 50);
+                        cb();
+                    }
+                });
+            }
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('MORAY-131 case insensitive match', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            str: {
+                type: 'string'
+            }
+        }
+    };
+    var data = {
+        str: 'MaRk'
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var f = '(str:caseIgnoreMatch:=mark)';
+            var req = c.findObjects(b, f);
+            var ok = false;
+            req.once('record', function () {
+                ok = true;
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('MORAY-131 case insensitive substrings match', function (t) {
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            str: {
+                type: 'string'
+            }
+        }
+    };
+    var data = {
+        str: 'MaRk'
+    };
+
+    c.putBucket(b, cfg, function (err1) {
+        t.ifError(err1);
+        c.putObject(b, k, data, function (err2) {
+            t.ifError(err2);
+            var f = '(str:caseIgnoreSubstringsMatch:=m*r*)';
+            var req = c.findObjects(b, f);
+            var ok = false;
+            req.once('record', function () {
+                ok = true;
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('MORAY-322 bucketCache shootdown during update', function (t) {
+    var server2;
+    var c2;
+    var k = libuuid.create();
+    var cfg = {
+        index: {
+            num: {
+                type: 'number'
+            }
+        },
+        options: {
+            version: 1
+        }
+    };
+
+    if (!helper.multipleServersSupported()) {
+        t.skip('skipping because running against remote server');
+        t.end();
+        return;
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function setupServer(_, cb) {
+                cb = once(cb);
+                var opts = {
+                    portOverride: 2021
+                };
+                helper.createServer(opts, function (s) {
+                    server2 = s;
+                    c2 = helper.createClient();
+                    c2.once('error', cb);
+                    c2.once('connect', cb);
+                });
+            },
+            function setupBucket(_, cb) {
+                c.putBucket(b, cfg, cb);
+            },
+            function insert(_, cb) {
+                var data = {
+                    num: 10,
+                    new_num: 20
+                };
+                c.putObject(b, k, data, cb);
+            },
+            function primeCache(_, cb) {
+                c2.getObject(b, k, cb);
+            },
+            function bucketUpdate(_, cb) {
+                cfg.options.version = 2;
+                cfg.index.new_num = {
+                    type: 'number'
+                };
+                c.updateBucket(b, cfg, cb);
+            },
+            function reindexRow(_, cb) {
+                c.reindexObjects(b, 100, function (err, res) {
+                    t.ifError(err);
+                    t.equal(res.processed, 1);
+                    c.reindexObjects(b, 100, function (err2, res2) {
+                        t.ifError(err2);
+                        t.equal(res2.processed, 0);
+                        cb();
+                    });
+                });
+            },
+            function checkLocalIndex(_, cb) {
+                var filter = '(new_num=20)';
+                var found = 0;
+                var res = c.findObjects(b, filter, {});
+                res.on('error', cb);
+                res.on('record', function () {
+                    found++;
+                });
+                res.on('end', function () {
+                    t.equal(found, 1);
+                    cb();
+                });
+            },
+            function updateRow(_, cb) {
+                var data = {
+                    num: 10,
+                    new_num: 30
+                };
+                c2.putObject(b, k, data, cb);
+            },
+            function checkRemoteIndex(_, cb) {
+                cb = once(cb);
+                var filter = '(new_num=30)';
+                var found = 0;
+                var res = c2.findObjects(b, filter, {});
+                res.on('error', cb);
+                res.on('record', function () {
+                    found++;
+                });
+                res.on('end', function () {
+                    t.equal(found, 1);
+                    cb();
+                });
+            }
+        ],
+        arg: null
+    }, function (err, results) {
+        t.ifError(err);
+        c2.on('close', function () {
+            helper.cleanupServer(server2, function () {
+                t.end();
+            });
+        });
+        c2.close();
+    });
+});
diff --git a/test/loop.test.js b/test/loop.test.js
new file mode 100644
index 0000000..fbac67f
--- /dev/null
+++ b/test/loop.test.js
@@ -0,0 +1,201 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * loop.test.js: this test program runs basic PutObject/GetObject queries in a
+ * loop with modest concurrency.  By default, it fails if any request fails or
+ * takes too long.  You can configure this test to ignore explicit errors in
+ * order to test client behavior in the face of server restarts.
+ */
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var jsprim = require('jsprim');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var moray = require('moray');
+var helper = require('./helper');
+
+
+///--- Globals
+
+var server, client, queue;
+var noperations = 5000;             /* total operations to complete */
+var concurrency = 5;                /* concurrency of operations */
+var timeout = 60000;                /* per-operation timeout */
+var ignoreExplicitErrors = false;   /* ignore explicit moray failures */
+var nokay = 0;                      /* count of successful operations */
+var nfailed = 0;                    /* count of total failures */
+var nbyerror = {};                  /* count of failures by error name */
+var bucket = 'moray_loop_test_js_' + libuuid.create().substr(0, 7);
+var bucketconfig = {
+    index: {
+        foo: {
+            type: 'string'
+        }
+    }
+};
+
+
+///--- Mainline
+
+function main() {
+    if (process.argv[2] == '--ignore-explicit-errors') {
+        console.log('ignoring explicit errors');
+        ignoreExplicitErrors = true;
+    }
+
+    console.log('starting server');
+    helper.createServer(null, function (s) {
+        server = s;
+        client = helper.createClient({ 'level': 'fatal' });
+
+        queue = vasync.queuev({
+            'concurrency': concurrency,
+            'worker': makeOneRequest
+        });
+
+        client.once('connect', onClientReady);
+    });
+}
+
+/*
+ * Invoked upon successful connection to Moray to enqueue however many
+ * operations we intend to complete.  When we've finished them all, invokes
+ * cleanup().
+ */
+function onClientReady() {
+    console.log('creating test bucket: %s', bucket);
+    client.putBucket(bucket, bucketconfig, function (init_err) {
+        var i, opstate;
+
+        assert.ifError(init_err);
+
+        for (i = 0; i < noperations; i++) {
+            opstate = {
+                'op_key': libuuid.create(),
+                'op_value': { 'foo': '' + 1 },
+                'op_timeout': null,
+                'op_error': null
+            };
+
+            queue.push(opstate);
+        }
+
+        queue.on('end', function () {
+            console.log('all operations completed');
+            cleanup();
+        });
+
+        queue.close();
+    });
+}
+
+/*
+ * Invoked as a vasync queue callback to complete a single "operation", which
+ * consists of a PutObject and GetObject pair.  If this hasn't completed in 60
+ * seconds, we assume that we dropped a request and bail out.
+ */
+function makeOneRequest(opstate, qcallback) {
+    opstate.op_timeout = setTimeout(function () {
+        console.error('operation did not complete within %d milliseconds',
+            timeout);
+        throw (new Error('operation timeout'));
+    }, timeout);
+
+    client.putObject(bucket, opstate.op_key, opstate.op_value,
+        { 'noCache': true }, function (err) {
+        if (ignoreExplicitErrors && err) {
+            opstate.op_error = err;
+            finishRequest(opstate, qcallback);
+            return;
+        }
+
+        assert.ifError(err);
+        client.getObject(bucket, opstate.op_key, { 'noCache': true },
+            function (geterr, newvalue) {
+                if (!ignoreExplicitErrors) {
+                    assert.ifError(geterr);
+                    assert.deepEqual(newvalue.value, opstate.op_value);
+                }
+
+                opstate.op_error = err;
+                finishRequest(opstate, qcallback);
+            });
+    });
+}
+
+function finishRequest(opstate, qcallback) {
+    var c, errname;
+
+    /*
+     * Clear the operation we timeout that we set above.
+     */
+    clearTimeout(opstate.op_timeout);
+    opstate.op_timeout = null;
+
+    /*
+     * Categorize the result (success or failure, and if failure, what kind of
+     * failure) and maintain counters for each kind of result.
+     */
+    if (opstate.op_error) {
+        errname = opstate.op_error.name;
+        for (c = opstate.op_error; c !== null; c = VError.cause(c)) {
+            errname += ', ' + c.name;
+        }
+        if (!nbyerror.hasOwnProperty(errname)) {
+            nbyerror[errname] = 0;
+        }
+        nbyerror[errname]++;
+        nfailed++;
+    } else {
+        nokay++;
+    }
+
+    /*
+     * Requests do not necessarily complete in order, but this is just a basic
+     * progress notification.
+     */
+    if ((nokay + nfailed) % 1000 === 0) {
+        console.log('completed operation %d (%d okay, %d failed so far)',
+            nokay + nfailed, nokay, nfailed);
+    }
+
+    qcallback();
+}
+
+/*
+ * Clean up the entire operation.  Remove our test bucket and report what's
+ * happened.
+ */
+function cleanup() {
+    console.log('report:');
+    console.log('%d operations completed normally', nokay);
+    console.log('%d operations failed', nfailed);
+    jsprim.forEachKey(nbyerror, function (errname, count) {
+        console.log('    %d error: %s', count, errname);
+    });
+
+    console.log('deleting test bucket "%s"', bucket);
+    client.deleteBucket(bucket, function (err) {
+        assert.ifError(err);
+        console.log('closing client');
+        client.close();
+
+        console.log('closing server');
+        helper.cleanupServer(server, function () {
+            console.log('server shut down');
+        });
+    });
+}
+
+main();
diff --git a/test/objects.test.js b/test/objects.test.js
new file mode 100644
index 0000000..17212bb
--- /dev/null
+++ b/test/objects.test.js
@@ -0,0 +1,2171 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var jsprim = require('jsprim');
+var tape = require('tape');
+var once = require('once');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+var util = require('util');
+var net = require('net');
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var uuid = {
+    v1: libuuid.create,
+    v4: libuuid.create
+};
+
+var BUCKET_CFG = {
+    index: {
+        str: {
+            type: 'string'
+        },
+        str_u: {
+            type: 'string',
+            unique: true
+        },
+        str_2: {
+            type: 'string'
+        },
+        num: {
+            type: 'number'
+        },
+        num_u: {
+            type: 'number',
+            unique: true
+        },
+        bool: {
+            type: 'boolean'
+        },
+        bool_u: {
+            type: 'boolean',
+            unique: true
+        },
+        ip: {
+            type: 'ip'
+        },
+        ip_u: {
+            type: 'ip',
+            unique: true
+        },
+        subnet: {
+            type: 'subnet'
+        },
+        subnet_u: {
+            type: 'subnet',
+            unique: true
+        }
+    },
+    pre: [function (req, cb) {
+        var v = req.value;
+        if (v.pre)
+            v.pre = 'pre_overwrite';
+
+        cb();
+    }],
+    post: [function (req, cb) {
+        cb();
+    }],
+    options: {
+        version: 1,
+        trackModification: true,
+        guaranteeOrder: true
+    }
+};
+
+var c; // client
+var server;
+var b; // bucket
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', function () {
+                c.createBucket(b, BUCKET_CFG, function (err) {
+                    t.ifError(err);
+                    t.end();
+                });
+            });
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        c.delBucket(b, function (err) {
+            t.ifError(err);
+            c.once('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+
+///--- Helpers
+
+function assertObject(t, obj, k, v) {
+    t.ok(obj);
+    if (!obj)
+        return (undefined);
+
+    t.equal(obj.bucket, b);
+    t.equal(obj.key, k);
+    t.deepEqual(obj.value, v);
+    t.ok(obj._id);
+    t.ok(obj._etag);
+    t.ok(obj._mtime);
+    if (v.vnode) {
+        t.ok(obj.value.vnode);
+    }
+    return (undefined);
+}
+
+///--- Tests
+
+test('get object 404', function (t) {
+    c.getObject(b, uuid.v4().substr(0, 7), function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'ObjectNotFoundError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+
+test('del object 404', function (t) {
+    c.delObject(b, uuid.v4().substr(0, 7), function (err) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'ObjectNotFoundError') !== null);
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+
+test('CRUD object', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi',
+        vnode: 2
+    };
+    var v2 = {
+        str: 'hello world',
+        pre: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                return (cb());
+            });
+        }, function overwrite(_, cb) {
+            c.putObject(b, k, v2, cb);
+        }, function getAgain(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                v2.pre = 'pre_overwrite';
+                assertObject(t, obj, k, v2);
+                return (cb());
+            });
+        }, function del(_, cb) {
+            c.delObject(b, k, cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('get object (cached)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                return (cb());
+            });
+        }, function getAgain(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                return (cb());
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('CRUD objects unique indexes', function (t) {
+    var k = uuid.v4();
+    var k2 = uuid.v4();
+    var v = {
+        str_u: 'hi'
+    };
+    var v2 = {
+        str_u: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function putFail(_, cb) {
+            c.putObject(b, k2, v2, function (err) {
+                t.ok(err);
+                t.ok(VError.findCauseByName(err,
+                    'UniqueAttributeError') !== null);
+                cb();
+            });
+        }, function delK1(_, cb) {
+            c.delObject(b, k, cb);
+        }, function putK2(_, cb) {
+            c.putObject(b, k2, v2, cb);
+        }, function delK2(_, cb) {
+            c.delObject(b, k2, cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('put object w/etag ok', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var v2 = {
+        str: 'hello world'
+    };
+    var etag;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                etag = obj._etag;
+                return (cb());
+            });
+        }, function overwrite(_, cb) {
+            c.putObject(b, k, v2, {etag: etag}, cb);
+        }, function getAgain(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v2);
+                return (cb());
+            });
+        }, function del(_, cb) {
+            c.delObject(b, k, cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('del object w/etag ok', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var etag;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                etag = obj._etag;
+                return (cb());
+            });
+        }, function del(_, cb) {
+            c.delObject(b, k, {etag: etag}, cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('put object w/etag conflict', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function overwrite(_, cb) {
+            c.putObject(b, k, {}, {etag: 'foo'}, function (err) {
+                t.ok(err);
+                if (err) {
+                    t.ok(VError.findCauseByName(err,
+                        'EtagConflictError') !== null);
+                }
+                cb();
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+
+        t.end();
+    });
+});
+
+
+test('del object w/etag conflict', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function drop(_, cb) {
+            c.delObject(b, k, {etag: 'foo'}, function (err) {
+                t.ok(err);
+                if (err) {
+                    err = VError.findCauseByName(err, 'EtagConflictError');
+                    t.ok(err !== null);
+                    t.ok(err.context);
+                    if (err.context) {
+                        var ctx = err.context;
+                        t.equal(ctx.bucket, b);
+                        t.equal(ctx.key, k);
+                        t.equal(ctx.expected, 'foo');
+                        t.ok(ctx.actual);
+                    }
+                }
+                cb();
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+
+        t.end();
+    });
+});
+
+/*
+ * This test looks just like the previous one, but uses a client that unwraps
+ * Fast errors.  This option is provided for compatibility, and this test exists
+ * to verify that functionality.
+ *
+ * This does the right thing even for Moray clients that don't support
+ * "unwrapErrors", because those already behave this way.
+ */
+test('legacy error unwrapping behavior', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var c2;
+
+    vasync.pipeline({
+        funcs: [ function mkClient(_, cb) {
+            c2 = helper.createClient({ 'unwrapErrors': true });
+            c2.on('connect', function () { cb(); });
+        }, function put(_, cb) {
+            c2.putObject(b, k, v, cb);
+        }, function drop(_, cb) {
+            c2.delObject(b, k, {etag: 'foo'}, function (err) {
+                t.ok(err);
+                if (err) {
+                    t.equal(err.name, 'EtagConflictError');
+                    t.ok(err.context);
+                    if (err.context) {
+                        var ctx = err.context;
+                        t.equal(ctx.bucket, b);
+                        t.equal(ctx.key, k);
+                        t.equal(ctx.expected, 'foo');
+                        t.ok(ctx.actual);
+                    }
+                }
+                cb();
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        c2.once('close', function () { t.end(); });
+        c2.close();
+    });
+});
+
+
+test('MANTA-980 - null etag support', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var v2 = {
+        str: 'hello world'
+    };
+    var etag;
+    var value;
+
+    function get_cb(cb) {
+        function _cb(err, obj) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            t.ok(obj);
+            if (obj) {
+                assertObject(t, obj, k, value);
+                etag = obj._etag;
+            }
+            cb();
+        }
+        return (_cb);
+    }
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            value = v;
+            c.putObject(b, k, value, {etag: null}, cb);
+        }, function get(_, cb) {
+            c.getObject(b, k, get_cb(cb));
+        }, function overwrite(_, cb) {
+            value = v2;
+            c.putObject(b, k, value, {etag: etag}, cb);
+        }, function getAgain(_, cb) {
+            c.getObject(b, k, {noCache: true}, get_cb(cb));
+        }, function putFail(_, cb) {
+            c.putObject(b, k, v, {etag: null}, function (err) {
+                t.ok(err);
+                if (err) {
+                    err = VError.findCauseByName(err, 'EtagConflictError');
+                    t.ok(err !== null);
+                    t.ok(err.context);
+                    t.equal(err.context.bucket, b);
+                    t.equal(err.context.key, k);
+                    t.equal(err.context.expected, 'null');
+                    t.equal(err.context.actual, etag);
+                }
+                cb();
+            });
+        }, function del(_, cb) {
+            c.delObject(b, k, {etag: etag}, cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('find (like marlin)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello',
+        str_2: 'world'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(&(str=hello)(!(str_2=usa)))';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._count);
+                t.equal(typeof (obj._count), 'number');
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('find _mtime', function (t) {
+    var k = uuid.v4();
+    var now = Date.now();
+    var v = {
+        str: 'hello',
+        str_2: 'world'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function wait(_, cb) {
+            /* this is sensitive to clock skew between hosts */
+            setTimeout(cb, 1000);
+        }, function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(_mtime>=' + now + ')';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('find _key', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello',
+        str_2: 'world'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function wait(_, cb) {
+            setTimeout(cb, 500);
+        }, function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(_key=' + k + ')';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('find MANTA-156', function (t) {
+    var k = uuid.v4();
+    var v = {
+        num: 0,
+        num_u: 1
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function wait(_, cb) {
+            setTimeout(cb, 500);
+        }, function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(num>=0)';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('non-indexed AND searches (MANTA-317)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello',
+        cow: 'moo'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function wait(_, cb) {
+            setTimeout(cb, 500);
+        }, function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(&(str=hello)(!(cow=woof)))';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('_txn_snap on update', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var txn;
+
+    vasync.pipeline({
+        funcs: [ function create(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function getOne(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err) {
+                    cb(err);
+                } else {
+                    t.ok(obj);
+                    assertObject(t, obj, k, v);
+                    t.ok(obj._txn_snap);
+                    txn = obj._txn_snap;
+                    cb();
+                }
+            });
+        }, function update(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function getTwo(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err) {
+                    cb(err);
+                } else {
+                    t.ok(obj);
+                    assertObject(t, obj, k, v);
+                    t.ok(obj._txn_snap);
+                    t.notEqual(txn, obj._txn_snap);
+                    t.ok(obj._txn_snap > txn);
+                    cb();
+                }
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+
+        t.end();
+    });
+});
+
+
+test('find _txn_snap', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello',
+        str_2: 'world'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function wait(_, cb) {
+            setTimeout(cb, 500);
+        }, function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(&(_txn_snap>=1)(_id>=1))';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                t.ok(obj);
+                if (!obj)
+                    return (undefined);
+
+                t.equal(obj.bucket, b);
+                t.equal(obj.key, k);
+                t.deepEqual(obj.value, v);
+                t.ok(obj._id);
+                t.ok(obj._etag);
+                t.ok(obj._mtime);
+                t.ok(obj._txn_snap);
+                found = true;
+                return (undefined);
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+
+test('trackModification (MANTA-269)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hi'
+    };
+    var id1;
+
+    vasync.pipeline({
+        funcs: [ function create(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function getOne(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err) {
+                    cb(err);
+                } else {
+                    t.ok(obj);
+                    assertObject(t, obj, k, v);
+                    id1 = obj._id;
+                    cb();
+                }
+            });
+        }, function update(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function getTwo(_, cb) {
+            c.getObject(b, k, {noCache: true}, function (err, obj) {
+                if (err) {
+                    cb(err);
+                } else {
+                    t.ok(obj);
+                    assertObject(t, obj, k, v);
+                    t.notEqual(id1, obj._id);
+                    cb();
+                }
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+
+        t.end();
+    });
+});
+
+
+test('batch put objects', function (t) {
+    var requests = [
+        {
+            bucket: b,
+            key: uuid.v4(),
+            value: {
+                foo: 'bar'
+            }
+        },
+        {
+            bucket: b,
+            key: uuid.v4(),
+            value: {
+                bar: 'baz'
+            }
+        }
+    ];
+
+    c.batch(requests, function (err, meta) {
+        t.ifError(err);
+        t.ok(meta);
+        if (meta) {
+            t.ok(meta.etags);
+            if (meta.etags) {
+                t.ok(Array.isArray(meta.etags));
+                t.equal(meta.etags.length, 2);
+                meta.etags.forEach(function (e) {
+                    t.equal(b, e.bucket);
+                    t.ok(e.key);
+                    t.ok(e.etag);
+                });
+            }
+        }
+        c.getObject(b, requests[0].key, function (er2, obj) {
+            t.ifError(er2);
+            t.ok(obj);
+            if (obj)
+                t.deepEqual(obj.value, requests[0].value);
+
+            var r = requests[1];
+            c.getObject(b, r.key, function (err3, obj2) {
+                t.ifError(err3);
+                t.ok(obj2);
+                if (obj2)
+                    t.deepEqual(obj2.value, r.value);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('batch put with bad _value', function (t) {
+    // In a future node-moray, this shouldn't even be possible, but for now it
+    // needs to be dealt with.
+    var k = uuid.v4();
+    var requests = [
+        {
+            bucket: b,
+            key: k,
+            value: {
+                foo: 'bar'
+            },
+            options: {
+                _value: '{"this":"is", "bs":[}'
+            }
+        }
+    ];
+
+    vasync.pipeline({
+        funcs: [
+            function prepBucket(_, cb) {
+                var cfg = jsprim.deepCopy(BUCKET_CFG);
+                // Simplify test by removing pre/post bucket actions
+                // (Required for positive verification)
+                delete cfg.pre;
+                delete cfg.post;
+                cfg.options.version = 2;
+                c.updateBucket(b, cfg, cb);
+            },
+            function put(_, cb) {
+                c.batch(requests, cb);
+            },
+            function checkValid(_, cb) {
+                c.getObject(b, k, cb);
+            },
+            function cleanup(_, cb) {
+                c.delObject(b, k, cb);
+            }
+        ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('batch delete object', function (t) {
+    var k = uuid.v4();
+    var v = { str: 'hi' };
+    var requests = [
+        {
+            operation: 'delete',
+            bucket: b,
+            key: k
+        }
+    ];
+
+    vasync.pipeline({
+        funcs: [
+            function put(_, cb) {
+                c.putObject(b, k, v, cb);
+            },
+            function checkPresent(_, cb) {
+                c.getObject(b, k, cb);
+            },
+            function batchDel(_, cb) {
+                c.batch(requests, cb);
+            },
+            function checkGone(_, cb) {
+                c.getObject(b, k, function (err) {
+                    t.ok(err);
+                    t.ok(VError.findCauseByName(
+                        err, 'ObjectNotFoundError') !== null);
+                    t.ok(err.message);
+                    cb();
+                });
+            }
+        ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+
+        t.end();
+    });
+});
+
+
+test('update objects no keys', function (t) {
+    var requests = [];
+    for (var i = 0; i < 10; i++) {
+        requests.push({
+            bucket: b,
+            key: uuid.v4().substr(0, 7),
+            value: {
+                num: 20,
+                num_u: i,
+                str: 'foo',
+                str_u: uuid.v4().substr(0, 7)
+            }
+        });
+    }
+
+    c.batch(requests, function (put_err) {
+        t.ifError(put_err);
+        if (put_err) {
+            t.end();
+            return;
+        }
+
+        c.updateObjects(b, {}, '(num>=20)', function (err) {
+            t.ok(err);
+            t.ok(VError.findCauseByName(err, 'FieldUpdateError') !== null);
+            t.end();
+        });
+    });
+});
+
+
+test('update objects ok', function (t) {
+    var requests = [];
+    for (var i = 0; i < 10; i++) {
+        requests.push({
+            bucket: b,
+            key: uuid.v4().substr(0, 7),
+            value: {
+                num: 20,
+                num_u: i,
+                str: 'foo',
+                str_u: uuid.v4().substr(0, 7)
+            }
+        });
+    }
+
+    c.batch(requests, function (put_err) {
+        t.ifError(put_err);
+        if (put_err) {
+            t.end();
+            return;
+        }
+
+        var fields = {str: 'bar'};
+        c.updateObjects(b, fields, '(num>=20)', function (err, meta) {
+            t.ifError(err);
+            t.ok(meta);
+            if (!meta) {
+                t.end();
+                return;
+            }
+            t.ok(meta.etag);
+
+            c.getObject(b, requests[0].key, function (err2, obj) {
+                t.ifError(err2);
+                t.ok(obj);
+                if (obj) {
+                    t.equal(obj.value.str, 'bar');
+                    t.equal(obj._etag, meta.etag);
+                }
+
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('update objects w/array (ufds - no effect)', function (t) {
+    var requests = [];
+    for (var i = 0; i < 10; i++) {
+        requests.push({
+            bucket: b,
+            key: uuid.v4().substr(0, 7),
+            value: {
+                str: ['foo']
+            }
+        });
+    }
+
+    c.batch(requests, function (put_err) {
+        t.ifError(put_err);
+        if (put_err) {
+            t.end();
+            return;
+        }
+
+        var fields = {str: 'bar'};
+        c.updateObjects(b, fields, '(str=foo)', function (err, meta) {
+            t.ifError(err);
+            t.ok(meta);
+            if (!meta) {
+                t.end();
+                return;
+            }
+            t.ok(meta.etag);
+
+            var k = requests[0].key;
+            var o = {noCache: true};
+            c.getObject(b, k, o, function (err2, obj) {
+                t.ifError(err2);
+                t.ok(obj);
+                if (obj) {
+                    t.ok(Array.isArray(obj.value.str));
+                    t.notOk(obj.value.str_u);
+                    t.equal(obj.value.str[0], 'foo');
+                    t.equal(obj._etag, meta.etag);
+                }
+
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('batch put/update', function (t) {
+    var requests = [];
+    for (var i = 0; i < 10; i++) {
+        requests.push({
+            bucket: b,
+            key: uuid.v4().substr(0, 7),
+            value: {
+                num: 20,
+                num_u: i,
+                str: 'foo',
+                str_u: uuid.v4().substr(0, 7)
+            }
+        });
+    }
+
+    c.batch(requests, function (init_err) {
+        t.ifError(init_err);
+
+        var ops = [
+            {
+                bucket: b,
+                key: requests[0].key,
+                value: {
+                    num: 10,
+                    str: 'baz'
+                }
+            },
+            {
+                bucket: b,
+                operation: 'update',
+                fields: {
+                    str: 'bar'
+                },
+                filter: '(num_u>=5)'
+            }
+        ];
+        c.batch(ops, function (err, meta) {
+            t.ifError(err);
+            t.ok(meta);
+            t.ok(meta.etags);
+            var req = c.findObjects(b, '(num_u>=0)');
+            req.once('error', function (e) {
+                t.ifError(e);
+                t.end();
+            });
+            req.once('end', function () {
+                t.end();
+            });
+            req.on('record', function (r) {
+                t.equal(r.bucket, b);
+                t.ok(r.key);
+                var v = r.value;
+                if (v.num_u >= 5) {
+                    t.equal(v.str, 'bar');
+                } else if (r.key === requests[0].key) {
+                    t.equal(v.str, 'baz');
+                } else {
+                    t.equal(v.str, 'foo');
+                }
+            });
+        });
+    });
+});
+
+
+test('delete many objects ok', function (t) {
+    var requests = [];
+    for (var i = 0; i < 10; i++) {
+        requests.push({
+            bucket: b,
+            key: uuid.v4().substr(0, 7),
+            value: {
+                num: 20,
+                num_u: i,
+                str: 'foo',
+                str_u: uuid.v4().substr(0, 7)
+            }
+        });
+    }
+
+    c.batch(requests, function (put_err) {
+        t.ifError(put_err);
+        if (put_err) {
+            t.end();
+            return;
+        }
+
+        c.deleteMany(b, '(num>=20)', function (err) {
+            t.ifError(err);
+            t.end();
+        });
+    });
+});
+
+test('get tokens unsupported', function (t) {
+    c.getTokens(function (err, res) {
+        t.notOk(res);
+        t.ok(err);
+        t.end();
+    });
+});
+
+
+test('MORAY-147 (sqli)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello',
+        str_2: 'world'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(&(str=hel\')(!(str_2=usa)))';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                found = true;
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(!found);
+        t.end();
+    });
+});
+
+
+
+test('MORAY-148 (foo=bar=*)', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello=world',
+        str_2: 'world=hello'
+    };
+    var found = false;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function find(_, cb) {
+            var f = '(|(str=hello=*)(str_2=world=*))';
+            var req = c.findObjects(b, f);
+            req.once('error', cb);
+            req.once('end', cb);
+            req.once('record', function (obj) {
+                found = true;
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.ok(found);
+        t.end();
+    });
+});
+
+
+test('MORAY-166: deleteMany with LIMIT', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello=world'
+    };
+    var N = 35;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            cb = once(cb);
+
+            var done = 0;
+            function _cb(err) {
+                if (err) {
+                    cb(err);
+                } else if (++done === N) {
+                    cb();
+                }
+            }
+
+            for (var i = 0; i < N; i++)
+                c.putObject(b, k + '' + i, v, _cb);
+
+        }, function delMany(_, cb) {
+            cb = once(cb);
+
+            var _opts = {
+                limit: Math.floor(N / 4)
+            };
+
+            (function drop() {
+                function _cb(err, meta) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+
+                    t.ok(meta);
+                    if (!meta) {
+                        cb(new Error('boom'));
+                        return;
+                    }
+                    t.ok(meta.count <= _opts.limit);
+                    if (meta.count > 0) {
+                        drop();
+                    } else {
+                        cb();
+                    }
+                }
+
+                c.deleteMany(b, '(str=*)', _opts, _cb);
+            })();
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+
+test('MORAY-166: update with LIMIT', function (t) {
+    var k = uuid.v4();
+    var v = {
+        str: 'hello=world'
+    };
+    var N = 35;
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            cb = once(cb);
+
+            var done = 0;
+            function _cb(err) {
+                if (err) {
+                    cb(err);
+                } else if (++done === N) {
+                    cb();
+                }
+            }
+
+            for (var i = 0; i < N; i++)
+                c.putObject(b, k + '' + i, v, _cb);
+
+        }, function updateMany(_, cb) {
+            cb = once(cb);
+
+            var _opts = {
+                limit: Math.floor(N / 4)
+            };
+
+            function _cb(err, meta) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                t.ok(meta);
+                if (!meta) {
+                    cb(new Error('boom'));
+                    return;
+                }
+
+                t.equal(meta.count, _opts.limit);
+                cb();
+            }
+
+            c.updateObjects(b, {str: 'fo'}, '(str=*)', _opts, _cb);
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('MORAY-166: delete w/LIMIT in batch', function (t) {
+    var k = uuid.v4();
+
+    vasync.pipeline({
+        funcs: [
+            function putObjects(_, cb) {
+                cb = once(cb);
+                var barrier = vasync.barrier();
+                var vals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
+                vals.forEach(function (i) {
+                    barrier.start(i);
+                    var _k = k + i;
+                    var v = {
+                        num: i
+                    };
+
+                    c.putObject(b, _k, v, function (err) {
+                        if (err)
+                            cb(err);
+
+                        barrier.done(i);
+                    });
+                });
+
+                barrier.on('drain', cb);
+            },
+            function deleteObjects(_, cb) {
+                cb = once(cb);
+                c.batch([
+                    {
+                        operation: 'deleteMany',
+                        bucket: b,
+                        filter: 'num=*',
+                        options: {
+                            limit: 5
+                        }
+                    }
+                ], function (err, meta) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    t.ok(meta);
+                    t.equal(meta.etags[0].count, 5);
+                    cb();
+                });
+            }
+        ]
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('MORAY-175: overwrite with \' in name', function (t) {
+    var k = uuid.v4() + '\'foo';
+    var v = {
+        str: 'hi',
+        vnode: 2
+    };
+    var v2 = {
+        str: 'hello world',
+        pre: 'hi'
+    };
+
+    vasync.pipeline({
+        funcs: [ function create(_, cb) {
+            c.putObject(b, k, v, cb);
+        }, function overwrite(_, cb) {
+            c.putObject(b, k, v2, cb);
+        }, function getAgain(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err) {
+                    cb(err);
+                } else {
+                    t.ok(obj);
+                    v2.pre = 'pre_overwrite';
+                    assertObject(t, obj, k, v2);
+                    cb();
+                }
+            });
+        } ],
+        arg: {}
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('reindex objects', function (t) {
+
+    var field = 'unindexed';
+    var COUNT = 1000;
+    var PAGESIZE = 100;
+    var records = [];
+    for (var i = 0; i < COUNT; i++) {
+        records.push(i);
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function insertRecords(_, cb) {
+                vasync.forEachPipeline({
+                    func: function (id, callback) {
+                        var k = uuid.v4();
+                        var obj = {
+                            str: 'test'
+                        };
+                        obj[field] = id;
+                        c.putObject(b, k, obj, function (err, meta) {
+                            callback(err);
+                        });
+                    },
+                    inputs: records
+                }, function (err) {
+                    t.ifError(err);
+                    t.ok(true, 'insert records');
+                    cb(err);
+                });
+            },
+            function updateBucket(_, cb) {
+                var config = jsprim.deepCopy(BUCKET_CFG);
+                config.index[field] =  {type: 'number'};
+                config.options.version++;
+                c.updateBucket(b, config, function (err) {
+                    t.ifError(err);
+                    t.ok(true, 'update bucket');
+                    cb(err);
+                });
+            },
+            function reindexObjects(_, cb) {
+                var total = 0;
+                function runReindex() {
+                    c.reindexObjects(b, PAGESIZE, function (err, res) {
+                        if (err) {
+                            t.ifError(err);
+                            cb(err);
+                            return;
+                        }
+                        if (res.processed === 0) {
+                            t.equal(COUNT, total);
+                            cb();
+                        } else {
+                            total += res.processed;
+                            process.nextTick(runReindex);
+                        }
+                    });
+                }
+                runReindex();
+            },
+            function queryNewIndex(_, cb) {
+                var limit = COUNT / 2;
+                var filter = util.format('(%s<=%d)', field, limit);
+
+                var found = 0;
+                var opts = {
+                    noBucketCache: true
+                };
+                var res = c.findObjects(b, filter, opts);
+                res.on('error', cb);
+                res.on('record', function () {
+                    found++;
+                });
+                res.on('end', function () {
+                    // <= means limit+1
+                    t.equal(limit+1, found);
+                    cb();
+                });
+            }
+        ]
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('MORAY-291: add ip', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168.1.10'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                assertObject(t, obj, k, v);
+                t.ok(obj.value.ip, 'has ip value');
+
+                if (obj.value.ip) {
+                    t.ok(net.isIPv4(obj.value.ip), 'ip value is IPv4');
+                    t.equal(obj.value.ip, v.ip, 'ip is correct');
+                }
+
+                return (cb());
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-291: add partial ip not ok', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168'
+    };
+    var errmsg = 'index(ip) is of type ip';
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err) {
+                    t.ok(err, 'received an error');
+                    t.ok(jsprim.endsWith(err.message, errmsg),
+                        'with the right message');
+                    return (cb());
+                }
+                t.notOk(false, 'did not error on bogus ip');
+                return (cb());
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-291: add ip/cidr not ok', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168.1.10/24'
+    };
+    var errmsg = 'index(ip) is of type ip';
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err) {
+                    t.ok(err, 'received an error');
+                    t.ok(jsprim.endsWith(err.message, errmsg,
+                        'with the right message'));
+                    return (cb());
+                }
+                t.notOk(false, 'did not error on ip/cidr input');
+                return (cb());
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-291: add subnet', function (t) {
+    var k = uuid.v4();
+    var v = {
+        subnet: '192.168.1.0/24'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function get(_, cb) {
+            c.getObject(b, k, function (err, obj) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(obj);
+                t.ok(obj.value.subnet, 'has subnet value');
+
+                if (obj.value.ip) {
+                    t.equal(obj.value.subnet, v.subnet, 'subnet value correct');
+                }
+
+                return (cb());
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-291: invalid subnet', function (t) {
+    var k = uuid.v4();
+    var v = {
+        subnet: '192.168.1.10/24'
+    };
+    var errmsg = 'invalid cidr value: "' + v.subnet + '"';
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err) {
+                    t.ok(err, 'received an error');
+                    t.ok(jsprim.endsWith(err.message, errmsg,
+                        'with the right message'));
+                    return (cb());
+                }
+                t.notOk(false, 'did not error on bogus ip');
+                return (cb());
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-333: able to query on null subnet field', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168.1.10'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function put(_, cb) {
+                c.putObject(b, k, v, function (err, meta) {
+                    if (err)
+                        return (cb(err));
+
+                    t.ok(meta);
+                    if (meta)
+                        t.ok(meta.etag);
+                    return (cb());
+                });
+            },
+            function query(_, cb) {
+                var f = '(|(subnet=10.0.0.0/8)(ip=192.168.1.10))';
+                var req = c.findObjects(b, f);
+                var ok = false;
+                req.once('error', function (err) {
+                    t.ifError(err, 'query error');
+                    t.end();
+                });
+                req.once('end', function () {
+                    t.ok(ok);
+                    t.end();
+                });
+                req.on('record', function (obj) {
+                    t.ok(obj, 'received an object from the query');
+                    assertObject(t, obj, k, v);
+                    ok = true;
+                });
+            }
+        ]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('MORAY-333: able to query on null IP field', function (t) {
+    var k = uuid.v4();
+    var v = {
+        subnet: '192.168.0.0/16'
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function put(_, cb) {
+                c.putObject(b, k, v, function (err, meta) {
+                    if (err)
+                        return (cb(err));
+
+                    t.ok(meta);
+                    if (meta)
+                        t.ok(meta.etag);
+                    return (cb());
+                });
+            },
+            function query(_, cb) {
+                var f = '(|(ip=1.2.3.4)(subnet=192.168.0.0/16))';
+                var req = c.findObjects(b, f);
+                var ok = false;
+                req.once('error', function (err) {
+                    t.ifError(err, 'query error');
+                    t.end();
+                });
+                req.once('end', function () {
+                    t.ok(ok);
+                    t.end();
+                });
+                req.on('record', function (obj) {
+                    t.ok(obj, 'received an object from the query');
+                    assertObject(t, obj, k, v);
+                    ok = true;
+                });
+            }
+        ]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+
+// TODO: should create own bucket.
+test('MORAY-291: able to query on IP types', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168.1.10'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function query(_, cb) {
+            var f = '(ip=192.168.1.10)';
+            var req = c.findObjects(b, f);
+            var ok = false;
+            req.once('error', function (err) {
+                t.ifError(err, 'query error');
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+            req.on('record', function (obj) {
+                t.ok(obj, 'received an object from the query');
+                assertObject(t, obj, k, v);
+                ok = true;
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+// TODO: should create own bucket.
+test('MORAY-291: able to query <= on IP types', function (t) {
+    var k = uuid.v4();
+    var v = {
+        ip: '192.168.1.8'
+    };
+
+    vasync.pipeline({
+        funcs: [ function put(_, cb) {
+            c.putObject(b, k, v, function (err, meta) {
+                if (err)
+                    return (cb(err));
+
+                t.ok(meta);
+                if (meta)
+                    t.ok(meta.etag);
+                return (cb());
+            });
+        }, function query(_, cb) {
+            var f = '(ip<=192.168.1.9)';
+            var req = c.findObjects(b, f);
+            var ok = false;
+            req.once('error', function (err) {
+                t.ifError(err, 'query error');
+                t.end();
+            });
+            req.once('end', function () {
+                t.ok(ok);
+                t.end();
+            });
+            req.on('record', function (obj) {
+                t.ok(obj, 'received an object from the query');
+                assertObject(t, obj, k, v);
+                t.ok(obj.value.ip, 'has ip value');
+
+                if (obj.value.ip) {
+                    t.ok(net.isIPv4(obj.value.ip), 'ip value is IPv4');
+                    t.equal(obj.value.ip, v.ip, 'ip is correct');
+                }
+
+                ok = true;
+            });
+        }]
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+// TODO: other queries on IP types that we need: <=
+// TODO: queries on subnet types =, <=
+
+test('MORAY-298: presence filter works for all types', function (t) {
+    var recs = [
+        {
+            k: 'str',
+            v: 'string'
+        },
+        {
+            k: 'str_u',
+            v: 'unique string'
+        },
+        {
+            k: 'num',
+            v: 40
+        },
+        {
+            k: 'bool',
+            v: true
+        },
+        {
+            k: 'bool_u',
+            v: true
+        },
+        {
+            k: 'ip',
+            v: '192.168.5.2'
+        },
+        {
+            k: 'ip_u',
+            v: '192.168.5.3'
+        },
+        {
+            k: 'subnet',
+            v: '192.168.5.0/24'
+        },
+        {
+            k: 'subnet_u',
+            v: '192.168.6.0/24'
+        }
+    ];
+
+    vasync.forEachParallel({
+        inputs: recs,
+        func: function presence(rec, cb) {
+            var v = {};
+            v[rec.k] = rec.v;
+
+            c.putObject(b, rec.k, v, function (putErr, meta) {
+                var desc = ': ' + rec.k + '/' + rec.v;
+                var f = util.format('(%s=*)', rec.k);
+                var n = 0;
+                var req;
+
+                t.ifErr(putErr, 'put' + desc);
+                if (putErr)
+                    return (cb(putErr));
+
+                req = c.findObjects(b, f);
+
+                req.once('error', function (err) {
+                    t.ifError(err, 'query error' + desc);
+                    return (cb(err));
+                });
+
+                req.once('end', function () {
+                    t.equal(n, 1, '1 record returned' + desc);
+                    return (cb());
+                });
+
+                req.on('record', function (obj) {
+                    n++;
+                    t.equal(obj.value[rec.k], rec.v, 'value' + desc);
+                });
+
+                return req;
+            });
+        }
+    }, function (err) {
+        t.ifError(err, 'no errors');
+        t.end();
+    });
+});
+
+test('filter on unindexed fields', function (t) {
+    var v = {
+        str: 'required',
+        ui_str: 'value',
+        ui_num: 15,
+        ui_zero: 0,
+        ui_null: null
+    };
+    var k = uuid.v4();
+    var tests = {
+        // Equality:
+        '(ui_str=value)': true,
+        '(ui_str=bad)': false,
+        // '(ui_num=15)': true, ruined by strict types
+        '(ui_num=14)': false,
+        '(ui_num=0)': false,
+        // '(ui_zero=0)': true, ruined by strict types
+        '(ui_zero=1)': false,
+        // Presence:
+        '(ui_str=*)': true,
+        '(ui_num=*)': true,
+        '(ui_zero=*)': true,
+        '(ui_null=*)': false,
+        '(ui_bogus=*)': false,
+        // GE/LE:
+        '(ui_num>=15)': true,
+        '(ui_num>=0)': true,
+        '(ui_num>=16)': false,
+        '(ui_num<=15)': true,
+        '(ui_num<=0)': false,
+        '(ui_num<=16)': true,
+        '(ui_str>=value)': true,
+        '(ui_str>=valud)': true,
+        '(ui_str>=valuf)': false,
+        '(ui_str<=value)': true,
+        '(ui_str<=valud)': false,
+        '(ui_str<=valuf)': true,
+        // Substring:
+        '(ui_str=val*)': true,
+        '(ui_str=val*e)': true,
+        '(ui_str=*alue)': true,
+        '(ui_str=v*l*e)': true,
+        '(ui_str=n*ope)': false,
+        '(ui_str=*nope)': false,
+        '(ui_str=nope*)': false,
+        '(ui_str=no*p*e)': false,
+        // Ext:
+        '(ui_str:caseIgnoreMatch:=VALUE)': true,
+        '(ui_str:caseIgnoreMatch:=NOPE)': false,
+        '(ui_str:caseIgnoreSubstringsMatch:=V*LUE)': true,
+        '(ui_str:caseIgnoreSubstringsMatch:=N*PE)': false
+    };
+    c.putObject(b, k, v, function (putErr) {
+        if (putErr) {
+            t.ifError(putErr);
+            t.end();
+            return;
+        }
+        vasync.forEachParallel({
+            inputs: Object.keys(tests),
+            func: function filterCheck(f, cb) {
+                var found = false;
+                cb = once(cb);
+                var fixed = '(&(str=required)' + f + ')';
+                var res = c.findObjects(b, fixed);
+                res.once('error', function (err) {
+                    t.ifError(err);
+                    cb(err);
+                });
+                res.on('record', function (obj) {
+                    if (k !== obj.key)
+                        t.fail('invalid key');
+                    found = true;
+                });
+                res.once('end', function () {
+                    if (tests[f]) {
+                        t.ok(found, f + ' should find object');
+                    } else {
+                        t.notOk(found, f + ' should not find object');
+                    }
+                    cb();
+                });
+            }
+        }, function (err) {
+            t.ifError(err);
+            t.end();
+        });
+    });
+});
+
+test('MORAY-311: ext filters survive undefined fields', function (t) {
+    var v = {
+        num: 5
+    };
+    var k = uuid.v4();
+    var filters = [
+        '(&(num=5)(!(str:caseIgnoreSubstringsMatch:=*test*)))',
+        '(&(num=5)(!(str:caseIgnoreMatch:=*test*)))'
+    ];
+    c.putObject(b, k, v, function (putErr) {
+        if (putErr) {
+            t.ifError(putErr);
+            t.end();
+            return;
+        }
+        vasync.forEachParallel({
+            inputs: filters,
+            func: function filterCheck(f, cb) {
+                var found = false;
+                cb = once(cb);
+                var res = c.findObjects(b, f);
+                res.once('error', function (err) {
+                    t.ifError(err);
+                    cb(err);
+                });
+                res.on('record', function (obj) {
+                    t.equal(k, obj.key);
+                    found = true;
+                });
+                res.once('end', function () {
+                    t.ok(found);
+                    cb();
+                });
+            }
+        }, function (err) {
+            t.ifError(err);
+            t.end();
+        });
+    });
+});
diff --git a/test/sql.test.js b/test/sql.test.js
new file mode 100644
index 0000000..c94c051
--- /dev/null
+++ b/test/sql.test.js
@@ -0,0 +1,101 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+var tape = require('tape');
+var util = require('util');
+var uuid = require('libuuid').create;
+
+var helper = require('./helper.js');
+
+
+var c; // client
+var server;
+var table = 'moray_unit_test_' + uuid().substr(0, 7);
+var sql;
+var q;
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        c.once('close', function () {
+            helper.cleanupServer(server, function () {
+                t.pass('closed');
+                t.end();
+            });
+        });
+        c.close();
+    });
+}
+
+
+test('sql - execute', function (t) {
+    sql = util.format('CREATE TABLE %s (value integer);', table);
+    q = c.sql(sql, [], {});
+    q.on('error', t.ifError.bind(t));
+    q.once('end', function () {
+        t.pass('create table success');
+        t.end();
+    });
+});
+
+test('sql - insert', function (t) {
+    sql = util.format('INSERT INTO %s (value) VALUES ($1);', table);
+    q = c.sql(sql, [5], {});
+    q.on('error', t.ifError.bind(t));
+    q.once('end', function () {
+        t.pass('insert success');
+        t.end();
+    });
+});
+
+test('sql - select', function (t) {
+    var count = 0;
+    sql = util.format('SELECT * FROM %s', table);
+    q = c.sql(sql, [], {});
+    q.on('error', t.ifError.bind(t));
+    q.on('record', function (row) {
+        t.equal(row.value, 5);
+        count++;
+    });
+    q.once('end', function () {
+        t.equal(count, 1);
+        t.end();
+    });
+});
+
+test('sql - fail', function (t) {
+    sql = 'BOGUS QUERY;';
+    q = c.sql(sql, [], {});
+    q.once('error', function (err) {
+        t.ok(err);
+        t.end();
+    });
+});
+
+test('sql - cleanup', function (t) {
+    sql = util.format('DROP TABLE %s;', table);
+    q = c.sql(sql, [], {});
+    q.on('error', t.ifError.bind(t));
+    q.once('end', function () {
+        t.pass('success');
+        t.end();
+    });
+});
diff --git a/test/stress-client.js b/test/stress-client.js
new file mode 100644
index 0000000..27e4e43
--- /dev/null
+++ b/test/stress-client.js
@@ -0,0 +1,663 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * stress-client.js: run the client through a lot of different code paths for an
+ * extended period.  The intent is to help identify memory leaks by monitoring
+ * this process's memory usage over time.
+ *
+ * We want to exercise:
+ *
+ * - making RPC requests when disconnected (both never-connected and
+ *   transiently-disconnected cases)
+ * - repeated connection/disconnection
+ * - failed RPC calls for each type of request (failure path)
+ * - successful RPC calls for each type of request (success path)
+ * - RPC requests that time out
+ *
+ * That list should include any operation with a client that programs might do a
+ * large number of times over a long lifetime.
+ *
+ * This works as follows: there are a number of top-level commands, represented
+ * with functions that execute a command (like making a particular RPC request).
+ * When each function completes, it gets executed again.  This goes on until the
+ * user kills the process.
+ *
+ * This program opens a Kang server on port 9080 for inspecting progress.
+ */
+
+var assertplus = require('assert-plus');
+var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
+var kang = require('kang');
+var moray = require('moray');
+var net = require('net');
+var os = require('os');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var helper = require('./helper');
+
+var scTestBucketBogus = 'stress_client_bogus_bucket';
+var scTestBucketInvalid = 'buckets can\'t have spaces!';
+var scTestBucket = 'stress_client_bucket';
+var scKangPort = 9080;
+var scCommands = [];
+var scLog, scServer;
+
+/*
+ * We require that each of our top-level test commands complete one iteration
+ * every "scWatchdogLimit" milliseconds.  Otherwise, a call has likely hung, and
+ * we'll bail out.
+ */
+var scWatchdogLimit = 30000;
+
+function main()
+{
+    scLog = new bunyan({
+        'name': 'stress-client',
+        'level': process.env['LOG_LEVEL'] || 'fatal'
+    });
+
+    console.error('pid %d: setting up', process.pid);
+
+    kang.knStartServer({
+        'port': scKangPort,
+        'uri_base': '/kang',
+        'service_name': 'moray-client-stress',
+        'version': '1.0.0',
+        'ident': os.hostname(),
+        'list_types': knListTypes,
+        'list_objects': knListObjects,
+        'get': knGetObject
+    }, function () {
+        /*
+         * First, set up a server that all clients can use.
+         */
+        helper.createServer(null, function (s) {
+            scServer = s;
+
+            /*
+             * Now initialize each of the commands and start them running.
+             */
+            vasync.forEachParallel({
+                'inputs': scCommands,
+                'func': scCommandStart
+            }, function (err) {
+                if (err) {
+                    cmdutil.fail(new VError('setup'));
+                }
+
+                scLog.debug('set up all commands');
+                console.error('set up all commands');
+            });
+        });
+    });
+}
+
+function knListTypes()
+{
+    return ([ 'cmd' ]);
+}
+
+function knListObjects(type)
+{
+    assertplus.equal(type, 'cmd');
+    return (scCommands.map(function (_, i) {
+        return (i);
+    }));
+}
+
+function knGetObject(type, which)
+{
+    var cmdspec;
+
+    assertplus.equal(type, 'cmd');
+    cmdspec = scCommands[which];
+    return ({
+        'label': cmdspec.name,
+        'funcname': cmdspec.exec.name,
+        'nstarted': cmdspec.ctx.nstarted,
+        'lastStarted': cmdspec.ctx.lastStarted
+    });
+}
+
+function scCommandStart(cmdspec, callback)
+{
+    cmdspec.ctx = {};
+    cmdspec.ctx.nstarted = 0;
+    cmdspec.ctx.lastStarted = null;
+    cmdspec.ctx.setupStarted = new Date();
+    cmdspec.ctx.setupDone = null;
+    cmdspec.ctx.log = scLog.child({
+        'cmdname': cmdspec.exec.name || cmdspec.name
+    });
+    cmdspec.ctx.timer = null;
+
+    cmdspec.setup(cmdspec.ctx, function (err) {
+        if (err) {
+            callback(new VError(err, 'setup command "%s"', cmdspec.name));
+            return;
+        }
+
+        cmdspec.ctx.setupDone = new Date();
+        scCommandLoop(cmdspec);
+        callback();
+    });
+}
+
+function scCommandLoop(cmdspec)
+{
+    cmdspec.ctx.nstarted++;
+    cmdspec.ctx.log.debug({
+        'iteration': cmdspec.ctx.nstarted
+    }, 'starting iteration');
+    cmdspec.ctx.lastStarted = new Date();
+    cmdspec.ctx.timer = setTimeout(scWatchdogFire, scWatchdogLimit, cmdspec);
+
+    cmdspec.exec(cmdspec.ctx, function (err) {
+        clearTimeout(cmdspec.ctx.timer);
+
+        if (err) {
+            err = new VError(err, 'exec command "%s"', cmdspec.name);
+            cmdspec.ctx.log.fatal(err);
+            throw (err);
+        }
+
+        setImmediate(scCommandLoop, cmdspec);
+    });
+}
+
+function scWatchdogFire(cmdspec)
+{
+    /*
+     * This is basically going to be undebuggable without a core file.  We may
+     * as well abort straight away rather than hoping the user ran with
+     * --abort-on-uncaught-exception.
+     */
+    console.error('watchdog timer expired for command: "%s"', cmdspec.name);
+    console.error('aborting (to dump core)');
+    process.abort();
+}
+
+function ignoreErrorTypes(err, errtypes)
+{
+    var i;
+
+    assertplus.optionalObject(err);
+    assertplus.arrayOfString(errtypes, 'errtypes');
+    if (!err) {
+        return (err);
+    }
+
+    assertplus.ok(err instanceof Error);
+    for (i = 0; i < errtypes.length; i++) {
+        if (VError.findCauseByName(err, errtypes[i]) !== null) {
+            return (null);
+        }
+    }
+
+    return (err);
+}
+
+function cbIgnoreErrorTypes(callback, errtypes)
+{
+    return (function (err) {
+        var args = Array.prototype.slice.call(arguments, 1);
+        args.unshift(ignoreErrorTypes(err, errtypes));
+        callback.apply(null, args);
+    });
+}
+
+/*
+ * Command definitions
+ */
+
+/*
+ * This loop exercises code paths associated with sending RPC requests before
+ * we've ever established a connection.
+ */
+scCommands.push({
+    'name': 'make RPC requests before ever connected',
+    'setup': function cmdRpcNeverConnectedSetup(ctx, callback) {
+        /*
+         * Configure the client with a hostname that doesn't exist so that it
+         * will never connect.
+         */
+        ctx.client = moray.createClient({
+            'log': ctx.log.child({ 'component': 'MorayClient' }),
+            'host': 'bogus_hostname',
+            'port': 2020
+        });
+
+        callback();
+    },
+    'exec': function cmdRpcNeverConnected(ctx, callback) {
+        ctx.client.listBuckets(function (err) {
+            if (VError.findCauseByName(err, 'NoBackendsError') !== null) {
+                err = null;
+            }
+
+            callback(err);
+        });
+    }
+});
+
+/*
+ * This loop exercises the code paths associated with sending RPC requests while
+ * we have no connection (but we previously had one).  This is largely the same
+ * as the previous case, but could result in different code paths.
+ */
+scCommands.push({
+    'name': 'make RPC requests after connection closed',
+    'setup': function cmdRpcDisconnectedSetup(ctx, callback) {
+        helper.createServer({ 'portOverride': 2021 }, function (s) {
+            ctx.server = s;
+            ctx.client = moray.createClient({
+                'log': ctx.log.child({ 'component': 'MorayClient' }),
+                'host': '127.0.0.1',
+                'port': 2021
+            });
+            ctx.client.on('connect', function () {
+                helper.cleanupServer(ctx.server, callback);
+            });
+        });
+    },
+    'exec': function cmdRpcDisconnected(ctx, callback) {
+        ctx.client.listBuckets(function (err) {
+            if (!err) {
+                callback(new VError('expected error'));
+            } else {
+                callback();
+            }
+        });
+    }
+});
+
+/*
+ * This loop exercises connect/reconnect paths.
+ */
+scCommands.push({
+    'name': 'disconnect/reconnect repeatedly',
+    'setup': function cmdRpcReconnectSetup(ctx, callback) {
+        ctx.client = moray.createClient({
+            'log': ctx.log.child({ 'component': 'MorayClient' }),
+            'host': '127.0.0.1',
+            'port': 2022,
+            'maxConnections': 1,
+            'retry': {
+                'minTimeout': 50,
+                'maxTimeout': 50
+            }
+        });
+        callback();
+    },
+
+    'exec': function cmdRpcReconnect(ctx, callback) {
+        /*
+         * Our goal is to execute this sequence:
+         *
+         *   - set up a server
+         *   - wait for the client to connect to the server
+         *   - shut down the server
+         *   - wait for the client to see that the server is shutdown
+         *
+         * Our challenge is that the client deliberately abstracts over
+         * reconnection, so it doesn't expose the events we intend to wait for.
+         * So we accomplish the above using this sequence instead:
+         *
+         *   - set up a server
+         *   - make requests in a loop using the client until one of them
+         *     succeeds (meaning we've established a connection to our server)
+         *   - close the server
+         *   - make request using the client and verify that it fails
+         *     (meaning that the server has shut down)
+         *
+         * Importantly, we never instantiate a new client, since we're trying to
+         * make sure that a single long-lived client doesn't leak memory in
+         * these conditions.
+         *
+         * The fact that we use a separate process server here is extremely
+         * expensive, and means that we don't end up iterating very quickly on
+         * this command.  However, we need at least one request to succeed,
+         * which means we need a real Moray server.
+         */
+        ctx.server = null;
+        ctx.nloops = 0;
+        ctx.maxloops = 100;
+        ctx.pipeline = vasync.pipeline({
+            'funcs': [
+                function cmdRpcReconnectSetupServer(_, subcallback) {
+                    ctx.log.debug('creating server');
+                    helper.createServer({
+                        'portOverride': 2022
+                    }, function (s) {
+                        ctx.log.debug('server up');
+                        ctx.server = s;
+                        subcallback();
+                    });
+                },
+
+                function cmdRpcReconnectClientLoop(_, subcallback) {
+                    ctx.client.ping(function (err) {
+                        ctx.nloops++;
+                        if (err && ctx.nloops <= ctx.maxloops) {
+                            ctx.log.debug(err, 'ignoring transient error',
+                                { 'nloops': ctx.nloops });
+                            setTimeout(cmdRpcReconnectClientLoop, 100,
+                                _, subcallback);
+                            return;
+                        }
+
+                        if (err) {
+                            err = new VError(err, 'too many transient errors');
+                        }
+
+                        subcallback(err);
+                    });
+                },
+
+                function cmdRpcReconnectShutdown(_, subcallback) {
+                    ctx.log.debug('shutting down server');
+                    helper.cleanupServer(ctx.server, subcallback);
+                },
+
+                function cmdRpcReconnectClientFail(_, subcallback) {
+                    ctx.log.debug('making final client request');
+                    ctx.client.ping({ 'timeout': 5000 }, function (err) {
+                        if (err) {
+                            if (VError.findCauseByName(
+                                err, 'NoBackendsError') !== null ||
+                                VError.findCauseByName(
+                                err, 'FastTransportError') !== null ||
+                                VError.findCauseByName(
+                                err, 'FastProtocolError') !== null) {
+                                err = null;
+                            } else {
+                                err = new VError(err, 'unexpected error');
+                            }
+                        } else {
+                            err = new VError('unexpected success');
+                        }
+
+                        subcallback(err);
+                    });
+                }
+            ]
+        }, callback);
+    }
+});
+
+/*
+ * This loop exercises failure cases for each of the supported RPC requests.
+ */
+scCommands.push({
+    'name': 'failed RPC requests',
+    'setup': function cmdRpcFailSetup(ctx, callback) {
+        ctx.client = helper.createClient();
+        ctx.client.on('connect', callback);
+    },
+    'exec': function cmdRpcFail(ctx, callback) {
+        ctx.pipeline = vasync.pipeline({
+            'arg': null,
+            'funcs': [
+
+                /*
+                 * There's a test function for each of the supported RPC calls
+                 * that we can cause to fail reliably (and safely).  The
+                 * listBuckets(), ping(), and version() RPC calls do not appear
+                 * to have reliable ways to trigger failure.
+                 *
+                 * These test functions appear in the same order as the
+                 * corresponding RPC calls are registered in the Moray server's
+                 * lib/server.js.
+                 */
+
+                function cmdRpcFailCreateBucket(_, subcallback) {
+                    ctx.client.createBucket(scTestBucketInvalid, {},
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'InvalidBucketNameError' ]));
+                },
+
+                function cmdRpcFailGetBucket(_, subcallback) {
+                    ctx.client.getBucket(scTestBucketBogus,
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailUpdateBucket(_, subcallback) {
+                    ctx.client.updateBucket(scTestBucketBogus, {},
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailDeleteBucket(_, subcallback) {
+                    ctx.client.deleteBucket(scTestBucketBogus,
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailPutObject(_, subcallback) {
+                    ctx.client.putObject(scTestBucketBogus, 'key', {},
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailBatch(_, subcallback) {
+                    ctx.client.batch([ {
+                        'bucket': scTestBucketBogus,
+                        'operation': 'update',
+                        'fields': {},
+                        'filter': 'x=*'
+                    } ], cbIgnoreErrorTypes(
+                    subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailGetObject(_, subcallback) {
+                    ctx.client.getObject(scTestBucketBogus, 'key',
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailDelObject(_, subcallback) {
+                    ctx.client.delObject(scTestBucketBogus, 'key',
+                        cbIgnoreErrorTypes(
+                        subcallback, [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailFindObjects(_, subcallback) {
+                    var req = ctx.client.findObjects(scTestBucketBogus,
+                        'key=value');
+                    req.on('error', function (err) {
+                        err = ignoreErrorTypes(err, [ 'BucketNotFoundError' ]);
+                        subcallback(err);
+                    });
+                    req.on('end', function () {
+                        throw (new Error('unexpected "end"'));
+                    });
+                },
+
+                function cmdRpcFailUpdateObjects(_, subcallback) {
+                    ctx.client.updateObjects(scTestBucketBogus, {}, 'key=value',
+                        cbIgnoreErrorTypes(subcallback,
+                        [ 'FieldUpdateError' ]));
+                },
+
+                function cmdRpcFailReindexObjects(_, subcallback) {
+                    ctx.client.reindexObjects(scTestBucketBogus, 3,
+                        cbIgnoreErrorTypes(subcallback,
+                        [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailDeleteMany(_, subcallback) {
+                    ctx.client.deleteMany(scTestBucketBogus, 'x=y',
+                        cbIgnoreErrorTypes(subcallback,
+                        [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcFailGetTokens(_, subcallback) {
+                    ctx.client.getTokens(function (err) {
+                        assertplus.ok(err);
+                        assertplus.ok(/Operation not supported$/.test(
+                            err.message));
+                        subcallback();
+                    });
+                },
+
+                function cmdRpcFailSql(_, subcallback) {
+                    var req = ctx.client.sql('SELECT ctid from bogus;');
+                    req.on('error', function (err) {
+                        /* JSSTYLED */
+                        assertplus.ok(/relation "bogus" does not exist$/.test(
+                            err.message));
+                        subcallback();
+                    });
+                    req.on('end', function () {
+                        throw (new Error('unexpected "end"'));
+                    });
+                }
+            ]
+        }, callback);
+    }
+});
+
+/*
+ * This loop exercises success cases for each of the supported RPC requests.
+ */
+scCommands.push({
+    'name': 'successful RPC requests',
+    'setup': function cmdRpcOkaySetup(ctx, callback) {
+        ctx.client = helper.createClient();
+        ctx.client.on('connect', callback);
+    },
+    'exec': function cmdRpcOkay(ctx, callback) {
+        ctx.pipeline = vasync.pipeline({
+            'arg': null,
+            'funcs': [
+
+                /*
+                 * There's a test function for each of the supported RPC calls
+                 * that we can use successfully.  This excludes getTokens(),
+                 * which only succeeds for electric-moray.  The order is
+                 * different than the failure cases above because it's simpler
+                 * to create a working sequence in this order.  deleteBucket
+                 * appears twice to deal with unclean exits.
+                 */
+
+                function cmdRpcOkayDeleteBucketCleanup(_, subcallback) {
+                    ctx.client.deleteBucket(scTestBucket,
+                        cbIgnoreErrorTypes(subcallback,
+                        [ 'BucketNotFoundError' ]));
+                },
+
+                function cmdRpcOkayCreateBucket(_, subcallback) {
+                    ctx.client.createBucket(scTestBucket, {}, subcallback);
+                },
+
+                function cmdRpcOkayGetBucket(_, subcallback) {
+                    ctx.client.getBucket(scTestBucket, subcallback);
+                },
+
+                function cmdRpcOkayListBuckets(_, subcallback) {
+                    ctx.client.listBuckets(subcallback);
+                },
+
+                function cmdRpcOkayUpdateBucket(_, subcallback) {
+                    ctx.client.updateBucket(scTestBucket, {
+                        'index': { 'field1': { 'type': 'number' } }
+                    }, subcallback);
+                },
+
+                function cmdRpcOkayPutObject(_, subcallback) {
+                    ctx.client.putObject(scTestBucket, 'key5',
+                        { 'field1': 5 }, subcallback);
+                },
+
+                function cmdRpcOkayBatch(_, subcallback) {
+                    ctx.client.batch([ {
+                        'bucket': scTestBucket,
+                        'operation': 'put',
+                        'key': 'key2',
+                        'value': { 'field1': 2 }
+                    }, {
+                        'bucket': scTestBucket,
+                        'operation': 'put',
+                        'key': 'key3',
+                        'value': { 'field1': 3 }
+                    }, {
+                        'bucket': scTestBucket,
+                        'operation': 'put',
+                        'key': 'key7',
+                        'value': { 'field1': 7 }
+                    }, {
+                        'bucket': scTestBucket,
+                        'operation': 'put',
+                        'key': 'key9',
+                        'value': { 'field1': 9 }
+                    } ], subcallback);
+                },
+
+                function cmdRpcOkayGetObject(_, subcallback) {
+                    ctx.client.getObject(scTestBucket, 'key3', subcallback);
+                },
+
+                function cmdRpcOkayDelObject(_, subcallback) {
+                    ctx.client.delObject(scTestBucket, 'key5', subcallback);
+                },
+
+                function cmdRpcOkayFindObjects(_, subcallback) {
+                    var req = ctx.client.findObjects(scTestBucket, 'field1>=3');
+                    req.on('error', function (err) {
+                        subcallback(new VError(err, 'unexpected error'));
+                    });
+                    req.on('end', function () { subcallback(); });
+                },
+
+                function cmdRpcOkayUpdateObjects(_, subcallback) {
+                    ctx.client.updateObjects(scTestBucket,
+                        { 'field1': 10 }, 'field1>=9', subcallback);
+                },
+
+                function cmdRpcOkayReindexObjects(_, subcallback) {
+                    ctx.client.reindexObjects(scTestBucket, 3, subcallback);
+                },
+
+                function cmdRpcOkayDeleteMany(_, subcallback) {
+                    ctx.client.deleteMany(scTestBucket, 'field1>=7',
+                        subcallback);
+                },
+
+                function cmdRpcOkayDeleteBucket(_, subcallback) {
+                    ctx.client.deleteBucket(scTestBucket, subcallback);
+                },
+
+                function cmdRpcOkayPing(_, subcallback) {
+                    ctx.client.ping(subcallback);
+                },
+
+                function cmdRpcOkayVersion(_, subcallback) {
+                    ctx.client.versionInternal(subcallback);
+                },
+
+                function cmdRpcOkaySql(_, subcallback) {
+                    var req = ctx.client.sql('SELECT NOW();');
+                    req.on('error', function (err) {
+                        subcallback(new VError(err, 'unexpected error'));
+                    });
+                    req.on('end', function () { subcallback(); });
+                }
+            ]
+        }, callback);
+    }
+});
+
+
+
+main();
diff --git a/test/version.test.js b/test/version.test.js
new file mode 100644
index 0000000..26f40f1
--- /dev/null
+++ b/test/version.test.js
@@ -0,0 +1,93 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * version.test.js: test the "version" RPC call
+ */
+
+var moray = require('moray');
+var net = require('net');
+var tape = require('tape');
+var vasync = require('vasync');
+var VError = require('verror');
+var helper = require('./helper.js');
+
+var client, server;
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        helper.createServer(null, function (s) {
+            server = s;
+        client = helper.createClient();
+        client.on('connect', function () { t.end(); });
+        });
+    });
+
+    tape.test(name + ' - main', function (t) {
+        setup(t);
+    });
+
+    tape.test(name + ' - teardown', function (t) {
+        helper.cleanupServer(server, function () {
+            t.pass('closed');
+            t.end();
+        });
+    });
+}
+
+/*
+ * Tests the "version" RPC call from the current Moray server.  See the note
+ * about this RPC in the source before using it.
+ */
+test('version RPC: current server implementation', function (t) {
+    client.versionInternal(function (err, result) {
+        t.ifError(err);
+        t.equal(result, 2);
+        t.end();
+    });
+});
+
+/*
+ * Tests the "version" RPC call from a Moray server that does not respond.  This
+ * case is synthetic (i.e., we fake up a server that doesn't respond), but old
+ * implementations actually didn't respond, so this case is important.
+ */
+tape('version RPC: non-responsive server (takes 20s)', function (t) {
+    vasync.waterfall([
+        function startTcpServer(callback) {
+            server = net.createServer();
+            server.listen(function () { callback(); });
+        },
+
+        function connectClient(callback) {
+            client = moray.createClient({
+                'log': helper.createLogger(),
+                'host': server.address().address,
+                'port': server.address().port,
+                'maxConnections': 1
+            });
+
+            client.on('connect', function () { callback(); });
+        },
+
+        function makeRpc(callback) {
+            client.versionInternal(callback);
+        }
+    ], function (err, version) {
+        t.ok(err);
+        t.ok(VError.findCauseByName(err, 'TimeoutError') !== null);
+        t.ok(/note: very old Moray versions do not respond to this RPC/.test(
+            err.message));
+        t.ok(version === undefined || version === null);
+        t.end();
+        client.close();
+        server.close();
+    });
+});
diff --git a/tools/bashstyle b/tools/bashstyle
new file mode 100755
index 0000000..fa8dff7
--- /dev/null
+++ b/tools/bashstyle
@@ -0,0 +1,114 @@
+#!/usr/bin/env node
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+/*
+ * bashstyle: check bash scripts for adherence to style guidelines, including:
+ *
+ *    o no lines longer than 80 characters
+ *    o file does not end with a blank line
+ *
+ * Future enhancements could include:
+ *    o indents consistent with respect to tabs, spaces
+ *    o indents consistently sized (all are some multiple of the smallest
+ *      indent, which must be a tab or 4 or 8 spaces)
+ */
+
+var mod_assert = require('assert');
+var mod_fs = require('fs');
+
+var nerrors = 0;
+
+main();
+process.exit(0);
+
+function main()
+{
+	var files = process.argv.slice(2);
+
+	if (files.length === 0) {
+		console.error('usage: %s file1 [...]',
+		    process.argv.slice(0, 2).join(' '));
+		process.exit(2);
+	}
+
+	files.forEach(checkFile);
+
+	if (nerrors != 0)
+		process.exit(1);
+}
+
+function checkFile(filename)
+{
+	var text = mod_fs.readFileSync(filename, 'utf-8');
+	var lines = text.split('\n');
+	var i;
+
+	mod_assert.ok(lines.length > 0);
+
+	/*
+	 * Expand tabs in each line and check for long lines.
+	 */
+	for (i = 1; i <= lines.length; i++) {
+		var line = expandTabs(lines[i - 1]);
+
+		if (line.length > 80) {
+			nerrors++;
+			console.log('%s: %d: line exceeds 80 columns',
+			    filename, i);
+		}
+	}
+
+	/*
+	 * No sane editor lets you save a file without a newline at the very
+	 * end.
+	 */
+	if (lines[lines.length - 1].length !== 0) {
+		nerrors++;
+		console.log('%s: %d: file does not end with newline',
+			filename, lines.length);
+	}
+
+	/*
+	 * Since the file will always end with a newline, the last entry of
+	 * "lines" will actually be blank.
+	 */
+	if (lines.length > 1 && lines[lines.length - 2].length === 0) {
+		nerrors++;
+		console.log('%s: %d: file ends with a blank line',
+		    filename, lines.length - 1);
+	}
+}
+
+function expandTabs(text)
+{
+	var out = '';
+	var col = 0;
+	var j, k;
+
+	for (j = 0; j < text.length; j++) {
+		if (text[j] != '\t') {
+			out += text[j];
+			col++;
+			continue;
+		}
+
+		k = 8 - (col % 8);
+		col += k;
+
+		do {
+			out += ' ';
+		} while (--k > 0);
+
+		col += k;
+	}
+
+	return (out);
+}
diff --git a/tools/configure b/tools/configure
new file mode 100755
index 0000000..f7e39b8
--- /dev/null
+++ b/tools/configure
@@ -0,0 +1,747 @@
+#!/usr/bin/env node
+/* vim: set ft=javascript: */
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * configure CONFIG_FILE: given the configuration file specified in this
+ * project's README.md, produce a bash-sourceable file that will set PATH and
+ * other environment variables for use with this test suite.  Also set up local
+ * directories to find the appropriate implementations of the Moray client and
+ * server.
+ *
+ * The documentation for the environment variables lives in the generated file.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_cmdutil = require('cmdutil');
+var mod_envfile = require('../lib/envfile');
+var mod_forkexec = require('forkexec');
+var mod_fs = require('fs');
+var mod_jsprim = require('jsprim');
+var mod_mkdirp = require('mkdirp');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+/* Node 0.12 defines fs.X_OK, but that's not in 0.10. */
+var WORLD_EXECUTABLE = 0x1;
+
+/*
+ * This is the "npm install" argument we use to get the "stock" Moray client.
+ * TODO This should likely eventually become "moray" (i.e., the latest published
+ * one), but we haven't published v2 yet, so we're using this.
+ */
+var DFL_MORAY_CLIENT_TARGET = 'git://github.com/joyent/node-moray.git';
+var DFL_MORAY_SERVER_TARGET = 'git://github.com/joyent/moray.git';
+
+var usageMessage = [
+    '',
+    'Sets up this test suite workspace to run the test suite as configured ',
+    'in the specified CONFIG_FILE.  With -n, prints out the commands that ',
+    'would be executed without actually executing them.  See the README file',
+    'for information about the format of CONFIG_FILE.'
+].join('\n');
+
+/*
+ * Parse command-line arguments, read and parse the configuration file, and then
+ * hand off to configure() to do the real work.
+ */
+function main()
+{
+    var filename, argv;
+    var dryRun = false;
+
+    mod_cmdutil.configure({
+        'synopses': [ '[-n] CONFIG_FILE' ],
+        'usageMessage': usageMessage
+    });
+
+    argv = process.argv.slice(2);
+    if (argv.length > 0 && (argv[0] == '-n' || argv[0] == '--dry-run')) {
+        dryRun = true;
+        argv.shift();
+    }
+
+    if (argv.length != 1) {
+        mod_cmdutil.usage();
+    }
+
+    filename = argv[0];
+    readJsonFile(filename, function (err, p) {
+        var verr;
+
+        if (err) {
+            mod_cmdutil.fail(err);
+        }
+
+        verr = validateTestSuiteConfig(p);
+        if (verr instanceof Error) {
+            mod_cmdutil.fail(new VError(verr, 'validate "%s"', filename));
+        }
+
+        configure({
+            'tsconfig': p,
+            'dryRun': dryRun
+        }, function (perr) {
+            if (perr) {
+                mod_cmdutil.fail(perr);
+            }
+        });
+    });
+}
+
+/*
+ * Validates the given (parsed) configuration file.  Returns an error if the
+ * file is not valid.
+ */
+function validateTestSuiteConfig(tsconfig)
+{
+    var error;
+
+    error = mod_jsprim.validateJsonObject(tsConfigSchema, tsconfig);
+    if (error instanceof Error) {
+        return (error);
+    }
+
+    if (!tsconfig.server.hasOwnProperty('configBase') &&
+        !tsconfig.server.hasOwnProperty('remote')) {
+        return (new VError('at least one of "server.configBase" or ' +
+            '"server.remote" must be specified'));
+    }
+
+    return (null);
+}
+
+/*
+ * This function drives the work of this command.  Named arguments:
+ *
+ *     tsconfig     parsed, validated test suite configuration file
+ *
+ *     dryRun       boolean indicating whether this is a dry run.
+ *                  See the usage message for information about what this means.
+ */
+function configure(args, callback)
+{
+    var cfgctx, tsconfig, p, funcs;
+
+    mod_assertplus.object(args, 'args');
+    mod_assertplus.object(args.tsconfig, 'args.tsconfig');
+
+    /*
+     * Figure out what we're going to do up front so that we can report it for a
+     * dry run without doing anything.
+     */
+    tsconfig = args.tsconfig;
+    cfgctx = {
+        /*
+         * User-specified configuration
+         */
+
+        /* whether this is a dry run */
+        'c_dryrun': args.dryRun === true,
+
+        /* raw test suite configuration (parsed and validated) */
+        'c_tsconfig': tsconfig,
+
+        /* whether to use an existing Moray server */
+        'c_remote': mod_jsprim.pluck(tsconfig, 'server.remote'),
+        'c_use_remote': null,
+
+        /* user-configured "node" for server execution */
+        'c_server_node': mod_jsprim.pluck(
+            tsconfig, 'server.node') !== undefined ?
+            mod_path.resolve(mod_jsprim.pluck(tsconfig, 'server.node')) :
+            'node',
+
+        /* user-configured client path (null means stock client) */
+        'c_client_target': null,
+        /* user-configured server path (null means stock server) */
+        'c_server_target': null,
+
+        /*
+         * Derived configuration
+         */
+
+        /* root of test suite workspace */
+        'c_test_root': mod_path.normalize(mod_path.join(__dirname, '..')),
+        /* directory where we install packages and other files */
+        'c_run_root': null,
+
+        /* root of directory where client package is installed */
+        'c_run_client': null,
+        /* path to npm to use for the client */
+        'c_npm_client': null,
+        /* actual client package directory */
+        'c_client_installed': null,
+
+        /* root of directory where server package is installed */
+        'c_run_server': null,
+        /* path to npm to use for the server */
+        'c_npm_server': null,
+        /* actual server package directory */
+        'c_server_installed': null,
+        /* contents of server base configuration */
+        'c_server_base_config': null,
+        /* generated server configuration file */
+        'c_server_config': null,
+
+        /* environment variables to configure */
+        'c_env': new mod_envfile.Environment(),
+        'c_env_path': null          /* path to generated env.sh */
+    };
+
+    cfgctx.c_use_remote = cfgctx.c_remote !== undefined;
+
+    /*
+     * Fill in default values for the client and server npm targets.
+     */
+    p = mod_jsprim.pluck(cfgctx.c_tsconfig, 'client.path');
+    if (p !== undefined) {
+        cfgctx.c_client_target = mod_path.resolve(cfgctx.c_test_root, p);
+    }
+
+    p = mod_jsprim.pluck(cfgctx.c_tsconfig, 'server.path');
+    if (p !== undefined) {
+        cfgctx.c_server_target = mod_path.resolve(cfgctx.c_test_root, p);
+    }
+
+    /*
+     * Configure the other derived paths.
+     *
+     * We install or link the client and server dependencies in separate trees
+     * under "./run" and then use NODE_PATH to cause node to find them there.
+     * This allows the tests to require 'moray' as any other client consumer
+     * would without requiring us to put it into our package.json.  Part of the
+     * point of this test suite repository is to allow users to point the test
+     * suite at their own client implementation, and it would be confusing and
+     * potentially brittle to manage it via package.json.  Besides that, if we
+     * just depended on "moray" in package.json, "npm install" could wind up
+     * installing different packages based on our top-level dependencies than
+     * would be installed by a fresh copy of the same moray-client package.
+     * Keeping it in a separate path causes npm to treat it separately.
+     *
+     * The server has to be in a separate tree anyway because it may run with a
+     * different Node version with a different set of dependencies.
+     */
+    cfgctx.c_run_root = mod_path.join(cfgctx.c_test_root, 'run');
+    cfgctx.c_env_path = mod_path.join(cfgctx.c_run_root, 'env.sh');
+
+    cfgctx.c_run_client = mod_path.join(cfgctx.c_run_root, 'client');
+    cfgctx.c_client_installed = mod_path.join(cfgctx.c_run_client,
+        'node_modules', 'moray');
+
+    cfgctx.c_run_server = mod_path.join(cfgctx.c_run_root, 'server');
+    cfgctx.c_server_installed = mod_path.join(cfgctx.c_run_server,
+        'node_modules', 'moray-server');
+    cfgctx.c_server_config = mod_path.join(cfgctx.c_run_server,
+        'config-generated.json');
+
+    /*
+     * Configure the environment variables we'll need to set.
+     */
+    cfgctx.c_env.setVar({
+        'name': 'PATH',
+        'value': process.env['PATH'],
+        'comment': 'PATH is set so that the requested "node" is first on ' +
+            'our the PATH.'
+    });
+
+    cfgctx.c_node_client = 'node';
+    cfgctx.c_npm_client = 'npm';
+
+    if (cfgctx.c_server_node != 'node') {
+        cfgctx.c_npm_server = mod_path.join(
+            mod_path.dirname(cfgctx.c_server_node), 'npm');
+    } else {
+        cfgctx.c_npm_server = 'npm';
+    }
+
+    cfgctx.c_env.setVar({
+        'name': 'MORAY_TEST_ROOT',
+        'value': cfgctx.c_test_root,
+        'comment': 'MORAY_TEST_ROOT is the root of the test suite directory.'
+    });
+
+    if (process.env['NODE_PATH']) {
+        cfgctx.c_env.setVar({
+            'name': 'NODE_PATH',
+            'value': process.env['NODE_PATH']
+        });
+    }
+
+    cfgctx.c_env.prependPath({
+        'name': 'NODE_PATH',
+        'pathentry': mod_path.normalize(mod_path.join(
+            cfgctx.c_client_installed, '..')),
+        'comment': 'NODE_PATH is set to include the Moray client dependency.'
+    });
+
+    if (cfgctx.c_use_remote) {
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_REMOTE',
+            'value': cfgctx.c_remote,
+            'comment': 'URL for remote Moray instance to use for testing'
+        });
+
+        funcs = [
+            configureSanityCheckClientDirectory,
+            configureMkdirpClient,
+            configureInstallClient,
+            configureWriteEnv
+        ];
+    } else {
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_NODE_PATH',
+            'value': mod_path.normalize(mod_path.join(
+                cfgctx.c_server_installed, '..')),
+            'comment': 'MORAY_TEST_SERVER_NODE_PATH is the NODE_PATH that ' +
+                'will be used when invoking the server.'
+        });
+
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_NODE',
+            'value': cfgctx.c_server_node,
+            'comment': '"node" binary used to invoke the server'
+        });
+
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_ROOT',
+            'value': cfgctx.c_server_installed,
+            'comment': 'root of the server installation directory'
+        });
+
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_CONFIG',
+            'value': cfgctx.c_server_config,
+            'comment': 'path to generated server configuration file'
+        });
+
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_EXTRA_ARGS',
+            'value': '',
+            'comment': 'Extra arguments to pass to the Moray server.'
+        });
+
+        p = mod_jsprim.pluck(cfgctx.c_tsconfig, 'server.start');
+        if (p === undefined) {
+            p = '"$MORAY_TEST_SERVER_NODE" "$MORAY_TEST_SERVER_ROOT/main.js" ' +
+                '-f "$MORAY_TEST_SERVER_CONFIG" -v $MORAY_TEST_EXTRA_ARGS 2>&1';
+        }
+        cfgctx.c_env.setVar({
+            'name': 'MORAY_TEST_SERVER_RUN',
+            'value': p,
+            'comment': 'bash command used to invoke server'
+        });
+
+        funcs = [
+            configureSanityCheckClientDirectory,
+            configureSanityCheckServerDirectory,
+            configureMkdirpClient,
+            configureMkdirpServer,
+            configureReadServerConfig,
+            configureWriteServerConfig,
+            configureInstallClient,
+            configureInstallServer,
+            configureWriteEnv
+        ];
+    }
+
+    mod_vasync.pipeline({
+        'arg': cfgctx,
+        'funcs': funcs
+    }, function (err) {
+        callback(err);
+    });
+}
+
+/*
+ * Validate the presence of a Moray client installation.
+ */
+function configureSanityCheckClientDirectory(cfgctx, callback)
+{
+    configureSanityCheckDirectory(cfgctx, cfgctx.c_client_installed, callback);
+}
+
+/*
+ * Validate the presence of a Moray server installation.
+ */
+function configureSanityCheckServerDirectory(cfgctx, callback)
+{
+    configureSanityCheckDirectory(cfgctx, cfgctx.c_server_installed, callback);
+}
+
+/*
+ * General-purpose function (i.e., not a pipeline function) to validate the
+ * presence of an installed package.  Abort if there's something already there
+ * so that we don't have to worry about clobbering the wrong thing.
+ */
+function configureSanityCheckDirectory(cfgctx, directory, callback)
+{
+    if (cfgctx.c_dryrun) {
+        setImmediate(callback);
+        return;
+    }
+
+    mod_fs.lstat(directory, function (err) {
+        if (!err) {
+            callback(new VError('refusing to clobber "%s" ' +
+                '(run "make clean" to remove)', directory));
+        } else if (err && err['code'] != 'ENOENT') {
+            callback(new VError('lstat "%s"', directory));
+        } else {
+            callback();
+        }
+    });
+}
+
+/*
+ * Create the parent directory tree for the client install location.  We create
+ * the node_modules directory to cause "npm install" to install packages there
+ * instead of inside this package.
+ */
+function configureMkdirpClient(cfgctx, callback)
+{
+    configureMkdirp(cfgctx,
+        mod_path.join(cfgctx.c_run_client, 'node_modules'), callback);
+}
+
+/*
+ * Create the parent directory tree for the server install location.  We create
+ * the node_modules directory to cause "npm install" to install packages there
+ * instead of inside this package.
+ */
+function configureMkdirpServer(cfgctx, callback)
+{
+    configureMkdirp(cfgctx,
+        mod_path.join(cfgctx.c_run_server, 'node_modules'), callback);
+}
+
+/*
+ * General-purpose function (i.e., not a pipeline function) to "mkdirp" the
+ * specified path.  This does nothing in dry-run mode.
+ */
+function configureMkdirp(cfgctx, path, callback)
+{
+    if (cfgctx.c_dryrun) {
+        console.log('mkdir -p %s', JSON.stringify(path));
+        setImmediate(callback);
+        return;
+    }
+
+    mod_mkdirp(path, callback);
+}
+
+/*
+ * Read the server base configuration file specified by the user.
+ */
+function configureReadServerConfig(cfgctx, callback)
+{
+    var p;
+
+    /* The path was validated earlier. */
+    p = mod_jsprim.pluck(cfgctx.c_tsconfig, 'server.configBase');
+    mod_assertplus.string(p, 'server.configBase');
+
+    readJsonFile(p, function (err, c) {
+        if (err) {
+            callback(err);
+        } else {
+            cfgctx.c_server_base_config = c;
+            callback();
+        }
+    });
+}
+
+/*
+ * Write out a server configuration file based on the provided base
+ * configuration.
+ */
+function configureWriteServerConfig(cfgctx, callback)
+{
+    /*
+     * We currently don't make any changes from the provided base configuration.
+     * In the future, we may want to change the port number.
+     */
+    mod_assertplus.string(cfgctx.c_server_config);
+    mod_assertplus.object(cfgctx.c_server_base_config);
+    configureWriteFile(cfgctx, {
+        'filename': cfgctx.c_server_config,
+        'contents': JSON.stringify(cfgctx.c_server_base_config, null, '\t')
+    }, callback);
+}
+
+/*
+ * General-purpose function (i.e., not a pipeline function ) to write out the
+ * given contents to the specified file.  In dry-run mode, this emits a bash
+ * snippet that would do the same thing.
+ */
+function configureWriteFile(cfgctx, args, callback)
+{
+    var filename, eom, stream;
+
+    mod_assertplus.object(cfgctx, 'cfgctx');
+    mod_assertplus.object(args, 'args');
+    mod_assertplus.string(args.contents, 'args.contents');
+    mod_assertplus.string(args.filename, 'args.filename');
+    mod_assertplus.func(callback, 'callback');
+
+    filename = args.filename;
+    eom = 'EOF';
+    if (args.contents.indexOf(eom) != -1) {
+        setImmediate(callback, new VError('internal error: unsupported ' +
+            'file contents (contains "%s")', eom));
+        return;
+    }
+
+    if (cfgctx.c_dryrun) {
+        stream = process.stdout;
+        stream.write('cat > ' + JSON.stringify(filename) + ' << \'' +
+            eom + '\'\n');
+        stream.write(args.contents);
+        stream.write('\n' + eom + '\n');
+        setImmediate(callback);
+    } else {
+        console.log('writing %s', args.filename);
+        mod_fs.writeFile(args.filename, args.contents, function (err) {
+            if (err) {
+                err = new VError(err, 'write "%s"', filename);
+            }
+
+            callback(err);
+        });
+    }
+}
+
+/*
+ * Install the requested client package.
+ */
+function configureInstallClient(cfgctx, callback)
+{
+    configureInstall(cfgctx, {
+        'root': cfgctx.c_run_client,
+        'npm': cfgctx.c_npm_client,
+        'pkgname': 'moray',
+        'target': cfgctx.c_client_target,
+        'dflvalue': DFL_MORAY_CLIENT_TARGET
+    }, callback);
+}
+
+/*
+ * Install the requested server package.
+ */
+function configureInstallServer(cfgctx, callback)
+{
+    configureInstall(cfgctx, {
+        'root': cfgctx.c_run_server,
+        'npm': cfgctx.c_npm_server,
+        'pkgname': 'moray-server',
+        'target': cfgctx.c_server_target,
+        'dflvalue': DFL_MORAY_SERVER_TARGET
+    }, callback);
+}
+
+/*
+ * General-purpose function (i.e., not a pipeline function) to install the
+ * requested npm package.  Named arguments:
+ *
+ *     root     working directory into which to install the package
+ *
+ *     npm      path to the "npm" to use for the installation
+ *
+ *     pkgname  name of the package to install.  This is only used as a
+ *              sanity-check against the name in the package.json file.
+ *
+ *     target   If non-null, this is a path on the local filesystem containing a
+ *              package to "npm link" into place.  If null, a default copy of
+ *              the package is installed.
+ *
+ *     dflvalue The default argument to "npm install" if "target" was null.
+ *
+ * The reason "target" and "dflvalue" aren't combined into a single argument
+ * that just specifies what to install is that if "target" is null, we'll use
+ * "npm link".  Otherwise, we'll use "npm install".
+ */
+function configureInstall(cfgctx, args, callback)
+{
+    var forkexecArgs, pkgjson;
+    var pkgname, target, dflvalue;
+
+    mod_assertplus.object(cfgctx, 'cfgctx');
+    mod_assertplus.object(args, 'args');
+    mod_assertplus.string(args.root, 'args.root');
+    mod_assertplus.string(args.npm, 'args.npm');
+    mod_assertplus.string(args.pkgname, 'args.pkgname');
+    mod_assertplus.optionalString(args.target, 'args.target');
+    mod_assertplus.string(args.dflvalue, 'args.dflvalue');
+    mod_assertplus.func(callback, 'callback');
+
+    pkgname = args.pkgname;
+    target = args.target;
+    dflvalue = args.dflvalue;
+    forkexecArgs = {
+        'cwd': args.root,
+        'includeStderr': true,
+        'maxBuffer': 1024 * 1024
+    };
+
+    /*
+     * If the user provided us a string, we assume that's a local path and we
+     * use "npm link" to create a symlink for it into node_modules.  If not, we
+     * assume they want to use the stock target, and we'll "npm install" that.
+     */
+    if (target === null) {
+        forkexecArgs.argv = [ args.npm, 'install', dflvalue ];
+        configureExec(cfgctx, forkexecArgs, callback);
+        return;
+    }
+
+    /*
+     * In the local case, check the package name first.  We only bother with
+     * this because it's very possible people will be using a "moray" server
+     * whose package name is still "moray" instead of "moray-server", and that
+     * would lead to surprising, hard-to-debug behavior.
+     */
+    pkgjson = mod_path.join(target, 'package.json');
+    mod_fs.readFile(pkgjson, function (err, contents) {
+        var pkginfo;
+
+        if (err) {
+            callback(new VError(err, 'read "%s"', pkgjson));
+            return;
+        }
+
+        try {
+            pkginfo = JSON.parse(contents);
+        } catch (ex) {
+            callback(new VError(ex, 'parse "%s"', pkgjson));
+            return;
+        }
+
+        if (pkginfo['name'] != pkgname) {
+            callback(new VError('expected package name "%s" in "%s"',
+                pkgname, pkgjson));
+            return;
+        }
+
+        forkexecArgs.argv = [ args.npm, 'link', target ];
+        configureExec(cfgctx, forkexecArgs, callback);
+    });
+}
+
+/*
+ * General-purpose function (i.e., not a pipeline function) for executing a
+ * shell command as part of a configure() operation.  This essentially checks
+ * cfgctx.c_dryrun and may execute the command using forkexec, or may skip it.
+ */
+function configureExec(cfgctx, args, callback)
+{
+    if (cfgctx.c_dryrun) {
+        console.log('(cd "%s" && %s)', args.cwd, args.argv.join(' '));
+        setImmediate(callback);
+    } else {
+        console.error('running: %s (in %s)', args.argv.join(' '), args.cwd);
+        mod_forkexec.forkExecWait(args, callback);
+    }
+}
+
+/*
+ * Write out the environment variable that users can source to run individual
+ * tests.  In dry-run mode, this prints out a bash snippet that would do the
+ * exact same thing.
+ */
+function configureWriteEnv(cfgctx, callback)
+{
+    var stream, contents;
+
+    mod_assertplus.string(cfgctx.c_env_path, 'cfgctx.c_env_path');
+    contents = [
+        '#',
+        '# This file was auto-generated by the "configure" tool in the ',
+        '# moray-test-suite repository.',
+        '#',
+        '',
+        ''
+    ].join('\n');
+    stream = cfgctx.c_env.readable();
+    stream.on('data', function (c) { contents += c.toString('utf8'); });
+    stream.on('end', function () {
+        configureWriteFile(cfgctx, {
+            'filename': cfgctx.c_env_path,
+            'contents': contents
+        }, callback);
+    });
+}
+
+/*
+ * This function should probably be provided elsewhere.
+ */
+function readJsonFile(filename, callback)
+{
+    mod_fs.readFile(filename, function (err, contents) {
+        var c;
+
+        if (err) {
+            callback(new VError(err, 'read "%s"', filename));
+            return;
+        }
+
+        try {
+            c = JSON.parse(contents);
+        } catch (ex) {
+            callback(new VError(err, 'parse "%s"', filename));
+            return;
+        }
+
+        callback(null, c);
+    });
+}
+
+
+/*
+ * Configuration validation schemas.
+ */
+
+var tsSchemaStringNonEmpty = {
+    'type': 'string',
+    'minLength': 1
+};
+
+var tsSchemaPathname = tsSchemaStringNonEmpty;
+
+var tsConfigSchema = {
+    'type': 'object',
+    'additionalProperties': false,
+    'properties': {
+        'client': {
+            'type': 'object',
+            'additionalProperties': false,
+            'properties': {
+                'path': tsSchemaPathname
+            }
+        },
+
+        'server': {
+            'type': 'object',
+            'additionalProperties': false,
+            'required': true,
+            'properties': {
+                'configBase': tsSchemaPathname,
+                'path': tsSchemaPathname,
+                'start': tsSchemaStringNonEmpty,
+                'node': tsSchemaPathname,
+                'remote': tsSchemaStringNonEmpty
+            }
+        }
+    }
+};
+
+main();
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
new file mode 100644
index 0000000..5cf2ebb
--- /dev/null
+++ b/tools/jsl.node.conf
@@ -0,0 +1,142 @@
+#
+# Configuration File for JavaScript Lint 
+#
+# This configuration file can be used to lint a collection of scripts, or to enable
+# or disable warnings for scripts that are linted via the command line.
+#
+
+### Warnings
+# Enable or disable warnings based on requirements.
+# Use "+WarningName" to display or "-WarningName" to suppress.
+#
++ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
++ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
++ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
++anon_no_return_value         # anonymous function does not always return value
++assign_to_function_call      # assignment to a function call
+-block_without_braces         # block statement without curly braces
++comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
++comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
++default_not_at_end           # the default case is not at the end of the switch statement
++dup_option_explicit          # duplicate "option explicit" control comment
++duplicate_case_in_switch     # duplicate case in switch statement
++duplicate_formal             # duplicate formal argument {name}
++empty_statement              # empty statement or extra semicolon
++identifier_hides_another     # identifer {name} hides an identifier in a parent scope
+-inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
++incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
++invalid_fallthru             # unexpected "fallthru" control comment
++invalid_pass                 # unexpected "pass" control comment
++jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
++leading_decimal_point        # leading decimal point may indicate a number or an object member
++legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
++meaningless_block            # meaningless block; curly braces have no impact
++mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
++misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
++missing_break                # missing break statement
++missing_break_for_last_case  # missing break statement for last case in switch
++missing_default_case         # missing default case in switch statement
++missing_option_explicit      # the "option explicit" control comment is missing
++missing_semicolon            # missing semicolon
++missing_semicolon_for_lambda # missing semicolon for lambda assignment
++multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
++nested_comment               # nested comment
++no_return_value              # function {name} does not always return a value
++octal_number                 # leading zeros make an octal number
++parseint_missing_radix       # parseInt missing radix parameter
++partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
++redeclared_var               # redeclaration of {name}
++trailing_comma_in_array      # extra comma is not recommended in array initializers
++trailing_decimal_point       # trailing decimal point may indicate a number or an object member
++undeclared_identifier        # undeclared identifier: {name}
++unreachable_code             # unreachable code
+-unreferenced_argument        # argument declared but never referenced: {name}
+-unreferenced_function        # function is declared but never referenced: {name}
++unreferenced_variable        # variable is declared but never referenced: {name}
++unsupported_version          # JavaScript {version} is not supported
++use_of_label                 # use of label
++useless_assign               # useless assignment
++useless_comparison           # useless comparison; comparing identical expressions
+-useless_quotes               # the quotation marks are unnecessary
++useless_void                 # use of the void type may be unnecessary (void is always undefined)
++var_hides_arg                # variable {name} hides argument
++want_assign_or_call          # expected an assignment or function call
++with_statement               # with statement hides undeclared variables; use temporary variable instead
+
+
+### Output format
+# Customize the format of the error message.
+#    __FILE__ indicates current file path
+#    __FILENAME__ indicates current file name
+#    __LINE__ indicates current line
+#    __COL__ indicates current column
+#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
+#    __ERROR_NAME__ indicates error name (used in configuration file)
+#    __ERROR_PREFIX__ indicates error prefix
+#    __ERROR_MSG__ indicates error message
+#
+# For machine-friendly output, the output format can be prefixed with
+# "encode:". If specified, all items will be encoded with C-slashes.
+#
+# Visual Studio syntax (default):
++output-format __FILE__(__LINE__): __ERROR__
+# Alternative syntax:
+#+output-format __FILE__:__LINE__: __ERROR__
+
+
+### Context
+# Show the in-line position of the error.
+# Use "+context" to display or "-context" to suppress.
+#
++context
+
+
+### Control Comments
+# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
+# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
+# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
+# although legacy control comments are enabled by default for backward compatibility.
+#
+-legacy_control_comments
+
+
+### Defining identifiers
+# By default, "option explicit" is enabled on a per-file basis.
+# To enable this for all files, use "+always_use_option_explicit"
+-always_use_option_explicit
+
+# Define certain identifiers of which the lint is not aware.
+# (Use this in conjunction with the "undeclared identifier" warning.)
+#
+# Common uses for webpages might be:
++define __dirname
++define clearInterval
++define clearTimeout
++define console
++define exports
++define global
++define module
++define process
++define require
++define setImmediate
++define clearImmediate
++define setInterval
++define setTimeout
++define Buffer
++define JSON
++define Math
++define __dirname
++define __filename
+
+### JavaScript Version
+# To change the default JavaScript version:
+#+default-type text/javascript;version=1.5
+#+default-type text/javascript;e4x=1
+
+### Files
+# Specify which files to lint
+# Use "+recurse" to enable recursion (disabled by default).
+# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
+# or "+process Folder\Path\*.htm".
+#
+
diff --git a/tools/jsstyle.conf b/tools/jsstyle.conf
new file mode 100644
index 0000000..a994bd8
--- /dev/null
+++ b/tools/jsstyle.conf
@@ -0,0 +1,14 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+indent=4
+doxygen
+unparenthesized-return=0
+blank-after-start-comment=0
\ No newline at end of file
-- 
2.21.0

