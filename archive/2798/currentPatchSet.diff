From d9852b72390ead6e0d7a814befd23cb1632d79da Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Wed, 25 Oct 2017 15:49:22 -0400
Subject: [PATCH] joyent/node-vmadm#2 want support for `vmadm events` Reviewed
 by: Josh Wilsdon <josh@wilsdon.ca> Approved by: Josh Wilsdon
 <josh@wilsdon.ca>

---
 README.md    |  24 +++++
 lib/index.js | 248 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 package.json |   3 +-
 3 files changed, 270 insertions(+), 5 deletions(-)

diff --git a/README.md b/README.md
index 746ef79..d547011 100644
--- a/README.md
+++ b/README.md
@@ -243,6 +243,30 @@ Options:
 - `req_id`
 - `uuid`
 
+### events(opts, handler, callback)
+
+Calls `vmadm events -rj [uuid]`.  The callback is invoked as `callback(err,
+obj)` when the event stream is ready, or has failed to start.  `obj` is an
+object described below.  The handler is invoked as `handler(ev)` per every
+event seen where `ev` is an object describing the event
+seen.
+
+Options:
+
+- `log`
+- `req_id`
+- `uuid`, optional VM UUID to watch, if unset all VMs are watched
+- `name`, optional string identifier used for debug purposes
+
+Callback:
+
+- `err` set only if an error is encountered where the event stream couldn't be
+  created
+- `obj` object
+  - `obj.ev` an object that represents the "ready" event seen from `vmadm
+    events` with the `-r` argument.
+  - `obj.stop` a function to call to stop the event stream.
+
 ## Development
 
 Describe steps necessary for development here.
diff --git a/lib/index.js b/lib/index.js
index 8a8b59b..5c7ab5b 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,15 +5,17 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var cp = require('child_process');
 var fs = require('fs');
+var LineStream = require('lstream');
 var path = require('path');
 var spawn = cp.spawn;
-
+var stream = require('stream');
+var util = require('util');
 
 var VMADM_PATH = '/usr/sbin/vmadm';
 
@@ -21,6 +23,14 @@ var STDERR_TRUNCATE_LENGTH = 10000;
 
 function vmadm() {}
 
+function copyEnv() {
+    var ret = {};
+    Object.keys(process.env).forEach(function processEnvForEach(key) {
+        ret[key] = process.env[key];
+    });
+    return ret;
+}
+
 /*
  * Execute vmadm
  *
@@ -50,9 +60,9 @@ function execVmadm(opts, callback) {
     var stderrLines = [];
     var stdoutBuffer = '';
 
-    execOpts.env = process.env;
+    execOpts.env = copyEnv();
     if (opts.req_id) {
-        opts.log.info('setting req_id to %s', opts.req_id);
+        opts.log.info('setting req_id to "%s"', opts.req_id);
         execOpts.env.REQ_ID = opts.req_id;
     }
     execOpts.env.VMADM_DEBUG_LEVEL = 'debug';
@@ -1154,4 +1164,234 @@ vmadm.stop = function vmStop(opts, callback) {
     }, callback);
 };
 
+/*
+ * Wrapper around `vmadm events -jr [uuid]`
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID of VM to watch, if unset all VMs are watched
+ *      - log {Logger object}
+ *      - name {String} Identifier string for debugging purposes, this will be
+ *      used to construct the user-agent sent to vminfod
+ * @param handler {Function} `function (ev)`
+ *      - called when an event is seen
+ * @param callback {Function} `function (err, obj)`
+ *      - called when the stream is ready, or failed to start
+ *      - err {Error} set if an error occured that means the stream cannot be
+ *      created
+ *      - stop {Function} function to stop the event stream
+ */
+vmadm.events = function vmEvents(opts, handler, callback) {
+    var vs;
+    var log;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.uuid, 'opts.uuid');
+    assert.optionalString(opts.name, 'opts.name');
+
+    log = opts.log;
+    vs = new VmadmCLIEventStream(opts);
+
+    vs.once('ready', function vmadmStreamReady(err, ready_ev) {
+        log.debug({err: err}, 'vmadm event stream ready event');
+        var obj = {
+            ev: ready_ev,
+            stop: vmadmEventsStop
+        };
+        callback(err, obj);
+    });
+
+    vs.on('readable', function vmadmStreamReadable() {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            processVmadmEvent(ev);
+        }
+    });
+
+    function processVmadmEvent(ev) {
+        log.trace({ev: ev}, 'vmadm event');
+        handler(ev);
+    }
+
+    function vmadmEventsStop() {
+        log.debug('vmadm events stop called');
+        vs.stop();
+    }
+};
+
+function VmadmCLIEventStream(opts) {
+    var self = this;
+
+    var args = ['events', '-rj'];
+    var spawnOpts = {};
+
+    stream.Transform.call(self, {objectMode: true});
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.req_id, 'opts.req_id');
+    assert.optionalString(opts.name, 'opts.name');
+    assert.optionalString(opts.uuid, 'opts.uuid');
+
+    if (opts.uuid) {
+        args.push(opts.uuid);
+    }
+
+    self.stopped = false;
+    self.log = opts.log;
+
+    self.log.info({args: args}, 'calling %s %s',
+        VMADM_PATH, args.join(' '));
+
+    spawnOpts.env = copyEnv();
+    if (opts.req_id) {
+        self.log.info('setting req_id to "%s"', opts.req_id);
+        spawnOpts.env.REQ_ID = opts.req_id;
+    }
+    if (opts.name) {
+        self.log.info('setting name to "%s"', opts.name);
+        spawnOpts.env.VMADM_IDENT = opts.name;
+    }
+    spawnOpts.env.VMADM_DEBUG_LEVEL = 'fatal';
+
+    // fork vmadm
+    self.child = cp.spawn(VMADM_PATH, args, spawnOpts);
+    self.child.stdout.setEncoding('utf8');
+    self.child.stderr.setEncoding('utf8');
+
+    // Any child error will be logged and re-emitted
+    self.child.on('error', function vmadmProcessError(e) {
+        self.log.error({err: e}, 'child process error');
+        self.emit('error', e);
+    });
+
+    // The child dying is either an info or error message depending
+    // on if it was intentional (ie. .stop() was called)
+    self.child.on('close', function vmadmProcessClose(code, signal) {
+        if (self.stopped) {
+            self.log.info({code: code, signal: signal},
+                'vmadm events stopped');
+            return;
+        }
+
+        var e = new Error('child exited');
+        self.log.error({err: e, code: code, signal: signal},
+            'vmadm events child process closed');
+        self.emit('error', e);
+    });
+
+    // stdin is not needed
+    self.child.stdin.end();
+
+    // Parse stdout line by line by piping to ourselves
+    self.child.stdout.pipe(new LineStream()).pipe(self);
+
+    /*
+     * Parse stderr line by line - any stderr produced is a fatal error
+     * unexpected by the child process, so we log the error and abort the child
+     * process to generate a core dump.
+     *
+     * The only exception to this rule is if "events" has not been implemented
+     * yet by `vmadm`.
+     */
+    var stderrls = new LineStream();
+    self.child.stderr.pipe(stderrls).on('readable',
+        function vmadmStderrReadable() {
+
+        var lines = [];
+        var line;
+        while ((line = stderrls.read()) !== null) {
+            lines.push(line);
+        }
+
+        // If we have already been stopped don't abort the process
+        if (self.stopped) {
+            return;
+        }
+
+        self.log.error({stderr: lines.join('\n')}, 'stderr produced');
+
+        /*
+         * Check if the `vmadm events` command is unimplemented.  If so, emit
+         * an error object through the "ready" event.
+         */
+        var invalidCmd = lines.some(function stderrFindInvalidCmd(_line) {
+            return (_line === 'Invalid command: "events".');
+        });
+        if (invalidCmd) {
+            self.emit('ready', new Error('`vmadm events` not implemented'));
+            self.stop();
+            return;
+        }
+
+        // If we are here, we didn't expect this stderr so abort the process.
+        self._abort();
+    });
+}
+util.inherits(VmadmCLIEventStream, stream.Transform);
+
+/*
+ * The transform method to process vmadm stdout line-by-line
+ */
+VmadmCLIEventStream.prototype._transform =
+    function _transform(chunk, encoding, cb) {
+
+    var self = this;
+
+    var line = chunk.toString('utf8');
+    var ev;
+    try {
+        ev = JSON.parse(line);
+        assert.object(ev, 'ev');
+        assert.string(ev.type, 'ev.type');
+        assert.string(ev.date, 'ev.date');
+
+        ev.date = new Date(ev.date);
+        assert.ok(isFinite(ev.date), 'invalid ev.date');
+    } catch (e) {
+        /*
+         * Any JSON parse failure is a fatal error where we abort the child
+         * process to generate a core dump
+         */
+        self.log.error({err: e, line: line},
+            'failed to parse output line');
+        self._abort();
+        return;
+    }
+
+    switch (ev.type) {
+    case 'ready':
+        self.emit('ready', null, ev);
+        break;
+    default:
+        self.push(ev);
+        break;
+    }
+    cb();
+};
+
+/*
+ * Cleanly stop the stream by killing the child process with a SIGTERM
+ */
+VmadmCLIEventStream.prototype.stop = function stop() {
+    var self = this;
+
+    self.stopped = true;
+    self.child.kill();
+};
+
+/*
+ * Stop the stream and have it dump core.
+ */
+VmadmCLIEventStream.prototype._abort = function _abort() {
+    var self = this;
+
+    self.stopped = true;
+    self.log.error({child: self.child.pid},
+        '_abort() called - sending SIGABRT');
+    self.child.kill('SIGABRT');
+    var e = new Error('vmadm aborted');
+    self.emit('error', e);
+};
+
 module.exports = vmadm;
diff --git a/package.json b/package.json
index 1f19ca1..fec47ec 100644
--- a/package.json
+++ b/package.json
@@ -7,7 +7,8 @@
     "test": "echo \"Error: no test specified\" && exit 1"
   },
   "dependencies": {
-    "assert-plus": "0.1.5"
+    "assert-plus": "0.1.5",
+    "lstream": "0.0.4"
   },
   "author": "Joyent (joyent.com)",
   "directories": {
-- 
2.21.0

