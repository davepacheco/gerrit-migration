commit a004d2a41fbfb4c58b22a4eb232cc4fab065243d (refs/changes/58/3358/4)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-02-21T23:46:34+00:00 (1 year, 8 months ago)
    
    TRITON-90 Update fwadm(1M) to use fwrule@1.4.1
    Reviewed by: Jason King <jason.king@joyent.com>
    Approved by: Jordan Hendricks <jordan.hendricks@joyent.com>

diff --git a/src/fw/node_modules/fwrule/index.js b/src/fw/node_modules/fwrule/index.js
index f42f6a92..fa88a666 100644
--- a/src/fw/node_modules/fwrule/index.js
+++ b/src/fw/node_modules/fwrule/index.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2017, Joyent, Inc. All rights reserved.
  *
  *
  * firewall rule parser: entry point
@@ -93,14 +93,6 @@ parser.yy.validateIPv4address = function validateIPv4address(ip) {
 };
 
 
-parser.yy.validateIPv4subnet = function validateIPv4subnet(subnet) {
-    if (!validators.validateIPv4subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
 parser.yy.validateIPv6address = function validateIPv6address(ip) {
     if (!mod_net.isIPv6(ip)) {
         throw new validators.InvalidParamError('rule',
@@ -109,11 +101,8 @@ parser.yy.validateIPv6address = function validateIPv6address(ip) {
 };
 
 
-parser.yy.validateIPv6subnet = function validateIPv6subnet(subnet) {
-    if (!validators.validateIPv6subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
+parser.yy.validateSubnet = function validateSubnet(input) {
+    validators.validateSubnet('rule', input, parser.yy.enforceSubnetMask);
 };
 
 
@@ -231,6 +220,9 @@ function parse(input, opts) {
     // If a version hasn't been specified, use most recent
     parser.yy.maxVersion = opts.maxVersion || CURR_VERSION;
 
+    // Whether we should check if CIDRs have bits set past mask
+    parser.yy.enforceSubnetMask = !!opts.enforceSubnetMask;
+
     return parser.parse(input);
 }
 
diff --git a/src/fw/node_modules/fwrule/parser.js b/src/fw/node_modules/fwrule/parser.js
index f50b0abc..d9c6e5ac 100644
--- a/src/fw/node_modules/fwrule/parser.js
+++ b/src/fw/node_modules/fwrule/parser.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2017, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: firewall rule parser
@@ -55,7 +55,7 @@ break;
 case 18: yy.validateIPv4address($$[$0]);
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
-case 19: yy.validateIPv4subnet($$[$0-1] + $$[$0]);
+case 19: yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
 case 20: yy.validateOKVersion(3, 'IPv6');
@@ -63,7 +63,7 @@ case 20: yy.validateOKVersion(3, 'IPv6');
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
 case 21: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($$[$0-1] + $$[$0]);
+          yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
 case 22: this.$ = [ ['vm', $$[$0]] ]; 
@@ -93,7 +93,8 @@ case 33: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] }
 break;
 case 34: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
 break;
-case 35: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
+case 35: yy.validateOKVersion(3, 'IPv6');
+          this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] }; 
 break;
 case 36: this.$ = $$[$0-1]; 
 break;
diff --git a/src/fw/node_modules/fwrule/validators.js b/src/fw/node_modules/fwrule/validators.js
index 651df743..4238cc9c 100644
--- a/src/fw/node_modules/fwrule/validators.js
+++ b/src/fw/node_modules/fwrule/validators.js
@@ -30,6 +30,7 @@
 
 'use strict';
 
+var ipaddr = require('ip6addr');
 var net = require('net');
 var util = require('util');
 var VError = require('verror').VError;
@@ -92,24 +93,6 @@ function validateIPv4subnet(subnet) {
 }
 
 
-/**
- * Returns true if subnet is a valid IPv6 CIDR range
- */
-function validateIPv6subnet(subnet) {
-    var parts = subnet.split('/');
-    var plen = Number(parts[1]);
-    if (!net.isIPv6(parts[0])) {
-        return false;
-    }
-
-    if (!plen || (plen < 1) || (plen > 128)) {
-        return false;
-    }
-
-    return true;
-}
-
-
 /**
  * Returns true if port is a valid port number
  */
@@ -201,6 +184,35 @@ function validateString(name, str) {
 }
 
 
+/**
+ * Throws an InvalidParamError if the subnet is invalid
+ */
+function validateSubnet(name, input, enforceSubnetMask) {
+    var parts = input.split('/');
+    var addr, plen, subnet;
+
+    try {
+        addr = ipaddr.parse(parts[0]);
+        plen = Number(parts[1]);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad address component)', input);
+    }
+
+    try {
+        subnet = ipaddr.createCIDR(addr, plen);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad prefix length)', input);
+    }
+
+    if (enforceSubnetMask && subnet.address().compare(addr) !== 0) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bits set to right of mask)', input);
+    }
+}
+
+
 /**
  * Returns true if uuid is a valid UUID
  */
@@ -215,7 +227,7 @@ module.exports = {
     validateAction: validateAction,
     validateIPv4address: validateIPv4address,
     validateIPv4subnet: validateIPv4subnet,
-    validateIPv6subnet: validateIPv6subnet,
+    validateSubnet: validateSubnet,
     validatePort: validatePort,
     validatePortOrAll: validatePortOrAll,
     validateProtocol: validateProtocol,
diff --git a/src/fw/node_modules/ip6addr.js b/src/fw/node_modules/ip6addr.js
new file mode 100644
index 00000000..a63808c2
--- /dev/null
+++ b/src/fw/node_modules/ip6addr.js
@@ -0,0 +1,716 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var util = require('util');
+
+
+///--- Helpers
+
+function ParseError(input, message, index) {
+  if (Error.captureStackTrace)
+    Error.captureStackTrace(this, ParseError);
+
+  this.input = input;
+  this.message = message;
+  if (index !== undefined) {
+    this.message += ' at index ' + index;
+  }
+}
+util.inherits(ParseError, Error);
+
+function modulo(a, n) {
+  return (n + (a % n)) % n;
+}
+
+function _arrayToOctetString(input) {
+  var out;
+  out = (input[0] >> 8) + '.' + (input[0] & 0xff) + '.';
+  out += (input[1] >> 8) + '.' + (input[1] & 0xff);
+  return out;
+}
+
+function _isAddr(addr) {
+  if (typeof (addr) === 'object') {
+    /* It must resemble an Addr object */
+    if (Array.isArray(addr._fields) && typeof (addr._attrs) === 'object') {
+      return true;
+    }
+  }
+  return false;
+}
+
+function _toAddr(input) {
+  if (typeof (input) === 'string') {
+    return ip6addrParse(input);
+  } else if (_isAddr(input)) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: Addr or parsable string expected');
+  }
+}
+
+function _arrayToHex(input, zeroElide, zeroPad) {
+  var i;
+  var elStart = null;
+  var elLen = 0;
+  if (zeroElide) {
+    /* find longest run of zeroes to potentially elide */
+    var start = null;
+    var len = null;
+    for (i = 0; i < input.length; i++) {
+      if (input[i] === 0) {
+        if (start === null) {
+          start = i;
+          len = 1;
+        } else {
+          len++;
+        }
+      } else if (start !== null) {
+        if (len > elLen) {
+          elStart = start;
+          elLen = len;
+        }
+        start = null;
+      }
+    }
+    /* capturing last potential zero */
+    if (start !== null && len > elLen) {
+      elStart = start;
+      elLen = len;
+    }
+  }
+
+  var output = [];
+  var num;
+  for (i = 0; i < input.length; i++) {
+    if (elStart !== null) {
+      if (i === elStart) {
+        if (elLen === 8) {
+          /* all-zeroes is just '::' */
+          return ['::'];
+        } else if (elStart === 0 || elStart + elLen === input.length) {
+          /*
+           * For elided zeroes at the beginning/end of the address, an extra
+           * ':' is needed during the join step.
+           */
+          output.push(':');
+        } else {
+          output.push('');
+        }
+      }
+      if (i >= elStart && i < elStart + elLen) {
+        continue;
+      }
+    }
+    num = input[i].toString(16);
+    if (zeroPad && num.length != 4) {
+      num = '0000'.slice(num.length) + num;
+    }
+    output.push(num);
+  }
+  return output;
+}
+
+function _ipv4Mapped(input) {
+  var comp = [0, 0, 0, 0, 0, 0xffff];
+  var i;
+  for (i = 0; i < 6; i++) {
+    if (input[i] != comp[i])
+      return false;
+  }
+  return true;
+}
+
+function _prefixToAddr(len) {
+  assert.number(len);
+  len = len | 0;
+  assert.ok(len <= 128);
+  assert.ok(len >= 0);
+
+  var output = new Addr();
+  var i;
+  for (i = 0; len > 16; i++, len -= 16) {
+    output._fields[i] = 0xffff;
+  }
+  if (len > 0) {
+    output._fields[i] = 0xffff - ((1 << (16 - len)) - 1);
+  }
+  return output;
+}
+
+function _toCIDR(input) {
+  if (typeof (input) === 'string') {
+    return new CIDR(input);
+  } else if (input instanceof CIDR) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: CIDR or parsable string expected');
+  }
+}
+
+var strDefaults = {
+  format: 'auto', // Control format of printed address
+  zeroElide: true, // Elide longest run of zeros
+  zeroPad: false // Pad with zeros when a group would print as < 4 chars
+};
+
+function getStrOpt(opts, name) {
+  if (opts && opts.hasOwnProperty(name)) {
+    return opts[name];
+  } else {
+    return strDefaults[name];
+  }
+}
+
+///--- Public Classes
+
+/**
+ * IPv6/IPv4 address representation.
+ *
+ * It should not be instantiated directly by library consumers.
+ */
+function Addr() {
+  this._fields = [0, 0, 0, 0, 0, 0, 0, 0];
+  this._attrs = {};
+}
+
+Addr.prototype.kind = function getKind() {
+  if (v4subnet.contains(this)) {
+    return 'ipv4';
+  } else {
+    return 'ipv6';
+  }
+};
+
+Addr.prototype.toString = function toString(opts) {
+  assert.optionalObject(opts, 'opts');
+  var format = getStrOpt(opts, 'format');
+  var zeroElide = getStrOpt(opts, 'zeroElide');
+  var zeroPad = getStrOpt(opts, 'zeroPad');
+
+  assert.string(format, 'opts.format');
+  assert.bool(zeroElide, 'opts.zeroElide');
+  assert.bool(zeroPad, 'opts.zeroPad');
+
+  // Try to print the address the way it was originally formatted
+  if (format === 'auto') {
+    if (this._attrs.ipv4Bare) {
+      format = 'v4';
+    } else if (this._attrs.ipv4Mapped) {
+      format = 'v4-mapped';
+    } else {
+      format = 'v6';
+    }
+  }
+
+  switch (format) {
+  // Print in dotted-quad notation (but only if truly IPv4)
+  case 'v4':
+    if (!v4subnet.contains(this)) {
+        throw new Error('cannot print non-v4 address in dotted quad notation');
+    }
+    return _arrayToOctetString(this._fields.slice(6));
+
+  // Print as an IPv4-mapped IPv6 address
+  case 'v4-mapped':
+    if (!v4subnet.contains(this)) {
+        throw new Error('cannot print non-v4 address as a v4-mapped address');
+    }
+    var output = _arrayToHex(this._fields.slice(0, 6), zeroElide, zeroPad);
+    output.push(_arrayToOctetString(this._fields.slice(6)));
+    return output.join(':');
+
+  // Print as an IPv6 address
+  case 'v6':
+    return _arrayToHex(this._fields, zeroElide, zeroPad).join(':');
+
+  // Unrecognized formatting method
+  default:
+    throw new Error('unrecognized format method "' + format + '"');
+  }
+};
+
+Addr.prototype.toBuffer = function toBuffer(buf) {
+  if (buf !== undefined) {
+    if (!Buffer.isBuffer(buf)) {
+      throw new Error('optional arg must be Buffer');
+    }
+  } else {
+    buf = new Buffer(16);
+  }
+  var i;
+  for (i = 0; i < 8; i++) {
+    buf.writeUInt16BE(this._fields[i], i*2);
+  }
+  return buf;
+};
+
+Addr.prototype.toLong = function toLong() {
+  if (!v4subnet.contains(this)) {
+    throw new Error('only possible for ipv4-mapped addresses');
+  }
+  return ((this._fields[6] << 16) >>> 0) + this._fields[7];
+};
+
+Addr.prototype.clone = function cloneAddr() {
+  var out = new Addr();
+  out._fields = this._fields.slice();
+  for (var k in this._attrs) {
+      out._attrs[k] = this._attrs[k];
+  }
+  return out;
+};
+
+Addr.prototype.offset = function offset(num) {
+  if (num < -4294967295 || num > 4294967295) {
+    throw new Error('offsets should be between -4294967295 and 4294967295');
+  }
+  var out = this.clone();
+  var i, moved;
+  for (i = 7; i >= 0; i--) {
+    moved = out._fields[i] + num;
+    if (moved > 65535) {
+      num = moved >>> 16;
+      moved = moved & 0xffff;
+    } else if (moved < 0) {
+      num = Math.floor(moved / (1 << 16));
+      moved = modulo(moved, 1 << 16);
+    } else {
+      num = 0;
+    }
+    out._fields[i] = moved;
+
+    /* Prevent wrap-around for both ipv6 and ipv4-mapped addresses */
+    if (num !== 0) {
+      if ((i === 0) || (i === 6 && this._attrs.ipv4Mapped)) {
+        return null;
+      }
+    } else {
+      break;
+    }
+  }
+  return out;
+};
+
+Addr.prototype.and = function addrAnd(input) {
+  input = _toAddr(input);
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = output._fields[i] & input._fields[i];
+  }
+  return output;
+};
+
+Addr.prototype.or = function addrOr(input) {
+  input = _toAddr(input);
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = output._fields[i] | input._fields[i];
+  }
+  return output;
+};
+
+Addr.prototype.not = function addrNot() {
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = (~ output._fields[i]) & 0xffff;
+  }
+  return output;
+};
+
+Addr.prototype.compare = function compareMember(addr) {
+  return ip6addrCompare(this, addr);
+};
+
+/**
+ * CIDR Block
+ * @param addr CIDR network address
+ * @param prefixLen Length of network prefix
+ *
+ * The addr parameter can be an Addr object or a parseable string.
+ * If prefixLen is omitted, then addr must contain a parseable string in the
+ * form '<address>/<prefix>'.
+ */
+function CIDR(addr, prefixLen) {
+  if (prefixLen === undefined) {
+    /* OK to pass pass string of "<addr>/<prefix>" */
+    assert.string(addr);
+    var fields = addr.match(/^([a-fA-F0-9:.]+)\/([0-9]+)$/);
+    if (fields === null) {
+      throw new Error('Invalid argument: <addr>/<prefix> expected');
+    }
+    addr = fields[1];
+    prefixLen = parseInt(fields[2], 10);
+  }
+  assert.number(prefixLen);
+  prefixLen = prefixLen | 0;
+  addr = _toAddr(addr);
+
+  /* Expand prefix to ipv6 length of bare ipv4 address provided */
+  if (addr._attrs.ipv4Bare) {
+    prefixLen += 96;
+  }
+  if (prefixLen < 0 || prefixLen > 128) {
+    throw new Error('Invalid prefix length');
+  }
+  this._prefix = prefixLen;
+  this._mask = _prefixToAddr(prefixLen);
+  this._addr = addr.and(this._mask);
+}
+
+CIDR.prototype.contains = function cidrContains(input) {
+  input = _toAddr(input);
+  return (this._addr.compare(input.and(this._mask)) === 0);
+};
+
+CIDR.prototype.first = function cidrFirst(input) {
+  if (this._prefix >= 127) {
+    /* Support single-address and point-to-point networks */
+    return this._addr;
+  } else {
+    return this._addr.offset(1);
+  }
+};
+
+CIDR.prototype.last = function cidrLast(input) {
+  var ending = this._addr.or(this._mask.not());
+  if (this._prefix >= 127) {
+    /* Support single-address and point-to-point networks */
+    return ending;
+  } else {
+    if (this._addr._attrs.ipv4Mapped) {
+      /* don't include the broadcast for ipv4 */
+      return ending.offset(-1);
+    } else {
+      return ending;
+    }
+  }
+};
+
+CIDR.prototype.broadcast = function getBroadcast() {
+  if (!v4subnet.contains(this._addr)) {
+    throw new Error('Only IPv4 networks have broadcast addresses');
+  }
+  return this._addr.or(this._mask.not());
+};
+
+CIDR.prototype.compare = function compareCIDR(cidr) {
+  return ip6cidrCompare(this, cidr);
+};
+
+CIDR.prototype.prefixLength = function getPrefixLength(format) {
+  assert.optionalString(format, 'format');
+  if (format === undefined || format === 'auto') {
+    format = this._addr._attrs.ipv4Bare ? 'v4' : 'v6';
+  }
+
+  switch (format) {
+  case 'v4':
+    if (!v4subnet.contains(this._addr)) {
+        throw new Error('cannot return v4 prefix length for non-v4 address');
+    }
+    return this._prefix - 96;
+  case 'v6':
+    return this._prefix;
+  default:
+    throw new Error('unrecognized format method "' + format + '"');
+  }
+};
+
+CIDR.prototype.address = function getAddressComponent() {
+  return this._addr;
+};
+
+CIDR.prototype.toString = function cidrString(opts) {
+  assert.optionalObject(opts, 'opts');
+
+  var format = getStrOpt(opts, 'format');
+  if (format === 'v4-mapped') {
+    format = 'v6';
+  }
+
+  return this._addr.toString(opts) + '/' + this.prefixLength(format);
+};
+
+var v4subnet = new CIDR('::ffff:0:0', 96);
+
+function ip6cidrCompare(a, b) {
+  a = _toCIDR(a);
+  b = _toCIDR(b);
+
+  /*
+   * We compare first on the address component, and then on the prefix length,
+   * such that the network with the smaller prefix length (the larger subnet)
+   * is greater than the network with the smaller prefix (the smaller subnet).
+   * This is the same ordering used in Postgres.
+   */
+  var cmp = ip6addrCompare(a._addr, b._addr);
+  return cmp === 0 ? b._prefix - a._prefix : cmp;
+}
+
+/**
+ * Range of addresses.
+ * @param begin Beginning address of the range
+ * @param end Ending address of the range
+ *
+ * Parameters can be Addr objects or parsable address strings.
+ */
+function AddrRange(begin, end) {
+  begin = _toAddr(begin);
+  end = _toAddr(end);
+
+  if (begin.compare(end) > 0) {
+    throw new Error('begin address must be <= end address');
+  }
+
+  this._begin = begin;
+  this._end = end;
+}
+
+AddrRange.prototype.contains = function addrRangeContains(input) {
+  input = _toAddr(input);
+  return (this._begin.compare(input) <= 0 && this._end.compare(input) >= 0);
+};
+
+AddrRange.prototype.first = function addrRangeFirst() {
+  return this._begin;
+};
+
+AddrRange.prototype.last = function addrRangeLast() {
+  return this._end;
+};
+
+
+///--- Public Functions
+
+function ip6addrParse(input) {
+  if (typeof (input) === 'string') {
+    return parseString(input);
+  } else if (typeof (input) === 'number') {
+    return parseLong(input);
+  } else if (typeof (input) === 'object' && _isAddr(input)) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: only string|number allowed');
+  }
+}
+
+function parseString(input) {
+  assert.string(input);
+  input = input.toLowerCase();
+  var result = new Addr();
+
+  var ip6Fields = []; // hold unparsed hex fields
+  var ip4Fields = []; // hold unparsed decimal fields
+  var expIndex = null; // field index of '::' delimiter
+  var value = '';  // accumulate unparsed hex/dec field
+  var i, c;
+
+  /*
+   * No valid ipv6 is longer than 39 characters.
+   * An extra character of leeway is there to tolerate some :: funny business.
+   */
+  if (input.length > 40) {
+    throw new ParseError(input, 'Input too long');
+  }
+
+  for (i = 0; i < input.length; i++) {
+    c = input[i];
+    if (c === ':') {
+      if ((i+1) < input.length && input[i+1] === ':') {
+        /*
+         * Variable length '::' delimiter.
+         * Multiples would be ambiguous
+         */
+        if (expIndex !== null) {
+          throw new ParseError(input, 'Multiple :: delimiters', i);
+        }
+
+        /*
+         * The value buffer can be empty for cases where the '::' delimiter is
+         * the first portion of the address.
+         */
+        if (value !== '') {
+          ip6Fields.push(value);
+          value = '';
+        }
+        expIndex = ip6Fields.length;
+        i++;
+      } else {
+        /*
+         * Standard ':' delimiter
+         * The value buffer cannot be empty since that would imply an illegal
+         * pattern such as ':::' or ':.'.
+         */
+        if (value === '') {
+          throw new ParseError(input, 'illegal delimiter', i);
+        }
+        ip6Fields.push(value);
+        value = '';
+      }
+    } else if (c === '.') {
+      /*
+       * Handle dotted quad notation for ipv4 and ipv4-mapped addresses.
+       */
+      ip4Fields.push(value);
+      value = '';
+    } else {
+      value = value + c;
+    }
+  }
+  /* Handle the last stashed value */
+  if (value !== '') {
+    if (ip4Fields.length !== 0) {
+      ip4Fields.push(value);
+    } else {
+      ip6Fields.push(value);
+    }
+    value = '';
+  } else {
+    /* With no stashed value, the address must end with '::'. */
+    if (expIndex !== ip6Fields.length || ip4Fields.length > 0) {
+      throw new ParseError(input, 'Cannot end with delimiter besides ::');
+    }
+  }
+
+  /* With values collected, ensure we don't have too many/few */
+  if (ip4Fields.length === 0) {
+    if (ip6Fields.length > 8) {
+      throw new ParseError(input, 'Too many fields');
+    } else if (ip6Fields.length < 8 && expIndex === null) {
+      throw new ParseError(input, 'Too few fields');
+    }
+  } else {
+    if (ip4Fields.length !== 4) {
+      throw new ParseError(input, 'IPv4 portion must have 4 fields');
+    }
+    /* If this is a bare IP address, implicitly convert to IPv4 mapped */
+    if (ip6Fields.length === 0 && expIndex === null) {
+      result._attrs.ipv4Bare = true;
+      ip6Fields = ['ffff'];
+      expIndex = 0;
+    }
+
+    if (ip6Fields.length > 6) {
+      throw new ParseError(input, 'Too many fields');
+    } else if (ip6Fields.length < 6 && expIndex === null) {
+      throw new ParseError(input, 'Too few fields');
+    }
+  }
+
+  /* Parse integer values */
+  var field, num;
+  for (i = 0; i < ip6Fields.length; i++) {
+    field = ip6Fields[i];
+    num = Number('0x' + field);
+    if (isNaN(num) || num < 0 || num > 65535) {
+      throw new ParseError(input, 'Invalid field value: ' + field);
+    }
+    ip6Fields[i] = num;
+  }
+  for (i = 0; i < ip4Fields.length; i++) {
+    field = ip4Fields[i];
+    num = Number(field);
+    if (parseInt(field, 10) !== num || num < 0 || num > 255) {
+      throw new ParseError(input, 'Invalid field value: ' + field);
+    }
+    ip4Fields[i] = num;
+  }
+
+  /* Collapse IPv4 portion, if necessary */
+  if (ip4Fields.length !== 0) {
+    ip6Fields.push((ip4Fields[0]*256) + ip4Fields[1]);
+    ip6Fields.push((ip4Fields[2]*256) + ip4Fields[3]);
+  }
+
+  /* Expand '::' delimiter into implied 0s */
+  if (ip6Fields.length < 8 && expIndex !== null) {
+    var filler = [];
+    for (i = 0; i < (8 - ip6Fields.length); i++) {
+      filler.push(0);
+    }
+    ip6Fields = Array.prototype.concat(
+      ip6Fields.slice(0, expIndex),
+      filler,
+      ip6Fields.slice(expIndex)
+    );
+  }
+
+  /*
+   * If dotted-quad notation was used, ensure the input was either a bare ipv4
+   * address or a valid ipv4-mapped address.
+   */
+  if (ip4Fields.length !== 0) {
+    if (!_ipv4Mapped(ip6Fields)) {
+      throw new ParseError(input, 'invalid dotted-quad notation');
+    } else {
+      result._attrs.ipv4Mapped = true;
+    }
+  }
+
+  result._fields = ip6Fields;
+
+  return result;
+}
+
+function parseLong(input) {
+  assert.number(input);
+  if (input !== Math.floor(input)) {
+    throw new Error('Value must be integer');
+  }
+  if (input < 0 || input > 0xffffffff) {
+    throw new Error('Value must be 32 bit');
+  }
+  var out = new Addr();
+  out._fields[7] = input & 0xffff;
+  out._fields[6] = (input >>> 16);
+  /* this is ipv4-mapped */
+  out._fields[5] = 0xffff;
+  out._attrs.ipv4Bare = true;
+  out._attrs.ipv4Mapped = true;
+  return out;
+}
+
+/**
+ * Compare Addr objects in a manner suitable for Array.sort().
+ */
+function ip6addrCompare(a, b) {
+  a = _toAddr(a);
+  b = _toAddr(b);
+
+  var i;
+  for (i = 0; i < 8; i++) {
+    if (a._fields[i] < b._fields[i]) {
+      return -1;
+    } else if (a._fields[i] > b._fields[i]) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+///--- Exports
+
+module.exports = {
+  parse: ip6addrParse,
+  compare: ip6addrCompare,
+  createCIDR: function (addr, len) {
+    return new CIDR(addr, len);
+  },
+  compareCIDR: ip6cidrCompare,
+  createAddrRange: function (begin, end) {
+    return new AddrRange(begin, end);
+  }
+};
diff --git a/src/fw/package.json b/src/fw/package.json
index 313cbce5..f0e44cfa 100644
--- a/src/fw/package.json
+++ b/src/fw/package.json
@@ -16,6 +16,8 @@
     "clone": "0.1.4",
     "cmdln": "4.1.1",
     "extsprintf": "1.0.2",
+    "fwrule": "1.4.1",
+    "ip6addr": "0.2.2",
     "mkdirp": "0.3.4",
     "node-uuid": "1.2.0",
     "tab": "0.1.0",
diff --git a/src/fw/tools/bin/rebuild-node-modules b/src/fw/tools/bin/rebuild-node-modules
index c0b585a6..4b080e16 100755
--- a/src/fw/tools/bin/rebuild-node-modules
+++ b/src/fw/tools/bin/rebuild-node-modules
@@ -1,6 +1,6 @@
 #!/bin/bash
 #
-# Copyright 2014, Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc. All rights reserved.
 #
 # Creates a node modules suitable for checking in and installing in
 # the platform
@@ -25,6 +25,7 @@ mkdir ${NM}
 
 # The following are all Joyent-licensed
 cp ${NM_ORIG}/extsprintf/lib/extsprintf.js \
+    ${NM_ORIG}/ip6addr/ip6addr.js \
     ${NM_ORIG}/verror/lib/verror.js \
     ${NM_ORIG}/vasync/lib/vasync.js \
     ${NM_ORIG}/tab/lib/tab.js \
@@ -47,7 +48,8 @@ cp ${NM_ORIG}/clone/clone.js ${NM}/clone/index.js
 cp ${NM_ORIG}/clone/{LICENSE,clonePrototype.js} ${NM}/clone/
 
 mkdir ${NM}/fwrule
-cp tools/fwrule/lib/* ${NM}/fwrule/
+cp ${NM_ORIG}/fwrule/lib/* ${NM}/fwrule/
+cp -r ${NM_ORIG}/fwrule/docs tools/fwrule/
 
 mkdir ${NM}/cmdln
 cp ${NM_ORIG}/cmdln/lib/cmdln.js ${NM}/cmdln/index.js
diff --git a/src/fw/tools/fwrule/Makefile b/src/fw/tools/fwrule/Makefile
deleted file mode 100644
index d041e359..00000000
--- a/src/fw/tools/fwrule/Makefile
+++ /dev/null
@@ -1,142 +0,0 @@
-#
-# CDDL HEADER START
-#
-# The contents of this file are subject to the terms of the
-# Common Development and Distribution License, Version 1.0 only
-# (the "License").  You may not use this file except in compliance
-# with the License.
-#
-# You can obtain a copy of the license at http://smartos.org/CDDL
-#
-# See the License for the specific language governing permissions
-# and limitations under the License.
-#
-# When distributing Covered Code, include this CDDL HEADER in each
-# file.
-#
-# If applicable, add the following below this CDDL HEADER, with the
-# fields enclosed by brackets "[]" replaced with your own identifying
-# information: Portions Copyright [yyyy] [name of copyright owner]
-#
-# CDDL HEADER END
-#
-# Copyright 2016, Joyent, Inc. All rights reserved.
-#
-#
-# fwrule Makefile
-#
-
-
-#
-# Tools
-#
-JISON	:= ./node_modules/jison/lib/cli.js
-ISTANBUL := node_modules/.bin/istanbul
-FAUCET := node_modules/.bin/faucet
-RAMSEY := node_modules/ramsey/bin/ramsey
-NPM := npm
-JS_FILES	:= $(shell find lib test -name '*.js' | grep -v parser.js)
-JSL_CONF_NODE	 = tools/jsl.node.conf
-JSL_FILES_NODE   = $(JS_FILES)
-JSL_FLAGS  	?= --nologo --nosummary
-JSL_FLAGS_NODE 	 = --conf=$(JSL_CONF_NODE)
-JSSTYLE_FILES	 = $(JS_FILES)
-JSSTYLE_FLAGS    = -o indent=4,strict-indent=1,doxygen,unparenthesized-return=0,continuation-at-front=1,leading-right-paren-ok=1
-ESLINT		= ./node_modules/.bin/eslint
-ESLINT_CONF	= tools/eslint.node.conf
-ESLINT_FILES	= $(JS_FILES)
-
-
-#
-# Repo-specific targets
-#
-
-.PHONY: parser
-parser: $(JISON)
-	@cp ./src/header.js ./lib/parser.js
-	@cat ./src/fwrule.jison | $(JISON)  >> ./lib/parser.js
-
-$(ESLINT):
-	$(NPM) install
-
-$(ISTANBUL):
-	$(NPM) install
-
-$(FAUCET):
-	$(NPM) install
-
-$(JISON):
-	$(NPM) install
-
-$(RAMSEY):
-	$(NPM) install
-
-
-#
-# test / check targets
-#
-
-.PHONY: test
-test: $(ISTANBUL) $(FAUCET)
-	$(ISTANBUL) cover --print none test/run.js | $(FAUCET)
-
-.PHONY: check
-check: check-jsl check-jsstyle check-eslint
-	@echo check ok
-
-.PHONY: prepush
-prepush: check test
-
-.PHONY: docs
-docs: $(RAMSEY) docs/examples.md docs/rules.md
-
-docs/examples.md: docs/examples.md.in
-	$(RAMSEY) -d etc/examples -f etc/examples.json docs/examples.md.in $@
-
-docs/rules.md: docs/rules.md.in
-	$(RAMSEY) -p wrap=0 docs/rules.md.in $@
-
-#
-# This rule enables other rules that use files from a git submodule to have
-# those files depend on deps/module/.git and have "make" automatically check
-# out the submodule as needed.
-#
-deps/%/.git:
-	git submodule update --init deps/$*
-
-#
-# javascriptlint
-#
-
-JSL_EXEC	?= deps/javascriptlint/build/install/jsl
-JSL		?= $(JSL_EXEC)
-
-$(JSL_EXEC): | deps/javascriptlint/.git
-	cd deps/javascriptlint && make install
-
-distclean::
-	if [[ -f deps/javascriptlint/Makefile ]]; then \
-		cd deps/javascriptlint && make clean; \
-	fi
-
-
-#
-# jsstyle
-#
-
-JSSTYLE_EXEC	?= deps/jsstyle/jsstyle
-JSSTYLE		?= $(JSSTYLE_EXEC)
-
-$(JSSTYLE_EXEC): | deps/jsstyle/.git
-
-.PHONY: check-jsl
-check-jsl: $(JSL_EXEC)
-	@$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
-
-.PHONY: check-jsstyle
-check-jsstyle:  $(JSSTYLE_EXEC)
-	@$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
-
-.PHONY: check-eslint
-check-eslint: $(ESLINT)
-	@$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
diff --git a/src/fw/tools/fwrule/README.md b/src/fw/tools/fwrule/README.md
deleted file mode 100644
index b735d060..00000000
--- a/src/fw/tools/fwrule/README.md
+++ /dev/null
@@ -1,56 +0,0 @@
-# sdc-fwrule
-
-Joyent firewall rule object wrapper. This is a copy of the sdc-fwrule repo. For
-contribution guidelines, issues, and general documentation, visit the main
-[sdc-fwrule](http://github.com/joyent/sdc-fwrule) project page.
-
-This contains shared code for manipulating Triton firewall rules.
-There are two parts to this package:
-
-* A Jison grammar (src/fwrule.jison) that specifies a DSL for writing
-  firewall rules. This is used to generate the parser (lib/parser.js)
-* A rule object that wraps the parser and provides various convenience
-  and serialization methods.
-
-The parser is currently checked in to avoid requiring jison to be installed
-in order to use this package.
-
-
-# Repository
-
-    docs/           Documentation (restdown format)
-    lib/            Source files
-    node_modules/   node.js dependencies (populate by running "npm install")
-    src/            Contains the jison grammar for creating the firewall rule
-                    parser
-    tools/          Tools and configuration files
-    test/           Test suite (using nodeunit)
-
-
-# Development
-
-If you update the jison grammar, run the following to regenerate the parser:
-
-    make parser
-
-Before checking in, please run:
-
-    make check
-
-and fix any warnings. Note that jsstyle will stop after the first file with an
-error, so you may need to run this multiple times while fixing.
-
-For non-trivial changes, please add a unit test that covers the functionality
-of the change. If this is a syntax change, update docs/rules.md.in and
-docs/examples.md.in accordingly.
-
-
-# Testing
-
-To run all tests:
-
-    make test
-
-To run an individual test:
-
-    ./node_modules/.bin/nodeunit <path to test file>
diff --git a/src/fw/tools/fwrule/lib/index.js b/src/fw/tools/fwrule/lib/index.js
deleted file mode 100644
index f42f6a92..00000000
--- a/src/fw/tools/fwrule/lib/index.js
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * firewall rule parser: entry point
- */
-
-'use strict';
-
-var mod_net = require('net');
-var parser = require('./parser').parser;
-var rule = require('./rule');
-var validators = require('./validators');
-
-
-
-// --- Globals
-
-
-
-var uuidRE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-
-/**
- * The fwrule language is versioned so that use of new features can be
- * restricted. These versions are:
- *
- * 1 - Initial version of language
- * 2 - PORTS keyword & support for ranges of ports
- * 3 - Support for IPv6 targets, the ICMPv6 protocol, and the TYPE ALL keyword
- */
-var CURR_VERSION = 3;
-
-
-// --- Internal helper functions
-
-
-/**
- * Translates an internal parser name (usually all one word, all caps, for
- * brevity), to a friendlier user-facing name
- */
-function translateParserNames(name) {
-    var translated;
-    switch (name) {
-        case '\'ALL\'':
-        case '\'ANY\'':
-        case '\'IP\'':
-        case '\'SUBNET\'':
-        case '\'TAG\'':
-        case '\'VM\'':
-        case 'WORD':
-            translated = name.toLowerCase();
-            break;
-        default:
-            translated = name;
-            break;
-    }
-
-    return translated;
-}
-
-
-
-// --- Parser extension methods
-
-
-
-parser.yy.validateIPv4address = function validateIPv4address(ip) {
-    if (!validators.validateIPv4address(ip)) {
-        throw new validators.InvalidParamError('rule',
-            'IPv4 address "%s" is invalid', ip);
-    }
-};
-
-
-parser.yy.validateIPv4subnet = function validateIPv4subnet(subnet) {
-    if (!validators.validateIPv4subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
-parser.yy.validateIPv6address = function validateIPv6address(ip) {
-    if (!mod_net.isIPv6(ip)) {
-        throw new validators.InvalidParamError('rule',
-            'IPv6 address "%s" is invalid', ip);
-    }
-};
-
-
-parser.yy.validateIPv6subnet = function validateIPv6subnet(subnet) {
-    if (!validators.validateIPv6subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
-parser.yy.validatePortNumber = function validatePortNumber(num) {
-    if (isNaN(num) || Number(num) < 1 || Number(num) > 65535) {
-        throw new validators.InvalidParamError('rule',
-            'Port number "%s" is invalid', num);
-    }
-};
-
-parser.yy.validateRangeOrder = function validateRangeOrder(start, end) {
-    if (Number(end) < Number(start)) {
-        throw new validators.InvalidParamError('rule',
-            'The end of the range (%s) cannot be less than the start (%s)',
-            end, start);
-    }
-};
-
-parser.yy.createMaybePortRange = function createMaybePortRange(num) {
-    var range = num.split('-');
-
-    switch (range.length) {
-    case 1:
-            parser.yy.validatePortNumber(range[0]);
-            return Number(range[0]);
-    case 2:
-            parser.yy.validatePortNumber(range[0]);
-            parser.yy.validatePortNumber(range[1]);
-            parser.yy.validateRangeOrder(range[0], range[1]);
-            return { 'start': Number(range[0]), 'end': Number(range[1]) };
-    default:
-            throw new validators.InvalidParamError('rule',
-                '"%s" is not a valid port number or range', num);
-    }
-};
-
-
-parser.yy.validateICMPcode = function validateICMPcode(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
-        throw new validators.InvalidParamError('rule',
-            'ICMP code "%s" is invalid', num);
-    }
-};
-
-
-parser.yy.validateICMPtype = function validateICMPtype(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
-        throw new validators.InvalidParamError('rule',
-            'ICMP type "%s" is invalid', num);
-    }
-};
-
-
-parser.yy.validateUUID = function validateUUID(text) {
-    if (!uuidRE.test(text)) {
-        throw new validators.InvalidParamError('rule',
-            'UUID "%s" is invalid', text);
-    }
-};
-
-parser.yy.validateOKVersion = function validateOKVersion(ver, feature) {
-    if (ver > parser.yy.maxVersion) {
-        throw new validators.InvalidParamError('rule',
-            'The rule uses a feature (%s) newer than this API allows', feature);
-    }
-};
-
-
-parser.yy.parseError = function parseError(_, details) {
-    var err;
-    if (details.token === null) {
-        var pre = this.yy.lexer.pastInput();
-        var post = this.yy.lexer.upcomingInput();
-        err = new validators.InvalidParamError('rule',
-            'Error at character %d: \'%s\', found: unexpected text',
-            pre.length, post);
-        err.details = details;
-        throw err;
-    }
-
-    if (details.text === '') {
-        err = new validators.InvalidParamError('rule',
-            'Error at character 0: \'\', expected: \'FROM\', found: '
-            + 'empty string');
-        err.details = details;
-        throw err;
-    }
-
-    err = new validators.InvalidParamError('rule',
-        'Error at character %d: \'%s\', expected: %s, found: %s',
-        details.loc.last_column,
-        details.text,
-        details.expected.map(function (exp) {
-            return translateParserNames(exp);
-        }).join(', '),
-        translateParserNames(details.token));
-
-    err.details = details;
-    throw err;
-};
-
-
-parser.yy.tagUnescape = rule.tagUnescape;
-
-
-// --- Exports
-
-
-
-function parse(input, opts) {
-    if (!opts) {
-        opts = {};
-    }
-
-    // If a version hasn't been specified, use most recent
-    parser.yy.maxVersion = opts.maxVersion || CURR_VERSION;
-
-    return parser.parse(input);
-}
-
-
-
-module.exports = {
-    ACTIONS: ['allow', 'block'],
-    DIRECTIONS: rule.DIRECTIONS,
-    FIELDS: rule.FIELDS,
-    create: rule.create,
-    FwRule: rule.FwRule,
-    generateVersion: rule.generateVersion,
-    parse: parse,
-    PROTOCOLS: ['tcp', 'udp', 'icmp', 'icmp6'],
-    TARGET_TYPES: rule.TARGET_TYPES,
-    validators: validators
-};
diff --git a/src/fw/tools/fwrule/lib/parser.js b/src/fw/tools/fwrule/lib/parser.js
deleted file mode 100644
index f50b0abc..00000000
--- a/src/fw/tools/fwrule/lib/parser.js
+++ /dev/null
@@ -1,561 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser
- */
-
-
-/* parser generated by jison 0.4.2 */
-var parser = (function(){
-var parser = {trace: function trace() { },
-yy: {},
-symbols_: {"error":2,"start":3,"FROM":4,"target_list":5,"TO":6,"action":7,"protocol":8,"EOF":9,"any":10,"all":11,"(":12,"target_or_list":13,")":14,"target":15,"OR":16,"ipv4":17,"ipv4_subnet":18,"ipv6":19,"ipv6_subnet":20,"tag":21,"vm":22,"ALL":23,"VMS":24,"ANY":25,"IP":26,"IPV4ADDR":27,"SUBNET":28,"CIDRSUFFIX":29,"IPV6ADDR":30,"VM":31,"uuid":32,"WORD":33,"TAG":34,"tag_string":35,"=":36,"STRING":37,"BLOCK":38,"ALLOW":39,"TCP":40,"port_list":41,"ports":42,"UDP":43,"ICMP":44,"type_list":45,"ICMP6":46,"port_and_list":47,"port":48,"port_all":49,"AND":50,"PORT":51,"portnumber":52,"PORTS":53,"portnumbers":54,"portrange":55,"-":56,",":57,"type_and_list":58,"type":59,"type_all":60,"TYPE":61,"icmptype":62,"CODE":63,"icmpcode":64,"$accept":0,"$end":1},
-terminals_: {2:"error",4:"FROM",6:"TO",9:"EOF",12:"(",14:")",16:"OR",23:"ALL",24:"VMS",25:"ANY",26:"IP",27:"IPV4ADDR",28:"SUBNET",29:"CIDRSUFFIX",30:"IPV6ADDR",31:"VM",33:"WORD",34:"TAG",36:"=",37:"STRING",38:"BLOCK",39:"ALLOW",40:"TCP",43:"UDP",44:"ICMP",46:"ICMP6",50:"AND",51:"PORT",53:"PORTS",56:"-",57:",",61:"TYPE",63:"CODE"},
-productions_: [0,[3,7],[5,1],[5,1],[5,3],[5,1],[13,1],[13,3],[15,1],[15,1],[15,1],[15,1],[15,1],[15,1],[11,2],[11,4],[10,1],[10,3],[17,2],[18,3],[19,2],[20,3],[22,2],[32,1],[21,2],[21,4],[35,1],[35,1],[7,1],[7,1],[8,2],[8,2],[8,2],[8,2],[8,2],[8,2],[41,3],[41,1],[41,3],[41,1],[47,1],[47,3],[48,2],[42,2],[49,2],[52,1],[55,1],[55,3],[54,1],[54,3],[45,3],[45,1],[45,3],[45,1],[58,1],[58,3],[59,4],[59,2],[60,2],[62,1],[64,1]],
-performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {
-
-var $0 = $$.length - 1;
-switch (yystate) {
-case 1: return { 'from': $$[$0-5], 'to': $$[$0-3], 'action': $$[$0-2], 'protocol': $$[$0-1] }; 
-break;
-case 4:this.$ = $$[$0-1];
-break;
-case 7: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 14: this.$ = [ ['wildcard', 'vmall'] ]; 
-break;
-case 15: this.$ = [ ['wildcard', 'vmall'] ]; 
-break;
-case 16: this.$ = [ ['wildcard', 'any'] ]; 
-break;
-case 17: this.$ = [ ['wildcard', 'any'] ]; 
-break;
-case 18: yy.validateIPv4address($$[$0]);
-          this.$ = [ ['ip', $$[$0]] ]; 
-break;
-case 19: yy.validateIPv4subnet($$[$0-1] + $$[$0]);
-            this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
-break;
-case 20: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6address($$[$0]);
-          this.$ = [ ['ip', $$[$0]] ]; 
-break;
-case 21: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($$[$0-1] + $$[$0]);
-            this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
-break;
-case 22: this.$ = [ ['vm', $$[$0]] ]; 
-break;
-case 23: yy.validateUUID($$[$0]);
-          this.$ = $$[$0]; 
-break;
-case 24: this.$ = [ ['tag', $$[$0]] ]; 
-break;
-case 25: this.$ = [ ['tag', [ $$[$0-2], $$[$0] ] ] ]; 
-break;
-case 26: this.$ = yytext; 
-break;
-case 27: this.$ = $$[$0]; 
-break;
-case 28: this.$ = $$[$0].toLowerCase() 
-break;
-case 29: this.$ = $$[$0].toLowerCase() 
-break;
-case 30: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 31: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 32: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 33: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 34: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 35: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 36: this.$ = $$[$0-1]; 
-break;
-case 38: this.$ = $$[$0-1]; 
-break;
-case 41: this.$ = $$[$0-2].concat(Number($$[$0])); 
-break;
-case 42: this.$ = [ $$[$0] ]; 
-break;
-case 43: yy.validateOKVersion(2, 'port ranges');
-          this.$ = $$[$0]; 
-break;
-case 44: this.$ = [ 'all' ]; 
-break;
-case 45: yy.validatePortNumber($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-case 46: this.$ = [ yy.createMaybePortRange($$[$0]) ]; 
-break;
-case 47: yy.validatePortNumber($$[$0-2]);
-          yy.validatePortNumber($$[$0]);
-          yy.validateRangeOrder($$[$0-2], $$[$0]);
-          this.$ = [{ 'start': Number($$[$0-2]), 'end': Number($$[$0]) }]; 
-break;
-case 49: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 50: this.$ = $$[$0-1]; 
-break;
-case 52: this.$ = $$[$0-1]; 
-break;
-case 55: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 56: this.$ = [ $$[$0-2] + ':' + $$[$0] ]; 
-break;
-case 57: this.$ = [ $$[$0] ]; 
-break;
-case 58: yy.validateOKVersion(3, 'all ICMP types');
-          this.$ = [ 'all' ]; 
-break;
-case 59: yy.validateICMPtype($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-case 60: yy.validateICMPcode($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-}
-},
-table: [{3:1,4:[1,2]},{1:[3]},{5:3,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[1,20]},{6:[2,2],38:[2,2],39:[2,2]},{6:[2,3],38:[2,3],39:[2,3]},{13:21,15:24,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,23],25:[1,22],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,5],38:[2,5],39:[2,5]},{6:[2,16],38:[2,16],39:[2,16]},{24:[1,25]},{6:[2,8],14:[2,8],16:[2,8],38:[2,8],39:[2,8]},{6:[2,9],14:[2,9],16:[2,9],38:[2,9],39:[2,9]},{6:[2,10],14:[2,10],16:[2,10],38:[2,10],39:[2,10]},{6:[2,11],14:[2,11],16:[2,11],38:[2,11],39:[2,11]},{6:[2,12],14:[2,12],16:[2,12],38:[2,12],39:[2,12]},{6:[2,13],14:[2,13],16:[2,13],38:[2,13],39:[2,13]},{27:[1,26],30:[1,27]},{27:[1,28],30:[1,29]},{33:[1,32],35:30,37:[1,31]},{32:33,33:[1,34]},{5:35,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{14:[1,36],16:[1,37]},{14:[1,38]},{24:[1,39]},{14:[2,6],16:[2,6]},{6:[2,14],38:[2,14],39:[2,14]},{6:[2,18],14:[2,18],16:[2,18],38:[2,18],39:[2,18]},{6:[2,20],14:[2,20],16:[2,20],38:[2,20],39:[2,20]},{29:[1,40]},{29:[1,41]},{6:[2,24],14:[2,24],16:[2,24],36:[1,42],38:[2,24],39:[2,24]},{6:[2,26],14:[2,26],16:[2,26],36:[2,26],38:[2,26],39:[2,26]},{6:[2,27],14:[2,27],16:[2,27],36:[2,27],38:[2,27],39:[2,27]},{6:[2,22],14:[2,22],16:[2,22],38:[2,22],39:[2,22]},{6:[2,23],14:[2,23],16:[2,23],38:[2,23],39:[2,23]},{7:43,38:[1,44],39:[1,45]},{6:[2,4],38:[2,4],39:[2,4]},{15:46,17:10,18:11,19:12,20:13,21:14,22:15,26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,17],38:[2,17],39:[2,17]},{14:[1,47]},{6:[2,19],14:[2,19],16:[2,19],38:[2,19],39:[2,19]},{6:[2,21],14:[2,21],16:[2,21],38:[2,21],39:[2,21]},{33:[1,32],35:48,37:[1,31]},{8:49,40:[1,50],43:[1,51],44:[1,52],46:[1,53]},{40:[2,28],43:[2,28],44:[2,28],46:[2,28]},{40:[2,29],43:[2,29],44:[2,29],46:[2,29]},{14:[2,7],16:[2,7]},{6:[2,15],38:[2,15],39:[2,15]},{6:[2,25],14:[2,25],16:[2,25],38:[2,25],39:[2,25]},{9:[1,54]},{12:[1,57],41:55,42:56,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,57],41:62,42:63,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,65],45:64,59:66,60:67,61:[1,68]},{12:[1,65],45:69,59:66,60:67,61:[1,68]},{1:[2,1]},{9:[2,30]},{9:[2,31]},{47:70,48:72,49:71,51:[1,61]},{9:[2,37]},{9:[2,39]},{33:[1,75],54:73,55:74},{23:[1,77],33:[1,78],52:76},{9:[2,32]},{9:[2,33]},{9:[2,34]},{58:79,59:81,60:80,61:[1,68]},{9:[2,51]},{9:[2,53]},{23:[1,83],33:[1,84],62:82},{9:[2,35]},{14:[1,85],50:[1,86]},{14:[1,87]},{14:[2,40],50:[2,40]},{9:[2,43],57:[1,88]},{9:[2,48],57:[2,48]},{9:[2,46],56:[1,89],57:[2,46]},{9:[2,42],14:[2,42],50:[2,42]},{9:[2,44],14:[2,44]},{9:[2,45],14:[2,45],50:[2,45]},{14:[1,90],50:[1,91]},{14:[1,92]},{14:[2,54],50:[2,54]},{9:[2,57],14:[2,57],50:[2,57],63:[1,93]},{9:[2,58],14:[2,58]},{9:[2,59],14:[2,59],50:[2,59],63:[2,59]},{9:[2,36]},{48:94,51:[1,95]},{9:[2,38]},{33:[1,75],55:96},{33:[1,97]},{9:[2,50]},{59:98,61:[1,99]},{9:[2,52]},{33:[1,101],64:100},{14:[2,41],50:[2,41]},{33:[1,78],52:76},{9:[2,49],57:[2,49]},{9:[2,47],57:[2,47]},{14:[2,55],50:[2,55]},{33:[1,84],62:82},{9:[2,56],14:[2,56],50:[2,56]},{9:[2,60],14:[2,60],50:[2,60]}],
-defaultActions: {54:[2,1],55:[2,30],56:[2,31],58:[2,37],59:[2,39],62:[2,32],63:[2,33],64:[2,34],66:[2,51],67:[2,53],69:[2,35],85:[2,36],87:[2,38],90:[2,50],92:[2,52]},
-parseError: function parseError(str, hash) {
-    throw new Error(str);
-},
-parse: function parse(input) {
-    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
-    this.lexer.setInput(input);
-    this.lexer.yy = this.yy;
-    this.yy.lexer = this.lexer;
-    this.yy.parser = this;
-    if (typeof this.lexer.yylloc == "undefined")
-        this.lexer.yylloc = {};
-    var yyloc = this.lexer.yylloc;
-    lstack.push(yyloc);
-    var ranges = this.lexer.options && this.lexer.options.ranges;
-    if (typeof this.yy.parseError === "function")
-        this.parseError = this.yy.parseError;
-    function popStack(n) {
-        stack.length = stack.length - 2 * n;
-        vstack.length = vstack.length - n;
-        lstack.length = lstack.length - n;
-    }
-    function lex() {
-        var token;
-        token = self.lexer.lex() || 1;
-        if (typeof token !== "number") {
-            token = self.symbols_[token] || token;
-        }
-        return token;
-    }
-    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
-    while (true) {
-        state = stack[stack.length - 1];
-        if (this.defaultActions[state]) {
-            action = this.defaultActions[state];
-        } else {
-            if (symbol === null || typeof symbol == "undefined") {
-                symbol = lex();
-            }
-            action = table[state] && table[state][symbol];
-        }
-        if (typeof action === "undefined" || !action.length || !action[0]) {
-            var errStr = "";
-            if (!recovering) {
-                expected = [];
-                for (p in table[state])
-                    if (this.terminals_[p] && p > 2) {
-                        expected.push("'" + this.terminals_[p] + "'");
-                    }
-                if (this.lexer.showPosition) {
-                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
-                } else {
-                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
-                }
-                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
-            }
-        }
-        if (action[0] instanceof Array && action.length > 1) {
-            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
-        }
-        switch (action[0]) {
-        case 1:
-            stack.push(symbol);
-            vstack.push(this.lexer.yytext);
-            lstack.push(this.lexer.yylloc);
-            stack.push(action[1]);
-            symbol = null;
-            if (!preErrorSymbol) {
-                yyleng = this.lexer.yyleng;
-                yytext = this.lexer.yytext;
-                yylineno = this.lexer.yylineno;
-                yyloc = this.lexer.yylloc;
-                if (recovering > 0)
-                    recovering--;
-            } else {
-                symbol = preErrorSymbol;
-                preErrorSymbol = null;
-            }
-            break;
-        case 2:
-            len = this.productions_[action[1]][1];
-            yyval.$ = vstack[vstack.length - len];
-            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
-            if (ranges) {
-                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
-            }
-            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
-            if (typeof r !== "undefined") {
-                return r;
-            }
-            if (len) {
-                stack = stack.slice(0, -1 * len * 2);
-                vstack = vstack.slice(0, -1 * len);
-                lstack = lstack.slice(0, -1 * len);
-            }
-            stack.push(this.productions_[action[1]][0]);
-            vstack.push(yyval.$);
-            lstack.push(yyval._$);
-            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
-            stack.push(newState);
-            break;
-        case 3:
-            return true;
-        }
-    }
-    return true;
-}
-};
-/* generated by jison-lex 0.1.0 */
-var lexer = (function(){
-var lexer = {
-EOF:1,
-parseError:function parseError(str, hash) {
-        if (this.yy.parser) {
-            this.yy.parser.parseError(str, hash);
-        } else {
-            throw new Error(str);
-        }
-    },
-setInput:function (input) {
-        this._input = input;
-        this._more = this._less = this.done = false;
-        this.yylineno = this.yyleng = 0;
-        this.yytext = this.matched = this.match = '';
-        this.conditionStack = ['INITIAL'];
-        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
-        if (this.options.ranges) this.yylloc.range = [0,0];
-        this.offset = 0;
-        return this;
-    },
-input:function () {
-        var ch = this._input[0];
-        this.yytext += ch;
-        this.yyleng++;
-        this.offset++;
-        this.match += ch;
-        this.matched += ch;
-        var lines = ch.match(/(?:\r\n?|\n).*/g);
-        if (lines) {
-            this.yylineno++;
-            this.yylloc.last_line++;
-        } else {
-            this.yylloc.last_column++;
-        }
-        if (this.options.ranges) this.yylloc.range[1]++;
-
-        this._input = this._input.slice(1);
-        return ch;
-    },
-unput:function (ch) {
-        var len = ch.length;
-        var lines = ch.split(/(?:\r\n?|\n)/g);
-
-        this._input = ch + this._input;
-        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
-        //this.yyleng -= len;
-        this.offset -= len;
-        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
-        this.match = this.match.substr(0, this.match.length-1);
-        this.matched = this.matched.substr(0, this.matched.length-1);
-
-        if (lines.length-1) this.yylineno -= lines.length-1;
-        var r = this.yylloc.range;
-
-        this.yylloc = {first_line: this.yylloc.first_line,
-          last_line: this.yylineno+1,
-          first_column: this.yylloc.first_column,
-          last_column: lines ?
-              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
-              this.yylloc.first_column - len
-          };
-
-        if (this.options.ranges) {
-            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
-        }
-        return this;
-    },
-more:function () {
-        this._more = true;
-        return this;
-    },
-less:function (n) {
-        this.unput(this.match.slice(n));
-    },
-pastInput:function () {
-        var past = this.matched.substr(0, this.matched.length - this.match.length);
-        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
-    },
-upcomingInput:function () {
-        var next = this.match;
-        if (next.length < 20) {
-            next += this._input.substr(0, 20-next.length);
-        }
-        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
-    },
-showPosition:function () {
-        var pre = this.pastInput();
-        var c = new Array(pre.length + 1).join("-");
-        return pre + this.upcomingInput() + "\n" + c+"^";
-    },
-next:function () {
-        if (this.done) {
-            return this.EOF;
-        }
-        if (!this._input) this.done = true;
-
-        var token,
-            match,
-            tempMatch,
-            index,
-            col,
-            lines;
-        if (!this._more) {
-            this.yytext = '';
-            this.match = '';
-        }
-        var rules = this._currentRules();
-        for (var i=0;i < rules.length; i++) {
-            tempMatch = this._input.match(this.rules[rules[i]]);
-            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
-                match = tempMatch;
-                index = i;
-                if (!this.options.flex) break;
-            }
-        }
-        if (match) {
-            lines = match[0].match(/(?:\r\n?|\n).*/g);
-            if (lines) this.yylineno += lines.length;
-            this.yylloc = {first_line: this.yylloc.last_line,
-                           last_line: this.yylineno+1,
-                           first_column: this.yylloc.last_column,
-                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
-            this.yytext += match[0];
-            this.match += match[0];
-            this.matches = match;
-            this.yyleng = this.yytext.length;
-            if (this.options.ranges) {
-                this.yylloc.range = [this.offset, this.offset += this.yyleng];
-            }
-            this._more = false;
-            this._input = this._input.slice(match[0].length);
-            this.matched += match[0];
-            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
-            if (this.done && this._input) this.done = false;
-            if (token) return token;
-            else return;
-        }
-        if (this._input === "") {
-            return this.EOF;
-        } else {
-            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
-                    {text: "", token: null, line: this.yylineno});
-        }
-    },
-lex:function lex() {
-        var r = this.next();
-        if (typeof r !== 'undefined') {
-            return r;
-        } else {
-            return this.lex();
-        }
-    },
-begin:function begin(condition) {
-        this.conditionStack.push(condition);
-    },
-popState:function popState() {
-        return this.conditionStack.pop();
-    },
-_currentRules:function _currentRules() {
-        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
-    },
-topState:function () {
-        return this.conditionStack[this.conditionStack.length-2];
-    },
-pushState:function begin(condition) {
-        this.begin(condition);
-    },
-options: {},
-performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
-
-var YYSTATE=YY_START;
-switch($avoiding_name_collisions) {
-case 0:/* skip whitespace */
-break;
-case 1:return 9;
-break;
-case 2:return 4;
-break;
-case 3:return 4;
-break;
-case 4:return 6;
-break;
-case 5:return 6;
-break;
-case 6:return 26;
-break;
-case 7:return 26;
-break;
-case 8:return 28;
-break;
-case 9:return 28;
-break;
-case 10:return 25;
-break;
-case 11:return 25;
-break;
-case 12:return 23;
-break;
-case 13:return 23;
-break;
-case 14:return 34;
-break;
-case 15:return 34;
-break;
-case 16:return 31;
-break;
-case 17:return 31;
-break;
-case 18:return 24;
-break;
-case 19:return 24;
-break;
-case 20:return 56;
-break;
-case 21:return 57;
-break;
-case 22:return 36;
-break;
-case 23:return 12;
-break;
-case 24:return 14;
-break;
-case 25:return 16;
-break;
-case 26:return 16;
-break;
-case 27:return 50;
-break;
-case 28:return 50;
-break;
-case 29:return 38;
-break;
-case 30:return 38;
-break;
-case 31:return 39;
-break;
-case 32:return 39;
-break;
-case 33:return 51;
-break;
-case 34:return 51;
-break;
-case 35:return 53;
-break;
-case 36:return 53;
-break;
-case 37:return 40;
-break;
-case 38:return 40;
-break;
-case 39:return 43;
-break;
-case 40:return 43;
-break;
-case 41:return 44;
-break;
-case 42:return 44;
-break;
-case 43:return 46;
-break;
-case 44:return 46;
-break;
-case 45:return 61;
-break;
-case 46:return 61;
-break;
-case 47:return 63;
-break;
-case 48:return 63;
-break;
-case 49:yy_.yytext = yy.tagUnescape(yy_.yytext.substr(1,yy_.yyleng-2)); return 37;
-break;
-case 50:return 27;
-break;
-case 51:return 30;
-break;
-case 52:return 29;
-break;
-case 53:return 33
-break;
-}
-},
-rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:"(?:\\["bfnrt/()\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
-conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"inclusive":true}}
-};
-return lexer;
-})();
-parser.lexer = lexer;
-function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
-return new Parser;
-})();
-if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
-exports.parser = parser;
-exports.Parser = parser.Parser;
-exports.parse = function () { return parser.parse.apply(parser, arguments); };
-exports.main = function commonjsMain(args) {
-    if (!args[1]) {
-        console.log('Usage: '+args[0]+' FILE');
-        process.exit(1);
-    }
-    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
-    return exports.parser.parse(source);
-};
-if (typeof module !== 'undefined' && require.main === module) {
-  exports.main(process.argv.slice(1));
-}
-}
diff --git a/src/fw/tools/fwrule/lib/rule.js b/src/fw/tools/fwrule/lib/rule.js
deleted file mode 100644
index d9eab021..00000000
--- a/src/fw/tools/fwrule/lib/rule.js
+++ /dev/null
@@ -1,748 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule model
- */
-
-'use strict';
-
-var mod_net = require('net');
-var mod_uuid = require('node-uuid');
-var sprintf = require('extsprintf').sprintf;
-var util = require('util');
-var validators = require('./validators');
-var verror = require('verror');
-
-
-
-// --- Globals
-
-
-
-var DIRECTIONS = ['to', 'from'];
-// Exported fields that can be in the serialized rule:
-var FIELDS = [
-    'created_by',
-    'description',
-    'enabled',
-    'global',
-    'owner_uuid',
-    'rule',
-    'uuid',
-    'version'
-];
-// Maximum number of targets per side:
-var MAX_TARGETS_PER_SIDE = 24;
-// Maximum number of ports:
-var MAX_PORTS = 8;
-var STRING_PROPS = ['created_by', 'description'];
-var TARGET_TYPES = ['wildcard', 'ip', 'subnet', 'tag', 'vm'];
-
-var icmpr = /^icmp6?$/;
-
-// --- Internal functions
-
-
-/**
- * Safely check if an object has a property
- */
-function hasOwnProperty(obj, prop) {
-    return Object.prototype.hasOwnProperty.call(obj, prop);
-}
-
-
-/**
- * Calls callback for all of the firewall target types
- */
-function forEachTarget(obj, callback) {
-    DIRECTIONS.forEach(function (dir) {
-        if (!hasOwnProperty(obj, dir)) {
-            return;
-        }
-
-        TARGET_TYPES.forEach(function (type) {
-            var name = type + 's';
-            if (!hasOwnProperty(obj[dir], name)) {
-                return;
-            }
-
-            callback(dir, type, name, obj[dir][name]);
-        });
-    });
-}
-
-
-/**
- * Sorts a list of ICMP types (with optional codes)
- */
-function icmpTypeSort(types) {
-    return types.map(function (type) {
-        return type.toString().split(':');
-    }).sort(function (a, b) {
-        var aTot = (Number(a[0]) << 8) + (a.length === 1 ? 0 : Number(a[1]));
-        var bTot = (Number(b[0]) << 8) + (a.length === 1 ? 0 : Number(b[1]));
-        return aTot - bTot;
-    }).map(function (typeArr) {
-        return typeArr.join(':');
-    });
-}
-
-
-/**
- * Adds a tag to an object
- */
-function addTag(obj, tag, val) {
-    if (!hasOwnProperty(obj, tag)) {
-        obj[tag] = {};
-    }
-
-    if (val === undefined || val === null) {
-        obj[tag].all = true;
-        return;
-    }
-
-    if (!hasOwnProperty(obj[tag], 'values')) {
-        obj[tag].values = {};
-    }
-
-    obj[tag].values[val] = true;
-}
-
-
-/**
- * Creates a list of tags based on an object populated by addTag() above
- */
-function tagList(obj) {
-    var tags = [];
-    Object.keys(obj).sort().forEach(function (tag) {
-        if (hasOwnProperty(obj[tag], 'all')) {
-            tags.push(tag);
-        } else {
-            Object.keys(obj[tag].values).sort().forEach(function (val) {
-                tags.push([tag, val]);
-            });
-        }
-    });
-    return tags;
-}
-
-
-/**
- * The following characters are allowed to come after an escape, and get
- * escaped when producing rule text.
- *
- * Parentheses don't need to be escaped with newer parsers, but will cause
- * errors with older parsers which expect them to be escaped. We therefore
- * always escape them when generating rule text, to make sure we don't
- * cause issues for older parsers.
- */
-var escapes = {
-    '"': '"',
-    'b': '\b',
-    'f': '\f',
-    'n': '\n',
-    'r': '\r',
-    't': '\t',
-    '/': '/',
-    '(': '(',
-    ')': ')',
-    '\\': '\\'
-};
-
-
-/**
- * When producing text versions of a rule, we escape Unicode whitespace
- * characters. These characters don't need to be escaped, but we do so
- * to reduce the chance that an operator will look at a rule and mistake
- * any of them for the ASCII space character (\u0020), or not see them
- * because they're non-printing.
- */
-var unescapes = {
-    // Things that need to be escaped for the fwrule parser
-    '"': '"',
-    '(': '(',
-    ')': ')',
-    '\\': '\\',
-
-    // Special ASCII characters we don't want to print
-    '\u0000': 'u0000', // null (NUL)
-    '\u0001': 'u0001', // start of heading (SOH)
-    '\u0002': 'u0002', // start of text (STX)
-    '\u0003': 'u0003', // end of text (ETX)
-    '\u0004': 'u0004', // end of transmission (EOT)
-    '\u0005': 'u0005', // enquiry (ENQ)
-    '\u0006': 'u0006', // acknowledgement (ACK)
-    '\u0007': 'u0007', // bell (BEL)
-    '\u0008': 'b',     // backspace (BS)
-    '\u0009': 't',     // horizontal tab (HT)
-    '\u000A': 'n',     // newline (NL)
-    '\u000B': 'u000B', // vertical tab (VT)
-    '\u000C': 'f',     // form feed/next page (NP)
-    '\u000D': 'r',     // carriage return (CR)
-    '\u000E': 'u000E', // shift out (SO)
-    '\u000F': 'u000F', // shift in (SI)
-    '\u0010': 'u0010', // data link escape (DLE)
-    '\u0011': 'u0011', // device control 1 (DC1)/XON
-    '\u0012': 'u0012', // device control 2 (DC2)
-    '\u0013': 'u0013', // device control 3 (DC3)/XOFF
-    '\u0014': 'u0014', // device control 4 (DC4)
-    '\u0015': 'u0015', // negative acknowledgement (NAK)
-    '\u0016': 'u0016', // synchronous idle (SYN)
-    '\u0017': 'u0017', // end of transmission block (ETB)
-    '\u0018': 'u0018', // cancel (CAN)
-    '\u0019': 'u0019', // end of medium (EM)
-    '\u001A': 'u001A', // substitute (SUB)
-    '\u001B': 'u001B', // escape (ESC)
-    '\u001C': 'u001C', // file separator (FS)
-    '\u001D': 'u001D', // group separator (GS)
-    '\u001E': 'u001E', // record separator (RS)
-    '\u001F': 'u001F', // unit separator (US)
-    '\u007F': 'u007F', // delete (DEL)
-
-    // Unicode whitespace characters
-    '\u0085': 'u0085', // next line
-    '\u00A0': 'u00A0', // non-breaking space
-    '\u1680': 'u1680', // ogham space mark
-    '\u180E': 'u180E', // mongolian vowel separator
-    '\u2000': 'u2000', // en quad
-    '\u2001': 'u2001', // em quad
-    '\u2002': 'u2002', // en space
-    '\u2003': 'u2003', // em space
-    '\u2004': 'u2004', // three-per-em space
-    '\u2005': 'u2005', // four-per-em space
-    '\u2006': 'u2006', // six-per-em space
-    '\u2007': 'u2007', // figure space
-    '\u2008': 'u2008', // punctuation space
-    '\u2009': 'u2009', // thin space
-    '\u200A': 'u200A', // hair space
-    '\u200B': 'u200B', // zero width space
-    '\u200C': 'u200C', // zero width non-joiner
-    '\u200D': 'u200D', // zero width joiner
-    '\u2028': 'u2028', // line separator
-    '\u2029': 'u2029', // paragraph separator
-    '\u202F': 'u202F', // narrow no-break space
-    '\u205F': 'u205F', // medium mathematical space
-    '\u2060': 'u2060', // word joiner
-    '\u3000': 'u3000', // ideographic space
-    '\uFEFF': 'uFEFF'  // zero width no-break space
-};
-
-
-/**
- * Unescape a string that's been escaped so that it can be used
- * in a firewall rule.
- */
-function tagUnescape(ostr) {
-    var nstr = '';
-    var len = ostr.length;
-
-    for (var cur = 0; cur < len; cur += 1) {
-        var val = ostr[cur];
-        if (val === '\\') {
-            var escaped = ostr[cur + 1];
-            if (escaped === 'u') {
-                nstr += String.fromCharCode(
-                    parseInt(ostr.substring(cur + 2, cur + 6), 16));
-                cur += 5;
-            } else if (escapes[escaped] !== undefined) {
-                nstr += escapes[escaped];
-                cur += 1;
-            } else {
-                throw new Error('Invalid escape sequence "\\' + escaped + '"!');
-            }
-        } else {
-            nstr += val;
-        }
-    }
-
-    return nstr;
-}
-
-
-/**
- * Escape a string so that it can be placed, quoted, into a
- * firewall rule.
- */
-function tagEscape(ostr) {
-    var nstr = '';
-    var len = ostr.length;
-
-    for (var cur = 0; cur < len; cur += 1) {
-        var val = ostr[cur];
-        if (unescapes[val] !== undefined) {
-            nstr += '\\' + unescapes[val];
-        } else {
-            nstr += val;
-        }
-    }
-
-    return nstr;
-}
-
-
-/**
- * Quotes a string in case it contains non-alphanumeric
- * characters or keywords for firewall rules.
- */
-function quote(str) {
-    return '"' + tagEscape(str) + '"';
-}
-
-
-
-// --- Firewall object and methods
-
-
-
-/**
- * Firewall rule constructor
- */
-function FwRule(data, opts) {
-    var errs = [];
-    var parsed;
-
-    if (!opts) {
-        opts = {};
-    }
-
-    // -- validation --
-
-    if (!data.rule && !data.parsed) {
-        errs.push(new validators.InvalidParamError('rule',
-            'No rule specified'));
-    } else {
-        try {
-            parsed = data.parsed || require('./').parse(data.rule, opts);
-        } catch (err) {
-            errs.push(err);
-        }
-    }
-
-    if (hasOwnProperty(data, 'uuid')) {
-        if (!validators.validateUUID(data.uuid)) {
-            errs.push(new validators.InvalidParamError('uuid',
-                'Invalid rule UUID'));
-        }
-
-        this.uuid = data.uuid;
-    } else {
-        this.uuid = mod_uuid.v4();
-    }
-
-    this.version = data.version || generateVersion();
-
-    if (hasOwnProperty(data, 'owner_uuid')) {
-        if (!validators.validateUUID(data.owner_uuid)) {
-            errs.push(new validators.InvalidParamError('owner_uuid',
-                'Invalid owner UUID'));
-        }
-        this.owner_uuid = data.owner_uuid;
-    } else {
-        // No owner: this rule will affect all VMs
-        this.global = true;
-    }
-
-    if (hasOwnProperty(data, 'enabled')) {
-        if (!validators.bool(data.enabled)) {
-            errs.push(new validators.InvalidParamError('enabled',
-                'enabled must be true or false'));
-        }
-
-        this.enabled = data.enabled;
-    } else {
-        this.enabled = false;
-    }
-
-    for (var s in STRING_PROPS) {
-        var str = STRING_PROPS[s];
-        if (hasOwnProperty(data, str)) {
-            try {
-                validators.validateString(str, data[str]);
-                this[str] = data[str];
-            } catch (valErr) {
-                errs.push(valErr);
-            }
-        }
-    }
-
-    if (opts.enforceGlobal) {
-        if (hasOwnProperty(data, 'global') && !validators.bool(data.global)) {
-            errs.push(new validators.InvalidParamError('global',
-                'global must be true or false'));
-        }
-
-        if (hasOwnProperty(data, 'global')
-            && hasOwnProperty(data, 'owner_uuid') && data.global) {
-            errs.push(new validators.InvalidParamError('global',
-                'cannot specify both global and owner_uuid'));
-        }
-
-        if (!hasOwnProperty(data, 'global')
-            && !hasOwnProperty(data, 'owner_uuid')) {
-            errs.push(new validators.InvalidParamError('owner_uuid',
-                'owner_uuid required'));
-        }
-    }
-
-    if (errs.length !== 0) {
-        if (errs.length === 1) {
-            throw errs[0];
-        }
-
-        throw new verror.MultiError(errs);
-    }
-
-    // -- translate into the internal rule format --
-
-    var d;
-    var dir;
-
-    this.action = parsed.action;
-    this.protocol = parsed.protocol.name;
-
-    if (icmpr.test(this.protocol)) {
-        this.types = icmpTypeSort(parsed.protocol.targets);
-        this.protoTargets = this.types;
-    } else {
-        this.ports = parsed.protocol.targets.sort(function (a, b) {
-            var first = hasOwnProperty(a, 'start') ? a.start : a;
-            var second = hasOwnProperty(b, 'start') ? b.start : b;
-            return Number(first) - Number(second);
-        });
-        this.protoTargets = this.ports;
-    }
-
-    if (this.protoTargets.length > MAX_PORTS) {
-        throw new validators.InvalidParamError('rule',
-            'maximum of %d %s allowed',
-            MAX_TARGETS_PER_SIDE,
-            icmpr.test(this.protocol) ? 'types' : 'ports');
-    }
-
-    this.from = {};
-    this.to = {};
-
-    this.allVMs = false;
-    this.ips = {};
-    this.tags = {};
-    this.vms = {};
-    this.subnets = {};
-    this.wildcards = {};
-
-    var dirs = {
-        'to': {},
-        'from': {}
-    };
-    var numTargets;
-
-    for (d in DIRECTIONS) {
-        dir = DIRECTIONS[d];
-        numTargets = 0;
-        for (var j in parsed[dir]) {
-            var target = parsed[dir][j];
-            var targetName;
-            var name = target[0] + 's';
-
-            numTargets++;
-            if (!hasOwnProperty(dirs[dir], name)) {
-                dirs[dir][name] = {};
-            }
-
-            if (name === 'tags') {
-                var targetVal = null;
-                if (typeof (target[1]) === 'string') {
-                    targetName = target[1];
-                } else {
-                    targetName = target[1][0];
-                    targetVal = target[1][1];
-                }
-
-                addTag(this[name], targetName, targetVal);
-                addTag(dirs[dir][name], targetName, targetVal);
-
-            } else {
-                targetName = target[1];
-                this[name][targetName] = target[1];
-                dirs[dir][name][targetName] = target[1];
-            }
-        }
-
-        if (numTargets > MAX_TARGETS_PER_SIDE) {
-            throw new validators.InvalidParamError('rule',
-                'maximum of %d targets allowed per side',
-                MAX_TARGETS_PER_SIDE);
-        }
-    }
-
-    // Now dedup and sort
-    for (d in DIRECTIONS) {
-        dir = DIRECTIONS[d];
-        for (var t in TARGET_TYPES) {
-            var type = TARGET_TYPES[t] + 's';
-            if (hasOwnProperty(dirs[dir], type)) {
-                if (type === 'tags') {
-                    this[dir][type] = tagList(dirs[dir][type]);
-
-                } else {
-                    this[dir][type] = Object.keys(dirs[dir][type]).sort();
-                }
-            } else {
-                this[dir][type] = [];
-            }
-        }
-    }
-
-    this.ips = Object.keys(this.ips).sort();
-    this.tags = tagList(this.tags);
-    this.vms = Object.keys(this.vms).sort();
-    this.subnets = Object.keys(this.subnets).sort();
-    this.wildcards = Object.keys(this.wildcards).sort();
-
-    if (this.wildcards.length !== 0 && this.wildcards.indexOf('vmall') !== -1) {
-        this.allVMs = true;
-    }
-
-    // Check for rules that obviously don't make sense
-    if (this.protocol === 'icmp') {
-        this.ips.map(function (ip) {
-            if (!mod_net.isIPv4(ip)) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv4 but contains a non-IPv4 address');
-            }
-        });
-        this.subnets.map(function (subnet) {
-            if (!mod_net.isIPv4(subnet.split('/')[0])) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv4 but contains a non-IPv4 subnet');
-            }
-        });
-    } else if (this.protocol === 'icmp6') {
-        this.ips.map(function (ip) {
-            if (!mod_net.isIPv6(ip)) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv6 but contains a non-IPv6 address');
-            }
-        });
-        this.subnets.map(function (subnet) {
-            if (!mod_net.isIPv6(subnet.split('/')[0])) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv6 but contains a non-IPv6 subnet');
-            }
-        });
-    }
-
-    // Final check: does this rule actually contain targets that can actually
-    // affect VMs?
-    if (!this.allVMs && this.tags.length === 0 && this.vms.length === 0) {
-        throw new validators.InvalidParamError('rule',
-            'rule does not affect VMs');
-    }
-}
-
-
-/**
- * Returns the internal representation of the rule
- */
-FwRule.prototype.raw = function () {
-    var raw = {
-        action: this.action,
-        enabled: this.enabled,
-        from: this.from,
-        protocol: this.protocol,
-        to: this.to,
-        uuid: this.uuid,
-        version: this.version
-    };
-
-    if (this.owner_uuid) {
-        raw.owner_uuid = this.owner_uuid;
-    }
-
-    if (icmpr.test(this.protocol)) {
-        raw.types = this.types;
-    } else {
-        raw.ports = this.ports;
-    }
-
-    for (var s in STRING_PROPS) {
-        var str = STRING_PROPS[s];
-        if (hasOwnProperty(this, str)) {
-            raw[str] = this[str];
-        }
-    }
-
-    return raw;
-};
-
-
-/**
- * Returns the serialized version of the rule, suitable for storing
- *
- * @param fields {Array}: fields to return (optional)
- */
-FwRule.prototype.serialize = function (fields) {
-    var ser = {};
-    if (!fields) {
-        fields = FIELDS;
-    }
-
-    for (var f in fields) {
-        var field = fields[f];
-        if (field === 'rule') {
-            ser.rule = this.text();
-        } else if (field === 'global') {
-            // Only display the global flag if true
-            if (this.global) {
-                ser.global = true;
-            }
-        } else {
-            if (hasOwnProperty(this, field)) {
-                ser[field] = this[field];
-            }
-        }
-    }
-
-    return ser;
-};
-
-
-/**
- * Returns the text of the rule
- */
-FwRule.prototype.text = function () {
-    var containsRange;
-    var ports;
-    var protoTxt;
-    var targets = {
-        from: [],
-        to: []
-    };
-
-    forEachTarget(this, function (dir, type, _, arr) {
-        for (var i in arr) {
-            var txt;
-            if (type === 'tag') {
-                txt = util.format('%s %s', type,
-                    typeof (arr[i]) === 'string' ? quote(arr[i])
-                    : (quote(arr[i][0]) + ' = ' + quote(arr[i][1])));
-            } else {
-                txt = util.format('%s %s', type, arr[i]);
-            }
-
-            if (type === 'wildcard') {
-                txt = arr[i] === 'vmall' ? 'all vms' : arr[i];
-            }
-            targets[dir].push(txt);
-        }
-    });
-
-    // Protocol-specific text: different for ICMP rather than TCP/UDP
-    if (icmpr.test(this.protocol)) {
-        protoTxt = util.format('%sTYPE %s%s',
-            this.types.length > 1 ? '(' : '',
-            this.types.map(function (type) {
-                return type.toString().split(':');
-            }).map(function (code) {
-                return code[0] + (code.length === 1 ? '' : ' CODE ' + code[1]);
-            }).join(' AND TYPE '),
-            this.types.length > 1 ? ')' : ''
-        );
-    } else {
-        ports = this.ports.map(function (port) {
-            if (hasOwnProperty(port, 'start')
-                && hasOwnProperty(port, 'end')) {
-                /*
-                 * We only output PORTS when we have a range, since we don't
-                 * distinguish PORTS 1, 2 from (PORT 1 AND PORT 2) after
-                 * parsing.
-                 */
-                containsRange = true;
-                return port.start + ' - ' + port.end;
-            } else {
-                return port;
-            }
-        });
-        if (containsRange) {
-            protoTxt = util.format('PORTS %s', ports.join(', '));
-        } else {
-            protoTxt = util.format('%sPORT %s%s',
-                ports.length > 1 ? '(' : '',
-                ports.join(' AND PORT '),
-                ports.length > 1 ? ')' : ''
-            );
-        }
-    }
-
-    return util.format('FROM %s%s%s TO %s%s%s %s %s',
-            targets.from.length > 1 ? '(' : '',
-            targets.from.join(' OR '),
-            targets.from.length > 1 ? ')' : '',
-            targets.to.length > 1 ? '(' : '',
-            targets.to.join(' OR '),
-            targets.to.length > 1 ? ')' : '',
-            this.action.toUpperCase(),
-            this.protocol.toLowerCase(),
-            protoTxt
-    );
-};
-
-
-/**
- * Returns the string representation of the rule
- */
-FwRule.prototype.toString = function () {
-    return util.format('[%s,%s%s] %s', this.uuid, this.enabled,
-            (this.owner_uuid ? ',' + this.owner_uuid : ''),
-            this.text());
-};
-
-
-
-// --- Exported functions
-
-
-
-/**
- * Creates a new firewall rule from the payload
- */
-function createRule(payload, opts) {
-    return new FwRule(payload, opts);
-}
-
-
-function generateVersion() {
-    return Date.now(0) + '.' + sprintf('%06d', process.pid);
-}
-
-module.exports = {
-    create: createRule,
-    generateVersion: generateVersion,
-    tagEscape: tagEscape,
-    tagUnescape: tagUnescape,
-    DIRECTIONS: DIRECTIONS,
-    FIELDS: FIELDS,
-    FwRule: FwRule,
-    TARGET_TYPES: TARGET_TYPES
-};
diff --git a/src/fw/tools/fwrule/lib/validators.js b/src/fw/tools/fwrule/lib/validators.js
deleted file mode 100644
index 651df743..00000000
--- a/src/fw/tools/fwrule/lib/validators.js
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- */
-
-/*
- * firewall rule parser: validation functions
- */
-
-'use strict';
-
-var net = require('net');
-var util = require('util');
-var VError = require('verror').VError;
-
-
-
-// --- Globals
-
-
-
-var icmpr = /^icmp6?$/;
-var portRE = /^[0-9]{1,5}$/;
-var UUID_REGEX =
-    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
-
-
-
-// --- Exports
-
-
-
-/**
- * Constructor for an invalid parameter error
- */
-function InvalidParamError(field) {
-    VError.apply(this, Array.prototype.slice.call(arguments, 1));
-    this.field = field;
-}
-
-util.inherits(InvalidParamError, VError);
-
-
-/**
- * Returns true if ip is a valid IPv4 address, and not all zeroes or
- * the broadcast address
- */
-function validateIPv4address(ip) {
-    if (!net.isIPv4(ip) || (ip === '255.255.255.255') || (ip === '0.0.0.0')) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if subnet is in valid CIDR form
- */
-function validateIPv4subnet(subnet) {
-    var parts = subnet.split('/');
-    if (!validateIPv4address(parts[0])) {
-        return false;
-    }
-
-    if (!Number(parts[1]) || (parts[1] < 1) || (parts[1] > 32)) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if subnet is a valid IPv6 CIDR range
- */
-function validateIPv6subnet(subnet) {
-    var parts = subnet.split('/');
-    var plen = Number(parts[1]);
-    if (!net.isIPv6(parts[0])) {
-        return false;
-    }
-
-    if (!plen || (plen < 1) || (plen > 128)) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if port is a valid port number
- */
-function validatePort(port) {
-    if (!portRE.exec(port)) {
-        return false;
-    }
-
-    var portNum = Number(port);
-
-    if (isNaN(portNum) || portNum > 65535 || portNum < 1) {
-        return false;
-    }
-
-    return true;
-}
-
-/**
- * Returns true if port is a valid port number or 'all'
- */
-function validatePortOrAll(port) {
-    if (validatePort(port)) {
-        return true;
-    }
-
-    if (typeof (port) !== 'string') {
-        return false;
-    }
-
-    if (port.toLowerCase() === 'all') {
-        return true;
-    }
-
-    return false;
-}
-
-/**
- * Returns true if protocol is one of tcp, udp, icmp (mixing of upper
- * and lower-case allowed)
- */
-function validateProtocol(protocol) {
-    if (typeof (protocol) !== 'string') {
-        return false;
-    }
-
-    var protoLC = protocol.toLowerCase();
-    return ((protoLC === 'tcp') || (protoLC === 'udp') || icmpr.test(protoLC));
-}
-
-
-/**
- * Returns true if action is a valid firewall action ('allow' or 'block',
- * mixed case allowed)
- */
-function validateAction(action) {
-    if (typeof (action) !== 'string') {
-        return false;
-    }
-
-    var actionLC = action.toLowerCase();
-    return ((actionLC === 'allow') || (actionLC === 'block'));
-}
-
-
-/**
- * Returns true if bool is a valid boolean value, false otherwise
- */
-function validateBoolean(bool) {
-    if (typeof (bool) !== 'boolean' && bool !== 'true' && bool !== 'false') {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Throws an InvalidParamError if the string is invalid
- */
-function validateString(name, str) {
-    if (typeof (str) !== 'string') {
-        throw new InvalidParamError(name, name + ' must be a string');
-    }
-
-    if (str.length > 255) {
-        throw new InvalidParamError(name,
-            name + ' must be shorter than 255 characters');
-    }
-}
-
-
-/**
- * Returns true if uuid is a valid UUID
- */
-function validateUUID(uuid) {
-    return UUID_REGEX.test(uuid);
-}
-
-
-module.exports = {
-    bool: validateBoolean,
-    InvalidParamError: InvalidParamError,
-    validateAction: validateAction,
-    validateIPv4address: validateIPv4address,
-    validateIPv4subnet: validateIPv4subnet,
-    validateIPv6subnet: validateIPv6subnet,
-    validatePort: validatePort,
-    validatePortOrAll: validatePortOrAll,
-    validateProtocol: validateProtocol,
-    validateString: validateString,
-    validateUUID: validateUUID
-};
diff --git a/src/fw/tools/fwrule/package.json b/src/fw/tools/fwrule/package.json
deleted file mode 100644
index e3660f40..00000000
--- a/src/fw/tools/fwrule/package.json
+++ /dev/null
@@ -1,33 +0,0 @@
-{
-  "name": "fwrule",
-  "description": "Parser for Joyent firewall rules",
-  "version": "1.3.1",
-  "author": "Joyent (joyent.com)",
-  "keywords": [ "smartos", "triton" ],
-  "repository": {
-    "type": "git",
-    "url": "git://github.com/joyent/sdc-fwrule.git"
-  },
-  "dependencies": {
-    "node-uuid": "1.2.0",
-    "extsprintf": "1.0.1",
-    "verror": "1.3.4"
-  },
-  "devDependencies": {
-    "eslint": "2.13.1",
-    "eslint-plugin-joyent": "1.0.1",
-    "faucet": "0.0.1",
-    "istanbul": "^0.4.0",
-    "jison": "0.4.2",
-    "tape": "^4.2.2",
-    "ramsey": "0.1.2"
-  },
-  "engines": {
-    "node": ">=0.10"
-  },
-  "main": "lib/index.js",
-  "scripts": {
-    "test": "make test"
-  },
-  "license": "CDDL-1.0"
-}
diff --git a/src/fw/tools/fwrule/src/fwrule.jison b/src/fw/tools/fwrule/src/fwrule.jison
deleted file mode 100644
index cc6140ae..00000000
--- a/src/fw/tools/fwrule/src/fwrule.jison
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser grammar
- */
-
-%lex
-
-digit                   [0-9]
-hex                     [0-9a-f]
-t                       {digit}{1,3}
-
-%%
-
-\s+                     /* skip whitespace */
-<<EOF>>                 return 'EOF';
-
-"FROM"                  return 'FROM';
-"from"                  return 'FROM';
-"TO"                    return 'TO';
-"to"                    return 'TO';
-
-"IP"                    return 'IP';
-"ip"                    return 'IP';
-"SUBNET"                return 'SUBNET';
-"subnet"                return 'SUBNET';
-"ANY"                   return 'ANY';
-"any"                   return 'ANY';
-"ALL"                   return 'ALL';
-"all"                   return 'ALL';
-"TAG"                   return 'TAG';
-"tag"                   return 'TAG';
-"VM"                    return 'VM';
-"vm"                    return 'VM';
-"VMS"                   return 'VMS';
-"vms"                   return 'VMS';
-
-'-'                     return '-';
-','                     return ',';
-'='                     return '=';
-'('                     return '(';
-')'                     return ')';
-"OR"                    return 'OR';
-"or"                    return 'OR';
-"AND"                   return 'AND';
-"and"                   return 'AND';
-
-"BLOCK"                 return 'BLOCK';
-"block"                 return 'BLOCK';
-"ALLOW"                 return 'ALLOW';
-"allow"                 return 'ALLOW';
-"PORT"                  return 'PORT';
-"port"                  return 'PORT';
-"PORTS"                 return 'PORTS';
-"ports"                 return 'PORTS';
-"TCP"                   return 'TCP';
-"tcp"                   return 'TCP';
-"UDP"                   return 'UDP';
-"udp"                   return 'UDP';
-"ICMP"                  return 'ICMP';
-"icmp"                  return 'ICMP';
-"ICMP6"                 return 'ICMP6';
-"icmp6"                 return 'ICMP6';
-"TYPE"                  return 'TYPE';
-"type"                  return 'TYPE';
-"CODE"                  return 'CODE';
-"code"                  return 'CODE';
-
-\"(?:\\["bfnrt/()\\]|\\"u"[a-fA-F0-9]{4}|[^"\\])*\"  yytext = yy.tagUnescape(yytext.substr(1,yyleng-2)); return 'STRING';
-{t}'.'{t}'.'{t}'.'{t}          return 'IPV4ADDR';
-{hex}*':'{hex}*':'[:0-9a-f]*   return 'IPV6ADDR';
-'/'{digit}{1,3}                return 'CIDRSUFFIX';
-
-[-a-zA-Z0-9_]+          return 'WORD'
-
-/lex
-
-%%      /* Language grammar */
-
-start
-    : FROM target_list TO target_list action protocol EOF
-        { return { 'from': $2, 'to': $4, 'action': $5, 'protocol': $6 }; }
-    ;
-
-
-/* List of targets for 'FROM' and 'TO' */
-target_list
-    : any
-    | all
-    | '(' target_or_list ')'
-        {$$ = $2;}
-    | target
-    ;
-
-target_or_list
-    : target
-    | target_or_list 'OR' target
-        { $$ = $1.concat($3); }
-    ;
-
-target
-    : ipv4
-    | ipv4_subnet
-    | ipv6
-    | ipv6_subnet
-    | tag
-    | vm
-    ;
-
-
-/* Targets for 'FROM' and 'TO' */
-all
-    : ALL VMS
-        { $$ = [ ['wildcard', 'vmall'] ]; }
-    | '(' ALL VMS ')'
-        { $$ = [ ['wildcard', 'vmall'] ]; }
-    ;
-
-any
-    : ANY
-        { $$ = [ ['wildcard', 'any'] ]; }
-    | '(' ANY ')'
-        { $$ = [ ['wildcard', 'any'] ]; }
-    ;
-
-ipv4
-    : IP IPV4ADDR
-        { yy.validateIPv4address($2);
-          $$ = [ ['ip', $2] ]; }
-    ;
-
-ipv4_subnet
-    : SUBNET IPV4ADDR CIDRSUFFIX
-        { yy.validateIPv4subnet($2 + $3);
-            $$ = [ ['subnet', $2 + $3] ]; }
-    ;
-
-ipv6
-    : IP IPV6ADDR
-        { yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6address($2);
-          $$ = [ ['ip', $2] ]; }
-    ;
-
-ipv6_subnet
-    : SUBNET IPV6ADDR CIDRSUFFIX
-        { yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($2 + $3);
-            $$ = [ ['subnet', $2 + $3] ]; }
-    ;
-
-vm
-    : VM uuid
-        { $$ = [ ['vm', $2] ]; }
-    ;
-
-uuid
-    : WORD
-        { yy.validateUUID($1);
-          $$ = $1; }
-    ;
-
-tag
-    : TAG tag_string
-        { $$ = [ ['tag', $2] ]; }
-    | TAG tag_string '=' tag_string
-        { $$ = [ ['tag', [ $2, $4 ] ] ]; }
-    ;
-
-tag_string
-    : STRING
-        { $$ = yytext; }
-    | WORD
-        { $$ = $1; }
-    ;
-
-action
-    : BLOCK
-        { $$ = $1.toLowerCase() }
-    | ALLOW
-        { $$ = $1.toLowerCase() }
-    ;
-
-
-protocol
-    : TCP port_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | TCP ports
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | UDP port_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | UDP ports
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | ICMP type_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | ICMP6 type_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    ;
-
-
-/* TCP / UDP port list */
-port_list
-    : '(' port_and_list ')'
-        { $$ = $2; }
-    | port
-    | '(' port_all ')'
-        { $$ = $2; }
-    | port_all
-    ;
-
-port_and_list
-    : port
-    | port_and_list AND port
-        { $$ = $1.concat(Number($3)); }
-    ;
-
-port
-    : PORT portnumber
-        { $$ = [ $2 ]; }
-    ;
-
-ports
-    : PORTS portnumbers
-        { yy.validateOKVersion(2, 'port ranges');
-          $$ = $2; }
-    ;
-
-port_all
-    : PORT ALL
-        { $$ = [ 'all' ]; }
-    ;
-
-portnumber
-    : WORD
-        { yy.validatePortNumber($1);
-          $$ = Number($1); }
-    ;
-
-portrange
-    : WORD
-        { $$ = [ yy.createMaybePortRange($1) ]; }
-    | WORD '-' WORD
-        { yy.validatePortNumber($1);
-          yy.validatePortNumber($3);
-          yy.validateRangeOrder($1, $3);
-          $$ = [{ 'start': Number($1), 'end': Number($3) }]; }
-    ;
-
-portnumbers
-    : portrange
-    | portnumbers ',' portrange
-        { $$ = $1.concat($3); }
-    ;
-
-type_list
-    : '(' type_and_list ')'
-        { $$ = $2; }
-    | type
-    | '(' type_all ')'
-        { $$ = $2; }
-    | type_all
-    ;
-
-type_and_list
-    : type
-    | type_and_list AND type
-        { $$ = $1.concat($3); }
-    ;
-
-type
-    : TYPE icmptype CODE icmpcode
-        { $$ = [ $2 + ':' + $4 ]; }
-    | TYPE icmptype
-        { $$ = [ $2 ]; }
-    ;
-
-type_all
-    : TYPE ALL
-        { yy.validateOKVersion(3, 'all ICMP types');
-          $$ = [ 'all' ]; }
-    ;
-
-icmptype
-    : WORD
-        { yy.validateICMPtype($1);
-          $$ = Number($1); }
-    ;
-
-icmpcode
-    : WORD
-        { yy.validateICMPcode($1);
-          $$ = Number($1); }
-    ;
diff --git a/src/fw/tools/fwrule/src/header.js b/src/fw/tools/fwrule/src/header.js
deleted file mode 100644
index c7e8f7a3..00000000
--- a/src/fw/tools/fwrule/src/header.js
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser
- */
-
-
diff --git a/src/fw/tools/fwrule/test/invalid.test.js b/src/fw/tools/fwrule/test/invalid.test.js
deleted file mode 100644
index 379899c8..00000000
--- a/src/fw/tools/fwrule/test/invalid.test.js
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Negative unit tests for the firewall rule object
- */
-
-'use strict';
-
-var fwrule = require('../lib/index');
-var test = require('tape');
-
-
-function longStr() {
-    var str = '';
-    for (var i = 0; i < 256; i++) {
-        str += '0';
-    }
-
-    return str;
-}
-
-
-function nIPs(n) {
-    var ips = [];
-    for (var i = 0; i < n; i++) {
-        ips.push('10.0.0.' + i);
-    }
-
-    return '( ip ' + ips.join(' OR ip ') + ' )';
-}
-
-
-function nPorts(n) {
-    var ports = [];
-    for (var i = 0; i < n; i++) {
-        ports.push('1' + i);
-    }
-
-    return '( port ' + ports.join(' AND port ') + ' )';
-}
-
-
-function nTypes(n) {
-    var types = [];
-    for (var i = 0; i < n; i++) {
-        types.push(i.toString());
-    }
-
-    return '( type ' + types.join(' AND type ') + ' )';
-}
-
-
-
-var VALID_RULE = 'FROM ip 10.0.0.1 TO all vms ALLOW TCP port 53';
-var INVALID = [
-    [ 'invalid IP: too many numbers',
-        {
-            rule: 'FROM ip 10.99.99.99.254 TO tag smartdc_role ALLOW tcp '
-                + 'port 22' },
-            'rule', 'Error at character 19: \'.254 TO tag smartdc_\', '
-                            + 'found: unexpected text'],
-
-    [ 'invalid UUID',
-        { uuid: 'invalid',
-            rule: 'FROM tag foo TO ip 8.8.8.8 ALLOW udp port 53'
-        }, 'uuid', 'Invalid rule UUID' ],
-
-    [ 'invalid owner UUID',
-        { owner_uuid: 'invalid',
-            rule: 'FROM tag foo TO ip 8.8.8.8 ALLOW udp port 53'
-        }, 'owner_uuid', 'Invalid owner UUID' ],
-
-    [ 'non-target type in FROM',
-        { rule: 'FROM foo TO ip 8.8.8.8 ALLOW udp port 53' },
-        'rule', 'Error at character 4: \'foo\', '
-                        + 'expected: \'(\', \'all\', \'any\', \'ip\', '
-                        + '\'subnet\', \'vm\', \'tag\', found: word'],
-
-    [ 'invalid IPv4',
-        { rule: 'FROM tag foo TO ip 10.288.0.0 ALLOW udp port 53' },
-        'rule', 'IPv4 address "10.288.0.0" is invalid' ],
-
-    [ 'invalid IPv6',
-        { rule: 'FROM tag foo TO ip fd00::12345 ALLOW udp port 53' },
-        'rule', 'IPv6 address "fd00::12345" is invalid' ],
-
-    [ 'invalid IPv4 subnet: bad address component',
-        { rule: 'FROM tag foo TO subnet 10.350.0.0/24 ALLOW udp port 53' },
-        'rule', 'Subnet "10.350.0.0/24" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv4 subnet: bad prefix length',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/33 ALLOW udp port 53' },
-        'rule', 'Subnet "10.8.0.0/33" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv6 subnet: bad address component',
-        { rule: 'FROM tag foo TO subnet fd005::/64 ALLOW udp port 53' },
-        'rule', 'Subnet "fd005::/64" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv6 subnet: bad prefix length',
-        { rule: 'FROM tag foo TO subnet fd00::/130 ALLOW udp port 53' },
-        'rule', 'Subnet "fd00::/130" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid port: too small',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW udp port 0' },
-        'rule', 'Port number "0" is invalid' ],
-
-    [ 'invalid port: too big',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW udp port 65537' },
-        'rule', 'Port number "65537" is invalid' ],
-
-    [ 'invalid port range: too many numbers',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 1-20-30' },
-        'rule', '"1-20-30" is not a valid port number or range' ],
-
-    [ 'invalid port range: too small',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 0-20' },
-        'rule', 'Port number "0" is invalid' ],
-
-    [ 'invalid port range: too big',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20-65537' },
-        'rule', 'Port number "65537" is invalid' ],
-
-    [ 'invalid port range: not a port (at end)',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20-bar' },
-        'rule', 'Port number "bar" is invalid' ],
-
-    [ 'invalid port range: not a port (at beginning)',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports bar-20' },
-        'rule', 'Port number "bar" is invalid' ],
-
-    [ 'invalid port range: incorrect range ordering',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20 - 10' },
-        'rule',
-        'The end of the range (10) cannot be less than the start (20)' ],
-
-    [ 'invalid VM UUID',
-        { rule: 'FROM vm asdf TO subnet 10.8.0.0/24 ALLOW udp port 50' },
-        'rule', 'UUID "asdf" is invalid'],
-
-    [ 'all vms with other targets on FROM side',
-        { rule: 'FROM (all vms OR tag one) TO ip 10.0.0.1 ALLOW udp port 53' },
-        'rule', 'Error at character 13: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'all vms with other targets on TO side',
-        { rule: 'FROM tag one TO (all vms OR tag two) ALLOW udp port 53' },
-        'rule', 'Error at character 24: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'any with other targets on FROM side',
-        { rule: 'FROM (any OR tag one) TO ip 10.0.0.1 ALLOW udp port 53' },
-        'rule', 'Error at character 9: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'any with other targets on TO side',
-        { rule: 'FROM ip 10.0.0.1 TO (any OR tag one) ALLOW udp port 53' },
-        'rule', 'Error at character 24: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'other ports listed with ALL first', {
-        rule: 'FROM ip 10.0.0.1 TO all vms ALLOW TCP (port ALL AND port 53)' },
-        'rule',
-        'Error at character 47: \'AND\', expected: \'EOF\', \')\', found: AND'
-    ],
-
-    [ 'other ports listed with ALL second', {
-        rule: 'FROM ip 10.0.0.1 TO all vms ALLOW TCP (port 53 AND port ALL)'
-        }, 'rule',
-        'Error at character 55: \'ALL\', expected: \'WORD\', found: ALL' ],
-
-    [ 'created_by: object instead of string', {
-        created_by: { },
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: array instead of string', {
-        created_by: ['asdf'],
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: number instead of string', {
-        created_by: 42,
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: string too long', {
-        created_by: longStr(),
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be shorter than 255 characters'],
-
-    [ 'description: object instead of string', {
-        description: { },
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: array instead of string', {
-        description: ['asdf'],
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: number instead of string', {
-        description: 42,
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: string too long', {
-        description: longStr(),
-        rule: VALID_RULE
-        }, 'description',
-        'description must be shorter than 255 characters'],
-
-    [ 'rule: from any to any', {
-        rule: 'FROM any TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from any to any', {
-        rule: 'FROM any TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from ip to subnet', {
-        rule: 'FROM ip 10.8.0.1 TO subnet 10.9.0.0/16 ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from ip to any', {
-        rule: 'FROM ip 10.9.0.1 TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'global: not boolean', {
-        rule: VALID_RULE,
-        global: 'asdf'
-        }, 'global',
-        'global must be true or false'],
-
-    [ 'both global and owner_uuid set', {
-        rule: VALID_RULE,
-        global: true,
-        owner_uuid: 'e7d9d022-6272-11e3-a746-131978000f45'
-        }, 'global',
-        'cannot specify both global and owner_uuid'],
-
-    [ 'rule: max number per side', {
-        rule: 'FROM ' + nIPs(25) + ' TO all vms ALLOW TCP port 53'
-        }, 'rule',
-        'maximum of 24 targets allowed per side'],
-
-    [ 'rule: max number per side', {
-        rule: 'FROM all vms TO ' + nIPs(25) + ' BLOCK TCP port 53'
-        }, 'rule',
-        'maximum of 24 targets allowed per side'],
-
-    [ 'rule: max number of ports', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK TCP ' + nPorts(9)
-        }, 'rule',
-        'maximum of 24 ports allowed'],
-
-    [ 'rule: bad ip target for ICMPv4', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP TYPE 8'
-        }, 'rule',
-        'rule affects ICMPv4 but contains a non-IPv4 address'],
-
-    [ 'rule: bad subnet target for ICMPv4', {
-        rule: 'FROM all vms TO subnet fe80::/64 BLOCK ICMP TYPE 8'
-        }, 'rule',
-        'rule affects ICMPv4 but contains a non-IPv4 subnet'],
-
-    [ 'rule: bad ip target for ICMPv6', {
-        rule: 'FROM all vms TO ip 1.2.3.4 BLOCK ICMP6 TYPE 128'
-        }, 'rule',
-        'rule affects ICMPv6 but contains a non-IPv6 address'],
-
-    [ 'rule: bad subnet target for ICMPv6', {
-        rule: 'FROM all vms TO subnet 10.0.0.0/8 BLOCK ICMP6 TYPE 128'
-        }, 'rule',
-        'rule affects ICMPv6 but contains a non-IPv6 subnet'],
-
-    [ 'rule: bad ICMP type', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP TYPE 260'
-        }, 'rule',
-        'ICMP type \"260\" is invalid'],
-
-    [ 'rule: bad ICMP code', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP TYPE 8 CODE 270'
-        }, 'rule',
-        'ICMP code \"270\" is invalid'],
-
-    [ 'rule: bad ICMPv6 type', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP6 TYPE 260'
-        }, 'rule',
-        'ICMP type \"260\" is invalid'],
-
-    [ 'rule: bad ICMPv6 code', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP6 TYPE 128 CODE 270'
-        }, 'rule',
-        'ICMP code \"270\" is invalid'],
-
-    [ 'rule: max number of ICMPv6 types', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP ' + nTypes(9)
-        }, 'rule',
-        'maximum of 24 types allowed'],
-
-    [ 'rule: max number of ICMP types', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP ' + nTypes(9)
-        }, 'rule',
-        'maximum of 24 types allowed']
-];
-
-
-test('Invalid rules', function (t) {
-    INVALID.forEach(function (data) {
-        var testName = data[0];
-        var expMsg = data[3];
-        var field = data[2];
-        var opts;
-        var rule = data[1];
-        var thrown = false;
-
-        try {
-            opts = (field === 'global' ? { enforceGlobal: true } : {});
-            fwrule.create(rule, opts);
-        } catch (err) {
-            thrown = true;
-            t.equal(err.message, expMsg, 'Error message correct: ' + testName);
-            t.equal(err.field, field, 'Error field correct: ' + testName);
-        }
-
-        t.ok(thrown, 'Error thrown: ' + testName);
-    });
-
-    t.end();
-});
-
-
-test('Invalid parameters', function (t) {
-    var thrown = false;
-    var invalid = {
-        enabled: 'invalid',
-        rule: 'invalid',
-        owner_uuid: 'invalid',
-        uuid: 'invalid'
-    };
-
-    try {
-        fwrule.create(invalid);
-    } catch (err) {
-        thrown = true;
-
-        t.ok(err.hasOwnProperty('ase_errors'), 'multiple errors');
-        if (err.hasOwnProperty('ase_errors')) {
-            t.equal(err.ase_errors.length, 4, '4 sub-errors');
-            t.deepEqual(err.ase_errors.map(function (e) {
-                return [ e.field, e.message ];
-            }), [
-                ['rule', 'Error at character 0: \'invalid\', '
-                    + 'expected: \'FROM\', found: word'],
-                ['uuid', 'Invalid rule UUID'],
-                ['owner_uuid', 'Invalid owner UUID'],
-                ['enabled', 'enabled must be true or false']
-            ], 'sub-errors');
-        }
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
-
-
-test('Missing rule field', function (t) {
-    var thrown = false;
-
-    try {
-        fwrule.create({});
-    } catch (err) {
-        thrown = true;
-        t.equal(err.message, 'No rule specified', 'error message');
-        t.equal(err.field, 'rule', 'err.field');
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
-
-
-test('global and owner_uuid not set', function (t) {
-    var thrown = false;
-
-    try {
-        fwrule.create({
-            rule: 'FROM any to all vms ALLOW tcp port 80'
-        }, { enforceGlobal: true });
-    } catch (err) {
-        thrown = true;
-        t.equal(err.message, 'owner_uuid required', 'error message');
-        t.equal(err.field, 'owner_uuid', 'err.field');
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
diff --git a/src/fw/tools/fwrule/test/parser.test.js b/src/fw/tools/fwrule/test/parser.test.js
deleted file mode 100644
index 55373eb6..00000000
--- a/src/fw/tools/fwrule/test/parser.test.js
+++ /dev/null
@@ -1,602 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Unit tests for the firewall rule parser
- */
-
-'use strict';
-
-var util = require('util');
-var parser = require('../lib/index');
-var test = require('tape');
-
-
-// --- Helpers
-
-function checkInvalidRules(t, toCheck) {
-    toCheck.forEach(function (rule) {
-        try {
-            parser.parse(rule);
-            t.fail('Parsing bad rule didn\'t fail: ' + rule);
-        } catch (err) {
-            t.ok(err.message, 'Failed to parse bad rule: ' + rule);
-        }
-    });
-
-    t.end();
-}
-
-
-// --- Tests
-
-
-test('empty input', function (t) {
-    try {
-        parser.parse('');
-        t.ok(false, 'Empty input to the parser should throw!');
-    } catch (err) {
-        t.deepEqual(err.message,
-            'Error at character 0: \'\', expected: \'FROM\', '
-            + 'found: empty string');
-    }
-    t.end();
-});
-
-
-test('tags', function (t) {
-    t.deepEqual(parser.parse(
-        'FROM ip 1.2.3.4 TO tag some-tag ALLOW tcp PORT 80'),
-        { from: [ [ 'ip', '1.2.3.4' ] ],
-            to: [ [ 'tag', 'some-tag' ] ],
-            action: 'allow',
-            protocol: {
-                name: 'tcp',
-                targets: [ 80 ]
-            }
-        }, 'tag containing dashes');
-
-    t.end();
-});
-
-
-test('icmp', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 8 ]
-            }
-        }, 'icmp with type');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8 code 0', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ '8:0' ]
-            }
-        }, 'icmp with type and code');
-
-    t.end();
-});
-
-
-test('case insensitivity', function (t) {
-    var vm = 'b5ff85db-fc33-4471-b045-5688cb7fa6a8';
-    var ipToTag = {
-        from: [ [ 'ip', '1.2.3.4' ] ],
-        to: [ [ 'tag', 'some-tag' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'tcp',
-            targets: [ 80 ]
-        }
-    };
-
-    var anyToVM = {
-        from: [ [ 'wildcard', 'any' ] ],
-        to: [ [ 'vm', vm ] ],
-        action: 'allow',
-        protocol: {
-            name: 'udp',
-            targets: [ 50 ]
-        }
-    };
-
-    var subnetToAll = {
-        from: [ [ 'subnet', '10.8.0.0/16' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'icmp',
-            targets: [ 30 ]
-        }
-    };
-
-    var ipTag = {
-        from: [ [ 'subnet', '10.8.0.0/16' ],
-                        [ 'ip', '10.9.0.1' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'icmp',
-            targets: [ '8:0', 9 ]
-        }
-    };
-
-    [
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 80', ipToTag ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP ports 80', ipToTag ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORT 80', ipToTag ],
-        [ 'from ip 1.2.3.4 to tag some-tag allow tcp port 80', ipToTag ],
-        [ util.format('from ANY to VM %s allow UDP ports 50', vm), anyToVM ],
-        [ util.format('from any to vm %s allow udp ports 50', vm), anyToVM ],
-        [ util.format('from ANY to VM %s allow UDP port 50', vm), anyToVM ],
-        [ util.format('from any to vm %s allow udp port 50', vm), anyToVM ],
-        [ 'FROM SUBNET 10.8.0.0/16 TO ALL VMS ALLOW ICMP TYPE 30',
-            subnetToAll ],
-        [ 'FROM subnet 10.8.0.0/16 TO all vms ALLOW icmp type 30',
-            subnetToAll ],
-        [ 'FROM (subnet 10.8.0.0/16 OR ip 10.9.0.1) TO all vms ALLOW '
-            + 'icmp (TYPE 8 CODE 0 AND TYPE 9)', ipTag ],
-        [ 'FROM (subnet 10.8.0.0/16 OR ip 10.9.0.1) TO all vms ALLOW '
-            + 'icmp (type 8 code 0 and type 9)', ipTag ]
-
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err, data[0]);
-        }
-    });
-
-    t.end();
-});
-
-
-test('parentheses around wildcards', function (t) {
-    var anyToAll = {
-        from: [ [ 'wildcard', 'any' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'udp',
-            targets: [ 50 ]
-        }
-    };
-
-    [
-        [ 'from (ANY) to ALL VMS allow UDP ports 50', anyToAll ],
-        [ 'from (any) to all vms allow udp ports 50', anyToAll ],
-        [ 'from ANY to (ALL VMS) allow UDP ports 50', anyToAll ],
-        [ 'from any to (all vms) allow udp ports 50', anyToAll ],
-        [ 'FROM ( ANY ) TO ALL VMS ALLOW UDP ports 50', anyToAll ],
-        [ 'FROM ( ANY ) TO all vms ALLOW udp ports 50', anyToAll ],
-        [ 'from ANY to ( ALL VMS ) allow UDP ports 50', anyToAll ],
-        [ 'from any to ( all vms ) allow udp ports 50', anyToAll ],
-        [ 'from ( any ) to ( all vms ) allow udp ports 50', anyToAll ],
-        [ 'from (any) to (all vms) allow udp ports 50', anyToAll ]
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err, data[0]);
-        }
-    });
-
-    t.end();
-});
-
-
-test('incomplete rule text', function (t) {
-    var check = [ ];
-
-    var to = [ 'TO' ];
-    var targets = [
-        'any', 'all vms', 'ip 1.2.3.4', 'ip fd00::1', 'subnet 1.2.3.0/24',
-        'subnet fd00::/64', 'tag foo', 'tag foo = bar',
-        'vm ca3eb1d6-1555-44fb-ea1a-ab66f4685214'
-    ];
-    var endings = [ 'port', 'ports', 'ports 1 -', 'ports 1-', 'type',
-        'type 128 code' ];
-
-    function buildStr(str, remains) {
-        check.push(str);
-
-        if (remains[0] !== undefined) {
-            remains[0].forEach(function (strB) {
-                buildStr(str + ' ' + strB, remains.slice(1));
-            });
-        }
-    }
-
-    buildStr('FROM',
-        [ targets, to, targets, parser.ACTIONS, parser.PROTOCOLS, endings ]);
-
-    checkInvalidRules(t, check);
-});
-
-
-test('Invalid: Logical operations', function (t) {
-    checkInvalidRules(t, [
-        'FROM (tag a foo tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a xor tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a nand tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a not tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a nor tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a xnor tag b) TO any ALLOW tcp PORT 80'
-    ]);
-});
-
-
-test('Invalid: Actions', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any DENY tcp PORT 80',
-        'FROM any TO any FORWARD tcp PORT 80',
-        'FROM any TO any OBSTRUCT tcp PORT 80',
-        'FROM any TO any PASS tcp PORT 80',
-        'FROM any TO any PASSTHROUGH tcp PORT 80',
-        'FROM any TO any PERMIT tcp PORT 80'
-    ]);
-});
-
-
-test('Invalid: Protocols', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW foo PORT 80',
-        'FROM any TO any ALLOW bar PORT 80',
-        'FROM any TO any ALLOW ftp PORT 80',
-        'FROM any TO any ALLOW ssh PORT 80',
-        'FROM any TO any ALLOW http PORT 80',
-        'FROM any TO any ALLOW sctp PORT 80',
-        'FROM any TO any ALLOW dccp PORT 80',
-        'FROM any TO any ALLOW mtcp PORT 80'
-    ]);
-});
-
-test('Invalid: Parameters for TCP & UDP', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW tcp PORT hello',
-        'FROM any TO any ALLOW udp PORT hello',
-        'FROM any TO any ALLOW tcp PORT ssh',
-        'FROM any TO any ALLOW udp PORT ssh',
-        'FROM any TO any ALLOW tcp PORT _',
-        'FROM any TO any ALLOW udp PORT _',
-        'FROM any TO any ALLOW tcp PORT *',
-        'FROM any TO any ALLOW udp PORT *',
-        'FROM any TO any ALLOW tcp PORTS hello',
-        'FROM any TO any ALLOW udp PORTS hello',
-        'FROM any TO any ALLOW tcp PORTS ssh',
-        'FROM any TO any ALLOW udp PORTS ssh',
-        'FROM any TO any ALLOW tcp PORTS ssh-http',
-        'FROM any TO any ALLOW udp PORTS ssh-http',
-        'FROM any TO any ALLOW tcp PORTS _',
-        'FROM any TO any ALLOW udp PORTS _',
-        'FROM any TO any ALLOW tcp PORTS *',
-        'FROM any TO any ALLOW udp PORTS *',
-        'FROM any TO any ALLOW tcp TYPE 128',
-        'FROM any TO any ALLOW udp TYPE 128',
-        'FROM any TO any ALLOW tcp TYPE 128 CODE 0',
-        'FROM any TO any ALLOW udp TYPE 128 CODE 0'
-    ]);
-});
-
-test('Invalid: Parameters for ICMP(6)', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW icmp PORT 80',
-        'FROM any TO any ALLOW icmp6 PORT 80',
-        'FROM any TO any ALLOW icmp PORTS 80',
-        'FROM any TO any ALLOW icmp6 PORTS 80',
-        'FROM any TO any ALLOW icmp PORTS 80-85',
-        'FROM any TO any ALLOW icmp6 PORTS 80-85',
-        'FROM any TO any ALLOW icmp TYPE foo',
-        'FROM any TO any ALLOW icmp6 TYPE foo',
-        'FROM any TO any ALLOW icmp TYPE *',
-        'FROM any TO any ALLOW icmp6 TYPE *',
-        'FROM any TO any ALLOW icmp TYPE 1:0',
-        'FROM any TO any ALLOW icmp6 TYPE 1:0',
-        'FROM any TO any ALLOW icmp 1:0',
-        'FROM any TO any ALLOW icmp6 1:0',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE foo',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE foo',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE *',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE *',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE _',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE _'
-    ]);
-});
-
-
-test('port ranges', function (t) {
-    var rangeA = {
-        from: [ [ 'ip', '1.2.3.4' ] ],
-        to: [ [ 'tag', 'some-tag' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'tcp',
-            targets: [ { start: 20, end: 40 } ]
-        }
-    };
-
-    [
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 20-40', rangeA ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 20 - 40', rangeA ]
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err);
-        }
-    });
-    t.end();
-});
-
-
-test('version mismatch', function (t) {
-    try {
-        parser.parse('FROM tag foo TO tag bar ALLOW TCP PORTS 20-30',
-            { maxVersion: 1 });
-        t.ok(false,
-            'Using port ranges is a newer feature and should fail in v1');
-    } catch (err) {
-        t.deepEqual(err.message,
-            'The rule uses a feature (port ranges) newer than this API allows',
-            'Correct error message for using ports in version 1');
-    }
-    t.end();
-});
-
-
-test('icmp with code', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-    var ruleTxt = util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8 '
-        + 'code 0', vm);
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ '8:0' ]
-            }
-        }, 'icmp with type');
-
-    t.end();
-});
-
-
-test('icmp type all', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type all', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 'all' ]
-            }
-        }, 'icmp type all');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp ( TYPE ALL )', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 'all' ]
-            }
-        }, 'icmp type all in parens');
-
-    t.end();
-});
-
-
-test('icmp6 type all', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp6 type all', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp6',
-                targets: [ 'all' ]
-            }
-        }, 'icmp6 type all');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp6 ( TYPE ALL )', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp6',
-                targets: [ 'all' ]
-            }
-        }, 'icmp6 type all in parens');
-
-    t.end();
-});
-
-
-test('Tags: With value', function (t) {
-    var ruleTxt = 'FROM tag foo = bar TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'tag', [ 'foo', 'bar' ] ] ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Multiple values', function (t) {
-    var ruleTxt = 'FROM (tag foo = bar OR tag some = value) TO '
-        + 'ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-            [ 'tag', [ 'foo', 'bar' ] ],
-            [ 'tag', [ 'some', 'value' ] ]
-        ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Quoted value', function (t) {
-    var ruleTxt = 'FROM tag foo = "some value" TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'tag', [ 'foo', 'some value' ] ] ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Quoted name and value', function (t) {
-    var ruleTxt = 'FROM (tag "tag one" = "some value" OR '
-        + 'tag "tag two" = "another value")'
-        + 'TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-                [ 'tag', [ 'tag one', 'some value' ] ],
-                [ 'tag', [ 'tag two', 'another value' ] ]
-            ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Escaped characters', function (t) {
-    var ruleTxt = 'FROM (tag "\\"" = "\\)" OR tag "\\n" = "\\b") TO tag "\\(" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt), {
-        from: [ [ 'tag', [ '"', ')' ] ],
-                [ 'tag', [ '\n', '\b' ] ] ],
-        to: [ [ 'tag', '(' ] ],
-        action: 'block',
-        protocol: {
-            name: 'udp',
-            targets: [ 53 ]
-        }
-    });
-
-    t.end();
-});
-
-
-test('Tags: Parens shouldn\'t have to be escaped', function (t) {
-    var ruleTxt = 'FROM tag "(" = "(" TO tag ")" = ")" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt), {
-        from: [ [ 'tag', [ '(', '(' ] ] ],
-        to: [ [ 'tag', [ ')', ')' ] ] ],
-        action: 'block',
-        protocol: {
-            name: 'udp',
-            targets: [ 53 ]
-        }
-    });
-
-    t.end();
-});
-
-
-test('Tags: UTF-8 characters can be written using \\u', function (t) {
-    var escapedTxt = 'FROM tag "\\u2603" = "\\u0631\\u062c\\u0644 '
-        + '\\u0627\\u0644\\u062b\\u0644\\u062c" TO tag "\\u26C4" '
-        + 'BLOCK udp PORT 53';
-    var unicodeTxt = 'FROM tag "☃" = "رجل الثلج" TO tag "⛄" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(escapedTxt), parser.parse(unicodeTxt));
-
-    t.end();
-});
-
-
-test('Tags: Unicode characters', function (t) {
-    var ruleTxt = 'FROM (tag "☂" = "ທ" OR '
-        + 'tag "삼겹살" = "불고기")'
-        + 'TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-                [ 'tag', [ '☂', 'ທ' ] ],
-                [ 'tag', [ '삼겹살', '불고기' ] ]
-            ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
diff --git a/src/fw/tools/fwrule/test/rule.test.js b/src/fw/tools/fwrule/test/rule.test.js
deleted file mode 100644
index a855982a..00000000
--- a/src/fw/tools/fwrule/test/rule.test.js
+++ /dev/null
@@ -1,1700 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Unit tests for the firewall rule object
- */
-
-'use strict';
-
-var fwrule = require('../lib/index');
-var util = require('util');
-var test = require('tape');
-
-var TAG_TEST =
-    'FROM tag "%s" = "%s" TO tag "%s" = "%s" ALLOW tcp PORT 80';
-var TAG_TEST_UNQUOTED = 'FROM tag %s = %s TO tag %s = %s ALLOW tcp PORT 80';
-
-
-function stringify(val) {
-    switch (val) {
-    case '\u0085':
-        return '"\\u0085"';
-    default:
-        return JSON.stringify(val);
-    }
-}
-
-
-function testTagInRules(t, unquotedOK, txtIn, txtOut, val) {
-    var desc = util.format('txtIn=%s, txtOut=%s, val=%s',
-        stringify(txtIn), stringify(txtOut), stringify(val));
-    var ruleOut = util.format(TAG_TEST, txtOut, txtOut, txtOut, txtOut);
-    var toParse = [ util.format(TAG_TEST, txtIn, txtIn, txtIn, txtIn) ];
-
-    if (unquotedOK) {
-        toParse.push(
-            util.format(TAG_TEST_UNQUOTED, txtIn, txtIn, txtIn, txtIn));
-    }
-
-    toParse.forEach(function (ruleIn) {
-        var rule = fwrule.create({
-            rule: ruleIn,
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            version: fwrule.generateVersion()
-        });
-
-        var raw = {
-            from: {
-                ips: [],
-                subnets: [],
-                vms: [],
-                tags: [ [ val, val ] ],
-                wildcards: []
-            },
-            to: {
-                ips: [],
-                subnets: [],
-                vms: [],
-                tags: [ [ val, val ] ],
-                wildcards: []
-            },
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            ports: [ 80 ],
-            action: 'allow',
-            protocol: 'tcp',
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.raw(), raw, desc + ': rule.raw()');
-        t.deepEqual(rule.from, raw.from, desc + ': rule.from');
-        t.deepEqual(rule.to, raw.to, desc + ': rule.to');
-        t.ok(!rule.allVMs, desc + ': rule.allVMs');
-
-        var ser = {
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            global: true,
-            rule: ruleOut,
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-        t.deepEqual(rule.serialize(['enabled', 'version']),
-            { enabled: ser.enabled, version: ser.version },
-            'rule.serialize(): enabled, version');
-    });
-}
-
-
-function checkTagsInRules(t, toCheck) {
-    toCheck.forEach(function (cfg) {
-        testTagInRules(t, cfg.unquotedOK, cfg.in, cfg.out, cfg.val);
-    });
-
-    t.end();
-}
-
-
-// --- Tests
-
-
-
-test('rule exports', function (t) {
-    ['ACTIONS', 'DIRECTIONS', 'FIELDS', 'PROTOCOLS', 'TARGET_TYPES'].forEach(
-        function (field) {
-        t.ok(fwrule[field].length > 0, 'fwrule.' + field);
-    });
-
-    t.end();
-});
-
-
-test('all target types', function (t) {
-    var desc = 'all target types';
-    var ips = ['192.168.1.1', '10.2.0.3'];
-    var vms = ['9a343ca8-b42a-4a27-a9c5-800f57d1e8ed',
-        '518908b6-8299-466d-8ea5-20a0ceff63ec'];
-    var tags = ['tag1', 'tag2'];
-    var subnets = ['192.168.2.0/24', '10.2.1.0/24'];
-    var ruleTxt = util.format('FROM (ip %s OR vm %s OR tag %s OR subnet %s) ',
-        ips[0], vms[0], tags[0], subnets[0])
-        + util.format('TO (ip %s OR vm %s OR tag %s OR subnet %s)',
-        ips[1], vms[1], tags[1], subnets[1])
-        + ' ALLOW tcp port 80';
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ips[0]],
-            subnets: [subnets[0]],
-            vms: [vms[0]],
-            tags: [tags[0]],
-            wildcards: []
-        },
-        to: {
-            ips: [ips[1]],
-            subnets: [subnets[1]],
-            vms: [vms[1]],
-            tags: [tags[1]],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: util.format('FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) '
-            + 'TO (ip %s OR subnet %s OR tag "%s" OR vm %s) ALLOW tcp PORT 80',
-            ips[0], subnets[0], tags[0], vms[0],
-            ips[1], subnets[1], tags[1], vms[1]),
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('any', function (t) {
-    var ip = '192.168.3.2';
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var tag = 'tag3';
-    var subnet = '192.168.0.0/16';
-
-    var ruleTxt = util.format(
-        'FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) TO any'
-        + ' ALLOW tcp PORT 80', ip, subnet, tag, vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ip],
-            subnets: [subnet],
-            vms: [vm],
-            tags: [tag],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('all vms', function (t) {
-    var ip = '192.168.3.2';
-    var owner = '50716241-ac8d-4e63-a9e4-77ff07cede61';
-
-    var ruleTxt = util.format('FROM ip %s TO all vms ALLOW tcp PORT 80', ip);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        owner_uuid: owner,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ip],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['vmall']
-        },
-        enabled: true,
-        owner_uuid: owner,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.deepEqual(rule.wildcards, raw.to.wildcards, 'rule.wildcards');
-    t.ok(rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        // no global flag set because the rule has an owner_uuid
-        owner_uuid: owner,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('tags', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO tag some-tag ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'some-tag' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.end();
-});
-
-
-test('tag "hasOwnProperty"', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO (tag hasOwnProperty OR tag some-tag) '
-        + 'ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'hasOwnProperty', 'some-tag' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO (tag "hasOwnProperty" OR tag "some-tag") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.end();
-});
-
-
-test('multiple ports and owner_uuid', function (t) {
-    var inRule1 = {
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + '(PORT 1002 AND PORT 1052)',
-        enabled: true,
-        owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
-        version: fwrule.generateVersion()
-    };
-    var inRule2 = {
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 1002, 1052',
-        enabled: true,
-        owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
-        version: fwrule.generateVersion()
-    };
-
-
-    var rule1 = fwrule.create(inRule1);
-    var rule2 = fwrule.create(inRule2);
-    var raw = {
-        action: 'allow',
-        enabled: inRule1.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        owner_uuid: inRule1.owner_uuid,
-        protocol: 'tcp',
-        ports: [ 1002, 1052 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule1.uuid,
-        version: rule1.version
-    };
-
-    t.deepEqual(rule1.raw(), raw, 'rule1.raw()');
-    t.deepEqual(rule1.ports, raw.ports, 'rule1.ports');
-    t.deepEqual(rule1.protoTargets, raw.ports, 'rule1.protoTargets');
-
-    t.deepEqual(rule1.serialize(), {
-        enabled: true,
-        owner_uuid: inRule1.owner_uuid,
-        rule: inRule1.rule,
-        uuid: rule1.uuid,
-        version: rule1.version
-    }, 'rule1.serialize()');
-
-    raw.uuid = rule2.uuid;
-    raw.version = rule2.version;
-
-    t.deepEqual(rule2.raw(), raw, 'rule2.raw()');
-    t.deepEqual(rule2.ports, raw.ports, 'rule2.ports');
-    t.deepEqual(rule2.protoTargets, raw.ports, 'rule2.protoTargets');
-
-    t.deepEqual(rule2.serialize(), {
-        enabled: true,
-        owner_uuid: inRule2.owner_uuid,
-        rule: inRule1.rule,
-        uuid: rule2.uuid,
-        version: rule2.version
-    }, 'rule2.serialize()');
-
-    t.end();
-});
-
-
-test('icmp', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp TYPE 8', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('icmp with code', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp TYPE 8 CODE 0', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8:0' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('icmp: multiple types', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp (TYPE 8 CODE 0 AND TYPE 11 CODE 0 '
-        + 'AND TYPE 30)', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8:0', '11:0', '30' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.types, raw.types, 'rule.types');
-    t.deepEqual(rule.protoTargets, raw.types, 'rule.protoTargets');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: icmp codes', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var rule = fwrule.create({
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp '
-        + '(TYPE 8 CODE 0 AND TYPE 3 CODE 11 AND TYPE 40 AND TYPE 3 CODE 1 '
-        + 'AND TYPE 30 AND TYPE 3 CODE 5)', vm),
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '3:1', '3:5', '3:11', '8:0', '30', '40' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp '
-        + '(TYPE 3 CODE 1 AND TYPE 3 CODE 5 AND TYPE 3 CODE 11 '
-        + 'AND TYPE 8 CODE 0 AND TYPE 30 AND TYPE 40)', vm),
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: icmp6 codes', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var rule = fwrule.create({
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp6 '
-        + '(TYPE 8 CODE 0 AND TYPE 3 CODE 11 AND TYPE 40 AND TYPE 3 CODE 1 '
-        + 'AND TYPE 30 AND TYPE 3 CODE 5)', vm),
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '3:1', '3:5', '3:11', '8:0', '30', '40' ],
-        action: 'allow',
-        protocol: 'icmp6',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp6 '
-        + '(TYPE 3 CODE 1 AND TYPE 3 CODE 5 AND TYPE 3 CODE 11 '
-        + 'AND TYPE 8 CODE 0 AND TYPE 30 AND TYPE 40)', vm),
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: ports', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + '(PORT 1002 AND PORT 10 AND PORT 1052 AND PORT 80 AND PORT 30245 '
-            + 'AND PORT 6)',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 6, 10, 80, 1002, 1052, 30245 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + '(PORT 6 AND PORT 10 AND PORT 80 AND PORT 1002 AND PORT 1052 '
-            + 'AND PORT 30245)',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: port ranges', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + 'PORTS 1002, 20-40, 10, 1052, 80, 30245, 6 - 11',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ { start: 6, end: 11 }, 10, { start: 20, end: 40 },
-            80, 1002, 1052, 30245 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.strictEqual(rule.raw().ports[0].start, raw.ports[0].start,
-        'Both starts are Numbers');
-    t.strictEqual(rule.raw().ports[0].end, raw.ports[0].end,
-        'Both ends are Numbers');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 6 - 11, 10, 20 - 40, 80, 1002, 1052, 30245',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('single port range', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + 'PORTS 50-50',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ { start: 50, end: 50 } ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 50 - 50',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('port ALL', function (t) {
-    var normalText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp PORT all';
-    var parenText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp ( PORT all )';
-    var ruleTexts = [ normalText, parenText ];
-
-    ruleTexts.forEach(function (ruleText) {
-        var inRule = {
-            rule: ruleText,
-            enabled: true,
-            version: fwrule.generateVersion()
-        };
-
-        var rule = fwrule.create(inRule);
-        var raw = {
-            action: 'allow',
-            enabled: inRule.enabled,
-            from: {
-                ips: [ '10.88.88.1' ],
-                vms: [],
-                subnets: [],
-                tags: [],
-                wildcards: []
-            },
-            protocol: 'tcp',
-            ports: [ 'all' ],
-            to: {
-                ips: [],
-                vms: [],
-                subnets: [],
-                tags: [ 'tag2' ],
-                wildcards: []
-            },
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.raw(), raw, 'rule.raw()');
-        t.deepEqual(rule.ports, raw.ports, 'rule.ports');
-        t.deepEqual(rule.protoTargets, raw.ports, 'rule.protoTargets');
-
-        t.deepEqual(rule.serialize(), {
-            enabled: true,
-            global: true,
-            rule: normalText,
-            uuid: rule.uuid,
-            version: rule.version
-        }, 'rule.serialize()');
-    });
-
-    t.end();
-});
-
-
-test('tags: equal', function (t) {
-    var ruleTxt =
-        'FROM ip 1.2.3.4 TO tag some-tag = value ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ [ 'some-tag', 'value' ] ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" = "value" ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.to.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: equal', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO '
-        + '(tag some-tag = value OR tag some-tag = value2) ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some-tag', 'value' ],
-                [ 'some-tag', 'value2' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO '
-            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2")'
-            + ' ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.to.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: multiple values', function (t) {
-    var rule = new fwrule.create({
-        rule: 'FROM (tag some-tag OR tag some-tag = value0) TO '
-            + '(tag some-tag = value OR tag some-tag = value2) '
-            + 'ALLOW tcp PORT 80',
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'some-tag' ],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some-tag', 'value' ],
-                [ 'some-tag', 'value2' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        // 'some-tag = value0' is a subset of 'tag some-tag', so it is not
-        // included in the rule text
-        rule: 'FROM tag "some-tag" TO '
-            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.from.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: multiple quoted values', function (t) {
-    var owner = 'ace1da4b-9ab2-4991-8298-700bec1b70ed';
-    var rule = new fwrule.create({
-        owner_uuid: owner,
-        rule: 'FROM '
-            + '(tag "김치" = "백김치" '
-            + 'OR tag "김치" = "白김치") TO '
-            + '(tag "some tag" = value '
-            + 'OR tag some-tag = "another value") '
-            + 'ALLOW tcp PORT 80',
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ '김치', '白김치' ],
-                [ '김치', '백김치' ]
-            ],
-            wildcards: []
-        },
-        owner_uuid: owner,
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some tag', 'value' ],
-                [ 'some-tag', 'another value' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        owner_uuid: owner,
-        rule: 'FROM (tag "김치" = "白김치" '
-            + 'OR tag "김치" = "백김치") TO '
-            + '(tag "some tag" = "value" OR tag "some-tag" = "another value") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, [
-                [ 'some tag', 'value' ],
-                [ 'some-tag', 'another value' ],
-                [ '김치', '白김치' ],
-                [ '김치', '백김치' ]
-        ], 'rule.tags');
-
-    t.end();
-});
-
-
-test('IPv6 sources', function (t) {
-    var desc = 'IPv6 sources';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var ips = ['fd00::2', 'fe80::8:20ff:fe40:65e4'];
-    var ruleTxt = util.format('FROM (ip %s OR ip %s) ', ips[0], ips[1])
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: ips,
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 subnet sources', function (t) {
-    var desc = 'IPv6 subnet sources';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var cidr = 'fd00::/64';
-    var ruleTxt = util.format('FROM subnet %s ', cidr)
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [cidr],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 destinations', function (t) {
-    var desc = 'IPv6 destinations';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var ips = ['fd00::1', 'fd00::2'];
-    var ruleTxt = util.format('FROM vm %s ', vm)
-        + util.format('TO (ip %s OR ip %s) ALLOW tcp PORT 80', ips[0], ips[1]);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: ips,
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 subnet destinations', function (t) {
-    var desc = 'IPv6 subnet destinations';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var cidr = 'fd00::/64';
-    var ruleTxt = util.format('FROM vm %s ', vm)
-        + util.format('TO subnet %s BLOCK tcp PORT 80', cidr);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [cidr],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'block',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('Mixed IPv4 and IPv6', function (t) {
-    var desc = 'Mixed IPv4 and IPv6';
-    var vm1 = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var vm2 = '518908b6-8299-466d-8ea5-20a0ceff63ec';
-    var ips = ['10.10.10.5', 'fd00::1'];
-    var ruleTxt =
-        util.format('FROM (ip %s OR ip %s OR vm %s) ', ips[0], ips[1], vm1)
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm2);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: ips,
-            subnets: [],
-            vms: [vm1],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm2],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('Tag names and values: Normal', function (t) {
-    var tags = [ 'foo', 'foo-bar', 'foo_bar', 'db2', 'foo_bar-baz', '_' ];
-
-    var check = [];
-    tags.forEach(function (tag) {
-        check.push({ unquotedOK: true, in: tag, out: tag, val: tag });
-        var tagUpper = tag.toUpperCase();
-        check.push({
-            unquotedOK: true,
-            in: tagUpper,
-            out: tagUpper,
-            val: tagUpper
-        });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: IP addresses and subnets', function (t) {
-    checkTagsInRules(t, [
-        { in: '1.2.3.4', out: '1.2.3.4', val: '1.2.3.4' },
-        { in: '1.2.3.0/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
-        { in: '1.2.3.0\\/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
-        { in: 'fd00::a:b:c:5', out: 'fd00::a:b:c:5', val: 'fd00::a:b:c:5' },
-        { in: 'fc00::/7', out: 'fc00::/7', val: 'fc00::/7' },
-        { in: 'fc00::\\/7', out: 'fc00::/7', val: 'fc00::/7' }
-    ]);
-});
-
-
-test('Tag names and values: Numeric', function (t) {
-    var numbers = [
-        '0', '1', '5', '2000', '1234567890', '987654321', '23', '00000', '0',
-        '01', '10', '111111111'
-    ];
-
-    var check = [];
-    numbers.forEach(function (num) {
-        check.push({ unquotedOK: true, in: num, out: num, val: num });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Keywords', function (t) {
-    var kws = [
-        'tag', 'from', 'to', 'ip', 'subnet', 'vm', 'any', 'all', 'all vms',
-        'vms', 'or', 'and', 'block', 'allow', 'port', 'ports', 'tcp', 'udp',
-        'icmp', 'icmp6', 'type', 'code'
-    ];
-
-    var check = [];
-    kws.forEach(function (kw) {
-        check.push({ in: kw, out: kw, val: kw });
-        var kwUpper = kw.toUpperCase();
-        check.push({ in: kwUpper, out: kwUpper, val: kwUpper });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Escaped characters', function (t) {
-    checkTagsInRules(t, [
-        { val: ' ', in: ' ', out: ' ' },
-        { val: ' ', in: '\\u0020', out: ' ' },
-        { val: '\t', in: '\t', out: '\\t' },
-        { val: '\t', in: '\\t', out: '\\t' },
-        { val: '\t', in: '\\u0009', out: '\\t' },
-        { val: '\n', in: '\n', out: '\\n' },
-        { val: '\n', in: '\\n', out: '\\n' },
-        { val: '\n', in: '\\u000A', out: '\\n' },
-        { val: '\b', in: '\b', out: '\\b' },
-        { val: '\b', in: '\\b', out: '\\b' },
-        { val: '\b', in: '\\u0008', out: '\\b' },
-        { val: '\f', in: '\f', out: '\\f' },
-        { val: '\f', in: '\\f', out: '\\f' },
-        { val: '\f', in: '\\u000C', out: '\\f' },
-        { val: '\r', in: '\r', out: '\\r' },
-        { val: '\r', in: '\\r', out: '\\r' },
-        { val: '\r', in: '\\u000D', out: '\\r' },
-        { val: '/', in: '/', out: '/' },
-        { val: '/', in: '\\/', out: '/' },
-        { val: '(', in: '(', out: '\\(' },
-        { val: '(', in: '\\(', out: '\\(' },
-        { val: ')', in: ')', out: '\\)' },
-        { val: ')', in: '\\)', out: '\\)' },
-        { val: '"', in: '\\"', out: '\\"' },
-        { val: '\\', in: '\\\\', out: '\\\\' }
-    ]);
-});
-
-
-test('Tag names and values: Odd characters', function (t) {
-    var chars = [
-        '!', '@', '#', '$', '%', '^', '&', '*', ',', '.', '<', '>', '?', ';',
-        ':', '\'', '[', ']', '{', '}', '|', '=', '+', '~', '`', '-', '_'
-    ];
-
-    var check = [];
-    chars.forEach(function (c) {
-        check.push({ in: c, out: c, val: c });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: ASCII control characters', function (t) {
-    var chars = [
-        '0000', // null (NUL)
-        '0001', // start of heading (SOH)
-        '0002', // start of text (STX)
-        '0003', // end of text (ETX)
-        '0004', // end of transmission (EOT)
-        '0005', // enquiry (ENQ)
-        '0006', // acknowledgement (ACK)
-        '0007', // bell (BEL)
-        '000B', // vertical tab (VT)
-        '000E', // shift out (SO)
-        '000F', // shift in (SI)
-        '0010', // data link escape (DLE)
-        '0011', // device control 1 (DC1)/XON
-        '0012', // device control 2 (DC2)
-        '0013', // device control 3 (DC3)/XOFF
-        '0014', // device control 4 (DC4)
-        '0015', // negative acknowledgement (NAK)
-        '0016', // synchronous idle (SYN)
-        '0017', // end of transmission block (ETB)
-        '0018', // cancel (CAN)
-        '0019', // end of medium (EM)
-        '001A', // substitute (SUB)
-        '001B', // escape (ESC)
-        '001C', // file separator (FS)
-        '001D', // group separator (GS)
-        '001E', // record separator (RS)
-        '001F', // unit separator (US)
-        '007F'  // delete (DEL)
-    ];
-
-    var check = [];
-    chars.forEach(function (str) {
-        var space = String.fromCharCode(parseInt(str, 16));
-        var escaped = '\\u' + str;
-        var escapedLC = '\\u' + str.toLowerCase();
-        check.push({ in: space, out: escaped, val: space });
-        check.push({ in: escaped, out: escaped, val: space });
-        check.push({ in: escapedLC, out: escaped, val: space });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Unicode whitespace characters', function (t) {
-    var chars = [
-        '000B', // vertical tab
-        '0085', // next line
-        '00A0', // non-breaking space
-        '1680', // ogham space mark
-        '180E', // mongolian vowel separator
-        '2000', // en quad
-        '2001', // em quad
-        '2002', // en space
-        '2003', // em space
-        '2004', // three-per-em space
-        '2005', // four-per-em space
-        '2006', // six-per-em space
-        '2007', // figure space
-        '2008', // punctuation space
-        '2009', // thin space
-        '200A', // hair space
-        '200B', // zero width space
-        '200C', // zero width non-joiner
-        '200D', // zero width joiner
-        '2028', // line separator
-        '2029', // paragraph separator
-        '202F', // narrow no-break space
-        '205F', // medium mathematical space
-        '2060', // word joiner
-        '3000', // ideographic space
-        'FEFF'  // zero width no-break space
-    ];
-
-    var check = [];
-    chars.forEach(function (str) {
-        var space = String.fromCharCode(parseInt(str, 16));
-        var escaped = '\\u' + str;
-        var escapedLC = '\\u' + str.toLowerCase();
-        check.push({ in: space, out: escaped, val: space });
-        check.push({ in: escaped, out: escaped, val: space });
-        check.push({ in: escapedLC, out: escaped, val: space });
-    });
-
-    checkTagsInRules(t, check);
-});
diff --git a/src/fw/tools/fwrule/test/run.js b/src/fw/tools/fwrule/test/run.js
deleted file mode 100644
index 276bc301..00000000
--- a/src/fw/tools/fwrule/test/run.js
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2014 Patrick Mooney.  All rights reserved.
-
-'use strict';
-
-var assert = require('assert');
-var fs = require('fs');
-var path = require('path');
-
-function runTests(directory) {
-    fs.readdir(directory, function (err, files) {
-        assert.ifError(err);
-        files.filter(function (f) {
-            return (/\.test\.js$/.test(f));
-        }).map(function (f) {
-            return (path.join(directory, f));
-        }).forEach(require);
-    });
-}
-
-// --- Run All Tests
-
-(function main() {
-    runTests(__dirname);
-})();
diff --git a/src/fw/tools/fwrule/test/validators.test.js b/src/fw/tools/fwrule/test/validators.test.js
deleted file mode 100644
index 65c62b87..00000000
--- a/src/fw/tools/fwrule/test/validators.test.js
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright 2016, Joyent, Inc. All rights reserved.
- *
- */
-
-/*
- * Unit tests for the firewall rule validators
- */
-
-'use strict';
-
-var test = require('tape');
-var validator = require('../lib/validators.js');
-
-
-
-// --- Tests
-
-
-test('IPv4 addresses', function (t) {
-    var i;
-    var valid = [
-        '1.2.3.4',
-        '1.0.0.0'
-    ];
-
-    var invalid = [
-        '1',
-        'asdf',
-        '0.0.0.0',
-        '01.02.03.04',
-        '255.255.255.255',
-        '256.0.0.1'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateIPv4address(valid[i]), valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateIPv4address(invalid[i]), invalid[i]);
-    }
-
-    t.end();
-});
-
-
-test('IPv4 subnets', function (t) {
-    var i;
-    var valid = [
-        '1.2.3.4/24',
-        '1.0.0.0/32',
-        '10.88.88.24/32',
-        '10.88.88.24/1'
-    ];
-
-    var invalid = [
-        '1',
-        'asdf',
-        '0.0.0.0/32',
-        '1.0.0.0/33',
-        '01.02.03.04/24',
-        '1.0.0.0/0'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateIPv4subnet(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateIPv4subnet(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    t.end();
-});
-
-
-test('ports', function (t) {
-    var i;
-    var valid = [
-        1,
-        20,
-        200,
-        2000,
-        65535,
-        '1',
-        '65535',
-        'all',
-        'All',
-        'ALL'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        [],
-        -1,
-        'something'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validatePortOrAll(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validatePortOrAll(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
-
-
-test('protocols', function (t) {
-    var i;
-    var valid = [
-        'tcp',
-        'TCP',
-        'udp',
-        'UDP',
-        'icmp',
-        'ICMP',
-        'icmp6',
-        'ICMP6'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        [],
-        -1,
-        'something',
-        'ethernet',
-        'ftp'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateProtocol(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateProtocol(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
-
-test('actions', function (t) {
-    var i;
-    var valid = [
-        'block',
-        'BLOCK',
-        'allow',
-        'ALLOW'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        'something',
-        'permit',
-        'obstruct'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateAction(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateAction(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
diff --git a/src/fw/tools/fwrule/tools/eslint.node.conf b/src/fw/tools/fwrule/tools/eslint.node.conf
deleted file mode 100644
index ae6d704d..00000000
--- a/src/fw/tools/fwrule/tools/eslint.node.conf
+++ /dev/null
@@ -1,20 +0,0 @@
-{
-    "plugins": [ "joyent" ],
-    "extends": [
-        "eslint:recommended",
-        "plugin:joyent/style",
-        "plugin:joyent/lint"
-    ],
-    "parserOptions": {
-        "ecmaVersion": 5,
-        "sourceType": "script",
-        "ecmaFeatures": {
-        }
-    },
-    "env": {
-        "node": true
-    },
-    "rules": {
-        "strict": [ "error", "global" ]
-    }
-}
diff --git a/src/fw/tools/fwrule/tools/jsl.node.conf b/src/fw/tools/fwrule/tools/jsl.node.conf
deleted file mode 100644
index 591cb8c7..00000000
--- a/src/fw/tools/fwrule/tools/jsl.node.conf
+++ /dev/null
@@ -1,138 +0,0 @@
-#
-# Configuration File for JavaScript Lint 
-#
-# This configuration file can be used to lint a collection of scripts, or to enable
-# or disable warnings for scripts that are linted via the command line.
-#
-
-### Warnings
-# Enable or disable warnings based on requirements.
-# Use "+WarningName" to display or "-WarningName" to suppress.
-#
-+ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
-+ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
-+ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
-+anon_no_return_value         # anonymous function does not always return value
-+assign_to_function_call      # assignment to a function call
--block_without_braces         # block statement without curly braces
-+comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
-+comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
-+default_not_at_end           # the default case is not at the end of the switch statement
-+dup_option_explicit          # duplicate "option explicit" control comment
-+duplicate_case_in_switch     # duplicate case in switch statement
-+duplicate_formal             # duplicate formal argument {name}
-+empty_statement              # empty statement or extra semicolon
-+identifier_hides_another     # identifer {name} hides an identifier in a parent scope
--inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
-+incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
-+invalid_fallthru             # unexpected "fallthru" control comment
-+invalid_pass                 # unexpected "pass" control comment
-+jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
-+leading_decimal_point        # leading decimal point may indicate a number or an object member
-+legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
-+meaningless_block            # meaningless block; curly braces have no impact
-+mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
-+misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
-+missing_break                # missing break statement
-+missing_break_for_last_case  # missing break statement for last case in switch
-+missing_default_case         # missing default case in switch statement
-+missing_option_explicit      # the "option explicit" control comment is missing
-+missing_semicolon            # missing semicolon
-+missing_semicolon_for_lambda # missing semicolon for lambda assignment
-+multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
-+nested_comment               # nested comment
-+no_return_value              # function {name} does not always return a value
-+octal_number                 # leading zeros make an octal number
-+parseint_missing_radix       # parseInt missing radix parameter
-+partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
-+redeclared_var               # redeclaration of {name}
-+trailing_comma_in_array      # extra comma is not recommended in array initializers
-+trailing_decimal_point       # trailing decimal point may indicate a number or an object member
-+undeclared_identifier        # undeclared identifier: {name}
-+unreachable_code             # unreachable code
--unreferenced_argument        # argument declared but never referenced: {name}
--unreferenced_function        # function is declared but never referenced: {name}
-+unreferenced_variable        # variable is declared but never referenced: {name}
-+unsupported_version          # JavaScript {version} is not supported
-+use_of_label                 # use of label
-+useless_assign               # useless assignment
-+useless_comparison           # useless comparison; comparing identical expressions
--useless_quotes               # the quotation marks are unnecessary
-+useless_void                 # use of the void type may be unnecessary (void is always undefined)
-+var_hides_arg                # variable {name} hides argument
--want_assign_or_call          # expected an assignment or function call
-+with_statement               # with statement hides undeclared variables; use temporary variable instead
-
-
-### Output format
-# Customize the format of the error message.
-#    __FILE__ indicates current file path
-#    __FILENAME__ indicates current file name
-#    __LINE__ indicates current line
-#    __COL__ indicates current column
-#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
-#    __ERROR_NAME__ indicates error name (used in configuration file)
-#    __ERROR_PREFIX__ indicates error prefix
-#    __ERROR_MSG__ indicates error message
-#
-# For machine-friendly output, the output format can be prefixed with
-# "encode:". If specified, all items will be encoded with C-slashes.
-#
-# Visual Studio syntax (default):
-+output-format __FILE__(__LINE__): __ERROR__
-# Alternative syntax:
-#+output-format __FILE__:__LINE__: __ERROR__
-
-
-### Context
-# Show the in-line position of the error.
-# Use "+context" to display or "-context" to suppress.
-#
-+context
-
-
-### Control Comments
-# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
-# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
-# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
-# although legacy control comments are enabled by default for backward compatibility.
-#
--legacy_control_comments
-
-
-### Defining identifiers
-# By default, "option explicit" is enabled on a per-file basis.
-# To enable this for all files, use "+always_use_option_explicit"
--always_use_option_explicit
-
-# Define certain identifiers of which the lint is not aware.
-# (Use this in conjunction with the "undeclared identifier" warning.)
-#
-# Common uses for webpages might be:
-+define __dirname
-+define clearInterval
-+define clearTimeout
-+define console
-+define exports
-+define global
-+define module
-+define process
-+define require
-+define setInterval
-+define setTimeout
-+define Buffer
-+define JSON
-+define Math
-
-### JavaScript Version
-# To change the default JavaScript version:
-#+default-type text/javascript;version=1.5
-#+default-type text/javascript;e4x=1
-
-### Files
-# Specify which files to lint
-# Use "+recurse" to enable recursion (disabled by default).
-# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
-# or "+process Folder\Path\*.htm".
-#
-
diff --git a/src/manifest b/src/manifest
index e8d151a3..2fa8ef7c 100644
--- a/src/manifest
+++ b/src/manifest
@@ -598,6 +598,7 @@ f usr/fw/node_modules/cmdln/LICENSE.txt 0444 root bin
 f usr/fw/node_modules/dashdash.js 0444 root bin
 f usr/fw/node_modules/fuzzyset.js/README.rst 0444 root bin
 f usr/fw/node_modules/fuzzyset.js/index.js 0444 root bin
+f usr/fw/node_modules/ip6addr.js 0444 root bin
 f usr/fw/node_modules/dtrace-provider.js 0444 root bin
 f usr/fw/node_modules/DTraceProviderBindings.node 0444 root bin
 h usr/fw/node_modules/lockfd.js=usr/node/0.10/node_modules/lockfd.js
