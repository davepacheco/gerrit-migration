From be3565bafba5521be764087fc39cdc5870da44cc Mon Sep 17 00:00:00 2001
From: Mike Zeller <mike.zeller@joyent.com>
Date: Fri, 12 Aug 2016 10:29:27 -0700
Subject: [PATCH] OS-5588 lxbrand fcntl drops file flags

---
 .../uts/common/brand/lx/syscall/lx_fcntl.c    | 34 ++++++++++++++-----
 1 file changed, 25 insertions(+), 9 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_fcntl.c b/usr/src/uts/common/brand/lx/syscall/lx_fcntl.c
index 2699b9bac7..40c5910884 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_fcntl.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_fcntl.c
@@ -173,25 +173,41 @@ lx_fcntl_getfl(int fd)
 	return (rc);
 }
 
+#define LX_SETFL_MASK (O_NONBLOCK | O_APPEND | O_SYNC |  FASYNC);
+
 static int
 lx_fcntl_setfl(int fd, ulong_t arg)
 {
-	int new_arg;
+	int flags;
+
+	/*
+	 * When preforming fcntl(F_SETFL), only certain flags are
+	 * allowed to be manipulated. A mask is used to preserve
+	 * other flags, such as those which are specified during
+	 * open(2). The mask on Linux excludes O_LARGEFILE from
+	 * being manipulated, whereas illumos expects the flag to
+	 * be set. In order to properly preserve the O_LARGEFILE
+	 * (FOFFMAX) sate, we must first query for it via
+	 * fcntl(F_GETFL) so that the value can be carried
+	 * through.
+	 */
+	flags = fcntl(fd, F_GETFL, 0);
+	if (ttolwp(curthread)->lwp_errno != 0)
+		return (ttolwp(curthread)->lwp_errno);
+
+	flags &= ~LX_SETFL_MASK;
 
-	new_arg = 0;
 	/* LX_O_NDELAY == LX_O_NONBLOCK, so we only check for one */
 	if (arg & LX_O_NDELAY)
-		new_arg |= O_NONBLOCK;
+	       flags |= O_NONBLOCK;
 	if (arg & LX_O_APPEND)
-		new_arg |= O_APPEND;
+	       flags |= O_APPEND;
 	if (arg & LX_O_SYNC)
-		new_arg |= O_SYNC;
-	if (arg & LX_O_LARGEFILE)
-		new_arg |= O_LARGEFILE;
+	       flags |= O_SYNC;
 	if (arg & LX_O_ASYNC)
-		new_arg |= FASYNC;
+	       flags |= FASYNC;
 
-	return (fcntl(fd, F_SETFL, new_arg));
+	return (fcntl(fd, F_SETFL, flags));
 }
 
 /* The default unprivileged limit in Linux is 1MB */
-- 
2.21.0

