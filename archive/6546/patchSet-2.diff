commit 10be2eeff258e02e15c615f64f3e2c1cc49c8c5c
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2019-07-04T03:29:30+00:00 (3 months ago)
    
    OS-7863 test-bhyve-disk-resize failing with "size is greater than available space" error

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index d5ce6e1a..49129a8e 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -2349,7 +2349,7 @@ function createVolume(volume, opts, callback)
             return;
         }
 
-        zfsGet(image, ['volblocksize'], log,
+        zfsGet(image, ['volblocksize', 'copies'], log,
             function getCloneVbs(err, props) {
 
             if (err) {
@@ -2358,12 +2358,16 @@ function createVolume(volume, opts, callback)
                 return;
             }
 
-            var res = volsizeToRefreservation({
-                volsize: newsize,
-                volblocksize: props.volblocksize,
-                copies: 1
+            props.volsize = newsize;
+            volsizeToRefreservation(volume.zfs_filesystem, props, log,
+                function newCloneRefres(_err, res) {
+
+                if (_err) {
+                    _cb(_err);
+                    return;
+                }
+                _cb(null, res - newsize);
             });
-            _cb(null, res - newsize);
         });
     }
 
@@ -2382,12 +2386,17 @@ function createVolume(volume, opts, callback)
             return;
         }
 
-        var res = volsizeToRefreservation({
+        volsizeToRefreservation(volume.zfs_filesystem, {
             volsize: newsize,
             volblocksize: vbs,
             copies: 1
+        }, log, function newRefres(_err, res) {
+            if (_err) {
+                _cb(_err);
+                return;
+            }
+            _cb(null, res - newsize);
         });
-        _cb(null, res - newsize);
     }
 
     // A volChangeFunc for createResizeDeleteVolume()
@@ -4246,49 +4255,45 @@ function zfsGet(dataset, props, log, callback)
 /*
  * Calculate the zfs refreservation based on the volsize, volblocksize, and
  * copies.  All values are in bytes.
- *
- * Example:
- *
- *  var refres;
- *  ...
- *  zfsGet(volname, [ 'copies', 'volblocksize', 'volsize' ],
- *      function getCb(err, props) {
- *
- *      if (!err) {
- *          refres = volSizeToRefReservation(props);
- *      }
- *  });
- *
- * Adapted from usr/src/lib/libzfs/common/libzfs_dataset.c and related headers.
  */
-function volsizeToRefreservation(props)
+function volsizeToRefreservation(vol, props, log, callback)
 {
+    assert.string(vol);
     assert.object(props, 'props');
+    assert.object(log, 'log');
+    assert.func(callback, 'callback');
     assert.number(props.copies, 'props.copies');
     assert.number(props.volblocksize, 'props.volblocksize');
     assert.number(props.volsize, 'props.volsize');
-    var copies = props.copies;
-    var volblocksize = props.volblocksize;
-    var volsize = props.volsize;
 
-    var SPA_BLKPTRSHIFT = 7;        /* blkptr_t is 128 bytes */
-    var SPA_DVAS_PER_BP = 3;        /* Number of DVAs in a bp */
-    var DN_MAX_INDBLKSHIFT = 17;    /* 128k */
-    var DNODES_PER_LEVEL_SHIFT = DN_MAX_INDBLKSHIFT - SPA_BLKPTRSHIFT;
-    var DNODES_PER_LEVEL = 1 << DNODES_PER_LEVEL_SHIFT;
-    var blocks = volsize / volblocksize;
-    var numdb = 7;
+    // Use `zfs create` in dry-run mode to get it to calculate refreservation.
+    var args = ['create', '-nPV', String(props.volsize),
+        '-o', 'copies=' + props.copies,
+        '-o', 'volblocksize=' + props.volblocksize, vol];
 
-    while (blocks > 1) {
-        blocks = Math.floor((blocks + DNODES_PER_LEVEL - 1) / DNODES_PER_LEVEL);
-        numdb += blocks;
-    }
+    zfs(args, log, function zfsCreateDryRun(err, fds) {
+        if (err) {
+            log.error(err, 'failed to get refreservation: ' + fds.stderr);
+            callback(new Error(rtrim(fds.stderr)));
+            return;
+        }
 
-    numdb *= Math.min(SPA_DVAS_PER_BP, copies + 1);
-    volsize *= copies;
+        var line;
+        var lines = fds.stdout.split('\n');
+        for (line in lines) {
+            line = lines[line];
+            var fields = line.split('\t');
+            if (fields.length === 3 && fields[0] === 'property'
+                && fields[1] === 'refreservation') {
 
-    numdb *= 1 << DN_MAX_INDBLKSHIFT;
-    return volsize + numdb;
+                log.debug({vol: vol, props: props},
+                    'volsizeToRefeservation: refreservation is ' + fields[2]);
+                callback(null, Number(fields[2]));
+                return;
+            }
+        }
+        callback(new Error('failed to obtain new refreservation'));
+    });
 }
 
 exports.getSysinfo = function (args, options, callback)
@@ -7258,7 +7263,6 @@ function archiveVM(uuid, options, callback)
                 targ: path.join(archive_dirname, 'cores')
             });
             patterns_to_archive.push({
-                src: path.join(vmobj.zonepath, 'logs/console.log*'),
                 dst: path.join(archive_dirname, 'console'),
                 create_dst_dir: true
             });
@@ -14845,6 +14849,15 @@ function resizeDisks(vmobj, updates, log, callback)
          * quota and/or refreservation on the zone's dataset (zonepath dataset)
          * will need to change to allow the resize.
          *
+         * We can't assume that the delta will be based solely on the current
+         * way that refreservation is calculated.  Over time we have changed
+         * from reserving just volsize to reserving without regard to raidz's
+         * special behavior, to considering the inefficiences of raidz.  A pool
+         * that has acquired different raidz vdevs than it had at some earlier
+         * time may also end up with a diffferent value for refreservation.  See
+         * the big theory comment above zvol_volsize_to_referservation() in
+         * projects/illumos/usr/src/lib/libzfs/common/libzfs_dataset.c.
+         *
          * opts.volname The name of the zfs volume that is being resized.
          * opts.newsize The new size of the volume in bytes.
          *
@@ -14864,34 +14877,33 @@ function resizeDisks(vmobj, updates, log, callback)
                     return;
                 }
 
-                // Get the current size for 'auto'
                 var curRefres = props.refreservation;
-                var curAuto = volsizeToRefreservation(props);
-                var curMd = curAuto - props.volsize;
+                var curMd = curRefres - props.volsize;
 
                 log.debug({
                     props: props,
-                    curAuto: curAuto,
                     curMd: curMd,
                     volname: opts.volname
                     }, 'getRefresDelta: before changes');
 
-                // Bail out if 'zfs set volsize' will not adjust refreservation.
-                if (curRefres !== curAuto) {
-                    _cb(null, 0);
-                    return;
-                }
+                props.volsize = newsize * 1024 * 1024;
+                volsizeToRefreservation(opts.volname, props, log,
+                    function calcDelta(_err, newRefres) {
 
-                // Calculate the new size for 'auto'.
-                props.volsize = opts.newsize;
-                var newAuto = volsizeToRefreservation(props);
-                var newMd = newAuto - props.volsize;
+                    if (_err) {
+                        _cb(_err);
+                        return;
+                    }
+                    var newMd = newRefres - props.volsize;
+                    var delta = newMd - curMd;
+
+                    log.debug(
+                        {volname: opts.volname, delta: delta, props: props},
+                        'getRefresDelta: quota requires adjustment');
 
-                var delta = newMd - curMd;
-                log.debug({volname: opts.volname, delta: delta},
-                    'getRefresDelta: quota requires adjustment');
+                    _cb(null, delta);
+                });
 
-                _cb(null, delta);
             });
         }
 
