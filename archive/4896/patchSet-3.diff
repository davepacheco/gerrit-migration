From 92a6424e471888df82394008be0d76947e2c21a0 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Thu, 11 Oct 2018 13:46:06 -0700
Subject: [PATCH] TRITON-809 update sdc-cn-agent for TRITON-805

---
 bin/cn-agent.js                               |   1 -
 lib/app.js                                    |   3 +-
 lib/backends/dummy/index.js                   |  12 +-
 lib/backends/dummy/lib/sysinfo.js             |   7 +
 lib/backends/dummy/lib/vmadm.js               | 922 ------------------
 lib/backends/dummy/tasks/machine_boot.js      |  14 +-
 lib/backends/dummy/tasks/machine_create.js    |  21 +-
 .../dummy/tasks/machine_create_snapshot.js    |  76 ++
 .../dummy/tasks/machine_delete_snapshot.js    |  78 ++
 lib/backends/dummy/tasks/machine_destroy.js   |  12 +-
 lib/backends/dummy/tasks/machine_load.js      |  14 +-
 lib/backends/dummy/tasks/machine_reboot.js    |  14 +-
 .../dummy/tasks/machine_reprovision.js        | 201 ++++
 .../dummy/tasks/machine_rollback_snapshot.js  |  76 ++
 lib/backends/dummy/tasks/machine_shutdown.js  |  14 +-
 lib/backends/dummy/tasks/machine_update.js    |  16 +-
 lib/backends/dummy/tasks/nop.js               |   2 -
 .../dummy/tasks/server_update_nics.js         | 145 +++
 lib/task_agent/task_agent.js                  |   2 +
 lib/task_agent/task_runner.js                 |  12 +-
 lib/task_agent/task_worker.js                 |   2 +-
 package.json                                  |   6 +-
 22 files changed, 700 insertions(+), 950 deletions(-)
 delete mode 100644 lib/backends/dummy/lib/vmadm.js
 create mode 100644 lib/backends/dummy/tasks/machine_create_snapshot.js
 create mode 100644 lib/backends/dummy/tasks/machine_delete_snapshot.js
 create mode 100644 lib/backends/dummy/tasks/machine_reprovision.js
 create mode 100644 lib/backends/dummy/tasks/machine_rollback_snapshot.js
 create mode 100644 lib/backends/dummy/tasks/server_update_nics.js

diff --git a/bin/cn-agent.js b/bin/cn-agent.js
index 5261e6f..b1a9c8a 100755
--- a/bin/cn-agent.js
+++ b/bin/cn-agent.js
@@ -18,7 +18,6 @@ var verror = require('verror');
 
 var AgentHttpServer = require('../lib/server');
 var App = require('../lib/app');
-var TaskAgent = require('../lib/task_agent/task_agent');
 var dispatch = require('../lib/task_agent/dispatch');
 
 var createHttpTaskDispatchFn = dispatch.createHttpTaskDispatchFn;
diff --git a/lib/app.js b/lib/app.js
index e13cb42..38c1c06 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -17,6 +17,7 @@ var path = require('path');
 var assert = require('assert-plus');
 var async = require('async');
 var backo2 = require('backo2');
+var jsprim = require('jsprim');
 var restify = require('restify');
 var vasync = require('vasync');
 var verror = require('verror');
@@ -446,7 +447,7 @@ App.prototype.start = function () {
     var queueDefns;
     var uuid = self.uuid;
 
-    queueDefns = self.backend.queueDefns;
+    queueDefns = jsprim.deepCopy(self.backend.queueDefns);
     assert.object(queueDefns, 'queueDefns');
 
     agent = new TaskAgent({
diff --git a/lib/backends/dummy/index.js b/lib/backends/dummy/index.js
index 5601081..b624127 100644
--- a/lib/backends/dummy/index.js
+++ b/lib/backends/dummy/index.js
@@ -31,7 +31,7 @@ var cachedDNSDomain;
 var queueDefns = [
     {
         name: 'machine_creation',
-        tasks: [ 'machine_create' ]
+        tasks: [ 'machine_create', 'machine_reprovision' ]
     },
     {
         name: 'image_import_tasks',
@@ -41,9 +41,12 @@ var queueDefns = [
         name: 'machine_tasks',
         tasks: [
             'machine_boot',
+            'machine_create_snapshot',
+            'machine_delete_snapshot',
             'machine_destroy',
             'machine_kill',
             'machine_reboot',
+            'machine_rollback_snapshot',
             'machine_shutdown',
             'machine_update'
         ]
@@ -58,6 +61,13 @@ var queueDefns = [
     {
         name: 'nop',
         tasks: [ 'nop' ]
+    },
+    {
+        name: 'server_tasks',
+        tasks: [
+            'server_sysinfo_load',
+            'server_update_nics'
+        ]
     }
 ];
 
diff --git a/lib/backends/dummy/lib/sysinfo.js b/lib/backends/dummy/lib/sysinfo.js
index 224ff42..e2c575c 100644
--- a/lib/backends/dummy/lib/sysinfo.js
+++ b/lib/backends/dummy/lib/sysinfo.js
@@ -20,6 +20,7 @@ function sysinfo() {
 sysinfo.prototype.get = function get(opts, callback) {
     assert.object(opts, 'opts');
     assert.uuid(opts.serverUuid, 'opts.serverUuid');
+    assert.optionalObject(opts.serverAddress, 'opts.serverAddress');
     assert.func(callback, 'callback');
 
     var filename = common.SERVER_ROOT + '/' + opts.serverUuid + '/sysinfo.json';
@@ -33,6 +34,12 @@ sysinfo.prototype.get = function get(opts, callback) {
         }
 
         sinfo = JSON.parse(data.toString());
+
+        if (opts.serverAddress) {
+            sinfo['CN Agent Port'] = opts.serverAddress.port;
+            sinfo['CN Agent IP'] = opts.serverAddress.address;
+        }
+
         callback(null, sinfo);
     });
 };
diff --git a/lib/backends/dummy/lib/vmadm.js b/lib/backends/dummy/lib/vmadm.js
deleted file mode 100644
index e4b5ec7..0000000
--- a/lib/backends/dummy/lib/vmadm.js
+++ /dev/null
@@ -1,922 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2018, Joyent, Inc.
- */
-
-/*
- * A dummy version of node-vmadm
- *
- * XXX eventually this could just go in node-vmadm probably.
- */
-
-var cp = require('child_process');
-var fs = require('fs');
-var path = require('path');
-var spawn = cp.spawn;
-var stream = require('stream');
-var util = require('util');
-
-var assert = require('assert-plus');
-var jsprim = require('jsprim');
-var vasync = require('vasync');
-
-var common = require('../common');
-
-
-function vmadm() {}
-
-
-function addSystemProperties(arg, callback) {
-    // we know we loaded sysinfo if we got here
-    assert.object(arg, 'arg');
-    assert.object(arg.sysinfo, 'arg.sysinfo');
-    assert.object(arg.vmobj, 'arg.vmobj');
-
-    assert.uuid(arg.sysinfo.UUID, 'arg.sysinfo.UUID');
-    arg.vmobj.server_uuid = arg.sysinfo.UUID;
-
-    assert.string(arg.sysinfo['Datacenter Name'],
-        'arg.sysinfo[\'Datacenter Name\']');
-    arg.vmobj.datacenter_name = arg.sysinfo['Datacenter Name'];
-
-    assert.string(arg.sysinfo['Live Image'], 'arg.sysinfo[\'Live Image\']');
-    arg.vmobj.platform_buildstamp = arg.sysinfo['Live Image'];
-
-    // zpool?
-
-    callback();
-}
-
-function addInstanceExecutionInfo(arg, callback) {
-    var last_modified;
-
-    // XXX we just make stuff up for now
-    assert.object(arg, 'arg');
-    assert.object(arg.vmobj, 'arg.vmobj');
-
-    if (arg.vmobj.state === undefined) {
-        arg.vmobj.state = 'running';
-    }
-
-    if (arg.vmobj.state === 'running') {
-        last_modified = (new Date(arg.vmobj.last_modified)).getTime();
-        arg.vmobj.pid = Math.floor(last_modified / 1000) % 100000;
-        if (arg.vmobj.boot_timestamp === undefined) {
-            arg.vmobj.boot_timestamp = arg.vmobj.last_modified;
-        }
-    } else if (arg.vmobj.state === 'stopped') {
-        arg.vmobj.exit_status = 0;
-        if (arg.vmobj.exit_timestamp === undefined) {
-            arg.vmobj.exit_timestamp = arg.vmobj.last_modified;
-        }
-    }
-
-    callback();
-}
-
-function addHardcodedProperties(arg, callback) {
-    // these make no sense here, so we hardcode them to something for compat
-    assert.object(arg, 'arg');
-    assert.object(arg.vmobj, 'arg.vmobj');
-
-    assert.uuid(arg.vmobj.uuid, 'arg.vmobj.uuid');
-    arg.vmobj.zonename = arg.vmobj.uuid;
-
-    assert.string(arg.vmobj.state, 'arg.vmobj.state');
-    arg.vmobj.zone_state = arg.vmobj.state;
-
-    assert.optionalNumber(arg.vmobj.pid, 'arg.vmobj.pid');
-    if (arg.vmobj.pid !== undefined) {
-        arg.vmobj.zoneid = arg.vmobj.pid;
-    }
-
-    callback();
-}
-
-function loadTimestamp(arg, callback) {
-    assert.object(arg, 'arg');
-    assert.string(arg.file, 'arg.file');
-    assert.object(arg.vmobj, 'arg.vmobj');
-
-    fs.stat(arg.file, function _onStat(err, stats) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        arg.vmobj.last_modified = stats.mtime.toISOString();
-
-        callback();
-    });
-}
-
-function loadVm(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.sysinfo, 'opts.sysinfo');
-    assert.uuid(opts.sysinfo.UUID, 'opts.sysinfo.UUID');
-    assert.uuid(opts.uuid, 'opts.uuid');
-
-    var filename;
-    var server_uuid = opts.sysinfo.UUID;
-    var sysinfo = opts.sysinfo;
-    var uuid = opts.uuid;
-    var vmobj = {};
-
-    filename =
-        path.join(common.SERVER_ROOT, server_uuid, 'vms', uuid + '.json');
-
-    fs.readFile(filename, function _onRead(err, data) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        // XXX will throw on bad data
-        vmobj = JSON.parse(data.toString());
-
-        vasync.pipeline({
-            arg: {
-                file: filename,
-                sysinfo: sysinfo,
-                vmobj: vmobj
-            },
-            funcs: [
-                loadTimestamp,
-                addInstanceExecutionInfo,
-                addSystemProperties,
-                addHardcodedProperties
-            ]
-        }, function _afterPipeline(pipelineErr) {
-            callback(pipelineErr, vmobj);
-        });
-    });
-}
-
-function loadVms(opts, callback) {
-    var vmdir;
-
-    vmdir = path.join(common.SERVER_ROOT, opts.sysinfo.UUID, 'vms');
-
-    fs.readdir(vmdir, function _onReadDir(err, files) {
-        var filename;
-        var idx;
-        var matches;
-        var toLoad = [];
-
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        for (idx = 0; idx < files.length; idx++) {
-            filename = files[idx];
-
-            /* jsl:ignore (assignment in if()) */
-            if (matches = filename.match(/^([a-f0-9\-]*).json$/)) {
-                toLoad.push(matches[1]);
-            } else {
-                console.error('XXX WARNING: IGNORING: ' + filename);
-            }
-            /* jsl:end */
-        }
-
-        vasync.forEachParallel({
-            func: function _loadVm(uuid, cb) {
-                loadVm({
-                    sysinfo: opts.sysinfo,
-                    uuid: uuid
-                }, cb);
-            },
-            inputs: toLoad
-        }, function _afterLoading(loadErr, results) {
-            callback(loadErr, results.successes);
-        });
-    });
-}
-
-
-/**
- * Check whether a VM exists or not.
- *
- * @param opts {Object} Options
- *      - uuid {String} The VM uuid.
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, return VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err, exists)`
- *      - err is set on unhandled error
- *      - otherwise; exists will be true or false
- */
-
-vmadm.exists = function vmExists(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    vmadm.load(opts, {fields: ['uuid']}, function _onLoad(err, vm) {
-        if (err) {
-            if (err.restCode === 'VmNotFound') {
-                callback(null, false);
-                return;
-            }
-            callback(err);
-            return;
-        }
-
-        if (vm.do_not_inventory && !opts.include_dni) {
-            /*
-             * VM is marked do_not_inventory. And we don't have include_dni
-             * option set indicating we want to include those, so we treat the
-             * same as not existing.
-             */
-            opts.log.trace(err, 'vmadm.exists(): ' + opts.uuid +
-                ' has do_not_inventory');
-            callback(null, false);
-            return;
-        }
-
-        callback(null, true);
-        return;
-    });
-};
-
-
-/**
- * Call `vmadm get UUID`.
- *
- * @param opts {Object} Options
- *      - uuid {String} The VM uuid.
- *      - log {Logger object}
- * @param vmopts {Object} Optional vm options
- *      - fields {Array} Return only the keys give in `fields` array
- *      - include_dni {Boolean} If true, return VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.load = function vmLoad(opts, vmopts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-    assert.object(opts.sysinfo, 'opts.sysinfo');
-    assert.uuid(opts.sysinfo.UUID, 'opts.sysinfo.UUID');
-
-    if (!callback) {
-        callback = vmopts;
-    }
-
-    opts.log.trace({
-        req_id: opts.req_id,
-        uuid: opts.uuid
-    }, 'loading VM');
-
-    loadVm({
-        sysinfo: opts.sysinfo,
-        uuid: opts.uuid
-    }, function _onVmLoad(err, vm) {
-        var notFoundErr;
-
-        if (err && err.code === 'ENOENT') {
-            notFoundErr = new Error('vmadm load ' + opts.uuid +
-                ' failed: No such zone');
-            notFoundErr.restCode = 'VmNotFound';
-            callback(notFoundErr);
-            return;
-        } else if (err) {
-            callback(err);
-            return;
-        }
-
-        if (vm.do_not_inventory && !opts.include_dni) {
-            // Unless the caller is specifically asking for VMs that are
-            // do_not_inventory, we treat them the same a VMs that don't exist.
-            notFoundErr = new Error('vmadm load ' + opts.uuid +
-                ' failed: No such zone');
-            notFoundErr.restCode = 'VmNotFound';
-            callback(notFoundErr);
-            return;
-        }
-
-        if (opts.fields) {
-            Object.keys(vm).forEach(function _removeUnwantedFields(field) {
-                if (opts.fields.indexOf(field) === -1) {
-                    // not a field we want
-                    delete vm[field];
-                }
-            });
-        }
-
-        callback(null, vm);
-        return;
-    });
-};
-
-
-/**
- * Call `vmadm create`.
- *
- * @param opts {Object} Options
- *      - log {Logger object}
- * @param callback {Function} `function (err, info)`
- */
-
-vmadm.create = function vmCreate(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-
-    var log = opts.log;
-    var payload = opts;
-    var sysinfo = jsprim.deepCopy(payload.sysinfo);
-    var req_id;
-
-    req_id = opts.req_id;
-
-    delete payload.log;
-    delete payload.req_id;
-    delete payload.sysinfo;
-    delete payload.vmadmLogger;
-
-    log.trace({
-        req_id: req_id,
-        payload: payload
-    }, 'creating VM');
-
-    assert.uuid(payload.uuid, 'payload.uuid');
-
-    payload.state = 'running';
-    payload.autoboot = true;
-    payload.create_timestamp = (new Date()).toISOString();
-
-    // TODO:
-    //
-    //   strip out properties we don't care about, validate ones we do.
-    //   convert disks to final versions
-    //   fill in other fields that happen in real vmadm
-    //
-
-    writeVm(payload, {
-        log: log,
-        sysinfo: sysinfo
-    }, function _onWrite(err) {
-        callback(err);
-    });
-};
-
-
-/**
- * Call `vmadm delete <uuid>`.
- *
- * @param opts {Object} Options
- *      - uuid {String} UUID of VM to delete
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, delete VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.delete = function vmDelete(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    var filename;
-    var vmdir;
-
-    vmdir = path.join(common.SERVER_ROOT, opts.sysinfo.UUID, 'vms');
-
-    opts.log.trace({
-        req_id: opts.req_id,
-        uuid: opts.uuid
-    }, 'deleting VM');
-
-    assert.uuid(opts.uuid, 'opts.uuid');
-    filename = path.join(vmdir, opts.uuid + '.json');
-
-    vasync.pipeline({
-        funcs: [
-            // TODO: stop the instance, do any other cleanup
-            function _unlinkFile(_, cb) {
-                fs.unlink(filename, function _onUnlink(err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-
-                    cb();
-                });
-            }
-        ]
-    }, function _onDeleted(err) {
-        opts.log.info({err: err, uuid: opts.uuid}, 'delete VM');
-        callback(err);
-    });
-};
-
-
-/**
- * Call `vmadm update`.
- *
- * @param opts {Object} VMADM update payload
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, update VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.update = function vmUpdate(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    var log = opts.log;
-    var payload = opts;
-    var req_id = opts.req_id;
-
-    delete payload.log;
-    delete payload.req_id;
-    delete payload.vmadmLogger;
-
-    log.trace({
-        payload: payload,
-        req_id: req_id,
-        uuid: opts.uuid
-    }, 'updating VM');
-
-    // TODO: this should actually update
-
-    callback();
-};
-
-
-function writeVm(vmobj, opts, callback) {
-    var fd;
-    var filename;
-    var finalFilename;
-    var vmdir;
-
-    vmdir = path.join(common.SERVER_ROOT, opts.sysinfo.UUID, 'vms');
-    filename = path.join(vmdir, vmobj.uuid + '.json');
-
-    if (opts.atomicReplace) {
-        finalFilename = filename;
-        filename = filename + '.' + process.pid;
-    }
-
-    vasync.pipeline({
-        funcs: [
-            function _openFile(_, cb) {
-                fs.open(filename, 'wx', function _onOpen(err, openedFd) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-
-                    fd = openedFd;
-                    cb();
-                });
-            }, function _writeThenCloseFile(_, cb) {
-                var buf = new Buffer(JSON.stringify(vmobj, null, 2));
-
-                fs.write(fd, buf, 0, buf.length, null, function _onWrite(err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    fs.close(fd, function _onWritten() {
-                        cb();
-                    });
-                });
-            }, function _atomicReplace(_, cb) {
-                if (!opts.atomicReplace) {
-                    cb();
-                    return;
-                }
-
-                fs.rename(filename, finalFilename, cb);
-            }
-        ]
-    }, function _onWroteVm(err) {
-        opts.log.info({err: err, uuid: vmobj.uuid}, 'wrote VM');
-        callback(err);
-    });
-}
-
-
-/**
- * Call `vmadm reboot <uuid>`.
- *
- * @param opts {Object} Options
- *      - uuid {String} UUID of VM to reboot
- *      - force {Boolean} Whether to force the reboot.
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, reboot VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.reboot = function vmReboot(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    var args = [];
-
-    if (opts.force) {
-        args.push('-F');
-    }
-
-    opts.log.trace({
-        args: args,
-        force: Boolean(opts.force),
-        req_id: opts.req_id,
-        uuid: opts.uuid
-    }, 'rebooting VM');
-
-    // TODO: this should actually reboot
-
-    callback();
-};
-
-
-/**
- * Call `vmadm lookup -j`.
- *
- * @param opts {Object} Options
- *      - uuid {String} The VM uuid.
- *      - log {Logger object}
- * @param vmopts {Object} Optional vm options
- *      - fields {Array} Return only the keys give in `fields` array
- *      - include_dni {Boolean} If true, return VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err, vms)`
- */
-
-vmadm.lookup = function vmLookup(search, opts, callback) {
-    assert.object(search, 'search');
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    opts.log.error({
-        req_id: opts.req_id,
-        search: search
-    }, 'lookup VMs');
-
-
-    // XXX can't we also specify fields in opts?
-
-    loadVms({}, function _onLoadVms(err, loadedVms) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        if (JSON.stringify(search) === '{}') {
-            // no search, just return all VMs
-            callback(null, loadedVms);
-            return;
-        }
-
-        assert.ok(false, 'Don\'t yet know how to handle search: ' +
-            JSON.stringify(search));
-    });
-};
-
-
-/**
- * Call `vmadm start <uuid>`.
- *
- * @param opts {Object} Options
- *      - uuid {String} UUID of VM to start
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, start VMs that have do_not_inventory
- *        set. default: false.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.start = function vmStart(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    opts.log.trace({
-        req_id: opts.req_id,
-        uuid: opts.uuid
-    }, 'start VM');
-
-
-    // TODO: this should actually do the start
-
-    loadVm({
-        sysinfo: opts.sysinfo,
-        uuid: opts.uuid
-    }, function _onLoad(err, vmobj) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        vmobj.autoboot = true;
-        vmobj.state = 'running';
-
-        writeVm(vmobj, {
-            atomicReplace: true,
-            log: opts.log,
-            sysinfo: opts.sysinfo
-        }, function _onWrite(writeErr) {
-            callback(writeErr);
-        });
-    });
-};
-
-
-/**
- * Call `vmadm stop <uuid>`.
- *
- * @param opts {Object} Options
- *      - uuid {String} UUID of VM to stop
- *      - force {Boolean} Whether to force the stop
- *      - log {Logger object}
- *      - include_dni {Boolean} If true, stop VMs that have do_not_inventory
- *        set. default: false.
- *      - timeout {Number} If set, timeout in seconds between sending SIGTERM
- *        and SIGKILL when stopping docker containers.
- * @param callback {Function} `function (err)`
- */
-
-vmadm.stop = function vmStop(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.req_id, 'opts.req_id');
-    assert.optionalNumber(opts.timeout, 'opts.timeout');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.optionalBool(opts.include_dni, 'opts.include_dni');
-
-    opts.log.trace({
-        req_id: opts.req_id,
-        uuid: opts.uuid
-    }, 'stop VM');
-
-    // TODO: this should actually do the stop
-
-    loadVm({
-        sysinfo: opts.sysinfo,
-        uuid: opts.uuid
-    }, function _onLoad(err, vmobj) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        vmobj.autoboot = false;
-        vmobj.state = 'stopped';
-
-        writeVm(vmobj, {
-            atomicReplace: true,
-            log: opts.log,
-            sysinfo: opts.sysinfo
-        }, function _onWrite(writeErr) {
-            callback(err);
-        });
-    });
-};
-
-
-vmadm._deleteAllWatchers = function _deleteAllWatchers() {
-    var self = this;
-    var filename;
-    var idx;
-    var keys;
-
-    keys = Object.keys(self.fileWatches);
-    for (idx = 0; idx < keys.length; idx++) {
-        filename = keys[idx];
-
-        console.error('DELETE WATCH: ' + filename);
-
-        self.fileWatches[filename].close();
-        delete self.fileWatches[filename];
-    }
-};
-
-// wrap handler in a closure so we can keep the filename
-function wrapHandler(filename, handler) {
-    var fn = filename.slice(0);
-
-    return (function _onFileEvent(evt) {
-        handler(evt, fn);
-    });
-}
-
-function zoneFromFilename(filename) {
-    var matches;
-
-    /* jsl:ignore (assignment in if()) */
-    if (matches = filename.match(/^(.*)\.json$/)) {
-        assert.uuid(matches[1], 'zonename');
-        return (matches[1]);
-    }
-    /* jsl:end */
-
-    return undefined;
-}
-
-vmadm._dispatchEvent =
-function _dispatchEvent(evtName, zonename, opts, handler) {
-    var self = this;
-
-    assert.string(evtName, 'evtName');
-    assert.uuid(zonename, 'zonename');
-    assert.object(opts, 'opts');
-    assert.object(opts.sysinfo, 'opts.sysinfo');
-    assert.func(handler, 'handler');
-
-    if (self.loadingVms[zonename]) {
-        console.error('skipping ' + zonename
-            + ' which is already being loaded');
-        return;
-    }
-    self.loadingVms[zonename] = (new Date()).getTime();
-
-    loadVm({
-        sysinfo: opts.sysinfo,
-        uuid: zonename
-    }, function _onVmLoad(err, vmobj) {
-        delete self.loadingVms[zonename];
-
-        if (err && err.code === 'ENOENT') {
-            if (evtName === 'delete') {
-                handler({
-                    type: 'delete',
-                    vm: {},
-                    zonename: zonename
-                });
-            } else {
-                console.error('VM ' + zonename + ' unexpectedly disappeared '
-                    + 'while loading after ' + evtName);
-            }
-            return;
-        }
-
-       if (err) {
-            console.error('error loading ' + zonename + ': ' + err.message);
-            return;
-        }
-
-        handler({
-            type: evtName,
-            vm: vmobj,
-            zonename: zonename
-        });
-    });
-};
-
-vmadm.events = function vmEvents(opts, handler, callback) {
-    var self = this;
-
-    var vmdir = path.join(common.SERVER_ROOT, opts.sysinfo.UUID, 'vms');
-
-    self.fileWatches = {};
-    self.loadingVms = {};
-
-    // load initial set of files so we know when things change
-    fs.readdir(vmdir, function _onReadDir(err, files) {
-        var filename;
-        var idx;
-        var modifyHandler;
-
-        // XXX what to do on error
-
-        self.instanceFiles = files;
-
-        for (idx = 0; idx < files.length; idx++) {
-            filename = files[idx];
-
-            if (!zoneFromFilename(filename)) {
-                console.error('ignoring non-vm: ' + filename);
-                continue;
-            }
-
-            // need to make a closure with a copy of the filename since
-            // node doesn't give it to us w/ the event.
-            modifyHandler = wrapHandler(filename, function _onModify(evt, fn) {
-                fs.exists(path.join(vmdir, fn), function _onExists(exists) {
-                    if (exists) {
-                        self._dispatchEvent('modify', zoneFromFilename(fn),
-                            {sysinfo: opts.sysinfo}, handler);
-                    } else {
-                        console.error('ignoring modify event for deleted '
-                            + 'file: ' + fn);
-                    }
-                });
-            });
-
-            self.fileWatches[filename] =
-                fs.watch(path.join(vmdir, filename), {}, modifyHandler);
-        }
-    });
-
-    self.fileWatches[vmdir] =
-    fs.watch(vmdir, {}, function _onDirEvent(evt) {
-        fs.readdir(vmdir, function _onRead(err, files) {
-            var filename;
-            var idx;
-            var modifyHandler;
-
-            // XXX what to do on error
-
-            // XXX this is a pretty inefficient way to generate the
-            // added/deleted
-
-            for (idx = 0; idx < files.length; idx++) {
-                filename = files[idx];
-
-                if (!zoneFromFilename(filename)) {
-                    console.error('ignoring non-vm: ' + filename);
-                    continue;
-                }
-
-                if (self.instanceFiles.indexOf(filename) === -1) {
-                    // didn't exist before, exists now: added
-                    assert.equal(self.fileWatches[filename], undefined,
-                        'file should not already have a watcher');
-
-                    // need to make a closure with a copy of the filename since
-                    // node doesn't give it to us w/ the event.
-                    modifyHandler = wrapHandler(filename,
-                        function _onModify(_, fn) {
-
-                        fs.exists(path.join(vmdir, fn),
-                            function _onExists(exists) {
-
-                            if (exists) {
-                                self._dispatchEvent('modify',
-                                    zoneFromFilename(fn),
-                                    {sysinfo: opts.sysinfo}, handler);
-                            } else {
-                                console.error('ignoring modify event for '
-                                    + 'deleted file: ' + fn);
-                            }
-                        });
-                    });
-
-                    self.fileWatches[filename] =
-                        fs.watch(path.join(vmdir, filename), {},
-                            modifyHandler);
-
-                    self._dispatchEvent('create', zoneFromFilename(filename),
-                        {sysinfo: opts.sysinfo}, handler);
-                }
-            }
-
-            for (idx = 0; idx < self.instanceFiles.length; idx++) {
-                filename = self.instanceFiles[idx];
-                if (files.indexOf(filename) === -1) {
-                    // existed before, doesn't exist now: deleted
-                    if (self.fileWatches[filename]) {
-                        self.fileWatches[filename].close();
-                        delete self.fileWatches[filename];
-                    }
-
-                    self._dispatchEvent('delete', zoneFromFilename(filename),
-                        {sysinfo: opts.sysinfo}, handler);
-                }
-            }
-
-            // replace with new list
-            self.instanceFiles = files;
-        });
-    });
-
-    callback(null, {
-        ev: {
-            date: (new Date()).toISOString(),
-            type: 'ready'
-            // uuid: ?
-            // vms: { "uuid": { ...
-        },
-        stop: function _stop() {
-            self._deleteAllWatchers();
-        }
-    });
-};
-
-module.exports = vmadm;
diff --git a/lib/backends/dummy/tasks/machine_boot.js b/lib/backends/dummy/tasks/machine_boot.js
index e84d806..5ee2981 100644
--- a/lib/backends/dummy/tasks/machine_boot.js
+++ b/lib/backends/dummy/tasks/machine_boot.js
@@ -8,10 +8,11 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
 
+var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
+
 
 var MachineBootTask = module.exports = function (req) {
     Task.call(this);
@@ -39,12 +40,21 @@ function start(callback) {
     var idempotent = false;
     var self = this;
     var uuid = self.req.params.uuid;
+    var vmadm;
     var vmadmOpts = {};
 
     vmadmOpts.log = self.log;
     vmadmOpts.req_id = self.req.req_id;
     vmadmOpts.sysinfo = self.req.sysinfo;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     if (self.req.params.idempotent === true ||
         self.req.params.idempotent === 'true') {
 
diff --git a/lib/backends/dummy/tasks/machine_create.js b/lib/backends/dummy/tasks/machine_create.js
index 024b7b5..bb12e82 100644
--- a/lib/backends/dummy/tasks/machine_create.js
+++ b/lib/backends/dummy/tasks/machine_create.js
@@ -14,13 +14,17 @@ var path = require('path');
 
 // node_modules
 var assert = require('assert-plus');
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
 var vasync = require('vasync');
-var vmadm = require('../lib/vmadm');
 
 // local
 var common = require('../common');
 var Task = require('../../../task_agent/task');
 
+// global, gets created by start()
+var vmadm;
+
+
 var DISK_PAYLOAD = {
     image_name: true,
     image_size: true,
@@ -47,6 +51,7 @@ var NIC_PAYLOAD = {
     vlan_id: true
 };
 var VM_PAYLOAD = {
+    autoboot: true,
     alias: true,
     archive_on_delete: true,
     billing_id: true,
@@ -62,6 +67,7 @@ var VM_PAYLOAD = {
     firewall_enabled: false,
     image: false,
     image_uuid: true,
+    internal_metadata: true,
     gpus: true,
     max_lwps: true,
     max_physical_memory: true,
@@ -73,6 +79,7 @@ var VM_PAYLOAD = {
     quota: true,
     ram: true,
     resolvers: true,
+    tags: true,
     uuid: true,
     vcpus: true,
     zfs_io_priority: false
@@ -95,6 +102,14 @@ function start(callback) {
 
     var creationGuardFilename;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     vasync.pipeline({
         arg: {
             sysinfo: self.sysinfo
@@ -305,7 +320,9 @@ function map_payload(opts, payload) {
             newPayload.disks = {};
         }
     }
-    newPayload.autoboot = true;
+    if (!newPayload.hasOwnProperty('autoboot')) {
+        newPayload.autoboot = true;
+    }
     newPayload.datasets = [];
     newPayload.limit_priv = 'default';
     if (newPayload.max_locked_memory === undefined &&
diff --git a/lib/backends/dummy/tasks/machine_create_snapshot.js b/lib/backends/dummy/tasks/machine_create_snapshot.js
new file mode 100644
index 0000000..c718105
--- /dev/null
+++ b/lib/backends/dummy/tasks/machine_create_snapshot.js
@@ -0,0 +1,76 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var common = require('../common');
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+var Task = require('../../../task_agent/task');
+
+var MachineCreateSnapshotTask = module.exports = function (req) {
+    Task.call(this);
+    this.req = req;
+};
+
+Task.createTask(MachineCreateSnapshotTask);
+
+function start(callback) {
+    var self = this;
+    var opts = {};
+    var vmadm;
+
+    opts = self.req.params;
+    opts.log = self.log;
+    opts.req_id = self.req.req_id;
+
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
+    vmadm.create_snapshot(opts, function (error) {
+        var loadOpts = {};
+
+        if (error) {
+            var msg = error instanceof Error ? error.message : error;
+            if (error.restCode) {
+                self.fatal('vmadm.create_snapshot error: ' + msg,
+                    { restCode: error.restCode });
+            } else {
+                self.fatal('vmadm.create_snapshot error: ' + msg);
+            }
+            return;
+        }
+
+        loadOpts.log = self.log;
+        loadOpts.req_id = self.req.req_id;
+        loadOpts.uuid = self.req.params.uuid;
+
+        vmadm.load(
+            loadOpts,
+            function (loadError, machine)
+        {
+            if (loadError) {
+                if (loadError.restCode) {
+                    self.fatal('vmadm.load error: ' + loadError.message,
+                        { restCode: loadError.restCode });
+                } else {
+                    self.fatal('vmadm.load error: ' + loadError.message);
+                }
+                return;
+            }
+
+            self.finish({ vm: machine });
+        });
+    });
+}
+
+MachineCreateSnapshotTask.setStart(start);
diff --git a/lib/backends/dummy/tasks/machine_delete_snapshot.js b/lib/backends/dummy/tasks/machine_delete_snapshot.js
new file mode 100644
index 0000000..b5d7033
--- /dev/null
+++ b/lib/backends/dummy/tasks/machine_delete_snapshot.js
@@ -0,0 +1,78 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var common = require('../common');
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+var Task = require('../../../task_agent/task');
+
+var MachineDeleteSnapshotTask = module.exports = function (req) {
+    Task.call(this);
+    this.req = req;
+};
+
+Task.createTask(MachineDeleteSnapshotTask);
+
+function start(callback) {
+    var self = this;
+    var opts = {};
+    var vmadm;
+
+    opts = self.req.params;
+    opts.log = self.log;
+    opts.req_id = self.req.req_id;
+
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
+    vmadm.delete_snapshot(opts, function (error) {
+        var loadOpts = {};
+
+        if (error &&
+            !(error.message && error.message.match('No snapshot named'))) {
+
+            var msg = error instanceof Error ? error.message : error;
+            if (error.restCode) {
+                self.fatal('vmadm.delete_snapshot error: ' + msg,
+                    { restCode: error.restCode });
+            } else {
+                self.fatal('vmadm.delete_snapshot error: ' + msg);
+            }
+            return;
+        }
+
+        loadOpts.log = self.log;
+        loadOpts.req_id = self.req.req_id;
+        loadOpts.uuid = self.req.params.uuid;
+
+        vmadm.load(
+            loadOpts,
+            function (loadError, machine)
+        {
+            if (loadError) {
+                if (loadError.restCode) {
+                    self.fatal('vmadm.load error: ' + loadError.message,
+                        { restCode: loadError.restCode });
+                } else {
+                    self.fatal('vmadm.load error: ' + loadError.message);
+                }
+                return;
+            }
+
+            self.finish({ vm: machine });
+        });
+    });
+}
+
+MachineDeleteSnapshotTask.setStart(start);
diff --git a/lib/backends/dummy/tasks/machine_destroy.js b/lib/backends/dummy/tasks/machine_destroy.js
index 63a8762..60a7c53 100644
--- a/lib/backends/dummy/tasks/machine_destroy.js
+++ b/lib/backends/dummy/tasks/machine_destroy.js
@@ -10,9 +10,10 @@
 
 var vasync = require('vasync');
 
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+
 var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
 
 
 var MachineDestroyTask = module.exports = function (req) {
@@ -25,6 +26,7 @@ Task.createTask(MachineDestroyTask);
 function start() {
     var self = this;
     var uuid = self.req.params.uuid;
+    var vmadm;
     var vmadmOpts = {};
 
     vmadmOpts.log = self.log;
@@ -32,6 +34,14 @@ function start() {
     vmadmOpts.uuid = uuid;
     vmadmOpts.sysinfo = self.req.sysinfo;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     vasync.pipeline({
         funcs: [
             function ensureProvisionComplete(_, cb) {
diff --git a/lib/backends/dummy/tasks/machine_load.js b/lib/backends/dummy/tasks/machine_load.js
index 2185870..126fee3 100644
--- a/lib/backends/dummy/tasks/machine_load.js
+++ b/lib/backends/dummy/tasks/machine_load.js
@@ -10,8 +10,11 @@
 
 var assert = require('assert-plus');
 
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+
+var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
+
 
 var MachineLoadTask = module.exports = function (req) {
     Task.call(this);
@@ -23,6 +26,7 @@ Task.createTask(MachineLoadTask);
 function start(callback) {
     var self = this;
     var opts = {};
+    var vmadm;
 
     assert.object(self.log, 'self.log');
     assert.object(self.req, 'self.req');
@@ -37,6 +41,14 @@ function start(callback) {
     opts.sysinfo = self.sysinfo;
     opts.uuid = self.req.params.uuid;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     vmadm.load(opts, function _onLoad(error, vmobj) {
         var msg;
 
diff --git a/lib/backends/dummy/tasks/machine_reboot.js b/lib/backends/dummy/tasks/machine_reboot.js
index 9e01a5e..d309f3a 100644
--- a/lib/backends/dummy/tasks/machine_reboot.js
+++ b/lib/backends/dummy/tasks/machine_reboot.js
@@ -8,10 +8,11 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
 
+var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
+
 
 var MachineRebootTask = module.exports = function (req) {
     Task.call(this);
@@ -42,12 +43,21 @@ function start(callback) {
     var opts = {};
     var timeout = self.req.params.timeout;
     var uuid = self.req.params.uuid;
+    var vmadm;
     var vmadmOpts = {};
 
     vmadmOpts.log = self.log;
     vmadmOpts.req_id = self.req.req_id;
     vmadmOpts.sysinfo = self.req.sysinfo;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     function _addVmadmOpts(obj) {
         var newobj = obj;
 
diff --git a/lib/backends/dummy/tasks/machine_reprovision.js b/lib/backends/dummy/tasks/machine_reprovision.js
new file mode 100644
index 0000000..a0f295d
--- /dev/null
+++ b/lib/backends/dummy/tasks/machine_reprovision.js
@@ -0,0 +1,201 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var fs = require('fs');
+
+var async = require('async');
+
+var common = require('../common');
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+var Task = require('../../../task_agent/task');
+
+var vmadm;
+var MachineReprovisionTask = module.exports = function (req) {
+    Task.call(this);
+    this.req = req;
+    this.zpool = req.params.zfs_storage_pool_name || 'zones';
+};
+
+Task.createTask(MachineReprovisionTask);
+
+
+function start(callback) {
+    var self = this;
+    var provisionGuardFilename;
+
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
+    self.pre_check(function (error) {
+        if (error) {
+            self.fatal(error.message);
+            return;
+        }
+
+        async.waterfall([
+            function (cb) {
+                common.provisionInProgressFile(
+                    self.req.params.uuid,
+                    function (err, filename) {
+                        provisionGuardFilename = filename;
+                        cb();
+                        return;
+                    });
+            },
+            self.ensure_dataset_present.bind(self),
+            function (found, cb) {
+                // The previous step (ensure..) returns a boolean indicating
+                // whether the dataset was found. If that flag is set, we'll
+                // run this (fetch) step and skip it if not.
+                if (!found) {
+                    return self.fetch_dataset(cb);
+                } else {
+                    return cb();
+                }
+            },
+            self.reprovision_machine.bind(self)
+        ],
+        function (err) {
+            fs.unlink(provisionGuardFilename, function () {
+                var loadOpts = {};
+
+                loadOpts.log = self.log;
+                loadOpts.req_id = self.req.req_id;
+                loadOpts.uuid = self.req.params.uuid;
+
+                if (err) {
+                    self.fatal(err.message);
+                    return;
+                }
+
+                vmadm.load(
+                    loadOpts,
+                    function (loadError, machine)
+                {
+                    if (loadError) {
+                        self.fatal('vmadm.load error: ' + loadError.message);
+                        return;
+                    }
+
+                    self.finish({ vm: machine });
+                });
+            });
+        });
+    });
+}
+
+function pre_check(callback) {
+    var opts = {};
+    var self = this;
+
+    opts.uuid = self.req.params.uuid;
+    opts.log = self.log;
+
+    async.waterfall([
+        function (cb) {
+            // fail if zone does not exist
+            vmadm.exists(opts, function (err, exists) {
+                if (err) {
+                    cb(err);
+                    return;
+                } else if (!exists) {
+                    cb(new Error('VM ' + opts.uuid + ' does not exist.'));
+                    return;
+                }
+                cb();
+            });
+        }
+    ],
+    function (error) {
+        if (error) {
+            callback(error);
+            return;
+        }
+        callback();
+    });
+}
+
+function ensure_dataset_present(callback) {
+    var self = this;
+
+    var imageUuid = '<unknown>';
+    var params = self.req.params;
+
+    if (params.image_uuid) {
+        imageUuid = params.image_uuid;
+    }
+
+    // TODO: check whether dataset exists, set callback arg appropriately.
+    self.log.info('Dataset ' + imageUuid + ' exists.');
+    callback(null, true);
+}
+
+function fetch_dataset(callback) {
+    var self = this;
+
+    var imageUuid = '<unknown>';
+    var params = self.req.params;
+
+    if (params.image_uuid) {
+        imageUuid = params.image_uuid;
+    }
+
+    // This just pretends all images are already downloaded for now
+    self.log.info('Dataset ' + imageUuid + ' exists, not fetching.');
+    callback();
+}
+
+function reprovision_machine(callback) {
+    var self = this;
+    var opts = {};
+
+    opts = self.req.params;
+    opts.log = self.log;
+    opts.req_id = self.req.req_id;
+    opts.uuid = self.req.params.uuid;
+
+    vmadm.reprovision(opts, function (error) {
+        if (error) {
+            var msg = error instanceof Error ? error.message : error;
+            return callback(new Error('vmadm.reprovision error: ' + msg));
+        }
+        return callback();
+    });
+}
+
+MachineReprovisionTask.setStart(start);
+
+MachineReprovisionTask.createSteps({
+    pre_check: {
+        fn: pre_check,
+        progress: 20,
+        description: 'Pre-flight sanity check'
+    },
+    ensure_dataset_present: {
+        fn: ensure_dataset_present,
+        progress: 30,
+        description: 'Checking for zone template dataset'
+    },
+    fetch_dataset: {
+        fn: fetch_dataset,
+        progress: 50,
+        description: 'Fetching zone template dataset'
+    },
+    reprovision_machine: {
+        fn: reprovision_machine,
+        progress: 100,
+        description: 'Reprovisioning machine'
+    }
+});
diff --git a/lib/backends/dummy/tasks/machine_rollback_snapshot.js b/lib/backends/dummy/tasks/machine_rollback_snapshot.js
new file mode 100644
index 0000000..3ecca82
--- /dev/null
+++ b/lib/backends/dummy/tasks/machine_rollback_snapshot.js
@@ -0,0 +1,76 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var common = require('../common');
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
+var Task = require('../../../task_agent/task');
+
+var MachineRollbackSnapshotTask = module.exports = function (req) {
+    Task.call(this);
+    this.req = req;
+};
+
+Task.createTask(MachineRollbackSnapshotTask);
+
+function start(callback) {
+    var self = this;
+    var opts = {};
+    var vmadm;
+
+    opts = self.req.params;
+    opts.log = self.log;
+    opts.req_id = self.req.req_id;
+
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
+    vmadm.rollback_snapshot(opts, function (error) {
+        var loadOpts = {};
+
+        if (error) {
+            var msg = error instanceof Error ? error.message : error;
+            if (error.restCode) {
+                self.fatal('vmadm.rollback_snapshot error: ' + msg,
+                    { restCode: error.restCode });
+            } else {
+                self.fatal('vmadm.rollback_snapshot error: ' + msg);
+            }
+            return;
+        }
+
+        loadOpts.log = self.log;
+        loadOpts.req_id = self.req.req_id;
+        loadOpts.uuid = self.req.params.uuid;
+
+        vmadm.load(
+            loadOpts,
+            function (loadError, machine)
+        {
+            if (loadError) {
+                if (loadError.restCode) {
+                    self.fatal('vmadm.load error: ' + loadError.message,
+                        { restCode: loadError.restCode });
+                } else {
+                    self.fatal('vmadm.load error: ' + loadError.message);
+                }
+                return;
+            }
+
+            self.finish({ vm: machine });
+        });
+    });
+}
+
+MachineRollbackSnapshotTask.setStart(start);
diff --git a/lib/backends/dummy/tasks/machine_shutdown.js b/lib/backends/dummy/tasks/machine_shutdown.js
index 205d88a..ba35a6a 100644
--- a/lib/backends/dummy/tasks/machine_shutdown.js
+++ b/lib/backends/dummy/tasks/machine_shutdown.js
@@ -8,10 +8,11 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
 
+var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
+
 
 var MachineShutdownTask = module.exports = function (req) {
     Task.call(this);
@@ -43,6 +44,7 @@ function start(callback) {
     var loadOpts = {};
     var stopOpts = {};
     var timeout = self.req.params.timeout;
+    var vmadm;
     var vmadmOpts = {};
 
     vmadmOpts.log = self.log;
@@ -55,6 +57,14 @@ function start(callback) {
     stopOpts = vmadmOpts;
     stopOpts.uuid = self.req.params.uuid;
 
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
+
     if (self.req.params.force) {
         stopOpts.force = true;
     }
diff --git a/lib/backends/dummy/tasks/machine_update.js b/lib/backends/dummy/tasks/machine_update.js
index 985dc20..8cc1df0 100644
--- a/lib/backends/dummy/tasks/machine_update.js
+++ b/lib/backends/dummy/tasks/machine_update.js
@@ -8,10 +8,11 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
+var DummyVmadm = require('vmadm/lib/index.dummy_vminfod');
 
+var common = require('../common');
 var Task = require('../../../task_agent/task');
-var vmadm = require('../lib/vmadm');
+
 
 var MachineUpdateTask = module.exports = function (req) {
     Task.call(this);
@@ -23,11 +24,20 @@ Task.createTask(MachineUpdateTask);
 function start(callback) {
     var self = this;
     var uuid = self.req.params.uuid;
+    var vmadm;
     var vmadmOpts = {};
 
     vmadmOpts.log = self.log;
     vmadmOpts.req_id = self.req.req_id;
-    vmadmOpts.sysinfo = self.req.sysinfo;
+    // vmadmOpts.sysinfo = self.req.sysinfo;
+
+    // Create a new vmadm just for this server
+    vmadm = new DummyVmadm({
+        log: self.log,
+        serverRoot: common.SERVER_ROOT,
+        sysinfo: self.sysinfo,
+        uuid: self.sysinfo.UUID
+    });
 
     function _addVmadmOpts(obj) {
         var newobj = obj;
diff --git a/lib/backends/dummy/tasks/nop.js b/lib/backends/dummy/tasks/nop.js
index 5e835fa..bf1ad52 100644
--- a/lib/backends/dummy/tasks/nop.js
+++ b/lib/backends/dummy/tasks/nop.js
@@ -8,8 +8,6 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
-
 var Task = require('../../../task_agent/task');
 
 var Sleep = module.exports = function (req) {
diff --git a/lib/backends/dummy/tasks/server_update_nics.js b/lib/backends/dummy/tasks/server_update_nics.js
new file mode 100644
index 0000000..002425f
--- /dev/null
+++ b/lib/backends/dummy/tasks/server_update_nics.js
@@ -0,0 +1,145 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var fs = require('fs');
+var path = require('path');
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var common = require('../common');
+var SysinfoGetter = require('../lib/sysinfo');
+var Task = require('../../../task_agent/task');
+
+
+var NicUpdateTask = module.exports = function (req) {
+    Task.call(this);
+    this.req = req;
+};
+
+Task.createTask(NicUpdateTask);
+
+function writeSysinfo(opts, sysinfo, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.serverRoot, 'opts.serverRoot');
+    assert.object(sysinfo, 'sysinfo');
+    assert.func(callback, 'callback');
+
+    var fd;
+    var filename;
+    var tmpFilename;
+
+    filename = path.join(opts.serverRoot, sysinfo.UUID, 'sysinfo.json');
+    tmpFilename = filename + '.' + process.pid;
+
+    vasync.pipeline({
+        funcs: [
+            function _openFile(_, cb) {
+                fs.open(tmpFilename, 'wx', function _onOpen(err, openedFd) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+
+                    fd = openedFd;
+                    cb();
+                });
+            }, function _writeThenCloseFile(_, cb) {
+                var buf = new Buffer(JSON.stringify(sysinfo, null, 2) + '\n');
+
+                fs.write(fd, buf, 0, buf.length, null, function _onWrite(err) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    fs.close(fd, function _onWritten() {
+                        cb();
+                    });
+                });
+            }, function _atomicReplace(_, cb) {
+                fs.rename(tmpFilename, filename, cb);
+            }
+        ]
+    }, function _onWroteSysinfo(err) {
+        opts.log.debug({err: err, sysinfo: sysinfo}, 'wrote sysinfo');
+        callback(err);
+    });
+}
+
+function start() {
+    var self = this;
+    var serverRoot = common.SERVER_ROOT;
+
+    assert.object(self.req, 'self.req');
+    assert.object(self.req.sysinfo, 'self.req.sysinfo');
+    assert.object(self.req.serverAddress, 'self.req.serverAddress');
+
+    (new SysinfoGetter()).get({
+        serverAddress: self.req.serverAddress,
+        serverUuid: self.req.sysinfo.UUID
+    }, function _onSysinfo(getErr, sysinfo) {
+        var idx;
+        var iface;
+        var mac;
+        var macToIface = {};
+        var modified = false;
+        var nic;
+        var nicKeys;
+
+        if (getErr) {
+            self.fatal(getErr.message);
+            return;
+        }
+
+        self.progress(20);
+
+        nicKeys = Object.keys(sysinfo['Network Interfaces']);
+
+        for (idx = 0; idx < nicKeys.length; idx++) {
+            nic = sysinfo['Network Interfaces'][nicKeys[idx]];
+            assert.string(nic['MAC Address'], 'nic[\'MAC Address\']');
+            mac = nic['MAC Address'];
+            macToIface[mac] = nicKeys[idx];
+        }
+
+        for (idx = 0; idx < self.req.params.nics.length; idx++) {
+            nic = self.req.params.nics[idx];
+            if (macToIface.hasOwnProperty(nic.mac)) {
+                iface = macToIface[nic.mac];
+                sysinfo['Network Interfaces'][iface]['NIC Names'] =
+                    nic.nic_tags_provided;
+                modified = true;
+            } else {
+                self.log.error({nic: nic}, 'unknown NIC');
+            }
+        }
+
+        if (modified) {
+            writeSysinfo({
+                log: self.log,
+                serverRoot: serverRoot
+            },
+            sysinfo,
+            function _onWroteSysinfo(err) {
+                if (err) {
+                    self.fatal(err.message);
+                    return;
+                }
+
+                self.finish({sysinfo: sysinfo});
+            });
+        } else {
+            self.finish({sysinfo: sysinfo});
+        }
+    });
+}
+
+NicUpdateTask.setStart(start);
diff --git a/lib/task_agent/task_agent.js b/lib/task_agent/task_agent.js
index 199800c..beb9fe1 100644
--- a/lib/task_agent/task_agent.js
+++ b/lib/task_agent/task_agent.js
@@ -146,9 +146,11 @@ TaskAgent.prototype.setupTaskRoutes = function (defns) {
             }
         }
 
+        // All this data will end up being passed as req to the tasks' start().
         var params = {
             req_id: req.getId(),
             req_host: req.headers.host,
+            serverAddress: self.agentserver.server.address(),
             task: req.params.task,
             params: req.params.params,
             sysinfo: self.sysinfo,
diff --git a/lib/task_agent/task_runner.js b/lib/task_agent/task_runner.js
index 4fd5f2f..6584afe 100644
--- a/lib/task_agent/task_runner.js
+++ b/lib/task_agent/task_runner.js
@@ -20,6 +20,7 @@ var path = require('path');
 var util = require('util');
 
 var assert = require('assert-plus');
+var jsprim = require('jsprim');
 var sprintf = require('sprintf').sprintf;
 var mkdirp = require('mkdirp');
 
@@ -79,8 +80,9 @@ TaskRunner.prototype.dispatch = function (req) {
     var self = this;
 
     var i;
+    var env = jsprim.deepCopy(process.env);
+    var logtimestamp = (new Date()).getTime().toString();
     var taskModule = path.join(self.taskspath, req.task);
-    var env = JSON.parse(JSON.stringify(process.env));
 
     if (typeof (req.logging) !== 'undefined') {
         env.logging = req.logging ? '1' : '0';
@@ -91,6 +93,7 @@ TaskRunner.prototype.dispatch = function (req) {
     }
 
     env.logdir = self.logdir;
+    env.logtimestamp = logtimestamp;
     env.req_id = req.req_id;
     env.task = req.task;
     env.EXPERIMENTAL_VMJS_TRACING = 'true';
@@ -116,11 +119,8 @@ TaskRunner.prototype.dispatch = function (req) {
     }
 
     // Reformat logname here so we can log.info 'Child logging to %s...'
-    var logname = sprintf(
-        '%s-%s-%s.log',
-        (new Date()).getTime().toString(),
-        pid,
-        req.task);
+    // which matches what the task_worker will generate.
+    var logname = sprintf('%s-%s-%s.log', logtimestamp, pid, req.task);
 
     self.log.info({ logging: req.logging, req_id: req.params.req_id },
                   'Child logging to %s', env.logdir + '/' + logname);
diff --git a/lib/task_agent/task_worker.js b/lib/task_agent/task_worker.js
index 2ee6eab..d6c25cb 100644
--- a/lib/task_agent/task_worker.js
+++ b/lib/task_agent/task_worker.js
@@ -20,7 +20,7 @@ var logOpts = {
 
 var logname = sprintf(
         '%s-%s-%s.log',
-        (new Date()).getTime().toString(),
+        process.env.logtimestamp,
         process.pid,
         process.env.task);
 
diff --git a/package.json b/package.json
index 7b739d4..31d14b0 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cn-agent",
   "description": "Triton Compute Node Agent",
-  "version": "2.3.1",
+  "version": "2.3.2",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -25,7 +25,7 @@
     "pty.js": "0.3.1",
     "restify": "4.3.0",
     "rimraf": "2.4.3",
-    "sdc-clients": "10.0.3",
+    "sdc-clients": "11.3.1",
     "sdc-docker-build": "0.3.3",
     "semver": "5.4.1",
     "sprintf": "0.1.5",
@@ -33,7 +33,7 @@
     "uuid": "3.0.1",
     "vasync": "1.6.4",
     "verror": "1.9.0",
-    "vmadm": "git+https://github.com/joyent/node-vmadm.git#bfe4d6913785cfaa0abe7e008634794942553b29",
+    "vmadm": "git+https://github.com/joyent/node-vmadm.git#grr-TRITON-805",
     "zfs": "git+https://github.com/joyent/node-zfs.git#657a90d9424c45066e3e0919dfe9b34f5636e0e9"
   },
   "sdcDependencies": {
-- 
2.21.0

