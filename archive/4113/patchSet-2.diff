commit c9842223cc0836a0f18d9219c1b5bb2fbb3a0c17 (refs/changes/13/4113/2)
Author: Jason King <jason.king@joyent.com>
Date:   2018-06-04T10:20:35-05:00 (1 year, 4 months ago)
    
    Update overlay comments

diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index 82532f8caf..80013311fb 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -134,6 +134,40 @@
  * be sent to. In addition, they handle questions related to how to handle
  * things like broadcast and multicast traffic, etc.
  *
+ * ROUTING
+ *
+ * Supporting routing of packets between VLANs that exist on an overlay
+ * network require two major differences. First, packets destined for off-VLAN
+ * destinations need to be identified.  Second, we must obtain the necessary
+ * additional information necessary to deliver the packet to its off-VLAN
+ * destination.
+ *
+ * To solve the first issue, we utilize the existing IP routing functionality.
+ * Off-vlan destinations are given routes with next hops in the originating
+ * netstack's routing table--just like in physical networks.  The system will
+ * then attempt to generate an ARP query, which will be sent out to varpd in
+ * the exact same manner as is described above for other on-VLAN destinations.
+ * The response for this will include a MAC address that is both used for the
+ * ARP reply, and is added to our VL2 MAC->UL3 hash table, but is added
+ * with the OVERLAY_ENTRY_F_ROUTER flag set.  Once this is done, the originating
+ * netstack will send off-VLAN packets to this router MAC, allowing the
+ * overlay device to identify these packets as requiring routing.
+ *
+ * Once packets with an off-VLAN destination are identified, we must determine
+ * what the destination vid, VL2 VLAN, and VL2 MAC values are for the given
+ * packet.  For reasons similar to the VL2 MAC->UL3 lookup described above,
+ * we utilize the flexibility of user land to perform these lookups (also
+ * using varpd).  In this instance we are attempting to find a destination VL3
+ * IP to a UL3 IP mapping (a few extra bits of information are necessary to
+ * allow for disambiguation of the destination VL3 IP for situations such as
+ * mirroring a production environment including VL3 IPs in an isolated set of
+ * VLANs).  We then store these results in a VL3->UL3 hash table for future
+ * lookups.
+ *
+ * To prevent the size of both the VL2->UL3 and VL3->UL3 hash tables from
+ * growing without bound, we cap the number of entries in each hash table and
+ * utilize the ARC algorithm to manage their contents.
+ *
  * ----------
  * Properties
  * ----------
@@ -465,7 +499,7 @@
  * On the other hand, when we have an instance of OVERLAY_TARGET_DYNAMIC, things
  * are much more interesting and as a result, more complicated. We primarily
  * store lists of overlay_target_entry_t's which are stored in both an avl tree
- * and a refhash_t. The primary look up path uses the refhash_t and the avl tree
+ * and a sarc_t. The primary look up path uses the sarc_t and the avl tree
  * is only used for a few of the target ioctls used to dump data such that we
  * can get a consistent iteration order for things like dladm show-overlay -t.
  * The key that we use for the reference hashtable is based on the mac address
@@ -490,6 +524,28 @@
  * any outstanding data to that place. For the full story on how we look that up
  * will be discussed in the section on the Target Cache Lifecycle.
  *
+ * For routing, everything works largely the same as it does in the non-routing
+ * situations.  The major differences are that both the target cache is always
+ * an OVERLAY_TARGET_DYNAMIC cache, and that an additional hash table lookup
+ * occurs.  When a routed packet is sent down stack, the
+ * overlay_target_entry_t in the VL2 cache will have its
+ * OVERLAY_ENTRY_F_ROUTER flag set, which will prompt a lookup in the VL3->UL3
+ * cache (using the source VL3, source VL2 VLAN, and destination VL3 values
+ * from the packet as the lookup key).  The entry returned from the cache is
+ * used to modify the source and destination VL2 MAC addresses as well as
+ * the VL2 VLAN ID, and then is encapsulated and sent to its UL3 destination.
+ * On reception, decapsulation happens exactely the same as in the non-routed
+ * case, and the packet appears just as if it was sent out the VL2 network
+ * from a router connected to it.  This is done both to maintain the illusion
+ * of a physical network when sniffing packets at the instance level, and
+ * so that the mac layer sitting above the destinations overlay device
+ * (for the vnic created over the overlay) does not discard the packet because
+ * its VLAN tag does not match the VLAN tag of the destination VNIC.  While
+ * some of these modifications could be split between the source and
+ * destination hosts, by doing the work on the source, it maximizes any
+ * potential parallelism that might be present from multiple flows to a given
+ * destination.
+ *
  * ------------------------
  * FMA and Degraded Devices
  * ------------------------
