From c44518916e52dcba89615fcc2fb4af38b795bcb1 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Thu, 5 Jul 2018 12:16:09 -0400
Subject: [PATCH] TRITON-456 net-agent needs vminfod watcher

---
 lib/event-source.js      |  56 +++++++++++
 lib/net-agent.js         |  55 +++++++++--
 lib/vmadm-watcher-fsm.js | 208 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 310 insertions(+), 9 deletions(-)
 create mode 100644 lib/event-source.js
 create mode 100644 lib/vmadm-watcher-fsm.js

diff --git a/lib/event-source.js b/lib/event-source.js
new file mode 100644
index 0000000..9b2becb
--- /dev/null
+++ b/lib/event-source.js
@@ -0,0 +1,56 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var vmadm = require('vmadm');
+
+function determineEventSource(opts, cb) {
+    var vmadmEventsOpts;
+
+    assert.object(opts, 'opts');
+    assert(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    /*
+     * Figure out the best event source for the system.  Basically, this checks
+     * to see if vminfod is supported by looking for `vmadm events` support.
+     */
+    vmadmEventsOpts = {
+        log: opts.log,
+        name: 'VM Agent determineEventSource'
+    };
+
+    vmadm.events(vmadmEventsOpts,
+        function vmadmEventsHandler() {
+            /*
+             * We don't care about any events seen here - we are only
+             * starting this event stream to see if it is supported on the
+             * current platform to best determine the event source to use for
+             * all events.
+             */
+        }, function vmadmEventsReady(err, obj) {
+            if (err) {
+                // vmadm events is not supported, use default eventSource.
+                cb(null, 'default');
+                return;
+            }
+
+            /*
+             * vmadm events is supported! stop this stream and use the
+             * `vmadm-events` eventSource.
+             */
+            obj.stop();
+            cb(null, 'vmadm-events');
+        });
+}
+
+module.exports = determineEventSource;
diff --git a/lib/net-agent.js b/lib/net-agent.js
index e007f7b..e50b15f 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -54,9 +54,14 @@
  * Tracking VM changes
  * -------------------
  *
- * net-agent loads all of VMs that are located on the same CN as it is, by
- * executing `vmadm lookup`, and storing the VM objects in memory, each one
- * tracked by a separate InstanceFSM.
+ * On a platform with `vmadm events` (vminfod) support, the `vmadm-watcher-fsm`
+ * is used to track changes by consuming the events API. `net-agent` listens
+ * for changes relevant to the networking properties of the VM.
+ *
+ * On a platform without `vmadm events` (vminfod) support, net-agent loads all
+ * of VMs that are located on the same CN as it is, by executing `vmadm
+ * lookup`, and storing the VM objects in memory, each one tracked by a
+ * separate InstanceFSM.
  *
  * net-agent listens for VM events by executing a child `zoneevent` command,
  * and processing the JSON that it produces on stdout. `zoneevent` emits output
@@ -81,6 +86,8 @@ var NicFSM = require('./nic-fsm');
 var InstanceFSM = require('./inst-fsm');
 var ServerFSM = require('./server-fsm');
 var WatcherFSM = require('./watcher-fsm');
+var VmadmWatcherFSM = require('./vmadm-watcher-fsm');
+var determineEventSource = require('./event-source');
 
 // --- Internal helpers
 
@@ -130,10 +137,6 @@ function NetAgent(options) {
         userAgent: userAgent
     });
 
-    this.watcher = new WatcherFSM({
-        app: this
-    });
-
     this.server = new ServerFSM({
         uuid: this.cn_uuid,
         app: this
@@ -271,12 +274,46 @@ NetAgent.prototype.state_init = function (S) {
         S.gotoState('stopping');
     });
 
-    S.gotoState('init.watchzones');
+    S.gotoState('init.determineEventSource');
+};
+
+NetAgent.prototype.state_init.determineEventSource = function (S) {
+    var self = this;
+
+    determineEventSource({log: self.log},
+        function determinedEventSource(err, eventSource) {
+
+        if (err) {
+            throw err; // ???
+        }
+
+        self.log.info('determined best eventSource: %s', eventSource);
+
+        self.eventSource = eventSource;
+
+        S.gotoState('init.startWatcher');
+    });
 };
 
-NetAgent.prototype.state_init.watchzones = function (S) {
+NetAgent.prototype.state_init.startWatcher = function (S) {
     S.validTransitions([ 'running' ]);
 
+    switch (this.eventSource) {
+    case 'default':
+        this.watcher = new WatcherFSM({
+            app: this
+        });
+        break;
+    case 'vmadm-events':
+        this.watcher = new VmadmWatcherFSM({
+            app: this
+        });
+        break;
+    default:
+        // ???
+        throw new Error('unknown event source');
+    }
+
     S.on(this.watcher, 'stateChanged', function (newState) {
         if (newState === 'waiting') {
             S.gotoState('running');
diff --git a/lib/vmadm-watcher-fsm.js b/lib/vmadm-watcher-fsm.js
new file mode 100644
index 0000000..c2f4b34
--- /dev/null
+++ b/lib/vmadm-watcher-fsm.js
@@ -0,0 +1,208 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+var vmadm = require('vmadm');
+
+var WATCHED_FIELDS = [
+    'resolvers',
+    'nics',
+    'routes',
+    'state'
+];
+
+
+/**
+ * The VmadmWatcherFSM is responsible for collecting and managing information
+ * on VMs using `vmadm events` (vminfod).
+ */
+function VmadmWatcherFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.app, 'opts.app');
+
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'vmadm-watcher'
+    }, true);
+    this.vms = {};
+    this.ignore = {};
+    this.stopWatcher = null;
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(VmadmWatcherFSM, mod_mooremachine.FSM);
+
+VmadmWatcherFSM.prototype.state_init = function (S) {
+    S.on(this, 'startAsserted', function () {
+        S.gotoState('starting');
+    });
+};
+
+/*
+ * Create the `vmadm events` watcher which gets events for any VM change on the
+ * system using vminfod.
+ *
+ * An internal object (self.vms) is maintaned by this state which contains all
+ * VMs on the system (keyed by zonename).  When an event is seen for a specific
+ * VM, its corresponding object in the self.vms is updated to reflect the
+ * latest known state of the VM.  This object is then passed to `app.updateVMs`
+ * whenever any change on the system is seen.
+ */
+VmadmWatcherFSM.prototype.state_starting = function (S) {
+    var self = this;
+
+    self.vms = {};
+    assert(!self.stopWatcher, 'stopWatcher already defined');
+
+    var opts = {
+        log: self.log,
+        name: 'Net Agent'
+    };
+
+    // Called when a new event from `vmadm events` is seen
+    function handler(ev) {
+        assert.object(ev, 'ev');
+        assert.optionalObject(ev.vm, 'ev.vm');
+        assert.string(ev.type, 'ev.type');
+        assert.uuid(ev.zonename, 'ev.zonename');
+
+        var needsUpdate = false;
+
+        if (ev.vm && ev.vm.do_not_inventory) {
+            self.ignore[ev.zonename] = true;
+            self.log.debug('VM %s ignored - do_not_inventory set',
+                ev.zonename);
+            return;
+        }
+
+        switch (ev.type) {
+        case 'create':
+            assert.object(ev.vm, 'ev.vm');
+            assert(!self.vms.hasOwnProperty(ev.zonename), 'VM already created');
+
+            self.vms[ev.zonename] = ev.vm;
+            break;
+        case 'modify':
+            assert.object(ev.vm, 'ev.vm');
+            assert.arrayOfObject(ev.changes, 'ev.changes');
+            assert(self.vms.hasOwnProperty(ev.zonename), 'VM not found');
+
+            self.vms[ev.zonename] = ev.vm;
+
+            var changes = ev.changes.filter(function (change) {
+                return (WATCHED_FIELDS.indexOf(change.path[0]) >= 0);
+            });
+
+            if (changes.length > 0) {
+                var keys = changes.map(function (change) {
+                    return change.prettyPath;
+                });
+                self.log.debug(
+                    'VM %s fields updated (%s) - setting needsUpdate',
+                    ev.zonename, keys.join(','));
+                needsUpdate = true;
+            }
+
+            break;
+        case 'delete':
+            delete self.vms[ev.zonename];
+            if (!self.ignore[ev.zonename]) {
+                self.log.debug('VM %s deleted - setting needsUpdate',
+                    ev.zonename);
+                needsUpdate = true;
+            }
+            delete self.ignore[ev.zonename];
+            break;
+        default:
+            assert(false, 'unknown vmadm event type: ' + ev.type);
+            break;
+        }
+
+        if (needsUpdate) {
+            self._sendUpdate();
+        }
+    }
+
+    /*
+     * Called when `vmadm events` is ready (with full list of VMs on the
+     * system)
+     */
+    function ready(err, obj) {
+        if (err) {
+            throw err; // TODO what to do if vmadm events fails?
+        }
+
+        assert.object(obj, 'obj');
+        assert.func(obj.stop, 'obj.stop');
+        assert.object(obj.ev, 'obj.ev');
+        assert.object(obj.ev.vms, 'obj.ev.vms');
+
+        self.vms = obj.ev.vms;
+        self.stopWatcher = obj.stop;
+
+        Object.keys(self.vms).forEach(function (uuid) {
+            if (self.vms[uuid].do_not_inventory) {
+                self.ignore[uuid] = true;
+                delete self.vms[uuid];
+            }
+        });
+
+        self._sendUpdate();
+
+        S.gotoState('waiting');
+    }
+
+    vmadm.events(opts, handler, ready);
+};
+
+VmadmWatcherFSM.prototype.state_waiting = function (S) {
+    var self = this;
+
+    S.on(self, 'stopAsserted', function () {
+        S.gotoState('stopping');
+    });
+};
+
+VmadmWatcherFSM.prototype.state_stopping = function (S) {
+    var self = this;
+
+    assert(self.stopWatcher, 'stopWatcher not found');
+    self.stopWatcher();
+
+    S.gotoState('init');
+};
+
+VmadmWatcherFSM.prototype.start = function () {
+    this.emit('startAsserted');
+};
+
+VmadmWatcherFSM.prototype.stop = function () {
+    this.emit('stopAsserted');
+};
+
+VmadmWatcherFSM.prototype.refresh = function () {
+    // nop
+};
+
+VmadmWatcherFSM.prototype._sendUpdate = function () {
+    var self = this;
+
+    var vms = Object.keys(self.vms).map(function (uuid) {
+        return self.vms[uuid];
+    });
+
+    self.app.updateVMs(vms);
+};
+
+module.exports = VmadmWatcherFSM;
-- 
2.21.0

