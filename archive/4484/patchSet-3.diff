From 12d3eae927eb34e8d2a81b89389504517bdf3bc7 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Tue, 10 Jul 2018 12:22:43 -0400
Subject: [PATCH] TRITON-456 net-agent needs vminfod watcher

---
 lib/event-source.js      |  56 ++++++++
 lib/net-agent.js         |  59 +++++++--
 lib/vmadm-watcher-fsm.js | 279 +++++++++++++++++++++++++++++++++++++++
 package.json             |   2 +-
 4 files changed, 387 insertions(+), 9 deletions(-)
 create mode 100644 lib/event-source.js
 create mode 100644 lib/vmadm-watcher-fsm.js

diff --git a/lib/event-source.js b/lib/event-source.js
new file mode 100644
index 0000000..bfd75bc
--- /dev/null
+++ b/lib/event-source.js
@@ -0,0 +1,56 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var vmadm = require('vmadm');
+
+function determineEventSource(opts, cb) {
+    var vmadmEventsOpts;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    /*
+     * Figure out the best event source for the system.  Basically, this checks
+     * to see if vminfod is supported by looking for `vmadm events` support.
+     */
+    vmadmEventsOpts = {
+        log: opts.log,
+        name: 'VM Agent determineEventSource'
+    };
+
+    vmadm.events(vmadmEventsOpts,
+        function vmadmEventsHandler() {
+            /*
+             * We don't care about any events seen here - we are only
+             * starting this event stream to see if it is supported on the
+             * current platform to best determine the event source to use for
+             * all events.
+             */
+        }, function vmadmEventsReady(err, obj) {
+            if (err) {
+                // vmadm events is not supported, use default eventSource.
+                cb(null, 'default');
+                return;
+            }
+
+            /*
+             * vmadm events is supported! stop this stream and use the
+             * `vmadm-events` eventSource.
+             */
+            obj.stop();
+            cb(null, 'vmadm-events');
+        });
+}
+
+module.exports = determineEventSource;
diff --git a/lib/net-agent.js b/lib/net-agent.js
index e007f7b..c50c023 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -54,9 +54,14 @@
  * Tracking VM changes
  * -------------------
  *
- * net-agent loads all of VMs that are located on the same CN as it is, by
- * executing `vmadm lookup`, and storing the VM objects in memory, each one
- * tracked by a separate InstanceFSM.
+ * On a platform with `vmadm events` (vminfod) support, the `vmadm-watcher-fsm`
+ * is used to track changes by consuming the events API. `net-agent` listens
+ * for changes relevant to the networking properties of the VM.
+ *
+ * On a platform without `vmadm events` (vminfod) support, net-agent loads all
+ * of VMs that are located on the same CN as it is, by executing `vmadm
+ * lookup`, and storing the VM objects in memory, each one tracked by a
+ * separate InstanceFSM.
  *
  * net-agent listens for VM events by executing a child `zoneevent` command,
  * and processing the JSON that it produces on stdout. `zoneevent` emits output
@@ -74,6 +79,7 @@ var mod_cueball = require('cueball');
 var mod_jsprim = require('jsprim');
 var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
+var VError = require('verror');
 
 var AggrFSM = require('./aggr-fsm');
 var NetworkFSM = require('./net-fsm');
@@ -81,6 +87,8 @@ var NicFSM = require('./nic-fsm');
 var InstanceFSM = require('./inst-fsm');
 var ServerFSM = require('./server-fsm');
 var WatcherFSM = require('./watcher-fsm');
+var VmadmWatcherFSM = require('./vmadm-watcher-fsm');
+var determineEventSource = require('./event-source');
 
 // --- Internal helpers
 
@@ -130,9 +138,8 @@ function NetAgent(options) {
         userAgent: userAgent
     });
 
-    this.watcher = new WatcherFSM({
-        app: this
-    });
+    this.watcher = null;
+    this.eventSource = null;
 
     this.server = new ServerFSM({
         uuid: this.cn_uuid,
@@ -271,12 +278,48 @@ NetAgent.prototype.state_init = function (S) {
         S.gotoState('stopping');
     });
 
-    S.gotoState('init.watchzones');
+    S.gotoState('init.determineEventSource');
 };
 
-NetAgent.prototype.state_init.watchzones = function (S) {
+NetAgent.prototype.state_init.determineEventSource = function (S) {
+    var self = this;
+
+    determineEventSource({log: self.log},
+        function determinedEventSource(err, eventSource) {
+
+        if (err) {
+            self.log.error(err, 'error determining event source');
+            S.timeout(1000, function () {
+                S.gotoState('init.determineEventSource');
+            });
+            return;
+        }
+
+        self.log.info('determined best eventSource: %s', eventSource);
+        self.eventSource = eventSource;
+
+        S.gotoState('init.startWatcher');
+    });
+};
+
+NetAgent.prototype.state_init.startWatcher = function (S) {
     S.validTransitions([ 'running' ]);
 
+    switch (this.eventSource) {
+    case 'default':
+        this.watcher = new WatcherFSM({
+            app: this
+        });
+        break;
+    case 'vmadm-events':
+        this.watcher = new VmadmWatcherFSM({
+            app: this
+        });
+        break;
+    default:
+        throw new VError('unknown event source %j', this.eventSource);
+    }
+
     S.on(this.watcher, 'stateChanged', function (newState) {
         if (newState === 'waiting') {
             S.gotoState('running');
diff --git a/lib/vmadm-watcher-fsm.js b/lib/vmadm-watcher-fsm.js
new file mode 100644
index 0000000..d844945
--- /dev/null
+++ b/lib/vmadm-watcher-fsm.js
@@ -0,0 +1,279 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+var vmadm = require('vmadm');
+
+var WATCHED_FIELDS = [
+    'resolvers',
+    'nics',
+    'owner_uuid',
+    'routes',
+    'state'
+];
+
+
+/**
+ * The VmadmEventsFSM is responsible for collecting and managing information
+ * on VMs using `vmadm events` (vminfod).
+ */
+function VmadmEventsFSM(opts) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+
+    self.log = opts.log.child({
+        component: 'vmadm-events'
+    }, true);
+    self.vms = {};
+    self.ignore = {};
+    self.emitter = null;
+    self.stopWatcher = null;
+
+    mod_mooremachine.FSM.call(self, 'init');
+}
+mod_util.inherits(VmadmEventsFSM, mod_mooremachine.FSM);
+
+/*
+ * Create the `vmadm events` watcher which gets events for any VM change on the
+ * system using vminfod.
+ *
+ * An internal object (self.vms) is maintaned by this state which contains all
+ * VMs on the system (keyed by zonename).  When an event is seen for a specific
+ * VM, its corresponding object in the self.vms is updated to reflect the
+ * latest known state of the VM.  This object is then passed to `app.updateVMs`
+ * whenever any change on the system is seen.
+ */
+VmadmEventsFSM.prototype.state_init = function (S) {
+    var self = this;
+
+    self.vms = {};
+    assert(!self.stopWatcher, 'stopWatcher already defined');
+
+    var opts = {
+        log: self.log,
+        name: 'Net Agent VmadmEventsFSM'
+    };
+
+    // Called when a new event from `vmadm events` is seen
+    function handler(ev) {
+        assert.object(ev, 'ev');
+        assert.optionalObject(ev.vm, 'ev.vm');
+        assert.string(ev.type, 'ev.type');
+        assert.uuid(ev.zonename, 'ev.zonename');
+
+        var needsUpdate = false;
+
+        if (ev.vm && ev.vm.do_not_inventory) {
+            self.ignore[ev.zonename] = true;
+            self.log.debug('VM %s ignored - do_not_inventory set',
+                ev.zonename);
+        } else if (ev.vm && !ev.vm.do_not_inventory) {
+            delete self.ignore[ev.zonename];
+        }
+
+        switch (ev.type) {
+        case 'create':
+            assert.object(ev.vm, 'ev.vm');
+            assert(!self.vms.hasOwnProperty(ev.zonename), 'VM already created');
+
+            self.vms[ev.zonename] = ev.vm;
+            break;
+        case 'modify':
+            assert.object(ev.vm, 'ev.vm');
+            assert.arrayOfObject(ev.changes, 'ev.changes');
+            assert(self.vms.hasOwnProperty(ev.zonename), 'VM not found');
+
+            self.vms[ev.zonename] = ev.vm;
+
+            if (self.ignore[ev.zonename]) {
+                break;
+            }
+
+            var changes = ev.changes.filter(function (change) {
+                return (WATCHED_FIELDS.indexOf(change.path[0]) >= 0);
+            });
+
+            if (changes.length > 0) {
+                var keys = changes.map(function (change) {
+                    return change.prettyPath;
+                });
+                self.log.debug(
+                    'VM %s fields updated (%s) - setting needsUpdate',
+                    ev.zonename, keys.join(','));
+                needsUpdate = true;
+            }
+
+            break;
+        case 'delete':
+            delete self.vms[ev.zonename];
+            if (!self.ignore[ev.zonename]) {
+                self.log.debug('VM %s deleted - setting needsUpdate',
+                    ev.zonename);
+                needsUpdate = true;
+            }
+            delete self.ignore[ev.zonename];
+            break;
+        default:
+            assert(false, 'unknown vmadm event type: ' + ev.type);
+            break;
+        }
+
+        if (needsUpdate) {
+            self._emitUpdate();
+        }
+    }
+
+    /*
+     * Called when `vmadm events` is ready (with full list of VMs on the
+     * system)
+     */
+    function ready(err, obj) {
+        // This can fail in the event that vminfod is down
+        if (err) {
+            self.log.error(err, 'vmadm events failed to ready');
+
+            // Try again
+            S.timeout(1000, function () {
+                S.gotoState('init');
+            });
+            return;
+        }
+
+        assert.object(obj, 'obj');
+        assert.func(obj.stop, 'obj.stop');
+        assert.object(obj.ev, 'obj.ev');
+        assert.object(obj.ev.vms, 'obj.ev.vms');
+
+        self.vms = obj.ev.vms;
+        self.stopWatcher = obj.stop;
+
+        self._emitUpdate();
+
+        S.gotoState('running');
+    }
+
+    self.emitter = vmadm.events(opts, handler, ready);
+
+    S.on(self.emitter, 'error', function (err) {
+        self.log.error(err, 'vmadm events error');
+        self.emitter = null;
+        S.timeout(1000, function () {
+            S.gotoState('init');
+        });
+    });
+};
+
+VmadmEventsFSM.prototype.state_running = function (S) {
+    var self = this;
+
+    S.on(self.emitter, 'error', function (err) {
+        self.log.error(err, 'vmadm events error');
+        self.stopWatcher();
+        self.stopWatcher = null;
+        self.emitter = null;
+        S.timeout(1000, function () {
+            S.gotoState('init');
+        });
+    });
+
+    S.on(self, 'stopAsserted', function () {
+        S.gotoState('stopped');
+    });
+
+    S.on(self, 'restartAsserted', function () {
+        S.gotoState('init');
+    });
+};
+
+VmadmEventsFSM.prototype.state_stopped = function (S) {
+    S.validTransitions([]);
+};
+
+VmadmEventsFSM.prototype.start = function () {
+    var self = this;
+
+    self.emit('startAsserted');
+};
+
+VmadmEventsFSM.prototype.stop = function () {
+    var self = this;
+
+    self.emit('stopAsserted');
+};
+
+VmadmEventsFSM.prototype._emitUpdate = function () {
+    var self = this;
+
+    var vms = Object.keys(self.vms).map(function (uuid) {
+        return self.vms[uuid];
+    }).filter(function (vm) {
+        return !vm.do_not_inventory;
+    });
+
+    self.emit('vms-update', vms);
+};
+
+function VmadmWatcherFSM(opts) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.app.log, 'opts.app.log');
+
+    self.app = opts.app;
+    self.log = opts.app.log.child({
+        component: 'vmadm-watcher'
+    }, true);
+
+    mod_mooremachine.FSM.call(self, 'init');
+}
+mod_util.inherits(VmadmWatcherFSM, mod_mooremachine.FSM);
+
+VmadmWatcherFSM.prototype.state_init = function (S) {
+    var self = this;
+
+    S.on(self, 'startAsserted', function () {
+        S.gotoState('running');
+    });
+};
+
+VmadmWatcherFSM.prototype.state_running = function (S) {
+    var self = this;
+
+    self.vmadmevents = new VmadmEventsFSM({log: self.log});
+
+    S.on(self.vmadmevents, 'vms-update', function (vms) {
+        self.app.updateVMs(vms);
+    });
+};
+
+VmadmWatcherFSM.prototype.start = function () {
+    var self = this;
+
+    self.emit('startAsserted');
+};
+
+VmadmWatcherFSM.prototype.stop = function () {
+    var self = this;
+
+    self.emit('stopAsserted');
+};
+
+VmadmWatcherFSM.prototype.refresh = function () {
+    // nop
+};
+
+module.exports = VmadmWatcherFSM;
diff --git a/package.json b/package.json
index 0d5c8b3..c16fdea 100644
--- a/package.json
+++ b/package.json
@@ -19,7 +19,7 @@
         "uuid": "3.2.1",
         "vasync": "^1.6.4",
         "verror": "^1.6.1",
-        "vmadm": "1.0.0"
+        "vmadm": "1.1.0"
     },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
-- 
2.21.0

