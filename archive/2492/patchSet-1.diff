commit 430bb5b89240d8f48ddf39ef5757733bd7bc3c74 (refs/changes/92/2492/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-09-01T18:03:39-07:00 (2 years, 1 month ago)
    
    joyent/node-cueball#125 want support for setting "port" and TLS options in Agent#createPool
    joyent/node-cueball#37 no test coverage for Agent
    joyent/node-cueball#126 mistakes in documentation for getPool(), createPool()

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 254611c..f7394f2 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,15 @@ toc::[]
 
 ## v2.x
 
+### v2.4.0
+
+New minor release, due to addition of new API.
+
+API Changes:
+
+ - The `Agent` method `createPool()` now accepts a `port` option, as well as
+   various TLS-related options (#125)
+
 ### v2.3.0
 
 New minor release, due to addition of new API.
diff --git a/docs/api.adoc b/docs/api.adoc
index 8ac663f..e3bfe44 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -63,30 +63,36 @@ without calling `process.exit()`.
 
 ### `#getPool([host])`
 
-Returns the connection pool this agent has created for the input host,
-or creates one if it doesn't already exist.
+Returns the connection pool this agent has created for the input host. If no
+pool has yet been created, returns `undefined`.
 
 Parameters
 
-- `host` -- hostname of the host for which the pool is being requested.
+- `host` -- String, hostname of the host for which the pool is being requested.
 
 ### `#createPool(host, [options])`
 
-Creates and returns a connection pool for the host identified by the
-input host name if one doesn't already exist. You can either provide
-a resolver directly in the options parameter or have one allocated by
-cueball. If you provide a resolver, the Agent takes no responsibility
-for calling it's start() or stop() methods. The caller is responsible
-for doing so.
+Creates and returns a connection pool for the host identified by the input host
+name if one doesn't already exist. You can either provide a resolver directly in
+the options parameter or have one allocated by cueball (the behaviour matches
+`resolverForIpOrDomain()`). If you provide a resolver, the Agent takes no
+responsibility for calling its `start()` or `stop()` methods. The caller is
+responsible for doing so.
 
 Parameters
 
-- `host` -- hostname of the host for which the pool is being requested.
+- `host` -- String, hostname of the host for which a pool will be created.
 - `options` -- an optional Object, with keys:
-    * `resolver` - Object satisfying the Resolver interface.
-
-Note: This function throws an error if a resolver for the provided host
-already exists.
+    * `resolver` -- optional Object satisfying the Resolver interface, the
+                    resolver to use for this pool. If given, `port` will be
+                    ignored.
+    * `port` -- optional Number, override the default port number used for
+                this pool (the Resolver can still override this).
+    * `rejectUnauthorized`, `pfx`, `key`, `passphrase`, `cert`, `ca`, `ciphers`,
+      `servername` -- TLS options, passed through to the TLS library.
+
+NOTE: This function throws an error synchronously if a resolver for the
+provided host already exists, or if the Agent is stopped.
 
 [[pool]]
 ## ConnectionPool
diff --git a/lib/agent.js b/lib/agent.js
index 1a78608..2e71094 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -85,7 +85,7 @@ function CueBallAgent(options) {
 	    options.initialDomains !== null) {
 		var self = this;
 		options.initialDomains.forEach(function (host) {
-			self.addPool(host, {});
+			self._addPool(host, {});
 		});
 	}
 }
@@ -100,7 +100,7 @@ if (/^v0\.[0-9]\./.test(process.version) ||
 	USE_SECURECONNECT = true;
 }
 
-CueBallAgent.prototype.addPool = function (host, options) {
+CueBallAgent.prototype._addPool = function (host, options) {
 	var self = this;
 	if (this.cba_stopped) {
 		throw (new Error('Cannot add a pool to a stopped agent'));
@@ -114,7 +114,8 @@ CueBallAgent.prototype.addPool = function (host, options) {
 	mod_assert.optionalNumber(defPort, 'default port');
 
 	var res;
-	var useExternalResolver = options.hasOwnProperty('resolver');
+	var useExternalResolver = (options.resolver !== undefined &&
+	    options.resolver !== null);
 
 	if (useExternalResolver) {
 		res = options.resolver;
@@ -146,7 +147,8 @@ CueBallAgent.prototype.addPool = function (host, options) {
 			servername: backend.name || host
 		};
 		PASS_FIELDS.forEach(function (k) {
-			if (options.hasOwnProperty(k))
+			if (options[k] !== null &&
+			    options[k] !== undefined)
 				opts[k] = options[k];
 		});
 		var nsock;
@@ -193,7 +195,7 @@ CueBallAgent.prototype.addPool = function (host, options) {
 	if (this.cba_ping !== undefined &&
 	    this.cba_ping !== null) {
 		poolOpts.checkTimeout = this.cba_pingInterval || 30000;
-		poolOpts.checker = this.checkSocket.bind(this, host);
+		poolOpts.checker = this._checkSocket.bind(this, host);
 	}
 	this.log.debug({ host: host }, 'CueBallAgent creating new pool');
 	this.pools[host] = new Pool(poolOpts);
@@ -285,7 +287,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 	var host = options.host || options.hostname;
 	mod_assert.string(host, 'hostname');
 	if (this.pools[host] === undefined) {
-		this.addPool(host, options);
+		this._addPool(host, options);
 	}
 	var pool = this.pools[host];
 	var waiter, sock, conn;
@@ -306,7 +308,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 			 */
 			var fakesock = new FakeSocket();
 			req.onSocket(fakesock);
-			setImmediate(function () {
+			process.nextTick(function () {
 				fakesock.emit('error', err);
 			});
 			return;
@@ -390,7 +392,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 	}
 };
 
-CueBallAgent.prototype.checkSocket = function (host, handle, socket) {
+CueBallAgent.prototype._checkSocket = function (host, handle, socket) {
 	var t1 = new Date();
 	var log = handle.ch_slot.makeChildLogger({
 		component: 'CueBallAgent',
@@ -458,14 +460,25 @@ CueBallAgent.prototype.getPool = function (host) {
 /* Used by muskie to create a pool if one doesn't already exist. */
 CueBallAgent.prototype.createPool = function (host, options) {
 	mod_assert.string(host, 'hostname');
+	mod_assert.optionalObject(options, 'options');
+	if (options) {
+		mod_assert.optionalNumber(options.port, 'options.port');
+		mod_assert.optionalObject(options.resolver, 'options.resolver');
+	}
 	if (this.pools[host] === undefined) {
-		if (options && options.hasOwnProperty('resolver')) {
+		if (options) {
 			var opts = {
-				resolver: options['resolver']
+				port: options.port,
+				resolver: options.resolver
 			};
-			this.addPool(host, opts);
+			PASS_FIELDS.forEach(function (k) {
+				if (options[k] !== null &&
+				    options[k] !== undefined)
+					opts[k] = options[k];
+			});
+			this._addPool(host, opts);
 		} else {
-			this.addPool(host, {});
+			this._addPool(host, {});
 		}
 	} else {
 		throw (new Error('Attempting to create a pool for a hostname ' +
diff --git a/package.json b/package.json
index 1aa09f7..e1bd03f 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.3.0",
+  "version": "2.4.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
@@ -9,10 +9,10 @@
     "cmdutil": ">=1.0.0 <2.0.0",
     "extsprintf": ">=1.3.0 <2.0.0",
     "ipaddr.js": ">=1.1.0 <2.0.0",
-    "mooremachine": ">=2.2.0 <3.0.0",
     "mname-client": ">=0.5.0 <0.6.0",
-    "uuid": ">=3.0.1 <4.0.0",
+    "mooremachine": ">=2.2.0 <3.0.0",
     "posix-getopt": ">=1.2.0 <2.0.0",
+    "uuid": ">=3.0.1 <4.0.0",
     "vasync": ">=1.6.3 <2.0.0",
     "verror": ">=1.6.1 <2.0.0"
   },
@@ -26,7 +26,8 @@
     "json": ">=9.0.3 <10.0.0",
     "mname": ">=1.0.8 <2.0.0",
     "kang": "^1.1.0",
-    "restify": "^4.3.0"
+    "restify": "^4.3.0",
+    "sshpk": "^1.13.1"
   },
   "engines": {
     "node": ">=0.10.0"
diff --git a/test/agent.test.js b/test/agent.test.js
new file mode 100644
index 0000000..73c5ae2
--- /dev/null
+++ b/test/agent.test.js
@@ -0,0 +1,389 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+const mod_tape = require('tape');
+const mod_sinon = require('sinon');
+const mod_events = require('events');
+const mod_util = require('util');
+const mod_assert = require('assert-plus');
+const mod_bunyan = require('bunyan');
+const mod_restify = require('restify');
+const mod_net = require('net');
+const mod_sshpk = require('sshpk');
+
+const mod_cueball = require('..');
+
+var log = mod_bunyan.createLogger({
+	name: 'agent-test',
+	level: process.env.LOGLEVEL || 'debug'
+});
+var recovery = {
+	default: {timeout: 100, retries: 2, delay: 50 }
+};
+
+var servers = {};
+
+mod_tape.test('setup server 1', function (t) {
+	var srv = mod_restify.createServer({
+		log: log
+	});
+	servers[12380] = srv;
+	srv.get('/test/:val', function (req, res, next) {
+		res.send('test response');
+		srv.lastVal = req.params.val;
+		next();
+	});
+	srv.listen(12380, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('basic agent usage, fixed ip', function (t) {
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://127.0.0.1:12380',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	client.get('/test/test1', function (err, req, res, data) {
+		t.error(err);
+		t.strictEqual(data, 'test response');
+		t.strictEqual(servers[12380].lastVal, 'test1');
+
+		var pool = agent.getPool('127.0.0.1');
+		t.ok(pool);
+		t.ok(pool.isInState('running'));
+
+		t.strictEqual(agent.getPool('abcd'), undefined);
+
+		t.throws(function () {
+			agent.createPool('127.0.0.1', {});
+		});
+
+		agent.stop(function () {
+			t.ok(pool.isInState('stopped'));
+			t.end();
+		});
+	});
+});
+
+mod_tape.test('agent initialDomains', function (t) {
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		defaultPort: 12380,
+		initialDomains: ['127.0.0.1'],
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://127.0.0.1',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	var pool = agent.getPool('127.0.0.1');
+	t.ok(pool);
+
+	client.get('/test/test2', function (err, req, res, data) {
+		t.error(err);
+		t.strictEqual(data, 'test response');
+		t.strictEqual(servers[12380].lastVal, 'test2');
+
+		t.ok(pool.isInState('running'));
+
+		agent.stop(function () {
+			t.ok(pool.isInState('stopped'));
+			t.throws(function () {
+				agent.addPool('example.com');
+			});
+			t.end();
+		});
+	});
+});
+
+mod_tape.test('agent pinger', function (t) {
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		ping: '/test/ping',
+		pingInterval: 100,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://127.0.0.1:12380',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	var pool = agent.getPool('127.0.0.1');
+	t.strictEqual(pool, undefined);
+	agent.createPool('127.0.0.1', { port: 12380 });
+	pool = agent.getPool('127.0.0.1');
+	t.ok(pool);
+	t.strictEqual(pool, agent.getPool('127.0.0.1'));
+
+	t.notStrictEqual(servers[12380].lastVal, 'ping');
+	setTimeout(function () {
+		t.strictEqual(servers[12380].lastVal, 'ping');
+
+		client.get('/test/test3', function (err) {
+			t.error(err);
+			t.strictEqual(servers[12380].lastVal, 'test3');
+			agent.stop(function () {
+				t.end();
+			});
+		});
+	}, 200);
+});
+
+mod_tape.test('setup server 2', function (t) {
+	var srv = mod_restify.createServer({
+		log: log
+	});
+	servers[12381] = srv;
+	srv.get('/test/:val', function (req, res, next) {
+		res.send('test response');
+		srv.lastVal = req.params.val;
+		next();
+	});
+	srv.listen(12381, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('agent with custom resolver', function (t) {
+	var res = new mod_cueball.StaticIpResolver({
+		backends: [
+			{ address: '127.0.0.1', port: 12380 },
+			{ address: '127.0.0.1', port: 12381 }
+		]
+	});
+
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		ping: '/test/ping',
+		pingTimeout: 150,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://foobar',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	var srv = servers[12380];
+	srv.server.timeout = 100;
+
+	var pool = agent.getPool('foobar');
+	t.strictEqual(pool, undefined);
+	agent.createPool('foobar', { resolver: res });
+	pool = agent.getPool('foobar');
+	t.ok(pool);
+
+	t.ok(res.isInState('stopped'));
+	res.start();
+
+	client.get('/test/test4', function (err, req, resp, data) {
+		t.error(err);
+		t.strictEqual(data, 'test response');
+		t.ok(servers[12381].lastVal === 'test4' ||
+		    servers[12380].lastVal === 'test4');
+
+		t.ok(pool.isInState('running'));
+
+		srv.on('close', function () {
+			setTimeout(nextReq, 100);
+		});
+
+		function nextReq() {
+			client.get('/test/test5',
+			    function (err2, req2, resp2, data2) {
+				t.error(err2);
+				t.strictEqual(data2, 'test response');
+
+				t.strictEqual(servers[12381].lastVal, 'test5');
+
+				agent.stop(function () {
+					t.ok(pool.isInState('stopped'));
+					t.ok(!res.isInState('stopped'));
+					res.stop();
+					t.end();
+				});
+			});
+		}
+
+		srv.close();
+		delete (servers[12380]);
+	});
+});
+
+mod_tape.test('setup server 3', function (t) {
+	var srv = mod_net.createServer();
+	servers[12382] = srv;
+	srv.on('connection', function (c) {
+		setTimeout(function () {
+			c.destroy();
+		}, 50);
+	});
+	srv.listen(12382, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('agent on conn refused server', function (t) {
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://127.0.0.1:12389',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	var t0 = process.hrtime();
+
+	client.get('/test/test5', function (err, req, res, data) {
+		t.ok(err);
+		var delta = process.hrtime(t0);
+		console.log(delta);
+		t.ok(delta[0] < 1 && delta[1] < 1e9);
+
+		var pool = agent.getPool('127.0.0.1');
+		t.ok(pool.isInState('failed'));
+
+		agent.stop(function () {
+			t.ok(pool.isInState('stopped'));
+			t.end();
+		});
+	});
+});
+
+mod_tape.test('agent on broken server', function (t) {
+	var agent = new mod_cueball.HttpAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'http://127.0.0.1:12382',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	client.get('/test/test5', function (err, req, res, data) {
+		t.ok(err);
+		t.strictEqual(err.code, 'ECONNRESET');
+
+		var pool = agent.getPool('127.0.0.1');
+
+		client.get('/test/test5', function (err2, req2, res2, data2) {
+			t.ok(err2);
+			t.strictEqual(err2.code, 'ECONNRESET');
+
+			setTimeout(function () {
+				t.ok(pool.isInState('running'));
+
+				agent.stop(function () {
+					t.ok(pool.isInState('stopped'));
+					t.end();
+				});
+			}, 1000);
+		});
+	});
+});
+
+mod_tape.test('setup server 4 (tls)', function (t) {
+	var privkey = mod_sshpk.generatePrivateKey('ecdsa');
+	var id = mod_sshpk.identityFromDN('CN=127.0.0.1');
+	var tlsCert = mod_sshpk.createSelfSignedCertificate(id, privkey);
+	var srv = mod_restify.createServer({
+		httpsServerOptions: {
+			key: privkey.toBuffer('pem'),
+			cert: tlsCert.toBuffer('pem')
+		},
+		log: log
+	});
+	servers[12383] = srv;
+	srv.get('/test/:val', function (req, res, next) {
+		res.send('test response');
+		srv.lastVal = req.params.val;
+		next();
+	});
+	srv.listen(12383, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('agent https', function (t) {
+	var agent = new mod_cueball.HttpsAgent({
+		spares: 2,
+		maximum: 4,
+		recovery: recovery,
+		log: log
+	});
+
+	var client = mod_restify.createStringClient({
+		url: 'https://127.0.0.1:12383',
+		agent: agent,
+		log: log,
+		retry: false
+	});
+
+	agent.createPool('127.0.0.1', {
+		port: 12383,
+		rejectUnauthorized: false
+	});
+
+	client.get('/test/test6', function (err, req, res, data) {
+		t.error(err);
+		t.strictEqual(data, 'test response');
+		t.strictEqual(servers[12383].lastVal, 'test6');
+
+		var pool = agent.getPool('127.0.0.1');
+		t.ok(pool);
+		t.ok(pool.isInState('running'));
+
+		agent.stop(function () {
+			t.ok(pool.isInState('stopped'));
+			t.end();
+		});
+	});
+});
+
+mod_tape.test('teardown servers', function (t) {
+	Object.keys(servers).forEach(function (k) {
+		servers[k].close();
+	});
+	t.end();
+});
