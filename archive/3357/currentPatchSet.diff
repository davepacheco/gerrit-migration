commit c6bb433c75816f2d7479633794ea911cd2d90647 (refs/changes/57/3357/9)
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2018-02-15T12:40:05-08:00 (1 year, 8 months ago)
    
    TRITON-122 docker tests can end up with a lot of binary data in the output process invoked by execPlus function fails
    Reviewed by: Trent Mick <trentm@gmail.com>
    Approved by: Trent Mick <trentm@gmail.com>

diff --git a/test/integration/cli-copy.test.js b/test/integration/cli-copy.test.js
index 37ac311..4f8a2e0 100644
--- a/test/integration/cli-copy.test.js
+++ b/test/integration/cli-copy.test.js
@@ -27,6 +27,8 @@ var h = require('./helpers');
 var vm = require('../lib/vm');
 var configLoader = require('../../lib/config-loader.js');
 
+var STDIO_ON_ERROR_SIZE = 0;
+
 var STATE = {
     log: require('../lib/log')
 };
@@ -615,7 +617,8 @@ function copyFileOut(tt, remotefn, localfn, containerName, callback) {
         'cp "%s:%s" - | tar xOf - "%s"',
         containerName, remotefn, localfn);
     var execOpts = { maxBuffer: 1024*1024+1, encoding: 'binary' };
-    cli.docker(args, { execOpts: execOpts }, onDocker);
+    cli.docker(args, {
+        maxStdoutOnError: STDIO_ON_ERROR_SIZE, execOpts: execOpts }, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
         var str = stdout.toString();
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 8536f23..c4359c9 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -828,6 +828,8 @@ GzDockerEnv.prototype.exec = function denvExec(cmd, opts, cb) {
         // TODO: escaping single-quotes
         command: fmt('zlogin %s \'%s\'', this.clientZone.uuid, cmd),
         log: this.log,
+        maxStdoutOnError: opts.maxStdoutOnError,
+        maxStderrOnError: opts.maxStderrOnError,
         execOpts: opts.execOpts
     }, cb);
 };
diff --git a/test/lib/common.js b/test/lib/common.js
index c6f2e69..ca39411 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -93,6 +93,8 @@ function execPlus(args, cb) {
     assert.string(args.command, 'args.command');
     assert.optionalString(args.errMsg, 'args.errMsg');
     assert.optionalObject(args.execOpts, 'args.execOpts');
+    assert.optionalNumber(args.maxStdoutOnError, 'args.maxStdoutOnError');
+    assert.optionalNumber(args.maxStderrOnError, 'args.maxStderrOnError');
     assert.object(args.log, 'args.log');
     assert.func(cb);
     var command = args.command;
@@ -104,15 +106,24 @@ function execPlus(args, cb) {
         args.log.trace({exec: true, command: command, execOpts: execOpts,
             err: err, stdout: stdout, stderr: stderr}, 'exec done');
         if (err) {
+
+            // Render stdio as something we can send to the console.
+            if (args.hasOwnProperty('maxStdoutOnError')) {
+                stdout = stdout.slice(0, args.maxStdoutOnError);
+            }
+            if (args.hasOwnProperty('maxStderrOnError')) {
+                stderr = stderr.slice(0, args.maxStderrOnError);
+            }
+
             cb(
                 new VError(err,
                     '%s:\n'
                     + '\tcommand: %s\n'
                     + '\texit status: %s\n'
-                    + '\tstdout:\n%s\n'
-                    + '\tstderr:\n%s',
+                    + '\tstdout: %s\n'
+                    + '\tstderr: %s',
                     args.errMsg || 'exec error', command, err.code,
-                    stdout.trim(), stderr.trim()),
+                    JSON.stringify(stdout), JSON.stringify(stderr)),
                 stdout, stderr);
         } else {
             cb(null, stdout, stderr);
