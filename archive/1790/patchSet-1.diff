From 1227420a24b9ce21d3e88e1c54a4d9e9c28080c9 Mon Sep 17 00:00:00 2001
From: David Pacheco <dap@joyent.com>
Date: Thu, 13 Apr 2017 14:30:54 -0700
Subject: [PATCH] joyent/node-verror#49 want convenience functions for
 MultiErrors

---
 CHANGES.md             |  4 +++
 README.md              | 32 ++++++++++++++++++
 lib/verror.js          | 31 +++++++++++++++++
 package.json           |  2 +-
 test/tst.multierror.js | 75 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 143 insertions(+), 1 deletion(-)

diff --git a/CHANGES.md b/CHANGES.md
index 4eb3d6d..bbb745a 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,10 @@
 
 None yet.
 
+## v1.10.0
+
+* #49 want convenience functions for MultiErrors
+
 ## v1.9.0
 
 * #47 could use VError.hasCauseWithName()
diff --git a/README.md b/README.md
index d27603b..67e7c36 100644
--- a/README.md
+++ b/README.md
@@ -338,6 +338,35 @@ Returns true if and only if `VError.findCauseByName(err, name)` would return
 a non-null value.  This essentially determines whether `err` has any cause in
 its cause chain that has name `name`.
 
+### `VError.errorForList(list)`
+
+Given an array of Error objects (possibly empty), return a single error
+representing the whole collection of errors.  If the list has:
+
+* 0 elements, returns `null`
+* 1 element, returns the sole error
+* more than 1 element, returns a MultiError referencing the whole list
+
+This is useful for cases where an operation may produce any number of errors,
+and you ultimately want to implement the usual `callback(err)` pattern.  You can
+accumulate the errors in an array and then invoke
+`callback(VError.errorForList(list))` when the operation is complete.
+
+
+### `VError.errorForEach(err, func)`
+
+Convenience function for iterating an error that may itself be a MultiError.
+
+In all cases, `err` must be an Error.  If `err` is a MultiError, then `func` is
+invoked as `func(errorN)` for each of the underlying errors of the MultiError.
+If `err` is any other kind of error, `func` is invoked once as `func(err)`.  In
+all cases, `func` is invoked synchronously.
+
+This is useful for cases where an operation may produce any number of warnings
+that may be encapsulated with a MultiError -- but may not be.
+
+This function does not iterate an error's cause chain.
+
 
 ## Examples
 
@@ -483,6 +512,9 @@ outputs:
 
     first of 2 errors: failed to resolve DNS name "abc.example.com"
 
+See the convenience function `VError.errorForList`, which is sometimes simpler
+to use than this constructor.
+
 ## Public methods
 
 
diff --git a/lib/verror.js b/lib/verror.js
index 4e93e55..51849a4 100644
--- a/lib/verror.js
+++ b/lib/verror.js
@@ -306,6 +306,37 @@ VError.fullStack = function (err)
 	return (err.stack);
 };
 
+VError.errorForList = function (errors)
+{
+	mod_assertplus.arrayOfObject(errors, 'errors');
+
+	if (errors.length === 0) {
+		return (null);
+	}
+
+	errors.forEach(function (e) {
+		mod_assertplus.ok(mod_isError(e));
+	});
+
+	if (errors.length == 1) {
+		return (errors[0]);
+	}
+
+	return (new MultiError(errors));
+};
+
+VError.errorForEach = function (err, func)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.func(func, 'func');
+
+	if (err instanceof MultiError) {
+		err.errors().forEach(function iterError(e) { func(e); });
+	} else {
+		func(err);
+	}
+};
+
 
 /*
  * SError is like VError, but stricter about types.  You cannot pass "null" or
diff --git a/package.json b/package.json
index ba3d961..79295c5 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "verror",
-	"version": "1.9.0",
+	"version": "1.10.0",
 	"description": "richer JavaScript errors",
 	"main": "./lib/verror.js",
 	"repository": {
diff --git a/test/tst.multierror.js b/test/tst.multierror.js
index f31e8a1..bf95dcf 100644
--- a/test/tst.multierror.js
+++ b/test/tst.multierror.js
@@ -7,6 +7,8 @@ var mod_verror = require('../lib/verror');
 var mod_testcommon = require('./common');
 
 var MultiError = mod_verror.MultiError;
+var errorForList = mod_verror.errorForList;
+var errorForEach = mod_verror.errorForEach;
 
 /*
  * Save the generic parts of all stack traces so we can avoid hardcoding
@@ -20,6 +22,7 @@ var nodestack = new Error().stack.split('\n').slice(2).join('\n');
 function main()
 {
 	var err1, err2, err3, merr, stack;
+	var accum, doAccum;
 
 	mod_assert.throws(function () {
 		console.error(new MultiError());
@@ -52,6 +55,78 @@ function main()
 	    '    at main (dummy filename)',
 	    '    at Object.<anonymous> (dummy filename)'
 	].join('\n') + '\n' + nodestack);
+
+
+	/* errorForList */
+	mod_assert.throws(function () {
+		console.error(errorForList());
+	}, /^AssertionError: errors \(\[object\]\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForList(null));
+	}, /^AssertionError: errors \(\[object\]\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForList({}));
+	}, /^AssertionError: errors \(\[object\]\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForList('asdf'));
+	}, /^AssertionError: errors \(\[object\]\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForList([ new Error(), 17 ]));
+	}, /^AssertionError: errors \(\[object\]\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForList([ new Error(), {} ]));
+	}, /^AssertionError/);
+
+	mod_assert.strictEqual(null, errorForList([]));
+	mod_assert.ok(err1 == errorForList([ err1 ]));
+	mod_assert.ok(err2 == errorForList([ err2 ]));
+	merr = errorForList([ err1, err2, err3 ]);
+	mod_assert.ok(merr instanceof MultiError);
+	mod_assert.ok(merr.errors()[0] == err1);
+	mod_assert.ok(merr.errors()[1] == err2);
+	mod_assert.ok(merr.errors()[2] == err3);
+
+
+	/* errorForEach */
+	mod_assert.throws(function () {
+		console.error(errorForEach());
+	}, /^AssertionError: err must be an Error$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForEach(null));
+	}, /^AssertionError: err must be an Error$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForEach(err1));
+	}, /^AssertionError: func \(func\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForEach(err1, {}));
+	}, /^AssertionError: func \(func\) is required$/);
+
+	mod_assert.throws(function () {
+		console.error(errorForEach({}, function () {}));
+	}, /^AssertionError: err must be an Error$/);
+
+	accum = [];
+	doAccum = function (e) { accum.push(e); };
+
+	accum = [];
+	errorForEach(err1, doAccum);
+	mod_assert.equal(accum.length, 1);
+	mod_assert.ok(accum[0] == err1);
+
+	accum = [];
+	errorForEach(merr, doAccum);
+	mod_assert.equal(accum.length, 3);
+	mod_assert.ok(accum[0] == err1);
+	mod_assert.ok(accum[1] == err2);
+	mod_assert.ok(accum[2] == err3);
 }
 
 main();
-- 
2.21.0

