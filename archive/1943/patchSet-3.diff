From 764983058a4a6952f904cebcafb9d29c54615f7e Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Fri, 5 May 2017 00:27:14 +0000
Subject: [PATCH] OS-6111 ixgbe MAC_CAPAB_LED support Reviewed by: Jerry
 Jelinek <jerry.jelinek@joyent.com> Approved by: Jerry Jelinek
 <jerry.jelinek@joyent.com>

---
 usr/src/uts/common/io/ixgbe/ixgbe_gld.c  | 66 ++++++++++++++++++++++++
 usr/src/uts/common/io/ixgbe/ixgbe_main.c | 41 +++++++++++++++
 usr/src/uts/common/io/ixgbe/ixgbe_sw.h   |  8 +++
 3 files changed, 115 insertions(+)

diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_gld.c b/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
index 9dff2fe2db..4034735042 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
@@ -220,6 +220,62 @@ ixgbe_m_ioctl(void *arg, queue_t *q, mblk_t *mp)
 	}
 }
 
+static int
+ixgbe_led_set(void *arg, mac_led_mode_t mode, uint_t flags)
+{
+	int ret;
+	ixgbe_t *ixgbe = arg;
+	struct ixgbe_hw *hw = &ixgbe->hw;
+	uint32_t lidx = ixgbe->ixgbe_led_index;
+
+	if (flags != 0)
+		return (EINVAL);
+
+	if (mode != MAC_LED_DEFAULT &&
+	    mode != MAC_LED_IDENT &&
+	    mode != MAC_LED_OFF &&
+	    mode != MAC_LED_ON)
+		return (ENOTSUP);
+
+	if (ixgbe->ixgbe_led_blink && mode != MAC_LED_IDENT) {
+		if ((ret = ixgbe_blink_led_stop(hw, lidx)) != IXGBE_SUCCESS) {
+			return (EIO);
+		}
+		ixgbe->ixgbe_led_blink = B_FALSE;
+	}
+
+	if (mode != MAC_LED_DEFAULT && !ixgbe->ixgbe_led_active) {
+		ixgbe->ixgbe_led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+		ixgbe->ixgbe_led_active = B_TRUE;
+	}
+
+	switch (mode) {
+	case MAC_LED_DEFAULT:
+		if (ixgbe->ixgbe_led_active) {
+			IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ixgbe->ixgbe_led_reg);
+			ixgbe->ixgbe_led_active = B_FALSE;
+		}
+		break;
+	case MAC_LED_IDENT:
+		if ((ret = ixgbe_blink_led_start(hw, lidx)) != IXGBE_SUCCESS)
+			return (EIO);
+		ixgbe->ixgbe_led_blink = B_TRUE;
+		break;
+	case MAC_LED_OFF:
+		if ((ret = ixgbe_led_off(hw, lidx)) != IXGBE_SUCCESS)
+			return (EIO);
+		break;
+	case MAC_LED_ON:
+		if ((ret = ixgbe_led_on(hw, lidx)) != IXGBE_SUCCESS)
+			return (EIO);
+		break;
+	default:
+		return (ENOTSUP);
+	}
+
+	return (0);
+}
+
 /*
  * Obtain the MAC's capabilities and associated data from
  * the driver.
@@ -295,6 +351,16 @@ ixgbe_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 		mct->mct_read = ixgbe_transceiver_read;
 		return (B_TRUE);
 	}
+	case MAC_CAPAB_LED: {
+		mac_capab_led_t *mcl = cap_data;
+
+		mcl->mcl_flags = 0;
+		mcl->mcl_modes = MAC_LED_DEFAULT | MAC_LED_ON | MAC_LED_OFF |
+		    MAC_LED_IDENT;
+		mcl->mcl_set = ixgbe_led_set;
+		break;
+
+	}
 	default:
 		return (B_FALSE);
 	}
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_main.c b/usr/src/uts/common/io/ixgbe/ixgbe_main.c
index a30cd4fb07..41078b8996 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_main.c
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_main.c
@@ -1241,6 +1241,42 @@ ixgbe_destroy_locks(ixgbe_t *ixgbe)
 	mutex_destroy(&ixgbe->watchdog_lock);
 }
 
+/*
+ * We need to try and determine which LED index in hardware corresponds to the
+ * link/activity LED. This is the one that'll be overwritten when we perform
+ * GLDv3 LED activity.
+ */
+static void
+ixgbe_led_init(ixgbe_t *ixgbe)
+{
+	uint32_t reg, i;
+	struct ixgbe_hw *hw = &ixgbe->hw;
+
+	reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+	for (i = 0; i < 4; i++) {
+		if (((reg >> IXGBE_LED_MODE_SHIFT(i)) &
+		    IXGBE_LED_MODE_MASK_BASE) == IXGBE_LED_LINK_ACTIVE) {
+			ixgbe->ixgbe_led_index = i;
+			return;
+		}
+	}
+
+	/*
+	 * If we couldn't determine this, we use the default for various MACs
+	 * based on information Intel has inserted into other drivers over the
+	 * years.  Note, when we have support for the X553 which should add the
+	 * ixgbe_x550_em_a mac type, that should be at index 0.
+	 */
+	switch (hw->mac.type) {
+	case ixgbe_mac_X550EM_x:
+		ixgbe->ixgbe_led_index = 1;
+		break;
+	default:
+		ixgbe->ixgbe_led_index = 2;
+		break;
+	}
+}
+
 static int
 ixgbe_resume(dev_info_t *devinfo)
 {
@@ -1428,6 +1464,11 @@ ixgbe_init(ixgbe_t *ixgbe)
 		    "printed-board-assembly", (char *)pbanum);
 	}
 
+	/*
+	 * Determine LED index.
+	 */
+	ixgbe_led_init(ixgbe);
+
 	if (ixgbe_check_acc_handle(ixgbe->osdep.reg_handle) != DDI_FM_OK) {
 		goto init_fail;
 	}
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_sw.h b/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
index 0a40284416..ca52b10c89 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
@@ -721,6 +721,14 @@ typedef struct ixgbe {
 	hrtime_t		link_check_hrtime;
 	ddi_periodic_t		periodic_id; /* for link check timer func */
 
+	/*
+	 * LED related constants.
+	 */
+	boolean_t		ixgbe_led_active;
+	boolean_t		ixgbe_led_blink;
+	uint32_t		ixgbe_led_reg;
+	uint32_t		ixgbe_led_index;
+
 	/*
 	 * Kstat definitions
 	 */
-- 
2.21.0

