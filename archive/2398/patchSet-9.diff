commit 78190a311a79df7ddffb42490a17c6b2c205ba62 (refs/changes/98/2398/9)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-11-29T13:12:10-05:00 (1 year, 10 months ago)
    
    joyent/node-vasync#37 want whilst
    Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
    Reviewed by: Michael Zeller <mike.zeller@joyent.com>

diff --git a/CHANGES.md b/CHANGES.md
index 9cbf321..cd72b86 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,10 @@
 
 None yet.
 
+## v2.2.0
+
+* #37 want whilst
+
 ## v2.1.0
 
 * #33 want filter, filterLimit, and filterSeries
diff --git a/README.md b/README.md
index 2174881..b327fb8 100644
--- a/README.md
+++ b/README.md
@@ -47,6 +47,8 @@ have several ways of getting at this state:
   invoke the same function on N inputs in series (and stop on failure)
 * [filter/filterSeries/filterLimit](#filterfilterlimitfilterseries-filter-n-inputs-serially-or-concurrently):
   filter N inputs serially or concurrently
+* [whilst](#whilst-invoke-a-function-repeatedly-until-a-stopping-condition-is-met):
+  invoke a function repeatedly until a stopping condition is met
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
   like pipeline, but propagating results between stages
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
@@ -426,6 +428,49 @@ mod_vasync.filter(inputs, filterFunc, function (err, results) {
 });
 ```
 
+### whilst: invoke a function repeatedly until a stopping condition is met
+
+Synopsis: `whilst(testFunc, iterateFunc, callback)`
+
+Repeatedly invoke `iterateFunc` while `testFunc` returns a true value.
+`iterateFunc` is an asychronous function that must call its callback (the first
+and only argument given to it) when it is finished with an optional error
+object as the first argument, and any other arbitrary arguments.  If an error
+object is given as the first argument, `whilst` will finish and call `callback`
+with the error object.  `testFunc` is a synchronous function that must return
+a value - if the value resolves to true `whilst` will invoke `iterateFunc`, if
+it resolves to false `whilst` will finish and invoke `callback` with the last
+set of arguments `iterateFunc` called back with.
+
+`whilst` also returns an object suitable for introspecting the current state of
+the specific `whilst` invocation which contains the following properties:
+
+* `finished`: boolean if this invocation has finished or is in progress
+* `iterations`: number of iterations performed (calls to `iterateFunc`)
+
+Compatible with `async.whilst`
+
+```js
+var n = 0;
+
+var w = mod_vasync.whilst(
+    function testFunc() {
+        return (n < 5);
+    },
+    function iterateFunc(cb) {
+        n++;
+        cb(null, {n: n});
+    },
+    function whilstDone(err, arg) {
+        // err => undefined
+        // arg => {n: 5}
+        // w => {finished: true, iterations: 5}
+    }
+);
+
+// w => {finished: false, iterations: 0}
+```
+
 ### barrier: coordinate multiple concurrent operations
 
 Synopsis: `barrier([args])`
diff --git a/examples/whilst.js b/examples/whilst.js
new file mode 100644
index 0000000..a0aa9e2
--- /dev/null
+++ b/examples/whilst.js
@@ -0,0 +1,20 @@
+var mod_vasync = require('../lib/vasync');
+
+var n = 0;
+
+var w = mod_vasync.whilst(
+    function testFunc() {
+        return (n < 5);
+    },
+    function iterateFunc(cb) {
+        n++;
+        cb(null, {n: n});
+    },
+    function whilstDone(err, arg) {
+        console.log('err: %j', err);
+        console.log('arg: %j', arg);
+        console.log('w (end): %j', w);
+    }
+);
+
+console.log('w (start): %j', w);
diff --git a/lib/vasync.js b/lib/vasync.js
index 3b8f414..0671eda 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -18,6 +18,7 @@ exports.forEachPipeline = forEachPipeline;
 exports.filter = filter;
 exports.filterLimit = filterLimit;
 exports.filterSeries = filterSeries;
+exports.whilst = whilst;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -331,6 +332,77 @@ function filterLimit(inputs, limit, filterFunc, callback) {
 	return (q);
 }
 
+/*
+ * async-compatible "whilst" function, with a few notable exceptions/addons.
+ *
+ * 1. More strict typing of arguments (functions *must* be supplied).
+ * 2. A callback function is required, not optional.
+ * 3. An object is returned, not undefined.
+ */
+function whilst(testFunc, iterateFunc, callback) {
+	mod_assert.equal(typeof (testFunc), 'function',
+	    '"testFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (iterateFunc), 'function',
+	    '"iterateFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+	    '"callback" argument must be specified as a function');
+
+	/*
+	 * The object returned to the caller that provides a read-only
+	 * interface to introspect this specific invocation of "whilst".
+	 */
+	var o = {
+	    'finished': false,
+	    'iterations': 0
+	};
+
+	/*
+	 * Store the last set of arguments from the final call to "iterateFunc".
+	 * The arguments will be passed to the final callback when an error is
+	 * encountered or when the testFunc returns false.
+	 */
+	var args = [];
+
+	function iterate() {
+		var shouldContinue = testFunc();
+
+		if (!shouldContinue) {
+			/*
+			 * The test condition is false - break out of the loop.
+			 */
+			done();
+			return;
+		}
+
+		/* Bump iterations after testFunc but before iterateFunc. */
+		o.iterations++;
+
+		iterateFunc(function whilstIteration(err) {
+			/* Store the latest set of arguments seen. */
+			args = Array.prototype.slice.call(arguments);
+
+			/* Any error with iterateFunc will break the loop. */
+			if (err) {
+				done();
+				return;
+			}
+
+			/* Try again. */
+			setImmediate(iterate);
+		});
+	}
+
+	function done(err) {
+		mod_assert.ok(!o.finished, 'whilst already finished');
+		o.finished = true;
+		callback.apply(this, args);
+	}
+
+	setImmediate(iterate);
+
+	return (o);
+}
+
 /*
  * async-compatible "queue" function.
  */
diff --git a/package.json b/package.json
index cf4acb2..60f6eee 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "vasync",
-	"version": "2.1.0",
+	"version": "2.2.0",
 	"description": "utilities for observable asynchronous control flow",
 	"main": "./lib/vasync.js",
 	"repository": {
diff --git a/tests/whilst.js b/tests/whilst.js
new file mode 100644
index 0000000..0fa7bef
--- /dev/null
+++ b/tests/whilst.js
@@ -0,0 +1,108 @@
+/*
+ * Tests the "whilst" function
+ */
+
+var mod_util = require('util');
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+mod_tap.test('basic whilst', function (test) {
+	var n = 0;
+
+	mod_vasync.whilst(
+	    function condition() {
+		return (n < 5);
+	    },
+	    function body(cb) {
+		n++;
+		cb(null, n);
+	    },
+	    function done(err, arg) {
+		test.ok(!err, 'error unset');
+		test.equal(n, 5, 'n == 5');
+		test.equal(n, arg, 'n == arg');
+		test.end();
+	    });
+});
+
+mod_tap.test('whilst return object', function (test) {
+	var n = 0;
+
+	var w = mod_vasync.whilst(
+	    function condition() {
+		return (n < 5);
+	    },
+	    function body(cb) {
+		n++;
+
+		test.equal(n, w.iterations, 'n == w.iterations: ' + n);
+
+		cb(null, n, 'foo');
+	    },
+	    function done(err, arg1, arg2, arg3) {
+		test.ok(!err, 'error unset');
+		test.equal(w.iterations, 5, 'whilst had 5 iterations');
+		test.equal(w.finished, true, 'whilst has finished');
+		test.equal(arg1, n, 'whilst arg1 == n');
+		test.equal(arg2, 'foo', 'whilst arg2 == "foo"');
+		test.equal(arg3, undefined, 'whilst arg3 == undefined');
+		test.end();
+	    });
+
+	test.equal(typeof (w), 'object', 'whilst returns an object');
+	test.equal(w.finished, false, 'whilst is not finished');
+	test.equal(w.iterations, 0, 'whilst has not started yet');
+});
+
+mod_tap.test('whilst false condition', function (test) {
+	mod_vasync.whilst(
+	    function condition() {
+		return (false);
+	    },
+	    function body(cb) {
+		cb();
+	    },
+	    function done(err, arg) {
+		test.ok(!err, 'error is unset');
+		test.ok(!arg, 'arg is unset');
+		test.end();
+	    });
+});
+
+mod_tap.test('whilst error', function (test) {
+	var n = 0;
+
+	var w = mod_vasync.whilst(
+	    function condition() {
+		return (true);
+	    },
+	    function body(cb) {
+		n++;
+
+		if (n > 5) {
+			cb(new Error('n > 5'), 'bar');
+		} else {
+			cb(null, 'foo');
+		}
+	    },
+	    function done(err, arg) {
+		test.ok(err, 'error is set');
+		test.equal(err.message, 'n > 5');
+		test.equal(arg, 'bar');
+
+		test.equal(w.finished, true, 'whilst is finished');
+
+		/*
+		 * Iterations is bumped after the test condition is run and
+		 * before the iteration function is run.  Because the condition
+		 * in this example is inside the iteration function (the test
+		 * condition always returns true), the iteration count will be
+		 * 1 higher than expected, since it will fail when (n > 5), or
+		 * when iterations is 6.
+		 */
+		test.equal(w.iterations, 6, 'whilst had 6 iterations');
+
+		test.end();
+	    });
+});
