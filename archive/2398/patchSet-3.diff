commit 01e3cc20fb4f26479439739bfa7bf1d527d11d44 (refs/changes/98/2398/3)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-09-18T13:28:15-04:00 (2 years, 1 month ago)
    
    joyent/node-vasync#37 want whilst

diff --git a/README.md b/README.md
index 2174881..bf9914a 100644
--- a/README.md
+++ b/README.md
@@ -47,6 +47,8 @@ have several ways of getting at this state:
   invoke the same function on N inputs in series (and stop on failure)
 * [filter/filterSeries/filterLimit](#filterfilterlimitfilterseries-filter-n-inputs-serially-or-concurrently):
   filter N inputs serially or concurrently
+* [whilst](#whilst-invoke-a-function-repeatedly-until-a-stopping-condition-is-met):
+  invoke a function repeatedly until a stopping condition is met
 * [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):
   like pipeline, but propagating results between stages
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
@@ -426,6 +428,46 @@ mod_vasync.filter(inputs, filterFunc, function (err, results) {
 });
 ```
 
+### whilst: invoke a function repeatedly until a stopping condition is met
+
+Synopsis: `whilst(testFunc, iterateFunc, callback)`
+
+Repeatedly invoke `iterateFunc` while `testFunc` returns a true value.
+`iterateFunc` is an asychronous function that must call its callback (the first
+and only argument given to it) when it is finished with an optional error
+object as the first argument, and any other arbitrary arguments.  If an error
+object is given as the first argument, `whilst` will finish and call `callback`
+with the error object.  `testFunc` is a synchcronous function that must return
+a value - if the value resolves to true `whilst` will invoke `iterateFunc`, if
+it resolves to false `whilst` will finish and invoke `callback` with the last
+set of arguments `iterateFunc` called back with.  `whilst` also returns an
+object suitable for introspecting the current state of the specific `whilst`
+invocation.
+
+Compatible with `async.whilst`
+
+``` js
+var n = 0;
+
+var w = (mod_vasync.whilst(
+    function testFunc() {
+        return (n < 5);
+    },
+    function iterateFunc(cb) {
+        n++;
+        cb(null, {n: n});
+    },
+    function whilstDone(err, arg) {
+        // err => undefined
+        // arg => {n: 5}
+        // w => {finished: true, iterations: 5, error: null,
+        //       args: [{n: 5}]}
+    }
+));
+
+// w => {finished: false, iterations: 0, error: null, args: null}
+```
+
 ### barrier: coordinate multiple concurrent operations
 
 Synopsis: `barrier([args])`
diff --git a/lib/vasync.js b/lib/vasync.js
index b3b7f7e..4cbb732 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -18,6 +18,7 @@ exports.forEachPipeline = forEachPipeline;
 exports.filter = filter;
 exports.filterLimit = filterLimit;
 exports.filterSeries = filterSeries;
+exports.whilst = whilst;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -331,6 +332,82 @@ function filterLimit(inputs, limit, filterFunc, callback) {
 	return (q);
 }
 
+/*
+ * async-compatible "whilst" function
+ */
+function whilst(testFunc, iterateFunc, callback) {
+	mod_assert.equal(typeof (testFunc), 'function',
+	    '"testFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (iterateFunc), 'function',
+	    '"iterateFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+	    '"callback" argument must be specified as a function');
+
+	/*
+	 * The object returned to the caller that provides a read-only
+	 * interface to introspect this specific invocation of "whilst".
+	 */
+	var o = {
+		finished: false,
+		error: null,
+		args: null,
+		iterations: 0
+	};
+
+	/*
+	 * Store the last set of arguments from the final call to "iterateFunc".
+	 * The arguments will be passed to the final callback when an error is
+	 * encountered or when the testFunc returns false.
+	 */
+	var args = [];
+
+	function iterate() {
+		var shouldContinue = testFunc();
+
+		if (!shouldContinue) {
+			// The test condition is false - break out of the loop.
+			done();
+			return;
+		}
+
+		// Bump iterations after testFunc but before iterateFunc.
+		o.iterations++;
+
+		iterateFunc(function whilstIteration(err) {
+			// Store the latest set of arguments seen.
+			args = Array.prototype.slice.call(arguments);
+
+			// Any error with iterateFunc will break the loop.
+			if (err) {
+				o.error = err;
+				done();
+				return;
+			}
+
+			// Try again.
+			setImmediate(iterate);
+		});
+	}
+
+	function done() {
+		mod_assert.ok(!o.finished, 'whilst already finished');
+		o.finished = true;
+
+                /*
+                 * Slice off the first argument when saving `o.args`, as it is
+                 * the optional error argument already stored as `o.error` if
+                 * it is set.
+                 */
+		o.args = args.slice(1);
+
+		callback.apply(this, args);
+	}
+
+	setImmediate(iterate);
+
+	return (o);
+}
+
 /*
  * async-compatible "queue" function.
  */
diff --git a/tests/whilst.js b/tests/whilst.js
new file mode 100644
index 0000000..3eaa521
--- /dev/null
+++ b/tests/whilst.js
@@ -0,0 +1,114 @@
+/*
+ * Tests the "whilst" function
+ */
+
+var mod_util = require('util');
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+mod_tap.test('basic whilst', function (test) {
+	var n = 0;
+
+	mod_vasync.whilst(
+	    function condition() {
+		return (n < 5);
+	    },
+	    function body(cb) {
+		n++;
+		cb(null, n);
+	    },
+	    function done(err, arg) {
+		test.ok(!err, 'error unset');
+		test.equal(n, 5, 'n == 5');
+		test.equal(n, arg, 'n == arg');
+		test.end();
+	    });
+});
+
+mod_tap.test('whilst return object', function (test) {
+	var n = 0;
+
+	var w = (mod_vasync.whilst(
+	    function condition() {
+		return (n < 5);
+	    },
+	    function body(cb) {
+		n++;
+
+		test.equal(n, w.iterations, 'n == w.iterations: ' + n);
+
+		cb(null, n, 'foo');
+	    },
+	    function done(err, arg) {
+		test.ok(!err, 'error unset');
+		test.equal(w.iterations, 5, 'whilst had 5 iterations');
+		test.equal(w.finished, true, 'whilst has finished');
+		test.equal(w.error, null, 'whilst had no error');
+		test.equal(w.args[0], n, 'whilst args[0] == n');
+		test.equal(w.args[1], 'foo', 'whilst args[1] == "foo"');
+		test.equal(w.args[2], undefined, 'whilst args[2] == undefined');
+		test.end();
+	    }));
+
+	test.equal(typeof (w), 'object', 'whilst returns an object');
+	test.equal(w.finished, false, 'whilst is not finished');
+	test.equal(w.args, null, 'whilst has no arguments yet');
+	test.equal(w.error, null, 'whilst has no error yet');
+	test.equal(w.iterations, 0, 'whilst has not started yet');
+});
+
+mod_tap.test('whilst false condition', function (test) {
+	mod_vasync.whilst(
+	    function condition() {
+		return (false);
+	    },
+	    function body(cb) {
+		cb();
+	    },
+	    function done(err, arg) {
+		test.ok(!err, 'error is unset');
+		test.ok(!arg, 'arg is unset');
+		test.end();
+	    });
+});
+
+mod_tap.test('whilst error', function (test) {
+	var n = 0;
+
+	var w = (mod_vasync.whilst(
+	    function condition() {
+		return (true);
+	    },
+	    function body(cb) {
+		n++;
+
+		if (n > 5) {
+			cb(new Error('n > 5'), 'bar');
+		} else {
+			cb(null, 'foo');
+		}
+	    },
+	    function done(err, arg) {
+		test.ok(err, 'error is set');
+		test.equal(err.message, 'n > 5');
+		test.equal(arg, 'bar');
+
+		test.equal(w.finished, true, 'whilst is finished');
+
+		/*
+		 * Iterations is bumped after the test condition is run and
+		 * before the iteration function is run.  Because the condition
+		 * in this example is inside the iteration function (the test
+		 * condition always returns true), the iteration count will be
+		 * 1 higher than expected, since it will fail when (n > 5), or
+		 * when iterations is 6.
+		 */
+		test.equal(w.iterations, 6, 'whilst had 6 iterations');
+
+		test.deepEqual(w.error, err, 'errors are the same');
+		test.equal(w.args[0], arg, 'args are the same');
+
+		test.end();
+	    }));
+});
