commit 3d82684d2e603c2ac50437b7ff269eab228efe14 (refs/changes/61/3661/1)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2018-03-16T11:49:36-05:00 (1 year, 7 months ago)
    
    OS-6639 bhyve memory allocations that can't succeed should fail or at least be interruptible
    Reviewed by: Mike Gerdts <mike.gerdts@joyent.com>
    Reviewed by: John Levon <john.levon@joyent.com>
    Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
    Approved by: John Levon <john.levon@joyent.com>

diff --git a/usr/src/cmd/bhyve/bhyverun.c b/usr/src/cmd/bhyve/bhyverun.c
index 7a19ffd2a4..dbc2414e23 100644
--- a/usr/src/cmd/bhyve/bhyverun.c
+++ b/usr/src/cmd/bhyve/bhyverun.c
@@ -1005,7 +1005,20 @@ main(int argc, char *argv[])
 	fbsdrun_set_capabilities(ctx, BSP);
 
 	vm_set_memflags(ctx, memflags);
+#ifdef	__FreeBSD__
 	err = vm_setup_memory(ctx, memsize, VM_MMAP_ALL);
+#else
+	do {
+		errno = 0;
+		err = vm_setup_memory(ctx, memsize, VM_MMAP_ALL);
+		error = errno;
+		if (err != 0 && error == ENOMEM) {
+			(void) fprintf(stderr, "Unable to allocate memory "
+			    "(%llu), retrying in 1 second\n", memsize);
+			sleep(1);
+		}
+	} while (error == ENOMEM);
+#endif
 	if (err) {
 		fprintf(stderr, "Unable to setup memory (%d)\n", errno);
 		exit(1);
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index 7a24c8633c..1b074d2f92 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -115,7 +115,7 @@ struct vmspace_mapping {
 };
 typedef struct vmspace_mapping vmspace_mapping_t;
 
-#define VMSM_OFFSET(vmsm, addr)	(			\
+#define	VMSM_OFFSET(vmsm, addr)	(			\
 	    (vmsm)->vmsm_offset +			\
 	    ((addr) - (uintptr_t)(vmsm)->vmsm_addr))
 
@@ -941,7 +941,12 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 	switch (type) {
 	case OBJT_DEFAULT: {
 		/* XXXJOY: opt-in to larger pages? */
-		vmo->vmo_data = vmem_alloc(vmm_arena, size, KM_SLEEP);
+		vmo->vmo_data = vmem_alloc(vmm_arena, size, KM_NOSLEEP);
+		if (vmo->vmo_data == NULL) {
+			mutex_destroy(&vmo->vmo_lock);
+			kmem_free(vmo, sizeof (*vmo));
+			return (NULL);
+		}
 		/* XXXJOY: Better zeroing approach? */
 		bzero(vmo->vmo_data, size);
 		vmo->vmo_pager = vm_object_pager_heap;
@@ -1300,7 +1305,7 @@ vm_map_wire(vm_map_t map, vm_offset_t start, vm_offset_t end, int flags)
 	vmo = vmsm->vmsm_object;
 	prot = vmsm->vmsm_prot;
 
-	for (uintptr_t pos = addr; pos < end;) {
+	for (uintptr_t pos = addr; pos < end; ) {
 		pfn_t pfn;
 		uintptr_t pg_size, map_addr;
 		uint_t map_lvl = 0;
