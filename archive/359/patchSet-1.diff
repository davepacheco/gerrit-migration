From 3b98d2fcc2d5b7461092c069b8a7c1ee02dc0803 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 4 Aug 2016 01:24:51 +0000
Subject: [PATCH] FWAPI-164 Move fwadm(1M) to new node-cmdln FWAPI-245
 Arguments placed before fwadm(1M) subcommands are ignored

---
 src/fw/lib/cli.js                          |   15 +-
 src/fw/lib/fwadm.js                        |  282 +++--
 src/fw/man/fwadm.1m.md                     |   21 +-
 src/fw/man/fwadm.1m.md.in                  |   21 +-
 src/fw/man/fwrule.5.footer                 |    2 +-
 src/fw/man/fwrule.5.md                     |    2 +-
 src/fw/node_modules/assert-plus/README.md  |   78 +-
 src/fw/node_modules/assert-plus/index.js   |  335 ++---
 src/fw/node_modules/cmdln/index.js         | 1294 ++++++++++++++++++--
 src/fw/node_modules/dashdash/LICENSE.txt   |   24 -
 src/fw/node_modules/dashdash/README.md     |  574 +++++++++
 src/fw/node_modules/dashdash/index.js      |  618 ++++++++--
 src/fw/node_modules/fuzzyset.js/README.rst |  133 ++
 src/fw/node_modules/fuzzyset.js/index.js   |  288 +++++
 src/fw/package.json                        |    4 +-
 src/fw/test/unit/vms.test.js               |    2 +-
 src/fw/tools/bin/rebuild-node-modules      |    6 +-
 src/manifest                               |    5 +-
 18 files changed, 3193 insertions(+), 511 deletions(-)
 delete mode 100644 src/fw/node_modules/dashdash/LICENSE.txt
 create mode 100644 src/fw/node_modules/dashdash/README.md
 create mode 100755 src/fw/node_modules/fuzzyset.js/README.rst
 create mode 100644 src/fw/node_modules/fuzzyset.js/index.js

diff --git a/src/fw/lib/cli.js b/src/fw/lib/cli.js
index e93d8a08..1dfb1778 100644
--- a/src/fw/lib/cli.js
+++ b/src/fw/lib/cli.js
@@ -20,12 +20,13 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: CLI shared logic
  */
 
+var cmdln = require('cmdln');
 var fs = require('fs');
 var tab = require('tab');
 var tty = require('tty');
@@ -148,7 +149,8 @@ function getPayload(opts, args, callback) {
             rule: args.join(' ')
         };
 
-        return callback(null, payload);
+        callback(null, payload);
+        return;
     }
 
     if (!file && !tty.isatty(0)) {
@@ -156,7 +158,8 @@ function getPayload(opts, args, callback) {
     }
 
     if (!file) {
-        return callback(new verror.VError('Must supply file!'));
+        callback(new cmdln.UsageError('Must supply file!'));
+        return;
     }
 
     if (file === '-') {
@@ -217,6 +220,9 @@ function outputError(err, opts) {
                 if (opts.verbose) {
                     j.stack = e.stack;
                 }
+                if (e.cmdlnErrHelpFromErr) {
+                    j.help = cmdln.errHelpFromErr(e);
+                }
                 return j;
             })
         }));
@@ -227,6 +233,9 @@ function outputError(err, opts) {
         if (opts && opts.verbose) {
             console.error(e.stack);
         }
+        if (e.cmdlnErrHelpFromErr) {
+            console.error('\n' + cmdln.errHelpFromErr(e));
+        }
     });
 }
 
diff --git a/src/fw/lib/fwadm.js b/src/fw/lib/fwadm.js
index 1d2dd4c0..3c0a6abf 100644
--- a/src/fw/lib/fwadm.js
+++ b/src/fw/lib/fwadm.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: CLI logic
@@ -36,6 +36,7 @@ var path = require('path');
 var pipeline = require('./pipeline').pipeline;
 var util = require('util');
 var util_log = require('./util/log');
+var util_obj = require('./util/obj');
 var vasync = require('vasync');
 var verror = require('verror');
 var VM = require('/usr/vm/node_modules/VM');
@@ -56,11 +57,13 @@ var OPTS = {
     delim: {
         names: ['delim', 'd'],
         type: 'string',
+        helpArg: '<char>',
         help: 'Output delimiter.'
     },
     description: {
         names: ['description', 'desc' ],
         type: 'string',
+        helpArg: '<str>',
         help: 'Rule description.'
     },
     enable: {
@@ -71,6 +74,7 @@ var OPTS = {
     file: {
         names: ['file', 'f'],
         type: 'string',
+        helpArg: '<file>',
         help: 'Input file.'
     },
     global: {
@@ -91,11 +95,13 @@ var OPTS = {
     output_fields: {
         names: ['fields', 'o'],
         type: 'string',
+        helpArg: '<fields>',
         help: 'Output field list'
     },
     owner_uuid: {
         names: ['owner_uuid', 'O'],
         type: 'string',
+        helpArg: '<uuid>',
         help: 'Owner UUID'
     },
     parseable: {
@@ -280,8 +286,30 @@ function Fwadm() {
     cmdln.Cmdln.call(this, {
         name: 'fwadm',
         desc: 'Manage firewall rules',
-        options: [ OPTS.help, OPTS.json, OPTS.dryrun, OPTS.stdout,
-            OPTS.verbose ]
+        helpSubcmds: [
+            'add',
+            'delete',
+            'disable',
+            'enable',
+            'get',
+            'list',
+            'update',
+            'vms',
+            { group: '' },
+            'add-rvm',
+            'delete-rvm',
+            'get-rvm',
+            'list-rvms',
+            'rvm-rules',
+            { group: '' },
+            'rules',
+            'start',
+            'status',
+            'stats',
+            'stop',
+            { group: '', unmatched: true }
+        ],
+        options: [ OPTS.help, OPTS.json, OPTS.verbose ]
     });
 }
 
@@ -319,7 +347,7 @@ Fwadm.prototype.do_add = function (subcmd, opts, args, callback) {
 /**
  * Adds a remote VM
  */
-Fwadm.prototype['do_add-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_add_rvm = function (subcmd, opts, args, callback) {
     LOG = util_log.create({ action: 'add' });
 
     pipeline({
@@ -361,21 +389,19 @@ Fwadm.prototype.do_list = function (subcmd, opts, args, callback) {
     }
 
     if (opts.delim && !opts.parseable) {
-        var delimErr = new Error('-d requires -p');
-        cli.outputError(delimErr, opts);
-        return callback(delimErr);
+        callback(new cmdln.UsageError('-d requires -p'));
+        return;
     }
 
     if (opts.json && opts.parseable) {
-        var fmtErr = new Error('cannot specify both -j and -p');
-        cli.outputError(fmtErr, opts);
-        return callback(fmtErr);
+        callback(new cmdln.UsageError('cannot specify both -j and -p'));
+        return;
     }
 
     LOG = util_log.create({ action: 'list' }, true);
     listOpts.log = LOG;
 
-    return fw.list(listOpts, function (err, res) {
+    fw.list(listOpts, function (err, res) {
         cli.displayRules(err, res, opts);
         return callback(err);
     });
@@ -385,7 +411,7 @@ Fwadm.prototype.do_list = function (subcmd, opts, args, callback) {
 /**
  * Lists remote VMs
  */
-Fwadm.prototype['do_list-rvms'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_list_rvms = function (subcmd, opts, args, callback) {
     LOG = util_log.create({ action: 'listRemoteVMs' }, true);
 
     // XXX: support filtering, sorting
@@ -410,10 +436,10 @@ Fwadm.prototype.do_update = function (subcmd, opts, args, callback) {
         id = args.shift();
     }
 
-    return cli.getPayload(opts, args, function (err, payload) {
+    cli.getPayload(opts, args, function (err, payload) {
         if (err) {
-            cli.outputError(err, opts);
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var updatePayload = preparePayload(opts, payload);
@@ -425,7 +451,7 @@ Fwadm.prototype.do_update = function (subcmd, opts, args, callback) {
             updatePayload.rules[0].uuid = cli.validateUUID(id);
         }
 
-        return doUpdate(opts, updatePayload, 'Updated', callback);
+        doUpdate(opts, updatePayload, 'Updated', callback);
     });
 };
 
@@ -452,7 +478,7 @@ Fwadm.prototype.do_get = function (subcmd, opts, args, callback) {
 /**
  * Gets a remote VM
  */
-Fwadm.prototype['do_get-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_get_rvm = function (subcmd, opts, args, callback) {
     var uuid = cli.validateUUID(args[0]);
     LOG = util_log.create({ action: 'getRemoteVM' }, true);
 
@@ -474,14 +500,15 @@ Fwadm.prototype['do_get-rvm'] = function (subcmd, opts, args, callback) {
 function enableDisable(subcmd, opts, args, callback) {
     var enabled = subcmd === 'enable';
     if (args.length === 0) {
-        return callback(new Error('Must specify rules to enable!'));
+        callback(new cmdln.UsageError('Must specify rules to enable!'));
+        return;
     }
 
     var rules = args.map(function (uuid) {
         return { uuid: cli.validateUUID(uuid), enabled: enabled };
     });
 
-    return doUpdate(opts, preparePayload(opts, { rules: rules }),
+    doUpdate(opts, preparePayload(opts, { rules: rules }),
         enabled ? 'Enabled' : 'Disabled', callback);
 }
 
@@ -490,6 +517,7 @@ Fwadm.prototype.do_enable = function () {
     enableDisable.apply(this, arguments);
 };
 
+
 Fwadm.prototype.do_disable = function () {
     enableDisable.apply(this, arguments);
 };
@@ -529,7 +557,7 @@ Fwadm.prototype.do_delete = function (subcmd, opts, args, callback) {
 /**
  * Deletes a remote VM
  */
-Fwadm.prototype['do_delete-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_delete_rvm = function (subcmd, opts, args, callback) {
     if (args.length === 0) {
         return console.error('Must specify remote VMs to delete!');
     }
@@ -560,7 +588,7 @@ Fwadm.prototype['do_delete-rvm'] = function (subcmd, opts, args, callback) {
 /**
  * Gets the rules that apply to a remote VM
  */
-Fwadm.prototype['do_rvm-rules'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_rvm_rules = function (subcmd, opts, args, callback) {
     var uuid = cli.validateUUID(args[0]);
     LOG = util_log.create({ action: 'rvmRules' }, true);
 
@@ -706,17 +734,6 @@ Fwadm.prototype.do_vms = function (subcmd, opts, args, callback) {
     });
 };
 
-var ARG_OPTS;
-
-/**
- * Run before any of the do_* methods
- */
-Fwadm.prototype.init = function (opts, args, callback) {
-    ARG_OPTS = opts;
-    return callback();
-
-};
-
 
 
 // --- Help text and other cmdln options
@@ -724,46 +741,148 @@ Fwadm.prototype.init = function (opts, args, callback) {
 
 
 var HELP = {
-    add: 'add firewall rules or remote VMs',
-    'add-rvm': 'add a remote VM',
-    delete: 'delete a rule',
-    'delete-rvm': 'delete a remote VM',
-    disable: 'disable a rule',
-    enable: 'enable a rule',
-    get: 'get a rule',
-    'get-rvm': 'get a remote VM',
-    list: 'list rules',
-    'list-rvms': 'list remote VMs',
-    rules: 'list rules that apply to a VM',
-    'rvm-rules': 'list rules that apply to a remote VM',
-    start: 'start a VM\'s firewall',
-    status: 'get the status of a VM\'s firewall',
-    stats: 'get rule statistics for a VM\'s firewall',
-    stop: 'stop a VM\'s firewall',
-    update: 'update firewall rules or data',
-    vms: 'list the UUIDs of VMs affected by a rule'
+    add: {
+        summary: 'Add firewall rules or remote VMs.',
+        synopses: [
+            '{{name}} {{cmd}} -f <file>',
+            '{{name}} {{cmd}} [-e] [--desc <description>] [-g] [-O <owner uuid>] <rule>'
+        ],
+        options: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
+            OPTS.owner_uuid ],
+        examples: '    fwadm add -e -O $USER_UUID FROM any TO all vms ALLOW udp '
+            + 'PORTS 67, 68\n'
+            + '    fwadm add -g -e FROM any TO all vms ALLOW tcp PORT 22\n'
+            + '    fwadm add <<EOF\n'
+            + '    {\n'
+            + '      "rules": [ {\n'
+            + '        "description": "allow all ICMPv6 types",\n'
+            + '        "rule": "FROM any TO all vms ALLOW icmp6 type all",\n'
+            + '        "enabled": true,\n'
+            + '        "global": true\n'
+            + '      } ]\n'
+            + '    }\n'
+            + '    EOF\n'
+    },
+    add_rvm: {
+        summary: 'Add a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS]' ],
+        options: [ OPTS.file ]
+    },
+    delete: {
+        summary: 'Delete a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    },
+    delete_rvm: {
+        summary: 'Delete a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    disable: {
+        summary: 'Disable a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    enable: {
+        summary: 'Enable a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    get: {
+        summary: 'Get a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    },
+    get_rvm: {
+        summary: 'Get a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    list: {
+        summary: 'List rules.',
+        synopses: [
+            '{{name}} {{cmd}} [OPTIONS] -p [-d <char>]',
+            '{{name}} {{cmd}} [OPTIONS] -j'
+        ],
+        options: [ OPTS.delim, OPTS.output_fields, OPTS.parseable ]
+    },
+    list_rvms: {
+        summary: 'List remote VMs.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS]' ]
+    },
+    rules: {
+        summary: 'List rules that apply to a VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    rvm_rules: {
+        summary: 'List rules that apply to a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    start: {
+        summary: 'Start a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    status: {
+        summary: 'Get the status of a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    stats: {
+        summary: 'Get rule statistics for a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    stop: {
+        summary: 'Stop a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    update: {
+        summary: 'Update firewall rules or data.',
+        synopses: [
+            '{{name}} {{cmd}} -f <file>',
+            '{{name}} {{cmd}} <rule uuid> [-e] [--desc <description>] [-g] \\\n'
+                + '    [-O <owner uuid>] <rule>'
+        ],
+        options: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
+            OPTS.owner_uuid ],
+    },
+    vms: {
+        summary: 'List the UUIDs of VMs affected by a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    }
 };
 
-var EXTRA_OPTS = {
-    add: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
-        OPTS.owner_uuid ],
-    'add-rvm': [ OPTS.file ],
-    list: [ OPTS.delim, OPTS.output_fields, OPTS.parseable ],
-    update: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
-        OPTS.owner_uuid ]
-};
+
+/**
+ * Wrap a subcommand function with common checks
+ */
+function wrapSubcmd(func) {
+    return function (subcmd, opts, args, callback) {
+        if (opts.help) {
+            this.do_help('help', {}, [ subcmd ], callback);
+            return;
+        }
+
+        opts = this.opts = util_obj.mergeObjects(this.opts, opts);
+
+        onlyif.rootInSmartosGlobal(function (err) {
+            if (err) {
+                console.error('FATAL: cannot run: %s', err);
+                return process.exit(2);
+            }
+
+            func(subcmd, opts, args, callback);
+        });
+    };
+}
+
 
 // Help text and options for all commands
 for (var cmd in HELP) {
-    var proto = Fwadm.prototype['do_' + cmd];
-    proto.help = HELP[cmd];
-    if (!EXTRA_OPTS.hasOwnProperty(cmd)) {
-        EXTRA_OPTS[cmd] = [];
+    var do_key = 'do_' + cmd;
+    var info = HELP[cmd];
+    var proto = Fwadm.prototype[do_key];
+    proto = Fwadm.prototype[do_key] = wrapSubcmd(proto);
+    proto.help = info.summary + '\n\n{{usage}}\n\n{{options}}'
+    if (info.hasOwnProperty('examples')) {
+        proto.help += '\n\nExamples:\n\n' + info.examples;
     }
 
-    EXTRA_OPTS[cmd] = EXTRA_OPTS[cmd].concat([
-        OPTS.dryrun, OPTS.json, OPTS.stdout, OPTS.verbose ]);
-    proto.options = EXTRA_OPTS[cmd];
+    proto.synopses = info.synopses;
+    proto.options = (info.options || []).concat([
+        OPTS.help, OPTS.dryrun, OPTS.json, OPTS.stdout, OPTS.verbose ]);
 }
 
 
@@ -776,30 +895,23 @@ for (var cmd in HELP) {
  * Main entry point
  */
 function main() {
-    onlyif.rootInSmartosGlobal(function (err) {
-        if (err) {
-            console.error('FATAL: cannot run: %s', err);
-            return process.exit(2);
+    var fwadm = new Fwadm();
+    fwadm.main(process.argv, function (err2) {
+        if (err2 && !cli.haveOutputErr()) {
+            cli.outputError(err2, fwadm.opts);
+            // This is a usage error - no need to flush logs
+            process.exit(2);
         }
 
-        var fwadm = new Fwadm;
-        fwadm.main(process.argv, function (err2) {
-            if (err2 && !cli.haveOutputErr()) {
-                cli.outputError(err2, ARG_OPTS);
-                // This is a usage error - no need to flush logs
-                process.exit(2);
+        // Potentially 3 different logs to flush: if we've only used
+        // fw.js, just flush LOG.  If we've gone through VM.update
+        // (for start / stop), we need to flush VM.log and VM.fw_log.
+        util_log.flush([LOG, VM.log, VM.fw_log], function () {
+            if (cli.haveOutputErr()) {
+                process.exit(1);
             }
 
-            // Potentially 3 different logs to flush: if we've only used
-            // fw.js, just flush LOG.  If we've gone through VM.update
-            // (for start / stop), we need to flush VM.log and VM.fw_log.
-            util_log.flush([LOG, VM.log, VM.fw_log], function () {
-                if (cli.haveOutputErr()) {
-                    process.exit(1);
-                }
-
-                process.exit(0);
-            });
+            process.exit(0);
         });
     });
 }
diff --git a/src/fw/man/fwadm.1m.md b/src/fw/man/fwadm.1m.md
index f37deed4..22fe3d1d 100644
--- a/src/fw/man/fwadm.1m.md
+++ b/src/fw/man/fwadm.1m.md
@@ -1,4 +1,4 @@
-# fwadm(1m) -- Manage SmartOS firewall rules
+# fwadm(1M) -- Manage SmartOS firewall rules
 
 
 ## SYNOPSIS
@@ -202,7 +202,8 @@ the firewalls of any VMs affected.
             
 
     fwadm update -f <file>
-    fwadm update [-e] [--desc <description>] [-g] [-O <owner uuid>] <rule>
+    fwadm update <rule uuid> [-e] [--desc <description>] [-g] \
+        [-O <owner uuid>] <rule>
 
         Update firewall rules or remote VMs.  A single rule and its properties
         can be updated using arguments, or the -f option can be used to pass a
@@ -224,8 +225,8 @@ the firewalls of any VMs affected.
                                     that were updated.
 
         Arguments:
-            <rule>                  Firewall rule, written in the rule DSL.  See
-                                    fwrule(5) for syntax.
+            <rule>                  Firewall rule, written in the rule DSL.
+                                    See fwrule(5) for syntax.
 
         Examples:
             # Update a rule by specifying it on the commandline.
@@ -371,7 +372,7 @@ the firewalls of any VMs affected.
 
 ## REMOTE VM PROPERTIES
 
-    Remote VMs are simplified versions of the VM objects used by vmadm(1m).
+    Remote VMs are simplified versions of the VM objects used by vmadm(1M).
     They are also in a JSON format, but only the properties below will be
     stored and used by fwadm. All other properties will be discarded. The
     properties used are:
@@ -384,7 +385,7 @@ the firewalls of any VMs affected.
 
     nics:
 
-        Array of nics, as per vmadm(1m). Only the "ip" property of each of
+        Array of nics, as per vmadm(1M). Only the "ip" property of each of
         these nic objects is required - all other properties will be ignored.
         This property is used for creation of remote VMs only - it is not
         stored in the object. IPs from these objects will be added to the ips
@@ -398,12 +399,12 @@ the firewalls of any VMs affected.
 
     tags:
 
-        vmadm(1m) tags object, mapping tag keys to values.
+        vmadm(1M) tags object, mapping tag keys to values.
 
     uuid (required):
 
         UUID. This must not be the same as the UUID of any other remote VM or
-        local VM managed by vmadm(1m).
+        local VM managed by vmadm(1M).
 
     Note that VMs can be added and updated in this simplified representation,
     or using the same representation as "vmadm get". This enables the output
@@ -413,7 +414,7 @@ the firewalls of any VMs affected.
 
 ## INTERACTION WITH VMADM(1M)
 
-    fwadm relies on properties of VMs from vmadm(1m) in order to generate
+    fwadm relies on properties of VMs from vmadm(1M) in order to generate
     firewall rules correctly. Therefore, when vmadm is used to create a new
     VM or update properties on an existing VM that can affect firewall rules,
     it will update firewall rules through fwadm accordingly.
@@ -483,4 +484,4 @@ The following exit values are returned:
 
 ## SEE ALSO
 
-    vmadm(1m), fwrule(5), ipf(1m), ipfilter(5)
+    vmadm(1M), fwrule(5), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwadm.1m.md.in b/src/fw/man/fwadm.1m.md.in
index cb7eab8b..8b45c5d5 100644
--- a/src/fw/man/fwadm.1m.md.in
+++ b/src/fw/man/fwadm.1m.md.in
@@ -1,4 +1,4 @@
-# fwadm(1m) -- Manage SmartOS firewall rules
+# fwadm(1M) -- Manage SmartOS firewall rules
 
 
 ## SYNOPSIS
@@ -188,7 +188,8 @@ the firewalls of any VMs affected.
 
 
     fwadm update -f <file>
-    fwadm update [-e] [--desc <description>] [-g] [-O <owner uuid>] <rule>
+    fwadm update <rule uuid> [-e] [--desc <description>] [-g] \
+        [-O <owner uuid>] <rule>
 
         Update firewall rules or remote VMs.  A single rule and its properties
         can be updated using arguments, or the -f option can be used to pass a
@@ -210,8 +211,8 @@ the firewalls of any VMs affected.
                                     that were updated.
 
         Arguments:
-            <rule>                  Firewall rule, written in the rule DSL.  See
-                                    fwrule(5) for syntax.
+            <rule>                  Firewall rule, written in the rule DSL.
+                                    See fwrule(5) for syntax.
 
         Examples:
             {{#indent_and_wrap}}
@@ -335,7 +336,7 @@ the firewalls of any VMs affected.
 
 ## REMOTE VM PROPERTIES
 
-    Remote VMs are simplified versions of the VM objects used by vmadm(1m).
+    Remote VMs are simplified versions of the VM objects used by vmadm(1M).
     They are also in a JSON format, but only the properties below will be
     stored and used by fwadm. All other properties will be discarded. The
     properties used are:
@@ -348,7 +349,7 @@ the firewalls of any VMs affected.
 
     nics:
 
-        Array of nics, as per vmadm(1m). Only the "ip" property of each of
+        Array of nics, as per vmadm(1M). Only the "ip" property of each of
         these nic objects is required - all other properties will be ignored.
         This property is used for creation of remote VMs only - it is not
         stored in the object. IPs from these objects will be added to the ips
@@ -362,12 +363,12 @@ the firewalls of any VMs affected.
 
     tags:
 
-        vmadm(1m) tags object, mapping tag keys to values.
+        vmadm(1M) tags object, mapping tag keys to values.
 
     uuid (required):
 
         UUID. This must not be the same as the UUID of any other remote VM or
-        local VM managed by vmadm(1m).
+        local VM managed by vmadm(1M).
 
     Note that VMs can be added and updated in this simplified representation,
     or using the same representation as "vmadm get". This enables the output
@@ -377,7 +378,7 @@ the firewalls of any VMs affected.
 
 ## INTERACTION WITH VMADM(1M)
 
-    fwadm relies on properties of VMs from vmadm(1m) in order to generate
+    fwadm relies on properties of VMs from vmadm(1M) in order to generate
     firewall rules correctly. Therefore, when vmadm is used to create a new
     VM or update properties on an existing VM that can affect firewall rules,
     it will update firewall rules through fwadm accordingly.
@@ -418,4 +419,4 @@ The following exit values are returned:
 
 ## SEE ALSO
 
-    vmadm(1m), fwrule(5), ipf(1m), ipfilter(5)
+    vmadm(1M), fwrule(5), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwrule.5.footer b/src/fw/man/fwrule.5.footer
index f10b991f..3272f277 100644
--- a/src/fw/man/fwrule.5.footer
+++ b/src/fw/man/fwrule.5.footer
@@ -1,4 +1,4 @@
 
 ## SEE ALSO
 
-    fwadm(1m), vmadm(1m), ipf(1m), ipfilter(5)
+    fwadm(1M), vmadm(1M), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwrule.5.md b/src/fw/man/fwrule.5.md
index 4b38f110..820dfb05 100644
--- a/src/fw/man/fwrule.5.md
+++ b/src/fw/man/fwrule.5.md
@@ -323,4 +323,4 @@ Some examples of rules that would cause this message include:
 
 ## SEE ALSO
 
-    fwadm(1m), vmadm(1m), ipf(1m), ipfilter(5)
+    fwadm(1M), vmadm(1M), ipf(1M), ipfilter(5)
diff --git a/src/fw/node_modules/assert-plus/README.md b/src/fw/node_modules/assert-plus/README.md
index c0c3a530..ec200d16 100644
--- a/src/fw/node_modules/assert-plus/README.md
+++ b/src/fw/node_modules/assert-plus/README.md
@@ -1,24 +1,26 @@
-# node-assert-plus
+# assert-plus
 
 This library is a super small wrapper over node's assert module that has two
 things: (1) the ability to disable assertions with the environment variable
-NODE_NDEBUG, and (2) some API wrappers for argument testing.  Like
+NODE\_NDEBUG, and (2) some API wrappers for argument testing.  Like
 `assert.string(myArg, 'myArg')`.  As a simple example, most of my code looks
 like this:
 
+```javascript
     var assert = require('assert-plus');
 
     function fooAccount(options, callback) {
-	    assert.object(options, 'options');
-		assert.number(options.id, 'options.id);
-		assert.bool(options.isManager, 'options.isManager');
-		assert.string(options.name, 'options.name');
-		assert.arrayOfString(options.email, 'options.email');
-		assert.func(callback, 'callback');
+        assert.object(options, 'options');
+        assert.number(options.id, 'options.id');
+        assert.bool(options.isManager, 'options.isManager');
+        assert.string(options.name, 'options.name');
+        assert.arrayOfString(options.email, 'options.email');
+        assert.func(callback, 'callback');
 
         // Do stuff
-		callback(null, {});
+        callback(null, {});
     }
+```
 
 # API
 
@@ -27,60 +29,94 @@ take an argument, and then a string 'name' that's not a message; `AssertionError
 will be thrown if the assertion fails with a message like:
 
     AssertionError: foo (string) is required
-	at test (/home/mark/work/foo/foo.js:3:9)
-	at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
-	at Module._compile (module.js:446:26)
-	at Object..js (module.js:464:10)
-	at Module.load (module.js:353:31)
-	at Function._load (module.js:311:12)
-	at Array.0 (module.js:484:10)
-	at EventEmitter._tickCallback (node.js:190:38)
+    at test (/home/mark/work/foo/foo.js:3:9)
+    at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
+    at Module._compile (module.js:446:26)
+    at Object..js (module.js:464:10)
+    at Module.load (module.js:353:31)
+    at Function._load (module.js:311:12)
+    at Array.0 (module.js:484:10)
+    at EventEmitter._tickCallback (node.js:190:38)
 
 from:
 
+```javascript
     function test(foo) {
-	    assert.string(foo, 'foo');
+        assert.string(foo, 'foo');
     }
+```
 
-There you go.  You can check that arrays are of a homogenous type with `Arrayof$Type`:
+There you go.  You can check that arrays are of a homogeneous type with `Arrayof$Type`:
 
+```javascript
     function test(foo) {
-	    assert.arrayOfString(foo, 'foo');
+        assert.arrayOfString(foo, 'foo');
     }
+```
 
 You can assert IFF an argument is not `undefined` (i.e., an optional arg):
 
+```javascript
     assert.optionalString(foo, 'foo');
+```
 
 Lastly, you can opt-out of assertion checking altogether by setting the
 environment variable `NODE_NDEBUG=1`.  This is pseudo-useful if you have
 lots of assertions, and don't want to pay `typeof ()` taxes to v8 in
-production.
+production.  Be advised:  The standard functions re-exported from `assert` are
+also disabled in assert-plus if NDEBUG is specified.  Using them directly from
+the `assert` module avoids this behavior.
 
 The complete list of APIs is:
 
+* assert.array
 * assert.bool
 * assert.buffer
 * assert.func
 * assert.number
+* assert.finite
 * assert.object
 * assert.string
+* assert.stream
+* assert.date
+* assert.regexp
+* assert.uuid
+* assert.arrayOfArray
 * assert.arrayOfBool
+* assert.arrayOfBuffer
 * assert.arrayOfFunc
 * assert.arrayOfNumber
+* assert.arrayOfFinite
 * assert.arrayOfObject
 * assert.arrayOfString
+* assert.arrayOfStream
+* assert.arrayOfDate
+* assert.arrayOfRegexp
+* assert.arrayOfUuid
+* assert.optionalArray
 * assert.optionalBool
 * assert.optionalBuffer
 * assert.optionalFunc
 * assert.optionalNumber
+* assert.optionalFinite
 * assert.optionalObject
 * assert.optionalString
+* assert.optionalStream
+* assert.optionalDate
+* assert.optionalRegexp
+* assert.optionalUuid
+* assert.optionalArrayOfArray
 * assert.optionalArrayOfBool
+* assert.optionalArrayOfBuffer
 * assert.optionalArrayOfFunc
 * assert.optionalArrayOfNumber
+* assert.optionalArrayOfFinite
 * assert.optionalArrayOfObject
 * assert.optionalArrayOfString
+* assert.optionalArrayOfStream
+* assert.optionalArrayOfDate
+* assert.optionalArrayOfRegexp
+* assert.optionalArrayOfUuid
 * assert.AssertionError
 * assert.fail
 * assert.ok
diff --git a/src/fw/node_modules/assert-plus/index.js b/src/fw/node_modules/assert-plus/index.js
index 70583f12..26f944ee 100644
--- a/src/fw/node_modules/assert-plus/index.js
+++ b/src/fw/node_modules/assert-plus/index.js
@@ -1,196 +1,211 @@
 // Copyright (c) 2012, Mark Cavage. All rights reserved.
+// Copyright 2015 Joyent, Inc.
 
 var assert = require('assert');
 var Stream = require('stream').Stream;
 var util = require('util');
 
 
-
 ///--- Globals
 
-var NDEBUG = process.env.NODE_NDEBUG || false;
-
-
-
-///--- Messages
-
-var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
-var TYPE_REQUIRED = '%s (%s) is required';
-
+/* JSSTYLED */
+var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
 
 
 ///--- Internal
 
-function capitalize(str) {
-        return (str.charAt(0).toUpperCase() + str.slice(1));
+function _capitalize(str) {
+    return (str.charAt(0).toUpperCase() + str.slice(1));
 }
 
-function uncapitalize(str) {
-        return (str.charAt(0).toLowerCase() + str.slice(1));
+function _toss(name, expected, oper, arg, actual) {
+    throw new assert.AssertionError({
+        message: util.format('%s (%s) is required', name, expected),
+        actual: (actual === undefined) ? typeof (arg) : actual(arg),
+        expected: expected,
+        operator: oper || '===',
+        stackStartFunction: _toss.caller
+    });
 }
 
-function _() {
-        return (util.format.apply(util, arguments));
+function _getClass(arg) {
+    return (Object.prototype.toString.call(arg).slice(8, -1));
 }
 
-
-function _assert(arg, type, name, stackFunc) {
-        if (!NDEBUG) {
-                name = name || type;
-                stackFunc = stackFunc || _assert.caller;
-                var t = typeof (arg);
-
-                if (t !== type) {
-                        throw new assert.AssertionError({
-                                message: _(TYPE_REQUIRED, name, type),
-                                actual: t,
-                                expected: type,
-                                operator: '===',
-                                stackStartFunction: stackFunc
-                        });
-                }
-        }
+function noop() {
+    // Why even bother with asserts?
 }
 
 
+///--- Exports
 
-///--- API
-
-function array(arr, type, name) {
-        if (!NDEBUG) {
-                name = name || type;
-
-                if (!Array.isArray(arr)) {
-                        throw new assert.AssertionError({
-                                message: _(ARRAY_TYPE_REQUIRED, name, type),
-                                actual: typeof (arr),
-                                expected: 'array',
-                                operator: 'Array.isArray',
-                                stackStartFunction: array.caller
-                        });
-                }
-
-                for (var i = 0; i < arr.length; i++) {
-                        _assert(arr[i], type, name, array);
-                }
+var types = {
+    bool: {
+        check: function (arg) { return typeof (arg) === 'boolean'; }
+    },
+    func: {
+        check: function (arg) { return typeof (arg) === 'function'; }
+    },
+    string: {
+        check: function (arg) { return typeof (arg) === 'string'; }
+    },
+    object: {
+        check: function (arg) {
+            return typeof (arg) === 'object' && arg !== null;
         }
-}
-
-
-function bool(arg, name) {
-        _assert(arg, 'boolean', name, bool);
-}
-
-
-function buffer(arg, name) {
-        if (!Buffer.isBuffer(arg)) {
-                throw new assert.AssertionError({
-                        message: _(TYPE_REQUIRED, name, type),
-                        actual: typeof (arg),
-                        expected: 'buffer',
-                        operator: 'Buffer.isBuffer',
-                        stackStartFunction: buffer
-                });
+    },
+    number: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg);
         }
-}
-
-
-function func(arg, name) {
-        _assert(arg, 'function', name);
-}
-
-
-function number(arg, name) {
-        _assert(arg, 'number', name);
-}
-
-
-function object(arg, name) {
-        _assert(arg, 'object', name);
-}
-
-
-function stream(arg, name) {
-        if (!(arg instanceof Stream)) {
-                throw new assert.AssertionError({
-                        message: _(TYPE_REQUIRED, name, type),
-                        actual: typeof (arg),
-                        expected: 'Stream',
-                        operator: 'instanceof',
-                        stackStartFunction: buffer
-                });
+    },
+    finite: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
         }
-}
-
-
-function string(arg, name) {
-        _assert(arg, 'string', name);
-}
-
-
-
-///--- Exports
-
-module.exports = {
-        bool: bool,
-        buffer: buffer,
-        func: func,
-        number: number,
-        object: object,
-        stream: stream,
-        string: string
+    },
+    buffer: {
+        check: function (arg) { return Buffer.isBuffer(arg); },
+        operator: 'Buffer.isBuffer'
+    },
+    array: {
+        check: function (arg) { return Array.isArray(arg); },
+        operator: 'Array.isArray'
+    },
+    stream: {
+        check: function (arg) { return arg instanceof Stream; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    date: {
+        check: function (arg) { return arg instanceof Date; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    regexp: {
+        check: function (arg) { return arg instanceof RegExp; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    uuid: {
+        check: function (arg) {
+            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
+        },
+        operator: 'isUUID'
+    }
 };
 
+function _setExports(ndebug) {
+    var keys = Object.keys(types);
+    var out;
+
+    /* re-export standard assert */
+    if (process.env.NODE_NDEBUG) {
+        out = noop;
+    } else {
+        out = function (arg, msg) {
+            if (!arg) {
+                _toss(msg, 'true', arg);
+            }
+        };
+    }
 
-Object.keys(module.exports).forEach(function (k) {
-        if (k === 'buffer')
+    /* standard checks */
+    keys.forEach(function (k) {
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        var type = types[k];
+        out[k] = function (arg, msg) {
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* optional checks */
+    keys.forEach(function (k) {
+        var name = 'optional' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
                 return;
-
-        var name = 'arrayOf' + capitalize(k);
-
-        if (k === 'bool')
-                k = 'boolean';
-        if (k === 'func')
-                k = 'function';
-        module.exports[name] = function (arg, name) {
-                array(arg, k, name);
+            }
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
         };
-});
-
-Object.keys(module.exports).forEach(function (k) {
-        var _name = 'optional' + capitalize(k);
-        var s = uncapitalize(k.replace('arrayOf', ''));
-        if (s === 'bool')
-                s = 'boolean';
-        if (s === 'func')
-                s = 'function';
-
-        if (k.indexOf('arrayOf') !== -1) {
-          module.exports[_name] = function (arg, name) {
-                  if (!NDEBUG && arg !== undefined) {
-                          array(arg, s, name);
-                  }
-          };
-        } else {
-          module.exports[_name] = function (arg, name) {
-                  if (!NDEBUG && arg !== undefined) {
-                          _assert(arg, s, name);
-                  }
-          };
+    });
+
+    /* arrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'arrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
         }
-});
-
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* optionalArrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'optionalArrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
 
-// Reexport built-in assertions
-Object.keys(assert).forEach(function (k) {
+    /* re-export built-in assertions */
+    Object.keys(assert).forEach(function (k) {
         if (k === 'AssertionError') {
-                module.exports[k] = assert[k];
-                return;
+            out[k] = assert[k];
+            return;
+        }
+        if (ndebug) {
+            out[k] = noop;
+            return;
         }
+        out[k] = assert[k];
+    });
 
-        module.exports[k] = function () {
-                if (!NDEBUG) {
-                        assert[k].apply(assert[k], arguments);
-                }
-        };
-});
+    /* export ourselves (for unit tests _only_) */
+    out._setExports = _setExports;
+
+    return out;
+}
+
+module.exports = _setExports(process.env.NODE_NDEBUG);
diff --git a/src/fw/node_modules/cmdln/index.js b/src/fw/node_modules/cmdln/index.js
index 5a6e281a..95b99b6e 100644
--- a/src/fw/node_modules/cmdln/index.js
+++ b/src/fw/node_modules/cmdln/index.js
@@ -1,6 +1,5 @@
 /*
- * Copyright (c) 2013, Trent Mick. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016 Trent Mick
  */
 
 var DEBUG = false;
@@ -26,6 +25,7 @@ var dashdash = require('dashdash');
 var sprintf = require('extsprintf').sprintf;
 
 
+
 // ---- globals
 
 var DEFAULT_OPTIONS = [
@@ -36,10 +36,22 @@ var DEFAULT_OPTIONS = [
     }
 ];
 
+var DEFAULT_SYNOPSES = [
+    '{{name}} [OPTIONS] COMMAND [ARGS...]',
+    '{{name}} help COMMAND'
+];
 
 
 // ---- internal support stuff
 
+function indent(s, indentation) {
+    if (!indentation) {
+        indentation = '    ';
+    }
+    var lines = s.split(/\r?\n/g);
+    return indentation + lines.join('\n' + indentation);
+}
+
 function space(n) {
     var s = '';
     for (var i = 0; i < n; i++) {
@@ -48,12 +60,41 @@ function space(n) {
     return s;
 }
 
-function objCopy(obj) {
-    var copy = {};
+function objCopy(obj, target) {
+    if (!target) {
+        target = {};
+    }
     Object.keys(obj).forEach(function (k) {
-        copy[k] = obj[k];
+        target[k] = obj[k];
+    });
+    return target;
+}
+
+/**
+ * Return a new object that is a shallow merge of all the given objects.
+ * Last one wins. Example:
+ *
+ *  > objMerge({"a":1,"b":2}, {"b":3,"c":4});
+ *  { a: 1, b: 3, c: 4 }
+ */
+function objMerge(/* ... */) {
+    var merged = {};
+    for (var i = 0; i < arguments.length; i++) {
+        var obj = arguments[i];
+        var keys = Object.keys(obj);
+        for (var k = 0; k < keys.length; k++) {
+            merged[keys[k]] = obj[keys[k]];
+        }
+    }
+    return merged;
+}
+
+
+// Replace {{variable}} in `s` with the template data in `d`.
+function renderTemplate(s, d) {
+    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {
+        return d.hasOwnProperty(key) ? d[key] : match;
     });
-    return copy;
 }
 
 
@@ -87,26 +128,130 @@ function CmdlnError(options) {
     });
 }
 util.inherits(CmdlnError, WError);
+CmdlnError.prototype.name = 'CmdlnError';
+
 
-function OptionError(cause, subcmd) {
+/*
+ * An error returned when there is an error parsing a command or subcmd's
+ * options.
+ */
+function OptionError(cause) {
     assert.object(cause, 'cause');
-    assert.optionalString(subcmd, 'subcmd');
     CmdlnError.call(this, {
         cause: cause,
         message: cause.message,
         code: 'Option',
-        exitStatus: 1,
-        subcmd: subcmd
+        exitStatus: 1
     });
 }
+
 util.inherits(OptionError, CmdlnError);
+OptionError.prototype.name = 'OptionError';
+
+/**
+ * Attempt to give an appropriate 'usage: ...' errHelp that shows all
+ * the options. E.g.:
+ *
+ *     $ triton inst tag set -123
+ *     triton instance tag set: error (Option): unknown option: "-1" in "-1...
+ *     usage: triton instance tag set [-h | --help] [-f FILE | --file=FILE]
+ *         [-w | --wait] [--wait-timeout=INT] [-j | --json] [-q | --quiet] ...
+ *
+ * Notes:
+ * - This does NOT use `synopses` because, at least in my current typical
+ *   usage, the synopses just show `[OPTIONS]` instead of expliclity listing
+ *   all the options.
+ * - The above indentation is intentional (as opposed to `git --help`s) in
+ *   case the command name is long.
+ */
+OptionError.prototype.cmdlnErrHelpFromErr = function optionErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    var errHelp = '';
+
+    var options = (err._cmdlnHandler || err._cmdlnInst).options;
+    if (options) {
+        var lines = [];
+        var line = 'usage: ' + nameFromErr(err);
+        for (var i = 0; i < options.length; i++) {
+            var synopsis = dashdash.synopsisFromOpt(options[i]);
+            if (!synopsis) {
+                continue;
+            } else if (line.length === 0) {
+                line += '    ' + synopsis;
+            } else if (line.length + synopsis.length + 1 > 80) {
+                lines.push(line);
+                line = '    ' + synopsis;
+            } else {
+                line += ' ' + synopsis;
+            }
+        }
+        lines.push(line + ' ...');  // The "..." for the args.
+        errHelp = lines.join('\n');
+    }
+
+
+    return errHelp;
+};
+
+
+/*
+ * An error returned when there is a subcmd usage error (wrong args).
+ *
+ *      new UsageError(<message>);
+ *      new UsageError(<cause>, <message>);
+ */
+function UsageError(cause, message) {
+    if (message === undefined) {
+        message = cause;
+        cause = undefined;
+    }
+    assert.optionalObject(cause, 'cause');
+    assert.string(message, 'message');
+    CmdlnError.call(this, {
+        cause: cause,
+        message: message,
+        code: 'Usage',
+        exitStatus: 1
+    });
+}
+
+util.inherits(UsageError, CmdlnError);
+UsageError.prototype.name = 'UsageError';
+
+/**
+ * Show a 'usage: ...' errHelp using the command's `synopses`. E.g.:
+ *
+ *     $ triton inst list foo
+ *     triton instance list: error (Usage): invalid filter: "foo" ...
+ *     usage: triton instance list [OPTIONS] [FILTERS...]
+ */
+UsageError.prototype.cmdlnErrHelpFromErr = function usageErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    var errHelp = '';
+    var synopses = err._cmdlnInst.synopsesFromSubcmd(
+        err._cmdlnSubcmd || err._cmdlnInst);
+    if (synopses.length === 1) {
+        errHelp = 'usage: ' + synopses[0];
+    } else if (synopses.length > 1) {
+        errHelp = 'usage:\n    ' + synopses.join('\n    ');
+    }
+    return errHelp;
+};
+
 
 function UnknownCommandError(cause, command) {
     if (command === undefined) {
         command = cause;
         cause = undefined;
     }
-    assert.string(command);
+    assert.string(command, 'command');
+    this.command = command;
     CmdlnError.call(this, {
         cause: cause,
         message: sprintf('unknown command: "%s"', command),
@@ -114,8 +259,145 @@ function UnknownCommandError(cause, command) {
         exitStatus: 1
     });
 }
+
 util.inherits(UnknownCommandError, CmdlnError);
+UnknownCommandError.prototype.name = 'UnknownCommandError';
 
+/**
+ * Show an errHelp for possible intended commands, assuming a typo. E.g.:
+ *
+ *     $ triton ins
+ *     triton: error (UnknownCommand): unknown command: "ins"
+ *     Did you mean this?
+ *         inst
+ *         instance
+ */
+UnknownCommandError.prototype.cmdlnErrHelpFromErr =
+        function ucErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    try {
+        var FuzzySet = require('fuzzyset.js');
+    } catch (requireErr) {
+        return '';
+    }
+
+    var errHelp = '';
+    var aliases = FuzzySet(Object.keys(err._cmdlnInst._nameFromAlias));
+    var candidates = aliases.get(this.command); // array of [score, alias];
+    var ge50 = [];
+    candidates && candidates.forEach(function (candidate) {
+        if (candidate[0] >= 0.3) {
+            ge50.push(candidate[1]);
+        }
+    });
+    if (ge50.length > 0) {
+        errHelp = 'Did you mean this?\n    ' + ge50.join('\n    ');
+    }
+
+    return errHelp;
+};
+
+
+function NoCommandError() {
+    CmdlnError.call(this, {
+        message: 'no command given',
+        code: 'NoCommand',
+        exitStatus: 1
+    });
+}
+util.inherits(NoCommandError, CmdlnError);
+NoCommandError.prototype.name = 'NoCommandError';
+
+
+/**
+ * # errHelp
+ *
+ * Sometimes, for some CLI errors, it is nice to print brief help info after
+ * the error message. E.g.:
+ *
+ *      $ ls -D
+ *      ls: illegal option -- D
+ *  >   usage: ls [-ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1] [file ...]
+ *
+ *      $ git foo
+ *      git: 'foo' is not a git command. See 'git --help'.
+ *
+ *  >   Did you mean this?
+ *  >          fo
+ *
+ * This module calls that `errHelp`. This function will attempt to determine
+ * reasonable errHelp from an `err` returned by `<cmdln>.main()`. By default
+ * errHelp is implemented for some of this module's error classes:
+ *
+ * - OptionError: Show a synopsis of the command's options.
+ * - UsageError: Show the command's synopses, if available.
+ * - UnknownCommandError: List possible fuzzy matches.
+ *
+ *
+ * # usage
+ *
+ * 1. Optionally set `synopses` on your `do_SUBCMD` handlers. E.g.:
+ *
+ *      do_list.synopses = ['{{name}} list [OPTIONS] [FILTERS...]'];
+ *
+ *    Note that `{{usage}}` in your command help output will expand to these
+ *    synopses.
+ *
+ * 2. Use `cmdln.errHelpFromErr()` in your mainline something like this:
+ *
+ *      var cmdln = require('cmdln');
+ *      var cli = new MyCmdlnSubclass();
+ *      cli.main(argv, function (err) {
+ *          if (err) {
+ *              console.error('%s: error: %s', cli.name, err.message);
+ *              var errHelp = cmdln.errHelpFromErr(err);
+ *              if (errHelp) {
+ *                  console.error(errHelp);
+ *              }
+ *          }
+ *      });
+ *
+ *    Or use the convenience top-level `cmdln.main()` function, which does
+ *    similar.
+ *
+ *
+ * @param {Object} err: Error returned from `<cmdln>.main()`. The main
+ *      function adds some cmdln-specific context properties to the returned
+ *      err object. This function uses those properties.
+ * @returns {String} Error help string, if any, else the empty string.
+ */
+function errHelpFromErr(err) {
+    assert.object(err, 'err');
+    var errHelp;
+
+    if (err && typeof (err.cmdlnErrHelpFromErr) === 'function') {
+        errHelp = err.cmdlnErrHelpFromErr(err);
+    }
+
+    return (errHelp || '');
+};
+
+
+/**
+ * Return the full command name (e.g. 'triton instance list') at which the
+ * error occurred, from an `err` instance returned by `<cmdln>.main()`.
+ */
+function nameFromErr(err) {
+    assert.object(err, 'err');
+    assert.object(err._cmdlnInst, 'err._cmdlnInst');
+    var name = err._cmdlnInst.name;
+    if (err._cmdlnHandler) {
+        if (typeof (err._cmdlnHandler) === 'object') {
+            name = err._cmdlnHandler.name;
+        } else if (err._cmdlnSubcmd) {
+            name += ' ' + err._cmdlnSubcmd;
+        }
+    }
+    return name;
+}
 
 
 // ---- Cmdln object
@@ -128,9 +410,29 @@ util.inherits(UnknownCommandError, CmdlnError);
  *        name.
  *      - @param desc {String} Description string to include at the top of
  *        usage information.
+ *      - @param synopses {Array} Optional array of synopses for the command.
+ *        Synopses are used for the `{{usage}}` template var in help output
+ *        and for `errHelp` for `UsageError`s. If not given the default will be:
+ *          `['{{name}} [OPTIONS] COMMAND [ARGS...]', '{{name}} help COMMAND']`
  *      - @param helpOpts {Object} Help output formatting options. These
  *        are the same formatting options as for `dashdash.Parser.help`:
  *        indent, maxCol, helpCol, minHelpCol, maxHelpCol (TODO:doc).
+ *      - @param helpBody {String} Extra string content to put at the end of
+ *        help output.
+ *      - @param helpSubcmds {Array} Control the output of the "Commands:"
+ *        section of top-level help output. By default all commands are
+ *        listed in the order defined in code. `helpSubcmds` allows one to
+ *        specify the order and, optionally, groupings with group headers. E.g.:
+ *              helpSubcmds: [
+ *                  'help',
+ *                  { group: '' },   // an empty group, results in a blank line
+ *                  'foo',
+ *                  'bar',
+ *                  { group: 'Bling' }, // a group header
+ *                  'bloom',
+ *                  // Use `unmatched: true` to include remaining subcmds.
+ *                  { group: 'Other Commands', unmatched: true }
+ *              ]
  *      - @param options {Array} Custom options (in the format used by
  *        [dashdash](https://github.com/trentm/node-dashdash)). If not
  *        specified, then it defaults to a single -h/--help option.
@@ -138,10 +440,10 @@ util.inherits(UnknownCommandError, CmdlnError);
  *        override the base `init(opts, args, callback)` to act on those
  *        options after being parsed.
  *
- * XXX hooks for adding help ? instead of automatic?
+ * TODO: hooks for adding help ? instead of automatic?
  *      - @param helpCmd {Boolean} Whether to include the `help` subcommand.
  *        Default true.
- *      - XXX take optional bunyan logger
+ * TODO: take optional bunyan logger for trace logging
  */
 function Cmdln(config) {
     var self = this;
@@ -150,20 +452,35 @@ function Cmdln(config) {
     assert.optionalString(config.name, 'config.name')
     assert.optionalString(config.desc, 'config.desc')
     assert.optionalArrayOfObject(config.options, 'config.options');
+    assert.optionalArrayOfString(config.synopses, 'config.synopses');
     assert.optionalObject(config.helpOpts, 'config.helpOpts')
+    assert.optionalString(config.helpBody, 'config.helpBody')
+    assert.optionalObject(config.helpSubcmds, 'config.helpSubcmds');
 
     this.name = config.name || this.constructor.name.toLowerCase();
     this.desc = config.desc;
+    this.synopses = config.synopses || DEFAULT_SYNOPSES;
     this.options = config.options || DEFAULT_OPTIONS;
     this.helpOpts = config.helpOpts || {};
+    this.helpBody = config.helpBody;
+    this.helpSubcmds = config.helpSubcmds || null;
     if (!this.helpOpts.indent)
         this.helpOpts.indent = space(4);
     else if (typeof (this.helpOpts.indent) === 'number')
         this.helpOpts.indent = space(this.helpOpts.indent);
+    if (!this.helpOpts.groupIndent) {
+        var gilen = Math.round(this.helpOpts.indent.length / 2);
+        this.helpOpts.groupIndent = space(gilen);
+    } else if (typeof (this.helpOpts.groupIndent) === 'number') {
+        this.helpOpts.groupIndent = space(this.helpOpts.groupIndent);
+    }
     if (!this.helpOpts.maxCol) this.helpOpts.maxCol = 80;
     if (!this.helpOpts.minHelpCol) this.helpOpts.minHelpCol = 20;
     if (!this.helpOpts.maxHelpCol) this.helpOpts.maxHelpCol = 40;
 
+    this.optParser = new dashdash.Parser(
+        {options: this.options, interspersed: false});
+
     // Find the tree of constructors (typically just this and the Cmdln
     // super class) on who's prototype to look for "do_*" and "help_*"
     // methods.
@@ -176,26 +493,134 @@ function Cmdln(config) {
     prototypes.reverse();
 
     // Load subcmds (do_* methods) and aliases (`do_*.aliases`).
-    this.subcmdOrder = [];
-    this.subcmds = {};
-    this.aliases = {};
+    var enumOrder = [];
+    this._handlerFromName = {};
+    this._nameFromAlias = {};
     prototypes.forEach(function (proto) {
         Object.keys(proto)
             .filter(function (funcname) { return /^do_/.test(funcname); })
             .forEach(function (funcname) {
-                var name = funcname.slice(3);
+                var name = self.subcmdFromFuncname(funcname);
                 var func = proto[funcname];
-                self.subcmds[name] = func;
-                self.subcmdOrder.push(name);
-                self.aliases[name] = name;
-                (func.aliases || []).forEach(function (alias) {
-                    self.aliases[alias] = name;
+                var allAliases;
+                if (func.prototype.__proto__ === Cmdln.prototype) {
+                    /**
+                     * This is a `Cmdln` sub-class. Create the sub-Cmdln
+                     * instance and use that as the handler.
+                     *
+                     * Limitation: This doesn't catch multi-level inheritance
+                     * from `Cmdln`.
+                     *
+                     * Also validate which properties are allowed to be
+                     * set on the *constructor*, e.g.:
+                     *      Top.prototype.do_sub = Sub
+                     *      Top.prototype.do_sub.<property> = ...
+                     * vs. not allowed, because they must be set on the `Sub`
+                     * itself:
+                     *      function Sub(top) {
+                     *          Cmdln.call(this, {name: ..., options: ...})
+                     *      }
+                     */
+                    ['options', 'help'].forEach(function (prop) {
+                        if (func.hasOwnProperty(prop)) {
+                            throw new Error(format(
+                                'cannot set "%s.prototype.do_%s.%s" property '
+                                + 'because "do_%s" is a sub-Cmdln handler',
+                                self.constructor.name, name, prop, name));
+                        }
+                    });
+                    var handler = new func(self);
+                    // Copy class properies like 'alias', 'hidden', etc.
+                    for (prop in func) {
+                        if (prop === 'super_')
+                            continue;
+                        handler[prop] = func[prop];
+                    }
+                    self._handlerFromName[name] = handler;
+                } else {
+                    self._handlerFromName[name] = func;
+                }
+                if (!self._handlerFromName[name].hidden) {
+                    enumOrder.push(name);
+                }
+                self._nameFromAlias[name] = name;
+                allAliases = func.aliases || [];
+                if (func.hiddenAliases)
+                    allAliases = allAliases.concat(func.hiddenAliases);
+                allAliases.forEach(function (alias) {
+                    if (self._nameFromAlias[alias]) {
+                        throw new Error(format('ambiguous alias "%s": ' +
+                            'refers to commands "%s" and "%s"', alias,
+                            name, self._nameFromAlias[alias]));
+                    }
+                    self._nameFromAlias[alias] = name;
                 });
             });
     });
-    // p('subcmdOrder:', this.subcmdOrder);
-    // p('subcmds: ', this.subcmds);
-    // p('aliases: ', this.aliases);
+
+    if (self.helpSubcmds !== null) {
+        /*
+         * Reconcile the provided subcommand order (and group headings) with
+         * the discovered options.
+         */
+        var unmatchedNames = [];
+        var matchedNames = [];
+        enumOrder.forEach(function (enumName) {
+            if (self.helpSubcmds.indexOf(enumName) === -1) {
+                unmatchedNames.push(enumName);
+            } else {
+                matchedNames.push(enumName);
+            }
+        });
+
+        var unmatchCount = 0;
+        self._subcmdOrder = [];
+        self.helpSubcmds.forEach(function (sc) {
+            if (typeof (sc) === 'object') {
+                assert.string(sc.group, 'helpSubcmds.*.group');
+                assert.optionalBool(sc.unmatched, 'helpSubcmds.*.unmatched');
+
+                self._subcmdOrder.push(sc);
+
+                if (sc.unmatched) {
+                    if (++unmatchCount > 1) {
+                        throw (new Error(format('"unmatched" directive used ' +
+                            'more than once in "helpSubcmds" option: %j', sc)));
+                    }
+
+                    /*
+                     * Include all of the unmatched names here:
+                     */
+                    while (unmatchedNames.length > 0) {
+                        self._subcmdOrder.push(unmatchedNames.shift());
+                    }
+                }
+                return;
+            }
+
+            /*
+             * If this is not a group heading object, it must be the name
+             * of a handler to include in the output:
+             */
+            assert.string(sc);
+            if (matchedNames.indexOf(sc) === -1) {
+                throw (new Error('command handler included in help order ' +
+                    'but not found: ' + sc));
+            }
+            self._subcmdOrder.push(sc);
+        });
+
+        if (unmatchedNames.length > 0) {
+            throw (new Error('"helpSubcmds" error: unmatched command ' +
+                'handlers found: ' + unmatchedNames.join(', ') + '.'));
+        }
+    } else {
+        self._subcmdOrder = enumOrder;
+    }
+
+    // p('_subcmdOrder:', this._subcmdOrder);
+    // p('_handlerFromName: ', this._handlerFromName);
+    // p('_nameFromAlias: ', this._nameFromAlias);
 }
 
 
@@ -203,47 +628,269 @@ function Cmdln(config) {
  * Cmdln mainline.
  *
  * @param argv {Array}
- * @param callback {Function} `function (err)`
+ * @param cb {Function} `function (err)` where err is an error object if
+ *      there was a problem. The following properties are added to a
+ *      returned `err`. These add context used by `errHelpFromErr`
+ *      and `nameFromErr`.
+ *
+ * Dev Notes: The relevant *private* members added for this context are:
+ * - `err._cmdlnInst`: The Cmdln instance on which the error occurred.
+ *   For single-level subcommands, this will always be the top Cmdln
+ *   instance on which `main` was called. However for tools with
+ *   nested Cmdln's (e.g. `mytool some-subcmd some-subsubcmd`) it
+ *   might be that nested Cmdln.
+ * - `err._cmdlnSubcmd` and `err._cmdlnHandler`: If appropriate, this is
+ *   the subcmd handler on which the error occurred. This might be a
+ *   `do_SUBCMD` handler *function* or a Cmdln subcmd handler *object*.
+ *   If the error happened before a subcmd handler was selected, then
+ *   this isn't set.
  */
-Cmdln.prototype.main = function main(argv, callback) {
+Cmdln.prototype.main = function cmdlnMain(argv, cb) {
     var self = this;
+    assert.arrayOfString(argv, 'argv');
+    assert.func(cb, 'cb');
+
+    var decoErrAndCb = function (err) {
+        if (err && !err._cmdlnInst) {
+            err._cmdlnInst = self;
+        }
+        cb(err);
+    };
+
+    var finiAndCb = function (err, subcmd) {
+        debug('-> <%s>.fini(%j, err=%s)', self.name, subcmd, err);
+        self.fini(subcmd, err, function (finiErr) {
+            debug('<- <%s>.fini: finiErr=%s', self.name, finiErr);
+            decoErrAndCb(finiErr || err);
+        });
+    }
+
     try {
-        this.optParser = new dashdash.Parser(
-            {options: this.options, interspersed: false});
         this.opts = this.optParser.parse(argv);
     } catch (e) {
-        callback(new OptionError(e));
+        decoErrAndCb(new OptionError(e));
+        return;
     }
     var args = this.opts._args;
 
-    debug('-> init(%j, %j)', this.opts, args);
+    debug('-> <%s>.init(%j, %j)', self.name, this.opts, args);
     self.init(this.opts, args, function (initErr) {
-        debug('<- init(%s)', initErr)
+        debug('<- <%s>.init: initErr=%s', self.name, initErr)
         if (initErr) {
-            callback(initErr);
+            finiAndCb(initErr);
             return;
         } else if (initErr === false) {
-            //XXX How to handle non-zero exit here? Special error?
-            //    StopProcessingError?
-            callback();
+            // TODO: How to handle non-zero exit here? Special error?
+            // StopProcessingError?
+            finiAndCb();
             return
         }
 
         if (args.length === 0) {
-            self.printHelp(function (helpErr) { callback(helpErr); });
+            self.emptyLine(finiAndCb);
             return;
         }
 
         var subcmdArgv = argv.slice(0, 2).concat(args);
         var subcmd = args.shift();
         try {
-            debug('-> dispatch(%j, %j)', subcmd, subcmdArgv);
-            self.dispatch(subcmd, subcmdArgv,
-                function (dispErr) { callback(dispErr); });
+            debug('-> <%s>.dispatch({subcmd: %j, argv: %j})',
+                self.name, subcmd, subcmdArgv);
+            self.dispatch({subcmd: subcmd, argv: subcmdArgv},
+                function (dispErr) {
+                    debug('<- <%s>.dispatch: dispErr=%s',
+                        self.name, dispErr);
+                    /*
+                     * Do in nextTick to assure that we do not callback twice
+                     * if (a) dispatch returns synchronously and (b) there is
+                     * an exception raised during `finiAndCb`.
+                     */
+                    process.nextTick(function () {
+                        finiAndCb(dispErr, subcmd);
+                    });
+                });
         } catch (ex) {
-            callback(ex);
+            debug('<- <%s>.dispatch crash: ex=%s', self.name, ex);
+            finiAndCb(ex, subcmd);
+        }
+    });
+
+};
+
+
+/* BEGIN JSSTYLED */
+/**
+ * Return a Bash completion "spec" for this CLI.
+ *
+ * The Bash completion "spec" is the var that gets interpolated into the
+ * "dashdash.bash_completion.in" template. It is Bash code that defines the
+ * CLI options and subcmds for the template's completion code. It looks
+ * something like this:
+ *
+ *      # Top-level.
+ *      local cmd_shortopts="-J ..."
+ *      local cmd_longopts="--help ..."
+ *      local cmd_optargs="-p=tritonprofile ..."
+ *      local cmd_subcmds="account create list ..."
+ *      local cmd_allsubcmds="account hiddensub create list ..."
+ *
+ *      # The "TOOL instance ..." subcommand.
+ *      local cmd__instance_shortopts="-h"
+ *      local cmd__instance_longopts="--help"
+ *      local cmd__instance_optargs=""
+ *      local cmd__instance_subcmds="help list ls get ..."
+ *      local cmd__instance_allsubcmds="help list ls get ..."
+ *
+ *      # The "TOOL instance list" sub-subcommand.
+ *      local cmd__instance__list_shortopts="-h -H -o -l -s -j"
+ *      local cmd__instance__list_longopts="--help --long --json"
+ *      local cmd__instance__list_optargs="-o= -s="
+ *
+ *      # ...
+ *
+ *      # Optional completion functions for types referenced in "optargs" vars.
+ *      # There is no requirement to have a completion function for every
+ *      # type.
+ *      function complete_tritonprofile {
+ *          local word="$1"
+ *          local candidates
+ *          candidates=$(ls -1 ~/.triton/profiles.d/*.json 2>/dev/null \
+ *              | sed -E 's/^.*\/([ \/]+)\.json$/\1/')
+ *          compgen $compgen_opts -W "$candidates" -- "$word"
+ *      }
+ *
+ * @param opts.context {String} Optional context string for the "local cmd*"
+ *      vars. For example, for the "instance" subcommand above,
+ *      `context="__instance"`.
+ * @param opts.includeHidden {Boolean} Optional. Default false. By default
+ *      hidden options and subcmds are "excluded". Here excluded means they
+ *      won't be offered as a completion, but if used, their argument type
+ *      will be completed. "Hidden" options and subcmds are ones with the
+ *      `hidden: true` attribute to exclude them from default help output.
+ */
+/* END JSSTYLED */
+Cmdln.prototype.bashCompletionSpec = function bashCompletionSpec(opts) {
+    var self = this;
+    if (!opts) {
+        opts = {};
+    }
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.context, 'opts.context');
+    assert.optionalBool(opts.includeHidden, 'opts.includeHidden');
+
+    var spec = [];
+    var context = opts.context || '';
+    var includeHidden = (opts.includeHidden === undefined
+        ? false : opts.includeHidden);
+
+    // Top-level.
+    spec.push(dashdash.bashCompletionSpecFromOptions({
+        options: self.options,
+        context: context,
+        includeHidden: includeHidden
+    }));
+
+    var aliases = [];
+    var allAliases = [];
+    Object.keys(this._nameFromAlias).sort().forEach(function (alias) {
+        if (alias === '?') {
+            // '?' as a Bash completion is painful. Also, '?' as a default
+            // alias for 'help' should die.
+            return;
+        }
+
+        var name = self._nameFromAlias[alias];
+        var handler = self._handlerFromName[name];
+
+        if (includeHidden || !handler.hidden) {
+            aliases.push(alias);
+        }
+        allAliases.push(alias);
+    });
+    spec.push(format('local cmd%s_subcmds="%s"', context, aliases.join(' ')));
+    spec.push(format('local cmd%s_allsubcmds="%s"', context,
+        allAliases.join(' ')));
+
+    // Subcmds.
+    // We include completion info even for "hidden" subcmds, so that once
+    // one has specified a hidden subcmd you get full completion under it.
+    Object.keys(this._nameFromAlias).sort().forEach(function (alias) {
+        if (alias === '?') {
+            return;
+        }
+        spec.push('');
+        var context_ = context + '__' + alias.replace(/-/g, '_');
+        var name = self._nameFromAlias[alias];
+        var handler = self._handlerFromName[name];
+
+        if (typeof (handler.bashCompletionSpec) === 'function') {
+            // This is a `Cmdln` subclass, i.e. a sub-CLI.
+            var subspec = handler.bashCompletionSpec({context: context_});
+            if (subspec) {
+                spec.push(subspec);
+            }
+        } else {
+            if (handler.completionArgtypes) {
+                assert.arrayOfString(handler.completionArgtypes,
+                    'do_' + name + '.completionArgtypes');
+                spec.push(format('local cmd%s_argtypes="%s"',
+                    context_, handler.completionArgtypes.join(' ')));
+            }
+            spec.push(dashdash.bashCompletionSpecFromOptions({
+                options: handler.options || [],
+                context: context_,
+                includeHidden: includeHidden
+            }));
         }
     });
+
+    return spec.join('\n');
+}
+
+/**
+ * Generate and return Bash completion for this Cmdln subclass instance.
+ *
+ * @param opts.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "node-dashdash/examples/ddcompletion.js" for an example.
+ */
+Cmdln.prototype.bashCompletion = function bashCompletion(opts) {
+    if (!opts) {
+        opts = {};
+    }
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.specExtra, 'opts.specExtra');
+
+    // Gather template data.
+    var data = {
+        name: this.name,
+        date: new Date(),
+        spec: this.bashCompletionSpec()
+    };
+    if (opts.specExtra) {
+        data.spec += '\n\n' + opts.specExtra;
+    }
+
+    // Render template.
+    var template = fs.readFileSync(
+        dashdash.BASH_COMPLETION_TEMPLATE_PATH, 'utf8');
+    return renderTemplate(template, data);
+};
+
+
+/**
+ * Handler called for an empty line of input. By default this prints help
+ * output and returns a `NoCommandError` (exitStatus == 1).
+ *
+ * Dev Note: Equiv to python-cmdln's Cmdln.emptyline.
+ *
+ * @param callback {Function} `function (err)`
+ */
+Cmdln.prototype.emptyLine = function emptyLine(callback) {
+    this.printHelp(function (helpErr) {
+        callback(helpErr || new NoCommandError());
+    });
 };
 
 
@@ -256,10 +903,9 @@ Cmdln.prototype.main = function main(argv, callback) {
  * @param opts {Object} The parsed options.
  * @param args {Array} The left-over CLI arguments after options have been
  *      parsed out.
- *
- * @param callback {Function} `function (err)` where `err==false` means stop
- *      processing, `err==<error instance>` passes that error back up
- *      `!err` means continue.
+ * @param callback {Function} `function (err)` where `err===false` means stop
+ *      processing, `err==<error instance>` passes that error back up, and
+ *      no `err` means continue.
  */
 Cmdln.prototype.init = function init(opts, args, callback) {
     if (opts.help) {
@@ -272,6 +918,19 @@ Cmdln.prototype.init = function init(opts, args, callback) {
 };
 
 
+/**
+ * Hook run after the subcommand handler is run.
+ *
+ * @param subcmd {String} The name of the subcommand run.
+ * @param err {Error} The error being returned to the `main` caller, if any.
+ * @param callback {Function} `function (finiErr)` where `finiErr` is an
+ *      error from finalization handling. Note that this `fini()` method
+ *      cannot abort `err`.
+ */
+Cmdln.prototype.fini = function fini(subcmd, err, callback) {
+    callback();
+};
+
 
 /**
  * Print top-level tool help.
@@ -283,6 +942,7 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     var self = this;
     var helpOpts = this.helpOpts;
     var indent = helpOpts.indent;
+    var gindent = helpOpts.groupIndent;
 
     var lines = [];
     if (this.desc) {
@@ -293,9 +953,7 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     }
 
     lines = lines.concat([
-        'Usage:',
-        format('%s%s [OPTIONS] COMMAND [ARGS...]', indent, self.name),
-        format('%s%s help COMMAND', indent, self.name),
+        this._renderHelp('{{usage}}', this),
         ''
     ]);
     if (this.optParser.help) {
@@ -306,137 +964,545 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     lines = lines.concat([
         'Commands:'
     ]);
-    // Automatic command line from `this.subcmds`.
+    // Automatic command line from `this._handlerFromName`.
     // TODO: same helpCol as for the opts above, textwrap, etc.
     var cmdTemplate = format('%s%%-%ds  %s',
         indent, helpOpts.minHelpCol - indent.length - 2);
-    this.subcmdOrder.forEach(function (name) {
-        var func = self.subcmds[name];
-        if (func.hidden) {
+    this._subcmdOrder.forEach(function (name, idx) {
+        if (typeof (name) === 'object') {
+            if (idx > 0) {
+                /*
+                 * If this is not the first line, print a blank line to
+                 * visually separate this group from previous lines.
+                 */
+                lines.push('');
+            }
+
+            /*
+             * If the group name is not blank, print the group heading.
+             * If it is blank, the caller only wants the separator line
+             * printed above.
+             */
+            assert.string(name.group, 'name.group');
+            if (name.group) {
+                lines.push(format('%s%s:', gindent, name.group));
+            }
+            return;
+        }
+
+        assert.string(name, 'name');
+        var handler = self._handlerFromName[name];
+        if (handler.hidden) {
             return;
         }
         var names = name;
-        if (func.aliases) {
-            names += sprintf(' (%s)', func.aliases.join(', '));
+        if (handler.aliases) {
+            names += sprintf(' (%s)', handler.aliases.join(', '));
         }
-        var desc = (func.help || '').split('\n', 1)[0];
-        desc = desc.replace(/{{name}}/g, self.name);
-        var line = sprintf(cmdTemplate, names, desc);
+        var summary = handler.desc ||
+            (typeof (handler.help) === 'string' && handler.help) ||
+            '';
+        summary = summary.split('\n', 1)[0]; // just leading line
+        summary = self._renderTemplate(summary, name);
+        var line = sprintf(cmdTemplate, names, summary);
         lines.push(line);
     });
 
+    if (this.helpBody) {
+        if (lines.slice(-1) !== '\n') {
+            lines.push('');
+        }
+        lines.push(this.helpBody);
+    }
+
     console.log(lines.join('\n'));
     callback();
 };
 
+
+Cmdln.prototype.subcmdFromFuncname = function subcmdFromFuncname(funcname) {
+    return funcname.slice(3).replace(/_/g, '-');
+};
+
+
 /**
- * Dispatch to the appropriate "do_SUBCMD" function.
+ * Return the handler function for the given sub-command string (aka the
+ * subcmd *name*). This returns undefined if there is no handler for that
+ * sub-command.
  */
-Cmdln.prototype.dispatch = function dispatch(subcmd, argv, callback) {
-    var name = this.aliases[subcmd];
+Cmdln.prototype.handlerFromSubcmd = function handlerFromSubcmd(alias) {
+    var name = this._nameFromAlias[alias];
     if (!name) {
-        callback(new UnknownCommandError(subcmd));
         return;
     }
-    var func = this.subcmds[name];
+    return this._handlerFromName[name];
+};
 
-    var opts = null;
-    var args = argv.slice(3);
-    if (func.options) {
-        try {
-            var parser = new dashdash.Parser({options: func.options});
-            opts = parser.parse(argv, 3);
-        } catch (e) {
-            callback(new OptionError(e, subcmd));
+
+/**
+ * Return the help content for the given sub-command string (aka the
+ * subcmd *name*).
+ *
+ * *Limitation*: If the command has a help *function*, then the function is
+ * returned. It is up to the caller to call it, if they like. The help
+ * function is defined to be async and is *not* defined to return the
+ * string, so running it isn't useful here.
+ *
+ * @param alias {String} The sub-command name or alias.
+ * @throws `UnknownCommandError` if there is no such sub-command.
+ * @returns The help string, a help *function* (see the "Limitation" note
+ *      above), or `null` if no help.
+ */
+Cmdln.prototype.helpFromSubcmd = function helpFromSubcmd(alias) {
+    var handler = this.handlerFromSubcmd(alias);
+    if (!handler) {
+        throw new UnknownCommandError(alias);
+    }
+
+    if (handler.help) {
+        if (typeof (handler.help) === 'function') {
+            return handler.help;
+        } else {
+            return this._renderHelp(handler.help, handler, alias);
+        }
+    } else if (handler.do_help) {
+        // This is likely a `Cmdln` subclass.
+        return function subCliHelp(subcmd, opts, args, cb) {
+            handler.do_help('help', opts, args.slice(1), function (helpErr) {
+                cb(helpErr || false);
+            });
         }
-        args = opts._args;
-        debug('-- parse %j opts: %j', subcmd, opts);
+    } else {
+        return null;
     }
+};
 
-    func.call(this, subcmd, opts, args, callback);
+
+Cmdln.prototype._renderHelp = function _renderHelp(template, handler, alias) {
+    assert.string(template, 'template');
+    assert.optionalString(alias, 'alias');
+
+    var help = this._renderTemplate(template, alias);
+    if (~help.indexOf('{{usage}}')) {
+        var synopses = this.synopsesFromSubcmd(alias || handler);
+        if (synopses.length) {
+            help = help.replace('{{usage}}',
+                'Usage:\n' + indent(synopses.join('\n')));
+        }
+    }
+    if (~help.indexOf('{{options}}') && handler.options) {
+        var parser = new dashdash.Parser({options: handler.options});
+        var helpOpts = (handler.helpOpts
+            ? objMerge(this.helpOpts, handler.helpOpts)
+            : this.helpOpts);
+        help = help.replace('{{options}}',
+            'Options:\n' + parser.help(helpOpts));
+    }
+    help = help.trimRight();
+    return help;
 };
 
-Cmdln.prototype.do_help = function do_help(subcmd, opts, args, callback) {
+Cmdln.prototype._renderTemplate = function _renderTemplate(template, alias) {
+    assert.string(template, 'template');
+    assert.optionalString(alias, 'alias');
+
+    var s = template;
+    s = s.replace(/{{name}}/g, this.name);
+    if (alias) {
+        s = s.replace(/{{cmd}}/g, alias);
+    }
+    return s;
+};
+
+/**
+ * A Cmdln subcmd handler (i.e. the `do_SUBCMD` function) can define a
+ * `synopses` array of usage summaries. E.g.:
+ *
+ *      CLI.prototype.do_foo.synopses = ['{{name}} foo [OPTIONS] ...'];
+ *
+ * Synopses can use the following template vars:
+ *      {{name}}        The cmdln name, e.g. 'mycmd'.
+ *      {{cmd}}         The sub-command name.
+ *
+ * @param {String|Function|Object} subcmd: The subcommand name/alias or the
+ *      subcmd handler (a `do_SUBCMD` function or sub-Cmdln instance).
+ * @returns {Array} of synopsis strings, if any.
+ * @throws {UnknownCommandError} if `alias` doesn't correspond to a command.
+ */
+Cmdln.prototype.synopsesFromSubcmd = function synopsesFromSubcmd(subcmd) {
+    assert.ok(['function', 'string', 'object'].indexOf(typeof (subcmd)) !== -1);
+
+    var name, handler;
+    if (typeof (subcmd) === 'function') {
+        handler = subcmd;
+        name = this.subcmdFromFuncname(handler.name);
+    } else if (typeof (subcmd) === 'object') {
+        name = subcmd.name;
+        handler = subcmd;
+    } else {
+        name = subcmd;
+        handler = this.handlerFromSubcmd(subcmd);
+        if (!handler) {
+            throw new UnknownCommandError(subcmd);
+        }
+    }
+
+    var synopses = [];
+    if (handler.synopses) {
+        for (var i = 0; i < handler.synopses.length; i++) {
+            synopses.push(this._renderTemplate(handler.synopses[i], name));
+        }
+    }
+
+    return synopses;
+};
+
+
+/**
+ * Dispatch to the appropriate "do_SUBCMD" function.
+ *
+ * Old call signature:
+ *      function dispatch(subcmd, argv, callback)
+ *
+ * New call signature:
+ *      function dispatch(dispatchOpts, callback)
+ *
+ * where `argv` is the raw argv array, e.g. ['node', 'foo.js', 'arg1', 'arg2'].
+ *
+ * @param dispatchOpts {Object}
+ *      - @param dispatchOpts.subcmd {String} Required.
+ *      - @param dispatchOpts.argv {Array}
+ *      - @param dispatchOpts.opts {Object}
+ *      - @param dispatchOpts.args {Array}
+ *        One must provide either `argv` *or* both `opts` and `args`. In the
+ *        former, more common case, the option processing has not yet been done
+ *        on the argv. This is equiv to the "old call signature". In the latter,
+ *        dashdash option processing *has* been done. This can be useful for
+ *        subcmds that are modified or shortcut versions of other ones.
+ * @param callback {Function}
+ */
+Cmdln.prototype.dispatch = function dispatch(dispatchOpts, callback) {
+    // Sort out input params.
+    var subcmd, argv, opts, args;
+    if (typeof (callback) === 'function') {
+        // New call signature.
+        assert.string(dispatchOpts.subcmd, 'dispatchOpts.subcmd');
+        assert.optionalArrayOfString(dispatchOpts.argv, 'dispatchOpts.argv');
+        assert.optionalObject(dispatchOpts.opts, 'dispatchOpts.opts');
+        assert.optionalArrayOfString(dispatchOpts.args, 'dispatchOpts.args');
+        subcmd = dispatchOpts.subcmd;
+        argv = dispatchOpts.argv;
+        opts = dispatchOpts.opts;
+        args = dispatchOpts.args;
+    } else {
+        // Old call signature.
+        assert.string(arguments[0], 'subcmd');
+        assert.arrayOfString(arguments[1], 'argv');
+        subcmd = arguments[0];
+        argv = arguments[1];
+        callback = arguments[2];
+    }
+    assert.func(callback, 'callback');
+    assert.ok((argv && !opts && !args) || (!argv && opts && args),
+        'must specify only one of "argv" *or* "opts/args"');
     var self = this;
+
+    var finish = function (err) {
+        if (err) {
+            if (!err._cmdlnInst) err._cmdlnInst = self;
+            if (!err._cmdlnSubcmd && subcmd) err._cmdlnSubcmd = subcmd;
+            if (!err._cmdlnHandler && handler) err._cmdlnHandler = handler;
+        }
+        callback(err);
+    }
+
+    var handler = this.handlerFromSubcmd(subcmd);
+    if (!handler) {
+        finish(new UnknownCommandError(subcmd));
+        return;
+    }
+
+    if (argv) {
+        opts = {};
+        args = argv.slice(3);
+    }
+
+    if (typeof (handler.main) === 'function') {
+        // This is likely a `Cmdln` subclass instance, i.e. a subcli.
+        (function callCmdlnHandler(subcmd, opts, args, cb) {
+            var argv = ['', ''].concat(args);
+            handler.main(argv, cb);
+        }).call(this, subcmd, opts, args, finish);
+    } else {
+        // This is a vanilla `do_SUBCMD` function on the Cmdln class.
+
+        // Skip optional processing if given `opts` -- i.e. it was already done.
+        if (argv && handler.options) {
+            try {
+                var parser = new dashdash.Parser({
+                    options: handler.options,
+                    interspersed: (handler.interspersedOptions !== undefined
+                        ? handler.interspersedOptions : true),
+                    allowUnknown: (handler.allowUnknownOptions !== undefined
+                        ? handler.allowUnknownOptions : false)
+                });
+                opts = parser.parse(argv, 3);
+            } catch (e) {
+                finish(new OptionError(e));
+                return;
+            }
+            args = opts._args;
+            debug('-- parse %j opts: %j', subcmd, opts);
+        }
+        handler.call(this, subcmd, opts, args, finish);
+    }
+};
+
+Cmdln.prototype.do_help = function do_help(subcmd, opts, args, callback) {
     if (args.length === 0) {
         this.printHelp(callback);
         return;
     }
     var alias = args[0];
-    var name = this.aliases[alias];
-    if (!name) {
+    var handler = this.handlerFromSubcmd(alias);
+    if (!handler) {
         callback(new UnknownCommandError(alias));
         return;
     }
 
-    var func = this.subcmds[name];
-    if (func.help) {
-        var help = func.help;
-        help = help.replace('{{name}}', name);
-        if (~help.indexOf('{{options}}')) {
-            var parser = new dashdash.Parser({options: func.options});
-            help = help.replace('{{options}}',
-                'Options:\n' + parser.help(this.helpOpts));
-        }
-        console.log(help.trimRight());
-        callback();
-    } else {
+    try {
+        var help = this.helpFromSubcmd(alias);
+    } catch (e) {
+        callback(e);
+    }
+    if (!help) {
         callback(new CmdlnError({message: format('no help for "%s"', alias)}));
+    } else if (typeof (help) === 'function') {
+        help(subcmd, opts, args, callback);
+    } else {
+        console.log(help);
+        callback();
     }
 };
 Cmdln.prototype.do_help.aliases = ['?'];
 Cmdln.prototype.do_help.help = 'Help on a specific sub-command.';
 
-Cmdln.prototype.help_help = function help_help(subcmd, callback) {
-    this.printHelp(callback);
-};
-
 
 
 // ---- convenience main function for a script
 
 /**
- * Mainline for a Cmdln-using tool. E.g.,
+ * A convenience `main()` for a CLI script using this module. It takes a
+ * Cmdln subclass instance, runs it with the current process argv and
+ * exits with appropriate error output and status code. This does not have a
+ * callback because it calls `process.exit` (with an appropriate exit status).
+ *
+ * Usage example:
  *
- *      function MyTool() {
+ *      function MyCLI() {
  *          // ...
  *      }
- *      util.inherits(MyTool, Cmdln);
+ *      util.inherits(MyCLI, Cmdln);
+ *      // ...
  *
- *      ...
  *      if (require.main === module) {
- *          cmdln.main(MyTool);
+ *          var cli = MyCLI();
+ *          cmdln.main(cli);
  *      }
  *
- * @param cmdClass {Function} The Cmdln subclass ctor.
- * @param argv {Array} The argv to process. Optional. Default is `process.argv`.0
+ * If one wants more control over process termination, err printing or whatever,
+ * the gist of this convenience function is:
+ *
+ *      var cli = MyCLI();
+ *      cli.main(process.argv, function (err) {
+ *          // handle `err`, if any
+ *      });
+ *
+ * @param cli {Function} A `Cmdln` subclass instance.
+ * @param options {Object}
+ *      - `argv` {Array} The argv to process. Optional. Default is
+ *        `process.argv`.
+ *      - `finale` {String} Optional, default 'softexit'. What to do when
+ *        done. Options are 'softexit' (set `process.exitCode` if supported,
+ *        else call `process.exit()`), 'exit' (call `process.exit()` which
+ *        can result in std handles not being flushed), 'callback' (call
+ *        the given `options.callback`), or 'none'.
+ *      - `callback` {Function} Optional. A function called `function (err)`
+ *        if `options.finale === "callback"`.
+ *      - `showErr` {Boolean} Optional. Whether to show (i.e. print via
+ *        `console.error(...)` an error. If not set, then `<cli>.showErr`
+ *        decides. Default true.
+ *      - `showCode` {Boolean} Default false. Whether to show the error `code`
+ *        in the stderr output, if available on the error objects returned
+ *        by subcommands. E.g. with `showCode=false`:
+ *              mycli: error: blip blup burp
+ *        with `showCode=true`:
+ *              mycli: error (BlipBlup): blip blup burp
+ *        See the doc on the `CmdlnError` class above for details on the `code`.
+ *      - `showNoCommandErr` {Boolean} Optional. Whether to show an error
+ *        message on `NoCommandError` -- i.e. when the CLI is called with
+ *        no sub-command. Default false.
+ *      - `showErrStack` {Boolean} Optional. Whether to show the error stack
+ *        when printing an error. If not set, then `<cli>.showErrStack`
+ *        decides. Default false.
+ *      - `showErrHelp` {Boolean} Optional. Whether to show error help
+ *        (see comment on `errHelpFromErr()` and the CHANGES.md entry for
+ *        version 4.0.0) after an error is printed and if error help is
+ *        available. Typically only this module's own error classes support
+ *        error help. Default true.
+ *
+ * Some fields can be set on the Cmdln instance, `<cli>`, to control error
+ * printing. One might want to set these dynamically based, e.g., on top-level
+ * options like `--quiet` or `--verbose`.
+ * - `<cli>.showErr`
+ * - `<cli>.showErrStack`
  */
-function main(cmdClass, argv) {
-    assert.func(cmdClass, 'cmdClass');
-    assert.optionalArrayOfString(argv, 'argv');
-    if (!argv) argv = process.argv;
+function main(cli, options) {
+    /*
+     * For *backward compat*, support the cmdln v1.x calling style:
+     *      cmdln.main(<cmdln-class-ctor>[, <argv>[, <options>]]);
+     * and semantics:
+     * - showNoCommandErr=true by default
+     * - DEBUG=1 envvar will set showErrStack=true
+     */
+    if (typeof (cli) === 'function') {
+        cli = new cli();
+        var argv = options;
+        if (arguments[2]) {
+            assert.object(arguments[2], 'options');
+            options = objCopy(arguments[2]);
+        } else {
+            options = {};
+        }
+        if (argv) {
+            options.argv = argv;
+        }
+        // Backward compat for `process.DEBUG` resulting in error output
+        // including the error stack.
+        if (options.showErrStack === undefined && process.env.DEBUG) {
+            options.showErrStack = true;
+        }
+        if (options.showNoCommandErr === undefined) {
+            options.showNoCommandErr = true;
+        }
+    }
 
-    var cli = new cmdClass();
-    cli.main(argv, function (err) {
-        if (err) {
-            console.error('%s%s: error%s: %s',
-                cli.name,
-                (err.subcmd ? ' ' + err.subcmd : ''),
-                (false && err.code ? format(' (%s)', err.code) : ''),
-                (process.env.DEBUG ? err.stack : err.message));
-            process.exit(err.exitStatus || 1);
+    assert.object(cli, 'cli');
+    assert.optionalObject(options, 'options');
+    options = options ? objCopy(options) : {};
+    assert.optionalArrayOfString(options.argv, 'options.argv');
+    if (!options.argv) {
+        options.argv = process.argv;
+    }
+    assert.optionalBool(options.showErr, 'options.showErr');
+    assert.optionalBool(options.showCode, 'options.showCode');
+    assert.optionalBool(options.showNoCommandErr, 'options.showNoCommandErr');
+    assert.optionalBool(options.showErrStack, 'options.showErrStack');
+    assert.optionalBool(options.showErrHelp, 'options.showErrHelp');
+
+    var VALID_FINALES = ['softexit', 'exit', 'callback', 'none'];
+    var finale;
+    if (options.hasOwnProperty('finale')) {
+        assert.ok(VALID_FINALES.indexOf(options.finale) !== -1,
+            format('invalid options.finale "%s": valid values are "%s"',
+                options.finale, '", "'.join(VALID_FINALES)));
+        finale = options.finale
+    } else {
+        finale = 'softexit';
+    }
+    if (options.hasOwnProperty('callback')) {
+        assert.func(options.callback, 'options.callback');
+        assert.equal(finale, 'callback',
+            'options.callback provided, but options.finale is not "callback"');
+    }
+
+    cli.main(options.argv, function (err) {
+        var exitStatus = (err ? err.exitStatus || 1 : 0);
+
+        // We show (i.e. console.error) an error by default, unless turned
+        // off via `options.showErr` or `cli.showErr`.
+        var showErr = (options.showErr !== undefined ? options.showErr
+            : (cli.showErr !== undefined ? cli.showErr : true));
+
+        if (err && showErr) {
+            var code = (err.body ? err.body.code : err.code);
+            if (code === 'NoCommand' && !options.showNoCommandErr) {
+                /* jsl:pass */
+            } else if (!cli.suppressShowErr && err.message !== undefined) {
+                /*
+                 * If the `err` has no "message" field, then this probably
+                 * isn't an Error instance. Let's just not print an error
+                 * message. This can happen if the subcmd passes back `true`
+                 * or similar to indicate "yes there was an error".
+                 */
+                var showErrStack = (options.showErrStack === undefined
+                        ? cli.showErrStack : options.showErrStack);
+                console.error('%s: error%s: %s',
+                    nameFromErr(err),
+                    (options.showCode && code ? format(' (%s)', code) : ''),
+                    (showErrStack ? err.stack : err.message));
+                var showErrHelp = (options.showErrHelp === undefined
+                    ? true : options.showErrHelp);
+                if (showErrHelp) {
+                    var errHelp = errHelpFromErr(err);
+                    if (errHelp) {
+                        console.error(errHelp);
+                    }
+                }
+            }
+        }
+
+        if (finale === 'exit') {
+            process.exit(exitStatus);
+        } else if (finale === 'softexit') {
+            /*
+             * We'd like to NOT use `process.exit` because node then doesn't in
+             * general allow std handles to flush. For some node versions it
+             * *will* flush if stdout is a TTY. However, you are then screwed
+             * when piping output to anything. IOW, that is no help.
+             *
+             * In node 0.12, `process.exitCode` provided a way to set the exit
+             * code without the hard immediate `process.exit()`.
+             *
+             * Note: A side-effect of avoiding `process.exit()` if we can
+             * manage it, is that a node tool using this that still has active
+             * handles will hang instead of exiting. If that is you, use
+             * `finale: "exit"`.
+             */
+            var supportsProcessExitCode = true;
+            var nodeVer = process.versions.node.split('.').map(Number);
+            if (nodeVer[0] === 0 && nodeVer[1] <= 10) {
+                supportsProcessExitCode = false;
+            }
+
+            if (supportsProcessExitCode) {
+                process.exitCode = exitStatus;
+            } else if (exitStatus !== 0) {
+                process.exit(exitStatus);
+            }
+        } else if (finale === 'callback') {
+            if (options.callback) {
+                options.callback(err);
+            }
         }
-        process.exit(0);
     });
 }
 
 
+
 // ---- exports
 
 module.exports = {
     Cmdln: Cmdln,
+    main: main,
+
     CmdlnError: CmdlnError,
+    UsageError: UsageError,
     OptionError: OptionError,
     UnknownCommandError: UnknownCommandError,
-    main: main
+    errHelpFromErr: errHelpFromErr,
+    nameFromErr: nameFromErr,
+
+    // Expose this to allow calling code to `cmdln.dashdash.addOptionType`.
+    dashdash: dashdash
 };
diff --git a/src/fw/node_modules/dashdash/LICENSE.txt b/src/fw/node_modules/dashdash/LICENSE.txt
deleted file mode 100644
index 54706c66..00000000
--- a/src/fw/node_modules/dashdash/LICENSE.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-# This is the MIT license
-
-Copyright (c) 2013 Trent Mick. All rights reserved.
-Copyright (c) 2013 Joyent Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/src/fw/node_modules/dashdash/README.md b/src/fw/node_modules/dashdash/README.md
new file mode 100644
index 00000000..e47b106e
--- /dev/null
+++ b/src/fw/node_modules/dashdash/README.md
@@ -0,0 +1,574 @@
+A light, featureful and explicit option parsing library for node.js.
+
+[Why another one? See below](#why). tl;dr: The others I've tried are one of
+too loosey goosey (not explicit), too big/too many deps, or ill specified.
+YMMV.
+
+Follow <a href="https://twitter.com/intent/user?screen_name=trentmick" target="_blank">@trentmick</a>
+for updates to node-dashdash.
+
+# Install
+
+    npm install dashdash
+
+
+# Usage
+
+```javascript
+var dashdash = require('dashdash');
+
+// Specify the options. Minimally `name` (or `names`) and `type`
+// must be given for each.
+var options = [
+    {
+        // `names` or a single `name`. First element is the `opts.KEY`.
+        names: ['help', 'h'],
+        // See "Option specs" below for types.
+        type: 'bool',
+        help: 'Print this help and exit.'
+    }
+];
+
+// Shortcut form. As called it infers `process.argv`. See below for
+// the longer form to use methods like `.help()` on the Parser object.
+var opts = dashdash.parse({options: options});
+
+console.log("opts:", opts);
+console.log("args:", opts._args);
+```
+
+
+# Longer Example
+
+A more realistic [starter script "foo.js"](./examples/foo.js) is as follows.
+This also shows using `parser.help()` for formatted option help.
+
+```javascript
+var dashdash = require('./lib/dashdash');
+
+var options = [
+    {
+        name: 'version',
+        type: 'bool',
+        help: 'Print tool version and exit.'
+    },
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Print this help and exit.'
+    },
+    {
+        names: ['verbose', 'v'],
+        type: 'arrayOfBool',
+        help: 'Verbose output. Use multiple times for more verbose.'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'File to process',
+        helpArg: 'FILE'
+    }
+];
+
+var parser = dashdash.createParser({options: options});
+try {
+    var opts = parser.parse(process.argv);
+} catch (e) {
+    console.error('foo: error: %s', e.message);
+    process.exit(1);
+}
+
+console.log("# opts:", opts);
+console.log("# args:", opts._args);
+
+// Use `parser.help()` for formatted options help.
+if (opts.help) {
+    var help = parser.help({includeEnv: true}).trimRight();
+    console.log('usage: node foo.js [OPTIONS]\n'
+                + 'options:\n'
+                + help);
+    process.exit(0);
+}
+
+// ...
+```
+
+
+Some example output from this script (foo.js):
+
+```
+$ node foo.js -h
+# opts: { help: true,
+  _order: [ { name: 'help', value: true, from: 'argv' } ],
+  _args: [] }
+# args: []
+usage: node foo.js [OPTIONS]
+options:
+    --version             Print tool version and exit.
+    -h, --help            Print this help and exit.
+    -v, --verbose         Verbose output. Use multiple times for more verbose.
+    -f FILE, --file=FILE  File to process
+
+$ node foo.js -v
+# opts: { verbose: [ true ],
+  _order: [ { name: 'verbose', value: true, from: 'argv' } ],
+  _args: [] }
+# args: []
+
+$ node foo.js --version arg1
+# opts: { version: true,
+  _order: [ { name: 'version', value: true, from: 'argv' } ],
+  _args: [ 'arg1' ] }
+# args: [ 'arg1' ]
+
+$ node foo.js -f bar.txt
+# opts: { file: 'bar.txt',
+  _order: [ { name: 'file', value: 'bar.txt', from: 'argv' } ],
+  _args: [] }
+# args: []
+
+$ node foo.js -vvv --file=blah
+# opts: { verbose: [ true, true, true ],
+  file: 'blah',
+  _order:
+   [ { name: 'verbose', value: true, from: 'argv' },
+     { name: 'verbose', value: true, from: 'argv' },
+     { name: 'verbose', value: true, from: 'argv' },
+     { name: 'file', value: 'blah', from: 'argv' } ],
+  _args: [] }
+# args: []
+```
+
+
+See the ["examples"](examples/) dir for a number of starter examples using
+some of dashdash's features.
+
+
+# Environment variable integration
+
+If you want to allow environment variables to specify options to your tool,
+dashdash makes this easy. We can change the 'verbose' option in the example
+above to include an 'env' field:
+
+```javascript
+    {
+        names: ['verbose', 'v'],
+        type: 'arrayOfBool',
+        env: 'FOO_VERBOSE',         // <--- add this line
+        help: 'Verbose output. Use multiple times for more verbose.'
+    },
+```
+
+then the **"FOO_VERBOSE" environment variable** can be used to set this
+option:
+
+```shell
+$ FOO_VERBOSE=1 node foo.js
+# opts: { verbose: [ true ],
+  _order: [ { name: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Boolean options will interpret the empty string as unset, '0' as false
+and anything else as true.
+
+```shell
+$ FOO_VERBOSE= node examples/foo.js                 # not set
+# opts: { _order: [], _args: [] }
+# args: []
+
+$ FOO_VERBOSE=0 node examples/foo.js                # '0' is false
+# opts: { verbose: [ false ],
+  _order: [ { key: 'verbose', value: false, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_VERBOSE=1 node examples/foo.js                # true
+# opts: { verbose: [ true ],
+  _order: [ { key: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_VERBOSE=boogabooga node examples/foo.js       # true
+# opts: { verbose: [ true ],
+  _order: [ { key: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Non-booleans can be used as well. Strings:
+
+```shell
+$ FOO_FILE=data.txt node examples/foo.js
+# opts: { file: 'data.txt',
+  _order: [ { key: 'file', value: 'data.txt', from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Numbers:
+
+```shell
+$ FOO_TIMEOUT=5000 node examples/foo.js
+# opts: { timeout: 5000,
+  _order: [ { key: 'timeout', value: 5000, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_TIMEOUT=blarg node examples/foo.js
+foo: error: arg for "FOO_TIMEOUT" is not a positive integer: "blarg"
+```
+
+With the `includeEnv: true` config to `parser.help()` the environment
+variable can also be included in **help output**:
+
+    usage: node foo.js [OPTIONS]
+    options:
+        --version             Print tool version and exit.
+        -h, --help            Print this help and exit.
+        -v, --verbose         Verbose output. Use multiple times for more verbose.
+                              Environment: FOO_VERBOSE=1
+        -f FILE, --file=FILE  File to process
+
+
+# Bash completion
+
+Dashdash provides a simple way to create a Bash completion file that you
+can place in your "bash_completion.d" directory -- sometimes that is
+"/usr/local/etc/bash_completion.d/"). Features:
+
+- Support for short and long opts
+- Support for knowing which options take arguments
+- Support for subcommands (e.g. 'git log <TAB>' to show just options for the
+  log subcommand). See
+  [node-cmdln](https://github.com/trentm/node-cmdln#bash-completion) for
+  how to integrate that.
+- Does the right thing with "--" to stop options.
+- Custom optarg and arg types for custom completions.
+
+Dashdash will return bash completion file content given a parser instance:
+
+    var parser = dashdash.createParser({options: options});
+    console.log( parser.bashCompletion({name: 'mycli'}) );
+
+or directly from a `options` array of options specs:
+
+    var code = dashdash.bashCompletionFromOptions({
+        name: 'mycli',
+        options: OPTIONS
+    });
+
+Write that content to "/usr/local/etc/bash_completion.d/mycli" and you will
+have Bash completions for `mycli`. Alternatively you can write it to
+any file (e.g. "~/.bashrc") and source it.
+
+You could add a `--completion` hidden option to your tool that emits the
+completion content and document for your users to call that to install
+Bash completions.
+
+See [examples/ddcompletion.js](examples/ddcompletion.js) for a complete
+example, including how one can define bash functions for completion of custom
+option types. Also see [node-cmdln](https://github.com/trentm/node-cmdln) for
+how it uses this for Bash completion for full multi-subcommand tools.
+
+- TODO: document specExtra
+- TODO: document includeHidden
+- TODO: document custom types, `function complete\_FOO` guide, completionType
+- TODO: document argtypes
+
+
+# Parser config
+
+Parser construction (i.e. `dashdash.createParser(CONFIG)`) takes the
+following fields:
+
+- `options` (Array of option specs). Required. See the
+  [Option specs](#option-specs) section below.
+
+- `interspersed` (Boolean). Optional. Default is true. If true this allows
+  interspersed arguments and options. I.e.:
+
+        node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args
+
+  Set it to false to have '-h' **not** get parsed as an option in the above
+  example.
+
+- `allowUnknown` (Boolean).  Optional.  Default is false.  If false, this causes
+  unknown arguments to throw an error.  I.e.:
+
+        node ./tool.js -v arg1 --afe8asefksjefhas
+
+  Set it to true to treat the unknown option as a positional
+  argument.
+
+  **Caveat**: When a shortopt group, such as `-xaz` contains a mix of
+  known and unknown options, the *entire* group is passed through
+  unmolested as a positional argument.
+
+  Consider if you have a known short option `-a`, and parse the
+  following command line:
+
+        node ./tool.js -xaz
+
+  where `-x` and `-z` are unknown.  There are multiple ways to
+  interpret this:
+
+    1. `-x` takes a value: `{x: 'az'}`
+    2. `-x` and `-z` are both booleans: `{x:true,a:true,z:true}`
+
+  Since dashdash does not know what `-x` and `-z` are, it can't know
+  if you'd prefer to receive `{a:true,_args:['-x','-z']}` or
+  `{x:'az'}`, or `{_args:['-xaz']}`. Leaving the positional arg unprocessed
+  is the easiest mistake for the user to recover from.
+
+
+# Option specs
+
+Example using all fields (required fields are noted):
+
+```javascript
+{
+    names: ['file', 'f'],       // Required (one of `names` or `name`).
+    type: 'string',             // Required.
+    completionType: 'filename',
+    env: 'MYTOOL_FILE',
+    help: 'Config file to load before running "mytool"',
+    helpArg: 'PATH',
+    helpWrap: false,
+    default: path.resolve(process.env.HOME, '.mytoolrc')
+}
+```
+
+Each option spec in the `options` array must/can have the following fields:
+
+- `name` (String) or `names` (Array). Required. These give the option name
+  and aliases. The first name (if more than one given) is the key for the
+  parsed `opts` object.
+
+- `type` (String). Required. One of:
+
+    - bool
+    - string
+    - number
+    - integer
+    - positiveInteger
+    - date (epoch seconds, e.g. 1396031701, or ISO 8601 format
+      `YYYY-MM-DD[THH:MM:SS[.sss][Z]]`, e.g. "2014-03-28T18:35:01.489Z")
+    - arrayOfBool
+    - arrayOfString
+    - arrayOfNumber
+    - arrayOfInteger
+    - arrayOfPositiveInteger
+    - arrayOfDate
+
+  FWIW, these names attempt to match with asserts on
+  [assert-plus](https://github.com/mcavage/node-assert-plus).
+  You can add your own custom option types with `dashdash.addOptionType`.
+  See below.
+
+- `completionType` (String). Optional. This is used for [Bash
+  completion](#bash-completion) for an option argument. If not specified,
+  then the value of `type` is used. Any string may be specified, but only the
+  following values have meaning:
+
+    - `none`: Provide no completions.
+    - `file`: Bash's default completion (i.e. `complete -o default`), which
+      includes filenames.
+    - *Any string FOO for which a `function complete_FOO` Bash function is
+      defined.* This is for custom completions for a given tool. Typically
+      these custom functions are provided in the `specExtra` argument to
+      `dashdash.bashCompletionFromOptions()`. See
+      ["examples/ddcompletion.js"](examples/ddcompletion.js) for an example.
+
+- `env` (String or Array of String). Optional. An environment variable name
+  (or names) that can be used as a fallback for this option. For example,
+  given a "foo.js" like this:
+
+        var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];
+        var opts = dashdash.parse({options: options});
+
+  Both `node foo.js --dry-run` and `FOO_DRY_RUN=1 node foo.js` would result
+  in `opts.dry_run = true`.
+
+  An environment variable is only used as a fallback, i.e. it is ignored if
+  the associated option is given in `argv`.
+
+- `help` (String). Optional. Used for `parser.help()` output.
+
+- `helpArg` (String). Optional. Used in help output as the placeholder for
+  the option argument, e.g. the "PATH" in:
+
+        ...
+        -f PATH, --file=PATH    File to process
+        ...
+
+- `helpWrap` (Boolean). Optional, default true. Set this to `false` to have
+  that option's `help` *not* be text wrapped in `<parser>.help()` output.
+
+- `default`. Optional. A default value used for this option, if the
+  option isn't specified in argv.
+
+- `hidden` (Boolean). Optional, default false. If true, help output will not
+  include this option. See also the `includeHidden` option to
+  `bashCompletionFromOptions()` for [Bash completion](#bash-completion).
+
+
+# Option group headings
+
+You can add headings between option specs in the `options` array.  To do so,
+simply add an object with only a `group` property -- the string to print as
+the heading for the subsequent options in the array.  For example:
+
+```javascript
+var options = [
+    {
+        group: 'Armament Options'
+    },
+    {
+        names: [ 'weapon', 'w' ],
+        type: 'string'
+    },
+    {
+        group: 'General Options'
+    },
+    {
+        names: [ 'help', 'h' ],
+        type: 'bool'
+    }
+];
+...
+```
+
+Note: You can use an empty string, `{group: ''}`, to get a blank line in help
+output between groups of options.
+
+
+# Help config
+
+The `parser.help(...)` function is configurable as follows:
+
+        Options:
+          Armament Options:
+        ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |
+       /                                sword, spear, maul                  |
+      /   General Options:                                                  |
+     /      -h, --help                  Print this help and exit.           |
+    /   ^^^^                            ^                                   |
+    \       `-- indent                   `-- helpCol              maxCol ---'
+     `-- headingIndent
+
+- `indent` (Number or String). Default 4. Set to a number (for that many
+  spaces) or a string for the literal indent.
+- `headingIndent` (Number or String). Default half length of `indent`. Set to
+  a number (for that many spaces) or a string for the literal indent. This
+  indent applies to group heading lines, between normal option lines.
+- `nameSort` (String). Default is 'length'. By default the names are
+  sorted to put the short opts first (i.e. '-h, --help' preferred
+  to '--help, -h'). Set to 'none' to not do this sorting.
+- `maxCol` (Number). Default 80. Note that reflow is just done on whitespace
+  so a long token in the option help can overflow maxCol.
+- `helpCol` (Number). If not set a reasonable value will be determined
+  between `minHelpCol` and `maxHelpCol`.
+- `minHelpCol` (Number). Default 20.
+- `maxHelpCol` (Number). Default 40.
+- `helpWrap` (Boolean). Default true. Set to `false` to have option `help`
+  strings *not* be textwrapped to the helpCol..maxCol range.
+- `includeEnv` (Boolean). Default false. If the option has associated
+  environment variables (via the `env` option spec attribute), then
+  append mentioned of those envvars to the help string.
+- `includeDefault` (Boolean). Default false. If the option has a default value
+  (via the `default` option spec attribute, or a default on the option's type),
+  then a "Default: VALUE" string will be appended to the help string.
+
+
+# Custom option types
+
+Dashdash includes a good starter set of option types that it will parse for
+you. However, you can add your own via:
+
+    var dashdash = require('dashdash');
+    dashdash.addOptionType({
+        name: '...',
+        takesArg: true,
+        helpArg: '...',
+        parseArg: function (option, optstr, arg) {
+            ...
+        },
+        array: false,  // optional
+        arrayFlatten: false,  // optional
+        default: ...,   // optional
+        completionType: ...  // optional
+    });
+
+For example, a simple option type that accepts 'yes', 'y', 'no' or 'n' as
+a boolean argument would look like:
+
+    var dashdash = require('dashdash');
+
+    function parseYesNo(option, optstr, arg) {
+        var argLower = arg.toLowerCase()
+        if (~['yes', 'y'].indexOf(argLower)) {
+            return true;
+        } else if (~['no', 'n'].indexOf(argLower)) {
+            return false;
+        } else {
+            throw new Error(format(
+                'arg for "%s" is not "yes" or "no": "%s"',
+                optstr, arg));
+        }
+    }
+
+    dashdash.addOptionType({
+        name: 'yesno'
+        takesArg: true,
+        helpArg: '<yes|no>',
+        parseArg: parseYesNo
+    });
+
+    var options = {
+        {names: ['answer', 'a'], type: 'yesno'}
+    };
+    var opts = dashdash.parse({options: options});
+
+See "examples/custom-option-\*.js" for other examples.
+See the `addOptionType` block comment in "lib/dashdash.js" for more details.
+Please let me know [with an
+issue](https://github.com/trentm/node-dashdash/issues/new) if you write a
+generally useful one.
+
+
+
+# Why
+
+Why another node.js option parsing lib?
+
+- `nopt` really is just for "tools like npm". Implicit opts (e.g. '--no-foo'
+  works for every '--foo'). Can't disable abbreviated opts. Can't do multiple
+  usages of same opt, e.g. '-vvv' (I think). Can't do grouped short opts.
+
+- `optimist` has surprise interpretation of options (at least to me).
+  Implicit opts mean ambiguities and poor error handling for fat-fingering.
+  `process.exit` calls makes it hard to use as a libary.
+
+- `optparse` Incomplete docs. Is this an attempted clone of Python's `optparse`.
+  Not clear. Some divergence. `parser.on("name", ...)` API is weird.
+
+- `argparse` Dep on underscore. No thanks just for option processing.
+  `find lib | wc -l` -> `26`. Overkill.
+  Argparse is a bit different anyway. Not sure I want that.
+
+- `posix-getopt` No type validation. Though that isn't a killer. AFAIK can't
+  have a long opt without a short alias. I.e. no `getopt_long` semantics.
+  Also, no whizbang features like generated help output.
+
+- ["commander.js"](https://github.com/visionmedia/commander.js): I wrote
+  [a critique](http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html)
+  a while back. It seems fine, but last I checked had
+  [an outstanding bug](https://github.com/visionmedia/commander.js/pull/121)
+  that would prevent me from using it.
+
+
+# License
+
+MIT. See LICENSE.txt.
diff --git a/src/fw/node_modules/dashdash/index.js b/src/fw/node_modules/dashdash/index.js
index 09ce5fee..adb6f13b 100644
--- a/src/fw/node_modules/dashdash/index.js
+++ b/src/fw/node_modules/dashdash/index.js
@@ -1,11 +1,14 @@
 /**
- * dashdash - yet another node.js optional parsing library
+ * dashdash - A light, featureful and explicit option parsing library for
+ * node.js.
  */
+// vim: set ts=4 sts=4 sw=4 et:
 
-var p = console.log;
+var assert = require('assert-plus');
 var format = require('util').format;
+var fs = require('fs');
+var path = require('path');
 
-var assert = require('assert-plus');
 
 var DEBUG = true;
 if (DEBUG) {
@@ -18,6 +21,13 @@ if (DEBUG) {
 
 // ---- internal support stuff
 
+// Replace {{variable}} in `s` with the template data in `d`.
+function renderTemplate(s, d) {
+    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {
+        return d.hasOwnProperty(key) ? d[key] : match;
+    });
+}
+
 /**
  * Return a shallow copy of the given object;
  */
@@ -42,6 +52,18 @@ function space(n) {
 }
 
 
+function makeIndent(arg, deflen, name) {
+    if (arg === null || arg === undefined)
+        return space(deflen);
+    else if (typeof (arg) === 'number')
+        return space(arg);
+    else if (typeof (arg) === 'string')
+        return arg;
+    else
+        assert.fail('invalid "' + name + '": not a string or number: ' + arg);
+}
+
+
 /**
  * Return an array of lines wrapping the given text to the given width.
  * This splits on whitespace. Single tokens longer than `width` are not
@@ -86,7 +108,7 @@ function optionKeyFromName(name) {
 // ---- Option types
 
 function parseBool(option, optstr, arg) {
-    return true;
+    return Boolean(arg);
 }
 
 function parseString(option, optstr, arg) {
@@ -117,14 +139,45 @@ function parseInteger(option, optstr, arg) {
 function parsePositiveInteger(option, optstr, arg) {
     assert.string(arg, 'arg');
     var num = Number(arg);
-    if (!/^[0-9]+$/.test(arg) || isNaN(num)) {
+    if (!/^[0-9]+$/.test(arg) || isNaN(num) || num === 0) {
         throw new Error(format('arg for "%s" is not a positive integer: "%s"',
             optstr, arg));
     }
     return num;
 }
 
-var types = {
+/**
+ * Supported date args:
+ * - epoch second times (e.g. 1396031701)
+ * - ISO 8601 format: YYYY-MM-DD[THH:MM:SS[.sss][Z]]
+ *      2014-03-28T18:35:01.489Z
+ *      2014-03-28T18:35:01.489
+ *      2014-03-28T18:35:01Z
+ *      2014-03-28T18:35:01
+ *      2014-03-28
+ */
+function parseDate(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var date;
+    if (/^\d+$/.test(arg)) {
+        // epoch seconds
+        date = new Date(Number(arg) * 1000);
+    /* JSSTYLED */
+    } else if (/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?Z?)?$/i.test(arg)) {
+        // ISO 8601 format
+        date = new Date(arg);
+    } else {
+        throw new Error(format('arg for "%s" is not a valid date format: "%s"',
+            optstr, arg));
+    }
+    if (date.toString() === 'Invalid Date') {
+        throw new Error(format('arg for "%s" is an invalid date: "%s"',
+            optstr, arg));
+    }
+    return date;
+}
+
+var optionTypes = {
     bool: {
         takesArg: false,
         parseArg: parseBool
@@ -149,6 +202,11 @@ var types = {
         helpArg: 'INT',
         parseArg: parsePositiveInteger
     },
+    date: {
+        takesArg: true,
+        helpArg: 'DATE',
+        parseArg: parseDate
+    },
     arrayOfBool: {
         takesArg: false,
         array: true,
@@ -178,6 +236,12 @@ var types = {
         array: true,
         parseArg: parsePositiveInteger
     },
+    arrayOfDate: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parseDate
+    },
 };
 
 
@@ -190,6 +254,8 @@ var types = {
  * @param config {Object} The parser configuration
  *      - options {Array} Array of option specs. See the README for how to
  *        specify each option spec.
+ *      - allowUnknown {Boolean} Default false. Whether to throw on unknown
+ *        options. If false, then unknown args are included in the _args array.
  *      - interspersed {Boolean} Default true. Whether to allow interspersed
  *        arguments (non-options) and options. E.g.:
  *              node tool.js arg1 arg2 -v
@@ -208,12 +274,21 @@ function Parser(config) {
     this.interspersed = (config.interspersed !== undefined
         ? config.interspersed : true);
 
+    // Don't allow unknown flags (true by default).
+    this.allowUnknown = (config.allowUnknown !== undefined
+        ? config.allowUnknown : false);
+
     this.options = config.options.map(function (o) { return shallowCopy(o); });
     this.optionFromName = {};
     this.optionFromEnv = {};
     for (var i = 0; i < this.options.length; i++) {
         var o = this.options[i];
-        assert.ok(types[o.type],
+        if (o.group !== undefined && o.group !== null) {
+            assert.optionalString(o.group,
+                format('config.options.%d.group', i));
+            continue;
+        }
+        assert.ok(optionTypes[o.type],
             format('invalid config.options.%d.type: "%s" in %j',
                    i, o.type, o));
         assert.optionalString(o.name, format('config.options.%d.name', i));
@@ -227,6 +302,11 @@ function Parser(config) {
             env = [env];
         }
         assert.optionalArrayOfString(env, format('config.options.%d.env', i));
+        assert.optionalString(o.helpGroup,
+            format('config.options.%d.helpGroup', i));
+        assert.optionalBool(o.helpWrap,
+            format('config.options.%d.helpWrap', i));
+        assert.optionalBool(o.hidden, format('config.options.%d.hidden', i));
 
         if (o.name) {
             o.names = [o.name];
@@ -255,13 +335,13 @@ function Parser(config) {
 }
 
 Parser.prototype.optionTakesArg = function optionTakesArg(option) {
-    return types[option.type].takesArg;
+    return optionTypes[option.type].takesArg;
 };
 
 /**
  * Parse options from the given argv.
  *
- * @param inputs {Object}
+ * @param inputs {Object} Optional.
  *      - argv {Array} Optional. The argv to parse. Defaults to
  *        `process.argv`.
  *      - slice {Number} The index into argv at which options/args begin.
@@ -280,31 +360,33 @@ Parser.prototype.parse = function parse(inputs) {
         inputs = {argv: arguments[0], slice: arguments[1]};
     }
 
-    assert.object(inputs, 'inputs');
+    assert.optionalObject(inputs, 'inputs');
+    if (!inputs) {
+        inputs = {};
+    }
     assert.optionalArrayOfString(inputs.argv, 'inputs.argv');
     //assert.optionalNumber(slice, 'slice');
     var argv = inputs.argv || process.argv;
     var slice = inputs.slice !== undefined ? inputs.slice : 2;
     var args = argv.slice(slice);
     var env = inputs.env || process.env;
-
-    // Setup default values
     var opts = {};
     var _order = [];
-    this.options.forEach(function (o) {
-        if (o.default) {
-            opts[o.key] = o.default;
-        }
-    });
 
     function addOpt(option, optstr, key, val, from) {
-        var type = types[option.type];
+        var type = optionTypes[option.type];
         var parsedVal = type.parseArg(option, optstr, val);
         if (type.array) {
             if (!opts[key]) {
                 opts[key] = [];
             }
-            opts[key].push(parsedVal);
+            if (type.arrayFlatten && Array.isArray(parsedVal)) {
+                for (var i = 0; i < parsedVal.length; i++) {
+                    opts[key].push(parsedVal[i]);
+                }
+            } else {
+                opts[key].push(parsedVal);
+            }
         } else {
             opts[key] = parsedVal;
         }
@@ -315,7 +397,7 @@ Parser.prototype.parse = function parse(inputs) {
     // Parse args.
     var _args = [];
     var i = 0;
-    while (i < args.length) {
+    outer: while (i < args.length) {
         var arg = args[i];
 
         // End of options marker.
@@ -334,42 +416,64 @@ Parser.prototype.parse = function parse(inputs) {
             }
             var option = this.optionFromName[name];
             if (!option) {
-                throw new Error(format('unknown option: "--%s"', name));
-            }
-            var takesArg = this.optionTakesArg(option);
-            if (val !== null && !takesArg) {
-                throw new Error(format('argument given to "--%s" option '
-                    + 'that does not take one: "%s"', name, arg));
-            }
-            if (!takesArg) {
-                addOpt(option, '--'+name, option.key, true, 'argv');
-            } else if (val !== null) {
-                addOpt(option, '--'+name, option.key, val, 'argv');
-            } else if (i + 1 >= args.length) {
-                throw new Error(format('do not have enough args for "--%s" '
-                    + 'option', name));
+                if (!this.allowUnknown)
+                    throw new Error(format('unknown option: "--%s"', name));
+                else if (this.interspersed)
+                    _args.push(arg);
+                else
+                    break outer;
             } else {
-                addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
-                i++;
+                var takesArg = this.optionTakesArg(option);
+                if (val !== null && !takesArg) {
+                    throw new Error(format('argument given to "--%s" option '
+                        + 'that does not take one: "%s"', name, arg));
+                }
+                if (!takesArg) {
+                    addOpt(option, '--'+name, option.key, true, 'argv');
+                } else if (val !== null) {
+                    addOpt(option, '--'+name, option.key, val, 'argv');
+                } else if (i + 1 >= args.length) {
+                    throw new Error(format('do not have enough args for "--%s" '
+                        + 'option', name));
+                } else {
+                    addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
+                    i++;
+                }
             }
 
         // Short option
         } else if (arg[0] === '-' && arg.length > 1) {
             var j = 1;
+            var allFound = true;
             while (j < arg.length) {
                 var name = arg[j];
-                var val = arg.slice(j + 1);  // option val if it takes an arg
-                // debug('name: %s (val: %s)', name, val)
                 var option = this.optionFromName[name];
                 if (!option) {
-                    if (arg.length > 2) {
+                    allFound = false;
+                    if (this.allowUnknown) {
+                        if (this.interspersed) {
+                            _args.push(arg);
+                            break;
+                        } else
+                            break outer;
+                    } else if (arg.length > 2) {
                         throw new Error(format(
                             'unknown option: "-%s" in "%s" group',
                             name, arg));
                     } else {
                         throw new Error(format('unknown option: "-%s"', name));
                     }
+                } else if (this.optionTakesArg(option)) {
+                    break;
                 }
+                j++;
+            }
+
+            j = 1;
+            while (allFound && j < arg.length) {
+                var name = arg[j];
+                var val = arg.slice(j + 1);  // option val if it takes an arg
+                var option = this.optionFromName[name];
                 var takesArg = this.optionTakesArg(option);
                 if (!takesArg) {
                     addOpt(option, '-'+name, option.key, true, 'argv');
@@ -394,7 +498,7 @@ Parser.prototype.parse = function parse(inputs) {
 
         // An arg and interspersed args are not allowed, so done options.
         } else {
-            break;
+            break outer;
         }
         i++;
     }
@@ -411,10 +515,23 @@ Parser.prototype.parse = function parse(inputs) {
         var takesArg = self.optionTakesArg(option);
         if (takesArg) {
             addOpt(option, envname, option.key, val, 'env');
-        } else if (val) {
-            // For now, we make VAR=<empty-string> NOT set the value
-            // false. It is as if the VAR was not set.
-            addOpt(option, envname, option.key, true, 'env');
+        } else if (val !== '') {
+            // Boolean envvar handling:
+            // - VAR=<empty-string>     not set (as if the VAR was not set)
+            // - VAR=0                  false
+            // - anything else          true
+            addOpt(option, envname, option.key, (val !== '0'), 'env');
+        }
+    });
+
+    // Apply default values.
+    this.options.forEach(function (o) {
+        if (opts[o.key] === undefined) {
+            if (o.default !== undefined) {
+                opts[o.key] = o.default;
+            } else if (o.type && optionTypes[o.type].default !== undefined) {
+                opts[o.key] = optionTypes[o.type].default;
+            }
         }
     });
 
@@ -445,23 +562,24 @@ Parser.prototype.parse = function parse(inputs) {
  *        automatically.
  *      - minHelpCol {Number} Default 20.
  *      - maxHelpCol {Number} Default 40.
- *      - includeEnv {Boolean} Default false.
+ *      - includeEnv {Boolean} Default false. If true, a note stating the `env`
+ *        envvar (if specified for this option) will be appended to the help
+ *        output.
+ *      - includeDefault {Boolean} Default false. If true, a note stating
+ *        the `default` for this option, if any, will be appended to the help
+ *        output.
+ *      - helpWrap {Boolean} Default true. Wrap help text in helpCol..maxCol
+ *        bounds.
  * @returns {String}
  */
 Parser.prototype.help = function help(config) {
     config = config || {};
     assert.object(config, 'config');
-    var indent;
-    if (config.indent === undefined) {
-        indent = space(4);
-    } else if (typeof (config.indent) === 'number') {
-        indent = space(config.indent);
-    } else if (typeof (config.indent) === 'string') {
-        indent = config.indent;
-    } else {
-        assert.fail('invalid "config.indent": not a string or number: '
-            + config.indent);
-    }
+
+    var indent = makeIndent(config.indent, 4, 'config.indent');
+    var headingIndent = makeIndent(config.headingIndent,
+        Math.round(indent.length / 2), 'config.headingIndent');
+
     assert.optionalString(config.nameSort, 'config.nameSort');
     var nameSort = config.nameSort || 'length';
     assert.ok(~['length', 'none'].indexOf(nameSort),
@@ -471,6 +589,8 @@ Parser.prototype.help = function help(config) {
     assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');
     assert.optionalNumber(config.helpCol, 'config.helpCol');
     assert.optionalBool(config.includeEnv, 'config.includeEnv');
+    assert.optionalBool(config.includeDefault, 'config.includeDefault');
+    assert.optionalBool(config.helpWrap, 'config.helpWrap');
     var maxCol = config.maxCol || 80;
     var minHelpCol = config.minHelpCol || 20;
     var maxHelpCol = config.maxHelpCol || 40;
@@ -478,7 +598,15 @@ Parser.prototype.help = function help(config) {
     var lines = [];
     var maxWidth = 0;
     this.options.forEach(function (o) {
-        var type = types[o.type];
+        if (o.hidden) {
+            return;
+        }
+        if (o.group !== undefined && o.group !== null) {
+            // We deal with groups in the next pass
+            lines.push(null);
+            return;
+        }
+        var type = optionTypes[o.type];
         var arg = o.helpArg || type.helpArg || 'ARG';
         var line = '';
         var names = o.names.slice();
@@ -515,47 +643,285 @@ Parser.prototype.help = function help(config) {
         helpCol = maxWidth + indent.length + 2;
         helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
     }
-    this.options.forEach(function (o, i) {
-        if (!o.help) {
+    var i = -1;
+    this.options.forEach(function (o) {
+        if (o.hidden) {
+            return;
+        }
+        i++;
+
+        if (o.group !== undefined && o.group !== null) {
+            if (o.group === '') {
+                // Support a empty string "group" to have a blank line between
+                // sets of options.
+                lines[i] = '';
+            } else {
+                // Render the group heading with the heading-specific indent.
+                lines[i] = (i === 0 ? '' : '\n') + headingIndent +
+                    o.group + ':';
+            }
             return;
         }
-        var line = lines[i];
-        var n = helpCol - (indent.length + line.length);
+
+        var helpDefault;
+        if (config.includeDefault) {
+            if (o.default !== undefined) {
+                helpDefault = format('Default: %j', o.default);
+            } else if (o.type && optionTypes[o.type].default !== undefined) {
+                helpDefault = format('Default: %j',
+                    optionTypes[o.type].default);
+            }
+        }
+
+        var line = lines[i] = indent + lines[i];
+        if (!o.help && !(config.includeEnv && o.env) && !helpDefault) {
+            return;
+        }
+        var n = helpCol - line.length;
         if (n >= 0) {
             line += space(n);
         } else {
             line += '\n' + space(helpCol);
         }
-        var help = o.help;
+
+        var helpEnv = '';
         if (o.env && o.env.length && config.includeEnv) {
-            if (help.length && !~'.!?'.indexOf(help.slice(-1))) {
+            helpEnv += 'Environment: ';
+            var type = optionTypes[o.type];
+            var arg = o.helpArg || type.helpArg || 'ARG';
+            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(
+                function (e) {
+                    if (type.takesArg) {
+                        return e + '=' + arg;
+                    } else {
+                        return e + '=1';
+                    }
+                }
+            );
+            helpEnv += envs.join(', ');
+        }
+        var help = (o.help || '').trim();
+        if (o.helpWrap !== false && config.helpWrap !== false) {
+            // Wrap help description normally.
+            if (help.length && !~'.!?"\''.indexOf(help.slice(-1))) {
                 help += '.';
             }
-            help += ' Environment: ';
-            var type = types[o.type];
-            var arg = o.helpArg || type.helpArg || 'ARG';
-            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(function (e) {
-                if (type.takesArg) {
-                    return e + '=' + arg;
-                } else {
-                    return e + '=1';
+            if (help.length) {
+                help += ' ';
+            }
+            help += helpEnv;
+            if (helpDefault) {
+                if (helpEnv) {
+                    help += '. ';
                 }
-            });
-            help += envs.join(', ');
+                help += helpDefault;
+            }
+            line += textwrap(help, maxCol - helpCol).join(
+                '\n' + space(helpCol));
+        } else {
+            // Do not wrap help description, but indent newlines appropriately.
+            var helpLines = help.split('\n').filter(
+                    function (ln) { return ln.length });
+            if (helpEnv !== '') {
+                helpLines.push(helpEnv);
+            }
+            if (helpDefault) {
+                helpLines.push(helpDefault);
+            }
+            line += helpLines.join('\n' + space(helpCol));
         }
-        line += textwrap(help, maxCol - helpCol).join(
-            '\n' + space(helpCol));
+
         lines[i] = line;
     });
 
     var rv = '';
     if (lines.length > 0) {
-        rv = indent + lines.join('\n' + indent) + '\n';
+        rv = lines.join('\n') + '\n';
     }
     return rv;
 };
 
 
+/**
+ * Return a string suitable for a Bash completion file for this tool.
+ *
+ * @param args.name {String} The tool name.
+ * @param args.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "examples/ddcompletion.js" for an example.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+Parser.prototype.bashCompletion = function bashCompletion(args) {
+    assert.object(args, 'args');
+    assert.string(args.name, 'args.name');
+    assert.optionalString(args.specExtra, 'args.specExtra');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    return bashCompletionFromOptions({
+        name: args.name,
+        specExtra: args.specExtra,
+        argtypes: args.argtypes,
+        options: this.options
+    });
+};
+
+
+// ---- Bash completion
+
+const BASH_COMPLETION_TEMPLATE_PATH = path.join(
+    __dirname, '../etc/dashdash.bash_completion.in');
+
+/**
+ * Return the Bash completion "spec" (the string value for the "{{spec}}"
+ * var in the "dashdash.bash_completion.in" template) for this tool.
+ *
+ * The "spec" is Bash code that defines the CLI options and subcmds for
+ * the template's completion code. It looks something like this:
+ *
+ *      local cmd_shortopts="-J ..."
+ *      local cmd_longopts="--help ..."
+ *      local cmd_optargs="-p=tritonprofile ..."
+ *
+ * @param args.options {Array} The array of dashdash option specs.
+ * @param args.context {String} Optional. A context string for the "local cmd*"
+ *      vars in the spec. By default it is the empty string. When used to
+ *      scope for completion on a *sub-command* (e.g. for "git log" on a "git"
+ *      tool), then it would have a value (e.g. "__log"). See
+ *      <http://github.com/trentm/node-cmdln> Bash completion for details.
+ * @param opts.includeHidden {Boolean} Optional. Default false. By default
+ *      hidden options and subcmds are "excluded". Here excluded means they
+ *      won't be offered as a completion, but if used, their argument type
+ *      will be completed. "Hidden" options and subcmds are ones with the
+ *      `hidden: true` attribute to exclude them from default help output.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+function bashCompletionSpecFromOptions(args) {
+    assert.object(args, 'args');
+    assert.object(args.options, 'args.options');
+    assert.optionalString(args.context, 'args.context');
+    assert.optionalBool(args.includeHidden, 'args.includeHidden');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    var context = args.context || '';
+    var includeHidden = (args.includeHidden === undefined
+        ? false : args.includeHidden);
+
+    var spec = [];
+    var shortopts = [];
+    var longopts = [];
+    var optargs = [];
+    (args.options || []).forEach(function (o) {
+        if (o.group !== undefined && o.group !== null) {
+            // Skip group headers.
+            return;
+        }
+
+        var optNames = o.names || [o.name];
+        var optType = getOptionType(o.type);
+        if (optType.takesArg) {
+            var completionType = o.completionType ||
+                optType.completionType || o.type;
+            optNames.forEach(function (optName) {
+                if (optName.length === 1) {
+                    if (includeHidden || !o.hidden) {
+                        shortopts.push('-' + optName);
+                    }
+                    // Include even hidden options in `optargs` so that bash
+                    // completion of its arg still works.
+                    optargs.push('-' + optName + '=' + completionType);
+                } else {
+                    if (includeHidden || !o.hidden) {
+                        longopts.push('--' + optName);
+                    }
+                    optargs.push('--' + optName + '=' + completionType);
+                }
+            });
+        } else {
+            optNames.forEach(function (optName) {
+                if (includeHidden || !o.hidden) {
+                    if (optName.length === 1) {
+                        shortopts.push('-' + optName);
+                    } else {
+                        longopts.push('--' + optName);
+                    }
+                }
+            });
+        }
+    });
+
+    spec.push(format('local cmd%s_shortopts="%s"',
+        context, shortopts.sort().join(' ')));
+    spec.push(format('local cmd%s_longopts="%s"',
+        context, longopts.sort().join(' ')));
+    spec.push(format('local cmd%s_optargs="%s"',
+        context, optargs.sort().join(' ')));
+    if (args.argtypes) {
+        spec.push(format('local cmd%s_argtypes="%s"',
+            context, args.argtypes.join(' ')));
+    }
+    return spec.join('\n');
+}
+
+
+/**
+ * Return a string suitable for a Bash completion file for this tool.
+ *
+ * @param args.name {String} The tool name.
+ * @param args.options {Array} The array of dashdash option specs.
+ * @param args.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "examples/ddcompletion.js" for an example.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+function bashCompletionFromOptions(args) {
+    assert.object(args, 'args');
+    assert.object(args.options, 'args.options');
+    assert.string(args.name, 'args.name');
+    assert.optionalString(args.specExtra, 'args.specExtra');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    // Gather template data.
+    var data = {
+        name: args.name,
+        date: new Date(),
+        spec: bashCompletionSpecFromOptions({
+            options: args.options,
+            argtypes: args.argtypes
+        }),
+    };
+    if (args.specExtra) {
+        data.spec += '\n\n' + args.specExtra;
+    }
+
+    // Render template.
+    var template = fs.readFileSync(BASH_COMPLETION_TEMPLATE_PATH, 'utf8');
+    return renderTemplate(template, data);
+}
+
+
 
 // ---- exports
 
@@ -584,8 +950,106 @@ function parse(config) {
     return parser.parse({argv: argv, env: env});
 }
 
+
+/**
+ * Add a new option type.
+ *
+ * @params optionType {Object}:
+ *      - name {String} Required.
+ *      - takesArg {Boolean} Required. Whether this type of option takes an
+ *        argument on process.argv. Typically this is true for all but the
+ *        "bool" type.
+ *      - helpArg {String} Required iff `takesArg === true`. The string to
+ *        show in generated help for options of this type.
+ *      - parseArg {Function} Require. `function (option, optstr, arg)` parser
+ *        that takes a string argument and returns an instance of the
+ *        appropriate type, or throws an error if the arg is invalid.
+ *      - array {Boolean} Optional. Set to true if this is an 'arrayOf' type
+ *        that collects multiple usages of the option in process.argv and
+ *        puts results in an array.
+ *      - arrayFlatten {Boolean} Optional. XXX
+ *      - default Optional. Default value for options of this type, if no
+ *        default is specified in the option type usage.
+ */
+function addOptionType(optionType) {
+    assert.object(optionType, 'optionType');
+    assert.string(optionType.name, 'optionType.name');
+    assert.bool(optionType.takesArg, 'optionType.takesArg');
+    if (optionType.takesArg) {
+        assert.string(optionType.helpArg, 'optionType.helpArg');
+    }
+    assert.func(optionType.parseArg, 'optionType.parseArg');
+    assert.optionalBool(optionType.array, 'optionType.array');
+    assert.optionalBool(optionType.arrayFlatten, 'optionType.arrayFlatten');
+
+    optionTypes[optionType.name] = {
+        takesArg: optionType.takesArg,
+        helpArg: optionType.helpArg,
+        parseArg: optionType.parseArg,
+        array: optionType.array,
+        arrayFlatten: optionType.arrayFlatten,
+        default: optionType.default
+    }
+}
+
+
+function getOptionType(name) {
+    assert.string(name, 'name');
+    return optionTypes[name];
+}
+
+
+/**
+ * Return a synopsis string for the given option spec.
+ *
+ * Examples:
+ *      > synopsisFromOpt({names: ['help', 'h'], type: 'bool'});
+ *      '[ --help | -h ]'
+ *      > synopsisFromOpt({name: 'file', type: 'string', helpArg: 'FILE'});
+ *      '[ --file=FILE ]'
+ */
+function synopsisFromOpt(o) {
+    assert.object(o, 'o');
+
+    if (o.hasOwnProperty('group')) {
+        return null;
+    }
+    var names = o.names || [o.name];
+    // `type` here could be undefined if, for example, the command has a
+    // dashdash option spec with a bogus 'type'.
+    var type = getOptionType(o.type);
+    var helpArg = o.helpArg || (type && type.helpArg) || 'ARG';
+    var parts = [];
+    names.forEach(function (name) {
+        var part = (name.length === 1 ? '-' : '--') + name;
+        if (type && type.takesArg) {
+            part += (name.length === 1 ? ' ' + helpArg : '=' + helpArg);
+        }
+        parts.push(part);
+    });
+    return ('[ ' + parts.join(' | ') + ' ]');
+};
+
+
 module.exports = {
     createParser: createParser,
     Parser: Parser,
-    parse: parse
+    parse: parse,
+    addOptionType: addOptionType,
+    getOptionType: getOptionType,
+    synopsisFromOpt: synopsisFromOpt,
+
+    // Bash completion-related exports
+    BASH_COMPLETION_TEMPLATE_PATH: BASH_COMPLETION_TEMPLATE_PATH,
+    bashCompletionFromOptions: bashCompletionFromOptions,
+    bashCompletionSpecFromOptions: bashCompletionSpecFromOptions,
+
+    // Export the parseFoo parsers because they might be useful as primitives
+    // for custom option types.
+    parseBool: parseBool,
+    parseString: parseString,
+    parseNumber: parseNumber,
+    parseInteger: parseInteger,
+    parsePositiveInteger: parsePositiveInteger,
+    parseDate: parseDate
 };
diff --git a/src/fw/node_modules/fuzzyset.js/README.rst b/src/fw/node_modules/fuzzyset.js/README.rst
new file mode 100755
index 00000000..6705286a
--- /dev/null
+++ b/src/fw/node_modules/fuzzyset.js/README.rst
@@ -0,0 +1,133 @@
+=============================================
+fuzzyset - A fuzzy string set for javascript.
+=============================================
+
+fuzzyset is a data structure that performs something akin to fulltext search
+against data to determine likely mispellings and approximate string matching.
+Note that this is a javascript port of a `python library`_.
+
+Usage
+-----
+
+The usage is simple. Just add a string to the set, and ask for it later
+by using ``.get``::
+
+   a = FuzzySet();
+   a.add("michael axiak");
+   a.get("micael asiak");
+   [[0.8461538461538461, 'michael axiak']];
+
+The result will be an array of ``[score, mached_value]`` arrays.
+The score is between 0 and 1, with 1 being a perfect match.
+
+Construction Arguments
+----------------------
+
+ - array: An array of strings to initialize the data structure with
+ - useLevenshtein: Whether or not to use the levenshtein distance to determine the match scoring. Default: True
+ - gramSizeLower: The lower bound of gram sizes to use, inclusive (see Theory of operation). Default: 2
+ - gramSizeUpper: The upper bound of gram sizes to use, inclusive (see Theory of operation). Default: 3
+
+Methods
+-------
+
+ - get(value, [default]): try to match a string to entries, otherwise return `null` or `default` if it is given.
+ - add(value): add a value to the set returning `false` if it is already in the set.
+ - length(): return the number of items in the set.
+ - isEmpty(): returns true if the set is empty.
+ - values(): returns an array of the values in the set.
+
+Theory of operation
+-------------------
+
+Adding to the data structure
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+First let's look at adding a string, 'michaelich' to an empty set. We first break apart the string into n-grams (strings of length
+n). So trigrams of 'michaelich' would look like::
+
+    '-mi'
+    'mic'
+    'ich'
+    'cha'
+    'hae'
+    'ael'
+    'eli'
+    'lic'
+    'ich'
+    'ch-'
+
+Note that fuzzyset will first normalize the string by removing non word characters except for spaces and commas and force
+everything to be lowercase.
+
+Next the fuzzyset essentially creates a reverse index on those grams. Maintaining a dictionary that says::
+
+     'mic' -> (1, 0)
+     'ich' -> (2, 0)
+     ...
+
+where the first number is the number of grams and the second number is the index of the item in a list that looks like::
+
+    [[3.31, 'michaelich']]
+
+Note that we maintain this reverse index for *all* grams from ``gram_size_lower`` to ``gram_size_upper`` in the constructor.
+This becomes important in a second.
+
+Retrieving
+~~~~~~~~~~
+
+To search the data structure, we take the n-grams of the query string and perform a reverse index look up. To illustrate,
+let's consider looking up ``'michael'`` in our fictitious set containing ``'michaelich'`` where the ``gram_size_upper``
+and ``gram_size_lower`` parameters are default (3 and 2 respectively).
+
+We begin by considering first all trigrams (the value of ``gram_size_upper``). Those grams are::
+
+   '-mi'
+   'mic'
+   'ich'
+   'cha'
+   'el-'
+
+Then we create a list of any element in the set that has *at least one* occurrence of a trigram listed above. Note that
+this is just a dictionary lookup 5 times. For each of these matched elements, we compute the `cosine similarity`_ between
+each element and the query string. We then sort to get the most similar matched elements.
+
+If ``use_levenshtein`` is false, then we return all top matched elements with the same cosine similarity.
+
+If ``use_levenshtein`` is true, then we truncate the possible search space to 50, compute a score based on the levenshtein
+distance (so that we handle transpositions), and return based on that.
+
+In the event that none of the trigrams matched, we try the whole thing again with bigrams (note though that if there are no matches,
+the failure to match will be quick). Bigram searching will always be slower because there will be a much larger set to order.
+
+.. _cosine similarity: http://en.wikipedia.org/wiki/Cosine_similarity
+.. _python library: https://github.com/axiak/fuzzyset
+
+
+Install
+--------
+this::
+
+    <script type="text/javascript" src="/path/to/fuzzyset.js"></script>
+
+or::
+
+    npm install fuzzyset.js
+
+
+
+License
+-------
+
+BSD
+
+Python Author
+--------
+
+Mike Axiak <mike@axiak.net>
+
+
+JavaScript Port Author
+--------
+
+Glen Chiacchieri (http://glench.com)
diff --git a/src/fw/node_modules/fuzzyset.js/index.js b/src/fw/node_modules/fuzzyset.js/index.js
new file mode 100644
index 00000000..ef190ad0
--- /dev/null
+++ b/src/fw/node_modules/fuzzyset.js/index.js
@@ -0,0 +1,288 @@
+(function() {
+
+var FuzzySet = function(arr, useLevenshtein, gramSizeLower, gramSizeUpper) {
+    var fuzzyset = {
+        version: '0.0.1'
+    };
+
+    // default options
+    arr = arr || [];
+    fuzzyset.gramSizeLower = gramSizeLower || 2;
+    fuzzyset.gramSizeUpper = gramSizeUpper || 3;
+    fuzzyset.useLevenshtein = useLevenshtein || true;
+
+    // define all the object functions and attributes
+    fuzzyset.exactSet = {}
+    fuzzyset.matchDict = {};
+    fuzzyset.items = {};
+
+    // helper functions
+    var levenshtein = function(str1, str2) {
+        var current = [], prev, value;
+
+        for (var i = 0; i <= str2.length; i++)
+            for (var j = 0; j <= str1.length; j++) {
+            if (i && j)
+                if (str1.charAt(j - 1) === str2.charAt(i - 1))
+                value = prev;
+                else
+                value = Math.min(current[j], current[j - 1], prev) + 1;
+            else
+                value = i + j;
+
+            prev = current[j];
+            current[j] = value;
+            }
+
+        return current.pop();
+    };
+
+    // return an edit distance from 0 to 1
+    var _distance = function(str1, str2) {
+        if (str1 == null && str2 == null) throw 'Trying to compare two null values'
+        if (str1 == null || str2 == null) return 0;
+        str1 = String(str1); str2 = String(str2);
+
+        var distance = levenshtein(str1, str2);
+        if (str1.length > str2.length) {
+            return 1 - distance / str1.length;
+        } else {
+            return 1 - distance / str2.length;
+        }
+    };
+    var _nonWordRe = /[^\w, ]+/;
+
+    var _iterateGrams = function(value, gramSize) {
+        gramSize = gramSize || 2;
+        var simplified = '-' + value.toLowerCase().replace(_nonWordRe, '') + '-',
+            lenDiff = gramSize - simplified.length,
+            results = [];
+        if (lenDiff > 0) {
+            for (var i = 0; i < lenDiff; ++i) {
+                value += '-';
+            }
+        }
+        for (var i = 0; i < simplified.length - gramSize + 1; ++i) {
+            results.push(simplified.slice(i, i + gramSize))
+        }
+        return results;
+    };
+
+    var _gramCounter = function(value, gramSize) {
+        gramSize = gramSize || 2;
+        var result = {},
+            grams = _iterateGrams(value, gramSize),
+            i = 0;
+        for (i; i < grams.length; ++i) {
+            if (grams[i] in result) {
+                result[grams[i]] += 1;
+            } else {
+                result[grams[i]] = 1;
+            }
+        }
+        return result;
+    };
+
+    // the main functions
+    fuzzyset.get = function(value, defaultValue) {
+        var result = this._get(value);
+        if (!result && defaultValue) {
+            return defaultValue;
+        }
+        return result;
+    };
+
+    fuzzyset._get = function(value) {
+        var normalizedValue = this._normalizeStr(value),
+            result = this.exactSet[normalizedValue];
+        if (result) {
+            return [[1, result]];
+        }
+        var results = [];
+        for (var gramSize = this.gramSizeUpper; gramSize > this.gramSizeLower; --gramSize) {
+            results = this.__get(value, gramSize);
+            if (results) {
+                return results;
+            }
+        }
+        return null;
+    };
+
+    fuzzyset.__get = function(value, gramSize) {
+        var normalizedValue = this._normalizeStr(value),
+            matches = {},
+            gramCounts = _gramCounter(normalizedValue, gramSize),
+            items = this.items[gramSize],
+            sumOfSquareGramCounts = 0,
+            gram,
+            gramCount,
+            i,
+            index,
+            otherGramCount;
+
+        for (gram in gramCounts) {
+            gramCount = gramCounts[gram];
+            sumOfSquareGramCounts += Math.pow(gramCount, 2);
+            if (gram in this.matchDict) {
+                for (i = 0; i < this.matchDict[gram].length; ++i) {
+                    index = this.matchDict[gram][i][0];
+                    otherGramCount = this.matchDict[gram][i][1];
+                    if (index in matches) {
+                        matches[index] += gramCount * otherGramCount;
+                    } else {
+                        matches[index] = gramCount * otherGramCount;
+                    }
+                }
+            }
+        }
+
+        function isEmptyObject(obj) {
+            for(var prop in obj) {
+                if(obj.hasOwnProperty(prop))
+                    return false;
+            }
+            return true;
+        }
+
+        if (isEmptyObject(matches)) {
+            return null;
+        }
+
+        var vectorNormal = Math.sqrt(sumOfSquareGramCounts),
+            results = [],
+            matchScore;
+        // build a results list of [score, str]
+        for (var matchIndex in matches) {
+            matchScore = matches[matchIndex];
+            results.push([matchScore / (vectorNormal * items[matchIndex][0]), items[matchIndex][1]]);
+        }
+        var sortDescending = function(a, b) {
+            if (a[0] < b[0]) {
+                return 1;
+            } else if (a[0] > b[0]) {
+                return -1;
+            } else {
+                return 0;
+            }
+        };
+        results.sort(sortDescending);
+        if (this.useLevenshtein) {
+            var newResults = [],
+                endIndex = Math.min(50, results.length);
+            // truncate somewhat arbitrarily to 50
+            for (var i = 0; i < endIndex; ++i) {
+                newResults.push([_distance(results[i][1], normalizedValue), results[i][1]]);
+            }
+            results = newResults;
+            results.sort(sortDescending);
+        }
+        var newResults = [];
+        for (var i = 0; i < results.length; ++i) {
+            if (results[i][0] == results[0][0]) {
+                newResults.push([results[i][0], this.exactSet[results[i][1]]]);
+            }
+        }
+        return newResults;
+    };
+
+    fuzzyset.add = function(value) {
+        var normalizedValue = this._normalizeStr(value);
+        if (normalizedValue in this.exactSet) {
+            return false;
+        }
+
+        var i = this.gramSizeLower;
+        for (i; i < this.gramSizeUpper + 1; ++i) {
+            this._add(value, i);
+        }
+    };
+
+    fuzzyset._add = function(value, gramSize) {
+        var normalizedValue = this._normalizeStr(value),
+            items = this.items[gramSize] || [],
+            index = items.length;
+
+        items.push(0);
+        var gramCounts = _gramCounter(normalizedValue, gramSize),
+            sumOfSquareGramCounts = 0,
+            gram, gramCount;
+        for (var gram in gramCounts) {
+            gramCount = gramCounts[gram];
+            sumOfSquareGramCounts += Math.pow(gramCount, 2);
+            if (gram in this.matchDict) {
+                this.matchDict[gram].push([index, gramCount]);
+            } else {
+                this.matchDict[gram] = [[index, gramCount]];
+            }
+        }
+        var vectorNormal = Math.sqrt(sumOfSquareGramCounts);
+        items[index] = [vectorNormal, normalizedValue];
+        this.items[gramSize] = items;
+        this.exactSet[normalizedValue] = value;
+    };
+
+    fuzzyset._normalizeStr = function(str) {
+        if (Object.prototype.toString.call(str) !== '[object String]') throw 'Must use a string as argument to FuzzySet functions'
+        return str.toLowerCase();
+    };
+
+    // return length of items in set
+    fuzzyset.length = function() {
+        var count = 0,
+            prop;
+        for (prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                count += 1;
+            }
+        }
+        return count;
+    };
+
+    // return is set is empty
+    fuzzyset.isEmpty = function() {
+        for (var prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                return false;
+            }
+        }
+        return true;
+    };
+
+    // return list of values loaded into set
+    fuzzyset.values = function() {
+        var values = [],
+            prop;
+        for (prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                values.push(this.exactSet[prop])
+            }
+        }
+        return values;
+    };
+
+
+    // initialization
+    var i = fuzzyset.gramSizeLower;
+    for (i; i < fuzzyset.gramSizeUpper + 1; ++i) {
+        fuzzyset.items[i] = [];
+    }
+    // add all the items to the set
+    for (i = 0; i < arr.length; ++i) {
+        fuzzyset.add(arr[i]);
+    }
+
+    return fuzzyset;
+};
+
+var root = this;
+// Export the fuzzyset object for **CommonJS**, with backwards-compatibility
+// for the old `require()` API. If we're not in CommonJS, add `_` to the
+// global object.
+if (typeof module !== 'undefined' && module.exports) {
+    module.exports = FuzzySet;
+    root.FuzzySet = FuzzySet;
+} else {
+    root.FuzzySet = FuzzySet;
+}
+
+})();
diff --git a/src/fw/package.json b/src/fw/package.json
index fe52bd0a..ebb24123 100644
--- a/src/fw/package.json
+++ b/src/fw/package.json
@@ -11,10 +11,10 @@
     "ramsey": "0.1.2"
   },
   "dependencies": {
-    "assert-plus": "0.1.2",
+    "assert-plus": "1.0.0",
     "bunyan": "0.14.6",
     "clone": "0.1.4",
-    "cmdln": "1.1.1",
+    "cmdln": "4.1.1",
     "extsprintf": "1.0.2",
     "mkdirp": "0.3.4",
     "node-uuid": "1.2.0",
diff --git a/src/fw/test/unit/vms.test.js b/src/fw/test/unit/vms.test.js
index 566baa76..3872f941 100644
--- a/src/fw/test/unit/vms.test.js
+++ b/src/fw/test/unit/vms.test.js
@@ -75,7 +75,7 @@ exports.setUp = function (cb) {
 exports['missing vms'] = function (t) {
     fw.vms({ }, function (err, res) {
         t.ok(err, 'error returned');
-        t.equal(err.message, 'opts.vms ([object]) required',
+        t.equal(err.message, 'opts.vms ([object]) is required',
             'error message');
         return t.done();
     });
diff --git a/src/fw/tools/bin/rebuild-node-modules b/src/fw/tools/bin/rebuild-node-modules
index a378661a..c820621a 100755
--- a/src/fw/tools/bin/rebuild-node-modules
+++ b/src/fw/tools/bin/rebuild-node-modules
@@ -55,7 +55,11 @@ cp ${NM_ORIG}/cmdln/LICENSE.txt ${NM}/cmdln/
 
 mkdir ${NM}/dashdash
 cp ${NM_ORIG}/cmdln/node_modules/dashdash/lib/dashdash.js ${NM}/dashdash/index.js
-cp ${NM_ORIG}/cmdln/node_modules/dashdash/LICENSE.txt ${NM}/dashdash/LICENSE.txt
+cp ${NM_ORIG}/cmdln/node_modules/dashdash/README.md ${NM}/dashdash/README.md
+
+mkdir ${NM}/fuzzyset.js
+cp ${NM_ORIG}/cmdln/node_modules/fuzzyset.js/lib/fuzzyset.js ${NM}/fuzzyset.js/index.js
+cp ${NM_ORIG}/cmdln/node_modules/fuzzyset.js/README.rst ${NM}/fuzzyset.js/README.rst
 
 mkdir ${NM}/carrier
 cp ${NM_ORIG}/tab/node_modules/carrier/lib/carrier.js ${NM}/carrier/index.js
diff --git a/src/manifest b/src/manifest
index d0778447..3add9888 100644
--- a/src/manifest
+++ b/src/manifest
@@ -557,6 +557,7 @@ d usr/fw/node_modules/carrier 0555 root bin
 d usr/fw/node_modules/clone 0555 root bin
 d usr/fw/node_modules/cmdln 0555 root bin
 d usr/fw/node_modules/dashdash 0555 root bin
+d usr/fw/node_modules/fuzzyset.js 0555 root bin
 d usr/fw/node_modules/fwrule 0555 root bin
 d usr/fw/node_modules/strsplit 0555 root bin
 d usr/fw/sbin 0555 root bin
@@ -584,7 +585,9 @@ f usr/fw/node_modules/clone/index.js 0444 root bin
 f usr/fw/node_modules/cmdln/index.js 0444 root bin
 f usr/fw/node_modules/cmdln/LICENSE.txt 0444 root bin
 f usr/fw/node_modules/dashdash/index.js 0444 root bin
-f usr/fw/node_modules/dashdash/LICENSE.txt 0444 root bin
+f usr/fw/node_modules/dashdash/README.md 0444 root bin
+f usr/fw/node_modules/fuzzyset.js/README.rst 0444 root bin
+f usr/fw/node_modules/fuzzyset.js/index.js 0444 root bin
 f usr/fw/node_modules/dtrace-provider.js 0444 root bin
 f usr/fw/node_modules/DTraceProviderBindings.node 0444 root bin
 f usr/fw/node_modules/fwrule/index.js 0444 root bin
-- 
2.21.0

