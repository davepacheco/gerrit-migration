From f592eaaa4d630b4a508c29940bf5f89ba4efcb95 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 4 Aug 2016 01:24:51 +0000
Subject: [PATCH] FWAPI-164 Move fwadm(1M) to new node-cmdln FWAPI-245
 Arguments placed before fwadm(1M) subcommands are ignored Reviewed by: Trent
 Mick <trent.mick@joyent.com> Approved by: Alex Wilson
 <alex.wilson@joyent.com>

---
 src/fw/lib/cli.js                          |   15 +-
 src/fw/lib/fwadm.js                        |  283 +++--
 src/fw/man/fwadm.1m.md                     |   21 +-
 src/fw/man/fwadm.1m.md.in                  |   21 +-
 src/fw/man/fwrule.5.footer                 |    2 +-
 src/fw/man/fwrule.5.md                     |    2 +-
 src/fw/node_modules/assert-plus/README.md  |   78 +-
 src/fw/node_modules/assert-plus/index.js   |  335 ++---
 src/fw/node_modules/cmdln/index.js         | 1294 ++++++++++++++++++--
 src/fw/node_modules/dashdash.js            | 1055 ++++++++++++++++
 src/fw/node_modules/dashdash/LICENSE.txt   |   24 -
 src/fw/node_modules/dashdash/index.js      |  591 ---------
 src/fw/node_modules/fuzzyset.js/README.rst |  133 ++
 src/fw/node_modules/fuzzyset.js/index.js   |  288 +++++
 src/fw/node_modules/verror.js              |  106 +-
 src/fw/package.json                        |    7 +-
 src/fw/test/unit/vms.test.js               |    2 +-
 src/fw/tools/bin/rebuild-node-modules      |    8 +-
 src/manifest                               |    7 +-
 19 files changed, 3234 insertions(+), 1038 deletions(-)
 create mode 100644 src/fw/node_modules/dashdash.js
 delete mode 100644 src/fw/node_modules/dashdash/LICENSE.txt
 delete mode 100644 src/fw/node_modules/dashdash/index.js
 create mode 100755 src/fw/node_modules/fuzzyset.js/README.rst
 create mode 100644 src/fw/node_modules/fuzzyset.js/index.js

diff --git a/src/fw/lib/cli.js b/src/fw/lib/cli.js
index e93d8a08..1dfb1778 100644
--- a/src/fw/lib/cli.js
+++ b/src/fw/lib/cli.js
@@ -20,12 +20,13 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: CLI shared logic
  */
 
+var cmdln = require('cmdln');
 var fs = require('fs');
 var tab = require('tab');
 var tty = require('tty');
@@ -148,7 +149,8 @@ function getPayload(opts, args, callback) {
             rule: args.join(' ')
         };
 
-        return callback(null, payload);
+        callback(null, payload);
+        return;
     }
 
     if (!file && !tty.isatty(0)) {
@@ -156,7 +158,8 @@ function getPayload(opts, args, callback) {
     }
 
     if (!file) {
-        return callback(new verror.VError('Must supply file!'));
+        callback(new cmdln.UsageError('Must supply file!'));
+        return;
     }
 
     if (file === '-') {
@@ -217,6 +220,9 @@ function outputError(err, opts) {
                 if (opts.verbose) {
                     j.stack = e.stack;
                 }
+                if (e.cmdlnErrHelpFromErr) {
+                    j.help = cmdln.errHelpFromErr(e);
+                }
                 return j;
             })
         }));
@@ -227,6 +233,9 @@ function outputError(err, opts) {
         if (opts && opts.verbose) {
             console.error(e.stack);
         }
+        if (e.cmdlnErrHelpFromErr) {
+            console.error('\n' + cmdln.errHelpFromErr(e));
+        }
     });
 }
 
diff --git a/src/fw/lib/fwadm.js b/src/fw/lib/fwadm.js
index 1d2dd4c0..1e3aff00 100644
--- a/src/fw/lib/fwadm.js
+++ b/src/fw/lib/fwadm.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: CLI logic
@@ -36,6 +36,7 @@ var path = require('path');
 var pipeline = require('./pipeline').pipeline;
 var util = require('util');
 var util_log = require('./util/log');
+var util_obj = require('./util/obj');
 var vasync = require('vasync');
 var verror = require('verror');
 var VM = require('/usr/vm/node_modules/VM');
@@ -56,11 +57,13 @@ var OPTS = {
     delim: {
         names: ['delim', 'd'],
         type: 'string',
+        helpArg: '<char>',
         help: 'Output delimiter.'
     },
     description: {
         names: ['description', 'desc' ],
         type: 'string',
+        helpArg: '<str>',
         help: 'Rule description.'
     },
     enable: {
@@ -71,6 +74,7 @@ var OPTS = {
     file: {
         names: ['file', 'f'],
         type: 'string',
+        helpArg: '<file>',
         help: 'Input file.'
     },
     global: {
@@ -91,11 +95,13 @@ var OPTS = {
     output_fields: {
         names: ['fields', 'o'],
         type: 'string',
+        helpArg: '<fields>',
         help: 'Output field list'
     },
     owner_uuid: {
         names: ['owner_uuid', 'O'],
         type: 'string',
+        helpArg: '<uuid>',
         help: 'Owner UUID'
     },
     parseable: {
@@ -280,8 +286,30 @@ function Fwadm() {
     cmdln.Cmdln.call(this, {
         name: 'fwadm',
         desc: 'Manage firewall rules',
-        options: [ OPTS.help, OPTS.json, OPTS.dryrun, OPTS.stdout,
-            OPTS.verbose ]
+        helpSubcmds: [
+            'add',
+            'delete',
+            'disable',
+            'enable',
+            'get',
+            'list',
+            'update',
+            'vms',
+            { group: '' },
+            'add-rvm',
+            'delete-rvm',
+            'get-rvm',
+            'list-rvms',
+            'rvm-rules',
+            { group: '' },
+            'rules',
+            'start',
+            'status',
+            'stats',
+            'stop',
+            { group: '', unmatched: true }
+        ],
+        options: [ OPTS.help, OPTS.json, OPTS.verbose ]
     });
 }
 
@@ -319,7 +347,7 @@ Fwadm.prototype.do_add = function (subcmd, opts, args, callback) {
 /**
  * Adds a remote VM
  */
-Fwadm.prototype['do_add-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_add_rvm = function (subcmd, opts, args, callback) {
     LOG = util_log.create({ action: 'add' });
 
     pipeline({
@@ -361,21 +389,19 @@ Fwadm.prototype.do_list = function (subcmd, opts, args, callback) {
     }
 
     if (opts.delim && !opts.parseable) {
-        var delimErr = new Error('-d requires -p');
-        cli.outputError(delimErr, opts);
-        return callback(delimErr);
+        callback(new cmdln.UsageError('-d requires -p'));
+        return;
     }
 
     if (opts.json && opts.parseable) {
-        var fmtErr = new Error('cannot specify both -j and -p');
-        cli.outputError(fmtErr, opts);
-        return callback(fmtErr);
+        callback(new cmdln.UsageError('cannot specify both -j and -p'));
+        return;
     }
 
     LOG = util_log.create({ action: 'list' }, true);
     listOpts.log = LOG;
 
-    return fw.list(listOpts, function (err, res) {
+    fw.list(listOpts, function (err, res) {
         cli.displayRules(err, res, opts);
         return callback(err);
     });
@@ -385,7 +411,7 @@ Fwadm.prototype.do_list = function (subcmd, opts, args, callback) {
 /**
  * Lists remote VMs
  */
-Fwadm.prototype['do_list-rvms'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_list_rvms = function (subcmd, opts, args, callback) {
     LOG = util_log.create({ action: 'listRemoteVMs' }, true);
 
     // XXX: support filtering, sorting
@@ -410,10 +436,10 @@ Fwadm.prototype.do_update = function (subcmd, opts, args, callback) {
         id = args.shift();
     }
 
-    return cli.getPayload(opts, args, function (err, payload) {
+    cli.getPayload(opts, args, function (err, payload) {
         if (err) {
-            cli.outputError(err, opts);
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var updatePayload = preparePayload(opts, payload);
@@ -425,7 +451,7 @@ Fwadm.prototype.do_update = function (subcmd, opts, args, callback) {
             updatePayload.rules[0].uuid = cli.validateUUID(id);
         }
 
-        return doUpdate(opts, updatePayload, 'Updated', callback);
+        doUpdate(opts, updatePayload, 'Updated', callback);
     });
 };
 
@@ -452,7 +478,7 @@ Fwadm.prototype.do_get = function (subcmd, opts, args, callback) {
 /**
  * Gets a remote VM
  */
-Fwadm.prototype['do_get-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_get_rvm = function (subcmd, opts, args, callback) {
     var uuid = cli.validateUUID(args[0]);
     LOG = util_log.create({ action: 'getRemoteVM' }, true);
 
@@ -474,14 +500,15 @@ Fwadm.prototype['do_get-rvm'] = function (subcmd, opts, args, callback) {
 function enableDisable(subcmd, opts, args, callback) {
     var enabled = subcmd === 'enable';
     if (args.length === 0) {
-        return callback(new Error('Must specify rules to enable!'));
+        callback(new cmdln.UsageError('Must specify rules to enable!'));
+        return;
     }
 
     var rules = args.map(function (uuid) {
         return { uuid: cli.validateUUID(uuid), enabled: enabled };
     });
 
-    return doUpdate(opts, preparePayload(opts, { rules: rules }),
+    doUpdate(opts, preparePayload(opts, { rules: rules }),
         enabled ? 'Enabled' : 'Disabled', callback);
 }
 
@@ -490,6 +517,7 @@ Fwadm.prototype.do_enable = function () {
     enableDisable.apply(this, arguments);
 };
 
+
 Fwadm.prototype.do_disable = function () {
     enableDisable.apply(this, arguments);
 };
@@ -529,7 +557,7 @@ Fwadm.prototype.do_delete = function (subcmd, opts, args, callback) {
 /**
  * Deletes a remote VM
  */
-Fwadm.prototype['do_delete-rvm'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_delete_rvm = function (subcmd, opts, args, callback) {
     if (args.length === 0) {
         return console.error('Must specify remote VMs to delete!');
     }
@@ -560,7 +588,7 @@ Fwadm.prototype['do_delete-rvm'] = function (subcmd, opts, args, callback) {
 /**
  * Gets the rules that apply to a remote VM
  */
-Fwadm.prototype['do_rvm-rules'] = function (subcmd, opts, args, callback) {
+Fwadm.prototype.do_rvm_rules = function (subcmd, opts, args, callback) {
     var uuid = cli.validateUUID(args[0]);
     LOG = util_log.create({ action: 'rvmRules' }, true);
 
@@ -706,17 +734,6 @@ Fwadm.prototype.do_vms = function (subcmd, opts, args, callback) {
     });
 };
 
-var ARG_OPTS;
-
-/**
- * Run before any of the do_* methods
- */
-Fwadm.prototype.init = function (opts, args, callback) {
-    ARG_OPTS = opts;
-    return callback();
-
-};
-
 
 
 // --- Help text and other cmdln options
@@ -724,46 +741,149 @@ Fwadm.prototype.init = function (opts, args, callback) {
 
 
 var HELP = {
-    add: 'add firewall rules or remote VMs',
-    'add-rvm': 'add a remote VM',
-    delete: 'delete a rule',
-    'delete-rvm': 'delete a remote VM',
-    disable: 'disable a rule',
-    enable: 'enable a rule',
-    get: 'get a rule',
-    'get-rvm': 'get a remote VM',
-    list: 'list rules',
-    'list-rvms': 'list remote VMs',
-    rules: 'list rules that apply to a VM',
-    'rvm-rules': 'list rules that apply to a remote VM',
-    start: 'start a VM\'s firewall',
-    status: 'get the status of a VM\'s firewall',
-    stats: 'get rule statistics for a VM\'s firewall',
-    stop: 'stop a VM\'s firewall',
-    update: 'update firewall rules or data',
-    vms: 'list the UUIDs of VMs affected by a rule'
+    add: {
+        summary: 'Add firewall rules or remote VMs.',
+        synopses: [
+            '{{name}} {{cmd}} -f <file>',
+            '{{name}} {{cmd}} [-e] [--desc <description>] '
+                + '[-g] [-O <owner uuid>] <rule>'
+        ],
+        options: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
+            OPTS.owner_uuid ],
+        examples: '    fwadm add -e -O $USER_UUID FROM any TO all vms ALLOW udp'
+            + ' PORTS 67, 68\n'
+            + '    fwadm add -g -e FROM any TO all vms ALLOW tcp PORT 22\n'
+            + '    fwadm add <<EOF\n'
+            + '    {\n'
+            + '      "rules": [ {\n'
+            + '        "description": "allow all ICMPv6 types",\n'
+            + '        "rule": "FROM any TO all vms ALLOW icmp6 type all",\n'
+            + '        "enabled": true,\n'
+            + '        "global": true\n'
+            + '      } ]\n'
+            + '    }\n'
+            + '    EOF\n'
+    },
+    add_rvm: {
+        summary: 'Add a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS]' ],
+        options: [ OPTS.file ]
+    },
+    delete: {
+        summary: 'Delete a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    },
+    delete_rvm: {
+        summary: 'Delete a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    disable: {
+        summary: 'Disable a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    enable: {
+        summary: 'Enable a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    get: {
+        summary: 'Get a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    },
+    get_rvm: {
+        summary: 'Get a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    list: {
+        summary: 'List rules.',
+        synopses: [
+            '{{name}} {{cmd}} [OPTIONS] -p [-d <char>]',
+            '{{name}} {{cmd}} [OPTIONS] -j'
+        ],
+        options: [ OPTS.delim, OPTS.output_fields, OPTS.parseable ]
+    },
+    list_rvms: {
+        summary: 'List remote VMs.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS]' ]
+    },
+    rules: {
+        summary: 'List rules that apply to a VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    rvm_rules: {
+        summary: 'List rules that apply to a remote VM.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rvm uuid>' ]
+    },
+    start: {
+        summary: 'Start a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    status: {
+        summary: 'Get the status of a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    stats: {
+        summary: 'Get rule statistics for a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    stop: {
+        summary: 'Stop a VM\'s firewall.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <vm uuid>' ]
+    },
+    update: {
+        summary: 'Update firewall rules or data.',
+        synopses: [
+            '{{name}} {{cmd}} -f <file>',
+            '{{name}} {{cmd}} <rule uuid> [-e] [--desc <description>] [-g] \\\n'
+                + '    [-O <owner uuid>] <rule>'
+        ],
+        options: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
+            OPTS.owner_uuid ]
+    },
+    vms: {
+        summary: 'List the UUIDs of VMs affected by a rule.',
+        synopses: [ '{{name}} {{cmd}} [OPTIONS] <rule uuid>' ]
+    }
 };
 
-var EXTRA_OPTS = {
-    add: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
-        OPTS.owner_uuid ],
-    'add-rvm': [ OPTS.file ],
-    list: [ OPTS.delim, OPTS.output_fields, OPTS.parseable ],
-    update: [ OPTS.description, OPTS.enable, OPTS.file, OPTS.global,
-        OPTS.owner_uuid ]
-};
+
+/**
+ * Wrap a subcommand function with common checks
+ */
+function wrapSubcmd(func) {
+    return function (subcmd, opts, args, callback) {
+        if (opts.help) {
+            this.do_help('help', {}, [ subcmd ], callback);
+            return;
+        }
+
+        opts = this.opts = util_obj.mergeObjects(this.opts, opts);
+
+        onlyif.rootInSmartosGlobal(function (err) {
+            if (err) {
+                console.error('FATAL: cannot run: %s', err);
+                return process.exit(2);
+            }
+
+            func(subcmd, opts, args, callback);
+        });
+    };
+}
+
 
 // Help text and options for all commands
 for (var cmd in HELP) {
-    var proto = Fwadm.prototype['do_' + cmd];
-    proto.help = HELP[cmd];
-    if (!EXTRA_OPTS.hasOwnProperty(cmd)) {
-        EXTRA_OPTS[cmd] = [];
+    var do_key = 'do_' + cmd;
+    var info = HELP[cmd];
+    var proto = Fwadm.prototype[do_key];
+    proto = Fwadm.prototype[do_key] = wrapSubcmd(proto);
+    proto.help = info.summary + '\n\n{{usage}}\n\n{{options}}';
+    if (info.hasOwnProperty('examples')) {
+        proto.help += '\n\nExamples:\n\n' + info.examples;
     }
 
-    EXTRA_OPTS[cmd] = EXTRA_OPTS[cmd].concat([
-        OPTS.dryrun, OPTS.json, OPTS.stdout, OPTS.verbose ]);
-    proto.options = EXTRA_OPTS[cmd];
+    proto.synopses = info.synopses;
+    proto.options = (info.options || []).concat([
+        OPTS.help, OPTS.dryrun, OPTS.json, OPTS.stdout, OPTS.verbose ]);
 }
 
 
@@ -776,30 +896,23 @@ for (var cmd in HELP) {
  * Main entry point
  */
 function main() {
-    onlyif.rootInSmartosGlobal(function (err) {
-        if (err) {
-            console.error('FATAL: cannot run: %s', err);
-            return process.exit(2);
+    var fwadm = new Fwadm();
+    fwadm.main(process.argv, function (err2) {
+        if (err2 && !cli.haveOutputErr()) {
+            cli.outputError(err2, fwadm.opts);
+            // This is a usage error - no need to flush logs
+            process.exit(2);
         }
 
-        var fwadm = new Fwadm;
-        fwadm.main(process.argv, function (err2) {
-            if (err2 && !cli.haveOutputErr()) {
-                cli.outputError(err2, ARG_OPTS);
-                // This is a usage error - no need to flush logs
-                process.exit(2);
+        // Potentially 3 different logs to flush: if we've only used
+        // fw.js, just flush LOG.  If we've gone through VM.update
+        // (for start / stop), we need to flush VM.log and VM.fw_log.
+        util_log.flush([LOG, VM.log, VM.fw_log], function () {
+            if (cli.haveOutputErr()) {
+                process.exit(1);
             }
 
-            // Potentially 3 different logs to flush: if we've only used
-            // fw.js, just flush LOG.  If we've gone through VM.update
-            // (for start / stop), we need to flush VM.log and VM.fw_log.
-            util_log.flush([LOG, VM.log, VM.fw_log], function () {
-                if (cli.haveOutputErr()) {
-                    process.exit(1);
-                }
-
-                process.exit(0);
-            });
+            process.exit(0);
         });
     });
 }
diff --git a/src/fw/man/fwadm.1m.md b/src/fw/man/fwadm.1m.md
index f37deed4..22fe3d1d 100644
--- a/src/fw/man/fwadm.1m.md
+++ b/src/fw/man/fwadm.1m.md
@@ -1,4 +1,4 @@
-# fwadm(1m) -- Manage SmartOS firewall rules
+# fwadm(1M) -- Manage SmartOS firewall rules
 
 
 ## SYNOPSIS
@@ -202,7 +202,8 @@ the firewalls of any VMs affected.
             
 
     fwadm update -f <file>
-    fwadm update [-e] [--desc <description>] [-g] [-O <owner uuid>] <rule>
+    fwadm update <rule uuid> [-e] [--desc <description>] [-g] \
+        [-O <owner uuid>] <rule>
 
         Update firewall rules or remote VMs.  A single rule and its properties
         can be updated using arguments, or the -f option can be used to pass a
@@ -224,8 +225,8 @@ the firewalls of any VMs affected.
                                     that were updated.
 
         Arguments:
-            <rule>                  Firewall rule, written in the rule DSL.  See
-                                    fwrule(5) for syntax.
+            <rule>                  Firewall rule, written in the rule DSL.
+                                    See fwrule(5) for syntax.
 
         Examples:
             # Update a rule by specifying it on the commandline.
@@ -371,7 +372,7 @@ the firewalls of any VMs affected.
 
 ## REMOTE VM PROPERTIES
 
-    Remote VMs are simplified versions of the VM objects used by vmadm(1m).
+    Remote VMs are simplified versions of the VM objects used by vmadm(1M).
     They are also in a JSON format, but only the properties below will be
     stored and used by fwadm. All other properties will be discarded. The
     properties used are:
@@ -384,7 +385,7 @@ the firewalls of any VMs affected.
 
     nics:
 
-        Array of nics, as per vmadm(1m). Only the "ip" property of each of
+        Array of nics, as per vmadm(1M). Only the "ip" property of each of
         these nic objects is required - all other properties will be ignored.
         This property is used for creation of remote VMs only - it is not
         stored in the object. IPs from these objects will be added to the ips
@@ -398,12 +399,12 @@ the firewalls of any VMs affected.
 
     tags:
 
-        vmadm(1m) tags object, mapping tag keys to values.
+        vmadm(1M) tags object, mapping tag keys to values.
 
     uuid (required):
 
         UUID. This must not be the same as the UUID of any other remote VM or
-        local VM managed by vmadm(1m).
+        local VM managed by vmadm(1M).
 
     Note that VMs can be added and updated in this simplified representation,
     or using the same representation as "vmadm get". This enables the output
@@ -413,7 +414,7 @@ the firewalls of any VMs affected.
 
 ## INTERACTION WITH VMADM(1M)
 
-    fwadm relies on properties of VMs from vmadm(1m) in order to generate
+    fwadm relies on properties of VMs from vmadm(1M) in order to generate
     firewall rules correctly. Therefore, when vmadm is used to create a new
     VM or update properties on an existing VM that can affect firewall rules,
     it will update firewall rules through fwadm accordingly.
@@ -483,4 +484,4 @@ The following exit values are returned:
 
 ## SEE ALSO
 
-    vmadm(1m), fwrule(5), ipf(1m), ipfilter(5)
+    vmadm(1M), fwrule(5), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwadm.1m.md.in b/src/fw/man/fwadm.1m.md.in
index cb7eab8b..8b45c5d5 100644
--- a/src/fw/man/fwadm.1m.md.in
+++ b/src/fw/man/fwadm.1m.md.in
@@ -1,4 +1,4 @@
-# fwadm(1m) -- Manage SmartOS firewall rules
+# fwadm(1M) -- Manage SmartOS firewall rules
 
 
 ## SYNOPSIS
@@ -188,7 +188,8 @@ the firewalls of any VMs affected.
 
 
     fwadm update -f <file>
-    fwadm update [-e] [--desc <description>] [-g] [-O <owner uuid>] <rule>
+    fwadm update <rule uuid> [-e] [--desc <description>] [-g] \
+        [-O <owner uuid>] <rule>
 
         Update firewall rules or remote VMs.  A single rule and its properties
         can be updated using arguments, or the -f option can be used to pass a
@@ -210,8 +211,8 @@ the firewalls of any VMs affected.
                                     that were updated.
 
         Arguments:
-            <rule>                  Firewall rule, written in the rule DSL.  See
-                                    fwrule(5) for syntax.
+            <rule>                  Firewall rule, written in the rule DSL.
+                                    See fwrule(5) for syntax.
 
         Examples:
             {{#indent_and_wrap}}
@@ -335,7 +336,7 @@ the firewalls of any VMs affected.
 
 ## REMOTE VM PROPERTIES
 
-    Remote VMs are simplified versions of the VM objects used by vmadm(1m).
+    Remote VMs are simplified versions of the VM objects used by vmadm(1M).
     They are also in a JSON format, but only the properties below will be
     stored and used by fwadm. All other properties will be discarded. The
     properties used are:
@@ -348,7 +349,7 @@ the firewalls of any VMs affected.
 
     nics:
 
-        Array of nics, as per vmadm(1m). Only the "ip" property of each of
+        Array of nics, as per vmadm(1M). Only the "ip" property of each of
         these nic objects is required - all other properties will be ignored.
         This property is used for creation of remote VMs only - it is not
         stored in the object. IPs from these objects will be added to the ips
@@ -362,12 +363,12 @@ the firewalls of any VMs affected.
 
     tags:
 
-        vmadm(1m) tags object, mapping tag keys to values.
+        vmadm(1M) tags object, mapping tag keys to values.
 
     uuid (required):
 
         UUID. This must not be the same as the UUID of any other remote VM or
-        local VM managed by vmadm(1m).
+        local VM managed by vmadm(1M).
 
     Note that VMs can be added and updated in this simplified representation,
     or using the same representation as "vmadm get". This enables the output
@@ -377,7 +378,7 @@ the firewalls of any VMs affected.
 
 ## INTERACTION WITH VMADM(1M)
 
-    fwadm relies on properties of VMs from vmadm(1m) in order to generate
+    fwadm relies on properties of VMs from vmadm(1M) in order to generate
     firewall rules correctly. Therefore, when vmadm is used to create a new
     VM or update properties on an existing VM that can affect firewall rules,
     it will update firewall rules through fwadm accordingly.
@@ -418,4 +419,4 @@ The following exit values are returned:
 
 ## SEE ALSO
 
-    vmadm(1m), fwrule(5), ipf(1m), ipfilter(5)
+    vmadm(1M), fwrule(5), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwrule.5.footer b/src/fw/man/fwrule.5.footer
index f10b991f..3272f277 100644
--- a/src/fw/man/fwrule.5.footer
+++ b/src/fw/man/fwrule.5.footer
@@ -1,4 +1,4 @@
 
 ## SEE ALSO
 
-    fwadm(1m), vmadm(1m), ipf(1m), ipfilter(5)
+    fwadm(1M), vmadm(1M), ipf(1M), ipfilter(5)
diff --git a/src/fw/man/fwrule.5.md b/src/fw/man/fwrule.5.md
index 4b38f110..820dfb05 100644
--- a/src/fw/man/fwrule.5.md
+++ b/src/fw/man/fwrule.5.md
@@ -323,4 +323,4 @@ Some examples of rules that would cause this message include:
 
 ## SEE ALSO
 
-    fwadm(1m), vmadm(1m), ipf(1m), ipfilter(5)
+    fwadm(1M), vmadm(1M), ipf(1M), ipfilter(5)
diff --git a/src/fw/node_modules/assert-plus/README.md b/src/fw/node_modules/assert-plus/README.md
index c0c3a530..ec200d16 100644
--- a/src/fw/node_modules/assert-plus/README.md
+++ b/src/fw/node_modules/assert-plus/README.md
@@ -1,24 +1,26 @@
-# node-assert-plus
+# assert-plus
 
 This library is a super small wrapper over node's assert module that has two
 things: (1) the ability to disable assertions with the environment variable
-NODE_NDEBUG, and (2) some API wrappers for argument testing.  Like
+NODE\_NDEBUG, and (2) some API wrappers for argument testing.  Like
 `assert.string(myArg, 'myArg')`.  As a simple example, most of my code looks
 like this:
 
+```javascript
     var assert = require('assert-plus');
 
     function fooAccount(options, callback) {
-	    assert.object(options, 'options');
-		assert.number(options.id, 'options.id);
-		assert.bool(options.isManager, 'options.isManager');
-		assert.string(options.name, 'options.name');
-		assert.arrayOfString(options.email, 'options.email');
-		assert.func(callback, 'callback');
+        assert.object(options, 'options');
+        assert.number(options.id, 'options.id');
+        assert.bool(options.isManager, 'options.isManager');
+        assert.string(options.name, 'options.name');
+        assert.arrayOfString(options.email, 'options.email');
+        assert.func(callback, 'callback');
 
         // Do stuff
-		callback(null, {});
+        callback(null, {});
     }
+```
 
 # API
 
@@ -27,60 +29,94 @@ take an argument, and then a string 'name' that's not a message; `AssertionError
 will be thrown if the assertion fails with a message like:
 
     AssertionError: foo (string) is required
-	at test (/home/mark/work/foo/foo.js:3:9)
-	at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
-	at Module._compile (module.js:446:26)
-	at Object..js (module.js:464:10)
-	at Module.load (module.js:353:31)
-	at Function._load (module.js:311:12)
-	at Array.0 (module.js:484:10)
-	at EventEmitter._tickCallback (node.js:190:38)
+    at test (/home/mark/work/foo/foo.js:3:9)
+    at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
+    at Module._compile (module.js:446:26)
+    at Object..js (module.js:464:10)
+    at Module.load (module.js:353:31)
+    at Function._load (module.js:311:12)
+    at Array.0 (module.js:484:10)
+    at EventEmitter._tickCallback (node.js:190:38)
 
 from:
 
+```javascript
     function test(foo) {
-	    assert.string(foo, 'foo');
+        assert.string(foo, 'foo');
     }
+```
 
-There you go.  You can check that arrays are of a homogenous type with `Arrayof$Type`:
+There you go.  You can check that arrays are of a homogeneous type with `Arrayof$Type`:
 
+```javascript
     function test(foo) {
-	    assert.arrayOfString(foo, 'foo');
+        assert.arrayOfString(foo, 'foo');
     }
+```
 
 You can assert IFF an argument is not `undefined` (i.e., an optional arg):
 
+```javascript
     assert.optionalString(foo, 'foo');
+```
 
 Lastly, you can opt-out of assertion checking altogether by setting the
 environment variable `NODE_NDEBUG=1`.  This is pseudo-useful if you have
 lots of assertions, and don't want to pay `typeof ()` taxes to v8 in
-production.
+production.  Be advised:  The standard functions re-exported from `assert` are
+also disabled in assert-plus if NDEBUG is specified.  Using them directly from
+the `assert` module avoids this behavior.
 
 The complete list of APIs is:
 
+* assert.array
 * assert.bool
 * assert.buffer
 * assert.func
 * assert.number
+* assert.finite
 * assert.object
 * assert.string
+* assert.stream
+* assert.date
+* assert.regexp
+* assert.uuid
+* assert.arrayOfArray
 * assert.arrayOfBool
+* assert.arrayOfBuffer
 * assert.arrayOfFunc
 * assert.arrayOfNumber
+* assert.arrayOfFinite
 * assert.arrayOfObject
 * assert.arrayOfString
+* assert.arrayOfStream
+* assert.arrayOfDate
+* assert.arrayOfRegexp
+* assert.arrayOfUuid
+* assert.optionalArray
 * assert.optionalBool
 * assert.optionalBuffer
 * assert.optionalFunc
 * assert.optionalNumber
+* assert.optionalFinite
 * assert.optionalObject
 * assert.optionalString
+* assert.optionalStream
+* assert.optionalDate
+* assert.optionalRegexp
+* assert.optionalUuid
+* assert.optionalArrayOfArray
 * assert.optionalArrayOfBool
+* assert.optionalArrayOfBuffer
 * assert.optionalArrayOfFunc
 * assert.optionalArrayOfNumber
+* assert.optionalArrayOfFinite
 * assert.optionalArrayOfObject
 * assert.optionalArrayOfString
+* assert.optionalArrayOfStream
+* assert.optionalArrayOfDate
+* assert.optionalArrayOfRegexp
+* assert.optionalArrayOfUuid
 * assert.AssertionError
 * assert.fail
 * assert.ok
diff --git a/src/fw/node_modules/assert-plus/index.js b/src/fw/node_modules/assert-plus/index.js
index 70583f12..26f944ee 100644
--- a/src/fw/node_modules/assert-plus/index.js
+++ b/src/fw/node_modules/assert-plus/index.js
@@ -1,196 +1,211 @@
 // Copyright (c) 2012, Mark Cavage. All rights reserved.
+// Copyright 2015 Joyent, Inc.
 
 var assert = require('assert');
 var Stream = require('stream').Stream;
 var util = require('util');
 
 
-
 ///--- Globals
 
-var NDEBUG = process.env.NODE_NDEBUG || false;
-
-
-
-///--- Messages
-
-var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
-var TYPE_REQUIRED = '%s (%s) is required';
-
+/* JSSTYLED */
+var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
 
 
 ///--- Internal
 
-function capitalize(str) {
-        return (str.charAt(0).toUpperCase() + str.slice(1));
+function _capitalize(str) {
+    return (str.charAt(0).toUpperCase() + str.slice(1));
 }
 
-function uncapitalize(str) {
-        return (str.charAt(0).toLowerCase() + str.slice(1));
+function _toss(name, expected, oper, arg, actual) {
+    throw new assert.AssertionError({
+        message: util.format('%s (%s) is required', name, expected),
+        actual: (actual === undefined) ? typeof (arg) : actual(arg),
+        expected: expected,
+        operator: oper || '===',
+        stackStartFunction: _toss.caller
+    });
 }
 
-function _() {
-        return (util.format.apply(util, arguments));
+function _getClass(arg) {
+    return (Object.prototype.toString.call(arg).slice(8, -1));
 }
 
-
-function _assert(arg, type, name, stackFunc) {
-        if (!NDEBUG) {
-                name = name || type;
-                stackFunc = stackFunc || _assert.caller;
-                var t = typeof (arg);
-
-                if (t !== type) {
-                        throw new assert.AssertionError({
-                                message: _(TYPE_REQUIRED, name, type),
-                                actual: t,
-                                expected: type,
-                                operator: '===',
-                                stackStartFunction: stackFunc
-                        });
-                }
-        }
+function noop() {
+    // Why even bother with asserts?
 }
 
 
+///--- Exports
 
-///--- API
-
-function array(arr, type, name) {
-        if (!NDEBUG) {
-                name = name || type;
-
-                if (!Array.isArray(arr)) {
-                        throw new assert.AssertionError({
-                                message: _(ARRAY_TYPE_REQUIRED, name, type),
-                                actual: typeof (arr),
-                                expected: 'array',
-                                operator: 'Array.isArray',
-                                stackStartFunction: array.caller
-                        });
-                }
-
-                for (var i = 0; i < arr.length; i++) {
-                        _assert(arr[i], type, name, array);
-                }
+var types = {
+    bool: {
+        check: function (arg) { return typeof (arg) === 'boolean'; }
+    },
+    func: {
+        check: function (arg) { return typeof (arg) === 'function'; }
+    },
+    string: {
+        check: function (arg) { return typeof (arg) === 'string'; }
+    },
+    object: {
+        check: function (arg) {
+            return typeof (arg) === 'object' && arg !== null;
         }
-}
-
-
-function bool(arg, name) {
-        _assert(arg, 'boolean', name, bool);
-}
-
-
-function buffer(arg, name) {
-        if (!Buffer.isBuffer(arg)) {
-                throw new assert.AssertionError({
-                        message: _(TYPE_REQUIRED, name, type),
-                        actual: typeof (arg),
-                        expected: 'buffer',
-                        operator: 'Buffer.isBuffer',
-                        stackStartFunction: buffer
-                });
+    },
+    number: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg);
         }
-}
-
-
-function func(arg, name) {
-        _assert(arg, 'function', name);
-}
-
-
-function number(arg, name) {
-        _assert(arg, 'number', name);
-}
-
-
-function object(arg, name) {
-        _assert(arg, 'object', name);
-}
-
-
-function stream(arg, name) {
-        if (!(arg instanceof Stream)) {
-                throw new assert.AssertionError({
-                        message: _(TYPE_REQUIRED, name, type),
-                        actual: typeof (arg),
-                        expected: 'Stream',
-                        operator: 'instanceof',
-                        stackStartFunction: buffer
-                });
+    },
+    finite: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
         }
-}
-
-
-function string(arg, name) {
-        _assert(arg, 'string', name);
-}
-
-
-
-///--- Exports
-
-module.exports = {
-        bool: bool,
-        buffer: buffer,
-        func: func,
-        number: number,
-        object: object,
-        stream: stream,
-        string: string
+    },
+    buffer: {
+        check: function (arg) { return Buffer.isBuffer(arg); },
+        operator: 'Buffer.isBuffer'
+    },
+    array: {
+        check: function (arg) { return Array.isArray(arg); },
+        operator: 'Array.isArray'
+    },
+    stream: {
+        check: function (arg) { return arg instanceof Stream; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    date: {
+        check: function (arg) { return arg instanceof Date; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    regexp: {
+        check: function (arg) { return arg instanceof RegExp; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    uuid: {
+        check: function (arg) {
+            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
+        },
+        operator: 'isUUID'
+    }
 };
 
+function _setExports(ndebug) {
+    var keys = Object.keys(types);
+    var out;
+
+    /* re-export standard assert */
+    if (process.env.NODE_NDEBUG) {
+        out = noop;
+    } else {
+        out = function (arg, msg) {
+            if (!arg) {
+                _toss(msg, 'true', arg);
+            }
+        };
+    }
 
-Object.keys(module.exports).forEach(function (k) {
-        if (k === 'buffer')
+    /* standard checks */
+    keys.forEach(function (k) {
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        var type = types[k];
+        out[k] = function (arg, msg) {
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* optional checks */
+    keys.forEach(function (k) {
+        var name = 'optional' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
                 return;
-
-        var name = 'arrayOf' + capitalize(k);
-
-        if (k === 'bool')
-                k = 'boolean';
-        if (k === 'func')
-                k = 'function';
-        module.exports[name] = function (arg, name) {
-                array(arg, k, name);
+            }
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
         };
-});
-
-Object.keys(module.exports).forEach(function (k) {
-        var _name = 'optional' + capitalize(k);
-        var s = uncapitalize(k.replace('arrayOf', ''));
-        if (s === 'bool')
-                s = 'boolean';
-        if (s === 'func')
-                s = 'function';
-
-        if (k.indexOf('arrayOf') !== -1) {
-          module.exports[_name] = function (arg, name) {
-                  if (!NDEBUG && arg !== undefined) {
-                          array(arg, s, name);
-                  }
-          };
-        } else {
-          module.exports[_name] = function (arg, name) {
-                  if (!NDEBUG && arg !== undefined) {
-                          _assert(arg, s, name);
-                  }
-          };
+    });
+
+    /* arrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'arrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
         }
-});
-
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* optionalArrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'optionalArrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
 
-// Reexport built-in assertions
-Object.keys(assert).forEach(function (k) {
+    /* re-export built-in assertions */
+    Object.keys(assert).forEach(function (k) {
         if (k === 'AssertionError') {
-                module.exports[k] = assert[k];
-                return;
+            out[k] = assert[k];
+            return;
+        }
+        if (ndebug) {
+            out[k] = noop;
+            return;
         }
+        out[k] = assert[k];
+    });
 
-        module.exports[k] = function () {
-                if (!NDEBUG) {
-                        assert[k].apply(assert[k], arguments);
-                }
-        };
-});
+    /* export ourselves (for unit tests _only_) */
+    out._setExports = _setExports;
+
+    return out;
+}
+
+module.exports = _setExports(process.env.NODE_NDEBUG);
diff --git a/src/fw/node_modules/cmdln/index.js b/src/fw/node_modules/cmdln/index.js
index 5a6e281a..95b99b6e 100644
--- a/src/fw/node_modules/cmdln/index.js
+++ b/src/fw/node_modules/cmdln/index.js
@@ -1,6 +1,5 @@
 /*
- * Copyright (c) 2013, Trent Mick. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016 Trent Mick
  */
 
 var DEBUG = false;
@@ -26,6 +25,7 @@ var dashdash = require('dashdash');
 var sprintf = require('extsprintf').sprintf;
 
 
+
 // ---- globals
 
 var DEFAULT_OPTIONS = [
@@ -36,10 +36,22 @@ var DEFAULT_OPTIONS = [
     }
 ];
 
+var DEFAULT_SYNOPSES = [
+    '{{name}} [OPTIONS] COMMAND [ARGS...]',
+    '{{name}} help COMMAND'
+];
 
 
 // ---- internal support stuff
 
+function indent(s, indentation) {
+    if (!indentation) {
+        indentation = '    ';
+    }
+    var lines = s.split(/\r?\n/g);
+    return indentation + lines.join('\n' + indentation);
+}
+
 function space(n) {
     var s = '';
     for (var i = 0; i < n; i++) {
@@ -48,12 +60,41 @@ function space(n) {
     return s;
 }
 
-function objCopy(obj) {
-    var copy = {};
+function objCopy(obj, target) {
+    if (!target) {
+        target = {};
+    }
     Object.keys(obj).forEach(function (k) {
-        copy[k] = obj[k];
+        target[k] = obj[k];
+    });
+    return target;
+}
+
+/**
+ * Return a new object that is a shallow merge of all the given objects.
+ * Last one wins. Example:
+ *
+ *  > objMerge({"a":1,"b":2}, {"b":3,"c":4});
+ *  { a: 1, b: 3, c: 4 }
+ */
+function objMerge(/* ... */) {
+    var merged = {};
+    for (var i = 0; i < arguments.length; i++) {
+        var obj = arguments[i];
+        var keys = Object.keys(obj);
+        for (var k = 0; k < keys.length; k++) {
+            merged[keys[k]] = obj[keys[k]];
+        }
+    }
+    return merged;
+}
+
+
+// Replace {{variable}} in `s` with the template data in `d`.
+function renderTemplate(s, d) {
+    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {
+        return d.hasOwnProperty(key) ? d[key] : match;
     });
-    return copy;
 }
 
 
@@ -87,26 +128,130 @@ function CmdlnError(options) {
     });
 }
 util.inherits(CmdlnError, WError);
+CmdlnError.prototype.name = 'CmdlnError';
+
 
-function OptionError(cause, subcmd) {
+/*
+ * An error returned when there is an error parsing a command or subcmd's
+ * options.
+ */
+function OptionError(cause) {
     assert.object(cause, 'cause');
-    assert.optionalString(subcmd, 'subcmd');
     CmdlnError.call(this, {
         cause: cause,
         message: cause.message,
         code: 'Option',
-        exitStatus: 1,
-        subcmd: subcmd
+        exitStatus: 1
     });
 }
+
 util.inherits(OptionError, CmdlnError);
+OptionError.prototype.name = 'OptionError';
+
+/**
+ * Attempt to give an appropriate 'usage: ...' errHelp that shows all
+ * the options. E.g.:
+ *
+ *     $ triton inst tag set -123
+ *     triton instance tag set: error (Option): unknown option: "-1" in "-1...
+ *     usage: triton instance tag set [-h | --help] [-f FILE | --file=FILE]
+ *         [-w | --wait] [--wait-timeout=INT] [-j | --json] [-q | --quiet] ...
+ *
+ * Notes:
+ * - This does NOT use `synopses` because, at least in my current typical
+ *   usage, the synopses just show `[OPTIONS]` instead of expliclity listing
+ *   all the options.
+ * - The above indentation is intentional (as opposed to `git --help`s) in
+ *   case the command name is long.
+ */
+OptionError.prototype.cmdlnErrHelpFromErr = function optionErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    var errHelp = '';
+
+    var options = (err._cmdlnHandler || err._cmdlnInst).options;
+    if (options) {
+        var lines = [];
+        var line = 'usage: ' + nameFromErr(err);
+        for (var i = 0; i < options.length; i++) {
+            var synopsis = dashdash.synopsisFromOpt(options[i]);
+            if (!synopsis) {
+                continue;
+            } else if (line.length === 0) {
+                line += '    ' + synopsis;
+            } else if (line.length + synopsis.length + 1 > 80) {
+                lines.push(line);
+                line = '    ' + synopsis;
+            } else {
+                line += ' ' + synopsis;
+            }
+        }
+        lines.push(line + ' ...');  // The "..." for the args.
+        errHelp = lines.join('\n');
+    }
+
+
+    return errHelp;
+};
+
+
+/*
+ * An error returned when there is a subcmd usage error (wrong args).
+ *
+ *      new UsageError(<message>);
+ *      new UsageError(<cause>, <message>);
+ */
+function UsageError(cause, message) {
+    if (message === undefined) {
+        message = cause;
+        cause = undefined;
+    }
+    assert.optionalObject(cause, 'cause');
+    assert.string(message, 'message');
+    CmdlnError.call(this, {
+        cause: cause,
+        message: message,
+        code: 'Usage',
+        exitStatus: 1
+    });
+}
+
+util.inherits(UsageError, CmdlnError);
+UsageError.prototype.name = 'UsageError';
+
+/**
+ * Show a 'usage: ...' errHelp using the command's `synopses`. E.g.:
+ *
+ *     $ triton inst list foo
+ *     triton instance list: error (Usage): invalid filter: "foo" ...
+ *     usage: triton instance list [OPTIONS] [FILTERS...]
+ */
+UsageError.prototype.cmdlnErrHelpFromErr = function usageErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    var errHelp = '';
+    var synopses = err._cmdlnInst.synopsesFromSubcmd(
+        err._cmdlnSubcmd || err._cmdlnInst);
+    if (synopses.length === 1) {
+        errHelp = 'usage: ' + synopses[0];
+    } else if (synopses.length > 1) {
+        errHelp = 'usage:\n    ' + synopses.join('\n    ');
+    }
+    return errHelp;
+};
+
 
 function UnknownCommandError(cause, command) {
     if (command === undefined) {
         command = cause;
         cause = undefined;
     }
-    assert.string(command);
+    assert.string(command, 'command');
+    this.command = command;
     CmdlnError.call(this, {
         cause: cause,
         message: sprintf('unknown command: "%s"', command),
@@ -114,8 +259,145 @@ function UnknownCommandError(cause, command) {
         exitStatus: 1
     });
 }
+
 util.inherits(UnknownCommandError, CmdlnError);
+UnknownCommandError.prototype.name = 'UnknownCommandError';
 
+/**
+ * Show an errHelp for possible intended commands, assuming a typo. E.g.:
+ *
+ *     $ triton ins
+ *     triton: error (UnknownCommand): unknown command: "ins"
+ *     Did you mean this?
+ *         inst
+ *         instance
+ */
+UnknownCommandError.prototype.cmdlnErrHelpFromErr =
+        function ucErrHelpFromErr(err) {
+    if (!err || !err._cmdlnInst) {
+        return '';
+    }
+
+    try {
+        var FuzzySet = require('fuzzyset.js');
+    } catch (requireErr) {
+        return '';
+    }
+
+    var errHelp = '';
+    var aliases = FuzzySet(Object.keys(err._cmdlnInst._nameFromAlias));
+    var candidates = aliases.get(this.command); // array of [score, alias];
+    var ge50 = [];
+    candidates && candidates.forEach(function (candidate) {
+        if (candidate[0] >= 0.3) {
+            ge50.push(candidate[1]);
+        }
+    });
+    if (ge50.length > 0) {
+        errHelp = 'Did you mean this?\n    ' + ge50.join('\n    ');
+    }
+
+    return errHelp;
+};
+
+
+function NoCommandError() {
+    CmdlnError.call(this, {
+        message: 'no command given',
+        code: 'NoCommand',
+        exitStatus: 1
+    });
+}
+util.inherits(NoCommandError, CmdlnError);
+NoCommandError.prototype.name = 'NoCommandError';
+
+
+/**
+ * # errHelp
+ *
+ * Sometimes, for some CLI errors, it is nice to print brief help info after
+ * the error message. E.g.:
+ *
+ *      $ ls -D
+ *      ls: illegal option -- D
+ *  >   usage: ls [-ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1] [file ...]
+ *
+ *      $ git foo
+ *      git: 'foo' is not a git command. See 'git --help'.
+ *
+ *  >   Did you mean this?
+ *  >          fo
+ *
+ * This module calls that `errHelp`. This function will attempt to determine
+ * reasonable errHelp from an `err` returned by `<cmdln>.main()`. By default
+ * errHelp is implemented for some of this module's error classes:
+ *
+ * - OptionError: Show a synopsis of the command's options.
+ * - UsageError: Show the command's synopses, if available.
+ * - UnknownCommandError: List possible fuzzy matches.
+ *
+ *
+ * # usage
+ *
+ * 1. Optionally set `synopses` on your `do_SUBCMD` handlers. E.g.:
+ *
+ *      do_list.synopses = ['{{name}} list [OPTIONS] [FILTERS...]'];
+ *
+ *    Note that `{{usage}}` in your command help output will expand to these
+ *    synopses.
+ *
+ * 2. Use `cmdln.errHelpFromErr()` in your mainline something like this:
+ *
+ *      var cmdln = require('cmdln');
+ *      var cli = new MyCmdlnSubclass();
+ *      cli.main(argv, function (err) {
+ *          if (err) {
+ *              console.error('%s: error: %s', cli.name, err.message);
+ *              var errHelp = cmdln.errHelpFromErr(err);
+ *              if (errHelp) {
+ *                  console.error(errHelp);
+ *              }
+ *          }
+ *      });
+ *
+ *    Or use the convenience top-level `cmdln.main()` function, which does
+ *    similar.
+ *
+ *
+ * @param {Object} err: Error returned from `<cmdln>.main()`. The main
+ *      function adds some cmdln-specific context properties to the returned
+ *      err object. This function uses those properties.
+ * @returns {String} Error help string, if any, else the empty string.
+ */
+function errHelpFromErr(err) {
+    assert.object(err, 'err');
+    var errHelp;
+
+    if (err && typeof (err.cmdlnErrHelpFromErr) === 'function') {
+        errHelp = err.cmdlnErrHelpFromErr(err);
+    }
+
+    return (errHelp || '');
+};
+
+
+/**
+ * Return the full command name (e.g. 'triton instance list') at which the
+ * error occurred, from an `err` instance returned by `<cmdln>.main()`.
+ */
+function nameFromErr(err) {
+    assert.object(err, 'err');
+    assert.object(err._cmdlnInst, 'err._cmdlnInst');
+    var name = err._cmdlnInst.name;
+    if (err._cmdlnHandler) {
+        if (typeof (err._cmdlnHandler) === 'object') {
+            name = err._cmdlnHandler.name;
+        } else if (err._cmdlnSubcmd) {
+            name += ' ' + err._cmdlnSubcmd;
+        }
+    }
+    return name;
+}
 
 
 // ---- Cmdln object
@@ -128,9 +410,29 @@ util.inherits(UnknownCommandError, CmdlnError);
  *        name.
  *      - @param desc {String} Description string to include at the top of
  *        usage information.
+ *      - @param synopses {Array} Optional array of synopses for the command.
+ *        Synopses are used for the `{{usage}}` template var in help output
+ *        and for `errHelp` for `UsageError`s. If not given the default will be:
+ *          `['{{name}} [OPTIONS] COMMAND [ARGS...]', '{{name}} help COMMAND']`
  *      - @param helpOpts {Object} Help output formatting options. These
  *        are the same formatting options as for `dashdash.Parser.help`:
  *        indent, maxCol, helpCol, minHelpCol, maxHelpCol (TODO:doc).
+ *      - @param helpBody {String} Extra string content to put at the end of
+ *        help output.
+ *      - @param helpSubcmds {Array} Control the output of the "Commands:"
+ *        section of top-level help output. By default all commands are
+ *        listed in the order defined in code. `helpSubcmds` allows one to
+ *        specify the order and, optionally, groupings with group headers. E.g.:
+ *              helpSubcmds: [
+ *                  'help',
+ *                  { group: '' },   // an empty group, results in a blank line
+ *                  'foo',
+ *                  'bar',
+ *                  { group: 'Bling' }, // a group header
+ *                  'bloom',
+ *                  // Use `unmatched: true` to include remaining subcmds.
+ *                  { group: 'Other Commands', unmatched: true }
+ *              ]
  *      - @param options {Array} Custom options (in the format used by
  *        [dashdash](https://github.com/trentm/node-dashdash)). If not
  *        specified, then it defaults to a single -h/--help option.
@@ -138,10 +440,10 @@ util.inherits(UnknownCommandError, CmdlnError);
  *        override the base `init(opts, args, callback)` to act on those
  *        options after being parsed.
  *
- * XXX hooks for adding help ? instead of automatic?
+ * TODO: hooks for adding help ? instead of automatic?
  *      - @param helpCmd {Boolean} Whether to include the `help` subcommand.
  *        Default true.
- *      - XXX take optional bunyan logger
+ * TODO: take optional bunyan logger for trace logging
  */
 function Cmdln(config) {
     var self = this;
@@ -150,20 +452,35 @@ function Cmdln(config) {
     assert.optionalString(config.name, 'config.name')
     assert.optionalString(config.desc, 'config.desc')
     assert.optionalArrayOfObject(config.options, 'config.options');
+    assert.optionalArrayOfString(config.synopses, 'config.synopses');
     assert.optionalObject(config.helpOpts, 'config.helpOpts')
+    assert.optionalString(config.helpBody, 'config.helpBody')
+    assert.optionalObject(config.helpSubcmds, 'config.helpSubcmds');
 
     this.name = config.name || this.constructor.name.toLowerCase();
     this.desc = config.desc;
+    this.synopses = config.synopses || DEFAULT_SYNOPSES;
     this.options = config.options || DEFAULT_OPTIONS;
     this.helpOpts = config.helpOpts || {};
+    this.helpBody = config.helpBody;
+    this.helpSubcmds = config.helpSubcmds || null;
     if (!this.helpOpts.indent)
         this.helpOpts.indent = space(4);
     else if (typeof (this.helpOpts.indent) === 'number')
         this.helpOpts.indent = space(this.helpOpts.indent);
+    if (!this.helpOpts.groupIndent) {
+        var gilen = Math.round(this.helpOpts.indent.length / 2);
+        this.helpOpts.groupIndent = space(gilen);
+    } else if (typeof (this.helpOpts.groupIndent) === 'number') {
+        this.helpOpts.groupIndent = space(this.helpOpts.groupIndent);
+    }
     if (!this.helpOpts.maxCol) this.helpOpts.maxCol = 80;
     if (!this.helpOpts.minHelpCol) this.helpOpts.minHelpCol = 20;
     if (!this.helpOpts.maxHelpCol) this.helpOpts.maxHelpCol = 40;
 
+    this.optParser = new dashdash.Parser(
+        {options: this.options, interspersed: false});
+
     // Find the tree of constructors (typically just this and the Cmdln
     // super class) on who's prototype to look for "do_*" and "help_*"
     // methods.
@@ -176,26 +493,134 @@ function Cmdln(config) {
     prototypes.reverse();
 
     // Load subcmds (do_* methods) and aliases (`do_*.aliases`).
-    this.subcmdOrder = [];
-    this.subcmds = {};
-    this.aliases = {};
+    var enumOrder = [];
+    this._handlerFromName = {};
+    this._nameFromAlias = {};
     prototypes.forEach(function (proto) {
         Object.keys(proto)
             .filter(function (funcname) { return /^do_/.test(funcname); })
             .forEach(function (funcname) {
-                var name = funcname.slice(3);
+                var name = self.subcmdFromFuncname(funcname);
                 var func = proto[funcname];
-                self.subcmds[name] = func;
-                self.subcmdOrder.push(name);
-                self.aliases[name] = name;
-                (func.aliases || []).forEach(function (alias) {
-                    self.aliases[alias] = name;
+                var allAliases;
+                if (func.prototype.__proto__ === Cmdln.prototype) {
+                    /**
+                     * This is a `Cmdln` sub-class. Create the sub-Cmdln
+                     * instance and use that as the handler.
+                     *
+                     * Limitation: This doesn't catch multi-level inheritance
+                     * from `Cmdln`.
+                     *
+                     * Also validate which properties are allowed to be
+                     * set on the *constructor*, e.g.:
+                     *      Top.prototype.do_sub = Sub
+                     *      Top.prototype.do_sub.<property> = ...
+                     * vs. not allowed, because they must be set on the `Sub`
+                     * itself:
+                     *      function Sub(top) {
+                     *          Cmdln.call(this, {name: ..., options: ...})
+                     *      }
+                     */
+                    ['options', 'help'].forEach(function (prop) {
+                        if (func.hasOwnProperty(prop)) {
+                            throw new Error(format(
+                                'cannot set "%s.prototype.do_%s.%s" property '
+                                + 'because "do_%s" is a sub-Cmdln handler',
+                                self.constructor.name, name, prop, name));
+                        }
+                    });
+                    var handler = new func(self);
+                    // Copy class properies like 'alias', 'hidden', etc.
+                    for (prop in func) {
+                        if (prop === 'super_')
+                            continue;
+                        handler[prop] = func[prop];
+                    }
+                    self._handlerFromName[name] = handler;
+                } else {
+                    self._handlerFromName[name] = func;
+                }
+                if (!self._handlerFromName[name].hidden) {
+                    enumOrder.push(name);
+                }
+                self._nameFromAlias[name] = name;
+                allAliases = func.aliases || [];
+                if (func.hiddenAliases)
+                    allAliases = allAliases.concat(func.hiddenAliases);
+                allAliases.forEach(function (alias) {
+                    if (self._nameFromAlias[alias]) {
+                        throw new Error(format('ambiguous alias "%s": ' +
+                            'refers to commands "%s" and "%s"', alias,
+                            name, self._nameFromAlias[alias]));
+                    }
+                    self._nameFromAlias[alias] = name;
                 });
             });
     });
-    // p('subcmdOrder:', this.subcmdOrder);
-    // p('subcmds: ', this.subcmds);
-    // p('aliases: ', this.aliases);
+
+    if (self.helpSubcmds !== null) {
+        /*
+         * Reconcile the provided subcommand order (and group headings) with
+         * the discovered options.
+         */
+        var unmatchedNames = [];
+        var matchedNames = [];
+        enumOrder.forEach(function (enumName) {
+            if (self.helpSubcmds.indexOf(enumName) === -1) {
+                unmatchedNames.push(enumName);
+            } else {
+                matchedNames.push(enumName);
+            }
+        });
+
+        var unmatchCount = 0;
+        self._subcmdOrder = [];
+        self.helpSubcmds.forEach(function (sc) {
+            if (typeof (sc) === 'object') {
+                assert.string(sc.group, 'helpSubcmds.*.group');
+                assert.optionalBool(sc.unmatched, 'helpSubcmds.*.unmatched');
+
+                self._subcmdOrder.push(sc);
+
+                if (sc.unmatched) {
+                    if (++unmatchCount > 1) {
+                        throw (new Error(format('"unmatched" directive used ' +
+                            'more than once in "helpSubcmds" option: %j', sc)));
+                    }
+
+                    /*
+                     * Include all of the unmatched names here:
+                     */
+                    while (unmatchedNames.length > 0) {
+                        self._subcmdOrder.push(unmatchedNames.shift());
+                    }
+                }
+                return;
+            }
+
+            /*
+             * If this is not a group heading object, it must be the name
+             * of a handler to include in the output:
+             */
+            assert.string(sc);
+            if (matchedNames.indexOf(sc) === -1) {
+                throw (new Error('command handler included in help order ' +
+                    'but not found: ' + sc));
+            }
+            self._subcmdOrder.push(sc);
+        });
+
+        if (unmatchedNames.length > 0) {
+            throw (new Error('"helpSubcmds" error: unmatched command ' +
+                'handlers found: ' + unmatchedNames.join(', ') + '.'));
+        }
+    } else {
+        self._subcmdOrder = enumOrder;
+    }
+
+    // p('_subcmdOrder:', this._subcmdOrder);
+    // p('_handlerFromName: ', this._handlerFromName);
+    // p('_nameFromAlias: ', this._nameFromAlias);
 }
 
 
@@ -203,47 +628,269 @@ function Cmdln(config) {
  * Cmdln mainline.
  *
  * @param argv {Array}
- * @param callback {Function} `function (err)`
+ * @param cb {Function} `function (err)` where err is an error object if
+ *      there was a problem. The following properties are added to a
+ *      returned `err`. These add context used by `errHelpFromErr`
+ *      and `nameFromErr`.
+ *
+ * Dev Notes: The relevant *private* members added for this context are:
+ * - `err._cmdlnInst`: The Cmdln instance on which the error occurred.
+ *   For single-level subcommands, this will always be the top Cmdln
+ *   instance on which `main` was called. However for tools with
+ *   nested Cmdln's (e.g. `mytool some-subcmd some-subsubcmd`) it
+ *   might be that nested Cmdln.
+ * - `err._cmdlnSubcmd` and `err._cmdlnHandler`: If appropriate, this is
+ *   the subcmd handler on which the error occurred. This might be a
+ *   `do_SUBCMD` handler *function* or a Cmdln subcmd handler *object*.
+ *   If the error happened before a subcmd handler was selected, then
+ *   this isn't set.
  */
-Cmdln.prototype.main = function main(argv, callback) {
+Cmdln.prototype.main = function cmdlnMain(argv, cb) {
     var self = this;
+    assert.arrayOfString(argv, 'argv');
+    assert.func(cb, 'cb');
+
+    var decoErrAndCb = function (err) {
+        if (err && !err._cmdlnInst) {
+            err._cmdlnInst = self;
+        }
+        cb(err);
+    };
+
+    var finiAndCb = function (err, subcmd) {
+        debug('-> <%s>.fini(%j, err=%s)', self.name, subcmd, err);
+        self.fini(subcmd, err, function (finiErr) {
+            debug('<- <%s>.fini: finiErr=%s', self.name, finiErr);
+            decoErrAndCb(finiErr || err);
+        });
+    }
+
     try {
-        this.optParser = new dashdash.Parser(
-            {options: this.options, interspersed: false});
         this.opts = this.optParser.parse(argv);
     } catch (e) {
-        callback(new OptionError(e));
+        decoErrAndCb(new OptionError(e));
+        return;
     }
     var args = this.opts._args;
 
-    debug('-> init(%j, %j)', this.opts, args);
+    debug('-> <%s>.init(%j, %j)', self.name, this.opts, args);
     self.init(this.opts, args, function (initErr) {
-        debug('<- init(%s)', initErr)
+        debug('<- <%s>.init: initErr=%s', self.name, initErr)
         if (initErr) {
-            callback(initErr);
+            finiAndCb(initErr);
             return;
         } else if (initErr === false) {
-            //XXX How to handle non-zero exit here? Special error?
-            //    StopProcessingError?
-            callback();
+            // TODO: How to handle non-zero exit here? Special error?
+            // StopProcessingError?
+            finiAndCb();
             return
         }
 
         if (args.length === 0) {
-            self.printHelp(function (helpErr) { callback(helpErr); });
+            self.emptyLine(finiAndCb);
             return;
         }
 
         var subcmdArgv = argv.slice(0, 2).concat(args);
         var subcmd = args.shift();
         try {
-            debug('-> dispatch(%j, %j)', subcmd, subcmdArgv);
-            self.dispatch(subcmd, subcmdArgv,
-                function (dispErr) { callback(dispErr); });
+            debug('-> <%s>.dispatch({subcmd: %j, argv: %j})',
+                self.name, subcmd, subcmdArgv);
+            self.dispatch({subcmd: subcmd, argv: subcmdArgv},
+                function (dispErr) {
+                    debug('<- <%s>.dispatch: dispErr=%s',
+                        self.name, dispErr);
+                    /*
+                     * Do in nextTick to assure that we do not callback twice
+                     * if (a) dispatch returns synchronously and (b) there is
+                     * an exception raised during `finiAndCb`.
+                     */
+                    process.nextTick(function () {
+                        finiAndCb(dispErr, subcmd);
+                    });
+                });
         } catch (ex) {
-            callback(ex);
+            debug('<- <%s>.dispatch crash: ex=%s', self.name, ex);
+            finiAndCb(ex, subcmd);
+        }
+    });
+
+};
+
+
+/* BEGIN JSSTYLED */
+/**
+ * Return a Bash completion "spec" for this CLI.
+ *
+ * The Bash completion "spec" is the var that gets interpolated into the
+ * "dashdash.bash_completion.in" template. It is Bash code that defines the
+ * CLI options and subcmds for the template's completion code. It looks
+ * something like this:
+ *
+ *      # Top-level.
+ *      local cmd_shortopts="-J ..."
+ *      local cmd_longopts="--help ..."
+ *      local cmd_optargs="-p=tritonprofile ..."
+ *      local cmd_subcmds="account create list ..."
+ *      local cmd_allsubcmds="account hiddensub create list ..."
+ *
+ *      # The "TOOL instance ..." subcommand.
+ *      local cmd__instance_shortopts="-h"
+ *      local cmd__instance_longopts="--help"
+ *      local cmd__instance_optargs=""
+ *      local cmd__instance_subcmds="help list ls get ..."
+ *      local cmd__instance_allsubcmds="help list ls get ..."
+ *
+ *      # The "TOOL instance list" sub-subcommand.
+ *      local cmd__instance__list_shortopts="-h -H -o -l -s -j"
+ *      local cmd__instance__list_longopts="--help --long --json"
+ *      local cmd__instance__list_optargs="-o= -s="
+ *
+ *      # ...
+ *
+ *      # Optional completion functions for types referenced in "optargs" vars.
+ *      # There is no requirement to have a completion function for every
+ *      # type.
+ *      function complete_tritonprofile {
+ *          local word="$1"
+ *          local candidates
+ *          candidates=$(ls -1 ~/.triton/profiles.d/*.json 2>/dev/null \
+ *              | sed -E 's/^.*\/([ \/]+)\.json$/\1/')
+ *          compgen $compgen_opts -W "$candidates" -- "$word"
+ *      }
+ *
+ * @param opts.context {String} Optional context string for the "local cmd*"
+ *      vars. For example, for the "instance" subcommand above,
+ *      `context="__instance"`.
+ * @param opts.includeHidden {Boolean} Optional. Default false. By default
+ *      hidden options and subcmds are "excluded". Here excluded means they
+ *      won't be offered as a completion, but if used, their argument type
+ *      will be completed. "Hidden" options and subcmds are ones with the
+ *      `hidden: true` attribute to exclude them from default help output.
+ */
+/* END JSSTYLED */
+Cmdln.prototype.bashCompletionSpec = function bashCompletionSpec(opts) {
+    var self = this;
+    if (!opts) {
+        opts = {};
+    }
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.context, 'opts.context');
+    assert.optionalBool(opts.includeHidden, 'opts.includeHidden');
+
+    var spec = [];
+    var context = opts.context || '';
+    var includeHidden = (opts.includeHidden === undefined
+        ? false : opts.includeHidden);
+
+    // Top-level.
+    spec.push(dashdash.bashCompletionSpecFromOptions({
+        options: self.options,
+        context: context,
+        includeHidden: includeHidden
+    }));
+
+    var aliases = [];
+    var allAliases = [];
+    Object.keys(this._nameFromAlias).sort().forEach(function (alias) {
+        if (alias === '?') {
+            // '?' as a Bash completion is painful. Also, '?' as a default
+            // alias for 'help' should die.
+            return;
+        }
+
+        var name = self._nameFromAlias[alias];
+        var handler = self._handlerFromName[name];
+
+        if (includeHidden || !handler.hidden) {
+            aliases.push(alias);
+        }
+        allAliases.push(alias);
+    });
+    spec.push(format('local cmd%s_subcmds="%s"', context, aliases.join(' ')));
+    spec.push(format('local cmd%s_allsubcmds="%s"', context,
+        allAliases.join(' ')));
+
+    // Subcmds.
+    // We include completion info even for "hidden" subcmds, so that once
+    // one has specified a hidden subcmd you get full completion under it.
+    Object.keys(this._nameFromAlias).sort().forEach(function (alias) {
+        if (alias === '?') {
+            return;
+        }
+        spec.push('');
+        var context_ = context + '__' + alias.replace(/-/g, '_');
+        var name = self._nameFromAlias[alias];
+        var handler = self._handlerFromName[name];
+
+        if (typeof (handler.bashCompletionSpec) === 'function') {
+            // This is a `Cmdln` subclass, i.e. a sub-CLI.
+            var subspec = handler.bashCompletionSpec({context: context_});
+            if (subspec) {
+                spec.push(subspec);
+            }
+        } else {
+            if (handler.completionArgtypes) {
+                assert.arrayOfString(handler.completionArgtypes,
+                    'do_' + name + '.completionArgtypes');
+                spec.push(format('local cmd%s_argtypes="%s"',
+                    context_, handler.completionArgtypes.join(' ')));
+            }
+            spec.push(dashdash.bashCompletionSpecFromOptions({
+                options: handler.options || [],
+                context: context_,
+                includeHidden: includeHidden
+            }));
         }
     });
+
+    return spec.join('\n');
+}
+
+/**
+ * Generate and return Bash completion for this Cmdln subclass instance.
+ *
+ * @param opts.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "node-dashdash/examples/ddcompletion.js" for an example.
+ */
+Cmdln.prototype.bashCompletion = function bashCompletion(opts) {
+    if (!opts) {
+        opts = {};
+    }
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.specExtra, 'opts.specExtra');
+
+    // Gather template data.
+    var data = {
+        name: this.name,
+        date: new Date(),
+        spec: this.bashCompletionSpec()
+    };
+    if (opts.specExtra) {
+        data.spec += '\n\n' + opts.specExtra;
+    }
+
+    // Render template.
+    var template = fs.readFileSync(
+        dashdash.BASH_COMPLETION_TEMPLATE_PATH, 'utf8');
+    return renderTemplate(template, data);
+};
+
+
+/**
+ * Handler called for an empty line of input. By default this prints help
+ * output and returns a `NoCommandError` (exitStatus == 1).
+ *
+ * Dev Note: Equiv to python-cmdln's Cmdln.emptyline.
+ *
+ * @param callback {Function} `function (err)`
+ */
+Cmdln.prototype.emptyLine = function emptyLine(callback) {
+    this.printHelp(function (helpErr) {
+        callback(helpErr || new NoCommandError());
+    });
 };
 
 
@@ -256,10 +903,9 @@ Cmdln.prototype.main = function main(argv, callback) {
  * @param opts {Object} The parsed options.
  * @param args {Array} The left-over CLI arguments after options have been
  *      parsed out.
- *
- * @param callback {Function} `function (err)` where `err==false` means stop
- *      processing, `err==<error instance>` passes that error back up
- *      `!err` means continue.
+ * @param callback {Function} `function (err)` where `err===false` means stop
+ *      processing, `err==<error instance>` passes that error back up, and
+ *      no `err` means continue.
  */
 Cmdln.prototype.init = function init(opts, args, callback) {
     if (opts.help) {
@@ -272,6 +918,19 @@ Cmdln.prototype.init = function init(opts, args, callback) {
 };
 
 
+/**
+ * Hook run after the subcommand handler is run.
+ *
+ * @param subcmd {String} The name of the subcommand run.
+ * @param err {Error} The error being returned to the `main` caller, if any.
+ * @param callback {Function} `function (finiErr)` where `finiErr` is an
+ *      error from finalization handling. Note that this `fini()` method
+ *      cannot abort `err`.
+ */
+Cmdln.prototype.fini = function fini(subcmd, err, callback) {
+    callback();
+};
+
 
 /**
  * Print top-level tool help.
@@ -283,6 +942,7 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     var self = this;
     var helpOpts = this.helpOpts;
     var indent = helpOpts.indent;
+    var gindent = helpOpts.groupIndent;
 
     var lines = [];
     if (this.desc) {
@@ -293,9 +953,7 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     }
 
     lines = lines.concat([
-        'Usage:',
-        format('%s%s [OPTIONS] COMMAND [ARGS...]', indent, self.name),
-        format('%s%s help COMMAND', indent, self.name),
+        this._renderHelp('{{usage}}', this),
         ''
     ]);
     if (this.optParser.help) {
@@ -306,137 +964,545 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
     lines = lines.concat([
         'Commands:'
     ]);
-    // Automatic command line from `this.subcmds`.
+    // Automatic command line from `this._handlerFromName`.
     // TODO: same helpCol as for the opts above, textwrap, etc.
     var cmdTemplate = format('%s%%-%ds  %s',
         indent, helpOpts.minHelpCol - indent.length - 2);
-    this.subcmdOrder.forEach(function (name) {
-        var func = self.subcmds[name];
-        if (func.hidden) {
+    this._subcmdOrder.forEach(function (name, idx) {
+        if (typeof (name) === 'object') {
+            if (idx > 0) {
+                /*
+                 * If this is not the first line, print a blank line to
+                 * visually separate this group from previous lines.
+                 */
+                lines.push('');
+            }
+
+            /*
+             * If the group name is not blank, print the group heading.
+             * If it is blank, the caller only wants the separator line
+             * printed above.
+             */
+            assert.string(name.group, 'name.group');
+            if (name.group) {
+                lines.push(format('%s%s:', gindent, name.group));
+            }
+            return;
+        }
+
+        assert.string(name, 'name');
+        var handler = self._handlerFromName[name];
+        if (handler.hidden) {
             return;
         }
         var names = name;
-        if (func.aliases) {
-            names += sprintf(' (%s)', func.aliases.join(', '));
+        if (handler.aliases) {
+            names += sprintf(' (%s)', handler.aliases.join(', '));
         }
-        var desc = (func.help || '').split('\n', 1)[0];
-        desc = desc.replace(/{{name}}/g, self.name);
-        var line = sprintf(cmdTemplate, names, desc);
+        var summary = handler.desc ||
+            (typeof (handler.help) === 'string' && handler.help) ||
+            '';
+        summary = summary.split('\n', 1)[0]; // just leading line
+        summary = self._renderTemplate(summary, name);
+        var line = sprintf(cmdTemplate, names, summary);
         lines.push(line);
     });
 
+    if (this.helpBody) {
+        if (lines.slice(-1) !== '\n') {
+            lines.push('');
+        }
+        lines.push(this.helpBody);
+    }
+
     console.log(lines.join('\n'));
     callback();
 };
 
+
+Cmdln.prototype.subcmdFromFuncname = function subcmdFromFuncname(funcname) {
+    return funcname.slice(3).replace(/_/g, '-');
+};
+
+
 /**
- * Dispatch to the appropriate "do_SUBCMD" function.
+ * Return the handler function for the given sub-command string (aka the
+ * subcmd *name*). This returns undefined if there is no handler for that
+ * sub-command.
  */
-Cmdln.prototype.dispatch = function dispatch(subcmd, argv, callback) {
-    var name = this.aliases[subcmd];
+Cmdln.prototype.handlerFromSubcmd = function handlerFromSubcmd(alias) {
+    var name = this._nameFromAlias[alias];
     if (!name) {
-        callback(new UnknownCommandError(subcmd));
         return;
     }
-    var func = this.subcmds[name];
+    return this._handlerFromName[name];
+};
 
-    var opts = null;
-    var args = argv.slice(3);
-    if (func.options) {
-        try {
-            var parser = new dashdash.Parser({options: func.options});
-            opts = parser.parse(argv, 3);
-        } catch (e) {
-            callback(new OptionError(e, subcmd));
+
+/**
+ * Return the help content for the given sub-command string (aka the
+ * subcmd *name*).
+ *
+ * *Limitation*: If the command has a help *function*, then the function is
+ * returned. It is up to the caller to call it, if they like. The help
+ * function is defined to be async and is *not* defined to return the
+ * string, so running it isn't useful here.
+ *
+ * @param alias {String} The sub-command name or alias.
+ * @throws `UnknownCommandError` if there is no such sub-command.
+ * @returns The help string, a help *function* (see the "Limitation" note
+ *      above), or `null` if no help.
+ */
+Cmdln.prototype.helpFromSubcmd = function helpFromSubcmd(alias) {
+    var handler = this.handlerFromSubcmd(alias);
+    if (!handler) {
+        throw new UnknownCommandError(alias);
+    }
+
+    if (handler.help) {
+        if (typeof (handler.help) === 'function') {
+            return handler.help;
+        } else {
+            return this._renderHelp(handler.help, handler, alias);
+        }
+    } else if (handler.do_help) {
+        // This is likely a `Cmdln` subclass.
+        return function subCliHelp(subcmd, opts, args, cb) {
+            handler.do_help('help', opts, args.slice(1), function (helpErr) {
+                cb(helpErr || false);
+            });
         }
-        args = opts._args;
-        debug('-- parse %j opts: %j', subcmd, opts);
+    } else {
+        return null;
     }
+};
 
-    func.call(this, subcmd, opts, args, callback);
+
+Cmdln.prototype._renderHelp = function _renderHelp(template, handler, alias) {
+    assert.string(template, 'template');
+    assert.optionalString(alias, 'alias');
+
+    var help = this._renderTemplate(template, alias);
+    if (~help.indexOf('{{usage}}')) {
+        var synopses = this.synopsesFromSubcmd(alias || handler);
+        if (synopses.length) {
+            help = help.replace('{{usage}}',
+                'Usage:\n' + indent(synopses.join('\n')));
+        }
+    }
+    if (~help.indexOf('{{options}}') && handler.options) {
+        var parser = new dashdash.Parser({options: handler.options});
+        var helpOpts = (handler.helpOpts
+            ? objMerge(this.helpOpts, handler.helpOpts)
+            : this.helpOpts);
+        help = help.replace('{{options}}',
+            'Options:\n' + parser.help(helpOpts));
+    }
+    help = help.trimRight();
+    return help;
 };
 
-Cmdln.prototype.do_help = function do_help(subcmd, opts, args, callback) {
+Cmdln.prototype._renderTemplate = function _renderTemplate(template, alias) {
+    assert.string(template, 'template');
+    assert.optionalString(alias, 'alias');
+
+    var s = template;
+    s = s.replace(/{{name}}/g, this.name);
+    if (alias) {
+        s = s.replace(/{{cmd}}/g, alias);
+    }
+    return s;
+};
+
+/**
+ * A Cmdln subcmd handler (i.e. the `do_SUBCMD` function) can define a
+ * `synopses` array of usage summaries. E.g.:
+ *
+ *      CLI.prototype.do_foo.synopses = ['{{name}} foo [OPTIONS] ...'];
+ *
+ * Synopses can use the following template vars:
+ *      {{name}}        The cmdln name, e.g. 'mycmd'.
+ *      {{cmd}}         The sub-command name.
+ *
+ * @param {String|Function|Object} subcmd: The subcommand name/alias or the
+ *      subcmd handler (a `do_SUBCMD` function or sub-Cmdln instance).
+ * @returns {Array} of synopsis strings, if any.
+ * @throws {UnknownCommandError} if `alias` doesn't correspond to a command.
+ */
+Cmdln.prototype.synopsesFromSubcmd = function synopsesFromSubcmd(subcmd) {
+    assert.ok(['function', 'string', 'object'].indexOf(typeof (subcmd)) !== -1);
+
+    var name, handler;
+    if (typeof (subcmd) === 'function') {
+        handler = subcmd;
+        name = this.subcmdFromFuncname(handler.name);
+    } else if (typeof (subcmd) === 'object') {
+        name = subcmd.name;
+        handler = subcmd;
+    } else {
+        name = subcmd;
+        handler = this.handlerFromSubcmd(subcmd);
+        if (!handler) {
+            throw new UnknownCommandError(subcmd);
+        }
+    }
+
+    var synopses = [];
+    if (handler.synopses) {
+        for (var i = 0; i < handler.synopses.length; i++) {
+            synopses.push(this._renderTemplate(handler.synopses[i], name));
+        }
+    }
+
+    return synopses;
+};
+
+
+/**
+ * Dispatch to the appropriate "do_SUBCMD" function.
+ *
+ * Old call signature:
+ *      function dispatch(subcmd, argv, callback)
+ *
+ * New call signature:
+ *      function dispatch(dispatchOpts, callback)
+ *
+ * where `argv` is the raw argv array, e.g. ['node', 'foo.js', 'arg1', 'arg2'].
+ *
+ * @param dispatchOpts {Object}
+ *      - @param dispatchOpts.subcmd {String} Required.
+ *      - @param dispatchOpts.argv {Array}
+ *      - @param dispatchOpts.opts {Object}
+ *      - @param dispatchOpts.args {Array}
+ *        One must provide either `argv` *or* both `opts` and `args`. In the
+ *        former, more common case, the option processing has not yet been done
+ *        on the argv. This is equiv to the "old call signature". In the latter,
+ *        dashdash option processing *has* been done. This can be useful for
+ *        subcmds that are modified or shortcut versions of other ones.
+ * @param callback {Function}
+ */
+Cmdln.prototype.dispatch = function dispatch(dispatchOpts, callback) {
+    // Sort out input params.
+    var subcmd, argv, opts, args;
+    if (typeof (callback) === 'function') {
+        // New call signature.
+        assert.string(dispatchOpts.subcmd, 'dispatchOpts.subcmd');
+        assert.optionalArrayOfString(dispatchOpts.argv, 'dispatchOpts.argv');
+        assert.optionalObject(dispatchOpts.opts, 'dispatchOpts.opts');
+        assert.optionalArrayOfString(dispatchOpts.args, 'dispatchOpts.args');
+        subcmd = dispatchOpts.subcmd;
+        argv = dispatchOpts.argv;
+        opts = dispatchOpts.opts;
+        args = dispatchOpts.args;
+    } else {
+        // Old call signature.
+        assert.string(arguments[0], 'subcmd');
+        assert.arrayOfString(arguments[1], 'argv');
+        subcmd = arguments[0];
+        argv = arguments[1];
+        callback = arguments[2];
+    }
+    assert.func(callback, 'callback');
+    assert.ok((argv && !opts && !args) || (!argv && opts && args),
+        'must specify only one of "argv" *or* "opts/args"');
     var self = this;
+
+    var finish = function (err) {
+        if (err) {
+            if (!err._cmdlnInst) err._cmdlnInst = self;
+            if (!err._cmdlnSubcmd && subcmd) err._cmdlnSubcmd = subcmd;
+            if (!err._cmdlnHandler && handler) err._cmdlnHandler = handler;
+        }
+        callback(err);
+    }
+
+    var handler = this.handlerFromSubcmd(subcmd);
+    if (!handler) {
+        finish(new UnknownCommandError(subcmd));
+        return;
+    }
+
+    if (argv) {
+        opts = {};
+        args = argv.slice(3);
+    }
+
+    if (typeof (handler.main) === 'function') {
+        // This is likely a `Cmdln` subclass instance, i.e. a subcli.
+        (function callCmdlnHandler(subcmd, opts, args, cb) {
+            var argv = ['', ''].concat(args);
+            handler.main(argv, cb);
+        }).call(this, subcmd, opts, args, finish);
+    } else {
+        // This is a vanilla `do_SUBCMD` function on the Cmdln class.
+
+        // Skip optional processing if given `opts` -- i.e. it was already done.
+        if (argv && handler.options) {
+            try {
+                var parser = new dashdash.Parser({
+                    options: handler.options,
+                    interspersed: (handler.interspersedOptions !== undefined
+                        ? handler.interspersedOptions : true),
+                    allowUnknown: (handler.allowUnknownOptions !== undefined
+                        ? handler.allowUnknownOptions : false)
+                });
+                opts = parser.parse(argv, 3);
+            } catch (e) {
+                finish(new OptionError(e));
+                return;
+            }
+            args = opts._args;
+            debug('-- parse %j opts: %j', subcmd, opts);
+        }
+        handler.call(this, subcmd, opts, args, finish);
+    }
+};
+
+Cmdln.prototype.do_help = function do_help(subcmd, opts, args, callback) {
     if (args.length === 0) {
         this.printHelp(callback);
         return;
     }
     var alias = args[0];
-    var name = this.aliases[alias];
-    if (!name) {
+    var handler = this.handlerFromSubcmd(alias);
+    if (!handler) {
         callback(new UnknownCommandError(alias));
         return;
     }
 
-    var func = this.subcmds[name];
-    if (func.help) {
-        var help = func.help;
-        help = help.replace('{{name}}', name);
-        if (~help.indexOf('{{options}}')) {
-            var parser = new dashdash.Parser({options: func.options});
-            help = help.replace('{{options}}',
-                'Options:\n' + parser.help(this.helpOpts));
-        }
-        console.log(help.trimRight());
-        callback();
-    } else {
+    try {
+        var help = this.helpFromSubcmd(alias);
+    } catch (e) {
+        callback(e);
+    }
+    if (!help) {
         callback(new CmdlnError({message: format('no help for "%s"', alias)}));
+    } else if (typeof (help) === 'function') {
+        help(subcmd, opts, args, callback);
+    } else {
+        console.log(help);
+        callback();
     }
 };
 Cmdln.prototype.do_help.aliases = ['?'];
 Cmdln.prototype.do_help.help = 'Help on a specific sub-command.';
 
-Cmdln.prototype.help_help = function help_help(subcmd, callback) {
-    this.printHelp(callback);
-};
-
 
 
 // ---- convenience main function for a script
 
 /**
- * Mainline for a Cmdln-using tool. E.g.,
+ * A convenience `main()` for a CLI script using this module. It takes a
+ * Cmdln subclass instance, runs it with the current process argv and
+ * exits with appropriate error output and status code. This does not have a
+ * callback because it calls `process.exit` (with an appropriate exit status).
+ *
+ * Usage example:
  *
- *      function MyTool() {
+ *      function MyCLI() {
  *          // ...
  *      }
- *      util.inherits(MyTool, Cmdln);
+ *      util.inherits(MyCLI, Cmdln);
+ *      // ...
  *
- *      ...
  *      if (require.main === module) {
- *          cmdln.main(MyTool);
+ *          var cli = MyCLI();
+ *          cmdln.main(cli);
  *      }
  *
- * @param cmdClass {Function} The Cmdln subclass ctor.
- * @param argv {Array} The argv to process. Optional. Default is `process.argv`.0
+ * If one wants more control over process termination, err printing or whatever,
+ * the gist of this convenience function is:
+ *
+ *      var cli = MyCLI();
+ *      cli.main(process.argv, function (err) {
+ *          // handle `err`, if any
+ *      });
+ *
+ * @param cli {Function} A `Cmdln` subclass instance.
+ * @param options {Object}
+ *      - `argv` {Array} The argv to process. Optional. Default is
+ *        `process.argv`.
+ *      - `finale` {String} Optional, default 'softexit'. What to do when
+ *        done. Options are 'softexit' (set `process.exitCode` if supported,
+ *        else call `process.exit()`), 'exit' (call `process.exit()` which
+ *        can result in std handles not being flushed), 'callback' (call
+ *        the given `options.callback`), or 'none'.
+ *      - `callback` {Function} Optional. A function called `function (err)`
+ *        if `options.finale === "callback"`.
+ *      - `showErr` {Boolean} Optional. Whether to show (i.e. print via
+ *        `console.error(...)` an error. If not set, then `<cli>.showErr`
+ *        decides. Default true.
+ *      - `showCode` {Boolean} Default false. Whether to show the error `code`
+ *        in the stderr output, if available on the error objects returned
+ *        by subcommands. E.g. with `showCode=false`:
+ *              mycli: error: blip blup burp
+ *        with `showCode=true`:
+ *              mycli: error (BlipBlup): blip blup burp
+ *        See the doc on the `CmdlnError` class above for details on the `code`.
+ *      - `showNoCommandErr` {Boolean} Optional. Whether to show an error
+ *        message on `NoCommandError` -- i.e. when the CLI is called with
+ *        no sub-command. Default false.
+ *      - `showErrStack` {Boolean} Optional. Whether to show the error stack
+ *        when printing an error. If not set, then `<cli>.showErrStack`
+ *        decides. Default false.
+ *      - `showErrHelp` {Boolean} Optional. Whether to show error help
+ *        (see comment on `errHelpFromErr()` and the CHANGES.md entry for
+ *        version 4.0.0) after an error is printed and if error help is
+ *        available. Typically only this module's own error classes support
+ *        error help. Default true.
+ *
+ * Some fields can be set on the Cmdln instance, `<cli>`, to control error
+ * printing. One might want to set these dynamically based, e.g., on top-level
+ * options like `--quiet` or `--verbose`.
+ * - `<cli>.showErr`
+ * - `<cli>.showErrStack`
  */
-function main(cmdClass, argv) {
-    assert.func(cmdClass, 'cmdClass');
-    assert.optionalArrayOfString(argv, 'argv');
-    if (!argv) argv = process.argv;
+function main(cli, options) {
+    /*
+     * For *backward compat*, support the cmdln v1.x calling style:
+     *      cmdln.main(<cmdln-class-ctor>[, <argv>[, <options>]]);
+     * and semantics:
+     * - showNoCommandErr=true by default
+     * - DEBUG=1 envvar will set showErrStack=true
+     */
+    if (typeof (cli) === 'function') {
+        cli = new cli();
+        var argv = options;
+        if (arguments[2]) {
+            assert.object(arguments[2], 'options');
+            options = objCopy(arguments[2]);
+        } else {
+            options = {};
+        }
+        if (argv) {
+            options.argv = argv;
+        }
+        // Backward compat for `process.DEBUG` resulting in error output
+        // including the error stack.
+        if (options.showErrStack === undefined && process.env.DEBUG) {
+            options.showErrStack = true;
+        }
+        if (options.showNoCommandErr === undefined) {
+            options.showNoCommandErr = true;
+        }
+    }
 
-    var cli = new cmdClass();
-    cli.main(argv, function (err) {
-        if (err) {
-            console.error('%s%s: error%s: %s',
-                cli.name,
-                (err.subcmd ? ' ' + err.subcmd : ''),
-                (false && err.code ? format(' (%s)', err.code) : ''),
-                (process.env.DEBUG ? err.stack : err.message));
-            process.exit(err.exitStatus || 1);
+    assert.object(cli, 'cli');
+    assert.optionalObject(options, 'options');
+    options = options ? objCopy(options) : {};
+    assert.optionalArrayOfString(options.argv, 'options.argv');
+    if (!options.argv) {
+        options.argv = process.argv;
+    }
+    assert.optionalBool(options.showErr, 'options.showErr');
+    assert.optionalBool(options.showCode, 'options.showCode');
+    assert.optionalBool(options.showNoCommandErr, 'options.showNoCommandErr');
+    assert.optionalBool(options.showErrStack, 'options.showErrStack');
+    assert.optionalBool(options.showErrHelp, 'options.showErrHelp');
+
+    var VALID_FINALES = ['softexit', 'exit', 'callback', 'none'];
+    var finale;
+    if (options.hasOwnProperty('finale')) {
+        assert.ok(VALID_FINALES.indexOf(options.finale) !== -1,
+            format('invalid options.finale "%s": valid values are "%s"',
+                options.finale, '", "'.join(VALID_FINALES)));
+        finale = options.finale
+    } else {
+        finale = 'softexit';
+    }
+    if (options.hasOwnProperty('callback')) {
+        assert.func(options.callback, 'options.callback');
+        assert.equal(finale, 'callback',
+            'options.callback provided, but options.finale is not "callback"');
+    }
+
+    cli.main(options.argv, function (err) {
+        var exitStatus = (err ? err.exitStatus || 1 : 0);
+
+        // We show (i.e. console.error) an error by default, unless turned
+        // off via `options.showErr` or `cli.showErr`.
+        var showErr = (options.showErr !== undefined ? options.showErr
+            : (cli.showErr !== undefined ? cli.showErr : true));
+
+        if (err && showErr) {
+            var code = (err.body ? err.body.code : err.code);
+            if (code === 'NoCommand' && !options.showNoCommandErr) {
+                /* jsl:pass */
+            } else if (!cli.suppressShowErr && err.message !== undefined) {
+                /*
+                 * If the `err` has no "message" field, then this probably
+                 * isn't an Error instance. Let's just not print an error
+                 * message. This can happen if the subcmd passes back `true`
+                 * or similar to indicate "yes there was an error".
+                 */
+                var showErrStack = (options.showErrStack === undefined
+                        ? cli.showErrStack : options.showErrStack);
+                console.error('%s: error%s: %s',
+                    nameFromErr(err),
+                    (options.showCode && code ? format(' (%s)', code) : ''),
+                    (showErrStack ? err.stack : err.message));
+                var showErrHelp = (options.showErrHelp === undefined
+                    ? true : options.showErrHelp);
+                if (showErrHelp) {
+                    var errHelp = errHelpFromErr(err);
+                    if (errHelp) {
+                        console.error(errHelp);
+                    }
+                }
+            }
+        }
+
+        if (finale === 'exit') {
+            process.exit(exitStatus);
+        } else if (finale === 'softexit') {
+            /*
+             * We'd like to NOT use `process.exit` because node then doesn't in
+             * general allow std handles to flush. For some node versions it
+             * *will* flush if stdout is a TTY. However, you are then screwed
+             * when piping output to anything. IOW, that is no help.
+             *
+             * In node 0.12, `process.exitCode` provided a way to set the exit
+             * code without the hard immediate `process.exit()`.
+             *
+             * Note: A side-effect of avoiding `process.exit()` if we can
+             * manage it, is that a node tool using this that still has active
+             * handles will hang instead of exiting. If that is you, use
+             * `finale: "exit"`.
+             */
+            var supportsProcessExitCode = true;
+            var nodeVer = process.versions.node.split('.').map(Number);
+            if (nodeVer[0] === 0 && nodeVer[1] <= 10) {
+                supportsProcessExitCode = false;
+            }
+
+            if (supportsProcessExitCode) {
+                process.exitCode = exitStatus;
+            } else if (exitStatus !== 0) {
+                process.exit(exitStatus);
+            }
+        } else if (finale === 'callback') {
+            if (options.callback) {
+                options.callback(err);
+            }
         }
-        process.exit(0);
     });
 }
 
 
+
 // ---- exports
 
 module.exports = {
     Cmdln: Cmdln,
+    main: main,
+
     CmdlnError: CmdlnError,
+    UsageError: UsageError,
     OptionError: OptionError,
     UnknownCommandError: UnknownCommandError,
-    main: main
+    errHelpFromErr: errHelpFromErr,
+    nameFromErr: nameFromErr,
+
+    // Expose this to allow calling code to `cmdln.dashdash.addOptionType`.
+    dashdash: dashdash
 };
diff --git a/src/fw/node_modules/dashdash.js b/src/fw/node_modules/dashdash.js
new file mode 100644
index 00000000..adb6f13b
--- /dev/null
+++ b/src/fw/node_modules/dashdash.js
@@ -0,0 +1,1055 @@
+/**
+ * dashdash - A light, featureful and explicit option parsing library for
+ * node.js.
+ */
+// vim: set ts=4 sts=4 sw=4 et:
+
+var assert = require('assert-plus');
+var format = require('util').format;
+var fs = require('fs');
+var path = require('path');
+
+
+var DEBUG = true;
+if (DEBUG) {
+    var debug = console.warn;
+} else {
+    var debug = function () {};
+}
+
+
+
+// ---- internal support stuff
+
+// Replace {{variable}} in `s` with the template data in `d`.
+function renderTemplate(s, d) {
+    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {
+        return d.hasOwnProperty(key) ? d[key] : match;
+    });
+}
+
+/**
+ * Return a shallow copy of the given object;
+ */
+function shallowCopy(obj) {
+    if (!obj) {
+        return (obj);
+    }
+    var copy = {};
+    Object.keys(obj).forEach(function (k) {
+        copy[k] = obj[k];
+    });
+    return (copy);
+}
+
+
+function space(n) {
+    var s = '';
+    for (var i = 0; i < n; i++) {
+        s += ' ';
+    }
+    return s;
+}
+
+
+function makeIndent(arg, deflen, name) {
+    if (arg === null || arg === undefined)
+        return space(deflen);
+    else if (typeof (arg) === 'number')
+        return space(arg);
+    else if (typeof (arg) === 'string')
+        return arg;
+    else
+        assert.fail('invalid "' + name + '": not a string or number: ' + arg);
+}
+
+
+/**
+ * Return an array of lines wrapping the given text to the given width.
+ * This splits on whitespace. Single tokens longer than `width` are not
+ * broken up.
+ */
+function textwrap(s, width) {
+    var words = s.trim().split(/\s+/);
+    var lines = [];
+    var line = '';
+    words.forEach(function (w) {
+        var newLength = line.length + w.length;
+        if (line.length > 0)
+            newLength += 1;
+        if (newLength > width) {
+            lines.push(line);
+            line = '';
+        }
+        if (line.length > 0)
+            line += ' ';
+        line += w;
+    });
+    lines.push(line);
+    return lines;
+}
+
+
+/**
+ * Transform an option name to a "key" that is used as the field
+ * on the `opts` object returned from `<parser>.parse()`.
+ *
+ * Transformations:
+ * - '-' -> '_': This allow one to use hyphen in option names (common)
+ *   but not have to do silly things like `opt["dry-run"]` to access the
+ *   parsed results.
+ */
+function optionKeyFromName(name) {
+    return name.replace(/-/g, '_');
+}
+
+
+
+// ---- Option types
+
+function parseBool(option, optstr, arg) {
+    return Boolean(arg);
+}
+
+function parseString(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    return arg;
+}
+
+function parseNumber(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (isNaN(num)) {
+        throw new Error(format('arg for "%s" is not a number: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+function parseInteger(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) {
+        throw new Error(format('arg for "%s" is not an integer: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+function parsePositiveInteger(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (!/^[0-9]+$/.test(arg) || isNaN(num) || num === 0) {
+        throw new Error(format('arg for "%s" is not a positive integer: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+/**
+ * Supported date args:
+ * - epoch second times (e.g. 1396031701)
+ * - ISO 8601 format: YYYY-MM-DD[THH:MM:SS[.sss][Z]]
+ *      2014-03-28T18:35:01.489Z
+ *      2014-03-28T18:35:01.489
+ *      2014-03-28T18:35:01Z
+ *      2014-03-28T18:35:01
+ *      2014-03-28
+ */
+function parseDate(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var date;
+    if (/^\d+$/.test(arg)) {
+        // epoch seconds
+        date = new Date(Number(arg) * 1000);
+    /* JSSTYLED */
+    } else if (/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?Z?)?$/i.test(arg)) {
+        // ISO 8601 format
+        date = new Date(arg);
+    } else {
+        throw new Error(format('arg for "%s" is not a valid date format: "%s"',
+            optstr, arg));
+    }
+    if (date.toString() === 'Invalid Date') {
+        throw new Error(format('arg for "%s" is an invalid date: "%s"',
+            optstr, arg));
+    }
+    return date;
+}
+
+var optionTypes = {
+    bool: {
+        takesArg: false,
+        parseArg: parseBool
+    },
+    string: {
+        takesArg: true,
+        helpArg: 'ARG',
+        parseArg: parseString
+    },
+    number: {
+        takesArg: true,
+        helpArg: 'NUM',
+        parseArg: parseNumber
+    },
+    integer: {
+        takesArg: true,
+        helpArg: 'INT',
+        parseArg: parseInteger
+    },
+    positiveInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        parseArg: parsePositiveInteger
+    },
+    date: {
+        takesArg: true,
+        helpArg: 'DATE',
+        parseArg: parseDate
+    },
+    arrayOfBool: {
+        takesArg: false,
+        array: true,
+        parseArg: parseBool
+    },
+    arrayOfString: {
+        takesArg: true,
+        helpArg: 'ARG',
+        array: true,
+        parseArg: parseString
+    },
+    arrayOfNumber: {
+        takesArg: true,
+        helpArg: 'NUM',
+        array: true,
+        parseArg: parseNumber
+    },
+    arrayOfInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parseInteger
+    },
+    arrayOfPositiveInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parsePositiveInteger
+    },
+    arrayOfDate: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parseDate
+    },
+};
+
+
+
+// ---- Parser
+
+/**
+ * Parser constructor.
+ *
+ * @param config {Object} The parser configuration
+ *      - options {Array} Array of option specs. See the README for how to
+ *        specify each option spec.
+ *      - allowUnknown {Boolean} Default false. Whether to throw on unknown
+ *        options. If false, then unknown args are included in the _args array.
+ *      - interspersed {Boolean} Default true. Whether to allow interspersed
+ *        arguments (non-options) and options. E.g.:
+ *              node tool.js arg1 arg2 -v
+ *        '-v' is after some args here. If `interspersed: false` then '-v'
+ *        would not be parsed out. Note that regardless of `interspersed`
+ *        the presence of '--' will stop option parsing, as all good
+ *        option parsers should.
+ */
+function Parser(config) {
+    assert.object(config, 'config');
+    assert.arrayOfObject(config.options, 'config.options');
+    assert.optionalBool(config.interspersed, 'config.interspersed');
+    var self = this;
+
+    // Allow interspersed arguments (true by default).
+    this.interspersed = (config.interspersed !== undefined
+        ? config.interspersed : true);
+
+    // Don't allow unknown flags (true by default).
+    this.allowUnknown = (config.allowUnknown !== undefined
+        ? config.allowUnknown : false);
+
+    this.options = config.options.map(function (o) { return shallowCopy(o); });
+    this.optionFromName = {};
+    this.optionFromEnv = {};
+    for (var i = 0; i < this.options.length; i++) {
+        var o = this.options[i];
+        if (o.group !== undefined && o.group !== null) {
+            assert.optionalString(o.group,
+                format('config.options.%d.group', i));
+            continue;
+        }
+        assert.ok(optionTypes[o.type],
+            format('invalid config.options.%d.type: "%s" in %j',
+                   i, o.type, o));
+        assert.optionalString(o.name, format('config.options.%d.name', i));
+        assert.optionalArrayOfString(o.names,
+            format('config.options.%d.names', i));
+        assert.ok((o.name || o.names) && !(o.name && o.names),
+            format('exactly one of "name" or "names" required: %j', o));
+        assert.optionalString(o.help, format('config.options.%d.help', i));
+        var env = o.env || [];
+        if (typeof (env) === 'string') {
+            env = [env];
+        }
+        assert.optionalArrayOfString(env, format('config.options.%d.env', i));
+        assert.optionalString(o.helpGroup,
+            format('config.options.%d.helpGroup', i));
+        assert.optionalBool(o.helpWrap,
+            format('config.options.%d.helpWrap', i));
+        assert.optionalBool(o.hidden, format('config.options.%d.hidden', i));
+
+        if (o.name) {
+            o.names = [o.name];
+        } else {
+            assert.string(o.names[0],
+                format('config.options.%d.names is empty', i));
+        }
+        o.key = optionKeyFromName(o.names[0]);
+        o.names.forEach(function (n) {
+            if (self.optionFromName[n]) {
+                throw new Error(format(
+                    'option name collision: "%s" used in %j and %j',
+                    n, self.optionFromName[n], o));
+            }
+            self.optionFromName[n] = o;
+        });
+        env.forEach(function (n) {
+            if (self.optionFromEnv[n]) {
+                throw new Error(format(
+                    'option env collision: "%s" used in %j and %j',
+                    n, self.optionFromEnv[n], o));
+            }
+            self.optionFromEnv[n] = o;
+        });
+    }
+}
+
+Parser.prototype.optionTakesArg = function optionTakesArg(option) {
+    return optionTypes[option.type].takesArg;
+};
+
+/**
+ * Parse options from the given argv.
+ *
+ * @param inputs {Object} Optional.
+ *      - argv {Array} Optional. The argv to parse. Defaults to
+ *        `process.argv`.
+ *      - slice {Number} The index into argv at which options/args begin.
+ *        Default is 2, as appropriate for `process.argv`.
+ *      - env {Object} Optional. The env to use for 'env' entries in the
+ *        option specs. Defaults to `process.env`.
+ * @returns {Object} Parsed `opts`. It has special keys `_args` (the
+ *      remaining args from `argv`) and `_order` (gives the order that
+ *      options were specified).
+ */
+Parser.prototype.parse = function parse(inputs) {
+    var self = this;
+
+    // Old API was `parse([argv, [slice]])`
+    if (Array.isArray(arguments[0])) {
+        inputs = {argv: arguments[0], slice: arguments[1]};
+    }
+
+    assert.optionalObject(inputs, 'inputs');
+    if (!inputs) {
+        inputs = {};
+    }
+    assert.optionalArrayOfString(inputs.argv, 'inputs.argv');
+    //assert.optionalNumber(slice, 'slice');
+    var argv = inputs.argv || process.argv;
+    var slice = inputs.slice !== undefined ? inputs.slice : 2;
+    var args = argv.slice(slice);
+    var env = inputs.env || process.env;
+    var opts = {};
+    var _order = [];
+
+    function addOpt(option, optstr, key, val, from) {
+        var type = optionTypes[option.type];
+        var parsedVal = type.parseArg(option, optstr, val);
+        if (type.array) {
+            if (!opts[key]) {
+                opts[key] = [];
+            }
+            if (type.arrayFlatten && Array.isArray(parsedVal)) {
+                for (var i = 0; i < parsedVal.length; i++) {
+                    opts[key].push(parsedVal[i]);
+                }
+            } else {
+                opts[key].push(parsedVal);
+            }
+        } else {
+            opts[key] = parsedVal;
+        }
+        var item = { key: key, value: parsedVal, from: from };
+        _order.push(item);
+    }
+
+    // Parse args.
+    var _args = [];
+    var i = 0;
+    outer: while (i < args.length) {
+        var arg = args[i];
+
+        // End of options marker.
+        if (arg === '--') {
+            i++;
+            break;
+
+        // Long option
+        } else if (arg.slice(0, 2) === '--') {
+            var name = arg.slice(2);
+            var val = null;
+            var idx = name.indexOf('=');
+            if (idx !== -1) {
+                val = name.slice(idx + 1);
+                name = name.slice(0, idx);
+            }
+            var option = this.optionFromName[name];
+            if (!option) {
+                if (!this.allowUnknown)
+                    throw new Error(format('unknown option: "--%s"', name));
+                else if (this.interspersed)
+                    _args.push(arg);
+                else
+                    break outer;
+            } else {
+                var takesArg = this.optionTakesArg(option);
+                if (val !== null && !takesArg) {
+                    throw new Error(format('argument given to "--%s" option '
+                        + 'that does not take one: "%s"', name, arg));
+                }
+                if (!takesArg) {
+                    addOpt(option, '--'+name, option.key, true, 'argv');
+                } else if (val !== null) {
+                    addOpt(option, '--'+name, option.key, val, 'argv');
+                } else if (i + 1 >= args.length) {
+                    throw new Error(format('do not have enough args for "--%s" '
+                        + 'option', name));
+                } else {
+                    addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
+                    i++;
+                }
+            }
+
+        // Short option
+        } else if (arg[0] === '-' && arg.length > 1) {
+            var j = 1;
+            var allFound = true;
+            while (j < arg.length) {
+                var name = arg[j];
+                var option = this.optionFromName[name];
+                if (!option) {
+                    allFound = false;
+                    if (this.allowUnknown) {
+                        if (this.interspersed) {
+                            _args.push(arg);
+                            break;
+                        } else
+                            break outer;
+                    } else if (arg.length > 2) {
+                        throw new Error(format(
+                            'unknown option: "-%s" in "%s" group',
+                            name, arg));
+                    } else {
+                        throw new Error(format('unknown option: "-%s"', name));
+                    }
+                } else if (this.optionTakesArg(option)) {
+                    break;
+                }
+                j++;
+            }
+
+            j = 1;
+            while (allFound && j < arg.length) {
+                var name = arg[j];
+                var val = arg.slice(j + 1);  // option val if it takes an arg
+                var option = this.optionFromName[name];
+                var takesArg = this.optionTakesArg(option);
+                if (!takesArg) {
+                    addOpt(option, '-'+name, option.key, true, 'argv');
+                } else if (val) {
+                    addOpt(option, '-'+name, option.key, val, 'argv');
+                    break;
+                } else {
+                    if (i + 1 >= args.length) {
+                        throw new Error(format('do not have enough args '
+                            + 'for "-%s" option', name));
+                    }
+                    addOpt(option, '-'+name, option.key, args[i + 1], 'argv');
+                    i++;
+                    break;
+                }
+                j++;
+            }
+
+        // An interspersed arg
+        } else if (this.interspersed) {
+            _args.push(arg);
+
+        // An arg and interspersed args are not allowed, so done options.
+        } else {
+            break outer;
+        }
+        i++;
+    }
+    _args = _args.concat(args.slice(i));
+
+    // Parse environment.
+    Object.keys(this.optionFromEnv).forEach(function (envname) {
+        var val = env[envname];
+        if (val === undefined)
+            return;
+        var option = self.optionFromEnv[envname];
+        if (opts[option.key] !== undefined)
+            return;
+        var takesArg = self.optionTakesArg(option);
+        if (takesArg) {
+            addOpt(option, envname, option.key, val, 'env');
+        } else if (val !== '') {
+            // Boolean envvar handling:
+            // - VAR=<empty-string>     not set (as if the VAR was not set)
+            // - VAR=0                  false
+            // - anything else          true
+            addOpt(option, envname, option.key, (val !== '0'), 'env');
+        }
+    });
+
+    // Apply default values.
+    this.options.forEach(function (o) {
+        if (opts[o.key] === undefined) {
+            if (o.default !== undefined) {
+                opts[o.key] = o.default;
+            } else if (o.type && optionTypes[o.type].default !== undefined) {
+                opts[o.key] = optionTypes[o.type].default;
+            }
+        }
+    });
+
+    opts._order = _order;
+    opts._args = _args;
+    return opts;
+};
+
+
+/**
+ * Return help output for the current options.
+ *
+ * E.g.: if the current options are:
+ *      [{names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'}]
+ * then this would return:
+ *      '  -h, --help     Show help and exit.\n'
+ *
+ * @param config {Object} Config for controlling the option help output.
+ *      - indent {Number|String} Default 4. An indent/prefix to use for
+ *        each option line.
+ *      - nameSort {String} Default is 'length'. By default the names are
+ *        sorted to put the short opts first (i.e. '-h, --help' preferred
+ *        to '--help, -h'). Set to 'none' to not do this sorting.
+ *      - maxCol {Number} Default 80. Note that long tokens in a help string
+ *        can go past this.
+ *      - helpCol {Number} Set to specify a specific column at which
+ *        option help will be aligned. By default this is determined
+ *        automatically.
+ *      - minHelpCol {Number} Default 20.
+ *      - maxHelpCol {Number} Default 40.
+ *      - includeEnv {Boolean} Default false. If true, a note stating the `env`
+ *        envvar (if specified for this option) will be appended to the help
+ *        output.
+ *      - includeDefault {Boolean} Default false. If true, a note stating
+ *        the `default` for this option, if any, will be appended to the help
+ *        output.
+ *      - helpWrap {Boolean} Default true. Wrap help text in helpCol..maxCol
+ *        bounds.
+ * @returns {String}
+ */
+Parser.prototype.help = function help(config) {
+    config = config || {};
+    assert.object(config, 'config');
+
+    var indent = makeIndent(config.indent, 4, 'config.indent');
+    var headingIndent = makeIndent(config.headingIndent,
+        Math.round(indent.length / 2), 'config.headingIndent');
+
+    assert.optionalString(config.nameSort, 'config.nameSort');
+    var nameSort = config.nameSort || 'length';
+    assert.ok(~['length', 'none'].indexOf(nameSort),
+        'invalid "config.nameSort"');
+    assert.optionalNumber(config.maxCol, 'config.maxCol');
+    assert.optionalNumber(config.maxHelpCol, 'config.maxHelpCol');
+    assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');
+    assert.optionalNumber(config.helpCol, 'config.helpCol');
+    assert.optionalBool(config.includeEnv, 'config.includeEnv');
+    assert.optionalBool(config.includeDefault, 'config.includeDefault');
+    assert.optionalBool(config.helpWrap, 'config.helpWrap');
+    var maxCol = config.maxCol || 80;
+    var minHelpCol = config.minHelpCol || 20;
+    var maxHelpCol = config.maxHelpCol || 40;
+
+    var lines = [];
+    var maxWidth = 0;
+    this.options.forEach(function (o) {
+        if (o.hidden) {
+            return;
+        }
+        if (o.group !== undefined && o.group !== null) {
+            // We deal with groups in the next pass
+            lines.push(null);
+            return;
+        }
+        var type = optionTypes[o.type];
+        var arg = o.helpArg || type.helpArg || 'ARG';
+        var line = '';
+        var names = o.names.slice();
+        if (nameSort === 'length') {
+            names.sort(function (a, b) {
+                if (a.length < b.length)
+                    return -1;
+                else if (b.length < a.length)
+                    return 1;
+                else
+                    return 0;
+            })
+        }
+        names.forEach(function (name, i) {
+            if (i > 0)
+                line += ', ';
+            if (name.length === 1) {
+                line += '-' + name
+                if (type.takesArg)
+                    line += ' ' + arg;
+            } else {
+                line += '--' + name
+                if (type.takesArg)
+                    line += '=' + arg;
+            }
+        });
+        maxWidth = Math.max(maxWidth, line.length);
+        lines.push(line);
+    });
+
+    // Add help strings.
+    var helpCol = config.helpCol;
+    if (!helpCol) {
+        helpCol = maxWidth + indent.length + 2;
+        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
+    }
+    var i = -1;
+    this.options.forEach(function (o) {
+        if (o.hidden) {
+            return;
+        }
+        i++;
+
+        if (o.group !== undefined && o.group !== null) {
+            if (o.group === '') {
+                // Support a empty string "group" to have a blank line between
+                // sets of options.
+                lines[i] = '';
+            } else {
+                // Render the group heading with the heading-specific indent.
+                lines[i] = (i === 0 ? '' : '\n') + headingIndent +
+                    o.group + ':';
+            }
+            return;
+        }
+
+        var helpDefault;
+        if (config.includeDefault) {
+            if (o.default !== undefined) {
+                helpDefault = format('Default: %j', o.default);
+            } else if (o.type && optionTypes[o.type].default !== undefined) {
+                helpDefault = format('Default: %j',
+                    optionTypes[o.type].default);
+            }
+        }
+
+        var line = lines[i] = indent + lines[i];
+        if (!o.help && !(config.includeEnv && o.env) && !helpDefault) {
+            return;
+        }
+        var n = helpCol - line.length;
+        if (n >= 0) {
+            line += space(n);
+        } else {
+            line += '\n' + space(helpCol);
+        }
+
+        var helpEnv = '';
+        if (o.env && o.env.length && config.includeEnv) {
+            helpEnv += 'Environment: ';
+            var type = optionTypes[o.type];
+            var arg = o.helpArg || type.helpArg || 'ARG';
+            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(
+                function (e) {
+                    if (type.takesArg) {
+                        return e + '=' + arg;
+                    } else {
+                        return e + '=1';
+                    }
+                }
+            );
+            helpEnv += envs.join(', ');
+        }
+        var help = (o.help || '').trim();
+        if (o.helpWrap !== false && config.helpWrap !== false) {
+            // Wrap help description normally.
+            if (help.length && !~'.!?"\''.indexOf(help.slice(-1))) {
+                help += '.';
+            }
+            if (help.length) {
+                help += ' ';
+            }
+            help += helpEnv;
+            if (helpDefault) {
+                if (helpEnv) {
+                    help += '. ';
+                }
+                help += helpDefault;
+            }
+            line += textwrap(help, maxCol - helpCol).join(
+                '\n' + space(helpCol));
+        } else {
+            // Do not wrap help description, but indent newlines appropriately.
+            var helpLines = help.split('\n').filter(
+                    function (ln) { return ln.length });
+            if (helpEnv !== '') {
+                helpLines.push(helpEnv);
+            }
+            if (helpDefault) {
+                helpLines.push(helpDefault);
+            }
+            line += helpLines.join('\n' + space(helpCol));
+        }
+
+        lines[i] = line;
+    });
+
+    var rv = '';
+    if (lines.length > 0) {
+        rv = lines.join('\n') + '\n';
+    }
+    return rv;
+};
+
+
+/**
+ * Return a string suitable for a Bash completion file for this tool.
+ *
+ * @param args.name {String} The tool name.
+ * @param args.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "examples/ddcompletion.js" for an example.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+Parser.prototype.bashCompletion = function bashCompletion(args) {
+    assert.object(args, 'args');
+    assert.string(args.name, 'args.name');
+    assert.optionalString(args.specExtra, 'args.specExtra');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    return bashCompletionFromOptions({
+        name: args.name,
+        specExtra: args.specExtra,
+        argtypes: args.argtypes,
+        options: this.options
+    });
+};
+
+
+// ---- Bash completion
+
+const BASH_COMPLETION_TEMPLATE_PATH = path.join(
+    __dirname, '../etc/dashdash.bash_completion.in');
+
+/**
+ * Return the Bash completion "spec" (the string value for the "{{spec}}"
+ * var in the "dashdash.bash_completion.in" template) for this tool.
+ *
+ * The "spec" is Bash code that defines the CLI options and subcmds for
+ * the template's completion code. It looks something like this:
+ *
+ *      local cmd_shortopts="-J ..."
+ *      local cmd_longopts="--help ..."
+ *      local cmd_optargs="-p=tritonprofile ..."
+ *
+ * @param args.options {Array} The array of dashdash option specs.
+ * @param args.context {String} Optional. A context string for the "local cmd*"
+ *      vars in the spec. By default it is the empty string. When used to
+ *      scope for completion on a *sub-command* (e.g. for "git log" on a "git"
+ *      tool), then it would have a value (e.g. "__log"). See
+ *      <http://github.com/trentm/node-cmdln> Bash completion for details.
+ * @param opts.includeHidden {Boolean} Optional. Default false. By default
+ *      hidden options and subcmds are "excluded". Here excluded means they
+ *      won't be offered as a completion, but if used, their argument type
+ *      will be completed. "Hidden" options and subcmds are ones with the
+ *      `hidden: true` attribute to exclude them from default help output.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+function bashCompletionSpecFromOptions(args) {
+    assert.object(args, 'args');
+    assert.object(args.options, 'args.options');
+    assert.optionalString(args.context, 'args.context');
+    assert.optionalBool(args.includeHidden, 'args.includeHidden');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    var context = args.context || '';
+    var includeHidden = (args.includeHidden === undefined
+        ? false : args.includeHidden);
+
+    var spec = [];
+    var shortopts = [];
+    var longopts = [];
+    var optargs = [];
+    (args.options || []).forEach(function (o) {
+        if (o.group !== undefined && o.group !== null) {
+            // Skip group headers.
+            return;
+        }
+
+        var optNames = o.names || [o.name];
+        var optType = getOptionType(o.type);
+        if (optType.takesArg) {
+            var completionType = o.completionType ||
+                optType.completionType || o.type;
+            optNames.forEach(function (optName) {
+                if (optName.length === 1) {
+                    if (includeHidden || !o.hidden) {
+                        shortopts.push('-' + optName);
+                    }
+                    // Include even hidden options in `optargs` so that bash
+                    // completion of its arg still works.
+                    optargs.push('-' + optName + '=' + completionType);
+                } else {
+                    if (includeHidden || !o.hidden) {
+                        longopts.push('--' + optName);
+                    }
+                    optargs.push('--' + optName + '=' + completionType);
+                }
+            });
+        } else {
+            optNames.forEach(function (optName) {
+                if (includeHidden || !o.hidden) {
+                    if (optName.length === 1) {
+                        shortopts.push('-' + optName);
+                    } else {
+                        longopts.push('--' + optName);
+                    }
+                }
+            });
+        }
+    });
+
+    spec.push(format('local cmd%s_shortopts="%s"',
+        context, shortopts.sort().join(' ')));
+    spec.push(format('local cmd%s_longopts="%s"',
+        context, longopts.sort().join(' ')));
+    spec.push(format('local cmd%s_optargs="%s"',
+        context, optargs.sort().join(' ')));
+    if (args.argtypes) {
+        spec.push(format('local cmd%s_argtypes="%s"',
+            context, args.argtypes.join(' ')));
+    }
+    return spec.join('\n');
+}
+
+
+/**
+ * Return a string suitable for a Bash completion file for this tool.
+ *
+ * @param args.name {String} The tool name.
+ * @param args.options {Array} The array of dashdash option specs.
+ * @param args.specExtra {String} Optional. Extra Bash code content to add
+ *      to the end of the "spec". Typically this is used to append Bash
+ *      "complete_TYPE" functions for custom option types. See
+ *      "examples/ddcompletion.js" for an example.
+ * @param args.argtypes {Array} Optional. Array of completion types for
+ *      positional args (i.e. non-options). E.g.
+ *          argtypes = ['fruit', 'veggie', 'file']
+ *      will result in completion of fruits for the first arg, veggies for the
+ *      second, and filenames for the third and subsequent positional args.
+ *      If not given, positional args will use Bash's 'default' completion.
+ *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.
+ *      `complete_fruit` and `complete_veggie` in this example.
+ */
+function bashCompletionFromOptions(args) {
+    assert.object(args, 'args');
+    assert.object(args.options, 'args.options');
+    assert.string(args.name, 'args.name');
+    assert.optionalString(args.specExtra, 'args.specExtra');
+    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');
+
+    // Gather template data.
+    var data = {
+        name: args.name,
+        date: new Date(),
+        spec: bashCompletionSpecFromOptions({
+            options: args.options,
+            argtypes: args.argtypes
+        }),
+    };
+    if (args.specExtra) {
+        data.spec += '\n\n' + args.specExtra;
+    }
+
+    // Render template.
+    var template = fs.readFileSync(BASH_COMPLETION_TEMPLATE_PATH, 'utf8');
+    return renderTemplate(template, data);
+}
+
+
+
+// ---- exports
+
+function createParser(config) {
+    return new Parser(config);
+}
+
+/**
+ * Parse argv with the given options.
+ *
+ * @param config {Object} A merge of all the available fields from
+ *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,
+ *      argv, env, slice.
+ */
+function parse(config) {
+    assert.object(config, 'config');
+    assert.optionalArrayOfString(config.argv, 'config.argv');
+    assert.optionalObject(config.env, 'config.env');
+    var config = shallowCopy(config);
+    var argv = config.argv;
+    delete config.argv;
+    var env = config.env;
+    delete config.env;
+
+    var parser = new Parser(config);
+    return parser.parse({argv: argv, env: env});
+}
+
+
+/**
+ * Add a new option type.
+ *
+ * @params optionType {Object}:
+ *      - name {String} Required.
+ *      - takesArg {Boolean} Required. Whether this type of option takes an
+ *        argument on process.argv. Typically this is true for all but the
+ *        "bool" type.
+ *      - helpArg {String} Required iff `takesArg === true`. The string to
+ *        show in generated help for options of this type.
+ *      - parseArg {Function} Require. `function (option, optstr, arg)` parser
+ *        that takes a string argument and returns an instance of the
+ *        appropriate type, or throws an error if the arg is invalid.
+ *      - array {Boolean} Optional. Set to true if this is an 'arrayOf' type
+ *        that collects multiple usages of the option in process.argv and
+ *        puts results in an array.
+ *      - arrayFlatten {Boolean} Optional. XXX
+ *      - default Optional. Default value for options of this type, if no
+ *        default is specified in the option type usage.
+ */
+function addOptionType(optionType) {
+    assert.object(optionType, 'optionType');
+    assert.string(optionType.name, 'optionType.name');
+    assert.bool(optionType.takesArg, 'optionType.takesArg');
+    if (optionType.takesArg) {
+        assert.string(optionType.helpArg, 'optionType.helpArg');
+    }
+    assert.func(optionType.parseArg, 'optionType.parseArg');
+    assert.optionalBool(optionType.array, 'optionType.array');
+    assert.optionalBool(optionType.arrayFlatten, 'optionType.arrayFlatten');
+
+    optionTypes[optionType.name] = {
+        takesArg: optionType.takesArg,
+        helpArg: optionType.helpArg,
+        parseArg: optionType.parseArg,
+        array: optionType.array,
+        arrayFlatten: optionType.arrayFlatten,
+        default: optionType.default
+    }
+}
+
+
+function getOptionType(name) {
+    assert.string(name, 'name');
+    return optionTypes[name];
+}
+
+
+/**
+ * Return a synopsis string for the given option spec.
+ *
+ * Examples:
+ *      > synopsisFromOpt({names: ['help', 'h'], type: 'bool'});
+ *      '[ --help | -h ]'
+ *      > synopsisFromOpt({name: 'file', type: 'string', helpArg: 'FILE'});
+ *      '[ --file=FILE ]'
+ */
+function synopsisFromOpt(o) {
+    assert.object(o, 'o');
+
+    if (o.hasOwnProperty('group')) {
+        return null;
+    }
+    var names = o.names || [o.name];
+    // `type` here could be undefined if, for example, the command has a
+    // dashdash option spec with a bogus 'type'.
+    var type = getOptionType(o.type);
+    var helpArg = o.helpArg || (type && type.helpArg) || 'ARG';
+    var parts = [];
+    names.forEach(function (name) {
+        var part = (name.length === 1 ? '-' : '--') + name;
+        if (type && type.takesArg) {
+            part += (name.length === 1 ? ' ' + helpArg : '=' + helpArg);
+        }
+        parts.push(part);
+    });
+    return ('[ ' + parts.join(' | ') + ' ]');
+};
+
+
+module.exports = {
+    createParser: createParser,
+    Parser: Parser,
+    parse: parse,
+    addOptionType: addOptionType,
+    getOptionType: getOptionType,
+    synopsisFromOpt: synopsisFromOpt,
+
+    // Bash completion-related exports
+    BASH_COMPLETION_TEMPLATE_PATH: BASH_COMPLETION_TEMPLATE_PATH,
+    bashCompletionFromOptions: bashCompletionFromOptions,
+    bashCompletionSpecFromOptions: bashCompletionSpecFromOptions,
+
+    // Export the parseFoo parsers because they might be useful as primitives
+    // for custom option types.
+    parseBool: parseBool,
+    parseString: parseString,
+    parseNumber: parseNumber,
+    parseInteger: parseInteger,
+    parsePositiveInteger: parsePositiveInteger,
+    parseDate: parseDate
+};
diff --git a/src/fw/node_modules/dashdash/LICENSE.txt b/src/fw/node_modules/dashdash/LICENSE.txt
deleted file mode 100644
index 54706c66..00000000
--- a/src/fw/node_modules/dashdash/LICENSE.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-# This is the MIT license
-
-Copyright (c) 2013 Trent Mick. All rights reserved.
-Copyright (c) 2013 Joyent Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff --git a/src/fw/node_modules/dashdash/index.js b/src/fw/node_modules/dashdash/index.js
deleted file mode 100644
index 09ce5fee..00000000
--- a/src/fw/node_modules/dashdash/index.js
+++ /dev/null
@@ -1,591 +0,0 @@
-/**
- * dashdash - yet another node.js optional parsing library
- */
-
-var p = console.log;
-var format = require('util').format;
-
-var assert = require('assert-plus');
-
-var DEBUG = true;
-if (DEBUG) {
-    var debug = console.warn;
-} else {
-    var debug = function () {};
-}
-
-
-
-// ---- internal support stuff
-
-/**
- * Return a shallow copy of the given object;
- */
-function shallowCopy(obj) {
-    if (!obj) {
-        return (obj);
-    }
-    var copy = {};
-    Object.keys(obj).forEach(function (k) {
-        copy[k] = obj[k];
-    });
-    return (copy);
-}
-
-
-function space(n) {
-    var s = '';
-    for (var i = 0; i < n; i++) {
-        s += ' ';
-    }
-    return s;
-}
-
-
-/**
- * Return an array of lines wrapping the given text to the given width.
- * This splits on whitespace. Single tokens longer than `width` are not
- * broken up.
- */
-function textwrap(s, width) {
-    var words = s.trim().split(/\s+/);
-    var lines = [];
-    var line = '';
-    words.forEach(function (w) {
-        var newLength = line.length + w.length;
-        if (line.length > 0)
-            newLength += 1;
-        if (newLength > width) {
-            lines.push(line);
-            line = '';
-        }
-        if (line.length > 0)
-            line += ' ';
-        line += w;
-    });
-    lines.push(line);
-    return lines;
-}
-
-
-/**
- * Transform an option name to a "key" that is used as the field
- * on the `opts` object returned from `<parser>.parse()`.
- *
- * Transformations:
- * - '-' -> '_': This allow one to use hyphen in option names (common)
- *   but not have to do silly things like `opt["dry-run"]` to access the
- *   parsed results.
- */
-function optionKeyFromName(name) {
-    return name.replace(/-/g, '_');
-}
-
-
-
-// ---- Option types
-
-function parseBool(option, optstr, arg) {
-    return true;
-}
-
-function parseString(option, optstr, arg) {
-    assert.string(arg, 'arg');
-    return arg;
-}
-
-function parseNumber(option, optstr, arg) {
-    assert.string(arg, 'arg');
-    var num = Number(arg);
-    if (isNaN(num)) {
-        throw new Error(format('arg for "%s" is not a number: "%s"',
-            optstr, arg));
-    }
-    return num;
-}
-
-function parseInteger(option, optstr, arg) {
-    assert.string(arg, 'arg');
-    var num = Number(arg);
-    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) {
-        throw new Error(format('arg for "%s" is not an integer: "%s"',
-            optstr, arg));
-    }
-    return num;
-}
-
-function parsePositiveInteger(option, optstr, arg) {
-    assert.string(arg, 'arg');
-    var num = Number(arg);
-    if (!/^[0-9]+$/.test(arg) || isNaN(num)) {
-        throw new Error(format('arg for "%s" is not a positive integer: "%s"',
-            optstr, arg));
-    }
-    return num;
-}
-
-var types = {
-    bool: {
-        takesArg: false,
-        parseArg: parseBool
-    },
-    string: {
-        takesArg: true,
-        helpArg: 'ARG',
-        parseArg: parseString
-    },
-    number: {
-        takesArg: true,
-        helpArg: 'NUM',
-        parseArg: parseNumber
-    },
-    integer: {
-        takesArg: true,
-        helpArg: 'INT',
-        parseArg: parseInteger
-    },
-    positiveInteger: {
-        takesArg: true,
-        helpArg: 'INT',
-        parseArg: parsePositiveInteger
-    },
-    arrayOfBool: {
-        takesArg: false,
-        array: true,
-        parseArg: parseBool
-    },
-    arrayOfString: {
-        takesArg: true,
-        helpArg: 'ARG',
-        array: true,
-        parseArg: parseString
-    },
-    arrayOfNumber: {
-        takesArg: true,
-        helpArg: 'NUM',
-        array: true,
-        parseArg: parseNumber
-    },
-    arrayOfInteger: {
-        takesArg: true,
-        helpArg: 'INT',
-        array: true,
-        parseArg: parseInteger
-    },
-    arrayOfPositiveInteger: {
-        takesArg: true,
-        helpArg: 'INT',
-        array: true,
-        parseArg: parsePositiveInteger
-    },
-};
-
-
-
-// ---- Parser
-
-/**
- * Parser constructor.
- *
- * @param config {Object} The parser configuration
- *      - options {Array} Array of option specs. See the README for how to
- *        specify each option spec.
- *      - interspersed {Boolean} Default true. Whether to allow interspersed
- *        arguments (non-options) and options. E.g.:
- *              node tool.js arg1 arg2 -v
- *        '-v' is after some args here. If `interspersed: false` then '-v'
- *        would not be parsed out. Note that regardless of `interspersed`
- *        the presence of '--' will stop option parsing, as all good
- *        option parsers should.
- */
-function Parser(config) {
-    assert.object(config, 'config');
-    assert.arrayOfObject(config.options, 'config.options');
-    assert.optionalBool(config.interspersed, 'config.interspersed');
-    var self = this;
-
-    // Allow interspersed arguments (true by default).
-    this.interspersed = (config.interspersed !== undefined
-        ? config.interspersed : true);
-
-    this.options = config.options.map(function (o) { return shallowCopy(o); });
-    this.optionFromName = {};
-    this.optionFromEnv = {};
-    for (var i = 0; i < this.options.length; i++) {
-        var o = this.options[i];
-        assert.ok(types[o.type],
-            format('invalid config.options.%d.type: "%s" in %j',
-                   i, o.type, o));
-        assert.optionalString(o.name, format('config.options.%d.name', i));
-        assert.optionalArrayOfString(o.names,
-            format('config.options.%d.names', i));
-        assert.ok((o.name || o.names) && !(o.name && o.names),
-            format('exactly one of "name" or "names" required: %j', o));
-        assert.optionalString(o.help, format('config.options.%d.help', i));
-        var env = o.env || [];
-        if (typeof (env) === 'string') {
-            env = [env];
-        }
-        assert.optionalArrayOfString(env, format('config.options.%d.env', i));
-
-        if (o.name) {
-            o.names = [o.name];
-        } else {
-            assert.string(o.names[0],
-                format('config.options.%d.names is empty', i));
-        }
-        o.key = optionKeyFromName(o.names[0]);
-        o.names.forEach(function (n) {
-            if (self.optionFromName[n]) {
-                throw new Error(format(
-                    'option name collision: "%s" used in %j and %j',
-                    n, self.optionFromName[n], o));
-            }
-            self.optionFromName[n] = o;
-        });
-        env.forEach(function (n) {
-            if (self.optionFromEnv[n]) {
-                throw new Error(format(
-                    'option env collision: "%s" used in %j and %j',
-                    n, self.optionFromEnv[n], o));
-            }
-            self.optionFromEnv[n] = o;
-        });
-    }
-}
-
-Parser.prototype.optionTakesArg = function optionTakesArg(option) {
-    return types[option.type].takesArg;
-};
-
-/**
- * Parse options from the given argv.
- *
- * @param inputs {Object}
- *      - argv {Array} Optional. The argv to parse. Defaults to
- *        `process.argv`.
- *      - slice {Number} The index into argv at which options/args begin.
- *        Default is 2, as appropriate for `process.argv`.
- *      - env {Object} Optional. The env to use for 'env' entries in the
- *        option specs. Defaults to `process.env`.
- * @returns {Object} Parsed `opts`. It has special keys `_args` (the
- *      remaining args from `argv`) and `_order` (gives the order that
- *      options were specified).
- */
-Parser.prototype.parse = function parse(inputs) {
-    var self = this;
-
-    // Old API was `parse([argv, [slice]])`
-    if (Array.isArray(arguments[0])) {
-        inputs = {argv: arguments[0], slice: arguments[1]};
-    }
-
-    assert.object(inputs, 'inputs');
-    assert.optionalArrayOfString(inputs.argv, 'inputs.argv');
-    //assert.optionalNumber(slice, 'slice');
-    var argv = inputs.argv || process.argv;
-    var slice = inputs.slice !== undefined ? inputs.slice : 2;
-    var args = argv.slice(slice);
-    var env = inputs.env || process.env;
-
-    // Setup default values
-    var opts = {};
-    var _order = [];
-    this.options.forEach(function (o) {
-        if (o.default) {
-            opts[o.key] = o.default;
-        }
-    });
-
-    function addOpt(option, optstr, key, val, from) {
-        var type = types[option.type];
-        var parsedVal = type.parseArg(option, optstr, val);
-        if (type.array) {
-            if (!opts[key]) {
-                opts[key] = [];
-            }
-            opts[key].push(parsedVal);
-        } else {
-            opts[key] = parsedVal;
-        }
-        var item = { key: key, value: parsedVal, from: from };
-        _order.push(item);
-    }
-
-    // Parse args.
-    var _args = [];
-    var i = 0;
-    while (i < args.length) {
-        var arg = args[i];
-
-        // End of options marker.
-        if (arg === '--') {
-            i++;
-            break;
-
-        // Long option
-        } else if (arg.slice(0, 2) === '--') {
-            var name = arg.slice(2);
-            var val = null;
-            var idx = name.indexOf('=');
-            if (idx !== -1) {
-                val = name.slice(idx + 1);
-                name = name.slice(0, idx);
-            }
-            var option = this.optionFromName[name];
-            if (!option) {
-                throw new Error(format('unknown option: "--%s"', name));
-            }
-            var takesArg = this.optionTakesArg(option);
-            if (val !== null && !takesArg) {
-                throw new Error(format('argument given to "--%s" option '
-                    + 'that does not take one: "%s"', name, arg));
-            }
-            if (!takesArg) {
-                addOpt(option, '--'+name, option.key, true, 'argv');
-            } else if (val !== null) {
-                addOpt(option, '--'+name, option.key, val, 'argv');
-            } else if (i + 1 >= args.length) {
-                throw new Error(format('do not have enough args for "--%s" '
-                    + 'option', name));
-            } else {
-                addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
-                i++;
-            }
-
-        // Short option
-        } else if (arg[0] === '-' && arg.length > 1) {
-            var j = 1;
-            while (j < arg.length) {
-                var name = arg[j];
-                var val = arg.slice(j + 1);  // option val if it takes an arg
-                // debug('name: %s (val: %s)', name, val)
-                var option = this.optionFromName[name];
-                if (!option) {
-                    if (arg.length > 2) {
-                        throw new Error(format(
-                            'unknown option: "-%s" in "%s" group',
-                            name, arg));
-                    } else {
-                        throw new Error(format('unknown option: "-%s"', name));
-                    }
-                }
-                var takesArg = this.optionTakesArg(option);
-                if (!takesArg) {
-                    addOpt(option, '-'+name, option.key, true, 'argv');
-                } else if (val) {
-                    addOpt(option, '-'+name, option.key, val, 'argv');
-                    break;
-                } else {
-                    if (i + 1 >= args.length) {
-                        throw new Error(format('do not have enough args '
-                            + 'for "-%s" option', name));
-                    }
-                    addOpt(option, '-'+name, option.key, args[i + 1], 'argv');
-                    i++;
-                    break;
-                }
-                j++;
-            }
-
-        // An interspersed arg
-        } else if (this.interspersed) {
-            _args.push(arg);
-
-        // An arg and interspersed args are not allowed, so done options.
-        } else {
-            break;
-        }
-        i++;
-    }
-    _args = _args.concat(args.slice(i));
-
-    // Parse environment.
-    Object.keys(this.optionFromEnv).forEach(function (envname) {
-        var val = env[envname];
-        if (val === undefined)
-            return;
-        var option = self.optionFromEnv[envname];
-        if (opts[option.key] !== undefined)
-            return;
-        var takesArg = self.optionTakesArg(option);
-        if (takesArg) {
-            addOpt(option, envname, option.key, val, 'env');
-        } else if (val) {
-            // For now, we make VAR=<empty-string> NOT set the value
-            // false. It is as if the VAR was not set.
-            addOpt(option, envname, option.key, true, 'env');
-        }
-    });
-
-    opts._order = _order;
-    opts._args = _args;
-    return opts;
-};
-
-
-/**
- * Return help output for the current options.
- *
- * E.g.: if the current options are:
- *      [{names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'}]
- * then this would return:
- *      '  -h, --help     Show help and exit.\n'
- *
- * @param config {Object} Config for controlling the option help output.
- *      - indent {Number|String} Default 4. An indent/prefix to use for
- *        each option line.
- *      - nameSort {String} Default is 'length'. By default the names are
- *        sorted to put the short opts first (i.e. '-h, --help' preferred
- *        to '--help, -h'). Set to 'none' to not do this sorting.
- *      - maxCol {Number} Default 80. Note that long tokens in a help string
- *        can go past this.
- *      - helpCol {Number} Set to specify a specific column at which
- *        option help will be aligned. By default this is determined
- *        automatically.
- *      - minHelpCol {Number} Default 20.
- *      - maxHelpCol {Number} Default 40.
- *      - includeEnv {Boolean} Default false.
- * @returns {String}
- */
-Parser.prototype.help = function help(config) {
-    config = config || {};
-    assert.object(config, 'config');
-    var indent;
-    if (config.indent === undefined) {
-        indent = space(4);
-    } else if (typeof (config.indent) === 'number') {
-        indent = space(config.indent);
-    } else if (typeof (config.indent) === 'string') {
-        indent = config.indent;
-    } else {
-        assert.fail('invalid "config.indent": not a string or number: '
-            + config.indent);
-    }
-    assert.optionalString(config.nameSort, 'config.nameSort');
-    var nameSort = config.nameSort || 'length';
-    assert.ok(~['length', 'none'].indexOf(nameSort),
-        'invalid "config.nameSort"');
-    assert.optionalNumber(config.maxCol, 'config.maxCol');
-    assert.optionalNumber(config.maxHelpCol, 'config.maxHelpCol');
-    assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');
-    assert.optionalNumber(config.helpCol, 'config.helpCol');
-    assert.optionalBool(config.includeEnv, 'config.includeEnv');
-    var maxCol = config.maxCol || 80;
-    var minHelpCol = config.minHelpCol || 20;
-    var maxHelpCol = config.maxHelpCol || 40;
-
-    var lines = [];
-    var maxWidth = 0;
-    this.options.forEach(function (o) {
-        var type = types[o.type];
-        var arg = o.helpArg || type.helpArg || 'ARG';
-        var line = '';
-        var names = o.names.slice();
-        if (nameSort === 'length') {
-            names.sort(function (a, b) {
-                if (a.length < b.length)
-                    return -1;
-                else if (b.length < a.length)
-                    return 1;
-                else
-                    return 0;
-            })
-        }
-        names.forEach(function (name, i) {
-            if (i > 0)
-                line += ', ';
-            if (name.length === 1) {
-                line += '-' + name
-                if (type.takesArg)
-                    line += ' ' + arg;
-            } else {
-                line += '--' + name
-                if (type.takesArg)
-                    line += '=' + arg;
-            }
-        });
-        maxWidth = Math.max(maxWidth, line.length);
-        lines.push(line);
-    });
-
-    // Add help strings.
-    var helpCol = config.helpCol;
-    if (!helpCol) {
-        helpCol = maxWidth + indent.length + 2;
-        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
-    }
-    this.options.forEach(function (o, i) {
-        if (!o.help) {
-            return;
-        }
-        var line = lines[i];
-        var n = helpCol - (indent.length + line.length);
-        if (n >= 0) {
-            line += space(n);
-        } else {
-            line += '\n' + space(helpCol);
-        }
-        var help = o.help;
-        if (o.env && o.env.length && config.includeEnv) {
-            if (help.length && !~'.!?'.indexOf(help.slice(-1))) {
-                help += '.';
-            }
-            help += ' Environment: ';
-            var type = types[o.type];
-            var arg = o.helpArg || type.helpArg || 'ARG';
-            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(function (e) {
-                if (type.takesArg) {
-                    return e + '=' + arg;
-                } else {
-                    return e + '=1';
-                }
-            });
-            help += envs.join(', ');
-        }
-        line += textwrap(help, maxCol - helpCol).join(
-            '\n' + space(helpCol));
-        lines[i] = line;
-    });
-
-    var rv = '';
-    if (lines.length > 0) {
-        rv = indent + lines.join('\n' + indent) + '\n';
-    }
-    return rv;
-};
-
-
-
-// ---- exports
-
-function createParser(config) {
-    return new Parser(config);
-}
-
-/**
- * Parse argv with the given options.
- *
- * @param config {Object} A merge of all the available fields from
- *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,
- *      argv, env, slice.
- */
-function parse(config) {
-    assert.object(config, 'config');
-    assert.optionalArrayOfString(config.argv, 'config.argv');
-    assert.optionalObject(config.env, 'config.env');
-    var config = shallowCopy(config);
-    var argv = config.argv;
-    delete config.argv;
-    var env = config.env;
-    delete config.env;
-
-    var parser = new Parser(config);
-    return parser.parse({argv: argv, env: env});
-}
-
-module.exports = {
-    createParser: createParser,
-    Parser: Parser,
-    parse: parse
-};
diff --git a/src/fw/node_modules/fuzzyset.js/README.rst b/src/fw/node_modules/fuzzyset.js/README.rst
new file mode 100755
index 00000000..6705286a
--- /dev/null
+++ b/src/fw/node_modules/fuzzyset.js/README.rst
@@ -0,0 +1,133 @@
+=============================================
+fuzzyset - A fuzzy string set for javascript.
+=============================================
+
+fuzzyset is a data structure that performs something akin to fulltext search
+against data to determine likely mispellings and approximate string matching.
+Note that this is a javascript port of a `python library`_.
+
+Usage
+-----
+
+The usage is simple. Just add a string to the set, and ask for it later
+by using ``.get``::
+
+   a = FuzzySet();
+   a.add("michael axiak");
+   a.get("micael asiak");
+   [[0.8461538461538461, 'michael axiak']];
+
+The result will be an array of ``[score, mached_value]`` arrays.
+The score is between 0 and 1, with 1 being a perfect match.
+
+Construction Arguments
+----------------------
+
+ - array: An array of strings to initialize the data structure with
+ - useLevenshtein: Whether or not to use the levenshtein distance to determine the match scoring. Default: True
+ - gramSizeLower: The lower bound of gram sizes to use, inclusive (see Theory of operation). Default: 2
+ - gramSizeUpper: The upper bound of gram sizes to use, inclusive (see Theory of operation). Default: 3
+
+Methods
+-------
+
+ - get(value, [default]): try to match a string to entries, otherwise return `null` or `default` if it is given.
+ - add(value): add a value to the set returning `false` if it is already in the set.
+ - length(): return the number of items in the set.
+ - isEmpty(): returns true if the set is empty.
+ - values(): returns an array of the values in the set.
+
+Theory of operation
+-------------------
+
+Adding to the data structure
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+First let's look at adding a string, 'michaelich' to an empty set. We first break apart the string into n-grams (strings of length
+n). So trigrams of 'michaelich' would look like::
+
+    '-mi'
+    'mic'
+    'ich'
+    'cha'
+    'hae'
+    'ael'
+    'eli'
+    'lic'
+    'ich'
+    'ch-'
+
+Note that fuzzyset will first normalize the string by removing non word characters except for spaces and commas and force
+everything to be lowercase.
+
+Next the fuzzyset essentially creates a reverse index on those grams. Maintaining a dictionary that says::
+
+     'mic' -> (1, 0)
+     'ich' -> (2, 0)
+     ...
+
+where the first number is the number of grams and the second number is the index of the item in a list that looks like::
+
+    [[3.31, 'michaelich']]
+
+Note that we maintain this reverse index for *all* grams from ``gram_size_lower`` to ``gram_size_upper`` in the constructor.
+This becomes important in a second.
+
+Retrieving
+~~~~~~~~~~
+
+To search the data structure, we take the n-grams of the query string and perform a reverse index look up. To illustrate,
+let's consider looking up ``'michael'`` in our fictitious set containing ``'michaelich'`` where the ``gram_size_upper``
+and ``gram_size_lower`` parameters are default (3 and 2 respectively).
+
+We begin by considering first all trigrams (the value of ``gram_size_upper``). Those grams are::
+
+   '-mi'
+   'mic'
+   'ich'
+   'cha'
+   'el-'
+
+Then we create a list of any element in the set that has *at least one* occurrence of a trigram listed above. Note that
+this is just a dictionary lookup 5 times. For each of these matched elements, we compute the `cosine similarity`_ between
+each element and the query string. We then sort to get the most similar matched elements.
+
+If ``use_levenshtein`` is false, then we return all top matched elements with the same cosine similarity.
+
+If ``use_levenshtein`` is true, then we truncate the possible search space to 50, compute a score based on the levenshtein
+distance (so that we handle transpositions), and return based on that.
+
+In the event that none of the trigrams matched, we try the whole thing again with bigrams (note though that if there are no matches,
+the failure to match will be quick). Bigram searching will always be slower because there will be a much larger set to order.
+
+.. _cosine similarity: http://en.wikipedia.org/wiki/Cosine_similarity
+.. _python library: https://github.com/axiak/fuzzyset
+
+
+Install
+--------
+this::
+
+    <script type="text/javascript" src="/path/to/fuzzyset.js"></script>
+
+or::
+
+    npm install fuzzyset.js
+
+
+
+License
+-------
+
+BSD
+
+Python Author
+--------
+
+Mike Axiak <mike@axiak.net>
+
+
+JavaScript Port Author
+--------
+
+Glen Chiacchieri (http://glench.com)
diff --git a/src/fw/node_modules/fuzzyset.js/index.js b/src/fw/node_modules/fuzzyset.js/index.js
new file mode 100644
index 00000000..ef190ad0
--- /dev/null
+++ b/src/fw/node_modules/fuzzyset.js/index.js
@@ -0,0 +1,288 @@
+(function() {
+
+var FuzzySet = function(arr, useLevenshtein, gramSizeLower, gramSizeUpper) {
+    var fuzzyset = {
+        version: '0.0.1'
+    };
+
+    // default options
+    arr = arr || [];
+    fuzzyset.gramSizeLower = gramSizeLower || 2;
+    fuzzyset.gramSizeUpper = gramSizeUpper || 3;
+    fuzzyset.useLevenshtein = useLevenshtein || true;
+
+    // define all the object functions and attributes
+    fuzzyset.exactSet = {}
+    fuzzyset.matchDict = {};
+    fuzzyset.items = {};
+
+    // helper functions
+    var levenshtein = function(str1, str2) {
+        var current = [], prev, value;
+
+        for (var i = 0; i <= str2.length; i++)
+            for (var j = 0; j <= str1.length; j++) {
+            if (i && j)
+                if (str1.charAt(j - 1) === str2.charAt(i - 1))
+                value = prev;
+                else
+                value = Math.min(current[j], current[j - 1], prev) + 1;
+            else
+                value = i + j;
+
+            prev = current[j];
+            current[j] = value;
+            }
+
+        return current.pop();
+    };
+
+    // return an edit distance from 0 to 1
+    var _distance = function(str1, str2) {
+        if (str1 == null && str2 == null) throw 'Trying to compare two null values'
+        if (str1 == null || str2 == null) return 0;
+        str1 = String(str1); str2 = String(str2);
+
+        var distance = levenshtein(str1, str2);
+        if (str1.length > str2.length) {
+            return 1 - distance / str1.length;
+        } else {
+            return 1 - distance / str2.length;
+        }
+    };
+    var _nonWordRe = /[^\w, ]+/;
+
+    var _iterateGrams = function(value, gramSize) {
+        gramSize = gramSize || 2;
+        var simplified = '-' + value.toLowerCase().replace(_nonWordRe, '') + '-',
+            lenDiff = gramSize - simplified.length,
+            results = [];
+        if (lenDiff > 0) {
+            for (var i = 0; i < lenDiff; ++i) {
+                value += '-';
+            }
+        }
+        for (var i = 0; i < simplified.length - gramSize + 1; ++i) {
+            results.push(simplified.slice(i, i + gramSize))
+        }
+        return results;
+    };
+
+    var _gramCounter = function(value, gramSize) {
+        gramSize = gramSize || 2;
+        var result = {},
+            grams = _iterateGrams(value, gramSize),
+            i = 0;
+        for (i; i < grams.length; ++i) {
+            if (grams[i] in result) {
+                result[grams[i]] += 1;
+            } else {
+                result[grams[i]] = 1;
+            }
+        }
+        return result;
+    };
+
+    // the main functions
+    fuzzyset.get = function(value, defaultValue) {
+        var result = this._get(value);
+        if (!result && defaultValue) {
+            return defaultValue;
+        }
+        return result;
+    };
+
+    fuzzyset._get = function(value) {
+        var normalizedValue = this._normalizeStr(value),
+            result = this.exactSet[normalizedValue];
+        if (result) {
+            return [[1, result]];
+        }
+        var results = [];
+        for (var gramSize = this.gramSizeUpper; gramSize > this.gramSizeLower; --gramSize) {
+            results = this.__get(value, gramSize);
+            if (results) {
+                return results;
+            }
+        }
+        return null;
+    };
+
+    fuzzyset.__get = function(value, gramSize) {
+        var normalizedValue = this._normalizeStr(value),
+            matches = {},
+            gramCounts = _gramCounter(normalizedValue, gramSize),
+            items = this.items[gramSize],
+            sumOfSquareGramCounts = 0,
+            gram,
+            gramCount,
+            i,
+            index,
+            otherGramCount;
+
+        for (gram in gramCounts) {
+            gramCount = gramCounts[gram];
+            sumOfSquareGramCounts += Math.pow(gramCount, 2);
+            if (gram in this.matchDict) {
+                for (i = 0; i < this.matchDict[gram].length; ++i) {
+                    index = this.matchDict[gram][i][0];
+                    otherGramCount = this.matchDict[gram][i][1];
+                    if (index in matches) {
+                        matches[index] += gramCount * otherGramCount;
+                    } else {
+                        matches[index] = gramCount * otherGramCount;
+                    }
+                }
+            }
+        }
+
+        function isEmptyObject(obj) {
+            for(var prop in obj) {
+                if(obj.hasOwnProperty(prop))
+                    return false;
+            }
+            return true;
+        }
+
+        if (isEmptyObject(matches)) {
+            return null;
+        }
+
+        var vectorNormal = Math.sqrt(sumOfSquareGramCounts),
+            results = [],
+            matchScore;
+        // build a results list of [score, str]
+        for (var matchIndex in matches) {
+            matchScore = matches[matchIndex];
+            results.push([matchScore / (vectorNormal * items[matchIndex][0]), items[matchIndex][1]]);
+        }
+        var sortDescending = function(a, b) {
+            if (a[0] < b[0]) {
+                return 1;
+            } else if (a[0] > b[0]) {
+                return -1;
+            } else {
+                return 0;
+            }
+        };
+        results.sort(sortDescending);
+        if (this.useLevenshtein) {
+            var newResults = [],
+                endIndex = Math.min(50, results.length);
+            // truncate somewhat arbitrarily to 50
+            for (var i = 0; i < endIndex; ++i) {
+                newResults.push([_distance(results[i][1], normalizedValue), results[i][1]]);
+            }
+            results = newResults;
+            results.sort(sortDescending);
+        }
+        var newResults = [];
+        for (var i = 0; i < results.length; ++i) {
+            if (results[i][0] == results[0][0]) {
+                newResults.push([results[i][0], this.exactSet[results[i][1]]]);
+            }
+        }
+        return newResults;
+    };
+
+    fuzzyset.add = function(value) {
+        var normalizedValue = this._normalizeStr(value);
+        if (normalizedValue in this.exactSet) {
+            return false;
+        }
+
+        var i = this.gramSizeLower;
+        for (i; i < this.gramSizeUpper + 1; ++i) {
+            this._add(value, i);
+        }
+    };
+
+    fuzzyset._add = function(value, gramSize) {
+        var normalizedValue = this._normalizeStr(value),
+            items = this.items[gramSize] || [],
+            index = items.length;
+
+        items.push(0);
+        var gramCounts = _gramCounter(normalizedValue, gramSize),
+            sumOfSquareGramCounts = 0,
+            gram, gramCount;
+        for (var gram in gramCounts) {
+            gramCount = gramCounts[gram];
+            sumOfSquareGramCounts += Math.pow(gramCount, 2);
+            if (gram in this.matchDict) {
+                this.matchDict[gram].push([index, gramCount]);
+            } else {
+                this.matchDict[gram] = [[index, gramCount]];
+            }
+        }
+        var vectorNormal = Math.sqrt(sumOfSquareGramCounts);
+        items[index] = [vectorNormal, normalizedValue];
+        this.items[gramSize] = items;
+        this.exactSet[normalizedValue] = value;
+    };
+
+    fuzzyset._normalizeStr = function(str) {
+        if (Object.prototype.toString.call(str) !== '[object String]') throw 'Must use a string as argument to FuzzySet functions'
+        return str.toLowerCase();
+    };
+
+    // return length of items in set
+    fuzzyset.length = function() {
+        var count = 0,
+            prop;
+        for (prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                count += 1;
+            }
+        }
+        return count;
+    };
+
+    // return is set is empty
+    fuzzyset.isEmpty = function() {
+        for (var prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                return false;
+            }
+        }
+        return true;
+    };
+
+    // return list of values loaded into set
+    fuzzyset.values = function() {
+        var values = [],
+            prop;
+        for (prop in this.exactSet) {
+            if (this.exactSet.hasOwnProperty(prop)) {
+                values.push(this.exactSet[prop])
+            }
+        }
+        return values;
+    };
+
+
+    // initialization
+    var i = fuzzyset.gramSizeLower;
+    for (i; i < fuzzyset.gramSizeUpper + 1; ++i) {
+        fuzzyset.items[i] = [];
+    }
+    // add all the items to the set
+    for (i = 0; i < arr.length; ++i) {
+        fuzzyset.add(arr[i]);
+    }
+
+    return fuzzyset;
+};
+
+var root = this;
+// Export the fuzzyset object for **CommonJS**, with backwards-compatibility
+// for the old `require()` API. If we're not in CommonJS, add `_` to the
+// global object.
+if (typeof module !== 'undefined' && module.exports) {
+    module.exports = FuzzySet;
+    root.FuzzySet = FuzzySet;
+} else {
+    root.FuzzySet = FuzzySet;
+}
+
+})();
diff --git a/src/fw/node_modules/verror.js b/src/fw/node_modules/verror.js
index 9ca087b1..26e84b9b 100644
--- a/src/fw/node_modules/verror.js
+++ b/src/fw/node_modules/verror.js
@@ -10,17 +10,45 @@ var mod_extsprintf = require('extsprintf');
 /*
  * Public interface
  */
-exports.VError = VError;
-exports.WError = WError;
-exports.MultiError = MultiError;
+
+/* So you can 'var VError = require('verror')' */
+module.exports = VError;
+/* For compatibility */
+VError.VError = VError;
+/* Other exported classes */
+VError.SError = SError;
+VError.WError = WError;
+VError.MultiError = MultiError;
 
 /*
- * Like JavaScript's built-in Error class, but supports a "cause" argument and a
- * printf-style message.  The cause argument can be null.
+ * VError([cause], fmt[, arg...]): Like JavaScript's built-in Error class, but
+ * supports a "cause" argument (another error) and a printf-style message.  The
+ * cause argument can be null or omitted entirely.
+ *
+ * Examples:
+ *
+ * CODE                                    MESSAGE
+ * new VError('something bad happened')    "something bad happened"
+ * new VError('missing file: "%s"', file)  "missing file: "/etc/passwd"
+ *   with file = '/etc/passwd'
+ * new VError(err, 'open failed')          "open failed: file not found"
+ *   with err.message = 'file not found'
  */
 function VError(options)
 {
-	var args, causedBy, ctor, tailmsg;
+	var args, obj, causedBy, ctor, tailmsg;
+
+	/*
+	 * This is a regrettable pattern, but JavaScript's built-in Error class
+	 * is defined to work this way, so we allow the constructor to be called
+	 * without "new".
+	 */
+	if (!(this instanceof VError)) {
+		args = Array.prototype.slice.call(arguments, 0);
+		obj = Object.create(VError.prototype);
+		VError.apply(obj, arguments);
+		return (obj);
+	}
 
 	if (options instanceof Error || typeof (options) === 'object') {
 		args = Array.prototype.slice.call(arguments, 1);
@@ -29,6 +57,37 @@ function VError(options)
 		options = undefined;
 	}
 
+	/*
+	 * extsprintf (which we invoke here with our caller's arguments in order
+	 * to construct this Error's message) is strict in its interpretation of
+	 * values to be processed by the "%s" specifier.  The value passed to
+	 * extsprintf must actually be a string or something convertible to a
+	 * String using .toString().  Passing other values (notably "null" and
+	 * "undefined") is considered a programmer error.  The assumption is
+	 * that if you actually want to print the string "null" or "undefined",
+	 * then that's easy to do that when you're calling extsprintf; on the
+	 * other hand, if you did NOT want that (i.e., there's actually a bug
+	 * where the program assumes some variable is non-null and tries to
+	 * print it, which might happen when constructing a packet or file in
+	 * some specific format), then it's better to stop immediately than
+	 * produce bogus output.
+	 *
+	 * However, sometimes the bug is only in the code calling VError, and a
+	 * programmer might prefer to have the error message contain "null" or
+	 * "undefined" rather than have the bug in the error path crash the
+	 * program (making the first bug harder to identify).  For that reason,
+	 * by default VError converts "null" or "undefined" arguments to their
+	 * string representations and passes those to extsprintf.  Programmers
+	 * desiring the strict behavior can use the SError class or pass the
+	 * "strict" option to the VError constructor.
+	 */
+	if (!options || !options.strict) {
+		args = args.map(function (a) {
+			return (a === null ? 'null' :
+			    a === undefined ? 'undefined' : a);
+		});
+	}
+
 	tailmsg = args.length > 0 ?
 	    mod_extsprintf.sprintf.apply(null, args) : '';
 	this.jse_shortmsg = tailmsg;
@@ -54,6 +113,8 @@ function VError(options)
 		ctor = ctor || arguments.callee;
 		Error.captureStackTrace(this, ctor);
 	}
+
+	return (this);
 }
 
 mod_util.inherits(VError, Error);
@@ -75,6 +136,38 @@ VError.prototype.cause = function ve_cause()
 };
 
 
+/*
+ * SError is like VError, but stricter about types.  You cannot pass "null" or
+ * "undefined" as string arguments to the formatter.  Since SError is only a
+ * different function, not really a different class, we don't set
+ * SError.prototype.name.
+ */
+function SError()
+{
+	var fmtargs, opts, key, args;
+
+	opts = {};
+	opts.constructorOpt = SError;
+
+	if (arguments[0] instanceof Error) {
+		opts.cause = arguments[0];
+		fmtargs = Array.prototype.slice.call(arguments, 1);
+	} else if (typeof (arguments[0]) == 'object') {
+		for (key in arguments[0])
+			opts[key] = arguments[0][key];
+		fmtargs = Array.prototype.slice.call(arguments, 1);
+	} else {
+		fmtargs = Array.prototype.slice.call(arguments, 0);
+	}
+
+	opts.strict = true;
+	args = [ opts ].concat(fmtargs);
+	VError.apply(this, args);
+}
+
+mod_util.inherits(SError, VError);
+
+
 /*
  * Represents a collection of errors for the purpose of consumers that generally
  * only deal with one error.  Callers can extract the individual errors
@@ -93,7 +186,6 @@ function MultiError(errors)
 mod_util.inherits(MultiError, VError);
 
 
-
 /*
  * Like JavaScript's built-in Error class, but supports a "cause" argument which
  * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
diff --git a/src/fw/package.json b/src/fw/package.json
index fe52bd0a..313cbce5 100644
--- a/src/fw/package.json
+++ b/src/fw/package.json
@@ -11,17 +11,16 @@
     "ramsey": "0.1.2"
   },
   "dependencies": {
-    "assert-plus": "0.1.2",
+    "assert-plus": "1.0.0",
     "bunyan": "0.14.6",
     "clone": "0.1.4",
-    "cmdln": "1.1.1",
+    "cmdln": "4.1.1",
     "extsprintf": "1.0.2",
     "mkdirp": "0.3.4",
     "node-uuid": "1.2.0",
-    "nopt": "1.0.10",
     "tab": "0.1.0",
     "vasync": "1.6.3",
-    "verror": "1.3.6"
+    "verror": "1.6.0"
   },
   "scripts": {
     "test": "make test"
diff --git a/src/fw/test/unit/vms.test.js b/src/fw/test/unit/vms.test.js
index 566baa76..3872f941 100644
--- a/src/fw/test/unit/vms.test.js
+++ b/src/fw/test/unit/vms.test.js
@@ -75,7 +75,7 @@ exports.setUp = function (cb) {
 exports['missing vms'] = function (t) {
     fw.vms({ }, function (err, res) {
         t.ok(err, 'error returned');
-        t.equal(err.message, 'opts.vms ([object]) required',
+        t.equal(err.message, 'opts.vms ([object]) is required',
             'error message');
         return t.done();
     });
diff --git a/src/fw/tools/bin/rebuild-node-modules b/src/fw/tools/bin/rebuild-node-modules
index a378661a..c0b585a6 100755
--- a/src/fw/tools/bin/rebuild-node-modules
+++ b/src/fw/tools/bin/rebuild-node-modules
@@ -53,9 +53,11 @@ mkdir ${NM}/cmdln
 cp ${NM_ORIG}/cmdln/lib/cmdln.js ${NM}/cmdln/index.js
 cp ${NM_ORIG}/cmdln/LICENSE.txt ${NM}/cmdln/
 
-mkdir ${NM}/dashdash
-cp ${NM_ORIG}/cmdln/node_modules/dashdash/lib/dashdash.js ${NM}/dashdash/index.js
-cp ${NM_ORIG}/cmdln/node_modules/dashdash/LICENSE.txt ${NM}/dashdash/LICENSE.txt
+cp ${NM_ORIG}/cmdln/node_modules/dashdash/lib/dashdash.js ${NM}/dashdash.js
+
+mkdir ${NM}/fuzzyset.js
+cp ${NM_ORIG}/cmdln/node_modules/fuzzyset.js/lib/fuzzyset.js ${NM}/fuzzyset.js/index.js
+cp ${NM_ORIG}/cmdln/node_modules/fuzzyset.js/README.rst ${NM}/fuzzyset.js/README.rst
 
 mkdir ${NM}/carrier
 cp ${NM_ORIG}/tab/node_modules/carrier/lib/carrier.js ${NM}/carrier/index.js
diff --git a/src/manifest b/src/manifest
index d0778447..76f7ecbe 100644
--- a/src/manifest
+++ b/src/manifest
@@ -556,7 +556,7 @@ d usr/fw/node_modules 0555 root bin
 d usr/fw/node_modules/carrier 0555 root bin
 d usr/fw/node_modules/clone 0555 root bin
 d usr/fw/node_modules/cmdln 0555 root bin
-d usr/fw/node_modules/dashdash 0555 root bin
+d usr/fw/node_modules/fuzzyset.js 0555 root bin
 d usr/fw/node_modules/fwrule 0555 root bin
 d usr/fw/node_modules/strsplit 0555 root bin
 d usr/fw/sbin 0555 root bin
@@ -583,8 +583,9 @@ f usr/fw/node_modules/clone/clonePrototype.js 0444 root bin
 f usr/fw/node_modules/clone/index.js 0444 root bin
 f usr/fw/node_modules/cmdln/index.js 0444 root bin
 f usr/fw/node_modules/cmdln/LICENSE.txt 0444 root bin
-f usr/fw/node_modules/dashdash/index.js 0444 root bin
-f usr/fw/node_modules/dashdash/LICENSE.txt 0444 root bin
+f usr/fw/node_modules/dashdash.js 0444 root bin
+f usr/fw/node_modules/fuzzyset.js/README.rst 0444 root bin
+f usr/fw/node_modules/fuzzyset.js/index.js 0444 root bin
 f usr/fw/node_modules/dtrace-provider.js 0444 root bin
 f usr/fw/node_modules/DTraceProviderBindings.node 0444 root bin
 f usr/fw/node_modules/fwrule/index.js 0444 root bin
-- 
2.21.0

