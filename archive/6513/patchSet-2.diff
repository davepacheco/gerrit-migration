commit b3a575b2a629e6a23cc01268a4fb196b90065559
Author: Robert Mustacchi <rm@joyent.com>
Date:   2019-07-09T14:16:03+00:00 (3 months ago)
    
    fixups

diff --git a/usr/src/cmd/fm/mcdecode/mcdecode.c b/usr/src/cmd/fm/mcdecode/mcdecode.c
index 64c18c987f..e6b8b62ce7 100644
--- a/usr/src/cmd/fm/mcdecode/mcdecode.c
+++ b/usr/src/cmd/fm/mcdecode/mcdecode.c
@@ -46,8 +46,8 @@ mcdecode_usage(void)
 	    "Usage: mcdecode [-f infile] [-d address | -w outfile] device\n"
 	    "\n"
 	    "\t-d  decode physical address to the correspond dimm\n"
-	    "\t-f  use decoder image from inflie\n"
-	    "\t-w  write decoder snapshot state to the specified fie\n");
+	    "\t-f  use decoder image from infile\n"
+	    "\t-w  write decoder snapshot state to the specified file\n");
 	exit(MCDECODE_USAGE);
 }
 
diff --git a/usr/src/common/mc/imc/imc_decode.c b/usr/src/common/mc/imc/imc_decode.c
index d5a1997ea7..7e52e9795e 100644
--- a/usr/src/common/mc/imc/imc_decode.c
+++ b/usr/src/common/mc/imc/imc_decode.c
@@ -17,8 +17,8 @@
  * Memory decoding logic.
  *
  * This file is part of the 'imc' driver on x86. It supports taking a physical
- * address and determining what the correspond DIMM is. This is shared between
- * the kernel and userland for easier testing.
+ * address and determining what the corresponding DIMM is. This is shared
+ * between the kernel and userland for easier testing.
  *
  * For more information about the different parts of the decoding process,
  * please see the file 'uts/i86pc/io/imc/imc.c'.
@@ -101,7 +101,6 @@ imc_decode_addr_resvd(const imc_t *imc, imc_decode_state_t *dec)
 	sad = &imc->imc_sockets[0].isock_sad;
 	if (sad->isad_valid != IMC_SAD_V_VALID) {
 		dec->ids_fail = IMC_DECODE_F_BAD_SAD;
-		dec->ids_fail_data = i;
 		return (B_TRUE);
 	}
 
@@ -109,8 +108,8 @@ imc_decode_addr_resvd(const imc_t *imc, imc_decode_state_t *dec)
 	 * An address may fall into three ranges. It may fall into conventional
 	 * memory. It may fall into low memory. It may fall into high memory.
 	 * The conventional memory range is inclusive at the top. The others
-	 * have been translated such that they are uniformaly exclusive at the
-	 * top. Becuause the bottom of conventional memory is at zero, the
+	 * have been translated such that they are uniformly exclusive at the
+	 * top. Because the bottom of conventional memory is at zero, the
 	 * compiler will be angry if we compare against IMC_DECODE_CONV_BASE as
 	 * it is always true.
 	 */
@@ -262,9 +261,9 @@ start:
 	}
 
 	/*
-	 * On some platforms we need to derive the target channel baesd on the
+	 * On some platforms we need to derive the target channel based on the
 	 * physical address and additional rules in the SAD. If we do, do that
-	 * here. The idea is that this may overrules the memory channel route
+	 * here. The idea is that this may overrule the memory channel route
 	 * table target that was determined from the SAD rule.
 	 */
 	if (rule->isr_need_mod3) {
@@ -400,7 +399,7 @@ start:
  * we're targeting. This is determined based on the number of ways that the
  * socket and channel are supposed to be interleaved. The TAD has a target
  * channel list sitting with the TAD rule. To figure out the appropriate index,
- * the alorithm is roughly:
+ * the algorithm is roughly:
  *
  *    idx = [(dec->ids_pa >> 6) / socket-ways] % channel-ways
  *
diff --git a/usr/src/lib/fm/topo/modules/i86pc/chip/chip_intel.c b/usr/src/lib/fm/topo/modules/i86pc/chip/chip_intel.c
index cf1205d961..4c5da1e8cb 100644
--- a/usr/src/lib/fm/topo/modules/i86pc/chip/chip_intel.c
+++ b/usr/src/lib/fm/topo/modules/i86pc/chip/chip_intel.c
@@ -607,13 +607,13 @@ mc_channel_create_v1(topo_mod_t *mod, tnode_t *pnode, nvlist_t *auth,
 		return (-1);
 	}
 
+	nvlist_free(fmri);
 	if (topo_node_fru_set(chnode, NULL, 0, &err) != 0) {
 		whinge(mod, NULL, "mc_channel_create_v1: fru set failed: "
 		    "%d\n", err);
-		nvlist_free(fmri);
 		return (topo_mod_seterrno(mod, err));
 	}
-	nvlist_free(fmri);
+
 	if (topo_pgroup_create(chnode, &dimm_channel_pgroup, &err) != 0) {
 		whinge(mod, NULL, "mc_channel_create_v1: failed to create "
 		    "property group: %d\n", err);
@@ -668,13 +668,13 @@ mc_imc_create_v1(topo_mod_t *mod, tnode_t *pnode, const char *name,
 		return (-1);
 	}
 
+	nvlist_free(fmri);
 	if (topo_node_fru_set(mcnode, NULL, 0, &err) != 0) {
 		whinge(mod, NULL, "mc_nb_create_v1: fru set failed: "
 		    "%d\n", err);
-		nvlist_free(fmri);
 		return (topo_mod_seterrno(mod, err));
 	}
-	nvlist_free(fmri);
+
 	if (topo_pgroup_create(mcnode, &mc_pgroup, &err) != 0) {
 		whinge(mod, NULL, "mc_nb_create_v1: failed to create "
 		    "property group: %d\n", err);
diff --git a/usr/src/test/os-tests/tests/imc/imc_test.c b/usr/src/test/os-tests/tests/imc/imc_test.c
index 1df413802a..7a916fc90f 100644
--- a/usr/src/test/os-tests/tests/imc/imc_test.c
+++ b/usr/src/test/os-tests/tests/imc/imc_test.c
@@ -53,9 +53,9 @@ imc_test_strerror(imc_decode_failure_t fail)
 	case IMC_DECODE_F_NO_SAD_RULE:
 		return ("No valid SAD rule");
 	case IMC_DECODE_F_BAD_SAD_INTERLEAVE:
-		return ("SAD bad interelave target");
+		return ("SAD bad interleave target");
 	case IMC_DECODE_F_BAD_REMOTE_MC_ROUTE:
-		return ("SAD MC_ROUTE refers to non-existant socket");
+		return ("SAD MC_ROUTE refers to non-existent socket");
 	case IMC_DECODE_F_SAD_SEARCH_LOOP:
 		return ("SAD search looped");
 	case IMC_DECODE_F_SAD_BAD_MOD:
@@ -75,7 +75,7 @@ imc_test_strerror(imc_decode_failure_t fail)
 	case IMC_DECODE_F_BAD_CHANNEL_TAD_OFFSET:
 		return ("Bad channel tad offset");
 	case IMC_DECODE_F_NO_RIR_RULE:
-		return ("No valid rank interelave rule");
+		return ("No valid rank interleave rule");
 	case IMC_DECODE_F_BAD_RIR_ILEAVE_TARGET:
 		return ("Bad rank interleave target");
 	case IMC_DECODE_F_BAD_DIMM_INDEX:
diff --git a/usr/src/uts/i86pc/Makefile.files b/usr/src/uts/i86pc/Makefile.files
index 770432531a..d541e92bf3 100644
--- a/usr/src/uts/i86pc/Makefile.files
+++ b/usr/src/uts/i86pc/Makefile.files
@@ -326,7 +326,7 @@ CPR_IMPL_OBJS	= cpr_impl.o	cpr_wakecode.o
 $(KDI_ASSYM_DEPS:%=$(OBJS_DIR)/%):	$(DSF_DIR)/$(OBJS_DIR)/kdi_assym.h
 
 #
-# Intel Integrated Memeory Controller
+# Intel Integrated Memory Controller
 # (Sandy Bridge - Cascade Lake)
 #
 IMC_OBJS =	imc.o imc_decode.o imc_dump.o
diff --git a/usr/src/uts/i86pc/io/imc/imc.c b/usr/src/uts/i86pc/io/imc/imc.c
index 2a1e498eba..1abf38d12c 100644
--- a/usr/src/uts/i86pc/io/imc/imc.c
+++ b/usr/src/uts/i86pc/io/imc/imc.c
@@ -38,7 +38,7 @@
  *
  * SYSTEM ADDRESS
  *
- *	This is a physical address that operating system normally uses. This
+ *	This is a physical address that the operating system normally uses. This
  *	address may refer to DRAM, it may refer to memory mapped PCI
  *	configuration space or device registers, or it may refer to other parts
  *	of the system's memory map, such as the extended advanced programmable
@@ -211,7 +211,7 @@
  * Another wrinkle is that the way that the OS sees the numbering of the CPUs is
  * generally based on the APIC ID (see uts/i86pc/os/cpuid.c for more
  * information). However, to map to the corresponding socket, we need to look at
- * the sockets node ID. The order of PCI buses in the system is not required to
+ * the socket's node ID. The order of PCI buses in the system is not required to
  * have any relation to the socket ID. Therefore, we have to have yet another
  * indirection table in the imc_t.
  *
@@ -226,7 +226,7 @@
  * process. This nvlist uses the version 1 format, which more explicitly encodes
  * the topology in a series of nested nvlists.
  *
- * In addition, the tool, /usr/lib/fm/fmd/mcdecode, can be used to query the
+ * In addition, the tool /usr/lib/fm/fmd/mcdecode can be used to query the
  * decoder and ask it to perform decoding.
  *
  * Decoding Addresses
@@ -279,7 +279,7 @@
  *  o It doesn't support virtual lockstep and adaptive mirroring on Purley
  *    platforms.
  *  o It doesn't properly handle Intel Optane (3D-X Point) NVDIMMs.
- *  o Three way channel interleaving.
+ *  o It doesn't know how to decode three way channel interleaving.
  *
  * None of these are intrinsic problems to the driver, it's mostly a matter of
  * having proper documentation and testing.
@@ -421,12 +421,12 @@ static const imc_gen_data_t imc_gen_data_skx = {
 };
 
 /*
- * This contains a table of all the devices that we're looking for from a stub
+ * This table contains of all the devices that we're looking for from a stub
  * perspective. These are organized by generation. Different generations behave
  * in slightly different ways. For example, Sandy Bridge through Broadwell use
- * unique PCI IDs for each PCI device/function combination that appears. Where
- * as Skylake based systems use the same PCI ID; however, different
- * device/function values indicate that the IDs are used for different purposes.
+ * unique PCI IDs for each PCI device/function combination that appears. Whereas
+ * Skylake based systems use the same PCI ID; however, different device/function
+ * values indicate that the IDs are used for different purposes.
  */
 /* BEGIN CSTYLED */
 static const imc_stub_table_t imc_stub_table[] = {
@@ -676,7 +676,7 @@ imc_mcroute_check(imc_t *imc, imc_sad_t *sad, imc_stub_t *stub)
  * On Skylake, many of the devices that we care about are on separate PCI Buses.
  * These can be mapped together by the DECS register. However, we need to know
  * how to map different buses together so that we can more usefully associate
- * information. The set of buses is all present in the decs register. We'll
+ * information. The set of buses is all present in the DECS register. We'll
  * effectively assign sockets to buses. This is also still something that comes
  * up on pre-Skylake systems as well.
  */
@@ -2197,11 +2197,6 @@ imc_attach_complete(void *arg)
 	imc_fixup_stubs(imc);
 	imc_map_sockets(imc);
 
-	/*
-	 * At this point, if we've made it this far, even if we fail to create
-	 * all of our minor nodes, fail the sanity check, or get incomplete
-	 * data, we'll stick around so that we can understand why.
-	 */
 	if (!imc_create_minors(imc)) {
 		goto done;
 	}
@@ -2904,51 +2899,47 @@ imc_alloc(void)
 }
 
 static struct cb_ops imc_cb_ops = {
-	imc_open,		/* cb_open */
-	imc_close,		/* cb_close */
-	nodev,			/* cb_strategy */
-	nodev,			/* cb_print */
-	nodev,			/* cb_dump */
-	nodev,			/* cb_read */
-	nodev,			/* cb_write */
-	imc_ioctl,		/* cb_ioctl */
-	nodev,			/* cb_devmap */
-	nodev,			/* cb_mmap */
-	nodev,			/* cb_segmap */
-	nochpoll,		/* cb_chpoll */
-	ddi_prop_op,		/* cb_prop_op */
-	NULL,			/* cb_stream */
-	D_MP,			/* cb_flag */
-	CB_REV,			/* cb_rev */
-	nodev,			/* cb_aread */
-	nodev			/* cb_awrite */
+	.cb_open = imc_open,
+	.cb_close = imc_close,
+	.cb_strategy = nodev,
+	.cb_print = nodev,
+	.cb_dump = nodev,
+	.cb_read = nodev,
+	.cb_write = nodev,
+	.cb_ioctl = imc_ioctl,
+	.cb_devmap = nodev,
+	.cb_mmap = nodev,
+	.cb_segmap = nodev,
+	.cb_chpoll = nochpoll,
+	.cb_prop_op = ddi_prop_op,
+	.cb_flag = D_MP,
+	.cb_rev = CB_REV,
+	.cb_aread = nodev,
+	.cb_awrite = nodev
 };
 
 static struct dev_ops imc_dev_ops = {
-	DEVO_REV,		/* devo_rev */
-	0,			/* devo_refcnt */
-	imc_getinfo,		/* devo_getinfo */
-	nulldev,		/* devo_identify */
-	nulldev,		/* devo_probe */
-	imc_attach,		/* devo_attach */
-	imc_detach,		/* devo_detach */
-	nodev,			/* devo_reset */
-	&imc_cb_ops,		/* devo_cb_ops */
-	NULL,			/* devo_bus_ops */
-	NULL,			/* devo_power */
-	ddi_quiesce_not_needed	/* devo_quiesce */
+	.devo_rev = DEVO_REV,
+	.devo_refcnt = 0,
+	.devo_getinfo = imc_getinfo,
+	.devo_identify = nulldev,
+	.devo_probe = nulldev,
+	.devo_attach = imc_attach,
+	.devo_detach = imc_detach,
+	.devo_reset = nodev,
+	.devo_cb_ops = &imc_cb_ops,
+	.devo_quiesce = ddi_quiesce_not_needed
 };
 
 static struct modldrv imc_modldrv = {
-	&mod_driverops,
-	"Intel Integrated Memory Controller Driver",
-	&imc_dev_ops
+	.drv_modops = &mod_driverops,
+	.drv_linkinfo = "Intel Integrated Memory Controller Driver",
+	.drv_dev_ops = &imc_dev_ops
 };
 
 static struct modlinkage imc_modlinkage = {
-	MODREV_1,
-	&imc_modldrv,
-	NULL
+	.ml_rev = MODREV_1,
+	.ml_linkage = { &imc_modldrv, NULL }
 };
 
 int
diff --git a/usr/src/uts/i86pc/io/imc/imc.h b/usr/src/uts/i86pc/io/imc/imc.h
index 61c6dcfd76..7d07be20af 100644
--- a/usr/src/uts/i86pc/io/imc/imc.h
+++ b/usr/src/uts/i86pc/io/imc/imc.h
@@ -327,7 +327,7 @@ extern "C" {
 #define	IMC_TAD_SYSDEF2_CHANHASH(x)	BITX(x, 21, 21)
 
 /*
- * Maximum number of differe wayness entries that exist across the various IMC
+ * Maximum number of different wayness entries that exist across the various IMC
  * generations. Each wayness then has a maximum number of target entries.
  */
 #define	IMC_MAX_RANK_WAYS		5
diff --git a/usr/src/uts/i86pc/io/imc/imcstub.c b/usr/src/uts/i86pc/io/imc/imcstub.c
index 89f01d6143..ee020dd5c4 100644
--- a/usr/src/uts/i86pc/io/imc/imcstub.c
+++ b/usr/src/uts/i86pc/io/imc/imcstub.c
@@ -40,30 +40,26 @@ imcstub_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 }
 
 static struct dev_ops imcstub_dev_ops = {
-	DEVO_REV,		/* devo_rev */
-	0,			/* devo_refcnt */
-	nodev,			/* devo_getinfo */
-	nulldev,		/* devo_identify */
-	nulldev,		/* devo_probe */
-	imcstub_attach,		/* devo_attach */
-	imcstub_detach,		/* devo_detach */
-	nodev,			/* devo_reset */
-	NULL,			/* devo_cb_ops */
-	NULL,			/* devo_bus_ops */
-	NULL,			/* devo_power */
-	ddi_quiesce_not_needed	/* devo_quiesce */
+	.devo_rev = DEVO_REV,
+	.devo_refcnt = 0,
+	.devo_getinfo = nodev,
+	.devo_identify = nodev,
+	.devo_probe = nulldev,
+	.devo_attach = imcstub_attach,
+	.devo_detach = imcstub_detach,
+	.devo_reset = nodev,
+	.devo_quiesce = ddi_quiesce_not_needed
 };
 
 static struct modldrv imcstub_modldrv = {
-	&mod_driverops,
-	"IMC Stub driver",
-	&imcstub_dev_ops
+	.drv_modops = &mod_driverops,
+	.drv_linkinfo = "IMC Stub driver",
+	.drv_dev_ops = &imcstub_dev_ops
 };
 
 static struct modlinkage imcstub_modlinkage = {
-	MODREV_1,
-	&imcstub_modldrv,
-	NULL
+	.ml_rev = MODREV_1,
+	.ml_linkage = { &imcstub_modldrv, NULL }
 };
 
 int
diff --git a/usr/src/uts/intel/sys/mc.h b/usr/src/uts/intel/sys/mc.h
index 03a1f4623d..d4815b515f 100644
--- a/usr/src/uts/intel/sys/mc.h
+++ b/usr/src/uts/intel/sys/mc.h
@@ -86,7 +86,7 @@ typedef struct mc_snapshot_info {
 } mc_snapshot_info_t;
 
 /*
- * Data used to simulate the an encoding or decoding.
+ * Data used to simulate encoding or decoding of a physical / DIMM address.
  */
 typedef struct mc_encode_ioc {
 	uint64_t	mcei_pa;
diff --git a/usr/src/uts/intel/sys/mc_intel.h b/usr/src/uts/intel/sys/mc_intel.h
index 459bb5ccee..4c43d3d695 100644
--- a/usr/src/uts/intel/sys/mc_intel.h
+++ b/usr/src/uts/intel/sys/mc_intel.h
@@ -63,7 +63,7 @@ extern "C" {
 #define	MCINTEL_NVLIST_REV	"dimm-part-rev"
 
 /*
- * Version 1 payload. Where as the version 0 payload uses a flat name space, we
+ * Version 1 payload. Whereas the version 0 payload uses a flat name space, we
  * instead opt to use a hierarchical name space. This means that we can know how
  * many devices there are at any level, as each level has this. Effectively,
  * this means that we have an nvlist structure, for a socket that looks like:
