commit f33158880f15f1a87b10bd60ab0017d3c5640299 (refs/changes/17/1917/4)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2017-12-05T11:44:05-08:00 (1 year, 10 months ago)
    
    DOCKER-1050 add redirect handling for docker registry client getManifest() call

diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 938f98c..4e0b0de 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -1280,6 +1280,7 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
     assert.string(opts.ref, 'opts.ref');
     assert.optionalBool(opts.acceptManifestLists, 'opts.acceptManifestLists');
     assert.optionalNumber(opts.maxSchemaVersion, 'opts.maxSchemaVersion');
+    assert.optionalBool(opts.followRedirects, 'opts.followRedirects');
     assert.func(cb, 'cb');
 
     var acceptManifestLists = opts.acceptManifestLists;
@@ -1311,12 +1312,20 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
                 }
                 headers = common.objMerge({}, self._headers, {accept: accept});
             }
-            self._api.get({
+            var requestOpts = {
+                method: 'get',
+                url: self._url,
                 path: fmt('/v2/%s/manifests/%s',
                     encodeURI(self.repo.remoteName),
                     encodeURI(opts.ref)),
                 headers: headers
-            }, function _afterCall(err, req, res_, manifest_, body) {
+            };
+            if (opts.hasOwnProperty('followRedirects')) {
+                requestOpts.followRedirects = opts.followRedirects;
+            }
+            self._makeJsonRequest(requestOpts,
+                function _afterCall(err, req, res_, manifest_, body) {
+                res = res_;
                 if (err) {
                     if (err.statusCode === 401) {
                         // Convert into a 404 error.
@@ -1404,6 +1413,119 @@ RegistryClientV2.prototype.getManifest = function getManifest(opts, cb) {
 };
 
 
+/**
+ * Makes a http request to the given url, following any redirects, then fires
+ * the callback(err, req, responses) with the result.
+ *
+ * Note that 'responses' is an *array* of restify http response objects, with
+ * the last response being at the end of the array. When there is more than
+ * one response, it means a redirect has been followed.
+ */
+RegistryClientV2.prototype._makeHttpRequest =
+function _makeHttpRequest(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.string(opts.method, 'opts.method');
+    assert.string(opts.path, 'opts.path');
+    assert.string(opts.url, 'opts.url');
+    assert.optionalObject(opts.headers, 'opts.headers');
+    assert.optionalBool(opts.followRedirects, 'opts.followRedirects');
+    assert.optionalNumber(opts.maxRedirects, 'opts.maxRedirects');
+    assert.func(cb, 'cb');
+
+    var followRedirects = true;
+    if (opts.hasOwnProperty('followRedirects')) {
+        followRedirects = opts.followRedirects;
+    }
+    var maxRedirects = opts.maxRedirects || 3;
+    var numRedirs = 0;
+    var req;
+    var ress = [];
+
+    // We want a non-redirect (i.e. non-3xx) response to return. Use a
+    // barrier to gate that.
+    var barrier = vasync.barrier();
+    barrier.on('drain', function _onGetNonRedirResult() {
+        self.log.trace({res: ress[ress.length - 1]},
+            'got a non-redir response');
+        cb(null, req, ress);
+    });
+
+    function makeReq(reqOpts) {
+        if (numRedirs >= maxRedirects) {
+            cb(new errors.DownloadError(fmt(
+                'maximum number of redirects (%s) hit',
+                maxRedirects)), req, ress);
+            return;
+        }
+        numRedirs += 1;
+
+        var client = restifyClients.createHttpClient(common.objMerge({
+            url: reqOpts.url
+        }, self._commonHttpClientOpts));
+        self._clientsToClose.push(client);
+
+        client[opts.method](reqOpts, function _onConn(connErr, req_) {
+            if (connErr) {
+                cb(connErr, req, ress);
+                return;
+            }
+            req = req_;
+            req.on('result', function (err, res) {
+                ress.push(res);
+                if (err) {
+                    cb(err, req, ress);
+                    return;
+                }
+                if (followRedirects &&
+                    (res.statusCode === 302 || res.statusCode === 307)) {
+                    var loc = mod_url.parse(res.headers.location);
+                    makeReq({
+                        url: loc.protocol + '//' + loc.host,
+                        path: loc.path
+                    });
+                } else {
+                    // party like it's node 0.10
+                    common.pauseStream(res);
+                    barrier.done('nonRedirRes');
+                }
+            });
+        });
+    }
+
+    barrier.start('nonRedirRes');
+    makeReq({
+        url: opts.url,
+        path: opts.path,
+        headers: opts.headers
+    });
+};
+
+/**
+ * Makes a http request to the given url, following any redirects, then parses
+ * the (JSON) response and fires the callback(err, req, res, obj, body) with
+ * the result. Note that 'obj' is the parsed JSON response object, 'body' is
+ * the raw response body string.
+ */
+RegistryClientV2.prototype._makeJsonRequest =
+function _makeJsonRequest(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    self._makeHttpRequest(opts, function (err, req, responses) {
+        var res = responses ? responses[responses.length - 1] : null;
+        if (err) {
+            cb(err, req, res);
+            return;
+        }
+        // Parse the response body using the JSON client parser.
+        var parseFn = DockerJsonClient.prototype.parse.call(self._api, req, cb);
+        parseFn(err, res);
+        // Release the bulls!
+        res.resume();
+    });
+};
 
 RegistryClientV2.prototype._headOrGetBlob = function _headOrGetBlob(opts, cb) {
     var self = this;
@@ -1418,68 +1540,18 @@ RegistryClientV2.prototype._headOrGetBlob = function _headOrGetBlob(opts, cb) {
         function doLogin(_, next) {
             self.login(next);
         },
-        function call(_, next) {
-            // We want a non-redirect (i.e. non-3xx) response to return. Use a
-            // barrier to gate that.
-            var barrier = vasync.barrier();
-            barrier.on('drain', function _onGetNonRedirResult() {
-                self.log.trace(
-                    {res: ress[ress.length - 1], digest: opts.digest},
-                    'got a non-redir response');
-                next(null, ress);
-            });
-
-            var MAX_NUM_REDIRS = 3;
-            var numRedirs = 0;
-            function makeReq(reqOpts) {
-                if (numRedirs >= MAX_NUM_REDIRS) {
-                    next(new errors.DownloadError(fmt(
-                        'maximum number of redirects (%s) hit ' +
-                        'when attempting to get blob for digest %s',
-                        MAX_NUM_REDIRS, opts.digest)));
-                    return;
-                }
-                numRedirs += 1;
-
-                var client = restifyClients.createHttpClient(common.objMerge({
-                    url: reqOpts.url
-                }, self._commonHttpClientOpts));
-                self._clientsToClose.push(client);
-
-                client[opts.method](reqOpts, function _onConn(connErr, req) {
-                    if (connErr) {
-                        next(connErr);
-                        return;
-                    }
-                    req.on('result', function (err, res) {
-                        ress.push(res);
-                        if (err) {
-                            next(err);
-                            return;
-                        }
-                        if (res.statusCode === 302 || res.statusCode === 307) {
-                            var loc = mod_url.parse(res.headers.location);
-                            makeReq({
-                                url: loc.protocol + '//' + loc.host,
-                                path: loc.path
-                            });
-                        } else {
-                            // party like it's node 0.10
-                            common.pauseStream(res);
-                            barrier.done('nonRedirRes');
-                        }
-                    });
-                });
-            }
-
-            barrier.start('nonRedirRes');
-            makeReq({
+        function doRequest(_, next) {
+            self._makeHttpRequest({
+                method: opts.method,
                 url: self._url,
                 path: fmt('/v2/%s/blobs/%s',
                     encodeURI(self.repo.remoteName),
                     encodeURI(opts.digest)),
                 headers: self._headers
-            }, next);
+            }, function (err, req, responses) {
+                ress = responses;
+                next(err);
+            });
         }
     ]}, function (err) {
         cb(err, ress);
diff --git a/test/v2.dockerioprivate.test.js b/test/v2.dockerioprivate.test.js
index f93e1e7..cd8a44c 100644
--- a/test/v2.dockerioprivate.test.js
+++ b/test/v2.dockerioprivate.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -162,7 +162,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
      */
     var manifest;
     var manifestDigest;
-    tt.test('  getManifest', function (t) {
+    tt.test('  getManifest (v2.1)', function (t) {
         client.getManifest({ref: CONFIG.tag}, function (err, manifest_, res) {
             t.ifErr(err);
             manifest = manifest_;
@@ -178,15 +178,51 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
         });
     });
 
-    tt.test('  getManifest (by digest)', function (t) {
+    // Note: The manifestDigest returned above is for a v2.2 manifest (i.e. it
+    // was originally pushed as a v2.2 manifest), so requesting this digest via
+    // the v2.1 API will fail, as the digest will not match up!
+    tt.test('  getManifest (v2.1 by digest)', function (t) {
         client.getManifest({ref: manifestDigest}, function (err, manifest_) {
+            t.ok(err, 'expect an err');
+            t.notOk(manifest_);
+            t.equal(err.statusCode, 404);
+            t.end();
+        });
+    });
+
+    var v2Manifest;
+    var v2ManifestDigest;
+    tt.test('  getManifest (v2.2)', function (t) {
+        var getOpts = {ref: CONFIG.tag, maxSchemaVersion: 2};
+        client.getManifest(getOpts, function (err, manifest_, res) {
             t.ifErr(err);
-            t.ok(manifest);
-            ['schemaVersion',
-             'config',
-             'layers'].forEach(function (k) {
-               t.deepEqual(manifest_[k], manifest[k], k);
-            });
+            v2Manifest = manifest_;
+            v2ManifestDigest = res.headers['docker-content-digest'];
+            t.ok(v2Manifest);
+            t.equal(v2Manifest.schemaVersion, 2);
+            t.ok(v2Manifest.config);
+            t.ok(v2Manifest.config.digest);
+            t.ok(v2Manifest.layers);
+            t.ok(v2Manifest.layers.length > 0);
+            t.ok(v2Manifest.layers[0].digest);
+            t.end();
+        });
+    });
+
+    tt.test('  getManifest (v2.2 by digest)', function (t) {
+        var opts = {
+            maxSchemaVersion: 2,
+            ref: v2ManifestDigest
+        };
+        client.getManifest(opts, function (err, manifest_) {
+            t.ifErr(err);
+            t.ok(manifest_);
+            t.equal(manifest_.schemaVersion, 2);
+            t.ok(manifest_.config);
+            t.ok(manifest_.config.digest);
+            t.ok(manifest_.layers);
+            t.ok(manifest_.layers.length > 0);
+            t.ok(manifest_.layers[0].digest);
             t.end();
         });
     });
diff --git a/test/v2.gcrio.test.js b/test/v2.gcrio.test.js
index 814583d..ae527dd 100644
--- a/test/v2.gcrio.test.js
+++ b/test/v2.gcrio.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var crypto = require('crypto');
@@ -33,6 +33,7 @@ test('v2 gcr.io', function (tt) {
     tt.test('  createClient', function (t) {
         client = drc.createClientV2({
             name: REPO,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(client);
@@ -263,17 +264,19 @@ test('v2 gcr.io', function (tt) {
             t.equal(first.headers['docker-distribution-api-version'],
                 'registry/2.0');
 
-            t.ok(stream, 'got a stream');
-            t.equal(stream.statusCode, 200,
-                'got a 200 HTTP status: ' + stream.statusCode);
-            // At some point (by July 2017 at least), gcr started responding
-            // with `Content-Type: text/html` for this blob response for this
-            // image. Hrm.
-            // t.equal(stream.headers['content-type'],
-            //     'application/octet-stream');
-            t.ok(stream.headers['content-length'],
-                'got a Content-Length header: '
-                    + stream.headers['content-length']);
+            t.ok(stream);
+            t.equal(stream.statusCode, 200);
+            // Content-Type:
+            // - docker.io gives 'application/octet-stream', which is what
+            //   I'd expect for the GET response at least.
+            // - However gcr.io, at least for the iamge being tested, now
+            //   returns text/html.
+            t.equal(stream.headers['content-type'],
+                'text/html',
+                format('expect specific Content-Type on stream response; '
+                    + 'statusCode=%s headers=%j',
+                    stream.statusCode, stream.headers));
+            t.ok(stream.headers['content-length']);
 
             var numBytes = 0;
             var hash = crypto.createHash(digest.split(':')[0]);
diff --git a/test/v2.redhat.test.js b/test/v2.redhat.test.js
new file mode 100644
index 0000000..35f677a
--- /dev/null
+++ b/test/v2.redhat.test.js
@@ -0,0 +1,95 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Test v2 Registry API against <registry.access.redhat.com>.
+ */
+
+var test = require('tape');
+
+var drc = require('..');
+
+
+// --- globals
+
+var log = require('./lib/log');
+
+var REPO = 'registry.access.redhat.com/rhel';
+var TAG = '6.7';
+
+
+// --- Tests
+
+test('v2 registry.access.redhat.com', function (tt) {
+    var client;
+    var repo = drc.parseRepo(REPO);
+
+    tt.test('  createClient', function (t) {
+        client = drc.createClientV2({
+            log: log,
+            maxSchemaVersion: 2,
+            name: REPO
+        });
+        t.ok(client);
+        t.equal(client.version, 2);
+        t.end();
+    });
+
+    tt.test('  supportsV2', function (t) {
+        client.supportsV2(function (err, supportsV2) {
+            t.ifErr(err);
+            t.ok(supportsV2, 'supportsV2');
+            t.end();
+        });
+    });
+
+    tt.test('  ping', function (t) {
+        client.ping(function (err, body, res) {
+            t.ifErr(err, 'ping should not err');
+            t.ok(res, 'have a response');
+            if (res) {
+                t.equal(res.statusCode, 200);
+                t.equal(res.headers['docker-distribution-api-version'],
+                    'registry/2.0');
+            }
+            t.end();
+        });
+    });
+
+    tt.test(' getManifest (no redirects)', function (t) {
+        client.getManifest({ref: TAG, followRedirects: false},
+            function (err, manifest, res) {
+            // Should get a 302 error.
+            t.ok(err);
+            t.equal(res.statusCode, 302, 'statusCode should be 302');
+            t.end();
+        });
+    });
+
+    tt.test(' getManifest (redirected)', function (t) {
+        client.getManifest({ref: TAG}, function (err, manifest, res) {
+            t.ifErr(err);
+            t.ok(manifest, 'Got the manifest');
+            t.equal(manifest.schemaVersion, 1);
+            t.equal(manifest.name, repo.remoteName);
+            t.equal(manifest.tag, TAG);
+            t.ok(manifest.architecture);
+            t.ok(manifest.fsLayers);
+            t.ok(manifest.history[0].v1Compatibility);
+            t.ok(manifest.signatures[0].signature);
+            t.end();
+        });
+    });
+
+    tt.test(' close', function (t) {
+        client.close();
+        t.end();
+    });
+});
