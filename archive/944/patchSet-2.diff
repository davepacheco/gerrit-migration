commit 34187c8d09f5c478b15cf59f78741353be5da99b (refs/changes/44/944/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-11-23T15:30:11-08:00 (2 years, 10 months ago)
    
    CNS-176 ufds cn=changecount cannot be relied upon to match changenumber

diff --git a/lib/ufds-watcher.js b/lib/ufds-watcher.js
index 4a316b1..2e0f2b3 100644
--- a/lib/ufds-watcher.js
+++ b/lib/ufds-watcher.js
@@ -41,26 +41,176 @@ function UfdsWatcher(opts) {
 
 	this.pool = opts.ufdsPool;
 	this.pollerStream = opts.pollerStream;
-	this.lastSerial = -1;
+	this.lastSerial = undefined;
 	this.inCheck = false;
 
 	var self = this;
 	this.timer = setInterval(function () {
 		self.check();
 	}, 5000);
+
+	this.catchUp();
 }
 
+/*
+ * The first thing we need to do is figure out what changenumber (serial number)
+ * the UFDS changelog is at right now. Then we can start watching for new
+ * changes after that and analyzing them.
+ *
+ * You'd think UFDS would just provide something you could query for the latest
+ * changenumber, but it does not. Instead we have to do a two-part search
+ * through the log to find where it ends. It might have holes in it, so we
+ * have to make sure to do a >= search at every step and skip past the hole
+ * to the first entry after it.
+ *
+ * In mode 1, we exponentially increase the serial number until we hit an entry
+ * that is off the end of the log. Then we switch to mode 2, where we do a
+ * binary search between the last point we saw that was on the log, and the
+ * point we just hit. This gets us efficiently to the end of the log (takes
+ * 2-3 seconds against a 6.5M entry changelog).
+ */
+UfdsWatcher.prototype.catchUp = function () {
+	var self = this;
+	var log = self.log;
+	this.pool.claim(function (err, handle, ufds) {
+		if (err) {
+			log.error(err, 'failed to claim UFDS client');
+			setTimeout(function () {
+				self.catchUp();
+			}, 5000);
+			return;
+		}
+
+		var q = vasync.queue(trySerial, 1);
+		var mode = 1;
+		var low, high, highestFound;
+
+		function trySerial(serial, cb) {
+			var base = 'cn=changelog';
+			log.trace('trying at serial = %d (mode = %d)', serial,
+			    mode);
+			var opts = {
+				scope: 'one',
+				filter: new ldapjs.GreaterThanEqualsFilter({
+					attribute: 'changenumber',
+					value: serial.toString()
+				}),
+				attributes: ['changenumber'],
+				sizeLimit: 1
+			};
+			ufds.search(base, opts, function (err2, res) {
+				if (err2) {
+					log.error(err2, 'failed to query UFDS');
+					q.close();
+					cb();
+					return;
+				}
+				var gotEnt = false;
+				res.on('searchEntry', function (ent) {
+					var n;
+					gotEnt = true;
+					ent.attributes.forEach(function (attr) {
+						if (attr.type ===
+						    'changenumber') {
+							n = parseInt(
+							    attr.vals[0], 10);
+						}
+					});
+					if (n === undefined) {
+						throw (new Error(
+						    'ent missing num'));
+					}
+					if (highestFound === undefined ||
+					    n > highestFound) {
+						highestFound = n;
+					}
+				});
+				res.once('end', function () {
+					/* Mode 1: exponential increase. */
+					if (mode === 1 && gotEnt) {
+						q.push(highestFound * 2);
+
+					/* Mode 1: until we get no results. */
+					} else if (mode === 1) {
+						/* Switch to mode 2. */
+						low = highestFound;
+						high = serial;
+						mode = 2;
+						q.push(Math.round(
+						    low + (high - low) / 2));
+
+					/* Mode 2: binary search. */
+					} else if (mode === 2 && gotEnt) {
+						if (high - low > 1) {
+							low = highestFound;
+							q.push(Math.round(low +
+							    (high - low) / 2));
+						} else {
+							q.close();
+						}
+					} else if (mode === 2) {
+						if (high - low > 1) {
+							high = serial;
+							q.push(Math.round(low +
+							    (high - low) / 2));
+						} else {
+							q.close();
+						}
+					} else {
+						throw (new Error(
+						    'case not handled'));
+					}
+					cb();
+				});
+				res.once('error', function (err3) {
+					log.error(err3, 'while searching ufds');
+					q.close();
+					cb();
+				});
+			});
+		}
+		q.on('end', function () {
+			handle.release();
+			if (mode === 2 && high - low <= 1) {
+				log.trace('binary search finished, low = %d, ' +
+				    'high = %d', low, high);
+				self.lastSerial = low;
+				log.info('caught up to ufds at %d', low);
+			} else {
+				log.error({ mode: mode, low: low, high: high,
+				    highestFound: highestFound },
+				    'failed to catch up to ufds, will try ' +
+				    'again in 5s');
+				setTimeout(function () {
+					self.catchUp();
+				}, 5000);
+			}
+		});
+		q.push(1);
+	});
+};
+
+/*
+ * Check UFDS for any changelog entries newer than the last one we saw. If
+ * we see any, start this.fetch() to retrieve and analyze them.
+ */
 UfdsWatcher.prototype.check = function () {
+	if (this.lastSerial === undefined)
+		return;
 	if (this.inCheck)
 		return;
 	this.inCheck = true;
 
-	var base = 'cn=changelogcount';
+	var base = 'cn=changelog';
 	var opts = {
 		scope: 'one',
-		filter: new ldapjs.filters.PresenceFilter({
-			attribute: 'objectclass'
-		})
+		filter: new ldapjs.filters.GreaterThanEqualsFilter({
+			attribute: 'changenumber',
+			value: this.lastSerial.toString()
+		}),
+		attributes: ['changenumber'],
+		/* Just get the current one and one more (if it's there) */
+		sizeLimit: 2
 	};
 	var self = this;
 	this.pool.claim(function (err, handle, ufds) {
@@ -78,24 +228,29 @@ UfdsWatcher.prototype.check = function () {
 				return;
 			}
 
-			res.once('searchEntry', function (ent) {
+			var newSerial;
+			res.on('searchEntry', function (ent) {
 				var es = ent.attributes.filter(function (attr) {
-					return (attr.type === 'count');
+					return (attr.type === 'changenumber');
 				});
 				assert.strictEqual(es.length, 1);
-				var count = es[0].vals[0];
-				if (count > self.lastSerial) {
-					var last = self.lastSerial;
-					self.lastSerial = count;
-					self.log.trace('ufds serial now at ' +
-					    '%d', count);
-					if (last >= 0)
-						self.fetch(last);
-				}
+				/*
+				 * Don't bother comparing, UFDS always gives
+				 * us the entries in order anyway.
+				 */
+				newSerial = parseInt(es[0].vals[0], 10);
 			});
 			res.once('end', function () {
 				handle.release();
-				self.inCheck = false;
+				if (newSerial !== undefined &&
+				    newSerial > self.lastSerial) {
+					self.log.debug('ufds serial updated ' +
+					    '(saw %d, was %d)', newSerial,
+					    self.lastSerial);
+					self.fetch(self.lastSerial);
+				} else {
+					self.inCheck = false;
+				}
 			});
 			res.once('error', function (err3) {
 				self.log.error(err3, 'UFDS query failed');
@@ -109,37 +264,18 @@ UfdsWatcher.prototype.check = function () {
 UfdsWatcher.prototype.fetch = function (serial) {
 	var self = this;
 	var base = 'cn=changelog';
-	var flts = [];
-	flts.push(new ldapjs.filters.GreaterThanEqualsFilter({
-		attribute: 'changenumber',
-		value: serial
-	}));
-	flts.push(new ldapjs.filters.SubstringFilter({
-		attribute: 'targetdn',
-		'initial': 'uuid=',
-		'final': 'ou=users, o=smartdc'
-	}));
-	flts.push(new ldapjs.filters.OrFilter({
-		filters: [
-			new ldapjs.filters.EqualityFilter({
-				attribute: 'changetype',
-				value: 'add'
-			}),
-			new ldapjs.filters.EqualityFilter({
-				attribute: 'changetype',
-				value: 'modify'
-			})
-		]
-	}));
 	var opts = {
 		scope: 'one',
-		filter: new ldapjs.filters.AndFilter({
-			filters: flts
-		})
+		filter: new ldapjs.filters.GreaterThanEqualsFilter({
+			attribute: 'changenumber',
+			value: serial.toString()
+		}),
+		sizeLimit: 1000
 	};
 	this.pool.claim(function (err, handle, ufds) {
 		if (err) {
 			self.log.error(err, 'failed to claim UFDS client');
+			self.inCheck = false;
 			return;
 		}
 
@@ -147,6 +283,7 @@ UfdsWatcher.prototype.fetch = function (serial) {
 			if (err2) {
 				handle.release();
 				self.log.error(err2, 'UFDS query failed');
+				self.inCheck = false;
 				return;
 			}
 
@@ -158,6 +295,8 @@ UfdsWatcher.prototype.fetch = function (serial) {
 			});
 			res.once('end', function () {
 				handle.release();
+				self.log.info('processed up to UFDS serial %d',
+				    self.lastSerial);
 				Object.keys(uuids).forEach(function (uuid) {
 					var f = {
 						state: 'active',
@@ -169,37 +308,69 @@ UfdsWatcher.prototype.fetch = function (serial) {
 					self.ufdsCache.del(uuid);
 					self.pollerStream.start(f);
 				});
+				self.inCheck = false;
 			});
 			res.once('error', function (err3) {
 				self.log.error(err3, 'UFDS query failed');
 				handle.release();
+				self.inCheck = false;
 			});
 		});
 	});
 	function processEntry(ent) {
-		var es;
-
-		es = ent.attributes.filter(function (attr) {
-			return (attr.type === 'changenumber');
+		var logentry = {};
+		ent.attributes.forEach(function (attr) {
+			assert.strictEqual(logentry[attr.type], undefined);
+			assert.equal(attr.vals.length, 1);
+			logentry[attr.type] = attr.vals[0];
 		});
-		if (es.length !== 1)
-			return (false);
-		var n = es[0].vals[0];
-		if (typeof (n) === 'string')
-			n = parseInt(n, 10);
-		if (n == serial)
+
+		assert.string(logentry.targetdn, 'logentry.targetdn');
+		assert.string(logentry.changetype, 'logentry.changetype');
+		assert.strictEqual(logentry.objectclass, 'changeLogEntry');
+		assert.string(logentry.changetime, 'changetime');
+		assert.optionalString(logentry.entry, 'entry');
+		assert.string(logentry.changenumber, 'changenumber');
+		assert.string(logentry.changes, 'changes');
+
+		logentry.changenumber = parseInt(logentry.changenumber, 10);
+		if (logentry.changenumber <= serial)
 			return (false);
 
-		es = ent.attributes.filter(function (attr) {
-			return (attr.type === 'changes');
-		});
-		if (es.length !== 1)
+		/* Record that we've seen this entry. */
+		self.lastSerial = logentry.changenumber;
+
+		var dn = ldapjs.parseDN(logentry.targetdn);
+		var r;
+
+		/* We only care about DNs that look like a user record. */
+		r = dn.pop();
+		if (!r || !r.attrs.o || r.attrs.o.value !== 'smartdc')
+			return (false);
+		r = dn.pop();
+		if (!r || !r.attrs.ou || r.attrs.ou.value !== 'users')
 			return (false);
-		try {
-			var changes = JSON.parse(es[0].vals[0]);
-		} catch (e) {
+		r = dn.pop();
+		if (!r || !r.attrs.uuid)
 			return (false);
-		}
+		var uuid = r.attrs.uuid.value;
+		r = dn.pop();
+		if (r)
+			return (false);
+
+		logentry.changes = JSON.parse(logentry.changes);
+		var changes = logentry.changes;
+
+		/*
+		 * If there are any changes to the interesting fields that we
+		 * need to generate DNS records, we should re-poll this user's
+		 * VMs.
+		 *
+		 * Note that things like adminui and portal just unconditionally
+		 * write the triton_cns_enabled field for users even if they're
+		 * not changing its value. We make no effort to detect this,
+		 * and just play it safe for now.
+		 */
 		if (Array.isArray(changes)) {
 			var cs = changes.filter(function (ch) {
 				return (ch.operation === 'replace' &&
@@ -216,27 +387,6 @@ UfdsWatcher.prototype.fetch = function (serial) {
 				return (false);
 		}
 
-		es = ent.attributes.filter(function (attr) {
-			return (attr.type === 'targetdn');
-		});
-		if (es.length !== 1)
-			return (false);
-
-		var dn = ldapjs.parseDN(es[0].vals[0]);
-		var r;
-
-		r = dn.pop();
-		assert.strictEqual(r.attrs.o.value, 'smartdc');
-		r = dn.pop();
-		assert.strictEqual(r.attrs.ou.value, 'users');
-		r = dn.pop();
-
-		if (!r.attrs.uuid)
-			return (false);
-		var uuid = r.attrs.uuid.value;
-		if (dn.pop() !== undefined)
-			return (false);
-
 		return (uuid);
 	}
 };
