From a0713ca1ac64595d4ebb8d627a7643fa07f1bed1 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Mon, 26 Mar 2018 22:12:41 +0000
Subject: [PATCH] MANTA-3603 reshard service hugs SAPI to death MANTA-3604
 reshard service should not trust "params" from SAPI instance Reviewed by:
 Brittany Wald <brittany.wald@joyent.com> Approved by: Brittany Wald
 <brittany.wald@joyent.com>

---
 lib/executor.js                               |  54 ++++++-
 lib/phase_check_postgres_version.js           |   4 +-
 lib/phase_create_manatee_peers.js             |   7 +-
 lib/phase_create_morays.js                    |  12 +-
 lib/phase_delete_data.js                      |   7 +-
 lib/phase_freeze_cluster.js                   |   5 +-
 lib/phase_remap_ring.js                       |   4 +-
 lib/phase_restart_electric_moray_readonly.js  |   2 +-
 lib/phase_restart_electric_moray_readwrite.js |   2 +-
 lib/phase_shutdown_new_peers.js               |   4 +-
 lib/phase_unfreeze_cluster.js                 |   6 +-
 lib/phase_update_electric_moray_ring.js       |   4 +-
 lib/triton_access.js                          | 147 +++++++++++-------
 13 files changed, 164 insertions(+), 94 deletions(-)

diff --git a/lib/executor.js b/lib/executor.js
index 549cf60..14129eb 100644
--- a/lib/executor.js
+++ b/lib/executor.js
@@ -471,11 +471,55 @@ dispatch()
 
 			lib_triton_access.get_instance(ctx, uuid, callback);
 		},
-		get_instances: function (filter, callback) {
+		get_instances: function (filter, status, callback) {
 			mod_assert.object(filter, 'filter');
+			mod_assert.object(status, 'status');
 			mod_assert.func(callback, 'callback');
 
-			lib_triton_access.get_instances(ctx, filter, callback);
+			mod_assert.string(filter.service, 'filter.service');
+			status.update('listing instances of "%s"',
+			    filter.service);
+
+			mod_assert.optionalString(filter.shard, 'filter.shard');
+			if (filter.shard) {
+				status.prop('shard', filter.shard);
+			}
+
+			mod_assert.optionalUuid(filter.server, 'filter.server');
+			if (filter.server) {
+				status.prop('server', filter.server);
+			}
+
+			/*
+			 * Unlike most SAPI accesses which tend to request a
+			 * single object, the "get_instances()" routine can
+			 * potentially return a large quantity of results.  In
+			 * order to reduce the load on the SAPI server, we
+			 * serialise requests of this type.
+			 */
+			var ch = status.child();
+			ch.update('queued, waiting to use SAPI');
+			exe.exe_q_sapi.run(function (baton) {
+				ch.done();
+
+				if (ctl.pausing(callback)) {
+					baton.release();
+					return;
+				}
+
+				lib_triton_access.get_instances(ctx, filter,
+				    function (err, res) {
+					baton.release();
+
+					/*
+					 * Clean up the properties we used.
+					 */
+					status.prop('shard', null);
+					status.prop('server', null);
+
+					callback(err, res);
+				});
+			});
 		},
 		get_instance_ip: function (uuid, callback) {
 			lib_triton_access.get_instance_ip(ctx, uuid, callback);
@@ -909,6 +953,12 @@ Executor(opts)
 	 */
 	self.exe_q_moray = new lib_serial.SerialQueue('moray');
 
+	/*
+	 * In an attempt to avoid overloading SAPI, constrain the number of
+	 * SAPI requests we will make at once.
+	 */
+	self.exe_q_sapi = new lib_serial.SerialQueue('sapi');
+
 	self.exe_plan_problems = [];
 	self.exe_plan_run = {};
 	self.exe_switching = false;
diff --git a/lib/phase_check_postgres_version.js b/lib/phase_check_postgres_version.js
index 57b92b2..07f23fa 100644
--- a/lib/phase_check_postgres_version.js
+++ b/lib/phase_check_postgres_version.js
@@ -31,10 +31,8 @@ phase_check_postgres_version(ctl)
 			return;
 		}
 
-		status.update('listing instances of "postgres"');
-
 		ctl.get_instances({ service: 'postgres', shard: plan.shard },
-		    function (err, _insts) {
+		    status, function (err, _insts) {
 			if (err) {
 				done(err);
 				return;
diff --git a/lib/phase_create_manatee_peers.js b/lib/phase_create_manatee_peers.js
index ea2d460..c2cf2d0 100644
--- a/lib/phase_create_manatee_peers.js
+++ b/lib/phase_create_manatee_peers.js
@@ -53,9 +53,8 @@ phase_create_manatee_peers(ctl)
 			return;
 		}
 
-		status.update('listing instances of "postgres"');
 		ctl.get_instances({ service: 'postgres', shard: p.shard },
-		    function (err, _insts) {
+		    status, function (err, _insts) {
 			if (err) {
 				done(err);
 				return;
@@ -118,8 +117,8 @@ phase_create_manatee_peers(ctl)
 				return;
 			}
 
-			var this_server = i.params.server_uuid;
-			mod_assert.uuid(this_server, 'params.server_uuid');
+			var this_server = i.server_uuid;
+			mod_assert.uuid(this_server, 'i.server_uuid');
 
 			/*
 			 * Assign this Manatee peer to one of the server slots
diff --git a/lib/phase_create_morays.js b/lib/phase_create_morays.js
index 8928527..c3faec6 100644
--- a/lib/phase_create_morays.js
+++ b/lib/phase_create_morays.js
@@ -47,10 +47,8 @@ phase_create_morays(ctl)
 		/*
 		 * Collect the list of Moray instances for the target shard.
 		 */
-		status.update('listing instances of "moray"');
-		status.prop('shard', p.shard);
 		ctl.get_instances({ service: 'moray', shard: p.shard },
-		    function (err, _insts) {
+		    status, function (err, _insts) {
 			if (err) {
 				done(err);
 				return;
@@ -79,10 +77,8 @@ phase_create_morays(ctl)
 		 * associate them with the servers in the deployment plan.
 		 */
 		status.clear();
-		status.update('listing instances of "moray"');
-		status.prop('shard', p.new_shard);
 		ctl.get_instances({ service: 'moray', shard: p.new_shard },
-		    done);
+		    status, done);
 
 	}, function (_insts, done) {
 		var errors = [];
@@ -104,8 +100,8 @@ phase_create_morays(ctl)
 				return;
 			}
 
-			var this_server = i.params.server_uuid;
-			mod_assert.uuid(this_server, 'params.server_uuid');
+			var this_server = i.server_uuid;
+			mod_assert.uuid(this_server, 'i.server_uuid');
 
 			var assigned = false;
 			for (var j = 0; j < servers.length; j++) {
diff --git a/lib/phase_delete_data.js b/lib/phase_delete_data.js
index f7ad7fb..c02672e 100644
--- a/lib/phase_delete_data.js
+++ b/lib/phase_delete_data.js
@@ -121,8 +121,7 @@ phase_delete_data(ctl)
 			return;
 		}
 
-		status.update('listing instances of "electric-moray"');
-		ctl.get_instances({ service: 'electric-moray' },
+		ctl.get_instances({ service: 'electric-moray' }, status,
 		    function (err, _insts) {
 			if (err) {
 				done(err);
@@ -352,10 +351,8 @@ delete_ghost_data(ctl, vnode_data, delete_from_shard, ghost_shard, status,
 			return;
 		}
 
-		stch.update('listing instances of "postgres"');
-		stch.prop('shard', delete_from_shard);
 		ctl.get_instances({ service: 'postgres',
-		    shard: delete_from_shard }, done);
+		    shard: delete_from_shard }, stch, done);
 
 	}, function (_insts, done) {
 		if (ctl.pausing(done)) {
diff --git a/lib/phase_freeze_cluster.js b/lib/phase_freeze_cluster.js
index a35ddee..49c9cc4 100644
--- a/lib/phase_freeze_cluster.js
+++ b/lib/phase_freeze_cluster.js
@@ -30,11 +30,8 @@ phase_freeze_cluster(ctl)
 			return;
 		}
 
-		status.update('listing instances of "postgres"');
-		status.prop('shard', plan.shard);
-
 		ctl.get_instances({ service: 'postgres', shard: plan.shard },
-		    function (err, _insts) {
+		    status, function (err, _insts) {
 			if (err) {
 				done(err);
 				return;
diff --git a/lib/phase_remap_ring.js b/lib/phase_remap_ring.js
index a5f2ccf..bb47e20 100644
--- a/lib/phase_remap_ring.js
+++ b/lib/phase_remap_ring.js
@@ -149,9 +149,8 @@ phase_remap_ring(ctl)
 			return;
 		}
 
-		status.update('listing instances of "electric-moray"');
 		ctl.log.info('listing "electric-moray" instances');
-		ctl.get_instances({ service: 'electric-moray' },
+		ctl.get_instances({ service: 'electric-moray' }, status,
 		    function (err, insts) {
 			if (err) {
 				done(err);
@@ -193,6 +192,7 @@ phase_remap_ring(ctl)
 		 * Create a workspace in an Electric Moray zone.  Download
 		 * and unpack a copy of the latest hash ring database.
 		 */
+		status.clear();
 		status.update('remapping vnodes');
 		status.prop('via zone', emoray);
 		status.trunc();
diff --git a/lib/phase_restart_electric_moray_readonly.js b/lib/phase_restart_electric_moray_readonly.js
index cca91f5..e8bd526 100644
--- a/lib/phase_restart_electric_moray_readonly.js
+++ b/lib/phase_restart_electric_moray_readonly.js
@@ -26,7 +26,7 @@ phase_restart_electric_moray_readonly(ctl)
 			return;
 		}
 
-		ctl.get_instances({ service: 'electric-moray' },
+		ctl.get_instances({ service: 'electric-moray' }, status,
 		    function (err, _insts) {
 			if (err) {
 				done(err);
diff --git a/lib/phase_restart_electric_moray_readwrite.js b/lib/phase_restart_electric_moray_readwrite.js
index aa18b0f..01d75c7 100644
--- a/lib/phase_restart_electric_moray_readwrite.js
+++ b/lib/phase_restart_electric_moray_readwrite.js
@@ -26,7 +26,7 @@ phase_restart_electric_moray_readwrite(ctl)
 			return;
 		}
 
-		ctl.get_instances({ service: 'electric-moray' },
+		ctl.get_instances({ service: 'electric-moray' }, status,
 		    function (err, _insts) {
 			if (err) {
 				done(err);
diff --git a/lib/phase_shutdown_new_peers.js b/lib/phase_shutdown_new_peers.js
index 8257216..64dab0b 100644
--- a/lib/phase_shutdown_new_peers.js
+++ b/lib/phase_shutdown_new_peers.js
@@ -43,10 +43,8 @@ phase_shutdown_new_peers(ctl)
 			return;
 		}
 
-		status.update('listing instances of "postgres"');
-		status.prop('shard', p.shard);
 		ctl.get_instances({ service: 'postgres', shard: p.shard },
-		    function (err, _insts) {
+		    status, function (err, _insts) {
 			if (err) {
 				done(err);
 				return;
diff --git a/lib/phase_unfreeze_cluster.js b/lib/phase_unfreeze_cluster.js
index 3c64203..e112d45 100644
--- a/lib/phase_unfreeze_cluster.js
+++ b/lib/phase_unfreeze_cluster.js
@@ -56,10 +56,8 @@ unfreeze_shard(ctl, shard, status, callback)
 			return;
 		}
 
-		status.update('listing instances of "postgres"');
-		status.prop('shard', shard);
-
-		ctl.get_instances({ service: 'postgres', shard: shard }, done);
+		ctl.get_instances({ service: 'postgres', shard: shard }, status,
+		    done);
 
 	}, function (insts, done) {
 		if (ctl.pausing(done)) {
diff --git a/lib/phase_update_electric_moray_ring.js b/lib/phase_update_electric_moray_ring.js
index b55ed46..91a2aac 100644
--- a/lib/phase_update_electric_moray_ring.js
+++ b/lib/phase_update_electric_moray_ring.js
@@ -52,8 +52,7 @@ phase_update_electric_moray_ring(ctl)
 		opts.HASH_RING_IMGAPI_SERVICE =
 		    app.metadata.HASH_RING_IMGAPI_SERVICE;
 
-		status.update('listing instances of "electric-moray"');
-		ctl.get_instances({ service: 'electric-moray' }, done);
+		ctl.get_instances({ service: 'electric-moray' }, status, done);
 
 	}, function (_insts, done) {
 		if (ctl.pausing(done)) {
@@ -64,6 +63,7 @@ phase_update_electric_moray_ring(ctl)
 
 		var ilist = Object.keys(insts).sort();
 
+		status.clear();
 		status.update('updating hash ring in all %d Electric Moray ' +
 		    'instances', ilist.length);
 		ctl.log.info({ instances: ilist },
diff --git a/lib/triton_access.js b/lib/triton_access.js
index ac437a2..f373d3b 100644
--- a/lib/triton_access.js
+++ b/lib/triton_access.js
@@ -14,7 +14,8 @@ var mod_net = require('net');
 var mod_assert = require('assert-plus');
 var mod_verror = require('verror');
 var mod_vasync = require('vasync');
-var mod_jsprim = require('jsprim');
+
+var lib_common = require('../lib/common');
 
 var VE = mod_verror.VError;
 
@@ -148,82 +149,118 @@ get_instances(ctx, filter, callback)
 	mod_assert.object(filter, 'filter');
 	mod_assert.string(filter.service, 'filter.service');
 	mod_assert.optionalString(filter.shard, 'filter.shard');
+	mod_assert.optionalUuid(filter.server, 'filter.server');
 
-	ctx.ctx_sapi.getApplicationObjects(ctx.ctx_app.uuid,
-	    { include_master: true }, function (err, res) {
-		if (err) {
-			callback(new VE(err, 'load Manta application objects'));
-			return;
-		}
+	mod_vasync.waterfall([ function gis_get_service(done) {
+		get_service(ctx, filter.service, done);
 
-		mod_assert.object(res.services, 'services');
-		mod_assert.object(res.instances, 'instances');
+	}, function gis_list_instances(service, done) {
+		mod_assert.uuid(service.uuid, 'service.uuid');
 
-		var found = {};
-		mod_jsprim.forEachKey(res.services, function (uuid, service) {
-			if (service.name === filter.service) {
-				mod_assert.arrayOfObject(res.instances[uuid],
-				    'res.instances[' + uuid + ']');
-
-				res.instances[uuid].forEach(function (i) {
-					mod_assert.uuid(i.params.server_uuid,
-					    'i.params.server_uuid');
-
-					if (filter.hasOwnProperty('shard') &&
-					    filter.shard !==
-					    i.metadata.SERVICE_NAME) {
-						return;
-					}
-
-					if (filter.hasOwnProperty('server') &&
-					    filter.server !==
-					    i.params.server_uuid) {
-						return;
-					}
-
-					if (!filter.hasOwnProperty('shard') ||
-					    filter.shard ===
-					    i.metadata.SERVICE_NAME) {
-						found[i.uuid] = i;
-					}
-				});
+		/*
+		 * Load all instances of the nominated service.
+		 */
+		ctx.ctx_sapi.listInstances({
+			include_master: true,
+			service_uuid: service.uuid
+		}, function (err, res) {
+			if (err) {
+				done(new VE(err, 'load instances of service ' +
+				    '"%s"', filter.service));
+				return;
 			}
+
+			mod_assert.arrayOfObject(res, 'res');
+			done(null, res);
 		});
 
+	}, function gis_filter_instances_shard(instances, done) {
+		mod_assert.arrayOfObject(instances, 'instances');
+		mod_assert.func(done, 'done');
+
+		if (filter.hasOwnProperty('shard')) {
+			instances = instances.filter(function (i) {
+				return (filter.shard ===
+				    i.metadata.SERVICE_NAME);
+			});
+		}
+
+		setImmediate(done, null, instances);
+
+	}, function gis_vmapi_augment(instances, done) {
 		/*
-		 * Unfortunately SAPI doesn't keep "params.image_uuid"
-		 * up to date when you use "sapiadm reprovision".  As such,
-		 * we should fetch the image UUID from VMAPI.
+		 * SAPI does not, itself, keep the contents of "params" current
+		 * when the operator uses "sapiadm reprovision" to update a
+		 * zone, or if a zone is manually migrated to another server.
+		 * As such, we fetch the current server and image UUID from
+		 * VMAPI and ignore the values in "params".
 		 */
-		mod_vasync.forEachPipeline({ inputs: Object.keys(found),
-		    func: function (uuid, next) {
-			var inst = found[uuid];
-
-			var dc = inst.metadata.DATACENTER;
-			mod_assert.string(dc, 'inst.metadata.DATACENTER');
+		mod_vasync.forEachPipeline({ inputs: instances,
+		    func: function gis_vmapi_augment_one(i, next) {
+			var dc = i.metadata.DATACENTER;
+			mod_assert.string(dc, 'i.metadata.DATACENTER');
 
 			var vmapi = ctx.ctx_dcs[dc].dc_clients.dcc_vmapi;
 
-			vmapi.getVm({ uuid: uuid }, function (err, vm) {
+			vmapi.getVm({ uuid: i.uuid }, function (err, vm) {
 				if (err) {
-					next(err);
+					next(new VE(err, 'augment instance ' +
+					    '%s from VMAPI (%s)', i.uuid, dc));
+					return;
+				}
+
+				if (!lib_common.is_uuid(vm.image_uuid)) {
+					next(new VE('VMAPI (%s) has no ' +
+					    'image UUID for instance %s', dc,
+					    i.uuid));
 					return;
 				}
+				i.image_uuid = vm.image_uuid;
 
-				mod_assert.uuid(vm.image_uuid, 'vm.image_uuid');
+				if (!lib_common.is_uuid(vm.server_uuid)) {
+					next(new VE('VMAPI (%s) has no ' +
+					    'server UUID for instance %s', dc,
+					    i.uuid));
+					return;
+				}
+				i.server_uuid = vm.server_uuid;
 
-				inst.image_uuid = vm.image_uuid;
 				next();
 			});
 
 		}}, function (err) {
-			if (err) {
-				callback(err);
-				return;
-			}
+			done(err, instances);
+		});
+
+	}, function gis_filter_instances_server(instances, done) {
+		mod_assert.arrayOfObject(instances, 'instances');
+		mod_assert.func(done, 'done');
+
+		if (filter.hasOwnProperty('server')) {
+			instances = instances.filter(function (i) {
+				mod_assert.uuid(i.server_uuid, 'i.server_uuid');
+
+				return (filter.server === i.server_uuid);
+			});
+		}
+
+		setImmediate(done, null, instances);
+
+	} ], function (err, instances) {
+		if (err) {
+			callback(new VE(err, 'get instances matching %j',
+			    filter));
+			return;
+		}
 
-			callback(null, found);
+		var found = {};
+		instances.forEach(function (i) {
+			mod_assert.uuid(i.uuid, 'i.uuid');
+
+			found[i.uuid] = i;
 		});
+
+		callback(null, found);
 	});
 }
 
-- 
2.21.0

