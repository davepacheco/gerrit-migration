From aaa507314a29896ae09de5d493145c6e760f5ba9 Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Tue, 12 Mar 2019 16:58:50 -0700
Subject: [PATCH] TRITON-1305 sdcadm: add Procedure.prepare API, standard
 runProcs(), convert 'sdcadm create'

---
 CHANGES.md                  |   5 +
 lib/cli/do_create.js        | 399 ++++++++++++++++--------------------
 lib/common.js               |  44 +++-
 lib/procedures/index.js     | 173 +++++++++++++++-
 lib/procedures/procedure.js | 103 +++++++++-
 lib/sdcadm.js               |   2 -
 package.json                |   8 +-
 7 files changed, 488 insertions(+), 246 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index 623b2c8..33d4e94 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -10,6 +10,11 @@
 
 # sdcadm Changelog
 
+## 1.24.10
+
+- TRITON-1305 Improvements to internal "Procedures" API. Convert
+  'sdcadm create'.
+
 ## 1.24.9
 
 - TRITON-1300 Start improving CLI output with a `<cli>.ui` interface. So far
diff --git a/lib/cli/do_create.js b/lib/cli/do_create.js
index 4092041..32481ca 100644
--- a/lib/cli/do_create.js
+++ b/lib/cli/do_create.js
@@ -5,251 +5,149 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * The 'sdcadm create' CLI subcommand.
  */
 
-var p = console.log;
 var util = require('util');
 
 var assert = require('assert-plus');
 var vasync = require('vasync');
 
-var common = require('../common');
 var errors = require('../errors');
+var Procedure = require('../procedures/procedure').Procedure;
+var runProcs = require('../procedures').runProcs;
 var steps = require('../steps');
 
-/*
- * The 'sdcadm create' CLI subcommand.
- */
 
-function Create(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.cli, 'opts.cli');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.sdcadm, 'opts.sdcadm');
-    assert.func(opts.progress, 'opts.progress');
-    assert.string(opts.uuid, 'opts.uuid');
-
-    this.log = opts.log;
-    this.sdcadm = opts.sdcadm;
-    this.progress = opts.progress;
-    this.uuid = opts.uuid;
-    this.cli = opts.cli;
-}
+function CreateInstanceProcedure(opts) {
+    assert.string(opts.svcName, 'opts.svcName');
+    assert.arrayOfString(opts.serverNames, 'opts.serverNames');
+    assert.ok(opts.serverNames.length > 0, 'at least one server name');
+    assert.optionalUuid(opts.imageUuid, 'opts.imageUuid');
+    assert.optionalString(opts.imageChannel, 'opts.imageChannel');
+    assert.optionalBool(opts.skipHACheck, 'opts.skipHACheck');
 
-Create.prototype.name = 'create';
+    this.svcName = opts.svcName;
+    this.serverNames = opts.serverNames;
+    this.imageUuid = opts.imageUuid;
+    this.imageChannel = opts.imageChannel;
+    this.skipHACheck = Boolean(opts.skipHACheck);
+}
+util.inherits(CreateInstanceProcedure, Procedure);
 
-Create.prototype.execute = function cExecute(opts, args, cb) {
-    assert.object(opts, 'opts');
-    assert.object(args, 'args');
-    assert.func(cb, 'cb');
+CreateInstanceProcedure.prototype.prepare = function prepare(opts, cb) {
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+    assert.object(opts.log, 'opts.log');
 
+    var log = opts.log;
+    var sdcadm = opts.sdcadm;
     var self = this;
+    var ui = opts.ui;
 
-    var unlock;
-    var svcs;
-    var svcFromName;
-    var changes = [];
-    var plan;
-    var execStart;
-
-    var serverNames = opts.servers || [];
-    // In case the deprecated 'server' option is provided, just add it to
-    // the new 'servers' option.
-    if (opts.server) {
-        serverNames.push(opts.server);
-    }
+    vasync.pipeline({arg: {}, funcs: [
+        sdcadm.ensureSdcApp.bind(sdcadm),
 
-    if (serverNames.length === 0) {
-        cb(new errors.UsageError(
-            'Must specify at least one server via "-s, --servers" option'));
-        return;
-    }
-
-    var context = {
-        sdcadm: self.sdcadm,
-        log: self.log,
-        serverNames: serverNames
-    };
-
-    vasync.pipeline({ arg: context, funcs: [
-        function ensureSdcApp(_, next) {
-            self.sdcadm.ensureSdcApp({}, function (err) {
+        function gatherServiceInfo(_, next) {
+            ui.info('Gathering SAPI service data');
+            sdcadm.getSvc({
+                app: 'sdc',
+                svc: self.svcName
+            }, function (err, svc) {
                 if (err) {
                     next(err);
-                    return;
-                }
-                // Set or override the default channel if anything is given:
-                if (opts.channel) {
-                    self.sdcadm.updates.channel = opts.channel;
+                } else {
+                    self.svc = svc;
+                    next();
                 }
-                next();
-            });
-        },
-        function getLock(_, next) {
-            self.sdcadm.acquireLock({progress: self.progress},
-                                    function (lockErr, unlock_) {
-                unlock = unlock_;
-                next(lockErr);
             });
         },
 
-        steps.servers.serversFromServerNames, // ctx.serverNames -> ctx.servers
-        steps.servers.ensureServersSetup,
-        steps.servers.ensureServersRunning,
-
-        function getSvcs(_, next) {
-            self.sdcadm.getServices({}, function (err, svcs_) {
-                svcs = svcs_;
-                svcFromName = {};
-                var i;
-                for (i = 0; i < svcs.length; i += 1) {
-                    svcFromName[svcs[i].name] = svcs[i];
-                }
+        function gatherServerInfo(_, next) {
+            ui.info('Gathering server data');
+            steps.servers.selectServers({
+                log: log,
+                sdcadm: sdcadm,
+                includeServerNames: self.serverNames
+            }, function selectedServers(err, servers) {
+                self.servers = servers;
                 next(err);
             });
         },
 
-        function getChangeFromArgs(ctx, next) {
-            if (args.length === 0) {
-                next(new errors.UsageError(
-                    'Must specify service name or uuid'));
-                return;
-            }
-
-            var service = args[0];
-            var change = {};
-            if (svcFromName[service] === undefined) {
-                next(new errors.UsageError(
-                    'unknown service: ' + service));
-                return;
+        function determineImage(ctx, next) {
+            // Set or override the default channel if anything is given.
+            //
+            // Dev Note: The way we set the channel indirectly here is too
+            // subtle. It would be better to improve image resolution to
+            // pass the channel explicitly through.
+            if (this.imageChannel) {
+                sdcadm.updates.channel = this.imageChannel;
             }
 
-            change.servers = ctx.servers.map(function (s) { return s.uuid; });
-            change.service = args[0];
-
-            if (opts.image) {
-                change.image = opts.image;
-            } else if (svcFromName[service].params) {
-                change.image = svcFromName[service].params.image_uuid;
-            }
-
-            /*
-             * TOOLS-1719: Fail graceful if service doesn't have an associated
-             * image, instead of downloading the latest available image for
-             * service
-             */
-            if (!change.image) {
-                next(new errors.ValidationError(util.format(
-                    'Missing image_uuid for service %s in SAPI.', service)));
-                return;
+            ctx.image = null;
+            if (this.imageUuid) {
+                ctx.image = opts.imageUuid;
+            } else {
+                // Default to the set `image_uuid` on the SAPI service.
+                if (!self.svc.params || !self.svc.params.image_uuid) {
+                    next(new errors.ValidationError(util.format(
+                        'SAPI "%s" service is missing params.image_uuid',
+                        self.svc.name)));
+                    return;
+                }
+                ctx.image = self.svc.params.image_uuid;
             }
 
-            change.type = 'create-instances';
-            changes.push(change);
             next();
         },
 
-        function genPlan(_, next) {
-            self.log.debug('genPlan');
-            self.sdcadm.genUpdatePlan({
-                changes: changes,
-                progress: self.progress,
-                uuid: self.uuid,
-                skipHACheck: opts.dev_allow_multiple_instances,
+        function generatePlan(ctx, next) {
+            var change = {
+                type: 'create-instances',
+                service: self.svcName,
+                servers: self.servers.map(function (s) { return s.uuid; }),
+                image: ctx.image
+            };
+            log.debug({change: change}, 'CreateInstanceProcedure change');
+
+            sdcadm.genUpdatePlan({
+                changes: [change],
+                progress: ui.progressFunc(),
+                skipHACheck: self.skipHACheck,
                 forceDataPath: true
-            }, function (err, plan_) {
-                plan = plan_;
+            }, function (err, plan) {
+                self.plan = plan;
                 next(err);
             });
-        },
-        function confirm(_, next) {
-            if (plan.procs.length === 0) {
-                next();
-                return;
-            }
-            p('');
-            p('This command will make the following changes:');
-            self.sdcadm.summarizePlan({plan: plan, progress: self.progress});
-            p('');
-            if (opts.yes) {
-                next();
-                return;
-            }
-            var msg = 'Would you like to continue? [y/N] ';
-            common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
-                if (answer !== 'y') {
-                    p('Aborting');
-                    cb();
-                    return;
-                }
-                p('');
-                next();
-            });
-        },
-        function execPlan(_, next) {
-            execStart = Date.now();
-            if (plan.procs.length === 0) {
-                next();
-                return;
-            }
-            if (opts.dry_run) {
-                p('[dry-run] done');
-                next();
-                return;
-            }
-            self.sdcadm.execUpdatePlan({
-                plan: plan,
-                progress: self.progress,
-                uuid: self.uuid
-            }, next);
         }
-    ]}, function finishCreate(err) {
-        vasync.pipeline({funcs: [
-            function dropLock(_, next) {
-                if (!unlock) {
-                    next();
-                    return;
-                }
-                self.sdcadm.releaseLock({unlock: unlock}, next);
-            }
-        ]}, function done(finishCreateErr) {
-            // We shouldn't ever get a `finishCreateErr`.
-            // Let's be loud if we do.
-            if (finishCreateErr) {
-                self.log.fatal({err: finishCreateErr},
-                    'unexpected error finishing create');
-            }
-            if (err || finishCreateErr) {
-                cb(err || finishCreateErr);
-                return;
-            }
-
-            if (plan.procs.length === 0) {
-                p('No-op.');
-            } else {
-                p('Created successfully (elapsed %ds).',
-                    Math.floor((Date.now() - execStart) / 1000));
-            }
-            cb();
-        });
+    ]}, function finish(err) {
+        cb(err, false);
     });
 };
 
 
-Create.prototype.help = (
-    'Create one or more instances for an existing SDC service.\n' +
-    '\n' +
-    'Usage:\n' +
-    '       {{name}} create <svc>\n\n' +
-    'Note that in order to create an instance of some services the option\n' +
-    '--dev-allow-multiple-instances must be specified, given that those\n' +
-    'services are not supposed to have more than one instance. There are\n' +
-    'also some services whose instances should not be created using\n' +
-    'this tool, like manatee or binder. Finally, the first instance of some\n' +
-    'services should not be created using this tool when there is an\n' +
-    'alternate choice provided by post-setup subcommand.\n'
-);
+CreateInstanceProcedure.prototype.summarize = function summarize() {
+    var summaries = this.plan.procs.map(proc => proc.summarize());
+    return summaries.join('\n');
+};
+
+CreateInstanceProcedure.prototype.execute = function execute(opts, cb) {
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+
+    opts.sdcadm.execUpdatePlan(
+        {
+            plan: this.plan,
+            progress: opts.ui.progressFunc()
+        },
+        cb
+    );
+};
 
 
 // --- CLI
@@ -260,17 +158,49 @@ function do_create(subcmd, opts, args, cb) {
     if (opts.help) {
         this.do_help('help', {}, [subcmd], cb);
         return;
+    } else if (args.length < 1) {
+        cb(new errors.UsageError('missing SERVICE argument'));
+        return;
+    } else if (args.length > 1) {
+        cb(new errors.UsageError('too many arguments'));
+        return;
     }
 
-    var proc = new Create({
-        sdcadm: self.sdcadm,
+    if (opts.servers && opts.server) {
+        cb(new errors.UsageError(
+            'cannot specify both "--server SERVER" (deprecated) and ' +
+            '"--servers SERVERS" options'));
+        return;
+    }
+    var serverNames = opts.servers;
+    if (!serverNames && opts.server) {
+        serverNames = [opts.server];
+    }
+    if (!serverNames) {
+        cb(new errors.UsageError(
+            'must specify at least one server via the "-s, --servers" option'));
+        return;
+    }
+
+    var procs = [
+        new CreateInstanceProcedure({
+            svcName: args[0],
+            serverNames: opts.servers,
+            imageUuid: opts.image,
+            imageChannel: opts.channel,
+            skipHACheck: opts.dev_allow_multiple_instances
+        })
+    ];
+    runProcs({
         log: self.log,
-        uuid: self.uuid,
-        progress: self.progress,
-        cli: self
+        procs: procs,
+        sdcadm: self.sdcadm,
+        ui: self.ui,
+        dryRun: opts.dry_run,
+        skipConfirm: opts.yes
+    }, function done(err) {
+        cb(err);
     });
-    opts.experimental = false;
-    proc.execute(opts, args, cb);
 }
 
 
@@ -285,16 +215,33 @@ do_create.options = [
         type: 'bool',
         help: 'Go through the motions without actually creating.'
     },
+    {
+        names: ['yes', 'y'],
+        type: 'bool',
+        help: 'Answer yes to all confirmations.'
+    },
+    {
+        names: ['dev-allow-multiple-instances'],
+        type: 'bool',
+        help: 'Allow additional instances to be created even if the service ' +
+              'is not HA ready (for development purposes).'
+    },
+    {
+        group: 'Instance options'
+    },
     {
         names: ['image', 'i'],
         type: 'string',
-        help: 'UUID of the Image to be used for the instance.'
+        help: 'UUID of the service image to use for the new instance(s). ' +
+            'By default the image configured on the service (in SAPI) is used.',
+        helpArg: 'UUID'
     },
     {
         names: ['channel', 'C'],
         type: 'string',
-        help: 'Use the given channel to fetch the image, even if it is ' +
-            'not the default one.'
+        help: 'The updates.joyent.com channel from which to fetch the image ' +
+            'given in the "--image UUID" option.',
+        helpArg: 'CHAN'
     },
     {
         // Deprecated in favour of `-s,--servers`
@@ -308,24 +255,24 @@ do_create.options = [
         help: 'Comma separated list of servers (either hostnames or uuids) ' +
             'on which to create the instance(s).',
         helpArg: 'SERVERS'
-    },
-    {
-        names: ['yes', 'y'],
-        type: 'bool',
-        help: 'Answer yes to all confirmations.'
-    },
-    {
-        names: ['dev-allow-multiple-instances'],
-        type: 'bool',
-        help: 'Allow additional instances to be created even if the service ' +
-              'is not HA ready (for development purposes).'
     }
 ];
 
 do_create.help = (
-    Create.prototype.help +
+    'Create one or more instances of an existing Triton VM service.\n' +
+    '\n' +
+    'Usage:\n' +
+    '       {{name}} create SERVICE\n' +
+    '\n' +
+    '{{options}}' +
     '\n' +
-    '{{options}}'
+    'Note that in order to create an instance of some services the option\n' +
+    '--dev-allow-multiple-instances must be specified, given that those\n' +
+    'services are not supposed to have more than one instance. There are\n' +
+    'also some services whose instances should not be created using\n' +
+    'this tool, like manatee or binder. Finally, the first instance of some\n' +
+    'services should not be created using this tool when there is an\n' +
+    'alternate choice provided by post-setup subcommand.\n'
 );
 
 do_create.logToFile = true;
diff --git a/lib/common.js b/lib/common.js
index b244b46..380c4c2 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -5,9 +5,11 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var child_process = require('child_process'),
     exec = child_process.exec,
@@ -23,6 +25,7 @@ var vasync = require('vasync');
 var backoff = require('backoff');
 var once = require('once');
 var sprintf = require('extsprintf').sprintf;
+var VError = require('verror');
 
 var errors = require('./errors');
 var InternalError = errors.InternalError;
@@ -1776,6 +1779,42 @@ function utcTimestamp(start) {
     return stamp;
 }
 
+// This takes a VError instance that might be a MultiError of MultiErrors
+// and will return a flattened VError (if just one) or MultiError.
+function flattenMultiError(err) {
+    // Dev Note: It is possible that these MultiError instances are not from the
+    // same `verror` import as in this module. That means that
+    // `VError.errorForEach` may not work as expected due to a `instanceof
+    // MultiError` check, so we cannot use that method.
+    function errsFromVError(e) {
+        var errs = [];
+        if (e.constructor.name === 'MultiError') {
+            // `MultiError.prototype.errors()` added in verror@1.7.0.
+            if (typeof (e.errors) === 'function') {
+                e.errors().map(function (subErr) {
+                    errs = errs.concat(errsFromVError(subErr));
+                });
+            } else {
+                // MultiError was added to verror@1.1.0 and since the beginning
+                // had a `.ase_errors` array (for its own historical reasons).
+                for (let subErr of e.ase_errors) {
+                    errs = errs.concat(errsFromVError(subErr));
+                }
+            }
+        } else {
+            errs.push(e);
+        }
+        return errs;
+    }
+
+    if (!err) {
+        return null;
+    }
+
+    var flattenedErrs = errsFromVError(err);
+    return VError.errorFromList(flattenedErrs);
+}
+
 // --- exports
 
 module.exports = {
@@ -1813,6 +1852,7 @@ module.exports = {
     unmountUsbKey: unmountUsbKey,
     copyFile: copyFile,
     safeCycles: safeCycles,
-    utcTimestamp: utcTimestamp
+    utcTimestamp: utcTimestamp,
+    flattenMultiError: flattenMultiError
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index 4fcb6f3..dd33a61 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -19,7 +19,7 @@ var os = require('os');
 var util = require('util'),
     format = util.format;
 var vasync = require('vasync');
-var verror = require('verror');
+var VError = require('verror');
 
 var common = require('../common');
 var errors = require('../errors'),
@@ -279,7 +279,7 @@ function coordinatePlan(opts, cb) {
                     changes: handle
                 }));
             }
-            next(verror.errorFromList(errs));
+            next(VError.errorFromList(errs));
         },
 
         function updateSingleHeadnodeImgapi(_, next) {
@@ -574,7 +574,7 @@ function coordinatePlan(opts, cb) {
                     changes: handle
                 }));
             }
-            next(verror.errorFromList(errs));
+            next(VError.errorFromList(errs));
         },
 
         function updateBinder(_, next) {
@@ -621,7 +621,7 @@ function coordinatePlan(opts, cb) {
                     handle.length);
                 procs.push(new UpdateBinderV2({ changes: handle }));
             }
-            next(verror.errorFromList(errs));
+            next(VError.errorFromList(errs));
         },
 
 
@@ -800,7 +800,7 @@ function coordinatePlan(opts, cb) {
                 }
 
             }
-            next(verror.errorFromList(errs));
+            next(VError.errorFromList(errs));
         },
 
         function dockerLogger(_, next) {
@@ -865,7 +865,7 @@ function coordinatePlan(opts, cb) {
                     changes: handle
                 }));
             }
-            next(verror.errorFromList(errs));
+            next(VError.errorFromList(errs));
         },
 
         function createAgentInstance(_, next) {
@@ -1033,7 +1033,7 @@ function coordinatePlan(opts, cb) {
                         changes: handleDockerlogger
                     }));
                 }
-                next(verror.errorFromList(errs));
+                next(VError.errorFromList(errs));
             });
         },
 
@@ -1086,9 +1086,166 @@ function coordinatePlan(opts, cb) {
 }
 
 
+/*
+ * Appropriately run a given array of Procedure instances. This involves
+ * acquiring the sdcadm lock, running each procedure's "prepare", filtering
+ * out procedures that have "nothingToDo", summarizing, getting confirmation,
+ * executing, and reporting completion/error.
+ *
+ * Dev Note: Eventually `sdcadm update` ("do_update.js", `sdcadm.summarizePlan`,
+ * etc.) should use this, but currently it does not.
+ */
+function runProcs(opts, cb) {
+    assert.arrayOfObject(opts.procs, 'opts.procs');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+    assert.optionalBool(opts.skipConfirm, 'opts.skipConfirm');
+    assert.optionalBool(opts.dryRun, 'opts.dryRun');
+
+    var execStart;
+    var log = opts.log;
+    var procs = opts.procs;
+    var p = opts.ui.progressFunc();
+    var sdcadm = opts.sdcadm;
+    var ui = opts.ui;
+    var unlock;
+
+    vasync.pipeline({arg: {}, funcs: [
+        function getLock(_, next) {
+            sdcadm.acquireLock({
+                progress: p
+            }, function (lockErr, unlock_) {
+                unlock = unlock_;
+                next(lockErr);
+            });
+        },
+
+        // `prepare()` each procedure and filter out those that have
+        // "nothingToDo".
+        function prepareProcs(_, next) {
+            vasync.forEachParallel({
+                inputs: procs,
+                func: function prepareProc(proc, nextProc) {
+                    log.debug({procName: proc.constructor.name}, 'prepareProc');
+                    proc.prepare({
+                        sdcadm: sdcadm,
+                        ui: ui,
+                        log: log
+                    }, function preparedProc(err, nothingToDo) {
+                        if (err) {
+                            nextProc(err);
+                        } else {
+                            proc._nothingToDo = Boolean(nothingToDo);
+                            if (proc._nothingToDo) {
+                                log.debug({procName: proc.constructor.name},
+                                    'proc has nothingToDo');
+                            }
+                            nextProc();
+                        }
+                    });
+                }
+            }, function (err) {
+                if (err) {
+                    next(common.flattenMultiError(err));
+                } else {
+                    // Filter out procs with nothing to do.
+                    procs = procs.filter(proc => !proc._nothingToDo);
+                    next();
+                }
+            });
+        },
+
+        function confirm(_, next) {
+            if (procs.length === 0) {
+                ui.info('');
+                ui.info('Nothing to do.');
+                next(true); // Early abort.
+                return;
+            }
+
+            ui.info('');
+            ui.info('This will make the following changes:');
+            for (let proc of procs) {
+                ui.info(common.indent(proc.summarize()));
+            }
+            ui.info('');
+            if (opts.skipConfirm) {
+                next();
+                return;
+            }
+            var msg = 'Would you like to continue? [y/N] ';
+            common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
+                if (answer !== 'y') {
+                    ui.info('Aborting.');
+                    next(true);
+                    return;
+                }
+                ui.info('');
+                next();
+            });
+        },
+
+        function exec(_, next) {
+            execStart = Date.now();
+            if (opts.dryRun) {
+                ui.info('Skipping execution (dry-run).');
+                next();
+                return;
+            }
+            vasync.forEachPipeline({
+                inputs: procs,
+                func: function execProc(proc, nextProc) {
+                    log.debug({summary: proc.summarize()}, 'execProc');
+                    proc.execute({
+                        sdcadm: sdcadm,
+                        // The `progress` arg is deprecated. Procs should switch
+                        // to `ui`.
+                        progress: p,
+                        ui: ui,
+                        log: log
+                    }, nextProc);
+                }
+            }, next);
+        }
+    ]}, function finishUp(err) {
+        // Early abort signal.
+        if (err === true) {
+            err = null;
+        }
+
+        vasync.pipeline({funcs: [
+            function dropLock(_, next) {
+                if (!unlock) {
+                    next();
+                    return;
+                }
+                sdcadm.releaseLock({unlock: unlock}, next);
+            }
+        ]}, function cleanedUp(cleanUpErr) {
+            // We shouldn't ever get a `cleanUpErr`. Let's be loud if we do.
+            if (cleanUpErr) {
+                log.fatal({err: cleanUpErr}, 'unexpected error cleaning up');
+            }
+            if (err || cleanUpErr) {
+                cb(err || cleanUpErr);
+                return;
+            }
+
+            if (execStart) {
+                ui.info('Completed successfully (%selapsed %ds).',
+                    (opts.dryRun ? 'dry-run, ' : ''),
+                    Math.floor((Date.now() - execStart) / 1000));
+            }
+            cb();
+        });
+    });
+}
+
 // --- exports
 
 module.exports = {
-    coordinatePlan: coordinatePlan
+    coordinatePlan: coordinatePlan,
+    runProcs: runProcs
 };
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/procedures/procedure.js b/lib/procedures/procedure.js
index 96454da..5f37b80 100644
--- a/lib/procedures/procedure.js
+++ b/lib/procedures/procedure.js
@@ -5,16 +5,111 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
-function Procedure() {}
+/*
+ * A "Procedure" API for managing execution of some of the larger sdcadm tasks.
+ * For smaller tasks encapsulated as a single function, see
+ * "lib/steps/README.md".
+ *
+ * `sdcadm` has a number of "Procedure" subclasses for doing some larger task,
+ * e.g. downloading images for an update, updating one of the simple stateless
+ * core service instances, updating manatee. The expected usage is:
+ *
+ * 1. create an array of one or more procedure objects:
+ *
+ *      var procs = [new DownloadImages(...), new UpdateMoray(...)];
+ *
+ * 2. prepare the procedures, during which they gather necessary information
+ *    from the system, error out if it cannot be accomplished, and callback
+ *    with whether they have work to do:
+ *
+ *          vasync.forEachParallel({
+ *              inputs: procs,
+ *              func: function prepareProc(proc, nextProc) {
+ *                  proc.prepare({
+ *                      log: log,
+ *                      ui: ui,
+ *                      sdcadm: sdcadm
+ *                  }, function onPrepare(err, nothingToDo) {
+ *                      // ...
+ *                  });
+ *              }
+ *          }, function (err) {
+ *              // ...
+ *          });
+ *
+ * 3. Use `.summarize(...)` for each procedure to show what will be done, and
+ *    get confirmation from the operator before proceeding.
+ *
+ * 4. Call `.execute(...)` on each procedure in series.
+ *
+ * See `runProcs()` in "lib/procedures/index.js" for a method to handle this
+ * usage.
+ */
+
+var assert = require('assert-plus');
+var VError = require('verror');
+
+
+// Create a procedure. All configuration defining a procedure should be
+// passed into its constructor.
+function Procedure(_opts) {}
+
+// Prepare the procedure. This involves:
+//
+// - gathering necessary system data to determine the exact steps to perform,
+// - calling back with an error if the procedure is not viable,
+//   (e.g. if a requested server is not running, or a required service is down),
+// - calling back with a boolean if the procedure has nothing to do (e.g. if
+//   an image to download is already in the DC's IMGAPI, or a service to add
+//   is already in SAPI)
+//
+// This will be called before `<procedure>.summarize`, so this provides an
+// opportunity for the procedure to gather info necessary for a useful
+// summary string.
+//
+// @param {Object} opts.log - Bunyan logger.
+// @param {Object} opts.sdcadm
+// @param {Object} opts.ui - see "lib/cli/ui.js".
+// @param {Function} cb - `function (err, nothingToDo)`
+//      `err` is null or is an Error with the reason(s) the procedure
+//      (as configured) cannot be performed. If `err` is null, and the procedure
+//      has nothing to do (the work has already been done), then `nothingToDo`
+//      is `true`. If so, then the caller need not call its `execute`.
+Procedure.prototype.prepare = function prepare(opts, cb) {
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+
+    // By default a procedure is viable and should be executed.
+    cb(null, false);
+};
+
+// @returns {String} A bullet point summary of work that will be done.
 Procedure.prototype.summarize = function summarize() {};
-Procedure.prototype.execute = function execute(_options, _cb) {};
 
-// --- exports
+// Execute the procedure.
+//
+// TODO: Spec the required `opts` for this. Currently there is a large
+// mishmash used in SdcAdm.execUpdatePlan. This should be reduced. Odd
+// params can come in via Procedure constructors.
+Procedure.prototype.execute = function execute(opts, cb) {
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.func(opts.progress, 'opts.progress');  // Deprecated. Use `ui`.
+    assert.object(opts.ui, 'opts.ui');
+
+    cb(new VError({name: 'NotImplementedError'},
+        this.constructor.name + '.execute() is not implemented'));
+};
+
+
+// ---- exports
 
 module.exports = {
     Procedure: Procedure
 };
+
 // vim: set softtabstop=4 shiftwidth=4:
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index 5b88add..c02eb29 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -1631,7 +1631,6 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
     assert.optionalBool(options.forceDataPath, 'opts.forceDataPath');
     assert.optionalBool(options.forceRabbitmq, 'options.forceRabbitmq');
     assert.optionalBool(options.forceSameImage, 'options.forceSameImage');
-    assert.optionalString(options.uuid, 'options.uuid');
     assert.optionalBool(options.keepAllImages, 'options.keepAllImages');
     assert.optionalBool(options.noVerbose, 'options.noVerbose');
     assert.optionalBool(options.justAvailable, 'options.justAvailable');
@@ -2493,7 +2492,6 @@ SdcAdm.prototype.execUpdatePlan = function execUpdatePlan(options, cb) {
     assert.object(options.plan, 'options.plan');
     assert.optionalFunc(options.progress, 'options.progress');
     assert.optionalBool(options.dryRun, 'options.dryRun');
-    assert.optionalString(options.uuid, 'options.uuid');
     assert.optionalNumber(options.concurrency, 'options.concurrency');
     assert.optionalNumber(options.ufdsBackupTimeout,
             'options.ufdsBackupTimeout');
diff --git a/package.json b/package.json
index 2937825..9d95fc5 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "sdcadm",
   "description": "Administer a SmartDataCenter (SDC) standup",
-  "version": "1.24.9",
+  "version": "1.24.10",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -30,8 +30,8 @@
     "triton-netconfig": "1.0.0",
     "ufds": "1.3.0",
     "urclient": "1.2.0",
-    "vasync": "^1.6.4",
-    "verror": "^1.10.0",
+    "vasync": "2.2.0",
+    "verror": "1.10.0",
     "wf-client": "0.3.0"
   },
   "devDependencies": {
@@ -43,7 +43,7 @@
     "zkstream": "0.11.2"
   },
   "engines": {
-    "node": ">=0.10"
+    "node": ">=4.x"
   },
   "license": "MPL-2.0"
 }
-- 
2.21.0

