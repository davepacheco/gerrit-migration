From 9e26a312feddce5c14f8436028e1e53d51100a1e Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Thu, 8 Mar 2018 02:34:40 +0000
Subject: [PATCH] MANATEE-307 manatee-snapshotter failing on snapshot with
 dependent clones MANATEE-332 manatee-snapshotter fails spuriously during
 rebuild

---
 README.md           |  32 +++++++-
 lib/snapShotter.js  | 182 ++++++++++++++++++++++++++++++++++++--------
 smf/snapshotter.xml |   5 +-
 snapshotter.js      |   5 +-
 4 files changed, 184 insertions(+), 40 deletions(-)

diff --git a/README.md b/README.md
index 595a881..d931f35 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright (c) 2014, Joyent, Inc.
+    Copyright (c) 2018, Joyent, Inc.
 -->
 
 # Manatee
@@ -238,7 +238,8 @@ the first peer runs postgres on port 5432, the second peer runs postgres on port
 
 There are currently two components to run for each peer: the sitter (which also
 starts postgres) and the backup server (which is used for bootstrapping
-replication for new downstream peers).  To start the first peer, use:
+replication for new downstream peers).  These commands are all intended to be
+run with "root" user privileges.  To start the first peer, use:
 
     # node sitter.js -f devconfs/sitter1/sitter.json
 
@@ -249,5 +250,28 @@ Similarly, to run the backupserver, use:
 
     # node backupserver.js -f devconfs/sitter1/backupserver.json
 
-There's also a snapshotter, but running that for development is not yet
-documented.
+There's also a snapshotter, but you will likely want to create a custom
+configuration file for running it for development:
+
+    1. Create a file of this format, i.e. `etc/snapshotter_test_config.json`
+
+    {
+      "//": "The ZFS dataset used by Manatee."
+      "dataset": "zones/$ZONE_UUID/data/manatee",
+      "//" : "Snapshot period in ms",
+      "pollInterval": 36000,
+      "//" : "Number of snapshots to keep.",
+      "snapshotNumber": 20
+    }
+
+    2. Run the snapshotter with the config file:
+
+    # node snapshotter.js -f etc/snapshotter_test_config.json 2>&1 | bunyan
+
+### Running tests
+
+Before you can run a clean `make prepush`, you will need to set these
+environmental variables:
+
+    # export SHARD=1.moray.$YOUR_LAB_OR_VM.joyent.us
+    # export ZK_IPS=$NAMESERVICE_INSTANCE_IP
\ No newline at end of file
diff --git a/lib/snapShotter.js b/lib/snapShotter.js
index 88d3bae..43dd4d7 100644
--- a/lib/snapShotter.js
+++ b/lib/snapShotter.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 /**
@@ -27,6 +27,7 @@ var once = require('once');
 var restify = require('restify');
 var util = require('util');
 var vasync = require('vasync');
+var verror = require('verror');
 
 /*
  * For determining if a ZFS snapshot name is at least somewhat well-formed.
@@ -156,11 +157,18 @@ SnapShotter.prototype.start = function start(callback) {
             }
         });
     }
-    // manually start the first time as setInterval waits the interval before
-    // starting
+
+    /*
+     * Call create() before setting the interval so that the function fires
+     * immediately rather than waiting before its first execution.
+     */
     create();
     setInterval(create, self._pollInterval);
 
+
+    /*
+     * Call cleanup() immediately, it will be scheduled to repeat later.
+     */
     (function cleanup() {
         log.info('cleaning up snapshots');
         vasync.pipeline({funcs: [
@@ -235,42 +243,151 @@ SnapShotter.prototype.start = function start(callback) {
             function _deleteSnapshots(_, cb) {
                 cb = once(cb);
                 var snapshots = _.snapshots;
-                if (snapshots.length > self._snapshotNumber) {
-                    log.info({
-                        numberOfSnapshots: snapshots.length,
-                        threshHold: self._snapshotNumber
-                    }, 'deleting snapshots as number exceeds threshold');
 
-                    var barrier = vasync.barrier();
+                if (snapshots.length < self._snapshotNumber) {
+                    setImmediate(cb);
+                    return;
+                }
+
+                log.info({
+                    numberOfSnapshots: snapshots.length,
+                    threshHold: self._snapshotNumber
+                }, 'deleting snapshots as number exceeds threshold');
 
-                    barrier.on('drain', cb);
-                    for (var i = 0;
-                         i < snapshots.length - self._snapshotNumber;
-                         i++) {
+                var excessSnapshots =
+                    snapshots.length - self._snapshotNumber;
+                if (excessSnapshots <= 0) {
+                    setImmediate(cb);
+                    return;
+                }
 
-                        var delSnapshot = snapshots[i];
-                        barrier.start(delSnapshot);
+                var deletedCount = 0;
+                /*
+                 * stuckSnapshots is an array of objects containing a
+                 * snapshot and the error messages that occured when that
+                 * snapshot could not be deleted in the following loop.
+                 */
+                var stuckSnapshots = [];
+
+                vasync.forEachPipeline({
+                    inputs: snapshots,
+                    func: function (s, next) {
+
+                        /*
+                         * If enough snapshots have been deleted to bring the
+                         * total number under the configured threshold, move on.
+                         */
+                        if (deletedCount >= excessSnapshots) {
+                            setImmediate(next);
+                            return;
+                        }
 
-                        /* jshint loopfunc: true */
-                        self._deleteSnapshot(delSnapshot,
-                                             function (err, snapshot) {
+                        self._deleteSnapshot(s, function (err, snapshot) {
                             if (err) {
-                                log.error({
+                                /*
+                                 * Though the callback has passed an error, we
+                                 * do not want to fire an amon alert on a single
+                                 * delete failure, since the reason for it may
+                                 * resolve with a retry.  Collect the failed
+                                 * deletions with information about which
+                                 * snapshot could not be deleted and why in case
+                                 * intervention is required.
+                                 */
+                                var deleteFailure = {
                                     err: err,
-                                    snapshot: delSnapshot
-                                }, 'unable to delete snapshot');
-                                return cb(err);
+                                    snapshot: snapshot
+                                };
+                                stuckSnapshots.push(deleteFailure);
+
+                                /*
+                                 * If the number of stuck snapshots has reached
+                                 * or exceeded the total number of snapshots, we
+                                 * have tried them all.  If the situation does
+                                 * not resolve itself on subsequent cleanup
+                                 * attempts, the snapshotter service will be
+                                 * essentially unusable.
+                                 */
+                                if (stuckSnapshots.length >= snapshots.length) {
+                                    /*
+                                     * We justify the use of a fatal error here,
+                                     * which is needed to fire an amon alert,
+                                     * because if this condition is hit the
+                                     * service may become "unusable" as per the
+                                     * bunyan log level documentation.
+                                     */
+                                    log.fatal({
+                                        numberOfStuckSnapshots:
+                                            stuckSnapshots.length,
+                                        numberofTotalSnapshots:
+                                            snapshots.length,
+                                        threshold: self._snapshotNumber
+                                    }, 'unable to delete any snapshots, if we' +
+                                    ' are over the threshold of snapshots to' +
+                                    ' keep we can\'t create new ones!');
+
+                                    next(err);
+                                    return;
+                                }
+
+                                /*
+                                 * Quit the delete operation and raise an error
+                                 * once we have tried to delete each snapshot in
+                                 * the array except the most recent, which is
+                                 * currently the last snapshot in the array.
+                                 */
+                                if (stuckSnapshots.length >= excessSnapshots) {
+                                    log.error({
+                                        numberOfStuckSnapshots:
+                                            stuckSnapshots.length,
+                                        stuckSnapshots: stuckSnapshots
+                                    }, 'unable to delete snapshots, exceeding' +
+                                        ' the threshold of snapshots to keep!');
+
+                                    next(err);
+                                    return;
+                                }
+
+                                /*
+                                 * Continue to iterate through snapshots.
+                                 */
+                                next();
+                                return;
                             }
-                            barrier.done(snapshot);
+
+                            /*
+                             * Successful removal of a snapshot.
+                             */
+                            deletedCount++;
+                            next();
+
                         });
                     }
-                } else {
-                    return cb();
-                }
+                }, function snapshotterPipelineDone(err) {
+                    if (err) {
+                        log.info('could not complete snapshot deletion');
+                        cb(err);
+                        return;
+                    }
+                    log.info('completed snapshot deletion');
+                    cb();
+                });
             }
-        ], arg: {}}, function (err, results) {
+        ], arg: {}}, function onSnapshotterCleanupEnd(err, results) {
+            /*
+             * The cleanup operation will retry regardless of prior failure if
+             * too few snapshots were deleted to bring the total number of
+             * snapshots for this dataset under the configured threshold. This
+             * is done in case these errors were transient. Even if they were
+             * not, it is better to have more alarms fire than to allow the
+             * system to fill up with old snapshots when retrying continuously
+             * could have, in many cases, easily prevented that.  Though its
+             * true this may produce more logging, which also takes up space,
+             * error messages are likely much smaller than a snapshot of a
+             * production dataset.
+             */
+            setTimeout(cleanup, self._pollInterval);
             if (err) {
-                log.fatal({err: err, results: results},
+                log.error({err: err, results: results},
                           'unable to maintain snapshots');
                 /**
                  * SnapShotter error event.
@@ -279,9 +396,8 @@ SnapShotter.prototype.start = function start(callback) {
                  * @type {Error}
                  */
                 self.emit('error', err);
-            } else {
-                setTimeout(cleanup, self._pollInterval);
             }
+            log.info('done with snapshot cleanup');
         });
     })();
 
@@ -316,7 +432,11 @@ SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
             log.info('ZFS snapshot created');
         }
 
-        // ignore all errors and try again later.
+        /*
+         * These errors are only logged, not passed up to the caller, since the
+         * caller's responsibility is to retry periodically regardless of
+         * failure.
+         */
         callback();
     });
 };
diff --git a/smf/snapshotter.xml b/smf/snapshotter.xml
index 37db933..27af456 100644
--- a/smf/snapshotter.xml
+++ b/smf/snapshotter.xml
@@ -7,7 +7,7 @@
 -->
 
 <!--
-    Copyright (c) 2014, Joyent, Inc.
+    Copyright (c) 2018, Joyent, Inc.
 -->
 
 <service_bundle type='manifest' name='export'>
@@ -19,7 +19,8 @@
     <dependency name='filesystem' grouping='require_all' restart_on='error' type='service'>
       <service_fmri value='svc:/system/filesystem/local'/>
     </dependency>
-    <exec_method name='start' type='method' exec='node snapshotter.js -vvv -f ./etc/snapshotter.json &amp;' timeout_seconds='30'>
+    <exec_method name='start' type='method' exec='node --abort-on-uncaught-exception
+      snapshotter.js -vvv -f ./etc/snapshotter.json &amp;' timeout_seconds='30'>
       <method_context working_directory='/opt/manatee'>
         <method_environment>
           <envvar name='PATH' value='/opt/manatee/build/node/bin:/opt/local/bin:/usr/bin:/usr/sbin:/bin'/>
diff --git a/snapshotter.js b/snapshotter.js
index d12c715..dc38466 100644
--- a/snapshotter.js
+++ b/snapshotter.js
@@ -118,9 +118,8 @@ function readConfig(options) {
 
     var snapShotter = new SnapShotter(_config);
 
-    snapShotter.on('err', function (err) {
-        LOG.fatal('got error from snapshotter', err);
-        throw err;
+    snapShotter.on('error', function (err) {
+        LOG.error('got error from snapshotter', err);
     });
 
     snapShotter.start(function () {
-- 
2.21.0

