From b6e8ab81fcd47893e09905ce69873167bb349960 Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Thu, 8 Mar 2018 02:34:40 +0000
Subject: [PATCH] MANATEE-307 manatee-snapshotter failing on snapshot with
 dependent clones MANATEE-332 manatee-snapshotter fails spuriously during
 rebuild

---
 lib/snapShotter.js  | 80 +++++++++++++++++++++++++++++++++++++--------
 smf/snapshotter.xml |  3 +-
 snapshotter.js      |  5 ++-
 3 files changed, 70 insertions(+), 18 deletions(-)

diff --git a/lib/snapShotter.js b/lib/snapShotter.js
index 88d3bae..35a9731 100644
--- a/lib/snapShotter.js
+++ b/lib/snapShotter.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /**
@@ -156,8 +156,11 @@ SnapShotter.prototype.start = function start(callback) {
             }
         });
     }
-    // manually start the first time as setInterval waits the interval before
-    // starting
+
+    /*
+     * Call create() before setting the interval so that the function fires
+     * immediately rather than waiting before its first execution.
+     */
     create();
     setInterval(create, self._pollInterval);
 
@@ -244,9 +247,17 @@ SnapShotter.prototype.start = function start(callback) {
                     var barrier = vasync.barrier();
 
                     barrier.on('drain', cb);
-                    for (var i = 0;
-                         i < snapshots.length - self._snapshotNumber;
-                         i++) {
+
+                    var excessSnapshots =
+                        snapshots.length - self._snapshotNumber;
+
+                    /*
+                     * stuckSnapshots is an array of objects containing a
+                     * snapshot and the error messages that occured when that
+                     * snapshot could not be deleted in the following loop.
+                     */
+                    var stuckSnapshots = [];
+                    for (var i = 0; i < excessSnapshots; i++) {
 
                         var delSnapshot = snapshots[i];
                         barrier.start(delSnapshot);
@@ -255,11 +266,37 @@ SnapShotter.prototype.start = function start(callback) {
                         self._deleteSnapshot(delSnapshot,
                                              function (err, snapshot) {
                             if (err) {
-                                log.error({
+                                /*
+                                 * Though the callback has passed an error, we
+                                 * do not want to fire an amon alert on a single
+                                 * delete failure, since the reason for it may
+                                 * resolve with a retry.  Collect the failed
+                                 * deletions with information about which
+                                 * snapshot could not be deleted and why in case
+                                 * intervention is required.
+                                 */
+                                var deleteFailure = {
                                     err: err,
-                                    snapshot: delSnapshot
-                                }, 'unable to delete snapshot');
-                                return cb(err);
+                                    snapshot: snapshot
+                                };
+                                stuckSnapshots.push(deleteFailure);
+
+                                /*
+                                 * Only quit the delete operation and raise an
+                                 * error alert once we have tried to delete each
+                                 * snapshot in the array except the most recent,
+                                 * which is currently (as of March 2018) the
+                                 * last in the array.
+                                 */
+                                if (i >= excessSnapshots) {
+                                    log.error({
+                                        numberOfStuckSnapshots:
+                                            stuckSnapshots.length,
+                                        stuckSnapshots: stuckSnapshots
+                                    }, 'unable to delete snapshots, exceeding' +
+                                        ' the threshold of snapshots to keep!');
+                                    return cb(err);
+                                }
                             }
                             barrier.done(snapshot);
                         });
@@ -270,7 +307,7 @@ SnapShotter.prototype.start = function start(callback) {
             }
         ], arg: {}}, function (err, results) {
             if (err) {
-                log.fatal({err: err, results: results},
+                log.error({err: err, results: results},
                           'unable to maintain snapshots');
                 /**
                  * SnapShotter error event.
@@ -279,9 +316,20 @@ SnapShotter.prototype.start = function start(callback) {
                  * @type {Error}
                  */
                 self.emit('error', err);
-            } else {
-                setTimeout(cleanup, self._pollInterval);
             }
+            /*
+             * The cleanup operation will retry regardless of prior failure if
+             * too few snapshots were deleted to bring the total number of
+             * snapshots for this dataset under the configured threshold. This
+             * is done in case these errors were transient. Even if they were
+             * not, it is better to have more alarms fire than to allow the
+             * system to fill up with old snapshots when retrying continuously
+             * could have, in many cases, easily prevented that.  Though its
+             * true this may produce more logging, which also takes up space,
+             * error messages are likely much smaller than a snapshot of a
+             * production dataset.
+             */
+            setTimeout(cleanup, self._pollInterval);
         });
     })();
 
@@ -316,7 +364,11 @@ SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
             log.info('ZFS snapshot created');
         }
 
-        // ignore all errors and try again later.
+        /*
+         * These errors are only logged, not passed up to the caller, since the
+         * caller's responsibility (as of March 2018) is to retry periodically
+         * regardless of failure.
+         */
         callback();
     });
 };
diff --git a/smf/snapshotter.xml b/smf/snapshotter.xml
index 37db933..42be405 100644
--- a/smf/snapshotter.xml
+++ b/smf/snapshotter.xml
@@ -19,7 +19,8 @@
     <dependency name='filesystem' grouping='require_all' restart_on='error' type='service'>
       <service_fmri value='svc:/system/filesystem/local'/>
     </dependency>
-    <exec_method name='start' type='method' exec='node snapshotter.js -vvv -f ./etc/snapshotter.json &amp;' timeout_seconds='30'>
+    <exec_method name='start' type='method' exec='node --abort-on-uncaught-exception
+      snapshotter.js -vvv -f ./etc/snapshotter.json &amp;' timeout_seconds='30'>
       <method_context working_directory='/opt/manatee'>
         <method_environment>
           <envvar name='PATH' value='/opt/manatee/build/node/bin:/opt/local/bin:/usr/bin:/usr/sbin:/bin'/>
diff --git a/snapshotter.js b/snapshotter.js
index d12c715..dc38466 100644
--- a/snapshotter.js
+++ b/snapshotter.js
@@ -118,9 +118,8 @@ function readConfig(options) {
 
     var snapShotter = new SnapShotter(_config);
 
-    snapShotter.on('err', function (err) {
-        LOG.fatal('got error from snapshotter', err);
-        throw err;
+    snapShotter.on('error', function (err) {
+        LOG.error('got error from snapshotter', err);
     });
 
     snapShotter.start(function () {
-- 
2.21.0

