commit 76c51e3b07246d768d696390ad49a09de1b6a1a8 (refs/changes/52/1652/3)
Author: YangYong3 <yy1111.yang@samsung.com>
Date:   2017-04-04T09:10:03+09:00 (2 years, 6 months ago)
    
    joyent/node-triton#104 wait timeout on `triton inst enable/disable-firewall`...

diff --git a/lib/cloudapi2.js b/lib/cloudapi2.js
index f872baa..e205859 100644
--- a/lib/cloudapi2.js
+++ b/lib/cloudapi2.js
@@ -1060,51 +1060,6 @@ CloudApi.prototype.machineAudit = function machineAudit(id, cb) {
     });
 };
 
-
-/**
- * Wait for a machine's `firewall_enabled` field to go true/false.
- *
- * @param {Object} options
- *      - {String} id: Required. The machine UUID.
- *      - {Boolean} state: Required. The desired `firewall_enabled` state.
- *      - {Number} interval: Optional. Time (in ms) to poll.
- * @param {Function} callback of the form f(err, machine, res).
- */
-CloudApi.prototype.waitForMachineFirewallEnabled =
-function waitForMachineFirewallEnabled(opts, cb) {
-    var self = this;
-
-    assert.object(opts, 'opts');
-    assert.uuid(opts.id, 'opts.id');
-    assert.bool(opts.state, 'opts.state');
-    assert.optionalNumber(opts.interval, 'opts.interval');
-    assert.func(cb, 'cb');
-
-    var interval = opts.interval || 1000;
-    assert.ok(interval > 0, 'interval must be a positive number');
-
-    poll();
-
-    function poll() {
-        self.getMachine({
-            id: opts.id
-        }, function (err, machine, res) {
-            if (err) {
-                cb(err, null, res);
-                return;
-            }
-
-            if (opts.state === machine.firewall_enabled) {
-                cb(null, machine, res);
-                return;
-            }
-
-            setTimeout(poll, interval);
-        });
-    }
-};
-
-
 // --- machine tags
 
 /**
diff --git a/lib/do_instance/do_disable_firewall.js b/lib/do_instance/do_disable_firewall.js
index 7f51b39..96a83b8 100644
--- a/lib/do_instance/do_disable_firewall.js
+++ b/lib/do_instance/do_disable_firewall.js
@@ -33,46 +33,25 @@ function do_disable_firewall(subcmd, opts, args, cb) {
 
     var cli = this.top;
 
-    function wait(name, id, next) {
-        cli.tritonapi.cloudapi.waitForMachineFirewallEnabled({
-            id: id,
-            state: false
-        }, function (err, inst) {
-            if (err) {
-                next(err);
-                return;
-            }
-            assert.ok(!inst.firewall_enabled, format(
-                'inst %s firewall_enabled not in expected state after '
-                + 'waitForMachineFirewallEnabled', id));
-
-            console.log('Disabled firewall for instance "%s"', name);
-            next();
-        });
-    }
-
     common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
         if (setupErr) {
             cb(setupErr);
         }
         vasync.forEachParallel({
             inputs: args,
-            func: function disableOne(name, nextInst) {
-                cli.tritonapi.disableInstanceFirewall({
-                    id: name
+            func: function disableOne(name, next) {
+               console.log('Disabling firewall for instance "%s"', name);
+               cli.tritonapi.disableInstanceFirewall({
+                    id: name,
+                    wait: opts.wait,
+                    waitTimeout: opts.wait_timeout * 1000
                 }, function (err, fauxInst) {
                     if (err) {
-                        nextInst(err);
+                        next(err);
                         return;
                     }
-
-                    console.log('Disabling firewall for instance "%s"', name);
-
-                    if (opts.wait) {
-                        wait(name, fauxInst.id, nextInst);
-                    } else {
-                        nextInst();
-                    }
+                    console.log('Disabled firewall for instance "%s"', name);
+                    next();
                 });
             }
         }, function (err) {
@@ -92,6 +71,13 @@ do_disable_firewall.options = [
         names: ['wait', 'w'],
         type: 'bool',
         help: 'Wait for the firewall to be disabled.'
+    },
+    {
+        names: ['wait-timeout'],
+        type: 'positiveInteger',
+        default: 120,
+        help: 'The number of seconds to wait before timing out with an error. '
+            + 'The default is 120 seconds.'
     }
 ];
 do_disable_firewall.synopses = [
diff --git a/lib/do_instance/do_enable_firewall.js b/lib/do_instance/do_enable_firewall.js
index 97f1dfb..3d090f4 100644
--- a/lib/do_instance/do_enable_firewall.js
+++ b/lib/do_instance/do_enable_firewall.js
@@ -33,46 +33,25 @@ function do_enable_firewall(subcmd, opts, args, cb) {
 
     var cli = this.top;
 
-    function wait(name, id, next) {
-        cli.tritonapi.cloudapi.waitForMachineFirewallEnabled({
-            id: id,
-            state: true
-        }, function (err, inst) {
-            if (err) {
-                next(err);
-                return;
-            }
-            assert.ok(inst.firewall_enabled, format(
-                'inst %s firewall_enabled not in expected state after '
-                + 'waitForMachineFirewallEnabled', id));
-
-            console.log('Enabled firewall for instance "%s"', name);
-            next();
-        });
-    }
-
     common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
         if (setupErr) {
             cb(setupErr);
         }
         vasync.forEachParallel({
             inputs: args,
-            func: function enableOne(name, nextInst) {
-                cli.tritonapi.enableInstanceFirewall({
-                    id: name
+            func: function enableOne(name, next) {
+               console.log('Enabling firewall for instance "%s"', name);
+               cli.tritonapi.enableInstanceFirewall({
+                    id: name,
+                    wait: opts.wait,
+                    waitTimeout: opts.wait_timeout * 1000
                 }, function (err, fauxInst) {
                     if (err) {
-                        nextInst(err);
+                        next(err);
                         return;
                     }
-
-                    console.log('Enabling firewall for instance "%s"', name);
-
-                    if (opts.wait) {
-                        wait(name, fauxInst.id, nextInst);
-                    } else {
-                        nextInst();
-                    }
+                    console.log('Enabled firewall for instance "%s"', name);
+                    next();
                 });
             }
         }, function (err) {
@@ -92,7 +71,15 @@ do_enable_firewall.options = [
         names: ['wait', 'w'],
         type: 'bool',
         help: 'Wait for the firewall to be enabled.'
+    },
+    {
+        names: ['wait-timeout'],
+        type: 'positiveInteger',
+        default: 120,
+        help: 'The number of seconds to wait before timing out with an error. '
+            + 'The default is 120 seconds.'
     }
+
 ];
 do_enable_firewall.synopses = [
     '{{name}} enable-firewall [OPTIONS] INST [INST ...]'
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index c5f159a..3034209 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -939,6 +939,11 @@ TritonApi.prototype.getInstance = function getInstance(opts, cb) {
  *
  * @param {Object} opts
  *      - {String} id: Required. The instance ID, name, or short ID.
+ *      - {Boolean} wait: Wait (via polling) until the enableFirewall
+ *        is complete.
+ *      - {Number} waitTimeout: The number of milliseconds after which to
+ *        timeout (call `cb` with a timeout error) waiting. Only relevant if
+ *        `opts.wait === true`. Default is Infinity (i.e. it doesn't timeout).
  * @param {Function} callback `function (err, fauxInst, res)`
  *      On failure `err` is an error instance, else it is null.
  *      On success: `fauxInst` is an object with just the instance id,
@@ -950,6 +955,8 @@ TritonApi.prototype.getInstance = function getInstance(opts, cb) {
 TritonApi.prototype.enableInstanceFirewall =
 function enableInstanceFirewall(opts, cb) {
     assert.string(opts.id, 'opts.id');
+    assert.optionalBool(opts.wait, 'opts.wait');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
     assert.func(cb, 'cb');
 
     var self = this;
@@ -967,7 +974,19 @@ function enableInstanceFirewall(opts, cb) {
                 res = _res;
                 next(err);
             });
+        },
+        function waitForFirewallUpdate(arg, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+            self._waitForFirewallUpdate({
+                id: arg.instId,
+                state: true,
+                timeout: opts.waitTimeout
+            }, next);
         }
+
     ]}, function (err) {
         cb(err, fauxInst, res);
     });
@@ -979,6 +998,11 @@ function enableInstanceFirewall(opts, cb) {
  *
  * @param {Object} opts
  *      - {String} id: Required. The instance ID, name, or short ID.
+ *      - {Boolean} wait: Wait (via polling) until the disable firewall
+ *        is complete.
+ *      - {Number} waitTimeout: The number of milliseconds after which to
+ *        timeout (call `cb` with a timeout error) waiting. Only relevant if
+ *        `opts.wait === true`. Default is Infinity (i.e. it doesn't timeout).
  * @param {Function} callback `function (err, fauxInst, res)`
  *      On failure `err` is an error instance, else it is null.
  *      On success: `fauxInst` is an object with just the instance id,
@@ -990,6 +1014,8 @@ function enableInstanceFirewall(opts, cb) {
 TritonApi.prototype.disableInstanceFirewall =
 function disableInstanceFirewall(opts, cb) {
     assert.string(opts.id, 'opts.id');
+    assert.optionalBool(opts.wait, 'opts.wait');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
     assert.func(cb, 'cb');
 
     var self = this;
@@ -1007,12 +1033,78 @@ function disableInstanceFirewall(opts, cb) {
                 res = _res;
                 next(err);
             });
+        },
+        function waitForFirewallUpdate(arg, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+            self._waitForFirewallUpdate({
+                id: arg.instId,
+                state: false,
+                timeout: opts.waitTimeout
+            }, next);
         }
     ]}, function (err) {
         cb(err, fauxInst, res);
     });
 };
 
+/**
+ * Wait for a machine's `firewall_enable` field to go true/false.
+ *
+ * @param {Object} options
+ *      - {String} id: Required. The machine UUID.
+ *      - {Boolean} state: Required. The desired `firewall_enabled` state.
+ *      - {Number} waitTimeout: The number of milliseconds after which to
+ *        timeout (call `cb` with a timeout error) waiting. Only relevant if
+ *        `opts.wait === true`. Default is Infinity (i.e. it doesn't timeout).
+ * @param {Function} callback of the form f(err, machine, res).
+ */
+TritonApi.prototype._waitForFirewallUpdate =
+function _waitForFirewallUpdate(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.bool(opts.state, 'opts.state');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    var timeout = opts.hasOwnProperty('timeout') ? opts.timeout : Infinity;
+    assert.ok(timeout > 0, 'opts.timeout must be greater than zero');
+    assert.func(cb, 'cb');
+
+    /*
+     * Hardcoded 2s poll interval for now. Not yet configurable, being mindful
+     * of avoiding lots of clients naively swamping a CloudAPI and hitting
+     * throttling.
+     */
+    var POLL_INTERVAL = 2 * 1000;
+    var startTime = Date.now();
+
+    var poll = function () {
+        self.cloudapi.getMachine({id: opts.id}, function (err, machine) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            if (opts.state === machine.firewall_enabled) {
+                cb();
+                return;
+            }
+
+            var elapsedTime = Date.now() - startTime;
+            if (elapsedTime > timeout) {
+                cb(new errors.TimeoutError(format('timeout waiting for '
+                    + 'instance %s firewall change (elapsed %ds)',
+                    opts.id, Math.round(elapsedTime / 1000))));
+            } else {
+                setTimeout(poll, POLL_INTERVAL);
+            }
+        });
+    };
+
+    setImmediate(poll);
+};
 
 // ---- instance snapshots
 
