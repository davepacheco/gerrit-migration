commit 941bc37b1371db1d78834249f8e749bd7c24b133
Author: John Levon <john.levon@joyent.com>
Date:   2019-01-28T20:13:07+00:00 (8 months ago)
    
    TRITON-1017 iPXE should be provided directly from joyent/ipxe
    TRITON-1072 sdc-booter needs EFI chain-loading support

diff --git a/lib/dhcp.js b/lib/dhcp.js
index 589bfae..b94d57a 100644
--- a/lib/dhcp.js
+++ b/lib/dhcp.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -141,6 +141,17 @@ DHCP_MESSAGE_TYPE[6] = 'DHCPNAK';
 DHCP_MESSAGE_TYPE[7] = 'DHCPRELEASE';
 DHCP_MESSAGE_TYPE[8] = 'DHCPINFORM';
 
+var DHCP_CLIENT_ARCH_TYPE = [];
+DHCP_CLIENT_ARCH_TYPE[0] = 'Intel x86PC';
+DHCP_CLIENT_ARCH_TYPE[1] = 'NEC/PC98';
+DHCP_CLIENT_ARCH_TYPE[2] = 'EFI Itanium';
+DHCP_CLIENT_ARCH_TYPE[3] = 'DEC Alpha';
+DHCP_CLIENT_ARCH_TYPE[4] = 'Arc x86';
+DHCP_CLIENT_ARCH_TYPE[5] = 'Intel Lean Client';
+DHCP_CLIENT_ARCH_TYPE[6] = 'EFI IA32';
+DHCP_CLIENT_ARCH_TYPE[7] = 'EFI BC';
+DHCP_CLIENT_ARCH_TYPE[8] = 'EFI Xscale';
+DHCP_CLIENT_ARCH_TYPE[9] = 'EFI x86-64';
 
 
 // --- DHCPPacket object
@@ -457,6 +468,7 @@ module.exports = {
     createReplyPacket: createDHCPreply,
     DHCP_OPTION: DHCP_OPTION,
     DHCP_MESSAGE_TYPE: DHCP_MESSAGE_TYPE,
+    DHCP_CLIENT_ARCH_TYPE: DHCP_CLIENT_ARCH_TYPE,
     DHCPPacket: DHCPPacket,
     parse: parseDHCPpacket
 };
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index 63052f9..54dfc0b 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -305,7 +305,6 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
     var packetOpts = {
         'siaddr': this.config.serverIp,
         'yiaddr': params.ip,
-        'file': this.config.chainloadGrub ? 'pxegrub' : 'undionly.kpxe',
         'options': {
             '1': params.netmask || this.config.netmask,
             '51': this.config.leaseTime,
@@ -329,6 +328,7 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
 
         return '';
     }
+
     /*
      * If option 82 (circuit id) and giaddr are both set that means the CN
      * is behind a DHCP relay and we need to provide it a different gateway IP.
@@ -350,7 +350,37 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
         packetOpts['options']['3'] = this.config.defaultGateway;
     }
 
-    if (packet.options[77]) {
+    /*
+     * Decide on our boot file to return: if the user class isn't set, then we
+     * presume this is a BIOS PXE client.  We want the client to chain load into
+     * iPXE, and we'll peek at the client arch (RFC 4578 2.1) to decide whether
+     * to provide the EFI or the legacy version. (It's still possible for legacy
+     * clients to get pxegrub if so configured, but it's not the default.)
+     *
+     * Otherwise, we expect to see iPXE: it's either the above chain-loaded
+     * instance, or it's from the client's USB key.  In response, we can provide
+     * the real iPXE boot script.
+     */
+    if (!packet.options[77]) {
+        packetOpts.file = this.config.chainloadGrub ?
+            'pxegrub' : 'undionly.kpxe';
+
+        if (packet.options[93]) {
+            /*
+             * Should be a big-endian uint16_t. By the RFC, the client may
+             * specify more than one, however unlikely that seems.
+             */
+            if (packet.options[93].length < 2) {
+                log.warn({option_93: packet.options[93]}, 'malformed option');
+            } else {
+                var arch = (packet.options[93][0] << 8) | packet.options[93][1];
+
+                if (dhcp.DHCP_CLIENT_ARCH_TYPE[arch] === 'EFI BC' ||
+                    dhcp.DHCP_CLIENT_ARCH_TYPE[arch] === 'EFI x86-64')
+                    packetOpts.file = 'snponly.efi';
+            }
+        }
+    } else {
         var userClass = new Buffer(packet.options[77]).toString();
         if (userClass === 'iPXE') {
             packetOpts.file = 'boot.ipxe.01' +
diff --git a/tftpboot/snponly.efi b/tftpboot/snponly.efi
new file mode 100644
index 0000000..ab5ecd9
Binary files /dev/null and b/tftpboot/snponly.efi differ
diff --git a/tftpboot/undionly.kpxe b/tftpboot/undionly.kpxe
index 2fd8133..23110e8 100644
Binary files a/tftpboot/undionly.kpxe and b/tftpboot/undionly.kpxe differ
diff --git a/tools/update_ipxe b/tools/update_ipxe
index 19601a5..b7d3ad5 100755
--- a/tools/update_ipxe
+++ b/tools/update_ipxe
@@ -1,18 +1,14 @@
 #!/bin/ksh
 #
-# For rather unforunate reasons related to inter-repository dependencies, we
-# ship a copy of "pxegrub" from the platform boot tarball, and "undionly.kpxe"
-# (iPXE) from the "sdcboot" tarball.
+# This repository has local copies of the iPXE binaries we provide to CNs that
+# use BIOS PXE instead of booting iPXE from a local USB key.
 #
-# This tool may be run to download the iPXE binary from the latest build of the
-# master branch of the "sdcboot" repository into the correct place in this
-# repository.
+# This script updates to the latest binaries from the ipxe tarball.
 #
+# Copyright (c) 2018, Joyent, Inc.
+
+IPXEFILES="./boot/undionly.kpxe ./boot/snponly.efi"
 
-#
-# The file we want; i.e. the iPXE UNDI chainloading PXE boot binary
-#
-IPXEFILE='./boot/undionly.kpxe'
 
 set -o errexit
 set -o pipefail
@@ -22,7 +18,7 @@ dir="$(dirname $(whence $0))/.."
 cd "${dir}"
 
 function fatal {
-	printf 'ERROR: %s\n' >&2
+	printf "ERROR: %s\n" "$*" >&2
 	if [[ -n "${tdir}" && -d "${tdir}" ]]; then
 		# Clean up temporary directory
 		rm -rf "${tdir}"
@@ -30,35 +26,37 @@ function fatal {
 	exit 1
 }
 
-if ! mdir="$(mget -q /Joyent_Dev/public/builds/sdcboot/master-latest)"; then
-	fatal 'could not locate latest "sdcboot" build directory in Manta'
+branch=${1:-master}
+
+if ! mdir="$(mget -q /Joyent_Dev/public/builds/ipxe/$branch-latest)"; then
+	fatal "could not locate latest ipxe build directory in Manta"
 fi
 
-printf '%15s: %s\n' 'Manta Dir' "${mdir}" >&2
+printf "%15s: %s\n" "Manta Dir" "${mdir}" >&2
 
-if ! mfile="$(mfind -t o -n "^sdcboot-master-.*.tgz$" "${mdir}")"; then
-	fatal 'could not locate latest "sdcboot" build tarball in Manta'
+if ! mfile="$(mfind -t o -n "^ipxe-$branch-.*.tgz$" "${mdir}")"; then
+	fatal "could not locate latest ipxe build tarball in Manta"
 fi
 
-printf '%15s: %s\n' 'Manta File' "${mfile}" >&2
+printf "%15s: %s\n" "Manta File" "${mfile}" >&2
 
 if ! tdir="$(/usr/bin/mktemp -d)"; then
-	fatal 'could not make temporary directory'
+	fatal "could not make temporary directory"
 fi
 
-printf '%15s: %s\n' 'Temp Dir' "${mfile}" >&2
+printf "%15s: %s\n" "Temp Dir" "${tdir}" >&2
 cd "${tdir}"
 
-if ! mget -o sdcboot.tgz "${mfile}"; then
-	fatal 'could not download "sdcboot" build tarball'
+if ! mget -o ipxe.tgz "${mfile}"; then
+	fatal "could not download ${mfile}"
 fi
 
-if ! tar xvzf sdcboot.tgz "${IPXEFILE}"; then
-	fatal 'could not extract iPXE binary from "sdcboot" tarball'
+if ! tar xvzf ipxe.tgz ${IPXEFILES}; then
+	fatal "could not extract iPXE binaries from tarball"
 fi
 
-mv "${IPXEFILE}" "${dir}/tftpboot/"
+mv ${IPXEFILES} ${dir}/tftpboot
 cd /
 rm -rf "${tdir}"
 
-printf 'ok\n' >&2
+printf "ok\n" >&2
