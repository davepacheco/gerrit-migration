commit a9c59a0fa32d75bbccf1e16d6c21a8162f536a30
Author: John Levon <john.levon@joyent.com>
Date:   2019-02-21T13:54:48+00:00 (8 months ago)
    
    TRITON-1016 Need to build and deliver the ipxe EFI binary
    TRITON-1072 sdc-booter needs EFI chain-loading support

diff --git a/Makefile b/Makefile
index 75b186c..49176e4 100644
--- a/Makefile
+++ b/Makefile
@@ -141,7 +141,7 @@ release: $(RELEASE_TARBALL)
 $(RELEASE_TARBALL): pkg
 	(cd $(PKG_DIR); $(TAR) -I pigz -cf $(TOP)/$(RELEASE_TARBALL) root)
 
-publish:
+publish: release
 	@if [[ -z "$(ENGBLD_BITS_DIR)" ]]; then \
 		echo "error: 'ENGBLD_BITS_DIR' must be set for 'publish' target"; \
 		exit 1; \
diff --git a/lib/dhcp.js b/lib/dhcp.js
index 589bfae..4e21c62 100644
--- a/lib/dhcp.js
+++ b/lib/dhcp.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -141,6 +141,18 @@ DHCP_MESSAGE_TYPE[6] = 'DHCPNAK';
 DHCP_MESSAGE_TYPE[7] = 'DHCPRELEASE';
 DHCP_MESSAGE_TYPE[8] = 'DHCPINFORM';
 
+// RFC 4578 adjusted for https://www.rfc-editor.org/errata/eid4624
+var DHCP_CLIENT_ARCH_TYPE = [];
+DHCP_CLIENT_ARCH_TYPE[0] = 'Intel x86PC';
+DHCP_CLIENT_ARCH_TYPE[1] = 'NEC/PC98';
+DHCP_CLIENT_ARCH_TYPE[2] = 'EFI Itanium';
+DHCP_CLIENT_ARCH_TYPE[3] = 'DEC Alpha';
+DHCP_CLIENT_ARCH_TYPE[4] = 'Arc x86';
+DHCP_CLIENT_ARCH_TYPE[5] = 'Intel Lean Client';
+DHCP_CLIENT_ARCH_TYPE[6] = 'EFI IA32';
+DHCP_CLIENT_ARCH_TYPE[7] = 'EFI x86-64';
+DHCP_CLIENT_ARCH_TYPE[8] = 'EFI Xscale';
+DHCP_CLIENT_ARCH_TYPE[9] = 'EFI BC';
 
 
 // --- DHCPPacket object
@@ -457,6 +469,7 @@ module.exports = {
     createReplyPacket: createDHCPreply,
     DHCP_OPTION: DHCP_OPTION,
     DHCP_MESSAGE_TYPE: DHCP_MESSAGE_TYPE,
+    DHCP_CLIENT_ARCH_TYPE: DHCP_CLIENT_ARCH_TYPE,
     DHCPPacket: DHCPPacket,
     parse: parseDHCPpacket
 };
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index 63052f9..bb1ddac 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -301,11 +301,11 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
     var mac = packet.chaddr;
     var resolvers = [];
     var serverIp = this.config.serverIp;
+    var userClass = 'unknown';
 
     var packetOpts = {
         'siaddr': this.config.serverIp,
         'yiaddr': params.ip,
-        'file': this.config.chainloadGrub ? 'pxegrub' : 'undionly.kpxe',
         'options': {
             '1': params.netmask || this.config.netmask,
             '51': this.config.leaseTime,
@@ -329,6 +329,7 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
 
         return '';
     }
+
     /*
      * If option 82 (circuit id) and giaddr are both set that means the CN
      * is behind a DHCP relay and we need to provide it a different gateway IP.
@@ -350,18 +351,45 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
         packetOpts['options']['3'] = this.config.defaultGateway;
     }
 
+    /*
+     * Decide on our boot file to return: if the user class isn't iPXE, then we
+     * presume this is a BIOS PXE client.  We want the client to chain load into
+     * iPXE, and we'll peek at the client arch (RFC 4578 2.1) to decide whether
+     * to provide the EFI or the legacy version. (It's still possible for legacy
+     * clients to get pxegrub if so configured, but it's not the default.)
+     *
+     * Otherwise, we're seeing either the above chain-loaded instance of iPXE,
+     * or it's from the client's USB key.  In response, we can provide the real
+     * iPXE boot script.
+     */
+    packetOpts.file = this.config.chainloadGrub ? 'pxegrub' : 'undionly.kpxe';
+
     if (packet.options[77]) {
-        var userClass = new Buffer(packet.options[77]).toString();
-        if (userClass === 'iPXE') {
-            packetOpts.file = 'boot.ipxe.01' +
-                mac.split(':').join('').toUpperCase();
-            log.info('Detected iPXE, setting file to "%s"',
-                    packetOpts.file);
+        userClass = new Buffer(packet.options[77]).toString();
+    }
+
+    if (userClass === 'iPXE') {
+        packetOpts.file = 'boot.ipxe.01' +
+            mac.split(':').join('').toUpperCase();
+    } else if (packet.options[93]) {
+        /*
+         * Should be a big-endian uint16_t. By the RFC, the client may
+         * specify more than one, however unlikely that seems.
+         */
+        if (packet.options[93].length < 2) {
+             log.warn({option_93: packet.options[93]}, 'malformed option');
         } else {
-            log.warn('Unknown user-class: "%s", ignoring', userClass);
+            var arch = (packet.options[93][0] << 8) | packet.options[93][1];
+
+            if (dhcp.DHCP_CLIENT_ARCH_TYPE[arch] === 'EFI x86-64') {
+                packetOpts.file = 'snponly.efi';
+            }
         }
     }
 
+    log.info('Client user class "%s", file set to "%s"', userClass,
+        packetOpts.file);
+
     if (params.resolvers && params.resolvers.length) {
         resolvers = params.resolvers;
     }
diff --git a/tftpboot/snponly.efi b/tftpboot/snponly.efi
new file mode 100644
index 0000000..5bac849
Binary files /dev/null and b/tftpboot/snponly.efi differ
diff --git a/tftpboot/undionly.kpxe b/tftpboot/undionly.kpxe
index 2fd8133..b177ac1 100644
Binary files a/tftpboot/undionly.kpxe and b/tftpboot/undionly.kpxe differ
diff --git a/tools/update_ipxe b/tools/update_ipxe
index 19601a5..d05051a 100755
--- a/tools/update_ipxe
+++ b/tools/update_ipxe
@@ -1,18 +1,14 @@
 #!/bin/ksh
 #
-# For rather unforunate reasons related to inter-repository dependencies, we
-# ship a copy of "pxegrub" from the platform boot tarball, and "undionly.kpxe"
-# (iPXE) from the "sdcboot" tarball.
+# This repository has local copies of the iPXE binaries we provide to CNs that
+# use BIOS PXE instead of booting iPXE from a local USB key.
 #
-# This tool may be run to download the iPXE binary from the latest build of the
-# master branch of the "sdcboot" repository into the correct place in this
-# repository.
+# This script updates to the latest binaries from the ipxe tarball.
 #
+# Copyright (c) 2018, Joyent, Inc.
+
+IPXEFILES="./boot/undionly.kpxe ./boot/snponly.efi"
 
-#
-# The file we want; i.e. the iPXE UNDI chainloading PXE boot binary
-#
-IPXEFILE='./boot/undionly.kpxe'
 
 set -o errexit
 set -o pipefail
@@ -22,7 +18,7 @@ dir="$(dirname $(whence $0))/.."
 cd "${dir}"
 
 function fatal {
-	printf 'ERROR: %s\n' >&2
+	printf "ERROR: %s\n" "$*" >&2
 	if [[ -n "${tdir}" && -d "${tdir}" ]]; then
 		# Clean up temporary directory
 		rm -rf "${tdir}"
@@ -30,35 +26,37 @@ function fatal {
 	exit 1
 }
 
-if ! mdir="$(mget -q /Joyent_Dev/public/builds/sdcboot/master-latest)"; then
-	fatal 'could not locate latest "sdcboot" build directory in Manta'
+branch=${1:-master}
+
+if ! mdir="$(mget -q /Joyent_Dev/public/builds/ipxe/$branch-latest)"; then
+	fatal "could not locate latest ipxe build directory in Manta"
 fi
 
-printf '%15s: %s\n' 'Manta Dir' "${mdir}" >&2
+printf "%15s: %s\n" "Manta Dir" "${mdir}" >&2
 
-if ! mfile="$(mfind -t o -n "^sdcboot-master-.*.tgz$" "${mdir}")"; then
-	fatal 'could not locate latest "sdcboot" build tarball in Manta'
+if ! mfile="$(mfind -t o -n "^ipxe-$branch-.*.tar.gz$" "${mdir}")"; then
+	fatal "could not locate latest ipxe build tarball in Manta"
 fi
 
-printf '%15s: %s\n' 'Manta File' "${mfile}" >&2
+printf "%15s: %s\n" "Manta File" "${mfile}" >&2
 
 if ! tdir="$(/usr/bin/mktemp -d)"; then
-	fatal 'could not make temporary directory'
+	fatal "could not make temporary directory"
 fi
 
-printf '%15s: %s\n' 'Temp Dir' "${mfile}" >&2
+printf "%15s: %s\n" "Temp Dir" "${tdir}" >&2
 cd "${tdir}"
 
-if ! mget -o sdcboot.tgz "${mfile}"; then
-	fatal 'could not download "sdcboot" build tarball'
+if ! mget -o ipxe.tar.gz "${mfile}"; then
+	fatal "could not download ${mfile}"
 fi
 
-if ! tar xvzf sdcboot.tgz "${IPXEFILE}"; then
-	fatal 'could not extract iPXE binary from "sdcboot" tarball'
+if ! tar xvzf ipxe.tar.gz ${IPXEFILES}; then
+	fatal "could not extract iPXE binaries from tarball"
 fi
 
-mv "${IPXEFILE}" "${dir}/tftpboot/"
+mv ${IPXEFILES} ${dir}/tftpboot
 cd /
 rm -rf "${tdir}"
 
-printf 'ok\n' >&2
+printf "ok\n" >&2
