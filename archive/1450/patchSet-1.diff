commit 7e3f9020438803779bca1a40799db628d3360d69 (refs/changes/50/1450/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-02-06T18:03:55-08:00 (2 years, 8 months ago)
    
    joyent/node-mname#15 make format parser-generators into functions

diff --git a/lib/protocol.js b/lib/protocol.js
index c6ea187..d471ec4 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -49,562 +49,495 @@
 var ipaddr = require('ipaddr.js');
 var assert = require('assert-plus');
 var DNSBuffer = require('./dns-buffer');
+var util = require('util');
 
-var Formats = {};
+function DNSProtoBuffer(opts) {
+        assert.object(opts, 'options');
+        if (opts.buffer !== undefined)
+                assert.buffer(opts.buffer, 'options.buffer');
+        DNSBuffer.call(this, opts);
+}
+util.inherits(DNSProtoBuffer, DNSBuffer);
+
+DNSProtoBuffer.prototype.readRecord = function (ctx) {
+        var r = {};
+        var kctx = { parent: ctx };
+        kctx.name = (r.name = this.readName());
+        kctx.rtype = (r.rtype = this.readUInt16());
+        r.rclass = this.readUInt16();
+        r.rttl = this.readUInt32();
+        r.rdata = this.readNSData(kctx);
+        return (r);
+};
 
-Formats.record = {
-        name: { type: '_nsName' },
-        rtype: { type: 'UInt16BE' },
-        rclass: { type: 'UInt16BE' },
-        rttl: { type: 'UInt32BE' },
-        rdata: { type: '_nsData' }     // rdlength is prepended to this field
+DNSProtoBuffer.prototype.writeRecord = function (v, ctx) {
+        assert.object(v, 'record');
+        this.writeName(v.name);
+        this.writeUInt16(v.rtype);
+        this.writeUInt16(v.rclass);
+        this.writeUInt32(v.rttl);
+        var kctx = { parent: ctx, rtype: v.rtype, name: v.name };
+        this.writeNSData(v.rdata, kctx);
 };
 
-Formats.question = {
-        name: { type: '_nsName' },
-        type: { type: 'UInt16BE' },
-        qclass: { type: 'UInt16BE' }
+DNSProtoBuffer.prototype.readQuestion = function (ctx) {
+        var r = {};
+        r.name = this.readName();
+        r.type = this.readUInt16();
+        r.qclass = this.readUInt16();
+        return (r);
 };
 
-Formats.header = {
-        id: { type: 'UInt16BE' },
-        flags: { type: '_nsFlags' },
-        qdCount: { type: 'UInt16BE' },
-        anCount: { type: 'UInt16BE' },
-        nsCount: { type: 'UInt16BE' },
-        arCount: { type: 'UInt16BE' }
+DNSProtoBuffer.prototype.writeQuestion = function (v, ctx) {
+        assert.object(v, 'question');
+        this.writeName(v.name);
+        this.writeUInt16(v.type);
+        this.writeUInt16(v.qclass);
 };
 
-Formats.soa = {
-        host: { type: '_nsName' },
-        admin: { type: '_nsName' },
-        serial: { type: 'UInt32BE' },
-        refresh: { type: 'UInt32BE' },
-        retry: { type: 'UInt32BE' },
-        expire: { type: 'UInt32BE' },
-        ttl: { type: 'UInt32BE' }
+DNSProtoBuffer.prototype.readHeader = function (ctx) {
+        var r = {};
+        r.id = this.readUInt16();
+        r.flags = this.readNSFlags(ctx);
+        r.qdCount = this.readUInt16();
+        r.anCount = this.readUInt16();
+        r.nsCount = this.readUInt16();
+        r.arCount = this.readUInt16();
+        return (r);
 };
 
-Formats.mx = {
-        priority: { type: 'UInt16BE' },
-        exchange: { type: '_nsName' }
+DNSProtoBuffer.prototype.writeHeader = function (v, ctx) {
+        assert.object(v, 'header');
+        this.writeUInt16(v.id);
+        this.writeNSFlags(v.flags, { parent: ctx });
+        this.writeUInt16(v.qdCount);
+        this.writeUInt16(v.anCount);
+        this.writeUInt16(v.nsCount);
+        this.writeUInt16(v.arCount);
 };
 
-Formats.txt = {
-        text: { type: '_nsText' }
+DNSProtoBuffer.prototype.readSOA = function (ctx) {
+        var r = {};
+        r.host = this.readName();
+        r.admin = this.readName();
+        r.serial = this.readUInt32();
+        r.refresh = this.readUInt32();
+        r.retry = this.readUInt32();
+        r.expire = this.readUInt32();
+        r.ttl = this.readUInt32();
+        return (r);
 };
 
-Formats.opt = {
-        options: { type: '_ednsOptions' }
+DNSProtoBuffer.prototype.writeSOA = function (v, ctx) {
+        assert.object(v, 'soa');
+        this.writeName(v.host);
+        this.writeName(v.admin);
+        this.writeUInt32(v.serial);
+        this.writeUInt32(v.refresh);
+        this.writeUInt32(v.retry);
+        this.writeUInt32(v.expire);
+        this.writeUInt32(v.ttl);
 };
 
-Formats.srv = {
-        priority: { type: 'UInt16BE' },
-        weight: { type: 'UInt16BE' },
-        port: { type: 'UInt16BE' },
-        target: { type: '_nsName' }
+DNSProtoBuffer.prototype.readMX = function (ctx) {
+        var r = {};
+        r.priority = this.readUInt16();
+        r.exchange = this.readName();
+        return (r);
 };
 
-Formats.tsig = {
-        algorithm: { type: '_nsNamePlain' },
-        time: { type: 'DateTime48' },
-        fudge: { type: 'UInt16BE' },
-        mac: { type: '_lp16Binary' },
-        origid: { type: 'UInt16BE' },
-        error: { type: 'UInt16BE' },
-        other: { type: '_lp16Binary' }
+DNSProtoBuffer.prototype.writeMX = function (v, ctx) {
+        assert.object(v, 'mx');
+        this.writeUInt16(v.priority);
+        this.writeName(v.exchange);
 };
 
-Formats.tsigSignDataReq = {
-        message: { type: '_binary' },
-        rname: { type: '_nsNamePlain' },
-        rclass: { type: 'UInt16BE' },
-        rttl: { type: 'UInt32BE' },
-        algorithm: { type: '_nsNamePlain' },
-        time: { type: 'DateTime48' },
-        fudge: { type: 'UInt16BE' },
-        error: { type: 'UInt16BE' },
-        other: { type: '_lp16Binary' }
+DNSProtoBuffer.prototype.readSRV = function (ctx) {
+        var r = {};
+        r.priority = this.readUInt16();
+        r.weight = this.readUInt16();
+        r.port = this.readUInt16();
+        r.target = this.readName();
+        return (r);
 };
 
-Formats.tsigSignDataResp = {
-        rmac: { type: '_lp16Binary' },
-        message: { type: '_binary' },
-        rname: { type: '_nsNamePlain' },
-        rclass: { type: 'UInt16BE' },
-        rttl: { type: 'UInt32BE' },
-        algorithm: { type: '_nsNamePlain' },
-        time: { type: 'DateTime48' },
-        fudge: { type: 'UInt16BE' },
-        error: { type: 'UInt16BE' },
-        other: { type: '_lp16Binary' }
+DNSProtoBuffer.prototype.writeSRV = function (v, ctx) {
+        assert.object(v, 'srv');
+        this.writeUInt16(v.priority);
+        this.writeUInt16(v.weight);
+        this.writeUInt16(v.port);
+        this.writeName(v.target);
 };
 
-Formats.tsigSignTcp = {
-        rmac: { type: '_lp16Binary' },
-        message: { type: '_binary' },
-        time: { type: 'DateTime48' },
-        fudge: { type: 'UInt16BE' }
+DNSProtoBuffer.prototype.readTSIG = function (ctx) {
+        var r = {};
+        r.algorithm = this.readName();
+        r.time = this.readDateTime48();
+        r.fudge = this.readUInt16();
+        r.mac = this.readLengthPrefixed(2, function (cbuf) {
+                return (cbuf.remainder());
+        });
+        r.origid = this.readUInt16();
+        r.error = this.readUInt16();
+        r.other = this.readLengthPrefixed(2, function (cbuf) {
+                return (cbuf.remainder());
+        });
+        return (r);
 };
 
-Formats.message = {
-        header: { type: { format: 'header' } },
-        question: { type: { format: 'question' },
-            count: ['header', 'qdCount'] },
-        answer: { type: { format: 'record' },
-            count: ['header', 'anCount'] },
-        authority: { type: { format: 'record' },
-            maxCount: ['header', 'nsCount'] },
-        additional: { type: { format: 'record' },
-            maxCount: ['header', 'arCount'] }
+DNSProtoBuffer.prototype.writeTSIG = function (v, ctx) {
+        assert.object(v, 'tsig');
+        this.writeNamePlain(v.algorithm);
+        this.writeDateTime48(v.time, 'tsig.time');
+        this.writeUInt16(v.fudge);
+        this.writeUInt16(v.mac.length);
+        this.write(v.mac);
+        this.writeUInt16(v.origid);
+        this.writeUInt16(v.error);
+        this.writeUInt16(v.other.length);
+        this.write(v.other);
 };
 
-/* For compatibility, include these old aliases of 'message'. */
-Formats.queryMessage = Formats.message;
-Formats.answerMessage = Formats.message;
-Formats.answerMessageNoQ = Formats.message;
+DNSProtoBuffer.prototype.writeTSIGSignData = function (v, ctx) {
+        assert.object(v, 'tsigSignData');
+        this.writeNamePlain(v.rname);
+        this.writeUInt16(v.rclass);
+        this.writeUInt32(v.rttl);
+        this.writeNamePlain(v.algorithm);
+        this.writeDateTime48(v.time, 'tsig.time');
+        this.writeUInt16(v.fudge);
+        this.writeUInt16(v.error);
+        this.writeUInt16(v.other.length);
+        this.write(v.other);
+};
 
-// turns a dotted-decimal address into a UInt32
-function parseIPv4(addr) {
-        assert.string(addr);
+DNSProtoBuffer.prototype.writeTSIGSignDataReq = function (v, ctx) {
+        assert.object(v, 'tsigSignData');
+        this.write(v.message);
+        this.writeTSIGSignData(v, ctx);
+};
 
-        var octets = addr.split('.').map(function (octet) {
-                return (parseInt(octet, 10));
+DNSProtoBuffer.prototype.writeTSIGSignDataResp = function (v, ctx) {
+        assert.object(v, 'tsigSignData');
+        this.writeLengthPrefixed(2, function (cbuf) {
+                cbuf.write(v.rmac);
         });
-        if (octets.length !== 4)
-                throw new TypeError('valid IP address required');
-        var b = new Buffer(octets);
+        this.write(v.message);
+        this.writeTSIGSignData(v, ctx);
+};
+
+DNSProtoBuffer.prototype.writeTSIGSignTCP = function (v, ctx) {
+        assert.object(v, 'tsigSignDataTcp');
+        this.writeLengthPrefixed(2, function (cbuf) {
+                cbuf.write(v.rmac);
+        });
+        this.write(v.message);
+        this.writeDateTime48(v.time, 'tsig.time');
+        this.writeUInt16(v.fudge);
+};
+
+DNSProtoBuffer.prototype.readMessage = function (ctx) {
+        var r = {}, i;
+        r.header = this.readHeader(ctx);
+        r.question = [];
+        r.answer = [];
+        r.authority = [];
+        r.additional = [];
+        for (i = 0; i < r.header.qdCount; ++i)
+                r.question.push(this.readQuestion(ctx));
+        for (i = 0; i < r.header.anCount; ++i)
+                r.answer.push(this.readRecord(ctx));
+        for (i = 0; i < r.header.nsCount; ++i)
+                r.authority.push(this.readRecord(ctx));
+        for (i = 0; i < r.header.arCount && !this.atEnd(); ++i)
+                r.additional.push(this.readRecord(ctx));
+        return (r);
+};
+
+DNSProtoBuffer.prototype.writeMessage = function (v, ctx) {
+        var i;
+        assert.object(v, 'message');
+        this.writeHeader(v.header, ctx);
+        for (i = 0; i < v.header.qdCount; ++i)
+                this.writeQuestion(v.question[i], ctx);
+        for (i = 0; i < v.header.anCount; ++i)
+                this.writeRecord(v.answer[i], ctx);
+        for (i = 0; i < v.header.nsCount; ++i)
+                this.writeRecord(v.authority[i], ctx);
+        for (i = 0; i < v.header.arCount; ++i)
+                this.writeRecord(v.additional[i], ctx);
+};
+
+/*
+ * Turns an IPv4 address in dotted-decimal notation into a UInt32BE. This gets
+ * very hot in a lot of cases, so it's worth avoiding unnecessary memory
+ * allocation and optimizing this pretty heavily.
+ */
+function parseIPv4(addr) {
+        assert.string(addr);
+        var b = new Buffer(4);
+        var i = -1, j, k = 0;
+        while (i < addr.length && k < 4) {
+                j = addr.indexOf('.', i + 1);
+                if (j === -1)
+                        j = addr.length;
+                b[k++] = parseInt(addr.slice(i + 1, j), 10);
+                i = j;
+        }
+        if (k !== 4)
+                throw (new TypeError('valid IP address required'));
         return (b.readUInt32BE(0));
 }
 
 
 function parseIPv6(addr) {
         assert.string(addr);
-
         var a;
         try {
                 a = ipaddr.parse(addr);
         } catch (e) {
                 return false;
         }
-
-        return a.parts;
+        return (a.parts);
 
 }
 
-
-// each of these serializers are functions which accept a value to serialize
-// and must return the serialized value as a buffer
-var serializers = {
-        'DateTime48': {
-                encoder: function (buf, v, ctx) {
-                        assert.date(v, ctx.field);
-                        var secs = v.getTime() / 1000;
-                        var highPart = Math.floor(secs / 4294967296);
-                        var lowPart = secs & 0xffffffff;
-                        buf.writeUInt16(highPart);
-                        buf.writeUInt32(lowPart);
-                },
-                decoder: function (buf, ctx) {
-                        var highPart = buf.readUInt16();
-                        var lowPart = buf.readUInt32();
-                        var d = new Date();
-                        d.setTime((highPart * 4294967296 + lowPart) * 1000);
-                        return (d);
-                }
-        },
-        'UInt32BE': {
-                encoder: function (buf, v, ctx) {
-                        assert.number(v, ctx.field);
-                        buf.writeUInt32(v);
-                },
-                decoder: function (buf, ctx) {
-                        return (buf.readUInt32());
-                }
-        },
-        'UInt16BE': {
-                encoder: function (buf, v, ctx) {
-                        assert.number(v, ctx.field);
-                        buf.writeUInt16(v);
-                },
-                decoder: function (buf, ctx) {
-                        return (buf.readUInt16());
-                }
-        },
-        '_nsFlags': {
-                encoder: function (buf, v, ctx) {
-                        assert.object(v, 'flags');
-                        var f = 0x0000;
-                        f = f | (v.qr << 15);
-                        f = f | (v.opcode << 11);
-                        f = f | (v.aa << 10);
-                        f = f | (v.tc << 9);
-                        f = f | (v.rd << 8);
-                        f = f | (v.ra << 7);
-                        f = f | (v.z  << 6);
-                        f = f | (v.ad << 5);
-                        f = f | (v.cd << 4);
-                        f = f | v.rcode;
-                        buf.writeUInt16(f);
-                },
-                decoder: function (buf, ctx) {
-                        var flags = buf.readUInt16();
-                        var f = {
-                                qr:     ((flags & 0x8000)) ? true : false,
-                                opcode: ((flags & 0x7800) >> 11),
-                                aa:     ((flags & 0x0400)) ? true : false,
-                                tc:     ((flags & 0x0200)) ? true : false,
-                                rd:     ((flags & 0x0100)) ? true : false,
-                                ra:     ((flags & 0x0080)) ? true : false,
-                                z:      ((flags & 0x0040)) ? true : false,
-                                ad:     ((flags & 0x0020)) ? true : false,
-                                cd:     ((flags & 0x0010)) ? true : false,
-                                rcode:  ((flags & 0x000F))
-                        };
-                        return (f);
-                }
-        },
-        '_nsIP4': {
-                encoder: function (buf, v, ctx) {
-                        assert.string(v, 'ipv4');
-                        var a = parseIPv4(v);
-                        buf.writeUInt32(a);
-                },
-                decoder: function (buf, ctx) {
-                        var parts = [];
-                        for (var i = 0; i < 4; ++i)
-                                parts[i] = buf.readUInt8().toString(10);
-                        return (parts.join('.'));
-                }
-        },
-        '_nsIP6': {
-                encoder: function (buf, v, ctx) {
-                        assert.string(v, 'ipv6');
-                        var a = parseIPv6(v);
-                        for (var i = 0; i < 8; i++)
-                                buf.writeUInt16(a[i]);
-                },
-                decoder: function (buf, ctx) {
-                        var parts = [];
-                        for (var i = 0; i < 8; ++i)
-                                parts[i] = buf.readUInt16().toString(16);
-                        return (parts.join(':'));
-                }
-        },
-        '_binary': {
-                encoder: function (buf, v, ctx) {
-                        assert.buffer(v, ctx.field);
-                        buf.write(v);
-                },
-                decoder: function (buf, ctx) {
-                        throw (new Error('Direct binaries are write only'));
-                }
-        },
-        '_ednsOptions': {
-                encoder: function (buf, v, ctx) {
-                        assert.optionalArrayOfObject(v, 'edns options');
-                        if (v === undefined)
-                                return;
-                        v.forEach(function (opt) {
-                                assert.number(opt.code);
-                                assert.buffer(opt.data);
-                                buf.writeUInt16(opt.code);
-                                buf.writeLengthPrefixed(2, function (cbuf) {
-                                        cbuf.write(opt.data);
-                                });
-                        });
-                },
-                decoder: function (buf, ctx) {
-                        var opts = [];
-                        while (!buf.atEnd()) {
-                                var opt = {};
-                                opt.code = buf.readUInt16();
-                                buf.readLengthPrefixed(2, function (cbuf) {
-                                        opt.data = cbuf.remainder();
-                                });
-                                opts.push(opt);
-                        }
-
-                        return (opts);
-                }
-        },
-        '_nsName': {
-                encoder: function (buf, v, ctx) {
-                        assert.string(v, 'name');
-                        buf.writeName(v);
-                },
-                decoder: function (buf, ctx) {
-                        return (buf.readName());
-                }
-        },
-        '_nsNamePlain': {
-                encoder: function (buf, v, ctx) {
-                        assert.string(v, ctx.field);
-                        buf.writeNamePlain(v);
-                },
-                decoder: function (buf, ctx) {
-                        return (buf.readName());
-                }
-        },
-        '_nsText': {
-                encoder: function (buf, v, ctx) {
-                        assert.string(v);
-                        buf.writeUInt8(v.length);
-                        buf.write(new Buffer(v, 'binary'));
-                },
-                decoder: function (buf, ctx) {
-                        var r;
-                        buf.readLengthPrefixed(1, function (cbuf) {
-                                r = cbuf.remainder().toString('binary');
-                        });
-                        return (r);
-                }
-        },
-        '_lp16Binary': {
-                encoder: function (buf, v, ctx) {
-                        assert.buffer(v);
-                        buf.writeUInt16(v.length);
-                        buf.write(v);
-                },
-                decoder: function (buf, ctx) {
-                        var r;
-                        buf.readLengthPrefixed(2, function (cbuf) {
-                                r = cbuf.remainder();
-                        });
-                        return (r);
-                }
-        },
-        '_nsData': {
-                encoder: function (buf, v, ctx) {
-                        buf.writeLengthPrefixed(2, function (cbuf) {
-                                switch (ctx.parent.rtype) {
-                                case queryTypes['A']:
-                                        serializers['_nsIP4'].
-                                            encoder(cbuf, v.target, ctx);
-                                        break;
-                                case queryTypes['AAAA']:
-                                        serializers['_nsIP6'].
-                                            encoder(cbuf, v.target, ctx);
-                                        break;
-                                case queryTypes['CNAME']:
-                                case queryTypes['NS']:
-                                case queryTypes['PTR']:
-                                        serializers['_nsName'].
-                                            encoder(cbuf, v.target, ctx);
-                                        break;
-                                case queryTypes['TXT']:
-                                        serializers['_nsText'].
-                                            encoder(cbuf, v.target, ctx);
-                                        break;
-                                case queryTypes['SOA']:
-                                        _encode(cbuf, v, 'soa', ctx);
-                                        break;
-                                case queryTypes['MX']:
-                                        _encode(cbuf, v, 'mx', ctx);
-                                        break;
-                                case queryTypes['SRV']:
-                                        _encode(cbuf, v, 'srv', ctx);
-                                        break;
-                                case queryTypes['OPT']:
-                                        _encode(cbuf, v, 'opt', ctx);
-                                        break;
-                                case queryTypes['TSIG']:
-                                        _encode(cbuf, v, 'tsig', ctx);
-                                        break;
-                                default:
-                                        throw new Error('unrecognized nsdata' +
-                                            ' type');
-                                }
-                        });
-                },
-                decoder: function (buf, ctx) {
-                        var res = buf.readLengthPrefixed(2, function (cbuf) {
-                                var r;
-                                switch (ctx.parent.rtype) {
-                                case queryTypes['A']:
-                                        r = serializers['_nsIP4'].
-                                            decoder(cbuf, ctx);
-                                        r = {target: r};
-                                        break;
-                                case queryTypes['AAAA']:
-                                        r = serializers['_nsIP6'].
-                                            decoder(cbuf, ctx);
-                                        r = {target: r};
-                                        break;
-                                case queryTypes['CNAME']:
-                                case queryTypes['NS']:
-                                case queryTypes['PTR']:
-                                        r = serializers['_nsName'].
-                                            decoder(cbuf, ctx);
-                                        r = {target: r};
-                                        break;
-                                case queryTypes['TXT']:
-                                        r = serializers['_nsText'].
-                                            decoder(cbuf, ctx);
-                                        r = {target: r};
-                                        break;
-                                case queryTypes['SOA']:
-                                        r = _decode(cbuf, 'soa', ctx);
-                                        break;
-                                case queryTypes['MX']:
-                                        r = _decode(cbuf, 'mx', ctx);
-                                        break;
-                                case queryTypes['SRV']:
-                                        r = _decode(cbuf, 'srv', ctx);
-                                        break;
-                                case queryTypes['OPT']:
-                                        r = _decode(cbuf, 'opt', ctx);
-                                        break;
-                                case queryTypes['TSIG']:
-                                        r = _decode(cbuf, 'tsig', ctx);
-                                        break;
-                                default:
-                                        throw (new Error('unsupported nsdata ' +
-                                            'type: ' +
-                                            queryTypes[ctx.parent.rtype]));
-                                }
-                                return (r);
-                        });
-                        return (res);
-                }
-        }
+DNSProtoBuffer.prototype.readDateTime48 = function () {
+        var highPart = this.readUInt16();
+        var lowPart = this.readUInt32();
+        var d = new Date();
+        d.setTime((highPart * 4294967296 + lowPart) * 1000);
+        return (d);
 };
 
-function _encode(buf, obj, format, ctx) {
-        assert.object(obj);
-        assert.string(format);
-        assert.optionalObject(ctx);
-
-        var kidctx = { parent: obj, parentCtx: ctx };
+DNSProtoBuffer.prototype.writeDateTime48 = function (v, name) {
+        assert.date(v, name);
+        var secs = v.getTime() / 1000;
+        var highPart = Math.floor(secs / 4294967296);
+        var lowPart = secs & 0xffffffff;
+        this.writeUInt16(highPart);
+        this.writeUInt32(lowPart);
+};
 
-        var fmt = Formats[format];
+DNSProtoBuffer.prototype.readNSFlags = function (ctx) {
+        var flags = this.readUInt16();
+        var f = {
+                qr:     ((flags & 0x8000)) ? true : false,
+                opcode: ((flags & 0x7800) >> 11),
+                aa:     ((flags & 0x0400)) ? true : false,
+                tc:     ((flags & 0x0200)) ? true : false,
+                rd:     ((flags & 0x0100)) ? true : false,
+                ra:     ((flags & 0x0080)) ? true : false,
+                z:      ((flags & 0x0040)) ? true : false,
+                ad:     ((flags & 0x0020)) ? true : false,
+                cd:     ((flags & 0x0010)) ? true : false,
+                rcode:  ((flags & 0x000F))
+        };
+        return (f);
+};
 
-        var keys = Object.keys(fmt);
-        for (var j = 0; j < keys.length; ++j) {
-                var f = keys[j];
-                kidctx.field = f;
-                var type = fmt[f].type;
+DNSProtoBuffer.prototype.writeNSFlags = function (v, ctx) {
+        assert.object(v, 'flags');
+        var f = 0x0000;
+        f = f | (v.qr << 15);
+        f = f | (v.opcode << 11);
+        f = f | (v.aa << 10);
+        f = f | (v.tc << 9);
+        f = f | (v.rd << 8);
+        f = f | (v.ra << 7);
+        f = f | (v.z  << 6);
+        f = f | (v.ad << 5);
+        f = f | (v.cd << 4);
+        f = f | v.rcode;
+        this.writeUInt16(f);
+};
 
-                var vs = [obj[f]];
-                var count;
-                if (fmt[f].count !== undefined ||
-                    fmt[f].maxCount !== undefined) {
-                        count = evalCount(obj, fmt[f]);
-                        vs = obj[f];
-                        assert.arrayOfObject(vs, f);
-                        assert.strictEqual(count, vs.length, f + ' requires ' +
-                            count + ' items');
-                }
+DNSProtoBuffer.prototype.readIP4 = function (ctx) {
+        var parts = [];
+        for (var i = 0; i < 4; ++i)
+                parts[i] = this.readUInt8().toString(10);
+        return (parts.join('.'));
+};
 
-                for (var i = 0; i < vs.length; ++i) {
-                        var v = vs[i];
+DNSProtoBuffer.prototype.writeIP4 = function (v, ctx) {
+        assert.string(v, 'ipv4');
+        var a = parseIPv4(v);
+        this.writeUInt32(a);
+};
 
-                        if (typeof (type) === 'string') {
-                                serializers[type].encoder(buf, v, kidctx);
+DNSProtoBuffer.prototype.readIP6 = function (ctx) {
+        var parts = [];
+        for (var i = 0; i < 8; ++i)
+                parts[i] = this.readUInt16().toString(16);
+        return (parts.join(':'));
+};
 
-                        } else if (typeof (type) === 'object') {
-                                var reftype = type.format;
-                                _encode(buf, v, reftype, kidctx);
+DNSProtoBuffer.prototype.writeIP6 = function (v, ctx) {
+        assert.string(v, 'ipv6');
+        var a = parseIPv6(v);
+        for (var i = 0; i < 8; i++)
+                this.writeUInt16(a[i]);
+};
 
-                        } else {
-                                var err = new TypeError('Invalid format type');
-                                err.type = type;
-                                err.context = kidctx;
-                                throw (err);
-                        }
-                }
+DNSProtoBuffer.prototype.readOPT = function (ctx) {
+        var opts = [];
+        while (!this.atEnd()) {
+                var opt = {};
+                opt.code = this.readUInt16();
+                this.readLengthPrefixed(2, function (cbuf) {
+                        opt.data = cbuf.remainder();
+                });
+                opts.push(opt);
         }
 
-        return (buf.toBuffer());
-}
-
-function encode(obj, format) {
-        var buf = new DNSBuffer({});
-        return (_encode(buf, obj, format));
-}
+        return ({ options: opts });
+};
 
-function evalCount(obj, fmtf) {
-        var countExpr = fmtf.count || fmtf.maxCount;
-        var x = obj;
-        if (Array.isArray(countExpr)) {
-                countExpr.forEach(function (prop) {
-                        x = x[prop];
+DNSProtoBuffer.prototype.writeOPT = function (v, ctx) {
+        assert.object(v, 'edns opt');
+        assert.optionalArrayOfObject(v.options, 'edns options');
+        if (v.options === undefined)
+                return;
+        v.options.forEach(function (opt) {
+                assert.number(opt.code);
+                assert.buffer(opt.data);
+                this.writeUInt16(opt.code);
+                this.writeLengthPrefixed(2, function (cbuf) {
+                        cbuf.write(opt.data);
                 });
-        } else {
-                x = countExpr;
-        }
-        assert.number(x);
-        return (x);
-}
+        });
+};
 
-function _decode(buf, format, ctx) {
-        assert.object(buf);
-        assert.ok(buf instanceof DNSBuffer);
-        assert.string(format);
-        assert.optionalObject(ctx);
-
-        var result = {};
-        var kidctx = { parent: result, parentCtx: ctx };
-
-        var fmt = Formats[format];
-        assert.object(fmt);
-
-        var keys = Object.keys(fmt);
-        for (var j = 0; j < keys.length; ++j) {
-                var f = keys[j];
-                kidctx.field = f;
-
-                var res;
-                var type = fmt[f].type;
-                var count, required = false;
-                if (fmt[f].count !== undefined) {
-                        count = evalCount(result, fmt[f]);
-                        result[f] = [];
-                        required = true;
-                }
-                if (fmt[f].maxCount !== undefined) {
-                        count = evalCount(result, fmt[f]);
-                        result[f] = [];
+DNSProtoBuffer.prototype.readNSText = function (ctx) {
+        var r;
+        this.readLengthPrefixed(1, function (cbuf) {
+                r = cbuf.remainder().toString('binary');
+        });
+        return (r);
+};
+
+DNSProtoBuffer.prototype.writeNSText = function (v, ctx) {
+        assert.string(v);
+        this.writeUInt8(v.length);
+        this.write(new Buffer(v, 'binary'));
+};
+
+DNSProtoBuffer.prototype.readNSData = function (ctx) {
+        var res = this.readLengthPrefixed(2, function (cbuf) {
+                var r;
+                switch (ctx.rtype) {
+                case queryTypes['A']:
+                        r = { target: cbuf.readIP4(ctx) };
+                        break;
+                case queryTypes['AAAA']:
+                        r = { target: cbuf.readIP6(ctx) };
+                        break;
+                case queryTypes['CNAME']:
+                case queryTypes['NS']:
+                case queryTypes['PTR']:
+                        r = { target: cbuf.readName(ctx) };
+                        break;
+                case queryTypes['TXT']:
+                        r = { target: cbuf.readNSText(ctx) };
+                        break;
+                case queryTypes['SOA']:
+                        r = cbuf.readSOA(ctx);
+                        break;
+                case queryTypes['MX']:
+                        r = cbuf.readMX(ctx);
+                        break;
+                case queryTypes['SRV']:
+                        r = cbuf.readSRV(ctx);
+                        break;
+                case queryTypes['OPT']:
+                        r = cbuf.readOPT(ctx);
+                        break;
+                case queryTypes['TSIG']:
+                        r = cbuf.readTSIG(ctx);
+                        break;
+                default:
+                        throw (new Error('unsupported nsdata type: ' +
+                            queryTypes[ctx.rtype]));
                 }
+                return (r);
+        });
+        return (res);
+};
 
-                /*
-                 * If the type is a string it's a reference to a serializer.
-                 * If the type is an object it's a nested format and we call
-                 * decode again with the appropriate offset.
-                 */
-
-                var times = (count === undefined) ? 1 : count;
-                for (var i = 0; i < times; ++i) {
-                        if (buf.atEnd() && !required)
-                                break;
-
-                        if (typeof (type) === 'string') {
-                                res = serializers[type].decoder(buf, kidctx);
-
-                        } else if (typeof (type) === 'object') {
-                                var reftype = type.format;
-                                res = _decode(buf, reftype, kidctx);
-
-                        } else {
-                                var err = new TypeError('Invalid format type');
-                                err.type = type;
-                                err.context = kidctx;
-                                throw (err);
-                        }
-
-                        if (count !== undefined)
-                                result[f].push(res);
-                        else
-                                result[f] = res;
+DNSProtoBuffer.prototype.writeNSData = function (v, ctx) {
+        this.writeLengthPrefixed(2, function (cbuf) {
+                switch (ctx.rtype) {
+                case queryTypes['A']:
+                        cbuf.writeIP4(v.target, ctx);
+                        break;
+                case queryTypes['AAAA']:
+                        cbuf.writeIP6(v.target, ctx);
+                        break;
+                case queryTypes['CNAME']:
+                case queryTypes['NS']:
+                case queryTypes['PTR']:
+                        cbuf.writeName(v.target);
+                        break;
+                case queryTypes['TXT']:
+                        cbuf.writeNSText(v.target, ctx);
+                        break;
+                case queryTypes['SOA']:
+                        cbuf.writeSOA(v, ctx);
+                        break;
+                case queryTypes['MX']:
+                        cbuf.writeMX(v, ctx);
+                        break;
+                case queryTypes['SRV']:
+                        cbuf.writeSRV(v, ctx);
+                        break;
+                case queryTypes['OPT']:
+                        cbuf.writeOPT(v, ctx);
+                        break;
+                case queryTypes['TSIG']:
+                        cbuf.writeTSIG(v, ctx);
+                        break;
+                default:
+                        throw new Error('unrecognized nsdata type');
                 }
-        }
+        });
+};
 
-        return (result);
+function encode(obj, format) {
+        var buf = new DNSProtoBuffer({});
+        switch (format) {
+        case 'message':
+        /* These are legacy aliases for compatibility. */
+        case 'queryMessage':
+        case 'answerMessage':
+        case 'answerMessageNoQ':
+                buf.writeMessage(obj, {});
+                break;
+        case 'tsigSignDataReq':
+                buf.writeTSIGSignDataReq(obj, {});
+                break;
+        case 'tsigSignDataResp':
+                buf.writeTSIGSignDataResp(obj, {});
+                break;
+        case 'tsigSignTcp':
+                buf.writeTSIGSignTCP(obj, {});
+                break;
+        default:
+                throw (new Error('Unknown format: ' + format));
+        }
+        return (buf.toBuffer());
 }
 
 function decode(raw, format) {
-        var buf = new DNSBuffer({buffer: raw});
-        return (_decode(buf, format));
+        var buf = new DNSProtoBuffer({ buffer: raw });
+        switch (format) {
+        case 'message':
+        case 'queryMessage':
+        case 'answerMessage':
+        case 'answerMessageNoQ':
+                return (buf.readMessage({}));
+        default:
+                throw (new Error('Unknown format: ' + format));
+        }
 }
 
 var opCodes = {
diff --git a/package.json b/package.json
index 374a491..2d4caba 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "mname",
   "description": "DNS server library for node.js",
-  "version": "1.3.2",
+  "version": "1.3.3",
   "author": "arekinath <alex@cooperi.net>",
   "contributors": [
     "Mark Cavage",
