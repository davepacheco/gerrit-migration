From 608350ffc5e686c06c493e5b1a5d549fea6c454c Mon Sep 17 00:00:00 2001
From: dyep <dyep49@gmail.com>
Date: Wed, 12 Sep 2018 11:10:23 -0700
Subject: [PATCH] OS-7182 vmadm can create/destroy/rollback bhyve VM snapshots

---
 overlay/generic/manifest                      |   2 +
 .../generic/usr/lib/brand/bhyve/statechange   |  25 ++
 src/vm/man/vmadm.1m.md                        |  26 +-
 src/vm/node_modules/VM.js                     | 128 +++++---
 src/vm/tests/test-snapshots.js                | 299 +++++++++++++++++-
 5 files changed, 418 insertions(+), 62 deletions(-)
 create mode 100644 overlay/generic/usr/lib/brand/bhyve/statechange

diff --git a/overlay/generic/manifest b/overlay/generic/manifest
index ebc1a35c..955677c6 100644
--- a/overlay/generic/manifest
+++ b/overlay/generic/manifest
@@ -118,6 +118,8 @@ f smartdc/vm-upgrade/001_upgrade 0555 root bin
 f usr/bin/json 0555 root bin
 f usr/include/usb.h 0444 root bin
 d usr/lib/brand 0755 root bin
+d usr/lib/brand/bhyve 0755 root bin
+f usr/lib/brand/bhyve/statechange 0444 root root
 d usr/lib/brand/jcommon 0755 root bin
 f usr/lib/brand/jcommon/cattach 0444 root root
 f usr/lib/brand/jcommon/cdetach 0444 root root
diff --git a/overlay/generic/usr/lib/brand/bhyve/statechange b/overlay/generic/usr/lib/brand/bhyve/statechange
new file mode 100644
index 00000000..398f46b4
--- /dev/null
+++ b/overlay/generic/usr/lib/brand/bhyve/statechange
@@ -0,0 +1,25 @@
+#! /bin/ksh
+
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+ps_brand=bhyve
+
+# Should we show snapshots?
+jst_showsnap="yes"
+
+typeset -A FORCED_ATTRS
+FORCED_ATTRS["zlog-mode"]=g--
+FORCED_ATTRS["zlog-name"]=platform.log
+
+. /usr/lib/brand/jcommon/statechange
diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index f54db653..95547c95 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -37,8 +37,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       create-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         The <snapname> parameter specifies the name of the snapshot to take
         of the specified VM. The snapname must be 64 characters or less and
@@ -83,8 +83,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       delete-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         This command deletes the ZFS snapshot that exists with the name
         <snapname> from the VM with the specified uuid. You cannot undo this
@@ -248,8 +248,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       rollback-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         This command rolls the dataset backing the the VM with the specified
         uuid back to its state at the point when the snapshot with snapname was
@@ -482,9 +482,9 @@ tab-complete UUIDs rather than having to type them out for every command.
 
 ## SNAPSHOTS
 
-    Snapshots are currently only implemented for OS VMs, and only for those
-    that do not utilize delegated datasets or any other datasets other than
-    the zoneroot dataset.
+    Snapshots are currently only implemented for bhyve VMs and OS VMs, and only
+    for those that do not utilize delegated datasets or any other datasets other
+    than the zoneroot dataset.
 
     When you create a snapshot with create-snapshot, it will create a ZFS
     snapshot of that dataset with the name dataset@vmsnap-<snapname> and the
@@ -1798,12 +1798,12 @@ tab-complete UUIDs rather than having to type them out for every command.
 
     snapshots (EXPERIMENTAL):
 
-        For OS VMs, this will display a list of snapshots from which you can
-        restore the root dataset for your VM.  Currently this is only supported
-        when your VM does not have any delegated datasets.
+        For bhyve VMs and OS VMs, this will display a list of snapshots from
+        which you can restore the root dataset for your VM.  Currently this
+        is only supported when your VM does not have any delegated datasets.
 
         type: array
-        vmtype: OS
+        vmtype: OS or bhyve
         listable: no
         create: no (but you can use create-snapshot)
         update: no (but you can use rollback-snapshot and delete-snapshot)
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index f7b97338..193bc5ec 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -66,7 +66,6 @@
 
 // Ensure we're using the platform's node
 require('/usr/node/node_modules/platform_node_version').assert();
-
 var assert = require('/usr/node/node_modules/assert-plus');
 var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
@@ -11505,7 +11504,7 @@ exports.rollback_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+        if (vmobj.brand === 'kvm') {
             callback(new Error('snapshots for ' + vmobj.brand
                 + ' VMs currently unsupported'));
             return;
@@ -11528,49 +11527,78 @@ exports.rollback_snapshot = function (uuid, snapname, options, callback)
 
         snapshot_list = [vmobj.zfs_filesystem + '@vmsnap-' + snapname];
 
-        if (vmobj.state !== 'stopped') {
-            VM.stop(vmobj.uuid, {'force': true, log: log}, function (stop_err) {
-                if (stop_err) {
-                    log.error(stop_err, 'failed to stop VM ' + vmobj.uuid
-                        + ': ' + stop_err.message);
-                    callback(stop_err);
-                    return;
-                }
-                performSnapshotRollback(snapshot_list, log,
-                    function (rollback_err) {
-
-                    if (rollback_err) {
-                        log.error(rollback_err, 'failed to '
-                            + 'performSnapshotRollback');
-                        callback(rollback_err);
+        vasync.pipeline({
+            funcs: [
+                function listSnapshots(_, next) {
+                    if (vmobj.brand !== 'bhyve') {
+                        snapshot_list = [vmobj.zfs_filesystem + '@vmsnap-'
+                            + snapname];
+                        next();
                         return;
                     }
-                    if (options.do_not_start) {
-                        callback();
-                    } else {
-                        VM.start(vmobj.uuid, {}, {log: log}, callback);
+
+                    var args = ['list', '-o', 'name', '-H', '-t',
+                        'snapshot', '-r', 'zones/' + vmobj.uuid ];
+
+                    zfs(args, log, function onList(zfs_err, fds) {
+                        if (zfs_err) {
+                            log.error({err: zfs_err, stdout: fds.stdout,
+                                stderr: fds.stdout}, 'zfs list failed.');
+                            next(zfs_err);
+                            return;
+                        }
+
+                        log.debug({err: zfs_err, stdout: fds.stdout,
+                            stderr: fds.stderr}, 'zfs '
+                            + args.join(' '));
+
+                        snapshot_list = fds.stdout.split('\n').filter(
+                        function matchSnapshot(snapshot) {
+                            var re = new RegExp('@vmsnap-' + snapname + '$');
+                            return re.test(snapshot);
+                        });
+
+                        next();
+                    });
+                },
+                function stopVm(_, next) {
+                    if (vmobj.state === 'stopped') {
+                        next();
+                        return;
                     }
-                    return;
-                });
-            });
-        } else {
-            performSnapshotRollback(snapshot_list, log,
-                function (rollback_err) {
 
-                if (rollback_err) {
-                    log.error(rollback_err, 'failed to '
-                        + 'performSnapshotRollback');
-                    callback(rollback_err);
-                    return;
-                }
-                if (options.do_not_start) {
-                    callback();
-                } else {
-                    VM.start(vmobj.uuid, {}, {log: log}, callback);
+                    VM.stop(vmobj.uuid, {'force': true, log: log},
+                    function vmStopped(stop_err) {
+                        if (stop_err) {
+                            log.error(stop_err, 'failed to stop VM '
+                                + vmobj.uuid + ': ' + stop_err.message);
+                            next(stop_err);
+                            return;
+                        }
+
+                        next();
+                    });
+                },
+                function performRollback(_, next) {
+                    performSnapshotRollback(snapshot_list, log,
+                    function (rollback_err) {
+                        if (rollback_err) {
+                            log.error(rollback_err, 'failed to '
+                                + 'performSnapshotRollback');
+                            next(rollback_err);
+                            return;
+                        }
+
+                        if (options.do_not_start) {
+                            next();
+                            return;
+                        }
+
+                        VM.start(vmobj.uuid, {}, {log: log}, next);
+                    });
                 }
-                return;
-            });
-        }
+            ]
+        }, callback);
     });
 };
 
@@ -11624,7 +11652,7 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+        if (vmobj.brand === 'kvm') {
             callback(new Error('snapshots for ' + vmobj.brand
                 + ' VMs currently unsupported'));
             return;
@@ -11699,8 +11727,13 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
             }, function (cb) {
                 var args;
 
-                args = ['destroy', vmobj.zfs_filesystem + '@vmsnap-'
-                    + snapname];
+                if (vmobj.brand === 'bhyve') {
+                    args = ['destroy', '-r', vmobj.zfs_filesystem + '@vmsnap-'
+                        + snapname];
+                } else {
+                    args = ['destroy', vmobj.zfs_filesystem + '@vmsnap-'
+                        + snapname];
+                }
 
                 zfs(args, log, function (e, fds) {
                     if (e) {
@@ -11786,7 +11819,7 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+        if (vmobj.brand === 'kvm') {
             callback(new Error('snapshots for ' + vmobj.brand
                 + ' VMs currently unsupported'));
             return;
@@ -11835,7 +11868,12 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
             function (cb) {
                 // take the snapshot
                 var args;
-                args = ['snapshot'].concat(snapshot_list);
+
+                if (vmobj.brand === 'bhyve') {
+                    args = ['snapshot', '-r'].concat(snapshot_list);
+                } else {
+                    args = ['snapshot'].concat(snapshot_list);
+                }
 
                 zfs(args, log, function (zfs_err, fds) {
                     if (zfs_err) {
diff --git a/src/vm/tests/test-snapshots.js b/src/vm/tests/test-snapshots.js
index b718026f..e17080fa 100644
--- a/src/vm/tests/test-snapshots.js
+++ b/src/vm/tests/test-snapshots.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -167,8 +167,8 @@ test('create KVM VM', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
-                if (!err) {
+                t.ok(!e, 'loading VM after create');
+                if (!e) {
                     t.ok(o.snapshots.length === 0, 'VM has no snapshots');
                     vmobj = o;
                 } else {
@@ -257,7 +257,7 @@ test('create joyent-minimal VM w/o delegated', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                t.ok(!e, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
@@ -1163,3 +1163,294 @@ test('delete VM with garbage snapshot', function (t) {
         vmobj = {};
     });
 });
+
+//    create snapshot
+//    snapshot count == 1
+//    replace data
+//    create second snapshot
+//    snapshot count == 2
+//    rollback to snapshot1
+//    read data
+//    rollback to snapshot2
+//    read data
+//    delete snapshot1
+//    snapshot count == 1
+//    delete snapshot2
+//    snapshot count == 0
+
+test('create bhyve VM', function (t) {
+    var payload = {
+        alias: 'test-snapshots-' + process.pid,
+        brand: 'bhyve',
+        autoboot: true,
+        do_not_inventory: true,
+        ram: 128,
+        disks: [ {
+            size: 5120,
+            model: 'virtio'
+        } ]
+    };
+
+    VM.create(payload, function (err, obj) {
+        if (err) {
+            t.ok(false, 'error creating VM: ' + err.message);
+            t.end();
+        } else {
+            t.ok(true, 'VM created with uuid ' + obj.uuid);
+            VM.load(obj.uuid, function (e, o) {
+                t.ok(!e, 'loading VM after create');
+                if (!e) {
+                    t.ok(o.snapshots.length === 0, 'VM has no snapshots');
+                    t.ok(o.hasOwnProperty('zfs_filesystem'),
+                        'has zfs_filesystem');
+                    vmobj = o;
+                } else {
+                    abort = true;
+                }
+                t.end();
+            });
+        }
+    });
+});
+
+test('write file to bhyve zoneroot then snapshot1', function (t) {
+
+    var filename;
+
+    if (abort) {
+        t.ok(false, 'skipping writing as test run is aborted.');
+        t.end();
+        return;
+    }
+    filename = path.join(vmobj.zonepath, 'root', '/tmp/hello.txt');
+
+    fs.writeFile(filename, MAGIC_STRING1, function (err) {
+        t.ok(!err, 'no error writing file to zoneroot');
+        if (err) {
+            abort = true;
+            t.end();
+        } else {
+            VM.create_snapshot(vmobj.uuid, 'snapshot1', {}, function (snaperr) {
+                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid
+                    + (snaperr ? ' ' + snaperr.message : ''));
+                VM.load(vmobj.uuid, function (e, o) {
+                    t.ok(!e, 'loading VM after create');
+                    if (!e) {
+                        t.ok(o.snapshots.length === 1,
+                            '1 snapshot after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                            'snapshot1 after create');
+                    } else {
+                        abort = true;
+                    }
+                    t.end();
+                });
+            });
+        }
+    });
+});
+
+test('write file to bhyve zoneroot again then snapshot2', function (t) {
+    var filename;
+
+    if (abort) {
+        t.ok(false, 'skipping writing as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    filename = path.join(vmobj.zonepath, 'root', '/tmp/hello.txt');
+
+    fs.writeFile(filename, MAGIC_STRING2, function (err) {
+        t.ok(!err, 'no error writing file to zoneroot'
+            + (err ? ' ' + err.message : ''));
+        if (err) {
+            abort = true;
+            t.end();
+        } else {
+            VM.create_snapshot(vmobj.uuid, 'snapshot2', {}, function (snaperr) {
+                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid);
+                VM.load(vmobj.uuid, function (e, o) {
+                    t.ok(!e, 'loading VM after create');
+                    if (!e) {
+                        t.ok(o.snapshots.length === 2,
+                            '2 snapshots after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                            'snapshot1 after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot2'),
+                            'snapshot2 after create');
+                    } else {
+                        abort = true;
+                    }
+                    t.end();
+                });
+            });
+        }
+    });
+});
+
+test('write file to bhyve zoneroot one last time, then snapshot3',
+function (t) {
+    var filename;
+
+    if (abort) {
+        t.ok(false, 'skipping writing as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    filename = path.join(vmobj.zonepath, 'root', '/tmp/hello.txt');
+
+    fs.writeFile(filename, MAGIC_STRING3, function (err) {
+        t.ok(!err, 'no error writing file to zoneroot'
+            + (err ? ' ' + err.message : ''));
+        if (err) {
+            abort = true;
+            t.end();
+        } else {
+            VM.create_snapshot(vmobj.uuid, 'snapshot3', {}, function (snaperr) {
+                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid);
+                VM.load(vmobj.uuid, function (e, o) {
+                    t.ok(!e, 'loading VM after create');
+                    if (!e) {
+                        t.ok(o.snapshots.length === 3,
+                            '3 snapshots after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                            'snapshot1 after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot2'),
+                            'snapshot2 after create');
+                        t.ok(hasSnapshot(o.snapshots, 'snapshot3'),
+                            'snapshot3 after create');
+                    } else {
+                        abort = true;
+                    }
+                    t.end();
+                });
+            });
+        }
+    });
+});
+
+test('rollback bhyve to snapshot2 and test data', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping rollback as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    var filename = path.join(vmobj.zonepath, 'root', '/tmp/hello.txt');
+
+    VM.rollback_snapshot(vmobj.uuid, 'snapshot2', {}, function (err) {
+        t.ok(!err, 'no error rolling back snapshot2 of '
+            + vmobj.uuid + (err ? ' ' + err.message : ''));
+
+        fs.readFile(filename, function (error, data) {
+            t.ok(!error, 'no error reading file from ' + filename);
+            if (error) {
+                abort = true;
+                t.end();
+                return;
+            } else {
+                t.ok(data == MAGIC_STRING2, 'string in file is MAGIC_STRING2 ['
+                    + data + ',' + MAGIC_STRING2 + ']');
+                VM.load(vmobj.uuid, function (e, o) {
+                    t.ok(!e, 'loading VM after rollback to snapshot2');
+                    if (e) {
+                        abort = true;
+                        t.end();
+                        return;
+                    }
+                    // snapshot3 should have been deleted since it's newer
+                    t.ok(o.snapshots.length === 2,
+                        '2 snapshots remain after rollback');
+                    t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                        'snapshot1 after create');
+                    t.ok(hasSnapshot(o.snapshots, 'snapshot2'),
+                        'snapshot2 after create');
+                    t.end();
+                });
+            }
+        });
+    });
+});
+
+test('rollback bhyve to snapshot1 and test data', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping rollback as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    var filename = path.join(vmobj.zonepath, 'root', '/tmp/hello.txt');
+
+    VM.rollback_snapshot(vmobj.uuid, 'snapshot1', {}, function (err) {
+        t.ok(!err, 'no error rolling back snapshot1 of ' + vmobj.uuid
+            + (err ? ' ' + err.message : ''));
+
+        fs.readFile(filename, function (error, data) {
+            t.ok(!error, 'no error reading file from ' + filename);
+            if (error) {
+                abort = true;
+                t.end();
+                return;
+            } else {
+                t.ok(data == MAGIC_STRING1, 'string in file is MAGIC_STRING1 ['
+                    + data + ',' + MAGIC_STRING1 + ']');
+                VM.load(vmobj.uuid, function (e, o) {
+                    t.ok(!e, 'loading VM after rollback to snapshot1');
+                    if (e) {
+                        abort = true;
+                        t.end();
+                        return;
+                    }
+                    // snapshot3 should have been deleted since it's newer
+                    t.ok(o.snapshots.length === 1,
+                        '1 snapshot remains after rollback');
+                    t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                        'snapshot1 after create');
+                    t.end();
+                });
+            }
+        });
+    });
+});
+
+test('delete snapshot1 from bhyve', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping deletion as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    deleteSnapshot(t, vmobj.uuid, 'snapshot1', 0, function (err) {
+        t.ok(!err, 'no error deleting snapshot1 of ' + vmobj.uuid
+            + (err ? ' ' + err.message : ''));
+        if (err) {
+            abort = true;
+        }
+        t.end();
+    });
+});
+
+test('delete bhyve VM', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping send as test run is aborted.');
+        t.end();
+        return;
+    }
+    if (vmobj.uuid) {
+        VM.delete(vmobj.uuid, function (err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + err.message);
+                abort = true;
+            } else {
+                t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            }
+            t.end();
+        });
+    } else {
+        t.ok(false, 'no VM to delete');
+        abort = true;
+        t.end();
+    }
+});
-- 
2.21.0

