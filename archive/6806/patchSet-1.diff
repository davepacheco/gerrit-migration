From 56c79d7e13b1ee163ac82cba042135336363fd6d Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Thu, 15 Aug 2019 18:54:33 +0000
Subject: [PATCH] OS-7955 CKM_AES_CBC_PAD multi-part updates w/ multiple full
 blocks incorrectly

---
 .../pkcs11_softtoken/common/softAESCrypt.c    | 61 ++++++++++++++++++-
 1 file changed, 58 insertions(+), 3 deletions(-)

diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
index 4aff7660c5..c2dc5d7b67 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
@@ -878,6 +878,7 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
     CK_ULONG ulEncryptedDataLen, CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen)
 {
 	aes_ctx_t *aes_ctx = session_p->decrypt.context;
+	uint8_t *buffer_block = NULL;
 	crypto_data_t out = {
 		.cd_format = CRYPTO_DATA_RAW,
 		.cd_offset = 0,
@@ -887,6 +888,7 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 	};
 	CK_MECHANISM_TYPE mech = session_p->decrypt.mech.mechanism;
 	CK_RV rv = CKR_OK;
+	size_t in_len = ulEncryptedDataLen;
 	size_t out_len;
 	int rc = CRYPTO_SUCCESS;
 
@@ -897,6 +899,7 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 		break;
 	case CKM_AES_CBC_PAD:
 		out_len = aes_ctx->ac_remainder_len + ulEncryptedDataLen;
+
 		/*
 		 * Since we cannot know which data is the final block
 		 * of data until C_DecryptFinal() is called, we must
@@ -906,6 +909,10 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 		 * decrypt and remove the padding.
 		 */
 		if (out_len <= AES_BLOCK_LEN) {
+			/*
+			 * If we have a full block or less, buffer it
+			 * until next time.
+			 */
 			uint8_t *dest = (uint8_t *)aes_ctx->ac_remainder +
 			    aes_ctx->ac_remainder_len;
 
@@ -913,8 +920,35 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 			aes_ctx->ac_remainder_len += ulEncryptedDataLen;
 			*pulDataLen = 0;
 			return (CKR_OK);
+		} else if (out_len > AES_BLOCK_LEN &&
+		    (out_len % AES_BLOCK_LEN == 0)) {
+			/*
+			 * If we have more than one full blocks, but nothing
+			 * left over, we defer decryping the last block
+			 * until next time (or the final call).
+			 */
+			VERIFY3U(aes_ctx->ac_remainder_len, <=, AES_BLOCK_LEN);
+			VERIFY3U(ulEncryptedDataLen, >=, AES_BLOCK_LEN);
+
+			buffer_block = pEncryptedData + ulEncryptedDataLen -
+			    AES_BLOCK_LEN;
+
+			in_len -= AES_BLOCK_LEN;
+			out_len -= AES_BLOCK_LEN;
+			out.cd_length -= AES_BLOCK_LEN;
+			out.cd_raw.iov_len -= AES_BLOCK_LEN;
+		} else {
+			/*
+			 * If we have more than one block, but have some amount
+			 * of data left over, than either there must be more
+			 * data to decrypt in a future update call (to get us
+			 * to a full block), or we have a decryption error.
+			 * Either way, we can let
+			 * cbc_decrypt_contiguous_blocks decrypt all the full
+			 * blocks that are present and buffer the remainder.
+			 */
+			out_len &= ~(AES_BLOCK_LEN - 1);
 		}
-		out_len &= ~(AES_BLOCK_LEN - 1);
 		break;
 	default:
 		out_len = aes_ctx->ac_remainder_len + ulEncryptedDataLen;
@@ -933,7 +967,7 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 	}
 
 	rc = aes_decrypt_contiguous_blocks(aes_ctx, (char *)pEncryptedData,
-	    ulEncryptedDataLen, &out);
+	    in_len, &out);
 
 	if (rc != CRYPTO_SUCCESS) {
 		rv = CKR_FUNCTION_FAILED;
@@ -942,10 +976,31 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 
 	*pulDataLen = out.cd_offset;
 
-	if ((aes_ctx->ac_flags & CTR_MODE) && (aes_ctx->ac_remainder_len > 0)) {
+	switch (mech) {
+	case CKM_AES_CTR:
+		if (aes_ctx->ac_remainder_len == 0) {
+			break;
+		}
 		rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &out,
 		    aes_encrypt_block);
 		rv = crypto2pkcs11_error_number(rc);
+		break;
+	case CKM_AES_CBC_PAD:
+		if (buffer_block == NULL) {
+			break;
+		}
+
+		VERIFY0(aes_ctx->ac_remainder_len);
+
+		/*
+		 * We had multiple blocks of data to decrypt with nothing
+		 * left over and deferred decrypting the last block of data.
+		 * Copy it into aes_ctx->ac_remainder to decrypt on the
+		 * next update call (or final).
+		 */
+		bcopy(buffer_block, aes_ctx->ac_remainder, AES_BLOCK_LEN);
+		aes_ctx->ac_remainder_len = AES_BLOCK_LEN;
+		break;
 	}
 
 done:
-- 
2.21.0

