From ff1cb7a6055238cb156c9eb6849492bf275f0a9c Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Thu, 15 Mar 2018 15:48:06 +0000
Subject: [PATCH] added bucket, producers, and consumers

---
 lib/buckets.js  |  48 ++++++++++++++++++-
 lib/common.js   |  14 +++++-
 lib/consumer.js |  48 ++++++++++++++++++-
 lib/producer.js | 124 +++++++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 229 insertions(+), 5 deletions(-)

diff --git a/lib/buckets.js b/lib/buckets.js
index 739267e..713cfe6 100644
--- a/lib/buckets.js
+++ b/lib/buckets.js
@@ -65,8 +65,7 @@ var BUCKETS = {
                 }
             },
             options: {
-                version: 0
-            }
+                version: 0 }
         }
     },
 
@@ -86,6 +85,51 @@ var BUCKETS = {
                 version: 0
             }
         }
+    },
+
+    /*
+     * Key:  vnet_id,vlan_id,subnet,r_subnet
+     */
+    vnet_routes: {
+        desc: 'local to remote vnet mapping',
+        name: 'portolan_attached_vnets',
+        schema: {
+            index: {
+                vnet_id: {
+                    type: 'number'
+                },
+                vlan_id: {
+                    type: 'number'
+                },
+                subnet: {
+                    type: 'string'
+                },
+                r_dc_id: {
+                    type: 'number'
+                },
+                r_vnet_id: {
+                    type: 'number'
+                },
+                r_vlan_id: {
+                    type: 'number'
+                },
+                r_subnet: {
+                    type: 'string'
+                },
+                r_send_mac: {
+                    type: 'number'
+                },
+                version: {
+                    type: 'number'
+                },
+                deleted: {
+                    type: 'boolean'
+                }
+            },
+            options: {
+                version: 0
+            }
+        }
     }
 };
 var NAMES = {};
diff --git a/lib/common.js b/lib/common.js
index f7e6e41..eacb953 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -28,7 +28,19 @@ function vnetMacIPkey(ip, vid) {
 }
 
 
+/*
+ * Returns a key for the vnet_routes table
+ */
+function vnetRouteKey(opts) {
+    return [
+        opts.vnet_id,
+        opts.vlan_id,
+        opts.subnet,
+        opts.r_subnet
+    ].join(',');
+}
 
 module.exports = {
-    vnetMacIPkey: vnetMacIPkey
+    vnetMacIPkey: vnetMacIPkey,
+    vnetRouteKey: vnetRouteKey
 };
diff --git a/lib/consumer.js b/lib/consumer.js
index 84695be..1ca006d 100644
--- a/lib/consumer.js
+++ b/lib/consumer.js
@@ -365,6 +365,51 @@ function logRm(opts, callback) {
     });
 }
 
+function vnetRouteLookup(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.moray, 'opts.moray');
+
+    var ip = opts.ip;
+    var vnet_id = opts.src_vnet_id;
+    var vlan_id = opts.src_vlan_id;
+
+    /*
+     * We get all local vnet & vlan remote mappings, and leave it up to
+     * protolan to check if the src and dst IP's fall into the subnet and
+     * r_subnet.
+     */
+    var filter = fmt('&(vnet_id=%d)(vlan_id=%d)', vnet_id, vlan_id, ip);
+    var searchOpts = {
+        limit: opts.limit,
+        sort: {
+            attribute: '_mtime'
+        }
+    };
+
+    var routes = [];
+
+    var req = opts.moray.findObjects(NAMES.attached_vnets, filter, searchOpts);
+
+    req.once('error', function searchError(err) {
+        opts.log.error(err, 'vnetRoute search error');
+        callback(err);
+        return; 
+    });
+
+    req.on('record', function onRecord(obj) {
+        obj.value.id = obj.key;
+        routes.push(obj.value);
+    });
+
+    req.once('end', function onEnd() {
+        // "no results" is acceptable here.
+        opts.log.debug({ routes: routes }, 'consumer.vnetRoute records');
+        return callback(null, routes);
+    });
+
+    callback();
+}
 
 module.exports = {
     underlayLookup: underlayLookup,
@@ -374,5 +419,6 @@ module.exports = {
     vl2LookupCns: vl2LookupCns,
     vl3Lookup: vl3Lookup,
     logReq: logReq,
-    logRm: logRm
+    logRm: logRm,
+    vnetRouteLookup: vnetRouteLookup
 };
diff --git a/lib/producer.js b/lib/producer.js
index f59f406..294e8b0 100644
--- a/lib/producer.js
+++ b/lib/producer.js
@@ -244,6 +244,124 @@ function removeUnderlayMapping(opts, cb) {
     client.delObject(NAMES.underlay, key, cb);
 }
 
+function vnetRouteMapRecord(opts) {
+    return {
+        key: mod_common.vnetRouteKey(opts),
+        value: {
+            vnet_id: opts.vnet_id,
+            vlan_id: opts.vlan_id,
+            subnet: opts.subnet,
+            r_dc_id: opts.r_dc_id,
+            r_vnet_id: opts.r_vnet_id,
+            r_vlan_id: opts.r_vlan_id,
+            r_subnet: opts.r_subnet,
+            r_send_mac: opts.r_send_mac,
+            version: opts.version || VERSION,
+            deleted: opts.deleted || false
+        }
+    };
+}
+
+function addVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.string(opts.vnet_id, 'opts.vnet_id');
+    assert.string(opts.vlan_id, 'opts.vlan_id');
+    assert.number(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_dc_id, 'opts.r_dc_id');
+    assert.number(opts.r_vnet_id, 'opts.r_vnet_id');
+    assert.number(opts.r_vlan_id, 'opts.r_vlan_id');
+    assert.number(opts.r_subnet, 'opts.r_subnet');
+    assert.number(opts.r_send_mac, 'opts.r_send_mac');
+    assert.optionalNumber(opts.version, 'opts.version');
+    assert.optionalBool(opts.deleted, 'opts.deleted');
+    assert.func(callback, 'callback');
+
+    var client = opts.moray;
+    var rec = vnetRouteMapRecord(opts);
+
+    client.putObject(NAMES.vnet_routes, rec.key, rec.value, function (err) {
+        if (err) {
+            return callback(err);
+        }
+
+        return callback();
+    });
+}
+
+
+function updateVnetRouteMapping(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.string(opts.vnet_id, 'opts.vnet_id');
+    assert.string(opts.vlan_id, 'opts.vlan_id');
+    assert.number(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_dc_id, 'opts.r_dc_id');
+    assert.number(opts.r_vnet_id, 'opts.r_vnet_id');
+    assert.number(opts.r_vlan_id, 'opts.r_vlan_id');
+    assert.number(opts.r_subnet, 'opts.r_subnet');
+    assert.number(opts.r_send_mac, 'opts.r_send_mac');
+    assert.optionalNumber(opts.version, 'opts.version');
+    assert.optionalBool(opts.deleted, 'opts.deleted');
+    assert.func(cb, 'callback');
+
+    var client = opts.moray;
+    var key = mod_common.vnetRouteKey(opts);
+
+    client.getObject(NAMES.vnet_routes, key, function (err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var rec_val = {
+            vnet_id: opts.vnet_id,
+            vlan_id: opts.vlan_id,
+            subnet: opts.subnet, 
+            r_dc_id: opts.r_dc_id || obj.r_dc_id,
+            r_vnet_id: opts.r_vnet_id || obj.r_vnet_id,
+            r_vlan_id: opts.r_vlan_id || obj.r_vlan_id,
+            r_subnet: opts.r_subnet,
+            r_send_mac: opts.r_send_mac || obj.r_send_mac,
+            version: opts.version || obj.version || VERSION,
+            deleted: opts.deleted || obj.deleted ||false
+        };
+
+        // rui: ???
+        var putOpts = {
+            etag: obj._etag
+        };
+
+        client.putObject(NAMES.vnet_routes, key, rec_val, putOpts,
+            function (err2) {
+
+            if (err2) {
+               cb(err2);
+               return;
+            }
+            
+            cb(null, rec_val);
+            return;
+        });
+    });
+}
+
+
+// removeVnetRouteMapping
+function removeVnetRouteMapping(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.vlan_id, 'opts.vlan_id');
+    assert.number(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_subnet, 'opts.r_subnet');
+
+    var client = opts.moray;
+    var key = mod_common.vnetRouteKey(opts);
+
+    client.delObject(NAMES.vnet_routes, key, cb);
+}
+
 /*
  * Produces a moray-batchable set of SVP VL2 logs, indicating that a shootdown
  * is required. These are required when an IP:MAC mapping is deleted (which
@@ -339,5 +457,9 @@ module.exports = {
     removeUnderlayMapping: removeUnderlayMapping,
 
     vl2CnEventBatch: vl2CnEventBatch,
-    vl3CnEventBatch: vl3CnEventBatch
+    vl3CnEventBatch: vl3CnEventBatch,
+
+    addVnetRouteMapping: addVnetRouteMapping,
+    updateVnetRouteMapping: updateVnetRouteMapping,
+    removeVnetRouteMapping: removeVnetRouteMapping
 };
-- 
2.21.0

