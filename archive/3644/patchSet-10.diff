From ab709b523c2f3a23e5f1503acba3fd61bd1c30ee Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Thu, 15 Mar 2018 15:48:06 +0000
Subject: [PATCH] added bucket, producers, and consumers minor fixups fixed up
 some asserts added vnetRouteEventBatch

---
 lib/buckets.js  |  48 ++++++++++++-
 lib/common.js   |  14 +++-
 lib/consumer.js |  49 ++++++++++++-
 lib/producer.js | 182 +++++++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 288 insertions(+), 5 deletions(-)

diff --git a/lib/buckets.js b/lib/buckets.js
index 739267e..06d6286 100644
--- a/lib/buckets.js
+++ b/lib/buckets.js
@@ -65,8 +65,7 @@ var BUCKETS = {
                 }
             },
             options: {
-                version: 0
-            }
+                version: 0 }
         }
     },
 
@@ -86,6 +85,51 @@ var BUCKETS = {
                 version: 0
             }
         }
+    },
+
+    /*
+     * Key:  vnet_id,vlan_id,subnet,r_subnet
+     */
+    vnet_routes: {
+        desc: 'local to remote vnet mapping',
+        name: 'portolan_vnet_routes',
+        schema: {
+            index: {
+                vnet_id: {
+                    type: 'number'
+                },
+                vlan_id: {
+                    type: 'number'
+                },
+                subnet: {
+                    type: 'string'
+                },
+                r_dc_id: {
+                    type: 'number'
+                },
+                r_vnet_id: {
+                    type: 'number'
+                },
+                r_vlan_id: {
+                    type: 'number'
+                },
+                r_subnet: {
+                    type: 'string'
+                },
+                r_send_mac: {
+                    type: 'number'
+                },
+                version: {
+                    type: 'number'
+                },
+                deleted: {
+                    type: 'boolean'
+                }
+            },
+            options: {
+                version: 0
+            }
+        }
     }
 };
 var NAMES = {};
diff --git a/lib/common.js b/lib/common.js
index f7e6e41..eacb953 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -28,7 +28,19 @@ function vnetMacIPkey(ip, vid) {
 }
 
 
+/*
+ * Returns a key for the vnet_routes table
+ */
+function vnetRouteKey(opts) {
+    return [
+        opts.vnet_id,
+        opts.vlan_id,
+        opts.subnet,
+        opts.r_subnet
+    ].join(',');
+}
 
 module.exports = {
-    vnetMacIPkey: vnetMacIPkey
+    vnetMacIPkey: vnetMacIPkey,
+    vnetRouteKey: vnetRouteKey
 };
diff --git a/lib/consumer.js b/lib/consumer.js
index 84695be..ba6677b 100644
--- a/lib/consumer.js
+++ b/lib/consumer.js
@@ -365,6 +365,52 @@ function logRm(opts, callback) {
     });
 }
 
+function vnetRouteLookup(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.moray, 'opts.moray');
+    assert.number(opts.src_vnet_id, 'opts.src_vnet_id');
+    assert.number(opts.src_vlan_id, 'opts.src_vlan_id');
+
+    var vnet_id = opts.src_vnet_id;
+    var vlan_id = opts.src_vlan_id;
+
+    /*
+     * We get all local vnet & vlan remote mappings, and leave it up to
+     * protolan to check if the src and dst IP's fall into the subnet and
+     * r_subnet.
+     */
+    var filter = fmt('&(vnet_id=%d)(vlan_id=%d)', vnet_id, vlan_id);
+    var searchOpts = {
+        limit: opts.limit,
+        sort: {
+            attribute: '_mtime'
+        }
+    };
+
+    var routes = [];
+
+    var req = opts.moray.findObjects(NAMES.vnet_routes, filter, searchOpts);
+
+    req.once('error', function searchError(err) {
+        opts.log.error(err, 'vnetRoute search error');
+        callback(err);
+        return;
+    });
+
+    req.on('record', function onRecord(obj) {
+        if (obj.value.deleted) {
+            return;
+        }
+        routes.push(obj.value);
+    });
+
+    req.once('end', function onEnd() {
+        // XXX What to do on no results?
+        opts.log.debug({ routes: routes }, 'consumer.vnetRoute records');
+        return callback(null, routes);
+    });
+}
 
 module.exports = {
     underlayLookup: underlayLookup,
@@ -374,5 +420,6 @@ module.exports = {
     vl2LookupCns: vl2LookupCns,
     vl3Lookup: vl3Lookup,
     logReq: logReq,
-    logRm: logRm
+    logRm: logRm,
+    vnetRouteLookup: vnetRouteLookup
 };
diff --git a/lib/producer.js b/lib/producer.js
index f59f406..c8985c5 100644
--- a/lib/producer.js
+++ b/lib/producer.js
@@ -48,6 +48,23 @@ function overlayMapRecord(opts) {
     };
 }
 
+function vnetRouteMapRecord(opts) {
+    return {
+        key: mod_common.vnetRouteKey(opts),
+        value: {
+            vnet_id: opts.vnet_id,
+            vlan_id: opts.vlan_id,
+            subnet: opts.subnet,
+            r_dc_id: opts.r_dc_id,
+            r_vnet_id: opts.r_vnet_id,
+            r_vlan_id: opts.r_vlan_id,
+            r_subnet: opts.r_subnet,
+            r_send_mac: opts.r_send_mac,
+            version: opts.version || VERSION,
+            deleted: opts.deleted || false
+        }
+    };
+}
 
 
 // --- Exports
@@ -244,6 +261,107 @@ function removeUnderlayMapping(opts, cb) {
     client.delObject(NAMES.underlay, key, cb);
 }
 
+function addVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.vlan_id, 'opts.vlan_id');
+    assert.string(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_dc_id, 'opts.r_dc_id');
+    assert.number(opts.r_vnet_id, 'opts.r_vnet_id');
+    assert.number(opts.r_vlan_id, 'opts.r_vlan_id');
+    assert.string(opts.r_subnet, 'opts.r_subnet');
+    assert.number(opts.r_send_mac, 'opts.r_send_mac');
+    assert.optionalNumber(opts.version, 'opts.version');
+    assert.optionalBool(opts.deleted, 'opts.deleted');
+    assert.func(callback, 'callback');
+
+    var client = opts.moray;
+    var rec = vnetRouteMapRecord(opts);
+
+    client.putObject(NAMES.vnet_routes, rec.key, rec.value, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback();
+        return;
+    });
+}
+
+
+function updateVnetRouteMapping(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.vlan_id, 'opts.vlan_id');
+    assert.string(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_dc_id, 'opts.r_dc_id');
+    assert.number(opts.r_vnet_id, 'opts.r_vnet_id');
+    assert.number(opts.r_vlan_id, 'opts.r_vlan_id');
+    assert.string(opts.r_subnet, 'opts.r_subnet');
+    assert.number(opts.r_send_mac, 'opts.r_send_mac');
+    assert.optionalNumber(opts.version, 'opts.version');
+    assert.optionalBool(opts.deleted, 'opts.deleted');
+    assert.func(cb, 'callback');
+
+    var client = opts.moray;
+    var key = mod_common.vnetRouteKey(opts);
+
+    client.getObject(NAMES.vnet_routes, key, function (err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var rec_val = {
+            vnet_id: opts.vnet_id,
+            vlan_id: opts.vlan_id,
+            subnet: opts.subnet,
+            r_dc_id: opts.r_dc_id || obj.r_dc_id,
+            r_vnet_id: opts.r_vnet_id || obj.r_vnet_id,
+            r_vlan_id: opts.r_vlan_id || obj.r_vlan_id,
+            r_subnet: opts.r_subnet,
+            r_send_mac: opts.r_send_mac || obj.r_send_mac,
+            version: opts.version || obj.version || VERSION,
+            deleted: opts.deleted || obj.deleted || false
+        };
+
+        // rui: ???
+        var putOpts = {
+            etag: obj._etag
+        };
+
+        client.putObject(NAMES.vnet_routes, key, rec_val, putOpts,
+            function (err2) {
+
+            if (err2) {
+               cb(err2);
+               return;
+            }
+
+            cb(null, rec_val);
+            return;
+        });
+    });
+}
+
+
+// removeVnetRouteMapping
+function removeVnetRouteMapping(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.moray, 'opts.moray');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.vlan_id, 'opts.vlan_id');
+    assert.number(opts.subnet, 'opts.subnet');
+    assert.number(opts.r_subnet, 'opts.r_subnet');
+
+    var client = opts.moray;
+    var key = mod_common.vnetRouteKey(opts);
+
+    client.delObject(NAMES.vnet_routes, key, cb);
+}
+
 /*
  * Produces a moray-batchable set of SVP VL2 logs, indicating that a shootdown
  * is required. These are required when an IP:MAC mapping is deleted (which
@@ -326,6 +444,63 @@ function vl3CnEventBatch(opts) {
     return batch;
 }
 
+/*
+ * Produce a moray-batchable set of SVP ROUTE logs, indicating that a an
+ * overlay mapping needs to be updated or removed.  This is triggered when a
+ * network's attached networks array has been updated.
+ */
+/*
+ * XXX:
+ * Do we really need to batch this?
+ * Are the batches going to be "indexed" by CN uuid like the others?
+ */
+function vnetRouteEventBatch(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.vnetCns, 'opts.vnetCns');
+    assert.number(opts.src_vnet_id, 'opts.src_vnet_id');
+    assert.number(opts.dst_vnet_id, 'opts.dst_vnet_id');
+    assert.number(opts.dcid, 'opts.dcid');
+    assert.string(opts.srcip, 'opts.srcip');
+    assert.string(opts.dstip, 'opts.dstip');
+    assert.number(opts.src_vlan_id, 'opts.src_vlan_id');
+    assert.number(opts.dst_vlan_id, 'opts.src_vlan_id');
+    assert.number(opts.src_prefixlen, 'opts.src_prefixlen');
+    assert.number(opts.dst_prefixlen, 'opts.dst_prefixlen');
+    assert.optionalNumber(opts.version, 'opts.version');
+
+    var batch = [];
+    batch = opts.vnetCns.map(function (cn) {
+        var uuid = mod_uuid.v4();
+        return {
+            bucket: NAMES.net_events,
+            key: uuid,
+            operation: 'put',
+            options: {
+                etag: null
+            },
+            value: {
+                cn_uuid: cn,
+                vnet_id: opts.src_vnet_id,
+                version: opts.version || VERSION,
+                record: {
+                    type: 'SVP_LOG_ROUTE',
+                    src_vnet_id: opts.src_vnet_id,
+                    dst_vnet_id: opts.dst_vnet_id,
+                    dcid: opts.dcid,
+                    srcip: opts.srcip,
+                    dstip: opts.dstip,
+                    src_vlan_id: opts.src_vlan_id,
+                    dst_vlan_id: opts.dst_vlan_id,
+                    src_prefixlen: opts.src_prefixlen,
+                    dst_prefixlen: opts.dst_prefixlen
+                }
+            }
+        };
+    });
+
+    return batch;
+}
+
 module.exports = {
     addOverlayMapping: addOverlayMapping,
     overlayMappingBatch: overlayMappingBatch,
@@ -339,5 +514,10 @@ module.exports = {
     removeUnderlayMapping: removeUnderlayMapping,
 
     vl2CnEventBatch: vl2CnEventBatch,
-    vl3CnEventBatch: vl3CnEventBatch
+    vl3CnEventBatch: vl3CnEventBatch,
+    vnetRouteEventBatch: vnetRouteEventBatch,
+
+    addVnetRouteMapping: addVnetRouteMapping,
+    updateVnetRouteMapping: updateVnetRouteMapping,
+    removeVnetRouteMapping: removeVnetRouteMapping
 };
-- 
2.21.0

