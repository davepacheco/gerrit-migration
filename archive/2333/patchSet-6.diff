commit d84f0a67648114ea9a42b00be7d874bb4474fc90 (refs/changes/33/2333/6)
Author: Tim Kordas <tim.kordas@joyent.com>
Date:   2017-08-24T10:25:43-07:00 (2 years, 1 month ago)
    
    joyent/node-checker#38 http checker never reads responses, resulting in leaks and failed checks
    Reviewed by: Dave Pacheco <dap@joyent.com>

diff --git a/lib/checkers/http_checker.js b/lib/checkers/http_checker.js
index c34c82d..f14995c 100644
--- a/lib/checkers/http_checker.js
+++ b/lib/checkers/http_checker.js
@@ -60,8 +60,19 @@ HttpChecker.prototype.check = function (cb) {
                         error = new Error('status code is >= 300');
                         error.code = res.statusCode;
                 }
-                cb(error, {
-                        'httpStatusCode': res.statusCode
+                /*
+                 * There is an unfortunate side-effect here: without the
+                 * data listener, no data is consumed from the connection,
+                 * and the end-listener will never be called. The unconsumed
+                 * data is leaked, and the underlying TCP socket is left in
+                 * CLOSE_WAIT. So we add an "empty" data-listener: it consumes
+                 * inbound response-data, preventing the leak.
+                 */
+                res.on('data', function (d) { /* consume */});
+                res.on('end', function () {
+                       cb(error, {
+                               'httpStatusCode': res.statusCode
+                       });
                 });
         });
         req.once('error', function (err) {
diff --git a/test/http_checker.test.js b/test/http_checker.test.js
new file mode 100644
index 0000000..7b74a67
--- /dev/null
+++ b/test/http_checker.test.js
@@ -0,0 +1,100 @@
+// Copyright (c) 2017, Joyent, Inc. All rights reserved.
+
+var bunyan = require('bunyan');
+var helper = require('./helper.js');
+var http = require('http');
+var checker = require('../lib');
+var HttpChecker = require('../lib/checkers/http_checker');
+var nodeunit = require('nodeunit');
+
+var test = helper.test;
+
+var server = http.createServer(function (req, res) {
+        if (req.url === '/path/to/probe') {
+                res.writeHead(200, {'Content-type':'text/plain'});
+                res.end('still alive\n');
+        } else if (req.url === '/path/to/size') {
+                res.writeHead(200, {'Content-type':'text/plain'});
+                res.end(new Buffer(Array(16*1024*1024)).toString('base64'));
+        } else if (req.url === '/path/to/slowness') {
+                setTimeout(function () {
+                        res.writeHead(200, {'Content-type':'text/plain'});
+                        res.end('still alive\n');
+                }, 5000);
+        } else {
+                res.writeHead(404, {'Content-type':'text/plain'});
+                res.end('not found\n');
+        }
+});
+
+helper.before(function(cb) {
+        server.listen(0);
+        cb();
+});
+
+helper.after(function(cb) {
+        server.close();
+        cb();
+});
+
+var opts = {};
+opts.config = {};
+opts.config.ip = '127.0.0.1';
+opts.config.secure = false;
+
+var LOG = bunyan.createLogger({
+        level: (process.env.LOG_LEVEL || 'debug'),
+        name: 'checker',
+        stream: process.stdout
+});
+opts.log = LOG;
+
+test('valid path', function(t) {
+        opts.config.port = server.address().port;
+        opts.config.path = '/path/to/probe';
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(200, status.httpStatusCode);
+                t.done();
+        });
+});
+
+test('invalid path', function(t) {
+        opts.config.port = server.address().port;
+        opts.config.path = '/missingpath/to/probe';
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(404, status.httpStatusCode);
+                t.done();
+        });
+});
+
+
+test('timeout path', function(t) {
+        opts.config.port = server.address().port;
+        opts.config.path = '/path/to/slowness';
+        opts.config.timeout = 1000;
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(error.code, 'Timeout');
+                t.done();
+        });
+});
+
+test('large response path', function(t) {
+        opts.config.port = server.address().port;
+        opts.config.path = '/path/to/size';
+        opts.config.timeout = 5000;
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                // after a short amount of time, we should have zero connections
+                setTimeout(function () {
+                        t.equal(server._connections, 0);
+                        t.done();
+                }, 1000);
+        });
+});
