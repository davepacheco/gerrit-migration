commit c548bfb6ea2d3152b91936e4831312644c7e28fe (refs/changes/33/2333/12)
Author: Tim Kordas <tim.kordas@joyent.com>
Date:   2017-09-05T13:33:18-07:00 (2 years, 1 month ago)
    
    joyent/node-checker#38 http checker never reads responses, resulting in leaks and failed checks
    Reviewed by: Dave Pacheco <dap@joyent.com>

diff --git a/lib/checkers/http_checker.js b/lib/checkers/http_checker.js
index c34c82d..3f0c74e 100644
--- a/lib/checkers/http_checker.js
+++ b/lib/checkers/http_checker.js
@@ -60,8 +60,21 @@ HttpChecker.prototype.check = function (cb) {
                         error = new Error('status code is >= 300');
                         error.code = res.statusCode;
                 }
-                cb(error, {
-                        'httpStatusCode': res.statusCode
+                /*
+                 * There is an unfortunate side-effect here: without the
+                 * data listener, no data is consumed from the connection,
+                 * and the end-listener will never be called. The unconsumed
+                 * data is leaked, and the underlying TCP socket is left in
+                 * CLOSE_WAIT. So we add an "empty" data-listener: it consumes
+                 * inbound response-data, preventing the leak.
+                 */
+                res.on('data', function (d) { /* consume */});
+
+                res.on('end', function () {
+                        cb(error, {
+                                'httpStatusCode': res.statusCode,
+                                'httpResponseLength' : res.socket.bytesRead
+                        });
                 });
         });
         req.once('error', function (err) {
diff --git a/lib/health_checker.js b/lib/health_checker.js
index 22c4335..706b165 100644
--- a/lib/health_checker.js
+++ b/lib/health_checker.js
@@ -152,7 +152,6 @@ function performHealthCheck(check) {
                 checkResultsCalled = true;
         }
 
-        check.check(onCheckResults);
         //Check timeout...
         checkTimeoutId = setTimeout(function () {
                 checkTimeout = true;
@@ -164,6 +163,7 @@ function performHealthCheck(check) {
                 error.code = 'CheckTimeout';
                 onCheckResults(error);
         }, CHECK_TIMEOUT);
+        check.check(onCheckResults);
 }
 
 
diff --git a/test/health_checker.test.js b/test/health_checker.test.js
index 50bbd5c..ac87ddf 100644
--- a/test/health_checker.test.js
+++ b/test/health_checker.test.js
@@ -1,21 +1,18 @@
-// Copyright (c) 2013, Joyent, Inc. All rights reserved.
+// Copyright (c) 2017, Joyent, Inc. All rights reserved.
+
+/*
+ * A very simple health-check test. We implement a "null" healthcheck,
+ * configure a pair of them, and then let them go. We wait 11 seconds
+ * and verify that we have two check and that they ran.
+ *
+ */
 
 var bunyan = require('bunyan');
 var helper = require('./helper.js');
 var HealthChecker = require('../lib/health_checker');
-var vasync = require('vasync');
-
-
-
-///--- Globals
-
-//TODO: Make this an actual test...
-//var test = helper.test;
-
-
+var test = helper.test;
 
 ///--- Objects
-
 function TestChecker(opts) {
         var self = this;
         self.opts = opts;
@@ -37,15 +34,15 @@ TestChecker.prototype.label = function label() {
 ///--- Tests
 
 var testCfg = {
-        //Processes are monitored a certain way.  In this case, the "test"
+        // Processes are monitored a certain way.  In this case, the "test"
         // process has its health checked by the "test checker".  The process
         // type is what links this to processes in the hostDescription.
-        //Checkers have to be registered in code.
+        // Checkers have to be registered in code.
         'processTypes': [
                 { 'processType': 'test',
                   'checkerType': 'testChecker' }
         ],
-        //Hosts have many processes.  The processes have types, which are
+        // Hosts have many processes.  The processes have types, which are
         // described in the processDescription.  The host type is used to
         // link the description with a physical host...
         'hostTypes': [ {
@@ -74,33 +71,27 @@ var LOG = bunyan.createLogger({
 });
 
 var hc = new HealthChecker({ log: LOG });
-vasync.pipeline({
-        'funcs': [
-                function initHc(_, subcb) {
-                        hc.registerChecker({
-                                'label': 'testChecker',
-                                'checker': TestChecker
-                        }, function (err) {
-                                subcb(err);
-                        });
-                },
-                function registerConfig(_, subcb) {
-                        hc.registerFromConfig(testCfg, subcb);
-                },
-                function start(_, subcb) {
-                        hc.start(subcb);
-                },
-                function pause(_, subcb) {
-                        setTimeout(subcb, 11000);
-                },
-                function stop(_, subcb) {
-                        LOG.info({ stats: hc.getStats() }, 'final stats');
-                        hc.stop(subcb);
-                }
-        ]
-}, function (err) {
-        if (err) {
-                LOG.error(err);
-                process.exit(1);
-        }
+
+helper.before(function (cb) {
+        var configAndStart = function() {
+                hc.registerFromConfig(testCfg,
+                                      function () { hc.start(cb) });
+        };
+        hc.registerChecker({
+                'label': 'testChecker',
+                'checker': TestChecker }, configAndStart);
+
+});
+
+helper.after(function(cb) {
+        hc.stop(cb);
+});
+
+test('the checks we configure execute and count up', function(t) {
+        setTimeout(function () {
+                t.equal(hc.checks.length, 2);
+                t.ok(hc.checks[0].numChecks > 0);
+                t.ok(hc.checks[1].numChecks > 0);
+                t.done();
+        }, 11000);
 });
diff --git a/test/http_checker.test.js b/test/http_checker.test.js
new file mode 100644
index 0000000..38f4189
--- /dev/null
+++ b/test/http_checker.test.js
@@ -0,0 +1,139 @@
+// Copyright (c) 2017, Joyent, Inc. All rights reserved.
+
+/*
+ * Simple test of the http-checker.
+ *
+ * This test starts up a server, then verifies that the checker
+ * generates the expected output based on some statically-configured
+ * URLs. The goal is to exercise each case in http-checker (e.g. when
+ * the server takes a long time to respond, the checker should
+ * generate a timeout).
+ */
+
+var bunyan = require('bunyan');
+var helper = require('./helper.js');
+var http = require('http');
+var checker = require('../lib');
+var HttpChecker = require('../lib/checkers/http_checker');
+var nodeunit = require('nodeunit');
+
+var test = helper.test;
+var bigResponse = new Buffer(Array(16*1024*1024)).toString('base64');
+var server = http.createServer(function (req, res) {
+        if (req.url === '/path/to/probe') {
+                res.writeHead(200, {'Content-type':'text/plain'});
+                res.end('still alive\n');
+        } else if (req.url === '/path/to/size') {
+                res.writeHead(200, {'Content-type':'text/plain'});
+                res.end(bigResponse);
+        } else if (req.url === '/path/to/slowness') {
+                /*
+                 * The value 5000ms is arbitrary. It just needs to be
+                 * longer than the timeout used for the timeout-path
+                 * test below.
+                 */
+                setTimeout(function () {
+                        res.writeHead(200, {'Content-type':'text/plain'});
+                        res.end('still alive after all this time\n');
+                }, 5000);
+        } else {
+                res.writeHead(404, {'Content-type':'text/plain'});
+                res.end('not found\n');
+        }
+});
+
+helper.before(function(cb) {
+        server.listen(0, '127.0.0.1', cb);
+});
+
+helper.after(function(cb) {
+        server.close(cb);
+});
+
+
+
+var logger = bunyan.createLogger({
+        level: (process.env.LOG_LEVEL || 'debug'),
+        name: 'checker',
+        stream: process.stdout
+});
+
+function getCheckerOpts() {
+        var opts = {};
+        opts.config = {};
+        opts.config.ip = '127.0.0.1';
+        opts.config.secure = false;
+        opts.log = logger;
+
+        opts.config.port = server.address().port;
+
+        return (opts);
+}
+
+test('valid path', function(t) {
+        var opts = getCheckerOpts();
+        opts.config.path = '/path/to/probe';
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(200, status.httpStatusCode);
+                t.done();
+        });
+});
+
+test('invalid path', function(t) {
+        var opts = getCheckerOpts();
+        opts.config.path = '/missingpath/to/probe';
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(404, status.httpStatusCode);
+                t.done();
+        });
+});
+
+
+test('timeout path', function(t) {
+        var opts = getCheckerOpts();
+        opts.config.path = '/path/to/slowness';
+
+        /*
+         * The timeout value is arbitrary, but needs to be shorter than the
+         * "/path/to/slowness" time used by the server (ie we're testing that
+         * timeouts occur, and return the appropriate error-code.)
+         */
+        opts.config.timeout = 1000;
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                t.equal(error.code, 'Timeout');
+                t.done();
+        });
+});
+
+test('large response path', function(t) {
+        var opts = getCheckerOpts();
+        opts.config.path = '/path/to/size';
+
+        /*
+         * Save the server-side reference to the connection, so that
+         * we can validate that it had its data consumed properly.
+         */
+        var serverSide = null;
+        server.on('connection', function (c) {serverSide = c;});
+
+        httpchecker = new HttpChecker(opts);
+        httpchecker.check(function (error, status) {
+                /*
+                 * Verify that the checker got the right status code
+                 * and consumed the entire response (server and client
+                 * agree on the bytes-transferred, and both transferred
+                 * the body of the response, plus some extra for
+                 * headers.)
+                 */
+                t.equal(200, status.httpStatusCode);
+                t.equal(status.httpResponseLength, serverSide.bytesWritten);
+                t.ok(status.httpResponseLength > bigResponse.length);
+                t.done();
+        });
+});
