From 9b465033ef13126ed8e04390d9d71f529a5c8f36 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Tue, 28 Feb 2017 16:51:01 +0000
Subject: [PATCH] OS-5987 zone stuck in shutdown during clustrix install

---
 usr/src/uts/common/brand/lx/syscall/lx_aio.c | 25 ++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_aio.c b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
index f47bf399e6..02a81e7333 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_aio.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
@@ -71,6 +71,20 @@
  * we hit the maximum at lx_aio_max_workers. See the code in io_setup for more
  * information.
  *
+ * Because the worker threads never leave the kernel, they are marked with the
+ * TP_KTHREAD bit so that /proc operations essentially ignore the thread. We
+ * also tag the brand lwp flags with the BR_AIO_LWP bit so that these threads
+ * never appear in the lx /proc. Aside from servicing aio submissions, the
+ * worker threads don't participate in most application-initiated operations,
+ * but forking is a special case. The Linux fork(2) and vfork(2) behavior
+ * always forks only a single thread; the caller. However, during cfork()
+ * the system attempts to quiesce all threads by calling holdlwps(). Because
+ * our worker threads are always in the kernel, spend most of their lives
+ * blocked while waiting for work, and will not participate in the fork(),
+ * we remove them from the p_lwprcnt counter on startup so that holdlwps()
+ * doesn't block on these threads. When these threads are exiting, we add them
+ * to p_lwprcnt so that they interact properly with the rest of the system.
+ *
  * It is hard to make any generalized statements about how the aio syscalls
  * are used in production. MySQL is one of the more popular consumers of aio
  * and in the default configuration it will create 10 contexts with a capacity
@@ -413,6 +427,16 @@ lx_io_worker(void *a)
 
 	set_active_fd(-1);	/* See comment in lx_io_cp_rele */
 
+	/*
+	 * Since this thread is already (always) in the kernel and spends most
+	 * of its life stopped while waiting for work, decrement p_lwprcnt so
+	 * that this process can fork if necessary. See the big theory comment
+	 * for more details.
+	 */
+	mutex_enter(&curproc->p_lock);
+	curproc->p_lwprcnt--;
+	mutex_exit(&curproc->p_lock);
+
 	while (!cp->lxioctx_shutdown) {
 		mutex_enter(&cp->lxioctx_p_lock);
 		if (list_is_empty(&cp->lxioctx_pending)) {
@@ -489,6 +513,7 @@ lx_io_worker(void *a)
 
 	ASSERT(curthread->t_lwp != NULL);
 	mutex_enter(&curproc->p_lock);
+	curproc->p_lwprcnt++;
 	lwp_exit();
 }
 
-- 
2.21.0

