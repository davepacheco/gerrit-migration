From 55835f4eda14d30f324a9cc73181bb562b003764 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Tue, 28 Feb 2017 20:05:04 +0000
Subject: [PATCH] OS-5987 zone stuck in shutdown during clustrix install

---
 usr/src/uts/common/brand/lx/syscall/lx_aio.c | 47 +++++++++++++++++++-
 1 file changed, 46 insertions(+), 1 deletion(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_aio.c b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
index f47bf399e6..2ae034126d 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_aio.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
@@ -71,6 +71,17 @@
  * we hit the maximum at lx_aio_max_workers. See the code in io_setup for more
  * information.
  *
+ * Because the worker threads never leave the kernel, they are marked with the
+ * TP_KTHREAD bit so that /proc operations essentially ignore the thread. We
+ * also tag the brand lwp flags with the BR_AIO_LWP bit so that these threads
+ * never appear in the lx /proc. Aside from servicing aio submissions, the
+ * worker threads don't participate in most application-initiated operations,
+ * but forking is a special case. The Linux fork(2) and vfork(2) behavior
+ * always forks only a single thread; the caller. However, during cfork()
+ * the system attempts to quiesce all threads by calling holdlwps(). The
+ * worker threads check for SHOLDFORK and SHOLDFORK1 in their loops and
+ * suspend themselves ala holdlwp() if the process forks.
+ *
  * It is hard to make any generalized statements about how the aio syscalls
  * are used in production. MySQL is one of the more popular consumers of aio
  * and in the default configuration it will create 10 contexts with a capacity
@@ -101,6 +112,7 @@
 #include <sys/brand.h>
 #include <sys/sysmacros.h>
 #include <sys/sdt.h>
+#include <sys/procfs.h>
 
 #include <sys/lx_brand.h>
 #include <sys/lx_syscalls.h>
@@ -410,13 +422,22 @@ lx_io_worker(void *a)
 {
 	lx_io_ctx_t *cp = (lx_io_ctx_t *)a;
 	lx_io_elem_t *ep;
+	k_sigset_t hold_set;
+
+	sigfillset(&hold_set);
+	mutex_enter(&curproc->p_lock);
+	curthread->t_hold = hold_set;
+	mutex_exit(&curproc->p_lock);
 
 	set_active_fd(-1);	/* See comment in lx_io_cp_rele */
 
 	while (!cp->lxioctx_shutdown) {
 		mutex_enter(&cp->lxioctx_p_lock);
 		if (list_is_empty(&cp->lxioctx_pending)) {
-			cv_wait(&cp->lxioctx_pending_cv, &cp->lxioctx_p_lock);
+
+			cv_wait_sig(&cp->lxioctx_pending_cv,
+			    &cp->lxioctx_p_lock);
+
 			if (cp->lxioctx_shutdown) {
 				mutex_exit(&cp->lxioctx_p_lock);
 				break;
@@ -426,6 +447,18 @@ lx_io_worker(void *a)
 		ep = list_remove_head(&cp->lxioctx_pending);
 		mutex_exit(&cp->lxioctx_p_lock);
 
+		/*
+		 * If forking we need to do the equivalent of holdlwp().
+		 * Perform initial check outside of p_lock to avoid it getting
+		 * too hot.
+		 */
+		if (curproc->p_flag & (SHOLDFORK | SHOLDFORK1)) {
+			mutex_enter(&curproc->p_lock);
+			if (curproc->p_flag & (SHOLDFORK | SHOLDFORK1))
+				stop(PR_SUSPENDED, SUSPEND_NORMAL);
+			mutex_exit(&curproc->p_lock);
+		}
+
 		while (ep != NULL) {
 			boolean_t do_resfd;
 			int resfd = 0;
@@ -479,6 +512,18 @@ lx_io_worker(void *a)
 			if (cp->lxioctx_shutdown)
 				break;
 
+			/*
+			 * If forking do the equivalent of holdlwp(). Perform
+			 * initial check outside of p_lock to avoid it getting
+			 * too hot.
+			 */
+			if (curproc->p_flag & (SHOLDFORK | SHOLDFORK1)) {
+				mutex_enter(&curproc->p_lock);
+				if (curproc->p_flag & (SHOLDFORK | SHOLDFORK1))
+					stop(PR_SUSPENDED, SUSPEND_NORMAL);
+				mutex_exit(&curproc->p_lock);
+			}
+
 			mutex_enter(&cp->lxioctx_p_lock);
 			ep = list_remove_head(&cp->lxioctx_pending);
 			mutex_exit(&cp->lxioctx_p_lock);
-- 
2.21.0

