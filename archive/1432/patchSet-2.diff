commit cf04b59159e000ecd0f89af935548e2d6c72cb0b (refs/changes/32/1432/2)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2017-02-04T00:46:34+00:00 (2 years, 8 months ago)
    
    TOOLS-1670 Need common validation module

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..cad79a6
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,58 @@
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile: top-level Makefile
+#
+# This Makefile contains only repo-specific logic and uses included makefiles
+# to supply common targets (javascriptlint, jsstyle, restdown, etc.), which are
+# used by other repos as well.
+#
+
+#
+# Tools must be installed on the path
+#
+NPM		:= npm
+
+#
+# Files
+#
+JS_FILES	:= $(shell find lib tests -name '*.js' -not -name compat.js)
+JSL_FILES_NODE  := $(JS_FILES)
+JSSTYLE_FILES	:= $(JS_FILES)
+JSSTYLE_FLAGS	:= -f tools/jsstyle.conf
+JSL_CONF_NODE	:= tools/jsl.node.conf
+ISTANBUL 	:= node_modules/.bin/istanbul
+FAUCET	 	:= node_modules/.bin/faucet
+ESLINT		 = ./node_modules/.bin/eslint
+ESLINT_CONF	 = tools/eslint.node.conf
+ESLINT_FILES	 = $(JS_FILES)
+
+include ./tools/mk/Makefile.defs
+
+$(ESLINT):
+	$(NPM) install
+
+$(ISTANBUL):
+	$(NPM) install
+
+$(FAUCET):
+	$(NPM) install
+
+all: $(JSL_EXEC) $(JSSTYLE_EXEC)
+	$(NPM) install
+
+.PHONY: check
+check:: $(ESLINT)
+	$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
+
+test: 
+	$(ISTANBUL) cover --print none tests/run.js
+
+include ./tools/mk/Makefile.deps
+ifeq ($(shell uname -s),SunOS)
+	include ./tools/mk/Makefile.node_prebuilt.targ
+else
+	include ./tools/mk/Makefile.node.targ
+endif
+include ./tools/mk/Makefile.smf.targ
+include ./tools/mk/Makefile.targ
diff --git a/deps/javascriptlint b/deps/javascriptlint
new file mode 160000
index 0000000..ad52812
--- /dev/null
+++ b/deps/javascriptlint
@@ -0,0 +1 @@
+Subproject commit ad52812e77bdfb1e90fb71a1201adb2b665a27e6
diff --git a/deps/jsstyle b/deps/jsstyle
new file mode 160000
index 0000000..9600c7e
--- /dev/null
+++ b/deps/jsstyle
@@ -0,0 +1 @@
+Subproject commit 9600c7e56c84f3a74d6e3d70c336e86f7a3e3769
diff --git a/deps/restdown b/deps/restdown
new file mode 160000
index 0000000..1b833da
--- /dev/null
+++ b/deps/restdown
@@ -0,0 +1 @@
+Subproject commit 1b833da2199b08c3bc92ef16cf52b0b0d6e4c189
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..5d247db
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,46 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Turn a value into an array, unless it is one already.
+ */
+function arrayify(obj) {
+    if (typeof (obj) === 'object') {
+        return obj;
+    }
+
+    if (obj === '') {
+        return [];
+    }
+
+    return obj.split(',');
+}
+
+
+/*
+ * Returns true if the hash is empty
+ */
+function hashEmpty(hash) {
+    /* jsl:ignore (for unused variable warning) */
+    for (var _k in hash) {
+        return false;
+    }
+    /* jsl:end */
+
+    return true;
+}
+
+
+module.exports = {
+    arrayify: arrayify,
+    hashEmpty: hashEmpty
+};
diff --git a/lib/constants.js b/lib/constants.js
new file mode 100644
index 0000000..d2c7a63
--- /dev/null
+++ b/lib/constants.js
@@ -0,0 +1,40 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Shared constants
+ */
+
+var MESSAGES = {
+    INVALID_PARAMS: 'Invalid parameters',
+    ARRAY_OF_STR: 'must be an array of strings',
+    ARRAY_EMPTY: 'must not be an empty array',
+    STR: 'must be a string',
+    INVALID_UUID: 'invalid UUID',
+    UNKNOWN_PARAMS: 'Unknown parameters',
+    PARAMETERS_ARE_OBJECTS: 'Parameters must be objects',
+    CIDR_SUBNET: 'Subnet must be in CIDR form',
+    OFFSET: 'invalid value, offset must be an integer greater than or ' +
+        'equal to 0',
+    LIMIT: 'invalid limit, must be an integer greater than 0 or less than or ' +
+        'equal to 1000'
+};
+
+module.exports = {
+    msg: MESSAGES,
+    MAX_LIMIT: 1000,
+    MAX_STR_LEN: 64,
+    SUBNET_MIN_IPV4: 8,
+    SUBNET_MIN_IPV6: 8,
+    MIN_LIMIT: 1,
+    MIN_OFFSET: 0
+};
diff --git a/lib/errors.js b/lib/errors.js
new file mode 100644
index 0000000..06f52d5
--- /dev/null
+++ b/lib/errors.js
@@ -0,0 +1,139 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Default error classes and helpers.
+ */
+
+var assert = require('assert-plus');
+var constants = require('./constants');
+var restify = require('restify');
+var util = require('util');
+
+
+
+/*
+ * Globals
+ * =======
+ */
+
+
+
+var MSG = {
+    duplicate: 'Already exists',
+    internal: 'Internal error',
+    missingParam: 'Missing parameter',
+    missingParams: 'Missing parameters'
+};
+
+
+
+/*
+ * Error Classes
+ * =============
+ */
+
+
+
+/*
+ * Base class for invalid / missing parameters
+ */
+function InvalidParamsError(message, errors) {
+    assert.string(message, 'message');
+    assert.arrayOfObject(errors, 'errors');
+
+    restify.RestError.call(this, {
+        restCode: 'InvalidParameters',
+        statusCode: 422,
+        message: message,
+        body: {
+            code: 'InvalidParameters',
+            message: message,
+            errors: errors
+        }
+    });
+
+    this.name = 'InvalidParamsError';
+}
+
+util.inherits(InvalidParamsError, restify.RestError);
+
+
+
+/*
+ * Functions for building elements in a response's errors array
+ *
+ * Response-Errors Functions
+ * =========================
+ */
+
+
+
+/*
+ * Error response for invalid parameters
+ */
+function invalidParam(field, message) {
+    assert.string(field, 'field');
+
+    var param = {
+        field: field,
+        code: 'InvalidParameter',
+        message: message || constants.msg.INVALID_PARAMS
+    };
+
+    return param;
+}
+
+/*
+ * Error response for unknown parameters
+ */
+function unknownParams(params, message) {
+    var msg;
+
+    assert.arrayOfString(params, 'params');
+    assert.optionalString(message, 'message');
+
+    msg = message || constants.msg.UNKNOWN_PARAMS;
+    msg += ': ' + params.join(', ');
+
+    var param = {
+        field: params,
+        code: 'UnknownParameters',
+        message: msg
+    };
+
+    return param;
+}
+
+
+/*
+ * Error response for missing parameters
+ */
+function missingParam(field, message) {
+    assert.string(field, 'field');
+
+    return {
+        field: field,
+        code: 'MissingParameter',
+        message: message || MSG.missingParam
+    };
+}
+
+
+
+module.exports = {
+    invalidParam: invalidParam,
+    InvalidParamsError: InvalidParamsError,
+    missingParam: missingParam,
+    msg: MSG,
+    unknownParams: unknownParams
+};
diff --git a/lib/validate.js b/lib/validate.js
new file mode 100644
index 0000000..1f8963e
--- /dev/null
+++ b/lib/validate.js
@@ -0,0 +1,250 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Basic parameter validation engine.
+ */
+
+var errors = require('./errors');
+var constants = require('./constants');
+var validators = require('./validators');
+var assert = require('assert-plus');
+var fmt = require('util').format;
+var restify = require('restify');
+var verror = require('verror');
+var vasync = require('vasync');
+
+/*
+ * Calls callback with the appropriate error depending on the contents of errs
+ */
+function errResult(errs, validated, callback) {
+    var invalid = false;
+
+    if (errs.length !== 0) {
+        var realErrs = [];
+        var sortedErrs = errs.filter(function (e) {
+            if (!e.hasOwnProperty('field')) {
+                realErrs.push(e);
+                return false;
+            }
+            if (!invalid && e.hasOwnProperty('code') &&
+                e.code !== 'MissingParameter') {
+                invalid = true;
+            }
+
+            return true;
+        }).sort(function (a, b) { return (a.field > b.field) ? 1 : -1; });
+
+        if (realErrs.length !== 0) {
+            callback(new restify.InternalError(
+                realErrs.length === 1 ? realErrs[0] :
+                    new verror.MultiError(realErrs),
+                'Internal error'));
+            return;
+        }
+
+        callback(new errors.InvalidParamsError(
+            invalid ? constants.msg.INVALID_PARAMS : 'Missing parameters',
+            sortedErrs));
+        return;
+    }
+
+    callback(null, validated);
+}
+
+
+
+/*
+ * Exports
+ * =======
+ */
+
+
+/*
+ * Check for any uknown parameters if strict mode is engaged.
+ */
+function validateUnknowns(params, req, opt) {
+    var field;
+    var unknowns = [];
+
+    for (field in params) {
+        if (!params.hasOwnProperty(field)) {
+            continue;
+        }
+        if ((req && req.hasOwnProperty(field)) ||
+           (opt && opt.hasOwnProperty(field))) {
+            continue;
+        }
+
+        unknowns.push(field);
+    }
+
+    if (unknowns.length === 0) {
+        return null;
+    }
+
+    return new errors.unknownParams(unknowns);
+}
+
+
+/*
+ * Validate parameters on an object.
+ *
+ * @param opts {Object}: Options for validating the input object
+ * - `strict` {Boolean}: Fail if there are extra, unknown fields on the object
+ * - `required` {Object}: A map of validation functions for each required field
+ * - `optional` {Object}: A map of validation functions for each optional field
+ * @param arg {Any}: A value to pass as the first argument to each validation
+ *     function. Usually an object containing configuration information or a
+ *     database handle.
+ * @param params {Object}: Object to validate
+ * @param callback {Function}: Callback with (err, validated) where validated
+ *     is an object with only validated fields or fields added by the
+ *     validation functions.
+ */
+
+function validateParams(opts, arg, params, callback) {
+    var errs = [];
+    var field;
+    var validatedParams = {};
+
+    assert.object(opts, 'opts');
+    assert.optionalBool(opts.strict, 'opts.strict');
+    assert.optionalObject(opts.required, 'opts.required');
+    assert.optionalObject(opts.optional, 'opts.optional');
+    assert.func(callback);
+
+    if (!params || typeof (params) !== 'object' || Array.isArray(params)) {
+        errs.push(errors.invalidParam('parameters',
+            constants.msg.PARAMETERS_ARE_OBJECTS));
+        errResult(errs, validatedParams, callback);
+        return;
+    }
+
+    var toValidate = [];
+
+    if (opts.required) {
+        for (field in opts.required) {
+            assert.func(opts.required[field],
+                fmt('opts.required[%s]', field));
+
+            if (params.hasOwnProperty(field)) {
+                toValidate.push({
+                    field: field,
+                    fn: opts.required[field],
+                    val: params[field]
+                });
+            } else {
+                errs.push(errors.missingParam(field));
+            }
+        }
+    }
+
+    for (field in opts.optional) {
+        assert.func(opts.optional[field],
+            fmt('opts.optional[%s]', field));
+
+        if (params.hasOwnProperty(field)) {
+            toValidate.push({
+                field: field,
+                fn: opts.optional[field],
+                val: params[field]
+            });
+        }
+    }
+
+    vasync.forEachParallel({
+        inputs: toValidate,
+        func: function _callValidateFn(val, cb) {
+            /*
+             * TODO: allow specifying an array of validation functions, and
+             * bail after the first failure
+             */
+
+            val.fn(arg, val.field, val.val, function (e, validated, multi) {
+                if (e) {
+                    errs.push(e);
+                }
+
+                if (typeof (validated) !== 'undefined') {
+                    validatedParams[val.field] = validated;
+                }
+                if (typeof (multi) !== 'undefined' &&
+                    typeof (multi) === 'object') {
+
+                    for (var v in multi) {
+                        validatedParams[v] = multi[v];
+                    }
+                }
+
+                return cb();
+            });
+        }
+    }, function after() {
+        if (opts.strict) {
+            var err = validateUnknowns(params, opts.required,
+                opts.optional);
+            if (err !== null) {
+                errs.push(err);
+            }
+        }
+
+        if (opts.hasOwnProperty('after') && errs.length === 0) {
+            if (!Array.isArray(opts.after)) {
+                opts.after = [opts.after];
+            }
+            return crossValidate(errs, arg, params, validatedParams,
+                opts.after, callback);
+        }
+        return errResult(errs, validatedParams, callback);
+    });
+}
+
+/*
+ * Used by validate.params to call an array of 'after' functions, which have
+ * access to all the raw and validated parameters. This is typically used to
+ * validate conditions between parameters, e.g., nicTag/network MTUs.
+ */
+function crossValidate(errs, arg, raw, validated, afterFuncs, callback) {
+    vasync.forEachPipeline({
+        inputs: afterFuncs,
+        func: function _validate(func, cb) {
+            func(arg, raw, validated, function (err) {
+                if (err) {
+                    if (Array.isArray(err)) {
+                        errs = errs.concat(err);
+                    } else {
+                        errs.push(err);
+                    }
+                }
+                return cb();
+            });
+        }
+    }, function (_err, _results) {
+        return errResult(errs, validated, callback);
+    });
+}
+
+module.exports = {
+    params: validateParams,
+    fieldsArray: validators.fieldsArray,
+    IParray: validators.IParray,
+    IP: validators.IP,
+    subnet: validators.subnet,
+    subnetArray: validators.subnetArray,
+    UUID: validators.UUID,
+    isUUID: validators.isUUID,
+    UUIDarray: validators.UUIDarray,
+    isNotInteger: validators.isNotInteger,
+    offset: validators.offset,
+    limit: validators.limit
+};
diff --git a/lib/validators.js b/lib/validators.js
new file mode 100644
index 0000000..d7ae5e2
--- /dev/null
+++ b/lib/validators.js
@@ -0,0 +1,391 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http:mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+/*
+ * Some stock validators that consumers of this module may want to use. For
+ * example UUIDs, standard subnets, standard IPs, etc. But they are just as
+ * welcome to write their own (for example NAPI will want to use its own subnet
+ * validator to support its own legacy subnet formats). The validators here
+ * come in 2 variants. The first is a return-based variant that returns a
+ * boolean that indicates if the input has been validated. The second is a
+ * callback-based variant that uses the callback error object to indicate
+ * validation failure. This second variant is usually implemented in terms of
+ * the first variant.
+ *
+ * This allows users to use the first variant in code that has to validate some
+ * string, but for some reason can't do it through the validation engine (for
+ * example we may want to validate some string we fetched from Moray, but isn't
+ * passed to us an HTTP param).
+ */
+
+var errors = require('./errors');
+var util_common = require('./common');
+var constants = require('./constants');
+var assert = require('assert-plus');
+var fmt = require('util').format;
+var util = require('util');
+var net = require('net');
+var ipaddr = require('ip6addr');
+
+/*
+ * Globals
+ * =======
+ */
+
+var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
+
+/*
+ * Validates an array of (one or more) IP addresses
+ */
+function validateIParray(_, name, arr, callback) {
+    var errs = [];
+    var ips = [];
+
+    if (!util.isArray(arr) && typeof (arr) !== 'string') {
+        callback(new errors.invalidParam(name, constants.msg.STR));
+        return;
+    }
+
+    var ip_array = util_common.arrayify(arr);
+    if (ip_array.length === 0) {
+        errs.push('Empty string');
+    } else {
+        /*
+         * UFDS will return a scalar if there's only one IP. Also allow
+         * comma-separated IPs from the commandline tools
+         */
+        ip_array.forEach(function (i) {
+            var ip = i.replace(/\s+/, '');
+            var ipAddr = net.isIP(ip);
+
+            if (!ipAddr) {
+                errs.push(ip);
+            } else {
+                ips.push(ipAddr);
+            }
+        });
+    }
+
+    if (errs.length !== 0) {
+        var ipErr = errors.invalidParam(name,
+            fmt('invalid IP%s', errs.length === 1 ? '' : 's'));
+        ipErr.invalid = errs.sort();
+        callback(ipErr);
+        return;
+    }
+
+    callback(null, ips);
+}
+
+
+function _validateIP(addr) {
+    if (net.isIP(addr) !== 0) {
+        return false;
+    }
+
+    return true;
+}
+
+/*
+ * Validates only 1 IP address.
+ */
+function validateIP(_, name, addr, callback) {
+    var invalid = _validateIP(addr);
+    if (invalid) {
+        callback(errors.invalidParam(name, 'invalid IP address'));
+        return;
+    }
+    callback(null, addr);
+}
+
+
+function _validateSubnet(subnetTxt) {
+    var params = {};
+
+    if (typeof (subnetTxt) !== 'string') {
+        return true;
+    }
+
+    var subnet = subnetTxt.split('/');
+
+    function validIPv4SubnetBits(obj) {
+        return obj.subnet_start.kind() === 'ipv4' &&
+          obj.subnet_bits >= constants.SUBNET_MIN_IPV4 &&
+          obj.subnet_bits <= 32;
+    }
+
+    function validIPv6SubnetBits(obj) {
+        return obj.subnet_start.kind() === 'ipv6' &&
+          obj.subnet_bits >= constants.SUBNET_MIN_IPV6 &&
+          obj.subnet_bits <= 128;
+    }
+
+    if (subnet.length !== 2) {
+        return true;
+    }
+
+    function toIPAddr(addr) {
+        if (/^[0-9]+$/.test(addr)) {
+            addr = Number(addr);
+        }
+
+        try {
+            return ipaddr.parse(addr);
+        } catch (_) {
+            return null;
+        }
+    }
+
+    var ip = toIPAddr(subnet[0]);
+    if (!ip) {
+        return true;
+    }
+
+    params.subnet_start = ip;
+    params.subnet_bits = Number(subnet[1]);
+
+    if (isNaN(params.subnet_bits) ||
+        (!validIPv4SubnetBits(params) && !validIPv6SubnetBits(params))) {
+        return true;
+    }
+
+    var cidr = ipaddr.createCIDR(ip, params.subnet_bits);
+
+    if (cidr.address().compare(ip) !== 0) {
+        return true;
+    }
+
+    return false;
+}
+
+function validateSubnetArray(_, name, arr, callback) {
+    var errs = [];
+    var sns = [];
+
+    if (!util.isArray(arr) && typeof (arr) !== 'string') {
+        callback(new errors.invalidParam(name, constants.msg.STR));
+        return;
+    }
+
+    var sn_array = util_common.arrayify(arr);
+    if (sn_array.length === 0) {
+        errs.push('Empty string');
+    } else {
+        /*
+         * UFDS will return a scalar if there's only one IP. Also allow
+         * comma-separated IPs from the commandline tools
+         */
+        sn_array.forEach(function (i) {
+            var sn = i.replace(/\s+/, '');
+            var inval = _validateSubnet(sn);
+
+            if (inval) {
+                errs.push(sn);
+            } else {
+                sns.push(sn);
+            }
+        });
+    }
+
+    if (errs.length !== 0) {
+        var snErr = errors.invalidParam(name, constants.msg.CIDR_SUBNET);
+        snErr.invalid = errs.sort();
+        callback(snErr);
+        return;
+    }
+
+    callback(null, sns);
+}
+
+function validateSubnet(_, name, subnet, callback) {
+    var invalid = _validateSubnet(subnet);
+    if (invalid) {
+        callback(errors.invalidParam(name, constants.msg.CIDR_SUBNET));
+        return;
+    }
+    callback(null, subnet);
+}
+
+
+
+function _validateUUID(uuid) {
+    if (!UUID_RE.test(uuid)) {
+        return true;
+    }
+    return false;
+}
+
+/*
+ * Validates a UUID
+ */
+function validateUUID(_, name, uuid, callback) {
+    var invalid = _validateUUID(uuid);
+
+    if (invalid) {
+        callback(new errors.invalidParam(name,
+                constants.msg.INVALID_UUID));
+        return;
+    }
+    callback(null, uuid);
+}
+
+function isValidUUID(uuid) {
+    if (typeof (uuid) !== 'string' || !UUID_RE.test(uuid)) {
+        return false;
+    }
+    return true;
+}
+
+
+/*
+ * Validates an array of UUIDs
+ */
+function validateUUIDarray(_, name, val, callback) {
+    var arr = util_common.arrayify(val);
+
+    /* Dedup the list and find invalid UUIDs */
+    var invalid = {};
+    var valid = {};
+    arr.forEach(function (uuid) {
+        if (UUID_RE.test(uuid)) {
+            valid[uuid] = 1;
+        } else {
+            invalid[uuid] = 1;
+        }
+    });
+
+    if (!util_common.hashEmpty(invalid)) {
+        var err = new errors.invalidParam(name, 'invalid UUID');
+        err.invalid = Object.keys(invalid).sort();
+        callback(err);
+        return;
+    }
+
+
+
+    callback(null, Object.keys(valid).sort());
+}
+
+
+
+function isNotInteger(val, id) {
+    assert.string(val);
+    return (val === '' || val.trim() !== val || isNaN(id) ||
+        Math.floor(id) !== id);
+}
+
+/*
+ * Checks for valid limits and offsets which are integers greater than or equal
+ * to zero. val usually is a string as it comes in from an HTTP query parameter.
+ */
+function validateOffset(_, name, val, callback) {
+    var id = Number(val);
+
+    if (typeof (val) !== 'number') {
+        if (isNotInteger(val, id)) {
+            callback(new errors.invalidParam(name,
+                constants.msg.OFFSET));
+            return;
+        }
+    }
+
+    if (isNaN(id) || id < constants.MIN_OFFSET) {
+        callback(new errors.invalidParam(name, constants.msg.OFFSET));
+        return;
+    }
+
+    callback(null, id);
+}
+
+
+/*
+ * Checks for valid limits which are integers in the range (0, 1000]. val is
+ * usually a string as it comes in from an HTTP query parameter.
+ */
+function validateLimit(_, name, val, callback) {
+    var id = Number(val);
+
+    if (typeof (val) !== 'number') {
+        if (isNotInteger(val, id)) {
+            callback(new errors.invalidParam(name,
+                constants.msg.LIMIT));
+            return;
+        }
+    }
+
+    if (isNaN(id) || id < constants.MIN_LIMIT || id > constants.MAX_LIMIT) {
+        callback(new errors.invalidParam(name, constants.msg.LIMIT));
+        return;
+    }
+
+    callback(null, id);
+}
+
+/*
+ * Validates a "fields" array - an array of strings specifying which of an
+ * object's fields to return in a response.  `fields` is the list of allowed
+ * fields that can be in the array.
+ */
+function validateFieldsArray(fields) {
+    assert.arrayOfString(fields, 'fields');
+    return function _validateFieldsArray(_, name, arr, callback) {
+        if (!util.isArray(arr)) {
+            callback(new errors.invalidParam(name,
+                    constants.msg.ARRAY_OF_STR));
+            return;
+        }
+
+        if (arr.length === 0) {
+            callback(new errors.invalidParam(name,
+                    constants.msg.ARRAY_EMPTY));
+            return;
+        }
+
+        if (arr.length > fields.length) {
+            callback(new errors.invalidParam(name,
+                fmt('can only specify a maximum of %d fields',
+                fields.length)));
+            return;
+        }
+
+        for (var a in arr) {
+            if (typeof (arr[a]) !== 'string') {
+                callback(new errors.invalidParam(name,
+                        constants.msg.ARRAY_OF_STR));
+                return;
+            }
+
+            if (fields.indexOf(arr[a]) === -1) {
+                callback(new errors.invalidParam(name,
+                    'unknown field specified'));
+                return;
+            }
+        }
+
+        callback(null, arr);
+    };
+}
+
+
+module.exports = {
+    fieldsArray: validateFieldsArray,
+    IParray: validateIParray,
+    IP: validateIP,
+    subnet: validateSubnet,
+    subnetArray: validateSubnetArray,
+    UUID: validateUUID,
+    isUUID: isValidUUID,
+    UUIDarray: validateUUIDarray,
+    isNotInteger: isNotInteger,
+    offset: validateOffset,
+    limit: validateLimit
+};
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..c5b0042
--- /dev/null
+++ b/package.json
@@ -0,0 +1,34 @@
+{
+  "name": "restify-warden",
+  "version": "0.1.0",
+  "description": "Yet another parameter validator",
+  "author": "Joyent, Inc",
+  "main": "./lib/validate.js",
+  "bin": {
+  },
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/node-restify-warden.git"
+  },
+  "engines": ["node >=0.10.0"],
+  "keywords": ["validate", "params"],
+  "license": "MPL-2.0",
+  "optionalDependencies": {
+  },
+  "devDependencies": {
+    "istanbul": "^0.4.0",
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.0.1",
+    "tape": "^4.2.2",
+    "faucet": "0.0.1"
+  },
+  "scripts": {
+  },
+  "dependencies": {
+    "assert-plus": "0.1",
+    "vasync": "1.6.4",
+    "verror": "1.3",
+    "ip6addr": "0.2.2",
+    "restify": "git://github.com/mcavage/node-restify.git#0d7b4ba"
+  }
+}
diff --git a/tests/run.js b/tests/run.js
new file mode 100644
index 0000000..eaeea1c
--- /dev/null
+++ b/tests/run.js
@@ -0,0 +1,1194 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+'use strict';
+
+var test = require('tape');
+var validate = require('../lib/validate');
+var util_const = require('../lib/constants');
+var util_common = require('../lib/common');
+var util_err = require('../lib/errors');
+var fmt = require('util').format;
+var restify = require('restify');
+var verror = require('verror');
+
+function expErr(message, errors, err, t) {
+    var cmp = function (err1, err2) {
+        if (err1.code < err2.code) {
+            return -1;
+        }
+        if (err1.code > err2.code) {
+            return 1;
+        }
+        return 0;
+    };
+    var errExp = new util_err.InvalidParamsError(message, errors.sort(cmp));
+    if (err.body.errors) {
+        err.body.errors = err.body.errors.sort(cmp);
+    }
+    t.deepEqual(err, errExp);
+}
+
+function expErrInternal(err, t) {
+    var errExp = new restify.InternalError('Internal error');
+
+    t.deepEqual(err, errExp);
+}
+
+function expVErrInternal(err, errs,  t) {
+    var errExp = new restify.InternalError('Internal error');
+    errExp.we_cause = new verror.MultiError(errs);
+
+    t.deepEqual(err, errExp);
+}
+
+/*
+ * Most tests will create an `opts` object which will contain parameters,
+ * config information, and the validation callbacks for use with params(). Any
+ * parameters may each be known-valid, known-invalid, unknown (shorted to KV,
+ * KI, U). We also test these combinations when strictness (S) is turned off.
+ *
+ * We want to test on mixes which are homogenous (all known-invalid, for
+ * example), and heterogenous (contain at least 2 of the 3 possibilities).
+ *
+ * We run the tests against the stock validators in validators.js
+ *
+ * This is a) necessary, and b) just as good as running on custom validators
+ *
+ * Some tests involve calling boolean functions instead of params().
+ *
+ * We also need to verify that turning strict OFF also works.
+ */
+
+test('IP-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IP
+        }
+    };
+    var params = { ip: '8.8.8.8' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('GEN-S-MULTI', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            foo: function (_opts, _name, foo, cb) {
+                return cb(null, null, {foo: foo, bar: 'bar'});
+            }
+        }
+    };
+    var params = { foo: 'foo' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        var expRes = {foo: 'foo', bar: 'bar'};
+        t.deepEqual(res, expRes, 'Expect res and expRes to be eq');
+        t.end();
+    });
+});
+
+test('Fields-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: [ 'name' ] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('Params-S-Undef', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name' ])
+        }
+    };
+
+    var params = null;
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('parameters',
+            util_const.msg.PARAMETERS_ARE_OBJECTS) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Params-S-Arr', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name' ])
+        }
+    };
+
+    var params = ['just', 'an', 'array'];
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('parameters',
+            util_const.msg.PARAMETERS_ARE_OBJECTS) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Params-S-Num', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name' ])
+        }
+    };
+
+    var params = 42;
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('parameters',
+            util_const.msg.PARAMETERS_ARE_OBJECTS) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Fields-S-KI-arr-excess', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name', 'addr' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: [ 'name', 'addr', 'excess' ] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var submsg = fmt('can only specify a maximum of %d fields',
+            2);
+        var errors = [ util_err.invalidParam('fields', submsg) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Fields-S-KI-notarr', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name', 'addr' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: 'thisisnotanarray' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('fields',
+            util_const.msg.ARRAY_OF_STR) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Fields-S-KI-arr-has-no-str', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name', 'addr' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: [ {num: 42}, {num: 42} ] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('fields',
+            util_const.msg.ARRAY_OF_STR) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Fields-S-KI-arr-bad-name', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name', 'addr' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: [ 'unrecognized' ] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('fields',
+            'unknown field specified') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('Fields-S-KI-arr-zero', function (t) {
+    var opts = {
+        strict: true,
+        required: { name: validate.UUID },
+        optional: {
+            fields: validate.fieldsArray([ 'name', 'addr' ])
+        }
+    };
+
+    var params = { name: 'e9e39136-bb4e-11e6-b107-ef7f99024cc4',
+        fields: [ ] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('fields',
+            util_const.msg.ARRAY_EMPTY) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IP-S-KI', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IP
+        }
+    };
+    var params = { ip: 'Veni, vidi, vici' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('ip',
+            'invalid IP address') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IP-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IP
+        }
+    };
+    var params = { hal: '1000' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        /* TODO Unknown params instead of invalid param */
+        var errors = [ util_err.unknownParams(['hal']),
+            util_err.missingParam('ip') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IP-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IP
+        }
+    };
+    var params = { ip: 'Et tu, Brute?', hal: '1000' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.unknownParams(['hal']),
+            util_err.invalidParam('ip', 'invalid IP address') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IParray-S-KV-array', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { ip: ['8.8.8.8', '4.4.4.4'] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('IParray-S-KV-array-after', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        },
+        after: function some_no_op(_, _raw, _validated, cb) {
+                   return cb();
+        }
+    };
+    var params = { ip: ['8.8.8.8', '4.4.4.4'] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('IParray-S-KV-string', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { ip: '8.8.8.8,4.4.4.4' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('IParray-S-KV-array-after', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        },
+        after: function some_no_op(_, _raw, _validated, cb) {
+                   return cb({my_err_obj: 42});
+        }
+    };
+    var params = { ip: ['8.8.8.8', '4.4.4.4'] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        expErrInternal(err, t);
+        t.end();
+    });
+});
+
+test('IParray-S-KV-array-after2', function (t) {
+    var afterErrs = [ {my_err_obj: 42}, {meo: 43} ];
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        },
+        after: function some_no_op(_, _raw, _validated, cb) {
+            return cb(afterErrs);
+        }
+    };
+    var params = { ip: ['8.8.8.8', '4.4.4.4'] };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        expVErrInternal(err, afterErrs, t);
+        t.end();
+    });
+});
+
+test('IParray-S-KI-string-empty', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { ip: '' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error = util_err.invalidParam('ip', 'invalid IP');
+        error.invalid = [ 'Empty string' ];
+        var errors = [ error ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IParray-S-KI-string-notArr', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { ip: {obj: 'notanarray', foo: 43 } };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('ip',
+            util_const.msg.STR) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnetArray-S-KI-string-notArr', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnetArray
+        }
+    };
+    var params = { subnet: {obj: 'notanarray', foo: 43 } };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.STR) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('IParray-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { hotdog: ['frank', 'bun', 'dijon'] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.unknownParams([ 'hotdog' ]),
+            util_err.missingParam('ip') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+function set_err_inv(error, invalid, noproc, sort) {
+    var inv_list = [];
+    var arr;
+    if (typeof (invalid) === 'string') {
+        arr = util_common.arrayify(invalid);
+        if (invalid === '') {
+            error.invalid = [ 'Empty string' ];
+            return;
+        }
+    } else {
+        arr = invalid;
+        if (noproc) {
+            error.invalid = arr.sort();
+            return;
+        }
+    }
+    arr.forEach(function (i) {
+        var ip = i.replace(/\s+/, '');
+        inv_list.push(ip);
+    });
+    if (sort) {
+        error.invalid = inv_list.sort();
+    } else {
+        error.invalid = inv_list;
+    }
+}
+
+test('IParray-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            ip: validate.IParray
+        }
+    };
+    var params = { nirvana: ['in bloom', 'smells like teen spirit'],
+        ip: ['By the prickling of my thumbs', 'something wicked',
+            'this way comes']
+    };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('ip', 'invalid IPs');
+        set_err_inv(error1, params.ip);
+        var error2 = util_err.unknownParams([ 'nirvana' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '8.8.8.0/24' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('subnet-S-KI-gibberish', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: 'I will force spiders and badgers on the enemy!' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-badip', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: 'notanip/24' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-notstr', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: 42 };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-ipv4-badsub', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '8.8.8.8/99' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-ipv4-bad-ip-sub-pair', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '8.8.8.8/24' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-ipv4-bad/sub', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '8.8.8.8/99/99' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-ipv6-badsub', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '2001:0db8:0a0b:12f0::1/999' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-ipv6-badsubNaN', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: '2001:0db8:0a0b:12f0::1/^^' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { konrad: 'zuse' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.unknownParams([ 'konrad' ]),
+            util_err.missingParam('subnet') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnet-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: 'I want you to stuff the ice-chest!',
+        lebowski: 'shut the $#@% up donny!' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.unknownParams([ 'lebowski' ]),
+            util_err.invalidParam('subnet', util_const.msg.CIDR_SUBNET)
+        ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnetArray-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnetArray
+        }
+    };
+    var params = { subnet: '8.8.8.0/24,4.4.4.0/24' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('subnetArray-S-KI-gibberish', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnetArray
+        }
+    };
+    var params = { subnet: 'not,a,subnet,tro,lo,lo' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET);
+        set_err_inv(error1, params.subnet, false, true);
+        var errors = [ error1 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnetArray-S-KI-emptystring', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnetArray
+        }
+    };
+    var params = { subnet: '' };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET);
+        set_err_inv(error1, '');
+        var errors = [ error1 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('subnetArray-S-KI-notobject', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            subnet: validate.subnet
+        }
+    };
+    var params = { subnet: { notanarray: 'not', val: 42 } };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('subnet',
+            util_const.msg.CIDR_SUBNET) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUID-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUID
+        }
+    };
+    var params = { uuid: '895ef360-aadb-11e6-b917-178ac4f402e3' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('UUID-S-KI', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUID
+        }
+    };
+    var params = { uuid: 'Yo mama\'s pudgey. Face it.' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('uuid',
+            util_const.msg.INVALID_UUID) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUID-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUID
+        }
+    };
+    var params = { kilroy: 'was here' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.unknownParams([ 'kilroy' ]),
+            util_err.missingParam('uuid') ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUID-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUID
+        }
+    };
+    var params = { uuid: 'they took my spider-jars into prison',
+        czr: 'the die is cast' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('uuid',
+            util_const.msg.INVALID_UUID),
+            util_err.unknownParams([ 'czr' ]) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUIDarray-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUIDarray
+        }
+    };
+    var params = { uuid: ['ee985c08-aadb-11e6-a317-bb60373c8455',
+        '1719a244-ab78-11e6-bd7e-c71f1a793a36'] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('UUIDarray-S-KI', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUIDarray
+        }
+    };
+    var params = { uuid: ['Gotta keep my mind free...',
+        '1719a244-ab78-11e6-bd7e-c71f1a793a36'] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('uuid',
+            util_const.msg.INVALID_UUID);
+        set_err_inv(error1, [ 'Gotta keep my mind free...'], true);
+        var errors = [ error1 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUIDarray-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUIDarray
+        }
+    };
+    var params = { badcafe: [ '1719a244-ab78-11e6-bd7e-c71f1a793a36'] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.missingParam('uuid');
+        var error2 = util_err.unknownParams([ 'badcafe' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('UUIDarray-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            uuid: validate.UUIDarray
+        }
+    };
+    var params = { quickcheck: [ 'The way tests were meant', 'to be written'],
+        uuid: ['I was happy...', '...then your sister...',
+        '...threw a seafish at my TV.'] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('uuid',
+            util_const.msg.INVALID_UUID);
+        set_err_inv(error1, params.uuid, true);
+        var error2 = util_err.unknownParams([ 'quickcheck' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('limit-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = { limit: util_const.MAX_LIMIT };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('limit-S-KI-toobig', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = { limit: (util_const.MAX_LIMIT + 1) };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('limit',
+            util_const.msg.LIMIT) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('limit-S-KI-toosmall', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = { limit: (util_const.MIN_LIMIT - 1) };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('limit',
+            util_const.msg.LIMIT) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('limit-S-KI-NaN', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = {
+        limit: 'I bought 2 zebras & tamed a parrot named Mr. Future'
+    };
+
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var errors = [ util_err.invalidParam('limit',
+            util_const.msg.LIMIT) ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('limit-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = { lesson: 'Production is a harsh teacher' };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.missingParam('limit');
+        var error2 = util_err.unknownParams([ 'lesson' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('limit-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            limit: validate.limit
+        }
+    };
+    var params = { limit: -1, list: [1, 2, 3, 4] };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('limit', util_const.msg.LIMIT);
+        var error2 = util_err.unknownParams([ 'list' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('offset-S-KV', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            offset: validate.offset
+        }
+    };
+    var params = { offset: util_const.MIN_OFFSET };
+    validate.params(opts, null, params, function (err, res) {
+        t.ifErr(err, 'Expecting success');
+        t.end();
+    });
+});
+
+test('offset-S-KI', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            offset: validate.offset
+        }
+    };
+    var params = { offset: util_const.MIN_OFFSET - 1 };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('offset', util_const.msg.OFFSET);
+        var errors = [ error1 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('offset-S-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            offset: validate.offset
+        }
+    };
+    var params = { unknown: util_const.MIN_OFFSET };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.missingParam('offset');
+        var error2 = util_err.unknownParams([ 'unknown' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('offset-S-KI-U', function (t) {
+    var opts = {
+        strict: true,
+        required: {
+            offset: validate.offset
+        }
+    };
+    var params = { offset: 'the proletariat will rise and overthrow the' +
+            ' bourgeoisie',
+        hi: util_const.MIN_OFFSET };
+    validate.params(opts, null, params, function (err, res) {
+        t.ok(err, 'Expecting error');
+        var msg = util_const.msg.INVALID_PARAMS;
+        var error1 = util_err.invalidParam('offset', util_const.msg.OFFSET);
+        var error2 = util_err.unknownParams([ 'hi' ]);
+        var errors = [ error1, error2 ];
+        expErr(msg, errors, err, t);
+        t.end();
+    });
+});
+
+test('isUUID', function (t) {
+    var uuid = '4aafe9a6-ab7d-11e6-93bb-c315b954888f';
+    var T = validate.isUUID(uuid);
+    t.ok(T === true, 'Expected true');
+    var F = validate.isUUID('4aafe9a6ab7d11e693bbc315b954888f');
+    t.ok(F === false, 'Expected false');
+    F = validate.isUUID(0x4aafe9a6ab7d);
+    t.ok(F === false, 'Expected false');
+    t.end();
+});
+
+test('isNotInteger', function (t) {
+    var val = '';
+    var id = 'str';
+    var T = validate.isNotInteger(val, id);
+    t.ok(T === true, 'Expected true');
+    val = '1234';
+    id = 42;
+    var F = validate.isNotInteger(val, id);
+    t.ok(F === false, 'Expected false');
+    t.end();
+});
