From 4acb16771735de18138de0d74cf4d492e695a74f Mon Sep 17 00:00:00 2001
From: Richard Bradley <richard.bradley@joyent.com>
Date: Wed, 7 Feb 2018 15:08:32 +0000
Subject: [PATCH] MANATEE-380 would like `manatee-adm promote` MANATEE-393
 manatee-adm does not listen for PG errors after connecting

---
 bin/manatee-adm             |  86 ++++++++-
 docs/man/manatee-adm.md     |  22 ++-
 lib/adm.js                  | 349 +++++++++++++++++++++++++++++++++++-
 man/man1/manatee-adm.1      |  22 ++-
 test/tst.manateeAdmUsage.js |  12 +-
 5 files changed, 486 insertions(+), 5 deletions(-)

diff --git a/bin/manatee-adm b/bin/manatee-adm
index 7e34493..e6d03d0 100755
--- a/bin/manatee-adm
+++ b/bin/manatee-adm
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var adm = require('../lib/adm');
@@ -104,6 +104,8 @@ function ManateeAdm() {
             'unfreeze',
             'reap',
             'rebuild',
+            'promote',
+            'clear-promote',
             { 'group': 'UPGRADE COMMANDS' },
             'state-backfill',
             { 'group': 'META COMMANDS' },
@@ -838,6 +840,88 @@ ManateeAdm.prototype.do_rebuild.help = ([
     '{{options}}'
 ].join('\n'));
 
+/*
+ * Promotes a peer to the next applicable position in the topology.
+ */
+ManateeAdm.prototype.do_promote = function (subcmd, opts, args, cb) {
+    var self = this;
+
+    self.checkHelpRequested(subcmd, opts, cb);
+    self.checkRequiredOption(subcmd, opts, 'role', cb);
+    self.checkRequiredOption(subcmd, opts, 'zonename', cb);
+    self.checkRequiredOption(subcmd, opts, 'shard', cb);
+    self.checkRequiredOption(subcmd, opts, 'zk', cb);
+
+    adm.promote(opts, function (err) {
+        if (!err) {
+            console.log('Successfully promoted peer.');
+        }
+        cb(err);
+    });
+};
+ManateeAdm.prototype.do_promote.options = [
+    commonOptions.help,
+    {
+        'names': [ 'role', 'r' ],
+        'type': 'string',
+        'helpArg': 'ROLE',
+        'help': 'The current role of the peer to promote'
+    },
+    {
+        'names': [ 'zonename', 'n' ],
+        'type': 'string',
+        'helpArg': 'ZONENAME',
+        'help': 'The zonename of the peer to promote'
+    },
+    {
+        'names': [ 'asyncIndex', 'i' ],
+        'type': 'number',
+        'helpArg': 'INDEX',
+        'help': 'Index of peer in async chain (zero-based)'
+    },
+    commonOptions.shard,
+    commonOptions.zk
+];
+ManateeAdm.prototype.do_promote.help = ([
+    'Promote the given peer to the next applicable position in the topology.',
+    '',
+    'Usage:',
+    '    {{name}} promote [OPTIONS]',
+    '',
+    '{{options}}'
+].join('\n'));
+
+/*
+ * Clears a "promote" object from the cluster's state in ZooKeeper.
+ */
+ManateeAdm.prototype.do_clear_promote = function (subcmd, opts, args, cb) {
+    var self = this;
+
+    self.checkHelpRequested(subcmd, opts, cb);
+    self.checkRequiredOption(subcmd, opts, 'shard', cb);
+    self.checkRequiredOption(subcmd, opts, 'zk', cb);
+
+    adm.clearPromote(opts, function (err) {
+        if (!err) {
+            console.log('Cleared promote request.');
+        }
+        cb(err);
+    });
+};
+ManateeAdm.prototype.do_clear_promote.options = [
+    commonOptions.help,
+    commonOptions.shard,
+    commonOptions.zk
+];
+ManateeAdm.prototype.do_clear_promote.help = ([
+    'Clear a promote object from cluster\'s state.',
+    '',
+    'Usage:',
+    '    {{name}} clear-promote [OPTIONS]',
+    '',
+    '{{options}}'
+].join('\n'));
+
 /**
  * Freezes a Manatee's cluster state so that it won't make any state
  * transitions.
diff --git a/docs/man/manatee-adm.md b/docs/man/manatee-adm.md
index 442afce..a73a78b 100644
--- a/docs/man/manatee-adm.md
+++ b/docs/man/manatee-adm.md
@@ -343,7 +343,27 @@ will be used.
     The zonename of the peer to remove.
 
 
+### promote [-n | --zonename ZONENAME] [-r | --role ROLE] [-i | --asyncIndex INDEX]
 
+Promote a peer from its current position to the next applicable position in the
+topology.  The taken-over peer moves down the replication chain by one position,
+except in the case where the promoted peer is the sync, in which case the
+primary will be deposed.
+
+-n, --zonename `ZONENAME`
+    The zonename of the peer to promote.
+
+-r, --role `ROLE`
+    The current role of the peer to promote.
+
+-i, --asyncIndex `INDEX`
+    The zero-indexed position of the peer to be promoted's position in
+    the async chain (if applicable).
+
+### clear-promote
+
+Clears a promote object from the cluster's state in the event that Manatee
+itself does not.
 
 ## UPGRADE COMMANDS
 
@@ -443,4 +463,4 @@ not.
 
 ## COPYRIGHT
 
-Copyright (c) 2015 Joyent Inc., All rights reserved.
+Copyright (c) 2018 Joyent Inc., All rights reserved.
diff --git a/lib/adm.js b/lib/adm.js
index 6e642b0..5d725e2 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /**
@@ -31,6 +31,7 @@ var progbar = require('progbar');
 var prompt = require('prompt');
 var restify = require('restify');
 var sprintf = require('extsprintf').sprintf;
+var jsprim = require('jsprim');
 var util = require('util');
 var vasync = require('vasync');
 var VError = require('verror');
@@ -50,6 +51,8 @@ exports.checkLock = checkLock;
 exports.freeze = freeze;
 exports.unfreeze = unfreeze;
 exports.history = history;
+exports.promote = promote;
+exports.clearPromote = clearPromote;
 exports.rebuild = rebuild;
 exports.reap = reap;
 exports.setOnwm = setOnwm;
@@ -1623,6 +1626,311 @@ function rebuild(opts, cb) {
 
 }
 
+/**
+ * Promote a given peer to the next applicable position in the cluster.
+ * Performs some initial validation against the cluster to ensure the safety of
+ * a promotion in this state, writes the intended promotion request into the
+ * cluster's state in ZooKeeper, then watches the cluster for the appropriate
+ * change.
+ */
+function promote(opts, callback) {
+    vasync.pipeline({ arg: opts, funcs: [
+        _createZkClient,
+        function getState(_, cb) {
+            /*
+             * The get/set cycle for state objects is handled differently to how
+             * some of the other parts of manatee-adm (e.g. ManateeCluterDetails
+             * obtain state.  As such, we record the state from ZooKeeper (along
+             * with its stat object) in a separate place which we use later to
+             * write back into ZooKeeper.
+             */
+            var p = '/manatee/' + _.shard + '/state';
+            _.zkClient.getData(p, function (err, data, stat) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                _.originalState = JSON.parse(data.toString('utf8'));
+                _.stateStat = stat;
+                cb();
+            });
+        },
+        _getShards,
+        _getClusterStates,
+        function _verifyStates(_, cb) {
+            /*
+             * We want to make sure that the object we verify against is the
+             * same as the one we'll eventually write back to ZooKeeper.
+             */
+            if (!jsprim.deepEqual(_.state[_.shard], _.originalState)) {
+                cb(new VError('state has unexpectedly changed'));
+                return;
+            }
+            cb();
+        },
+        _addPostgresStatus,
+        _constructClusterDetails,
+        function validateInput(_, cb) {
+            if ([ 'sync', 'async' ].indexOf(_.role) === -1) {
+                cb(new VError('promotion of "%s" is invalid', _.role));
+                return;
+            }
+
+            /*
+             * Only complain about a missing asyncIndex if the cluster has more
+             * than one async.
+             */
+            if (_.role === 'async') {
+                if (!(_.asyncIndex >= 0) && _.state[_.shard].async.length > 1) {
+                    cb(new VError('promotion of "async" ambiguous given the ' +
+                        'current state of the cluster (asyncIndex required)'));
+                    return;
+                } else {
+                    _.asyncIndex = 0;
+                }
+            }
+
+            if (_.role !== 'async' && (_.asyncIndex >= 0)) {
+                cb(new VError('asyncIndex not applicable to this promotion'));
+                return;
+            }
+
+            _.currentRole = getRoleFromZkState(_.state[_.shard], _.zonename);
+            if (!_.currentRole) {
+                cb(new VError('"%s" not found in shard information',
+                    _.zonename));
+                return;
+            }
+
+            _.currentAsyncIndex = null;
+            if (_.currentRole === 'async') {
+                _.state[_.shard].async.forEach(function (p, i) {
+                    if (_.zonename === p.zoneId) {
+                        _.currentAsyncIndex = i;
+                    }
+                });
+            }
+
+            if (_.currentRole !== _.role) {
+                cb(new VError('"%s" does not hold the role "%s" (it is ' +
+                    'currently "%s"%s)',
+                    _.zonename, _.role, _.currentRole,
+                    (_.currentAsyncIndex && _.currentAsyncIndex >= 0) ?
+                        ', position ' + _.currentAsyncIndex : ''));
+                return;
+            }
+
+            if (_.asyncIndex && (_.currentAsyncIndex !== _.asyncIndex)) {
+                cb(new VError('"%s" is not position %d in the async chain ' +
+                    '(it is currently position %d)',
+                    _.zonename, _.asyncIndex, _.currentAsyncIndex));
+                return;
+            }
+
+            cb();
+        },
+        function validateState(_, cb) {
+            if (_.fullState.pgs_frozen) {
+                cb(new VError('cluster is frozen (reason: "%s")',
+                    _.fullState.pgs_freeze_reason));
+                return;
+            }
+
+            if (_.fullState.pgs_singleton) {
+                cb(new VError('cluster is in singleton mode'));
+                return;
+            }
+
+            if (_.fullState.pgs_errors.length) {
+                cb(new VError(new VError.MultiError(_.fullState.pgs_errors),
+                    'cluster has errors'));
+                return;
+            }
+
+            if (_.fullState.pgs_warnings.length) {
+                cb(new VError(new VError.MultiError(_.fullState.pgs_warnings),
+                    'cluster has warnings'));
+                return;
+            }
+
+            /*
+             * We need to check the replication LSNs here to ensure we have
+             * genuine lag, as opposed to the cluster just not taking any
+             * writes.
+             */
+            var replErrs = [];
+            jsprim.forEachKey(_.fullState.pgs_peers, function (key, peer) {
+                var sent_lsn = jsprim.pluck(peer, 'pgp_repl.sent_location');
+                var flush_lsn = jsprim.pluck(peer, 'pgp_repl.flush_location');
+                if (peer.pgp_lag && sent_lsn !== flush_lsn) {
+                    replErrs.push(new VError('"%s" has non-zero lag to its ' +
+                        'downstream peer', peer.pgp_ident.zoneId));
+                }
+            });
+            if (replErrs.length) {
+                cb(new VError(new VError.MultiError(replErrs),
+                    'cluster is exhibiting an unacceptable amount of lag'));
+                return;
+            }
+
+            cb();
+        },
+        function confirm(_, cb) {
+            var msg = [
+                'You are about to make changes to this cluster\'s topology.  ' +
+                'This operation will have varying effects on the cluster ' +
+                'depending on the requested action, and you should be aware ' +
+                'of these effects before proceeding.'
+            ].join('');
+            var promptMsg = sprintf('Promote this peer ("%s")?',
+                _.role);
+
+            console.error(msg);
+            prompt.start({
+                message: promptMsg
+            });
+            prompt.get(['no'], function (err, result) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                if (result.no !== 'yes' && result.no !== 'y') {
+                    cb(new VError('aborting promotion due to user command'));
+                    return;
+                }
+                cb();
+            });
+        },
+        function buildPromoteState(_, cb) {
+            _.promote = {};
+            if (_.role === 'sync') {
+                _.promote.id = _.state[_.shard][_.role].id;
+            } else {
+                _.promote.id = _.state[_.shard].async[_.asyncIndex].id;
+                _.promote.asyncIndex = _.asyncIndex;
+            }
+            _.promote.role = _.role;
+            _.promote.generation = _.state[_.shard].generation;
+            _.promote.expireTime =
+                jsprim.iso8601(new Date().getTime() + (5 * 1000));
+
+            cb();
+        },
+        function setPromoteState(_, cb) {
+            _.state = _.originalState;
+            _.state.promote = _.promote;
+            cb();
+        },
+        _putState,
+        function watchClusterState(_, cb) {
+            /*
+             * Watch for the removal of the "promote" object from ZooKeeper, and
+             * for a change in position in the cluster of the promoted peer.  If
+             * the promoted peer doesn't see a role change within 10s, fail the
+             * operation and inform the operator.  Also fail if no changes are
+             * made within the expireTime of the promote object.
+             *
+             * This could do with being much more comprehensive, but for now
+             * it's enough to tell if the state machine has either acted upon or
+             * ignored our promotion request.
+             */
+            var watchStart = new Date();
+            var watchSeconds = 10;
+            var watchTimeout = watchSeconds * 1000;
+            console.log('Waiting until %s for promotion to be acknowledged, ' +
+                'or %s seconds if no role change occurs after acknowledgement',
+                _.promote.expireTime, watchSeconds);
+
+            function watch() {
+                vasync.pipeline({ arg: _, funcs: [
+                    _getShards,
+                    _getClusterStates,
+                    _addPostgresStatus,
+                    _constructClusterDetails
+                ]}, function (err, res) {
+                    if (err) {
+                        callback(err);
+                        return;
+                    }
+
+                    var now = new Date();
+                    var promoteObjectRemoved = false;
+                    var roleChanged = false;
+
+                    if (!_.state[_.shard].promote) {
+                        promoteObjectRemoved = true;
+                    }
+
+                    if (_.promote.role === 'async') {
+                        if (_.fullState['pgs_asyncs'][
+                            _.promote.asyncIndex] !== _.promote.id) {
+                            roleChanged = true;
+                        }
+                    } else if (_.fullState['pgs_' + _.promote.role] !==
+                        _.promote.id) {
+                        roleChanged = true;
+                    }
+
+                    var expireTime = new Date(_.promote.expireTime).getTime();
+                    if (!promoteObjectRemoved &&
+                        now.getTime() > expireTime) {
+                        callback(new VError('cluster has not acted upon our ' +
+                            'promotion request within the expected timeout.  ' +
+                            'check sitter logs.'));
+                        return;
+                    }
+
+                    var duration = now.getTime() - watchStart.getTime();
+                    if (promoteObjectRemoved && roleChanged) {
+                        callback();
+                    } else if (duration > watchTimeout) {
+                        callback(new VError('role has not changed within %s ' +
+                            'seconds.  check sitter logs.', watchSeconds));
+                    } else {
+                        setTimeout(watch, 1000);
+                    }
+                });
+            }
+            watch();
+        }
+    ]}, function (err) {
+        _closeZkClient(opts);
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback();
+    });
+}
+
+/*
+ * Removes the "promote" object from the cluster's state.
+ */
+function clearPromote(opts, callback) {
+    vasync.pipeline({ arg: opts, funcs: [
+        _createZkClient,
+        _getState,
+        function _clearPromote(_, cb) {
+            if (!_.state.promote) {
+                cb(new VError('cluster has no outstanding promotion request'));
+                return;
+            }
+            delete (_.state.promote);
+            cb();
+        },
+        _putState
+    ]}, function (err) {
+        _closeZkClient(opts);
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback();
+    });
+}
+
 /**
  * @param {Object} opts The options object.
  * @param {String} opts.zk The zookeeper URL.
@@ -1790,6 +2098,7 @@ function queryPg(url, _query, callback) {
     var client = new pg.Client(url);
     client.connect(function (err) {
         if (err) {
+            LOG.debug(err, 'error connecting to postgres');
             return callback(err);
         }
         LOG.debug({
@@ -1802,6 +2111,11 @@ function queryPg(url, _query, callback) {
             return callback(err2, result);
         });
     });
+    client.on('error', function (err) {
+        LOG.debug(err, 'error from postgres client');
+        client.end();
+        callback(err);
+    });
 }
 
 function oldHistoryToObj(fNode) {
@@ -2008,3 +2322,36 @@ function transformPgUrl(zkNode) {
     var data = zkNode.split('-')[0].split(':');
     return 'tcp://postgres@' + data[0] + ':' + data[1] + '/postgres';
 }
+
+/*
+ * Given a ZK state object and zoneId, return the role of the requested zoneId.
+ * If the zoneId is not found to be a member of the cluster, returns undefined.
+ */
+function getRoleFromZkState(state, zoneId) {
+    assert.object(state, 'state');
+    assert.string(zoneId, 'zoneId');
+
+    var role;
+
+    if (state.primary && state.primary.zoneId === zoneId) {
+        role = 'primary';
+    } else if (state.sync && state.sync.zoneId === zoneId) {
+        role = 'sync';
+    } else {
+        state.async.forEach(function (p) {
+            if (p.zoneId === zoneId) {
+                role = 'async';
+            }
+        });
+    }
+
+    if (!role) {
+        state.deposed.forEach(function (p) {
+            if (p.zoneId === zoneId) {
+                role = 'deposed';
+            }
+        });
+    }
+
+    return (role);
+}
diff --git a/man/man1/manatee-adm.1 b/man/man1/manatee-adm.1
index fc757dc..4c858f2 100644
--- a/man/man1/manatee-adm.1
+++ b/man/man1/manatee-adm.1
@@ -381,6 +381,26 @@ will be used.
 .PP
 \-n, \-\-zonename \fB\fCZONENAME\fR
     The zonename of the peer to remove.
+.SS promote [\-n | \-\-zonename ZONENAME] [\-r | \-\-role ROLE] [\-i | \-\-asyncIndex INDEX]
+.PP
+Promote a peer from its current position to the next applicable position in the
+topology.  The taken\-over peer moves down the replication chain by one position,
+except in the case where the promoted peer is the sync, in which case the
+primary will be deposed.
+.PP
+\-n, \-\-zonename \fB\fCZONENAME\fR
+    The zonename of the peer to promote.
+.PP
+\-r, \-\-role \fB\fCROLE\fR
+    The current role of the peer to promote.
+.PP
+\-i, \-\-asyncIndex \fB\fCINDEX\fR
+    The zero\-indexed position of the peer to be promoted's position in
+    the async chain (if applicable).
+.SS clear\-promote
+.PP
+Clears a promote object from the cluster's state in the event that Manatee
+itself does not.
 .SH UPGRADE COMMANDS
 .SS state\-backfill
 .PP
@@ -465,4 +485,4 @@ not.
     Sets the node\-bunyan logging level. Defaults to fatal.
 .SH COPYRIGHT
 .PP
-Copyright (c) 2015 Joyent Inc., All rights reserved.
+Copyright (c) 2018 Joyent Inc., All rights reserved.
diff --git a/test/tst.manateeAdmUsage.js b/test/tst.manateeAdmUsage.js
index 1251c37..6d23c97 100644
--- a/test/tst.manateeAdmUsage.js
+++ b/test/tst.manateeAdmUsage.js
@@ -132,6 +132,14 @@ var subcmds = {
     'reap': {
         'required': [ 'shard', 'zk' ],
         'destructive': true
+    },
+    'promote': {
+        'required': [ 'role', 'zonename', 'shard', 'zk' ],
+        'destructive': true
+    },
+    'clear-promote': {
+        'required': [ 'shard', 'zk' ],
+        'destructive': true
     }
 };
 
@@ -164,7 +172,9 @@ var requiredOptionEnvVars = {
     'config': null,
     'mode': null,
     'path': null,
-    'reason': null
+    'reason': null,
+    'role': null,
+    'zonename': null
 };
 
 var testsOk = 0;            /* count of tests that passed */
-- 
2.21.0

