From 47a2857ae50ffe19352d85940d0d90838339697a Mon Sep 17 00:00:00 2001
From: Richard Bradley <richard.bradley@joyent.com>
Date: Mon, 29 Apr 2019 16:08:11 +0100
Subject: [PATCH] MANATEE-380 would like `manatee-adm promote` MANATEE-393
 manatee-adm does not listen for PG errors after connecting MANATEE-417
 Manatee should not use the master branch for its state machine dependency

---
 bin/manatee-adm             | 140 ++++++++---
 docs/man/manatee-adm.md     |  75 +++++-
 lib/adm.js                  | 481 +++++++++++++++++++++++++++++++++++-
 man/man1/manatee-adm.1      |  92 ++++++-
 package.json                |   2 +-
 test/tst.manateeAdmUsage.js |  14 +-
 6 files changed, 762 insertions(+), 42 deletions(-)

diff --git a/bin/manatee-adm b/bin/manatee-adm
index 13dbd22..ce1efe4 100755
--- a/bin/manatee-adm
+++ b/bin/manatee-adm
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var adm = require('../lib/adm');
@@ -104,6 +104,8 @@ function ManateeAdm() {
             'unfreeze',
             'reap',
             'rebuild',
+            'promote',
+            'clear-promote',
             { 'group': 'UPGRADE COMMANDS' },
             'state-backfill',
             { 'group': 'META COMMANDS' },
@@ -838,6 +840,96 @@ ManateeAdm.prototype.do_rebuild.help = ([
     '{{options}}'
 ].join('\n'));
 
+/*
+ * Promotes a peer to the next applicable position in the topology.
+ */
+ManateeAdm.prototype.do_promote = function (subcmd, opts, args, cb) {
+    var self = this;
+
+    self.checkHelpRequested(subcmd, opts, cb);
+    self.checkRequiredOption(subcmd, opts, 'role', cb);
+    self.checkRequiredOption(subcmd, opts, 'zonename', cb);
+    self.checkRequiredOption(subcmd, opts, 'shard', cb);
+    self.checkRequiredOption(subcmd, opts, 'zk', cb);
+
+    adm.promote(opts, function (err) {
+        if (!err) {
+            console.log('Successfully promoted peer.');
+        }
+        cb(err);
+    });
+};
+ManateeAdm.prototype.do_promote.options = [
+    commonOptions.help,
+    {
+        'names': [ 'role', 'r' ],
+        'type': 'string',
+        'helpArg': 'ROLE',
+        'help': 'The current role of the peer to promote'
+    },
+    {
+        'names': [ 'zonename', 'n' ],
+        'type': 'string',
+        'helpArg': 'ZONENAME',
+        'help': 'The zonename of the peer to promote'
+    },
+    {
+        'names': [ 'asyncIndex', 'i' ],
+        'type': 'number',
+        'helpArg': 'INDEX',
+        'help': 'Index of peer in async chain (zero-based)'
+    },
+    {
+        'names': [ 'lagToIgnore', 'l' ],
+        'type': 'number',
+        'helpArg': 'SECONDS',
+        'help': 'Lag in seconds that is acceptable for this promotion ' +
+            '(default: 5s)',
+        'default': 5
+    },
+    commonOptions.shard,
+    commonOptions.zk
+];
+ManateeAdm.prototype.do_promote.help = ([
+    'Promote the given peer to the next applicable position in the topology.',
+    '',
+    'Usage:',
+    '    {{name}} promote [OPTIONS]',
+    '',
+    '{{options}}'
+].join('\n'));
+
+/*
+ * Clears a "promote" object from the cluster's state in ZooKeeper.
+ */
+ManateeAdm.prototype.do_clear_promote = function (subcmd, opts, args, cb) {
+    var self = this;
+
+    self.checkHelpRequested(subcmd, opts, cb);
+    self.checkRequiredOption(subcmd, opts, 'shard', cb);
+    self.checkRequiredOption(subcmd, opts, 'zk', cb);
+
+    adm.clearPromote(opts, function (err) {
+        if (!err) {
+            console.log('Cleared promote request.');
+        }
+        cb(err);
+    });
+};
+ManateeAdm.prototype.do_clear_promote.options = [
+    commonOptions.help,
+    commonOptions.shard,
+    commonOptions.zk
+];
+ManateeAdm.prototype.do_clear_promote.help = ([
+    'Clear a promote request from cluster\'s state.',
+    '',
+    'Usage:',
+    '    {{name}} clear-promote [OPTIONS]',
+    '',
+    '{{options}}'
+].join('\n'));
+
 /**
  * Freezes a Manatee's cluster state so that it won't make any state
  * transitions.
@@ -1321,46 +1413,26 @@ function rowForPeer(columns, role, peer) {
 }
 
 /*
- * Given a postgres time duration object "lag", which may have properties like
- * "minutes", "seconds", and the like, return a human readable summary of the
- * duration, like "87m12s".  If the object is null, returns "-".  If the time is
- * not known, returns "?".
+ * Given a postgres time duration object "lag", return a human readable summary
+ * of the duration, like "87m12s".  If the lag object is null, returns "-".  If
+ * lagInSeconds() cannot determine the time, returns "?".
  */
 function pgDuration(lag) {
-    var minutes, seconds, key;
-
-    if (lag === null)
-        return ('-');
+    var seconds, minutes;
 
-    minutes = lag.minutes || 0;
-    seconds = lag.seconds || 0;
-    for (key in lag) {
-        switch (key) {
-        case 'days':
-            minutes += lag[key] * 24 * 60;
-            break;
+    seconds = adm.lagInSeconds(lag);
 
-        case 'hours':
-            minutes += lag[key] * 60;
-            break;
-
-        case 'minutes':
-        case 'seconds':
-            break;
+    if (seconds instanceof Error) {
+        return ('?');
+    }
 
-        default:
-            /*
-             * The node-pg-types code that parses postgres intervals implies
-             * that it could produce keys for "months" or "years", but
-             * empirically it doesn't seem to.  That's a relief (and probably
-             * not accidental), since the number of minutes in these units is
-             * not constant.  If we get something we don't know about, indicate
-             * this to the user.
-             */
-            return ('?');
-        }
+    if (seconds === null) {
+        return ('-');
     }
 
+    minutes = Math.floor(seconds / 60);
+    seconds = seconds % 60;
+
     return (sprintf('%dm%02ds', minutes, seconds));
 }
 
diff --git a/docs/man/manatee-adm.md b/docs/man/manatee-adm.md
index 442afce..6db6301 100644
--- a/docs/man/manatee-adm.md
+++ b/docs/man/manatee-adm.md
@@ -343,7 +343,80 @@ will be used.
     The zonename of the peer to remove.
 
 
+### promote [-n | --zonename ZONENAME] [-r | --role ROLE] [-i | --asyncIndex INDEX]
+
+Initiate a request to promote the specified peer to the next applicable position
+in the topology.  The primary is responsible for acting on a promotion request
+in most cases, with the only exception being where the sync is to be promoted
+which will result in deposing the primary, which subsequently will require a
+rebuild.  It's possible for a cluster to ignore our promotion request (see
+"clear-promote" for details).
+
+The impact of this request varies depending on what peer is promoted.
+Initiating a promotion request using this subcommand reduces the time it takes
+for a cluster to take action on a planned takeover but can still result in data
+path downtime.  The type of downtime can be expected to be the same as if the
+cluster experienced a takeover naturally and is outlined below.
+
+- sync promotion: deposed primary, read downtime for duration of async to sync
+  transition, write downtime for duration of sync to primary transition
+  (including time taken to establish synchronous replication)
+- first async promoted: no read downtime, write downtime for duration of async
+  transition to sync
+- other async promoted: no impact
+
+When promoting the sync or the async in a cluster with only one async, only
+`--role` and `--zonename` are required.  For clusters with more than one async,
+`--asyncIndex` is required in order to determine which async is to be promoted.
+These are required in order to prevent race conditions in the event that the
+cluster changes topology while we are composing our promotion request.
+
+Any warnings or errors reported by the cluster will result in a failed
+promotion request.  Any amount of time lag is considered a warning (see
+`pg-lag` from the "pg-status" section).  The acceptable amount of time lag is
+defined by the `--lagToIgnore` flag which has a default value of 5s.  It is
+possible to ignore these warnings interactively at a prompt, but the reported
+warnings should be carefully reviewed before ignoring them.
+
+Example usage:
+
+Requesting the promotion of the sync peer:
+
+    # manatee-adm promote --role=sync \
+        --zonename=4e27e2a9-2ff9-4c22-afd1-6cc9909c056c
+
+Requesting the promotion of the second async peer:
+
+    # manatee-adm promote --role=async \
+        --zonename=83f16f67-3c08-4022-8435-8bd0c65262eb \
+        --asyncIndex=1
 
+-n, --zonename `ZONENAME`
+    The zonename of the peer to promote.
+
+-r, --role `ROLE`
+    The current role of the peer to promote.
+
+-i, --asyncIndex `INDEX`
+    The zero-indexed position of the peer to be promoted's position in
+    the async chain (if applicable).
+
+-l, --lagToIgnore `SECONDS`
+    Ignore this number of seconds in replication lag on each peer (default is
+    5s)
+
+### clear-promote
+
+If a promotion request is not acted upon by the cluster and is still present in
+the cluster's state object then this subcommand can be used to clear it.
+
+An example of an ignored request would be where an operator has requested the
+promotion of the sync, but immediately after initiating the request the async
+was removed from the cluster.  In this case, the cluster has no replacement for
+the sync, so the request will be ignored.  The request will still be present in
+the cluster's state if this happens and will not affect the ongoing function of
+the cluster, but an operator might make use of this subcommand to clear the
+request in the interest of tidiness.
 
 ## UPGRADE COMMANDS
 
@@ -443,4 +516,4 @@ not.
 
 ## COPYRIGHT
 
-Copyright (c) 2015 Joyent Inc., All rights reserved.
+Copyright (c) 2019 Joyent Inc., All rights reserved.
diff --git a/lib/adm.js b/lib/adm.js
index dde4f63..31a24ce 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /**
@@ -31,6 +31,8 @@ var progbar = require('progbar');
 var prompt = require('prompt');
 var restify = require('restify');
 var sprintf = require('extsprintf').sprintf;
+var jsprim = require('jsprim');
+var util = require('util');
 var vasync = require('vasync');
 var VError = require('verror');
 var ZfsClient = require('./zfsClient');
@@ -49,6 +51,8 @@ exports.checkLock = checkLock;
 exports.freeze = freeze;
 exports.unfreeze = unfreeze;
 exports.history = history;
+exports.promote = promote;
+exports.clearPromote = clearPromote;
 exports.rebuild = rebuild;
 exports.reap = reap;
 exports.setOnwm = setOnwm;
@@ -57,6 +61,7 @@ exports.zkState = zkState;
 exports.stateBackfill = stateBackfill;
 exports.status = status;
 exports.loadClusterDetails = loadClusterDetails;
+exports.lagInSeconds = lagInSeconds;
 
 
 // Constants
@@ -1678,6 +1683,362 @@ function rebuild(opts, cb) {
 
 }
 
+/**
+ * Promote a given peer to the next applicable position in the cluster.
+ * Performs some initial validation against the cluster to ensure the safety of
+ * a promotion in this state, writes the intended promotion request into the
+ * cluster's state in ZooKeeper, then watches the cluster for the appropriate
+ * change.
+ */
+function promote(opts, callback) {
+    vasync.pipeline({ arg: opts, funcs: [
+        _createZkClient,
+        function getState(_, cb) {
+            /*
+             * The get/set cycle for state objects is handled differently to how
+             * some of the other parts of manatee-adm (e.g.
+             * ManateeClusterDetails) obtain state.  As such, we record the
+             * state from ZooKeeper (along with its stat object) in a separate
+             * place which we use later to write back into ZooKeeper.
+             */
+            var p = '/manatee/' + _.shard + '/state';
+            _.zkClient.getData(p, function (err, data, stat) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                _.originalState = JSON.parse(data.toString('utf8'));
+                _.stateStat = stat;
+                cb();
+            });
+        },
+        _getShards,
+        _getClusterStates,
+        function _verifyStates(_, cb) {
+            /*
+             * We want to make sure that the object we verify against is the
+             * same as the one we'll eventually write back to ZooKeeper.
+             */
+            if (!jsprim.deepEqual(_.state[_.shard], _.originalState)) {
+                cb(new VError('state has unexpectedly changed'));
+                return;
+            }
+            cb();
+        },
+        _addPostgresStatus,
+        _constructClusterDetails,
+        function validateInput(_, cb) {
+            if (typeof (_.lagToIgnore) !== 'number' || _.lagToIgnore < 0 ||
+                _.lagToIgnore % 1 !== 0) {
+                cb(new VError('lagToIgnore must be a non-negative integer ' +
+                    '(found "%s")', _.lagToIgnore));
+            }
+
+            if ([ 'sync', 'async' ].indexOf(_.role) === -1) {
+                cb(new VError('promotion of "%s" is invalid', _.role));
+                return;
+            }
+
+            _.currentRole = getRoleFromZkState(_.state[_.shard], _.zonename);
+            if (!_.currentRole) {
+                cb(new VError('"%s" not found in shard information',
+                    _.zonename));
+                return;
+            }
+
+            /*
+             * Only complain about a missing asyncIndex if the cluster has more
+             * than one async.
+             */
+            if (_.role === 'async' && (typeof (_.asyncIndex) !== 'number' ||
+                _.asyncIndex < 0)) {
+                if (_.state[_.shard].async.length === 1) {
+                    _.asyncIndex = 0;
+                } else {
+                    cb(new VError('promotion of "%s" ambiguous given the ' +
+                        'current state of the cluster (asyncIndex required)',
+                        _.role));
+                    return;
+                }
+            }
+
+            if (_.role !== 'async' && (_.asyncIndex >= 0)) {
+                cb(new VError('asyncIndex cannot be specified with role "%s"',
+                    _.role));
+                return;
+            }
+
+            _.currentAsyncIndex = null;
+            if (_.currentRole === 'async') {
+                _.state[_.shard].async.forEach(function (p, i) {
+                    if (_.zonename === p.zoneId) {
+                        _.currentAsyncIndex = i;
+                    }
+                });
+            }
+
+            if (_.currentRole !== _.role) {
+                cb(new VError('"%s" does not hold the role "%s" (it is ' +
+                    'currently "%s")',
+                    _.zonename, _.role, _.currentRole));
+                return;
+            }
+
+            if (_.role === 'async' && _.currentAsyncIndex !== _.asyncIndex) {
+                cb(new VError('"%s" is not position %d in the async chain ' +
+                    '(it is currently position %d)',
+                    _.zonename, _.asyncIndex, _.currentAsyncIndex));
+                return;
+            }
+
+            cb();
+        },
+        function validateState(_, cb) {
+            if (_.fullState.pgs_frozen) {
+                cb(new VError('cluster is frozen (reason: "%s")',
+                    _.fullState.pgs_freeze_reason));
+                return;
+            }
+
+            if (_.fullState.pgs_singleton) {
+                cb(new VError('cluster is in singleton mode'));
+                return;
+            }
+
+            /*
+             * It's possible to ignore the following warnings, so we collect
+             * them in one place in order to print them to the operator in a
+             * later prompt.
+             */
+            var warnings = [];
+
+            if (_.fullState.pgs_errors.length) {
+                warnings.push(new VError.WError(new VError.MultiError(
+                    _.fullState.pgs_errors), 'cluster has errors'));
+            }
+
+            if (_.fullState.pgs_warnings.length) {
+                warnings.push(new VError.WError(new VError.MultiError(
+                    _.fullState.pgs_warnings), 'cluster has warnings'));
+            }
+
+            /*
+             * We need to check the replication LSNs here to ensure we have
+             * genuine lag, as opposed to the cluster just not taking any
+             * writes.
+             */
+            var replErrs = [];
+            jsprim.forEachKey(_.fullState.pgs_peers, function (key, peer) {
+                var lag_in_seconds = lagInSeconds(peer.pgp_lag);
+                if (lag_in_seconds instanceof Error) {
+                    replErrs.push(new VError(lag_in_seconds, '"%s"',
+                        peer.pgp_label));
+                }
+                if (lag_in_seconds !== null && lag_in_seconds > _.lagToIgnore) {
+                    replErrs.push(new VError('"%s" has %ds of lag behind ' +
+                        'its upstream peer', peer.pgp_label, lag_in_seconds));
+                }
+            });
+            if (replErrs.length) {
+                warnings.push(new VError.WError(new VError.MultiError(replErrs),
+                    'cluster is exhibiting lag'));
+            }
+
+            _.clusterWarnings = warnings;
+
+            cb();
+        },
+        function promptForWarnings(_, cb) {
+            if (_.clusterWarnings.length === 0) {
+                cb();
+                return;
+            }
+            var msg = [
+                'The cluster is currently experiencing a number of warnings ' +
+                'and/or errors.  Review the following and determine if they ' +
+                'can be ignored.'
+            ].join('');
+            var promptMsg = 'Ignore warning(s)?';
+
+            console.error(msg);
+            printVErrorIter(new VError.MultiError(_.clusterWarnings), 2);
+
+            prompt.start({
+                message: promptMsg
+            });
+            prompt.get(['no'], function (err, result) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                if (result.no !== 'yes' && result.no !== 'y') {
+                    cb(new VError('aborting promotion due to warnings'));
+                    return;
+                }
+                /*
+                 * If we don't set this variable then the prompt library will
+                 * will not re-set the message in subsequent prompts.
+                 */
+                prompt.started = false;
+                cb();
+            });
+        },
+        function confirm(_, cb) {
+            var msg = [
+                'You are about to make changes to this cluster\'s topology.  ' +
+                'This operation could impact database service to multiple ' +
+                'members of the cluster, details of which can be found in ' +
+                'the manual.'
+            ].join('');
+            var promptMsg = sprintf('Promote this peer ("%s")?',
+                _.role);
+
+            console.error(msg);
+            prompt.start({
+                message: promptMsg
+            });
+            prompt.get(['no'], function (err, result) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                if (result.no !== 'yes' && result.no !== 'y') {
+                    cb(new VError('aborting promotion due to user command'));
+                    return;
+                }
+                cb();
+            });
+        },
+        function buildPromoteState(_, cb) {
+            _.promote = {};
+            if (_.role === 'sync') {
+                _.promote.id = _.state[_.shard][_.role].id;
+            } else {
+                _.promote.id = _.state[_.shard].async[_.asyncIndex].id;
+                _.promote.asyncIndex = _.asyncIndex;
+            }
+            _.promote.role = _.role;
+            _.promote.generation = _.state[_.shard].generation;
+            _.promote.expireTime =
+                jsprim.iso8601(new Date().getTime() + (30 * 1000));
+
+            cb();
+        },
+        function setPromoteState(_, cb) {
+            _.state = _.originalState;
+            _.state.promote = _.promote;
+            cb();
+        },
+        _putState,
+        function watchClusterState(_, cb) {
+            /*
+             * Watch for the removal of the "promote" object from ZooKeeper, and
+             * for a change in position in the cluster of the promoted peer.  If
+             * the promoted peer doesn't see a role change within 10s, inform
+             * the operator.  Also inform if no changes are made within the
+             * expireTime of the promote object.
+             *
+             * This could do with being much more comprehensive, but for now
+             * it's enough to tell if the state machine has either acted upon or
+             * ignored our promotion request.
+             */
+            console.log('Promotion requested.  Watching until request has ' +
+                'been acknowleged and topology has changed.');
+
+            function watch() {
+                vasync.pipeline({ arg: _, funcs: [
+                    _getShards,
+                    _getClusterStates,
+                    _addPostgresStatus,
+                    _constructClusterDetails
+                ]}, function (err, res) {
+                    if (err) {
+                        callback(err);
+                        return;
+                    }
+
+                    var now = new Date();
+                    var promoteObjectRemoved = false;
+                    var roleChanged = false;
+
+                    if (!_.state[_.shard].promote) {
+                        promoteObjectRemoved = true;
+                    }
+
+                    if (_.promote.role === 'async') {
+                        if (_.fullState['pgs_asyncs'][
+                            _.promote.asyncIndex] !== _.promote.id) {
+                            roleChanged = true;
+                        }
+                    } else if (_.fullState['pgs_' + _.promote.role] !==
+                        _.promote.id) {
+                        roleChanged = true;
+                    }
+
+                    var expireTime = new Date(_.promote.expireTime).getTime();
+
+                    if (promoteObjectRemoved && roleChanged) {
+                        callback();
+                    } else if (now.getTime() > expireTime) {
+                        console.error(sprintf('Warning: Topology has not ' +
+                            'changed within the expected deadline ("%s")',
+                            _.promote.expireTime));
+                        if (!promoteObjectRemoved) {
+                            console.error(sprintf(' - Cluster has ignored ' +
+                                'our request (see "manatee-adm ' +
+                                'clear-promote")'));
+                        }
+                        if (!roleChanged) {
+                            console.error(sprintf(' - Role has not changed'));
+                        }
+                        console.error('Check logs for manatee-sitter ' +
+                            'service and the manual for more information.');
+                    } else {
+                        setTimeout(watch, 1000);
+                    }
+                });
+            }
+            watch();
+        }
+    ]}, function (err) {
+        _closeZkClient(opts);
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback();
+    });
+}
+
+/*
+ * Removes the "promote" object from the cluster's state.
+ */
+function clearPromote(opts, callback) {
+    vasync.pipeline({ arg: opts, funcs: [
+        _createZkClient,
+        _getState,
+        function _clearPromote(_, cb) {
+            if (!_.state.promote) {
+                cb(new VError('cluster has no outstanding promotion request'));
+                return;
+            }
+            delete (_.state.promote);
+            cb();
+        },
+        _putState
+    ]}, function (err) {
+        _closeZkClient(opts);
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback();
+    });
+}
+
 /**
  * @param {Object} opts The options object.
  * @param {String} opts.zk The zookeeper URL.
@@ -1845,6 +2206,7 @@ function queryPg(url, _query, callback) {
     var client = new pg.Client(url);
     client.connect(function (err) {
         if (err) {
+            LOG.debug(err, 'error connecting to postgres');
             return callback(err);
         }
         LOG.debug({
@@ -1857,6 +2219,11 @@ function queryPg(url, _query, callback) {
             return callback(err2, result);
         });
     });
+    client.on('error', function (err) {
+        LOG.debug(err, 'error from postgres client');
+        client.end();
+        callback(err);
+    });
 }
 
 function oldHistoryToObj(fNode) {
@@ -2060,3 +2427,115 @@ function transformBackupUrl(zkNode) {
     var data = zkNode.split('-')[0].split(':');
     return 'http://' + data[0] + ':' + data[2];
 }
+
+/*
+ * Given a ZK state object and zoneId, return the role of the requested zoneId.
+ * If the zoneId is not found to be a member of the cluster, returns undefined.
+ */
+function getRoleFromZkState(state, zoneId) {
+    assert.object(state, 'state');
+    assert.string(zoneId, 'zoneId');
+
+    var role;
+
+    if (state.primary && state.primary.zoneId === zoneId) {
+        role = 'primary';
+    } else if (state.sync && state.sync.zoneId === zoneId) {
+        role = 'sync';
+    } else {
+        state.async.forEach(function (p) {
+            if (p.zoneId === zoneId) {
+                role = 'async';
+            }
+        });
+    }
+
+    if (!role) {
+        state.deposed.forEach(function (p) {
+            if (p.zoneId === zoneId) {
+                role = 'deposed';
+            }
+        });
+    }
+
+    return (role);
+}
+
+/*
+ * Given an Error with nested causes (by way of VError), this function will
+ * iterate over the causes up to a depth of maxDepth, nesting and printing
+ * their messages as it goes.
+ */
+function printVErrorIter(error, maxDepth, currentDepth) {
+    assert.ok(error instanceof Error, 'error must be an instance of Error');
+    assert.number(maxDepth, 'maxDepth');
+    assert.optionalNumber(currentDepth, 'currentDepth');
+
+    var indent;
+
+    if (!currentDepth) {
+        currentDepth = 0;
+    }
+
+    if (currentDepth >= maxDepth) {
+        return;
+    }
+
+    indent = '';
+    for (var i = 0; i < currentDepth; i++) {
+        indent += '  ';
+    }
+
+    currentDepth++;
+    VError.errorForEach(error, function (e) {
+        console.error(indent, '-', e.message);
+        if (e.cause()) {
+            printVErrorIter(e.cause(), maxDepth, currentDepth);
+        }
+    });
+}
+
+/*
+ * Given a ManateeClusterDetails peer's pgp_lag object or lack thereof, report
+ * the lag in seconds.  Returns null if no lag object supplied.  Returns an
+ * error if we're not able to determine the number of seconds based on the
+ * object's properties.
+ */
+function lagInSeconds(lag) {
+    assert.optionalObject(lag);
+    var seconds, unit;
+
+    if (!lag) {
+        return (null);
+    }
+
+    seconds = lag.seconds || 0;
+
+    for (unit in lag) {
+        switch (unit) {
+            case 'days':
+                seconds += lag[unit] * 24 * 60 * 60;
+                break;
+            case 'hours':
+                seconds += lag[unit] * 60 * 60;
+                break;
+            case 'minutes':
+                seconds += lag[unit] * 60;
+                break;
+            case 'seconds':
+                break;
+            default:
+                /*
+                 * The node-pg-types code that parses postgres intervals implies
+                 * that it could produce keys for "months" or "years", but
+                 * empirically it doesn't seem to.  That's a relief (and
+                 * probably not accidental), since the number of minutes in
+                 * these units is not constant.  If we get something we don't
+                 * know about, return an error.
+                 */
+                return (new VError('unable to determine lag'));
+        }
+    }
+
+    return (seconds);
+}
diff --git a/man/man1/manatee-adm.1 b/man/man1/manatee-adm.1
index fc757dc..77d14f2 100644
--- a/man/man1/manatee-adm.1
+++ b/man/man1/manatee-adm.1
@@ -177,6 +177,7 @@ ROLE     PEER     PG   REPL  SENT       WRITE      FLUSH      REPLAY     LAG
 primary  09957297 ok   sync  0/79E88D28 0/79E88D28 0/79E88D28 0/79E884B0 \-     
 sync     a376df2b ok   \-     \-          \-          \-          \-          \-     
 async    bb348824 fail \-     \-          \-          \-          \-          \-     
+
 warning: peer "a376df2b": downstream replication peer not connected
 .fi
 .RE
@@ -190,6 +191,7 @@ ROLE     PEER     PG   REPL  SENT       WRITE      FLUSH      REPLAY     LAG
 primary  bb348824 fail \-     \-          \-          \-          \-          \-     
 sync     09957297 ok   async 0/79DE6478 0/79DE6478 0/79DE6478 0/79DE6478 \-     
 async    a376df2b ok   \-     \-          \-          \-          \-          0m33s 
+
 error: cannot query postgres on primary: peer "bb348824": ECONNREFUSED
 error: peer "bb348824": downstream replication peer not connected
 .fi
@@ -381,6 +383,91 @@ will be used.
 .PP
 \-n, \-\-zonename \fB\fCZONENAME\fR
     The zonename of the peer to remove.
+.SS promote [\-n | \-\-zonename ZONENAME] [\-r | \-\-role ROLE] [\-i | \-\-asyncIndex INDEX]
+.PP
+Initiate a request to promote the specified peer to the next applicable position
+in the topology.  The primary is responsible for acting on a promotion request
+in most cases, with the only exception being where the sync is to be promoted
+which will result in deposing the primary, which subsequently will require a
+rebuild.  It's possible for a cluster to ignore our promotion request (see
+"clear\-promote" for details).
+.PP
+The impact of this request varies depending on what peer is promoted.
+Initiating a promotion request using this subcommand reduces the time it takes
+for a cluster to take action on a planned takeover but can still result in data
+path downtime.  The type of downtime can be expected to be the same as if the
+cluster experienced a takeover naturally and is outlined below.
+.RS
+.IP \(bu 2
+sync promotion: deposed primary, read downtime for duration of async to sync
+transition, write downtime for duration of sync to primary transition
+(including time taken to establish synchronous replication)
+.IP \(bu 2
+first async promoted: no read downtime, write downtime for duration of async
+transition to sync
+.IP \(bu 2
+other async promoted: no impact
+.RE
+.PP
+When promoting the sync or the async in a cluster with only one async, only
+\fB\fC\-\-role\fR and \fB\fC\-\-zonename\fR are required.  For clusters with more than one async,
+\fB\fC\-\-asyncIndex\fR is required in order to determine which async is to be promoted.
+These are required in order to prevent race conditions in the event that the
+cluster changes topology while we are composing our promotion request.
+.PP
+Any warnings or errors reported by the cluster will result in a failed
+promotion request.  Any amount of time lag is considered a warning (see
+\fB\fCpg\-lag\fR from the "pg\-status" section).  The acceptable amount of time lag is
+defined by the \fB\fC\-\-lagToIgnore\fR flag which has a default value of 5s.  It is
+possible to ignore these warnings interactively at a prompt, but the reported
+warnings should be carefully reviewed before ignoring them.
+.PP
+Example usage:
+.PP
+Requesting the promotion of the sync peer:
+.PP
+.RS
+.nf
+# manatee\-adm promote \-\-role=sync \\
+    \-\-zonename=4e27e2a9\-2ff9\-4c22\-afd1\-6cc9909c056c
+.fi
+.RE
+.PP
+Requesting the promotion of the second async peer:
+.PP
+.RS
+.nf
+# manatee\-adm promote \-\-role=async \\
+    \-\-zonename=83f16f67\-3c08\-4022\-8435\-8bd0c65262eb \\
+    \-\-asyncIndex=1
+.fi
+.RE
+.PP
+\-n, \-\-zonename \fB\fCZONENAME\fR
+    The zonename of the peer to promote.
+.PP
+\-r, \-\-role \fB\fCROLE\fR
+    The current role of the peer to promote.
+.PP
+\-i, \-\-asyncIndex \fB\fCINDEX\fR
+    The zero\-indexed position of the peer to be promoted's position in
+    the async chain (if applicable).
+.PP
+\-l, \-\-lagToIgnore \fB\fCSECONDS\fR
+    Ignore this number of seconds in replication lag on each peer (default is
+    5s)
+.SS clear\-promote
+.PP
+If a promotion request is not acted upon by the cluster and is still present in
+the cluster's state object then this subcommand can be used to clear it.
+.PP
+An example of an ignored request would be where an operator has requested the
+promotion of the sync, but immediately after initiating the request the async
+was removed from the cluster.  In this case, the cluster has no replacement for
+the sync, so the request will be ignored.  The request will still be present in
+the cluster's state if this happens and will not affect the ongoing function of
+the cluster, but an operator might make use of this subcommand to clear the
+request in the interest of tidiness.
 .SH UPGRADE COMMANDS
 .SS state\-backfill
 .PP
@@ -390,8 +477,7 @@ documentation on migration for the appropriate use of this tool.
 .PP
 These commands fetch or modify internal data structures and should only be used
 by developers or as part of documented procedures.
-.SS set\-onwm \-y | \-\-ignorePrompts
-\[la]-m | --mode (on | off)\[ra]
+.SS set\-onwm \-y | \-\-ignorePrompts \[la]-m | --mode (on | off)\[ra]
 .PP
 Toggles the singleton ("one\-node\-write") mode property of the cluster state.
 This is generally not required, and is not the normal way to enable
@@ -465,4 +551,4 @@ not.
     Sets the node\-bunyan logging level. Defaults to fatal.
 .SH COPYRIGHT
 .PP
-Copyright (c) 2015 Joyent Inc., All rights reserved.
+Copyright (c) 2019 Joyent Inc., All rights reserved.
diff --git a/package.json b/package.json
index 6260ab6..8629ba1 100644
--- a/package.json
+++ b/package.json
@@ -28,7 +28,7 @@
         "iniparser": "1.0.5",
         "forkexec": "1.1.0",
         "jsprim": "2.0.0",
-        "manatee-state-machine": "git+https://github.com/joyent/manatee-state-machine.git#master",
+        "manatee-state-machine": "git+https://github.com/joyent/manatee-state-machine.git#ff78e7596746ba8ff6b75784270c71ddaac008c9",
         "manta": "1.2.6",
         "node-uuid": "1.4.1",
         "joyent-zookeeper-client": "0.2.3",
diff --git a/test/tst.manateeAdmUsage.js b/test/tst.manateeAdmUsage.js
index 1251c37..b8b93a4 100644
--- a/test/tst.manateeAdmUsage.js
+++ b/test/tst.manateeAdmUsage.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -132,6 +132,14 @@ var subcmds = {
     'reap': {
         'required': [ 'shard', 'zk' ],
         'destructive': true
+    },
+    'promote': {
+        'required': [ 'role', 'zonename', 'shard', 'zk' ],
+        'destructive': true
+    },
+    'clear-promote': {
+        'required': [ 'shard', 'zk' ],
+        'destructive': true
     }
 };
 
@@ -164,7 +172,9 @@ var requiredOptionEnvVars = {
     'config': null,
     'mode': null,
     'path': null,
-    'reason': null
+    'reason': null,
+    'role': null,
+    'zonename': null
 };
 
 var testsOk = 0;            /* count of tests that passed */
-- 
2.21.0

