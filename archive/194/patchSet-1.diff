From f0a3709fd398da5c15b52523915bde6e7d7e0418 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Tue, 2 Aug 2016 15:09:30 -0700
Subject: [PATCH] DOCKER-774 zfs_snapshot_tar: docker build/commit hardlinks
 are not added to generated image DOCKER-751 docker build: zfs_snapshot_tar
 failure for files with link changes

---
 cmd.c | 523 ++++++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 402 insertions(+), 121 deletions(-)

diff --git a/cmd.c b/cmd.c
index e8f7e06..fe8d3cb 100644
--- a/cmd.c
+++ b/cmd.c
@@ -37,6 +37,7 @@
 #define	CMD_ZFS		"/sbin/zfs"
 
 typedef struct diff_ent diff_ent_t;
+typedef struct snaptar snaptar_t;
 
 struct diff_ent {
 	char *de_name;
@@ -46,6 +47,13 @@ struct diff_ent {
 	diff_ent_t *de_parent;
 };
 
+typedef struct hardlink_ent {
+	char *hle_path;
+	ino_t hle_inode;
+	dev_t hle_device;
+	list_node_t hle_link;
+} hardlink_ent_t;
+
 typedef enum snaptar_flags {
 	SNTR_F_FAILED = 0x01,
 	SNTR_F_IGNORE_SPECIALS = 0x02,
@@ -63,30 +71,92 @@ typedef enum snaptar_param {
 } snaptar_param_t;
 
 typedef struct {
+	snaptar_t *stss_owner;
+	char *stss_dataset;
+	char *stss_snapshot;
+	char *stss_mountpoint;
+	int stss_fd;
+	dev_t stss_device;
+} snaptar_snapshot_t;
+
+#define	NSNAPSHOTS	2
+struct snaptar {
 	snaptar_flags_t st_flags;
 
 	char *st_root_prefix;
-	char *st_dataset0;
-	char *st_dataset1;
-	char *st_snap0;
-	char *st_snap1;
 	strlist_t *st_exclude_paths;
 
-	char *st_mountpoint;
+	/*
+	 * This program operates on either one or two ZFS snapshots.  In all
+	 * cases, the snapshot to archive is in this array at index 1; if
+	 * there is a "parent" snapshot for an incremental archive, that
+	 * snapshot will be at index 0.
+	 */
+	snaptar_snapshot_t st_snapshots[NSNAPSHOTS];
 
 	diff_ent_t st_root;
 
-	int st_snapshot_fd;
 	custr_t *st_errstr;
 
 	struct archive *st_archive;
 	struct archive_entry *st_archive_entry;
-} snaptar_t;
 
+	list_t st_hardlinks;
+};
+
+/*
+ * Function pointer types:
+ */
 typedef int ent_enum_cb(snaptar_t *, const char *, int, struct stat *,
-    const char *);
+    const char *, void *);
 typedef int walk_dir_func(snaptar_t *, ent_enum_cb *);
 
+/*
+ * Forward declarations:
+ */
+static int run_readdir_impl(snaptar_t *, int, int, const char *, ent_enum_cb *,
+    boolean_t, void *);
+static int record_path_impl(snaptar_t *, const char *);
+
+
+static hardlink_ent_t *
+hardlinks_lookup(snaptar_t *st, struct stat *statp)
+{
+	hardlink_ent_t *hle;
+
+	for (hle = list_head(&st->st_hardlinks); hle != NULL;
+	    hle = list_next(&st->st_hardlinks, hle)) {
+		if (hle->hle_inode == statp->st_ino &&
+		    hle->hle_device == statp->st_dev) {
+			return (hle);
+		}
+	}
+
+	return (NULL);
+}
+
+static void
+hardlinks_add(snaptar_t *st, const char *path, struct stat *statp)
+{
+	hardlink_ent_t *hle;
+
+	if ((hle = hardlinks_lookup(st, statp)) != NULL) {
+		errx(1, "duplicate hardlink entry %s, %s\n", path,
+		    hle->hle_path);
+	}
+
+	if ((hle = calloc(1, sizeof (*hle))) == NULL) {
+		err(1, "calloc");
+	}
+	if ((hle->hle_path = strdup(path)) == NULL) {
+		err(1, "strdup");
+	}
+	hle->hle_inode = statp->st_ino;
+	hle->hle_device = statp->st_dev;
+
+	list_insert_tail(&st->st_hardlinks, hle);
+}
+
 void
 whiteout_path(const char *path, char **outp)
 {
@@ -121,17 +191,19 @@ done:
 }
 
 static int
-make_fullsnap(const char *dataset, const char *snap, char **fullsnap)
+make_fullsnap(snaptar_snapshot_t *stss, char **fullsnap)
 {
-	VERIFY(dataset != NULL);
-	VERIFY(snap != NULL);
+	VERIFY3P(stss->stss_dataset, !=, NULL);
+	VERIFY3P(stss->stss_snapshot, !=, NULL);
 
-	if (strchr(dataset, '@') != NULL || strchr(snap, '@') != NULL) {
+	if (strchr(stss->stss_dataset, '@') != NULL ||
+	    strchr(stss->stss_snapshot, '@') != NULL) {
 		errno = EINVAL;
 		return (-1);
 	}
 
-	if (asprintf(fullsnap, "%s@%s", dataset, snap) < 0) {
+	if (asprintf(fullsnap, "%s@%s", stss->stss_dataset,
+	    stss->stss_snapshot) < 0) {
 		return (-1);
 	}
 
@@ -149,7 +221,11 @@ snaptar_alloc(snaptar_t **stp, char *errstr, size_t errlen)
 		return (-1);
 	}
 
-	st->st_snapshot_fd = -1;
+	for (int i = 0; i < NSNAPSHOTS; i++) {
+		st->st_snapshots[i].stss_owner = st;
+		st->st_snapshots[i].stss_fd = -1;
+	}
+
 	st->st_flags |= SNTR_F_IGNORE_SPECIALS;
 
 	if (strlist_alloc(&st->st_exclude_paths, 0) != 0) {
@@ -160,12 +236,15 @@ snaptar_alloc(snaptar_t **stp, char *errstr, size_t errlen)
 		return (-1);
 	}
 
+	list_create(&st->st_hardlinks, sizeof (hardlink_ent_t),
+	    offsetof(hardlink_ent_t, hle_link));
+
 	*stp = st;
 	return (0);
 }
 
 static int
-copy_snapshot_string(const char *src, char **dsetp, char **snapp)
+copy_snapshot_string(const char *src, snaptar_snapshot_t *stss)
 {
 	char *dset = NULL, *snap = NULL;
 	const char *atp;
@@ -192,10 +271,10 @@ copy_snapshot_string(const char *src, char **dsetp, char **snapp)
 		return (-1);
 	}
 
-	free(*dsetp);
-	free(*snapp);
-	*dsetp = dset;
-	*snapp = snap;
+	free(stss->stss_dataset);
+	free(stss->stss_snapshot);
+	stss->stss_dataset = dset;
+	stss->stss_snapshot = snap;
 	return (0);
 }
 
@@ -208,9 +287,7 @@ copy_string(const char *src, char **dstp)
 		return (-1);
 	}
 
-	if (*dstp != NULL) {
-		free(*dstp);
-	}
+	free(*dstp);
 	*dstp = dst;
 	return (0);
 }
@@ -254,12 +331,10 @@ snaptar_param_set(snaptar_t *st, snaptar_param_t p, const char *val)
 		return (copy_string(val, &st->st_root_prefix));
 
 	case SNTR_P_EXPLICIT:
-		return (copy_snapshot_string(val, &st->st_dataset1,
-		    &st->st_snap1));
+		return (copy_snapshot_string(val, &st->st_snapshots[1]));
 
 	case SNTR_P_EXPLICIT_PARENT:
-		return (copy_snapshot_string(val, &st->st_dataset0,
-		    &st->st_snap0));
+		return (copy_snapshot_string(val, &st->st_snapshots[0]));
 
 	case SNTR_P_DATASET:
 		/*
@@ -268,16 +343,16 @@ snaptar_param_set(snaptar_t *st, snaptar_param_t p, const char *val)
 		 * dataset.  To preserve this behaviour, we copy that
 		 * argument into both st_dataset0 and st_dataset1.
 		 */
-		if (copy_string(val, &st->st_dataset0) != 0) {
+		if (copy_string(val, &st->st_snapshots[0].stss_dataset) != 0) {
 			return (-1);
 		}
-		return (copy_string(val, &st->st_dataset1));
+		return (copy_string(val, &st->st_snapshots[1].stss_dataset));
 
 	case SNTR_P_SNAPSHOT:
-		return (copy_string(val, &st->st_snap1));
+		return (copy_string(val, &st->st_snapshots[1].stss_snapshot));
 
 	case SNTR_P_SNAPSHOT_PARENT:
-		return (copy_string(val, &st->st_snap0));
+		return (copy_string(val, &st->st_snapshots[0].stss_snapshot));
 
 	case SNTR_P_EXCLUDE_PATH:
 		if (!is_valid_path_param("exclude paths", val, len)) {
@@ -306,24 +381,40 @@ snaptar_free_diffent(diff_ent_t *dir, boolean_t free_this)
 		free(dir);
 }
 
+static void
+snaptar_fini_snapshot(snaptar_t *st, snaptar_snapshot_t *stss)
+{
+	VERIFY3P(st, ==, stss->stss_owner);
+
+	free(stss->stss_mountpoint);
+	free(stss->stss_dataset);
+	free(stss->stss_snapshot);
+	if (stss->stss_fd != -1) {
+		VERIFY0(close(stss->stss_fd));
+	}
+}
+
 void
 snaptar_fini(snaptar_t *st)
 {
-	if (st->st_snapshot_fd != -1) {
-		VERIFY0(close(st->st_snapshot_fd));
+	hardlink_ent_t *hle;
+
+	while ((hle = list_remove_tail(&st->st_hardlinks)) != NULL) {
+		free(hle->hle_path);
+		free(hle);
+	}
+	list_destroy(&st->st_hardlinks);
+
+	for (int i = 0; i < NSNAPSHOTS; i++) {
+		snaptar_fini_snapshot(st, &st->st_snapshots[i]);
 	}
 
-	free(st->st_mountpoint);
-	free(st->st_dataset0);
-	free(st->st_dataset1);
-	free(st->st_snap0);
-	free(st->st_snap1);
 	strlist_free(st->st_exclude_paths);
 	custr_free(st->st_errstr);
 	snaptar_free_diffent(&st->st_root, B_FALSE);
 
-	VERIFY(st->st_archive == NULL);
-	VERIFY(st->st_archive_entry == NULL);
+	VERIFY3P(st->st_archive, ==, NULL);
+	VERIFY3P(st->st_archive_entry, ==, NULL);
 
 	free(st);
 }
@@ -411,7 +502,7 @@ unescape_zfs_diff_path(const char *input, custr_t *unescaped)
 				goto invalid;
 			}
 
-			VERIFY(custr_len(seq) < 5);
+			VERIFY3U(custr_len(seq), <, 5);
 			if (custr_len(seq) == 4) {
 				long val;
 
@@ -453,7 +544,7 @@ unescape_zfs_diff_path(const char *input, custr_t *unescaped)
 		}
 
 		if (*p == '\0') {
-			VERIFY(custr_len(seq) == 0);
+			VERIFY3U(custr_len(seq), ==, 0);
 			ret = 0;
 			goto out;
 		}
@@ -473,18 +564,133 @@ out:
 	return (ret);
 }
 
+struct check_links_arg {
+	int cla_otherfd;
+	dev_t cla_otherdev;
+};
+
 static int
-record_path(snaptar_t *st, const char *path)
+check_links_cb(snaptar_t *st, const char *path, int level,
+    struct stat *statp, const char *sympath, void *arg)
+{
+	struct stat sto;
+	struct check_links_arg *cla = arg;
+
+	if (!S_ISREG(statp->st_mode)) {
+		return (0);
+	}
+
+	if (cla->cla_otherfd == -1) {
+		/*
+		 * If the other directory does not exist at all, then we
+		 * must check _every_ entry.
+		 */
+		record_path_impl(st, path);
+		return (0);
+	}
+
+	if (fstatat(cla->cla_otherfd, path, &sto, AT_SYMLINK_NOFOLLOW) != 0) {
+		if (errno == ENOENT) {
+			record_path_impl(st, path);
+			return (0);
+		}
+
+		err(1, "fstatat(%s)", path);
+	}
+
+	if (sto.st_dev != cla->cla_otherdev) {
+		errx(1, "file %s st_dev %lu outside of expected file system "
+		    "(%ld)", path, sto.st_dev, cla->cla_otherdev);
+	}
+
+	if (statp->st_ino != sto.st_ino) {
+		record_path_impl(st, path);
+	}
+
+	return (0);
+}
+
+static void
+check_links_pre(snaptar_t *st, const char *path, boolean_t *exists,
+    struct stat *sta, int this)
+{
+	VERIFY(this == 0 || this == 1);
+
+	if (fstatat(st->st_snapshots[this].stss_fd, path, &sta[this],
+	    AT_SYMLINK_NOFOLLOW) != 0) {
+		if (errno == ENOENT) {
+			exists[this] = B_FALSE;
+			return;
+		}
+		err(1, "fstatat(%s)", path);
+	}
+
+	if (!S_ISDIR(sta[this].st_mode)) {
+		exists[this] = B_FALSE;
+		return;
+	}
+
+	if (sta[this].st_dev != st->st_snapshots[this].stss_device) {
+		errx(1, "dir %s in snap %s st_dev %lu outside of expected %lu",
+		    path, st->st_snapshots[this].stss_snapshot,
+		    sta[this].st_dev, st->st_snapshots[this].stss_device);
+	}
+
+	exists[this] = B_TRUE;
+}
+
+static void
+check_links_post(snaptar_t *st, const char *path, boolean_t *exists,
+    struct stat *sta, int this, int that)
+{
+	int fd;
+	struct check_links_arg cla = { 0 };
+
+	VERIFY3S(this, !=, that);
+	VERIFY(this == 0 || this == 1);
+	VERIFY(that == 0 || that == 1);
+
+	if (!exists[this]) {
+		return;
+	}
+
+	if ((fd = openat(st->st_snapshots[this].stss_fd, path, O_RDONLY |
+	    O_LARGEFILE)) == -1) {
+		err(1, "openat(%s)", path);
+	}
+
+	if (exists[that]) {
+		cla.cla_otherfd = st->st_snapshots[that].stss_fd;
+		cla.cla_otherdev = sta[that].st_dev;
+	} else {
+		cla.cla_otherfd = -1;
+	}
+
+	run_readdir_impl(st, fd, 1, path, check_links_cb, B_FALSE, &cla);
+}
+
+static void
+check_links(snaptar_t *st, const char *path)
+{
+	boolean_t exists[NSNAPSHOTS];
+	struct stat sta[NSNAPSHOTS];
+
+	check_links_pre(st, path, exists, sta, 0);
+	check_links_pre(st, path, exists, sta, 1);
+
+	check_links_post(st, path, exists, sta, 0, 1);
+	check_links_post(st, path, exists, sta, 1, 0);
+}
+
+static int
+record_path(snaptar_t *st, const char *path, boolean_t do_check_links)
 {
-	strlist_t *sl = NULL;
-	custr_t *cu = NULL;
 	custr_t *unescaped = NULL;
-	diff_ent_t *de = &st->st_root;
-	const char *start;
+	const char *start, *mountpoint;
+	int rv;
 
-	if (strlist_alloc(&sl, 0) != 0 || custr_alloc(&cu) != 0 ||
-	    custr_alloc(&unescaped) != 0) {
-		err(1, "strlist_alloc/custr_alloc");
+	if (custr_alloc(&unescaped) != 0) {
+		err(1, "custr_alloc");
 	}
 
 	/*
@@ -496,12 +702,13 @@ record_path(snaptar_t *st, const char *path)
 	}
 	start = custr_cstr(unescaped);
 
-	if (st->st_mountpoint != NULL) {
-		size_t len = strlen(st->st_mountpoint);
+	if ((mountpoint = st->st_snapshots[1].stss_mountpoint) != NULL) {
+		size_t len = strlen(mountpoint);
 
-		if (strncmp(start, st->st_mountpoint, len) != 0) {
+		if (strncmp(start, mountpoint, len) != 0) {
 			errno = EINVAL;
-			return (-1);
+			rv = -1;
+			goto done;
 		}
 
 		start += len;
@@ -525,16 +732,47 @@ record_path(snaptar_t *st, const char *path)
 		free(x);
 
 		if (!match) {
-			return (0);
+			/*
+			 * While we want to skip changes on the root
+			 * directory itself, we still need to check for
+			 * link changes in entries in the root directory.
+			 */
+			if (do_check_links && strcmp(start,
+			    st->st_root_prefix) == 0) {
+				check_links(st, start);
+			}
+			rv = 0;
+			goto done;
 		}
 	}
 
+	if (do_check_links) {
+		check_links(st, start);
+	}
+
+	rv = record_path_impl(st, start);
+
+done:
+	custr_free(unescaped);
+	return (rv);
+}
+
+static int
+record_path_impl(snaptar_t *st, const char *path)
+{
+	custr_t *cu = NULL;
+	strlist_t *sl = NULL;
+
+	if (strlist_alloc(&sl, 0) != 0 || custr_alloc(&cu) != 0) {
+		err(1, "strlist_alloc/custr_alloc");
+	}
+
 	/*
 	 * Split a path into components, e.g.:
 	 *   a/b/c/d/  -->   "a", "b", "c", "d"
 	 *   /e/f///g  -->   "e", "f", "g"
 	 */
-	for (const char *p = start; ; p++) {
+	for (const char *p = path; ; p++) {
 		if (*p != '\0' && *p != '/') {
 			if (custr_appendc(cu, *p) != 0) {
 				err(1, "custr_appendc");
@@ -558,19 +796,20 @@ record_path(snaptar_t *st, const char *path)
 	 * Ensure this path, and all parent directories, exist in the
 	 * tree.
 	 */
+	diff_ent_t *de = &st->st_root;
 	for (unsigned i = 0; i < strlist_contig_count(sl); i++) {
 		if (get_child(de, strlist_get(sl, i), &de) != 0) {
 			err(1, "get_child");
 		}
 	}
-	VERIFY(de != NULL);
+	VERIFY3P(de, !=, NULL);
 
 	strlist_free(sl);
 	custr_free(cu);
-	custr_free(unescaped);
 	return (0);
 }
 
+
 int
 split_on(const char *line, char delim, strlist_t *sl)
 {
@@ -667,12 +906,14 @@ run_zfs_diff_cb(const char *line, void *arg0)
 	    strlist_match(sl, 0, "+") ||
 	    strlist_match(sl, 0, "M")) {
 		/*
-		 * Simple entry (removed/created/modified).
+		 * Simple entry (removed/created/modified).  May have a link
+		 * count modification in an optional fourth column.
 		 */
-		if (strlist_contig_count(sl) != 3) {
+		if (strlist_contig_count(sl) != 3 &&
+		    strlist_contig_count(sl) != 4) {
 			errx_unexpected_zfs_diff(sl);
 		}
-		VERIFY0(record_path(st, strlist_get(sl, 2)));
+		VERIFY0(record_path(st, strlist_get(sl, 2), B_TRUE));
 
 	} else if (strlist_match(sl, 0, "R")) {
 		/*
@@ -681,8 +922,8 @@ run_zfs_diff_cb(const char *line, void *arg0)
 		if (strlist_contig_count(sl) != 4) {
 			errx_unexpected_zfs_diff(sl);
 		}
-		VERIFY0(record_path(st, strlist_get(sl, 2)));
-		VERIFY0(record_path(st, strlist_get(sl, 3)));
+		VERIFY0(record_path(st, strlist_get(sl, 2), B_FALSE));
+		VERIFY0(record_path(st, strlist_get(sl, 3), B_FALSE));
 
 	} else {
 		errx_unexpected_zfs_diff(sl);
@@ -698,8 +939,8 @@ run_zfs_diff(snaptar_t *st)
 	char *fullsnap1 = NULL;
 	char errbuf[512];
 
-	VERIFY0(make_fullsnap(st->st_dataset0, st->st_snap0, &fullsnap0));
-	VERIFY0(make_fullsnap(st->st_dataset1, st->st_snap1, &fullsnap1));
+	VERIFY0(make_fullsnap(&st->st_snapshots[0], &fullsnap0));
+	VERIFY0(make_fullsnap(&st->st_snapshots[1], &fullsnap1));
 
 	char *const argv[] = {
 		CMD_ZFS,
@@ -731,7 +972,7 @@ run_zfs_diff(snaptar_t *st)
 
 static int
 run_readdir_impl(snaptar_t *st, int dirfd, int level, const char *parent,
-    ent_enum_cb *cbfunc)
+    ent_enum_cb *cbfunc, boolean_t recurse, void *arg)
 {
 	DIR *dir;
 	struct dirent *d;
@@ -767,7 +1008,7 @@ run_readdir_impl(snaptar_t *st, int dirfd, int level, const char *parent,
 		if (S_ISLNK(stb.st_mode)) {
 			ssize_t sz;
 
-			if ((sz = readlinkat(st->st_snapshot_fd, path, buf,
+			if ((sz = readlinkat(dirfd, d->d_name, buf,
 			    sizeof (buf))) < 0) {
 				err(1, "readlinkat");
 			}
@@ -779,11 +1020,15 @@ run_readdir_impl(snaptar_t *st, int dirfd, int level, const char *parent,
 		/*
 		 * Fire callback for this directory entry.
 		 */
-		if (cbfunc(st, path, level, &stb, sympath) != 0) {
+		if (cbfunc(st, path, level, &stb, sympath, arg) != 0) {
 			e = errno;
 			goto out;
 		}
 
+		if (!recurse) {
+			goto next;
+		}
+
 		if (!S_ISDIR(stb.st_mode)) {
 			/*
 			 * This directory entry is not, itself, a directory; no
@@ -798,7 +1043,7 @@ run_readdir_impl(snaptar_t *st, int dirfd, int level, const char *parent,
 		}
 
 		if (run_readdir_impl(st, chdirfd, level + 1, path,
-		    cbfunc) != 0) {
+		    cbfunc, recurse, arg) != 0) {
 			e = errno;
 			goto out;
 		}
@@ -862,13 +1107,14 @@ path_is_excluded(snaptar_t *st, const char *path)
 
 static int
 print_entry(snaptar_t *st, const char *path, int level, struct stat *stp,
-    const char *sympath)
+    const char *sympath, void *arg)
 {
 	char *whpath = NULL;
 	char typ = '?';
 	boolean_t special = B_FALSE;
 	boolean_t unknown = B_FALSE;
 	const char *relpath = path;
+	hardlink_ent_t *hle = NULL;
 
 	if (st->st_root_prefix != NULL) {
 		size_t len = strlen(st->st_root_prefix);
@@ -900,7 +1146,12 @@ print_entry(snaptar_t *st, const char *path, int level, struct stat *stp,
 		typ = '-';
 
 	} else if (S_ISREG(stp->st_mode)) {
-		typ = 'F';
+		if ((hle = hardlinks_lookup(st, stp)) == NULL) {
+			hardlinks_add(st, relpath, stp);
+			typ = 'F';
+		} else {
+			typ = 'H';
+		}
 
 	} else if (S_ISDIR(stp->st_mode)) {
 		typ = 'D';
@@ -936,7 +1187,9 @@ print_entry(snaptar_t *st, const char *path, int level, struct stat *stp,
 	}
 
 	fprintf(stderr, "%c %s", typ, relpath);
-	if (sympath != NULL) {
+	if (hle != NULL) {
+		fprintf(stderr, " -> %s", hle->hle_path);
+	} else if (sympath != NULL) {
 		fprintf(stderr, " -> %s", sympath);
 	}
 	if ((special && (st->st_flags & SNTR_F_IGNORE_SPECIALS)) ||
@@ -971,7 +1224,7 @@ run_readdir(snaptar_t *st, ent_enum_cb *cbfunc)
 		parent = st->st_root_prefix;
 	}
 
-	if ((dirfd = openat(st->st_snapshot_fd, pfx, O_RDONLY |
+	if ((dirfd = openat(st->st_snapshots[1].stss_fd, pfx, O_RDONLY |
 	    O_LARGEFILE)) == -1) {
 		err(1, "openat");
 	}
@@ -984,20 +1237,21 @@ run_readdir(snaptar_t *st, ent_enum_cb *cbfunc)
 		errx(1, "\"%s\" (within snapshot) is not a directory", pfx);
 	}
 
-	return (run_readdir_impl(st, dirfd, 1, parent, cbfunc));
+	return (run_readdir_impl(st, dirfd, 1, parent, cbfunc, B_TRUE, NULL));
 }
 
 void
 get_zfs_mountpoint_cb(const char *line, void *arg0)
 {
-	snaptar_t *st = arg0;
+	snaptar_snapshot_t *stss = arg0;
+	snaptar_t *st = stss->stss_owner;
 	strlist_t *sl = NULL;
 
 	if (st->st_flags & SNTR_F_FAILED) {
 		return;
 	}
 
-	if (st->st_mountpoint != NULL) {
+	if (stss->stss_mountpoint != NULL) {
 		/*
 		 * There should have been at most one line of output from
 		 * the zfs(1M) command.
@@ -1018,7 +1272,7 @@ get_zfs_mountpoint_cb(const char *line, void *arg0)
 	/*
 	 * Verify that the dataset name we found was the one we were expecting.
 	 */
-	if (!strlist_match(sl, 0, st->st_dataset1)) {
+	if (!strlist_match(sl, 0, stss->stss_dataset)) {
 		custr_append(st->st_errstr, "unexpected dataset in list");
 		goto errout;
 	}
@@ -1028,7 +1282,7 @@ get_zfs_mountpoint_cb(const char *line, void *arg0)
 	 */
 	if (!strlist_match(sl, 1, "filesystem")) {
 		custr_append_printf(st->st_errstr, "found dataset (%s) was "
-		    "not a filesystem", st->st_dataset1);
+		    "not a filesystem", stss->stss_dataset);
 		goto errout;
 	}
 
@@ -1037,12 +1291,12 @@ get_zfs_mountpoint_cb(const char *line, void *arg0)
 	 */
 	if (!strlist_match(sl, 2, "yes")) {
 		custr_append_printf(st->st_errstr, "filesystem (%s) is not "
-		    "mounted", st->st_dataset1);
+		    "mounted", stss->stss_dataset);
 		goto errout;
 	}
 
 	VERIFY(strlist_get(sl, 3)[0] == '/');
-	if ((st->st_mountpoint = strdup(strlist_get(sl, 3))) == NULL) {
+	if ((stss->stss_mountpoint = strdup(strlist_get(sl, 3))) == NULL) {
 		err(1, "strdup");
 	}
 
@@ -1055,27 +1309,10 @@ out:
 	strlist_free(sl);
 }
 
-static int
-open_zfs_snap(snaptar_t *st, const char *snapname)
-{
-	char *path = NULL;
-
-	if (asprintf(&path, "%s/.zfs/snapshot/%s", st->st_mountpoint,
-	    snapname) < 0) {
-		err(1, "asprintf");
-	}
-
-	if ((st->st_snapshot_fd = open(path, O_RDONLY | O_LARGEFILE)) == -1) {
-		err(1, "open_zfs_snap: open(%s)", path);
-	}
-
-	free(path);
-	return (0);
-}
-
 int
-get_zfs_mountpoint(snaptar_t *st)
+get_zfs_mountpoint(snaptar_snapshot_t *stss)
 {
+	snaptar_t *st = stss->stss_owner;
 	char *const argv[] = {
 		CMD_ZFS,
 		"list",
@@ -1083,7 +1320,7 @@ get_zfs_mountpoint(snaptar_t *st)
 		"-p",
 		"-o",
 		"name,type,mounted,mountpoint",
-		st->st_dataset1,
+		stss->stss_dataset,
 		NULL
 	};
 	char *const envp[] = {
@@ -1091,9 +1328,15 @@ get_zfs_mountpoint(snaptar_t *st)
 	};
 	int code;
 	char errbuf[512];
+	char *path = NULL;
+	struct stat stmp;
+
+	VERIFY3P(stss->stss_dataset, !=, NULL);
+	VERIFY3P(stss->stss_snapshot, !=, NULL);
+	VERIFY3S(stss->stss_fd, ==, -1);
 
 	if (run_command(CMD_ZFS, argv, envp, errbuf, sizeof (errbuf),
-	    get_zfs_mountpoint_cb, &code, st) != 0) {
+	    get_zfs_mountpoint_cb, &code, stss) != 0) {
 		errx(1, "failed to run \"zfs list\"");
 	}
 
@@ -1105,18 +1348,34 @@ get_zfs_mountpoint(snaptar_t *st)
 		return (-1);
 	}
 
-	if (st->st_mountpoint == NULL) {
-		custr_append(st->st_errstr, "could not find dataset");
+	if (stss->stss_mountpoint == NULL) {
+		custr_append_printf(st->st_errstr, "dataset not found: %s",
+		    stss->stss_dataset);
 		st->st_flags |= SNTR_F_FAILED;
 		return (-1);
 	}
 
-	if (open_zfs_snap(st, st->st_snap1) != 0) {
-		custr_append(st->st_errstr, "could not open snapdir");
-		st->st_flags |= SNTR_F_FAILED;
+	if (asprintf(&path, "%s/.zfs/snapshot/%s", stss->stss_mountpoint,
+	    stss->stss_snapshot) < 0) {
+		err(1, "asprintf");
+	}
+
+	if ((stss->stss_fd = open(path, O_RDONLY | O_LARGEFILE)) == -1) {
+		custr_append_printf(st->st_errstr, "could not open snapshot "
+		    "directory (%s): %s", path, strerror(errno));
+		free(path);
+		return (-1);
+	}
+
+	if (fstat(stss->stss_fd, &stmp) != 0) {
+		custr_append_printf(st->st_errstr, "could not stat snapshot "
+		    "directory (%s): %s", path, strerror(errno));
+		free(path);
 		return (-1);
 	}
+	stss->stss_device = stmp.st_dev;
 
+	free(path);
 	return (0);
 }
 
@@ -1147,7 +1406,7 @@ make_tarball_entry_empty_file(struct archive_entry *ae)
 
 static int
 make_tarball_entry(snaptar_t *st, const char *path, int level,
-    struct stat *statp, const char *sympath)
+    struct stat *statp, const char *sympath, void *arg)
 {
 	struct archive *a = st->st_archive;
 	struct archive_entry *ae = st->st_archive_entry;
@@ -1155,8 +1414,8 @@ make_tarball_entry(snaptar_t *st, const char *path, int level,
 	int datafd = -1;
 	const char *relpath = path;
 
-	VERIFY(a != NULL);
-	VERIFY(ae != NULL);
+	VERIFY3P(a, !=, NULL);
+	VERIFY3P(ae, !=, NULL);
 
 	if (st->st_root_prefix != NULL) {
 		size_t len = strlen(st->st_root_prefix);
@@ -1204,6 +1463,8 @@ make_tarball_entry(snaptar_t *st, const char *path, int level,
 	} else if (S_ISLNK(statp->st_mode) || S_ISDIR(statp->st_mode) ||
 	    S_ISREG(statp->st_mode) || S_ISFIFO(statp->st_mode) ||
 	    S_ISSOCK(statp->st_mode)) {
+		hardlink_ent_t *hle;
+
 		/*
 		 * This is a regular file, directory, symbolic link, fifo or
 		 * socket.  Metadata is copied from the stat(2) structure.
@@ -1214,16 +1475,35 @@ make_tarball_entry(snaptar_t *st, const char *path, int level,
 		}
 		archive_entry_copy_stat(ae, statp);
 
-		if (S_ISREG(statp->st_mode)) {
+		if (S_ISREG(statp->st_mode) && (hle = hardlinks_lookup(st,
+		    statp)) != NULL) {
+			/*
+			 * This link references an inode that we have included
+			 * already.  Instead of including the contents a second
+			 * time, we instruct tar to create a hard link to the
+			 * first copy we included.
+			 */
+			archive_entry_set_hardlink(ae, hle->hle_path);
+			archive_entry_set_size(ae, 0);
+
+		} else if (S_ISREG(statp->st_mode)) {
 			/*
-			 * Open the regular file from the snapshot so that we
-			 * can read its contents into the archive.
+			 * This is a regular file with an inode we have not yet
+			 * seen.  Open the file as it exists in the snapshot so
+			 * that its contents may be included in the archive.
 			 */
-			if ((datafd = openat(st->st_snapshot_fd, path,
-			    O_RDONLY | O_LARGEFILE | O_NOFOLLOW)) == -1) {
+			if ((datafd = openat(st->st_snapshots[1].stss_fd,
+			    path, O_RDONLY | O_LARGEFILE | O_NOFOLLOW)) == -1) {
 				err(1, "reg file open(%s)", path);
 			}
 
+			/*
+			 * Record the relative path for this inode number in
+			 * case it is included via an additional hard link
+			 * later.
+			 */
+			hardlinks_add(st, relpath, statp);
+
 		} else if (S_ISLNK(statp->st_mode)) {
 			/*
 			 * Specify the symbolic link target path.
@@ -1366,7 +1646,7 @@ out:
 
 static int
 walk_diff_tree_impl(snaptar_t *st, diff_ent_t *de, int level,
-    const char *parent, ent_enum_cb *cbfunc)
+    const char *parent, ent_enum_cb *cbfunc, void *cbarg)
 {
 	boolean_t root = (de->de_name == NULL);
 	struct stat stb;
@@ -1374,6 +1654,7 @@ walk_diff_tree_impl(snaptar_t *st, diff_ent_t *de, int level,
 	char *path = NULL;
 	char buf[MAXPATHLEN];
 	char *sympath = NULL;
+	int snapfd = st->st_snapshots[1].stss_fd;
 
 	if (root) {
 		/*
@@ -1391,7 +1672,7 @@ walk_diff_tree_impl(snaptar_t *st, diff_ent_t *de, int level,
 		err(1, "asprintf");
 	}
 
-	if (fstatat(st->st_snapshot_fd, path, &stb, AT_SYMLINK_NOFOLLOW) != 0) {
+	if (fstatat(snapfd, path, &stb, AT_SYMLINK_NOFOLLOW) != 0) {
 		if (errno != ENOENT) {
 			err(1, "fstatat");
 		}
@@ -1406,8 +1687,7 @@ walk_diff_tree_impl(snaptar_t *st, diff_ent_t *de, int level,
 	if (S_ISLNK(stb.st_mode)) {
 		ssize_t sz;
 
-		if ((sz = readlinkat(st->st_snapshot_fd, path, buf,
-		    sizeof (buf))) < 0) {
+		if ((sz = readlinkat(snapfd, path, buf, sizeof (buf))) < 0) {
 			err(1, "readlinkat");
 		}
 
@@ -1416,7 +1696,7 @@ walk_diff_tree_impl(snaptar_t *st, diff_ent_t *de, int level,
 		sympath = buf;
 	}
 
-	if (cbfunc(st, path, level, stp, sympath) != 0) {
+	if (cbfunc(st, path, level, stp, sympath, cbarg) != 0) {
 		free(path);
 		return (-1);
 	}
@@ -1426,7 +1706,7 @@ skip:
 	 * Walk each child of this directory:
 	 */
 	for (diff_ent_t *ch = de->de_child; ch != NULL; ch = ch->de_sibling) {
-		walk_diff_tree_impl(st, ch, level + 1, path, cbfunc);
+		walk_diff_tree_impl(st, ch, level + 1, path, cbfunc, cbarg);
 	}
 
 	free(path);
@@ -1436,7 +1716,7 @@ skip:
 int
 walk_diff_tree(snaptar_t *st, ent_enum_cb *cbfunc)
 {
-	return (walk_diff_tree_impl(st, &st->st_root, 0, NULL, cbfunc));
+	return (walk_diff_tree_impl(st, &st->st_root, 0, NULL, cbfunc, NULL));
 }
 
 static void
@@ -1600,7 +1880,8 @@ main(int argc, char *argv[])
 	}
 
 options_done:
-	if (get_zfs_mountpoint(st) != 0) {
+	if ((incremental && get_zfs_mountpoint(&st->st_snapshots[0]) != 0) ||
+	    get_zfs_mountpoint(&st->st_snapshots[1]) != 0) {
 		goto out;
 	}
 
-- 
2.21.0

