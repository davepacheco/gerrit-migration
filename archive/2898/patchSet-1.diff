From 746a0723571dfa8772378bd79b8d3bcc0f3c1b55 Mon Sep 17 00:00:00 2001
From: Tim Kordas <tim.kordas@joyent.com>
Date: Wed, 1 Nov 2017 17:24:45 -0700
Subject: [PATCH] eventually this will be node-moray#??

---
 lib/pool.js  | 46 +++++++++++++++++++++++++++++++++-------------
 package.json |  2 +-
 2 files changed, 34 insertions(+), 14 deletions(-)

diff --git a/lib/pool.js b/lib/pool.js
index b8203be..e18faf9 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -29,7 +29,6 @@
  */
 
 var assert = require('assert-plus');
-var jsprim = require('jsprim');
 var VError = require('verror');
 
 module.exports = MorayConnectionPool;
@@ -114,32 +113,53 @@ function MorayConnectionPool(args) {
  * The caller must invoke connRelease() when the request is finished.
  */
 MorayConnectionPool.prototype.connAlloc = function () {
-    var availkeys, key, mconn, aconn;
+    var availkeys, key, mconn, aconn, lowest;
+    var self = this;
 
     /*
      * There are more sophisticated ways to pick a connection (e.g., store
-     * connections in a priority queue by number of outstanding requests).  But
-     * our expectation is that Moray servers are pretty uniform, Moray requests
-     * are pretty uniform in their cost on the server, and so a random
-     * distribution is likely to be reasonable.
+     * connections in a priority queue by number of outstanding requests).
+     * Our release and drain functionality often requires access by key, so
+     * a maintaining a pure priority-queue is a little bit complex.
+     *
+     * Randomly picking Moray servers works when their response times are
+     * all uniform; but small differences in response times, (especially
+     * with bursty workloads) can end up assigning to much work to the
+     * slowest server(s). In cases where the server performance is partly
+     * dictated by the amount of work, we end up with a positive feedback
+     * loop where the slowest servers acquire a mounting backlog while the
+     * least-loaded stay lightly loaded.
+     *
+     * Until we have an appropriately augmented priority-queue, we'll just
+     * pick the server with the fewest outstanding requests.
      */
-    availkeys = Object.keys(this.mcp_avail);
+    availkeys = Object.keys(self.mcp_avail);
     if (availkeys.length === 0) {
-        this.mcp_nalloc_fail++;
-        this.mcp_log.trace('failed to allocate connection');
+        self.mcp_nalloc_fail++;
+        self.mcp_log.trace('failed to allocate connection');
         return (new VError({
             'name': 'NoBackendsError'
         }, 'no connections available'));
     }
 
-    key = jsprim.randElt(availkeys);
-    mconn = this.mcp_conns[key];
+    key = undefined;
+    lowest = 0;
+    availkeys.forEach(function (k) {
+        if (key === undefined || self.mcp_avail[k] < lowest) {
+            key = k;
+            lowest = self.mcp_avail[k];
+        }
+    });
+
+    mconn = self.mcp_conns[key];
     assert.ok(mconn instanceof MorayConnection);
     assert.ok(mconn.mc_nreqs >= 0);
     mconn.mc_nreqs++;
+    self.mcp_avail[key] = mconn.mc_nreqs;
+
     aconn = new MorayConnectionAllocation(mconn);
     mconn.mc_log.trace('allocated connection');
-    this.mcp_nalloc_ok++;
+    self.mcp_nalloc_ok++;
     return (aconn);
 };
 
@@ -182,7 +202,7 @@ MorayConnectionPool.prototype.connAdd = function connAdd(key, conn, hdl) {
     mconn = new MorayConnection(key, conn, hdl,
         this.mcp_log.child(extras, true));
     this.mcp_conns[key] = mconn;
-    this.mcp_avail[key] = true;
+    this.mcp_avail[key] = 0;
     mconn.mc_log.info('new connection');
 };
 
diff --git a/package.json b/package.json
index 4bb2a9d..affb441 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "3.4.0",
+    "version": "3.5.0",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
-- 
2.21.0

