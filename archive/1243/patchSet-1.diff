From 0ec5667c45253762e0f9a7ff86bf48ba423352b5 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Thu, 12 Jan 2017 23:08:22 +0000
Subject: [PATCH] OS-4923 lxbrand aio LTP failures

---
 usr/src/lib/brand/lx/lx_brand/common/aio.c | 39 ++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/usr/src/lib/brand/lx/lx_brand/common/aio.c b/usr/src/lib/brand/lx/lx_brand/common/aio.c
index b19502df99..baa22c0525 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/aio.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/aio.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/syscall.h>
@@ -143,7 +143,20 @@ lx_io_submit(lx_aio_context_t cid, long nr, uintptr_t **bpp)
 	struct aiocb *aiocb;
 	lx_aio_ctxt_t *ctx = (lx_aio_ctxt_t *)cid;
 
-	if (nr <= 0 || ctx == NULL)
+	/*
+	 * To accomodate LTP tests we have to check in a specific order.
+	 * Linux checks for invalid context first, then passes if nr == 0.
+	 */
+	/* Perform some validation on the context */
+	if (ctx == NULL || (long)ctx == -1 ||
+	    (ctx->lxaio_size == 0 && ctx->lxaio_nevents == 0) ||
+	    ctx->lxaio_nevents > lx_aio_max_nr)
+		return (-EINVAL);
+
+	if (nr == 0)
+		return (0);
+
+	if (nr < 0)
 		return (-EINVAL);
 
 	if ((iocbpp = (lx_iocb_t **)malloc(nr * sizeof (uintptr_t))) == NULL)
@@ -287,11 +300,20 @@ lx_io_getevents(lx_aio_context_t cid, long min_nr, long nr,
 	int rval, i, err;
 	lx_aio_ctxt_t *ctx = (lx_aio_ctxt_t *)cid;
 
+	/* Perform some validation on the context */
+	if (ctx == NULL || (long)ctx == -1 ||
+	    (ctx->lxaio_size == 0 && ctx->lxaio_nevents == 0) ||
+	    ctx->lxaio_nevents > lx_aio_max_nr)
+		return (-EINVAL);
+
 	/* ctx->lxaio_nevents already validated against lx_aio_max_nr */
 	if (min_nr < 0 || min_nr > ctx->lxaio_nevents ||
 	    nr < 0 || nr > ctx->lxaio_nevents)
 		return (-EINVAL);
 
+	if (events == NULL)
+		return (-EFAULT);
+
 	/*
 	 * We can't return ENOMEM from this syscall so EINTR is the closest
 	 * we can come.
@@ -459,9 +481,16 @@ lx_io_cancel(lx_aio_context_t cid, lx_iocb_t *iocbp, lx_io_event_t *result)
 	lx_aiocb_t *lxcb;
 	lx_aio_ctxt_t *ctx = (lx_aio_ctxt_t *)cid;
 
+	/* This is in a specific order for LTP */
 	if (uucopy(iocbp, &iocb, sizeof (lx_iocb_t)) != 0)
 		return (-EFAULT);
 
+	/* Perform some validation on the context */
+	if (ctx == NULL || (long)ctx == -1 ||
+	    (ctx->lxaio_size == 0 && ctx->lxaio_nevents == 0) ||
+	    ctx->lxaio_nevents > lx_aio_max_nr)
+		return (-EINVAL);
+
 	mutex_enter(&ctx->lxaio_lock);
 
 	if (ctx->lxaio_destroying) {
@@ -499,6 +528,12 @@ lx_io_destroy(lx_aio_context_t cid)
 	int port;
 	lx_aio_ctxt_t *ctx = (lx_aio_ctxt_t *)cid;
 
+	/* Perform some validation on the context */
+	if (ctx == NULL || (long)ctx == -1 ||
+	    (ctx->lxaio_size == 0 && ctx->lxaio_nevents == 0) ||
+	    ctx->lxaio_nevents > lx_aio_max_nr)
+		return (-EINVAL);
+
 	port = ctx->lxaio_port;
 	mutex_enter(&ctx->lxaio_lock);
 
-- 
2.21.0

