From 6aeb35ee82be4226c5b0eb1c9c071e34d0054029 Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Fri, 10 Nov 2017 09:36:06 -0700
Subject: [PATCH] MANTA-3452 Muskie should wait for minimal set of services
 before servicing requests Reviewed by: Jared Morrow <jm@joyent.com>

---
 lib/auth.js   |   6 +-
 lib/common.js |  28 +--
 lib/server.js |  24 +--
 main.js       | 504 +++++++++++++++++++++++++++++---------------------
 4 files changed, 319 insertions(+), 243 deletions(-)

diff --git a/lib/auth.js b/lib/auth.js
index 68fe898..997ca9d 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -997,12 +997,12 @@ module.exports = {
     authenticationHandler: function handlers(options) {
         assert.object(options, 'options');
         assert.object(options.log, 'options.log');
-        assert.func(options.mahi, 'options.mahi');
+        assert.object(options.mahi, 'options.mahi');
 
         return ([
             function _authSetup(req, res, next) {
-                req.mahi = options.mahi();
-                req.keyapi = options.keyapi();
+                req.mahi = options.mahi;
+                req.keyapi = options.keyapi;
                 req.auth = {};
                 req.authContext = {
                     conditions: {}
diff --git a/lib/common.js b/lib/common.js
index fcced7c..d53dad2 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -893,17 +893,17 @@ module.exports = {
         return (getMetadata);
     },
 
-    setupHandler: function (options) {
+    setupHandler: function (options, clients) {
         assert.object(options, 'options');
         assert.object(options.jobCache, 'options.jobCache');
         assert.object(options.log, 'options.log');
         assert.object(options.collector, 'options.collector');
-        assert.func(options.keyapi, 'options.keyapi');
-        assert.func(options.mahi, 'options.mahi');
-        assert.func(options.marlin, 'options.marlin');
-        assert.func(options.picker, 'options.picker');
-        assert.func(options.moray, 'options.moray');
-        assert.func(options.medusa, 'options.medusa');
+        assert.object(clients.keyapi, 'clients.keyapi');
+        assert.object(clients.mahi, 'clients.mahi');
+        assert.object(clients.marlin, 'clients.marlin');
+        assert.object(clients.picker, 'clients.picker');
+        assert.object(options.moray, 'options.moray');
+        assert.object(clients.medusa, 'clients.medusa');
         assert.object(options.sharkConfig, 'options.sharkConfig');
         assert.object(options.storage, 'options.storage');
         assert.number(options.storage.defaultMaxStreamingSizeMB,
@@ -914,7 +914,7 @@ module.exports = {
 
         function setup(req, res, next) {
             req.config = options;
-            req.moray = options.moray();
+            req.moray = clients.moray;
 
             // MANTA-331: while a trailing '/' is ok in HTTP,
             // this messes with the consistent hashing, so
@@ -933,14 +933,14 @@ module.exports = {
             // Attach an artedi metric collector to each request object.
             req.collector = options.collector;
 
-            req.mahi = options.mahi();
-            req.marlin = options.marlin();
-            req.keyapi = options.keyapi();
-            req.picker = options.picker();
+            req.mahi = clients.mahi;
+            req.marlin = clients.marlin;
+            req.keyapi = clients.keyapi;
+            req.picker = clients.picker;
             req.sharks = [];
             req.sharkConfig = options.sharkConfig;
-            req.sharkAgent = options.sharkAgent();
-            req.medusa = options.medusa();
+            req.sharkAgent = clients.sharkAgent;
+            req.medusa = clients.medusa;
             req.msk_defaults = {
                 maxStreamingSize: options.storage.defaultMaxStreamingSizeMB *
                     1024 * 1024,
diff --git a/lib/server.js b/lib/server.js
index 43888c7..c08e0b6 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -94,10 +94,11 @@ function formatJSON(req, res, body) {
  * @param {object} options.collector  - artedi metric collector.
  * @throws {TypeError} on bad input.
  */
-function createServer(options) {
+function createServer(options, clients, name) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.collector, 'options.collector');
+    assert.object(clients, 'clients');
 
     options.formatters = {
         'application/json': formatJSON,
@@ -210,24 +211,19 @@ function createServer(options) {
         var ok = true;
         var errors = [];
 
-        if (!options.picker()) {
-            errors.push(new Error('picker unavailable'));
+        if (!clients.picker) {
             req.log.error('picker unavailable');
             ok = false;
-        } else if (!options.moray()) {
-            errors.push(new Error('index moray unavailable'));
+        } else if (!clients.moray) {
             req.log.error('index moray unavailable');
             ok = false;
-        } else if (!options.mahi()) {
-            errors.push(new Error('mahi unavailable'));
+        } else if (!clients.mahi) {
             req.log.error('mahi unavailable');
             ok = false;
-        } else if (!options.marlin()) {
-            errors.push(new Error('marlin available'));
+        } else if (!clients.marlin) {
             req.log.error('marlin unavailable');
             ok = !req.isMarlinRequest();
-        } else if (!options.medusa()) {
-            errors.push(new Error('medusa unavailable'));
+        } else if (!clients.medusa) {
             req.log.error('medusa unavailable');
             ok = !req.isMedusaRequest();
         }
@@ -242,14 +238,14 @@ function createServer(options) {
 
     server.use(auth.authenticationHandler({
         log: log,
-        mahi: options.mahi,
-        keyapi: options.keyapi
+        mahi: clients.mahi,
+        keyapi: clients.keyapi
     }));
 
     server.use(auth.gatherContext);
 
     // Add various fields to the 'req' object before the handlers get called.
-    server.use(common.setupHandler(options));
+    server.use(common.setupHandler(options, clients));
 
     // Compute jobs
 
diff --git a/main.js b/main.js
index 0bf2441..060741a 100644
--- a/main.js
+++ b/main.js
@@ -21,87 +21,68 @@ var bunyan = require('bunyan');
 var cueball = require('cueball');
 var dashdash = require('dashdash');
 var dtrace = require('dtrace-provider');
+var jsprim = require('jsprim');
 var kang = require('kang');
 var keyapi = require('keyapi');
 var libmanta = require('libmanta');
 var LRU = require('lru-cache');
 var mahi = require('mahi');
 var marlin = require('marlin');
+var medusa = require('./lib/medusa');
 var once = require('once');
 var restify = require('restify');
 var vasync = require('vasync');
-var medusa = require('./lib/medusa');
 
 var app = require('./lib');
 var uploadsCommon = require('./lib/uploads/common');
 
 
+///--- Internal Functions
 
-///--- Globals
-
-var RequestCaptureStream = restify.bunyan.RequestCaptureStream;
-
-var NAME = 'muskie';
-var DEFAULT_CFG = __dirname + '/etc/' + NAME + '.config.json';
-var LEVEL = process.env.LOG_LEVEL || 'info';
-var LOG = bunyan.createLogger({
-    name: NAME,
-    streams: [ {
-        level: LEVEL,
-        stream: process.stderr
-    } ],
-    serializers: restify.bunyan.serializers
-});
-var AGENT;
-var SHARKAGENT;
-var MAHI;
-var MARLIN;
-var KEYAPI;
-var OPTIONS = [
-    {
-        names: ['file', 'f'],
-        type: 'string',
-        help: 'Configuration file to use.',
-        helpArg: 'FILE'
-    },
-    {
-        names: ['insecure-port', 'i'],
-        type: 'positiveInteger',
-        help: 'Listen for insecure requests on port.',
-        helpArg: 'PORT'
-    },
-    {
-        names: ['port', 'p'],
-        type: 'positiveInteger',
-        help: 'Listen for secure requests on port.',
-        helpArg: 'PORT'
-    },
-    {
-        names: ['verbose', 'v'],
-        type: 'arrayOfBool',
-        help: 'Verbose output. Use multiple times for more verbose.'
-    }
-];
-
-var PICKER;
-var MORAY;
-var MEDUSA;
-var VERSION = false;
-
+function getMuskieOptions() {
+    var options = [
+        {
+            names: ['file', 'f'],
+            type: 'string',
+            help: 'Configuration file to use.',
+            helpArg: 'FILE'
+        },
+        {
+            names: ['insecure-port', 'i'],
+            type: 'positiveInteger',
+            help: 'Listen for insecure requests on port.',
+            helpArg: 'PORT'
+        },
+        {
+            names: ['port', 'p'],
+            type: 'positiveInteger',
+            help: 'Listen for secure requests on port.',
+            helpArg: 'PORT'
+        },
+        {
+            names: ['verbose', 'v'],
+            type: 'arrayOfBool',
+            help: 'Verbose output. Use multiple times for more verbose.'
+        }
+    ];
 
+    return (options);
+}
 
-///--- Internal Functions
 
-function configure() {
-    var cfg;
+/**
+ * Command line option parsing and checking.
+ *
+ * @returns {Object} A object representing the command line options
+ */
+function parseOptions() {
     var opts;
-    var parser = new dashdash.Parser({options: OPTIONS});
+    var parser = new dashdash.Parser({options: getMuskieOptions()});
 
     try {
         opts = parser.parse(process.argv);
         assert.object(opts, 'options');
     } catch (e) {
-        LOG.fatal(e, 'invalid options');
         usage(parser, e.message);
     }
 
@@ -109,18 +90,43 @@ function configure() {
         usage(parser, '-f option is required');
     }
 
-    cfg = JSON.parse(readFile(opts.file));
+    return (opts);
+}
+
+
+/**
+ * Configure the application based on the configuration file data and the
+ * command line options
+ *
+ * @param {String} appName: Required. The name of the application
+ * @param {Object} opts: Required. An object representing the parsed command
+ * line options
+ * @param {} dtProbes: Required. An object containing the dtrace probes for the
+ * application
+ * @returns {Object} The configuration object
+ */
+function configure(appName, opts, dtProbes) {
+    var cfg = JSON.parse(readFile(opts.file));
+
+    assert.object(cfg, 'cfg');
+    assert.object(cfg.auth, 'cfg.auth');
+    assert.object(cfg.marlin, 'cfg.marlin');
+    assert.object(cfg.moray, 'cfg.moray');
+    assert.object(cfg.medusa, 'cfg.medusa');
+    assert.object(cfg.cueballHttpAgent, 'cfg.cueballHttpAgent');
+    assert.object(cfg.sharkConfig, 'cfg.sharkConfig');
+
     cfg.insecurePort = opts.insecure_port || cfg.insecurePort;
     cfg.port = opts.port || cfg.port;
-
     cfg.name = 'Manta';
     cfg.version = version();
+    cfg.log = configureLogging(appName, cfg.bunyan, opts.verbose);
 
-    if (opts.verbose) {
-        opts.verbose.forEach(function () {
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-        });
-    }
+    [ cfg.auth, cfg.marlin, cfg.moray, cfg.medusa,
+      cfg.cueballHttpAgent, cfg.sharkConfig
+    ].forEach(function (x) {
+        x.log = cfg.log;
+    });
 
     if (!cfg.hasOwnProperty('storage')) {
         cfg.storage = {};
@@ -144,7 +150,7 @@ function configure() {
          * function.
          */
         if (typeof (v) !== 'number' || v < 1) {
-            LOG.fatal('invalid "defaultMaxStreamingSizeMB" value');
+            cfg.log.fatal('invalid "defaultMaxStreamingSizeMB" value');
             process.exit(1);
         }
     } else {
@@ -162,7 +168,7 @@ function configure() {
         if (len < uploadsCommon.MIN_PREFIX_LEN ||
             len > uploadsCommon.MAX_PREFIX_LEN) {
 
-            LOG.fatal('invalid "prefixDirLen" value: must be between ' +
+            cfg.log.fatal('invalid "prefixDirLen" value: must be between ' +
                 uploadsCommon.MIN_PREFIX_LEN + ' and ' +
                 uploadsCommon.MAX_PREFIX_LEN);
             process.exit(1);
@@ -180,84 +186,118 @@ function configure() {
         }
     });
 
-    if (LOG.level() <= bunyan.DEBUG)
-        LOG = LOG.child({src: true});
+    cfg.jobCache = LRU({
+        maxAge: (cfg.marlin.jobCache.expiry * 1000) || 30000,
+        max: cfg.marlin.jobCache.size || 1000
+    });
+
+    cfg.dtrace_probes = dtProbes;
+
+    cfg.log.debug(cfg, 'muskie: config loaded');
+
+    return (cfg);
+}
 
-    LOG.debug(cfg, 'createServer: config loaded');
+
+/**
+ * Configure the logger based on the configuration data
+ *
+ * @param {String} appName: Required. The name of the application
+ * @param {Object} bunyanCfg: Required. The bunyan configuration data
+ * @param {arrayOfBool} verbose: Required. Array of boolean values that
+ * indicates if verbose logging should be enabled and the level of verbosity
+ * requested. Used to determine if syslog logging should be configured or not
+ * and to set the logging level appropriately.
+ * @returns {Object} A bunyan logger object
+ */
+function configureLogging(appName, bunyanCfg, verbose) {
+    var log = bunyan.createLogger({
+        name: appName,
+        streams: [ {
+            level: process.env.LOG_LEVEL || 'info',
+            stream: process.stderr
+        } ],
+        serializers: restify.bunyan.serializers
+    });
+    var level;
 
     // This is ugly, but we set this up so that if muskie is invoked with a
     // -v flag, then we know you're running locally, and you just want the
-    // messages to spew to stdout. Otherwise, it's "production", and muskie
-    // logs to a syslog endpoint
-
-    function setLogger() {
-        cfg.log = LOG;
-        cfg.auth.log = LOG;
-        cfg.marlin.log = LOG;
-        cfg.moray.log = LOG;
-        cfg.medusa.log = LOG;
-        cfg.cueballHttpAgent.log = LOG;
-        cfg.sharkConfig.log = LOG;
-    }
+    // messages to spew to stderr. Otherwise, it's "production", and muskie
+    // likely logs to a syslog endpoint
+    if (verbose || !bunyanCfg) {
+        if (verbose) {
+            level = Math.max(bunyan.TRACE, (log.level() - verbose.length * 10));
+            log.level(level);
+        }
 
-    if (opts.verbose || !cfg.bunyan) {
-        setLogger();
-        return (cfg);
+        return (log);
     }
 
-    var cfg_b = cfg.bunyan;
+    assert.object(bunyanCfg, 'config.bunyan');
+    assert.optionalString(bunyanCfg.level, 'config.bunyan.level');
+    assert.optionalObject(bunyanCfg.syslog, 'config.bunyan.syslog');
 
-    assert.object(cfg_b, 'config.bunyan');
-    assert.optionalString(cfg_b.level, 'config.bunyan.level');
-    assert.optionalObject(cfg_b.syslog, 'config.bunyan.syslog');
+    level = bunyan.resolveLevel(bunyanCfg.level || 'info');
 
-    var level = cfg_b.level || 'info';
-    var streams = [];
-    var sysl;
+    if (bunyanCfg.syslog) {
+        var streams = [];
+        var sysl;
 
-    // We want debug info only IFF the request fails AND the configured
-    // log level is info or higher
-    if (bunyan.resolveLevel(level) >= bunyan.INFO && cfg_b.syslog) {
-        assert.string(cfg_b.syslog.facility,
+        assert.string(bunyanCfg.syslog.facility,
                       'config.bunyan.syslog.facility');
-        assert.string(cfg_b.syslog.type, 'config.bunyan.syslog.type');
+        assert.string(bunyanCfg.syslog.type, 'config.bunyan.syslog.type');
 
         sysl = bsyslog.createBunyanStream({
-            facility: bsyslog.facility[cfg_b.syslog.facility],
-            name: NAME,
-            host: cfg_b.syslog.host,
-            port: cfg_b.syslog.port,
-            type: cfg_b.syslog.type
+            facility: bsyslog.facility[bunyanCfg.syslog.facility],
+            name: appName,
+            host: bunyanCfg.syslog.host,
+            port: bunyanCfg.syslog.port,
+            type: bunyanCfg.syslog.type
         });
+
         streams.push({
             level: level,
             stream: sysl
         });
-        streams.push({
-            level: 'debug',
-            type: 'raw',
-            stream: new RequestCaptureStream({
-                level: bunyan.WARN,
-                maxRecords: 2000,
-                maxRequestIds: 2000,
-                streams: [ {
-                    raw: true,
-                    stream: sysl
-                }]
-            })
-        });
-        LOG = bunyan.createLogger({
-            name: NAME,
+
+        // We want debug info only IFF the request fails AND the configured
+        // log level is info or higher
+        if (level >= bunyan.INFO) {
+            const RequestCaptureStream = restify.bunyan.RequestCaptureStream;
+            streams.push({
+                level: 'debug',
+                type: 'raw',
+                stream: new RequestCaptureStream({
+                    level: bunyan.WARN,
+                    maxRecords: 2000,
+                    maxRequestIds: 2000,
+                    streams: [ {
+                        raw: true,
+                        stream: sysl
+                    }]
+                })
+            });
+        }
+
+        log = bunyan.createLogger({
+            name: appName,
             level: level,
             streams: streams,
             serializers: restify.bunyan.serializers
         });
+    } else {
+        log.level(level);
     }
 
-    setLogger();
-    return (cfg);
+    if (log.level() <= bunyan.DEBUG) {
+        log = log.child({src: true});
+    }
+
+    return (log);
 }
 
+
 function usage(parser, message)
 {
     console.error('muskie: %s', message);
@@ -266,6 +306,7 @@ function usage(parser, message)
     process.exit(2);
 }
 
+
 function createMonitoringServer(cfg) {
     /*
      * Set up the monitoring server. This exposes a cueball kang monitoring
@@ -289,17 +330,12 @@ function createMonitoringServer(cfg) {
     monitorServer.get(new RegExp('.*'), kang.knRestifyHandler(kangOpts));
 
     monitorServer.listen(port, '0.0.0.0', function () {
-        LOG.info('monitoring server started on port %d', port);
+        cfg.log.info('monitoring server started on port %d', port);
     });
 }
 
-function createCueballHttpAgent(cfg) {
-    var sharkCfg = cfg.sharkConfig;
-
-    /* Used for connections to mahi and other services. */
-    AGENT = new cueball.HttpAgent(cfg.cueballHttpAgent);
 
-    /* Used only for connections to sharks. */
+function createCueballSharkAgent(sharkCfg) {
     var sharkCueball = {
         resolvers: sharkCfg.resolvers,
 
@@ -333,52 +369,69 @@ function createCueballHttpAgent(cfg) {
             }
         }
     };
-    SHARKAGENT = new cueball.HttpAgent(sharkCueball);
+
+    return (new cueball.HttpAgent(sharkCueball));
+}
+
+
+function onPickerConnect(clients, barrier, pickerClient) {
+    clients.picker = pickerClient;
+    barrier.done('createPickerClient');
 }
 
-function createPickerClient(cfg) {
+
+function createPickerClient(cfg, log, onConnect) {
     var opts = {
         interval: cfg.interval,
         lag: cfg.lag,
         moray: cfg.moray,
-        log: LOG.child({component: 'picker'}, true),
+        log: log.child({component: 'picker'}, true),
         multiDC: cfg.multiDC,
         defaultMaxStreamingSizeMB: cfg.defaultMaxStreamingSizeMB
     };
 
     var client = app.picker.createClient(opts);
 
-    client.once('connect', function onConnect() {
-        LOG.info('picker connected %s', client.toString());
-        PICKER = client;
+    client.once('connect', function _onConnect() {
+        log.info('picker connected %s', client.toString());
+        onConnect(client);
     });
 }
 
 
-function createAuthCacheClient(options) {
-    assert.object(options, 'options');
-    assert.string(options.url, 'options.url');
-    assert.optionalObject(options.typeTable, 'options.typeTable');
+function createAuthCacheClient(authCfg, agent) {
+    assert.object(authCfg, 'authCfg');
+    assert.string(authCfg.url, 'authCfg.url');
+    assert.optionalObject(authCfg.typeTable, 'authCfg.typeTable');
 
-    var log = LOG.child({component: 'mahi'}, true);
+    var options = jsprim.deepCopy(authCfg);
+    var log = authCfg.log.child({component: 'mahi'}, true);
     options.log = log;
 
     options.typeTable = options.typeTable || apertureConfig.typeTable || {};
-    options.agent = AGENT;
+    options.agent = agent;
 
-    MAHI = mahi.createClient(options);
+    return (mahi.createClient(options));
 }
 
-function createKeyAPIClient(opts) {
+
+function createKeyAPIClient(opts, clients) {
     var log = opts.log.child({component: 'keyapi'}, true);
     var _opts = {
         log: log,
         ufds: opts.ufds
     };
-    KEYAPI = new keyapi(_opts);
+
+    return (new keyapi(_opts));
+}
+
+
+function onMarlinConnect(clients, marlinClient) {
+    clients.marlin = marlinClient;
 }
 
-function createMarlinClient(opts) {
+
+function createMarlinClient(opts, onConnect) {
     var log = opts.log.child({component: 'marlin'}, true);
     var _opts = {
         moray: opts.moray,
@@ -386,16 +439,14 @@ function createMarlinClient(opts) {
         log: log
     };
 
-    marlin.createClient(_opts, function (err, client) {
+    marlin.createClient(_opts, function (err, marlinClient) {
         if (err) {
-            LOG.fatal(err, 'marlin: unable to create a client');
+            log.fatal(err, 'marlin: unable to create a client');
             process.nextTick(createMarlinClient.bind(null, opts));
         } else {
-            var barrier;
-
-            MARLIN = client;
-            LOG.info({
-                remote: MARLIN.ma_client.host
+            onConnect(marlinClient);
+            log.info({
+                remote: marlinClient.ma_client.host
             }, 'marlin: ready');
 
             /*
@@ -404,21 +455,21 @@ function createMarlinClient(opts) {
              * start reconnecting while the first client is still connected.  (A
              * persistent error could result in way too many Moray connections.)
              */
-            barrier = vasync.barrier();
+            var barrier = vasync.barrier();
             barrier.start('wait-for-close');
-            MARLIN.on('close', function () {
+            marlinClient.on('close', function () {
                 barrier.done('wait-for-close');
             });
 
             barrier.start('wait-for-error');
-            MARLIN.on('error', function (marlin_err) {
-                LOG.error(marlin_err, 'marlin error');
+            marlinClient.on('error', function (marlin_err) {
+                log.error(marlin_err, 'marlin error');
                 barrier.done('wait-for-error');
-                MARLIN.close();
+                marlinClient.close();
             });
 
             barrier.on('drain', function doReconnect() {
-                LOG.info('marlin: reconnecting');
+                log.info('marlin: reconnecting');
                 createMarlinClient(opts);
             });
         }
@@ -426,11 +477,17 @@ function createMarlinClient(opts) {
 }
 
 
-function createMorayClient(opts) {
+function onMorayConnect(clients, barrier, morayClient) {
+    clients.moray = morayClient;
+    barrier.done('createMorayClient');
+}
+
+
+function createMorayClient(opts, onConnect) {
     assert.object(opts, 'options');
     assert.object(opts.log, 'options.log');
 
-    var log = LOG.child({component: 'moray'}, true);
+    var log = opts.log.child({component: 'moray'}, true);
     opts.log = log;
 
     var client = new libmanta.createMorayClient(opts);
@@ -441,7 +498,7 @@ function createMorayClient(opts) {
         log.error(err, 'moray: failed to connect');
     });
 
-    client.once('connect', function onConnect() {
+    client.once('connect', function _onConnect() {
         client.removeAllListeners('error');
 
         log.info({
@@ -449,23 +506,28 @@ function createMorayClient(opts) {
             port: opts.port
         }, 'moray: connected');
 
-        MORAY = client;
+        onConnect(client);
     });
 }
 
 
-function createMedusaConnector(opts) {
+function onMedusaConnect(clients, medusaClient) {
+    clients.medusa = medusaClient;
+}
+
+
+function createMedusaConnector(opts, onConnect) {
     assert.object(opts, 'options');
     assert.object(opts.log, 'options.log');
 
-    var log = opts.log = opts.log.child({ component: 'medusa' });
+    var log = opts.log.child({ component: 'medusa' });
     log.debug({ opts: opts }, 'medusa options');
 
     var client = medusa.createConnector(opts);
 
-    client.once('connect', function onConnect() {
+    client.once('connect', function _onConnect() {
         log.info('medusa: connected');
-        MEDUSA = client;
+        onConnect(client);
     });
 }
 
@@ -485,78 +547,96 @@ function readFile(file) {
 
 
 function version() {
-    if (!VERSION) {
-        var fname = __dirname + '/package.json';
-        var pkg = fs.readFileSync(fname, 'utf8');
-        VERSION = JSON.parse(pkg).version;
-    }
-
-    return (VERSION);
+    var fname = __dirname + '/package.json';
+    var pkg = fs.readFileSync(fname, 'utf8');
+    return (JSON.parse(pkg).version);
 }
 
 
+function clientsConnected(appName, cfg, clients) {
+    var server1, server2;
+    var log = cfg.log;
 
-///--- Mainline
-
-(function main() {
-    var cfg = configure();
+    log.info('requisite client connections established, '
+    + 'starting muskie servers');
 
-    createCueballHttpAgent(cfg);
-    createMonitoringServer(cfg);
-    createMarlinClient(cfg.marlin);
-    createPickerClient(cfg.storage);
-    createAuthCacheClient(cfg.auth);
-    createMorayClient(cfg.moray);
-    createMedusaConnector(cfg.medusa);
-    createKeyAPIClient(cfg);
+    server1 = app.createServer(cfg, clients, 'ssl');
+    server1.on('error', function (err) {
+        log.fatal(err, 'server (secure) error');
+        process.exit(1);
+    });
+    server1.listen(cfg.port, function () {
+        log.info('%s listening at (trusted port) %s', appName, server1.url);
+    });
 
-    cfg.jobCache = LRU({
-        maxAge: (cfg.marlin.jobCache.expiry * 1000) || 30000,
-        max: cfg.marlin.jobCache.size || 1000
+    server2 = app.createServer(cfg, clients, 'insecure');
+    server2.on('error', function (err) {
+        log.fatal(err, 'server (clear) error');
+        process.exit(1);
     });
+    server2.listen(cfg.insecurePort, function () {
+        log.info('%s listening at (clear port) %s', appName, server2.url);
+    });
+
+    app.startKangServer();
+}
 
-    cfg.keyapi = function _keyapi() { return (KEYAPI); };
-    cfg.mahi = function mahiClient() { return (MAHI); };
-    cfg.marlin = function marlinClient() { return (MARLIN); };
-    cfg.picker = function picker() { return (PICKER); };
-    cfg.moray = function moray() { return (MORAY); };
-    cfg.medusa = function medusaClient() { return (MEDUSA); };
-    cfg.sharkAgent = function sharkAgent() { return (SHARKAGENT); };
 
-    cfg.name = 'ssl';
+///--- Mainline
+
+(function main() {
+    const muskie = 'muskie';
 
-    var dtp = dtrace.createDTraceProvider('muskie');
+    // Parent object for client connection objects
+    var clients = {};
+
+    // DTrace probe setup
+    var dtp = dtrace.createDTraceProvider(muskie);
     var client_close = dtp.addProbe('client_close', 'json');
     var socket_timeout = dtp.addProbe('socket_timeout', 'json');
+
     client_close.dtp = dtp;
     socket_timeout.dtp = dtp;
     dtp.enable();
 
-    cfg.dtrace_probes = {
+    const dtProbes = {
         client_close: client_close,
         socket_timeout: socket_timeout
     };
 
-    var server = app.createServer(cfg);
-    server.on('error', function (err) {
-        LOG.fatal(err, 'server (secure) error');
-        process.exit(1);
-    });
-    server.listen(cfg.port, function () {
-        LOG.info('%s listening at (trusted port) %s', NAME, server.url);
-    });
+    const opts = parseOptions();
+    const cfg = configure(muskie, opts, dtProbes);
 
-    cfg.name = 'insecure';
-    var server2 = app.createServer(cfg);
-    server2.on('error', function (err) {
-        LOG.fatal(err, 'server (clear) error');
-        process.exit(1);
-    });
-    server2.listen(cfg.insecurePort, function () {
-        LOG.info('%s listening at (clear port) %s', NAME, server2.url);
-    });
+    // Create a barrier to ensure client connections that are established
+    // asynchronously and are required for muskie to serve a minimal subset of
+    // requests are ready prior to starting up the restify servers and beginning
+    // to handle requests.
+    var barrier = vasync.barrier();
 
-    app.startKangServer();
+    barrier.on('drain', clientsConnected.bind(null, muskie, cfg, clients));
+
+    // Establish minimal set of client connections required to begin
+    // successfully servicing non-jobs requests
+
+    clients.agent = new cueball.HttpAgent(cfg.cueballHttpAgent);
+    clients.mahi = createAuthCacheClient(cfg.auth, clients.agent);
+
+    barrier.start('createMorayClient');
+    createMorayClient(cfg.moray, onMorayConnect.bind(null, clients, barrier));
+
+    barrier.start('createPickerClient');
+    createPickerClient(cfg.storage, cfg.log,
+        onPickerConnect.bind(null, clients, barrier));
+
+    // Establish other client connections
+
+    createMarlinClient(cfg.marlin, onMarlinConnect.bind(null, clients));
+    createMedusaConnector(cfg.medusa, onMedusaConnect.bind(null, clients));
+    clients.sharkAgent = createCueballSharkAgent(cfg.sharkConfig);
+    clients.keyapi = createKeyAPIClient(cfg);
+
+    // Create monitoring server
+    createMonitoringServer(cfg);
 
     process.on('SIGHUP', process.exit.bind(process, 0));
 
-- 
2.21.0

