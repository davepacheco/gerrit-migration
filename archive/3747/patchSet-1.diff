From 7884dcc2d1c0082fb14b2dccf3a8ef91fcee5b85 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 27 Mar 2018 16:15:09 +0000
Subject: [PATCH] TRITON-278 Allow a larger number of concurrent NIC provisions
 on a single network

---
 .gitignore                  |   1 +
 lib/models/ip/provision.js  |  14 +++--
 lib/models/nic/provision.js |   2 +-
 lib/util/constants.js       |   5 +-
 package.json                |   2 +-
 test/lib/nic.js             |  37 +++++++------
 test/unit/nics.test.js      | 104 ++++++++++++++++++++++++++++++------
 7 files changed, 125 insertions(+), 40 deletions(-)

diff --git a/.gitignore b/.gitignore
index a051ea4..d2c1180 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,4 @@ data.json
 /docs/media
 /docs/*.html
 /docs/*.json
+.*.s[a-w][a-z]
diff --git a/lib/models/ip/provision.js b/lib/models/ip/provision.js
index 7a4c249..dff4a16 100644
--- a/lib/models/ip/provision.js
+++ b/lib/models/ip/provision.js
@@ -208,7 +208,7 @@ var util_ip = require('../../util/ip.js');
  * Gap length could be bigger than JavaScript's max int, so
  * cap it off on the Postgres side before it gets to Moray.
  */
-var MAX_GAP_LENGTH = 100;
+var MAX_GAP_LENGTH = constants.IP_PROVISION_GAP_LENGTH;
 
 var GAP_IP_STR_SQL = util.format(
     'SELECT * FROM (SELECT ipaddr+1 gap_start, least(coalesce(lead(ipaddr) ' +
@@ -249,6 +249,8 @@ ProvisionInfo.prototype.shift = function getNextIP() {
     params.etag = nextIP.etag;
     params.ip = nextIP.ip;
 
+    this.tries += 1;
+
     return new common.IP(params);
 };
 
@@ -447,8 +449,15 @@ function nextIPonNetwork(opts, network, callback) {
 
     var provinfo = opts.ipProvisions[network.uuid];
 
-    // We've exceeded the maximum number of tries: return stop err
     if (provinfo.tries > constants.IP_PROVISION_RETRIES) {
+        /*
+         * Hitting this limit usually indicates that we're trying to perform
+         * many concurrent provisions on the same network, although it could
+         * suggest other problems, like operating with stale information.
+         *
+         * We keep this limit higher than the gap length so that we'll fetch
+         * new gaps before hitting this in case our gap is stale.
+         */
         opts.log.error({ tries: constants.IP_PROVISION_RETRIES },
             'nextIPonNetwork: Exceeded IP provision retries');
         callback(new errors.SubnetFullError(network.uuid));
@@ -458,7 +467,6 @@ function nextIPonNetwork(opts, network, callback) {
     if (provinfo.queue.length !== 0) {
         // We still have an IP in the queue to try - no need to fetch more
         var next = provinfo.shift();
-        provinfo.tries++;
 
         opts.log.debug({
             next: next,
diff --git a/lib/models/nic/provision.js b/lib/models/nic/provision.js
index 9dd85f9..0092b63 100644
--- a/lib/models/nic/provision.js
+++ b/lib/models/nic/provision.js
@@ -283,7 +283,7 @@ NetworkPoolProvision.prototype.setIntersection =
 
 
 /**
- * Move on to the next network pool, and provision an IP from it.
+ * Move on to the next network in the pool, and provision an IP from it.
  */
 NetworkPoolProvision.prototype.nextNetwork =
     function nextNetworkPool(opts, callback) {
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 74aef90..2b12213 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -142,7 +142,8 @@ module.exports = {
     EXTERNAL_RENAME_MSG: 'external nic tag cannot be renamed',
     GATEWAY_SUBNET_MSG: 'gateway cannot be outside subnet',
     INVALID_IP_MSG: 'invalid IP address',
-    IP_PROVISION_RETRIES: 20,
+    IP_PROVISION_GAP_LENGTH: 50,
+    IP_PROVISION_RETRIES: 100,
     msg: MESSAGES,
     MAC_RETRIES: 50,
     MAX_AGGR_MACS: 16,
@@ -162,7 +163,7 @@ module.exports = {
         MTU_NETWORK_MIN + ' and ' + MTU_MAX,
     MTU_NETWORK_GT_NICTAG: 'network mtu must be under nic_tag mtu',
     MTU_NICTAG_UPDATE_MSG: 'nic_tag mtu update must support existing networks',
-    NIC_PROVISION_RETRIES: 100,
+    NIC_PROVISION_RETRIES: 150,
     OWNER_MATCH_MSG: 'network owner_uuids do not match',
     POOL_IP_MSG: 'IP cannot be specified with a network pool',
     POOL_MIN_NETS_MSG:
diff --git a/package.json b/package.json
index 3367745..ea1e7b6 100644
--- a/package.json
+++ b/package.json
@@ -27,7 +27,7 @@
     "verror": "1.9.0"
   },
   "devDependencies": {
-    "moray-sandbox": "0.1.1",
+    "moray-sandbox": "0.1.3",
     "faucet": "0.0.1",
     "istanbul": "^0.4.0",
     "eslint": "2.13.1",
diff --git a/test/lib/nic.js b/test/lib/nic.js
index da46b70..23805eb 100644
--- a/test/lib/nic.js
+++ b/test/lib/nic.js
@@ -158,28 +158,31 @@ function delAllCreatedNics(t) {
 
     var created = common.allCreated('nics');
     if (created.length === 0) {
-        t.ok(true, 'No nics created');
-        return t.end();
+        t.pass('No nics created');
+        t.end();
+        return;
     }
 
     common.clearCreated('nics');
 
-    mod_vasync.forEachParallel({
-        inputs: created,
-        func: function _delOne(nic, cb) {
-            var delOpts = {
-                mightNotExist: true,
-                continueOnErr: true,
-                exp: {},
-                params: nic,
-                mac: nic.mac
-            };
-
-            delNic(t, delOpts, cb);
-        }
-    }, function () {
-        return t.end();
+    var q = mod_vasync.queue(function _delOne(nic, cb) {
+        var delOpts = {
+            mightNotExist: true,
+            continueOnErr: true,
+            exp: {},
+            params: nic,
+            mac: nic.mac
+        };
+
+        delNic(t, delOpts, cb);
+    }, 100);
+
+    q.on('end', function () {
+        t.end();
     });
+
+    q.push(created);
+    q.close();
 }
 
 
diff --git a/test/unit/nics.test.js b/test/unit/nics.test.js
index 806be27..c7ac7e1 100644
--- a/test/unit/nics.test.js
+++ b/test/unit/nics.test.js
@@ -49,6 +49,7 @@ var NET2;
 var NET3;
 var NET4;
 var NET5;
+var NET6;
 var PROV_MAC_NET;
 
 
@@ -173,6 +174,20 @@ test('Initial setup', function (t) {
         });
     });
 
+    t.test('create net6', function (t2) {
+        num = h.NET_NUM;
+        var params = h.validNetworkParams();
+        mod_net.create(t2, {
+            params: params,
+            partialExp: params
+        }, function (_, res) {
+            NET6 = res;
+            NET6.num = num;
+
+            t2.end();
+        });
+    });
+
     t.test('create admin net', function (t2) {
         num = h.NET_NUM;
         var params = h.validNetworkParams({ name: 'admin' });
@@ -857,9 +872,15 @@ test('Provision nic: exceed IP retries', function (t) {
     };
 
     var startIP = h.nextProvisionableIP(PROV_MAC_NET, true);
+    var range = [];
+    for (var i = 0; i < constants.IP_PROVISION_GAP_LENGTH; i++) {
+        range.push(util_ip.ipAddrPlus(util_ip.toIPAddr(startIP), i).toString());
+    }
+
     var ips = [];
-    for (var i = 0; i < constants.IP_PROVISION_RETRIES + 2; i++) {
-        ips.push(util_ip.ipAddrPlus(util_ip.toIPAddr(startIP), i).toString());
+    var dlen = constants.IP_PROVISION_RETRIES + 1;
+    while (ips.length !== dlen) {
+        ips = ips.concat(range.slice(0, dlen - ips.length));
     }
 
     t.test('Count NICs before provision attempt', function (t2) {
@@ -900,6 +921,9 @@ test('Provision nic: exceed IP retries', function (t) {
             batch: [ ]
         }, 'no more batch errors left');
 
+        // Reset in case we didn't hit everything:
+        MORAY.setMockErrors({ });
+
         mod_moray.countNics(MORAY, function (err4, numNicsAfter) {
             t2.ifError(err4, 'Counting NICs should succeed');
             t2.equal(numNicsAfter, numNicsBefore,
@@ -908,23 +932,38 @@ test('Provision nic: exceed IP retries', function (t) {
         });
     });
 
-    ips.forEach(function (ip) {
-        t.test('Confirm that the IP is free: ' + ip, function (t2) {
-            NAPI.getIP(PROV_MAC_NET.uuid, ip, function (err2, res) {
-                if (h.ifErr(t2, err2, 'getIP error')) {
-                    t2.end();
-                    return;
-                }
+    function checkIP(t2, barrier, ip) {
+        var prefix = ip + ': ';
 
-                t2.equal(res.free, true, 'IP has been freed');
-                mod_moray.getIP(MORAY, PROV_MAC_NET.uuid,
-                    PROV_MAC_NET.provision_start_ip, function (err3, ipRec) {
-                    t2.ok(err3, 'Getting IP should fail');
-                    t2.ok(!ipRec, 'IP record does not exist in moray');
-                    t2.end();
-                });
+        barrier.start(ip);
+
+        NAPI.getIP(PROV_MAC_NET.uuid, ip, function (err2, res) {
+            if (h.ifErr(t2, err2, prefix + 'getIP error')) {
+                t2.end();
+                return;
+            }
+
+            t2.equal(res.free, true, prefix + 'IP has been freed');
+            mod_moray.getIP(MORAY, PROV_MAC_NET.uuid,
+                PROV_MAC_NET.provision_start_ip, function (err3, ipRec) {
+                t2.ok(err3, prefix + 'Getting IP should fail');
+                t2.ok(!ipRec, prefix + 'IP record does not exist in moray');
+
+                barrier.done(ip);
             });
         });
+    }
+
+    t.test('Confirm that unused IPs are free', function (t2) {
+        var barrier = vasync.barrier();
+
+        range.forEach(function (ip) {
+            checkIP(t2, barrier, ip);
+        });
+
+        barrier.on('drain', function () {
+            t2.end();
+        });
     });
 });
 
@@ -1296,6 +1335,39 @@ test('Provision NIC: Retry after QueryTimeoutErrors', function (t) {
 });
 
 
+test('Provision many NICs concurrently - same network', function (t) {
+    var barrier = vasync.barrier();
+    var concurrency = 100;
+
+    function createNIC(n) {
+        var name = 'nic-prov-' + n;
+        var params = {
+            belongs_to_type: 'zone',
+            belongs_to_uuid: mod_uuid.v4(),
+            owner_uuid: mod_uuid.v4()
+        };
+
+        barrier.start(name);
+
+        mod_nic.provision(t, {
+            net: NET6.uuid,
+            params: params,
+            partialExp: params
+        }, function () {
+            barrier.done(name);
+        });
+    }
+
+    for (var i = 0; i < concurrency; ++i) {
+        createNIC(i);
+    }
+
+    barrier.on('drain', function () {
+        t.end();
+    });
+});
+
+
 test('Provision nic - with IP', function (t) {
     t.plan(7);
     var d = {};
-- 
2.21.0

