From 0160c0931abcd130ee60c3ba23e970df8a8bdbed Mon Sep 17 00:00:00 2001
From: David Pacheco <dap@joyent.com>
Date: Tue, 20 Mar 2018 14:20:54 -0700
Subject: [PATCH] joyent/mdb_v8#107 would like dcmd for heuristically finding
 back references

---
 CHANGES.md                        |   5 +-
 GNUmakefile                       |   4 +-
 docs/usage.md                     | 104 ++++-
 src/mdb_v8.c                      | 436 ++++++++++++---------
 src/mdb_v8_dbg.h                  |  30 ++
 src/mdb_v8_dbi.c                  | 111 ++++++
 src/mdb_v8_dbi.h                  |  21 ++
 src/mdb_v8_impl.h                 |   9 +-
 src/mdb_v8_subr.c                 |  86 +++++
 src/mdb_v8_whatis.c               | 130 +++++++
 test/standalone/common.js         |  13 +-
 test/standalone/tst.jsfindrefs.js | 607 ++++++++++++++++++++++++++++++
 version                           |   2 +-
 13 files changed, 1373 insertions(+), 185 deletions(-)
 create mode 100644 src/mdb_v8_dbi.c
 create mode 100644 src/mdb_v8_dbi.h
 create mode 100644 src/mdb_v8_whatis.c
 create mode 100644 test/standalone/tst.jsfindrefs.js

diff --git a/CHANGES.md b/CHANGES.md
index b6aaa11..fb0bbe7 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -10,10 +10,11 @@
 
 # mdb_v8 changelog
 
-## Unreleased changes
+## v1.4.0 (2018-03)
 
+* #107 would like dcmd for heuristically finding back references
 * #111 want `::v8whatis`
-* #112 stack corruption in jsobj_properties()
+* #112 stack corruption in jsobj\_properties()
 
 ## v1.3.0 (2018-02-09)
 
diff --git a/GNUmakefile b/GNUmakefile
index 96d0d21..e767f3b 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -50,10 +50,12 @@ MDBV8_SOURCES		 = \
     mdb_v8.c \
     mdb_v8_array.c \
     mdb_v8_cfg.c \
+    mdb_v8_dbi.c \
     mdb_v8_function.c \
     mdb_v8_strbuf.c \
     mdb_v8_string.c \
-    mdb_v8_subr.c
+    mdb_v8_subr.c \
+    mdb_v8_whatis.c
 
 MDBV8_GENSOURCES	 = mdb_v8_version.c
 
diff --git a/docs/usage.md b/docs/usage.md
index 29efebc..9aaecb7 100644
--- a/docs/usage.md
+++ b/docs/usage.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright (c) 2017, Joyent, Inc.
+    Copyright (c) 2018, Joyent, Inc.
 -->
 
 # Postmortem debugging with mdb_v8
@@ -567,6 +567,8 @@ Option summary:
     -r       Find references to the specified and/or marked object(s)
     -v       Provide verbose statistics
 
+See also: `jsfindrefs`.
+
 ### jsclosure
 
     addr::jsclosure
@@ -705,6 +707,106 @@ function's underlying V8 heap object address for use with `v8function`.
 
 See also: `jsfunction`
 
+### jsfindrefs
+
+    addr::jsfindrefs [-dv] [-l maxdepth]
+
+Given an object identified by `addr`, attempts to find JavaScript values that
+appear to reference `addr`.  This command attempts to find all known types of
+reference, including:
+
+- objects with a property whose value is `addr`
+- arrays with an element whose value is `addr`
+- closures containing a variable whose value is `addr`
+- functions created with `Function.bind()` where `addr` is the value of one of
+  the bound variables
+- sliced strings whose underlying string is `addr`
+- regular expressions whose source string is `addr`
+
+and others.  For example, if `addr` is a socket, you could use this command to
+find higher-level objects with a reference to the socket.  This is useful in
+general debugging, and especially when debugging memory leaks in order to figure
+out why an object has not been garbage-collected.
+
+With no arguments, the command prints out other JavaScript values that
+reference the given value `addr`.  For example, suppose we start with this
+array:
+
+    > 8f912f09::jsprint -d1
+    [
+        16,
+        32,
+        64,
+        96,
+        "^regular expression!$",
+        [...],
+    ]
+
+We can find what other objects reference this array.  In this case, there's
+only one:
+
+    > 8f912f09::jsfindrefs
+    8f912df1
+
+If we print out that value, we can see that it's an object, and that it does
+indeed reference our array via a property called "anArray":
+
+    > 8f912df1::jsprint -a
+    8f912df1: {
+    ...
+        "anArray": 8f912f09: [
+            20: 16,
+            40: 32,
+            80: 64,
+            c0: 96,
+            bda8ae39: "^regular expression!$",
+            8f912df1: [...],
+        ],
+    ...
+    }
+
+In this case, the "parent" object is also an element of the array.  This is a
+circular reference.  If we print the object's references, we'll find the array
+among them:
+
+    > 8f912df1::jsfindrefs
+    ...
+    8f912f09
+
+With the `-v` option, `jsfindrefs` prints a brief summary of each reference that
+it finds:
+
+    > 8f912f09::jsfindrefs -v
+    8f912df1 (type: JSObject)
+
+    > 8f912df1::jsfindrefs -v
+    ...
+    8f912f09 (type: JSArray)
+
+The output format used for `-v` is subject to change.
+
+With the `-l maxdepth` option, `jsfindrefs` limits its search to at most
+`maxdepth` levels of indirection among the underlying V8 heap classes.  In
+practice, it's only necessary to traverse 1 or 2 back references to find
+legitimate JavaScript references, so the default value for this option is quite
+low.
+
+With the `-d` option, `jsfindrefs` prints information as it walks back the
+reference graph.  This is intended for debugging cases where the command
+misbehaves, though it's likely that familiarity with V8 internals is needed to
+make sense of the output.  The output format for `-d` is subject to change.
+
+As with the rest of mdb_v8, this command is heuristic and may produce incorrect
+or incomplete output.  Please file a bug if you encounter this.
+
+This command may report duplicate results.
+
+See also: `findjsobjects`.  This command is similar to `::findjsobjects -r`, but
+it's much faster, as it does not require parsing every JavaScript object in the
+program.  (It does scan all mappings in the address space, but this is generally
+quite quick.)
+
+
 ### jsframe
 
     addr::jsframe [-aiv] [-f function] [-p property] [-n numlines]
diff --git a/src/mdb_v8.c b/src/mdb_v8.c
index c436e0b..da901f5 100644
--- a/src/mdb_v8.c
+++ b/src/mdb_v8.c
@@ -35,6 +35,7 @@
 #include "v8cfg.h"
 #include "mdb_v8_version.h"
 #include "mdb_v8_dbg.h"
+#include "mdb_v8_dbi.h"
 
 #define	offsetof(s, m)	((size_t)(&(((s *)0)->m)))
 
@@ -1800,7 +1801,7 @@ read_typebyte(uint8_t *valp, uintptr_t addr)
  * Given a heap object, returns in *valp the size of the object.  For
  * variable-size objects, returns an undefined value.
  */
-static int
+int
 read_size(size_t *valp, uintptr_t addr)
 {
 	uintptr_t mapaddr;
@@ -2251,92 +2252,6 @@ obj_print_class(uintptr_t addr, v8_class_t *clp)
 	return (rv);
 }
 
-/*
- * Attempts to determine whether the object at "addr" might contain the address
- * "target".  This is used for low-level heuristic analysis.  Note that it's
- * possible that we cannot tell whether the address is contained (e.g., if this
- * is a variable-length object and we can't read how big it is).
- */
-static int
-obj_contains(uintptr_t addr, uint8_t type, uintptr_t target,
-    boolean_t *containsp, int memflags)
-{
-	size_t size;
-	uintptr_t objsize;
-
-	/*
-	 * For sequential strings, we need to look at how many characters there
-	 * are, and how many bytes per character are used to encode the string.
-	 * For other types of strings, the V8 heap object is not variable-sized,
-	 * so we can treat it like the other cases below.
-	 */
-	if (V8_TYPE_STRING(type) && V8_STRREP_SEQ(type)) {
-		v8string_t *strp;
-		size_t length;
-
-		if ((strp = v8string_load(addr, memflags)) == NULL) {
-			return (-1);
-		}
-
-		length = v8string_length(strp);
-
-		if (V8_STRENC_ASCII(type)) {
-			size = V8_OFF_SEQASCIISTR_CHARS + length;
-		} else {
-			size = V8_OFF_SEQTWOBYTESTR_CHARS + (2 * length);
-		}
-
-		v8string_free(strp);
-		*containsp = target < addr + size;
-		return (0);
-	}
-
-	if (type == V8_TYPE_FIXEDARRAY) {
-		v8fixedarray_t *arrayp;
-		size_t length;
-
-		if ((arrayp = v8fixedarray_load(addr, memflags)) == NULL) {
-			return (-1);
-		}
-
-		length = v8fixedarray_length(arrayp);
-		size = V8_OFF_FIXEDARRAY_DATA + length * sizeof (uintptr_t);
-		v8fixedarray_free(arrayp);
-		*containsp = target < addr + size;
-		return (0);
-	}
-
-	if (read_size(&objsize, addr) != 0) {
-		return (-1);
-	}
-
-	size = objsize;
-	if (type == V8_TYPE_JSOBJECT) {
-		/*
-		 * Instances of JSObject can also contain a number of property
-		 * values directly in the object.  To find out how many, we need
-		 * to read the count out of the map.  See jsobj_properties() for
-		 * details on how this works.
-		 */
-		uintptr_t map;
-		uint8_t ninprops;
-		if (mdb_vread(&map, sizeof (map),
-		    addr + V8_OFF_HEAPOBJECT_MAP) == -1) {
-			return (-1);
-		}
-
-		if (mdb_vread(&ninprops, sizeof (ninprops),
-		    map + V8_OFF_MAP_INOBJECT_PROPERTIES) == -1) {
-			return (-1);
-		}
-
-		size += ninprops * sizeof (uintptr_t);
-	}
-
-	*containsp = target < addr + size;
-	return (0);
-}
-
 /*
  * Print the ASCII string for the given JS string, expanding ConsStrings and
  * ExternalStrings as needed.
@@ -2561,6 +2476,13 @@ jsobj_maybe_garbage(uintptr_t addr)
  * property lookup in the V8 source code, currently in Object::GetProperty.
  */
 
+/* ARGSUSED */
+static int
+jsobj_noop(const char *name, v8propvalue_t *propval, void *arg)
+{
+	return (0);
+}
+
 static int
 jsobj_properties(uintptr_t addr,
     int (*func)(const char *, v8propvalue_t *, void *), void *arg,
@@ -4210,7 +4132,7 @@ dcmd_v8print_help(void)
 	    "class.  With no arguments, the appropriate class is detected\n"
 	    "automatically.  The 'class' argument overrides this to print an\n"
 	    "object as an instance of the given class.  The list of known\n"
-	    "classes can be viewed with ::jsclasses.");
+	    "classes can be viewed with ::v8classes.\n");
 }
 
 /* ARGSUSED */
@@ -6165,6 +6087,227 @@ dcmd_jsconstructor(uintptr_t addr, uint_t flags, int argc,
 	return (DCMD_OK);
 }
 
+typedef struct {
+	uintptr_t	jsfr_addr;
+	uintptr_t	jsfr_origaddr;
+	size_t		jsfr_maxoffset;
+	unsigned short	jsfr_curdepth;
+	unsigned short	jsfr_maxdepth;
+	boolean_t	jsfr_verbose;
+	boolean_t	jsfr_debug;
+} jsfindrefs_t;
+
+static int jsfindrefs(jsfindrefs_t *);
+static int jsfindrefs_reference(uintptr_t, void *);
+
+static void
+dcmd_jsfindrefs_help(void)
+{
+	mdb_printf("%s\n",
+"Given an address representing a JavaScript value, attempt to find JavaScript\n"
+"objects referencing that value.  These references might include objects\n"
+"having this value as a property, arrays having this value as an element,\n"
+"closures having this value in a closure variable, and many other cases.\n");
+
+	mdb_dec_indent(2);
+	mdb_printf("%<b>OPTIONS%</b>\n");
+	mdb_inc_indent(2);
+
+	mdb_printf("%s\n",
+"  -d           print debug info about graph traversal (unstable output)\n"
+"  -v           print verbose information about each match (unstable output)\n"
+"  -l maxdepth  limit search to at most \"maxdepth\" levels of indirection\n");
+}
+
+static int
+dcmd_jsfindrefs(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
+{
+	jsfindrefs_t jsfr;
+	int err;
+
+	if (!(flags & DCMD_ADDRSPEC)) {
+		mdb_warn("must specify address for ::jsfindrefs\n");
+		return (DCMD_USAGE);
+	}
+
+	jsfr.jsfr_addr = addr;
+	jsfr.jsfr_origaddr = addr;
+	jsfr.jsfr_curdepth = 0;
+	jsfr.jsfr_maxdepth = 5;
+	jsfr.jsfr_maxoffset = 16384;
+	jsfr.jsfr_verbose = B_FALSE;
+	jsfr.jsfr_debug = B_FALSE;
+
+	if (mdb_getopts(argc, argv,
+	    'v', MDB_OPT_SETBITS, B_TRUE, &jsfr.jsfr_verbose,
+	    'd', MDB_OPT_SETBITS, B_TRUE, &jsfr.jsfr_debug,
+	    'l', MDB_OPT_UINTPTR, &jsfr.jsfr_maxdepth, NULL) != argc) {
+		return (DCMD_USAGE);
+	}
+
+	err = jsfindrefs(&jsfr);
+	return (err == 0 ? DCMD_OK : DCMD_ERR);
+}
+
+static int
+jsfindrefs(jsfindrefs_t *jsfr)
+{
+	return (dbi_ugrep(jsfr->jsfr_addr, jsfindrefs_reference, jsfr));
+}
+
+static int
+jsfindrefs_reference(uintptr_t refaddr, void *arg)
+{
+	jsfindrefs_t *jsfr = arg;
+	v8whatis_t whatis;
+	v8whatis_error_t err;
+	boolean_t verbose = jsfr->jsfr_verbose;
+	boolean_t debug = jsfr->jsfr_debug;
+	jspropinfo_t propinfo;
+
+	if (debug) {
+		mdb_printf("depth %d: %p: found reference at %p: ",
+		    jsfr->jsfr_curdepth, jsfr->jsfr_addr, refaddr);
+	}
+
+	err = v8whatis(refaddr, jsfr->jsfr_maxoffset, &whatis);
+	if (err == V8W_ERR_NOTFOUND) {
+		if (debug) {
+			mdb_printf("no heap object found within %d bytes\n",
+			    jsfr->jsfr_maxoffset);
+		}
+
+		return (0);
+	}
+
+	if (err == V8W_ERR_DOESNTCONTAIN) {
+		if (debug) {
+			mdb_printf("does not appear to be contained in a "
+			    "heap object\n");
+		}
+
+		return (0);
+	}
+
+	if (err != V8W_OK) {
+		if (debug) {
+			mdb_printf("unknown error\n");
+		}
+
+		return (-1);
+	}
+
+	/*
+	 * If we're looking at a JSObject, check whether the object itself
+	 * appears to be garbage.
+	 */
+	propinfo = JPI_NONE;
+	if (whatis.v8w_basetype == V8_TYPE_JSOBJECT &&
+	    (jsobj_properties(whatis.v8w_baseaddr, jsobj_noop, NULL,
+	    &propinfo) != 0 || (propinfo & JPI_MAYBE_GARBAGE) != 0)) {
+		if (debug) {
+			mdb_printf("skipping apparent garbage object: "
+			    "%p (%x)\n", whatis.v8w_baseaddr, propinfo);
+		}
+
+		return (0);
+	}
+
+	/*
+	 * If we're looking at a JSFunction, check whether our depth is larger
+	 * than one.  The reason for this is that if we landed at a JSFunction,
+	 * this is likely to be a closure variable reference.  In that case, if
+	 * the depth is more than one, then we've likely walked up to parent
+	 * closures, which we want to avoid here.  (If we limited the global
+	 * depth to 1, we'd miss other important cases -- like Arrays.)
+	 */
+	if (whatis.v8w_basetype == V8_TYPE_JSFUNCTION &&
+	    jsfr->jsfr_curdepth > 1) {
+		if (debug) {
+			mdb_printf("skipping JSFunction reference %p "
+			    "at depth %d\n", whatis.v8w_baseaddr,
+			    jsfr->jsfr_curdepth);
+		}
+
+		return (0);
+	}
+
+	if (whatis.v8w_basetype == V8_TYPE_HEAPNUMBER ||
+	    whatis.v8w_basetype == V8_TYPE_MUTABLEHEAPNUMBER ||
+	    whatis.v8w_basetype == V8_TYPE_ODDBALL ||
+	    whatis.v8w_basetype == V8_TYPE_JSOBJECT ||
+	    whatis.v8w_basetype == V8_TYPE_JSARRAY ||
+	    whatis.v8w_basetype == V8_TYPE_JSFUNCTION ||
+	    whatis.v8w_basetype == V8_TYPE_JSDATE ||
+	    whatis.v8w_basetype == V8_TYPE_JSREGEXP ||
+	    whatis.v8w_basetype == V8_TYPE_JSTYPEDARRAY ||
+	    whatis.v8w_basetype == V8_TYPE_JSBOUNDFUNCTION ||
+	    (V8_TYPE_STRING(whatis.v8w_basetype) &&
+	    (V8_STRREP_CONS(whatis.v8w_basetype) ||
+	    V8_STRREP_SLICED(whatis.v8w_basetype)))) {
+		/*
+		 * Success!  We've found a real JavaScript value.
+		 */
+		if (debug || verbose) {
+			mdb_printf("%p (type: %s)\n", whatis.v8w_baseaddr,
+			    enum_lookup_str(v8_types, whatis.v8w_basetype,
+			    "(unknown)"));
+		} else {
+			mdb_printf("%p\n", whatis.v8w_baseaddr);
+		}
+
+		return (0);
+	}
+
+	if (whatis.v8w_basetype == V8_TYPE_FIXEDARRAY) {
+		/*
+		 * FixedArrays can be legitimate intermediate values for
+		 * array element references, closure references, and some
+		 * property references.  In this case, we'll take another lap,
+		 * assuming we haven't hit our depth limit.
+		 */
+		jsfindrefs_t subjsfr;
+
+		if (debug) {
+			mdb_printf("internal V8 intermediate object\n");
+		}
+
+		if (jsfr->jsfr_curdepth == jsfr->jsfr_maxdepth - 1) {
+			/*
+			 * We don't expect this to happen in practice very
+			 * often, since most JS values should be referenced by
+			 * some other JS value within less than 5 hops through
+			 * V8 values.  So it's worth letting the user know when
+			 * this happens.  If this becomes noisy, we could hide
+			 * this under v8_warn() or else figure out if we should
+			 * handle the noisy cases better.
+			 */
+			mdb_warn("%p: gave up after following %d references\n",
+			    jsfr->jsfr_origaddr, jsfr->jsfr_curdepth);
+			return (0);
+		} else {
+			subjsfr = *jsfr;
+			subjsfr.jsfr_addr = whatis.v8w_baseaddr;
+			subjsfr.jsfr_curdepth++;
+			return (jsfindrefs(&subjsfr));
+		}
+	}
+
+	/*
+	 * We could treat this the same as we do for FixedArrays, but at
+	 * this time, we don't know what other intermediate types there
+	 * are, so we don't know whether this makes any sense.  For now,
+	 * we just stop the search.
+	 */
+	if (debug) {
+		mdb_printf("giving up search at instance of %s\n",
+		    enum_lookup_str(v8_types, whatis.v8w_basetype,
+		    "(unknown)"));
+	}
+
+	return (0);
+}
+
 /* ARGSUSED */
 static int
 dcmd_jsframe(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
@@ -6857,10 +7000,10 @@ dcmd_v8warnings(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 static int
 dcmd_v8whatis(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
-	uintptr_t origaddr, curaddr, curvalue, ptrlowbits;
-	size_t curoffset, maxoffset = 4096;
-	boolean_t contained, verbose = B_FALSE;
-	uint8_t typebyte;
+	size_t maxoffset = 4096;
+	boolean_t verbose = B_FALSE;
+	v8whatis_t whatis;
+	v8whatis_error_t err;
 
 	if (!(flags & DCMD_ADDRSPEC)) {
 		mdb_warn("must specify address for ::v8whatis\n");
@@ -6878,112 +7021,48 @@ dcmd_v8whatis(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		    maxoffset);
 	}
 
-	origaddr = addr;
-
-	/*
-	 * Objects will always be stored at pointer-aligned addresses.  If we're
-	 * given an address that's not pointer-aligned, clear the low bits to
-	 * find the pointer-sized value containing the address given.
-	 */
-	ptrlowbits = sizeof (uintptr_t) - 1;
-	addr &= ~ptrlowbits;
-	assert(addr <= origaddr && origaddr - addr < sizeof (uintptr_t));
-
-	/*
-	 * On top of that, set the heap object tag bits.  Recall that most
-	 * mdb_v8 commands interpret values the same way as V8: if the tag bits
-	 * are set, then this is a heap object; otherwise, it's not.  And this
-	 * command only makes sense for heap objects, so one might expect that
-	 * we would bail if we're given something else.  But in practice, this
-	 * command is expected to be chained with `::ugrep` or some other
-	 * command that reports heap objects without the tag bits set, so it
-	 * makes sense to just assume they were supposed to be set.
-	 */
-	addr |= V8_HeapObjectTag;
-	if (verbose && origaddr != addr) {
+	err = v8whatis(addr, maxoffset, &whatis);
+	if (verbose && whatis.v8w_origaddr != whatis.v8w_addr) {
 		mdb_warn("assuming heap object at %p\n", addr);
 	}
 
-	/*
-	 * At this point, we walk backwards from the address we're given looking
-	 * for something that looks like a V8 heap object.
-	 */
-	for (curoffset = 0; curoffset < maxoffset;
-	    curoffset += sizeof (uintptr_t)) {
-		curaddr = addr - curoffset;
-		assert(V8_IS_HEAPOBJECT(curaddr));
-
-		if (read_heap_ptr(&curvalue, curaddr,
-		    V8_OFF_HEAPOBJECT_MAP) != 0 ||
-		    read_typebyte(&typebyte, curvalue) != 0) {
-			/*
-			 * The address we're looking at was either unreadable,
-			 * or we could not follow its Map pointer to find the
-			 * type byte.  This cannot be a valid heap object
-			 * because every heap object has a Map pointer as its
-			 * first field.
-			 */
-			continue;
-		}
-
-		if (typebyte != V8_TYPE_MAP) {
-			/*
-			 * The address we're looking at refers to something
-			 * other than a Map.  Again, this cannot be the address
-			 * of a valid heap object.
-			 */
-			continue;
-		}
-
-		/*
-		 * We've found what looks like a valid Map object.  See if we
-		 * can read its type byte, too.  If not, this is likely garbage.
-		 */
-		if (read_typebyte(&typebyte, curaddr) != 0) {
-			continue;
-		}
-
-		break;
-	}
-
-	if (curoffset >= maxoffset) {
+	if (err == V8W_ERR_NOTFOUND) {
 		if (verbose) {
 			mdb_warn("%p: no heap object found in previous "
 			    "%u bytes\n", addr, maxoffset);
 		}
+
 		return (DCMD_OK);
 	}
 
-	/*
-	 * At this point, check to see if the address that we were given might
-	 * be contained in this object.  If not, that means we found a Map for a
-	 * heap object that doesn't contain our target address.  We could have
-	 * checked this in the loop above so that we'd keep walking backwards in
-	 * this case, but we assume that Map objects aren't likely to appear
-	 * inside the middle of other valid objects, and thus that if we found a
-	 * Map and its heap object doesn't contain our target address, then
-	 * we're done -- there is no heap object containing our target.
-	 */
-	if (obj_contains(curaddr, typebyte, addr, &contained,
-	    UM_SLEEP | UM_GC) == 0 && !contained) {
+	if (err == V8W_ERR_DOESNTCONTAIN) {
 		if (verbose) {
 			mdb_warn("%p: heap object found at %p "
 			    "(%p-0x%x, type %s) does not appear to contain "
-			    "%p\n", addr, curaddr, addr, curoffset,
-			    enum_lookup_str(v8_types, typebyte, "(unknown)"),
-			    addr);
+			    "%p\n", whatis.v8w_origaddr,
+			    whatis.v8w_baseaddr,
+			    whatis.v8w_origaddr,
+			    whatis.v8w_origaddr - whatis.v8w_baseaddr,
+			    enum_lookup_str(v8_types, whatis.v8w_basetype,
+			    "(unknown)"), addr);
 		}
+
 		return (DCMD_OK);
 	}
 
+	if (err != V8W_OK) {
+		return (DCMD_ERR);
+	}
+
 	if (!verbose) {
-		mdb_printf("%p\n", curaddr);
+		mdb_printf("%p\n", whatis.v8w_baseaddr);
 		return (DCMD_OK);
 	}
 
-	mdb_printf("%p (found Map at %p (%p-0x%x) for type %s)", curaddr,
-	    curaddr, origaddr, origaddr - curaddr,
-	    enum_lookup_str(v8_types, typebyte, "(unknown)"));
+	mdb_printf("%p (found Map at %p (%p-0x%x) for type %s)\n",
+	    whatis.v8w_baseaddr, whatis.v8w_baseaddr, whatis.v8w_origaddr,
+	    whatis.v8w_origaddr - whatis.v8w_baseaddr,
+	    enum_lookup_str(v8_types, whatis.v8w_basetype, "(unknown)"));
 	return (DCMD_OK);
 }
 
@@ -7239,6 +7318,9 @@ static const mdb_dcmd_t v8_mdb_dcmds[] = {
 	{ "jsconstructor", ":[-v]",
 		"print the constructor for a JavaScript object",
 		dcmd_jsconstructor },
+	{ "jsfindrefs", ":[-dv] [-l maxdepth]",
+		"find JavaScript values referencing a value",
+		dcmd_jsfindrefs, dcmd_jsfindrefs_help },
 	{ "jsframe", ":[-aiv] [-f function] [-p property] [-n numlines]",
 		"summarize a JavaScript stack frame", dcmd_jsframe },
 	{ "jsfunction", ":", "print information about a JavaScript function",
diff --git a/src/mdb_v8_dbg.h b/src/mdb_v8_dbg.h
index dbedbaa..b9c0705 100644
--- a/src/mdb_v8_dbg.h
+++ b/src/mdb_v8_dbg.h
@@ -332,4 +332,34 @@ int v8boundfunction_iter_args(v8boundfunction_t *,
     int (*)(v8boundfunction_t *, uint_t, uintptr_t, void *), void *);
 void v8boundfunction_free(v8boundfunction_t *);
 
+
+/*
+ * Higher-level functions.
+ */
+
+/*
+ * v8contains() attempts to determine whether a given V8 heap object contains a
+ * target address.
+ */
+int v8contains(uintptr_t, uint8_t, uintptr_t, boolean_t *);
+
+/*
+ * v8whatis() attempts to find the V8 heap object that contains the target
+ * address.
+ */
+typedef enum {
+	V8W_OK = 0,
+	V8W_ERR_NOTFOUND = 1,
+	V8W_ERR_DOESNTCONTAIN = 2
+} v8whatis_error_t;
+
+typedef struct {
+	uintptr_t	v8w_addr;	/* user-supplied address */
+	uintptr_t	v8w_origaddr;	/* adjusted address */
+	uintptr_t	v8w_baseaddr;	/* address of containing V8 object */
+	uint8_t		v8w_basetype;	/* type of containing V8 object */
+} v8whatis_t;
+
+v8whatis_error_t v8whatis(uintptr_t, size_t, v8whatis_t *);
+
 #endif	/* _MDBV8DBG_H */
diff --git a/src/mdb_v8_dbi.c b/src/mdb_v8_dbi.c
new file mode 100644
index 0000000..3659fbc
--- /dev/null
+++ b/src/mdb_v8_dbi.c
@@ -0,0 +1,111 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * mdb_v8_dbi.c: implementation of interfaces typically provided by the
+ * surrounding debugger (i.e., mdb).  Various low-level functions in mdb_v8.c
+ * (e.g., read_heap_ptr() and related functions) ought to be polished and moved
+ * into here.
+ */
+
+#include "mdb_v8_impl.h"
+
+#include <libproc.h>
+
+/*
+ * dbi_ugrep(addr, func, arg): find references to "addr" in the address space
+ * and invoke "func" for each one.  Specifically, scans all pointer-aligned
+ * values in mapped memory and invokes "func" for each one whose value is
+ * "addr".
+ *
+ * mdb provides a "::ugrep" dcmd that implements this sort of search (with much
+ * more flexibility), but there's no way for us to use it here (except maybe via
+ * an "::eval" that calls back into a private dcmd that we write).  Since it's
+ * not that complicated to begin with, we essentially reimplement it here.
+ */
+
+/*
+ * Describes the state of a "ugrep" operation.
+ */
+typedef struct ugrep_op {
+	uintptr_t	ug_addr;	/* address we're searching for */
+	int		ug_result;	/* ret code of the ugrep operation */
+	int		(*ug_callback)(uintptr_t, void *);	/* user cb */
+	void		*ug_cbarg;	/* user callback args */
+	uintptr_t	*ug_buf;	/* buffer for reading memory */
+	size_t		ug_bufsz;	/* size of "ug_buf" */
+} ugrep_op_t;
+
+static int ugrep_mapping(ugrep_op_t *, const prmap_t *, const char *);
+
+int
+dbi_ugrep(uintptr_t addr, int (*callback)(uintptr_t, void *), void *cbarg)
+{
+	struct ps_prochandle *Pr;
+	ugrep_op_t ugrep;
+	int err;
+
+	if (mdb_get_xdata("pshandle", &Pr, sizeof (Pr)) == -1) {
+		mdb_warn("couldn't read pshandle xdata");
+		return (-1);
+	}
+
+	ugrep.ug_addr = addr;
+	ugrep.ug_result = 0;
+	ugrep.ug_callback = callback;
+	ugrep.ug_cbarg = cbarg;
+	ugrep.ug_bufsz = 4096;
+	ugrep.ug_buf = mdb_zalloc(ugrep.ug_bufsz, UM_SLEEP);
+
+	err = Pmapping_iter(Pr, (proc_map_f *)ugrep_mapping, &ugrep);
+	mdb_free(ugrep.ug_buf, ugrep.ug_bufsz);
+
+	return (err != 0 ? -1 : ugrep.ug_result);
+}
+
+/* ARGSUSED */
+static int
+ugrep_mapping(ugrep_op_t *ugrep, const prmap_t *pmp, const char *name)
+{
+	uintptr_t chunkbase, vaddr;
+	uintptr_t *buf;
+	size_t ntoread, bufsz, nptrs, i;
+
+	buf = ugrep->ug_buf;
+	bufsz = ugrep->ug_bufsz;
+
+	for (chunkbase = pmp->pr_vaddr;
+	    chunkbase < pmp->pr_vaddr + pmp->pr_size; chunkbase += bufsz) {
+		ntoread = MIN(bufsz,
+		    pmp->pr_size - (chunkbase - pmp->pr_vaddr));
+
+		if (mdb_vread(buf, ntoread, chunkbase) == -1) {
+			/*
+			 * Some mappings are not present in core files.  This
+			 * does not represent an error case here.
+			 */
+			continue;
+		}
+
+		nptrs = ntoread / sizeof (uintptr_t);
+		for (i = 0; i < nptrs; i++) {
+			if (buf[i] == ugrep->ug_addr) {
+				vaddr = chunkbase + (i * sizeof (uintptr_t));
+				ugrep->ug_result = ugrep->ug_callback(vaddr,
+				    ugrep->ug_cbarg);
+				if (ugrep->ug_result != 0) {
+					return (-1);
+				}
+			}
+		}
+	}
+
+	return (0);
+}
diff --git a/src/mdb_v8_dbi.h b/src/mdb_v8_dbi.h
new file mode 100644
index 0000000..21326a1
--- /dev/null
+++ b/src/mdb_v8_dbi.h
@@ -0,0 +1,21 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * mdb_v8_dbi.h: interfaces typically provided by the surrounding debugger
+ * (i.e., mdb).
+ */
+
+#ifndef	_MDBV8DBI_H
+#define	_MDBV8DBI_H
+
+int dbi_ugrep(uintptr_t, int (*func)(uintptr_t, void *), void *);
+
+#endif	/* _MDBV8DBI_H */
diff --git a/src/mdb_v8_impl.h b/src/mdb_v8_impl.h
index ddb9de9..287768c 100644
--- a/src/mdb_v8_impl.h
+++ b/src/mdb_v8_impl.h
@@ -43,6 +43,7 @@ int read_heap_array(uintptr_t, uintptr_t **, size_t *, int);
 int read_heap_maybesmi(uintptr_t *, uintptr_t, ssize_t);
 int read_heap_ptr(uintptr_t *, uintptr_t, ssize_t);
 int read_heap_smi(uintptr_t *, uintptr_t, ssize_t);
+int read_size(size_t *, uintptr_t);
 int read_typebyte(uint8_t *, uintptr_t);
 void v8_warn(const char *, ...);
 boolean_t jsobj_is_undefined(uintptr_t);
@@ -51,10 +52,12 @@ boolean_t jsobj_is_undefined(uintptr_t);
  * We need to find a better way of exposing this information.  For now, these
  * represent all the metadata constants used by multiple C files.
  */
+extern intptr_t V8_TYPE_FIXEDARRAY;
 extern intptr_t V8_TYPE_JSARRAY;
-extern intptr_t V8_TYPE_JSFUNCTION;
 extern intptr_t V8_TYPE_JSBOUNDFUNCTION;
-extern intptr_t V8_TYPE_FIXEDARRAY;
+extern intptr_t V8_TYPE_JSFUNCTION;
+extern intptr_t V8_TYPE_JSOBJECT;
+extern intptr_t V8_TYPE_MAP;
 
 extern intptr_t V8_IsNotStringMask;
 extern intptr_t V8_StringTag;
@@ -77,6 +80,7 @@ extern ssize_t V8_OFF_CONSSTRING_SECOND;
 extern ssize_t V8_OFF_EXTERNALSTRING_RESOURCE;
 extern ssize_t V8_OFF_FIXEDARRAY_DATA;
 extern ssize_t V8_OFF_FIXEDARRAY_LENGTH;
+extern ssize_t V8_OFF_HEAPOBJECT_MAP;
 extern ssize_t V8_OFF_JSARRAY_LENGTH;
 extern ssize_t V8_OFF_JSBOUNDFUNCTION_BOUND_ARGUMENTS;
 extern ssize_t V8_OFF_JSBOUNDFUNCTION_BOUND_TARGET_FUNCTION;
@@ -85,6 +89,7 @@ extern ssize_t V8_OFF_JSFUNCTION_CONTEXT;
 extern ssize_t V8_OFF_JSFUNCTION_LITERALS_OR_BINDINGS;
 extern ssize_t V8_OFF_JSFUNCTION_SHARED;
 extern ssize_t V8_OFF_JSOBJECT_ELEMENTS;
+extern ssize_t V8_OFF_MAP_INOBJECT_PROPERTIES;
 extern ssize_t V8_OFF_SCRIPT_LINE_ENDS;
 extern ssize_t V8_OFF_SCRIPT_NAME;
 extern ssize_t V8_OFF_SEQASCIISTR_CHARS;
diff --git a/src/mdb_v8_subr.c b/src/mdb_v8_subr.c
index d55e490..f90936e 100644
--- a/src/mdb_v8_subr.c
+++ b/src/mdb_v8_subr.c
@@ -165,3 +165,89 @@ v8fixedarray_length(v8fixedarray_t *arrayp)
 {
 	return (arrayp->v8fa_nelts);
 }
+
+/*
+ * Attempts to determine whether the object at "addr" might contain the address
+ * "target".  This is used for low-level heuristic analysis.  Note that it's
+ * possible that we cannot tell whether the address is contained (e.g., if this
+ * is a variable-length object and we can't read how big it is).
+ */
+int
+v8contains(uintptr_t addr, uint8_t type, uintptr_t target,
+    boolean_t *containsp)
+{
+	size_t size;
+	uintptr_t objsize;
+
+	/*
+	 * For sequential strings, we need to look at how many characters there
+	 * are, and how many bytes per character are used to encode the string.
+	 * For other types of strings, the V8 heap object is not variable-sized,
+	 * so we can treat it like the other cases below.
+	 */
+	if (V8_TYPE_STRING(type) && V8_STRREP_SEQ(type)) {
+		v8string_t *strp;
+		size_t length;
+
+		if ((strp = v8string_load(addr, UM_SLEEP)) == NULL) {
+			return (-1);
+		}
+
+		length = v8string_length(strp);
+
+		if (V8_STRENC_ASCII(type)) {
+			size = V8_OFF_SEQASCIISTR_CHARS + length;
+		} else {
+			size = V8_OFF_SEQTWOBYTESTR_CHARS + (2 * length);
+		}
+
+		v8string_free(strp);
+		*containsp = target < addr + size;
+		return (0);
+	}
+
+	if (type == V8_TYPE_FIXEDARRAY) {
+		v8fixedarray_t *arrayp;
+		size_t length;
+
+		if ((arrayp = v8fixedarray_load(addr, UM_SLEEP)) == NULL) {
+			return (-1);
+		}
+
+		length = v8fixedarray_length(arrayp);
+		size = V8_OFF_FIXEDARRAY_DATA + length * sizeof (uintptr_t);
+		v8fixedarray_free(arrayp);
+		*containsp = target < addr + size;
+		return (0);
+	}
+
+	if (read_size(&objsize, addr) != 0) {
+		return (-1);
+	}
+
+	size = objsize;
+	if (type == V8_TYPE_JSOBJECT) {
+		/*
+		 * Instances of JSObject can also contain a number of property
+		 * values directly in the object.  To find out how many, we need
+		 * to read the count out of the map.  See jsobj_properties() for
+		 * details on how this works.
+		 */
+		uintptr_t map;
+		uint8_t ninprops;
+		if (mdb_vread(&map, sizeof (map),
+		    addr + V8_OFF_HEAPOBJECT_MAP) == -1) {
+			return (-1);
+		}
+
+		if (mdb_vread(&ninprops, sizeof (ninprops),
+		    map + V8_OFF_MAP_INOBJECT_PROPERTIES) == -1) {
+			return (-1);
+		}
+
+		size += ninprops * sizeof (uintptr_t);
+	}
+
+	*containsp = target < addr + size;
+	return (0);
+}
diff --git a/src/mdb_v8_whatis.c b/src/mdb_v8_whatis.c
new file mode 100644
index 0000000..c7c4b66
--- /dev/null
+++ b/src/mdb_v8_whatis.c
@@ -0,0 +1,130 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * mdb_v8_whatis.c: implementation of "v8whatis" functionality.
+ */
+
+#include <assert.h>
+
+#include "v8dbg.h"
+#include "mdb_v8_dbg.h"
+#include "mdb_v8_impl.h"
+
+/*
+ * v8whatis() attempts to find the V8 heap object that contains "addr" by
+ * looking at up to "maxoffset" bytes leading up to "addr" for the specific
+ * signature that indicates a V8 heap object, and then interpreting any possible
+ * heap object to see if the target address is indeed contained within it.
+ * Results are stored into "whatisp", and any errors are returned as a
+ * "v8whatis_error_t".  Note that as many fields of "whatisp" are populated as
+ * possible, so even if you get V8W_ERR_DOESNTCONTAIN (which indicates that we
+ * found an object, but it doesn't seem to contain the target), then
+ * v8w_baseaddr and v8w_basetype are still valid.
+ */
+v8whatis_error_t
+v8whatis(uintptr_t addr, size_t maxoffset, v8whatis_t *whatisp)
+{
+	uintptr_t origaddr, curaddr, curvalue, ptrlowbits;
+	size_t curoffset;
+	boolean_t contained;
+	uint8_t typebyte;
+
+	origaddr = addr;
+	whatisp->v8w_origaddr = origaddr;
+
+	/*
+	 * Objects will always be stored at pointer-aligned addresses.  If we're
+	 * given an address that's not pointer-aligned, clear the low bits to
+	 * find the pointer-sized value containing the address given.
+	 */
+	ptrlowbits = sizeof (uintptr_t) - 1;
+	addr &= ~ptrlowbits;
+	assert(addr <= origaddr && origaddr - addr < sizeof (uintptr_t));
+
+	/*
+	 * On top of that, set the heap object tag bits.  Recall that most
+	 * mdb_v8 operations interpret values the same way as V8: if the tag
+	 * bits are set, then this is a heap object; otherwise, it's not.  And
+	 * this command only makes sense for heap objects, so one might expect
+	 * that we would bail if we're given something else.  But in practice,
+	 * this command is expected to be chained with `::ugrep` or some other
+	 * command that reports heap objects without the tag bits set, so it
+	 * makes sense to just assume they were supposed to be set.
+	 */
+	addr |= V8_HeapObjectTag;
+	whatisp->v8w_addr = addr;
+
+	/*
+	 * At this point, we walk backwards from the address we're given looking
+	 * for something that looks like a V8 heap object.
+	 */
+	for (curoffset = 0; curoffset < maxoffset;
+	    curoffset += sizeof (uintptr_t)) {
+		curaddr = addr - curoffset;
+		assert(V8_IS_HEAPOBJECT(curaddr));
+
+		if (read_heap_ptr(&curvalue, curaddr,
+		    V8_OFF_HEAPOBJECT_MAP) != 0 ||
+		    read_typebyte(&typebyte, curvalue) != 0) {
+			/*
+			 * The address we're looking at was either unreadable,
+			 * or we could not follow its Map pointer to find the
+			 * type byte.  This cannot be a valid heap object
+			 * because every heap object has a Map pointer as its
+			 * first field.
+			 */
+			continue;
+		}
+
+		if (typebyte != V8_TYPE_MAP) {
+			/*
+			 * The address we're looking at refers to something
+			 * other than a Map.  Again, this cannot be the address
+			 * of a valid heap object.
+			 */
+			continue;
+		}
+
+		/*
+		 * We've found what looks like a valid Map object.  See if we
+		 * can read its type byte, too.  If not, this is likely garbage.
+		 */
+		if (read_typebyte(&typebyte, curaddr) != 0) {
+			continue;
+		}
+
+		break;
+	}
+
+	if (curoffset >= maxoffset) {
+		return (V8W_ERR_NOTFOUND);
+	}
+
+	whatisp->v8w_baseaddr = curaddr;
+	whatisp->v8w_basetype = typebyte;
+
+	/*
+	 * At this point, check to see if the address that we were given might
+	 * be contained in this object.  If not, that means we found a Map for a
+	 * heap object that doesn't contain our target address.  We could have
+	 * checked this in the loop above so that we'd keep walking backwards in
+	 * this case, but we assume that Map objects aren't likely to appear
+	 * inside the middle of other valid objects, and thus that if we found a
+	 * Map and its heap object doesn't contain our target address, then
+	 * we're done -- there is no heap object containing our target.
+	 */
+	if (v8contains(curaddr, typebyte, addr, &contained) == 0 &&
+	    !contained) {
+		return (V8W_ERR_DOESNTCONTAIN);
+	}
+
+	return (V8W_OK);
+}
diff --git a/test/standalone/common.js b/test/standalone/common.js
index 8ecfbf9..80754eb 100644
--- a/test/standalone/common.js
+++ b/test/standalone/common.js
@@ -190,11 +190,22 @@ MdbSession.prototype.checkMdbLeaks = function (callback)
  */
 function createMdbSessionFile(filename, callback)
 {
+	var envval, rmcore;
+
+	envval = process.env['MDBV8_TEST_KEEPCORE'];
+	if (envval !== undefined) {
+		envval = envval.toLowerCase();
+		rmcore = envval != 'true' && envval != '1' &&
+		    envval != 'yes';
+	} else {
+		rmcore = true;
+	}
+
 	return (createMdbSession({
 	    'targetType': 'file',
 	    'targetName': filename,
 	    'loadDmod': true,
-	    'removeOnSuccess': true
+	    'removeOnSuccess': rmcore
 	}, callback));
 }
 
diff --git a/test/standalone/tst.jsfindrefs.js b/test/standalone/tst.jsfindrefs.js
new file mode 100644
index 0000000..445c22d
--- /dev/null
+++ b/test/standalone/tst.jsfindrefs.js
@@ -0,0 +1,607 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * tst.jsfindrefs.js: exercises the ::jsfindrefs dcmd.  See
+ * test/standalone/tst.common.js for information about how this works.
+ */
+
+var assert = require('assert');
+var jsprim = require('jsprim');
+var path = require('path');
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var common = require('./common');
+
+/*
+ * Construct an object graph that represents a variety of cases.  We want to
+ * make sure we cover object property references, array element references,
+ * closure variable references, and references within built-in types (like bound
+ * functions, regular expressions, and so on).
+ *
+ * Initialization of the main test object happens inside init() in order to
+ * avoid closures picking up an additional reference to all the other top-level
+ * properties.
+ */
+var testObject;			/* used to find all values of interest */
+var testObjectAddr;		/* address (in core file) of "testObject" */
+var testAddrs = {};		/* addresses of "testObject" values */
+var bigObjectAddrs = {};	/* addresses of "bigObject" values */
+var simpleProps = [
+    'aRegExp',
+    'aBigObject',
+    'aSubObject',
+    'anArray',
+    'aSlicedString',
+    'aConsString',
+    'aClosure'
+];
+
+function init()
+{
+	var aString = '^regular expression!$';
+	var aLongerString = '0123456789012345678901234567890123456789';
+	var aDummyString = 'dummy';
+	var i;
+
+	testObject = {
+	    'aString': aString,
+	    'aDummyString': aDummyString,
+	    'aLongerString': aLongerString,
+	    'aRegExp': new RegExp(aString),
+	    'aBigObject': {},
+	    'aSubObject': {},
+	    'anArray': [ 16, 32, 64, 96, aString ],
+	    'aSlicedString': aLongerString.slice(1, 37),
+	    'aConsString': aString.concat('boom'),
+	    'aClosure': function leakClosureVariables() {
+		/* This closure should have a reference to aDummyString. */
+		console.log(aDummyString);
+	    },
+	    'aBoundFunction': main.bind(null, aString),
+	    'aNull': null,
+	    'anUndefined': undefined,
+	    'aTrue': true,
+	    'aFalse': false
+	};
+
+	/* Create a circular reference via the array. */
+	testObject['anArray'].push(testObject);
+
+	/* Flesh out a large object. */
+	for (i = 0; i < 128; i++) {
+		testObject['aBigObject']['prop_' + i] = 'str_' + i;
+	}
+}
+
+function main()
+{
+	var testFuncs;
+
+	init();
+
+	testFuncs = [];
+	testFuncs.push(function findTestObject(mdb, callback) {
+		common.findTestObject(mdb, function gotTestObject(err, addr) {
+			testObjectAddr = addr;
+			callback(err);
+		});
+	});
+	testFuncs.push(findTopLevelObjects);
+	testFuncs.push(testPropsSimple);
+	testFuncs.push(testPropsSimpleVerbose);
+	testFuncs.push(testPropViaSlicedString);
+	testFuncs.push(testPropAString);
+	testFuncs.push(testPropADummyString);
+	testFuncs.push(findBigObjectProperties);
+	testFuncs.push(testBigObjectProp);
+	testFuncs.push(testCycle);
+	testFuncs.push(testBogusAddress);
+	testFuncs.push(testNonJsFindMain);
+	testFuncs.push(testNonJsFindShared);
+	testFuncs.push(testNonJsFindScript);
+	testFuncs.push(testNonJsTest);
+
+	testFuncs.push(function (mdb, callback) {
+		mdb.checkMdbLeaks(callback);
+	});
+
+	common.finalizeTestObject(testObject);
+	common.standaloneTest(testFuncs, function (err) {
+		if (err) {
+			throw (err);
+		}
+
+		console.log('%s passed', process.argv[1]);
+	});
+}
+
+/*
+ * Locates the test addresses for each of the properties of "testObject".
+ */
+function findTopLevelObjects(mdb, callback)
+{
+	console.error('test: locating top-level property addresses');
+	assert.equal('string', typeof (testObjectAddr));
+	mdb.runCmd(testObjectAddr + '::jsprint -ad1\n', function (output) {
+		parseJsPrint(testObject, testAddrs, output);
+		console.error(testAddrs);
+		callback();
+	});
+}
+
+/*
+ * For each of the properties of "testObject" that are not referenced anywhere
+ * else, use "::jsfindrefs" to find the one reference.  This only really
+ * exercises the cases of values referenced via an object property.
+ */
+function testPropsSimple(mdb, callback)
+{
+	console.error('test: normal output for single-reference properties');
+	vasync.forEachPipeline({
+	    'inputs': simpleProps,
+	    'func': function testOneSimpleProperty(propname, subcb) {
+		var propaddr;
+
+		assert.equal('string', typeof (testAddrs[propname]));
+		propaddr = testAddrs[propname];
+		mdb.runCmd(propaddr + '::jsfindrefs\n', function (output) {
+			var lines;
+			lines = common.splitMdbLines(output, { 'count': 1 });
+			assert.equal(lines[0], testObjectAddr);
+			subcb();
+		});
+	    }
+	}, callback);
+}
+
+/*
+ * Similar to "testPropsSimple", but this test exercises the verbose mode of
+ * "::jsfindrefs".
+ */
+function testPropsSimpleVerbose(mdb, callback)
+{
+	console.error('test: verbose output for single-reference properties');
+	vasync.forEachPipeline({
+	    'inputs': simpleProps,
+	    'func': function testOneSimpleProperty(propname, subcb) {
+		var propaddr;
+
+		assert.equal('string', typeof (testAddrs[propname]));
+		propaddr = testAddrs[propname];
+		mdb.runCmd(propaddr + '::jsfindrefs -v\n', function (output) {
+			var lines, expected;
+			lines = common.splitMdbLines(output, { 'count': 1 });
+			expected = testObjectAddr + ' (type: JSObject)';
+			assert.equal(lines[0], expected);
+			subcb();
+		});
+	    }
+	}, callback);
+}
+
+/*
+ * Test that we can find references to objects via a SlicedString.  We use the
+ * "aLongerString" property, which should have two references: one from our
+ * main test object, and one from the "aSlicedString" object.
+ */
+function testPropViaSlicedString(mdb, callback)
+{
+	var addr;
+
+	console.error('test: sliced string reference');
+	assert.equal('string', typeof (testAddrs['aLongerString']));
+	addr = testAddrs['aLongerString'];
+
+	vasync.forEachPipeline({
+	    'inputs': [
+		addr + '::jsfindrefs ! sort\n',
+		addr + '::jsfindrefs -v ! sort\n'
+	    ],
+	    'func': function runCmd(cmd, subcallback) {
+		mdb.runCmd(cmd, function (output) {
+			subcallback(null, output);
+		});
+	    }
+	}, function (err, results) {
+		var lines, expectedAddrs, expectedVerbose;
+
+		assert.ok(!err);
+		expectedAddrs = [
+		    testObjectAddr,
+		    testAddrs['aSlicedString']
+		].sort();
+		lines = common.splitMdbLines(results.operations[0].result,
+		    { 'count': 2 });
+		assert.equal(lines[0], expectedAddrs[0]);
+		assert.equal(lines[1], expectedAddrs[1]);
+
+		expectedVerbose = [
+		    testObjectAddr + ' (type: JSObject)',
+		    testAddrs['aSlicedString'] + ' (type: SlicedString)'
+		].sort();
+		lines = common.splitMdbLines(results.operations[1].result,
+		    { 'count': 2 });
+		assert.equal(lines[0], expectedVerbose[0]);
+		assert.equal(lines[1], expectedVerbose[1]);
+
+		callback();
+	});
+}
+
+/*
+ * Tests that we can find all the references to our special string, "aString".
+ * This will exercise the ability to find string references via:
+ *
+ *   - common object property
+ *   - regular expressions
+ *   - ConsStrings
+ *   - bound functions
+ *   - array elements
+ */
+function testPropAString(mdb, callback)
+{
+	var addr;
+
+	console.error('test: several basic types of reference');
+	assert.equal('string', typeof (testAddrs['aString']));
+	addr = testAddrs['aString'];
+
+	vasync.forEachPipeline({
+	    'inputs': [
+		/*
+		 * This produces duplicates in some cases.  This would be nice
+		 * to avoid, but it's not a high priority at the moment.
+		 */
+		addr + '::jsfindrefs ! sort -u\n',
+		addr + '::jsfindrefs -v ! sort -u\n'
+	    ],
+	    'func': function runCmd(cmd, subcallback) {
+		mdb.runCmd(cmd, function (output) {
+			subcallback(null, output);
+		});
+	    }
+	}, function (err, results) {
+		var lines, expectedAddrs, expectedVerbose;
+		var output, functype;
+
+		assert.ok(!err);
+		output = results.operations[0].result;
+		expectedAddrs = [
+		    testObjectAddr,
+		    testAddrs['aConsString'],
+		    testAddrs['anArray'],
+		    testAddrs['aRegExp'],
+		    testAddrs['aBoundFunction']
+		].sort();
+		lines = common.splitMdbLines(output,
+		    { 'count': expectedAddrs.length });
+		assert.deepEqual(lines, expectedAddrs);
+
+		/*
+		 * The implementation class for a bound function depends
+		 * on the Node version.  See the corresponding comments in
+		 * mdb_v8.c and in v8boundfunction_load() for details.
+		 */
+		output = results.operations[1].result;
+		functype = output.indexOf('JSBoundFunction') != -1 ?
+		    'JSBoundFunction': 'JSFunction';
+		expectedVerbose = [
+		    testObjectAddr + ' (type: JSObject)',
+		    testAddrs['aConsString'] + ' (type: ConsString)',
+		    testAddrs['anArray'] + ' (type: JSArray)',
+		    testAddrs['aRegExp'] + ' (type: JSRegExp)',
+		    testAddrs['aBoundFunction'] + ' (type: ' + functype + ')'
+		].sort();
+		lines = common.splitMdbLines(output,
+		    { 'count': expectedVerbose.length });
+		assert.deepEqual(lines, expectedVerbose);
+
+		callback();
+	});
+}
+
+/*
+ * Tests that we can find the references we expect to "aDummyString", which is
+ * used only via a normal property reference and a closure variable.
+ */
+function testPropADummyString(mdb, callback)
+{
+	var addr;
+
+	console.error('test: closure references');
+	assert.equal('string', typeof (testAddrs['aDummyString']));
+	addr = testAddrs['aDummyString'];
+
+	vasync.forEachPipeline({
+	    'inputs': [
+		addr + '::jsfindrefs ! sort\n',
+		addr + '::jsfindrefs -v ! sort\n'
+	    ],
+	    'func': function runCmd(cmd, subcallback) {
+		mdb.runCmd(cmd, function (output) {
+			subcallback(null, output);
+		});
+	    }
+	}, function (err, results) {
+		var lines, expectedAddrs, expectedVerbose;
+
+		assert.ok(!err);
+		expectedAddrs = [
+		    testObjectAddr,
+		    testAddrs['aClosure']
+		].sort();
+
+		lines = common.splitMdbLines(results.operations[0].result,
+		    { 'count': expectedAddrs.length });
+		assert.deepEqual(lines, expectedAddrs);
+
+		expectedVerbose = [
+		    testObjectAddr + ' (type: JSObject)',
+		    testAddrs['aClosure'] + ' (type: JSFunction)'
+		].sort();
+
+		lines = common.splitMdbLines(results.operations[1].result,
+		    { 'count': expectedVerbose.length });
+		assert.deepEqual(lines, expectedVerbose);
+		callback();
+	});
+}
+
+/*
+ * Locates the addresses of the property values inside our big object.
+ */
+function findBigObjectProperties(mdb, callback)
+{
+	console.error('test: locating big object properties');
+	assert.equal('string', typeof (testAddrs['aBigObject']));
+	mdb.runCmd(testAddrs['aBigObject'] + '::jsprint -ad1\n',
+	    function (output) {
+		parseJsPrint(testObject['aBigObject'], bigObjectAddrs, output);
+		console.error(bigObjectAddrs);
+		callback();
+	    });
+}
+
+/*
+ * Tests finding a property value from our big object.  This is intended to
+ * exercise a different case of object layout -- namely, dictionary layout --
+ * than what is likely used for our main test object.
+ *
+ * This test is also used to verify that we cleanly stop iterating (having found
+ * no references) if the depth is limited too far.  To test this, we run the
+ * same test with depth limited to 1 and verify that we don't find any
+ * reference.
+ */
+function testBigObjectProp(mdb, callback)
+{
+	var addr;
+
+	console.error('test: big object property and depth limit');
+	addr = bigObjectAddrs['prop_25'];
+	assert.equal('string', typeof (addr));
+
+	vasync.forEachPipeline({
+	    'inputs': [
+		addr + '::jsfindrefs\n',
+		addr + '::jsfindrefs -l 1\n',
+		addr + '::jsfindrefs -v\n'
+	    ],
+	    'func': function runCmd(cmd, subcallback) {
+		mdb.runCmd(cmd, function (output) {
+			subcallback(null, output);
+		});
+	    }
+	}, function (err, results) {
+		var lines;
+
+		assert.ok(!err);
+		lines = common.splitMdbLines(results.operations[0].result,
+		    { 'count': 1 });
+		assert.deepEqual(lines, [ testAddrs['aBigObject'] ]);
+
+		assert.strictEqual('', results.operations[1].result);
+
+		lines = common.splitMdbLines(results.operations[2].result,
+		    { 'count': 1 });
+		assert.deepEqual(lines,
+		    [ testAddrs['aBigObject'] + ' (type: JSObject)' ]);
+		callback();
+	});
+}
+
+/*
+ * Verifies that we don't spin into an infinite loop in the case of cycles in
+ * the JavaScript object graph.  We test this by showing that we can find the
+ * references to "testObject", which should include our array, and we can find
+ * references to our test array, which should include "testObject".  This
+ * demonstrates that we found the cycle and didn't loop forever trying to
+ * process it.
+ *
+ * It would be nice to also test the case of cycles in the graph of V8 objects
+ * that aren't also JavaScript objects (e.g., two FixedArrays pointing at each
+ * other).  This is arguably a bigger risk, but it's harder to construct
+ * instances of such structures.
+ */
+function testCycle(mdb, callback)
+{
+	console.error('test: cycle');
+	assert.equal('string', typeof (testAddrs['anArray']));
+	assert.equal('string', typeof (testObjectAddr));
+
+	vasync.forEachPipeline({
+	    'inputs': [
+	        testObjectAddr + '::jsfindrefs\n',
+		testAddrs['anArray'] + '::jsfindrefs\n'
+	    ],
+	    'func': function runCmd(cmd, subcallback) {
+		mdb.runCmd(cmd, function (output) {
+			subcallback(null, output);
+		});
+	    }
+	}, function (err, results) {
+		var lines, found, i;
+
+		assert.ok(!err);
+
+		lines = common.splitMdbLines(results.operations[0].result, {});
+		found = false;
+		for (i = 0; i < lines.length; i++) {
+			if (lines[i] == testAddrs['anArray']) {
+				found = true;
+				break;
+			}
+		}
+		assert.ok(found,
+		    'did not find reference from array to testObject');
+
+		lines = common.splitMdbLines(results.operations[1].result, {});
+		found = false;
+		for (i = 0; i < lines.length; i++) {
+			if (lines[i] == testObjectAddr) {
+				found = true;
+				break;
+			}
+		}
+		assert.ok(found,
+		    'did not find reference from testObject to array');
+		callback();
+	});
+}
+
+/*
+ * Verifies the case that an address has no valid references from JavaScript
+ * objects.  It would be ideal to test this with a real JavaScript value that's
+ * not referenced, but that's naturally hard to find.  Instead, we pick the
+ * address of "main".  This should be mapped, but isn't itself a JavaScript
+ * object, and so should not have a reference from a JavaScript object.
+ */
+function testBogusAddress(mdb, callback)
+{
+	console.error('test: bogus address (from stack)');
+	mdb.runCmd('main=K\n', function (mainoutput) {
+		var lines, cmd;
+
+		lines = common.splitMdbLines(mainoutput, { 'count': 1 });
+		cmd = lines[0].trim() + '::jsfindrefs\n';
+		mdb.runCmd(cmd, function (output) {
+			assert.strictEqual(output, '',
+			    'found unexpected reference to main');
+			callback();
+		});
+	});
+}
+
+/*
+ * The following several functions implement a test case that starts with a V8
+ * heap object (that's not a JavaScript object).  This should give up quickly
+ * because the parent reference is not one of the internal V8 types that we
+ * believe can generate a useful JavaScript reference.
+ */
+var addrMain, addrMainShared, addrMainScript;
+
+function testNonJsFindMain(mdb, callback)
+{
+	var cmd;
+	console.error('test: walking back from non-JS V8 heap object');
+	cmd = '::jsfunctions -n main -s ' + path.basename(__filename) + '\n';
+	mdb.runCmd(cmd, function (output) {
+		var lines, parts;
+		lines = common.splitMdbLines(output, { 'count': 2 });
+		/* Skip the header row. */
+		parts = lines[1].trim().split(/\s+/);
+		addrMain = parts[0].trim();
+		callback();
+	});
+}
+
+/* See above. */
+function testNonJsFindShared(mdb, callback)
+{
+	var cmd;
+	assert.equal('string', typeof (addrMain));
+	cmd = addrMain + '::v8print ! awk \'$2 == "shared"{ print $4 }\'\n';
+	mdb.runCmd(cmd, function (output) {
+		var lines;
+		lines = common.splitMdbLines(output, { 'count': 1 });
+		addrMainShared = lines[0].trim();
+		callback();
+	});
+}
+
+/* See above. */
+function testNonJsFindScript(mdb, callback)
+{
+	var cmd;
+	assert.equal('string', typeof (addrMainShared));
+	cmd = addrMainShared +
+	    '::v8print ! awk \'$2 == "script"{ print $4 }\'\n';
+	mdb.runCmd(cmd, function (output) {
+		var lines;
+		lines = common.splitMdbLines(output, { 'count': 1 });
+		addrMainScript = lines[0].trim();
+		callback();
+	});
+}
+
+/* See above. */
+function testNonJsTest(mdb, callback)
+{
+	assert.equal('string', typeof (addrMainScript));
+	mdb.runCmd(addrMainScript + '::jsfindrefs\n', function (output) {
+		assert.deepEqual(output, '');
+
+		mdb.runCmd(addrMainScript + '::jsfindrefs -d\n',
+		    function (verbout) {
+			var re;
+			re = new RegExp('found reference.*giving up search ' +
+			    'at instance of SharedFunctionInfo');
+			assert.ok(re.test(verbout),
+			    'expected message about giving up search');
+			callback();
+		    });
+	});
+}
+
+function parseJsPrint(realObject, addrs, output)
+{
+	var lines, count;
+	var i, propname, propaddr;
+	var c1, c2;
+
+	count = 0;
+	jsprim.forEachKey(realObject, function () { count++; });
+
+	/*
+	 * There are two extra lines in the output for the header and footer of
+	 * the object.  These are deliberately skipped in the loop.
+	 */
+	lines = common.splitMdbLines(output, { 'count': count + 2 });
+	for (i = 1; i < lines.length - 1; i++) {
+		c1 = lines[i].indexOf(':');
+		c2 = lines[i].indexOf(':', c1 + 1);
+		assert.ok(c1 != -1 && c2 != -1 && c1 != c2);
+
+		propname = JSON.parse(lines[i].substring(0, c1).trim());
+		propaddr = lines[i].substring(c1 + 1, c2).trim();
+
+		assert.ok(jsprim.hasKey(realObject, propname),
+		    'found property in ::jsprint output that is not in the ' +
+		    'real object: ' + JSON.stringify(propname));
+		assert.ok(!jsprim.hasKey(addrs, propname),
+		    'found duplicate property in ::jsprint output: ' +
+		    JSON.stringify(propname));
+		addrs[propname] = propaddr.trim();
+	}
+}
+
+main();
diff --git a/version b/version
index cbbcbc6..a5f99e5 100644
--- a/version
+++ b/version
@@ -8,4 +8,4 @@
 #
 # This value is also used by the "publish" target in the build process.
 #
-1.3.0
+1.4.0
-- 
2.21.0

