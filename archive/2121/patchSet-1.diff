From 2d2f98bb9a4591e17f0adcd81e57c99e36194f84 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Fri, 16 Jun 2017 22:58:47 +0000
Subject: [PATCH] OS-6190 bnxe MAC_CAPAB_TRANSCEIVER support

---
 usr/src/uts/common/Makefile.files         |   1 +
 usr/src/uts/common/io/bnxe/bnxe.h         |   3 +
 usr/src/uts/common/io/bnxe/bnxe_gld.c     |   5 +
 usr/src/uts/common/io/bnxe/bnxe_illumos.c | 155 ++++++++++++++++++++++
 4 files changed, 164 insertions(+)
 create mode 100644 usr/src/uts/common/io/bnxe/bnxe_illumos.c

diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 450c903674..79cc7292d9 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -2237,6 +2237,7 @@ BNXE_OBJS +=	bnxe_cfg.o		\
 		bnxe_tx.o		\
 		bnxe_workq.o		\
 		bnxe_clc.o		\
+		bnxe_illumos.o		\
 		ecore_sp_verbs.o	\
 		bnxe_context.o		\
 		57710_init_values.o	\
diff --git a/usr/src/uts/common/io/bnxe/bnxe.h b/usr/src/uts/common/io/bnxe/bnxe.h
index 9634d2f4ad..3a707708b5 100644
--- a/usr/src/uts/common/io/bnxe/bnxe.h
+++ b/usr/src/uts/common/io/bnxe/bnxe.h
@@ -916,6 +916,9 @@ int       BnxeCheckAccHandle(ddi_acc_handle_t handle);
 int       BnxeCheckDmaHandle(ddi_dma_handle_t handle);
 void      BnxeFmErrorReport(um_device_t * pUM, char * detail);
 
+/* bnxe_illumos.c */
+extern boolean_t bnxe_fill_transceiver(um_device_t *, void *);
+
 extern kmutex_t bnxeLoaderMutex;
 extern u32_t    bnxeNumPlumbed;
 
diff --git a/usr/src/uts/common/io/bnxe/bnxe_gld.c b/usr/src/uts/common/io/bnxe/bnxe_gld.c
index a49d89dd20..dcc6be59ba 100644
--- a/usr/src/uts/common/io/bnxe/bnxe_gld.c
+++ b/usr/src/uts/common/io/bnxe/bnxe_gld.c
@@ -1859,6 +1859,11 @@ static boolean_t BnxeMacGetCapability(void *      pArg,
 
 #endif /* not __S11 or __S12 */
 
+#if defined(ILLUMOS)
+    case MAC_CAPAB_TRANSCEIVER:
+        return bnxe_fill_transceiver(pUM, pCapabilityData);
+#endif
+
     default:
 
         return B_FALSE;
diff --git a/usr/src/uts/common/io/bnxe/bnxe_illumos.c b/usr/src/uts/common/io/bnxe/bnxe_illumos.c
new file mode 100644
index 0000000000..e865576c1d
--- /dev/null
+++ b/usr/src/uts/common/io/bnxe/bnxe_illumos.c
@@ -0,0 +1,155 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * illumos specific bnxe related functions.
+ */
+
+#include "bnxe.h"
+
+/*
+ * Try to figure out which phy we should be using at this time based on the
+ * requested transceiver.
+ */
+static int
+bnxe_get_phy_id(um_device_t *um)
+{
+	int phy;
+
+	if (um->lm_dev.params.link.num_phys <= 1)
+		return (ELINK_INT_PHY);
+
+	if (um->lm_dev.vars.link.link_up) {
+		phy = ELINK_EXT_PHY1;
+		if ((um->lm_dev.vars.link.link_status & LINK_STATUS_SERDES_LINK) &&
+		    (um->lm_dev.params.link.phy[ELINK_EXT_PHY2].supported & ELINK_SUPPORTED_FIBRE))
+			phy = ELINK_EXT_PHY2;
+	} else {
+		switch (elink_phy_selection(&um->lm_dev.params.link)) {
+		case PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:
+		case PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:
+		case PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:
+			phy = ELINK_EXT_PHY1;
+			break;
+		case PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:
+		case PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:
+			phy = ELINK_EXT_PHY2;
+			break;
+		}
+	}
+
+	return (phy);
+}
+
+static int
+bnxe_transceiver_info(void *arg, uint_t id, mac_transceiver_info_t *infop)
+{
+	int phyid;
+	um_device_t *um = arg;
+	struct elink_params *params;
+	struct elink_phy *phy;
+	boolean_t present = B_FALSE, usable = B_FALSE;
+
+	if (id != 0 || arg == NULL || infop == NULL)
+		return (EINVAL);
+
+	BNXE_LOCK_ENTER_PHY(um);
+	phyid = bnxe_get_phy_id(um);
+	params = &um->lm_dev.params.link;
+	phy = &params->phy[phyid];
+	if (phy->media_type == ELINK_ETH_PHY_BASE_T) {
+		BNXE_LOCK_EXIT_PHY(um);
+		return (ENOTSUP);
+	} else if (phy->media_type != ELINK_ETH_PHY_NOT_PRESENT) {
+		present = B_TRUE;
+		if ((phy->flags & ELINK_FLAGS_SFP_NOT_APPROVED) == 0)
+			usable = B_TRUE;
+	}
+	BNXE_LOCK_EXIT_PHY(um);
+
+	mac_transceiver_info_set_present(infop, present);
+	mac_transceiver_info_set_usable(infop, usable);
+
+	return (0);
+}
+
+static int
+bnxe_transceiver_read(void *arg, uint_t id, uint_t page, void *bp,
+    size_t nbytes, off_t offset, size_t *nread)
+{
+	int phyid;
+	um_device_t *um = arg;
+	struct elink_phy *phy;
+	struct elink_params *params;
+	elink_status_t ret;
+
+	if (id != 0 || bp == NULL || nbytes == 0 || nread == NULL ||
+	    (page != 0xa0 && page != 0xa2) || offset < 0)
+		return (EINVAL);
+
+	/*
+	 * Sanity check length params.
+	 */
+	if (nbytes > 256 || offset >= 256 || (offset + nbytes > 256)) {
+		return (EINVAL);
+	}
+
+	BNXE_LOCK_ENTER_PHY(um);
+	phyid = bnxe_get_phy_id(um);
+	params = &um->lm_dev.params.link;
+	phy = &um->lm_dev.params.link.phy[phyid];
+
+	if (phy->media_type == ELINK_ETH_PHY_BASE_T) {
+		BNXE_LOCK_EXIT_PHY(um);
+		return (ENOTSUP);
+	}
+
+
+	PHY_HW_LOCK(&um->lm_dev);
+	ret = elink_read_sfp_module_eeprom(phy, params, (uint8_t)page,
+	    (uint16_t)offset, (uint16_t)nbytes, bp);
+	PHY_HW_UNLOCK(&um->lm_dev);
+
+	BNXE_LOCK_EXIT_PHY(um);
+
+	switch (ret) {
+	case ELINK_STATUS_OK:
+		*nread = nbytes;
+		return (0);
+	case ELINK_OP_NOT_SUPPORTED:
+		return (ENOTSUP);
+	default:
+		return (EIO);
+	}
+}
+
+boolean_t
+bnxe_fill_transceiver(um_device_t *um, void *arg)
+{
+	uint_t ntran = 1;
+	mac_capab_transceiver_t *mct = arg;
+
+	mct->mct_flags = 0;
+	/*
+	 * Whie there is nominally a dual-phy version of bnxe out there (see
+	 * ELINK_DUAL_MEDIA and related macros), these haven't been seen in the
+	 * wild. For the time just assume we only have.
+	 */
+	mct->mct_ntransceivers = 1;
+	mct->mct_info = bnxe_transceiver_info;
+	mct->mct_read = bnxe_transceiver_read;
+
+	return (B_TRUE);
+}
-- 
2.21.0

