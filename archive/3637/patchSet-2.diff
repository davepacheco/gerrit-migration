commit a72bda54b11bfebbe576ca3ec8521b2a5f5bacc1 (refs/changes/37/3637/2)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2018-03-15T12:22:37+10:30 (1 year, 7 months ago)
    
    PUBAPI-1476 Create a compatibility layer so that all cloudapi plugins can be used in sdc-docker, and vice versa
    DOCKER-1054 Provide provisioning limits plugin for sdc-docker similar to cloudapi functionality

diff --git a/plugins/free_tier.js b/plugins/free_tier.js
new file mode 100644
index 0000000..2da6c0e
--- /dev/null
+++ b/plugins/free_tier.js
@@ -0,0 +1,125 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Free Tier offering plugin: each account can create a single free-tier
+ * instance per datacenter for the first year after the account has been
+ * created.
+ *
+ * To configure this plugin, add the UUIDs of the packages that are used for the
+ * free tier; exactly one free allocation will be allowed from this set of
+ * packages:
+ *
+ * {
+ *    "name": "free_tier",
+ *    "enabled": true,
+ *    "config": {
+ *        "packages": [ ... list of UUIDs here ... ],
+ *    }
+ * }
+ *
+ * This is added to CLOUDAPI_PLUGINS and DOCKER_PLUGINS, serialized to JSON, and
+ * PUT to cloudapi's and sdc-docker's sapi services. E.g.:
+ *
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) -X PUT
+ * -d '{
+ *    "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"free_tier\", \
+ *         \"enabled\": true, \"config\": {\"packages\": \
+ *         [\"fb7f31ad-52d6-4e92-83d2-9f9d94ceef3f\"]}}]"
+ *    }
+ * }'
+ */
+
+
+var assert = require('assert-plus');
+
+
+// --- Globals
+
+
+var QUOTA_ERR = 'QuotaExceeded; free tier offering is limited to a single '
+    + 'instance for the first year after the account has been created';
+
+var YEAR_IN_MS = 365.25 * 24 * 60 * 60 * 1000;
+
+
+/*
+ * Calls cb(err), where no error means that the provision can proceed. An error
+ * should halt the provision.
+ */
+function allowOneYearFreeTier(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.object(cfg, 'cfg');
+    assert.arrayOfUuid(cfg.packages, 'cfg.packages');
+
+    var log = api.log;
+    var packageUuids = cfg.packages;
+
+    return function checkOneYearFreeTier(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.object(opts.pkg, 'opts.pkg');
+        assert.uuid(opts.req_id, 'opts.req_id');
+        assert.func(cb, 'cb');
+
+        log.debug('Running', checkOneYearFreeTier.name);
+
+        var account = opts.account;
+
+        // If requested package is not in the free tier config list, this plugin
+        // should have no impact on provisioning:
+        if (packageUuids.indexOf(opts.pkg.uuid) === -1) {
+            log.debug('Pkg %s is not free tier; allowing', opts.pkg.uuid);
+            return cb();
+        }
+
+        if (account.isAdmin()) {
+            log.debug('Account %s is an admin; allowing', account.login);
+            return cb();
+        }
+
+        // If the account is older than one year, disallow.
+        var created = new Date(account.created_at);
+        if (created < Date.now() - YEAR_IN_MS) {
+            log.info('Account %s created more than one year ago; disallowing',
+                account.login);
+            return cb(new api.NotAuthorizedError(QUOTA_ERR));
+        }
+
+        return api.getActiveVmsForAccount({
+            account: account,
+            fields: 'billing_id',
+            req_id: opts.req_id
+        }, function (err, vms) {
+            if (err) {
+                log.error({ err: err }, 'Unable to count VMs');
+                return cb(err);
+            }
+
+            var count = vms.filter(function (vm) {
+                return packageUuids.indexOf(vm.billing_id) !== -1;
+            }).length;
+
+            if (count > 0) {
+                log.info('%s free instances; disallowing', count);
+                return cb(new api.NotAuthorizedError(QUOTA_ERR));
+            }
+
+            return cb();
+        });
+    };
+}
+
+
+module.exports = {
+    allowProvision: allowOneYearFreeTier
+};
diff --git a/plugins/machine_email.js b/plugins/machine_email.js
new file mode 100644
index 0000000..65d2d4b
--- /dev/null
+++ b/plugins/machine_email.js
@@ -0,0 +1,143 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Sends an email after a VM/container has been successfully provisioned.
+ *
+ * To configure this plugin, provide the following configuration attributes:
+ *
+ * - from: email address that will be in the From field send to the client.
+ * - subject: what the subject line will be.
+ * - text: what the body of the email will be.
+ *
+ * In addition, the transport (sendmail or direct SMTP) requires configuration.
+ * To send through Sendmail, add the following attribute:
+ *
+ * - sendmail: {
+ *     path: full path to sendmail binary
+ * }
+ *
+ * To send through SMTP:
+ *
+ * - smtp: {
+ *     host: hostname of SMTP server
+ *     secureConnection: true to use SSL,
+ *     port: SMTP port,
+ *     auth: {
+ *         user: ...
+ *         pass: ...
+ *     }
+ * }
+ *
+ * A full example, using sendmail:
+ *
+ * {
+ *     "name": "machine_email",
+ *     "enabled": true,
+ *     "config": {
+ *         "from": "sender@example.com",
+ *         "subject": "A new container has been provisioned",
+ *         "text": "All toasty and ready for use!",
+ *         "sendmail": {
+ *             "path": "/usr/sbin/sendmail"
+ *         }
+ *     }
+ * }
+ *
+ * This is added to CLOUDAPI_PLUGINS and DOCKER_PLUGINS, serialized to JSON,
+ * and PUT to cloudapi's and sdc-docker's sapi services.
+ *
+ * E.g. for cloudapi:
+ *
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) -X PUT
+ * -d '{
+ *    "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"machine_email\",\"enabled\":true, \
+ *         \"config\":{\"from\":\"sender@example.com\",\"subject\": \
+ *         \"A new container has been provisioned\",\"text\": \
+ *         \"All toasty and ready for use!\", \
+ *         \"sendmail\":{\"path\":\"/usr/sbin/sendmail\"}}}]"
+ *    }
+ * }'
+ */
+
+
+var assert = require('assert-plus');
+var nodemailer = require('nodemailer');
+
+
+// --- Globals
+
+
+var EMAIL_RE = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i;
+
+
+/*
+ * Given a provision, send an email to the client who provisioned.
+ *
+ * Calls cb(). No error will ever be returned.
+ */
+function postProvisionEmail(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.object(cfg, 'cfg');
+    assert.object(cfg.smtp || cfg.sendmail || cfg.test,
+        'cfg.smtp || cfg.sendmaili || cfg.test');
+    assert.string(cfg.from, 'cfg.from');
+    assert.ok(EMAIL_RE.test(cfg.from), 'cfg.from (email) is required');
+    assert.string(cfg.subject, 'cfg.subject');
+    assert.string(cfg.text, 'cfg.text');
+
+    var log = api.log;
+    var from = cfg.from;
+    var subject = cfg.subject;
+    var text = cfg.text;
+
+    var transport;
+    if (cfg.smtp) {
+        transport = nodemailer.createTransport('SMTP', cfg.smtp);
+    } else if (cfg.sendmail) {
+        assert.string(cfg.sendmail.path, 'cfg.sendmail.path');
+        transport = nodemailer.createTransport('SENDMAIL', cfg.sendmail.path);
+    } else {
+        transport = cfg.test; // for testing purposes
+    }
+
+    return function sendPostProvisionEmail(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.string(opts.account.email, 'opts.account.email');
+        assert.func(cb, 'cb');
+
+        log.debug('Running', sendPostProvisionEmail.name);
+
+        var to = opts.account.email;
+
+        transport.sendMail({
+            from: from,
+            to: to,
+            subject: subject,
+            text: text
+        }, function sendMailCb(err) {
+            if (err) {
+                log.error({ err: err }, 'Email failure');
+            } else {
+                log.info('Email sent');
+            }
+
+            cb();
+        });
+    };
+}
+
+
+module.exports = {
+    postProvision: postProvisionEmail
+};
