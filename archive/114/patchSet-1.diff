commit f3c841b2bbd641b4008f52ec2e6bd25b707e6e1e (refs/changes/14/114/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-07-19T18:17:11-07:00 (3 years, 3 months ago)
    
    joyent/node-sshpk#6 Want support for openssh and x509 certificates

diff --git a/lib/certificate.js b/lib/certificate.js
new file mode 100644
index 0000000..c3466c8
--- /dev/null
+++ b/lib/certificate.js
@@ -0,0 +1,96 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Certificate;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var Key = require('./key');
+var PrivateKey = require('./private-key');
+var Identity = require('./identity');
+
+var formats = {};
+/*formats['auto'] = require('./formats/auto-cert');*/
+formats['openssh'] = require('./formats/openssh-cert');
+/*formats['pem'] = require('./formats/x509');
+formats['x509'] = require('./formats/x509');*/
+
+function Certificate(opts) {
+	assert.object(opts, 'options');
+	assert.ok(Identity.isIdentity(opts.subject), 'options.subject');
+	assert.ok(Key.isKey(opts.subjectKey), 'options.subjectKey');
+	assert.ok(Identity.isIdentity(opts.issuer), 'options.issuer');
+	if (opts.issuerKey !== undefined)
+		assert.ok(Key.isKey(opts.issuerKey), 'options.issuerKey');
+	assert.object(opts.signatures, 'options.signatures');
+	assert.ok(Object.keys(opts.signatures).length > 0,
+	    'must have at least 1 issuer signature');
+	assert.buffer(opts.serial, 'options.serial');
+
+	this.subject = opts.subject;
+	this.issuer = opts.issuer;
+	this.subjectKey = opts.subjectKey;
+	this.issuerKey = opts.issuerKey;
+	this.signatures = opts.signatures;
+}
+
+Certificate.formats = formats;
+
+Certificate.prototype.toBuffer = function (format, options) {
+};
+
+Certificate.prototype.toString = function (format, options) {
+};
+
+Certificate.prototype.fingerprint = function (algo) {
+};
+
+Certificate.prototype.isSignedBy = function (issuer) {
+	var issuerKey;
+	var issuerCert;
+	if (Certificate.isCertificate(issuer, [1, 0])) {
+		issuerCert = issuer;
+		issuerKey = issuer.subjectKey;
+	} else if (Key.isKey(issuer, [1, 3])) {
+		issuerKey = issuer;
+	} else {
+		throw (new Error('"issuer" must be a Certificate or Key'));
+	}
+
+	if (issuerCert !== undefined &&
+	    !this.issuer.equals(issuerCert.subject))
+		return (false);
+
+	if (this.issuerKey !== undefined) {
+		return (this.issuerKey.
+		    fingerprint('sha512').matches(issuerKey));
+	}
+
+	var fmt = Object.keys(this.signatures)[0];
+	var valid = formats[fmt].verify(this, issuerKey);
+	if (valid)
+		this.issuerKey = issuerKey;
+	return (valid);
+};
+
+Certificate.parse = function (data, format, options) {
+};
+
+Certificate.isCertificate = function (obj, ver) {
+	return (utils.isCompatible(obj, Certificate, ver));
+};
+
+/*
+ * API versions for Certificate:
+ * [1,0] -- initial ver
+ */
+Certificate.prototype._sshpkApiVersion = [1, 0];
+
+Certificate._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
diff --git a/lib/formats/openssh-cert.js b/lib/formats/openssh-cert.js
new file mode 100644
index 0000000..223cb9b
--- /dev/null
+++ b/lib/formats/openssh-cert.js
@@ -0,0 +1,8 @@
+// Copyright 2015 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	verify: verify,
+	sign: sign,
+	write: write
+};
diff --git a/lib/identity.js b/lib/identity.js
new file mode 100644
index 0000000..fb63eb5
--- /dev/null
+++ b/lib/identity.js
@@ -0,0 +1,169 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Identity;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var asn1 = require('asn1');
+
+var DNS_NAME_RE = /^[a-z0-9][a-z0-9\-]{0,62}(?:\.[a-z0-9][a-z0-9\-]{0,62})*$/i;
+
+var oids = {};
+oids.cn = '2.5.4.3';
+oids.o = '2.5.4.10';
+oids.ou = '2.5.4.11';
+oids.s = '2.5.4.8';
+oids.c = '2.5.4.6';
+oids.sn = '2.5.4.4';
+oids.dc = '0.9.2342.19200300.100.1.25';
+oids.uid = '0.9.2342.19200300.100.1.1';
+
+var unoids = {};
+Object.keys(oids).forEach(function (k) {
+	unoids[oids[k]] = k;
+});
+
+function Identity(opts) {
+	var self = this;
+	assert.object(opts, 'options');
+	assert.arrayOfObject(opts.components, 'options.components');
+	this.components = opts.components;
+	this.componentLookup = {};
+	this.components.forEach(function (c) {
+		if (c.name && !c.oid)
+			c.oid = oids[c.name];
+		if (c.oid && !c.name)
+			c.name = unoids[c.oid];
+		if (self.componentLookup[c.name] === undefined)
+			self.componentLookup[c.name] = [];
+		self.componentLookup[c.name].push(c);
+	});
+	if (this.componentLookup.cn.length > 0) {
+		this.cn = this.componentLookup.cn[0].value;
+	}
+	if (this.components.length === 1 &&
+	    this.componentLookup.cn.length === 1 &&
+	    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+		this.type = 'host';
+		this.hostname = this.componentLookup.cn[0].value;
+
+	} else if (this.components.length === this.componentLookup.dc.length) {
+		this.type = 'host';
+		this.hostname = this.componentLookup.dc.map(function (c) {
+			return (c.value);
+		}).join('.');
+
+	} else if (this.components.length === this.componentLookup.uid.length) {
+		this.type = 'user';
+		this.uid = this.componentLookup.uid[0].value;
+
+	} else if (this.componentLookup.cn.length === 1 &&
+	    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+		this.type = 'host';
+		this.hostname = this.componentLookup.cn[0].value;
+
+	} else if (this.componentLookup.uid.length === 1) {
+		this.type = 'user';
+		this.uid = this.componentLookup.uid[0].value;
+
+	} else if (this.componentLookup.cn.length === 1) {
+		this.type = 'user';
+		this.uid = this.componentLookup.cn[0].value;
+
+	} else {
+		this.type = 'unknown';
+	}
+}
+
+Identity.prototype.toString = function () {
+	return (this.components.map(function (c) {
+		return (c.name.toUpperCase() + '=' + c.value);
+	}).join(', '));
+};
+
+Identity.prototype.toAsn1 = function (der) {
+	der.startSequence();
+	der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+	this.components.forEach(function (c) {
+		der.startSequence();
+		der.writeOID(c.oid);
+		der.writeString(c.value, asn1.Ber.PrintableString);
+		der.endSequence();
+	});
+	der.endSequence();
+	der.endSequence();
+};
+
+Identity.prototype.equals = function (other) {
+	if (!Identity.isIdentity(other, [1, 0]))
+		return (false);
+	if (other.components.length !== this.components.length)
+		return (false);
+	for (var i = 0; i < this.components.length; ++i) {
+		if (this.components[i].oid !== other.components[i].oid)
+			return (false);
+		if (this.components[i].value !== other.components[i].value)
+			return (false);
+	}
+	return (true);
+};
+
+Identity.forHost = function (hostname) {
+	assert.string(hostname, 'hostname');
+	return (new Identity({
+		components: [ { name: 'cn', value: hostname } ]
+	}));
+};
+
+Identity.forUser = function (uid) {
+	assert.string(uid, 'uid');
+	return (new Identity({
+		components: [ { name: 'uid', value: hostname } ]
+	}));
+};
+
+Identity.parseAsn1 = function (der) {
+	var components = [];
+	der.readSequence();
+	der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+	var end = der.offset + der.length;
+	while (der.offset < end) {
+		der.readSequence();
+		var oid = der.readOID();
+		var type = der.peek();
+		var value;
+		switch (type) {
+		case asn1.Ber.PrintableString:
+		case asn1.Ber.IA5String:
+		case asn1.Ber.OctetString:
+			value = der.readString(type);
+			break;
+		default:
+			throw (new Error('Unknown asn1 type ' + type));
+		}
+		components.push({ oid: oid, value: value });
+	}
+	return (new Identity({
+		components: components
+	}));
+};
+
+Identity.isIdentity = function (obj, ver) {
+	return (utils.isCompatible(obj, Identity, ver));
+};
+
+/*
+ * API versions for Identity:
+ * [1,0] -- initial ver
+ */
+Identity.prototype._sshpkApiVersion = [1, 0];
+
+Identity._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
