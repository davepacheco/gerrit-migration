From 314f6b17c700fb5d436fd01c0dc5c944c2d44d37 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 19 Jul 2016 18:17:11 -0700
Subject: [PATCH] joyent/node-sshpk#6 Want support for openssh and x509
 certificates joyent/node-sshpk#8 DSA signatures come out with zero padding on
 's' Reviewed by: Cody Mello <cody.mello@joyent.com>

---
 README.md                              | 217 ++++++++++-
 lib/certificate.js                     | 282 +++++++++++++++
 lib/errors.js                          |  15 +-
 lib/fingerprint.js                     |  35 +-
 lib/formats/openssh-cert.js            | 276 ++++++++++++++
 lib/formats/pkcs8.js                   |   9 +-
 lib/formats/x509-pem.js                |  77 ++++
 lib/formats/x509.js                    | 481 +++++++++++++++++++++++++
 lib/identity.js                        | 255 +++++++++++++
 lib/index.js                           |  14 +-
 lib/key.js                             |   1 +
 lib/signature.js                       |  20 +-
 lib/ssh-buffer.js                      |  24 ++
 test/assets/1024b-dsa-example-cert.der | Bin 0 -> 883 bytes
 test/assets/cloudflare.pem             |  32 ++
 test/assets/comodo.crt                 | Bin 0 -> 931 bytes
 test/assets/digicert-ca.crt            | Bin 0 -> 1210 bytes
 test/assets/digicert.pem               |  50 +++
 test/assets/frank4dd-cacert.der        | Bin 0 -> 961 bytes
 test/assets/george-openssh.pub         |   1 +
 test/assets/george-x509.pem            |  15 +
 test/assets/google_jp_458san.pem       | 152 ++++++++
 test/assets/jim-openssh.pub            |   1 +
 test/assets/jim-x509.pem               |  12 +
 test/assets/joyent.pem                 |  31 ++
 test/assets/letsencrypt.pem            |  29 ++
 test/assets/napoleon-cert.pem          |  21 ++
 test/certs.js                          | 296 +++++++++++++++
 test/identity.js                       |  16 +
 test/openssl-cmd.js                    |  60 +++
 test/signature.js                      |  70 +++-
 31 files changed, 2466 insertions(+), 26 deletions(-)
 create mode 100644 lib/certificate.js
 create mode 100644 lib/formats/openssh-cert.js
 create mode 100644 lib/formats/x509-pem.js
 create mode 100644 lib/formats/x509.js
 create mode 100644 lib/identity.js
 create mode 100644 test/assets/1024b-dsa-example-cert.der
 create mode 100644 test/assets/cloudflare.pem
 create mode 100644 test/assets/comodo.crt
 create mode 100644 test/assets/digicert-ca.crt
 create mode 100644 test/assets/digicert.pem
 create mode 100644 test/assets/frank4dd-cacert.der
 create mode 100644 test/assets/george-openssh.pub
 create mode 100644 test/assets/george-x509.pem
 create mode 100644 test/assets/google_jp_458san.pem
 create mode 100644 test/assets/jim-openssh.pub
 create mode 100644 test/assets/jim-x509.pem
 create mode 100644 test/assets/joyent.pem
 create mode 100644 test/assets/letsencrypt.pem
 create mode 100644 test/assets/napoleon-cert.pem
 create mode 100644 test/certs.js
 create mode 100644 test/identity.js

diff --git a/README.md b/README.md
index d0fa88d..00a4055 100644
--- a/README.md
+++ b/README.md
@@ -401,6 +401,206 @@ Parameters
 
 Same as `this.toBuffer(format).toString('base64')`.
 
+## Certificates
+
+`sshpk` includes basic support for parsing certificates in X.509 (PEM) format
+and the OpenSSH certificate format. This feature is intended to be used mainly
+to access basic metadata about certificates, extract public keys from them, and
+also to generate simple self-signed certificates from an existing key.
+
+Notably, there is no implementation of CA chain-of-trust verification, and no
+support for key usage restrictions (or other kinds of restrictions). Please do
+the security world a favour, and DO NOT use this code for certificate
+verification in the traditional X.509 CA chain style.
+
+### `parseCertificate(data, format)`
+
+Parameters
+
+ - `data` -- a Buffer or String
+ - `format` -- a String, format to use, one of `'openssh'`, `'pem'` (X.509 in a
+               PEM wrapper), or `'x509'` (raw DER encoded)
+
+### `createSelfSignedCertificate(subject, privateKey[, options])`
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `privateKey` -- a PrivateKey, the key of the subject: will be used both to be
+                   placed in the certificate and also to sign it (since this is
+                   a self-signed certificate)
+ - `options` -- optional Object, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+                   seconds
+   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
+                                  certificate validity period. If given
+                                  `lifetime` will be ignored
+   - `serial` -- optional Buffer, the serial number of the certificate
+
+### `createCertificate(subject, key, issuer, issuerKey[, options])`
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `key` -- a Key, the public key of the subject
+ - `issuer` -- an Identity, the issuer of the certificate who will sign it
+ - `issuerKey` -- a PrivateKey, the issuer's private key for signing
+ - `options` -- optional Object, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+                   seconds
+   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
+                                  certificate validity period. If given
+                                  `lifetime` will be ignored
+   - `serial` -- optional Buffer, the serial number of the certificate
+
+### `Certificate#subjects`
+
+Array of `Identity` instances describing the subject of this certificate.
+
+### `Certificate#issuer`
+
+The `Identity` of the Certificate's issuer (signer).
+
+### `Certificate#subjectKey`
+
+The public key of the subject of the certificate, as a `Key` instance.
+
+### `Certificate#issuerKey`
+
+The public key of the signing issuer of this certificate, as a `Key` instance.
+May be `undefined` if the issuer's key is unknown (e.g. on an X509 certificate).
+
+### `Certificate#serial`
+
+The serial number of the certificate. As this is normally a 64-bit or wider
+integer, it is returned as a Buffer.
+
+### `Certificate#isExpired([when])`
+
+Tests whether the Certificate is currently expired (i.e. the `validFrom` and
+`validUntil` dates specify a range of time that does not include the current
+time).
+
+Parameters
+
+ - `when` -- optional Date, if specified, tests whether the Certificate was or
+             will be expired at the specified time instead of now
+
+Returns a Boolean.
+
+### `Certificate#isSignedByKey(key)`
+
+Tests whether the Certificate was validly signed by the given (public) Key.
+
+Parameters
+
+ - `key` -- a Key instance
+
+Returns a Boolean.
+
+### `Certificate#isSignedBy(certificate)`
+
+Tests whether this Certificate was validly signed by the subject of the given
+certificate. Also tests that the issuer Identity of this Certificate and the
+subject Identity of the other Certificate are equivalent.
+
+Parameters
+
+ - `certificate` -- another Certificate instance
+
+Returns a Boolean.
+
+### `Certificate#fingerprint([hashAlgo])`
+
+Returns the X509-style fingerprint of the entire certificate (as a Fingerprint
+instance). This matches what a web-browser or similar would display as the
+certificate fingerprint and should not be confused with the fingerprint of the
+subject's public key.
+
+Parameters
+
+ - `hashAlgo` -- an optional String, any hash function name
+
+### `Certificate#toBuffer([format])`
+
+Serializes the Certificate to a Buffer and returns it.
+
+Parameters
+
+ - `format` -- an optional String, output format, one of `'openssh'`, `'pem'` or
+               `'x509'`. Defaults to `'x509'`.
+
+Returns a Buffer.
+
+### `Certificate#toString([format])`
+
+ - `format` -- an optional String, output format, one of `'openssh'`, `'pem'` or
+               `'x509'`. Defaults to `'pem'`.
+
+Returns a String.
+
+## Certificate identities
+
+### `identityForHost(hostname)`
+
+Constructs a host-type Identity for a given hostname.
+
+Parameters
+
+ - `hostname` -- the fully qualified DNS name of the host
+
+Returns an Identity instance.
+
+### `identityForUser(uid)`
+
+Constructs a user-type Identity for a given UID.
+
+Parameters
+
+ - `uid` -- a String, user identifier (login name)
+
+Returns an Identity instance.
+
+### `identityForEmail(email)`
+
+Constructs an email-type Identity for a given email address.
+
+Parameters
+
+ - `email` -- a String, email address
+
+Returns an Identity instance.
+
+### `identityFromDN(dn)`
+
+Parses an LDAP-style DN string (e.g. `'CN=foo, C=US'`) and turns it into an
+Identity instance.
+
+Parameters
+
+ - `dn` -- a String
+
+Returns an Identity instance.
+
+### `Identity#toString()`
+
+Returns the identity as an LDAP-style DN string.
+e.g. `'CN=foo, O=bar corp, C=us'`
+
+### `Identity#type`
+
+The type of identity. One of `'host'`, `'user'`, `'email'` or `'unknown'`
+
+### `Identity#hostname`
+### `Identity#uid`
+### `Identity#email`
+
+Set when `type` is `'host'`, `'user'`, or `'email'`, respectively. Strings.
+
+### `Identity#cn`
+
+The value of the first `CN=` in the DN, if any.
+
 Errors
 ------
 
@@ -433,8 +633,8 @@ The key data given could not be parsed as a valid key.
 
 Properties
 
-- `keyName` -- `filename` that was given to `Key#parse`
-- `format` -- the `format` that was trying to parse the key
+- `keyName` -- `filename` that was given to `parseKey`
+- `format` -- the `format` that was trying to parse the key (see `parseKey`)
 - `innerErr` -- the inner Error thrown by the format parser
 
 ### `KeyEncryptedError`
@@ -444,10 +644,21 @@ parsing operation would succeed if it was given the `passphrase` option.
 
 Properties
 
-- `keyName` -- `filename` that was given to `Key#parse`
+- `keyName` -- `filename` that was given to `parseKey`
 - `format` -- the `format` that was trying to parse the key (currently can only
               be `"pem"`)
 
+### `CertificateParseError`
+
+The certificate data given could not be parsed as a valid certificate.
+
+Properties
+
+- `certName` -- `filename` that was given to `parseCertificate`
+- `format` -- the `format` that was trying to parse the key
+              (see `parseCertificate`)
+- `innerErr` -- the inner Error thrown by the format parser
+
 Friends of sshpk
 ----------------
 
diff --git a/lib/certificate.js b/lib/certificate.js
new file mode 100644
index 0000000..49514b5
--- /dev/null
+++ b/lib/certificate.js
@@ -0,0 +1,282 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Certificate;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var Key = require('./key');
+var PrivateKey = require('./private-key');
+var Identity = require('./identity');
+
+var formats = {};
+formats['openssh'] = require('./formats/openssh-cert');
+formats['x509'] = require('./formats/x509');
+formats['pem'] = require('./formats/x509-pem');
+
+var CertificateParseError = errs.CertificateParseError;
+var InvalidAlgorithmError = errs.InvalidAlgorithmError;
+
+function Certificate(opts) {
+	assert.object(opts, 'options');
+	assert.arrayOfObject(opts.subjects, 'options.subjects');
+	utils.assertCompatible(opts.subjects[0], Identity, [1, 0],
+	    'options.subjects');
+	utils.assertCompatible(opts.subjectKey, Key, [1, 0],
+	    'options.subjectKey');
+	utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
+	if (opts.issuerKey !== undefined) {
+		utils.assertCompatible(opts.issuerKey, Key, [1, 0],
+		    'options.issuerKey');
+	}
+	assert.object(opts.signatures, 'options.signatures');
+	assert.buffer(opts.serial, 'options.serial');
+	assert.date(opts.validFrom, 'options.validFrom');
+	assert.date(opts.validUntil, 'optons.validUntil');
+
+	this._hashCache = {};
+
+	this.subjects = opts.subjects;
+	this.issuer = opts.issuer;
+	this.subjectKey = opts.subjectKey;
+	this.issuerKey = opts.issuerKey;
+	this.signatures = opts.signatures;
+	this.serial = opts.serial;
+	this.validFrom = opts.validFrom;
+	this.validUntil = opts.validUntil;
+}
+
+Certificate.formats = formats;
+
+Certificate.prototype.toBuffer = function (format, options) {
+	if (format === undefined)
+		format = 'x509';
+	assert.string(format, 'format');
+	assert.object(formats[format], 'formats[format]');
+	assert.optionalObject(options, 'options');
+
+	return (formats[format].write(this, options));
+};
+
+Certificate.prototype.toString = function (format, options) {
+	if (format === undefined)
+		format = 'pem';
+	return (this.toBuffer(format, options).toString());
+};
+
+Certificate.prototype.fingerprint = function (algo) {
+	if (algo === undefined)
+		algo = 'sha256';
+	assert.string(algo, 'algorithm');
+	var opts = {
+		type: 'certificate',
+		hash: this.hash(algo),
+		algorithm: algo
+	};
+	return (new Fingerprint(opts));
+};
+
+Certificate.prototype.hash = function (algo) {
+	assert.string(algo, 'algorithm');
+	algo = algo.toLowerCase();
+	if (algs.hashAlgs[algo] === undefined)
+		throw (new InvalidAlgorithmError(algo));
+
+	if (this._hashCache[algo])
+		return (this._hashCache[algo]);
+
+	var hash = crypto.createHash(algo).
+	    update(this.toBuffer('x509')).digest();
+	this._hashCache[algo] = hash;
+	return (hash);
+};
+
+Certificate.prototype.isExpired = function (when) {
+	if (when === undefined)
+		when = new Date();
+	return (!((when.getTime() >= this.validFrom.getTime()) &&
+		(when.getTime() < this.validUntil.getTime())));
+};
+
+Certificate.prototype.isSignedBy = function (issuerCert) {
+	utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');
+
+	if (!this.issuer.equals(issuerCert.subjects[0]))
+		return (false);
+
+	return (this.isSignedByKey(issuerCert.subjectKey));
+};
+
+Certificate.prototype.isSignedByKey = function (issuerKey) {
+	utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');
+
+	if (this.issuerKey !== undefined) {
+		return (this.issuerKey.
+		    fingerprint('sha512').matches(issuerKey));
+	}
+
+	var fmt = Object.keys(this.signatures)[0];
+	var valid = formats[fmt].verify(this, issuerKey);
+	if (valid)
+		this.issuerKey = issuerKey;
+	return (valid);
+};
+
+Certificate.prototype.signWith = function (key) {
+	var fmts = Object.keys(formats);
+	for (var i = 0; i < fmts.length; ++i) {
+		if (fmts[i] !== 'pem')
+			formats[fmts[i]].sign(this, key);
+	}
+};
+
+Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
+	var subjects;
+	if (Array.isArray(subjectOrSubjects))
+		subjects = subjectOrSubjects;
+	else
+		subjects = [subjectOrSubjects];
+
+	assert.arrayOfObject(subjects);
+	subjects.forEach(function (subject) {
+		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
+	});
+
+	utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');
+
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalObject(options.validFrom, 'options.validFrom');
+	assert.optionalObject(options.validUntil, 'options.validUntil');
+	var validFrom = options.validFrom;
+	var validUntil = options.validUntil;
+	if (validFrom === undefined)
+		validFrom = new Date();
+	if (validUntil === undefined) {
+		assert.optionalNumber(options.lifetime, 'options.lifetime');
+		var lifetime = options.lifetime;
+		if (lifetime === undefined)
+			lifetime = 10*365*24*3600;
+		validUntil = new Date();
+		validUntil.setTime(validUntil.getTime() + lifetime*1000);
+	}
+	assert.optionalBuffer(options.serial, 'options.serial');
+	var serial = options.serial;
+	if (serial === undefined)
+		serial = new Buffer('0000000000000001', 'hex');
+
+	var cert = new Certificate({
+		subjects: subjects,
+		issuer: subjects[0],
+		subjectKey: key.toPublic(),
+		issuerKey: key.toPublic(),
+		signatures: {},
+		serial: serial,
+		validFrom: validFrom,
+		validUntil: validUntil
+	});
+	cert.signWith(key);
+
+	return (cert);
+};
+
+Certificate.create =
+    function (subjectOrSubjects, key, issuer, issuerKey, options) {
+	var subjects;
+	if (Array.isArray(subjectOrSubjects))
+		subjects = subjectOrSubjects;
+	else
+		subjects = [subjectOrSubjects];
+
+	assert.arrayOfObject(subjects);
+	subjects.forEach(function (subject) {
+		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
+	});
+
+	utils.assertCompatible(key, Key, [1, 0], 'key');
+	if (PrivateKey.isPrivateKey(key))
+		key = key.toPublic();
+	utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
+	utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');
+
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalObject(options.validFrom, 'options.validFrom');
+	assert.optionalObject(options.validUntil, 'options.validUntil');
+	var validFrom = options.validFrom;
+	var validUntil = options.validUntil;
+	if (validFrom === undefined)
+		validFrom = new Date();
+	if (validUntil === undefined) {
+		assert.optionalNumber(options.lifetime, 'options.lifetime');
+		var lifetime = options.lifetime;
+		if (lifetime === undefined)
+			lifetime = 10*365*24*3600;
+		validUntil = new Date();
+		validUntil.setTime(validUntil.getTime() + lifetime*1000);
+	}
+	assert.optionalBuffer(options.serial, 'options.serial');
+	var serial = options.serial;
+	if (serial === undefined)
+		serial = new Buffer('0000000000000001', 'hex');
+
+	var cert = new Certificate({
+		subjects: subjects,
+		issuer: issuer,
+		subjectKey: key,
+		issuerKey: issuerKey.toPublic(),
+		signatures: {},
+		serial: serial,
+		validFrom: validFrom,
+		validUntil: validUntil
+	});
+	cert.signWith(issuerKey);
+
+	return (cert);
+};
+
+Certificate.parse = function (data, format, options) {
+	if (typeof (data) !== 'string')
+		assert.buffer(data, 'data');
+	if (format === undefined)
+		format = 'auto';
+	assert.string(format, 'format');
+	if (typeof (options) === 'string')
+		options = { filename: options };
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalString(options.filename, 'options.filename');
+	if (options.filename === undefined)
+		options.filename = '(unnamed)';
+
+	assert.object(formats[format], 'formats[format]');
+
+	try {
+		var k = formats[format].read(data, options);
+		return (k);
+	} catch (e) {
+		throw (new CertificateParseError(options.filename, format, e));
+	}
+};
+
+Certificate.isCertificate = function (obj, ver) {
+	return (utils.isCompatible(obj, Certificate, ver));
+};
+
+/*
+ * API versions for Certificate:
+ * [1,0] -- initial ver
+ */
+Certificate.prototype._sshpkApiVersion = [1, 0];
+
+Certificate._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
diff --git a/lib/errors.js b/lib/errors.js
index d984f1a..1cc09ec 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -50,6 +50,18 @@ function SignatureParseError(type, format, innerErr) {
 }
 util.inherits(SignatureParseError, Error);
 
+function CertificateParseError(name, format, innerErr) {
+	if (Error.captureStackTrace)
+		Error.captureStackTrace(this, CertificateParseError);
+	this.name = 'CertificateParseError';
+	this.format = format;
+	this.certName = name;
+	this.innerErr = innerErr;
+	this.message = 'Failed to parse ' + name + ' as a valid ' + format +
+	    ' format certificate: ' + innerErr.message;
+}
+util.inherits(CertificateParseError, Error);
+
 function KeyEncryptedError(name, format) {
 	if (Error.captureStackTrace)
 		Error.captureStackTrace(this, KeyEncryptedError);
@@ -67,5 +79,6 @@ module.exports = {
 	InvalidAlgorithmError: InvalidAlgorithmError,
 	KeyParseError: KeyParseError,
 	SignatureParseError: SignatureParseError,
-	KeyEncryptedError: KeyEncryptedError
+	KeyEncryptedError: KeyEncryptedError,
+	CertificateParseError: CertificateParseError
 };
diff --git a/lib/fingerprint.js b/lib/fingerprint.js
index c607330..7ed7e51 100644
--- a/lib/fingerprint.js
+++ b/lib/fingerprint.js
@@ -7,6 +7,7 @@ var algs = require('./algs');
 var crypto = require('crypto');
 var errs = require('./errors');
 var Key = require('./key');
+var Certificate = require('./certificate');
 var utils = require('./utils');
 
 var FingerprintFormatError = errs.FingerprintFormatError;
@@ -14,6 +15,7 @@ var InvalidAlgorithmError = errs.InvalidAlgorithmError;
 
 function Fingerprint(opts) {
 	assert.object(opts, 'options');
+	assert.string(opts.type, 'options.type');
 	assert.buffer(opts.hash, 'options.hash');
 	assert.string(opts.algorithm, 'options.algorithm');
 
@@ -22,6 +24,7 @@ function Fingerprint(opts) {
 		throw (new InvalidAlgorithmError(this.algorithm));
 
 	this.hash = opts.hash;
+	this.type = opts.type;
 }
 
 Fingerprint.prototype.toString = function (format) {
@@ -44,11 +47,16 @@ Fingerprint.prototype.toString = function (format) {
 	}
 };
 
-Fingerprint.prototype.matches = function (key) {
-	assert.object(key, 'key');
-	utils.assertCompatible(key, Key, [1, 0], 'key');
+Fingerprint.prototype.matches = function (other) {
+	assert.object(other, 'key or certificate');
+	if (this.type === 'key') {
+		utils.assertCompatible(other, Key, [1, 0], 'key');
+	} else {
+		utils.assertCompatible(other, Certificate, [1, 0],
+		    'certificate');
+	}
 
-	var theirHash = key.hash(this.algorithm);
+	var theirHash = other.hash(this.algorithm);
 	var theirHash2 = crypto.createHash(this.algorithm).
 	    update(theirHash).digest('base64');
 
@@ -59,10 +67,19 @@ Fingerprint.prototype.matches = function (key) {
 	return (this.hash2 === theirHash2);
 };
 
-Fingerprint.parse = function (fp, enAlgs) {
+Fingerprint.parse = function (fp, options) {
 	assert.string(fp, 'fingerprint');
 
-	var alg, hash;
+	var alg, hash, enAlgs;
+	if (Array.isArray(options)) {
+		enAlgs = options;
+		options = {};
+	}
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	if (options.enAlgs !== undefined)
+		enAlgs = options.enAlgs;
 	assert.optionalArrayOfString(enAlgs, 'algorithms');
 
 	var parts = fp.split(':');
@@ -105,7 +122,11 @@ Fingerprint.parse = function (fp, enAlgs) {
 			throw (new InvalidAlgorithmError(alg));
 	}
 
-	return (new Fingerprint({algorithm: alg, hash: hash}));
+	return (new Fingerprint({
+		algorithm: alg,
+		hash: hash,
+		type: options.type || 'key'
+	}));
 };
 
 function addColons(s) {
diff --git a/lib/formats/openssh-cert.js b/lib/formats/openssh-cert.js
new file mode 100644
index 0000000..9365658
--- /dev/null
+++ b/lib/formats/openssh-cert.js
@@ -0,0 +1,276 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	verify: verify,
+	sign: sign,
+	write: write,
+
+	/* Internal private API */
+	fromBuffer: fromBuffer,
+	toBuffer: toBuffer
+};
+
+var assert = require('assert-plus');
+var SSHBuffer = require('../ssh-buffer');
+var crypto = require('crypto');
+var algs = require('../algs');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var Identity = require('../identity');
+var rfc4253 = require('./rfc4253');
+var Signature = require('../signature');
+var utils = require('../utils');
+var Certificate = require('../certificate');
+
+function verify(cert, key) {
+	/*
+	 * We always give an issuerKey, so if our verify() is being called then
+	 * there was no signature. Return false.
+	 */
+	return (false);
+}
+
+var TYPES = {
+	'user': 1,
+	'host': 2
+};
+Object.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });
+
+var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
+
+function read(buf, options) {
+	if (Buffer.isBuffer(buf))
+		buf = buf.toString('ascii');
+	var parts = buf.trim().split(/[ \t\n]+/g);
+	if (parts.length < 2 || parts.length > 3)
+		throw (new Error('Not a valid SSH certificate line'));
+
+	var algo = parts[0];
+	var data = parts[1];
+
+	data = new Buffer(data, 'base64');
+	return (fromBuffer(data, algo));
+}
+
+function fromBuffer(data, algo, partial) {
+	var sshbuf = new SSHBuffer({ buffer: data });
+	var innerAlgo = sshbuf.readString();
+	if (algo !== undefined && innerAlgo !== algo)
+		throw (new Error('SSH certificate algorithm mismatch'));
+
+	var cert = {};
+	cert.signatures = {};
+	cert.signatures.openssh = {};
+
+	cert.signatures.openssh.nonce = sshbuf.readBuffer();
+
+	var key = {};
+	parts = (key.parts = []);
+	key.type = getAlg(algo);
+
+	var partCount = algs.info[key.type].parts.length;
+	while (parts.length < partCount)
+		parts.push(sshbuf.readPart());
+	assert.ok(parts.length >= 1, 'key must have at least one part');
+
+	var algInfo = algs.info[key.type];
+	if (key.type === 'ecdsa') {
+		var res = ECDSA_ALGO.exec(algo);
+		assert.ok(res !== null);
+		assert.strictEqual(res[1], parts[0].data.toString());
+	}
+
+	for (var i = 0; i < algInfo.parts.length; ++i) {
+		parts[i].name = algInfo.parts[i];
+		if (parts[i].name !== 'curve' &&
+		    algInfo.normalize !== false) {
+			var p = parts[i];
+			p.data = utils.mpNormalize(p.data);
+		}
+	}
+
+	cert.subjectKey = new Key(key);
+
+	cert.serial = sshbuf.readInt64();
+
+	var type = TYPES[sshbuf.readInt()];
+	assert.string(type, 'valid cert type');
+
+	cert.signatures.openssh.keyId = sshbuf.readString();
+
+	var principals = [];
+	var pbuf = sshbuf.readBuffer();
+	var psshbuf = new SSHBuffer({ buffer: pbuf });
+	while (!psshbuf.atEnd())
+		principals.push(psshbuf.readString());
+	if (principals.length === 0)
+		principals = ['*'];
+
+	cert.subjects = principals.map(function (pr) {
+		if (type === 'user')
+			return (Identity.forUser(pr));
+		else if (type === 'host')
+			return (Identity.forHost(pr));
+		throw (new Error('Unknown identity type ' + type));
+	});
+
+	cert.validFrom = int64ToDate(sshbuf.readInt64());
+	cert.validUntil = int64ToDate(sshbuf.readInt64());
+
+	cert.signatures.openssh.critical = sshbuf.readBuffer();
+	cert.signatures.openssh.exts = sshbuf.readBuffer();
+
+	/* reserved */
+	sshbuf.readBuffer();
+
+	var signingKeyBuf = sshbuf.readBuffer();
+	cert.issuerKey = rfc4253.read(signingKeyBuf);
+
+	/*
+	 * OpenSSH certs don't give the identity of the issuer, just their
+	 * public key. So, we use an Identity that matches anything. The
+	 * isSignedBy() function will later tell you if the key matches.
+	 */
+	cert.issuer = Identity.forHost('**');
+
+	var sigBuf = sshbuf.readBuffer();
+	cert.signatures.openssh.signature =
+	    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');
+
+	if (partial !== undefined) {
+		partial.remainder = sshbuf.remainder();
+		partial.consumed = sshbuf._offset;
+	}
+
+	return (new Certificate(cert));
+}
+
+function int64ToDate(buf) {
+	var i = buf.readUInt32BE(0) * 4294967296;
+	i += buf.readUInt32BE(4);
+	var d = new Date();
+	d.setTime(i * 1000);
+	d.sourceInt64 = buf;
+	return (d);
+}
+
+function dateToInt64(date) {
+	if (date.sourceInt64 !== undefined)
+		return (date.sourceInt64);
+	var i = Math.round(date.getTime() / 1000);
+	var upper = Math.floor(i / 4294967296);
+	var lower = Math.floor(i % 4294967296);
+	var buf = new Buffer(8);
+	buf.writeUInt32BE(upper, 0);
+	buf.writeUInt32BE(lower, 4);
+	return (buf);
+}
+
+function sign(cert, key) {
+	assert.ok(PrivateKey.isPrivateKey(key, [1, 2]));
+	if (cert.signatures.openssh === undefined)
+		cert.signatures.openssh = {};
+	var sig = cert.signatures.openssh;
+
+	var blob = toBuffer(cert, true);
+	var signer = key.createSign();
+	signer.write(blob);
+	sig.signature = signer.sign();
+}
+
+function write(cert, options) {
+	if (options === undefined)
+		options = {};
+
+	var blob = toBuffer(cert);
+	var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
+	if (options.comment)
+		out = out + ' ' + options.comment;
+	return (out);
+}
+
+
+function toBuffer(cert, noSig) {
+	assert.object(cert.signatures.openssh, 'signature for openssh format');
+	var sig = cert.signatures.openssh;
+
+	if (sig.nonce === undefined)
+		sig.nonce = crypto.randomBytes(16);
+	var buf = new SSHBuffer({});
+	buf.writeString(getCertType(cert.subjectKey));
+	buf.writeBuffer(sig.nonce);
+
+	var key = cert.subjectKey;
+	var algInfo = algs.info[key.type];
+	algInfo.parts.forEach(function (part) {
+		buf.writePart(key.part[part]);
+	});
+
+	buf.writeInt64(cert.serial);
+
+	var type = cert.subjects[0].type;
+	assert.notStrictEqual(type, 'unknown');
+	cert.subjects.forEach(function (id) {
+		assert.strictEqual(id.type, type);
+	});
+	type = TYPES[type];
+	buf.writeInt(type);
+
+	if (sig.keyId === undefined) {
+		sig.keyId = cert.subjects[0].type + '_' +
+		    (cert.subjects[0].uid || cert.subjects[0].hostname);
+	}
+	buf.writeString(sig.keyId);
+
+	var sub = new SSHBuffer({});
+	cert.subjects.forEach(function (id) {
+		if (type === TYPES.host)
+			sub.writeString(id.hostname);
+		else if (type === TYPES.user)
+			sub.writeString(id.uid);
+	});
+	buf.writeBuffer(sub.toBuffer());
+
+	buf.writeInt64(dateToInt64(cert.validFrom));
+	buf.writeInt64(dateToInt64(cert.validUntil));
+
+	if (sig.critical === undefined)
+		sig.critical = new Buffer(0);
+	buf.writeBuffer(sig.critical);
+
+	if (sig.exts === undefined)
+		sig.exts = new Buffer(0);
+	buf.writeBuffer(sig.exts);
+
+	/* reserved */
+	buf.writeBuffer(new Buffer(0));
+
+	sub = rfc4253.write(cert.issuerKey);
+	buf.writeBuffer(sub);
+
+	if (!noSig)
+		buf.writeBuffer(sig.signature.toBuffer('ssh'));
+
+	return (buf.toBuffer());
+}
+
+function getAlg(certType) {
+	if (certType === 'ssh-rsa-cert-v01@openssh.com')
+		return ('rsa');
+	if (certType === 'ssh-dss-cert-v01@openssh.com')
+		return ('dsa');
+	if (certType.match(ECDSA_ALGO))
+		return ('ecdsa');
+	throw (new Error('Unsupported cert type ' + certType));
+}
+
+function getCertType(key) {
+	if (key.type === 'rsa')
+		return ('ssh-rsa-cert-v01@openssh.com');
+	if (key.type === 'dsa')
+		return ('ssh-dss-cert-v01@openssh.com');
+	if (key.type === 'ecdsa')
+		return ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');
+	throw (new Error('Unsupported key type ' + key.type));
+}
diff --git a/lib/formats/pkcs8.js b/lib/formats/pkcs8.js
index 33fb7cc..4ccbefc 100644
--- a/lib/formats/pkcs8.js
+++ b/lib/formats/pkcs8.js
@@ -42,10 +42,12 @@ function readPkcs8(alg, type, der) {
 	}
 
 	der.readSequence();
+	var next = der.offset + der.length;
 
 	var oid = der.readOID();
 	switch (oid) {
 	case '1.2.840.113549.1.1.1':
+		der._offset = next;
 		if (type === 'public')
 			return (readPkcs8RSAPublic(der));
 		else
@@ -66,10 +68,6 @@ function readPkcs8(alg, type, der) {
 }
 
 function readPkcs8RSAPublic(der) {
-	// Null -- XXX this probably isn't good practice
-	der.readByte();
-	der.readByte();
-
 	// bit string sequence
 	der.readSequence(asn1.Ber.BitString);
 	der.readByte();
@@ -93,9 +91,6 @@ function readPkcs8RSAPublic(der) {
 }
 
 function readPkcs8RSAPrivate(der) {
-	der.readByte();
-	der.readByte();
-
 	der.readSequence(asn1.Ber.OctetString);
 	der.readSequence();
 
diff --git a/lib/formats/x509-pem.js b/lib/formats/x509-pem.js
new file mode 100644
index 0000000..c59c7d5
--- /dev/null
+++ b/lib/formats/x509-pem.js
@@ -0,0 +1,77 @@
+// Copyright 2016 Joyent, Inc.
+
+var x509 = require('./x509');
+
+module.exports = {
+	read: read,
+	verify: x509.verify,
+	sign: x509.sign,
+	write: write
+};
+
+var assert = require('assert-plus');
+var asn1 = require('asn1');
+var algs = require('../algs');
+var utils = require('../utils');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var pem = require('./pem');
+var Identity = require('../identity');
+var Signature = require('../signature');
+var Certificate = require('../certificate');
+
+function read(buf, options) {
+	if (typeof (buf) !== 'string') {
+		assert.buffer(buf, 'buf');
+		buf = buf.toString('ascii');
+	}
+
+	var lines = buf.trim().split(/[\r\n]+/g);
+
+	var m = lines[0].match(/*JSSTYLED*/
+	    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
+	assert.ok(m, 'invalid PEM header');
+
+	var m2 = lines[lines.length - 1].match(/*JSSTYLED*/
+	    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
+	assert.ok(m2, 'invalid PEM footer');
+
+	var headers = {};
+	while (true) {
+		lines = lines.slice(1);
+		m = lines[0].match(/*JSSTYLED*/
+		    /^([A-Za-z0-9-]+): (.+)$/);
+		if (!m)
+			break;
+		headers[m[1].toLowerCase()] = m[2];
+	}
+
+	/* Chop off the first and last lines */
+	lines = lines.slice(0, -1).join('');
+	buf = new Buffer(lines, 'base64');
+
+	return (x509.read(buf, options));
+}
+
+function write(cert, options) {
+	var dbuf = x509.write(cert, options);
+
+	var header = 'CERTIFICATE';
+	var tmp = dbuf.toString('base64');
+	var len = tmp.length + (tmp.length / 64) +
+	    18 + 16 + header.length*2 + 10;
+	var buf = new Buffer(len);
+	var o = 0;
+	o += buf.write('-----BEGIN ' + header + '-----\n', o);
+	for (var i = 0; i < tmp.length; ) {
+		var limit = i + 64;
+		if (limit > tmp.length)
+			limit = tmp.length;
+		o += buf.write(tmp.slice(i, limit), o);
+		buf[o++] = 10;
+		i = limit;
+	}
+	o += buf.write('-----END ' + header + '-----\n', o);
+
+	return (buf.slice(0, o));
+}
diff --git a/lib/formats/x509.js b/lib/formats/x509.js
new file mode 100644
index 0000000..6e9b1f5
--- /dev/null
+++ b/lib/formats/x509.js
@@ -0,0 +1,481 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	verify: verify,
+	sign: sign,
+	write: write
+};
+
+var assert = require('assert-plus');
+var asn1 = require('asn1');
+var algs = require('../algs');
+var utils = require('../utils');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var pem = require('./pem');
+var Identity = require('../identity');
+var Signature = require('../signature');
+var Certificate = require('../certificate');
+var pkcs8 = require('./pkcs8');
+
+/*
+ * This file is based on RFC5280 (X.509).
+ */
+
+/* Helper to read in a single mpint */
+function readMPInt(der, nm) {
+	assert.strictEqual(der.peek(), asn1.Ber.Integer,
+	    nm + ' is not an Integer');
+	return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
+}
+
+function verify(cert, key) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	var algParts = sig.algo.split('-');
+	if (algParts[0] !== key.type)
+		return (false);
+
+	var blob = sig.cache;
+	if (blob === undefined) {
+		var der = new asn1.BerWriter();
+		writeTBSCert(cert, der);
+		blob = der.buffer;
+	}
+
+	var verifier = key.createVerify(algParts[1]);
+	verifier.write(blob);
+	return (verifier.verify(sig.signature));
+}
+
+function Local(i) {
+	return (asn1.Ber.Context | asn1.Ber.Constructor | i);
+}
+
+function Context(i) {
+	return (asn1.Ber.Context | i);
+}
+
+var SIGN_ALGS = {
+	'rsa-md5': '1.2.840.113549.1.1.4',
+	'rsa-sha1': '1.2.840.113549.1.1.5',
+	'rsa-sha256': '1.2.840.113549.1.1.11',
+	'rsa-sha384': '1.2.840.113549.1.1.12',
+	'rsa-sha512': '1.2.840.113549.1.1.13',
+	'dsa-sha1': '1.2.840.10040.4.3',
+	'dsa-sha256': '2.16.840.1.101.3.4.3.2',
+	'ecdsa-sha1': '1.2.840.10045.4.1',
+	'ecdsa-sha256': '1.2.840.10045.4.3.2',
+	'ecdsa-sha384': '1.2.840.10045.4.3.3',
+	'ecdsa-sha512': '1.2.840.10045.4.3.4'
+};
+Object.keys(SIGN_ALGS).forEach(function (k) {
+	SIGN_ALGS[SIGN_ALGS[k]] = k;
+});
+SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
+SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';
+
+var EXTS = {
+	'issuerKeyId': '2.5.29.35',
+	'altName': '2.5.29.17'
+};
+
+function read(buf, options) {
+	if (typeof (buf) === 'string') {
+		buf = new Buffer(buf, 'binary');
+	}
+	assert.buffer(buf, 'buf');
+
+	var der = new asn1.BerReader(buf);
+
+	der.readSequence();
+	if (Math.abs(der.length - der.remain) > 1) {
+		throw (new Error('DER sequence does not contain whole byte ' +
+		    'stream'));
+	}
+
+	var tbsStart = der.offset;
+	der.readSequence();
+	var sigOffset = der.offset + der.length;
+	var tbsEnd = sigOffset;
+
+	if (der.peek() === Local(0)) {
+		der.readSequence(Local(0));
+		var version = der.readInt();
+		assert.ok(version <= 3,
+		    'only x.509 versions up to v3 supported');
+	}
+
+	var cert = {};
+	cert.signatures = {};
+	var sig = (cert.signatures.x509 = {});
+	sig.extras = {};
+
+	cert.serial = readMPInt(der, 'serial');
+
+	der.readSequence();
+	var after = der.offset + der.length;
+	var certAlgOid = der.readOID();
+	var certAlg = SIGN_ALGS[certAlgOid];
+	if (certAlg === undefined)
+		throw (new Error('unknown signature algorithm ' + certAlgOid));
+
+	der._offset = after;
+	cert.issuer = Identity.parseAsn1(der);
+
+	der.readSequence();
+	cert.validFrom = readDate(der);
+	cert.validUntil = readDate(der);
+
+	cert.subjects = [Identity.parseAsn1(der)];
+
+	der.readSequence();
+	after = der.offset + der.length;
+	cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);
+	der._offset = after;
+
+	/* issuerUniqueID */
+	if (der.peek() === Local(1)) {
+		der.readSequence(Local(1));
+		sig.extras.issuerUniqueID =
+		    buf.slice(der.offset, der.offset + der.length);
+		der._offset += der.length;
+	}
+
+	/* subjectUniqueID */
+	if (der.peek() === Local(2)) {
+		der.readSequence(Local(2));
+		sig.extras.subjectUniqueID =
+		    buf.slice(der.offset, der.offset + der.length);
+		der._offset += der.length;
+	}
+
+	/* extensions */
+	if (der.peek() === Local(3)) {
+		der.readSequence(Local(3));
+		var extEnd = der.offset + der.length;
+		der.readSequence();
+
+		while (der.offset < extEnd)
+			readExtension(cert, buf, der);
+
+		assert.strictEqual(der.offset, extEnd);
+	}
+
+	assert.strictEqual(der.offset, sigOffset);
+
+	der.readSequence();
+	after = der.offset + der.length;
+	var sigAlgOid = der.readOID();
+	var sigAlg = SIGN_ALGS[sigAlgOid];
+	if (sigAlg === undefined)
+		throw (new Error('unknown signature algorithm ' + sigAlgOid));
+	der._offset = after;
+
+	var sigData = der.readString(asn1.Ber.BitString, true);
+	if (sigData[0] === 0)
+		sigData = sigData.slice(1);
+	var algParts = sigAlg.split('-');
+
+	sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
+	sig.signature.hashAlgorithm = algParts[1];
+	sig.algo = sigAlg;
+	sig.cache = buf.slice(tbsStart, tbsEnd);
+
+	return (new Certificate(cert));
+}
+
+function readDate(der) {
+	if (der.peek() === asn1.Ber.UTCTime) {
+		return (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));
+	} else if (der.peek() === asn1.Ber.GeneralizedTime) {
+		return (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));
+	} else {
+		throw (new Error('Unsupported date format'));
+	}
+}
+
+/* RFC5280, section 4.2.1.6 (GeneralName type) */
+var ALTNAME = {
+	OtherName: Local(0),
+	RFC822Name: Context(1),
+	DNSName: Context(2),
+	X400Address: Local(3),
+	DirectoryName: Local(4),
+	EDIPartyName: Local(5),
+	URI: Context(6),
+	IPAddress: Context(7),
+	OID: Context(8)
+};
+
+function readExtension(cert, buf, der) {
+	der.readSequence();
+	var after = der.offset + der.length;
+	var extId = der.readOID();
+	var id;
+	var sig = cert.signatures.x509;
+	sig.extras.exts = [];
+
+	var critical;
+	if (der.peek() === asn1.Ber.Boolean)
+		critical = der.readBoolean();
+
+	switch (extId) {
+	case (EXTS.altName):
+		der.readSequence(asn1.Ber.OctetString);
+		der.readSequence();
+		var aeEnd = der.offset + der.length;
+		while (der.offset < aeEnd) {
+			switch (der.peek()) {
+			case ALTNAME.OtherName:
+			case ALTNAME.EDIPartyName:
+				der.readSequence();
+				der._offset += der.length;
+				break;
+			case ALTNAME.OID:
+				der.readOID(ALTNAME.OID);
+				break;
+			case ALTNAME.RFC822Name:
+				/* RFC822 specifies email addresses */
+				var email = der.readString(ALTNAME.RFC822Name);
+				id = Identity.forEmail(email);
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			case ALTNAME.DirectoryName:
+				der.readSequence(ALTNAME.DirectoryName);
+				id = Identity.parseAsn1(der);
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			case ALTNAME.DNSName:
+				var host = der.readString(
+				    ALTNAME.DNSName);
+				id = Identity.forHost(host);
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			default:
+				der.readString(der.peek());
+				break;
+			}
+		}
+		sig.extras.exts.push({ oid: extId, critical: critical });
+		break;
+	default:
+		sig.extras.exts.push({
+			oid: extId,
+			critical: critical,
+			data: der.readString(asn1.Ber.OctetString, true)
+		});
+		break;
+	}
+
+	der._offset = after;
+}
+
+var UTCTIME_RE =
+    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
+function utcTimeToDate(t) {
+	var m = t.match(UTCTIME_RE);
+	assert.ok(m, 'timestamps must be in UTC');
+	var d = new Date();
+
+	var thisYear = d.getUTCFullYear();
+	var century = Math.floor(thisYear / 100) * 100;
+
+	var year = parseInt(m[1], 10);
+	if (thisYear % 100 < 50 && year >= 60)
+		year += (century - 1);
+	else
+		year += century;
+	d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
+	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
+	if (m[6] && m[6].length > 0)
+		d.setUTCSeconds(parseInt(m[6], 10));
+	return (d);
+}
+
+var GTIME_RE =
+    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
+function gTimeToDate(t) {
+	var m = t.match(GTIME_RE);
+	assert.ok(m);
+	var d = new Date();
+
+	d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,
+	    parseInt(m[3], 10));
+	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
+	if (m[6] && m[6].length > 0)
+		d.setUTCSeconds(parseInt(m[6], 10));
+	return (d);
+}
+
+function zeroPad(n) {
+	var s = '' + n;
+	while (s.length < 2)
+		s = '0' + s;
+	return (s);
+}
+
+function dateToUTCTime(d) {
+	var s = '';
+	s += zeroPad(d.getUTCFullYear() % 100);
+	s += zeroPad(d.getUTCMonth() + 1);
+	s += zeroPad(d.getUTCDate());
+	s += zeroPad(d.getUTCHours());
+	s += zeroPad(d.getUTCMinutes());
+	s += zeroPad(d.getUTCSeconds());
+	s += 'Z';
+	return (s);
+}
+
+function sign(cert, key) {
+	if (cert.signatures.x509 === undefined)
+		cert.signatures.x509 = {};
+	var sig = cert.signatures.x509;
+
+	sig.algo = key.type + '-' + key.defaultHashAlgorithm();
+	assert.string(SIGN_ALGS[sig.algo]);
+
+	var der = new asn1.BerWriter();
+	writeTBSCert(cert, der);
+	var blob = der.buffer;
+	sig.cache = blob;
+
+	var signer = key.createSign();
+	signer.write(blob);
+	cert.signatures.x509.signature = signer.sign();
+}
+
+function write(cert, options) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	var der = new asn1.BerWriter();
+	der.startSequence();
+	if (sig.cache) {
+		der._ensure(sig.cache.length);
+		sig.cache.copy(der._buf, der._offset);
+		der._offset += sig.cache.length;
+	} else {
+		writeTBSCert(cert, der);
+	}
+
+	der.startSequence();
+	der.writeOID(SIGN_ALGS[sig.algo]);
+	if (sig.algo.match(/^rsa-/))
+		der.writeNull();
+	der.endSequence();
+
+	var sigData = sig.signature.toBuffer('asn1');
+	var data = new Buffer(sigData.length + 1);
+	data[0] = 0;
+	sigData.copy(data, 1);
+	der.writeBuffer(data, asn1.Ber.BitString);
+	der.endSequence();
+
+	return (der.buffer);
+}
+
+function writeTBSCert(cert, der) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	der.startSequence();
+
+	der.startSequence(Local(0));
+	der.writeInt(2);
+	der.endSequence();
+
+	der.writeBuffer(cert.serial, asn1.Ber.Integer);
+
+	der.startSequence();
+	der.writeOID(SIGN_ALGS[sig.algo]);
+	der.endSequence();
+
+	cert.issuer.toAsn1(der);
+
+	der.startSequence();
+	der.writeString(dateToUTCTime(cert.validFrom), asn1.Ber.UTCTime);
+	der.writeString(dateToUTCTime(cert.validUntil), asn1.Ber.UTCTime);
+	der.endSequence();
+
+	var subject = cert.subjects[0];
+	var altNames = cert.subjects.slice(1);
+	subject.toAsn1(der);
+
+	pkcs8.writePkcs8(der, cert.subjectKey);
+
+	if (sig.extras && sig.extras.issuerUniqueID) {
+		der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
+	}
+
+	if (sig.extras && sig.extras.subjectUniqueID) {
+		der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
+	}
+
+	if (altNames.length > 0 || subject.type === 'host' ||
+	    (sig.extras && sig.extras.exts)) {
+		der.startSequence(Local(3));
+		der.startSequence();
+
+		var exts = [
+			{ oid: EXTS.altName }
+		];
+		if (sig.extras && sig.extras.exts)
+			exts = sig.extras.exts;
+
+		for (var i = 0; i < exts.length; ++i) {
+			der.startSequence();
+			der.writeOID(exts[i].oid);
+
+			if (exts[i].critical !== undefined)
+				der.writeBoolean(exts[i].critical);
+
+			if (exts[i].oid === EXTS.altName) {
+				der.startSequence(asn1.Ber.OctetString);
+				der.startSequence();
+				if (subject.type === 'host') {
+					der.writeString(subject.hostname,
+					    Context(2));
+				}
+				for (var j = 0; j < altNames.length; ++j) {
+					if (altNames[j].type === 'host') {
+						der.writeString(
+						    altNames[j].hostname,
+						    ALTNAME.DNSName);
+					} else if (altNames[j].type ===
+					    'email') {
+						der.writeString(
+						    altNames[j].email,
+						    ALTNAME.RFC822Name);
+					} else {
+						/*
+						 * Encode anything else as a
+						 * DN style name for now.
+						 */
+						der.startSequence(
+						    ALTNAME.DirectoryName);
+						altNames[j].toAsn1(der);
+						der.endSequence();
+					}
+				}
+				der.endSequence();
+				der.endSequence();
+			} else {
+				der.writeBuffer(exts[i].data,
+				    asn1.Ber.OctetString);
+			}
+
+			der.endSequence();
+		}
+
+		der.endSequence();
+		der.endSequence();
+	}
+
+	der.endSequence();
+}
diff --git a/lib/identity.js b/lib/identity.js
new file mode 100644
index 0000000..b4f5cd7
--- /dev/null
+++ b/lib/identity.js
@@ -0,0 +1,255 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Identity;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var asn1 = require('asn1');
+
+/*JSSTYLED*/
+var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
+
+var oids = {};
+oids.cn = '2.5.4.3';
+oids.o = '2.5.4.10';
+oids.ou = '2.5.4.11';
+oids.l = '2.5.4.7';
+oids.s = '2.5.4.8';
+oids.c = '2.5.4.6';
+oids.sn = '2.5.4.4';
+oids.dc = '0.9.2342.19200300.100.1.25';
+oids.uid = '0.9.2342.19200300.100.1.1';
+oids.mail = '0.9.2342.19200300.100.1.3';
+
+var unoids = {};
+Object.keys(oids).forEach(function (k) {
+	unoids[oids[k]] = k;
+});
+
+function Identity(opts) {
+	var self = this;
+	assert.object(opts, 'options');
+	assert.arrayOfObject(opts.components, 'options.components');
+	this.components = opts.components;
+	this.componentLookup = {};
+	this.components.forEach(function (c) {
+		if (c.name && !c.oid)
+			c.oid = oids[c.name];
+		if (c.oid && !c.name)
+			c.name = unoids[c.oid];
+		if (self.componentLookup[c.name] === undefined)
+			self.componentLookup[c.name] = [];
+		self.componentLookup[c.name].push(c);
+	});
+	if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
+		this.cn = this.componentLookup.cn[0].value;
+	}
+	assert.optionalString(opts.type, 'options.type');
+	if (opts.type === undefined) {
+		if (this.components.length === 1 &&
+		    this.componentLookup.cn &&
+		    this.componentLookup.cn.length === 1 &&
+		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.cn[0].value;
+
+		} else if (this.componentLookup.dc &&
+		    this.components.length === this.componentLookup.dc.length) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.dc.map(
+			    function (c) {
+				return (c.value);
+			}).join('.');
+
+		} else if (this.componentLookup.uid &&
+		    this.components.length ===
+		    this.componentLookup.uid.length) {
+			this.type = 'user';
+			this.uid = this.componentLookup.uid[0].value;
+
+		} else if (this.componentLookup.cn &&
+		    this.componentLookup.cn.length === 1 &&
+		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.cn[0].value;
+
+		} else if (this.componentLookup.uid &&
+		    this.componentLookup.uid.length === 1) {
+			this.type = 'user';
+			this.uid = this.componentLookup.uid[0].value;
+
+		} else if (this.componentLookup.mail &&
+		    this.componentLookup.mail.length === 1) {
+			this.type = 'email';
+			this.email = this.componentLookup.mail[0].value;
+
+		} else if (this.componentLookup.cn &&
+		    this.componentLookup.cn.length === 1) {
+			this.type = 'user';
+			this.uid = this.componentLookup.cn[0].value;
+
+		} else {
+			this.type = 'unknown';
+		}
+	} else {
+		this.type = opts.type;
+		if (this.type === 'host')
+			this.hostname = opts.hostname;
+		else if (this.type === 'user')
+			this.uid = opts.uid;
+		else if (this.type === 'email')
+			this.email = opts.email;
+		else
+			throw (new Error('Unknown type ' + this.type));
+	}
+}
+
+Identity.prototype.toString = function () {
+	return (this.components.map(function (c) {
+		return (c.name.toUpperCase() + '=' + c.value);
+	}).join(', '));
+};
+
+Identity.prototype.toAsn1 = function (der, tag) {
+	der.startSequence(tag);
+	this.components.forEach(function (c) {
+		der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+		der.startSequence();
+		der.writeOID(c.oid);
+		der.writeString(c.value, asn1.Ber.PrintableString);
+		der.endSequence();
+		der.endSequence();
+	});
+	der.endSequence();
+};
+
+function globMatch(a, b) {
+	if (a === '**' || b === '**')
+		return (true);
+	var aParts = a.split('.');
+	var bParts = b.split('.');
+	if (aParts.length !== bParts.length)
+		return (false);
+	for (var i = 0; i < aParts.length; ++i) {
+		if (aParts[i] === '*' || bParts[i] === '*')
+			continue;
+		if (aParts[i] !== bParts[i])
+			return (false);
+	}
+	return (true);
+}
+
+Identity.prototype.equals = function (other) {
+	if (!Identity.isIdentity(other, [1, 0]))
+		return (false);
+	if (other.components.length !== this.components.length)
+		return (false);
+	for (var i = 0; i < this.components.length; ++i) {
+		if (this.components[i].oid !== other.components[i].oid)
+			return (false);
+		if (!globMatch(this.components[i].value,
+		    other.components[i].value)) {
+			return (false);
+		}
+	}
+	return (true);
+};
+
+Identity.forHost = function (hostname) {
+	assert.string(hostname, 'hostname');
+	return (new Identity({
+		type: 'host',
+		hostname: hostname,
+		components: [ { name: 'cn', value: hostname } ]
+	}));
+};
+
+Identity.forUser = function (uid) {
+	assert.string(uid, 'uid');
+	return (new Identity({
+		type: 'user',
+		uid: uid,
+		components: [ { name: 'uid', value: uid } ]
+	}));
+};
+
+Identity.forEmail = function (email) {
+	assert.string(email, 'email');
+	return (new Identity({
+		type: 'email',
+		email: email,
+		components: [ { name: 'mail', value: email } ]
+	}));
+};
+
+Identity.parseDN = function (dn) {
+	assert.string(dn, 'dn');
+	var parts = dn.split(',');
+	var cmps = parts.map(function (c) {
+		c = c.trim();
+		var eqPos = c.indexOf('=');
+		var name = c.slice(0, eqPos).toLowerCase();
+		var value = c.slice(eqPos + 1);
+		return ({ name: name, value: value });
+	});
+	return (new Identity({ components: cmps }));
+};
+
+Identity.parseAsn1 = function (der, top) {
+	var components = [];
+	der.readSequence(top);
+	var end = der.offset + der.length;
+	while (der.offset < end) {
+		der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+		var after = der.offset + der.length;
+		der.readSequence();
+		var oid = der.readOID();
+		var type = der.peek();
+		var value;
+		switch (type) {
+		case asn1.Ber.PrintableString:
+		case asn1.Ber.IA5String:
+		case asn1.Ber.OctetString:
+		case asn1.Ber.T61String:
+			value = der.readString(type);
+			break;
+		case asn1.Ber.Utf8String:
+			value = der.readString(type, true);
+			value = value.toString('utf8');
+			break;
+		case asn1.Ber.CharacterString:
+		case asn1.Ber.BMPString:
+			value = der.readString(type, true);
+			value = value.toString('utf16le');
+			break;
+		default:
+			throw (new Error('Unknown asn1 type ' + type));
+		}
+		components.push({ oid: oid, value: value });
+		der._offset = after;
+	}
+	der._offset = end;
+	return (new Identity({
+		components: components
+	}));
+};
+
+Identity.isIdentity = function (obj, ver) {
+	return (utils.isCompatible(obj, Identity, ver));
+};
+
+/*
+ * API versions for Identity:
+ * [1,0] -- initial ver
+ */
+Identity.prototype._sshpkApiVersion = [1, 0];
+
+Identity._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
diff --git a/lib/index.js b/lib/index.js
index 0b40429..96a1384 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -4,6 +4,8 @@ var Key = require('./key');
 var Fingerprint = require('./fingerprint');
 var Signature = require('./signature');
 var PrivateKey = require('./private-key');
+var Certificate = require('./certificate');
+var Identity = require('./identity');
 var errs = require('./errors');
 
 module.exports = {
@@ -16,11 +18,21 @@ module.exports = {
 	parseSignature: Signature.parse,
 	PrivateKey: PrivateKey,
 	parsePrivateKey: PrivateKey.parse,
+	Certificate: Certificate,
+	parseCertificate: Certificate.parse,
+	createSelfSignedCertificate: Certificate.createSelfSigned,
+	createCertificate: Certificate.create,
+	Identity: Identity,
+	identityFromDN: Identity.parseDN,
+	identityForHost: Identity.forHost,
+	identityForUser: Identity.forUser,
+	identityForEmail: Identity.forEmail,
 
 	/* errors */
 	FingerprintFormatError: errs.FingerprintFormatError,
 	InvalidAlgorithmError: errs.InvalidAlgorithmError,
 	KeyParseError: errs.KeyParseError,
 	SignatureParseError: errs.SignatureParseError,
-	KeyEncryptedError: errs.KeyEncryptedError
+	KeyEncryptedError: errs.KeyEncryptedError,
+	CertificateParseError: errs.CertificateParseError
 };
diff --git a/lib/key.js b/lib/key.js
index edc5143..ff5c363 100644
--- a/lib/key.js
+++ b/lib/key.js
@@ -117,6 +117,7 @@ Key.prototype.fingerprint = function (algo) {
 		algo = 'sha256';
 	assert.string(algo, 'algorithm');
 	var opts = {
+		type: 'key',
 		hash: this.hash(algo),
 		algorithm: algo
 	};
diff --git a/lib/signature.js b/lib/signature.js
index ddf4a8c..964f55c 100644
--- a/lib/signature.js
+++ b/lib/signature.js
@@ -65,23 +65,31 @@ Signature.prototype.toBuffer = function (format) {
 			buf = new SSHBuffer({});
 			buf.writeString('ssh-dss');
 			r = this.part.r.data;
-			if (r[0] === 0x00)
+			if (r.length > 20 && r[0] === 0x00)
 				r = r.slice(1);
 			s = this.part.s.data;
+			if (s.length > 20 && s[0] === 0x00)
+				s = s.slice(1);
+			if ((this.hashAlgorithm &&
+			    this.hashAlgorithm !== 'sha1') ||
+			    r.length + s.length !== 40) {
+				throw (new Error('OpenSSH only supports ' +
+				    'DSA signatures with SHA1 hash'));
+			}
 			buf.writeBuffer(Buffer.concat([r, s]));
 			return (buf.toBuffer());
 		} else if (format === 'ssh' && this.type === 'ecdsa') {
 			var inner = new SSHBuffer({});
-			r = this.part.r;
-			if (r[0] === 0x00)
-				r = r.slice(1);
-			inner.writePart(r);
+			r = this.part.r.data;
+			inner.writeBuffer(r);
 			inner.writePart(this.part.s);
 
 			buf = new SSHBuffer({});
 			/* XXX: find a more proper way to do this? */
 			var curve;
-			var sz = this.part.r.data.length * 8;
+			if (r[0] === 0x00)
+				r = r.slice(1);
+			var sz = r.length * 8;
 			if (sz === 256)
 				curve = 'nistp256';
 			else if (sz === 384)
diff --git a/lib/ssh-buffer.js b/lib/ssh-buffer.js
index 0b00277..8fc2cb8 100644
--- a/lib/ssh-buffer.js
+++ b/lib/ssh-buffer.js
@@ -73,6 +73,14 @@ SSHBuffer.prototype.readInt = function () {
 	return (v);
 };
 
+SSHBuffer.prototype.readInt64 = function () {
+	assert.ok(this._offset + 8 < this._buffer.length,
+	    'buffer not long enough to read Int64');
+	var v = this._buffer.slice(this._offset, this._offset + 8);
+	this._offset += 8;
+	return (v);
+};
+
 SSHBuffer.prototype.readChar = function () {
 	var v = this._buffer[this._offset++];
 	return (v);
@@ -106,6 +114,22 @@ SSHBuffer.prototype.writeInt = function (v) {
 	this._offset += 4;
 };
 
+SSHBuffer.prototype.writeInt64 = function (v) {
+	assert.buffer(v, 'value');
+	if (v.length > 8) {
+		var lead = v.slice(0, v.length - 8);
+		for (var i = 0; i < lead.length; ++i) {
+			assert.strictEqual(lead[i], 0,
+			    'must fit in 64 bits of precision');
+		}
+		v = v.slice(v.length - 8, v.length);
+	}
+	while (this._offset + 8 > this._size)
+		this.expand();
+	v.copy(this._buffer, this._offset);
+	this._offset += 8;
+};
+
 SSHBuffer.prototype.writeChar = function (v) {
 	while (this._offset + 1 > this._size)
 		this.expand();
diff --git a/test/assets/1024b-dsa-example-cert.der b/test/assets/1024b-dsa-example-cert.der
new file mode 100644
index 0000000..cef4ef0
Binary files /dev/null and b/test/assets/1024b-dsa-example-cert.der differ
diff --git a/test/assets/cloudflare.pem b/test/assets/cloudflare.pem
new file mode 100644
index 0000000..eefb224
--- /dev/null
+++ b/test/assets/cloudflare.pem
@@ -0,0 +1,32 @@
+-----BEGIN CERTIFICATE-----
+MIIFfDCCBSOgAwIBAgIRAKUKr1+KSsQLm/QUXECt7cYwCgYIKoZIzj0EAwIwgZIx
+CzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNV
+BAcTB1NhbGZvcmQxGjAYBgNVBAoTEUNPTU9ETyBDQSBMaW1pdGVkMTgwNgYDVQQD
+Ey9DT01PRE8gRUNDIERvbWFpbiBWYWxpZGF0aW9uIFNlY3VyZSBTZXJ2ZXIgQ0Eg
+MjAeFw0xNjA3MDUwMDAwMDBaFw0xNzAxMDgyMzU5NTlaMGwxITAfBgNVBAsTGERv
+bWFpbiBDb250cm9sIFZhbGlkYXRlZDEhMB8GA1UECxMYUG9zaXRpdmVTU0wgTXVs
+dGktRG9tYWluMSQwIgYDVQQDExtzbmkxMTMzNTYuY2xvdWRmbGFyZXNzbC5jb20w
+WTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARgm17F3ag1w7gicQ7Qmo/OTCMpFm1C
+DO0vQ9pehgY8CYYrAJFzlRwjTpdXLxZ18LDAhS9FDosDNRERnglOeVBso4IDfTCC
+A3kwHwYDVR0jBBgwFoAUQAlhZ/C8g3FP3hIILG/U1Ct2PZYwHQYDVR0OBBYEFGhp
+JT1yvejIdhQVK0HY0u/yJ16nMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAA
+MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjBPBgNVHSAESDBGMDoGCysG
+AQQBsjEBAgIHMCswKQYIKwYBBQUHAgEWHWh0dHBzOi8vc2VjdXJlLmNvbW9kby5j
+b20vQ1BTMAgGBmeBDAECATBWBgNVHR8ETzBNMEugSaBHhkVodHRwOi8vY3JsLmNv
+bW9kb2NhNC5jb20vQ09NT0RPRUNDRG9tYWluVmFsaWRhdGlvblNlY3VyZVNlcnZl
+ckNBMi5jcmwwgYgGCCsGAQUFBwEBBHwwejBRBggrBgEFBQcwAoZFaHR0cDovL2Ny
+dC5jb21vZG9jYTQuY29tL0NPTU9ET0VDQ0RvbWFpblZhbGlkYXRpb25TZWN1cmVT
+ZXJ2ZXJDQTIuY3J0MCUGCCsGAQUFBzABhhlodHRwOi8vb2NzcC5jb21vZG9jYTQu
+Y29tMIIBxAYDVR0RBIIBuzCCAbeCG3NuaTExMzM1Ni5jbG91ZGZsYXJlc3NsLmNv
+bYISKi5hdmVyeS1za2FjaGF0Lm1sggsqLmJsZWFjaC5tbIIWKi5idW5rYmVkc2Zv
+cmdpcmxzLmNvbYIXKi5jaGljZnVybmlzaGluZzEwMS54eXqCCyouaW1leW91Lmlv
+ggwqLmtuZmVtNDAuY2aCGSoubWV0YWxkZXRlY3Rpbmdob3d0by54eXqCDCoubmx5
+dnU0MC5jZoIMKi5vYmtrZzQwLmdhgg8qLm9ub21hZC5vbmxpbmWCFCoub3V0bGFu
+ZGlzaGpvc2guY29tggwqLnRsaW9qNDUuZ2GCEGF2ZXJ5LXNrYWNoYXQubWyCCWJs
+ZWFjaC5tbIIUYnVua2JlZHNmb3JnaXJscy5jb22CFWNoaWNmdXJuaXNoaW5nMTAx
+Lnh5eoIJaW1leW91LmlvggprbmZlbTQwLmNmghdtZXRhbGRldGVjdGluZ2hvd3Rv
+Lnh5eoIKbmx5dnU0MC5jZoIKb2Jra2c0MC5nYYINb25vbWFkLm9ubGluZYISb3V0
+bGFuZGlzaGpvc2guY29tggp0bGlvajQ1LmdhMAoGCCqGSM49BAMCA0cAMEQCIAss
+1QbMKvQtnCVbXjNr3rXLThFAwpOGQjWD8u5Mh7+HAiBxnaMWa4+OB59rx1ypvqB4
+u9pTEKNZOM7c3kgawXq4Pw==
+-----END CERTIFICATE-----
diff --git a/test/assets/comodo.crt b/test/assets/comodo.crt
new file mode 100644
index 0000000..a11d5d5
Binary files /dev/null and b/test/assets/comodo.crt differ
diff --git a/test/assets/digicert-ca.crt b/test/assets/digicert-ca.crt
new file mode 100644
index 0000000..dd14c1b
Binary files /dev/null and b/test/assets/digicert-ca.crt differ
diff --git a/test/assets/digicert.pem b/test/assets/digicert.pem
new file mode 100644
index 0000000..4fc943c
--- /dev/null
+++ b/test/assets/digicert.pem
@@ -0,0 +1,50 @@
+-----BEGIN CERTIFICATE-----
+MIII9TCCB92gAwIBAgIQB5PsiVldumBtH9n3vjiYAjANBgkqhkiG9w0BAQsFADB1
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMTQwMgYDVQQDEytEaWdpQ2VydCBTSEEyIEV4dGVuZGVk
+IFZhbGlkYXRpb24gU2VydmVyIENBMB4XDTE2MDQxMzAwMDAwMFoXDTE4MDcxMjEy
+MDAwMFowggELMR0wGwYDVQQPDBRQcml2YXRlIE9yZ2FuaXphdGlvbjETMBEGCysG
+AQQBgjc8AgEDEwJVUzEVMBMGCysGAQQBgjc8AgECEwRVdGFoMRUwEwYDVQQFEww1
+Mjk5NTM3LTAxNDIxEjAQBgNVBAkTCVN1aXRlIDUwMDEkMCIGA1UECRMbMjYwMCBX
+ZXN0IEV4ZWN1dGl2ZSBQYXJrd2F5MQ4wDAYDVQQREwU4NDA0MzELMAkGA1UEBhMC
+VVMxDTALBgNVBAgTBFV0YWgxDTALBgNVBAcTBExlaGkxFzAVBgNVBAoTDkRpZ2lD
+ZXJ0LCBJbmMuMRkwFwYDVQQDExB3d3cuZGlnaWNlcnQuY29tMIICIjANBgkqhkiG
+9w0BAQEFAAOCAg8AMIICCgKCAgEAuQg5iARyi8lq9e6z8p/RiBSzaeGgBk0A95Fj
+QL5CZC8Wg5j+AIZA43H4FddYVNo484l2hA2/QrqJ/jMiJnQxTIrKT2DCVuQtieUw
+UUdZlwvibczmNhE0xQSOr9wo0rv75vWhy0t7qUllp52aIHdSDH7BRSQcBpTWTbDJ
+LCUTkfP3cXrGMMEWu4A+pTX2GUgdx85Xm3PRcECUB9f/NzCGy2s3qPnEtQSxdpxO
+RngfS6OQEwwucDWbVIeJmfnl0x7vlaWGF/kprYwD/5pwda8Nzfuzm3vYVXBcuiCZ
+xHmQkgxsbvUWjfIaj7JAsucOFMteil5tyHqYD9IW+4HLacIJPMiZf6QcdaSbN//b
+9WBecDjUVoRu+XOhQ+8PfM0XXdQRdLLciHsyJw0yJoxHQtVIzBXo2/0IEsH9Ugqn
+fB04OxaRQrBie4im7kvKuk/NSOem4z798ku6OrGIHZ9caQzoj6/HQlAABfPoQf5U
+D1nbfkFPXMDB+oHanC+hZl6999nVHKOGSJ9GyKiSUUWa0yhYMs/9eFy2sDiZGXah
+8FMGIUVWxGIpVMiEWIx1fpryJRMV1cPM+KUxtyXpPlCMfU2vYShGLBnBuV99Pu1c
+H2meXJ9WOpW98e56SUUhF7j30o7KIvDstAHLazdLjlSwHKmdiSaR/7W503zbwH0d
+2Aw7tQMCAwEAAaOCA+cwggPjMB8GA1UdIwQYMBaAFD3TUKXWoK3u80pgCmXTIdT4
++NYPMB0GA1UdDgQWBBS2NuP/ZUT2HMjct2KBgsNU1vfhGzCBkQYDVR0RBIGJMIGG
+ghB3d3cuZGlnaWNlcnQuY29tggxkaWdpY2VydC5jb22CFGNvbnRlbnQuZGlnaWNl
+cnQuY29tghd3d3cub3JpZ2luLmRpZ2ljZXJ0LmNvbYISbG9naW4uZGlnaWNlcnQu
+Y29tghBhcGkuZGlnaWNlcnQuY29tgg93cy5kaWdpY2VydC5jb20wDgYDVR0PAQH/
+BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjB1BgNVHR8EbjBs
+MDSgMqAwhi5odHRwOi8vY3JsMy5kaWdpY2VydC5jb20vc2hhMi1ldi1zZXJ2ZXIt
+ZzEuY3JsMDSgMqAwhi5odHRwOi8vY3JsNC5kaWdpY2VydC5jb20vc2hhMi1ldi1z
+ZXJ2ZXItZzEuY3JsMEsGA1UdIAREMEIwNwYJYIZIAYb9bAIBMCowKAYIKwYBBQUH
+AgEWHGh0dHBzOi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwBwYFZ4EMAQEwgYgGCCsG
+AQUFBwEBBHwwejAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29t
+MFIGCCsGAQUFBzAChkZodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNl
+cnRTSEEyRXh0ZW5kZWRWYWxpZGF0aW9uU2VydmVyQ0EuY3J0MAwGA1UdEwEB/wQC
+MAAwggF/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB2AKS5CZC0GFgUh7sTosxncAo8
+NZgE+RvfuON3zQ7IDdwQAAABVBHgwLgAAAQDAEcwRQIhAMrgQPcfykbBgZ7iZODi
+4454PeF6YAq4wSrSkWQcxr1hAiBCTOv1QQHaTjjBa0pGWRwH1+fnG7GO81P2zsr2
+ozUwlwB2AGj2mPgfZIK+OozuuSgdTPxxUV1nk9RE0QpnrLtPT/vEAAABVBHgv70A
+AAQDAEcwRQIgRbrwWwJGn/Df8bUDctAp6+yLDN8xeDuBb+Ca3e+s1rgCIQCPBsU8
+6ybInQTqAmwu9RCpV7ytVMtHeoue845hN+JObAB3AFYUBpov18Ls0/XhvUSyPsdG
+drm8mRFcwO+UmFXWidDdAAABVBHgwS0AAAQDAEgwRgIhAKlTN5K7HfPOnl+Foc2i
++umn/s/8SSlfcfWRO0Sn6gEOAiEA09nNyMnKlxW+fMatiDgpPwTnYEdyvwpvFA8U
+84dPFfowDQYJKoZIhvcNAQELBQADggEBAJJGUr8YXsJkwK9/c52ZTQxiiwPd9yqO
+aquypvBFd5UwobZqO08wX1e1XsPSR1FTRz0LEALWwcm+vap60EDRog1SIA+p5e7Z
+WYimYliUfGLgYikcbqHdeEe5J66RRUho1fcIag3cQbknSImFqY4vF4DLHq0JVwwL
+Hvc2Meuycm7bWDK2ErXxck4odVTOurz+xQxJWy0G4Q3h3BlDLUMR6rE50GcdKOJF
+m4vdDEEMl7xZm+dVZ5GQGfKxOUUF90E0PIbIvnCQGSLwIWdhtZW1Cfzxe0ZGYaPc
+MYTd5frlLpj1kU5+Hvs8sjwnLH57Y66e8T9bxVWR0cjBJO6G/LZadWE=
+-----END CERTIFICATE-----
diff --git a/test/assets/frank4dd-cacert.der b/test/assets/frank4dd-cacert.der
new file mode 100644
index 0000000..306de2a
Binary files /dev/null and b/test/assets/frank4dd-cacert.der differ
diff --git a/test/assets/george-openssh.pub b/test/assets/george-openssh.pub
new file mode 100644
index 0000000..ee5bdeb
--- /dev/null
+++ b/test/assets/george-openssh.pub
@@ -0,0 +1 @@
+ssh-dss-cert-v01@openssh.com AAAAHHNzaC1kc3MtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgzc/ITc93psigtgu8QX+zM61g/eCQp4CAEi/vFdqp3TwAAACBANBGJdbHdT5d/1tU3d3Cw1Hr2/PoyYsmaGP82wH+2apK0RoZOmQfHlc/oyz9yordFB/VgleR800m5rJJH2TvwMqphw611oGDu+hSqV5UGyQBKIzPfh4mi9WHY4rZ6nHEeC2SiT6QKZG7dutDvXHmjBrLU+hwBY/Fd7oBN9P0Qxu3AAAAFQC0/mjeSy8EnwMuUhO098QaKBbYFQAAAIEAtZiJz9yGBwT1vsoLM938qkWSYU78qseOqXmpXFgCi9nbtXWvrLFEMAsQIUTBzNkEyDWyVBU8ld9ycvlaj5jclNaRJ/JLcGyzK/8I78/QvtiY/VkSxLxymOkLI33q/yXWn5yUEU5HyBdiyI4eLFvYS2slyxYWq63b6NTr99lFBd4AAACBAItcldZqWy1ZyoLMLcFzYV3Q80vU2aFXWckDU7xPERsjSnmxIuvKSZGCpZZX6XqWn0zcdtu+AZGVZu1FOpV/g0cckpGi2ACtZ2XLGZ2IdMk0cTrZTmzXPBLxy5gBkO1CijIjGy2d5B4ojI9vAf5uTc+qY15qel1KzXuPgzP+zABmAAAAAAAAAAAAAAABAAAACWdlb3JnZWtleQAAAAoAAAAGZ2VvcmdlAAAAAFeRWggAAAAAWXE8fQAAAAAAAACCAAAAFXBlcm1pdC1YMTEtZm9yd2FyZGluZwAAAAAAAAAXcGVybWl0LWFnZW50LWZvcndhcmRpbmcAAAAAAAAAFnBlcm1pdC1wb3J0LWZvcndhcmRpbmcAAAAAAAAACnBlcm1pdC1wdHkAAAAAAAAADnBlcm1pdC11c2VyLXJjAAAAAAAAAAAAAAGzAAAAB3NzaC1kc3MAAACBANBGJdbHdT5d/1tU3d3Cw1Hr2/PoyYsmaGP82wH+2apK0RoZOmQfHlc/oyz9yordFB/VgleR800m5rJJH2TvwMqphw611oGDu+hSqV5UGyQBKIzPfh4mi9WHY4rZ6nHEeC2SiT6QKZG7dutDvXHmjBrLU+hwBY/Fd7oBN9P0Qxu3AAAAFQC0/mjeSy8EnwMuUhO098QaKBbYFQAAAIEAtZiJz9yGBwT1vsoLM938qkWSYU78qseOqXmpXFgCi9nbtXWvrLFEMAsQIUTBzNkEyDWyVBU8ld9ycvlaj5jclNaRJ/JLcGyzK/8I78/QvtiY/VkSxLxymOkLI33q/yXWn5yUEU5HyBdiyI4eLFvYS2slyxYWq63b6NTr99lFBd4AAACBAItcldZqWy1ZyoLMLcFzYV3Q80vU2aFXWckDU7xPERsjSnmxIuvKSZGCpZZX6XqWn0zcdtu+AZGVZu1FOpV/g0cckpGi2ACtZ2XLGZ2IdMk0cTrZTmzXPBLxy5gBkO1CijIjGy2d5B4ojI9vAf5uTc+qY15qel1KzXuPgzP+zABmAAAANwAAAAdzc2gtZHNzAAAAKC53ceRpJIQ73wc1BHbp9cccco08sPylyIEbBgT2e2SHBZV/WMOeInM= id_dsa
diff --git a/test/assets/george-x509.pem b/test/assets/george-x509.pem
new file mode 100644
index 0000000..d3f48ed
--- /dev/null
+++ b/test/assets/george-x509.pem
@@ -0,0 +1,15 @@
+-----BEGIN CERTIFICATE-----
+MIICazCCAigCCQC5yqE79U0ouDALBglghkgBZQMEAwIwGDEWMBQGCgmSJomT8ixk
+AQETBmdlb3JnZTAeFw0xNjA3MjEyMzI2MjJaFw0xNzA3MjEyMzI2MjJaMBgxFjAU
+BgoJkiaJk/IsZAEBEwZnZW9yZ2UwggG4MIIBLAYHKoZIzjgEATCCAR8CgYEA0EYl
+1sd1Pl3/W1Td3cLDUevb8+jJiyZoY/zbAf7ZqkrRGhk6ZB8eVz+jLP3Kit0UH9WC
+V5HzTSbmskkfZO/AyqmHDrXWgYO76FKpXlQbJAEojM9+HiaL1YdjitnqccR4LZKJ
+PpApkbt260O9ceaMGstT6HAFj8V3ugE30/RDG7cCFQC0/mjeSy8EnwMuUhO098Qa
+KBbYFQKBgQC1mInP3IYHBPW+ygsz3fyqRZJhTvyqx46pealcWAKL2du1da+ssUQw
+CxAhRMHM2QTINbJUFTyV33Jy+VqPmNyU1pEn8ktwbLMr/wjvz9C+2Jj9WRLEvHKY
+6Qsjfer/JdafnJQRTkfIF2LIjh4sW9hLayXLFharrdvo1Ov32UUF3gOBhQACgYEA
+i1yV1mpbLVnKgswtwXNhXdDzS9TZoVdZyQNTvE8RGyNKebEi68pJkYKlllfpepaf
+TNx2274BkZVm7UU6lX+DRxySkaLYAK1nZcsZnYh0yTRxOtlObNc8EvHLmAGQ7UKK
+MiMbLZ3kHiiMj28B/m5Nz6pjXmp6XUrNe4+DM/7MAGYwCwYJYIZIAWUDBAMCAzAA
+MC0CFQCvM7xt2Yzh/5hKwFXTzNWhTfaeNgIUM3mu1O1fK1s2V+TTIKx3KIvVm8I=
+-----END CERTIFICATE-----
diff --git a/test/assets/google_jp_458san.pem b/test/assets/google_jp_458san.pem
new file mode 100644
index 0000000..dae16d8
--- /dev/null
+++ b/test/assets/google_jp_458san.pem
@@ -0,0 +1,152 @@
+-----BEGIN CERTIFICATE-----
+MIIcFzCCG4CgAwIBAgIGR09PUAFxMA0GCSqGSIb3DQEBBQUAMEYxCzAJBgNVBAYT
+AlVTMRMwEQYDVQQKEwpHb29nbGUgSW5jMSIwIAYDVQQDExlHb29nbGUgSW50ZXJu
+ZXQgQXV0aG9yaXR5MB4XDTEyMTAyNDEzNTczOVoXDTEzMDYwNzE5NDMyN1owZDEL
+MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50
+YWluIFZpZXcxEzARBgNVBAoTCkdvb2dsZSBJbmMxEzARBgNVBAMTCmdvb2dsZS5j
+b20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMNn/Rw5irMPscWpYsExcGQT
+wqdxT/U9Pfybt9ttPYlXVbCd6yux0jWGNBHN+f4kCc5pwrbjmA4QSRY2uVa4T8f2
+g3NucDDveUi29WVN+FJcyhj+V38lEkYbdhpIZL149dK5fAN1zzwCo10Nk+lhebcY
+fCtMHLmuCX2D6mJ2CnPVAgMBAAGjghnwMIIZ7DAMBgNVHRMBAf8EAjAAMB0GA1Ud
+JQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNVHQ4EFgQU0Qp1w0hi4nhbaJEB
+h/wuZwO4OyIwHwYDVR0jBBgwFoAUv8Aw6/VDET5nup6R+/xq2uNrEiQwWwYDVR0f
+BFQwUjBQoE6gTIZKaHR0cDovL3d3dy5nc3RhdGljLmNvbS9Hb29nbGVJbnRlcm5l
+dEF1dGhvcml0eS9Hb29nbGVJbnRlcm5ldEF1dGhvcml0eS5jcmwwZgYIKwYBBQUH
+AQEEWjBYMFYGCCsGAQUFBzAChkpodHRwOi8vd3d3LmdzdGF0aWMuY29tL0dvb2ds
+ZUludGVybmV0QXV0aG9yaXR5L0dvb2dsZUludGVybmV0QXV0aG9yaXR5LmNydDCC
+GLYGA1UdEQSCGK0wghipggpnb29nbGUuY29tggwqLmdvb2dsZS5jb22CDSoueW91
+dHViZS5jb22CC3lvdXR1YmUuY29tghYqLnlvdXR1YmUtbm9jb29raWUuY29tggh5
+b3V0dS5iZYILKi55dGltZy5jb22CDSouYW5kcm9pZC5jb22CC2FuZHJvaWQuY29t
+ghQqLmdvb2dsZWNvbW1lcmNlLmNvbYISZ29vZ2xlY29tbWVyY2UuY29tghAqLnVy
+bC5nb29nbGUuY29tggwqLnVyY2hpbi5jb22CCnVyY2hpbi5jb22CFiouZ29vZ2xl
+LWFuYWx5dGljcy5jb22CFGdvb2dsZS1hbmFseXRpY3MuY29tghIqLmNsb3VkLmdv
+b2dsZS5jb22CBmdvby5nbIIEZy5jb4INKi5nc3RhdGljLmNvbYIPKi5nb29nbGVh
+cGlzLmNughYqLmFwcGVuZ2luZS5nb29nbGUuY29tggsqLmdvb2dsZS5hY4ILKi5n
+b29nbGUuYWSCCyouZ29vZ2xlLmFlggsqLmdvb2dsZS5hZoILKi5nb29nbGUuYWeC
+CyouZ29vZ2xlLmFsggsqLmdvb2dsZS5hbYILKi5nb29nbGUuYXOCCyouZ29vZ2xl
+LmF0ggsqLmdvb2dsZS5heoILKi5nb29nbGUuYmGCCyouZ29vZ2xlLmJlggsqLmdv
+b2dsZS5iZoILKi5nb29nbGUuYmeCCyouZ29vZ2xlLmJpggsqLmdvb2dsZS5iaoIL
+Ki5nb29nbGUuYnOCCyouZ29vZ2xlLmJ5ggsqLmdvb2dsZS5jYYIMKi5nb29nbGUu
+Y2F0ggsqLmdvb2dsZS5jY4ILKi5nb29nbGUuY2SCCyouZ29vZ2xlLmNmggsqLmdv
+b2dsZS5jZ4ILKi5nb29nbGUuY2iCCyouZ29vZ2xlLmNpggsqLmdvb2dsZS5jbIIL
+Ki5nb29nbGUuY22CCyouZ29vZ2xlLmNugg4qLmdvb2dsZS5jby5hb4IOKi5nb29n
+bGUuY28uYneCDiouZ29vZ2xlLmNvLmNrgg4qLmdvb2dsZS5jby5jcoIOKi5nb29n
+bGUuY28uaHWCDiouZ29vZ2xlLmNvLmlkgg4qLmdvb2dsZS5jby5pbIIOKi5nb29n
+bGUuY28uaW2CDiouZ29vZ2xlLmNvLmlugg4qLmdvb2dsZS5jby5qZYIOKi5nb29n
+bGUuY28uanCCDiouZ29vZ2xlLmNvLmtlgg4qLmdvb2dsZS5jby5rcoIOKi5nb29n
+bGUuY28ubHOCDiouZ29vZ2xlLmNvLm1hgg4qLmdvb2dsZS5jby5teoIOKi5nb29n
+bGUuY28ubnqCDiouZ29vZ2xlLmNvLnRogg4qLmdvb2dsZS5jby50eoIOKi5nb29n
+bGUuY28udWeCDiouZ29vZ2xlLmNvLnVrgg4qLmdvb2dsZS5jby51eoIOKi5nb29n
+bGUuY28udmWCDiouZ29vZ2xlLmNvLnZpgg4qLmdvb2dsZS5jby56YYIOKi5nb29n
+bGUuY28uem2CDiouZ29vZ2xlLmNvLnp3gg8qLmdvb2dsZS5jb20uYWaCDyouZ29v
+Z2xlLmNvbS5hZ4IPKi5nb29nbGUuY29tLmFpgg8qLmdvb2dsZS5jb20uYXKCDyou
+Z29vZ2xlLmNvbS5hdYIPKi5nb29nbGUuY29tLmJkgg8qLmdvb2dsZS5jb20uYmiC
+DyouZ29vZ2xlLmNvbS5iboIPKi5nb29nbGUuY29tLmJvgg8qLmdvb2dsZS5jb20u
+YnKCDyouZ29vZ2xlLmNvbS5ieYIPKi5nb29nbGUuY29tLmJ6gg8qLmdvb2dsZS5j
+b20uY26CDyouZ29vZ2xlLmNvbS5jb4IPKi5nb29nbGUuY29tLmN1gg8qLmdvb2ds
+ZS5jb20uY3mCDyouZ29vZ2xlLmNvbS5kb4IPKi5nb29nbGUuY29tLmVjgg8qLmdv
+b2dsZS5jb20uZWeCDyouZ29vZ2xlLmNvbS5ldIIPKi5nb29nbGUuY29tLmZqgg8q
+Lmdvb2dsZS5jb20uZ2WCDyouZ29vZ2xlLmNvbS5naIIPKi5nb29nbGUuY29tLmdp
+gg8qLmdvb2dsZS5jb20uZ3KCDyouZ29vZ2xlLmNvbS5ndIIPKi5nb29nbGUuY29t
+Lmhrgg8qLmdvb2dsZS5jb20uaXGCDyouZ29vZ2xlLmNvbS5qbYIPKi5nb29nbGUu
+Y29tLmpvgg8qLmdvb2dsZS5jb20ua2iCDyouZ29vZ2xlLmNvbS5rd4IPKi5nb29n
+bGUuY29tLmxigg8qLmdvb2dsZS5jb20ubHmCDyouZ29vZ2xlLmNvbS5tdIIPKi5n
+b29nbGUuY29tLm14gg8qLmdvb2dsZS5jb20ubXmCDyouZ29vZ2xlLmNvbS5uYYIP
+Ki5nb29nbGUuY29tLm5mgg8qLmdvb2dsZS5jb20ubmeCDyouZ29vZ2xlLmNvbS5u
+aYIPKi5nb29nbGUuY29tLm5wgg8qLmdvb2dsZS5jb20ubnKCDyouZ29vZ2xlLmNv
+bS5vbYIPKi5nb29nbGUuY29tLnBhgg8qLmdvb2dsZS5jb20ucGWCDyouZ29vZ2xl
+LmNvbS5waIIPKi5nb29nbGUuY29tLnBrgg8qLmdvb2dsZS5jb20ucGyCDyouZ29v
+Z2xlLmNvbS5wcoIPKi5nb29nbGUuY29tLnB5gg8qLmdvb2dsZS5jb20ucWGCDyou
+Z29vZ2xlLmNvbS5ydYIPKi5nb29nbGUuY29tLnNhgg8qLmdvb2dsZS5jb20uc2KC
+DyouZ29vZ2xlLmNvbS5zZ4IPKi5nb29nbGUuY29tLnNsgg8qLmdvb2dsZS5jb20u
+c3aCDyouZ29vZ2xlLmNvbS50aoIPKi5nb29nbGUuY29tLnRugg8qLmdvb2dsZS5j
+b20udHKCDyouZ29vZ2xlLmNvbS50d4IPKi5nb29nbGUuY29tLnVhgg8qLmdvb2ds
+ZS5jb20udXmCDyouZ29vZ2xlLmNvbS52Y4IPKi5nb29nbGUuY29tLnZlgg8qLmdv
+b2dsZS5jb20udm6CCyouZ29vZ2xlLmN2ggsqLmdvb2dsZS5jeoILKi5nb29nbGUu
+ZGWCCyouZ29vZ2xlLmRqggsqLmdvb2dsZS5ka4ILKi5nb29nbGUuZG2CCyouZ29v
+Z2xlLmR6ggsqLmdvb2dsZS5lZYILKi5nb29nbGUuZXOCCyouZ29vZ2xlLmZpggsq
+Lmdvb2dsZS5mbYILKi5nb29nbGUuZnKCCyouZ29vZ2xlLmdhggsqLmdvb2dsZS5n
+ZYILKi5nb29nbGUuZ2eCCyouZ29vZ2xlLmdsggsqLmdvb2dsZS5nbYILKi5nb29n
+bGUuZ3CCCyouZ29vZ2xlLmdyggsqLmdvb2dsZS5neYILKi5nb29nbGUuaGuCCyou
+Z29vZ2xlLmhuggsqLmdvb2dsZS5ocoILKi5nb29nbGUuaHSCCyouZ29vZ2xlLmh1
+ggsqLmdvb2dsZS5pZYILKi5nb29nbGUuaW2CDSouZ29vZ2xlLmluZm+CCyouZ29v
+Z2xlLmlxggsqLmdvb2dsZS5pc4ILKi5nb29nbGUuaXSCDiouZ29vZ2xlLml0LmFv
+ggsqLmdvb2dsZS5qZYILKi5nb29nbGUuam+CDSouZ29vZ2xlLmpvYnOCCyouZ29v
+Z2xlLmpwggsqLmdvb2dsZS5rZ4ILKi5nb29nbGUua2mCCyouZ29vZ2xlLmt6ggsq
+Lmdvb2dsZS5sYYILKi5nb29nbGUubGmCCyouZ29vZ2xlLmxrggsqLmdvb2dsZS5s
+dIILKi5nb29nbGUubHWCCyouZ29vZ2xlLmx2ggsqLmdvb2dsZS5tZIILKi5nb29n
+bGUubWWCCyouZ29vZ2xlLm1nggsqLmdvb2dsZS5ta4ILKi5nb29nbGUubWyCCyou
+Z29vZ2xlLm1uggsqLmdvb2dsZS5tc4ILKi5nb29nbGUubXWCCyouZ29vZ2xlLm12
+ggsqLmdvb2dsZS5td4ILKi5nb29nbGUubmWCDiouZ29vZ2xlLm5lLmpwggwqLmdv
+b2dsZS5uZXSCCyouZ29vZ2xlLm5sggsqLmdvb2dsZS5ub4ILKi5nb29nbGUubnKC
+CyouZ29vZ2xlLm51gg8qLmdvb2dsZS5vZmYuYWmCCyouZ29vZ2xlLnBrggsqLmdv
+b2dsZS5wbIILKi5nb29nbGUucG6CCyouZ29vZ2xlLnBzggsqLmdvb2dsZS5wdIIL
+Ki5nb29nbGUucm+CCyouZ29vZ2xlLnJzggsqLmdvb2dsZS5ydYILKi5nb29nbGUu
+cneCCyouZ29vZ2xlLnNjggsqLmdvb2dsZS5zZYILKi5nb29nbGUuc2iCCyouZ29v
+Z2xlLnNpggsqLmdvb2dsZS5za4ILKi5nb29nbGUuc22CCyouZ29vZ2xlLnNuggsq
+Lmdvb2dsZS5zb4ILKi5nb29nbGUuc3SCCyouZ29vZ2xlLnRkggsqLmdvb2dsZS50
+Z4ILKi5nb29nbGUudGuCCyouZ29vZ2xlLnRsggsqLmdvb2dsZS50bYILKi5nb29n
+bGUudG6CCyouZ29vZ2xlLnRvggsqLmdvb2dsZS50cIILKi5nb29nbGUudHSCCyou
+Z29vZ2xlLnVzggsqLmdvb2dsZS51eoILKi5nb29nbGUudmeCCyouZ29vZ2xlLnZ1
+ggsqLmdvb2dsZS53c4IJZ29vZ2xlLmFjgglnb29nbGUuYWSCCWdvb2dsZS5hZYIJ
+Z29vZ2xlLmFmgglnb29nbGUuYWeCCWdvb2dsZS5hbIIJZ29vZ2xlLmFtgglnb29n
+bGUuYXOCCWdvb2dsZS5hdIIJZ29vZ2xlLmF6gglnb29nbGUuYmGCCWdvb2dsZS5i
+ZYIJZ29vZ2xlLmJmgglnb29nbGUuYmeCCWdvb2dsZS5iaYIJZ29vZ2xlLmJqggln
+b29nbGUuYnOCCWdvb2dsZS5ieYIJZ29vZ2xlLmNhggpnb29nbGUuY2F0gglnb29n
+bGUuY2OCCWdvb2dsZS5jZIIJZ29vZ2xlLmNmgglnb29nbGUuY2eCCWdvb2dsZS5j
+aIIJZ29vZ2xlLmNpgglnb29nbGUuY2yCCWdvb2dsZS5jbYIJZ29vZ2xlLmNuggxn
+b29nbGUuY28uYW+CDGdvb2dsZS5jby5id4IMZ29vZ2xlLmNvLmNrggxnb29nbGUu
+Y28uY3KCDGdvb2dsZS5jby5odYIMZ29vZ2xlLmNvLmlkggxnb29nbGUuY28uaWyC
+DGdvb2dsZS5jby5pbYIMZ29vZ2xlLmNvLmluggxnb29nbGUuY28uamWCDGdvb2ds
+ZS5jby5qcIIMZ29vZ2xlLmNvLmtlggxnb29nbGUuY28ua3KCDGdvb2dsZS5jby5s
+c4IMZ29vZ2xlLmNvLm1hggxnb29nbGUuY28ubXqCDGdvb2dsZS5jby5ueoIMZ29v
+Z2xlLmNvLnRoggxnb29nbGUuY28udHqCDGdvb2dsZS5jby51Z4IMZ29vZ2xlLmNv
+LnVrggxnb29nbGUuY28udXqCDGdvb2dsZS5jby52ZYIMZ29vZ2xlLmNvLnZpggxn
+b29nbGUuY28uemGCDGdvb2dsZS5jby56bYIMZ29vZ2xlLmNvLnp3gg1nb29nbGUu
+Y29tLmFmgg1nb29nbGUuY29tLmFngg1nb29nbGUuY29tLmFpgg1nb29nbGUuY29t
+LmFygg1nb29nbGUuY29tLmF1gg1nb29nbGUuY29tLmJkgg1nb29nbGUuY29tLmJo
+gg1nb29nbGUuY29tLmJugg1nb29nbGUuY29tLmJvgg1nb29nbGUuY29tLmJygg1n
+b29nbGUuY29tLmJ5gg1nb29nbGUuY29tLmJ6gg1nb29nbGUuY29tLmNugg1nb29n
+bGUuY29tLmNvgg1nb29nbGUuY29tLmN1gg1nb29nbGUuY29tLmN5gg1nb29nbGUu
+Y29tLmRvgg1nb29nbGUuY29tLmVjgg1nb29nbGUuY29tLmVngg1nb29nbGUuY29t
+LmV0gg1nb29nbGUuY29tLmZqgg1nb29nbGUuY29tLmdlgg1nb29nbGUuY29tLmdo
+gg1nb29nbGUuY29tLmdpgg1nb29nbGUuY29tLmdygg1nb29nbGUuY29tLmd0gg1n
+b29nbGUuY29tLmhrgg1nb29nbGUuY29tLmlxgg1nb29nbGUuY29tLmptgg1nb29n
+bGUuY29tLmpvgg1nb29nbGUuY29tLmtogg1nb29nbGUuY29tLmt3gg1nb29nbGUu
+Y29tLmxigg1nb29nbGUuY29tLmx5gg1nb29nbGUuY29tLm10gg1nb29nbGUuY29t
+Lm14gg1nb29nbGUuY29tLm15gg1nb29nbGUuY29tLm5hgg1nb29nbGUuY29tLm5m
+gg1nb29nbGUuY29tLm5ngg1nb29nbGUuY29tLm5pgg1nb29nbGUuY29tLm5wgg1n
+b29nbGUuY29tLm5ygg1nb29nbGUuY29tLm9tgg1nb29nbGUuY29tLnBhgg1nb29n
+bGUuY29tLnBlgg1nb29nbGUuY29tLnBogg1nb29nbGUuY29tLnBrgg1nb29nbGUu
+Y29tLnBsgg1nb29nbGUuY29tLnBygg1nb29nbGUuY29tLnB5gg1nb29nbGUuY29t
+LnFhgg1nb29nbGUuY29tLnJ1gg1nb29nbGUuY29tLnNhgg1nb29nbGUuY29tLnNi
+gg1nb29nbGUuY29tLnNngg1nb29nbGUuY29tLnNsgg1nb29nbGUuY29tLnN2gg1n
+b29nbGUuY29tLnRqgg1nb29nbGUuY29tLnRugg1nb29nbGUuY29tLnRygg1nb29n
+bGUuY29tLnR3gg1nb29nbGUuY29tLnVhgg1nb29nbGUuY29tLnV5gg1nb29nbGUu
+Y29tLnZjgg1nb29nbGUuY29tLnZlgg1nb29nbGUuY29tLnZugglnb29nbGUuY3aC
+CWdvb2dsZS5jeoIJZ29vZ2xlLmRlgglnb29nbGUuZGqCCWdvb2dsZS5ka4IJZ29v
+Z2xlLmRtgglnb29nbGUuZHqCCWdvb2dsZS5lZYIJZ29vZ2xlLmVzgglnb29nbGUu
+ZmmCCWdvb2dsZS5mbYIJZ29vZ2xlLmZygglnb29nbGUuZ2GCCWdvb2dsZS5nZYIJ
+Z29vZ2xlLmdngglnb29nbGUuZ2yCCWdvb2dsZS5nbYIJZ29vZ2xlLmdwgglnb29n
+bGUuZ3KCCWdvb2dsZS5neYIJZ29vZ2xlLmhrgglnb29nbGUuaG6CCWdvb2dsZS5o
+coIJZ29vZ2xlLmh0gglnb29nbGUuaHWCCWdvb2dsZS5pZYIJZ29vZ2xlLmltggtn
+b29nbGUuaW5mb4IJZ29vZ2xlLmlxgglnb29nbGUuaXOCCWdvb2dsZS5pdIIMZ29v
+Z2xlLml0LmFvgglnb29nbGUuamWCCWdvb2dsZS5qb4ILZ29vZ2xlLmpvYnOCCWdv
+b2dsZS5qcIIJZ29vZ2xlLmtngglnb29nbGUua2mCCWdvb2dsZS5reoIJZ29vZ2xl
+Lmxhgglnb29nbGUubGmCCWdvb2dsZS5sa4IJZ29vZ2xlLmx0gglnb29nbGUubHWC
+CWdvb2dsZS5sdoIJZ29vZ2xlLm1kgglnb29nbGUubWWCCWdvb2dsZS5tZ4IJZ29v
+Z2xlLm1rgglnb29nbGUubWyCCWdvb2dsZS5tboIJZ29vZ2xlLm1zgglnb29nbGUu
+bXWCCWdvb2dsZS5tdoIJZ29vZ2xlLm13gglnb29nbGUubmWCDGdvb2dsZS5uZS5q
+cIIKZ29vZ2xlLm5ldIIJZ29vZ2xlLm5sgglnb29nbGUubm+CCWdvb2dsZS5ucoIJ
+Z29vZ2xlLm51gg1nb29nbGUub2ZmLmFpgglnb29nbGUucGuCCWdvb2dsZS5wbIIJ
+Z29vZ2xlLnBugglnb29nbGUucHOCCWdvb2dsZS5wdIIJZ29vZ2xlLnJvgglnb29n
+bGUucnOCCWdvb2dsZS5ydYIJZ29vZ2xlLnJ3gglnb29nbGUuc2OCCWdvb2dsZS5z
+ZYIJZ29vZ2xlLnNogglnb29nbGUuc2mCCWdvb2dsZS5za4IJZ29vZ2xlLnNtggln
+b29nbGUuc26CCWdvb2dsZS5zb4IJZ29vZ2xlLnN0gglnb29nbGUudGSCCWdvb2ds
+ZS50Z4IJZ29vZ2xlLnRrgglnb29nbGUudGyCCWdvb2dsZS50bYIJZ29vZ2xlLnRu
+gglnb29nbGUudG+CCWdvb2dsZS50cIIJZ29vZ2xlLnR0gglnb29nbGUudXOCCWdv
+b2dsZS51eoIJZ29vZ2xlLnZngglnb29nbGUudnWCCWdvb2dsZS53czANBgkqhkiG
+9w0BAQUFAAOBgQCROJdKT00d96BpNG4j3Xf5Kz7kJENMTYtgsGQW5E6y2yjRaguD
+LPO+y4IH9KiVXD+qO8koye9yOMNawN9r/DFQd+t2nDmvlpcwJBNguiuqxl+rJaU8
+KKgswikGaaM4z+i4vHuXcCKZtM/ELAaJlSaBPip4GBAkgv7D9hwh+sWvYA==
+-----END CERTIFICATE-----
diff --git a/test/assets/jim-openssh.pub b/test/assets/jim-openssh.pub
new file mode 100644
index 0000000..0038023
--- /dev/null
+++ b/test/assets/jim-openssh.pub
@@ -0,0 +1 @@
+ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgjP3tdayWI31bxhQEtB/QwEdVPw0a4T8OKM1/ZNVpptMAAAADAQABAAAAgQDVml3YDVqimFyVgK8rgEEitA++Gq67rXqvKV40V5GlT7OGQL+i0zrX8ikLR8IpCvVcs37F78KohF9wDj854nkcUCbNh0Jihor3I5aYlpvEFlO4S8njVw9KOrY+L9/0ALRAK6UO96gTwROW5o/8gtyDxUJxEF2DiWzegumQJW1SNwAAAAAAAAAAAAAAAgAAAAZqaW1rZXkAAAALAAAAB2ppbS5jb20AAAAAV5Fv1AAAAABZcVI2AAAAAAAAAAAAAAAAAAAAlwAAAAdzc2gtcnNhAAAAAwEAAQAAAIEA1Zpd2A1aophclYCvK4BBIrQPvhquu616ryleNFeRpU+zhkC/otM61/IpC0fCKQr1XLN+xe/CqIRfcA4/OeJ5HFAmzYdCYoaK9yOWmJabxBZTuEvJ41cPSjq2Pi/f9AC0QCulDveoE8ETluaP/ILcg8VCcRBdg4ls3oLpkCVtUjcAAACPAAAAB3NzaC1yc2EAAACAASHTzs/SOITFA9bhATC751bYIaJbg0u7xbP+RaFfczDMbnYTB2fD3ddjjJy/HlEdZ0Jb4y1och2n7FEPzxY/vmZNh7dFDc7Ii8NMcDEdkk5Vg7wXijJFtQtPlyaWdNpaJSqD+mV0/WuAgcQo/5o6oyz5l132JWuqM162aU/28vg= id_rsa
diff --git a/test/assets/jim-x509.pem b/test/assets/jim-x509.pem
new file mode 100644
index 0000000..194d1e0
--- /dev/null
+++ b/test/assets/jim-x509.pem
@@ -0,0 +1,12 @@
+-----BEGIN CERTIFICATE-----
+MIIByzCCATQCCQCr/VI8PlLAezANBgkqhkiG9w0BAQUFADAqMRMwEQYKCZImiZPy
+LGQBGRYDamltMRMwEQYKCZImiZPyLGQBGRYDY29tMB4XDTE2MDcyMjAxMDQyNloX
+DTE3MDcyMjAxMDQyNlowKjETMBEGCgmSJomT8ixkARkWA2ppbTETMBEGCgmSJomT
+8ixkARkWA2NvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1Zpd2A1aophc
+lYCvK4BBIrQPvhquu616ryleNFeRpU+zhkC/otM61/IpC0fCKQr1XLN+xe/CqIRf
+cA4/OeJ5HFAmzYdCYoaK9yOWmJabxBZTuEvJ41cPSjq2Pi/f9AC0QCulDveoE8ET
+luaP/ILcg8VCcRBdg4ls3oLpkCVtUjcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAQ
+U0ekppGXa0IGfo8l4UZWrqBOhDjbrOh2LcSBU0oiHB/pWHAliDy8hqXQA3rr17ir
+cm458oUFupEHvB26yQiO1uNLQcIuXTiGoUA2xcepgjYbZahn1WbYTJuKFtcNxkOV
+sq+Dmj34yvc1Ror4lcqlg5foPE8aH2ONroG2PwM7eQ==
+-----END CERTIFICATE-----
diff --git a/test/assets/joyent.pem b/test/assets/joyent.pem
new file mode 100644
index 0000000..67ffd87
--- /dev/null
+++ b/test/assets/joyent.pem
@@ -0,0 +1,31 @@
+-----BEGIN CERTIFICATE-----
+MIIFaDCCBFCgAwIBAgIQRqqqzQI4MxX9tbSSUtQ+HzANBgkqhkiG9w0BAQsFADBC
+MQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UEAxMS
+UmFwaWRTU0wgU0hBMjU2IENBMB4XDTE2MDUyNDAwMDAwMFoXDTE3MDUyNDIzNTk1
+OVowFzEVMBMGA1UEAwwMKi5qb3llbnQuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOC
+AQ8AMIIBCgKCAQEAua6H3bcQqOzUyE5NSzqkzbT2O2/hzmouEs5tUqXaWsENlsIk
+e+hRQ3CrPxqBf/txb4/EIPkUmi0B/RNxfhKTCZ8YRXjf7AUaD+H+aknuFmFWOU32
+lsPAYw/EP8vCYFEI7DfzY7Rg1ULcLSFolUTVRIOua218kZ+rv1vlcSkLJlP4qQQ9
+Q5XXqu0C26pJQCfV8hhFnHUAx33nZd9Sbgy9DmXM9PStY4x4j1RZoyQvzo25HqGI
+ykAtXew7f9i3Bz/ihybWBogGSZURV+vpJ2FMLnqJjOEaEe4q+GmZggcJvyHcNIlb
+0AVbvHDDHYScMR+QYU6v3K0hm5W2qbmNnsc5RQIDAQABo4ICgzCCAn8wIwYDVR0R
+BBwwGoIMKi5qb3llbnQuY29tggpqb3llbnQuY29tMAkGA1UdEwQCMAAwKwYDVR0f
+BCQwIjAgoB6gHIYaaHR0cDovL2dwLnN5bWNiLmNvbS9ncC5jcmwwbwYDVR0gBGgw
+ZjBkBgZngQwBAgEwWjAqBggrBgEFBQcCARYeaHR0cHM6Ly93d3cucmFwaWRzc2wu
+Y29tL2xlZ2FsMCwGCCsGAQUFBwICMCAMHmh0dHBzOi8vd3d3LnJhcGlkc3NsLmNv
+bS9sZWdhbDAfBgNVHSMEGDAWgBSXwidQnsLJ7AyIMsh8reKmAU/abzAOBgNVHQ8B
+Af8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMFcGCCsGAQUF
+BwEBBEswSTAfBggrBgEFBQcwAYYTaHR0cDovL2dwLnN5bWNkLmNvbTAmBggrBgEF
+BQcwAoYaaHR0cDovL2dwLnN5bWNiLmNvbS9ncC5jcnQwggEEBgorBgEEAdZ5AgQC
+BIH1BIHyAPAAdgDd6x0reg1PpiCLga2BaHB+Lo6dAdVciI09EcTNtuy+zAAAAVTk
+zlluAAAEAwBHMEUCIAouSdhGoMRAWdprnvqryiiZUv8FEmiv2EFOAqaC7/fFAiEA
+zx7aZjtiOC5kELoSDfbHjcDAayq+OfgF49mBnULmH4wAdgCkuQmQtBhYFIe7E6LM
+Z3AKPDWYBPkb37jjd80OyA3cEAAAAVTkzlmnAAAEAwBHMEUCIQCMV3cI6DqlWyjy
+6i0IuQAjCqzo1hKm3JBTI1dylJlBtwIgF9UHLufpaQ2U0qF0J/N+zRdVU4hTTyv4
+vaxH+UcVuXAwDQYJKoZIhvcNAQELBQADggEBAICbZrdFZlyxmfNkAhehgRv3sSwD
+1oBJ2sP5pSGhWOSsgb+PC7Tk36UDdGV/sv7HJwf9ssW06LlCWtcZIu7Wft1DTId7
+xjH2yXogYSC3ClLfFOMdIYD0cvjBmKAwajwEfLIG8PWY9PqDNBZNj8hnvGEA+qpR
+mLXDQAL5MeWI0bZDANACA5iSImJwoDIa3u36RW3kTu5eoQPtg0vfLIzx++BdCH8x
+JWT3OB0996mQ3qAK8E4yYdYMalxme18cKCWl3agcqS9fUzF76bYA8GaLn1FJIfF0
+QR3uD41rTugtDn9eMaQbeeQmdrkWCZo7EWVbODGFM3sMDuBDYAw5v64+pGU=
+-----END CERTIFICATE-----
diff --git a/test/assets/letsencrypt.pem b/test/assets/letsencrypt.pem
new file mode 100644
index 0000000..e8e8337
--- /dev/null
+++ b/test/assets/letsencrypt.pem
@@ -0,0 +1,29 @@
+-----BEGIN CERTIFICATE-----
+MIIE/DCCA+SgAwIBAgISAy33AhOr1xxbWtSsIBBKe5gJMA0GCSqGSIb3DQEBCwUA
+MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD
+ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjA3MjEyMzM4MDBaFw0x
+NjEwMTkyMzM4MDBaMBcxFTATBgNVBAMTDGNyLmpveWVudC51czCCASIwDQYJKoZI
+hvcNAQEBBQADggEPADCCAQoCggEBALFOmt+wPZpIozmBEeWutW256t0HgNJwjIRY
+HnnJ4jCOlJgNfKd4c2Dxwp9Avz5MXUiJkaMzN2P2sjmbt/Iqy1TwwMgC975MTmez
+I1hJwRR6YsXy9YOAwXP539AejZv8vhIBNkClW0bJ/ZlIFSvkfC/X/JhneIrdsIOE
+yZcyEMIBk9QvFwkWKHq43N+7c/siZHiQ6hWnlUzqh1xQejRvlhzTrT2Vf1U+/dkG
+0RKcy4cyqXy/Uz+emvCyv75lM0vrTJmmR9jH4M59HciVrZ6OYI3kWPalp0ju1kb3
+T8vNnMx8yg1TpKRSxigxJqnLOGUjVWNp+w5J62FbwLhG19iu+ksCAwEAAaOCAg0w
+ggIJMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUH
+AwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQU8ljh5m3JDMkAjo5WBuqgwwROLuww
+HwYDVR0jBBgwFoAUqEpqYwR93brm0Tm3pkVl7/Oo7KEwcAYIKwYBBQUHAQEEZDBi
+MC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5pbnQteDMubGV0c2VuY3J5cHQub3Jn
+LzAvBggrBgEFBQcwAoYjaHR0cDovL2NlcnQuaW50LXgzLmxldHNlbmNyeXB0Lm9y
+Zy8wFwYDVR0RBBAwDoIMY3Iuam95ZW50LnVzMIH+BgNVHSAEgfYwgfMwCAYGZ4EM
+AQIBMIHmBgsrBgEEAYLfEwEBATCB1jAmBggrBgEFBQcCARYaaHR0cDovL2Nwcy5s
+ZXRzZW5jcnlwdC5vcmcwgasGCCsGAQUFBwICMIGeDIGbVGhpcyBDZXJ0aWZpY2F0
+ZSBtYXkgb25seSBiZSByZWxpZWQgdXBvbiBieSBSZWx5aW5nIFBhcnRpZXMgYW5k
+IG9ubHkgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBDZXJ0aWZpY2F0ZSBQb2xpY3kg
+Zm91bmQgYXQgaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvcmVwb3NpdG9yeS8wDQYJ
+KoZIhvcNAQELBQADggEBAFtUWwfPA2107luHzpwdh/Hqr9KofaEYpOwe3+6kqpJB
+fUcvxty1qE1efTLy8s6GPyzU0gqlnhEDpB6jXyimVfGJn0mwZWdIHLoKZTcOlHMm
+QE0yBCXGxvBgIpRPG/GMHeyzJsWHynmFopmKiKyG51Y776oVudrIxnmxQBjUvUZO
+HKuqeASJI8yKtVQCTnQsjEwVABpTNrB3u06hoouSQ7PdsbBRkV2hnkK80C4k6bbo
+Fdg0bwhqzWmEzO3575YX7We7frE/lN1knVVRZuvWig/J+j3+HJooo/wq/s2bkylY
+mh8jOyfWA95w2Yn+aA4jfBNm+tcqe8nFs/2GkbQ6KoY=
+-----END CERTIFICATE-----
diff --git a/test/assets/napoleon-cert.pem b/test/assets/napoleon-cert.pem
new file mode 100644
index 0000000..2ce991e
--- /dev/null
+++ b/test/assets/napoleon-cert.pem
@@ -0,0 +1,21 @@
+-----BEGIN CERTIFICATE-----
+MIIDdDCCAt2gAwIBAgIBADANBgkqhkiG9w0BAQUFADCBmzELMAkGA1UEBhMCSlAx
+DjAMBgNVBAgTBVRva3lvMRAwDgYDVQQHEwdDaHVvLWt1MREwDwYDVQQKEwhGcmFu
+azRERDEYMBYGA1UECxMPV2ViQ2VydCBTdXBwb3J0MRgwFgYDVQQDEw9GcmFuazRE
+RCBXZWIgQ0ExIzAhBgkqhkiG9w0BCQEWFHN1cHBvcnRAZnJhbms0ZGQuY29tMCIY
+DzE3NjkwODE1MTU0NjQxWhgPMTgyMTA1MDUxNjUzMjFaMIHbMQswCQYDVQQGEwJG
+UjEXMBUGA1UECBQOw45sZS1kZS1GcmFuY2UxDjAMBgNVBAcTBVBhcmlzMRwwGgYD
+VQQKExNIZXJlZGl0YXJ5IE1vbmFyY2h5MRYwFAYDVQQLEw1IZWFkIG9mIFN0YXRl
+MSkwJwYJKoZIhvcNAQkBFhpuYXBwaUBncmVhdGZyZW5jaGVtcGlyZS5mcjEbMBkG
+A1UEAxMSRW1wZXJvciBOYXBvbGVvbiBJMRIwEAYDVQQEEwlCb25hcGFydGUxETAP
+BgNVBCoTCE5hcG9sZW9uMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
+vdcwMpsM3EgNmeO/fvcuZsirnBZCh0yJlySGmev792ohOBvfC+v27ZKcXN+H7V+x
+SxEDDAFq9SCEk4MZ8h/ggtw63T6SEYeNGtnfyLv8atienun/6ocDp0+26xvj8Nxm
+aKL4MQM9j9aYgt2EOxUTH5kBc7mc621q2RJi0q/y0/SdX2Pp/3MKDirOs81vfc2i
+cEaYAisd5IOF9vpMpLr3b3Qg9T66/4hQS6DgIOkfUurWqe33sA2RRv7ql1gcxL1I
+mBxBtYQGsujn8fCNRK5jtMtICkEi9tks/tYzSaqgby3QGfbA18xl7FLLjnZDLVX3
+ZVchhveR78/f7U/xh8C2WQIDAQABMA0GCSqGSIb3DQEBBQUAA4GBAFmEiU2vn10f
+XvL+nJdRHJsf0P+f6v8H+vbkomog4gVbagDuFACJfAdKJhnc/gzkCF1fyeowOD68
+k4e0H1vyLuk23BUmjW41nOjdg8LrTAS8fMwkj5FVSKR2mHciHWgY/BU4UypYJtcg
+ajH1bsqwUI50wfbggW4VzLD842q5LhnW
+-----END CERTIFICATE-----
diff --git a/test/certs.js b/test/certs.js
new file mode 100644
index 0000000..16bca48
--- /dev/null
+++ b/test/certs.js
@@ -0,0 +1,296 @@
+// Copyright 2016 Joyent, Inc.  All rights reserved.
+
+var test = require('tape').test;
+
+var sshpk = require('../lib/index');
+var fs = require('fs');
+var path = require('path');
+var crypto = require('crypto');
+var sinon = require('sinon');
+
+var testDir = path.join(__dirname, 'assets');
+
+var GEORGE_KEY, GEORGE_SSH, GEORGE_X509;
+var BARRY_KEY;
+var JIM_KEY, JIM_SSH, JIM_X509;
+var EC_KEY, EC_KEY2;
+
+test('setup', function (t) {
+	var d = fs.readFileSync(path.join(testDir, 'id_dsa'));
+	GEORGE_KEY = sshpk.parseKey(d);
+	GEORGE_SSH = fs.readFileSync(path.join(testDir, 'george-openssh.pub'));
+	GEORGE_X509 = fs.readFileSync(path.join(testDir, 'george-x509.pem'));
+
+	d = fs.readFileSync(path.join(testDir, 'id_dsa2'));
+	BARRY_KEY = sshpk.parsePrivateKey(d);
+
+	d = fs.readFileSync(path.join(testDir, 'id_rsa'));
+	JIM_KEY = sshpk.parsePrivateKey(d);
+
+	JIM_SSH = fs.readFileSync(path.join(testDir, 'jim-openssh.pub'));
+	JIM_X509 = fs.readFileSync(path.join(testDir, 'jim-x509.pem'));
+
+	d = fs.readFileSync(path.join(testDir, 'id_ecdsa'));
+	EC_KEY = sshpk.parsePrivateKey(d);
+	d = fs.readFileSync(path.join(testDir, 'id_ecdsa2'));
+	EC2_KEY = sshpk.parsePrivateKey(d);
+	t.end();
+});
+
+test('dsa openssh cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(GEORGE_SSH, 'openssh');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(GEORGE_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedByKey(GEORGE_KEY));
+	t.ok(!cert.isSignedByKey(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-22T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'UID=george');
+	t.strictEqual(cert.subjects[0].type, 'user');
+	t.strictEqual(cert.subjects[0].uid, 'george');
+
+	t.throws(function () {
+		cert.fingerprint();
+	});
+	t.end();
+});
+
+test('dsa x509 cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(GEORGE_X509, 'pem');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(GEORGE_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedByKey(GEORGE_KEY));
+	t.ok(!cert.isSignedByKey(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-22T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'UID=george');
+	t.strictEqual(cert.subjects[0].type, 'user');
+	t.strictEqual(cert.subjects[0].uid, 'george');
+
+	var fp = sshpk.parseFingerprint(
+	    'SHA256:rPrIM16iuYN1UkWprtIkRaUzerKz0JkNd/FjKG7OJCU',
+	    { type: 'certificate '});
+	t.ok(fp.matches(cert));
+	t.end();
+});
+
+test('rsa openssh cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(JIM_SSH, 'openssh');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(JIM_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedByKey(JIM_KEY));
+	t.ok(!cert.isSignedByKey(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-23T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'CN=jim.com');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'jim.com');
+
+	t.ok(cert.issuer.equals(cert.subjects[0]));
+
+	t.end();
+});
+
+test('rsa x509 cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(JIM_X509, 'pem');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(JIM_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedByKey(JIM_KEY));
+	t.ok(!cert.isSignedByKey(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-23T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'DC=jim, DC=com');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'jim.com');
+
+	t.ok(cert.issuer.equals(cert.subjects[0]));
+	t.ok(cert.isSignedBy(cert));
+
+	t.end();
+});
+
+test('create rsa self-signed, loopback', function (t) {
+	var id = sshpk.identityForHost('foobar.com');
+	var cert = sshpk.createSelfSignedCertificate(id, JIM_KEY);
+
+	var x509 = cert.toBuffer('pem');
+	var cert2 = sshpk.parseCertificate(x509, 'pem');
+	t.ok(JIM_KEY.fingerprint().matches(cert2.subjectKey));
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(JIM_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+	t.strictEqual(cert3.subjects[0].hostname, 'foobar.com');
+
+	t.end();
+});
+
+test('create ecdsa signed, loopback', function (t) {
+	var id = sshpk.identityForUser('jim');
+	var ca = sshpk.identityForHost('foobar.com');
+	var cacert = sshpk.createSelfSignedCertificate(ca, EC2_KEY);
+	var cert = sshpk.createCertificate(id, EC_KEY, ca, EC2_KEY);
+
+	var x509 = cert.toBuffer('pem');
+	var cert2 = sshpk.parseCertificate(x509, 'pem');
+	t.ok(EC_KEY.fingerprint().matches(cert2.subjectKey));
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+	t.ok(cert2.isSignedBy(cacert));
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(EC_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+	t.strictEqual(cert3.subjects[0].uid, 'jim');
+	t.ok(cert3.isSignedBy(cacert));
+
+	t.end();
+});
+
+test('subjectaltname', function (t) {
+	var ids = [
+		sshpk.identityForHost('foobar.com'),
+		sshpk.identityForHost('www.foobar.com'),
+		sshpk.identityForHost('mail.foobar.com')
+	];
+	var cert = sshpk.createSelfSignedCertificate(ids, JIM_KEY);
+
+	var x509 = cert.toBuffer('pem');
+	var cert2 = sshpk.parseCertificate(x509, 'pem');
+	t.ok(JIM_KEY.fingerprint().matches(cert2.subjectKey));
+	t.strictEqual(cert2.subjects.length, 3);
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+	t.ok(cert2.subjects[1].equals(cert.subjects[1]));
+	t.strictEqual(cert2.subjects[0].hostname, 'foobar.com');
+	t.strictEqual(cert2.subjects[1].hostname, 'www.foobar.com');
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(JIM_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+	t.strictEqual(cert3.subjects.length, 3);
+	t.strictEqual(cert3.subjects[0].hostname, 'foobar.com');
+	t.strictEqual(cert3.subjects[1].hostname, 'www.foobar.com');
+
+	t.end();
+});
+
+test('napoleon cert (generalizedtime) (x509)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'napoleon-cert.pem')), 'pem');
+	t.strictEqual(cert.subjectKey.type, 'rsa');
+	t.ok(cert.isExpired(new Date('1901-01-01T00:00Z')));
+	console.log(cert.validFrom.getTime());
+	console.log(cert.validUntil.getTime());
+	t.ok(!cert.isExpired(new Date('1775-03-01T00:00Z')));
+	t.end();
+});
+
+test('example cert: digicert (x509)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'digicert.pem')), 'pem');
+	t.strictEqual(cert.subjectKey.type, 'rsa');
+	t.strictEqual(cert.subjects.length, 8);
+	t.strictEqual(cert.subjects[0].hostname, 'www.digicert.com');
+	t.strictEqual(cert.issuer.cn,
+	    'DigiCert SHA2 Extended Validation Server CA');
+
+	var cacert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'digicert-ca.crt')), 'x509');
+	t.ok(cert.isSignedBy(cacert));
+	t.end();
+});
+
+test('example cert: joyent (x509)', function (t) {
+	var data = fs.readFileSync(path.join(testDir, 'joyent.pem'));
+	var cert = sshpk.parseCertificate(data, 'pem');
+	t.strictEqual(cert.subjectKey.type, 'rsa');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, '*.joyent.com');
+
+	var fp = sshpk.parseFingerprint(
+	    'SHA1:6UMWRUe9vr93cg8AGS7Nwl1XOAA',
+	    { type: 'certificate' });
+	t.ok(fp.matches(cert));
+	t.end();
+});
+
+test('example cert: cloudflare (x509)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'cloudflare.pem')), 'pem');
+	t.strictEqual(cert.subjectKey.type, 'ecdsa');
+	var id = sshpk.identityForHost('mail.imeyou.io');
+	t.ok(cert.subjects.some(function (subj) {
+		return (subj.equals(id));
+	}));
+	var fp = cert.fingerprint('sha1').toString('hex');
+	t.strictEqual(fp.toUpperCase(),
+	    'B7:11:BA:8E:83:43:E0:4D:A2:DC:6F:F7:87:2B:5D:78:2C:B1:31:2A');
+
+	var cacert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'comodo.crt')), 'x509');
+	t.ok(cert.isSignedBy(cacert));
+	t.end();
+});
+
+test('example cert: letsencrypt (x509)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'letsencrypt.pem')), 'pem');
+	t.strictEqual(cert.subjectKey.type, 'rsa');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'cr.joyent.us');
+	var fp = cert.fingerprint('sha1').toString('hex');
+	t.strictEqual(fp.toUpperCase(),
+	    '59:8B:FA:BF:F7:DD:D4:B5:7E:8F:53:61:B1:65:0D:DF:F5:4B:CC:72');
+	t.end();
+});
+
+test('example cert: DSA example (x509 DER)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, '1024b-dsa-example-cert.der')),
+	    'x509');
+	t.strictEqual(cert.subjectKey.type, 'dsa');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'www.example.com');
+
+	var cacert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'frank4dd-cacert.der')), 'x509');
+	t.ok(cert.isSignedBy(cacert));
+	t.end();
+});
+
+test('example cert: lots of SAN (x509)', function (t) {
+	var cert = sshpk.parseCertificate(
+	    fs.readFileSync(path.join(testDir, 'google_jp_458san.pem')),
+	    'pem');
+	t.strictEqual(cert.subjectKey.type, 'rsa');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'google.com');
+	var id = sshpk.identityForHost('google.co.jp');
+	t.ok(cert.subjects.some(function (subj) {
+		return (subj.equals(id));
+	}));
+	t.end();
+});
diff --git a/test/identity.js b/test/identity.js
new file mode 100644
index 0000000..995e72c
--- /dev/null
+++ b/test/identity.js
@@ -0,0 +1,16 @@
+// Copyright 2016 Joyent, Inc.  All rights reserved.
+
+var test = require('tape').test;
+
+var sshpk = require('../lib/index');
+var fs = require('fs');
+var path = require('path');
+var crypto = require('crypto');
+var sinon = require('sinon');
+
+test('parsedn', function (t) {
+	var id = sshpk.Identity.parseDN('cn=Blah Corp, s=CA, c=US');
+	t.strictEqual(id.type, 'user');
+	t.strictEqual(id.cn, 'Blah Corp');
+	t.end();
+});
diff --git a/test/openssl-cmd.js b/test/openssl-cmd.js
index f3f3a36..7af3750 100644
--- a/test/openssl-cmd.js
+++ b/test/openssl-cmd.js
@@ -202,6 +202,66 @@ function genTests() {
 		kid.stdin.write(data);
 		kid.stdin.end();
 	});
+
+	test('make a self-signed cert, parse with openssh', function (t) {
+		var pem = fs.readFileSync(path.join(testDir, 'id_' + algo));
+		var key = sshpk.parsePrivateKey(pem, 'pkcs1');
+
+		var ids = [
+			sshpk.identityFromDN('cn=' + algo + ', c=US'),
+			sshpk.identityFromDN('cn=' + algo + '.test, c=AU')
+		];
+		var cert = sshpk.createSelfSignedCertificate(ids, key);
+		var certPem = cert.toBuffer('pem');
+
+		var kid = spawn('openssl', ['x509', '-text']);
+		var bufs = [];
+		kid.stdout.on('data', bufs.push.bind(bufs));
+		kid.on('close', function (rc) {
+			t.equal(rc, 0);
+			var output = Buffer.concat(bufs).toString();
+
+			var m = output.match(/Issuer: (.*)$/m);
+			t.strictEqual(m[1], 'CN=' + algo + ', C=US');
+
+			m = output.match(/Subject: (.*)$/m);
+			t.strictEqual(m[1], 'CN=' + algo + ', C=US');
+
+			var re = /DNS:([^, \n]+)([, ]+|$)/gm;
+			m = re.exec(output);
+			t.strictEqual(m[1], algo);
+
+			m = re.exec(output);
+			t.strictEqual(m[1], algo + '.test');
+			t.end();
+		});
+		kid.stdin.write(certPem);
+		kid.stdin.end();
+	});
+
+	test('make a self-signed cert, verify with openssh', function (t) {
+		var pem = fs.readFileSync(path.join(testDir, 'id_' + algo));
+		var key = sshpk.parsePrivateKey(pem, 'pkcs1');
+
+		var id = sshpk.identityFromDN('cn=' + algo);
+		var cert = sshpk.createSelfSignedCertificate(id, key);
+		var certPem = cert.toBuffer('pem');
+
+		fs.writeFileSync(path.join(tmp, 'ca.pem'), certPem);
+
+		var kid = spawn('openssl', ['verify',
+		    '-CAfile', path.join(tmp, 'ca.pem')]);
+		var bufs = [];
+		kid.stdout.on('data', bufs.push.bind(bufs));
+		kid.on('close', function (rc) {
+			t.equal(rc, 0);
+			var output = Buffer.concat(bufs).toString();
+			t.strictEqual(output.trim(), 'stdin: OK');
+			t.end();
+		});
+		kid.stdin.write(certPem);
+		kid.stdin.end();
+	});
 });
 
 test('teardown', function (t) {
diff --git a/test/signature.js b/test/signature.js
index eff2d60..47a77ee 100644
--- a/test/signature.js
+++ b/test/signature.js
@@ -112,6 +112,54 @@ test('convert SSH DSA sig and verify', function(t) {
 	t.end();
 });
 
+test('sign with DSA and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_dsa')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'dsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
+test('sign with RSA and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_rsa')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'rsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
+test('sign with ECDSA-256 and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_ecdsa2')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'ecdsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
 test('convert SSH ECDSA-256 sig and verify', function(t) {
 	var key = sshpk.parseKey(
 	    fs.readFileSync(path.join(testDir, 'id_ecdsa2')), 'pem');
@@ -122,7 +170,7 @@ test('convert SSH ECDSA-256 sig and verify', function(t) {
 	t.end();
 });
 
-test('signatures of wrong type fail verification', function(t) {
+test('signature of wrong type fails verification', function(t) {
 	var key = sshpk.parseKey(
 	    fs.readFileSync(path.join(testDir, 'id_ecdsa')), 'pem');
 	var sig = sshpk.parseSignature(ECDSA_SIG_ASN1, 'rsa', 'asn1');
@@ -132,6 +180,26 @@ test('signatures of wrong type fail verification', function(t) {
 	t.end();
 });
 
+test('signature on wrong data fails verification', function(t) {
+	var key = sshpk.parseKey(
+	    fs.readFileSync(path.join(testDir, 'id_ecdsa2')), 'pem');
+	var sig = sshpk.parseSignature(ECDSA2_SIG_SSH, 'ecdsa', 'ssh');
+	var s = key.createVerify();
+	s.update('foonotbar');
+	t.ok(!s.verify(sig));
+	t.end();
+});
+
+test('signature with wrong key fails verification', function(t) {
+	var key = sshpk.parseKey(
+	    fs.readFileSync(path.join(testDir, 'id_ecdsa')), 'pem');
+	var sig = sshpk.parseSignature(ECDSA2_SIG_SSH, 'ecdsa', 'ssh');
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(!s.verify(sig));
+	t.end();
+});
+
 test('convert SSH ECDSA-384 sig and verify', function(t) {
 	var key = sshpk.parseKey(
 	    fs.readFileSync(path.join(testDir, 'id_ecdsa')), 'pem');
-- 
2.21.0

