commit 45bdc106676e73437646877fa48ae640b03bb970 (refs/changes/14/114/10)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-07-22T01:30:47+00:00 (3 years, 3 months ago)
    
    joyent/node-sshpk#6 Want support for openssh and x509 certificates

diff --git a/README.md b/README.md
index d0fa88d..671f49f 100644
--- a/README.md
+++ b/README.md
@@ -448,6 +448,198 @@ Properties
 - `format` -- the `format` that was trying to parse the key (currently can only
               be `"pem"`)
 
+## Certificates
+
+`sshpk` includes basic support for parsing certificates in X.509 (PEM) format
+and the OpenSSH certificate format. This feature is intended to be used mainly
+to access basic metadata about certificates, extract public keys from them, and
+also to generate simple self-signed certificates from an existing key.
+
+Notably, there is no implementation of CA chain-of-trust verification, and no
+support for key usage restrictions. Please do the security world a favour, and
+DO NOT use this code for certificate verification in the traditional X.509 CA
+chain style.
+
+### `parseCertificate(data, format)`
+
+Parameters
+
+ - `data` -- a Buffer or String
+ - `format` -- a String, format to use, one of `'openssh'` or `'x509'`
+
+### `Certificate.createSelfSigned(subject, key[, options])`
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `key` -- a PrivateKey, the key of the subject: will be used both to be placed
+            in the certificate and also to sign it (since this is a self-signed
+            certificate)
+ - `options` -- optional Object, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+                   seconds
+   - `serial` -- optional Buffer, the serial number of the certificate
+
+### `Certificate.create(subject, key, issuer, issuerKey[, options])`
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `key` -- a Key, the public key of the subject
+ - `issuer` -- an Identity, the issuer of the certificate who will sign it
+ - `issuerKey` -- a PrivateKey, the issuer's private key for signing
+ - `options` -- optional Object, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+                   seconds
+   - `serial` -- optional Buffer, the serial number of the certificate
+
+### `Certificate#subjects`
+
+Array of `Identity` instances describing the subject of this certificate.
+
+### `Certificate#issuer`
+
+The `Identity` of the Certificate's issuer (signer).
+
+### `Certificate#subjectKey`
+
+The public key of the subject of the certificate, as a `Key` instance.
+
+### `Certificate#issuerKey`
+
+The public key of the signing issuer of this certificate, as a `Key` instance.
+May be `undefined` if the issuer's key is unknown (e.g. on an X509 certificate).
+
+### `Certificate#serial`
+
+The serial number of the certificate. As this is normally a 64-bit or wider
+integer, it is returned as a Buffer.
+
+### `Certificate#isExpired([when])`
+
+Tests whether the Certificate is currently expired (i.e. the `validFrom` and
+`validUntil` dates specify a range of time that does not include the current
+time).
+
+Parameters
+
+ - `when` -- optional Date, if specified, tests whether the Certificate was or
+             will be expired at the specified time instead of now
+
+Returns a Boolean.
+
+### `Certificate#isSignedByKey(key)`
+
+Tests whether the Certificate was validly signed by the given key.
+
+Parameters
+
+ - `key` -- a Key instance
+
+Returns a Boolean.
+
+### `Certificate#isSignedBy(certificate)`
+
+Tests whether this Certificate was validly signed by the subject of the given
+certificate. Also tests that the issuer Identity of this Certificate and the
+subject Identity of the other Certificate are equivalent.
+
+Parameters
+
+ - `certificate` -- another Certificate instance
+
+Returns a Boolean.
+
+### `Certificate#fingerprint([hashAlgo])`
+
+Returns the X509-style fingerprint of the entire certificate (as a Fingerprint
+instance). This matches what a web-browser or similar would display as the
+certificate fingerprint and should not be confused with the fingerprint of the
+subject's public key.
+
+Parameters
+
+ - `hashAlgo` -- an optional String, any hash function name
+
+### `Certificate#toBuffer([format])`
+
+Serializes the Certificate to a Buffer and returns it.
+
+Parameters
+
+ - `format` -- an optional String, output format, one of `'openssh'` or
+               `'x509'`. Defaults to `'x509'`.
+
+Returns a Buffer.
+
+### `Certificate#toString([format])`
+
+ - `format` -- an optional String, output format, one of `'openssh'` or
+               `'x509'`. Defaults to `'x509'`.
+
+Returns a String.
+
+## Certificate identities
+
+### `Identity.parseDN(dn)`
+
+Parses an LDAP-style DN string (e.g. `'CN=foo, C=US'`) and turns it into an
+Identity instance.
+
+Parameters
+
+ - `dn` -- a String
+
+Returns an Identity instance.
+
+### `Identity.forHost(hostname)`
+
+Constructs a host-type Identity for a given hostname.
+
+Parameters
+
+ - `hostname` -- the fully qualified DNS name of the host
+
+Returns an Identity instance.
+
+### `Identity.forUser(uid)`
+
+Constructs a user-type Identity for a given UID.
+
+Parameters
+
+ - `uid` -- a String, user identifier (login name)
+
+Returns an Identity instance.
+
+### `Identity.forEmail(email)`
+
+Constructs an email-type Identity for a given email address.
+
+Parameters
+
+ - `email` -- a String, email address
+
+Returns an Identity instance.
+
+### `Identity#toString()`
+
+Returns the identity as an LDAP-style DN string.
+e.g. `'CN=foo, O=bar corp, C=us'`
+
+### `Identity#type`
+
+The type of identity. One of `'host'`, `'user'` or `'unknown'`
+
+### `Identity#hostname`
+### `Identity#uid`
+
+Set when `type` is `'host'` or `'user'` respectively. Strings.
+
+### `Identity#cn`
+
+The value of the first `CN=` in the DN, if any.
+
 Friends of sshpk
 ----------------
 
diff --git a/lib/certificate.js b/lib/certificate.js
new file mode 100644
index 0000000..35adae4
--- /dev/null
+++ b/lib/certificate.js
@@ -0,0 +1,278 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Certificate;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var Key = require('./key');
+var PrivateKey = require('./private-key');
+var Identity = require('./identity');
+
+var formats = {};
+formats['openssh'] = require('./formats/openssh-cert');
+formats['x509'] = require('./formats/x509');
+
+function Certificate(opts) {
+	assert.object(opts, 'options');
+	assert.arrayOfObject(opts.subjects, 'options.subjects');
+	utils.assertCompatible(opts.subjects[0], Identity, [1, 0],
+	    'options.subjects');
+	utils.assertCompatible(opts.subjectKey, Key, [1, 0],
+	    'options.subjectKey');
+	utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
+	if (opts.issuerKey !== undefined) {
+		utils.assertCompatible(opts.issuerKey, Key, [1, 0],
+		    'options.issuerKey');
+	}
+	assert.object(opts.signatures, 'options.signatures');
+	assert.buffer(opts.serial, 'options.serial');
+	assert.object(opts.validFrom, 'options.validFrom');
+	assert.object(opts.validUntil, 'options.validUntil');
+	assert.ok(opts.validFrom instanceof Date);
+	assert.ok(opts.validUntil instanceof Date);
+
+	this._hashCache = {};
+
+	this.subjects = opts.subjects;
+	this.issuer = opts.issuer;
+	this.subjectKey = opts.subjectKey;
+	this.issuerKey = opts.issuerKey;
+	this.signatures = opts.signatures;
+	this.serial = opts.serial;
+	this.validFrom = opts.validFrom;
+	this.validUntil = opts.validUntil;
+}
+
+Certificate.formats = formats;
+
+Certificate.prototype.toBuffer = function (format, options) {
+	if (format === undefined)
+		format = 'x509';
+	assert.string(format, 'format');
+	assert.object(formats[format], 'formats[format]');
+	assert.optionalObject(options, 'options');
+
+	return (formats[format].write(this, options));
+};
+
+Certificate.prototype.toString = function (format, options) {
+	return (this.toBuffer(format, options).toString());
+};
+
+Certificate.prototype.fingerprint = function (algo) {
+	if (algo === undefined)
+		algo = 'sha256';
+	assert.string(algo, 'algorithm');
+	var opts = {
+		type: 'certificate',
+		hash: this.hash(algo),
+		algorithm: algo
+	};
+	return (new Fingerprint(opts));
+};
+
+Certificate.prototype.hash = function (algo) {
+	assert.string(algo, 'algorithm');
+	algo = algo.toLowerCase();
+	if (algs.hashAlgs[algo] === undefined)
+		throw (new InvalidAlgorithmError(algo));
+
+	if (this._hashCache[algo])
+		return (this._hashCache[algo]);
+
+	var hash = crypto.createHash(algo).
+	    update(this.toBuffer('x509')).digest();
+	this._hashCache[algo] = hash;
+	return (hash);
+};
+
+Certificate.prototype.isExpired = function (when) {
+	if (when === undefined)
+		when = new Date();
+	return (!((when.getTime() >= this.validFrom.getTime()) &&
+		(when.getTime() < this.validUntil.getTime())));
+};
+
+Certificate.prototype.isSignedBy = function (issuer) {
+	var issuerKey;
+	var issuerCert;
+	if (Certificate.isCertificate(issuer, [1, 0])) {
+		issuerCert = issuer;
+		issuerKey = issuer.subjectKey;
+	} else if (Key.isKey(issuer, [1, 3])) {
+		issuerKey = issuer;
+	} else {
+		throw (new Error('"issuer" must be a Certificate or Key'));
+	}
+
+	if (issuerCert !== undefined &&
+	    !this.issuer.equals(issuerCert.subjects[0]))
+		return (false);
+
+	if (this.issuerKey !== undefined) {
+		return (this.issuerKey.
+		    fingerprint('sha512').matches(issuerKey));
+	}
+
+	var fmt = Object.keys(this.signatures)[0];
+	var valid = formats[fmt].verify(this, issuerKey);
+	if (valid)
+		this.issuerKey = issuerKey;
+	return (valid);
+};
+
+Certificate.prototype.isSignedByKey = Certificate.prototype.isSignedBy;
+
+Certificate.prototype.signWith = function (key) {
+	var fmts = Object.keys(formats);
+	for (var i = 0; i < fmts.length; ++i) {
+		formats[fmts[i]].sign(this, key);
+	}
+};
+
+Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
+	var subjects;
+	if (Array.isArray(subjectOrSubjects))
+		subjects = subjectOrSubjects;
+	else
+		subjects = [subjectOrSubjects];
+
+	assert.arrayOfObject(subjects);
+	subjects.forEach(function (subject) {
+		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
+	});
+
+	utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');
+
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalObject(options.validFrom, 'options.validFrom');
+	if (options.validFrom === undefined)
+		options.validFrom = new Date();
+	assert.optionalObject(options.validUntil, 'options.validUntil');
+	if (options.validUntil === undefined) {
+		assert.optionalNumber(options.lifetime, 'options.lifetime');
+		if (options.lifetime === undefined)
+			options.lifetime = 10*365*24*3600;
+		options.validUntil = new Date();
+		options.validUntil.setTime(
+		    options.validUntil.getTime() + options.lifetime*1000);
+	}
+	assert.optionalBuffer(options.serial, 'options.serial');
+	if (options.serial === undefined)
+		options.serial = new Buffer('0000000000000001', 'hex');
+
+	var cert = new Certificate({
+		subjects: subjects,
+		issuer: subjects[0],
+		subjectKey: key.toPublic(),
+		issuerKey: key.toPublic(),
+		signatures: {},
+		serial: options.serial,
+		validFrom: options.validFrom,
+		validUntil: options.validUntil
+	});
+	cert.signWith(key);
+
+	return (cert);
+};
+
+Certificate.create =
+    function (subjectOrSubjects, key, issuer, issuerKey, options) {
+	var subjects;
+	if (Array.isArray(subjectOrSubjects))
+		subjects = subjectOrSubjects;
+	else
+		subjects = [subjectOrSubjects];
+
+	assert.arrayOfObject(subjects);
+	subjects.forEach(function (subject) {
+		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
+	});
+
+	utils.assertCompatible(key, Key, [1, 0], 'key');
+	if (PrivateKey.isPrivateKey(key))
+		key = key.toPublic();
+	utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
+	utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');
+
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalObject(options.validFrom, 'options.validFrom');
+	if (options.validFrom === undefined)
+		options.validFrom = new Date();
+	assert.optionalObject(options.validUntil, 'options.validUntil');
+	if (options.validUntil === undefined) {
+		assert.optionalNumber(options.lifetime, 'options.lifetime');
+		if (options.lifetime === undefined)
+			options.lifetime = 2*365*24*3600;
+		options.validUntil = new Date();
+		options.validUntil.setTime(
+		    options.validUntil.getTime() + options.lifetime*1000);
+	}
+	assert.optionalBuffer(options.serial, 'options.serial');
+	if (options.serial === undefined)
+		options.serial = new Buffer('0000000000000001', 'hex');
+
+	var cert = new Certificate({
+		subjects: subjects,
+		issuer: issuer,
+		subjectKey: key,
+		issuerKey: issuerKey.toPublic(),
+		signatures: {},
+		serial: options.serial,
+		validFrom: options.validFrom,
+		validUntil: options.validUntil
+	});
+	cert.signWith(issuerKey);
+
+	return (cert);
+};
+
+Certificate.parse = function (data, format, options) {
+	if (typeof (data) !== 'string')
+		assert.buffer(data, 'data');
+	if (format === undefined)
+		format = 'auto';
+	assert.string(format, 'format');
+	if (typeof (options) === 'string')
+		options = { filename: options };
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalString(options.filename, 'options.filename');
+	if (options.filename === undefined)
+		options.filename = '(unnamed)';
+
+	assert.object(formats[format], 'formats[format]');
+
+	try {
+		var k = formats[format].read(data, options);
+		return (k);
+	} catch (e) {
+		throw (e);
+		throw (new KeyParseError(options.filename, format, e));
+	}
+};
+
+Certificate.isCertificate = function (obj, ver) {
+	return (utils.isCompatible(obj, Certificate, ver));
+};
+
+/*
+ * API versions for Certificate:
+ * [1,0] -- initial ver
+ */
+Certificate.prototype._sshpkApiVersion = [1, 0];
+
+Certificate._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
diff --git a/lib/fingerprint.js b/lib/fingerprint.js
index c607330..7ed7e51 100644
--- a/lib/fingerprint.js
+++ b/lib/fingerprint.js
@@ -7,6 +7,7 @@ var algs = require('./algs');
 var crypto = require('crypto');
 var errs = require('./errors');
 var Key = require('./key');
+var Certificate = require('./certificate');
 var utils = require('./utils');
 
 var FingerprintFormatError = errs.FingerprintFormatError;
@@ -14,6 +15,7 @@ var InvalidAlgorithmError = errs.InvalidAlgorithmError;
 
 function Fingerprint(opts) {
 	assert.object(opts, 'options');
+	assert.string(opts.type, 'options.type');
 	assert.buffer(opts.hash, 'options.hash');
 	assert.string(opts.algorithm, 'options.algorithm');
 
@@ -22,6 +24,7 @@ function Fingerprint(opts) {
 		throw (new InvalidAlgorithmError(this.algorithm));
 
 	this.hash = opts.hash;
+	this.type = opts.type;
 }
 
 Fingerprint.prototype.toString = function (format) {
@@ -44,11 +47,16 @@ Fingerprint.prototype.toString = function (format) {
 	}
 };
 
-Fingerprint.prototype.matches = function (key) {
-	assert.object(key, 'key');
-	utils.assertCompatible(key, Key, [1, 0], 'key');
+Fingerprint.prototype.matches = function (other) {
+	assert.object(other, 'key or certificate');
+	if (this.type === 'key') {
+		utils.assertCompatible(other, Key, [1, 0], 'key');
+	} else {
+		utils.assertCompatible(other, Certificate, [1, 0],
+		    'certificate');
+	}
 
-	var theirHash = key.hash(this.algorithm);
+	var theirHash = other.hash(this.algorithm);
 	var theirHash2 = crypto.createHash(this.algorithm).
 	    update(theirHash).digest('base64');
 
@@ -59,10 +67,19 @@ Fingerprint.prototype.matches = function (key) {
 	return (this.hash2 === theirHash2);
 };
 
-Fingerprint.parse = function (fp, enAlgs) {
+Fingerprint.parse = function (fp, options) {
 	assert.string(fp, 'fingerprint');
 
-	var alg, hash;
+	var alg, hash, enAlgs;
+	if (Array.isArray(options)) {
+		enAlgs = options;
+		options = {};
+	}
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	if (options.enAlgs !== undefined)
+		enAlgs = options.enAlgs;
 	assert.optionalArrayOfString(enAlgs, 'algorithms');
 
 	var parts = fp.split(':');
@@ -105,7 +122,11 @@ Fingerprint.parse = function (fp, enAlgs) {
 			throw (new InvalidAlgorithmError(alg));
 	}
 
-	return (new Fingerprint({algorithm: alg, hash: hash}));
+	return (new Fingerprint({
+		algorithm: alg,
+		hash: hash,
+		type: options.type || 'key'
+	}));
 };
 
 function addColons(s) {
diff --git a/lib/formats/openssh-cert.js b/lib/formats/openssh-cert.js
new file mode 100644
index 0000000..0d5be55
--- /dev/null
+++ b/lib/formats/openssh-cert.js
@@ -0,0 +1,263 @@
+// Copyright 2015 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	verify: verify,
+	sign: sign,
+	write: write
+};
+
+var assert = require('assert-plus');
+var SSHBuffer = require('../ssh-buffer');
+var crypto = require('crypto');
+var algs = require('../algs');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var Identity = require('../identity');
+var rfc4253 = require('./rfc4253');
+var Signature = require('../signature');
+var utils = require('../utils');
+var Certificate = require('../certificate');
+
+function verify(cert, key) {
+	/*
+	 * We always give an issuerKey, so if our verify() is being called then
+	 * there was no signature. Return false.
+	 */
+	return (false);
+}
+
+var TYPES = {
+	'user': 1,
+	'host': 2
+};
+Object.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });
+
+var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
+
+function read(buf, options) {
+	if (Buffer.isBuffer(buf))
+		buf = buf.toString('ascii');
+	var parts = buf.trim().split(/[ \t\n]+/g);
+	if (parts.length < 2 || parts.length > 3)
+		throw (new Error('Not a valid SSH certificate line'));
+
+	var algo = parts[0];
+	var data = parts[1];
+
+	data = new Buffer(data, 'base64');
+	var sshbuf = new SSHBuffer({ buffer: data });
+	var innerAlgo = sshbuf.readString();
+	if (innerAlgo !== algo)
+		throw (new Error('SSH certificate algorithm mismatch'));
+
+	var cert = {};
+	cert.signatures = {};
+	cert.signatures.openssh = {};
+
+	cert.signatures.openssh.nonce = sshbuf.readBuffer();
+
+	var key = {};
+	parts = (key.parts = []);
+	key.type = getAlg(algo);
+
+	var partCount = algs.info[key.type].parts.length;
+	while (parts.length < partCount)
+		parts.push(sshbuf.readPart());
+	assert.ok(parts.length >= 1, 'key must have at least one part');
+
+	var algInfo = algs.info[key.type];
+	if (key.type === 'ecdsa') {
+		var res = ECDSA_ALGO.exec(algo);
+		assert.ok(res !== null);
+		assert.strictEqual(res[1], parts[0].data.toString());
+	}
+
+	for (var i = 0; i < algInfo.parts.length; ++i) {
+		parts[i].name = algInfo.parts[i];
+		if (parts[i].name !== 'curve' &&
+		    algInfo.normalize !== false) {
+			var p = parts[i];
+			p.data = utils.mpNormalize(p.data);
+		}
+	}
+
+	cert.subjectKey = new Key(key);
+
+	cert.serial = sshbuf.readInt64();
+
+	var type = TYPES[sshbuf.readInt()];
+	assert.string(type, 'valid cert type');
+
+	cert.signatures.openssh.keyId = sshbuf.readString();
+
+	var principals = [];
+	var pbuf = sshbuf.readBuffer();
+	var psshbuf = new SSHBuffer({ buffer: pbuf });
+	while (!psshbuf.atEnd())
+		principals.push(psshbuf.readString());
+	if (principals.length === 0)
+		principals = ['*'];
+
+	cert.subjects = principals.map(function (pr) {
+		if (type === 'user')
+			return (Identity.forUser(pr));
+		else if (type === 'host')
+			return (Identity.forHost(pr));
+		throw (new Error('Unknown identity type ' + type));
+	});
+
+	cert.validFrom = int64ToDate(sshbuf.readInt64());
+	cert.validUntil = int64ToDate(sshbuf.readInt64());
+
+	cert.signatures.openssh.critical = sshbuf.readBuffer();
+	cert.signatures.openssh.exts = sshbuf.readBuffer();
+
+	/* reserved */
+	sshbuf.readBuffer();
+
+	var signingKeyBuf = sshbuf.readBuffer();
+	cert.issuerKey = rfc4253.read(signingKeyBuf);
+
+	/*
+	 * OpenSSH certs don't give the identity of the issuer, just their
+	 * public key. So, we use an Identity that matches anything. The
+	 * isSignedBy() function will later tell you if the key matches.
+	 */
+	cert.issuer = Identity.forHost('**');
+
+	var sigBuf = sshbuf.readBuffer();
+	cert.signatures.openssh.signature =
+	    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');
+
+	return (new Certificate(cert));
+}
+
+function int64ToDate(buf) {
+	var i = buf.readUInt32BE(0) * 4294967296;
+	i += buf.readUInt32BE(4);
+	var d = new Date();
+	d.setTime(i * 1000);
+	d.sourceInt64 = buf;
+	return (d);
+}
+
+function dateToInt64(date) {
+	if (date.sourceInt64 !== undefined)
+		return (date.sourceInt64);
+	var i = Math.round(date.getTime() / 1000);
+	var upper = Math.floor(i / 4294967296);
+	var lower = Math.floor(i % 4294967296);
+	var buf = new Buffer(8);
+	buf.writeUInt32BE(upper, 0);
+	buf.writeUInt32BE(lower, 4);
+	return (buf);
+}
+
+function sign(cert, key) {
+	assert.ok(PrivateKey.isPrivateKey(key, [1, 2]));
+	if (cert.signatures.openssh === undefined)
+		cert.signatures.openssh = {};
+	var sig = cert.signatures.openssh;
+
+	var blob = toBuffer(cert, true);
+	var signer = key.createSign();
+	signer.write(blob);
+	sig.signature = signer.sign();
+}
+
+function write(cert, options) {
+	if (options === undefined)
+		options = {};
+
+	var blob = toBuffer(cert);
+	var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
+	if (options.comment)
+		out = out + ' ' + options.comment;
+	return (out);
+}
+
+
+function toBuffer(cert, noSig) {
+	assert.object(cert.signatures.openssh, 'signature for openssh format');
+	var sig = cert.signatures.openssh;
+
+	if (sig.nonce === undefined)
+		sig.nonce = crypto.randomBytes(16);
+	var buf = new SSHBuffer({});
+	buf.writeString(getCertType(cert.subjectKey));
+	buf.writeBuffer(sig.nonce);
+
+	var key = cert.subjectKey;
+	var algInfo = algs.info[key.type];
+	algInfo.parts.forEach(function (part) {
+		buf.writePart(key.part[part]);
+	});
+
+	buf.writeInt64(cert.serial);
+
+	var type = cert.subjects[0].type;
+	assert.notStrictEqual(type, 'unknown');
+	cert.subjects.forEach(function (id) {
+		assert.strictEqual(id.type, type);
+	});
+	type = TYPES[type];
+	buf.writeInt(type);
+
+	if (sig.keyId === undefined) {
+		sig.keyId = cert.subjects[0].type + '_' +
+		    (cert.subjects[0].uid || cert.subjects[0].hostname);
+	}
+	buf.writeString(sig.keyId);
+
+	var sub = new SSHBuffer({});
+	cert.subjects.forEach(function (id) {
+		if (type === TYPES.host)
+			sub.writeString(id.hostname);
+		else if (type === TYPES.user)
+			sub.writeString(id.uid);
+	});
+	buf.writeBuffer(sub.toBuffer());
+
+	buf.writeInt64(dateToInt64(cert.validFrom));
+	buf.writeInt64(dateToInt64(cert.validUntil));
+
+	if (sig.critical === undefined)
+		sig.critical = new Buffer(0);
+	buf.writeBuffer(sig.critical);
+
+	if (sig.exts === undefined)
+		sig.exts = new Buffer(0);
+	buf.writeBuffer(sig.exts);
+
+	/* reserved */
+	buf.writeBuffer(new Buffer(0));
+
+	sub = rfc4253.write(cert.issuerKey);
+	buf.writeBuffer(sub);
+
+	if (!noSig)
+		buf.writeBuffer(sig.signature.toBuffer('ssh'));
+
+	return (buf.toBuffer());
+}
+
+function getAlg(certType) {
+	if (certType === 'ssh-rsa-cert-v01@openssh.com')
+		return ('rsa');
+	if (certType === 'ssh-dss-cert-v01@openssh.com')
+		return ('dsa');
+	if (certType.match(ECDSA_ALGO))
+		return ('ecdsa');
+	throw (new Error('Unsupported cert type ' + certType));
+}
+
+function getCertType(key) {
+	if (key.type === 'rsa')
+		return ('ssh-rsa-cert-v01@openssh.com');
+	if (key.type === 'dsa')
+		return ('ssh-dss-cert-v01@openssh.com');
+	if (key.type === 'ecdsa')
+		return ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');
+	throw (new Error('Unsupported key type ' + key.type));
+}
diff --git a/lib/formats/x509.js b/lib/formats/x509.js
new file mode 100644
index 0000000..edc7a73
--- /dev/null
+++ b/lib/formats/x509.js
@@ -0,0 +1,417 @@
+// Copyright 2015 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	verify: verify,
+	sign: sign,
+	write: write
+};
+
+var assert = require('assert-plus');
+var asn1 = require('asn1');
+var algs = require('../algs');
+var utils = require('../utils');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var pem = require('./pem');
+var Identity = require('../identity');
+var Signature = require('../signature');
+var Certificate = require('../certificate');
+var pkcs8 = require('./pkcs8');
+
+/* Helper to read in a single mpint */
+function readMPInt(der, nm) {
+	assert.strictEqual(der.peek(), asn1.Ber.Integer,
+	    nm + ' is not an Integer');
+	return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
+}
+
+function verify(cert, key) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	var algParts = sig.algo.split('-');
+	if (algParts[0] !== key.type)
+		return (false);
+
+	var blob = sig.cache;
+	if (blob === undefined) {
+		var der = new asn1.BerWriter();
+		writeTBSCert(cert, der);
+		blob = der.buffer;
+	}
+
+	var verifier = key.createVerify(algParts[1]);
+	verifier.write(blob);
+	return (verifier.verify(sig.signature));
+}
+
+function Local(i) {
+	return (asn1.Ber.Context | asn1.Ber.Constructor | i);
+}
+
+function Context(i) {
+	return (asn1.Ber.Context | i);
+}
+
+var SIGN_ALGS = {
+	'rsa-md5': '1.2.840.113549.1.1.4',
+	'rsa-sha1': '1.2.840.113549.1.1.5',
+	'rsa-sha256': '1.2.840.113549.1.1.11',
+	'rsa-sha384': '1.2.840.113549.1.1.12',
+	'rsa-sha512': '1.2.840.113549.1.1.13',
+	'dsa-sha1': '1.2.840.10040.4.3',
+	'dsa-sha256': '2.16.840.1.101.3.4.3.2',
+	'ecdsa-sha1': '1.2.840.10045.4.1',
+	'ecdsa-sha256': '1.2.840.10045.4.3.2',
+	'ecdsa-sha384': '1.2.840.10045.4.3.3',
+	'ecdsa-sha512': '1.2.840.10045.4.3.4'
+};
+Object.keys(SIGN_ALGS).forEach(function (k) {
+	SIGN_ALGS[SIGN_ALGS[k]] = k;
+});
+
+var EXTS = {
+	'issuerKeyId': '2.5.29.35',
+	'altName': '2.5.29.17'
+};
+
+function read(buf, options) {
+	if (typeof (buf) !== 'string') {
+		assert.buffer(buf, 'buf');
+		buf = buf.toString('ascii');
+	}
+
+	var lines = buf.trim().split(/[\r\n]+/g);
+
+	var m = lines[0].match(/*JSSTYLED*/
+	    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
+	assert.ok(m, 'invalid PEM header');
+
+	var m2 = lines[lines.length - 1].match(/*JSSTYLED*/
+	    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
+	assert.ok(m2, 'invalid PEM footer');
+
+	var headers = {};
+	while (true) {
+		lines = lines.slice(1);
+		m = lines[0].match(/*JSSTYLED*/
+		    /^([A-Za-z0-9-]+): (.+)$/);
+		if (!m)
+			break;
+		headers[m[1].toLowerCase()] = m[2];
+	}
+
+	/* Chop off the first and last lines */
+	lines = lines.slice(0, -1).join('');
+	buf = new Buffer(lines, 'base64');
+
+	var der = new asn1.BerReader(buf);
+
+	der.readSequence();
+	assert.strictEqual(der.length, der.remain);
+
+	var tbsStart = der.offset;
+	der.readSequence();
+	var sigOffset = der.offset + der.length;
+	var tbsEnd = sigOffset;
+
+	if (der.peek() === Local(0)) {
+		der.readSequence(Local(0));
+		var version = der.readInt();
+		assert.ok(version <= 2,
+		    'only x.509 versions up to v3 supported');
+	}
+
+	var cert = {};
+
+	cert.serial = readMPInt(der, 'serial');
+
+	der.readSequence();
+	var after = der.offset + der.length;
+	var certAlgOid = der.readOID();
+	var certAlg = SIGN_ALGS[certAlgOid];
+	if (certAlg === undefined)
+		throw (new Error('unknown signature algorithm ' + certAlgOid));
+
+	der._offset = after;
+	cert.issuer = Identity.parseAsn1(der);
+
+	der.readSequence();
+	var validFrom = der.readString(asn1.Ber.UTCTime);
+	var validUntil = der.readString(asn1.Ber.UTCTime);
+	cert.validFrom = utcTimeToDate(validFrom);
+	cert.validUntil = utcTimeToDate(validUntil);
+
+	cert.subjects = [Identity.parseAsn1(der)];
+
+	der.readSequence();
+	after = der.offset + der.length;
+	cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);
+	der._offset = after;
+
+	/* issuerUniqueID */
+	if (der.peek() === Local(1)) {
+		der.readSequence(Local(1));
+		der._offset += der.length;
+	}
+
+	/* subjectUniqueID */
+	if (der.peek() === Local(2)) {
+		der.readSequence(Local(2));
+		der._offset += der.length;
+	}
+
+	/* extensions */
+	if (der.peek() === Local(3)) {
+		der.readSequence(Local(3));
+		var extEnd = der.offset + der.length;
+		der.readSequence();
+
+		while (der.offset < extEnd)
+			readExtension(cert, der);
+
+		assert.strictEqual(der.offset, extEnd);
+	}
+
+	assert.strictEqual(der.offset, sigOffset);
+
+	cert.signatures = {};
+	var sig = (cert.signatures.x509 = {});
+
+	der.readSequence();
+	after = der.offset + der.length;
+	var sigAlgOid = der.readOID();
+	var sigAlg = SIGN_ALGS[sigAlgOid];
+	if (sigAlg === undefined)
+		throw (new Error('unknown signature algorithm ' + sigAlgOid));
+	der._offset = after;
+
+	var sigData = der.readString(asn1.Ber.BitString, true);
+	if (sigData[0] === 0)
+		sigData = sigData.slice(1);
+	var algParts = sigAlg.split('-');
+
+	sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
+	sig.signature.hashAlgorithm = algParts[1];
+	sig.algo = sigAlg;
+	sig.cache = buf.slice(tbsStart, tbsEnd);
+
+	return (new Certificate(cert));
+}
+
+function readExtension(cert, der) {
+	der.readSequence();
+	var after = der.offset + der.length;
+	var extId = der.readOID();
+	var id;
+
+	/* "critical" */
+	if (der.peek() === asn1.Ber.Boolean)
+		der.readBoolean();
+
+	switch (extId) {
+	case (EXTS.altName):
+		der.readSequence(asn1.Ber.OctetString);
+		der.readSequence();
+		var aeEnd = der.offset + der.length;
+		while (der.offset < aeEnd) {
+			switch (der.peek()) {
+			case Local(0):
+			case Local(5):
+				der.readSequence();
+				der._offset += der.length;
+				break;
+			case Context(8):
+				der.readOID(Context(8));
+				break;
+			case Context(1):
+				var email = der.readString(Context(1));
+				id = Identity.forEmail(email);
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			case Local(4):
+				id = Identity.parseAsn1(der, Local(4));
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			case Context(2):
+				var host = der.readString(
+				    Context(2));
+				id = Identity.forHost(host);
+				if (!cert.subjects[0].equals(id))
+					cert.subjects.push(id);
+				break;
+			default:
+				der.readString(der.peek());
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	der._offset = after;
+}
+
+var UTCTIME_RE =
+    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
+function utcTimeToDate(t) {
+	var m = t.match(UTCTIME_RE);
+	assert.ok(m);
+	var d = new Date();
+
+	var thisYear = d.getUTCFullYear();
+	var century = Math.floor(thisYear / 100) * 100;
+
+	var year = parseInt(m[1], 10);
+	if (thisYear % 100 < 50 && year >= 60)
+		year += (century - 1);
+	else
+		year += century;
+	d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
+	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
+	if (m[6] && m[6].length > 0)
+		d.setUTCSeconds(parseInt(m[6], 10));
+	return (d);
+}
+
+function zeroPad(n) {
+	var s = '' + n;
+	while (s.length < 2)
+		s = '0' + s;
+	return (s);
+}
+
+function dateToUTCTime(d) {
+	var s = '';
+	s += zeroPad(d.getUTCFullYear() % 100);
+	s += zeroPad(d.getUTCMonth() + 1);
+	s += zeroPad(d.getUTCDate());
+	s += zeroPad(d.getUTCHours());
+	s += zeroPad(d.getUTCMinutes());
+	s += zeroPad(d.getUTCSeconds());
+	s += 'Z';
+	return (s);
+}
+
+function sign(cert, key) {
+	if (cert.signatures.x509 === undefined)
+		cert.signatures.x509 = {};
+	var sig = cert.signatures.x509;
+
+	sig.algo = key.type + '-' + key.defaultHashAlgorithm();
+	assert.string(SIGN_ALGS[sig.algo]);
+
+	var der = new asn1.BerWriter();
+	writeTBSCert(cert, der);
+	var blob = der.buffer;
+	sig.cache = blob;
+
+	var signer = key.createSign();
+	signer.write(blob);
+	cert.signatures.x509.signature = signer.sign();
+}
+
+function write(cert, options) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	var der = new asn1.BerWriter();
+	der.startSequence();
+	writeTBSCert(cert, der);
+
+	der.startSequence();
+	der.writeOID(SIGN_ALGS[sig.algo]);
+	der.endSequence();
+
+	var sigData = sig.signature.toBuffer('asn1');
+	var data = new Buffer(sigData.length + 1);
+	data[0] = 0;
+	sigData.copy(data, 1);
+	der.writeBuffer(data, asn1.Ber.BitString);
+	der.endSequence();
+
+	var header = 'CERTIFICATE';
+	var tmp = der.buffer.toString('base64');
+	var len = tmp.length + (tmp.length / 64) +
+	    18 + 16 + header.length*2 + 10;
+	var buf = new Buffer(len);
+	var o = 0;
+	o += buf.write('-----BEGIN ' + header + '-----\n', o);
+	for (var i = 0; i < tmp.length; ) {
+		var limit = i + 64;
+		if (limit > tmp.length)
+			limit = tmp.length;
+		o += buf.write(tmp.slice(i, limit), o);
+		buf[o++] = 10;
+		i = limit;
+	}
+	o += buf.write('-----END ' + header + '-----\n', o);
+
+	return (buf.slice(0, o));
+}
+
+function writeTBSCert(cert, der) {
+	var sig = cert.signatures.x509;
+	assert.object(sig, 'x509 signature');
+
+	der.startSequence();
+
+	der.startSequence(Local(0));
+	der.writeInt(2);
+	der.endSequence();
+
+	der.writeBuffer(cert.serial, asn1.Ber.Integer);
+
+	der.startSequence();
+	der.writeOID(SIGN_ALGS[sig.algo]);
+	der.endSequence();
+
+	cert.issuer.toAsn1(der);
+
+	der.startSequence();
+	der.writeString(dateToUTCTime(cert.validFrom), asn1.Ber.UTCTime);
+	der.writeString(dateToUTCTime(cert.validUntil), asn1.Ber.UTCTime);
+	der.endSequence();
+
+	var subject = cert.subjects[0];
+	var altNames = cert.subjects.slice(1);
+	subject.toAsn1(der);
+
+	pkcs8.writePkcs8(der, cert.subjectKey);
+
+	if (altNames.length > 0 || subject.type === 'host') {
+		der.startSequence(Local(3));
+		der.startSequence();
+
+		der.startSequence();
+		der.writeOID(EXTS.altName);
+		der.startSequence(asn1.Ber.OctetString);
+		der.startSequence();
+		if (subject.type === 'host') {
+			der.writeString(subject.hostname, Context(2));
+		}
+		for (var i = 0; i < altNames.length; ++i) {
+			if (altNames[i].type === 'host') {
+				der.writeString(altNames[i].hostname,
+				    Context(2));
+			} else if (altNames[i].type === 'email') {
+				der.writeString(altNames[i].email,
+				    Context(1));
+			} else {
+				altNames[i].toAsn1(der, Local(4));
+			}
+		}
+		der.endSequence();
+		der.endSequence();
+		der.endSequence();
+
+		der.endSequence();
+		der.endSequence();
+	}
+
+	der.endSequence();
+}
diff --git a/lib/identity.js b/lib/identity.js
new file mode 100644
index 0000000..5f43e24
--- /dev/null
+++ b/lib/identity.js
@@ -0,0 +1,245 @@
+// Copyright 2016 Joyent, Inc.
+
+module.exports = Identity;
+
+var assert = require('assert-plus');
+var algs = require('./algs');
+var crypto = require('crypto');
+var Fingerprint = require('./fingerprint');
+var Signature = require('./signature');
+var errs = require('./errors');
+var util = require('util');
+var utils = require('./utils');
+var asn1 = require('asn1');
+
+var DNS_NAME_RE = /^[a-z0-9][a-z0-9\-]{0,62}(?:\.[a-z0-9][a-z0-9\-]{0,62})*$/i;
+
+var oids = {};
+oids.cn = '2.5.4.3';
+oids.o = '2.5.4.10';
+oids.ou = '2.5.4.11';
+oids.l = '2.5.4.7';
+oids.s = '2.5.4.8';
+oids.c = '2.5.4.6';
+oids.sn = '2.5.4.4';
+oids.dc = '0.9.2342.19200300.100.1.25';
+oids.uid = '0.9.2342.19200300.100.1.1';
+oids.mail = '0.9.2342.19200300.100.1.3';
+
+var unoids = {};
+Object.keys(oids).forEach(function (k) {
+	unoids[oids[k]] = k;
+});
+
+function Identity(opts) {
+	var self = this;
+	assert.object(opts, 'options');
+	assert.arrayOfObject(opts.components, 'options.components');
+	this.components = opts.components;
+	this.componentLookup = {};
+	this.components.forEach(function (c) {
+		if (c.name && !c.oid)
+			c.oid = oids[c.name];
+		if (c.oid && !c.name)
+			c.name = unoids[c.oid];
+		if (self.componentLookup[c.name] === undefined)
+			self.componentLookup[c.name] = [];
+		self.componentLookup[c.name].push(c);
+	});
+	if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
+		this.cn = this.componentLookup.cn[0].value;
+	}
+	assert.optionalString(opts.type, 'options.type');
+	if (opts.type === undefined) {
+		if (this.components.length === 1 &&
+		    this.componentLookup.cn &&
+		    this.componentLookup.cn.length === 1 &&
+		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.cn[0].value;
+
+		} else if (this.componentLookup.dc &&
+		    this.components.length === this.componentLookup.dc.length) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.dc.map(
+			    function (c) {
+				return (c.value);
+			}).join('.');
+
+		} else if (this.componentLookup.uid &&
+		    this.components.length === this.componentLookup.uid.length) {
+			this.type = 'user';
+			this.uid = this.componentLookup.uid[0].value;
+
+		} else if (this.componentLookup.cn && 
+		    this.componentLookup.cn.length === 1 &&
+		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
+			this.type = 'host';
+			this.hostname = this.componentLookup.cn[0].value;
+
+		} else if (this.componentLookup.uid &&
+		    this.componentLookup.uid.length === 1) {
+			this.type = 'user';
+			this.uid = this.componentLookup.uid[0].value;
+
+		} else if (this.componentLookup.mail &&
+		    this.componentLookup.mail.length === 1) {
+			this.type = 'email';
+			this.email = this.componentLookup.mail[0].value;
+
+		} else if (this.componentLookup.cn &&
+		    this.componentLookup.cn.length === 1) {
+			this.type = 'user';
+			this.uid = this.componentLookup.cn[0].value;
+
+		} else {
+			this.type = 'unknown';
+		}
+	} else {
+		this.type = opts.type;
+		if (this.type === 'host')
+			this.hostname = opts.hostname;
+		else if (this.type === 'user')
+			this.uid = opts.uid;
+		else if (this.type === 'email')
+			this.email = opts.email;
+		else
+			throw (new Error('Unknown type ' + this.type));
+	}
+}
+
+Identity.prototype.toString = function () {
+	return (this.components.map(function (c) {
+		return (c.name.toUpperCase() + '=' + c.value);
+	}).join(', '));
+};
+
+Identity.prototype.toAsn1 = function (der, tag) {
+	der.startSequence(tag);
+	this.components.forEach(function (c) {
+		der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+		der.startSequence();
+		der.writeOID(c.oid);
+		der.writeString(c.value, asn1.Ber.PrintableString);
+		der.endSequence();
+		der.endSequence();
+	});
+	der.endSequence();
+};
+
+function globMatch(a, b) {
+	if (a === '**' || b === '**')
+		return (true);
+	var aParts = a.split('.');
+	var bParts = b.split('.');
+	if (aParts.length !== bParts.length)
+		return (false);
+	for (var i = 0; i < aParts.length; ++i) {
+		if (aParts[i] === '*' || bParts[i] === '*')
+			continue;
+		if (aParts[i] !== bParts[i])
+			return (false);
+	}
+	return (true);
+}
+
+Identity.prototype.equals = function (other) {
+	if (!Identity.isIdentity(other, [1, 0]))
+		return (false);
+	if (other.components.length !== this.components.length)
+		return (false);
+	for (var i = 0; i < this.components.length; ++i) {
+		if (this.components[i].oid !== other.components[i].oid)
+			return (false);
+		if (!globMatch(this.components[i].value,
+		    other.components[i].value)) {
+			return (false);
+		}
+	}
+	return (true);
+};
+
+Identity.forHost = function (hostname) {
+	assert.string(hostname, 'hostname');
+	return (new Identity({
+		type: 'host',
+		hostname: hostname,
+		components: [ { name: 'cn', value: hostname } ]
+	}));
+};
+
+Identity.forUser = function (uid) {
+	assert.string(uid, 'uid');
+	return (new Identity({
+		type: 'user',
+		uid: uid,
+		components: [ { name: 'uid', value: uid } ]
+	}));
+};
+
+Identity.forEmail = function (email) {
+	assert.string(email, 'email');
+	return (new Identity({
+		type: 'email',
+		email: email,
+		components: [ { name: 'mail', value: email } ]
+	}));
+};
+
+Identity.parseDN = function (dn) {
+	assert.string(dn, 'dn');
+	var parts = dn.split(',');
+	var cmps = parts.map(function (c) {
+		c = c.trim();
+		var eqPos = c.indexOf('=');
+		var name = c.slice(0, eqPos).toLowerCase();
+		var value = c.slice(eqPos + 1);
+		return ({ name: name, value: value });
+	});
+	return (new Identity({ components: cmps }));
+};
+
+Identity.parseAsn1 = function (der, top) {
+	var components = [];
+	der.readSequence(top);
+	var end = der.offset + der.length;
+	while (der.offset < end) {
+		der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
+		der.readSequence();
+		var oid = der.readOID();
+		var type = der.peek();
+		var value;
+		switch (type) {
+		case asn1.Ber.PrintableString:
+		case asn1.Ber.IA5String:
+		case asn1.Ber.OctetString:
+			value = der.readString(type);
+			break;
+		case asn1.Ber.Utf8String:
+			value = der.readString(type, true);
+			value = value.toString('utf8');
+			break;
+		default:
+			throw (new Error('Unknown asn1 type ' + type));
+		}
+		components.push({ oid: oid, value: value });
+	}
+	der._offset = end;
+	return (new Identity({
+		components: components
+	}));
+};
+
+Identity.isIdentity = function (obj, ver) {
+	return (utils.isCompatible(obj, Identity, ver));
+};
+
+/*
+ * API versions for Identity:
+ * [1,0] -- initial ver
+ */
+Identity.prototype._sshpkApiVersion = [1, 0];
+
+Identity._oldVersionDetect = function (obj) {
+	return ([1, 0]);
+};
diff --git a/lib/index.js b/lib/index.js
index 0b40429..c9c146f 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -4,6 +4,8 @@ var Key = require('./key');
 var Fingerprint = require('./fingerprint');
 var Signature = require('./signature');
 var PrivateKey = require('./private-key');
+var Certificate = require('./certificate');
+var Identity = require('./identity');
 var errs = require('./errors');
 
 module.exports = {
@@ -16,6 +18,9 @@ module.exports = {
 	parseSignature: Signature.parse,
 	PrivateKey: PrivateKey,
 	parsePrivateKey: PrivateKey.parse,
+	Certificate: Certificate,
+	parseCertificate: Certificate.parse,
+	Identity: Identity,
 
 	/* errors */
 	FingerprintFormatError: errs.FingerprintFormatError,
diff --git a/lib/key.js b/lib/key.js
index edc5143..ff5c363 100644
--- a/lib/key.js
+++ b/lib/key.js
@@ -117,6 +117,7 @@ Key.prototype.fingerprint = function (algo) {
 		algo = 'sha256';
 	assert.string(algo, 'algorithm');
 	var opts = {
+		type: 'key',
 		hash: this.hash(algo),
 		algorithm: algo
 	};
diff --git a/lib/signature.js b/lib/signature.js
index ddf4a8c..964f55c 100644
--- a/lib/signature.js
+++ b/lib/signature.js
@@ -65,23 +65,31 @@ Signature.prototype.toBuffer = function (format) {
 			buf = new SSHBuffer({});
 			buf.writeString('ssh-dss');
 			r = this.part.r.data;
-			if (r[0] === 0x00)
+			if (r.length > 20 && r[0] === 0x00)
 				r = r.slice(1);
 			s = this.part.s.data;
+			if (s.length > 20 && s[0] === 0x00)
+				s = s.slice(1);
+			if ((this.hashAlgorithm &&
+			    this.hashAlgorithm !== 'sha1') ||
+			    r.length + s.length !== 40) {
+				throw (new Error('OpenSSH only supports ' +
+				    'DSA signatures with SHA1 hash'));
+			}
 			buf.writeBuffer(Buffer.concat([r, s]));
 			return (buf.toBuffer());
 		} else if (format === 'ssh' && this.type === 'ecdsa') {
 			var inner = new SSHBuffer({});
-			r = this.part.r;
-			if (r[0] === 0x00)
-				r = r.slice(1);
-			inner.writePart(r);
+			r = this.part.r.data;
+			inner.writeBuffer(r);
 			inner.writePart(this.part.s);
 
 			buf = new SSHBuffer({});
 			/* XXX: find a more proper way to do this? */
 			var curve;
-			var sz = this.part.r.data.length * 8;
+			if (r[0] === 0x00)
+				r = r.slice(1);
+			var sz = r.length * 8;
 			if (sz === 256)
 				curve = 'nistp256';
 			else if (sz === 384)
diff --git a/lib/ssh-buffer.js b/lib/ssh-buffer.js
index 0b00277..8fc2cb8 100644
--- a/lib/ssh-buffer.js
+++ b/lib/ssh-buffer.js
@@ -73,6 +73,14 @@ SSHBuffer.prototype.readInt = function () {
 	return (v);
 };
 
+SSHBuffer.prototype.readInt64 = function () {
+	assert.ok(this._offset + 8 < this._buffer.length,
+	    'buffer not long enough to read Int64');
+	var v = this._buffer.slice(this._offset, this._offset + 8);
+	this._offset += 8;
+	return (v);
+};
+
 SSHBuffer.prototype.readChar = function () {
 	var v = this._buffer[this._offset++];
 	return (v);
@@ -106,6 +114,22 @@ SSHBuffer.prototype.writeInt = function (v) {
 	this._offset += 4;
 };
 
+SSHBuffer.prototype.writeInt64 = function (v) {
+	assert.buffer(v, 'value');
+	if (v.length > 8) {
+		var lead = v.slice(0, v.length - 8);
+		for (var i = 0; i < lead.length; ++i) {
+			assert.strictEqual(lead[i], 0,
+			    'must fit in 64 bits of precision');
+		}
+		v = v.slice(v.length - 8, v.length);
+	}
+	while (this._offset + 8 > this._size)
+		this.expand();
+	v.copy(this._buffer, this._offset);
+	this._offset += 8;
+};
+
 SSHBuffer.prototype.writeChar = function (v) {
 	while (this._offset + 1 > this._size)
 		this.expand();
diff --git a/test/assets/george-openssh.pub b/test/assets/george-openssh.pub
new file mode 100644
index 0000000..ee5bdeb
--- /dev/null
+++ b/test/assets/george-openssh.pub
@@ -0,0 +1 @@
+ssh-dss-cert-v01@openssh.com AAAAHHNzaC1kc3MtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgzc/ITc93psigtgu8QX+zM61g/eCQp4CAEi/vFdqp3TwAAACBANBGJdbHdT5d/1tU3d3Cw1Hr2/PoyYsmaGP82wH+2apK0RoZOmQfHlc/oyz9yordFB/VgleR800m5rJJH2TvwMqphw611oGDu+hSqV5UGyQBKIzPfh4mi9WHY4rZ6nHEeC2SiT6QKZG7dutDvXHmjBrLU+hwBY/Fd7oBN9P0Qxu3AAAAFQC0/mjeSy8EnwMuUhO098QaKBbYFQAAAIEAtZiJz9yGBwT1vsoLM938qkWSYU78qseOqXmpXFgCi9nbtXWvrLFEMAsQIUTBzNkEyDWyVBU8ld9ycvlaj5jclNaRJ/JLcGyzK/8I78/QvtiY/VkSxLxymOkLI33q/yXWn5yUEU5HyBdiyI4eLFvYS2slyxYWq63b6NTr99lFBd4AAACBAItcldZqWy1ZyoLMLcFzYV3Q80vU2aFXWckDU7xPERsjSnmxIuvKSZGCpZZX6XqWn0zcdtu+AZGVZu1FOpV/g0cckpGi2ACtZ2XLGZ2IdMk0cTrZTmzXPBLxy5gBkO1CijIjGy2d5B4ojI9vAf5uTc+qY15qel1KzXuPgzP+zABmAAAAAAAAAAAAAAABAAAACWdlb3JnZWtleQAAAAoAAAAGZ2VvcmdlAAAAAFeRWggAAAAAWXE8fQAAAAAAAACCAAAAFXBlcm1pdC1YMTEtZm9yd2FyZGluZwAAAAAAAAAXcGVybWl0LWFnZW50LWZvcndhcmRpbmcAAAAAAAAAFnBlcm1pdC1wb3J0LWZvcndhcmRpbmcAAAAAAAAACnBlcm1pdC1wdHkAAAAAAAAADnBlcm1pdC11c2VyLXJjAAAAAAAAAAAAAAGzAAAAB3NzaC1kc3MAAACBANBGJdbHdT5d/1tU3d3Cw1Hr2/PoyYsmaGP82wH+2apK0RoZOmQfHlc/oyz9yordFB/VgleR800m5rJJH2TvwMqphw611oGDu+hSqV5UGyQBKIzPfh4mi9WHY4rZ6nHEeC2SiT6QKZG7dutDvXHmjBrLU+hwBY/Fd7oBN9P0Qxu3AAAAFQC0/mjeSy8EnwMuUhO098QaKBbYFQAAAIEAtZiJz9yGBwT1vsoLM938qkWSYU78qseOqXmpXFgCi9nbtXWvrLFEMAsQIUTBzNkEyDWyVBU8ld9ycvlaj5jclNaRJ/JLcGyzK/8I78/QvtiY/VkSxLxymOkLI33q/yXWn5yUEU5HyBdiyI4eLFvYS2slyxYWq63b6NTr99lFBd4AAACBAItcldZqWy1ZyoLMLcFzYV3Q80vU2aFXWckDU7xPERsjSnmxIuvKSZGCpZZX6XqWn0zcdtu+AZGVZu1FOpV/g0cckpGi2ACtZ2XLGZ2IdMk0cTrZTmzXPBLxy5gBkO1CijIjGy2d5B4ojI9vAf5uTc+qY15qel1KzXuPgzP+zABmAAAANwAAAAdzc2gtZHNzAAAAKC53ceRpJIQ73wc1BHbp9cccco08sPylyIEbBgT2e2SHBZV/WMOeInM= id_dsa
diff --git a/test/assets/george-x509.pem b/test/assets/george-x509.pem
new file mode 100644
index 0000000..d3f48ed
--- /dev/null
+++ b/test/assets/george-x509.pem
@@ -0,0 +1,15 @@
+-----BEGIN CERTIFICATE-----
+MIICazCCAigCCQC5yqE79U0ouDALBglghkgBZQMEAwIwGDEWMBQGCgmSJomT8ixk
+AQETBmdlb3JnZTAeFw0xNjA3MjEyMzI2MjJaFw0xNzA3MjEyMzI2MjJaMBgxFjAU
+BgoJkiaJk/IsZAEBEwZnZW9yZ2UwggG4MIIBLAYHKoZIzjgEATCCAR8CgYEA0EYl
+1sd1Pl3/W1Td3cLDUevb8+jJiyZoY/zbAf7ZqkrRGhk6ZB8eVz+jLP3Kit0UH9WC
+V5HzTSbmskkfZO/AyqmHDrXWgYO76FKpXlQbJAEojM9+HiaL1YdjitnqccR4LZKJ
+PpApkbt260O9ceaMGstT6HAFj8V3ugE30/RDG7cCFQC0/mjeSy8EnwMuUhO098Qa
+KBbYFQKBgQC1mInP3IYHBPW+ygsz3fyqRZJhTvyqx46pealcWAKL2du1da+ssUQw
+CxAhRMHM2QTINbJUFTyV33Jy+VqPmNyU1pEn8ktwbLMr/wjvz9C+2Jj9WRLEvHKY
+6Qsjfer/JdafnJQRTkfIF2LIjh4sW9hLayXLFharrdvo1Ov32UUF3gOBhQACgYEA
+i1yV1mpbLVnKgswtwXNhXdDzS9TZoVdZyQNTvE8RGyNKebEi68pJkYKlllfpepaf
+TNx2274BkZVm7UU6lX+DRxySkaLYAK1nZcsZnYh0yTRxOtlObNc8EvHLmAGQ7UKK
+MiMbLZ3kHiiMj28B/m5Nz6pjXmp6XUrNe4+DM/7MAGYwCwYJYIZIAWUDBAMCAzAA
+MC0CFQCvM7xt2Yzh/5hKwFXTzNWhTfaeNgIUM3mu1O1fK1s2V+TTIKx3KIvVm8I=
+-----END CERTIFICATE-----
diff --git a/test/assets/jim-openssh.pub b/test/assets/jim-openssh.pub
new file mode 100644
index 0000000..0038023
--- /dev/null
+++ b/test/assets/jim-openssh.pub
@@ -0,0 +1 @@
+ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgjP3tdayWI31bxhQEtB/QwEdVPw0a4T8OKM1/ZNVpptMAAAADAQABAAAAgQDVml3YDVqimFyVgK8rgEEitA++Gq67rXqvKV40V5GlT7OGQL+i0zrX8ikLR8IpCvVcs37F78KohF9wDj854nkcUCbNh0Jihor3I5aYlpvEFlO4S8njVw9KOrY+L9/0ALRAK6UO96gTwROW5o/8gtyDxUJxEF2DiWzegumQJW1SNwAAAAAAAAAAAAAAAgAAAAZqaW1rZXkAAAALAAAAB2ppbS5jb20AAAAAV5Fv1AAAAABZcVI2AAAAAAAAAAAAAAAAAAAAlwAAAAdzc2gtcnNhAAAAAwEAAQAAAIEA1Zpd2A1aophclYCvK4BBIrQPvhquu616ryleNFeRpU+zhkC/otM61/IpC0fCKQr1XLN+xe/CqIRfcA4/OeJ5HFAmzYdCYoaK9yOWmJabxBZTuEvJ41cPSjq2Pi/f9AC0QCulDveoE8ETluaP/ILcg8VCcRBdg4ls3oLpkCVtUjcAAACPAAAAB3NzaC1yc2EAAACAASHTzs/SOITFA9bhATC751bYIaJbg0u7xbP+RaFfczDMbnYTB2fD3ddjjJy/HlEdZ0Jb4y1och2n7FEPzxY/vmZNh7dFDc7Ii8NMcDEdkk5Vg7wXijJFtQtPlyaWdNpaJSqD+mV0/WuAgcQo/5o6oyz5l132JWuqM162aU/28vg= id_rsa
diff --git a/test/assets/jim-x509.pem b/test/assets/jim-x509.pem
new file mode 100644
index 0000000..194d1e0
--- /dev/null
+++ b/test/assets/jim-x509.pem
@@ -0,0 +1,12 @@
+-----BEGIN CERTIFICATE-----
+MIIByzCCATQCCQCr/VI8PlLAezANBgkqhkiG9w0BAQUFADAqMRMwEQYKCZImiZPy
+LGQBGRYDamltMRMwEQYKCZImiZPyLGQBGRYDY29tMB4XDTE2MDcyMjAxMDQyNloX
+DTE3MDcyMjAxMDQyNlowKjETMBEGCgmSJomT8ixkARkWA2ppbTETMBEGCgmSJomT
+8ixkARkWA2NvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1Zpd2A1aophc
+lYCvK4BBIrQPvhquu616ryleNFeRpU+zhkC/otM61/IpC0fCKQr1XLN+xe/CqIRf
+cA4/OeJ5HFAmzYdCYoaK9yOWmJabxBZTuEvJ41cPSjq2Pi/f9AC0QCulDveoE8ET
+luaP/ILcg8VCcRBdg4ls3oLpkCVtUjcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQAQ
+U0ekppGXa0IGfo8l4UZWrqBOhDjbrOh2LcSBU0oiHB/pWHAliDy8hqXQA3rr17ir
+cm458oUFupEHvB26yQiO1uNLQcIuXTiGoUA2xcepgjYbZahn1WbYTJuKFtcNxkOV
+sq+Dmj34yvc1Ror4lcqlg5foPE8aH2ONroG2PwM7eQ==
+-----END CERTIFICATE-----
diff --git a/test/certs.js b/test/certs.js
new file mode 100644
index 0000000..3a0168e
--- /dev/null
+++ b/test/certs.js
@@ -0,0 +1,187 @@
+// Copyright 2016 Joyent, Inc.  All rights reserved.
+
+var test = require('tape').test;
+
+var sshpk = require('../lib/index');
+var fs = require('fs');
+var path = require('path');
+var crypto = require('crypto');
+var sinon = require('sinon');
+
+var testDir = path.join(__dirname, 'assets');
+
+var GEORGE_KEY, GEORGE_SSH, GEORGE_X509;
+var BARRY_KEY;
+var JIM_KEY, JIM_SSH, JIM_X509;
+var EC_KEY, EC_KEY2;
+
+test('setup', function (t) {
+	var d = fs.readFileSync(path.join(testDir, 'id_dsa'));
+	GEORGE_KEY = sshpk.parseKey(d);
+	GEORGE_SSH = fs.readFileSync(path.join(testDir, 'george-openssh.pub'));
+	GEORGE_X509 = fs.readFileSync(path.join(testDir, 'george-x509.pem'));
+
+	d = fs.readFileSync(path.join(testDir, 'id_dsa2'));
+	BARRY_KEY = sshpk.parsePrivateKey(d);
+
+	d = fs.readFileSync(path.join(testDir, 'id_rsa'));
+	JIM_KEY = sshpk.parsePrivateKey(d);
+
+	JIM_SSH = fs.readFileSync(path.join(testDir, 'jim-openssh.pub'));
+	JIM_X509 = fs.readFileSync(path.join(testDir, 'jim-x509.pem'));
+
+	d = fs.readFileSync(path.join(testDir, 'id_ecdsa'));
+	EC_KEY = sshpk.parsePrivateKey(d);
+	d = fs.readFileSync(path.join(testDir, 'id_ecdsa2'));
+	EC2_KEY = sshpk.parsePrivateKey(d);
+	t.end();
+});
+
+test('dsa openssh cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(GEORGE_SSH, 'openssh');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(GEORGE_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedBy(GEORGE_KEY));
+	t.ok(!cert.isSignedBy(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-22T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'UID=george');
+	t.strictEqual(cert.subjects[0].type, 'user');
+	t.strictEqual(cert.subjects[0].uid, 'george');
+
+	t.throws(function () {
+		cert.fingerprint();
+	});
+	t.end();
+});
+
+test('dsa x509 cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(GEORGE_X509, 'x509');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(GEORGE_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedBy(GEORGE_KEY));
+	t.ok(!cert.isSignedBy(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-22T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'UID=george');
+	t.strictEqual(cert.subjects[0].type, 'user');
+	t.strictEqual(cert.subjects[0].uid, 'george');
+
+	var fp = sshpk.parseFingerprint(
+	    'SHA256:7bVAsKO50z85gMJbxczOvEuZvtQ/dWlhW6GOk0kA83k',
+	    { type: 'certificate '});
+	t.ok(fp.matches(cert));
+	t.end();
+});
+
+/*test('create dsa self-signed, loopback', function (t) {
+	var id = sshpk.Identity.forHost('foobar.com');
+	var cert = sshpk.Certificate.createSelfSigned(id, BARRY_KEY);
+
+	var x509 = cert.toBuffer('x509');
+	var cert2 = sshpk.parseCertificate(x509, 'x509');
+	t.ok(BARRY_KEY.fingerprint().matches(cert2.subjectKey));
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(BARRY_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+
+	t.end();
+});*/
+
+test('rsa openssh cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(JIM_SSH, 'openssh');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(JIM_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedBy(JIM_KEY));
+	t.ok(!cert.isSignedBy(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-23T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'CN=jim.com');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'jim.com');
+
+	t.ok(cert.issuer.equals(cert.subjects[0]));
+
+	t.end();
+});
+
+test('rsa x509 cert self-signed', function (t) {
+	var cert = sshpk.parseCertificate(JIM_X509, 'x509');
+	t.ok(sshpk.Certificate.isCertificate(cert));
+
+	t.ok(JIM_KEY.fingerprint().matches(cert.subjectKey));
+	t.ok(cert.isSignedBy(JIM_KEY));
+	t.ok(!cert.isSignedBy(BARRY_KEY));
+
+	t.ok(!cert.isExpired(new Date('2016-07-23T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2001-07-01T00:00:00Z')));
+	t.ok(cert.isExpired(new Date('2017-07-23T00:00:00Z')));
+
+	t.strictEqual(cert.subjects.length, 1);
+	t.strictEqual(cert.subjects[0].toString(), 'DC=jim, DC=com');
+	t.strictEqual(cert.subjects[0].type, 'host');
+	t.strictEqual(cert.subjects[0].hostname, 'jim.com');
+
+	t.ok(cert.issuer.equals(cert.subjects[0]));
+	t.ok(cert.isSignedBy(cert));
+
+	t.end();
+});
+
+test('create rsa self-signed, loopback', function (t) {
+	var id = sshpk.Identity.forHost('foobar.com');
+	var cert = sshpk.Certificate.createSelfSigned(id, JIM_KEY);
+
+	var x509 = cert.toBuffer('x509');
+	var cert2 = sshpk.parseCertificate(x509, 'x509');
+	t.ok(JIM_KEY.fingerprint().matches(cert2.subjectKey));
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(JIM_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+	t.strictEqual(cert3.subjects[0].hostname, 'foobar.com');
+
+	t.end();
+});
+
+test('create ecdsa signed, loopback', function (t) {
+	var id = sshpk.Identity.forUser('jim');
+	var ca = sshpk.Identity.forHost('foobar.com');
+	var cacert = sshpk.Certificate.createSelfSigned(ca, EC2_KEY);
+	var cert = sshpk.Certificate.create(id, EC_KEY, ca, EC2_KEY);
+
+	var x509 = cert.toBuffer('x509');
+	var cert2 = sshpk.parseCertificate(x509, 'x509');
+	t.ok(EC_KEY.fingerprint().matches(cert2.subjectKey));
+	t.ok(cert2.subjects[0].equals(cert.subjects[0]));
+	t.ok(cert2.isSignedBy(cacert));
+
+	var ossh = cert.toBuffer('openssh');
+	var cert3 = sshpk.parseCertificate(ossh, 'openssh');
+	t.ok(EC_KEY.fingerprint().matches(cert3.subjectKey));
+	t.ok(cert3.subjects[0].equals(cert.subjects[0]));
+	t.strictEqual(cert3.subjects[0].uid, 'jim');
+	t.ok(cert3.isSignedBy(cacert));
+
+	t.end();
+});
diff --git a/test/signature.js b/test/signature.js
index eff2d60..6c82d37 100644
--- a/test/signature.js
+++ b/test/signature.js
@@ -112,6 +112,54 @@ test('convert SSH DSA sig and verify', function(t) {
 	t.end();
 });
 
+test('sign with DSA and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_dsa')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'dsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
+test('sign with RSA and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_rsa')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'rsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
+test('sign with ECDSA-256 and loopback ssh', function(t) {
+	var key = sshpk.parsePrivateKey(
+	    fs.readFileSync(path.join(testDir, 'id_ecdsa2')), 'pem');
+	var signer = key.createSign();
+	signer.update('foobar');
+	var sig = signer.sign();
+
+	var data = sig.toBuffer('ssh');
+	sig = sshpk.parseSignature(data, 'ecdsa', 'ssh');
+
+	var s = key.createVerify();
+	s.update('foobar');
+	t.ok(s.verify(sig));
+	t.end();
+});
+
 test('convert SSH ECDSA-256 sig and verify', function(t) {
 	var key = sshpk.parseKey(
 	    fs.readFileSync(path.join(testDir, 'id_ecdsa2')), 'pem');
