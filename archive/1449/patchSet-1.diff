From 1425e4892bd9277f7c17dff9702bea5589a6f3e0 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Mon, 6 Feb 2017 14:53:18 -0800
Subject: [PATCH] joyent/node-mname#14 name compression is slow

---
 lib/dns-buffer.js | 106 +++++++++++++++++++++++++---------------------
 1 file changed, 58 insertions(+), 48 deletions(-)

diff --git a/lib/dns-buffer.js b/lib/dns-buffer.js
index 08ab3ac..e144d62 100644
--- a/lib/dns-buffer.js
+++ b/lib/dns-buffer.js
@@ -87,40 +87,49 @@ var NAME_STRING = 0x00;
 var NAME_PTR = 0xC0;
 
 DNSBuffer.prototype.readName = function () {
-        var rlen, name = [];
+        var rlen, name = '';
 
-        rlen = this.readUInt8();
+        var off = this._offset;
+        var finalOff;
+
+        rlen = this._buffer.readUInt8(off++);
         while (rlen !== 0x00) {
                 var meta = rlen & NAME_META_MASK;
 
                 if (meta == NAME_STRING) {
-                        assert.ok(this._offset + rlen < this._size,
+                        assert.ok(off + rlen < this._size,
                             'invalid name label length');
-                        var buf = this._buffer.slice(this._offset,
-                            this._offset + rlen);
-                        this._offset += rlen;
-                        name.push(buf.toString('ascii'));
+                        var buf = this._buffer.slice(off,
+                            off + rlen);
+                        off += rlen;
+                        name += buf.toString('ascii') + '.';
 
                 } else if (meta == NAME_PTR) {
-                        var ptr = this.readUInt8();
+                        var ptr = this._buffer.readUInt8(off++);
                         ptr = ptr | ((rlen & ~(0xC0)) << 8);
 
                         assert.ok(ptr < this._size,
                             'invalid label pointer (off end of buf)');
 
-                        var clone = Object.create(this);
-                        clone._offset = ptr;
-                        name.push(clone.readName());
-                        break;
+                        if (finalOff === undefined)
+                                finalOff = off;
+                        off = ptr;
 
                 } else {
                         throw (new Error('Invalid name segment type: ' + meta));
                 }
 
-                rlen = this.readUInt8();
+                rlen = this._buffer.readUInt8(off++);
         }
 
-        return (name.join('.'));
+        if (finalOff === undefined)
+                finalOff = off;
+        this._offset = finalOff;
+
+        if (name.charAt(name.length - 1) === '.')
+                name = name.slice(0, name.length - 1);
+
+        return (name);
 };
 
 DNSBuffer.prototype.writeName = function (name) {
@@ -130,26 +139,35 @@ DNSBuffer.prototype.writeName = function (name) {
                 this.writeUInt8(0);
                 return;
         }
-        var parts = name.split('.');
-        var rparts = parts;
+        if (name.charAt(name.length - 1) === '.')
+                name = name.slice(0, name.length - 1);
+        var maxIdx = name.length;
 
-        var suffix = this._ncache.getSuffix(parts);
-        if (suffix.remainder !== undefined) {
-                rparts = suffix.remainder;
+        var suffix = this._ncache.getSuffix(name);
+        if (suffix.index !== undefined) {
+                maxIdx = suffix.index;
         }
 
         var rlen;
-        while (rparts.length > 0) {
+        var i = -1, j;
+        while (i < maxIdx) {
+                var rem = name.slice(i + 1);
+                var j = name.indexOf('.', i + 1);
+                if (j === -1)
+                        j = name.length;
+                var part = name.slice(i + 1, j);
+                i = j;
+                rlen = part.length;
+
+                if (rlen === 0)
+                        break;
+
                 /* Can only use ptrs to things in the first 0x3fff bytes. */
                 if (this._offset <= 0x3fff)
-                        this._ncache.add(parts, this._offset);
+                        this._ncache.add(rem, this._offset);
 
-                var part = rparts.shift();
-                rlen = part.length;
                 assert.ok(rlen < 64, 'segment "' + part + '" of name "' +
                     name + '" is too long');
-                if (rlen === 0 && rparts.length === 0)
-                        break;
                 this.writeUInt8(rlen);
                 this.write(new Buffer(part, 'ascii'));
         }
@@ -296,33 +314,25 @@ if (Buffer.prototype.readUIntBE !== undefined &&
 
 
 function NameOffsetCache() {
-        this.root = {};
+        this.root = new Map();
 }
 
-NameOffsetCache.prototype.add = function (parts, offset) {
-        var node = this.root;
-        for (var i = parts.length - 1; i >= 0; --i) {
-                if (node[parts[i]] === undefined)
-                        node[parts[i]] = {};
-                node = node[parts[i]];
-        }
-        if (node.offset === undefined)
-                node.offset = offset;
+NameOffsetCache.prototype.add = function (name, offset) {
+        this.root.set(name, offset);
 };
 
-NameOffsetCache.prototype.getSuffix = function (parts) {
-        var node = this.root;
-        var rem = parts.slice();
-        var longest = {};
-        while (rem.length > 0) {
-                var part = rem.pop();
-                if (node[part] === undefined)
-                        break;
-                node = node[part];
-                if (node.offset !== undefined) {
-                        longest.remainder = rem.slice();
-                        longest.offset = node.offset;
+NameOffsetCache.prototype.getSuffix = function (name) {
+        var i = -1;
+        while (i < name.length) {
+                var off = this.root.get(name.slice(i + 1));
+                if (off !== undefined) {
+                        return ({
+                                index: i,
+                                offset: off
+                        });
                 }
+                if ((i = name.indexOf('.', i + 1)) === -1)
+                        break;
         }
-        return (longest);
+        return ({});
 };
-- 
2.21.0

