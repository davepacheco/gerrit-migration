From b421eb860374098217ded8d07d6b7196833ae406 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Tue, 26 Jul 2016 22:37:16 -0700
Subject: [PATCH] HEAD-2315 boot media should use current grub

---
 .gitignore              |   1 +
 Makefile                |  32 +++++-
 tools/images/1gb.fdisk  |   6 +
 tools/images/2gb.fdisk  |   6 +
 tools/images/4gb.fdisk  |   6 +
 tools/images/8gb.fdisk  |   6 +
 tools/images/make_image | 241 ++++++++++++++++++++++++++++++++++++++++
 7 files changed, 297 insertions(+), 1 deletion(-)
 create mode 100644 tools/images/1gb.fdisk
 create mode 100644 tools/images/2gb.fdisk
 create mode 100644 tools/images/4gb.fdisk
 create mode 100644 tools/images/8gb.fdisk
 create mode 100755 tools/images/make_image

diff --git a/.gitignore b/.gitignore
index 93a7d26f..9641c782 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,7 @@
 /projects
 /proto
 /proto.boot
+/proto.images
 /proto.strap
 /log
 /src/*.o
diff --git a/Makefile b/Makefile
index 16797bb4..500967b5 100644
--- a/Makefile
+++ b/Makefile
@@ -8,6 +8,7 @@ STRAP_PROTO =	$(ROOT)/proto.strap
 MPROTO =	$(ROOT)/manifest.d
 BOOT_MPROTO =	$(ROOT)/boot.manifest.d
 BOOT_PROTO =	$(ROOT)/proto.boot
+IMAGES_PROTO =	$(ROOT)/proto.images
 MCPROTO =	$(ROOT)/mancheck.conf.d
 
 # On Darwin/OS X we support running 'make check'
@@ -92,6 +93,12 @@ BOOT_VERSION :=	boot-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
     echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
 BOOT_TARBALL :=	output/$(BOOT_VERSION).tgz
 
+IMAGES_VERSION :=	images-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
+    echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
+IMAGES_TARBALL :=	output/$(IMAGES_VERSION).tgz
+
+IMAGES_SIZES_GB :=	1 2 4 8
+
 TOOLS_TARGETS = \
 	$(MANCHECK) \
 	$(MANCF) \
@@ -124,6 +131,27 @@ $(BOOT_TARBALL): world manifest
 	    $(BOOT_PROTO) $(ROOT)/proto
 	(cd $(BOOT_PROTO) && pfexec gtar czf $(ROOT)/$@ .)
 
+#
+# Create proforma images for use in assembling bootable USB device images.
+# These images are assembled into a sparse tar file which takes up hardly any
+# space, despite the large size of the (mostly blank) images.  This tar file is
+# used by "make coal" and "make usb" in "sdc-headnode.git" to create Triton
+# boot and installation media.
+#
+images: $(IMAGES_SIZES_GB:%=$(IMAGES_PROTO)/%gb.img)
+
+$(IMAGES_PROTO)/%.img: boot tools/images/%.fdisk tools/images/make_image
+	rm -f $@
+	mkdir -p $(IMAGES_PROTO)
+	./tools/images/make_image -s $* -G $(ROOT)/proto \
+	    -F tools/images/$*.fdisk $@
+
+images-tar: $(IMAGES_TARBALL)
+
+$(IMAGES_TARBALL): images
+	cd $(IMAGES_PROTO) && gtar -Scvz --owner=0 --group=0 -f $(ROOT)/$@ \
+	    $(IMAGES_SIZES_GB:%=%gb.img)
+
 #
 # Manifest construction.  There are 5 sources for manifests we need to collect
 # in $(MPROTO) before running the manifest tool.  One each comes from
@@ -335,7 +363,9 @@ clean:
 	(cd $(ROOT) && rm -rf $(PROTO))
 	(cd $(ROOT) && rm -rf $(STRAP_PROTO))
 	(cd $(ROOT) && pfexec rm -rf $(BOOT_PROTO))
-	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO))
+	(cd $(ROOT) && pfexec rm -rf $(IMAGES_PROTO))
+	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO) \
+	    $(IMAGES_PROTO))
 	rm -f tools/cryptpass
 	(cd tools/mancheck && gmake clean)
 	(cd tools/mancf && gmake clean)
diff --git a/tools/images/1gb.fdisk b/tools/images/1gb.fdisk
new file mode 100644
index 00000000..3f7f8993
--- /dev/null
+++ b/tools/images/1gb.fdisk
@@ -0,0 +1,6 @@
+*   12: FDISK_EXT_WIN
+* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
+  12    128  9      34     0       144    63     121     600        1952400
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/2gb.fdisk b/tools/images/2gb.fdisk
new file mode 100644
index 00000000..abb72f0e
--- /dev/null
+++ b/tools/images/2gb.fdisk
@@ -0,0 +1,6 @@
+*   12: FDISK_EXT_WIN
+* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
+  12    128  9      34     0       34     63     243     600        3905400
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/4gb.fdisk b/tools/images/4gb.fdisk
new file mode 100644
index 00000000..f9663cec
--- /dev/null
+++ b/tools/images/4gb.fdisk
@@ -0,0 +1,6 @@
+*   12: FDISK_EXT_WIN
+* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
+  12    128  9      34     0       69     63     486     600        7811400
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/8gb.fdisk b/tools/images/8gb.fdisk
new file mode 100644
index 00000000..67505973
--- /dev/null
+++ b/tools/images/8gb.fdisk
@@ -0,0 +1,6 @@
+*   12: FDISK_EXT_WIN
+* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
+  12    128  9      34     0       149    33     972     600        15624000
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
+  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/make_image b/tools/images/make_image
new file mode 100755
index 00000000..9651b571
--- /dev/null
+++ b/tools/images/make_image
@@ -0,0 +1,241 @@
+#!/bin/bash
+# vim: set ts=8 sts=8 sw=8 noet:
+
+PFEXEC=/bin/pfexec
+GRUB_FILES=(
+	fat_stage1_5
+	iso9660_stage1_5
+	stage1
+	stage2
+	stage2_eltorito
+	ufs_stage1_5
+	zfs_stage1_5
+)
+
+size=
+fdisk_file=
+grub_dir=
+image_file=
+lofi_device=
+lofi_raw=
+mount_point=
+tmp_dir=
+
+function warn
+{
+	local msg="$0: WARNING: $1\\n"
+	shift
+
+	printf "$msg" "$@" 2>&1
+}
+
+function cleanup
+{
+	if [[ -n $mount_point ]]; then
+		if ! $PFEXEC /sbin/umount "$mount_point"; then
+			warn 'could not unmount %s' "$mount_point"
+		fi
+	fi
+
+	if [[ -n $lofi_device ]]; then
+		if ! $PFEXEC /usr/sbin/lofiadm -d "$lofi_device"; then
+			warn 'could not remove lofi device %s' \
+			    "$lofi_device"
+		fi
+	fi
+
+	if [[ -n $tmp_dir ]]; then
+		rm -rf "$tmp_dir"
+	fi
+	if [[ $exit_status -ne 0 && -n $image_file ]]; then
+		rm -f "$image_file"
+	fi
+}
+
+function fatal
+{
+	local msg="$0: ERROR: $1\\n"
+	shift
+
+	printf "$msg" "$@" 2>&1
+
+	cleanup
+	exit 1
+}
+
+#
+# Option parsing:
+#
+while getopts 's:F:G:' a; do
+	case $a in
+	s)
+		case $OPTARG in
+		1gb|2gb|4gb|8gb)
+			size=${OPTARG%gb}
+			;;
+		*)
+			fatal 'unknown size (-s): %s' "$OPTARG"
+			;;
+		esac
+		;;
+	F)
+		if [[ ! -f $OPTARG ]]; then
+			fatal 'fdisk table file not found: %s' "$OPTARG"
+		fi
+		fdisk_file=$OPTARG
+		;;
+	G)
+		if [[ ! -d $OPTARG ]]; then
+			fatal 'grub directory not found: %s' "$OPTARG"
+		fi
+		grub_dir=$OPTARG
+		;;
+	*)
+		fatal 'usage error'
+		exit 1
+		;;
+	esac
+done
+
+shift $(($OPTIND - 1))
+if (( $# != 1 )); then
+	fatal 'missing positional argument'
+	exit 1
+fi
+image_file=$1
+
+if [[ -z $image_file || -z $size || -z $fdisk_file || -z $grub_dir ]]; then
+	fatal 'usage error: must provide all of -s, -F, and -G'
+fi
+
+if [[ -f $image_file ]]; then
+	printf 'image file exists already\n' >&2
+	exit 1
+fi
+
+printf '== create proforma image ========================================\n\n'
+printf '  output file:     %s\n' "$image_file"
+printf '  image size:      %d GB\n' "$size"
+printf '  fdisk template:  %s\n' "$fdisk_file"
+printf '  grub directory:  %s\n' "$grub_dir"
+
+#
+# Create a sparse file of the appropriate size.  This size must match that
+# which was used to create the fdisk(1M) template, and must be the same size or
+# smaller than the target USB drive.
+#
+printf 'create sparse image file\n'
+if ! /usr/sbin/mkfile -n $(( size * 1000000000 )) "$image_file"; then
+	fatal 'could not mkfile'
+fi
+
+#
+# Attach the blank image file to the system as a lofi(7D) device.
+#
+printf 'attach image file as lofi(7D) device\n'
+if ! lofi_device=$($PFEXEC /usr/sbin/lofiadm -a "$image_file"); then
+	fatal 'could not attach image as lofi(7D) device'
+fi
+
+#
+# The lofi(7D) device path is for the emulated block device.  We also need the
+# path to the emulated character device.
+#
+lofi_raw=${lofi_device/#\/dev\/lofi\//\/dev\/rlofi\/}
+printf '  lofi device:     %s\n' "$lofi_device"
+printf '  lofi raw device: %s\n' "$lofi_raw"
+
+if [[ ! -b $lofi_device || ! -c $lofi_raw ]]; then
+	fatal 'could not locate lofi(7D) device paths'
+fi
+
+printf 'create partition table\n'
+if ! $PFEXEC /sbin/fdisk -F "$fdisk_file" "$lofi_raw"; then
+	fatal 'could not make partition table'
+fi
+
+#
+# Create a FAT32 file system on the first partition of the image.  The volume
+# label is set to "HEADNODE".
+#
+printf 'format FAT32 file system\n'
+if ! $PFEXEC /usr/sbin/mkfs -F pcfs -o 'b=HEADNODE,fat=32' "$lofi_raw:c" \
+    </dev/null; then
+	fatal 'could not format FAT32 file system'
+fi
+
+#
+# Create a temporary directory in which to mount the image to avoid conflicting
+# with any other processes.
+#
+if ! tmp_dir=$(mktemp -d); then
+	fatal 'could not create temporary directory'
+fi
+
+mount_point=$tmp_dir/mnt
+if ! mkdir "$mount_point"; then
+	fatal 'could not create mount point directory: %s' "$mount_point"
+fi
+
+#
+# Mount the FAT32 file system from the image with the appropriate mount options.
+#
+printf 'mount FAT32 file system\n'
+if ! $PFEXEC /sbin/mount -F pcfs -o 'foldcase,noatime,hidden,clamptime,rw' \
+    "$lofi_device:c" "$mount_point"; then
+	fatal 'could not mount file system'
+fi
+
+#
+# Create the grub directory within the image.
+#
+if ! mkdir -p "$mount_point/boot/grub"; then
+	fatal 'could not create grub directory within image'
+fi
+
+#
+# Copy each grub file from the build area to the image, and create an empty
+# grub menu file in the appropriate location.
+#
+printf 'copying files:\n'
+for grub_file in ${GRUB_FILES[@]}; do
+	p=boot/grub/$grub_file
+	printf '      copy: %s\n' "$p"
+	if ! /bin/cp "$grub_dir/$p" "$mount_point/$p"; then
+		fatal 'could not copy %s' "$p"
+	fi
+done
+touch "$mount_point/boot/grub/menu.lst"
+
+#
+# Unmount the image now, so that we can use the grub shell without upsetting
+# the kernel.  Unset the "mount_point" variable so that cleanup does not try
+# to unmount a second time.
+#
+printf 'unmounting image\n'
+if ! $PFEXEC /sbin/umount "$mount_point"; then
+	fatal 'could not unmount image file system'
+fi
+unset mount_point
+
+#
+# Now that the file system is unmounted, use the grub command to install the
+# boot block within the MBR and embed the appropriate stage1_5.
+#
+printf 'installing grub\n'
+$PFEXEC "$grub_dir/boot/grub/bin/grub" --batch <<EOFGRUB
+device (hd0) $lofi_raw
+root (hd0,0)
+setup (hd0)
+quit
+EOFGRUB
+if [[ $? -ne 0 ]]; then
+	fatal 'failed to install grub'
+fi
+
+#
+# The image was successfully created.  Clean up all of our resources.
+#
+cleanup
+printf '\n'
+exit 0
-- 
2.21.0

