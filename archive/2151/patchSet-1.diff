From 66b1ad159e745c3a8bd96c1c288ffec86930882c Mon Sep 17 00:00:00 2001
From: Sean Chittenden <sean@chittenden.org>
Date: Sat, 24 Jun 2017 19:29:02 -0700
Subject: [PATCH] MANTA-3325: Improve the performance of mako_gc

I missed my goal of knocking this out over the course of two episodes
of Dinosaur Train this afternoon, but was close enough to declare
success at a round of Effectiveness Golf.  I'm not wild about the
structure but it's a close approximation of the shell script that was
there previously and the log lines/output should be compatible.  The
DeleteObject calls should be concurrent, too, but I'm leaving that as an
exercise for the reader.

Also left as an exercise to the reader is testing this.  It compiles.
This is far from how I'd suggest or condone writing a Go CLI app,
but it's a start and certainly going to be more productive than
seeing mako_gc rewritten in C.
---
 bin/.gitignore |   1 +
 bin/mako_gc.go | 619 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 620 insertions(+)
 create mode 100644 bin/.gitignore
 create mode 100755 bin/mako_gc.go

diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..0efd413
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1 @@
+mako_gc
diff --git a/bin/mako_gc.go b/bin/mako_gc.go
new file mode 100755
index 0000000..6925987
--- /dev/null
+++ b/bin/mako_gc.go
@@ -0,0 +1,619 @@
+// mako_gc cleans manta objects by first sucking down all files under:
+//
+// /manta_gc/mako/$MANTA_STORAGE_ID
+//
+// Which come in the following format:
+//
+//   mako + \t + mantaStorageId + \t + ownerId + \t + objectId
+//
+// Since manta objects are kept under /manta/ownerId/objectId, the ids are taken
+// from the lines in the file and used to find and unlink the objects on the
+// local filesystem.  When it is done it deletes the file in manta.
+
+package main
+
+import (
+	"bufio"
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path"
+	"strings"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	manta "github.com/jen20/manta-go"
+	"github.com/jen20/manta-go/authentication"
+	daemon "github.com/sevlyar/go-daemon"
+	"github.com/tidwall/gjson"
+)
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+type AuditLog struct {
+	Audit          bool      `json:"audit,omitempty"`
+	Name           string    `json:"name,omitempty"`
+	Level          int       `json:"level,omitempty"`
+	Error          string    `json:"string,omitempty"`
+	Message        string    `json:"msg,omitempty"`
+	Verbosity      int       `json:"v,omitempty"`
+	Time           time.Time `json:"time,omitempty"`
+	PID            int       `json:"pid,omitempty"`
+	CronExec       int       `json:"cronExec,omitempty"`
+	AlreadyDeleted bool      `json:alreadyDeleted,omitempty"`
+	ObjectID       string    `json:objectId,omitempty"`
+	Tomb           string    `json:tomb,omitempty"`
+	Processed      int       `json:tomb,omitempty"`
+	Hostname       string    `json:"hostname,omitempty"`
+	FileCount      uint64    `json:"fileCount,omitempty"`
+	ObjectCount    uint64    `json:"objectCount,omitempty"`
+	CleanCount     uint64    `json:"tombDirCleanupCount,omitempty"`
+}
+
+func auditRaw(r *AuditLog) error {
+	enc := json.NewEncoder(os.Stderr)
+	if err := enc.Encode(r); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func newAuditRecord() *AuditLog {
+	return &AuditLog{
+		Audit:       true,
+		Name:        "mako_gc",
+		Level:       30,
+		Message:     "audit",
+		Time:        time.Now(),
+		PID:         myPID,
+		Hostname:    myHostname,
+		FileCount:   atomic.LoadUint64(&fileCount),
+		ObjectCount: atomic.LoadUint64(&objectCount),
+		CleanCount:  atomic.LoadUint64(&cleanCount),
+	}
+}
+
+func audit() error {
+	auditRecord := AuditLog{
+		Audit:       true,
+		Name:        "mako_gc",
+		Level:       30, // XXX(seanc@): Magic number.  Where's this constant coming from?
+		Error:       auditError.Error(),
+		Message:     "audit",
+		Time:        time.Now(),
+		PID:         myPID,
+		CronExec:    1,
+		Hostname:    myHostname,
+		FileCount:   fileCount,
+		ObjectCount: objectCount,
+		CleanCount:  cleanCount,
+	}
+
+	return auditRaw(&auditRecord)
+}
+
+const (
+	MAKO_GC_PID          = "/tmp/mako_gc.pid"
+	MANTA_GC_CONFIG      = "/opt/smartdc/mako/etc/gc_config.json"
+	MANTA_STORAGE_ID_ENV = "MANTA_STORAGE_ID"
+	MANTA_STORAGE_ID_KEY = "manta_storage_id"
+	SDC_COMMON_CONFIG    = "/opt/smartdc/common/etc/config.json"
+
+	TOMB_ROOT           = "/manta/tombstone"
+	TOMB_DIRS_TO_KEEP   = 21
+	CLEANUP_CONCURRENCY = 8
+)
+
+type MantaConfig struct {
+	ID         string
+	SSHKeyPath string
+	SSHKeyID   string
+	URL        string
+	User       string
+}
+
+func loadConfig() (*MantaConfig, error) {
+	cfg := &MantaConfig{}
+
+	mantaStorageID, err := getConfigAny(MANTA_GC_CONFIG, "MANTA_STORAGE_ID", "manta_storage_id")
+	if err != nil {
+		return nil, err
+	}
+	cfg.ID = mantaStorageID
+
+	mantaURL, err := getConfigAny(MANTA_GC_CONFIG, "MANTA_URL", "manta_url")
+	if err != nil {
+		return nil, err
+	}
+	cfg.URL = mantaURL
+
+	mantaUser, err := getConfigKey(SDC_COMMON_CONFIG, "MANTA_USER", "manta.user")
+	if err != nil {
+		return nil, err
+	}
+	cfg.User = mantaUser
+
+	cfg.SSHKeyPath = getConfigAnyDefault("", "SSH_KEY", "", "/root/.ssh/id_rsa")
+
+	cmd := exec.Command("ssh-keygen", "-l", "-f", fmt.Sprintf("%s.pub", cfg.SSHKeyPath))
+	stdoutStderr, err := cmd.CombinedOutput()
+	if err != nil {
+		return nil, err
+	}
+
+	scanner := bufio.NewScanner(bytes.NewReader(stdoutStderr))
+	scanner.Split(bufio.ScanWords)
+	var count uint
+	for scanner.Scan() {
+		count++
+		if count == 2 {
+			cfg.SSHKeyID = scanner.Text()
+			break
+		}
+	}
+
+	return cfg, nil
+}
+
+// getConfigAny iterates through the entire json document until it finds configKey
+func getConfigAny(configPath, envVar, configKey string) (string, error) {
+	var val string
+	if envVar != "" {
+		var found bool
+		val, found = os.LookupEnv(envVar)
+		if found {
+			return val, nil
+		}
+	}
+
+	if configPath != "" {
+		json, err := ioutil.ReadFile(configPath)
+		if err != nil {
+			return "", err
+		}
+
+		r := gjson.ParseBytes(json)
+		r.ForEach(func(k, v gjson.Result) bool {
+			if k.String() == configKey {
+				val = v.String()
+				return false // terminate search
+			}
+
+			return true // keep searching
+		})
+	}
+
+	if val == "" {
+		return "", fmt.Errorf("unable to find %s in the config or environment variable %s", configKey, envVar)
+	}
+
+	return val, nil
+}
+
+// getConfigAnyDefault is a wrapper around getConfigAny()
+func getConfigAnyDefault(configPath, envVar, configKey, defaultValue string) string {
+	v, err := getConfigAny(configPath, envVar, configKey)
+	if err != nil {
+		return defaultValue
+	}
+
+	return v
+}
+
+// getConfigKey looks up a specific JSON key
+func getConfigKey(configPath, envVar, configKey string) (string, error) {
+	var val string
+	if envVar != "" {
+		var found bool
+		val, found = os.LookupEnv(envVar)
+		if found {
+			return val, nil
+		}
+	}
+
+	if configPath != "" {
+		json, err := ioutil.ReadFile(configPath)
+		if err != nil {
+			return "", err
+		}
+
+		r := gjson.ParseBytes(json).Get(configKey)
+		val = r.String()
+	}
+
+	if val == "" {
+		return "", fmt.Errorf("unable to find %s in the config or environment variable %s", configKey, envVar)
+	}
+
+	return val, nil
+}
+
+// Aggregate all process-wide variables into a single place
+var (
+	auditError error
+	myHostname string
+	myPID      int         = os.Getpid()
+	pidMode    os.FileMode = 0644
+
+	TOMB_DIR string
+	tombMode os.FileMode = 0755
+
+	// Atomically updated counters
+	fileCount   uint64
+	objectCount uint64
+	cleanCount  uint64
+)
+
+type LogLevel int
+
+func (l LogLevel) String() string {
+	switch l {
+	case INFO:
+		return "info"
+	case FATAL:
+		return "fatal"
+	default:
+		return fmt.Sprintf("<unknown %d>", l)
+	}
+}
+
+const (
+	INFO LogLevel = iota
+	FATAL
+)
+
+func log(level LogLevel, msg string) {
+	now := time.Now()
+	fmt.Fprintf(os.Stderr, "%s: %s (%d): %s: %s\n", now.Format(time.RFC3339), os.Args[0], myPID, level, msg)
+}
+
+func main() {
+	os.Exit(realMain())
+}
+
+func realMain() int {
+	{
+		var err error
+		myHostname, err = os.Hostname()
+		if err != nil {
+			log(FATAL, "unable to determine hostname")
+			return 1
+		}
+	}
+
+	{
+		now := time.Now()
+		now.Format("2006-01-02")
+		TOMB_DIR = fmt.Sprintf("%s/%s", TOMB_ROOT, now)
+	}
+
+	pidFile, err := daemon.CreatePidFile(MAKO_GC_PID, pidMode)
+	if err != nil {
+		fmt.Printf("%s process still running. Exiting...\n", os.Args[0])
+		return 1
+	}
+	defer pidFile.Remove()
+
+	cfg, err := loadConfig()
+	if err != nil {
+		log(FATAL, err.Error())
+		return 1
+	}
+
+	log(INFO, "starting gc")
+
+	sshKeySigner, err := authentication.NewSSHAgentSigner(cfg.SSHKeyID, "mako_gc")
+	if err != nil {
+		log(FATAL, err.Error())
+		return 1
+	}
+
+	client, err := manta.NewClient(&manta.ClientOptions{
+		Endpoint:    cfg.URL,
+		AccountName: cfg.User,
+		Signers:     []authentication.Signer{sshKeySigner},
+	})
+	if err != nil {
+		log(FATAL, err.Error())
+		return 1
+	}
+
+	// Unconditionally call audit
+	defer audit()
+
+	mpath := fmt.Sprintf("/manta_gc/mako/%s", cfg.ID)
+	if ready, soft, err := verifyGC(client, mpath); !ready {
+		if soft {
+			log(INFO, fmt.Sprintf("GC not ready yet: %s %s", mpath, err.Error()))
+			return 0
+		}
+
+		log(FATAL, fmt.Sprintf("GC not ready yet: %s %s", mpath, err.Error()))
+		return 1
+	}
+
+	if err := createTombDirs(); err != nil {
+		log(FATAL, fmt.Sprintf("createTombDirs: %v", err))
+		return 1
+	}
+
+	// Begin reading from stdin, newline encoded JSON objects
+	scanner := bufio.NewScanner(os.Stdin)
+	for scanner.Scan() {
+		line := scanner.Bytes()
+		r := gjson.ParseBytes(line)
+		var file string
+		r.ForEach(func(k, v gjson.Result) bool {
+			if k.String() == "name" {
+				file = v.String()
+				return false // terminate search
+			}
+			return true // keep searching
+		})
+
+		mfile := path.Join(mpath, file)
+		output, err := client.GetObject(&manta.GetObjectInput{
+			ObjectPath: mfile,
+		})
+		if err != nil {
+			log(FATAL, err.Error())
+			return 1
+		}
+		defer output.ObjectReader.Close()
+
+		lineScanner := bufio.NewScanner(output.ObjectReader)
+		for lineScanner.Scan() {
+			line := lineScanner.Text()
+			arr := strings.Fields(line)
+			if len(arr) != 4 {
+				log(INFO, fmt.Sprintf("unable to parse line %q", line))
+				continue
+			}
+
+			if arr[1] != cfg.ID {
+				continue
+			}
+
+			log(INFO, fmt.Sprintf("Processing %q", line))
+
+			ownerID := arr[2]
+			objectID := arr[3]
+
+			objectPath := path.Join("/manta", ownerID, objectID)
+			fi, err := os.Stat(objectPath)
+			if err != nil || !fi.Mode().IsRegular() {
+				rec := newAuditRecord()
+				rec.AlreadyDeleted = true
+				rec.ObjectID = objectID
+				rec.Tomb = TOMB_DIR
+				rec.Processed = 1
+				auditRaw(rec)
+				continue
+			}
+
+			{
+				rec := newAuditRecord()
+				rec.AlreadyDeleted = false
+				rec.ObjectID = objectID
+				rec.Tomb = TOMB_DIR
+				rec.Processed = 1
+				auditRaw(rec)
+			}
+
+			if err := CopyFile(objectPath, path.Join(TOMB_DIR, objectID)); err != nil {
+				log(FATAL, fmt.Sprintf("unable to copy %q: %s", objectID, err))
+				return 1
+			}
+
+			if err := os.Remove(objectPath); err != nil {
+				log(FATAL, fmt.Sprintf("unable to remove %q: %s", objectPath, err))
+				return 1
+			}
+
+			atomic.AddUint64(&objectCount, 1)
+		}
+
+		err = client.DeleteObject(&manta.DeleteObjectInput{
+			ObjectPath: mfile,
+		})
+		if err != nil {
+			log(FATAL, fmt.Sprintf("Unable to delete %q", mfile))
+			return 1
+		}
+		atomic.AddUint64(&fileCount, 1)
+	}
+	if err := scanner.Err(); err != nil {
+		fmt.Fprintln(os.Stderr, "reading standard input:", err)
+	}
+
+	if err := cleanupOldDirectories(); err != nil {
+		log(FATAL, fmt.Sprintf("error cleaning up directories: %v", err))
+		return 1
+	}
+
+	return 0
+}
+
+// cleanupOldDirectories removes directories scheduled for deletion.
+func cleanupOldDirectories() error {
+	log(INFO, "starting tombstone directory cleanup")
+
+	// ReadDir reads the directory named by dirname and returns a list of
+	// directory entries sorted by filename.  Perform the ReadDir() before
+	// initializing the workers in order to simplify the error handling code.
+	files, err := ioutil.ReadDir(TOMB_ROOT)
+	if err != nil {
+		return err
+	}
+
+	var waitGroup sync.WaitGroup
+	cleanupChan := make(chan string)
+
+	// Cleanup functor
+	var workerLock sync.Mutex
+	workerErr := make([]error, 0, CLEANUP_CONCURRENCY)
+
+	removeWorker := func() {
+		defer func() {
+			waitGroup.Done()
+		}()
+
+		for {
+			dir, ok := <-cleanupChan
+			if !ok {
+				break
+			}
+
+			log(INFO, fmt.Sprintf("cleaning up %s", dir))
+			if err := os.RemoveAll(dir); err != nil {
+				workerLock.Lock()
+				workerErr = append(workerErr, err)
+				workerLock.Unlock()
+				return
+			}
+
+			atomic.AddUint64(&cleanCount, 1)
+		}
+	}
+
+	// Spin up the necessary worker threads
+	for i := 0; i < CLEANUP_CONCURRENCY; i++ {
+		waitGroup.Add(1)
+		go removeWorker()
+	}
+
+	// Only iterate over the first TOMB_DIRS_TO_KEEP entries
+	if len(files) > 0 {
+		files = files[0:TOMB_DIRS_TO_KEEP]
+	}
+
+	for _, tombStoneDir := range files {
+		fullPath := path.Join(TOMB_ROOT, tombStoneDir.Name())
+		cleanupChan <- fullPath
+	}
+
+	close(cleanupChan)
+	waitGroup.Wait()
+
+	// Return the first error for now
+	if len(workerErr) > 0 {
+		return workerErr[0]
+	}
+
+	return nil
+}
+
+func createTombDirs() error {
+	fi, err := os.Stat(TOMB_DIR)
+	if err == nil && !fi.Mode().IsDir() {
+		return fmt.Errorf("%s exists but is not a directory: %v", TOMB_DIR)
+	} else {
+		if err := os.MkdirAll(TOMB_DIR, tombMode); err != nil {
+			return err
+		}
+	}
+
+	// Avoid requiring cgo.  The pam and libc rage is real.
+	cmd := exec.Command("chown", "nobody:nobody", TOMB_ROOT, TOMB_DIR)
+	if err := cmd.Run(); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// verifyGC returns nil if we can run the GC.
+//
+// NOTE(seanc@): I dislike this function signature.
+func verifyGC(client *manta.Client, mpath string) (ready, softFail bool, err error) {
+	output, err := client.GetObject(&manta.GetObjectInput{
+		ObjectPath: mpath,
+	})
+	if err != nil {
+		if mantaError, ok := err.(manta.MantaError); ok && mantaError.StatusCode == 404 {
+			return false, true, err
+		}
+		return false, false, err
+	}
+
+	// Copy and close as fast as possible
+	io.Copy(ioutil.Discard, output.ObjectReader)
+	output.ObjectReader.Close()
+
+	return true, false, nil
+}
+
+// Copy and pasted from:
+// https://stackoverflow.com/questions/21060945/simple-way-to-copy-a-file-in-golang
+
+// CopyFile copies a file from src to dst. If src and dst files exist, and are
+// the same, then return success. Otherise, attempt to create a hard link
+// between the two files. If that fail, copy the file contents from src to dst.
+func CopyFile(src, dst string) (err error) {
+	sfi, err := os.Stat(src)
+	if err != nil {
+		return
+	}
+	if !sfi.Mode().IsRegular() {
+		// cannot copy non-regular files (e.g., directories, symlinks, devices,
+		// etc.)
+		return fmt.Errorf("CopyFile: non-regular source file %s (%q)", sfi.Name(), sfi.Mode().String())
+	}
+	dfi, err := os.Stat(dst)
+	if err != nil {
+		if !os.IsNotExist(err) {
+			return
+		}
+	} else {
+		if !(dfi.Mode().IsRegular()) {
+			return fmt.Errorf("CopyFile: non-regular destination file %s (%q)", dfi.Name(), dfi.Mode().String())
+		}
+		if os.SameFile(sfi, dfi) {
+			return
+		}
+	}
+	if err = os.Link(src, dst); err == nil {
+		return
+	}
+	err = copyFileContents(src, dst)
+	return
+}
+
+// copyFileContents copies the contents of the file named src to the file named
+// by dst. The file will be created if it does not already exist. If the
+// destination file exists, all it's contents will be replaced by the contents
+// of the source file.
+func copyFileContents(src, dst string) (err error) {
+	in, err := os.Open(src)
+	if err != nil {
+		return
+	}
+	defer in.Close()
+	out, err := os.Create(dst)
+	if err != nil {
+		return
+	}
+	defer func() {
+		cerr := out.Close()
+		if err == nil {
+			err = cerr
+		}
+	}()
+	if _, err = io.Copy(out, in); err != nil {
+		return
+	}
+	err = out.Sync()
+	return
+}
-- 
2.21.0

