From 3a643852e3308ed9c47b2499adf00de5ec61061c Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Tue, 13 Aug 2019 20:38:42 +0000
Subject: [PATCH] OS-7928 KVM %gs reload needs to prevent FBT Reviewed by:
 Robert Mustacchi <rm@joyent.com> Reviewed by: Dan McDonald
 <danmcd@joyent.com> Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
 Approved by: Patrick Mooney <patrick.mooney@joyent.com>

---
 kvm_vmx.c | 19 +++++++------------
 kvm_x86.c |  8 ++++++--
 2 files changed, 13 insertions(+), 14 deletions(-)

diff --git a/kvm_vmx.c b/kvm_vmx.c
index ed1ec21..fe5109a 100644
--- a/kvm_vmx.c
+++ b/kvm_vmx.c
@@ -13,7 +13,7 @@
  * This work is licensed under the terms of the GNU GPL, version 2.  See
  * the COPYING file in the top-level directory.
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/sysmacros.h>
@@ -776,17 +776,12 @@ __vmx_load_host_state(struct vcpu_vmx *vmx)
 
 		kvm_load_ldt(vmx->host_state.ldt_sel);
 		/*
-		 * If we have to reload GS, we must take care to preserve our
-		 * GSBASE.  Note that between the kvm_load_gs() and the
-		 * completion of writing the MSR, GS is essentially in a
-		 * corrupt state -- we cannot allow code to be revectored
-		 * in this window.  In particular, this means that we not
-		 * hit a DTrace probe in this window (which will need the
-		 * intact GS to get to the CPU pointer).  Both kvm_load_gs()
-		 * and wrmsrl() turn into inlines or non-instrumentable
-		 * leaf routines, but vmcs_readl() has an SDT probe -- so we
-		 * call vmcs_readl() to get the HOST_GS_BASE before the call
-		 * to kvm_load_gs().
+		 * Reloading %gs effectively zeroes the upper 32 bits of the gs
+		 * base, so we need to restore our own value after the load. As
+		 * %gs is essentially corrupt in between this load and the
+		 * update of gsbase, then, we must be careful not to take an FBT
+		 * trap. We do this by marking the two functions as untraceable:
+		 * they have a dtrace_ prefix, which DTrace knows to ignore.
 		 */
 		cli();
 		gsbase = vmcs_readl(HOST_GS_BASE);
diff --git a/kvm_x86.c b/kvm_x86.c
index 31e54e4..97e4c4b 100644
--- a/kvm_x86.c
+++ b/kvm_x86.c
@@ -5062,8 +5062,10 @@ native_read_msr(unsigned int msr)
 	return (EAX_EDX_VAL(val, low, high));
 }
 
+/* See __vmx_load_host_state(). */
+#pragma weak native_write_msr = dtrace_native_write_msr
 void
-native_write_msr(unsigned int msr, unsigned low, unsigned high)
+dtrace_native_write_msr(unsigned int msr, unsigned low, unsigned high)
 {
 	__asm__ volatile("wrmsr" : : "c" (msr),
 	    "a"(low), "d" (high) : "memory");
@@ -5185,8 +5187,10 @@ kvm_load_fs(unsigned short sel)
 	__asm__("mov %0, %%fs" : : "rm"(sel));
 }
 
+/* See __vmx_load_host_state(). */
+#pragma weak kvm_load_gs = dtrace_kvm_load_gs
 void
-kvm_load_gs(unsigned short sel)
+dtrace_kvm_load_gs(unsigned short sel)
 {
 	__asm__("mov %0, %%gs" : : "rm"(sel));
 }
-- 
2.21.0

