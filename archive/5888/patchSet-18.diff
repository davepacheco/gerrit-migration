commit a3725e0694a21a61586279a9d46622a98ef8d5ba
Author: Jon Anderson <jon.anderson@joyent.com>
Date:   2019-05-08T13:48:45+00:00 (5 months ago)
    
    MANTA-4133 Invalid content-type resulted in 500 response

diff --git a/lib/server.js b/lib/server.js
index e0f3c31..9abba41 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -42,9 +42,14 @@ require('./errors');
 ///--- Globals
 
 var JOBS_ROOT_RE = /^\/([a-zA-Z][a-zA-Z0-9_\.@%]+)\/jobs\/?$/;
-/* JSSTYLED */
+/* BEGIN JSSTYLED */
 var JOBS_LIVE_RE = /(state|status|name)=/i;
-
+/*
+ * from https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
+ * match 'type/subtype' where subtypes can be +/- delimited
+ */
+var VALID_CONTENT_TYPE_RE = /.+\/.+/;
+/* END JSSTYLED */
 
 ///--- Helpers
 
@@ -194,9 +199,14 @@ function createServer(options, clients, name) {
     server.pre(restify.pre.sanitizePath());
     server.pre(function cleanupContentType(req, res, next) {
         var ct = req.headers['content-type'];
-        /* JSSTYLED */
-        if (ct && !/.*\/.*/.test(ct))
+        /*
+         * content-type must have a type, '/' and sub-type
+         */
+        if (ct && !VALID_CONTENT_TYPE_RE.test(ct)) {
+            req.log.debug('receieved a malformed content-type: %s', ct);
             req.headers['content-type'] = mime.lookup(ct);
+        }
+
         next();
     });
 
@@ -501,7 +511,6 @@ function forbiddenHandler(req, res, next) {
 }
 
 
-
 /*
  * This adds the routes for the majority of multipart upload API endpoints,
  * including:
diff --git a/test/obj.test.js b/test/obj.test.js
index c8ae95a..a510e07 100644
--- a/test/obj.test.js
+++ b/test/obj.test.js
@@ -177,7 +177,6 @@ test('put/get zero bytes', function (t) {
     });
 });
 
-
 test('put streaming object', function (t) {
     var self = this;
     var stream = new MemoryStream();
@@ -345,6 +344,7 @@ test('chattr: content-type', function (t) {
 });
 
 
+
 test('chattr: durability-level (not ok)', function (t) {
     var opts = {
         headers: {
@@ -1116,7 +1116,6 @@ test('Put-Get content-disposition cleaned', function (t) {
     });
 });
 
-
 test('streaming object valid content-disposition',
      function (t) {
          var stream = new MemoryStream();
@@ -1136,7 +1135,6 @@ test('streaming object valid content-disposition',
          });
      });
 
-
 test('streaming object invalid content-disposition',
      function (t) {
          var stream = new MemoryStream();
@@ -1201,3 +1199,182 @@ test('chattr invalid content-disposition',
              });
          });
      });
+
+// content-type tests
+
+/*
+ * Verify that a write with unknown content-type with a valid format succeeds
+ * and server returns valid content-type on read of the same object.
+ */
+test('MANTA-4133 (non-existent content-type)', function (t) {
+    var self = this;
+    var opts = {
+        headers: {
+            'content-type': 'argle/'
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'application/octet-stream');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write with a valid content-type with a valid format succeeds
+ * and server returns valid content-type on read of the same object.
+ */
+test('MANTA-4133 (verify valid json content-type)', function (t) {
+    var self = this;
+
+    var opts = {
+        headers: {
+            'content-type': 'application/json'
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.get(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'application/json');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write with an malformed content-type succeeds
+ * and server returns valid content-type on read of the same object.
+ */
+test('MANTA-4133 (malformed content-type)', function (t) {
+    var self = this;
+    var opts = {
+        headers: {
+            'content-type': '/*'
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'application/octet-stream');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write with an empty content-type succeeds and server
+ * returns valid content-type on read of the same object.
+ * Note: the change in 4133 should detect the absent content-type. The lookup
+ * should fail and return 'application/octet-stream', the default.
+ * The server returns 'text/plain' with the response as before.
+ */
+test('MANTA-4133 (empty content-type)', function (t) {
+    var self = this;
+    var opts = {
+        headers: {
+            'content-type': ''
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'text/plain');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write with a valid content-type with a valid format succeeds
+ * and server returns valid content-type on read of the same object.
+ */
+test('MANTA-4133 (verify valid plain text content-type)', function (t) {
+    var self = this;
+
+    var opts = {
+        headers: {
+            'content-type': 'text/plain'
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'text/plain');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write with unknown content-type with a valid format succeeds
+ * and server returns valid content-type on read of the same object.
+ */
+test('MANTA-4133 (verify non-existent utf-8 content-type)', function (t) {
+    var self = this;
+    var encoded = '%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94';
+    var ct_utf8 = unescape(encoded);
+
+    var opts = {
+        headers: {
+            'content-type': ct_utf8
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'application/octet-stream');
+            t.end();
+        });
+    });
+});
+
+/*
+ * Verify that a write properly formed content-type with a valid format succeeds
+ * and server returns the content-type on read of the same object.
+ */
+test('MANTA-4133 (verify a conforming content-type)', function (t) {
+    var self = this;
+
+    var opts = {
+        headers: {
+            'content-type': 'audio/mpeg'
+        }
+    };
+
+    writeObject(self.client, self.key, opts, function (err, res) {
+        t.ifError(err);
+        t.checkResponse(res, 204);
+        self.client.info(self.key, function (err2, stream, res2) {
+            t.ifError(err2);
+            t.checkResponse(res2, 200);
+            t.equal(res2.headers['content-type'], 'audio/mpeg');
+            t.end();
+        });
+    });
+});
