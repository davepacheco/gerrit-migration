From 2011228e6579a355b35d4aa4f0e4b5ed4a37fbc4 Mon Sep 17 00:00:00 2001
From: Tim Kordas <tim.kordas@joyent.com>
Date: Mon, 7 Aug 2017 09:32:11 -0700
Subject: [PATCH] joyent/node-mname#21 support for sig0 signatures in addition
 to tsig ?

---
 README.md         |  25 ++++
 lib/protocol.js   |  75 +++++++++++
 lib/query.js      |  72 ++++++++---
 lib/sig0.js       | 224 ++++++++++++++++++++++++++++++++
 test/sig0.test.js | 320 ++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 698 insertions(+), 18 deletions(-)
 create mode 100644 lib/sig0.js
 create mode 100644 test/sig0.test.js

diff --git a/README.md b/README.md
index 5b9962e..356b4f9 100644
--- a/README.md
+++ b/README.md
@@ -79,3 +79,28 @@ or were never implemented. This server aims to be RFC compliant, but does not
 implement any other protocol other than INET (the one we're all used to), and
 only supports a handful of record types (the ones that are in use on a regular
 basis).
+
+## Signatures over requests/responses
+
+Two schemes are supported:
+
+ * TSIG (symmetric HMAC key, shared between server and client)
+ * SIG0 (asymmetric, separate signing keys by server and client)
+
+Both schemes have tests which also serve as examples for use of the Signatures.
+
+In addition to internal tests, it is possible to verify implementations by
+using other implementations to issue requests. Perl's Net::DNS::SEC module
+supports TSIG and SIG0. A sig0 test using Bind's nsupdate as a client
+against a server running on 127.0.0.1:9999 might look like:
+
+```
+dnssec-keygen -T KEY -a rsasha1 -b 1024 -n USER testclient
+nsupdate -k Ktestclient.+005+*.private << EOF
+debug
+server 127.0.0.1 9999
+update add www1.example.com 86400 a 10.1.1.1
+show
+send
+EOF
+```
diff --git a/lib/protocol.js b/lib/protocol.js
index 0357913..84f0463 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -235,6 +235,60 @@ DNSProtoBuffer.prototype.writeTSIGSignTCP = function (v, ctx) {
         this.writeUInt16(v.fudge);
 };
 
+DNSProtoBuffer.prototype.readSIG0 = function (ctx) {
+        var r = {};
+        r.typecovered = this.readUInt16();
+        r.algorithm = this.readUInt8();
+        r.labels = this.readUInt8();
+        r.originalttl = this.readUInt32();
+        r.expiration = this.readUInt32();
+        r.inception = this.readUInt32();
+        r.keytag = this.readUInt16();
+        r.signername = this.readName();
+        r.signature = this.remainder();
+        return (r);
+};
+
+DNSProtoBuffer.prototype.writeSIG0 = function (v, ctx) {
+        assert.object(v, 'sig0');
+        this.writeUInt16(v.typecovered);
+        this.writeUInt8(v.algorithm);
+        this.writeUInt8(v.labels);
+        this.writeUInt32(v.originalttl);
+        this.writeUInt32(v.expiration);
+        this.writeUInt32(v.inception);
+        this.writeUInt16(v.keytag);
+        this.writeNamePlain(v.signername);
+        this.write(v.signature);
+};
+
+DNSProtoBuffer.prototype.writeSIG0SignData = function (v, ctx) {
+        assert.object(v, 'sig0SignData');
+        this.writeUInt16(v.rdata.typecovered);
+        this.writeUInt8(v.rdata.algorithm);
+        this.writeUInt8(v.rdata.labels);
+        this.writeUInt32(v.rdata.originalttl);
+        this.writeUInt32(v.rdata.expiration);
+        this.writeUInt32(v.rdata.inception);
+        this.writeUInt16(v.rdata.keytag);
+        this.writeNamePlain(v.rdata.signername);
+        this.write(v.rdata.signature);
+};
+
+DNSProtoBuffer.prototype.writeSIG0SignDataReq = function (v, ctx) {
+        assert.object(v, 'sig0SignData');
+        this.writeSIG0SignData(v, ctx);
+};
+
+DNSProtoBuffer.prototype.writeSIG0SignDataResp = function (v, ctx) {
+        assert.object(v, 'sig0SignData');
+        this.writeSIG0SignData(v, ctx);
+};
+
+DNSProtoBuffer.prototype.writeSIG0SignTCP = function (v, ctx) {
+        throw (new Error('SIG0 continuations for TCP not supported'));
+};
+
 DNSProtoBuffer.prototype.readMessage = function (ctx) {
         var r = {}, i;
         r.header = this.readHeader(ctx);
@@ -458,6 +512,9 @@ DNSProtoBuffer.prototype.readNSData = function (ctx) {
                 case queryTypes['TSIG']:
                         r = cbuf.readTSIG(ctx);
                         break;
+                case queryTypes['SIG0']:
+                        r = cbuf.readSIG0(ctx);
+                        break;
                 default:
                         throw (new Error('unsupported nsdata type: ' +
                             queryTypes[ctx.rtype]));
@@ -499,6 +556,9 @@ DNSProtoBuffer.prototype.writeNSData = function (v, ctx) {
                 case queryTypes['TSIG']:
                         cbuf.writeTSIG(v, ctx);
                         break;
+                case queryTypes['SIG0']:
+                        cbuf.writeSIG0(v, ctx);
+                        break;
                 default:
                         throw new Error('unrecognized nsdata type');
                 }
@@ -524,6 +584,19 @@ function encode(obj, format) {
         case 'tsigSignTcp':
                 buf.writeTSIGSignTCP(obj, {});
                 break;
+        /*
+         * sig0 is just like tsig, but with a different packet format
+         * (and different crypto)
+         */
+        case 'sig0SignDataReq':
+                buf.writeSIG0SignDataReq(obj, {});
+                break;
+        case 'sig0SignDataResp':
+                buf.writeSIG0SignDataResp(obj, {});
+                break;
+        case 'sig0SignTcp':
+                buf.writeSIG0SignTCP(obj, {});
+                break;
         default:
                 throw (new Error('Unknown format: ' + format));
         }
@@ -615,6 +688,7 @@ var queryTypes = {
         MINFO : 0x0E,    // mailbox or mail list information
         MX    : 0x0F,    // mail exchange
         TXT   : 0x10,    // text strings
+        SIG0  : 0x18,    // asymmetric transaction signatures (RFC2931)
         AAAA  : 0x1C,    // ipv6 address
         SRV   : 0x21,    // srv records
         OPT   : 0x29,
@@ -641,6 +715,7 @@ var queryTypes = {
         0x0E  : 'MINFO', // mailbox or mail list information
         0x0F  : 'MX',    // mail exchange
         0x10  : 'TXT',   // text strings
+        0x18  : 'SIG0',  // asymmetric transaction signatures (RFC2931)
         0x1C  : 'AAAA',  // ipv6 address
         0x21  : 'SRV',   // srv records
         0x29  : 'OPT',
diff --git a/lib/query.js b/lib/query.js
index 60d10e9..459ae2e 100644
--- a/lib/query.js
+++ b/lib/query.js
@@ -27,6 +27,7 @@ var nsRecord = require('./records/ns');
 var soaRecord = require('./records/soa');
 var assert = require('assert-plus');
 var mod_tsig = require('./tsig');
+var mod_sig0 = require('./sig0');
 
 function Query(opts) {
         assert.object(opts, 'options');
@@ -44,6 +45,7 @@ function Query(opts) {
         this.query = q;
         this.envelopeCount = 1;
         this.tsigKey = undefined;
+        this.sig0Key = undefined;
         this.lastResponse = undefined;
 
         this.reset();
@@ -177,32 +179,58 @@ Query.prototype.ixfrBase = function ixfrBase() {
 };
 
 Query.prototype.isSigned = function isSigned() {
-        var tsig = this.query.additional[this.query.additional.length - 1];
-        return (tsig && tsig.rtype === queryTypes.TSIG);
+        var sig = this.query.additional[this.query.additional.length - 1];
+        return (sig && (sig.rtype === queryTypes.TSIG ||
+            sig.rtype === queryTypes.SIG0));
 };
 
-Query.prototype.verify = function verify(keys) {
-        var tsig = this.query.additional[this.query.additional.length - 1];
-        if (tsig.rtype !== queryTypes.TSIG)
-                return (false);
-        try {
-                var result = mod_tsig.verifyRequest(this.query, keys);
-        } catch (err) {
-                var log = this._log || this.log;
-                if (log) {
-                        log.warn({err: err}, 'error processing TSIG');
+Query.prototype.verify = function verify(keys, req) {
+        var result = false;
+        var sig = this.query.additional[this.query.additional.length - 1];
+        switch (sig.rtype) {
+        case queryTypes.TSIG:
+                try {
+                        result = mod_tsig.verifyRequest(this.query, keys);
+                } catch (err) {
+                        var log = this._log || this.log;
+                        if (log) {
+                                log.warn({err: err}, 'error processing TSIG');
+                        }
+                        return (false);
                 }
+                /*
+                 * When we get a signed shared-secret message, sign
+                 * any response with the same secret.
+                 */
+                if (result)
+                        this.tsigKey = keys[sig.name];
+                return (result);
+        case queryTypes.SIG0:
+                try {
+                        if (this.testFlag('qr')) {
+                                result = mod_sig0.verifyResponse(
+                                        this.query, keys, req);
+                        } else {
+                                result = mod_sig0.verifyRequest(
+                                        this.query, keys);
+                        }
+                } catch (err) {
+                        var log = this._log || this.log;
+                        if (log) {
+                                log.warn({err: err}, 'error processing SIG0');
+                        }
+                }
+                return (result);
+        default:
                 return (false);
         }
-        if (result)
-                this.tsigKey = keys[tsig.name];
-        return (result);
+
 };
 
 Query.prototype.setError = function setError(name) {
         var code = protocol.rCodes[name.toUpperCase()];
         if (code === undefined) {
-                /* Try stripping off a leading E. */
+                // Try stripping off a leading E.
                 code = protocol.rCodes[name.toUpperCase().slice(1)];
                 if (code === undefined)
                         throw new Error('invalid error code %s', name);
@@ -235,6 +263,15 @@ Query.prototype.encode = function encode(recur) {
                             this.tsigKey, this.lastResponse);
                 }
         }
+        if (this.sig0Key !== undefined) {
+                if (this.lastResponse === undefined) {
+                        mod_sig0.signResponse(this.response, this.sig0Key,
+                            this.query);
+                } else {
+                        mod_sig0.signTcpContinuation(this.response,
+                            this.sig0Key, this.lastResponse);
+                }
+        }
 
         var encoded = protocol.encode(this.response, 'message');
 
@@ -261,7 +298,6 @@ Query.prototype.encode = function encode(recur) {
                 r.additional = [];
                 return (encode.call(this, true));
         }
-
         return (encoded);
 };
 Query.prototype.addAuthority = function (name, record, ttl) {
@@ -286,7 +322,7 @@ Query.prototype.addAuthority = function (name, record, ttl) {
         var r = this.response;
         r.authority.push(authority);
         r.header.nsCount++;
-        /* This is not great, but is necessary to be backwards compatible. */
+        // This is not great, but is necessary to be backwards compatible.
         r.header.flags.aa = true;
 };
 Query.prototype.addAdditional = function (name, record, ttl) {
diff --git a/lib/sig0.js b/lib/sig0.js
new file mode 100644
index 0000000..3b60a23
--- /dev/null
+++ b/lib/sig0.js
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2017 Joyent, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * SIG(0) Signatures for DNS (see RFC2931) -- public key signatures over
+ * DNS requests and responses.
+ *
+ * Structurally almost identical to TSIG signatures -- but with different
+ * backing crypto.
+ */
+
+module.exports = {
+        signRequest: signRequest,
+        signResponse: signResponse,
+        signTcpContinuation: signTcpContinuation,
+        verifyRequest: verifyRequest,
+        verifyResponse: verifyResponse,
+        verifyTcpContinuation: verifyTcpContinuation
+};
+
+var protocol = require('./protocol');
+var assert = require('assert-plus');
+var crypto = require('crypto');
+
+var ALGOS = {
+        'rsa-sha1' : 5,
+        'rsa-sha256' : 8,
+        'rsa-sha512' : 10,
+        'ecdsa-p256-sha256' : 13,
+        'ecdsa-p384-sha384' : 14,
+        'ed25519' : 15
+};
+
+var ALGOREV = {};
+Object.keys(ALGOS).forEach(function (k) {
+        ALGOREV[ALGOS[k]] = k.toUpperCase();
+});
+
+function assertKey(key) {
+        assert.string(key.name, 'key.name');
+        assert.string(key.algorithm, 'key.algorithm');
+        assert.buffer(key.publicKey, 'key.data');
+        assert.number(ALGOS[key.algorithm], 'supported algorithm');
+}
+
+function verifyRequest(msg, keys) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assert.object(keys, 'keys');
+        assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+        return (verify(msg, keys, 'sig0SignDataReq'));
+}
+
+function verifyResponse(msg, keys, reqMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assert.object(keys, 'keys');
+        assert.object(reqMsg, 'signedRequestMessage');
+        assert.object(reqMsg.header, 'signedRequestMessage.header');
+        assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+        return (verify(msg, keys, 'sig0SignDataResp', reqMsg));
+}
+
+function verifyTcpContinuation(msg, keys, lastMsg) {
+        throw (new Error('SIG0 continuations for TCP not supported'));
+}
+
+function signRequest(msg, key) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assertKey(key);
+        return (sign(msg, key, 'sig0SignDataReq'));
+}
+
+function signResponse(msg, key, reqMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assertKey(key);
+        return (sign(msg, key, 'sig0SignDataResp', reqMsg));
+}
+
+function signTcpContinuation(msg, key, lastMsg) {
+        throw (new Error('SIG0 continuations for TCP not supported'));
+}
+
+/*
+ * SIG0 verify works slightly different from TSIG verify:
+ *
+ * dns_dnssec_verifymessage() in:
+ * https://github.com/openbsd/src/blob/master/usr.sbin/bind/lib/dns/dnssec.c
+ * vs
+ * https://github.com/openbsd/src/blob/master/usr.sbin/bind/lib/dns/tsig.c#L831
+ *
+ * Basically, we feed our hash with the bare-SIG0, followed by the
+ * query chain with SIG0 removed. TSIG does this sort of the other way
+ * around.
+ */
+function verify(msg, keys, format, reqMsg) {
+        // deep-copy our message, with intact headers.
+        var newMsg =
+            protocol.decode(protocol.encode(msg, 'message'), 'message');
+        var sig0 = newMsg.additional.pop();
+        assert.strictEqual(sig0.rtype, protocol.queryTypes.SIG0);
+        newMsg.header.arCount--;
+
+        var kname = sig0.rdata.signername;
+        var key = keys[kname];
+        if (key === undefined)
+                throw (new Error('Unknown SIG0 key "' + kname + '"'));
+        assertKey(key);
+
+        var algo = sig0.rdata.algorithm;
+        assert.strictEqual(algo, ALGOS[key.algorithm], 'matching algorithm');
+
+        var signature = sig0.rdata.signature; // Save what we're verifying.
+        sig0.rdata.signature = Buffer(0);
+
+        var blob = protocol.encode(sig0, format); // digest SIG0
+        assert.buffer(blob);
+
+        var verifier = crypto.createVerify(ALGOREV[algo]);
+        verifier.update(blob);
+
+        // consume the request, if any
+        if (reqMsg !== undefined) {
+                blob = protocol.encode(reqMsg, 'message');
+                assert.buffer(blob);
+                verifier.update(blob);
+        }
+        blob = protocol.encode(newMsg, 'message');
+        verifier.update(blob);
+
+        var cryptoVerified = verifier.verify(key.publicKey, signature);
+
+        // check expiration against issuance/inception and expiration.
+        var now = new Date().getTime() / 1000;
+        var validTimeSignature =
+            (now < sig0.rdata.expiration && now > sig0.rdata.inception);
+
+        return (cryptoVerified && validTimeSignature);
+}
+
+/*
+ * SIG0 signing works slightly differently from TSIG signing.
+ *
+ * Feed the hash our SIG0 header, then the query (if any), then the
+ * header and body of the current message.
+ */
+function sign(msg, key, format, reqMsg) {
+        var algo = ALGOS[key.algorithm];
+
+        var sig0 = {};
+        sig0.name = ''; // single zero octet, per RFC
+        sig0.rtype = protocol.queryTypes.SIG0;
+        sig0.rclass = protocol.qClasses.ANY;
+        sig0.rdata = {};
+        sig0.rdata.typecovered = 0;
+        sig0.rdata.algorithm = algo;
+        sig0.rdata.labels = 0;
+        sig0.rdata.originalttl = 0;
+        sig0.rdata.keytag = key.tag;
+        sig0.rdata.signername = key.name;
+
+        var fudge = 300;
+        var now = new Date().getTime() / 1000;
+        sig0.rdata.expiration = now + fudge;
+        sig0.rdata.inception = now - fudge;
+        sig0.rdata.signature = new Buffer(0);
+
+        var blob = protocol.encode(sig0, format);
+        assert.buffer(blob);
+
+        var signer = crypto.createSign(ALGOREV[algo]);
+        signer.update(blob);
+
+        // consume the request, if any
+        if (reqMsg !== undefined) {
+                blob = protocol.encode(reqMsg, 'message');
+                assert.buffer(blob);
+                signer.update(blob);
+        }
+        blob = protocol.encode(msg, 'message');
+        assert.buffer(blob);
+        signer.update(blob);
+        var signature_data = signer.sign(key.privateKey);
+
+        var signature = {};
+        signature.name = ''; // single zero octet, per RFC
+        signature.rtype = protocol.queryTypes.SIG0;
+        signature.rclass = protocol.qClasses.ANY;
+        signature.rttl = 0;
+        signature.rdata = {};
+        signature.rdata.signername = sig0.rdata.signername;
+        signature.rdata.keytag = sig0.rdata.keytag;
+        signature.rdata.labels = sig0.rdata.labels;
+        signature.rdata.typecovered = 0;
+        signature.rdata.originalttl = sig0.rdata.originalttl;
+        signature.rdata.algorithm = sig0.rdata.algorithm;
+        signature.rdata.expiration = sig0.rdata.expiration;
+        signature.rdata.inception = sig0.rdata.inception;
+        signature.rdata.signature = signature_data;
+
+        msg.header.arCount++;
+        msg.additional.push(signature);
+}
diff --git a/test/sig0.test.js b/test/sig0.test.js
new file mode 100644
index 0000000..49bfd4b
--- /dev/null
+++ b/test/sig0.test.js
@@ -0,0 +1,320 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Basic test/example of sig0 RSA-SHA1 signatures on DNS reords.
+ */
+
+var mod_mname = require('../lib');
+var mod_sig0 = require('../lib/sig0');
+var protocol = require('../lib/protocol');
+var Query = require('../lib/Query');
+var dig = require('./dig');
+var mod_crypto = require('crypto');
+var dgram = require('dgram');
+
+if (require.cache[__dirname + '/helper.js'])
+        delete require.cache[__dirname + '/helper.js']
+var helper = require('./helper');
+
+var test = helper.test;
+var before = helper.before;
+var after = helper.after;
+
+var options = { port: 9999, server: '::1' };
+
+// 'dnssec-keygen -T KEY -a rsasha1 -b 1024 -n USER testroot'
+// 'dnssec2pem Ktestroot.+005+37511.private'
+var SERVER_TEST_KEY = {
+        name: 'testroot',
+        tag: 37511,
+        algorithm: 'rsa-sha1',
+        privateKey: Buffer.from(
+                "-----BEGIN RSA PRIVATE KEY-----\n" +
+                        "MIICXAIBAAKBgQCiZLRiwmTWHy2dBvu6Q2fo3WTRqiW4XfSXBX50bKtACPfWIDPP\n" +
+                        "YYRLPt6I6dFtuMS/6HxSHwXALLovvhrVOjIp3qixm0O427icUgdQl60r1JhBeuDn\n" +
+                        "2feFKECmOKbfqh4vMtYKuSXro5QFb9iPDNITvaBhIpjd9N5zsVV/YerpRQIDAQAB\n" +
+                        "AoGAaWZDTfYtzGvgBxMJPxOQ1ascTJjKcqdIoNyH/ripTZ6EfQ3ZkrgQTWY4uVRJ\n" +
+                        "AZXy3TvftM09xkVBcstITyy+cTW9TvEpXYPk3VAwrHbFfrcyechugnI5/3zOdwYJ\n" +
+                        "W6yfYXmKlILHjjAb5ro4t8F+AJteSfS46TjNVPnc7r7WVOECQQDXXiCjFZEmR+PQ\n" +
+                        "JBPAA1ntD5O4zBtdc7REOgiU8w7MmJ+edEgc0lqCi9KevJeAaS8wAzaoMEI89etd\n" +
+                        "fE+S/Q/zAkEAx/BzvmfFqGbLJcNxn46KPyIYNYMo784swnbDgrjJdl3pMbPKS1zG\n" +
+                        "B2HGRMx0LOGMt+DTLAnK19clZOpfLsG/ywJBAIH6pBXpEUYaQyq+a1EKdL53FT+F\n" +
+                        "p8pZ52T55W4H11mxjzwxj8gdSFTbkE0PIxxz3u/KMLWHEqL6BIfSW7ApnPMCQHdF\n" +
+                        "OlaQYvnlcDQz1fkft9qXhSeO+YGsVUkgPdsiTpP8y5pprTitvDg1HGh4KqmHV0Ft\n" +
+                        "ratsoAOIBXeg1Gz5CWcCQEKZ5U1GcIcjJ5CoZPe5LlnDl0VVLN/khkwGtjYt/QZY\n" +
+                        "bcO1Pfgqw0MZ9QajhkjktixpAOBTrZ8g8iev5eWgRHo=\n" +
+                        "-----END RSA PRIVATE KEY-----"
+        ),
+        publicKey: Buffer.from(
+                "-----BEGIN PUBLIC KEY-----\n" +
+                        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiZLRiwmTWHy2dBvu6Q2fo3WTR\n" +
+                        "qiW4XfSXBX50bKtACPfWIDPPYYRLPt6I6dFtuMS/6HxSHwXALLovvhrVOjIp3qix\n" +
+                        "m0O427icUgdQl60r1JhBeuDn2feFKECmOKbfqh4vMtYKuSXro5QFb9iPDNITvaBh\n" +
+                        "Ipjd9N5zsVV/YerpRQIDAQAB\n" +
+                        "-----END PUBLIC KEY-----"
+        )
+};
+
+var CLIENT_IDENTITY_KEY = {
+        name: 'testclient',
+        tag: 5536,
+        algorithm: 'rsa-sha1',
+        privateKey: Buffer.from(''), // empty
+        publicKey: Buffer.from(
+                "-----BEGIN PUBLIC KEY-----\n" +
+                        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwBScUzQMiBzCDimdcn1E+2xey\n" +
+                        "xat6mZgDpw02yKn5zq90rXK7p2Vzpe/3yOz0O4rqCP/liWfwm+vU0d0EdQyP7ypV\n" +
+                        "SACrhLf7IDVEfQO0JFw2yzg9XEpBQMbLqib1QesT+6pfY8kwLwHBDSalqDgK0+Rh\n" +
+                        "ayvZ9ZwG3KdLRtPoSQIDAQAB\n" +
+                        "-----END PUBLIC KEY-----"
+        )
+};
+
+var KEYS = {
+        'testroot': SERVER_TEST_KEY,
+        'testclient' : CLIENT_IDENTITY_KEY
+};
+
+before(function (callback) {
+        this.server = mod_mname.createServer({
+                log: helper.getLog('server')
+        });
+        var server = this.server;
+
+        this.server.on('query', function (query, cb) {
+                if (!query.isSigned() || !query.verify(KEYS)) {
+                        query.setError('notauth');
+                        query.send();
+                        cb();
+                        return;
+                }
+                var domain = query.name();
+                var record;
+                if (query.type() === 'AXFR') {
+                        var soa = new mod_mname.SOARecord(domain);
+                        query.addAnswer(domain, soa, 300);
+                        query.send();
+                        record = new mod_mname.ARecord('127.0.0.1');
+                        query.addAnswer(domain, record, 300);
+                        query.send();
+                        query.addAnswer(domain, soa, 300);
+                        query.send();
+                        cb();
+                } else {
+                        record = new mod_mname.ARecord('127.0.0.1');
+                        query.addAnswer(domain, record, 300);
+                        query.sig0Key = SERVER_TEST_KEY;
+                        query.send();
+                        cb();
+                }
+        });
+
+        this.server.listenUdp({port: options.port, address: options.server},
+            function () {
+                server.listenTcp({port: options.port, address: options.server},
+                    function () {
+                        process.nextTick(callback);
+                });
+            });
+});
+
+after(function (cb) {
+        this.server.close(cb);
+});
+
+/*
+ * Quick & Dirty pure-js simple-query generator
+ */
+function simpleDnsQuery(name, type, qclass) {
+        var req = {};
+        req.header = {};
+        req.header.id = 1234;
+        req.header.flags = {
+                qr:     false,
+                opcode: 0,
+                aa:     false,
+                tc:     false,
+                rd:     false,
+                ra:     false,
+                z:      false,
+                ad:     false,
+                cd:     false,
+                rcode:  0
+        };
+        req.header.qdCount = 1;
+        req.header.anCount = 0;
+        req.header.nsCount = 0;
+        req.header.arCount = 0;
+        req.question = [];
+        req.answer = [];
+        req.authority = [];
+        req.additional = [];
+
+        var question = {};
+        question.name = name;
+        question.type = type;
+        question.qclass = qclass;
+        req.question.push(question);
+
+        return (req);
+}
+
+function sendMessage(c, m) {
+        c.send(m, 0, m.length, options.port, options.server,
+                    function(err, bytes) {
+                            if (err) throw err;
+                    });
+}
+
+test('reject unauthed requests', function (t) {
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+var CLIENT_SIGNING_KEY = {
+        name: 'testclient',
+        tag: 5536,
+        algorithm: 'rsa-sha1',
+        privateKey: Buffer.from(
+                "-----BEGIN RSA PRIVATE KEY-----\n" +
+                        "MIICXQIBAAKBgQCwBScUzQMiBzCDimdcn1E+2xeyxat6mZgDpw02yKn5zq90rXK7\n" +
+                        "p2Vzpe/3yOz0O4rqCP/liWfwm+vU0d0EdQyP7ypVSACrhLf7IDVEfQO0JFw2yzg9\n" +
+                        "XEpBQMbLqib1QesT+6pfY8kwLwHBDSalqDgK0+RhayvZ9ZwG3KdLRtPoSQIDAQAB\n" +
+                        "AoGALWoW7EH89fGe7cFu67HbV3lVwvVHSgmI9CBMw37AhEh0cokx2gLVpSICKQ85\n" +
+                        "O8aFD98kjweFvsmr7iv7d2PvymGiJzbQCKv0+Mz7l+88BINNT8UEufNm2v8w7Yta\n" +
+                        "u3G60BQ3iwAR8kwkAAvqgYDyVTxWSw493BP1w6XwPaMpG4ECQQDsv/Re1VNIhx2F\n" +
+                        "ZxpKu29F/dXglfmoJQxZfRSc2TzchR+YTmdlnj/+Mveh+iiFUJ4od8lvPLDlx5nC\n" +
+                        "3E+HCq2NAkEAxUDUS+3dMLB5dzsGzTBBBCmoy/DN1G+EQ6rmOwxLu3UujF45uIFw\n" +
+                        "6ttXd51bHhrb4EIAKKhwAIfnuFDMHY9z3QJBAIOthBqW5hqJ5BaFsO7t70brluCy\n" +
+                        "Kcimyoafdi6C+UHh3R/WQ9YWPZuB94+k1pLHsx/o+CWhiPZUnSXvaWA/xSUCQDFp\n" +
+                        "cQToPA1zV6ofdi+2U8MYMHmOA/GgUdClofDOvrXhv9xXyjvG6SNb+Mg0+dtLvSKr\n" +
+                        "ReDpeM0ZPlm0m70X710CQQDij+JEuX0GXCcZtSB4vlPpJvnCt3NDfzGAqNaE9HDo\n" +
+                        "e6d0ZxHnxN5+ikjmZ10HiUhNMUtfoDzlrvflhCb7u6ac\n" +
+                        "-----END RSA PRIVATE KEY-----"
+        ),
+        publicKey: Buffer.from(
+                "-----BEGIN PUBLIC KEY-----\n" +
+                        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwBScUzQMiBzCDimdcn1E+2xey\n" +
+                        "xat6mZgDpw02yKn5zq90rXK7p2Vzpe/3yOz0O4rqCP/liWfwm+vU0d0EdQyP7ypV\n" +
+                        "SACrhLf7IDVEfQO0JFw2yzg9XEpBQMbLqib1QesT+6pfY8kwLwHBDSalqDgK0+Rh\n" +
+                        "ayvZ9ZwG3KdLRtPoSQIDAQAB\n" +
+                        "-----END PUBLIC KEY-----"
+        )
+};
+
+var SERVER_IDENTITY_KEY = {
+        name: 'testroot',
+        tag: 37511,
+        algorithm: 'rsa-sha1',
+        privateKey: Buffer.from(''), // empty
+        publicKey: Buffer.from(
+                "-----BEGIN PUBLIC KEY-----\n" +
+                        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCiZLRiwmTWHy2dBvu6Q2fo3WTR\n" +
+                        "qiW4XfSXBX50bKtACPfWIDPPYYRLPt6I6dFtuMS/6HxSHwXALLovvhrVOjIp3qix\n" +
+                        "m0O427icUgdQl60r1JhBeuDn2feFKECmOKbfqh4vMtYKuSXro5QFb9iPDNITvaBh\n" +
+                        "Ipjd9N5zsVV/YerpRQIDAQAB\n" +
+                        "-----END PUBLIC KEY-----"
+        )
+};
+
+var CLIENT_KEYS = {
+        'testroot': SERVER_IDENTITY_KEY
+};
+
+test('accepts signed requests, emits signed response', function(t) {
+        var req = simpleDnsQuery('example.com', protocol.queryTypes.A, protocol.qClasses.ANY);
+        mod_sig0.signRequest(req, CLIENT_SIGNING_KEY);
+        var client = dgram.createSocket('udp6');
+        client.on('message', function (message, remote) {
+                var qopts = {
+                        family: 'udp',
+                        address: remote.address,
+                        port: remote.port,
+                        data: message
+                };
+
+                var reply = Query.parse(qopts);
+                t.ok(reply.query.header.flags.rcode == protocol.rCodes.NOERROR,
+                    'expected success');
+                t.ok(reply.isSigned(), 'signed');
+                t.ok(reply.verify(CLIENT_KEYS, req));
+                t.end();
+                client.close();
+        });
+
+        var serializedReq = protocol.encode(req, 'message');
+        sendMessage(client, serializedReq);
+});
+
+test('rejects corrupt signed requests', function(t) {
+        var req = simpleDnsQuery('example.com', protocol.queryTypes.A, protocol.qClasses.ANY);
+        mod_sig0.signRequest(req, CLIENT_SIGNING_KEY);
+        var client = dgram.createSocket('udp6');
+        client.on('message', function (message, remote) {
+                var qopts = {
+                        family: 'udp',
+                        address: remote.address,
+                        port: remote.port,
+                        data: message
+                };
+
+                var reply = Query.parse(qopts);
+                t.ok(reply.query.header.flags.rcode == protocol.rCodes.NOTAUTH,
+                     'expected auth fail');
+                t.end();
+                client.close();
+        });
+
+        var serializedReq = protocol.encode(req, 'message');
+
+        // Corrupt our buffer
+        // modify a byte in the middle somewhere.
+        var offset = serializedReq.length / 2
+        var val = serializedReq.readUInt8(offset);
+        val = val ^ 1; // flip a bit
+        serializedReq.writeUInt8(val, offset);
+        sendMessage(client, serializedReq);
+});
+
+test('client rejects corrupt signed responses', function(t) {
+        var req = simpleDnsQuery('example.com', protocol.queryTypes.A, protocol.qClasses.ANY);
+        mod_sig0.signRequest(req, CLIENT_SIGNING_KEY);
+        var client = dgram.createSocket('udp6');
+        client.on('message', function (message, remote) {
+                // Corrupt our receive buffer
+                // modify a byte in the middle somewhere.
+                var offset = message.length / 2
+                var val = message.readUInt8(offset);
+                val = val ^ 1; // flip a bit
+                message.writeUInt8(val, offset);
+                var qopts = {
+                        family: 'udp',
+                        address: remote.address,
+                        port: remote.port,
+                        data: message
+                };
+
+                var reply = Query.parse(qopts);
+                t.ok(reply.query.header.flags.rcode == protocol.rCodes.NOERROR,
+                     'expected success');
+                t.ok(reply.isSigned(), 'signed');
+                t.ok(!reply.verify(CLIENT_KEYS, req));
+                t.end();
+                client.close();
+        });
+
+        var serializedReq = protocol.encode(req, 'message');
+        sendMessage(client, serializedReq);
+});
+
-- 
2.21.0

