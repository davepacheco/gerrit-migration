commit a2b90667b88c8d23e42fa47e5e0addce9fb434a8 (refs/changes/19/2319/6)
Author: David Pacheco <dap@joyent.com>
Date:   2017-11-03T11:14:11-07:00 (1 year, 11 months ago)
    
    MORAY-422 node-moray could smooth over connection shuffling
    MORAY-423 client memory leak

diff --git a/CHANGES.md b/CHANGES.md
index c1a1840..5f3d068 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## v3.4.1
+
+* [MORAY-422](http://smartos.org/bugview/MORAY-422) node-moray could smooth over connection shuffling
+
 ## v.3.4.0
 
 * [MORAY-428](https://smartos.org/bugview/MORAY-428) Make it safer to use reindexing buckets
@@ -8,6 +12,10 @@
 
 * [MANTA-3371](https://smartos.org/bugview/MANTA-3371) triggers cannot be installed with any vnodes in read-only mode
 
+## v3.2.1
+
+* [MORAY-409](http://smartos.org/bugview/MORAY-409) Moray client needs to pass timeout to server for sql()
+
 ## v3.2.0
 
 * [MORAY-104](https://smartos.org/bugview/MORAY-104) disallow filtering on non-indexed fields except interactively
diff --git a/lib/client.js b/lib/client.js
index b870bc4..50bab99 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -270,6 +270,7 @@ MorayClient.prototype.close = function close() {
     this.closeState = MORAY_CS_CLOSING;
     this.nactiveAtClose = this.nactive;
     this.log.info({ 'nactiveAtClose': this.nactive }, 'closing');
+    this.pool.fallbackDisable();
 
     if (this.nactive === 0) {
         setImmediate(function closeImmediate() { self.closeFini(); });
diff --git a/lib/fast_connection.js b/lib/fast_connection.js
index 55f2068..d9d8781 100644
--- a/lib/fast_connection.js
+++ b/lib/fast_connection.js
@@ -65,6 +65,11 @@ function FastConnection(args) {
         'log': args.log
     });
 
+    /*
+     * We maintain an analog of Node's "destroyed" field.
+     */
+    this.destroyed = false;
+
     /* List of all errors observed. */
     this.fc_all_errors = [];
 
@@ -190,6 +195,7 @@ FastConnection.prototype.fastClient = function () {
  */
 
 FastConnection.prototype.destroy = function () {
+    this.destroyed = true;
     this.fc_destroyed = true;
     this.fc_sock.destroy();
 };
diff --git a/lib/pool.js b/lib/pool.js
index b8203be..8f22847 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -26,12 +26,63 @@
  * connection pool expects.  To accommodate that, we use the simpler
  * ConnectionSet interface, which just maintains a set of connections for us.
  * Here, we implement allocation and connection tracking appropriately.
+ *
+ *
+ * Connection state machine
+ *
+ * Connections are provided to us by Cueball once they've been successfully
+ * established.  We use them for new requests until Cueball removes them,
+ * which typically happens because a particular backend is no longer listed as
+ * in-service in DNS or because Cueball has shuffled its set of connected
+ * backends.  We have found in some cases that the underlying mechanism flaps
+ * between two disjoint sets of connection (e.g., a set driven by SRV records
+ * and one driven by A records, with flaps between the two resulting from
+ * transient DNS issues).  To mitigate the impact of this, if we would be
+ * removing our last connection, we instead hold onto it for a brief period.
+ *
+ *           |
+ *           | cueball: 'added'
+ *           | connAdd()
+ *           v
+ *  +---------------------+
+ *  | state: MC_S_AVAIL   | ------------------------+ cueball: "removed",
+ *  +---------------------+                         | on last connection
+ *           |                                      v connRetire()
+ *           | cueball: "removed",      +----------------------+
+ *           | not last connection      | state: MC_S_FALLBACK |
+ *           | connRetire()/connDrain() +----------------------+
+ *           v                                      |
+ *  +---------------------+                         | fallback time expires
+ *  | state: MC_S_DRAIN   | <-----------------------+ or another connection is
+ *  +---------------------+                           added
+ *           |                                        connFallbackRemove()
+ *           | last request completes
+ *           | connDelete()
+ *           v
+ *  +---------------------+
+ *  | state: MC_S_DELETED |
+ *  |    (removed)        |
+ *  +---------------------+
  */
 
 var assert = require('assert-plus');
 var jsprim = require('jsprim');
 var VError = require('verror');
 
+/*
+ * Maximum time (in milliseconds) that we will continue to use a connection when
+ * it was the last connection that we knew about.
+ */
+var MorayFallbackMaxTime = 15 * 1000;
+
+/*
+ * Connection states (see above)
+ */
+var MC_S_AVAIL = '_moray_conn_state_avail';
+var MC_S_DRAIN = '_moray_conn_state_drain';
+var MC_S_FALLBACK = '_moray_conn_state_fallback';
+var MC_S_DELETED = '_moray_conn_state_deleted';
+
 module.exports = MorayConnectionPool;
 
 /*
@@ -48,6 +99,7 @@ function MorayConnection(key, conn, hdl, log) {
     this.mc_hdl = hdl;      /* cueball handle to release after drain */
     this.mc_log = log;      /* bunyan-style logger */
     this.mc_nreqs = 0;      /* number of outstanding requests */
+    this.mc_state = MC_S_AVAIL;
 }
 
 /*
@@ -82,27 +134,47 @@ function MorayConnectionPool(args) {
     this.mcp_cueball_set = args.cueballSet;
 
     /*
-     * We keep track of all connections that we know about, as well as the set
-     * of connections that are available for new work to be assigned.  These
-     * aren't the same, as there may be some connections that are being drained
-     * because they've disappeared from service discovery or because cueball is
-     * rebalancing the set.  Both of these sets are indexed by the
-     * cueball-provided key for each connection.
+     * We keep track of all connections that we know about in "mcp_conns".  This
+     * includes connections available for general use for new requests,
+     * connections that have been removed from service that still have pending
+     * requests (because they're no longer reported in service discovery or
+     * because cueball is rebalancing its connection set), and at most one
+     * fallback connection.  The keys in "mcp_conns" are the cueball-provided
+     * connection keys, and the values are the connections themselves.
+     *
+     * We separately track in "mcp_avail" the set of connections that cueball
+     * considers in-service.  Keys in "mcp_avail" are cueball-provided
+     * connection keys (just as with "mcp_conns"), but the values are not
+     * meaningful since it's just a set.  The keys actually present in
+     * "mcp_avail" are always a subset of those in "mcp_conns".
+     *
+     * There may be at most one connection in "mcp_conn_fallback" that has been
+     * removed from general use but remains available if we have no connections
+     * formally in service.  See above for details on this mechanism.  This
+     * connection also appears in "mcp_conns" (like all connections that we know
+     * about).
      */
-    this.mcp_conns = {};    /* all connections */
-    this.mcp_avail = {};    /* connections in service for new requests */
+    this.mcp_conns = {};    /* all connections, by key */
+    this.mcp_avail = {};    /* keys for conns cueball considers in-service */
+
+    /* Fallback connection information.  See above. */
+    this.mcp_fallback_enable = true;    /* fallback behavior enabled */
+    this.mcp_conn_fallback = null;      /* fallback connection itself */
+    this.mcp_conn_fallback_time = null; /* hrtime when it was made fallback */
 
     /* Counters for debugging */
-    this.mcp_nalloc_ok = 0;     /* successful allocations */
-    this.mcp_nalloc_fail = 0;   /* failed allocations */
-    this.mcp_nreleased = 0;     /* releases */
+    this.mcp_nalloc_ok = 0;         /* successful allocations */
+    this.mcp_nalloc_fail = 0;       /* failed allocations */
+    this.mcp_nalloc_fallback = 0;   /* allocations of a fallback conn */
+    this.mcp_nreleased = 0;         /* releases */
+    this.mcp_nfallbacks = 0;        /* assigned a conn as fallback */
 
     this.mcp_cueball_set.on('added', function onConnectionAdd(key, conn, hdl) {
         self.connAdd(key, conn, hdl);
     });
 
     this.mcp_cueball_set.on('removed', function onConnectionRemoved(key) {
-        self.connDrain(key);
+        self.connRetire(key);
     });
 }
 
@@ -114,7 +186,7 @@ function MorayConnectionPool(args) {
  * The caller must invoke connRelease() when the request is finished.
  */
 MorayConnectionPool.prototype.connAlloc = function () {
-    var availkeys, key, mconn, aconn;
+    var availkeys, key, mconn, aconn, staletime, staletimems;
 
     /*
      * There are more sophisticated ways to pick a connection (e.g., store
@@ -124,7 +196,32 @@ MorayConnectionPool.prototype.connAlloc = function () {
      * distribution is likely to be reasonable.
      */
     availkeys = Object.keys(this.mcp_avail);
-    if (availkeys.length === 0) {
+    if (availkeys.length > 0) {
+        key = jsprim.randElt(availkeys);
+        mconn = this.mcp_conns[key];
+        assert.strictEqual(mconn.mc_state, MC_S_AVAIL);
+    } else {
+        mconn = this.mcp_conn_fallback;
+        if (mconn !== null) {
+            assert.arrayOfNumber(this.mcp_conn_fallback_time);
+            assert.strictEqual(mconn.mc_state, MC_S_FALLBACK);
+            key = mconn.mc_key;
+            staletime = process.hrtime(this.mcp_conn_fallback_time);
+            staletimems = jsprim.hrtimeMillisec(staletime);
+            if (staletimems > MorayFallbackMaxTime) {
+                mconn = null;
+                this.connFallbackRemove({
+                    'staleTimeMs': staletimems,
+                    'maxTimeMs': MorayFallbackMaxTime,
+                    'reason': 'fallback is too old'
+                });
+            } else {
+                this.mcp_nalloc_fallback++;
+            }
+        }
+    }
+
+    if (mconn === null) {
         this.mcp_nalloc_fail++;
         this.mcp_log.trace('failed to allocate connection');
         return (new VError({
@@ -132,8 +229,6 @@ MorayConnectionPool.prototype.connAlloc = function () {
         }, 'no connections available'));
     }
 
-    key = jsprim.randElt(availkeys);
-    mconn = this.mcp_conns[key];
     assert.ok(mconn instanceof MorayConnection);
     assert.ok(mconn.mc_nreqs >= 0);
     mconn.mc_nreqs++;
@@ -162,8 +257,15 @@ MorayConnectionPool.prototype.connRelease = function (aconn) {
     this.mcp_nreleased++;
 
     key = mconn.mc_key;
-    if (!this.mcp_avail.hasOwnProperty(key) && mconn.mc_nreqs === 0) {
-        this.connDelete(key);
+    if (mconn.mc_state == MC_S_AVAIL) {
+        assert.ok(this.mcp_avail.hasOwnProperty(key));
+    } else {
+        assert.ok(!this.mcp_avail.hasOwnProperty(key));
+        assert.ok(mconn.mc_state == MC_S_DRAIN ||
+            mconn.mc_state == MC_S_FALLBACK);
+        if (mconn.mc_state == MC_S_DRAIN && mconn.mc_nreqs === 0) {
+            this.connDelete(key);
+        }
     }
 };
 
@@ -181,33 +283,76 @@ MorayConnectionPool.prototype.connAdd = function connAdd(key, conn, hdl) {
     extras.key = key;
     mconn = new MorayConnection(key, conn, hdl,
         this.mcp_log.child(extras, true));
+    assert.strictEqual(mconn.mc_state, MC_S_AVAIL);
     this.mcp_conns[key] = mconn;
     this.mcp_avail[key] = true;
     mconn.mc_log.info('new connection');
+
+    this.connFallbackRemove({ 'reason': 'new connection' });
 };
 
 /*
- * [private] Invoked by cueball when a connection should be removed from
- * service.  This connection may well still be in use by any number of requests.
+ * [private] Invoked when cueball determines that a connection should be removed
+ * from service.  This connection may still be in use by any number of requests.
  * It's our responsibility to stop assigning new work to it, wait for existing
  * requests to complete, and close the connection.
+ *
+ * This function always removes the specified connection from general-purpose
+ * use by new requests.  However, if this is the last connection we have, then
+ * we hold onto it as a fallback and don't drain it right away.
  */
-MorayConnectionPool.prototype.connDrain = function connDrain(key) {
+MorayConnectionPool.prototype.connRetire = function (key) {
     var mconn;
 
     assert.ok(this.mcp_conns.hasOwnProperty(key));
     assert.ok(this.mcp_avail.hasOwnProperty(key));
+    mconn = this.mcp_conns[key];
+    assert.strictEqual(mconn.mc_state, MC_S_AVAIL);
 
     /*
      * Remove the connection from service for new requests.
      */
     delete (this.mcp_avail[key]);
 
+    assert.bool(mconn.mc_conn.destroyed);
+    if (!jsprim.isEmpty(this.mcp_avail) || !this.mcp_fallback_enable ||
+        mconn.mc_conn.destroyed) {
+        this.connDrain(key);
+    } else {
+        /*
+         * This was the last available connection.  There must not already be a
+         * fallback because we would have removed that fallback when we added
+         * this connection.
+         */
+        assert.strictEqual(this.mcp_conn_fallback, null);
+        assert.strictEqual(this.mcp_conn_fallback_time, null);
+        mconn.mc_state = MC_S_FALLBACK;
+        mconn.mc_log.warn('retiring last connection (saving as fallback)');
+        this.mcp_nfallbacks++;
+        this.mcp_conn_fallback = mconn;
+        this.mcp_conn_fallback_time = process.hrtime();
+    }
+};
+
+/*
+ * [private] Invoked as part of connection teardown when we're definitely
+ * removing a connection from service.  This means either cueball has asked us
+ * to remove it and we have other connections available, or this was a fallback
+ * connection that we're no longer intending to use.
+ */
+MorayConnectionPool.prototype.connDrain = function connDrain(key) {
+    var mconn;
+
+    assert.ok(!this.mcp_avail.hasOwnProperty(key));
+    assert.ok(this.mcp_conns.hasOwnProperty(key));
+
     /*
      * If there are no requests using this connection, clean it up now.  If
      * there are, wait for those to finish and clean up when they're done.
      */
     mconn = this.mcp_conns[key];
+    assert.ok(mconn.mc_state == MC_S_AVAIL || mconn.mc_state == MC_S_FALLBACK);
+    mconn.mc_state = MC_S_DRAIN;
     if (mconn.mc_nreqs === 0) {
         this.connDelete(key);
     } else {
@@ -217,7 +362,7 @@ MorayConnectionPool.prototype.connDrain = function connDrain(key) {
 
 /*
  * [private] Invoked when we know that a connection is fully quiesced (there are
- * no requests associated with it) to remove it from service and destroy it.
+ * no requests associated with it) to destroy it.
  */
 MorayConnectionPool.prototype.connDelete = function (key) {
     var mconn;
@@ -226,9 +371,53 @@ MorayConnectionPool.prototype.connDelete = function (key) {
     assert.ok(this.mcp_conns.hasOwnProperty(key));
 
     mconn = this.mcp_conns[key];
+    assert.strictEqual(mconn.mc_state, MC_S_DRAIN);
+    assert.ok(this.mcp_conn_fallback != mconn,
+        'attempted to delete fallback connection');
     assert.strictEqual(mconn.mc_nreqs, 0);
     delete (this.mcp_conns[key]);
 
+    /*
+     * By the time the following completes, there should be no references to
+     * this object any more.  We mark the state DELETED in case we find it in
+     * the debugger (and so that assertions can tell if we've accidentally held
+     * onto something we shouldn't have).
+     */
+    mconn.mc_state = MC_S_DELETED;
     mconn.mc_log.info('removed connection');
     mconn.mc_hdl.release();
 };
+
+/*
+ * [private] Removes and cleans up the fallback connection, if any.
+ */
+MorayConnectionPool.prototype.connFallbackRemove = function (props) {
+    var mconn;
+
+    assert.object(props, 'props');
+    assert.string(props.reason, 'props.reason');
+
+    if (this.mcp_conn_fallback === null) {
+        assert.strictEqual(this.mcp_conn_fallback_time, null);
+        return;
+    }
+
+    assert.notStrictEqual(this.mcp_conn_fallback_time, null);
+    mconn = this.mcp_conn_fallback;
+    this.mcp_conn_fallback = null;
+    this.mcp_conn_fallback_time = null;
+
+    assert.strictEqual(mconn.mc_state, MC_S_FALLBACK);
+    mconn.mc_log.info(props, 'removing fallback connection');
+    this.connDrain(mconn.mc_key);
+};
+
+/*
+ * [private] Indicates that we should stop maintaining a fallback connection
+ * (generally because the parent client is shutting down).
+ */
+MorayConnectionPool.prototype.fallbackDisable = function ()
+{
+    this.mcp_fallback_enable = false;
+    this.connFallbackRemove({ 'reason': 'shutting down' });
+};
diff --git a/package.json b/package.json
index 4bb2a9d..a310842 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "3.4.0",
+    "version": "3.4.1",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
@@ -14,7 +14,7 @@
         "backoff": "^2.4.1",
         "bunyan": "^1.3.2",
         "cmdutil": "^1.1.0",
-        "cueball": "^2.2.0",
+        "cueball": "^2.3.0",
         "extsprintf": "^1.3.0",
         "fast": "^2.1.0",
         "libuuid": "0.2.1",
