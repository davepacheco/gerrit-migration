From 081727e7ed1d448a27c413088e5f82bdf5c3e57c Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Fri, 10 Feb 2017 15:16:44 -0800
Subject: [PATCH] joyent/node-cueball#94 ConnectionSet needs better protection
 against removing its last working connection

---
 lib/set.js        |  20 +++--
 test/cset.test.js | 205 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 219 insertions(+), 6 deletions(-)

diff --git a/lib/set.js b/lib/set.js
index 90788b3..3c1e216 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -402,17 +402,24 @@ CueBallConnectionSet.prototype._rebalance = function () {
 			return;
 
 		var k = fsm.csf_backend.key;
-		/*
-		 * Find any advertised connections from this FSM, and (after
-		 * setting the closeAfterRelease flag to avoid them retrying),
-		 * emit 'removed' so our consumer will close them.
-		 */
-		var cks = self.cs_connectionKeys[k];
+
+		/* Subtract from "busy" so the "if" above does its job. */
+		if (fsm.isInState('busy'))
+			--busy;
 		fsm.setUnwanted();
+
+		/* We might have stopped synchronously. */
 		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
 			delete (self.cs_fsm[k]);
 			--total;
 		}
+
+		/*
+		 * Find any advertised connections from this FSM, and (after
+		 * setting the unwanted FSM flag to avoid them retrying), emit
+		 * 'removed' so our consumer will close them.
+		 */
+		var cks = self.cs_connectionKeys[k];
 		cks.forEach(function (ck) {
 			var lconn = self.cs_lconns[ck];
 			if (!lconn.isInState('stopped'))
@@ -562,6 +569,7 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 		if (newState === 'stopped' || newState === 'failed') {
 			delete (self.cs_fsm[key]);
 			self.emit('closedBackend', fsm);
+			self.rebalance();
 		}
 	});
 
diff --git a/test/cset.test.js b/test/cset.test.js
index e4a8a8f..f3b8011 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -553,3 +553,208 @@ mod_tape.test('cset connect-reject (#92)', function (t) {
 		});
 	});
 });
+
+mod_tape.test('removing last backend (resolver)', function (t) {
+	connections = [];
+	resolver = new DummyResolver();
+	var inset = [];
+
+	var cset = new mod_cset.ConnectionSet({
+		log: log,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery,
+		target: 3,
+		maximum: 5,
+		resolver: resolver
+	});
+
+	cset.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
+			t.end();
+		}
+	});
+
+	cset.on('added', function (key, conn) {
+		inset.push(key);
+	});
+
+	cset.on('removed', function (key, conn, hdl) {
+		var idx = inset.indexOf(key);
+		t.notStrictEqual(idx, -1);
+		inset.splice(idx, 1);
+		conn.seen = true;
+		hdl.release();
+	});
+
+	resolver.emit('added', 'b1', {});
+	resolver.emit('added', 'b2', {});
+	resolver.emit('added', 'b3', {});
+	resolver.emit('added', 'b4', {});
+
+	cset.cs_keys.sort();
+	t.deepEqual(cset.cs_keys, ['b1', 'b2', 'b3', 'b4']);
+
+	setImmediate(function () {
+		t.equal(connections.length, 3);
+		summarize();
+		t.deepEqual(counts, { 'b1': 1, 'b2': 1, 'b3': 1 });
+		index.b1[0].connect();
+		index.b2[0].connect();
+		index.b3[0].connect();
+
+		setTimeout(function () {
+			t.equal(connections.length, 3);
+			summarize();
+			t.deepEqual(counts, { 'b1': 1, 'b2': 1, 'b3': 1 });
+			t.equal(inset.length, 3);
+
+			var conn1 = index.b1[0];
+			var conn2 = index.b2[0];
+			var conn3 = index.b3[0];
+
+			resolver.emit('removed', 'b1');
+			resolver.emit('removed', 'b2');
+			resolver.emit('removed', 'b3');
+
+			setTimeout(function () {
+				t.ok(conn1.dead);
+				t.ok(conn2.dead);
+				t.ok(conn3.dead);
+				t.ok(conn1.seen);
+				t.ok(conn2.seen);
+				t.ok(conn3.seen);
+
+				t.equal(inset.length, 0);
+				t.equal(connections.length, 1);
+				summarize();
+				t.deepEqual(counts, { 'b4': 1 });
+				index.b4[0].connect();
+
+				setTimeout(function () {
+					t.equal(connections.length, 1);
+					t.equal(inset.length, 1);
+					summarize();
+					t.deepEqual(counts, { 'b4': 1 });
+					cset.stop();
+					resolver.stop();
+				}, 1000);
+			}, 500);
+		}, 500);
+	});
+});
+
+mod_tape.test('removing last backend (rebal)', function (t) {
+	connections = [];
+	resolver = new DummyResolver();
+	var inset = [];
+	var events = [];
+
+	var cset = new mod_cset.ConnectionSet({
+		log: log,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery,
+		target: 2,
+		maximum: 5,
+		resolver: resolver
+	});
+
+	cset.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
+			t.end();
+		}
+	});
+
+	cset.on('added', function (key, conn) {
+		inset.push(key);
+		events.push(['added', conn.backend]);
+	});
+
+	cset.on('removed', function (key, conn, hdl) {
+		var idx = inset.indexOf(key);
+		t.notStrictEqual(idx, -1);
+		inset.splice(idx, 1);
+		events.push(['removed', conn.backend]);
+		conn.seen = true;
+		hdl.release();
+	});
+
+	resolver.emit('added', 'b1', {});
+	resolver.emit('added', 'b2', {});
+	resolver.emit('added', 'b3', {});
+	resolver.emit('added', 'b4', {});
+
+	cset.cs_keys.sort();
+	t.deepEqual(cset.cs_keys, ['b1', 'b2', 'b3', 'b4']);
+
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 1, 'b2': 1 });
+		t.equal(inset.length, 0);
+		index.b1[0].connect();
+		index.b2[0].connect();
+
+		setTimeout(function () {
+			t.equal(connections.length, 2);
+			t.equal(inset.length, 2);
+			summarize();
+			t.deepEqual(counts, { 'b1': 1, 'b2': 1 });
+
+			t.deepEqual(events, [
+				['added', 'b1'],
+				['added', 'b2']
+			]);
+			events = [];
+
+			var conn1 = index.b1[0];
+			var conn2 = index.b2[0];
+
+			cset.cs_keys.reverse();
+			cset.rebalance();
+
+			setTimeout(function () {
+				t.ok(conn1.dead);
+				t.ok(!conn2.dead);
+				t.ok(conn1.seen);
+				t.ok(!conn2.seen);
+
+				t.equal(inset.length, 1);
+				t.equal(connections.length, 3);
+				summarize();
+				t.deepEqual(counts,
+				    { 'b2': 1, 'b3': 1, 'b4': 1 });
+				t.deepEqual(events, [
+					['removed', 'b1']
+				]);
+				events = [];
+				index.b3[0].connect();
+				index.b4[0].connect();
+
+				setTimeout(function () {
+					t.equal(connections.length, 2);
+					t.equal(inset.length, 2);
+					summarize();
+					t.deepEqual(counts,
+					    { 'b3': 1, 'b4': 1 });
+					t.deepEqual(events, [
+						['added', 'b3'],
+						['added', 'b4'],
+						['removed', 'b2']
+					]);
+					t.ok(conn2.dead);
+					t.ok(conn2.seen);
+					cset.stop();
+					resolver.stop();
+				}, 1000);
+			}, 500);
+		}, 500);
+	});
+});
-- 
2.21.0

