commit 536aaa59cfa5f5354df337cc7da6d52106a7c827 (refs/changes/98/1498/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-02-10T16:02:45-08:00 (2 years, 8 months ago)
    
    joyent/node-cueball#94 ConnectionSet needs better protection against removing its last working connection

diff --git a/lib/set.js b/lib/set.js
index 90788b3..ef217a5 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -138,23 +138,89 @@ CueBallConnectionSet.prototype.on_resolver_added = function (k, backend) {
 CueBallConnectionSet.prototype.on_resolver_removed = function (k) {
 	var self = this;
 
-	var idx = this.cs_keys.indexOf(k);
-	mod_assert.notStrictEqual(idx, -1, 'Resolver removed key that is not ' +
-	    'present in cs_keys');
-	this.cs_keys.splice(idx, 1);
-	delete (this.cs_backends[k]);
-	delete (this.cs_dead[k]);
-
 	var fsm = self.cs_fsm[k];
-	if (fsm !== undefined)
-		fsm.setUnwanted();
+	var cks = this.cs_connectionKeys[k] || [];
 
-	var cks = this.cs_connectionKeys[k];
-	(cks || []).forEach(function (ck) {
-		var lconn = self.cs_lconns[ck];
-		if (!lconn.isInState('stopped'))
-			lconn.drain();
+	var advertised = false;
+	cks.forEach(function (ck) {
+		if (self.cs_lconns[ck].isInState('advertised'))
+			advertised = true;
 	});
+
+	var total = 0;
+	var adverts = 0;
+	this.cs_keys.forEach(function (key) {
+		if (self.cs_fsm[k] === undefined)
+			return;
+		var tcks = self.cs_connectionKeys[key] || [];
+		tcks.forEach(function (ck) {
+			if (self.cs_lconns[ck].isInState('advertised'))
+				++adverts;
+		});
+		++total;
+	});
+
+	/*
+	 * If this backend is the source of our very last advertised connection
+	 * at the moment, then we should delay removing it to give us a chance
+	 * to connect to other backends.
+	 */
+	if (adverts <= 1 && total > 1 && advertised) {
+		this.cs_log.info('backend "%s" has been removed, but ' +
+		    'it is the target of our last active connection. ' +
+		    'delaying removal in case we are connecting to others', k);
+
+		/* Keep retrying every 0.5s until we reach 5s, then give up. */
+		var retryTimer, finalTimer;
+		retryTimer = setInterval(function () {
+			total = 0;
+			adverts = 0;
+			self.cs_keys.forEach(function (key) {
+				if (self.cs_fsm[k] === undefined)
+					return;
+
+				var tcks = self.cs_connectionKeys[key] || [];
+				tcks.forEach(function (ck) {
+					var lconn = self.cs_lconns[ck];
+					if (lconn.isInState('advertised'))
+						++adverts;
+				});
+			});
+			if (adverts > 1) {
+				clearInterval(retryTimer);
+				clearTimeout(finalTimer);
+				doRemoval();
+			}
+		}, 500);
+		finalTimer = setTimeout(function () {
+			clearInterval(retryTimer);
+			self.cs_log.info('delayed removal of backend "%s" is ' +
+			    'taking took long, giving up and removing it ' +
+			    'anyway', k);
+			doRemoval();
+		}, 5000);
+	} else {
+		doRemoval();
+	}
+
+	function doRemoval() {
+		cks = self.cs_connectionKeys[k] || [];
+		var idx = self.cs_keys.indexOf(k);
+		mod_assert.notStrictEqual(idx, -1, 'Resolver removed key ' +
+		    'that is not present in cs_keys');
+		self.cs_keys.splice(idx, 1);
+		delete (self.cs_backends[k]);
+		delete (self.cs_dead[k]);
+
+		if (fsm !== undefined)
+			fsm.setUnwanted();
+
+		cks.forEach(function (ck) {
+			var lconn = self.cs_lconns[ck];
+			if (!lconn.isInState('stopped'))
+				lconn.drain();
+		});
+	}
 };
 
 CueBallConnectionSet.prototype.isDeclaredDead = function (backend) {
@@ -402,17 +468,24 @@ CueBallConnectionSet.prototype._rebalance = function () {
 			return;
 
 		var k = fsm.csf_backend.key;
-		/*
-		 * Find any advertised connections from this FSM, and (after
-		 * setting the closeAfterRelease flag to avoid them retrying),
-		 * emit 'removed' so our consumer will close them.
-		 */
-		var cks = self.cs_connectionKeys[k];
+
+		/* Subtract from "busy" so the "if" above does its job. */
+		if (fsm.isInState('busy'))
+			--busy;
 		fsm.setUnwanted();
+
+		/* We might have stopped synchronously. */
 		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
 			delete (self.cs_fsm[k]);
 			--total;
 		}
+
+		/*
+		 * Find any advertised connections from this FSM, and (after
+		 * setting the unwanted FSM flag to avoid them retrying), emit
+		 * 'removed' so our consumer will close them.
+		 */
+		var cks = self.cs_connectionKeys[k];
 		cks.forEach(function (ck) {
 			var lconn = self.cs_lconns[ck];
 			if (!lconn.isInState('stopped'))
@@ -562,6 +635,7 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 		if (newState === 'stopped' || newState === 'failed') {
 			delete (self.cs_fsm[key]);
 			self.emit('closedBackend', fsm);
+			self.rebalance();
 		}
 	});
 
diff --git a/test/cset.test.js b/test/cset.test.js
index e4a8a8f..3a7795d 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -553,3 +553,91 @@ mod_tape.test('cset connect-reject (#92)', function (t) {
 		});
 	});
 });
+
+mod_tape.test('removing last backend', function (t) {
+	connections = [];
+	resolver = new DummyResolver();
+
+	var cset = new mod_cset.ConnectionSet({
+		log: log,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery,
+		target: 3,
+		maximum: 5,
+		resolver: resolver
+	});
+
+	var stopTimer;
+	cset.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
+			t.end();
+		}
+	});
+
+	cset.on('added', function (key, conn) {
+	});
+
+	cset.on('removed', function (key, conn, hdl) {
+		conn.seen = true;
+		hdl.release();
+	});
+
+	resolver.emit('added', 'b1', {});
+	resolver.emit('added', 'b2', {});
+	resolver.emit('added', 'b3', {});
+	resolver.emit('added', 'b4', {});
+
+	cset.cs_keys.sort();
+	t.deepEqual(cset.cs_keys, ['b1', 'b2', 'b3', 'b4']);
+
+	setImmediate(function () {
+		t.equal(connections.length, 3);
+		summarize();
+		t.deepEqual(counts, { 'b1': 1, 'b2': 1, 'b3': 1 });
+		index.b1[0].connect();
+		index.b2[0].connect();
+		index.b3[0].connect();
+
+		setTimeout(function () {
+			t.equal(connections.length, 3);
+			summarize();
+			t.deepEqual(counts, { 'b1': 1, 'b2': 1, 'b3': 1 });
+
+			var conn1 = index.b1[0];
+			var conn2 = index.b2[0];
+			var conn3 = index.b3[0];
+
+			resolver.emit('removed', 'b1');
+			resolver.emit('removed', 'b2');
+			resolver.emit('removed', 'b3');
+
+			setTimeout(function () {
+				t.ok(conn1.dead);
+				t.ok(conn2.dead);
+				t.ok(!conn3.dead);
+				t.ok(conn1.seen);
+				t.ok(conn2.seen);
+				t.ok(!conn3.seen);
+
+				t.equal(connections.length, 2);
+				summarize();
+				t.deepEqual(counts, { 'b3': 1, 'b4': 1 });
+				index.b4[0].connect();
+
+				setTimeout(function () {
+					t.equal(connections.length, 1);
+					summarize();
+					t.deepEqual(counts, { 'b4': 1 });
+					t.ok(conn3.dead);
+					t.ok(conn3.seen);
+					cset.stop();
+					resolver.stop();
+				}, 1000);
+			}, 500);
+		}, 500);
+	});
+});
