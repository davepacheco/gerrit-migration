From f6140e8edc4df73304025cd1c6c92b6d46531fb0 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Tue, 30 Apr 2019 21:56:09 -0700
Subject: [PATCH] TRITON-1407 Migration sync fails with a snapshot out of space
 error for bhyve zones

---
 lib/backends/smartos/tasks/machine_migrate.js | 296 +++++++++++-------
 1 file changed, 190 insertions(+), 106 deletions(-)

diff --git a/lib/backends/smartos/tasks/machine_migrate.js b/lib/backends/smartos/tasks/machine_migrate.js
index 1ed40af..8a8c026 100644
--- a/lib/backends/smartos/tasks/machine_migrate.js
+++ b/lib/backends/smartos/tasks/machine_migrate.js
@@ -205,6 +205,158 @@ function zfsError(prefixMsg, error, stderr) {
 }
 
 
+function getFilesystemDetails(callback) {
+    var self = this;
+
+    var log = self.log;
+    var payload = self.req.params;
+
+    assert.object(payload, 'payload');
+    assert.object(payload.vm, 'payload.vm');
+
+    var vm = payload.vm;
+
+    // Delete any existing migration estimate snapshot.
+    var cmd = '/usr/sbin/zfs';
+    var args = [
+        'list',
+        '-Hp',
+        '-o',
+        'quota,reservation',
+        vm.zfs_filesystem
+    ];
+
+    log.debug({cmd: cmd, args: args}, 'getFilesystemDetails');
+
+    child_process.execFile(cmd, args, gExecFileDefaults,
+            function _execZfsDestroySnapshotCb(err, stdout, stderr) {
+        // Catch the error when a snapshot does not exist - that is allowed.
+        if (err) {
+            log.error('zfs list error:', err, ', stderr:', stderr);
+            self.fatal(new zfsError('zfs list failure', err, stderr));
+            return;
+        }
+
+        // Note that we are leaving these numbers as strings.
+        var values = stdout.trim().split('\t');
+        var result = {
+            quotaStr: values[0],
+            reservationStr: values[1]
+        };
+
+        log.debug('getFilesystemDetails:: result:', result);
+        self.finish(result);
+    });
+}
+
+
+function removeZfsQuota(callback) {
+    var self = this;
+
+    var log = self.log;
+    var payload = self.req.params;
+
+    assert.object(payload, 'payload');
+    assert.object(payload.vm, 'payload.vm');
+
+    var vm = payload.vm;
+
+    // Delete any existing migration estimate snapshot.
+    var cmd = '/usr/sbin/zfs';
+    var args = [
+        'set',
+        'quota=none',
+        vm.zfs_filesystem
+    ];
+
+    log.debug({cmd: cmd, args: args}, 'removeZfsQuota');
+
+    child_process.execFile(cmd, args, gExecFileDefaults,
+            function _execZfsDestroySnapshotCb(err, stdout, stderr) {
+        // Catch the error when a snapshot does not exist - that is allowed.
+        if (err) {
+            log.error('zfs set error:', err, ', stderr:', stderr);
+            self.fatal(new zfsError('zfs set failure', err, stderr));
+            return;
+        }
+
+        self.finish();
+    });
+}
+
+
+function restoreZfsQuota(callback) {
+    var self = this;
+
+    var log = self.log;
+    var payload = self.req.params;
+
+    assert.object(payload, 'payload');
+    assert.object(payload.vm, 'payload.vm');
+    assert.string(payload.vm.zfs_filesystem, 'payload.vm.zfs_filesystem');
+
+    var vm = payload.vm;
+
+    // Determine what the current used size is, then set the zfs filesystem
+    // quota to that value.
+    vasync.pipeline({arg: {}, funcs: [
+        function getUsedSize(ctx, next) {
+            var cmd = '/usr/sbin/zfs';
+            var args = [
+                'list',
+                '-Hp',
+                '-o',
+                'used',
+                vm.zfs_filesystem
+            ];
+
+            log.debug({cmd: cmd, args: args}, 'restoreZfsQuota');
+
+            child_process.execFile(cmd, args, gExecFileDefaults,
+                    function _execZfsListUsedSizeCb(err, stdout, stderr) {
+                if (err) {
+                    log.error('zfs list error:', err, ', stderr:', stderr);
+                    next(new zfsError('zfs list failure', err, stderr));
+                    return;
+                }
+
+                ctx.quotaStr = stdout.trim();
+                next();
+            });
+        },
+
+        function setQuota(ctx, next) {
+            var cmd = '/usr/sbin/zfs';
+            var args = [
+                'set',
+                'quota=' + ctx.quotaStr,
+                vm.zfs_filesystem
+            ];
+
+            log.debug({cmd: cmd, args: args}, 'setQuota');
+
+            child_process.execFile(cmd, args, gExecFileDefaults,
+                    function _execZfsSetQuotaCb(err, stdout, stderr) {
+                if (err) {
+                    log.error('zfs set error:', err, ', stderr:', stderr);
+                    next(new zfsError('zfs set failure', err, stderr));
+                    return;
+                }
+
+                next();
+            });
+        }
+    ]}, function _pipelineCb(err) {
+        if (err) {
+            self.fatal(err);
+            return;
+        }
+
+        self.finish();
+    });
+}
+
+
 function deleteSnapshot(snapshot, log, callback) {
     assert.string(snapshot, 'snapshot');
     assert.object(log, 'log');
@@ -250,7 +402,6 @@ function estimate(callback) {
 
     var estimatedSize = 0;
     var vm = payload.vm;
-    var isDocker = (vm.brand === 'lx' && vm.docker === true);
 
     // This is the main context for each dataset sync operation.
     var datasets = [vm.zfs_filesystem];
@@ -265,121 +416,46 @@ function estimate(callback) {
         });
     }
 
-    function estimateOneDataset(dataset, next) {
-        var ctx = {
-            snapshot: dataset + '@' + SNAPSHOT_NAME_PREFIX
-        };
-
-        vasync.pipeline({funcs: [
-            // Delete any existing migration estimate snapshot.
-            function deletePreviousSnapshot(_, cb) {
-                deleteSnapshot(ctx.snapshot, log, cb);
-            },
-
-            // Create a temporary snapshot to get an estimate.
-            function createSnapshot(_, cb) {
-                var cmd = '/usr/sbin/zfs';
-                var args = [
-                    'snapshot',
-                    '-r',
-                    ctx.snapshot
-                ];
-
-                log.debug({cmd: cmd, args: args}, 'zfs snapshot');
-
-                child_process.execFile(cmd, args, gExecFileDefaults,
-                        function _execZfsSnapshotCb(err, stdout, stderr) {
-                    if (err) {
-                        log.error('zfs snapshot error:', err,
-                            ', stderr:', stderr);
-                            cb(new zfsError('zfs snapshot failure',
-                                err, stderr));
-                        return;
-                    }
-
-                    ctx.snapshotCreated = true;
-                    cb();
-                });
-            },
-
-            // Get the estimate for the snapshot.
-            function getEstimate(_, cb) {
-                var replicateArg = '--replicate';
-
-                // Docker datasets are created on demand for each CN, so they
-                // will always be different between each CN. Thus we don't want
-                // the usual --replicate argument (as that will expect the
-                // origin dataset to be the same) - we want a full send instead.
-                if (isDocker) {
-                    replicateArg = '--props';
-                }
+    function estimateOneDataset(dataset, cb) {
+        var cmd = '/usr/sbin/zfs';
+        var args = [
+            'list',
+            '-p', // computer parseable
+            '-r', // recursive
+            '-H', // no headers
+            '-o', 'usedds',
+            dataset
+        ];
 
-                var cmd = '/usr/sbin/zfs';
-                var args = [
-                    'send',
-                    '--dryrun',
-                    '--parsable',
-                    replicateArg,
-                    ctx.snapshot
-                ];
-
-                log.info({cmd: cmd, args: args}, 'getEstimate');
-
-                child_process.execFile(cmd, args, gExecFileDefaults,
-                        function _execZfsSendEstimateCb(error, stdout, stderr) {
-                    if (error) {
-                        log.error('zfs snapshot error:', error,
-                            ', stderr:', stderr);
-                        cb(zfsError('zfs snapshot error', error, stderr));
-                        return;
-                    }
-
-                    var lines = stdout.trim().split('\n');
-                    var lastLine = lines.splice(-1)[0].trim();
-                    log.trace('getEstimate:: lastLine: %s', lastLine);
-
-                    var match = lastLine.match(/^size\s+(\d+)$/);
-                    if (!match) {
-                        log.error('Unable to get zfs send estimate, stdout:',
-                            stdout);
-                        cb(new Error('Unable to get zfs send estimate'));
-                        return;
-                    }
-
-                    log.debug({dataset: dataset, estimate: match[1]},
-                        'getEstimate');
-
-                    estimatedSize += Number(match[1]);
-
-                    cb();
-                });
-            },
-
-            // Delete the created migration estimate snapshot.
-            function cleanupSnapshot(_, cb) {
-                deleteSnapshot(ctx.snapshot, log, cb);
-            }
+        log.info({cmd: cmd, args: args}, 'getEstimate');
 
-        ]}, function _onEstimateOneDatasetPipelineCb(err) {
-            if (err) {
-                if (ctx.snapshotCreated) {
-                    deleteSnapshot(ctx.snapshot, log, function _deleteCb(err2) {
-                        // Ignoring err2 and using original err.
-                        next(err);
-                        return;
-                    });
-                }
-                next(err);
+        child_process.execFile(cmd, args, gExecFileDefaults,
+                function _execZfsSendEstimateCb(error, stdout, stderr) {
+            if (error) {
+                log.error('zfs list error:', error, ', stderr:', stderr);
+                cb(zfsError('zfs list error', error, stderr));
                 return;
             }
-            next();
+
+            var size = 0;
+            var lines = stdout.trim().split('\n');
+
+            lines.map(function _estimateLine(line) {
+                size += parseInt(line, 10) || 0;
+            });
+
+            log.debug({dataset: dataset, estimate: size}, 'getEstimate');
+
+            estimatedSize += size;
+
+            cb();
         });
     }
 
     vasync.forEachParallel({inputs: datasets, func: estimateOneDataset},
             function _onEstimateComplete(err) {
         if (err) {
-            // log.error('estimate failure', err);
+            log.error('estimate failure', err);
             self.fatal(err);
             return;
         }
@@ -633,9 +709,17 @@ function start(callback) {
     if (payload.action === 'kill_migration_process') {
         killChild.bind(this)(callback);
 
+    /* Begin */
+    } else if (payload.action === 'get-filesystem-details') {
+        getFilesystemDetails.bind(this)(callback);
+
     /* Sync */
     } else if (payload.action === 'sync' || payload.action === 'receive') {
         startChildProcess.bind(this)(callback);
+    } else if (payload.action === 'remove-zfs-quota') {
+        removeZfsQuota.bind(this)(callback);
+    } else if (payload.action === 'restore-zfs-quota') {
+        restoreZfsQuota.bind(this)(callback);
 
     /* Estimate */
     } else if (payload.action === 'estimate') {
-- 
2.21.0

