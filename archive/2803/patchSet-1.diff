commit c8f9bb6859a600fd1d65f716339ed9136bafdf7b (refs/changes/03/2803/1)
Author: Jordan Hendricks <jordan.hendricks@joyent.com>
Date:   2017-09-27T16:25:29+00:00 (2 years ago)
    
    Unit tests added for all streams except moray cleaner. Make check clean.

diff --git a/bin/kick_off_mpu_gc.js b/bin/kick_off_mpu_gc.js
index 0493be0..35687d2 100755
--- a/bin/kick_off_mpu_gc.js
+++ b/bin/kick_off_mpu_gc.js
@@ -132,8 +132,10 @@ function getMpuGcCmd(opts) {
         if (opts.gracePeriodSeconds) {
                 gracePeriodOption = ' -g ' + opts.gracePeriodSeconds;
         }
-        //We use a UUID only because there's no way (yet) to get a reference
-        // to which reducer this is running on.
+        /*
+         * As the normal GC job does, we use a UUID only because there's no way
+         * (yet) to get a reference to which reducer this is running on.
+         */
 /* BEGIN JSSTYLED */
         return (getEnvCommon(opts) + ' \
 export UUID=$(uuid) && \
@@ -292,7 +294,6 @@ function extractDate(p) {
 
 /*
  * Determines what input objects to pass to the MPU GC job.
- * TODO
  *
  * Inputs:
  *  - opts: an options block passed directly to common.findObjectsForShards
@@ -327,7 +328,7 @@ function findMpuGcObjects(opts, cb) {
                 for (var j = 0; j < results.length; ++j) {
                         var obj = results[j];
                         objects.push(obj);
-                        //Get the date from the filename...
+                        // Get the date from the filename.
                         dates.push(extractDate(obj));
                 }
 
diff --git a/bin/mpu_moray_gc.js b/bin/mpu_moray_gc.js
index f7fc748..7586f56 100755
--- a/bin/mpu_moray_gc.js
+++ b/bin/mpu_moray_gc.js
@@ -49,8 +49,12 @@ var mmcls = vstream.wrapStream(
 var mpuGcStreams = new vstream.PipelineStream({
         streams: [
                 vstream.wrapTransform(new lstream({ highWaterMark: 0 })),
-                vstream.wrapTransform(new mpu.createMpuBatchStream({ log: LOG })),
-                vstream.wrapTransform(new mpu.createMpuVerifyStream({ log: LOG })),
+                vstream.wrapTransform(new mpu.createMpuBatchStream({
+                        log: LOG
+                })),
+                vstream.wrapTransform(new mpu.createMpuVerifyStream({
+                        log: LOG
+                })),
                 vstream.wrapTransform(new mpu.createMpuUnlinkLiveRecordStream({
                         log: LOG,
                         dryRun: true,
diff --git a/lib/mpu/common.js b/lib/mpu/common.js
index 0c6c4c5..30f2a39 100644
--- a/lib/mpu/common.js
+++ b/lib/mpu/common.js
@@ -124,17 +124,17 @@ function FinalizingRecord(opts) {
         this.shard = opts.shard;
         this.date = opts.date;
         this.type = opts.type;
-
-        this.toString = function toString() {
-                return (this.uploadId + '\t' +
-                        MPUOBJ_FINALIZINGRECORD + '\t' +
-                        this.date + '\t' +
-                        this.shard + '\t' +
-                        this.type + '\t' +
-                        this.key);
-        };
 }
 
+FinalizingRecord.prototype.toString = function toString() {
+        return (this.uploadId + '\t' +
+                MPUOBJ_FINALIZINGRECORD + '\t' +
+                this.date + '\t' +
+                this.shard + '\t' +
+                this.type + '\t' +
+                this.key);
+};
+
 /*
  * Represents a "live" Manta record in the streams that process the metadata
  * record cleanup. In particular, a live record is either the part record or
@@ -160,16 +160,8 @@ function LiveRecord(opts) {
         this.key = opts.key;
         this.date = opts.date;
         this.type = opts.type;
-
-        this.toString = function toString() {
-                return (this.uploadId + '\t' +
-                        this.type + '\t' +
-                        this.date + '\t' +
-                        this.key);
-        };
 }
 
-
 /*
  * Represents a collection of all of the records related to a given multipart
  * upload.
diff --git a/lib/mpu/mpuBatchStream.js b/lib/mpu/mpuBatchStream.js
index 64dab05..f71523d 100644
--- a/lib/mpu/mpuBatchStream.js
+++ b/lib/mpu/mpuBatchStream.js
@@ -25,20 +25,20 @@ var sprintf = util.format;
  * exception if it encounters the same upload ID twice.
  *
  * Parameters:
- * - "opts": an options object with the following required parameters:
+ * - "args": an options object with the following required parameters:
  *      - "log": a bunyan logger
  */
-function MpuBatchStream(opts) {
+function MpuBatchStream(args) {
         var self = this;
 
-        assert.object(opts, 'opts');
-        assert.object(opts.log, 'opts.log');
+        assert.object(args, 'args');
+        assert.object(args.log, 'args.log');
 
         stream.Transform.call(this, {
             objectMode: true,
             highWaterMark: 0
         });
-        self.log = opts.log;
+        self.log = args.log;
 
         /* Current batch pointers */
         self.mpu_batch = [];            // array of record objects in the batch
diff --git a/lib/mpu/mpuMorayCleanerStream.js b/lib/mpu/mpuMorayCleanerStream.js
index 6012a21..44d0853 100644
--- a/lib/mpu/mpuMorayCleanerStream.js
+++ b/lib/mpu/mpuMorayCleanerStream.js
@@ -19,21 +19,21 @@ var mpuCommon = require('./common');
 /*
  * MpuMorayCleanerStream: Deletes the finalizing record for the MPU.
  */
-function MpuMorayCleanerStream(opts) {
-        assert.object(opts, 'opts');
-        assert.object(opts.log, 'opts.log');
-        assert.optionalBool(opts.dryRun, 'opts.dryRun');
-        assert.optionalBool(opts.verbose, 'opts.verbose');
+function MpuMorayCleanerStream(args) {
+        assert.object(args, 'args');
+        assert.object(args.log, 'args.log');
+        assert.optionalBool(args.dryRun, 'args.dryRun');
+        assert.optionalBool(args.verbose, 'args.verbose');
 
         stream.Writable.call(this, {
             objectMode: true,
             highWaterMark: 0
         });
 
-        this.log = opts.log;
+        this.log = args.log;
         this.morayClients = {};
-        this.dryRun = opts.dryRun;
-        this.verbose = opts.verbose;
+        this.dryRun = args.dryRun;
+        this.verbose = args.verbose;
 
         var self = this;
         this.on('finish', function () {
diff --git a/lib/mpu/mpuUnlinkLiveRecordStream.js b/lib/mpu/mpuUnlinkLiveRecordStream.js
index eff0f4b..4020bf8 100644
--- a/lib/mpu/mpuUnlinkLiveRecordStream.js
+++ b/lib/mpu/mpuUnlinkLiveRecordStream.js
@@ -23,29 +23,43 @@ var MULRS_TYPE_UPLOADDIR = 'uploadRecord';
 
 
 /*
- * MpuUnlinkStream: Unlinks parts directory and its contents.
+ * MpuUnlinkStream: Unlinks live records in Manta as part of the MPU garbage
+ * collection process. Depending on the arguments to its constructor, this
+ * stream will unlink a collection of parts in an upload directory or the upload
+ * directory itself.
+ *
+ * Parameters:
+ *  - args: an options block with the following required arguments:
+ *      - log:
+ *      - type:
+ *      - mantaClient:
+ *      - mahiClient:
+ *
+ *    and the following optional arguments:
+ *      - dryRun:
+ *      - verbose:
  */
-function MpuUnlinkLiveRecordStream(opts) {
-        assert.object(opts, 'opts');
-        assert.object(opts.log, 'opts.log');
-        assert.string(opts.type, 'opts.type');
-        assert.ok(opts.type === 'partRecords' || opts.type === 'uploadRecord');
-        assert.object(opts.mantaClient, 'opts.mantaClient');
-        assert.object(opts.mahiClient, 'opts.mahiClient');
-        assert.optionalBool(opts.dryRun, 'opts.dryRun');
-        assert.optionalBool(opts.verbose, 'opts.verbose');
+function MpuUnlinkLiveRecordStream(args) {
+        assert.object(args, 'args');
+        assert.object(args.log, 'args.log');
+        assert.string(args.type, 'args.type');
+        assert.ok(args.type === 'partRecords' || args.type === 'uploadRecord');
+        assert.object(args.mantaClient, 'args.mantaClient');
+        assert.object(args.mahiClient, 'args.mahiClient');
+        assert.optionalBool(args.dryRun, 'args.dryRun');
+        assert.optionalBool(args.verbose, 'args.verbose');
 
         stream.Transform.call(this, {
                 objectMode: true,
                 highWaterMark: 0
         });
 
-        this.log = opts.log;
-        this.mantaClient = opts.mantaClient;
-        this.mahiClient = opts.mahiClient;
-        this.type = opts.type;
-        this.dryRun = opts.dryRun;
-        this.verbose = opts.verbose;
+        this.log = args.log;
+        this.mantaClient = args.mantaClient;
+        this.mahiClient = args.mahiClient;
+        this.type = args.type;
+        this.dryRun = args.dryRun;
+        this.verbose = args.verbose;
 }
 util.inherits(MpuUnlinkLiveRecordStream, stream.Transform);
 
@@ -58,10 +72,9 @@ function mulrsWrite(batch, _, cb) {
         assert.optionalArrayOfObject(batch.partRecords, 'batch.partRecords');
 
         var self = this;
-        //self.log.info('unlink ' + batch.uploadId);
         if (!batch[self.type]) {
+        assert.object(batch, 'batch');
                 self.push(batch);
-                //self.log.info('mulrs cb (no unlink code run, type ' + self.type + '): ' + batch.uploadId);
                 setImmediate(cb);
                 return;
         }
@@ -125,8 +138,6 @@ function mulrsWrite(batch, _, cb) {
                         func: function optionalUnlinkLiveRecord(r, vcb) {
                                 assert.string(r.key);
                                 var mantaPath = r.key.replace(uuid, account);
-                                //self.log.info('key: \"' + r.key + '\", path: \"'
-                                        //+ mantaPath + '\"');
 
                                 if (self.verbose) {
                                         console.error('unlink ' + mantaPath);
@@ -135,7 +146,6 @@ function mulrsWrite(batch, _, cb) {
                                 if (!self.dryRun) {
                                         unlink(mantaPath, vcb);
                                 } else {
-                                        //self.log.info('mulrs cb (dry run): ' + batch.uploadId);
                                         vcb();
                                 }
                         },
@@ -153,11 +163,9 @@ function mulrsWrite(batch, _, cb) {
                                                    'stream failure');
                                         });
                                 } else {
-                                        //self.log.info('pushing batch to next stream: ' + batch.uploadId);
                                         self.push(batch);
                                 }
 
-                                //self.log.info('vasync cb: ' + batch.uploadId);
                                 cb();
                         }
                 });
diff --git a/lib/mpu/mpuVerifyStream.js b/lib/mpu/mpuVerifyStream.js
index add099e..b52978a 100644
--- a/lib/mpu/mpuVerifyStream.js
+++ b/lib/mpu/mpuVerifyStream.js
@@ -27,16 +27,16 @@ var MULRS_TYPE_UPLOADDIR = mulrs.MULRS_TYPE_UPLOADDIR;
  * The MPU is a valid candidate for garbage collection if a finalizing
  * record exists for the MPU.
  */
-function MpuVerifyStream(opts) {
-        assert.object(opts, 'opts');
-        assert.object(opts.log, 'opts.log');
+function MpuVerifyStream(args) {
+        assert.object(args, 'args');
+        assert.object(args.log, 'args.log');
 
         stream.Transform.call(this, {
             objectMode: true,
             highWaterMark: 0
         });
 
-        this.log = opts.log;
+        this.log = args.log;
 }
 util.inherits(MpuVerifyStream, stream.Transform);
 module.exports = MpuVerifyStream;
@@ -56,14 +56,14 @@ MpuVerifyStream.prototype.validateMPU = function validateMPU(id, records, cb) {
 
         var self = this;
 
-        var uploadRecord, partRecords, finalizingRecord = null;
+        var uploadRecord, partRecords, finalizingRecord;
         var invalidBatch = false;
 
         records.forEach(function (r) {
                 assert.ok(r instanceof mpuCommon.LiveRecord ||
                           r instanceof mpuCommon.FinalizingRecord);
-                var rId = r.uploadId;
 
+                var rId = r.uploadId;
                 if (id !== rId) {
                         self.log.error({
                                 batchUploadId: id,
@@ -126,6 +126,13 @@ MpuVerifyStream.prototype.validateMPU = function validateMPU(id, records, cb) {
                 }
         });
 
+        if (partRecords && partRecords.length > 0 && !uploadRecord) {
+                self.log.error({
+                        uploadId: id
+                }, 'part records found, but no upload record');
+                invalidBatch = true;
+        }
+
         if (!invalidBatch && finalizingRecord) {
                 assert.ok(finalizingRecord);
                 assert.optionalObject(uploadRecord);
diff --git a/test/mpu/.mpuBatchStream.test.js.swp b/test/mpu/.mpuBatchStream.test.js.swp
new file mode 100644
index 0000000..19bad74
Binary files /dev/null and b/test/mpu/.mpuBatchStream.test.js.swp differ
diff --git a/test/mpu/.mpuUnlinkLiveRecordStream.test.js.swp b/test/mpu/.mpuUnlinkLiveRecordStream.test.js.swp
new file mode 100644
index 0000000..03d2164
Binary files /dev/null and b/test/mpu/.mpuUnlinkLiveRecordStream.test.js.swp differ
diff --git a/test/mpu/mpuBatchStream.test.js b/test/mpu/mpuBatchStream.test.js
new file mode 100644
index 0000000..c3cf179
--- /dev/null
+++ b/test/mpu/mpuBatchStream.test.js
@@ -0,0 +1,227 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var jsprim = require('jsprim');
+var lstream = require('lstream');
+var MemoryStream = require('memorystream');
+var util = require('util');
+var uuid = require('libuuid');
+var stream = require('stream');
+
+var helper = require('../helper');
+var inputs = require('./testInputs');
+var mpu = require('../../lib/mpu');
+var mpuCommon = require('../../lib/mpu/common');
+
+///--- Globals
+
+var test = helper.test;
+var sprintf = util.format;
+
+var LOG = helper.createLogger('mpuBatchStream test');
+
+var MBS_ARGS = {
+        log: LOG
+};
+
+
+///--- Helpers
+
+function testMpuBatchStream(args) {
+        assert.object(args, 'args');
+        assert.arrayOfString(args.input, 'args.input');
+        assert.arrayOfObject(args.output, 'args.output');
+        assert.func(args.testCb, 'args.testCb');
+
+        var vsArgs = {
+                cb: args.testCb,
+                expect: args.output
+        };
+
+        var r = new stream.Readable({
+                objectMode: true
+        });
+        var mbs = new mpu.createMpuBatchStream(MBS_ARGS);
+        var vs = new inputs.ValidationStream(vsArgs);
+
+        args.input.forEach(function (i) {
+                r.push(i, 'utf8');
+        });
+        r.push(null);
+        r.pipe(mbs).pipe(vs);
+}
+
+
+///--- Tests
+
+test('single-record batch (FR only)', function (t) {
+        var input = [
+                inputs.FR_0
+        ];
+
+        var output = [ {
+                uploadId: inputs.ID_0,
+                records: [
+                        inputs.OBJ_FR0
+                ]
+        } ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuBatchStream(args);
+});
+
+test('multiple-record batch (FR, UR)', function (t) {
+        var input = [
+                inputs.FR_0, inputs.UR_0
+        ];
+
+        var output = [ {
+                uploadId: inputs.ID_0,
+                records: [
+                        inputs.OBJ_FR0, inputs.OBJ_UR0
+                ]
+        } ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuBatchStream(args);
+});
+
+test('multiple-record batch (with parts)', function (t) {
+        var input = [
+                inputs.FR_0, inputs.UR_0, inputs.PR_0[0]
+        ];
+
+        var output = [ {
+                uploadId: inputs.ID_0,
+                records: [
+                        inputs.OBJ_FR0, inputs.OBJ_UR0, inputs.OBJ_PR0[0]
+                ]
+        } ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuBatchStream(args);
+});
+
+test('multiple batches', function (t) {
+        var input = [
+                inputs.FR_0, inputs.UR_0, inputs.PR_0[0],
+                inputs.FR_2, inputs.UR_2,
+                inputs.FR_1, inputs.UR_1, inputs.PR_1[0], inputs.PR_1[1],
+                        inputs.PR_1[2]
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuBatchStream(args);
+});
+
+test('records out of order', function (t) {
+        var input = [
+                inputs.FR_0, inputs.UR_0,
+                inputs.FR_2, inputs.UR_2,
+                inputs.PR_0[0]
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.fail('records out of order');
+                        if (ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        var d = require('domain').create();
+        d.on('error', function (err) {
+                t.ok(err, 'no error');
+                t.done();
+        });
+        d.run(function () {
+                testMpuBatchStream(args);
+        });
+});
diff --git a/test/mpu/mpuUnlinkLiveRecordStream.test.js b/test/mpu/mpuUnlinkLiveRecordStream.test.js
new file mode 100644
index 0000000..30fe86f
--- /dev/null
+++ b/test/mpu/mpuUnlinkLiveRecordStream.test.js
@@ -0,0 +1,1150 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+
+///--- Globals
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var stream = require('stream');
+
+var helper = require('../helper');
+var inputs = require('./testInputs');
+var mpu = require('../../lib/mpu');
+var test = helper.test;
+
+var LOG = helper.createLogger('mpuUnlinkStream test');
+
+///--- Helpers
+
+function testMpuUnlinkLiveRecordStream(args) {
+        assert.object(args, 'args');
+        assert.arrayOfObject(args.input, 'args.input');
+        assert.arrayOfObject(args.output, 'args.output');
+        assert.func(args.testCb, 'args.testCb');
+        assert.string(args.type, 'args.type');
+        assert.ok(args.type === 'partRecords' || args.type === 'uploadRecord');
+        assert.func(args.unlinkFunc, 'args.unlinkFunc');
+        assert.func(args.getAccountByIdFunc, 'args.getAccountByIdFunc');
+        assert.optionalBool(args.dryRun, 'args.dryRun');
+        assert.optionalBool(args.verbose, 'args.verbose');
+
+        var mockMahiClient = {
+                getAccountById: args.getAccountByIdFunc
+        };
+
+        var mockMantaClient = {
+                unlink: args.unlinkFunc
+        };
+
+        var mvs = new mpu.createMpuUnlinkLiveRecordStream({
+                log: LOG,
+                type: args.type,
+                mantaClient: mockMantaClient,
+                mahiClient: mockMahiClient,
+                dryRun: args.dryRun,
+                verbose: args.verbose
+        });
+
+        var vsOpts = {
+                cb: args.testCb,
+                expect: args.output
+        };
+        var vs = new inputs.ValidationStream(vsOpts);
+
+        var r = new stream.Readable({
+                objectMode: true
+        });
+
+        args.input.forEach(function (i) {
+                r.push(i);
+        });
+        r.push(null);
+        r.pipe(mvs).pipe(vs);
+}
+
+///--- Tests: upload directory
+
+test('upload directory: one batch (no parts)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0, 'uuid mismatch');
+                gcb(null, {
+                        account: {
+                                login: inputs.ACCT_LOGIN_0
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+
+                        t.ok(jsprim.deepEqual(paths, expected));
+
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('upload directory: one batch (3 parts)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR1
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_1, 'uuid mismatch');
+                gcb(null, {
+                        account: {
+                                login: inputs.ACCT_LOGIN_1
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('upload directory: multiple batches', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0,
+                inputs.PATH_UR1,
+                inputs.PATH_UR2
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('upload directory: multiple batches (one with no UR)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0,
+                inputs.PATH_UR2
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('upload directory: 404 returned during unlink', function (t) {
+        /*
+         * Deliberately return a 404 for the upload directory. In this case, we
+         * would still expect to see the batch pushed to the next stream.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0,
+                inputs.PATH_UR2,
+                inputs.PATH_UR1
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                if (p === inputs.PATH_UR2) {
+                        ucb(new Error('simulated 404'), {
+                                statusCode: 404
+                        });
+                } else {
+                        var res = {
+                                statusCode: 204
+                        };
+
+                        ucb(null, res);
+                }
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+
+test('upload directory: error returned during unlink', function (t) {
+        /*
+         * Deliberately fail a request for one of the upload directory unlinks.
+         * We expect to see that batch dropped from the stream, but everything
+         * else to continue working.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1
+                }
+        ];
+
+        var output = [ input[0], input[2] ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0,
+                inputs.PATH_UR2,
+                inputs.PATH_UR1
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                // Fail one of the requests.
+                if (p === inputs.PATH_UR2) {
+                        ucb(new Error('simulated server error'), {
+                                statusCode: 503
+                        });
+                } else {
+                        var res = {
+                                statusCode: 204
+                        };
+
+                        ucb(null, res);
+                }
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('upload directory: error returned during getAccountById', function (t) {
+        /*
+         * Deliberately fail a request for one of the uuid lookups from mahi.
+         * We expect to see that batch dropped from the stream, but everything
+         * else to continue working.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1
+                }
+        ];
+
+        var output = [ input[0], input[2] ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_UR0,
+                inputs.PATH_UR1
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+
+                var err, login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                        err = new Error('simulated mahi error');
+                }
+
+                gcb(err, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'uploadRecord'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+
+
+///--- Tests: part records
+
+test('parts: one batch (1 part)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0]
+                        ]
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR1[0]
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_1, 'uuid mismatch');
+                gcb(null, {
+                        account: {
+                                login: inputs.ACCT_LOGIN_1
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('parts: one batch (3 parts)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR1[0],
+                inputs.PATH_PR1[1],
+                inputs.PATH_PR1[2]
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_1, 'uuid mismatch');
+                gcb(null, {
+                        account: {
+                                login: inputs.ACCT_LOGIN_1
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('parts: multiple batches (3 parts, 1', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR0[0],
+                inputs.PATH_PR1[0],
+                inputs.PATH_PR1[1],
+                inputs.PATH_PR1[2]
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('parts: 404 returned during unlink', function (t) {
+        /*
+         * Deliberately return a 404 for a part. In this case, we
+         * would still expect to see the batch pushed to the next stream.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                }
+        ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR0[0],
+                inputs.PATH_PR1[0],
+                inputs.PATH_PR1[1]
+        ];
+
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                if (p === inputs.PATH_PR1[0]) {
+                        ucb(new Error('simulated 404'), {
+                                statusCode: 404
+                        });
+                } else {
+                        var res = {
+                                statusCode: 204
+                        };
+
+                        ucb(null, res);
+                }
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: input,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+
+test('parts: error returned during unlink', function (t) {
+        /*
+         * Deliberately fail a request for one of the part unlinks.
+         * We expect to see that batch dropped from the stream, but everything
+         * else to continue working.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                }
+        ];
+
+        var output = [ input[0], input[1] ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR0[0],
+                inputs.PATH_PR1[0],
+                inputs.PATH_PR1[1]
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                // Fail one of the requests.
+                if (p === inputs.PATH_PR1[0]) {
+                        ucb(new Error('simulated server error'), {
+                                statusCode: 503
+                        });
+                } else {
+                        var res = {
+                                statusCode: 204
+                        };
+
+                        ucb(null, res);
+                }
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+                var login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(null, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
+
+test('parts: error returned during getAccountById', function (t) {
+        /*
+         * Deliberately fail a request for one of the uuid lookups from mahi.
+         * We expect to see that batch dropped from the stream, but everything
+         * else to continue working.
+         */
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                }
+        ];
+
+        var output = [ input[0], input[2] ];
+
+        var paths = [];
+        var expected = [
+                inputs.PATH_PR0[0]
+        ];
+        function unlink(p, opts, ucb) {
+                t.ok(typeof (opts) === 'object');
+                t.ok(jsprim.deepEqual(opts, {
+                        query: {
+                                override: true
+                        }
+                }));
+                paths.push(p);
+
+                var res = {
+                        statusCode: 204
+                };
+
+                ucb(null, res);
+        }
+
+        function getAccountById(uuid, gcb) {
+                t.ok(uuid === inputs.ACCT_ID_0 ||
+                        uuid === inputs.ACCT_ID_1 ||
+                        uuid == inputs.ACCT_ID_2, 'uuid mismatch');
+
+                var err, login;
+                if (uuid === inputs.ACCT_ID_0) {
+                        login = inputs.ACCT_LOGIN_0;
+                } else if (uuid === inputs.ACCT_ID_1) {
+                        login = inputs.ACCT_LOGIN_1;
+                        err = new Error('simulated mahi error');
+                } else {
+                        login = inputs.ACCT_LOGIN_2;
+                }
+
+                gcb(err, {
+                        account: {
+                                login: login
+                        }
+                });
+        }
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                debugger;
+                        t.ok(jsprim.deepEqual(paths, expected));
+                        t.done();
+                },
+                unlinkFunc: unlink,
+                getAccountByIdFunc: getAccountById,
+                type: 'partRecords'
+        };
+
+        testMpuUnlinkLiveRecordStream(args);
+});
diff --git a/test/mpu/mpuVerifyStream.test.js b/test/mpu/mpuVerifyStream.test.js
new file mode 100644
index 0000000..139f26d
--- /dev/null
+++ b/test/mpu/mpuVerifyStream.test.js
@@ -0,0 +1,829 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+
+///--- Globals
+
+var assert = require('assert-plus');
+var stream = require('stream');
+
+var helper = require('../helper');
+var inputs = require('./testInputs');
+var mpu = require('../../lib/mpu');
+var test = helper.test;
+
+var LOG = helper.createLogger('mpuVerifyStream test');
+
+var MVS_ARGS = {
+        log: LOG
+};
+
+///--- Helpers
+
+function testMpuVerifyStream(args) {
+        assert.object(args, 'args');
+        assert.arrayOfObject(args.input, 'args.input');
+        assert.arrayOfObject(args.output, 'args.output');
+        assert.func(args.testCb, 'args.testCb');
+
+        var vsArgs = {
+                cb: args.testCb,
+                expect: args.output
+        };
+
+        var mvs = new mpu.createMpuVerifyStream(MVS_ARGS);
+        var vs = new inputs.ValidationStream(vsArgs);
+        var r = new stream.Readable({
+                objectMode: true
+        });
+
+        args.input.forEach(function (i) {
+                r.push(i);
+        });
+        r.push(null);
+        r.pipe(mvs).pipe(vs);
+}
+
+///--- Tests
+
+test('single-record batch (FR only, commit)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: undefined,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('single-record batch (FR only, abort)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: undefined,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+
+
+test('multiple-record batch (FR, UR)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple-record batch (1 part)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple-record batch (3 parts)', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple batches', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+// Bad Input: We expect batches with bad input to be dropped from the stream.
+
+test('batch with different upload ids between FR and UR', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR1
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('batch with different upload ids between FR and PR', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_PR1[0]
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+
+test('batch with different upload ids between UR and PR', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR1[0]
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+
+test('batch with different upload ids: multiple batches', function (t) {
+        var input = [
+                // valid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                // invalid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR1[0]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('missing FR', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_UR1
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('missing FR: multiple batches', function (t) {
+        var input = [
+                // valid batch
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                },
+                // invalid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple FR: one batch', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_FR1
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple FR: multiple batches', function (t) {
+        var input = [
+                // invalid batch
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple UR: one batch', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_UR1
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('multiple FR: multiple batches', function (t) {
+        var input = [
+                // valid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                },
+                // invalid batch
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_UR1,
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('parts but no UR: one batch', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1]
+                        ]
+                }
+        ];
+
+        var output = [];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
+
+test('parts but no UR: multiple batches', function (t) {
+        var input = [
+                // valid batch
+                {
+                        uploadId: inputs.ID_0,
+                        records: [
+                                inputs.OBJ_FR0,
+                                inputs.OBJ_UR0,
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                // valid batch
+                {
+                        uploadId: inputs.ID_2,
+                        records: [
+                                inputs.OBJ_FR2,
+                                inputs.OBJ_UR2
+                        ]
+                },
+                // invalid batch
+                {
+                        uploadId: inputs.ID_1,
+                        records: [
+                                inputs.OBJ_FR1,
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var output = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2,
+                        partRecords: undefined
+                }
+        ];
+
+        var args = {
+                input: input,
+                output: output,
+                testCb: function cb(ok, actual) {
+                        t.ok(ok, 'valid stream output');
+                        if (!ok) {
+                                console.error('invalid output', actual);
+                        }
+                        t.done();
+                }
+        };
+
+        testMpuVerifyStream(args);
+});
diff --git a/test/mpu/test-files/one-record-batch b/test/mpu/test-files/one-record-batch
new file mode 100644
index 0000000..a7276b2
--- /dev/null
+++ b/test/mpu/test-files/one-record-batch
@@ -0,0 +1 @@
+07cff761-33c7-c9ad-a9a0-d3303afa1490	0_finalizingRecord	DATE	1.moray.emy-13.joyent.us	07cff761-33c7-c9ad-a9a0-d3303afa1490:/4204a7f8-3d97-ec27-c16d-f2f49366cc3c/stor/moray-streams-test/committed-some-parts	commit
diff --git a/test/mpu/testInputs.js b/test/mpu/testInputs.js
new file mode 100644
index 0000000..9c605c6
--- /dev/null
+++ b/test/mpu/testInputs.js
@@ -0,0 +1,253 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var stream = require('stream');
+var util = require('util');
+
+var mpuCommon = require('../../lib/mpu/common');
+
+
+///--- Globals
+
+var MORAY_1 = '1.moray.coal.joyent.us';
+var MORAY_2 = '2.moray.coal.joyent.us';
+
+
+// Batch 0: Committed MPU with finalizing record, upload record, 1 part records
+var ID_0 = '07cff761-33c7-c9ad-a9a0-d3303afa1490';
+var DATE_0 =  new Date(Date.now()).toISOString(); // TODO is this right
+var SHARD_0 =  MORAY_1;
+/* BEGIN JSSTYLED */
+var KEY_FR0 = '07cff761-33c7-c9ad-a9a0-d3303afa1490:/4204a7f8-3d97-ec27-c16d-f2f49366cc3c/stor/batch0';
+var KEY_UR0 = '/4204a7f8-3d97-ec27-c16d-f2f49366cc3c/uploads/0/07cff761-33c7-c9ad-a9a0-d3303afa1490';
+var KEY_PR0_0 = '/4204a7f8-3d97-ec27-c16d-f2f49366cc3c/uploads/0/07cff761-33c7-c9ad-a9a0-d3303afa1490/0';
+/* END JSSTYLED */
+var FR_0 = [ ID_0, '0_finalizingRecord', DATE_0, SHARD_0, KEY_FR0, 'commit' ]
+        .join('\t');
+var UR_0 = [ ID_0, '1_uploadRecord', DATE_0, KEY_UR0 ].join('\t');
+var PR_0 = [ [ ID_0, '2_partRecord', DATE_0, KEY_PR0_0 ].join('\t') ];
+var OBJ_FR0 = new mpuCommon.FinalizingRecord({
+        uploadId: ID_0,
+        key: KEY_FR0,
+        shard: SHARD_0,
+        date: DATE_0,
+        type: 'commit'
+});
+assert.object(OBJ_FR0, 'failed to create test finalizing record 0 obj');
+var OBJ_UR0 = new mpuCommon.LiveRecord({
+        uploadId: ID_0,
+        key: KEY_UR0,
+        date: DATE_0,
+        type: 'uploadRecord'
+});
+assert.object(OBJ_UR0, 'failed to create test upload record 0 obj');
+var OBJ_PR0 = [
+        new mpuCommon.LiveRecord({
+                uploadId: ID_0,
+                key: KEY_PR0_0,
+                date: DATE_0,
+                type: 'partRecords'
+        })
+];
+OBJ_PR0.forEach(function (o) {
+        assert.object(o, 'failed to create test part record 0 obj');
+});
+var ACCT_ID_0 = '4204a7f8-3d97-ec27-c16d-f2f49366cc3c';
+var ACCT_LOGIN_0 = 'testuser0';
+var PATH_UR0 = '/' + ACCT_LOGIN_0 +
+        '/uploads/0/07cff761-33c7-c9ad-a9a0-d3303afa1490';
+var PATH_PR0 = [
+        '/' + ACCT_LOGIN_0 + '/uploads/0/07cff761-33c7-c9ad-a9a0-d3303afa1490/0'
+];
+
+
+// Batch 1: Aborted MPU with finalizing record, upload record, 3 part records
+var ACCT_ID_1 = 'fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8';
+var ACCT_LOGIN_1 = 'testuser1';
+var PATH_UR1 = '/' + ACCT_LOGIN_1 +
+        '/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a';
+var PATH_PR1 = [
+        '/' + ACCT_LOGIN_1 +
+                '/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/0',
+        '/' + ACCT_LOGIN_1 +
+                '/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/1',
+        '/' + ACCT_LOGIN_1 +
+                '/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/2'
+];
+
+var ID_1 = 'c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a';
+var DATE_1 =  new Date(Date.now()).toISOString(); // TODO is this right
+var SHARD_1 =  MORAY_1;
+/* BEGIN JSSTYLED */
+var KEY_FR1 = 'c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a:/fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8/stor/batch1';
+var KEY_UR1 = '/fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a';
+var KEY_PR1_0 = '/fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/0';
+var KEY_PR1_1 = '/fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/1';
+var KEY_PR1_2 = '/fdfe27dc-64bc-11e6-90f8-47c1ceb05dd8/uploads/c/c46e3e66-4311-6a11-8cf9-8d3fa69aaf0a/2';
+/* END JSSTYLED */
+var FR_1 = [ ID_1, '0_finalizingRecord', DATE_1, SHARD_1, KEY_FR1, 'abort' ]
+        .join('\t');
+var UR_1 = [ ID_1, '1_uploadRecord', DATE_1, KEY_UR1 ].join('\t');
+var PR_1 = [ [ ID_1, '2_partRecord', DATE_1, KEY_PR1_0 ].join('\t'),
+             [ ID_1, '2_partRecord', DATE_1, KEY_PR1_1 ].join('\t'),
+             [ ID_1, '2_partRecord', DATE_1, KEY_PR1_2 ].join('\t')
+];
+var OBJ_FR1 = new mpuCommon.FinalizingRecord({
+        uploadId: ID_1,
+        key: KEY_FR1,
+        shard: SHARD_1,
+        date: DATE_1,
+        type: 'abort'
+});
+assert.object(OBJ_FR1, 'failed to create test finalizing record 1 obj');
+var OBJ_UR1 = new mpuCommon.LiveRecord({
+        uploadId: ID_1,
+        key: KEY_UR1,
+        date: DATE_1,
+        type: 'uploadRecord'
+});
+assert.object(OBJ_UR1, 'failed to create test upload record 1 obj');
+var OBJ_PR1 = [
+        new mpuCommon.LiveRecord({
+                uploadId: ID_1,
+                key: KEY_PR1_0,
+                date: DATE_1,
+                type: 'partRecords'
+        }),
+        new mpuCommon.LiveRecord({
+                uploadId: ID_1,
+                key: KEY_PR1_1,
+                date: DATE_1,
+                type: 'partRecords'
+        }),
+        new mpuCommon.LiveRecord({
+                uploadId: ID_1,
+                key: KEY_PR1_2,
+                date: DATE_1,
+                type: 'partRecords'
+        })
+];
+OBJ_PR1.forEach(function (o) {
+        assert.object(o, 'failed to create test part record 1 objs');
+});
+
+
+// Batch 2: Committed MPU with finalizing record, upload record
+var ACCT_ID_2 = '88af09d7-4845-e09a-8998-d7d04a88b879';
+var ACCT_LOGIN_2 = 'testuser2';
+var PATH_UR2 = '/' + ACCT_LOGIN_2 +
+        '/uploads/3/38aecc30-9a8c-63a4-f906-e512f02f5915';
+
+var ID_2 = '38aecc30-9a8c-63a4-f906-e512f02f5915';
+var DATE_2 =  new Date(Date.now()).toISOString(); // TODO is this right
+var SHARD_2 =  MORAY_1;
+/* BEGIN JSSTYLED */
+var KEY_FR2 = '38aecc30-9a8c-63a4-f906-e512f02f5915:/88af09d7-4845-e09a-8998-d7d04a88b879/stor/batch2';
+var KEY_UR2 = '/88af09d7-4845-e09a-8998-d7d04a88b879/uploads/3/38aecc30-9a8c-63a4-f906-e512f02f5915';
+/* END JSSTYLED */
+var FR_2 = [ ID_2, '0_finalizingRecord', DATE_2, SHARD_2, KEY_FR2, 'abort' ]
+        .join('\t');
+var UR_2 = [ ID_2, '1_uploadRecord', DATE_2, KEY_UR2 ].join('\t');
+var OBJ_FR2 = new mpuCommon.FinalizingRecord({
+        uploadId: ID_2,
+        key: KEY_FR2,
+        shard: SHARD_2,
+        date: DATE_2,
+        type: 'abort'
+});
+assert.object(OBJ_FR2, 'failed to create test finalizing record 2 obj');
+var OBJ_UR2 = new mpuCommon.LiveRecord({
+        uploadId: ID_2,
+        key: KEY_UR2,
+        date: DATE_2,
+        type: 'uploadRecord'
+});
+assert.object(OBJ_UR2, 'failed to create test upload record 2 obj');
+
+function ValidationStream(args) {
+        assert.object(args, 'args');
+        assert.func(args.cb, 'args.cb');
+        assert.array(args.expect, 'args.expect');
+
+        stream.Writable.call(this, {
+            objectMode: true,
+            highWaterMark: 0
+        });
+
+        var self = this;
+        self.vs_received = [];
+
+        self._write = function _write(chunk, _, cb) {
+                self.vs_received.push(chunk);
+                cb();
+        };
+
+        self.on('finish', function onFinish() {
+                var ok = jsprim.deepEqual(self.vs_received, args.expect);
+                args.cb(ok, self.vs_received);
+        });
+}
+util.inherits(ValidationStream, stream.Writable);
+
+
+module.exports = {
+        ID_0: ID_0,
+        DATE_0: DATE_0,
+        SHARD_0: SHARD_0,
+        KEY_FR0: KEY_FR0,
+        KEY_UR0: KEY_UR0,
+        KEY_PR0_0: KEY_PR0_0,
+        FR_0: FR_0,
+        UR_0: UR_0,
+        PR_0: PR_0,
+        OBJ_FR0: OBJ_FR0,
+        OBJ_UR0: OBJ_UR0,
+        OBJ_PR0: OBJ_PR0,
+        ACCT_ID_0: ACCT_ID_0,
+        ACCT_LOGIN_0: ACCT_LOGIN_0,
+        PATH_UR0: PATH_UR0,
+        PATH_PR0: PATH_PR0,
+
+        ID_1: ID_1,
+        DATE_1: DATE_1,
+        SHARD_1: SHARD_1,
+        KEY_FR1: KEY_FR1,
+        KEY_UR1: KEY_UR1,
+        KEY_PR1_0: KEY_PR1_0,
+        KEY_PR1_1: KEY_PR1_1,
+        KEY_PR1_2: KEY_PR1_2,
+        FR_1: FR_1,
+        UR_1: UR_1,
+        PR_1: PR_1,
+        OBJ_FR1: OBJ_FR1,
+        OBJ_UR1: OBJ_UR1,
+        OBJ_PR1: OBJ_PR1,
+        ACCT_ID_1: ACCT_ID_1,
+        ACCT_LOGIN_1: ACCT_LOGIN_1,
+        PATH_UR1: PATH_UR1,
+        PATH_PR1: PATH_PR1,
+
+        ID_2: ID_2,
+        DATE_2: DATE_2,
+        SHARD_2: SHARD_2,
+        KEY_FR2: KEY_FR2,
+        KEY_UR2: KEY_UR2,
+        FR_2: FR_2,
+        UR_2: UR_2,
+        OBJ_FR2: OBJ_FR2,
+        OBJ_UR2: OBJ_UR2,
+        ACCT_ID_2: ACCT_ID_2,
+        ACCT_LOGIN_2: ACCT_LOGIN_2,
+        PATH_UR2: PATH_UR2,
+
+        ValidationStream: ValidationStream
+};
