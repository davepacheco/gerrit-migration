commit 64538d54fb4f91fee6e97602fa3dd224677118f4 (refs/changes/04/2004/7)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-08-07T11:59:58+02:00 (2 years, 2 months ago)
    
    TOOLS-1770 Add multi server support to `sdcadm create AGENT_INSTANCE`

diff --git a/lib/cli/do_create.js b/lib/cli/do_create.js
index 96c608f..2e5b96a 100644
--- a/lib/cli/do_create.js
+++ b/lib/cli/do_create.js
@@ -16,6 +16,7 @@ var vasync = require('vasync');
 
 var common = require('../common');
 var errors = require('../errors');
+var steps = require('../steps');
 
 /*
  * The 'sdcadm create' CLI subcommand.
@@ -52,7 +53,26 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
     var plan;
     var execStart;
 
-    vasync.pipeline({funcs: [
+    var serverNames = opts.servers || [];
+    // In case the deprecated 'server' option is provided, just add it to
+    // the new 'servers' option.
+    if (opts.server) {
+        serverNames.push(opts.server);
+    }
+
+    if (serverNames.length === 0) {
+        cb(new errors.UsageError(
+            'Must specify at least one server via "-s, --servers" option'));
+        return;
+    }
+
+    var context = {
+        sdcadm: self.sdcadm,
+        log: self.log,
+        serverNames: serverNames
+    };
+
+    vasync.pipeline({ arg: context, funcs: [
         function getLock(_, next) {
             self.sdcadm.acquireLock({progress: self.progress},
                                     function (lockErr, unlock_) {
@@ -60,6 +80,11 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
                 next(lockErr);
             });
         },
+
+        steps.serversServersFromServerNames, // ctx.serverNames -> ctx.servers
+        steps.serversEnsureServersSetup,
+        steps.serversEnsureServersRunning,
+
         function getSvcs(_, next) {
             self.sdcadm.getServices({}, function (err, svcs_) {
                 svcs = svcs_;
@@ -71,38 +96,23 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
                 next(err);
             });
         },
-        function getServerFromHostname(_, next) {
-            if (!opts.server || common.UUID_RE.test(opts.server)) {
-                next();
-                return;
-            }
-            self.sdcadm.cnapi.listServers({
-                hostname: opts.server
-            }, function (err, servers) {
-                if (err || !servers.length) {
-                    self.sdcadm.log.error({err: err}, 'do_create');
-                    next(new errors.UsageError(util.format(
-                        'Cannot find server "%s"', opts.server)));
-                    return;
-                }
-                opts.server = servers[0].uuid;
-                next();
-            });
 
-        },
-        function getChangeFromArgs(_, next) {
+        function getChangeFromArgs(ctx, next) {
             if (args.length === 0) {
-                return next(new errors.UsageError(
+                next(new errors.UsageError(
                     'Must specify service name or uuid'));
+                return;
             }
 
             var service = args[0];
             var change = {};
             if (svcFromName[service] === undefined) {
-                return next(new errors.UsageError(
+                next(new errors.UsageError(
                     'unknown service: ' + service));
+                return;
             }
 
+            change.servers = ctx.servers.map(function (s) { return s.uuid; });
             change.service = args[0];
 
             if (opts.image) {
@@ -117,16 +127,12 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
              * service
              */
             if (!change.image) {
-                return next(new errors.ValidationError(util.format(
+                next(new errors.ValidationError(util.format(
                     'Missing image_uuid for service %s in SAPI.', service)));
+                return;
             }
 
-            if (!opts.server) {
-                return next(new errors.UsageError(
-                    'Must specify server uuid or hostname'));
-            }
-            change.server = opts.server;
-            change.type = 'create-instance';
+            change.type = 'create-instances';
             changes.push(change);
             next();
         },
@@ -146,20 +152,23 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
         },
         function confirm(_, next) {
             if (plan.procs.length === 0) {
-                return next();
+                next();
+                return;
             }
             p('');
             p('This command will make the following changes:');
             self.sdcadm.summarizePlan({plan: plan, progress: self.progress});
             p('');
             if (opts.yes) {
-                return next();
+                next();
+                return;
             }
             var msg = 'Would you like to continue? [y/N] ';
             common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
                 if (answer !== 'y') {
                     p('Aborting');
-                    return cb();
+                    cb();
+                    return;
                 }
                 p('');
                 next();
@@ -168,11 +177,13 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
         function execPlan(_, next) {
             execStart = Date.now();
             if (plan.procs.length === 0) {
-                return next();
+                next();
+                return;
             }
             if (opts.dry_run) {
                 p('[dry-run] done');
-                return next();
+                next();
+                return;
             }
             self.sdcadm.execUpdatePlan({
                 plan: plan,
@@ -184,7 +195,8 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
         vasync.pipeline({funcs: [
             function dropLock(_, next) {
                 if (!unlock) {
-                    return next();
+                    next();
+                    return;
                 }
                 self.sdcadm.releaseLock({unlock: unlock}, next);
             }
@@ -196,7 +208,8 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
                     'unexpected error finishing create');
             }
             if (err || finishCreateErr) {
-                return cb(err || finishCreateErr);
+                cb(err || finishCreateErr);
+                return;
             }
 
             if (plan.procs.length === 0) {
@@ -212,7 +225,7 @@ Create.prototype.execute = function cExecute(opts, args, cb) {
 
 
 Create.prototype.help = (
-    'Create an instance for an existing SDC service.\n' +
+    'Create one or more instances for an existing SDC service.\n' +
     '\n' +
     'Usage:\n' +
     '       {{name}} create <svc>\n\n' +
@@ -265,9 +278,17 @@ do_create.options = [
         help: 'UUID of the Image to be used for the instance.'
     },
     {
-        names: ['server', 's'],
+        // Deprecated in favour of `-s,--servers`
+        names: ['server'],
         type: 'string',
-        help: 'The server (UUID or hostname) on which to create the instance.'
+        hidden: true
+    },
+    {
+        names: ['servers', 's'],
+        type: 'arrayOfCommaSepString',
+        help: 'Comma separated list of servers (either hostnames or uuids) ' +
+            'on which to create the instance(s).',
+        helpArg: 'SERVERS'
     },
     {
         names: ['yes', 'y'],
diff --git a/lib/common.js b/lib/common.js
index 0c8f3e5..71180e6 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -1312,7 +1312,8 @@ function isUsbKeyMounted(log, cb) {
 
     function checkKeyMountedUsingUtility(ctx, next) {
         if (!ctx.utilityExists) {
-            return next();
+            next();
+            return;
         }
 
         var argv = [ctx.utility, 'status'];
@@ -1321,16 +1322,18 @@ function isUsbKeyMounted(log, cb) {
             log: log
         }, function (err, stdout, stderr) {
             if (err) {
-                return next(err);
+                next(err);
+                return;
             }
             if (stderr.trim() !== '') {
-                return next(new Error('Unexpected sdc-usbkey stderr: %s',
-                            stderr.trim()));
+                next(new Error(format('Unexpected sdc-usbkey stderr: %j',
+                            stderr.trim())));
+                return;
             }
             if (stdout.trim() === 'mounted') {
                 ctx.keyIsMounted = true;
             }
-            return next();
+            next();
         });
     }
 
@@ -1351,7 +1354,7 @@ function isUsbKeyMounted(log, cb) {
             if (st.isFile()) {
                 ctx.keyIsMounted = true;
             }
-            return next();
+            next();
         });
     }
 
@@ -1411,7 +1414,8 @@ function mountUsbKey(log, cb) {
 
     function mountUsingUtility(ctx, next) {
         if (!ctx.utilityExists || ctx.keyIsMounted) {
-            return next();
+            next();
+            return;
         }
 
         var argv = [ctx.utility, 'mount'];
@@ -1420,16 +1424,19 @@ function mountUsbKey(log, cb) {
             log: log
         }, function (err, stdout, stderr) {
             if (err) {
-                return next(err);
+                next(err);
+                return;
             }
             if (stderr.trim() !== '') {
-                return next(new Error('Unexpected sdc-usbkey stderr: %s',
-                            stderr.trim()));
+                next(new Error(format('Unexpected sdc-usbkey stderr: %j',
+                            stderr.trim())));
+                return;
             }
+
             if (stdout.trim() === '/mnt/usbkey') {
                 ctx.keyIsMounted = true;
             }
-            return next();
+            next();
         });
 
     }
diff --git a/lib/post-setup/ha-manatee.js b/lib/post-setup/ha-manatee.js
index 8b7cba5..6dbf1d0 100644
--- a/lib/post-setup/ha-manatee.js
+++ b/lib/post-setup/ha-manatee.js
@@ -482,7 +482,7 @@ function do_ha_manatee(subcmd, opts, args, cb) {
             return shared.waitForInstToBeUp({
                 change: {
                     server: opts.servers[0],
-                    type: 'create-instance',
+                    type: 'create-instances',
                     service: 'manatee',
                     image: img,
                     inst: {
diff --git a/lib/procedures/create-service-instance-v1.js b/lib/procedures/create-service-instance-v1.js
index c52d5c5..60f2303 100644
--- a/lib/procedures/create-service-instance-v1.js
+++ b/lib/procedures/create-service-instance-v1.js
@@ -16,6 +16,7 @@ var vasync = require('vasync');
 
 var Procedure = require('./procedure').Procedure;
 var s = require('./shared');
+var common = require('../common');
 var errors = require('../errors');
 var svcadm = require('../svcadm');
 function CreateServiceInstanceV1(options) {
@@ -26,8 +27,19 @@ util.inherits(CreateServiceInstanceV1, Procedure);
 
 CreateServiceInstanceV1.prototype.summarize = function csiv1Summarize() {
     return this.changes.map(function (ch) {
-        return sprintf('create "%s" service instance using image %s (%s@%s)',
+        var out = sprintf('create "%s" service instance\n' +
+            '    using image %s (%s@%s)\n',
             ch.service.name, ch.image.uuid, ch.image.name, ch.image.version);
+        if (ch.servers.length === 1) {
+            out += sprintf('    on server %s', ch.servers[0]);
+        } else {
+            out += util.format('    on %d servers:', ch.servers.length);
+            out = [out].concat(
+                ch.servers.map(function (serv) {
+                    return common.indent(serv, 8);
+            })).join('\n');
+        }
+        return out;
     }).join('\n');
 };
 
@@ -48,7 +60,7 @@ CreateServiceInstanceV1.prototype.execute = function csiv1Execute(opts, cb) {
             change: change,
             opts: opts,
             img: change.image,
-            server: change.server,
+            servers: change.servers,
             userScript: false,
             progress: progress,
             log: opts.log
@@ -84,13 +96,11 @@ CreateServiceInstanceV1.prototype.execute = function csiv1Execute(opts, cb) {
             },
             function generateInstanceAlias(_, next) {
                 var n = change.service.name;
-                progress('Calculating next %s instance alias', n);
                 var nextId = instances.map(function (inst) {
                     return Number(inst.params.alias.replace(n, ''));
                 }).sort().pop();
                 nextId = isNaN(nextId) ? 0 : nextId + 1;
-                alias = n + nextId;
-                arg.alias = alias;
+                arg.nextId = nextId;
                 next();
             }
         ];
@@ -104,9 +114,48 @@ CreateServiceInstanceV1.prototype.execute = function csiv1Execute(opts, cb) {
             ]);
         }
 
-        steps.push(s.imgadmInstallRemote);
-        steps.push(s.createInstance);
-        steps.push(s.waitForInstToBeUp);
+        change.servers.forEach(function (server) {
+            steps = steps.concat(
+                function generateAlias(ctx, next) {
+                    alias = change.service.name + ctx.nextId;
+                    ctx.nextId += 1;
+                    next();
+                },
+                function imgadmInstallForInstance(_, next) {
+                    return s.imgadmInstallRemote({
+                        progress: progress,
+                        img: change.image,
+                        log: opts.log,
+                        server: server
+                    }, next);
+                },
+                function createInstance(_, next) {
+                    change.server = server;
+                    s.createInstance({
+                        opts: {
+                            progress: progress,
+                            sdcadm: opts.sdcadm,
+                            log: opts.log
+                        },
+                        server: server,
+                        img: change.image,
+                        alias: alias,
+                        change: change
+                    }, next);
+                },
+                function waitForInstanceToBeUp(_, next) {
+                    s.waitForInstToBeUp({
+                        opts: {
+                            progress: progress,
+                            sdcadm: opts.sdcadm,
+                            log: opts.log
+                        },
+                        change: change
+                    }, next);
+                }
+            );
+        });
+
         steps.push(function hupHermes(_, next) {
             svcadm.restartHermes({
                 sdcadm: sdcadm,
@@ -128,7 +177,7 @@ CreateServiceInstanceV1.prototype.execute = function csiv1Execute(opts, cb) {
 };
 
 
-//---- exports
+// --- exports
 
 module.exports = {
     CreateServiceInstanceV1: CreateServiceInstanceV1
diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index 0b3599f..94780c0 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -618,51 +618,42 @@ function coordinatePlan(opts, cb) {
             var err;
 
             function processChange(change, nextChange) {
-                if (change.type !== 'create-instance' ||
+                if (change.type !== 'create-instances' ||
                     change.service.type !== 'vm') {
                     remaining.push(change);
                     return nextChange();
                 }
-                sdcadm.cnapi.getServer(change.server, function (sErr, serv) {
-                    if (sErr) {
-                        remaining.push(change);
-                        err = new UsageError('Cannot find server \'' +
-                                change.server + '\'');
-                        log.error({err: sErr}, 'createServiceInstance');
-                        return nextChange();
-                    }
 
-                    var sName = change.service.name;
-                    var allowed = ((avoid.indexOf(sName) === -1) &&
-                        (ALL_HA_READY_SVCS.indexOf(sName) !== -1 ||
-                            change.force));
+                var sName = change.service.name;
+                var allowed = ((avoid.indexOf(sName) === -1) &&
+                    (ALL_HA_READY_SVCS.indexOf(sName) !== -1 ||
+                        change.force));
 
-                    if (allowed) {
-                        log.debug({
-                            numInsts: 0,
-                            svc: sName,
-                            server: change.server
-                        }, 'CreateServiceIntanceV1 create service ' +
-                        'additional instance');
-                        handle.push(change);
+                if (allowed) {
+                    log.debug({
+                        numInsts: change.servers.length,
+                        svc: sName,
+                        servers: change.servers
+                    }, 'CreateServiceIntanceV1 create service ' +
+                    'additional instances');
+                    handle.push(change);
+                } else {
+                    if (avoid.indexOf(sName) === -1) {
+                        err = new UsageError(format(
+                            'The "%s" service does not support proper ' +
+                            'operation with multiple instances. Running ' +
+                            'multiple instances is unsupported.\n(For ' +
+                            'development of Triton, this guard can be ' +
+                            'skipped with ' +
+                            '"--dev-allow-multiple-instances")',
+                            sName));
                     } else {
-                        if (avoid.indexOf(sName) === -1) {
-                            err = new UsageError(format(
-                                'The "%s" service does not support proper ' +
-                                'operation with multiple instances. Running ' +
-                                'multiple instances is unsupported.\n(For ' +
-                                'development of Triton, this guard can be ' +
-                                'skipped with ' +
-                                '"--dev-allow-multiple-instances")',
-                                sName));
-                        } else {
-                            remaining.push(change);
-                        }
+                        remaining.push(change);
                     }
+                }
 
-                    return nextChange();
+                return nextChange();
 
-                });
             }
 
             vasync.forEachPipeline({
@@ -803,7 +794,7 @@ function coordinatePlan(opts, cb) {
 
             changes.forEach(function (change) {
                 if (change.service.name !== 'dockerlogger' ||
-                    change.type === 'create-instance') {
+                    change.type === 'create-instances') {
                     remaining.push(change);
                     return;
                 }
@@ -865,104 +856,149 @@ function coordinatePlan(opts, cb) {
 
 
             function processChange(change, nextChange) {
-                if (change.type !== 'create-instance' ||
+                if (change.type !== 'create-instances' ||
                     change.service.type !== 'agent') {
                     remaining.push(change);
-                    return nextChange();
+                    nextChange();
+                    return;
                 }
 
-                sdcadm.cnapi.getServer(change.server, function (sErr, serv) {
-                    if (sErr) {
-                        nextChange(new errors.UsageError(
-                            'Cannot find server "' +
-                                change.server + '"'));
-                        return;
-                    }
-
-                    if (change.type !== 'create-instance' ||
-                        change.service.type !== 'agent') {
-                        remaining.push(change);
-                        nextChange();
-                        return;
-                    }
-
-                    if (DISALLOWED_AGENTS.indexOf(change.service.name) !== -1) {
-                        errs.push(new errors.UsageError(format(
-                                'Creation of agent "%s" ' +
-                                'instances is not supported.',
-                                change.service.name)));
-                        remaining.push(change);
-                        nextChange();
-                        return;
-                    }
-
-                    var installedAgents = serv.agents.map(function (a) {
-                        return a.name;
-                    });
-
-                    if (installedAgents.indexOf(change.service.name) !== -1) {
-                        errs.push(new errors.UsageError(format(
-                                'Agent "%s" instance already exists on ' +
-                                'server "%s".',
-                                change.service.name, change.server)));
-                        remaining.push(change);
-                        nextChange();
-                        return;
-                    }
-
-                    var adminIp = common.serverAdminIpFromSysinfo(serv.sysinfo);
-
-                    change.insts = [ {
-                        type: change.service.type,
-                        service: change.service.name,
-                        image: change.image.uuid,
-                        server: serv.uuid,
-                        hostname: serv.hostname,
-                        server_ip: adminIp,
-                        instance: null,
-                        version: change.image.version
-                    }];
+                if (DISALLOWED_AGENTS.indexOf(change.service.name) !== -1) {
+                    errs.push(new errors.UsageError(format(
+                            'Creation of agent "%s" ' +
+                            'instances is not supported.',
+                            change.service.name)));
+                    remaining.push(change);
+                    nextChange();
+                    return;
+                }
 
-                    log.debug({
-                        numInsts: 1,
-                        svc: change.service.name,
-                        server: change.server
-                    }, 'UpdateAgentV1');
+                var arg = {
+                    insts: [],
+                    serverFromUuidOrHostname: opts.serverFromUuidOrHostname
+                };
+                vasync.pipeline({
+                    arg: arg,
+                    funcs: [
+                        function loadDockerloggerInstsServers(ctx, nextStep) {
+                            if (change.service.name !== 'dockerlogger') {
+                                nextStep();
+                                return;
+                            }
+                            sdcadm.sapi.listInstances({
+                                service_uuid: change.service.uuid
+                            }, function (sapiErr, sapiInsts) {
+                                if (sapiErr) {
+                                    errs.push(new errors.SDCClientError(
+                                        sapiErr, 'sapi'));
+                                    nextStep();
+                                    return;
+                                }
+                                var servers = sapiInsts.map(function (sIns) {
+                                    return sIns.params ?
+                                        sIns.params.server_uuid : null;
+                                }).filter(function (srv) {
+                                    return srv !== null;
+                                });
 
-                    if (change.service.name === 'dockerlogger') {
-                        sdcadm.sapi.listInstances({
-                            service_uuid: change.service.uuid
-                        }, function (sapiErr, sapiInsts) {
-                            if (sapiErr) {
-                                errs.push(new errors.SDCClientError(
-                                    sapiErr, 'sapi'));
-                                nextChange();
+                                ctx.dockerInstServers = servers;
+                                nextStep();
+                            });
+                        },
+                        function filterDockerLoggerInsts(ctx, nextStep) {
+                            if (change.service.name !== 'dockerlogger') {
+                                nextStep();
                                 return;
                             }
-                            var servers = sapiInsts.map(function (sIns) {
-                                return sIns.params ?
-                                    sIns.params.server_uuid : null;
-                            }).filter(function (srv) {
-                                return srv !== null;
+                            change.servers.forEach(function (server) {
+                                var s = ctx.serverFromUuidOrHostname[server];
+                                if (ctx.dockerInstServers.indexOf(
+                                    s.uuid) !== -1) {
+                                    errs.push(new errors.UsageError(format(
+                                        'Agent "%s" instance already exists ' +
+                                        'on server "%s".',
+                                        change.service.name, server)));
+                                    return;
+                                }
+                                ctx.insts.push({
+                                    type: change.service.type,
+                                    service: change.service.name,
+                                    image: change.image.uuid,
+                                    server: s.uuid,
+                                    hostname: s.hostname,
+                                    server_ip: common.serverAdminIpFromSysinfo(
+                                        s.sysinfo),
+                                    instance: null,
+                                    version: change.image.version
+                                });
                             });
-
-                            if (servers.indexOf(serv.uuid) !== -1) {
-                                errs.push(new errors.UsageError(format(
-                                    'Agent "%s" instance already exists on ' +
-                                    'server "%s".',
-                                    change.service.name, change.server)));
-                                nextChange();
+                            nextStep();
+                        },
+                        function filterAgentInstances(ctx, nextStep) {
+                            if (change.service.name === 'dockerlogger') {
+                                nextStep();
                                 return;
                             }
-                            handleDockerlogger.push(change);
-                            nextChange();
-                        });
+                            change.servers.forEach(function (server) {
+                                var s = ctx.serverFromUuidOrHostname[server];
+                                var installedAgents = s.agents.map(
+                                    function (a) {
+                                    return a.name;
+                                });
+
+                                if (installedAgents.indexOf(
+                                    change.service.name) !== -1) {
+                                    errs.push(new errors.UsageError(format(
+                                            'Agent "%s" instance already ' +
+                                            'exists on server "%s".',
+                                            change.service.name, server)));
+                                    return;
+                                }
+                                ctx.insts.push({
+                                    type: change.service.type,
+                                    service: change.service.name,
+                                    image: change.image.uuid,
+                                    server: s.uuid,
+                                    hostname: s.hostname,
+                                    server_ip: common.serverAdminIpFromSysinfo(
+                                        s.sysinfo),
+                                    instance: null,
+                                    version: change.image.version
+                                });
+                            });
+                            nextStep();
+                        },
+                        function removeDuplicates(ctx, nextStep) {
+                            var svcs = {};
+                            var duplicates = null;
+                            ctx.insts.forEach(function (ins) {
+                                if (!svcs[ins.service]) {
+                                    svcs[ins.service] = [ins.server];
+                                } else if (
+                                    svcs[ins.service].
+                                    indexOf(ins.server) !== -1) {
+                                    duplicates = true;
+                                    errs.push(new errors.UsageError(format(
+                                        'Duplicated server "%s" for service ' +
+                                        '"%s"', ins.server, ins.service)));
+                                }
+                            });
+                            nextStep(duplicates);
+                        }
+                    ]
+                }, function pipeCb(pipeErr) {
+                    if (!arg.insts.length || pipeErr) {
+                        remaining.push(change);
                     } else {
-                        handle.push(change);
-                        nextChange();
+                        change.insts = arg.insts;
+                        if (change.service.name === 'dockerlogger') {
+                            handleDockerlogger.push(change);
+                        } else {
+                            handle.push(change);
+                        }
                     }
+                    nextChange();
                 });
-
             }
 
             vasync.forEachPipeline({
@@ -989,7 +1025,8 @@ function coordinatePlan(opts, cb) {
                 }
                 var err = null;
                 if (errs.length) {
-                    err = new errors.MultiError(errs);
+                    err = (errs.length > 1) ?
+                        new errors.MultiError(errs) : errs[0];
                 }
                 next(err);
             });
diff --git a/lib/procedures/update-agent-v1.js b/lib/procedures/update-agent-v1.js
index 4e1b551..587387c 100644
--- a/lib/procedures/update-agent-v1.js
+++ b/lib/procedures/update-agent-v1.js
@@ -54,14 +54,27 @@ UpdateAgentV1.prototype.summarize = function uaSummarize() {
                         ch.instance.instance, ch.service.name),
                         common.indent(sprintf('to image %s (%s@%s)',
                         img.uuid, img.name, img.version))];
-        } else if (ch.type === 'create-instance') {
-            var inst = ch.insts[0];
-            out = [sprintf('create a new instance of "%s" service',
+        } else if (ch.type === 'create-instances') {
+            if (ch.insts.length > 1) {
+                out = [sprintf('create new instances of "%s" service',
                         ch.service.name),
-                        common.indent(sprintf('on server %s (%s)',
-                            inst.server, inst.hostname)),
-                        common.indent(sprintf('using image %s (%s@%s)',
-                        img.uuid, img.name, img.version))];
+                    common.indent(sprintf('using image %s (%s@%s)',
+                        img.uuid, img.name, img.version)),
+                    common.indent(sprintf('on %d servers:',
+                        ch.insts.length))
+                ];
+                out = out.concat(ch.insts.map(function (inst) {
+                    return common.indent(sprintf('%s (%s)',
+                        inst.server, inst.hostname), 8);
+                }));
+            } else {
+                out = [sprintf('create a new instance of "%s" service',
+                            ch.service.name),
+                            common.indent(sprintf('on server %s (%s)',
+                                ch.insts[0].server, ch.insts[0].hostname)),
+                            common.indent(sprintf('using image %s (%s@%s)',
+                            img.uuid, img.name, img.version))];
+            }
         }
         return out.join('\n');
     }).join('\n');
@@ -186,9 +199,10 @@ UpdateAgentV1.prototype.execute = function uaExecute(opts, callback) {
                 });
 
                 if (duplicates.length) {
-                    return next(new UpdateError(format(
+                    next(new UpdateError(format(
                         'there are duplicated instances for agent %s',
                         change.insts[0].service)));
+                    return;
                 }
                 next();
             },
@@ -234,7 +248,7 @@ UpdateAgentV1.prototype.execute = function uaExecute(opts, callback) {
                         size: change.insts.length,
                         bytes: false,
                         filename: format('%s %s', (change.type ===
-                            'create-instance' ?
+                            'create-instances' ?
                             'Creating instance of' : 'Updating'),
                             change.service.name)
                     });
@@ -393,7 +407,7 @@ UpdateAgentV1.prototype.execute = function uaExecute(opts, callback) {
                     if (bar) {
                         bar.end();
                     }
-                    if (change.type === 'create-instance') {
+                    if (change.type === 'create-instances') {
                         progress('successfully created instance of agent %s.',
                             change.service.name);
                     } else {
diff --git a/lib/procedures/update-dockerlogger.js b/lib/procedures/update-dockerlogger.js
index fdd7048..dd603d0 100644
--- a/lib/procedures/update-dockerlogger.js
+++ b/lib/procedures/update-dockerlogger.js
@@ -58,13 +58,27 @@ UpdateDockerlogger.prototype.summarize = function udSummarize() {
                         ch.instance.instance),
                         common.indent(sprintf('to image %s (%s@%s)',
                         img.uuid, img.name, img.version))];
-        } else if (ch.type === 'create-instance') {
-            var inst = ch.insts[0];
-            out = ['create a new instance of "dockerlogger" service',
-                        common.indent(sprintf('on server %s (%s)',
-                            inst.server, inst.hostname)),
-                        common.indent(sprintf('using image %s (%s@%s)',
-                        img.uuid, img.name, img.version))];
+        } else if (ch.type === 'create-instances') {
+            if (ch.insts.length > 1) {
+                out = [sprintf('create new instances of "%s" service',
+                        ch.service.name),
+                    common.indent(sprintf('using image %s (%s@%s)',
+                        img.uuid, img.name, img.version)),
+                    common.indent(sprintf('on %d servers:',
+                        ch.insts.length)),
+                    ch.insts.map(function (inst) {
+                        return common.indent(8, sprintf('%s (%s)',
+                            inst.server, inst.hostname));
+                    }).join(', ')
+                ];
+            } else {
+                out = [sprintf('create a new instance of "%s" service',
+                            ch.service.name),
+                            common.indent(sprintf('on server %s (%s)',
+                                ch.insts[0].server, ch.insts[0].hostname)),
+                            common.indent(sprintf('using image %s (%s@%s)',
+                            img.uuid, img.name, img.version))];
+            }
         }
         return out.join('\n');
     }).join('\n');
@@ -368,7 +382,7 @@ UpdateDockerlogger.prototype.execute = function udExecute(opts, callback) {
                     next();
                     return;
                 }
-                if (change.type === 'create-instance') {
+                if (change.type === 'create-instances') {
                     progress('Starting dockerlogger instance creation');
                 } else {
                     progress('Starting dockerlogger update on %d servers',
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index c40529d..f492199 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -247,8 +247,8 @@ function SdcAdm(options) {
     Object.defineProperty(this, 'updates', {
         get: function () {
             if (self._updates === undefined) {
-                assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) '
-                    + 'must be retrieved for client config');
+                assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) ' +
+                    'must be retrieved for client config');
                 var opts = {
                     url: self.config.updatesServerUrl,
                     proxy: self.sdc.metadata.http_proxy || false,
@@ -269,8 +269,8 @@ function SdcAdm(options) {
     Object.defineProperty(this, 'imagesJo', {
         get: function () {
             if (self._imagesJo === undefined) {
-                assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) '
-                    + 'must be retrieved for client config');
+                assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) ' +
+                    'must be retrieved for client config');
                 var opts = {
                     url: 'https://images.joyent.com',
                     proxy: self.sdc.metadata.http_proxy || false,
@@ -2147,8 +2147,8 @@ SdcAdm.prototype.getCandidateImages = function getCandidateImages(opts, cb) {
             }
             var filter = {
                 name: name,
-                marker: (currImgs.length > 0
-                    ? currImgs[0].published_at : undefined)
+                marker: (currImgs.length > 0 ?
+                    currImgs[0].published_at : undefined)
             };
 
             self.log.debug({filter: filter},
@@ -2276,8 +2276,9 @@ function reprovFailLock_IsLocked(cb) {
                 cb(readErr);
                 return;
             }
+            var reprovFailLock;
             try {
-                var reprovFailLock = JSON.parse(data);
+                reprovFailLock = JSON.parse(data);
             } catch (parseErr) {
                 cb(parseErr);
                 return;
@@ -2305,7 +2306,7 @@ SdcAdm.prototype.reprovFailLock_Unlock = function reprovFailLock_Unlock(cb) {
  *
  * `changes` is an array of objects of the following form:
  *
- * 1. create-instance: 'type:create-instance' and 'service' and 'server'
+ * 1. create-instances: 'type:create-instances' and 'service' and 'servers'
  * 2. agent delete-instance:
  *          'type:delete-instance' and 'service' and 'server'
  *    or
@@ -2391,11 +2392,12 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                 if (change.image) {
                     validateString(change.image, '"image" in ' + repr);
                 }
-                if (change.type === 'create-instance') {
-                    // 1. create-instance
+                if (change.type === 'create-instances') {
+                    // 1. create-instances
                     validateString(change.service, '"service" in ' + repr);
-                    validateString(change.server, '"server" in ' + repr);
-                    validateKeys(['type', 'server', 'service', 'image'],
+                    validateArrayOfStrings(change.servers,
+                        '"servers" in ' + repr);
+                    validateKeys(['type', 'servers', 'service', 'image'],
                         change, repr);
                 } else if (change.type === 'delete' && change.service &&
                         change.server) {
@@ -2477,6 +2479,24 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                         msg + ' (string) is required'));
                 }
             }
+            function validateArrayOfStrings(arr, msg) {
+                if (!Array.isArray(arr)) {
+                    errs.push(new errors.ValidationError(
+                        JSON.stringify(arr) + ' (array) is required'));
+                }
+
+                var arrErrs = [];
+                arr.forEach(function (elm) {
+                    if (typeof (elm) !== 'string') {
+                        arrErrs.push(elm);
+                    }
+                });
+                if (arrErrs.length) {
+                    errs.push(new errors.ValidationError(
+                        JSON.stringify(arrErrs.join(', ')) +
+                        ' (array of strings) is required'));
+                }
+            }
             function validateKeys(allowed, change_, repr_) {
                 var extraKeys = Object.keys(change_).filter(function (k) {
                     return !~allowed.indexOf(k);
@@ -2511,7 +2531,7 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                     svcFromName[svcs[i].name] = svcs[i];
                 }
                 if (options.justAvailable) {
-                    svcFromName['sdcadm'] = {
+                    svcFromName.sdcadm = {
                         name: 'sdcadm',
                         type: 'other'
                     };
@@ -2623,19 +2643,27 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                     }
 
                     if (ch.server) {
-                        found = false;
-                        for (i = 0; i < servers.length; i++) {
-                            if (servers[i].uuid === ch.server ||
-                                servers[i].hostname === ch.server)
-                            {
-                                found = true;
-                                break;
-                            }
-                        }
+                        found = serverFromUuidOrHostname[ch.server];
                         if (!found) {
-                            return nextChange(new errors.UpdateError(format(
+                            nextChange(new errors.UpdateError(format(
                                 'unknown SDC server "%s" from %s',
                                 ch.server, changeRepr)));
+                            return;
+                        }
+                    }
+
+                    if (ch.servers) {
+                        var notFound = [];
+                        ch.servers.forEach(function (s) {
+                            if (!serverFromUuidOrHostname[s]) {
+                                notFound.push(s);
+                            }
+                        });
+                        if (notFound.length) {
+                            nextChange(new errors.UpdateError(format(
+                                'unknown SDC servers "%s" from %s',
+                                notFound.join(', '), changeRepr)));
+                            return;
                         }
                     }
 
@@ -2688,8 +2716,8 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                         });
                     } else {
                         if (!updateAll && !options.noVerbose) {
-                            progress('Finding candidate update images '
-                                + 'for the "%s" service.', ch.service.name);
+                            progress('Finding candidate update images ' +
+                                'for the "%s" service.', ch.service.name);
                         }
                         // Special case for 'sdcadm', given it's not really a
                         // service and we get the images on a different way:
@@ -2758,35 +2786,41 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                 if (typeTarg === 'service') {
                     svc = ch.service.name;
                     if (changeFromSvc[svc]) {
-                        return next(new errors.UpdateError(format(
+                        next(new errors.UpdateError(format(
                             'conflict: cannot make multiple changes to the ' +
                             'same service: %s and %s', reprFromChange(ch),
                             reprFromChange(changeFromSvc[svc]))));
+                        return;
                     }
                     changeFromSvc[svc] = ch;
-                } else {
-                    assert.equal(typeTarg, 'instance');
+                } else if (typeTarg === 'instance') {
                     var inst = (ch.instance) ? ch.instance.instance : null;
                     if (changeFromInst[inst]) {
-                        return next(new errors.UpdateError(format(
+                        next(new errors.UpdateError(format(
                             'conflict: cannot make multiple changes to the ' +
                             'same instance: %s and %s', reprFromChange(ch),
                             reprFromChange(changeFromInst[inst]))));
+                        return;
                     }
                     changeFromInst[inst] = ch;
+                } else {
+                    next(new errors.UpdateError(format(
+                        'Unknown change type: %s', typeTarg)));
+                    return;
                 }
             }
             for (i = 0; i < changes.length; i++) {
                 ch = changes[i];
-                typeTarg = ch.type.split('-')[1] || 'instance';
+                typeTarg = ch.type.split('-')[1] || 'instance';
                 if (typeTarg === 'instance') {
                     svc = ch.service.name;
                     if (changeFromSvc[svc]) {
-                        return next(new errors.UpdateError(format(
+                        next(new errors.UpdateError(format(
                             'conflict: cannot make changes to a service and ' +
                             'an instance of that service: %s and %s',
                             reprFromChange(ch),
                             reprFromChange(changeFromSvc[svc]))));
+                        return;
                     }
                 }
             }
@@ -2955,18 +2989,22 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                     }
                 } else if (ch.type === 'update-instance') {
                     checkMinPlatform(ch.instance, ch);
-                } else if (ch.type === 'create-instance') {
-                    server = serverFromUuidOrHostname[ch.server];
-                    if (server.current_platform <
-                        self.config.vmMinPlatform)
-                    {
-                        errs.push(new errors.UpdateError(format(
-                            'insufficient platform for a new service "%s" ' +
-                            'instance on server "%s" (current ' +
-                            'platform is "%s", require minimum "%s")',
-                            ch.service.name, ch.server, server.current_platform,
-                            self.config.vmMinPlatform)));
-                    }
+                } else if (ch.type === 'create-instances') {
+                    ch.servers.forEach(function (chServ) {
+                        server = serverFromUuidOrHostname[chServ];
+                        if (server.current_platform <
+                            self.config.vmMinPlatform)
+                        {
+                            errs.push(new errors.UpdateError(format(
+                                'insufficient platform for a new service ' +
+                                '"%s" instance on server "%s" (current ' +
+                                'platform is "%s", require minimum "%s")',
+                                ch.service.name, chServ,
+                                server.current_platform,
+                                self.config.vmMinPlatform)));
+                        }
+
+                    });
                 }
             }
             if (errs.length) {
@@ -3040,7 +3078,7 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                     if (self.config.svcMinImages[ch.instance.service]) {
                         checkMinImageBuildDate(ch.instance);
                     }
-                } else if (ch.type === 'create-instance') {
+                } else if (ch.type === 'create-instances') {
                     if (self.config.svcMinImages[ch.service.name]) {
                         checkMinImageBuildDate({
                             service: ch.service.name,
@@ -3090,7 +3128,7 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                         }
                     }
                     break;
-                case 'create-instance':
+                case 'create-instances':
                     // Create instance for an existing service:
                     if (options.skipHACheck) {
                         ch.force = true;
@@ -3551,9 +3589,9 @@ SdcAdm.prototype.selfUpdate = function selfUpdate(options, cb) {
                     });
                     if (droppedVers.length) {
                         droppedVers.sort(semver.compare);
-                        progress('Skipping available major sdcadm '
-                            + 'update, version %s (use --allow-major-update '
-                            + 'to allow)',
+                        progress('Skipping available major sdcadm ' +
+                            'update, version %s (use --allow-major-update ' +
+                            'to allow)',
                             droppedVers[droppedVers.length - 1]);
                     }
                 }
@@ -3567,7 +3605,7 @@ SdcAdm.prototype.selfUpdate = function selfUpdate(options, cb) {
                 } else {
                     var ch = self.updates.channel;
                     progress('Already up-to-date (using %s update channel).',
-                        ch ? '"'+ch+'"' : 'default');
+                        ch ? '"' + ch + '"' : 'default');
                 }
                 next();
             });
diff --git a/lib/steps/index.js b/lib/steps/index.js
index 12ba0a0..801697d 100644
--- a/lib/steps/index.js
+++ b/lib/steps/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -24,7 +24,8 @@ module.exports = {};
 [
     'no-rabbit',
     'update_vm_size',
-    'sapi'
+    'sapi',
+    'servers'
 ].forEach(function (modName) {
     var mod = require('./' + modName);
     Object.keys(mod).forEach(function (symbol) {
diff --git a/lib/steps/servers.js b/lib/steps/servers.js
new file mode 100644
index 0000000..06919a3
--- /dev/null
+++ b/lib/steps/servers.js
@@ -0,0 +1,180 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * Steps for doing some things with CNAPI server objects.
+ */
+
+var assert = require('assert-plus');
+var util = require('util');
+var vasync = require('vasync');
+
+var common = require('../common');
+var errors = require('../errors');
+
+
+// ---- internal support functions
+
+function _cnapiServerFromName(args, cb) {
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.object(args.sdcadm, 'args.sdcadm');
+    assert.string(args.serverName, 'args.serverName');
+    assert.func(cb, 'cb');
+
+    if (common.UUID_RE.test(args.serverName)) {
+        args.sdcadm.cnapi.getServer(args.serverName, function (err, server) {
+            if (err) {
+                cb(err);
+            } else {
+                cb(null, server);
+            }
+        });
+    } else {
+        args.sdcadm.cnapi.listServers({
+            hostname: args.serverName
+        }, function (err, servers) {
+            if (err) {
+                cb(err);
+            } else if (servers.length === 0) {
+                cb(new errors.UsageError(util.format(
+                    'Cannot find server "%s"', args.serverName)));
+            } else {
+                cb(null, servers[0]);
+            }
+        });
+    }
+}
+
+
+// ---- steps
+
+/**
+ * A function appropriate for `vasync.pipeline` funcs that takes a
+ * `args.serverName` and sets `args.server` to the CNAPI server object,
+ * or errors (via `cb(err)`).
+ */
+function serversServerFromServerName(args, cb) {
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.object(args.sdcadm, 'args.sdcadm');
+    assert.string(args.serverName, 'args.serverName');
+    assert.func(cb, 'cb');
+
+    _cnapiServerFromName(args, function (err, server) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        args.server = server;
+        cb();
+    });
+}
+
+
+/**
+ * A function appropriate for `vasync.pipeline` funcs that takes a
+ * `args.serverNames` and sets `args.servers` to the CNAPI server
+ * objects, or errors (via `cb(err)`).
+ */
+function serversServersFromServerNames(args, cb) {
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.object(args.sdcadm, 'args.sdcadm');
+    assert.arrayOfString(args.serverNames, 'args.serverNames');
+    assert.func(cb, 'cb');
+
+    var servers = [];
+
+    // Note: We are assuming the number in parallel here isn't astronomical.
+    vasync.forEachParallel({
+        inputs: args.serverNames,
+        func: function resolveOneServer(serverName, nextServer) {
+            _cnapiServerFromName({
+                log: args.log,
+                sdcadm: args.sdcadm,
+                serverName: serverName
+            }, function (err, server) {
+                if (err) {
+                    nextServer(err);
+                    return;
+                }
+                servers.push(server);
+                nextServer();
+            });
+        }
+    }, function (err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        args.servers = servers;
+        cb();
+    });
+}
+
+
+/**
+ * A function appropriate for `vasync.pipeline` funcs that iterates through
+ * `args.servers` and errors if any of them are not setup.
+ */
+function serversEnsureServersSetup(args, cb) {
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.arrayOfObject(args.servers, 'args.servers');
+    assert.func(cb, 'cb');
+
+    var unsetup = args.servers.filter(function (s) {
+        return (!s.setup);
+    });
+
+    if (unsetup.length) {
+        cb(new errors.UsageError(util.format(
+            'The following servers are not setup:\n%s\n' +
+            unsetup.join(', '))));
+    } else {
+        cb();
+    }
+}
+
+
+/**
+ * A function appropriate for `vasync.pipeline` funcs that iterates through
+ * `args.servers` and errors if any of them are not running.
+ */
+function serversEnsureServersRunning(args, cb) {
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.arrayOfObject(args.servers, 'args.servers');
+    assert.func(cb, 'cb');
+
+    var notRunning = args.servers.filter(function (s) {
+        return (s.status !== 'running' || s.transitional_status !== '');
+    });
+
+    if (notRunning.length) {
+        cb(new errors.UsageError(util.format(
+            'The following servers are not running:\n%s\n' +
+            notRunning.join(', '))));
+    } else {
+        cb();
+    }
+}
+
+
+//---- exports
+
+module.exports = {
+    serversServerFromServerName: serversServerFromServerName,
+    serversServersFromServerNames: serversServersFromServerNames,
+    serversEnsureServersSetup: serversEnsureServersSetup,
+    serversEnsureServersRunning: serversEnsureServersRunning
+};
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/man/man1/sdcadm.1.ronn b/man/man1/sdcadm.1.ronn
index 245fce8..aad3019 100644
--- a/man/man1/sdcadm.1.ronn
+++ b/man/man1/sdcadm.1.ronn
@@ -257,7 +257,7 @@ rollback the services/instances listed into the provided plan file.
 
 ### sdcadm create \[options\] svc
 
-Create an instance for an existing SDC service.
+Create one or more instances for an existing SDC service.
 
 Note that in order to create an instance of some services the option
 --dev-allow-multiple-instances must be specified, given that those
@@ -277,8 +277,9 @@ alternate choice provided by post-setup subcommand.
 `-i ARG, --image=ARG`
     UUID of the Image to be used for the instance.
 
-`-s ARG, --server=ARG`
-    The UUID for the target server.
+`-s SERVERS, --servers=SERVERS`
+    Comma separated list of servers (either hostnames or uuids)
+    on which to create the instance(s).
 
 `-y, --yes`
     Answer yes to all confirmations.
