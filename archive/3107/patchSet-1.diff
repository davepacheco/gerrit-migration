commit 31289d4fbde0f6c20a3485994442540100d23638 (refs/changes/07/3107/1)
Author: Tim Kordas <tim.kordas@joyent.com>
Date:   2017-12-13T13:22:06-08:00 (1 year, 10 months ago)
    
    joyent/node-manta#301 Add an option to  that will upload a file using the Manta multipart upload API

diff --git a/bin/mmpu b/bin/mmpu
index 306e00a..8e1845d 100755
--- a/bin/mmpu
+++ b/bin/mmpu
@@ -11,6 +11,7 @@ var fs = require('fs');
 var path = require('path');
 var strsplit = require('strsplit');
 var util = require('util');
+var vasync = require('vasync');
 
 var bunyan = require('bunyan');
 var cmdln = require('cmdln');
@@ -29,6 +30,7 @@ var LOG = bunyan.createLogger({
     stream: process.stderr
 });
 
+var DEFAULT_PART_SIZE = 5242880;
 
 ///-- Helpers
 
@@ -477,6 +479,227 @@ MMpu.prototype.do_commit.help = [
     ''
 ].join('\n');
 
+//-- multi-Put
+MMpu.prototype.do_put = function do_put(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+    if (args.length < 1) {
+        cb(new Error('Object path must be specified'));
+        return;
+    } else if (args.length > 1) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var objectPath = args[0];
+    var client = createClient(opts);
+    var headers = {};
+    (opts.header || []).forEach(function (h) {
+        if (h.indexOf(':') === -1) {
+            cb(new Error('Header must be of the form "[header]: value"'));
+            return;
+        }
+        var tmp = strsplit(h, ':', 2);
+        headers[tmp[0]] = tmp[1].trim();
+    });
+
+
+    var filename = opts.file;
+    if (!filename)
+        cb(new Error('Need a file to send'));
+    var partSize = opts.chunksize || DEFAULT_PART_SIZE;
+    if (partSize < DEFAULT_PART_SIZE)
+        cb(new Error('Invalid part size'));
+
+    function splitFile(ctx, callback) {
+        var offset = 0;
+        var filename = ctx.filename;
+        fs.stat(filename, function (err, stats) {
+            if (!stats.isFile()) {
+                client.close();
+                callback(new Error(filename + ' is not a file'));
+                return;
+            }
+            size = stats.size;
+            while (offset < stats.size) {
+                console.log("offset: ", offset);
+                ctx.parts.push({
+                    start: offset,
+                    end: (offset + partSize < size) ? offset + partSize : size
+                });
+                offset += partSize;
+            }
+        });
+        callback();
+    };
+
+    function initUpload(ctx, callback) {
+        opts = ctx.opts;
+        console.log('initupload');
+        var createUploadOpts = {
+            headers: headers,
+            account: opts.account,
+            md5: opts.md5,
+            copies: opts.copies,
+            size: opts.size
+        };
+
+        client.createUpload(ctx.objectPath, createUploadOpts, function (err, obj) {
+            if (err) {
+                // XXX: abort?
+                callback(err);
+            } else {
+                console.log(obj.id);
+                ctx.multiput_obj = obj.id;
+                callback();
+            }
+        });
+    }
+
+    function doUploads(ctx, callback) {
+        console.log("do uploads", ctx.parts);
+        parts = ctx.parts;
+        client = ctx.client;
+
+        funcs = [];
+        ctx.parts.forEach(function (h, i) {
+            console.log("   part: ", h);
+            var partStream = fs.createReadStream(filename, h);
+            upload_part = function (_, callback) {
+                client.uploadPart(partStream, ctx.multiput_obj, i, ctx.opts, function (err, res) {
+                    if (err) {
+                        // XXX: abort ?
+                        callback(err);
+                        return;
+                    }
+                    console.log(res.headers.etag);
+                    ctx.etags.push(res.headers.etag);
+                    callback();
+                });
+            };
+            funcs.push(upload_part);
+        });
+        vasync.pipeline({
+            'funcs': funcs
+        }, function (err, results) {
+            if (err)
+                console.log('failed: ', err);
+            else
+//                console.log('complete: ', results);
+            callback();
+        });
+    };
+
+    function commitUpload(ctx, callback) {
+        console.log("commit upload:", ctx.etags);
+        // commit
+        var commitUploadOpts = {
+            account: opts.account
+        };
+
+        client.commitUpload(ctx.multiput_obj, ctx.etags, commitUploadOpts, function (err) {
+            if (err) {
+                // XXX: abort ?
+                callback(err);
+            } else {
+                callback();
+            }
+        });
+    };
+
+    var ctx = {
+        opts: opts,
+        filename: filename,
+        objectPath: objectPath,
+        parts: [],
+        etags: [],
+        multiput_obj: null,
+        client: client
+    };
+
+    // Do our operations in order.
+    vasync.pipeline({
+        'arg' : ctx,
+        'funcs' : [
+            initUpload,
+            splitFile,
+            doUploads,
+            commitUpload
+        ]
+    }, function (err, results) {
+        if (err)
+            console.log('failed: ', err);
+        else
+//            console.log('complete: ', results);
+        client.close();
+    });
+
+    cb();
+};
+
+
+MMpu.prototype.do_put.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu put options'
+    },
+    {
+        names: ['copies', 'c'],
+        type: 'positiveInteger',
+        default: 2,
+        help: 'number of copies to make',
+        helpArg: 'COPIES'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'local file to upload',
+        helpArg: 'FILE',
+        completionType: 'file'
+    },
+    {
+        names: ['size', 's'],
+        type: 'positiveInteger',
+        help: 'object size',
+        helpArg: 'SIZE'
+    },
+    {
+        names: ['chunksize', 'S'],
+        type: 'positiveInteger',
+        help: 'object chunk size',
+        helpArg: 'CHUNKSIZE'
+    },
+    {
+        names: ['header', 'H'],
+        type: 'arrayOfString',
+        help: 'HTTP headers to include',
+        helpArg: 'HEADER'
+    },
+    {
+        names: ['md5', 'm'],
+        type: 'string',
+        help: 'Calculated md5 sum (as a base 64 digest) of the object to be ' +
+                'uploaded. The server will validate this md5 on commit, and ' +
+                'will reject the commit if it does not match the sum ' +
+                'provided on create.',
+        helpArg: 'MD5'
+    }
+]);
+
+MMpu.prototype.do_put.help = [
+    'Create, split, upload and commit a multipart upload.',
+    '',
+    'The arguments to this command are first the object path, and second',
+    '(optionally) the input file.',
+    '',
+    'Additionally, mpu put accepts the same options as accepted by mpu create.',
+    '',
+    'Usage:',
+    '    mmpu put [OPTIONS] PATH [FILENAME]',
+    '',
+    '{{options}}',
+    ''
+].join('\n');
 
 //-- GetMPU
 
