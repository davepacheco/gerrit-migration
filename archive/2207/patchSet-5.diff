From 71c93799d8bbf97e5d5d87e757f27859e743e809 Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody.kantor@gmail.com>
Date: Fri, 28 Jul 2017 20:59:19 +0000
Subject: [PATCH] MANTA-2955 audit jobs report false positives when mako dumps
 take over 16 hours

---
 lib/common.js | 59 +++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 50 insertions(+), 9 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 7a68875..c9d178b 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -13,12 +13,13 @@ var fs = require('fs');
 var jsprim = require('jsprim');
 var sprintf = require('sprintf-js').sprintf;
 var vasync = require('vasync');
+var VError = require('verror').VError;
 
 
 // --- Globals
 var MAX_HOURS_IN_PAST = 24;
-// If the mako dumps are more than 3 days in the past we should fatal.
-var MAX_MILLIS_MAKO_DUMPS_IN_PAST = 1000 * 60 * 60 * 24 * 3; // 3 days
+// If the mako dumps are more than 4.5 days in the past we should fatal.
+var MAX_MILLIS_MAKO_DUMPS_IN_PAST = 1000 * 60 * 60 * 24 * 4.5; // 4.5 days
 
 /*
  * There is presently no way to discover the maximum number of reducers that
@@ -106,7 +107,24 @@ function getObjectsInDir(opts, cb) {
         assert.string(dir, 'dir');
         assert.object(client, 'client');
 
+        // For every object that we're going to return, we append the
+        // 'info' structure.
+        var getInfo = function (obj, callback) {
+                client.info(obj.fullPath, {},
+                        function (infoErr, result) {
+                                if (infoErr) {
+                                        errors.push(infoErr);
+                                } else {
+                                        obj.info = result.headers;
+                                        objects.push(obj);
+                                }
+                                callback();
+                        });
+        };
+
+        var queue = vasync.queue(getInfo, 10);
         var objects = [];
+        var errors = [];
         client.ls(dir, {}, function (err, res) {
                 if (err) {
                         cb(err);
@@ -114,14 +132,16 @@ function getObjectsInDir(opts, cb) {
                 }
 
                 res.on('object', function (obj) {
+                        var path = dir + '/' + obj.name;
                         if (opts.returnObjects) {
-                                objects.push({
+                                // Add the object to the work queue.
+                                queue.push({
                                         'directory': dir,
                                         'object': obj,
-                                        'fullPath': dir + '/' + obj.name
+                                        'fullPath': path
                                 });
                         } else {
-                                objects.push(dir + '/' + obj.name);
+                                objects.push(path);
                         }
                 });
 
@@ -130,9 +150,13 @@ function getObjectsInDir(opts, cb) {
                 });
 
                 res.once('end', function () {
-                        cb(null, objects);
+                        queue.close();
                 });
         });
+
+        queue.once('end', function () {
+                cb(VError.errorFromList(errors), objects);
+        });
 }
 
 
@@ -356,23 +380,40 @@ function findLatestMakoObjects(opts, cb) {
                 var earliestDump = null;
                 for (var i = 0; i < objects.length; ++i) {
                         var o = objects[i].object;
+                        var info = objects[i].info;
+                        var startTime;
+
+                        // If present, use the time when the dump was started,
+                        // since that is what we want to base our selection
+                        // of manatee backups on.
+                        // Older versions did not always provide this field, so
+                        // fall back to the dump's mtime if that's all we have.
+                        if (info && info['m-mako-dump-time']) {
+                                startTime = info['m-mako-dump-time'];
+                        } else {
+                                startTime = o.mtime;
+                        }
+
                         //We can string compare here since we have an
                         // ISO 8601 date.
-                        if (earliestDump === null || earliestDump > o.mtime) {
-                                earliestDump = o.mtime;
+                        // 'earliestDump' represents the dump which _started_
+                        // least recently.
+                        if (earliestDump === null || earliestDump > startTime) {
+                                earliestDump = startTime;
                         }
                 }
                 if (earliestDump === null) {
                         return (cb(new Error('Couldn\'t determine earliest ' +
                                              'dump from mako dumps.')));
                 }
+                opts.log.info('Earliest Mako dump started at %s', earliestDump);
 
                 // Mako dumps are too far in the past, then fatal.
                 var now = new Date().getTime();
                 var eTime = new Date(earliestDump).getTime();
                 if ((now - MAX_MILLIS_MAKO_DUMPS_IN_PAST) > eTime) {
                         var error = new Error('Earliest mako dumps are too ' +
-                                              ' old: ' + earliestDump);
+                                              'old: ' + earliestDump);
                         return (cb(error));
                 }
 
-- 
2.21.0

