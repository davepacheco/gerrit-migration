From 31bc612ca81dcea8024c06f5b0533f89732d40fa Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody.kantor@gmail.com>
Date: Mon, 17 Jul 2017 19:50:06 +0000
Subject: [PATCH] MANTA-2955 audit jobs report false positives when mako dumps
 take over 16 hours

---
 lib/common.js | 76 +++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 67 insertions(+), 9 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 7a68875..d928b4b 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -13,6 +13,7 @@ var fs = require('fs');
 var jsprim = require('jsprim');
 var sprintf = require('sprintf-js').sprintf;
 var vasync = require('vasync');
+var MultiError = require('verror').MultiError;
 
 
 // --- Globals
@@ -106,7 +107,27 @@ function getObjectsInDir(opts, cb) {
         assert.string(dir, 'dir');
         assert.object(client, 'client');
 
+        // For every object that we're going to return, we append the
+        // 'info' structure.
+        var getInfo = function (obj, callback) {
+                client.info(obj.fullPath, {},
+                        function (infoErr, result) {
+                                obj.info = result.headers;
+                                objects.push(obj);
+                                callback(infoErr);
+                        });
+        };
+
+        var handleError = function (err) {
+                if (err) {
+                        queue.kill();
+                        errors.push(err);
+                }
+        };
+
+        var queue = vasync.queue(getInfo, 10);
         var objects = [];
+        var errors = [];
         client.ls(dir, {}, function (err, res) {
                 if (err) {
                         cb(err);
@@ -114,14 +135,16 @@ function getObjectsInDir(opts, cb) {
                 }
 
                 res.on('object', function (obj) {
+                        var path = dir + '/' + obj.name;
                         if (opts.returnObjects) {
-                                objects.push({
+                                // Add the object to the work queue.
+                                queue.push({
                                         'directory': dir,
                                         'object': obj,
-                                        'fullPath': dir + '/' + obj.name
-                                });
+                                        'fullPath': path
+                                }, handleError);
                         } else {
-                                objects.push(dir + '/' + obj.name);
+                                objects.push(path);
                         }
                 });
 
@@ -130,9 +153,18 @@ function getObjectsInDir(opts, cb) {
                 });
 
                 res.once('end', function () {
-                        cb(null, objects);
+                        queue.close();
                 });
         });
+
+        queue.once('end', function () {
+                if (errors.length > 0) {
+                        cb(new MultiError(errors), objects);
+                } else {
+                        cb(null, objects);
+                }
+        });
+
 }
 
 
@@ -354,25 +386,51 @@ function findLatestMakoObjects(opts, cb) {
                 }
 
                 var earliestDump = null;
+                var oldestDump = null;
                 for (var i = 0; i < objects.length; ++i) {
                         var o = objects[i].object;
+                        var info = objects[i].info;
+                        var startTime, endTime;
+
+                        // If present, use the time when the dump was started,
+                        // since that is what we want to base our selection
+                        // of manatee backups on.
+                        // Older versions did not always provide this field, so
+                        // fall back to the dump's mtime if that's all we have.
+                        if (info && info['m-mako-dump-time']) {
+                                startTime = info['m-mako-dump-time'];
+                        } else {
+                                startTime = o.mtime;
+                        }
+                        endTime = o.mtime;
+
                         //We can string compare here since we have an
                         // ISO 8601 date.
-                        if (earliestDump === null || earliestDump > o.mtime) {
-                                earliestDump = o.mtime;
+                        // 'earliestDump' represents the dump which _started_
+                        // least recently.
+                        // 'oldestDump' represents the dump which _finished_
+                        // least recently.
+                        if (earliestDump === null || earliestDump > startTime) {
+                                earliestDump = startTime;
                         }
+                        if (oldestDump === null || oldestDump > endTime) {
+                                oldestDump = endTime;
+                        }
+
                 }
                 if (earliestDump === null) {
                         return (cb(new Error('Couldn\'t determine earliest ' +
                                              'dump from mako dumps.')));
                 }
+                opts.log.info('Earliest Mako dump started at %s', earliestDump);
+                opts.log.info('Oldest Mako dump finished at %s', oldestDump);
 
                 // Mako dumps are too far in the past, then fatal.
                 var now = new Date().getTime();
-                var eTime = new Date(earliestDump).getTime();
+                var eTime = new Date(oldestDump).getTime();
                 if ((now - MAX_MILLIS_MAKO_DUMPS_IN_PAST) > eTime) {
                         var error = new Error('Earliest mako dumps are too ' +
-                                              ' old: ' + earliestDump);
+                                              'old: ' + oldestDump);
                         return (cb(error));
                 }
 
-- 
2.21.0

