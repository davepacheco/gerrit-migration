From 1bb5bd8e817048e05fcca06873a544914573625c Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 6 Jul 2017 11:39:18 -0700
Subject: [PATCH] joyent/node-zkstream#23 add getACL to read the ACL for a node
 joyent/node-zkstream#21 document isConnected method joyent/node-zkstream#22
 increase test coverage

---
 README.md          |  19 +++
 lib/client.js      |  20 ++++
 lib/zk-buffer.js   |   8 ++
 lib/zk-streams.js  |  31 ++++-
 package.json       |   2 +-
 test/basic.test.js | 142 ++++++++++++++++++++++
 test/nasty.test.js | 288 +++++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 503 insertions(+), 7 deletions(-)
 create mode 100644 test/nasty.test.js

diff --git a/README.md b/README.md
index 1821fc5..76d326e 100644
--- a/README.md
+++ b/README.md
@@ -70,7 +70,12 @@ Parameters
  - `cb`: an optional Function `(err, children)` with parameters:
    - `children`: an Array of Strings
 
+### `Client#isConnected()`
 
+Determines whether the client has a working connection to ZooKeeper at the
+present time.
+
+Returns boolean.
 
 ### `Client#stat(path[, cb])`
 
@@ -102,6 +107,20 @@ Parameters
    - `stat`: an Object, same format as `stat` in `Client#stat`
 
 
+### `Client#getACL(path[, cb])`
+
+Gets the data stored in a given node.
+
+Parameters
+ - `path`: a String, path to the node
+ - `cb`: an optional Function `(err, acl)` with parameters:
+   - `acl`: an Array of Objects, ACL entries, with properties:
+     - `id`: an Object, the principal the ACL entry applies to
+       - `scheme`: a String, the principal URI scheme
+       - `id`: a String, the remainder of the URI
+     - `perms`: an Array of Strings, the permissions given to
+       this principal
+
 
 ### `Client#delete(path, version[, cb])`
 
diff --git a/lib/client.js b/lib/client.js
index 099d65c..5e50a44 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -422,6 +422,26 @@ ZKClient.prototype.stat = function (path, cb) {
 	req.once('error', cb);
 };
 
+ZKClient.prototype.getACL = function (path, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.func(cb, 'callback');
+
+	var conn = this.currentConnection();
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
+	var req = conn.request({
+		opcode: 'GET_ACL',
+		path: path,
+		watch: false
+	});
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.acl);
+	});
+	req.once('error', cb);
+};
+
 ZKClient.prototype.sync = function (path, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.func(cb, 'callback');
diff --git a/lib/zk-buffer.js b/lib/zk-buffer.js
index a4d1f96..51549f4 100644
--- a/lib/zk-buffer.js
+++ b/lib/zk-buffer.js
@@ -47,6 +47,14 @@ ZKBuffer.prototype.readConnectResponse = function () {
 	return (pkt);
 };
 
+ZKBuffer.prototype.writeConnectResponse = function (pkt) {
+	mod_assert.object(pkt, 'packet');
+	this.writeInt(pkt.protocolVersion, 'protocolVersion');
+	this.writeInt(pkt.timeOut, 'timeOut');
+	this.writeLong(pkt.sessionId);
+	this.writeBuffer(pkt.passwd, 'passwd');
+};
+
 ZKBuffer.prototype.readRequest = function () {
 	var pkt = {};
 	pkt.xid = this.readInt();
diff --git a/lib/zk-streams.js b/lib/zk-streams.js
index 6e4eafa..c9d59c1 100644
--- a/lib/zk-streams.js
+++ b/lib/zk-streams.js
@@ -25,9 +25,11 @@ const MAX_PACKET = 16*1024*1024;
 function ZKDecodeStream(opts) {
 	mod_assert.object(opts, 'options');
 	mod_assert.object(opts.fsm, 'options.fsm');
+	mod_assert.optionalBool(opts.isServer, 'options.isServer');
 	this.zd_fsm = opts.fsm;
 	this.zd_used = 0;
 	this.zd_buffer = new Buffer(4096);
+	this.zd_server = (opts.isServer === true);
 	opts.readableObjectMode = true;
 	opts.writableObjectMode = false;
 	mod_stream.Transform.call(this, opts);
@@ -42,7 +44,7 @@ ZKDecodeStream.prototype._transform = function (chunk, enc, cb) {
 		this.expandBuffer();
 	chunk.copy(this.zd_buffer, this.zd_used);
 	this.zd_used += chunk.length;
-	while (this.zd_used > 4) {
+	while (this.zd_used >= 4) {
 		var len = this.zd_buffer.readInt32BE(0);
 		if (len < 0 || len > MAX_PACKET) {
 			this.emit('error', new mod_errors.ZKProtocolError(
@@ -65,7 +67,10 @@ ZKDecodeStream.prototype._transform = function (chunk, enc, cb) {
 		var zkb = new ZKBuffer({buffer: pktBuf});
 		if (self.zd_fsm.isInState('handshaking')) {
 			try {
-				pkt = zkb.readConnectResponse();
+				if (self.zd_server)
+					pkt = zkb.readConnectRequest();
+				else
+					pkt = zkb.readConnectResponse();
 			} catch (e) {
 				self.emit('error',
 				    new mod_errors.ZKProtocolError('BAD_DECODE',
@@ -76,7 +81,12 @@ ZKDecodeStream.prototype._transform = function (chunk, enc, cb) {
 			self.push(pkt);
 		} else {
 			try {
-				pkt = zkb.readResponse(self.zd_fsm.zcf_xidMap);
+				if (self.zd_server) {
+					pkt = zkb.readRequest();
+				} else {
+					pkt = zkb.readResponse(
+					    self.zd_fsm.zcf_xidMap);
+				}
 			} catch (e) {
 				self.emit('error',
 				    new mod_errors.ZKProtocolError('BAD_DECODE',
@@ -99,7 +109,9 @@ ZKDecodeStream.prototype.expandBuffer = function () {
 function ZKEncodeStream(opts) {
 	mod_assert.object(opts, 'options');
 	mod_assert.object(opts.fsm, 'options.fsm');
+	mod_assert.optionalBool(opts.isServer, 'options.isServer');
 	this.ze_fsm = opts.fsm;
+	this.ze_server = (opts.isServer === true);
 	opts.readableObjectMode = false;
 	opts.writableObjectMode = true;
 	mod_stream.Transform.call(this, opts);
@@ -108,19 +120,26 @@ mod_util.inherits(ZKEncodeStream, mod_stream.Transform);
 
 ZKEncodeStream.prototype._transform = function (pkt, enc, cb) {
 	mod_assert.object(pkt);
+	var self = this;
 	var zkb = new ZKBuffer({});
 
 	if (this.ze_fsm.isInState('handshaking')) {
 		zkb.writeLengthPrefixed(function (sub) {
-			sub.writeConnectRequest(pkt);
+			if (self.ze_server)
+				sub.writeConnectResponse(pkt);
+			else
+				sub.writeConnectRequest(pkt);
 		});
 		this.push(zkb.toBuffer());
 		cb();
 	} else {
 		mod_assert.number(pkt.xid, 'xid');
-		mod_assert.string(pkt.opcode, 'opcode');
+		mod_assert.optionalString(pkt.opcode, 'opcode');
 		zkb.writeLengthPrefixed(function (sub) {
-			sub.writeRequest(pkt);
+			if (self.ze_server)
+				sub.writeResponse(pkt);
+			else
+				sub.writeRequest(pkt);
 		});
 		this.push(zkb.toBuffer());
 		this.ze_fsm.zcf_xidMap[pkt.xid] = pkt.opcode;
diff --git a/package.json b/package.json
index a9d8f23..bf0e01a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zkstream",
-  "version": "0.9.0",
+  "version": "0.10.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 1479e88..7f35312 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -108,6 +108,34 @@ mod_tape.test('simple connect and ping', function (t) {
 	});
 });
 
+mod_tape.test('double ping', function (t) {
+	var pinged = 0;
+
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.strictEqual(pinged, 2);
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		zkc.ping(function (err) {
+			t.error(err);
+			if (++pinged == 2)
+				zkc.close();
+		});
+		zkc.ping(function (err) {
+			t.error(err);
+			if (++pinged == 2)
+				zkc.close();
+		});
+	});
+});
+
 mod_tape.test('simple connect and ping, with death', function (t) {
 	var stopped = false;
 	var t1, t2;
@@ -181,6 +209,31 @@ mod_tape.test('find the test object', function (t) {
 	});
 });
 
+mod_tape.test('get acl for the test object', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		zkc.getACL('/foo', function (err, acl) {
+			t.error(err);
+			t.ok(Array.isArray(acl));
+			t.equal(acl.length, 1);
+			t.strictEqual(acl[0].id.scheme, 'world');
+			t.strictEqual(acl[0].id.id, 'anyone');
+			t.deepEqual(acl[0].perms.sort(),
+			    ['ADMIN', 'CREATE', 'DELETE', 'READ', 'WRITE']);
+			zkc.close();
+		});
+	});
+});
+
 mod_tape.test('delete the test object', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
@@ -561,6 +614,95 @@ mod_tape.test('session resumption with watcher', function (t) {
 	}
 });
 
+mod_tape.test('session resumption with watcher (ping timeout)', function (t) {
+	var connected = 0;
+	var closed = 0;
+
+	var zkc1 = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	var zkc2 = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	var ev1 = [];
+	zkc1.on('connect', ev1.push.bind(ev1, 'connect'));
+	zkc1.on('session', ev1.push.bind(ev1, 'session'));
+	zkc1.on('expire', ev1.push.bind(ev1, 'expire'));
+	zkc1.on('disconnect', ev1.push.bind(ev1, 'disconnect'));
+
+	zkc1.on('close', function () {
+		t.deepEqual(ev1,
+		    ['session', 'connect', 'disconnect', 'connect']);
+		if (++closed >= 2)
+			t.end();
+	});
+
+	zkc2.on('close', function () {
+		if (++closed >= 2)
+			t.end();
+	});
+
+	zkc1.on('connect', function () {
+		if (++connected == 2) {
+			create();
+		}
+	});
+
+	zkc2.on('connect', function () {
+		if (++connected == 2) {
+			create();
+		}
+	});
+
+	function create() {
+		var ret = 0;
+		var d = new Buffer('hi there', 'ascii');
+		var w = zkc2.watcher('/foo3');
+		function onCreated() {
+			if (++ret == 2) {
+				w.removeListener('created', onCreated);
+				ready();
+			}
+		}
+		w.on('created', onCreated);
+		zkc1.watcher('/foo3').on('dataChanged', function (data) {
+			if (data.toString('utf-8') === 'hello again') {
+				zkc1.close();
+			}
+		});
+		zkc1.create('/foo3', d, {}, function (err, path) {
+			t.error(err);
+			t.strictEqual(path, '/foo3');
+			if (++ret == 2) {
+				w.removeListener('created', onCreated);
+				ready();
+			}
+		});
+	}
+
+	function ready() {
+		zkc2.stat('/foo3', function (err, stat) {
+			t.error(err);
+
+			var sock = zkc1.getSession().getConnection().zcf_socket;
+			t.ok(sock.listeners('error').length > 0);
+			sock.destroy();
+
+			var data = new Buffer('hello again');
+			zkc2.set('/foo3', data, stat.version, function (err2) {
+				t.error(err2);
+				zkc2.close();
+			});
+		});
+	}
+});
+
 mod_tape.test('stop zk server', function (t) {
 	zk.on('stateChanged', function (st) {
 		if (st === 'stopped')
diff --git a/test/nasty.test.js b/test/nasty.test.js
new file mode 100644
index 0000000..d983bea
--- /dev/null
+++ b/test/nasty.test.js
@@ -0,0 +1,288 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+const mod_tape = require('tape');
+const mod_zk = require('./zkserver');
+const mod_zkc = require('../lib/index');
+const mod_net = require('net');
+const mod_bunyan = require('bunyan');
+const mod_zkbuf = require('../lib/zk-buffer');
+const mod_zkstreams = require('../lib/zk-streams');
+const mod_crypto = require('crypto');
+
+var log = mod_bunyan.createLogger({
+	name: 'zkstream-test',
+	level: process.env.LOG_LEVEL || 'info'
+});
+
+var zk;
+var pkt, pkt2;
+var connCount = 0;
+var connCb;
+
+mod_tape.test('start awful zk server', function (t) {
+	zk = mod_net.createServer();
+	zk.on('connection', function (sock) {
+		++connCount;
+		sock.on('error', function (e) {
+			log.error(e);
+		});
+		sock.write(pkt);
+		if (pkt2) {
+			setTimeout(function () {
+				sock.write(pkt2);
+			}, 100);
+		}
+	});
+	zk.listen(2181, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('connect failure: bad length (too big)', function (t) {
+	pkt = new Buffer('4000', 'hex');
+	pkt2 = new Buffer('4000', 'hex');
+
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+});
+
+mod_tape.test('connect failure: bad length (zero)', function (t) {
+	pkt = new Buffer('000000000102', 'hex');
+
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+});
+
+mod_tape.test('connect failure: bad length (negative)', function (t) {
+	pkt = new Buffer('fffffffe0102', 'hex');
+
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+});
+
+mod_tape.test('stop awful zk server', function (t) {
+	zk.close();
+	zk = undefined;
+	t.end();
+});
+
+mod_tape.test('argument assertions', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('connect', function (st) {
+		t.fail();
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	t.throws(function () {
+		zkc.list(5);
+	});
+
+	t.throws(function () {
+		zkc.list('/foo');
+	});
+
+	zkc.close();
+});
+
+mod_tape.test('calling before ready (not connected)', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('connect', function (st) {
+		t.fail();
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.list('/', function (err) {
+		t.ok(err);
+		t.strictEqual(err.code, 'CONNECTION_LOSS');
+		zkc.close();
+	});
+});
+
+mod_tape.test('start hanging zk server', function (t) {
+	zk = mod_net.createServer();
+	zk.on('connection', function (sock) {
+		++connCount;
+		sock.on('error', function (e) {
+			log.error(e);
+		});
+		if (connCb)
+			connCb();
+	});
+	zk.listen(2181, function () {
+		t.end();
+	});
+});
+
+
+mod_tape.test('calling before ready (handshaking)', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('connect', function (st) {
+		t.fail();
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	connCb = function () {
+		connCb = undefined;
+		zkc.list('/', function (err) {
+			t.ok(err);
+			t.strictEqual(err.code, 'CONNECTION_LOSS');
+			zkc.close();
+		});
+	};
+});
+
+mod_tape.test('stop awful zk server', function (t) {
+	zk.close();
+	zk = undefined;
+	t.end();
+});
+
+mod_tape.test('start fake zk server', function (t) {
+	zk = mod_net.createServer();
+	zk.on('connection', function (sock) {
+		++connCount;
+		var fsm = {};
+		fsm.isInState = function (st) {
+			return (st === 'handshaking');
+		};
+		fsm.zcf_xidMap = {};
+		var enc = new mod_zkstreams.ZKEncodeStream({
+			fsm: fsm,
+			isServer: true
+		});
+		var dec = new mod_zkstreams.ZKDecodeStream({
+			fsm: fsm,
+			isServer: true
+		});
+		sock.pipe(dec);
+		enc.pipe(sock);
+		sock.on('error', function (e) {
+			log.error(e);
+		});
+
+		dec.on('readable', function () {
+			var d = dec.read();
+			if (d === null)
+				return;
+			t.strictEqual(typeof (d), 'object');
+			t.notStrictEqual(d, null);
+			t.strictEqual(d.protocolVersion, 0);
+
+			t.strictEqual(dec.read(), null);
+
+			var r = {
+				protocolVersion: 1,
+				timeOut: d.timeOut,
+				sessionId: mod_crypto.randomBytes(8),
+				passwd: mod_crypto.randomBytes(8)
+			};
+			enc.write(r);
+		});
+	});
+	zk.listen(2181, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('handshake failure: bad version', function (t) {
+	pkt = new Buffer('fffffffe0102', 'hex');
+
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+});
+
+mod_tape.test('stop fake zk server', function (t) {
+	zk.close();
+	zk = undefined;
+	t.end();
+});
-- 
2.21.0

