commit a2ccede86e21e07018b0ac4678843465ecbfd674
Author: YanChii <janci@binaryparadise.com>
Date:   2019-03-29T12:54:25+00:00 (6 months ago)
    
    fix live migration

diff --git a/Makefile b/Makefile
index ee2192b..437ea20 100644
--- a/Makefile
+++ b/Makefile
@@ -58,7 +58,8 @@ KERNEL_CPPFLAGS = \
 	-nostdinc \
 	-I$(KERNEL_SOURCE)/usr/src/uts/common \
 	-I$(KERNEL_SOURCE)/usr/src/uts/intel \
-	-I$(KERNEL_SOURCE)/usr/src/uts/i86pc
+	-I$(KERNEL_SOURCE)/usr/src/uts/i86pc \
+	-I$(PROTO_AREA)/usr/include
 
 DMOD_CPPFLAGS = \
 	$(ALWAYS_CPPFLAGS) \
diff --git a/kvm.c b/kvm.c
index 9a729de..2827351 100644
--- a/kvm.c
+++ b/kvm.c
@@ -314,6 +314,7 @@
 #include <asm/cpu.h>
 #include <sys/id_space.h>
 #include <sys/hma.h>
+#include <time.h>
 
 #include "kvm_bitops.h"
 #include "kvm_vmx.h"
@@ -1963,9 +1964,9 @@ kvm_ioctl(dev_t dev, int cmd, intptr_t arg, int md, cred_t *cr, int *rv)
 		{ KVM_X86_SETUP_MCE, kvm_vcpu_ioctl_x86_setup_mce,
 		    sizeof (uint64_t) },
 		{ KVM_GET_MSRS, kvm_vcpu_ioctl_get_msrs,
-		    sizeof (struct kvm_msrs), B_TRUE },
+		    sizeof (struct msr_data), B_TRUE },
 		{ KVM_SET_MSRS, kvm_vcpu_ioctl_set_msrs,
-		    sizeof (struct kvm_msrs) },
+		    sizeof (struct msr_data) },
 		{ KVM_GET_MP_STATE, kvm_arch_vcpu_ioctl_get_mpstate,
 		    sizeof (struct kvm_mp_state), B_TRUE },
 		{ KVM_SET_MP_STATE, kvm_arch_vcpu_ioctl_set_mpstate,
@@ -2536,6 +2537,11 @@ kvm_ioctl(dev_t dev, int cmd, intptr_t arg, int md, cred_t *cr, int *rv)
 			break;
 		}
 
+		if (copyin(argp, &chip, sizeof chip) != 0) {
+			rval = EFAULT;
+			break;
+		}
+
 		rval = kvm_vm_ioctl_get_irqchip(kvmp, &chip);
 
 		if (rval == 0 && copyout(&chip, argp, sz) != 0) {
@@ -2587,6 +2593,44 @@ kvm_ioctl(dev_t dev, int cmd, intptr_t arg, int md, cred_t *cr, int *rv)
 		rval = kvm_vm_ioctl_get_dirty_log(kvmp, &log);
 		break;
 	}
+	case KVM_SET_CLOCK: {
+		struct kvm *kvmp;
+		struct kvm_clock_data user_ns;
+		hrtime_t now_ns;
+
+		rval = 0;
+		if (copyin(argp, &user_ns, sizeof(user_ns)) != 0) {
+			rval = EFAULT;
+			break;
+		}
+		if ((kvmp = ksp->kds_kvmp) == NULL) {
+			rval = EINVAL;
+			break;
+		}
+
+		now_ns = gethrtime();
+		kvmp->arch.boot_hrtime = now_ns - (hrtime_t)user_ns.clock;
+		break;
+	}
+	case KVM_GET_CLOCK: {
+		struct kvm *kvmp;
+		struct kvm_clock_data user_ns;
+		hrtime_t now_ns;
+
+		if ((kvmp = ksp->kds_kvmp) == NULL) {
+			rval = EINVAL;
+			break;
+		}
+
+		now_ns = gethrtime();
+		user_ns.clock = (uint64_t)(now_ns - kvmp->arch.boot_hrtime);
+		user_ns.flags = 0;
+
+		rval = 0;
+		if (copyout(&user_ns, argp, sizeof(user_ns)) != 0)
+			rval = EFAULT;
+		break;
+	}
 	case KVM_NMI: {
 
 		if (ksp->kds_kvmp == NULL) {
diff --git a/kvm_host.h b/kvm_host.h
index 58715cc..6e5e1ff 100644
--- a/kvm_host.h
+++ b/kvm_host.h
@@ -366,8 +366,8 @@ extern int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *,
     struct kvm_guest_debug *);
 extern int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *);
 
-extern int kvm_vcpu_ioctl_get_msrs(struct kvm_vcpu *, struct kvm_msrs *, int *);
-extern int kvm_vcpu_ioctl_set_msrs(struct kvm_vcpu *, struct kvm_msrs *, int *);
+extern int kvm_vcpu_ioctl_get_msrs(struct kvm_vcpu *, struct msr_data *, int *);
+extern int kvm_vcpu_ioctl_set_msrs(struct kvm_vcpu *, struct msr_data *, int *);
 extern int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *, uint64_t *);
 extern int kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *, struct kvm_cpuid2 *);
 extern int kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *, struct kvm_cpuid2 *,
diff --git a/kvm_x86.c b/kvm_x86.c
index 622198a..eae3cc8 100644
--- a/kvm_x86.c
+++ b/kvm_x86.c
@@ -757,6 +757,8 @@ kvm_write_guest_time(struct kvm_vcpu *v)
 
 	membar_producer();
 
+	DTRACE_PROBE1(kvm_write_pvclock, struct pvclock_vcpu_time_info*, (struct pvclock_vcpu_time_info*)pvclock);
+
 	/* indicate update finished */
 	pvclock->version = version + 1;
 	vcpu->time_update = hrt;
@@ -1494,14 +1496,14 @@ __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
 }
 
 int
-kvm_vcpu_ioctl_get_msrs(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, int *rv)
+kvm_vcpu_ioctl_get_msrs(struct kvm_vcpu *vcpu, struct msr_data *msrs, int *rv)
 {
 	int r;
 
-	if (msrs->nmsrs >= MAX_IO_MSRS)
+	if (msrs->info.nmsrs >= MAX_IO_MSRS)
 		return (-E2BIG);
 
-	if ((r = __msr_io(vcpu, msrs, msrs->entries, kvm_get_msr)) < 0)
+	if ((r = __msr_io(vcpu, &msrs->info, msrs->entries, kvm_get_msr)) < 0)
 		return (r);
 
 	*rv = r;
@@ -1510,14 +1512,14 @@ kvm_vcpu_ioctl_get_msrs(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, int *rv)
 }
 
 int
-kvm_vcpu_ioctl_set_msrs(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, int *rv)
+kvm_vcpu_ioctl_set_msrs(struct kvm_vcpu *vcpu, struct msr_data *msrs, int *rv)
 {
 	int r;
 
-	if (msrs->nmsrs >= MAX_IO_MSRS)
+	if (msrs->info.nmsrs >= MAX_IO_MSRS)
 		return (-E2BIG);
 
-	if ((r = __msr_io(vcpu, msrs, msrs->entries, do_set_msr)) < 0)
+	if ((r = __msr_io(vcpu, &msrs->info, msrs->entries, do_set_msr)) < 0)
 		return (-EINVAL);
 
 	*rv = r;
diff --git a/kvm_x86.h b/kvm_x86.h
index 668a2ee..180aefb 100644
--- a/kvm_x86.h
+++ b/kvm_x86.h
@@ -155,6 +155,11 @@ typedef struct kvm_msrs {
 	struct kvm_msr_entry entries[100];
 } kvm_msrs_t;
 
+typedef struct msr_data {
+	struct kvm_msrs info;
+	struct kvm_msr_entry entries[100];
+} msr_data_t;
+
 /* for KVM_GET_MSR_INDEX_LIST */
 typedef struct kvm_msr_list {
 	uint32_t nmsrs; /* number of msrs in entries */
