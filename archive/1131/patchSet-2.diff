From acf83f7a3ff4a25c03d4a9c46f238ba58efbb72e Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Fri, 16 Dec 2016 15:31:32 +0000
Subject: [PATCH] OS-5853 processes exiting or exited are missing from lx /proc

---
 usr/src/uts/common/brand/lx/os/lx_pid.c       | 32 +++++++++++++------
 usr/src/uts/common/brand/lx/os/lx_ptrace.c    |  4 +--
 .../uts/common/brand/lx/procfs/lx_prsubr.c    |  7 +++-
 usr/src/uts/common/brand/lx/sys/lx_brand.h    |  7 ++--
 .../uts/common/brand/lx/syscall/lx_futex.c    |  3 +-
 usr/src/uts/common/brand/lx/syscall/lx_kill.c |  4 +--
 .../uts/common/brand/lx/syscall/lx_sched.c    |  2 +-
 7 files changed, 41 insertions(+), 18 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/os/lx_pid.c b/usr/src/uts/common/brand/lx/os/lx_pid.c
index bd3440568b..7e85295726 100644
--- a/usr/src/uts/common/brand/lx/os/lx_pid.c
+++ b/usr/src/uts/common/brand/lx/os/lx_pid.c
@@ -334,24 +334,38 @@ retry:
 		return (-1);
 	}
 
-	/* Bail on system processes or those which are incomplete */
-	if (p->p_stat == SIDL || (p->p_flag & SSYS) != 0) {
+	/*
+	 * Bail on processes belonging to the system, those which are not yet
+	 * complete and zombies (unless explicitly allowed via the flags).
+	 */
+	if (p->p_stat == SIDL || (p->p_flag & SSYS) != 0 ||
+	    (p->p_stat == SZOMB && (flag & LXP_ZOMBOK) == 0)) {
 		mutex_exit(&pidlock);
 		return (-1);
 	}
 	mutex_enter(&p->p_lock);
 	mutex_exit(&pidlock);
 
-	if (flag == PRLOCK) {
-		int res;
-
-		res = sprtrylock_proc(p);
-		if (res < 0) {
+	if (flag & LXP_PRLOCK) {
+		/*
+		 * It would be convenient to call sprtrylock_proc() for this
+		 * task.  Unfortunately, its behavior of filtering zombies is
+		 * excessive for some lx_proc use cases.  Instead, when the
+		 * provided flags do not indicate that zombies are allowed,
+		 * exiting processes are filtered out (as would be performed by
+		 * sprtrylock_proc).
+		 */
+		if ((p->p_flag & (SEXITING|SEXITLWPS)) != 0 &&
+		    (flag & LXP_ZOMBOK) == 0) {
 			mutex_exit(&p->p_lock);
 			return (-1);
-		} else if (res > 0) {
+		}
+		if (p->p_proc_flag & P_PR_LOCK) {
 			sprwaitlock_proc(p);
 			goto retry;
+		} else {
+			p->p_proc_flag |= P_PR_LOCK;
+			THREAD_KPRI_REQUEST();
 		}
 	}
 
@@ -362,7 +376,7 @@ retry:
 
 		ld = lwp_hash_lookup(p, tid);
 		if (ld == NULL) {
-			if (flag == PRLOCK) {
+			if (flag & LXP_PRLOCK) {
 				sprunprlock(p);
 			}
 			mutex_exit(&p->p_lock);
diff --git a/usr/src/uts/common/brand/lx/os/lx_ptrace.c b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
index bb3d936b26..782a9001e3 100644
--- a/usr/src/uts/common/brand/lx/os/lx_ptrace.c
+++ b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
@@ -410,7 +410,7 @@ lx_ptrace_accord_get_by_pid(pid_t lxpid, lx_ptrace_accord_t **accordp)
 	 * Locate the process containing the tracer LWP based on its Linux pid
 	 * and lock it.
 	 */
-	if (lx_lpid_lock(lxpid, curzone, PRLOCK, &aproc, &athr) != 0) {
+	if (lx_lpid_lock(lxpid, curzone, LXP_PRLOCK, &aproc, &athr) != 0) {
 		return (ESRCH);
 	}
 
@@ -1014,7 +1014,7 @@ lx_ptrace_attach(pid_t lx_pid)
 	 * Locate the process containing the tracee LWP based on its Linux pid
 	 * and lock it.
 	 */
-	if (lx_lpid_lock(lx_pid, curzone, PRLOCK, &rproc, &rthr) != 0) {
+	if (lx_lpid_lock(lx_pid, curzone, LXP_PRLOCK, &rproc, &rthr) != 0) {
 		/*
 		 * We could not find the target process.
 		 */
diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c b/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
index 25824af541..da0cd0d40a 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
@@ -214,7 +214,12 @@ retry:
 		mutex_enter(&p->p_lock);
 		sprlock_proc(p);
 	} else {
-		if (lx_lpid_lock(pid, zone, PRLOCK, &p, &t) != 0) {
+		lx_pid_flag_t flags = LXP_PRLOCK;
+
+		if (zombie_ok == ZOMB_OK) {
+			flags |= LXP_ZOMBOK;
+		}
+		if (lx_lpid_lock(pid, zone, flags, &p, &t) != 0) {
 			return (NULL);
 		}
 	}
diff --git a/usr/src/uts/common/brand/lx/sys/lx_brand.h b/usr/src/uts/common/brand/lx/sys/lx_brand.h
index 9bb8bd290a..8e239a4f2a 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_brand.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_brand.h
@@ -678,9 +678,12 @@ extern void lx_emulate_user32(klwp_t *, int, uintptr_t *);
 extern int lx_debug;
 #define	lx_print	if (lx_debug) printf
 
+/*
+ * Flags for lx_lpid_lock()
+ */
 typedef enum {
-	NO_PRLOCK,
-	PRLOCK
+	LXP_PRLOCK	= 0x1,	/* acquire PR_LOCK as part of locking */
+	LXP_ZOMBOK	= 0x2	/* allow locking of zombies */
 } lx_pid_flag_t;
 
 extern void lx_pid_assign(kthread_t *, struct lx_pid *);
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_futex.c b/usr/src/uts/common/brand/lx/syscall/lx_futex.c
index b3f9848ff5..47784cb491 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_futex.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_futex.c
@@ -1000,7 +1000,8 @@ lx_get_robust_list(pid_t pid, void **listp, size_t *lenp)
 		mutex_enter(&curproc->p_lock);
 		sprlock_proc(rproc);
 	} else {
-		if (lx_lpid_lock(pid, curzone, PRLOCK, &rproc, &rthr) != 0) {
+		if (lx_lpid_lock(pid, curzone, LXP_PRLOCK, &rproc,
+		    &rthr) != 0) {
 			return (set_errno(ESRCH));
 		}
 
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_kill.c b/usr/src/uts/common/brand/lx/syscall/lx_kill.c
index 032ef44dbc..6fefbde705 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_kill.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_kill.c
@@ -106,7 +106,7 @@ lx_thrkill(pid_t tgid, pid_t pid, int lx_sig, boolean_t tgkill)
 	/*
 	 * Find the process for the passed pid...
 	 */
-	if (lx_lpid_lock(pid, curzone, NO_PRLOCK, &pp, &t) != 0) {
+	if (lx_lpid_lock(pid, curzone, 0, &pp, &t) != 0) {
 		rv = set_errno(ESRCH);
 		goto free_and_exit;
 	}
@@ -356,7 +356,7 @@ lx_helper_rt_tgsigqueueinfo(pid_t tgid, pid_t tid, int sig, siginfo_t *uinfo)
 	}
 	sqp = kmem_zalloc(sizeof (sigqueue_t), KM_SLEEP);
 
-	if (lx_lpid_lock(tid, curzone, NO_PRLOCK, &p, &t) != 0) {
+	if (lx_lpid_lock(tid, curzone, 0, &p, &t) != 0) {
 		err = ESRCH;
 		goto errout;
 	}
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_sched.c b/usr/src/uts/common/brand/lx/syscall/lx_sched.c
index 72d920d2ba..6d4904a5fe 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_sched.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_sched.c
@@ -189,7 +189,7 @@ lx_sched_pidlock(l_pid_t pid, proc_t **pp, kthread_t **tp, boolean_t is_write)
 		return (0);
 	}
 
-	if (lx_lpid_lock((pid_t)pid, curzone, PRLOCK, &p, &t) != 0) {
+	if (lx_lpid_lock((pid_t)pid, curzone, LXP_PRLOCK, &p, &t) != 0) {
 		return (ESRCH);
 	}
 
-- 
2.21.0

