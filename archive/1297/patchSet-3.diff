From b8a5b16e4d7e45c219adf8998c023a287c1beee7 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Thu, 19 Jan 2017 11:41:16 -0800
Subject: [PATCH] DOCKER-524 Implement docker push

---
 CHANGES.md                      |   4 +
 examples/v2/putManifest.js      |  82 +++++++
 examples/v2/uploadBlob.js       |  93 ++++++++
 lib/docker-json-client.js       |   4 +-
 lib/errors.js                   |  16 ++
 lib/registry-client-v2.js       | 393 +++++++++++++++++++++++++++++---
 package.json                    |   2 +-
 test/v2.amazonecr.test.js       |  57 ++++-
 test/v2.dockerioprivate.test.js | 104 ++++++---
 9 files changed, 682 insertions(+), 73 deletions(-)
 create mode 100644 examples/v2/putManifest.js
 create mode 100644 examples/v2/uploadBlob.js

diff --git a/CHANGES.md b/CHANGES.md
index 3640002..559f174 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,10 @@
 
 (nothing yet)
 
+## 3.3.0
+
+- DOCKER-524 Implement docker push. Adds uploadBlob and putManifest API methods.
+
 ## 3.2.6
 
 - DOCKER-984 Add a 10s connect timeout for endpoints involved in initial
diff --git a/examples/v2/putManifest.js b/examples/v2/putManifest.js
new file mode 100644
index 0000000..cc30ca0
--- /dev/null
+++ b/examples/v2/putManifest.js
@@ -0,0 +1,82 @@
+#!/usr/bin/env node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var fs = require('fs');
+var vasync = require('vasync');
+
+var drc = require('../../');
+var mainline = require('../mainline');
+
+function getFileSha256(filepath, callback) {
+    var sha256 = crypto.createHash('sha256');
+    var stream = fs.createReadStream(filepath);
+
+    sha256.on('readable', function () {
+        callback(null, sha256.read().toString('hex'));
+    });
+
+    stream.on('error', function (streamErr) {
+        callback(streamErr);
+    });
+
+    stream.pipe(sha256);
+}
+
+// Shared mainline with examples/foo.js to get CLI opts.
+var cmd = 'putManifest';
+mainline({cmd: cmd}, function (log, parser, opts, args) {
+    if (!args[0] || (args[0].indexOf(':') === -1 && !args[1])) {
+        console.error('usage: node examples/v2/%s.js REPO[:TAG|@DIGEST] ' +
+            'manifest-file\n\n' +
+            'options:\n' +
+            '%s', cmd, parser.help().trimRight());
+        process.exit(2);
+    }
+
+    // The interesting stuff starts here.
+    var rar = drc.parseRepoAndRef(args[0]);
+    assert.ok(rar.canonicalName, 'must specify a repo');
+    var ref = rar.tag || rar.digest;
+    assert.ok(ref, 'must specify a tag or digest');
+
+    console.log('Repo:', rar.canonicalName + ':' + ref);
+
+    var filepath = args[1];
+    assert.string(filepath, 'must specify a blob filepath');
+    var contents = fs.readFileSync(filepath).toString();
+
+    var client = drc.createClientV2({
+        repo: rar,
+        log: log,
+        insecure: opts.insecure,
+        username: opts.username,
+        password: opts.password
+    });
+
+    console.log('Uploading manifest: %s', filepath);
+    var manifestOpts = {
+        manifest: contents,
+        ref: ref
+    };
+    client.putManifest(manifestOpts,
+            function (uploadErr, res, digest, location) {
+        if (uploadErr) {
+            mainline.fail(cmd, uploadErr, opts);
+        }
+
+        console.log('Upload successful => digest:', digest,
+            'location:', location);
+        client.close();
+    });
+});
diff --git a/examples/v2/uploadBlob.js b/examples/v2/uploadBlob.js
new file mode 100644
index 0000000..f947122
--- /dev/null
+++ b/examples/v2/uploadBlob.js
@@ -0,0 +1,93 @@
+#!/usr/bin/env node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var fs = require('fs');
+var vasync = require('vasync');
+
+var drc = require('../../');
+var mainline = require('../mainline');
+
+function getFileSha256(filepath, callback) {
+    var sha256 = crypto.createHash('sha256');
+    var stream = fs.createReadStream(filepath);
+
+    sha256.on('readable', function () {
+        var digest = sha256.read();
+        if (digest) {
+            callback(null, digest.toString('hex'));
+        }
+    });
+
+    stream.on('error', function (streamErr) {
+        callback(streamErr);
+    });
+
+    stream.pipe(sha256);
+}
+
+// Shared mainline with examples/foo.js to get CLI opts.
+var cmd = 'uploadBlob';
+mainline({cmd: cmd}, function (log, parser, opts, args) {
+    if (!args[0] || (args[0].indexOf(':') === -1 && !args[1])) {
+        console.error('usage: node examples/v2/%s.js REPO blob-file\n' +
+            '\n' +
+            'options:\n' +
+            '%s', cmd, parser.help().trimRight());
+        process.exit(2);
+    }
+
+    // The interesting stuff starts here.
+    var rar = drc.parseRepoAndRef(args[0]);
+    assert.ok(rar.canonicalName, 'must specify a repo');
+    console.log('Repo:', rar.canonicalName);
+
+    var filepath = args[1];
+    assert.string(filepath, 'must specify a blob filepath');
+    var fileSize = fs.statSync(filepath).size;
+
+    getFileSha256(filepath, function (err, sha256) {
+        var client = drc.createClientV2({
+            insecure: opts.insecure,
+            log: log,
+            repo: rar,
+            username: opts.username,
+            password: opts.password
+        });
+
+        var digest = 'sha256:' + sha256;
+        var stream = fs.createReadStream(filepath);
+        var blobOpts = {
+            contentLength: fileSize,
+            digest: digest,
+            stream: stream
+        };
+        console.log('Uploading blob: %s, digest: %s', filepath, digest);
+        client.blobUpload(blobOpts, function (uploadErr, ress) {
+            if (uploadErr) {
+                mainline.fail(cmd, uploadErr, opts);
+            }
+
+            console.log('Response headers:');
+            console.log(JSON.stringify(ress.headers, null, 4));
+            if (ress.length > 1) {
+                console.log('Response headers (after redirects):');
+                console.log(JSON.stringify(ress[ress.length - 1].headers,
+                    null, 4));
+            }
+
+            console.log('Body:\n%s', ress.body);
+            client.close();
+        });
+    });
+});
diff --git a/lib/docker-json-client.js b/lib/docker-json-client.js
index e21f5ba..b3ff9aa 100644
--- a/lib/docker-json-client.js
+++ b/lib/docker-json-client.js
@@ -92,8 +92,8 @@ DockerJsonClient.prototype.parse = function parse(req, callback) {
 
         function finish() {
             var body = Buffer.concat(chunks, len);
-            if (res.log.trace()) {
-                res.log.trace({body: body.toString(), len: len},
+            if (res.log.trace) {
+                res.log.trace({body: body.toString(), len: len, url: req.path},
                     'body received');
             }
 
diff --git a/lib/errors.js b/lib/errors.js
index 6981c9d..c6ecb1b 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -136,6 +136,13 @@ util.inherits(ManifestVerificationError, _DockerRegistryClientBaseError);
 ManifestVerificationError.prototype.code = 'ManifestVerificationError';
 
 
+function InvalidManifestError() {
+    _DockerRegistryClientBaseError.apply(this, arguments);
+}
+util.inherits(InvalidManifestError, _DockerRegistryClientBaseError);
+InvalidManifestError.prototype.code = 'InvalidManifestError';
+
+
 function DownloadError() {
     _DockerRegistryClientBaseError.apply(this, arguments);
 }
@@ -143,6 +150,13 @@ util.inherits(DownloadError, _DockerRegistryClientBaseError);
 DownloadError.prototype.code = 'DownloadError';
 
 
+function UploadError() {
+    _DockerRegistryClientBaseError.apply(this, arguments);
+}
+util.inherits(UploadError, _DockerRegistryClientBaseError);
+UploadError.prototype.code = 'UploadError';
+
+
 function UnauthorizedError() {
     _DockerRegistryClientBaseError.apply(this, arguments);
 }
@@ -164,6 +178,8 @@ module.exports = {
     InternalError: InternalError,
     ManifestVerificationError: ManifestVerificationError,
     DownloadError: DownloadError,
+    UploadError: UploadError,
+    InvalidManifestError: InvalidManifestError,
     UnauthorizedError: UnauthorizedError,
     TooManyRedirectsError: TooManyRedirectsError
 };
diff --git a/lib/registry-client-v2.js b/lib/registry-client-v2.js
index 5c1946f..016e9b4 100644
--- a/lib/registry-client-v2.js
+++ b/lib/registry-client-v2.js
@@ -37,6 +37,7 @@ var errors = require('./errors');
 
 // https://github.com/docker/docker/blob/77da5d8/registry/config_unix.go#L10
 var DEFAULT_V2_REGISTRY = 'https://registry-1.docker.io';
+var MAX_REGISTRY_ERROR_LENGTH = 10000;
 
 
 
@@ -86,26 +87,67 @@ function _setAuthHeaderFromAuthInfo(headers, authInfo) {
 }
 
 /**
- * XXX still true for v2?
- *
- * Special handling of errors from the registry server.
+ * Return a scope string to be used for an auth request. Example:
+ *   repository:library/nginx:pull
+ */
+function _makeAuthScope(resource, name, actions) {
+    return fmt('%s:%s:%s', resource, name, actions.join(','));
+}
+
+/**
+ * Special handling of JSON body errors from the registry server.
  *
- * When some of the endpoints get a 404, the response body is a largish dump
- * of test/html. We don't want to include that as an error "message". It
- * isn't useful.
+ * POST/PUT endpoints can return an error in the body of the response.
+ * We want to check for that and convert the error body into a real
+ * node Error instance.
  *
  * Usage:
- *      cb(new _sanitizeErr(err, req, res[, errmsg]));
- *
- * where `errmsg` is an optional fallback error message to use for the
- * sanitized 404 err.message.
+ *      var regErr = _getRegistryResponseErr(res[, errorConstructor]));
  */
-function _sanitizeErr(err, req, res, errmsg) {
-    if (err.statusCode === 404 && res && res.headers['content-type'] &&
-        res.headers['content-type'].split(';')[0] !== 'application/json')
-    {
-        err.message = errmsg || 'not found';
+function _getRegistryResponseErr(res, baseError) {
+    if (!res.body) {
+        return null;
+    }
+    var obj = res.body;
+    if (typeof (obj) === 'string' && obj.length <= MAX_REGISTRY_ERROR_LENGTH) {
+        try {
+            obj = JSON.parse(obj);
+        } catch (ex) {
+            // Just return the error as a string.
+            return new errors.InternalError(obj);
+        }
+    }
+    if (typeof (obj) !== 'object' || !obj.hasOwnProperty('errors')) {
+        return null;
+    }
+    if (!Array.isArray(obj.errors)) {
+        return null;
+    }
+    // Example obj:
+    // {
+    //     "errors": [
+    //         {
+    //             "code": "MANIFEST_INVALID",
+    //             "message": "manifest invalid",
+    //             "detail": {}
+    //         }
+    //     ]
+    // }
+    var code, message, detail;
+    if (obj.errors.length === 1) {
+        code = obj.errors[0].code;
+        detail = obj.errors[0].detail;
+        message = obj.errors[0].message;
+    } else {
+        code = obj.errors.map(function (o) { return o.code; }).join(', ');
+        detail = obj.errors.map(function (o) { return o.detail; }).join(', ');
+        message = obj.errors.map(function (o) { return o.message; }).join(', ');
     }
+    var errorClass = baseError || errors.InternalError;
+    var err = new errorClass(message);
+    err.detail = detail;
+    err.code  = code;
+
     return err;
 }
 
@@ -1015,6 +1057,7 @@ function RegistryClientV2(opts) {
     this.username = opts.username;
     this.password = opts.password;
     this._loggedIn = false;
+    this._loggedInScope = null; // Keeps track of the login type.
     this._authInfo = null;
     this._headers = {};
 
@@ -1054,6 +1097,18 @@ function RegistryClientV2(opts) {
             return this.__api;
         }
     });
+
+    Object.defineProperty(this, '_httpapi', {
+        get: function () {
+            if (self.__httpapi === undefined) {
+                self.__httpapi = new restifyClients.HttpClient(common.objMerge({
+                    url: self._url
+                }, self._commonHttpClientOpts));
+                self._clientsToClose.push(self.__httpapi);
+            }
+            return this.__httpapi;
+        }
+    });
 }
 
 
@@ -1103,10 +1158,11 @@ RegistryClientV2.prototype.ping = function regPing(cb) {
  *        `ping()` call. This can be used to save re-pinging.
  *      - opts.pingErr {Object} Required if `pingRes` given. The error
  *        object for `pingRes`.
+ *      - opts.scope {String} Optional. Scope to use in the auth Bearer token.
  * @param cb {Function} `function (err)`
  *
  * Side-effects:
- * - On success, all of `this._loggedIn`, `this._authInfo`, and
+ * - On success, all of `this._loggedIn*`, `this._authInfo`, and
  *   `this._headers.authorization` are set.
  */
 RegistryClientV2.prototype.login = function regLogin(opts, cb) {
@@ -1117,16 +1173,17 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
     assert.object(opts, 'opts');
     assert.func(cb, 'cb');
 
-    if (this._loggedIn) {
-        return cb();
+    var self = this;
+    var scope = opts.scope;
+    if (!scope) {
+        var resource = 'repository';
+        var actions = ['pull'];
+        scope = _makeAuthScope(resource, self.repo.remoteName, actions);
     }
 
-    // TODO: expose requested token actions to ctor
-    var self = this;
-    var resource = 'repository';
-    var actions = ['pull'];
-    var scope = fmt('%s:%s:%s', resource, self.repo.remoteName,
-        actions.join(','));
+    if (this._loggedIn && this._loggedInScope === scope) {
+        return cb();
+    }
 
     login(common.objMerge({
         index: self.repo.index,
@@ -1139,6 +1196,7 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
         if (!err) {
             assert.ok(result);
             self._loggedIn = true;
+            self._loggedInScope = scope;
             self._authInfo = result.authInfo;
             _setAuthHeaderFromAuthInfo(self._headers, self._authInfo);
         }
@@ -1183,10 +1241,6 @@ RegistryClientV2.prototype.login = function regLogin(opts, cb) {
  * Note that, at least, currently we are presuming things are fine with a 401.
  * I.e. defering auth to later calls.
  *
- * TODO: It would be nice to pass error/response info back here. For example,
- * a connection failure to the host could be used to not bother with v1
- * fallback.
- *
  * @param cb {Function} `function (err, supportsV2)`
  *      where `supportsV2` is a boolean indicating if V2 API is supported.
  */
@@ -1213,9 +1267,11 @@ RegistryClientV2.prototype.supportsV2 = function supportsV2(cb) {
                     return cb(null, true);
                 }
             }
+            cb(null, true);
+            return;
         }
         self.log.trace({err: err, res: res}, 'supportsV2 response');
-        cb(null, false);
+        cb(err, false);
     });
 };
 
@@ -1587,6 +1643,285 @@ RegistryClientV2.prototype.createBlobReadStream =
 
 
 
+/*
+ * Upload an image manifest. `ref` is either a tag or a digest.
+ * <https://docs.docker.com/registry/spec/api/#pushing-an-image>
+ *
+ *   client.putManifest({manifest: <string>, ref: <tag or digest>},
+ *   function (err, res, digest, location) {
+ *      // Digest is `res.headers['docker-content-digest']`.
+ *   });
+ */
+RegistryClientV2.prototype.putManifest = function putManifest(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.string(opts.manifest, 'opts.manifest');
+    assert.string(opts.ref, 'opts.ref');
+    assert.func(cb, 'cb');
+
+    // Working variables.
+    var schemaVersion = 1;
+    // Result variables.
+    var digest;
+    var location;
+    var res;
+
+    var log = _createLogger(opts.log);
+    log.trace({
+        digest: opts.digest
+    }, 'putManifest');
+
+    vasync.pipeline({
+        arg: this,
+        funcs: [
+            function _getManifestVersion(_, next) {
+                try {
+                    var manifest = JSON.parse(opts.manifest);
+                    if (manifest.hasOwnProperty('schemaVersion')) {
+                        schemaVersion = parseInt(manifest.schemaVersion, 10);
+                    }
+                } catch (ex) {
+                    next(new errors.InvalidManifestError(
+                        'Unable to parse manifest string: ' + ex));
+                    return;
+                }
+                next();
+            },
+            function doLogin(_, next) {
+                var resource = 'repository';
+                var actions = ['pull', 'push'];
+                var scope = _makeAuthScope(resource, self.repo.remoteName,
+                    actions);
+                self.login({
+                    scope: scope
+                }, next);
+            },
+            function _putManifest(_, next) {
+                var headers = {
+                    'content-type': fmt(
+                        'application/vnd.docker.distribution.manifest.v%d+json',
+                        schemaVersion)
+                };
+                if (self._authInfo) {
+                    _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                }
+                self._httpapi.put({
+                    path: fmt('/v2/%s/manifests/%s',
+                        encodeURI(self.repo.remoteName),
+                        encodeURIComponent(opts.ref)),
+                    headers: headers
+                }, function _afterCall(err, req) {
+                    if (err) {
+                        return next(err);
+                    }
+
+                    req.on('result', function onReqResult(reqErr, res_) {
+                        res = res_;
+                        if (reqErr) {
+                            next(reqErr);
+                            return;
+                        }
+                        res_.body = '';
+                        res_.on('data', function onResChunk(chunk) {
+                            res_.body += chunk;
+                        });
+                        res_.on('end', function onResEnd() {
+                            // Parse and handle errors in the response body.
+                            var regErr = _getRegistryResponseErr(res_,
+                                errors.UploadError);
+                            if (regErr) {
+                                next(regErr);
+                                return;
+                            }
+                            digest = res_.headers['docker-content-digest'];
+                            location = res_.headers.location;
+                            next();
+                        });
+                    });
+
+                    req.on('error', function onReqError(reqErr) {
+                        log.error({
+                            err: reqErr
+                        }, 'Error uploading manifest');
+                        return next(reqErr);
+                    });
+
+                    req.write(opts.manifest);
+                    req.end();
+                });
+            }
+        ]
+    }, function _putManifestCb(err) {
+        cb(err, res, digest, location);
+    });
+};
+
+
+/*
+ * Upload a blob. The request stream will be used to
+ * complete the upload in a single request.
+ *
+ * <https://docs.docker.com/registry/spec/api/#starting-an-upload>
+ *
+ *   client.blobUpload({digest: <string>, stream: <object>,
+ *      contentLength: <number>},
+ *   function (err, res) { });
+ */
+RegistryClientV2.prototype.blobUpload = function blobUpload(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.number(opts.contentLength, 'opts.contentLength');
+    assert.string(opts.digest, 'opts.digest');
+    assert.object(opts.stream, 'opts.stream');
+    assert.optionalString(opts.contentType, 'opts.contentType');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    var log = _createLogger(opts.log);
+    log.trace({
+        contentLength: opts.contentLength,
+        digest: opts.digest
+    }, 'blobUpload');
+
+    // Working variables
+    var uploadUrl;
+    // Result variables.
+    var res;
+
+    vasync.pipeline({
+        arg: this,
+        funcs: [
+            function doLogin(_, next) {
+                log.trace({digest: opts.digest}, 'blobUpload:: doLogin');
+                var resource = 'repository';
+                var actions = ['pull', 'push'];
+                //var actions = ['push'];
+                var scope = _makeAuthScope(resource, self.repo.remoteName,
+                    actions);
+                self.login({
+                    scope: scope
+                }, next);
+            },
+            function _getUploadUuid(_, next) {
+                log.trace({digest: opts.digest}, 'blobUpload:: _getUploadUuid');
+                var path = fmt('/v2/%s/blobs/uploads/',
+                    encodeURI(self.repo.remoteName));
+                var headers = {};
+                if (self._authInfo) {
+                    _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                }
+                self._api.post({
+                    path: path,
+                    headers: headers
+                }, function _afterCall(err, req, res_) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    uploadUrl = res_.headers.location;
+                    if (!uploadUrl) {
+                        next(new errors.UploadError(
+                            'No registry upload location header returned'));
+                        return;
+                    }
+                    next();
+                });
+            },
+            function _putBlob(_, next) {
+                assert.string(uploadUrl, 'uploadUrl');
+                log.trace({digest: opts.digest}, 'blobUpload:: _putBlob');
+                var urlSep = '?';
+                if (uploadUrl.indexOf('?') > 0) {
+                    urlSep = '&';
+                }
+                var path = fmt('%s%sdigest=%s', uploadUrl, urlSep,
+                    encodeURIComponent(opts.digest));
+                var headers = {
+                    'content-length': opts.contentLength,
+                    'content-type': (opts.contentType ||
+                        'application/octet-stream')
+                };
+                _setAuthHeaderFromAuthInfo(headers, self._authInfo);
+                self._httpapi.put({
+                    path: path,
+                    headers: headers
+                }, function _afterCall(err, req) {
+                    log.trace({digest: opts.digest, err: err},
+                        'blobUpload:: put finished');
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    // Pipe through the stream data.
+                    var stream = opts.stream;
+
+                    function removeListeners() {
+                        stream.removeListener('error', onStreamPipeError);
+                        req.removeListener('result', onReqResult);
+                        req.removeListener('error', onReqError);
+                    }
+
+                    req.on('result', onReqResult);
+                    function onReqResult(reqErr, res_) {
+                        log.trace({digest: opts.digest},
+                            'blobUpload:: onResult');
+                        if (reqErr) {
+                            next(reqErr);
+                            return;
+                        }
+                        res_.body = '';
+                        res_.on('data', function onResChunk(chunk) {
+                            res_.body += chunk;
+                        });
+                        res_.on('end', function onResEnd() {
+                            removeListeners();
+                            // Parse and handle errors in the response body.
+                            var regErr = _getRegistryResponseErr(res_,
+                                errors.UploadError);
+                            if (regErr) {
+                                next(regErr);
+                                return;
+                            }
+                            res = res_;
+                            next();
+                        });
+                    }
+
+                    req.on('error', onReqError);
+                    function onReqError(reqErr) {
+                        log.error({
+                            digest: opts.digest,
+                            err: reqErr
+                        }, 'Error sending blob');
+                        removeListeners();
+                        return next(reqErr);
+                    }
+
+                    stream.on('error', onStreamPipeError);
+                    function onStreamPipeError(streamErr) {
+                        log.error({
+                            digest: opts.digest,
+                            err: streamErr
+                        }, 'Error piping blob');
+                        removeListeners();
+                        req.end();
+                        return next(streamErr);
+                    }
+
+                    stream.pipe(req);
+                    log.trace({digest: opts.digest},
+                        'blobUpload:: piping stream to req');
+                });
+            }
+        ]
+    }, function _blobUploadCb(err) {
+        cb(err, res);
+    });
+};
+
+
+
 // --- Exports
 
 function createClient(opts) {
diff --git a/package.json b/package.json
index 761230c..8b04fef 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "docker-registry-client",
-    "version": "3.2.6",
+    "version": "3.3.0",
     "description": "node.js client for the Docker Registry API",
     "author": "Joyent (joyent.com)",
     "main": "./lib/index.js",
diff --git a/test/v2.amazonecr.test.js b/test/v2.amazonecr.test.js
index 87da276..78a3d9f 100644
--- a/test/v2.amazonecr.test.js
+++ b/test/v2.amazonecr.test.js
@@ -48,6 +48,7 @@ test('v2 amazonecr', function (tt) {
     tt.test('  createClient', function (t) {
         noauthClient = drc.createClientV2({
             name: CONFIG.repo,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(noauthClient);
@@ -84,7 +85,7 @@ test('v2 amazonecr', function (tt) {
         noauthClient.listTags(function (err) {
             t.ok(err);
             t.equal(err.statusCode, 401, 'Expect a 401 status code');
-            t.equal(String(err.message).trim(), 'Not Authorizied');
+            t.equal(String(err.message).trim(), 'Not Authorized');
             t.end();
         });
     });
@@ -97,6 +98,7 @@ test('v2 amazonecr', function (tt) {
             name: CONFIG.repo,
             username: CONFIG.username,
             password: CONFIG.password,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(client);
@@ -136,12 +138,16 @@ test('v2 amazonecr', function (tt) {
      *      "signature": <JWS>
      *  }
      */
+    var blobDigest;
     var manifest;
     var manifestDigest;
+    var manifestStr;
     tt.test('  getManifest', function (t) {
-        client.getManifest({ref: CONFIG.tag}, function (err, manifest_, res) {
+        client.getManifest({ref: CONFIG.tag},
+                function (err, manifest_, res, manifestStr_) {
             t.ifErr(err);
             manifest = manifest_;
+            manifestStr = manifestStr_;
             // Note that Amazon ECR does not return a docker-content-digest
             // header.
             manifestDigest = res.headers['docker-content-digest'];
@@ -154,6 +160,7 @@ test('v2 amazonecr', function (tt) {
             t.ok(manifest.fsLayers);
             t.ok(manifest.history[0].v1Compatibility);
             t.ok(manifest.signatures[0].signature);
+            blobDigest = manifest.fsLayers[0].blobSum;
             t.end();
         });
     });
@@ -194,14 +201,10 @@ test('v2 amazonecr', function (tt) {
             var last = ress[ress.length - 1];
             t.ok(last);
             t.equal(last.statusCode, 200);
-
-            // Content-Type:
-            // - docker.io gives 'application/octet-stream', but amazon isn't so
-            //   nice for a HEAD request, it just returns text/plain.
             t.equal(last.headers['content-type'],
-                'text/plain; charset=utf-8');
-
+                'application/vnd.docker.container.image.v1+json');
             t.ok(last.headers['content-length']);
+
             t.end();
         });
     });
@@ -257,8 +260,7 @@ test('v2 amazonecr', function (tt) {
 
             t.ok(stream);
             t.equal(stream.statusCode, 200);
-            t.equal(stream.headers['content-type'],
-                'application/octet-stream');
+            t.equal(stream.headers['content-type'], 'application/x-gzip');
             t.ok(stream.headers['content-length']);
 
             var numBytes = 0;
@@ -300,6 +302,41 @@ test('v2 amazonecr', function (tt) {
         });
     });
 
+    tt.test('  blobUpload', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err, 'createBlobReadStream err');
+
+            var last = ress[ress.length - 1];
+            var uploadOpts = {
+                contentLength: parseInt(last.headers['content-length'], 10),
+                digest: blobDigest,
+                stream: stream
+            };
+            client.blobUpload(uploadOpts, function _uploadCb(uploadErr, res) {
+                t.ifErr(uploadErr, 'check blobUpload err');
+                t.equal(res.headers['docker-content-digest'], blobDigest,
+                    'Response header digest should match blob digest');
+                t.end();
+            });
+        });
+    });
+
+    tt.test('  putManifest', function (t) {
+        var uploadOpts = {
+            contentLength: manifestStr.length,
+            manifest: manifestStr,
+            ref: 'test_put_manifest'
+        };
+        client.putManifest(uploadOpts, function _uploadCb(uploadErr, res) {
+            t.ifErr(uploadErr, 'check blobUpload err');
+            //t.equal(res.headers['docker-content-digest'], manifestDigest,
+            //    'Response header digest should match manifest digest');
+            console.log('res.headers: ', res.headers);
+            t.end();
+        });
+    });
+
     tt.test('  close', function (t) {
         client.close();
         t.end();
diff --git a/test/v2.dockerioprivate.test.js b/test/v2.dockerioprivate.test.js
index 5ef090d..4442148 100644
--- a/test/v2.dockerioprivate.test.js
+++ b/test/v2.dockerioprivate.test.js
@@ -65,6 +65,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             name: CONFIG.repo,
             username: CONFIG.username,
             password: CONFIG.password,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(client);
@@ -111,6 +112,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     tt.test('  noAuthClient: setup', function (t) {
         noAuthClient = drc.createClientV2({
             name: CONFIG.repo,
+            maxSchemaVersion: 2,
             log: log
         });
         t.ok(noAuthClient);
@@ -143,33 +145,41 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
 
     /*
      *  {
-     *      "name": <name>,
-     *      "tag": <tag>,
-     *      "fsLayers": [
-     *         {
-     *            "blobSum": <tarsum>
-     *         },
-     *         ...
-     *      ],
-     *      "history": <v1 images>,
-     *      "signature": <JWS>
+     *      "schemaVersion": 2,
+     *      "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+     *      "config": {
+     *          "mediaType": "application/vnd.docker.container.image.v1+json",
+     *          "size": 1584,
+     *          "digest": "sha256:99e59f495ffaa2...545ab2bbe3b1b1ec3bd0b2"
+     *      },
+     *      "layers": [
+     *          {
+     *              "mediaType": "application/vnd.docker...diff.tar.gzip",
+     *              "size": 32,
+     *              "digest": "sha256:a3ed95caeb02ff...d00e8a7c22955b46d4"
+     *          }
+     *      ]
      *  }
      */
+    var blobDigest;
     var manifest;
     var manifestDigest;
+    var manifestStr;
     tt.test('  getManifest', function (t) {
-        client.getManifest({ref: CONFIG.tag}, function (err, manifest_, res) {
+        client.getManifest({ref: CONFIG.tag},
+                function (err, manifest_, res, manifestStr_) {
             t.ifErr(err);
             manifest = manifest_;
             manifestDigest = res.headers['docker-content-digest'];
+            manifestStr = manifestStr_;
             t.ok(manifest);
-            t.equal(manifest.schemaVersion, 1);
-            t.equal(manifest.name, repo.remoteName);
-            t.equal(manifest.tag, CONFIG.tag);
-            t.ok(manifest.architecture);
-            t.ok(manifest.fsLayers);
-            t.ok(manifest.history[0].v1Compatibility);
-            t.ok(manifest.signatures[0].signature);
+            t.equal(manifest.schemaVersion, 2);
+            t.ok(manifest.config);
+            t.ok(manifest.config.digest);
+            t.ok(manifest.layers);
+            t.ok(manifest.layers[0]);
+            t.ok(manifest.layers[0].digest);
+            blobDigest = manifest.layers[0].digest;
             t.end();
         });
     });
@@ -178,11 +188,11 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
         client.getManifest({ref: manifestDigest}, function (err, manifest_) {
             t.ifErr(err);
             t.ok(manifest);
-            ['schemaVersion',
-             'name',
-             'tag',
-             'architecture'].forEach(function (k) {
-                t.equal(manifest_[k], manifest[k], k);
+            ['config',
+             'layers',
+             'mediaType',
+             'schemaVersion'].forEach(function (k) {
+                t.deepEqual(manifest_[k], manifest[k], k);
             });
             t.end();
         });
@@ -198,8 +208,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     });
 
     tt.test('  headBlob', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
-        client.headBlob({digest: digest}, function (err, ress) {
+        client.headBlob({digest: blobDigest}, function (err, ress) {
             t.ifErr(err, 'no headBlob err');
             t.ok(ress, 'got a "ress"');
             t.ok(Array.isArray(ress), '"ress" is an array');
@@ -207,7 +216,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             t.ok(first.statusCode === 200 || first.statusCode === 307,
                 'first response statusCode is 200 or 307');
             if (first.headers['docker-content-digest']) {
-                t.equal(first.headers['docker-content-digest'], digest,
+                t.equal(first.headers['docker-content-digest'], blobDigest,
                     '"docker-content-digest" header from first response is '
                     + 'the queried digest');
             }
@@ -240,8 +249,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
     });
 
     tt.test('  createBlobReadStream', function (t) {
-        var digest = manifest.fsLayers[0].blobSum;
-        client.createBlobReadStream({digest: digest},
+        client.createBlobReadStream({digest: blobDigest},
                 function (err, stream, ress) {
             t.ifErr(err, 'createBlobReadStream err');
 
@@ -251,7 +259,7 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
             t.ok(first.statusCode === 200 || first.statusCode === 307,
                 'createBlobReadStream first res statusCode is 200 or 307');
             if (first.headers['docker-content-digest']) {
-                t.equal(first.headers['docker-content-digest'], digest,
+                t.equal(first.headers['docker-content-digest'], blobDigest,
                     '"docker-content-digest" header from first response is '
                     + 'the queried digest');
             }
@@ -267,13 +275,13 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
 
 
             var numBytes = 0;
-            var hash = crypto.createHash(digest.split(':')[0]);
+            var hash = crypto.createHash(blobDigest.split(':')[0]);
             stream.on('data', function (chunk) {
                 hash.update(chunk);
                 numBytes += chunk.length;
             });
             stream.on('end', function () {
-                t.equal(hash.digest('hex'), digest.split(':')[1]);
+                t.equal(hash.digest('hex'), blobDigest.split(':')[1]);
                 t.equal(numBytes, Number(stream.headers['content-length']));
                 t.end();
             });
@@ -296,6 +304,40 @@ test('v2 docker.io private repo (' + CONFIG.repo + ')', function (tt) {
         });
     });
 
+    tt.test('  blobUpload', function (t) {
+        client.createBlobReadStream({digest: blobDigest},
+                function (err, stream, ress) {
+            t.ifErr(err, 'createBlobReadStream err');
+
+            var last = ress[ress.length - 1];
+            var uploadOpts = {
+                contentLength: parseInt(last.headers['content-length'], 10),
+                digest: blobDigest,
+                stream: stream
+            };
+            client.blobUpload(uploadOpts, function _uploadCb(uploadErr, res) {
+                t.ifErr(uploadErr, 'check blobUpload err');
+                t.equal(res.headers['docker-content-digest'], blobDigest,
+                    'Response header digest should match blob digest');
+                t.end();
+            });
+        });
+    });
+
+    tt.test('  putManifest', function (t) {
+        var uploadOpts = {
+            contentLength: manifestStr.length,
+            manifest: manifestStr,
+            ref: 'test_put_manifest'
+        };
+        client.putManifest(uploadOpts, function _uploadCb(uploadErr, res) {
+            t.ifErr(uploadErr, 'check blobUpload err');
+            t.equal(res.headers['docker-content-digest'], manifestDigest,
+                'Response header digest should match manifest digest');
+            t.end();
+        });
+    });
+
     tt.test('  close', function (t) {
         client.close();
         t.end();
-- 
2.21.0

