commit 41d5de555a5b417c11c9dd43cb189da1f576ee3c (refs/changes/46/3946/1)
Author: John Levon <john.levon@joyent.com>
Date:   2018-05-14T10:47:45+00:00 (1 year, 5 months ago)
    
    m

diff --git a/lib/vasync.js b/lib/vasync.js
index 1b7b564..e5419d4 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -23,6 +23,7 @@ exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
 exports.waterfall = waterfall;
+exports.race = race;
 
 if (!global.setImmediate) {
 	global.setImmediate = function (func) {
@@ -762,7 +763,7 @@ function waterfall_impl(opts)
 
 	rv = {
 	    'operations': funcs.map(function (func) {
-	        return ({
+		return ({
 		    'func': func,
 		    'funcname': func.name || '(anon)',
 		    'status': 'waiting'
@@ -889,3 +890,76 @@ function waterfall_impl(opts)
 	}
 	return (rv);
 }
+
+/*
+ * Given a set of functions that complete asynchronously using the standard
+ * callback(err, result) pattern, invoke them all, but only invoke the callback
+ * for the first function to complete. The other callback invocations, if any,
+ * are ignored.  See README.md for details.
+ */
+function race(funcs, callback)
+{
+	var funcs, rv, doneOne, i;
+
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+
+	rv = {
+	    'operations': new Array(funcs.length),
+	    'successes': [],
+	    'ndone': 0,
+	    'nerrors': 0
+	};
+
+	if (funcs.length === 0) {
+		if (callback)
+			setImmediate(function () { callback(null, rv); });
+		return (rv);
+	}
+
+	function once (fn) {
+		var f = function () {
+			if (f.called)
+				return;
+			f.called = true;
+			fn.apply(this, arguments);
+		}
+		f.called = false;
+		return (f);
+	}
+
+	callback = once(callback);
+
+	doneOne = function (entry) {
+		return (function (err, result) {
+			mod_assert.equal(entry['status'], 'pending');
+
+			entry['err'] = err;
+			entry['result'] = result;
+			entry['status'] = err ? 'fail' : 'ok';
+
+			if (err)
+				rv['nerrors']++;
+			else
+				rv['successes'].push(result);
+
+			rv['ndone']++;
+
+			callback.apply(null, arguments);
+		});
+	};
+
+	for (i = 0; i < funcs.length; i++) {
+		rv['operations'][i] = {
+			'func': funcs[i],
+			'funcname': funcs[i].name || '(anon)',
+			'status': 'pending'
+		};
+
+		funcs[i](doneOne(rv['operations'][i]));
+	}
+
+	return (rv);
+}
diff --git a/tests/compat.js b/tests/compat.js
index 8461a82..ad7ace9 100644
--- a/tests/compat.js
+++ b/tests/compat.js
@@ -102,3 +102,5 @@ exports['waterfall error'] = function(test){
     });
     setTimeout(test.done, 50);
 };
+
+// FIXME
diff --git a/tests/race.js b/tests/race.js
new file mode 100644
index 0000000..040d3e0
--- /dev/null
+++ b/tests/race.js
@@ -0,0 +1,146 @@
+/*
+ * Tests the "waterfall" primitive.
+ */
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+var count = 0;
+var st;
+
+mod_tap.test('badargs', function (test) {
+	test.throws(function () { mod_vasync.race(); });
+	test.throws(function () { mod_vasync.race({}); });
+	test.throws(function () { mod_vasync.race([], 'foo'); });
+	test.throws(function () { mod_vasync.race('foo', 'bar'); });
+	test.end();
+});
+
+mod_tap.test('empty race, no callback', function (test) {
+	st = mod_vasync.race([]);
+	setTimeout(function () { test.end(); }, 100);
+});
+
+mod_tap.test('empty race', function (test) {
+	st = mod_vasync.race([], function (err) {
+		test.ok(err === null);
+		test.ok(st.ndone === 0);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 0);
+		test.ok(st.successes.length === 0);
+		test.equal(count, 1);
+		test.end();
+	});
+	count++;
+	test.ok(st.ndone === 0);
+	test.ok(st.nerrors === 0);
+	test.ok(st.operations.length === 0);
+	test.ok(st.successes.length === 0);
+});
+
+mod_tap.test('single func race', function (test) {
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, null, 1, 2);
+		},
+	], function callback(err, one, two) {
+		test.ok(count == 1, 'callback: count == 1');
+		test.ok(err === null, 'no error');
+		test.ok(one === 1);
+		test.ok(two === 2);
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 1);
+		test.ok(st.successes.length === 1);
+		test.ok(st.operations[0].status == 'ok');
+		setTimeout(function () { test.end() }, 10);
+	});
+});
+
+mod_tap.test('single func error', function (test) {
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, 'failed');
+		},
+	], function callback(err, res) {
+		test.ok(count == 1, 'callback: count == 1');
+		test.ok(err !== null, 'error seen');
+		test.ok(res === undefined, 'undefined result');
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 1);
+		test.ok(st.operations.length === 1);
+		test.ok(st.successes.length === 0);
+		test.ok(st.operations[0].status == 'fail');
+		setTimeout(function () { test.end() }, 10);
+	});
+});
+
+mod_tap.test('race with error', function (test) {
+	var called = 0;
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, 'failed');
+		},
+		function func2(cb) {
+			count++;
+			setTimeout(cb, 100, null, 1, 2);
+		},
+	], function callback(err, res) {
+		test.ok(count == 2, 'callback: count == 2');
+		test.ok(called === 0, 'callback: called == 0');
+		test.ok(err !== null, 'error seen');
+		test.ok(res === undefined, 'undefined result');
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 1);
+		test.ok(st.operations.length === 2);
+		test.ok(st.successes.length === 0);
+		test.ok(st.operations[0].status == 'fail');
+		test.ok(st.operations[1].status == 'pending');
+		called++;
+		setTimeout(function () { test.end() }, 110);
+	});
+});
+
+mod_tap.test('normal race', function (test) {
+	var called = 0;
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, null, 1, 2);
+		},
+		function func2(cb) {
+			count++;
+			setTimeout(cb, 100, null, 3, 4);
+		},
+		function func3(cb) {
+			count++;
+			setTimeout(cb, 101, null, 5);
+		}
+	], function callback(err, one, two) {
+                console.log('here ' + called);
+		test.ok(count == 3, 'callback: count == 3');
+		test.ok(called === 0, 'callback: called == 0');
+		test.ok(err === null, 'no error');
+		test.ok(one === 1);
+		test.ok(two === 2);
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 3);
+		test.ok(st.successes.length === 1);
+		test.ok(st.operations[0].status == 'ok');
+		test.ok(st.operations[1].status == 'pending');
+		called++;
+		setTimeout(function () { test.end() }, 110);
+	});
+});
