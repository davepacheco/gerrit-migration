From a3a1f8a0a6d8f991a910364e2999f55ce12a508c Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Wed, 1 May 2019 09:02:29 -0700
Subject: [PATCH] TRITON-1050 Add a guards to CNAPI servers and VMAPI VMs to
 prevent or allow migrations

---
 lib/vm-migration/migrate.js   |   8 +++
 package.json                  |   2 +-
 sapi_manifests/vmapi/template |   6 ++
 test/lib/migration.js         | 118 ++++++++++++++++++++++++++++++++++
 4 files changed, 133 insertions(+), 1 deletion(-)

diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
index db92d27..aa27045 100644
--- a/lib/vm-migration/migrate.js
+++ b/lib/vm-migration/migrate.js
@@ -45,6 +45,14 @@ function validateMigrationBegin(vm, ctx, callback) {
     assert.object(ctx, 'ctx');
     assert.optionalObject(ctx.migrationRecord, 'ctx.migrationRecord');
     assert.func(callback, 'callback');
+    var vmAllowed = vm.internal_metadata.user_migration_allowed === true;
+
+    if (!vmAllowed) {
+        callback(new restify.errors.PreconditionFailedError(
+            'User migration on this VM not allowed ' + vm.uuid +
+            ' ' + vm.internal_metadata.user_migration_allowed));
+        return;
+    }
 
     // Check if there is an existing unfinished migration.
     if (ctx.migrationRecord) {
diff --git a/package.json b/package.json
index f74d152..c1c484d 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "vmapi",
   "description": "VMs API",
-  "version": "9.8.4",
+  "version": "9.8.5",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/sapi_manifests/vmapi/template b/sapi_manifests/vmapi/template
index 139ea48..2c7028e 100644
--- a/sapi_manifests/vmapi/template
+++ b/sapi_manifests/vmapi/template
@@ -27,6 +27,12 @@
         "enabled": false
 {{/fabric_cfg}}
     },
+{{#zfs_send_mbps_limit}}
+    "zfs_send_mbps_limit": 500,
+{{/zfs_send_mbps_limit}}
+{{#max_running_migrations_per_cn}}
+    "max_running_migrations_per_cn": 500,
+{{/max_running_migrations_per_cn}}
     "wfapi": {
         "forceMd5Check": true,
         "workflows": [
diff --git a/test/lib/migration.js b/test/lib/migration.js
index 9e59947..888d3ae 100644
--- a/test/lib/migration.js
+++ b/test/lib/migration.js
@@ -222,6 +222,103 @@ function TestMigrationCfg(test, cfg) {
         });
     };
 
+    test.check_allow_migration_flag_unset = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, undefined);
+
+                t.done();
+            });
+    };
+
+    test.bad_migrate_not_allowed_by_vm_default = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed unset
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin',
+                sourceVm.uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag not set)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.set_vm_explicitly_disallow_migrations = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: false }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.check_allow_migration_flag_false = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, false);
+
+                t.done();
+            });
+    };
+
+    test.bad_migrate_explicitly_not_allowed_by_vm = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed = false
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin',
+                sourceVm.uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag false)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.set_vm_explicitly_allow_migrations = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: true }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.check_allow_migration_flag_true = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, true,
+                    'user_migration_allowed should be set');
+
+                t.done();
+            });
+    };
+
     test.bad_migrate_unknown_action = function (t) {
         // Unknown migration action.
         client.post({
@@ -1432,6 +1529,27 @@ function TestMigrationCfg(test, cfg) {
     };
 }
 
+function updateVmAndWait(t, client, vmUuid, payload, cb) {
+    var postOpts = {
+        path: format('/vms/%s?action=update', vmUuid)
+    };
+
+    client.post(postOpts, payload, function onUpdate(err, req, res, body) {
+        t.ifError(err, 'metadata should be set successfully');
+
+        t.ok(body.job_uuid, 'got a job uuid in the begin response');
+        var waitParams = {
+            client: client,
+            job_uuid: body.job_uuid,
+            timeout: 15 * 60
+        };
+        waitForJob(waitParams, function onUpdateJobCb(jerr, state, job) {
+            t.ifError(jerr, 'update job should be successful');
+            t.done();
+        });
+    });
+}
+
 
 module.exports = {
     TestMigrationCfg: TestMigrationCfg
-- 
2.21.0

