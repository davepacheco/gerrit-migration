commit 22b76368c885c936e0008533192c933509448d44
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2019-05-01T08:58:25-07:00 (5 months ago)
    
    TRITON-1050 Add a guards to CNAPI servers and VMAPI VMs to prevent or allow migrations

diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
index db92d27..aa27045 100644
--- a/lib/vm-migration/migrate.js
+++ b/lib/vm-migration/migrate.js
@@ -45,6 +45,14 @@ function validateMigrationBegin(vm, ctx, callback) {
     assert.object(ctx, 'ctx');
     assert.optionalObject(ctx.migrationRecord, 'ctx.migrationRecord');
     assert.func(callback, 'callback');
+    var vmAllowed = vm.internal_metadata.user_migration_allowed === true;
+
+    if (!vmAllowed) {
+        callback(new restify.errors.PreconditionFailedError(
+            'User migration on this VM not allowed ' + vm.uuid +
+            ' ' + vm.internal_metadata.user_migration_allowed));
+        return;
+    }
 
     // Check if there is an existing unfinished migration.
     if (ctx.migrationRecord) {
diff --git a/test/lib/migration.js b/test/lib/migration.js
index 9e59947..888d3ae 100644
--- a/test/lib/migration.js
+++ b/test/lib/migration.js
@@ -222,6 +222,103 @@ function TestMigrationCfg(test, cfg) {
         });
     };
 
+    test.check_allow_migration_flag_unset = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, undefined);
+
+                t.done();
+            });
+    };
+
+    test.bad_migrate_not_allowed_by_vm_default = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed unset
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin',
+                sourceVm.uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag not set)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.set_vm_explicitly_disallow_migrations = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: false }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.check_allow_migration_flag_false = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, false);
+
+                t.done();
+            });
+    };
+
+    test.bad_migrate_explicitly_not_allowed_by_vm = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed = false
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin',
+                sourceVm.uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag false)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.set_vm_explicitly_allow_migrations = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: true }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.check_allow_migration_flag_true = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, true,
+                    'user_migration_allowed should be set');
+
+                t.done();
+            });
+    };
+
     test.bad_migrate_unknown_action = function (t) {
         // Unknown migration action.
         client.post({
@@ -1432,6 +1529,27 @@ function TestMigrationCfg(test, cfg) {
     };
 }
 
+function updateVmAndWait(t, client, vmUuid, payload, cb) {
+    var postOpts = {
+        path: format('/vms/%s?action=update', vmUuid)
+    };
+
+    client.post(postOpts, payload, function onUpdate(err, req, res, body) {
+        t.ifError(err, 'metadata should be set successfully');
+
+        t.ok(body.job_uuid, 'got a job uuid in the begin response');
+        var waitParams = {
+            client: client,
+            job_uuid: body.job_uuid,
+            timeout: 15 * 60
+        };
+        waitForJob(waitParams, function onUpdateJobCb(jerr, state, job) {
+            t.ifError(jerr, 'update job should be successful');
+            t.done();
+        });
+    });
+}
+
 
 module.exports = {
     TestMigrationCfg: TestMigrationCfg
