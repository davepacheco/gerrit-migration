From 2e2d7fefa57bc9a4678519075e0c9a58172d98af Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Wed, 15 May 2019 01:22:53 -0700
Subject: [PATCH] TRITON-1050 Add a guards to CNAPI servers and VMAPI VMs to
 prevent or allow migrations

---
 lib/vm-migration/migrate.js |  19 ++++++
 package.json                |   2 +-
 test/lib/migration.js       | 122 ++++++++++++++++++++++++++++++++++++
 3 files changed, 142 insertions(+), 1 deletion(-)

diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
index f1209de..0f50e11 100644
--- a/lib/vm-migration/migrate.js
+++ b/lib/vm-migration/migrate.js
@@ -45,6 +45,21 @@ function validateMigrationBegin(vm, ctx, callback) {
     assert.object(ctx, 'ctx');
     assert.optionalObject(ctx.migrationRecord, 'ctx.migrationRecord');
     assert.func(callback, 'callback');
+    assert.optionalUuid(ctx.ownerUuid, 'ctx.ownerUuid');
+
+    var vmAllowed = false;
+
+    if (!ctx.ownerUuid) {
+        vmAllowed = true;
+    } else {
+        vmAllowed = vm.internal_metadata.user_migration_allowed === true;
+    }
+
+    if (!vmAllowed) {
+        callback(new restify.errors.PreconditionFailedError(
+            'User migration on this VM not allowed'));
+        return;
+    }
 
     // Check if there is an existing unfinished migration.
     if (ctx.migrationRecord) {
@@ -282,6 +297,10 @@ function migrateVm(req, res, next) {
         },
 
         function validate(ctx, cb) {
+            if (req.params.owner_uuid) {
+                ctx.ownerUuid = req.params.owner_uuid;
+            }
+
             if (action === 'begin' || action === 'estimate') {
                 validateMigrationBegin(vm, ctx, cb);
                 return;
diff --git a/package.json b/package.json
index b6fde8d..90e7416 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "vmapi",
   "description": "VMs API",
-  "version": "9.8.6",
+  "version": "9.8.7",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/test/lib/migration.js b/test/lib/migration.js
index 9b766c7..aca0b05 100644
--- a/test/lib/migration.js
+++ b/test/lib/migration.js
@@ -224,6 +224,105 @@ function TestMigrationCfg(test, cfg) {
         });
     };
 
+    test.bad_user_check_allow_migration_flag_unset = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, undefined);
+
+                t.done();
+            });
+    };
+
+    test.bad_user_migrate_not_allowed_by_vm_default = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed unset
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin'
+                + '&owner_uuid=' + cfg.vm.owner_uuid,
+                sourceVm.uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag not set)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.bad_user_set_vm_explicitly_disallow_migrations = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: false }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.bad_user_check_allow_migration_flag_false = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed, false);
+
+                t.done();
+            });
+    };
+
+    test.bad_user_migrate_explicitly_not_allowed_by_vm = function (t) {
+        // Should not be able to migrate a zone with
+        // user_migration_allowed = false
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin'
+                + '&owner_uuid=%s', sourceVm.uuid, cfg.vm.owner_uuid)
+        }, function onMigrateVm(err) {
+            t.ok(err,
+                'expect error attempting migration of a zone ' +
+                '(server user_migration_allowed flag false)');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s',
+                        err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.bad_user_set_vm_reset_internal_metadata = function (t) {
+        var payload = {
+            internal_metadata: { user_migration_allowed: true }
+        };
+        updateVmAndWait(t, client, sourceVm.uuid, payload,
+            function onUpdateVm(err) {
+                t.ifError(err);
+                t.done();
+            });
+    };
+
+    test.bad_user_check_allow_migration_flag_undefined = function (t) {
+        client.get('/vms/' + sourceVm.uuid,
+            function onListVms(err, req, res, vm) {
+                t.ifError(err);
+                t.ok(vm, 'getting vm should result in a non-empty response');
+
+                t.equal(vm.internal_metadata.user_migration_allowed,
+                    true);
+
+                t.done();
+            });
+    };
+
+
     test.bad_migrate_unknown_action = function (t) {
         // Unknown migration action.
         client.post({
@@ -1472,6 +1571,29 @@ function TestMigrationCfg(test, cfg) {
     };
 }
 
+function updateVmAndWait(t, client, vmUuid, payload, cb) {
+    var postOpts = {
+        path: format('/vms/%s?action=update', vmUuid)
+    };
+
+    client.post(postOpts, payload, function onUpdate(err, req, res, body) {
+        t.ifError(err, 'metadata should be set successfully');
+
+        console.dir(body.job_uuid);
+        t.ok(body.job_uuid, 'got a job uuid in the begin response');
+        var waitParams = {
+            client: client,
+            job_uuid: body.job_uuid,
+            timeout: 15 * 60
+        };
+
+        waitForJob(waitParams, function onUpdateJobCb(jerr, state, job) {
+            t.ifError(jerr, 'update job should be successful');
+            t.done();
+        });
+    });
+}
+
 
 module.exports = {
     TestMigrationCfg: TestMigrationCfg
-- 
2.21.0

