From 6576330a06cad1442c5c0318c711ae721df07d73 Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Tue, 12 Mar 2019 16:54:33 +0100
Subject: [PATCH] TRITON-9 affinity is racy

---
 docs/index.md              |   4 +-
 lib/machines.js            |  23 +-
 lib/triton-affinity.js     | 885 +------------------------------------
 package.json               |   4 +-
 test/affinity-unit.test.js | 387 +++++-----------
 test/machines/affinity.js  | 156 ++++++-
 6 files changed, 278 insertions(+), 1181 deletions(-)

diff --git a/docs/index.md b/docs/index.md
index 8ff3c63..1bb3bdf 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -844,6 +844,8 @@ The section describes API changes in CloudAPI versions.
 ## 9.5.0
 - Remove Cloud Analytics endpoints. Cloud Analytics has been removed from
   Triton. See [TRITON-884](https://smartos.org/bugview/TRITON-884) for details.
+- [CreateMachine](#CreateMachine)'s `affinity` rules now work with concurrent
+  provisions.
 
 ## 9.4.3
 - [ListPackages](#ListPackages) and [GetPackage](#GetPackage) include the
@@ -955,8 +957,6 @@ The section describes API changes in CloudAPI versions.
   Affinity rules (inspired by Docker Swarm affinity filters) allow a more
   powerful mechanism for controlling server placement of instances.
   This deprecates the `locality` field for "locality hints" on CreateMachine.
-  Limitation: Affinity rules currently do not properly consider *concurrent*
-  provisions (see [TRITON-9](https://smartos.org/bugview/TRITON-9)).
 
   This CloudAPI feature is comparable to [Triton's Docker placement affinity
   rules](https://apidocs.joyent.com/docker/features/placement).
diff --git a/lib/machines.js b/lib/machines.js
index 230e23d..24fa1e8 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -1573,25 +1573,26 @@ function create(req, res, next) {
      * planned that DAPI will support affinity rules natively, and we'll only
      * need to validate the affinity rules here.
      */
-    pipeline.push(function getLocalityFromAffinity(_, cb) {
+    pipeline.push(function getAffinityFromParam(_, cb) {
         if (!opts.affinity) {
             cb();
             return;
         }
 
-        triton_affinity.localityFromAffinity({
+        var strAffinity = opts.affinity;
+
+        triton_affinity.parseAffinity({
             log: req.log,
-            vmapi: req.sdc.vmapi,
-            ownerUuid: customer,
-            affinity: opts.affinity
-        }, function (affErr, locality, debugInfo) {
+            affinity: strAffinity
+        }, function parseAffinityCb(affErr, affinity) {
             if (affErr) {
                 cb(new errors.InvalidArgumentError(affErr, affErr.message));
-            } else if (locality) {
-                req.log.info({affinity: opts.affinity, locality: locality,
-                    rulesInfo: debugInfo.rulesInfo}, 'localityFromAffinity');
-                opts.locality = locality;
-                delete opts.affinity;
+            } else if (affinity) {
+                req.log.info({
+                    strAffinity: strAffinity,
+                    parsedAffinity: affinity
+                }, 'parseAffinity');
+                opts.affinity = affinity;
                 cb();
             } else {
                 cb();
diff --git a/lib/triton-affinity.js b/lib/triton-affinity.js
index 7ee9036..35ff507 100644
--- a/lib/triton-affinity.js
+++ b/lib/triton-affinity.js
@@ -5,13 +5,16 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /* BEGIN JSSTYLED */
 /*
  * Triton's *affinity rules* support (i.e. the rules/hints for deciding to what
- * server a new instance is provisioned).
+ * server a new instance is provisioned). We parse the affinity strings that
+ * Cloudapi and Docker understand and convert them into the affinity
+ * representation that DAPI uses, which is passed to vmapi's CreateMachine
+ * endpoint.
  *
  * A source motivation of Triton affinity rules was the affinity features that
  * Docker Swarm provides with its "affinity" container filters, described here:
@@ -42,27 +45,11 @@
  *   in the DC. Until a possible future when Triton acts as a Swarm master
  *   for multiple DCs, the semantics of this affinity don't apply.
  *
- * # Affinities -> Locality Hints
- *
- * Triton's current feature for a VM creation providing affinity is "locality
- * hints". As a first pass we'll be translating given affinity expressions
- * (in Docker, via both the '-e' envvar syntax and the newer '--label' syntax;
- * and in CloudAPI, via the 'affinity' param to CreateMachine) to Triton's
- * "locality hints". See here for the locality hints big-theory comment and
- * implementation:
- *      https://github.com/joyent/sdc-designation/blob/master/lib/algorithms/soft-filter-locality-hints.js
- *
  * # Limitations
  *
- * - DOCKER-1039 is a known issue: Hard affinity rules using instance names or
- *   tags for *concurrent provisions* will race. The correct fix for that (to
- *   handle the translation from instance name/tags to UUIDs in DAPI's
- *   server selection -- which is serialized in the DC) will fix the issue for
- *   both sdc-docker and CloudAPI.
- *
  * - Affinity rules using the '==' operator and that match *multiple instances
- *   on separate CNs*: the translation to locality hints must select just
- *   *one* of those multiple instances.
+ *   on separate CNs*: sdc-designation must select just *one* of those multiple
+ *   instances.
  *
  *   E.g. 'instance==webhead*' when there are "webhead0" and "webhead1"
  *   instances on separate CNs. There is no way to provision an instance that
@@ -73,21 +60,17 @@
  *   The issue is that the translation doesn't know which one might be more
  *   appropriate -- e.g. webhead0's server might be out of space.
  *
- * - sdc-designation's locality hints cannot handle mixed strict and non-strict
+ * - sdc-designation's currently cannot handle mixed strict and non-strict
  *   rules. E.g.:
  *      docker run -e affinity:container==db0 -e 'affinity:container!=db1' ...
- *   To support that we'd need to extend the "locality" data structure format.
  *   Currently we just drop the non-strict rules when hitting this. An
  *   alternative would be to error out.
  */
 /* END JSSTYLED */
 
 var assert = require('assert-plus');
-var format = require('util').format;
-var strsplit = require('strsplit');
 var vasync = require('vasync');
 var VError = require('verror');
-var XRegExp = require('xregexp');
 
 
 // ---- globals
@@ -115,129 +98,6 @@ var EXPR_VALUE_RE = /^[-a-z0-9:_\s.*/()?+[\]\\^$|]+$/i;
 
 // ---- internal support stuff
 
-function setIntersection(a, b) {
-    var intersection = new Set();
-    a.forEach(function (elem) {
-        if (b.has(elem)) {
-            intersection.add(elem);
-        }
-    });
-    return intersection;
-}
-
-function setJoin(set, sep) {
-    var arr = [];
-    set.forEach(function (elem) {
-        arr.push(elem);
-    });
-    return arr.join(sep);
-}
-
-
-function setRandomChoice(set) {
-    var idx = Math.floor(Math.random() * set.size);
-    var choice;
-    set.forEach(function (elem) {
-        if (idx === 0) {
-            choice = elem;
-        }
-        idx--;
-    });
-    assert.ok(choice !== undefined);
-    return choice;
-}
-
-function _isUuid(str) {
-    var re = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-    if (str && str.length === 36 && str.match(re)) {
-        return true;
-    } else {
-        return false;
-    }
-}
-
-
-/*
- * This is a copy of `dockerIdToUuid` from sdc-docker.git:
- *  https://github.com/joyent/sdc-docker/blob/94fa554d/lib/common.js#L537-L547
- * to determine a Triton VM UUID from a Docker container ID.
- */
-function dockerIdToUuid(dockerId) {
-    var out;
-
-    out = dockerId.substr(0, 8) + '-'
-        + dockerId.substr(8, 4) + '-'
-        + dockerId.substr(12, 4) + '-'
-        + dockerId.substr(16, 4) + '-'
-        + dockerId.substr(20, 12);
-
-    return (out);
-}
-
-
-/**
- * Parse out affinity rules from a Docker container config.
- *
- * Compare to Swarm's processing for pulling from Env and Labels,
- * storing `Labels['com.docker.swarm.affinities']`:
- *    https://github.com/docker/swarm/blob/4ff0b10/cluster/config.go
- *
- * *Side-Effect*:
- * - This removes 'affinity:*' entries from `container.Env`.
- * - If affinity expressions are provided in `container.Env` then
- *   `container.Labels['com.docker.swarm.affinities']` is updated with them.
- *
- * @throws {VError} with name 'ValidationError' if a given affinity label or
- *      envvar is invalid.
- */
-function _affinityRulesFromDockerContainer(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.container, 'opts.container');
-    assert.optionalObject(opts.container.Labels, 'opts.container.Labels');
-    assert.optionalArrayOfString(opts.container.Env, 'opts.container.Env');
-
-    var exprs = [];
-
-    // Labels, e.g.: { 'com.docker.swarm.affinities': '["a==b"]' }
-    var labels = opts.container.Labels;
-    if (labels && labels['com.docker.swarm.affinities']) {
-        exprs = exprs.concat(_affinityExprsFromDockerLabel(
-            labels['com.docker.swarm.affinities']));
-    }
-
-    // Env, e.g.: [ 'affinity:foo==bar' ]
-    var env = opts.container.Env;
-    var envIdxToDel = [];
-    var i, kv, parts;
-    if (env) {
-        for (i = 0; i < env.length; i++) {
-            kv = env[i];
-            if (kv.slice(0, 9) === 'affinity:') {
-                parts = strsplit(kv, ':', 2);
-                exprs.push(parts[1]);
-                envIdxToDel.push(i);
-            }
-        }
-    }
-
-    // Parse the rules/expressions.
-    var rules = [];
-    for (i = 0; i < exprs.length; i++) {
-        rules.push(ruleFromExpr(exprs[i]));
-    }
-
-    // Side-effects.
-    if (envIdxToDel.length > 0) {
-        envIdxToDel.reverse().forEach(function (idx) {
-            opts.container.Env.splice(idx, 1);
-        });
-        labels['com.docker.swarm.affinities'] = JSON.stringify(exprs);
-    }
-
-    return rules;
-}
-
 
 /**
  * Parse an affinity rule expression.
@@ -258,8 +118,7 @@ function _affinityRulesFromDockerContainer(opts) {
  *          operator: <'==' or '!='>,
  *          value: '<the value string>',
  *          isSoft: <true or false>,
- *          valueType: <'exact', 'glob' or 're'>,
- *          valueRe: <RegExp for `value`>   // only defined if valueType==='re'
+ *          valueType: <'exact', 'glob' or 're'>
  *      }
  *
  * @throws {VError} with name 'ValidationError' if a given rule string
@@ -313,7 +172,6 @@ function ruleFromExpr(s) {
         rule.value[rule.value.length - 1] === '/')
     {
         rule.valueType = 're';
-        rule.valueRe = XRegExp(rule.value.slice(1, -1));
     } else if (rule.value.indexOf('*') !== -1) {
         rule.valueType = 'glob';
     } else {
@@ -323,753 +181,42 @@ function ruleFromExpr(s) {
     return rule;
 }
 
-function exprFromRule(rule) {
-    assert.object(rule, 'rule');
-    assert.string(rule.key, 'rule.key');
-    assert.string(rule.operator, 'rule.operator');
-    assert.bool(rule.isSoft, 'rule.isSoft');
-    assert.string(rule.value, 'rule.value');
-
-    return format('%s%s%s%s', rule.key, rule.operator, rule.isSoft ? '~' : '',
-        rule.value);
-}
-
-/**
- * Parse affinity expressions from a `docker run` "com.docker.swarm.affinities"
- * label.
- *
- * @throws {VError} with name 'ValidationError' if there is an error parsing.
- */
-function _affinityExprsFromDockerLabel(label) {
-    assert.string(label, 'label');
-
-    var exprs;
-    try {
-        exprs = JSON.parse(label);
-    } catch (parseErr) {
-        throw new VError({name: 'ValidationError'},
-            'invalid affinities label: %j: %s', label, parseErr);
-    }
-
-    if (!Array.isArray(exprs)) {
-        throw new VError({name: 'ValidationError'},
-            'affinities label is not an array: ' + label);
-    }
-
-    return exprs;
-}
-
-
-/*
- * Find the VM(s) matching the given affinity rule (parsed by ruleFromExpr).
- *
- * If `affinity.key` is one of "container" or "instance" (*), the affinity value
- * can be any of:
- * - instance uuid: use that directly
- * - docker id: if at least a 32-char prefix of a docker_id,
- *   then can construct instance UUID from that and use that
- *   directly
- * - short docker id: look up all docker containers by uuid
- * - name: lookup all (not just docker) instances by alias
- * - name glob: lookup all (not just docker) instances by alias
- *   IIUC, Swarm's impl. is just simple globbing: '*'-only
- * - name regex: lookup all (not just docker) containers by
- *   alias.
- *
- * (*) "container" is required for Docker compat. "instance" is the external
- *     language that Triton now attempts to use, despite the continued use
- *     of "machine" in cloudapi code (e.g. see node-triton). It is perhaps
- *     debatable that we'd want to accept "inst" (node-triton does) and
- *     "machine". I'm inclined to *not*. This is a case of less (fewer options)
- *     is more: less confusion, less namespace pollution for tag names.
- *
- * Otherwise `affinity.key` is a tag key:
- * Find any VMs matching that key/value. As above, the value can be an exact
- * value (stringified comparison), glob (simple '*'-only glob) or regex.
- *
- * Dev Note: Annoyingly Triton prefixes docker labels with "docker:label:" on
- * VM.tags. So we search both. Note that this can look obtuse or ambiguious
- * to the docker user if a container has both 'foo' and 'docker:label:foo'
- * VM tags.
- *
- * @param {Object} opts.rule - The parsed affinity rule object.
- * @param {Object} opts.log
- * @param {UUID} opts.ownerUuid
- * @param {Object} opts.vmapi
- * @param {Object} opts.cache: Used to cache data for repeated calls to this
- *      function, e.g., for a single `localityFromDockerContainer` call.
- * @param {Function} cb: `function (err, vms)`
- */
-function _vmsFromRule(opts, cb) {
-    assert.object(opts.rule, 'opts.rule');
-    assert.object(opts.log, 'opts.log');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.object(opts.cache, 'opts.cache');
-    assert.func(cb, 'cb');
-
-    var rule = opts.rule;
-    var i;
-    var keyIsInst = (rule.key === 'instance' || rule.key === 'container');
-    var log = opts.log;
-    var query;
-    var vm;
-    var vms;
-
-    var headers = {};
-    if (log.fields.req_id) {
-        headers['x-request-id'] = log.fields.req_id;
-    }
-
-    // A caching version of VMAPI 'ListVms?state=active&owner_uuid=$ownerUuid'.
-    function getAllActiveVms(vmsCb) {
-        if (opts.cache.allActiveVms) {
-            vmsCb(null, opts.cache.allActiveVms);
-            return;
-        }
-        opts.vmapi.listVms({
-            fields: 'uuid,alias,server_uuid,internal_metadata,docker',
-            owner_uuid: opts.ownerUuid,
-            state: 'active'
-        }, {
-            headers: headers
-        }, function onListAllVms(err, allActiveVms) {
-            if (err) {
-                vmsCb(err);
-            } else {
-                opts.cache.allActiveVms = allActiveVms;
-                vmsCb(null, allActiveVms);
-            }
-        });
-    }
-
-
-    // $tag=$value
-    // $tag=$glob
-    if (!keyIsInst && rule.valueType !== 're') {
-        query = {
-            fields: 'uuid,alias,server_uuid,tags',
-            owner_uuid: opts.ownerUuid,
-            state: 'active',
-            predicate: JSON.stringify({
-                or: [
-                    {eq: ['tag.' + rule.key,              rule.value]},
-                    {eq: ['tag.docker:label:' + rule.key, rule.value]}
-                ]
-            })
-        };
-        opts.vmapi.listVms(query, {
-            headers: headers
-        }, function onListVmsMatchingTags(err, vms_) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            log.trace({expr: exprFromRule(rule), vms: vms_}, '_vmsFromRule');
-            cb(null, vms_);
-        });
-
-    // $tag==/regex/
-    // Get a all '$key=*'-tagged VMs and post-filter with `valueRe`.
-    } else if (!keyIsInst && rule.valueType === 're') {
-        query = {
-            fields: 'uuid,alias,server_uuid,tags',
-            owner_uuid: opts.ownerUuid,
-            state: 'active',
-            predicate: JSON.stringify({
-                or: [
-                    {eq: ['tag.' + rule.key,              '*']},
-                    {eq: ['tag.docker:label:' + rule.key, '*']}
-                ]
-            })
-        };
-        opts.vmapi.listVms(query, {
-            headers: headers
-        }, function onListVmsForTagRegex(err, allVms) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            vms = [];
-            for (i = 0; i < allVms.length; i++) {
-                vm = allVms[i];
-
-                var tag = vm.tags[rule.key];
-                if (tag !== undefined && rule.valueRe.test(tag.toString())) {
-                    // Docker labels can only be strings. Triton VM tags can
-                    // also be booleans or numbers.
-                    vms.push(vm);
-                    continue;
-                }
-                var label = vm.tags['docker:label:' + rule.key];
-                if (label !== undefined && rule.valueRe.test(label)) {
-                    vms.push(vm);
-                    continue;
-                }
-            }
-            log.trace({expr: exprFromRule(rule), vms: vms}, '_vmsFromRule');
-            cb(null, vms);
-        });
-
-    // instance==UUID
-    } else if (_isUuid(rule.value)) {
-        assert.ok(keyIsInst, 'key is "container" or "instance": ' + rule.key);
-        opts.vmapi.getVm({
-            uuid: rule.value,
-            owner_uuid: opts.ownerUuid,
-            fields: 'uuid,alias,state,server_uuid'
-        }, {
-            headers: headers
-        }, function onGetVm(err, vm_) {
-            if (err) {
-                cb(err);
-            } else if (vm_ &&
-                ['destroyed', 'failed'].indexOf(vm_.state) === -1) {
-                cb(null, [vm_]);
-            } else {
-                cb(null, []);
-            }
-        });
-
-    // instance==<full 64-char docker id>
-    //
-    // Given a full 64-char docker id, Docker-docker will skip container
-    // *name* matching (at least that's what containers.js#findContainerIdMatch
-    // implies). We'll do the same here. Any other length means we need to
-    // consider name matching.
-    } else if (/^[a-f0-9]{64}$/.test(rule.value)) {
-        assert.ok(keyIsInst, 'key is "container" or "instance": ' + rule.key);
-        var vmUuid = dockerIdToUuid(rule.value);
-        opts.vmapi.getVm({
-            uuid: vmUuid,
-            owner_uuid: opts.ownerUuid,
-            fields: 'uuid,alias,state,server_uuid,internal_metadata,docker'
-        }, {
-            headers: headers
-        }, function onGetVmFromDockerId(err, vm_) {
-            if (err && err.statusCode !== 404) {
-                cb(err);
-            } else if (!err && vm_ && vm_.docker &&
-                ['destroyed', 'failed'].indexOf(vm_.state) === -1 &&
-                vm_.internal_metadata['docker:id'] === rule.value)
-            {
-                cb(null, [vm_]);
-            } else {
-                cb(null, []);
-            }
-        });
-
-    // instance=<name>
-    // instance=<short docker id>
-    // instance=<name glob> (simple '*'-globbing only)
-    // instance=<name regex>
-    //
-    // List all active VMs (non-docker too) and pass to "containers.js"
-    // filter function to select a match.
-    } else {
-        assert.ok(keyIsInst, 'key is "container" or "instance": ' + rule.key);
-
-        vms = [];
-        vasync.pipeline({funcs: [
-            /*
-             * First attempt an exact name (aka alias) match as a quick out,
-             * if possible.
-             */
-            function attemptNameMatch(_, next) {
-                if (rule.valueType !== 'exact' && rule.valueType !== 'glob') {
-                    next();
-                    return;
-                }
-                opts.vmapi.listVms({
-                    fields: 'uuid,alias,server_uuid',
-                    owner_uuid: opts.ownerUuid,
-                    state: 'active',
-                    predicate: JSON.stringify({
-                        eq: ['alias', rule.value] // this supports '*'-glob
-                    })
-                }, {
-                    headers: headers
-                }, function onListVmsMatchingAlias(err, vms_) {
-                    if (err) {
-                        next(err);
-                    } else {
-                        vms = vms_;
-                        next();
-                    }
-                });
-            },
-
-            function fullVmListSearch(_, next) {
-                if (vms.length) {
-                    // Already got results.
-                    next();
-                    return;
-                }
-
-                getAllActiveVms(function onGetAllActiveVms(err, allVms) {
-                    if (err) {
-                        next(err);
-                        return;
-                    }
-
-                    switch (rule.valueType) {
-                    case 're':
-                        // Regex is only on container name, not id.
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && rule.valueRe.test(vm.alias)) {
-                                vms.push(vm);
-                            }
-                        }
-                        next();
-                        break;
-                    case 'glob':
-                        // Glob is only on container name, not id.
-                        // Dev Note: Better would be to use minimatch.
-                        var valueRe = new RegExp(
-                            '^'
-                            + XRegExp.escape(rule.value)
-                                .replace('\\*', '.*')
-                                .replace('\\?', '.')
-                            + '$');
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && valueRe.test(vm.alias)) {
-                                vms.push(vm);
-                            }
-                        }
-                        next();
-                        break;
-                    case 'exact':
-                        /*
-                         * This is a exact name match (preferred) or id prefix.
-                         * If there are multiple id-prefix matches, we'll
-                         * raise an ambiguity error.
-                         */
-                        var exactErr;
-                        var idPrefixMatches = [];
-                        var nameMatch;
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && vm.alias === rule.value) {
-                                nameMatch = vm;
-                                break;
-                            }
-                            if (vm.docker &&
-                                vm.internal_metadata['docker:id'] &&
-                                vm.internal_metadata['docker:id'].indexOf(
-                                    rule.value) === 0)
-                            {
-                                idPrefixMatches.push(vm);
-                            }
-                        }
-                        if (nameMatch) {
-                            vms.push(nameMatch);
-                        } else if (idPrefixMatches.length > 1) {
-                            exactErr = new VError({
-                                name: 'AmbiguousDockerContainerIdPrefixError',
-                                info: {
-                                    idPrefix: rule.value,
-                                    idPrefixMatches: idPrefixMatches
-                                }
-                            }, 'id prefix "%s" matches multiple containers',
-                            rule.value);
-                        } else if (idPrefixMatches.length === 1) {
-                            vms.push(idPrefixMatches[0]);
-                        }
-                        next(exactErr);
-                        break;
-                    default:
-                        next(new VError('unknown affinity rule valueType: '
-                            + rule.valueType));
-                        break;
-                    }
-                });
-            }
-        ]}, function onInstNameMatch(err) {
-            if (err) {
-                cb(err);
-            } else {
-                log.trace({expr: exprFromRule(rule), vms: vms}, '_vmsFromRule');
-                cb(null, vms);
-            }
-        });
-    }
-}
-
 
 // ---- exports
 
-/**
- * Calculate "locality" hints for a VMAPI CreateVm payload from Docker Swarm
- * "Env" and "Labels" affinity entries, if any, in a "docker run" API call.
- *
- * *Side-effects*:
- * - This *removes* affinity entries from `container.Env`.
- * - If affinities are provided in `container.Env` then
- *   `container.Labels['com.docker.swarm.affinities']` is updated with them.
- * Docker Swarm does the same.
- *
- * Swarm affinities can identify containers by id, id-prefix, name, name glob,
- * name regex, or via tag matches. They looks like the following:
- *      container<op><value>
- *      <tag><op><value>
- * where <op> is one of `==`, `!=`, `==~`, or `!=~` (`~` means a "soft"
- * affinity -- non-fatal if cannot match); and <value> can be a plain string
- * (exact match), a glob (simple '*'-only globbing), or a regexp (re2 syntax).
- * E.g.:
- *      container==1a8dae2f-d352-4340-8122-ae76b70a47bd
- *      container==1a8dae2fd352
- *      container!=db0
- *      container==db*
- *      container==/^db\d+$/
- *      flav!=staging
- *      role==/^web/
- *
- * Locality hints only speak VM uuids. They look like the following (all
- * fields are optional):
- *      {
- *          strict: <true|false>,
- *          near: [<array of VM uuids>],
- *          far: [<array of VM uuids>]
- *      }
- *
- * Looking up VMs in VMAPI is necessary for the translation.
- * Some failure modes:
- * - VMAPI requests could fail.
- * - No VMs could be found matching the filter, and the affinity is
- *   a strict '=='. (If we didn't fail, then we'd end up setting no `
- *   locality` and the strict affinity would be blithely ignored.)
- *
- * @param ...
- * @param {Function} cb: `function (err, locality, debugInfo)`
- *      where `debugInfo` is an object with a `rulesInfo` field that shows
- *      internal details. The caller may want to log this.
- */
-function localityFromDockerContainer(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
-    assert.object(opts.container, 'opts.container');
-    assert.func(cb, 'cb');
-
-    var log = opts.log;
-
-    try {
-        var rules = _affinityRulesFromDockerContainer(opts);
-    } catch (affErr) {
-        cb(affErr);
-        return;
-    }
-    if (rules.length === 0) {
-        cb();
-        return;
-    }
-    log.trace({rules: rules}, 'localityFromDockerContainer: rules');
-
-    _localityFromRules({
-        log: log,
-        vmapi: opts.vmapi,
-        ownerUuid: opts.ownerUuid,
-        rules: rules
-    }, cb);
-}
 
 /*
  * Convert the given `affinity` (as accepted by CloudAPI's CreateMachine) to
- * a `locality` object supported by sdc-designation (aka DAPI).
+ * a `affinity` object as supported by sdc-designation (aka DAPI).
  *
  * @param ...
  * @param {Function} cb: `function (err, locality, debugInfo)`
  *      where `debugInfo` is an object with a `rulesInfo` field that shows
  *      internal details. The caller may want to log this.
  */
-function localityFromAffinity(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
+function parseAffinity(opts, cb) {
     assert.arrayOfString(opts.affinity, 'opts.affinity');
     assert.func(cb, 'cb');
 
-    var log = opts.log;
+    var affinity = opts.affinity;
 
-    if (opts.affinity.length === 0) {
+    if (affinity.length === 0) {
         cb();
         return;
     }
 
-    var rules;
     try {
         // TODO: improve this to get all parse errors and VError.errorFromList.
-        rules = opts.affinity.map(function (expr) {
-            return ruleFromExpr(expr);
-        });
+        var rules = affinity.map(ruleFromExpr);
     } catch (exprErr) {
         cb(exprErr);
         return;
     }
-    log.trace({rules: rules}, 'localityFromAffinity: rules');
-
-    _localityFromRules({
-        log: log,
-        vmapi: opts.vmapi,
-        ownerUuid: opts.ownerUuid,
-        rules: rules
-    }, cb);
-}
-
-/*
- * Convert affinity rules to locality hints, as best as possible.
- *
- * @param ...
- * @param {Function} cb: `function (err, locality, debugInfo)`
- *      where `debugInfo` is an object with a `rulesInfo` field that shows
- *      internal details. The caller may want to log this.
- */
-function _localityFromRules(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vmapi, 'opts.vmapi');
-    assert.uuid(opts.ownerUuid, 'opts.ownerUuid');
-    assert.arrayOfObject(opts.rules, 'opts.rules');
-    assert.func(cb, 'cb');
-
-    var log = opts.log;
-    log.trace({rules: opts.rules}, '_localityFromRules: rules');
-
-    // First, gather VM info that we'll need for conversion.
-    // TODO: Really want forEachParallel with concurrency.
-    var cache = {};
-    vasync.forEachParallel({
-        inputs: opts.rules,
-        func: function gatherVmsForRule(rule, next) {
-            if (rule.key === 'image') {
-                // TODO: Should we allow 'image' tag here?
-                log.trace({rule: rule}, 'ignore "image" affinity');
-                next();
-                return;
-            }
-
-            _vmsFromRule({
-                rule: rule,
-                log: log,
-                ownerUuid: opts.ownerUuid,
-                vmapi: opts.vmapi,
-                cache: cache
-            }, function onVmsFromRule(err, vms) {
-                rule.vms = vms;
-                next(err);
-            });
-        }
-    }, function onVmsFromRules(err) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        // Second, convert to locality hints.
-        try {
-            var locality = localityFromRulesInfo({
-                log: log,
-                rules: opts.rules
-            });
-        } catch (convertErr) {
-            cb(convertErr);
-            return;
-        }
-
-        log.trace({locality: locality}, '_localityFromRules: locality');
-        cb(null, locality, {rulesInfo: opts.rules});
-    });
-}
-
-/*
- * Synchronously convert affinity rules (and required extra info) to locality
- * hints, as best as possible.
- *
- * Dev Note: we separate "gather async details" and "convert rules -> locality"
- * steps to make the latter more easily testable.
- */
-function localityFromRulesInfo(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    // Each rule object should have a 'vms' array. This code uses the 'uuid'
-    // and (if not null) 'server_uuid' fields of each VM.
-    assert.arrayOfObject(opts.rules, 'opts.rules');
-    opts.rules.forEach(function (r) {
-        assert.arrayOfObject(r.vms, 'opts.rules[*].vms');
-        r.vms.forEach(function (v) {
-            assert.ok(v.hasOwnProperty('uuid'));
-            assert.ok(v.hasOwnProperty('server_uuid'));
-        });
-    });
-
-    var i;
-    var log = opts.log;
-    var rules = opts.rules;
-    log.trace({rules: rules}, 'localityFromRulesInfo: rules');
-
-    var haveHard = false;
-    var haveSoft = false;
-    var softRules = [];
-    var hardRules = [];
-    for (i = 0; i < rules.length; i++) {
-        var isSoft = rules[i].isSoft;
-        if (isSoft) {
-            haveSoft = true;
-            softRules.push(rules[i]);
-        } else {
-            haveHard = true;
-            hardRules.push(rules[i]);
-        }
-    }
-    if (haveHard && haveSoft) {
-        log.trace({softRules: softRules},
-            'mixed hard and soft affinity rules: dropping soft affinity rules');
-        rules = hardRules;
-    }
-
-    var strict = haveHard;
-    var near = [];
-    var far = [];
-
-    var farServerUuids = new Set();
-    var farRules = rules.filter(function (farRule) {
-        return farRule.operator === '!=';
-    });
-    var farVmUuids = new Set();
-    farRules.forEach(function (farRule) {
-        farRule.vms.forEach(function (vm) {
-            farVmUuids.add(vm.uuid);
-            farServerUuids.add(vm.server_uuid);
-        });
-    });
-    farVmUuids.forEach(function (farVmUuid) {
-        far.push(farVmUuid);
-    });
-
-    // Work through each "near" rule.
-    var nearRules = rules.filter(function (nearRule) {
-        return nearRule.operator === '==';
-    });
-    var nearServerUuids = null; // Servers that satisfy all near rules.
-    nearRules.forEach(function (nearRule) {
-        if (nearRule.vms.length === 0) {
-            if (isSoft) {
-                nearRule.skip = true;
-                return;
-            } else {
-                throw new VError('cannot satisfy affinity rule "%s", '
-                    + 'it does not match any instances',
-                    exprFromRule(nearRule));
-            }
-        }
-
-        // Eliminate "far" servers from candidacy.
-        nearRule.remainingVms = nearRule.vms.filter(function (vm) {
-            // Provisioning VMs might not have a server_uuid.
-            return (vm.server_uuid && !farServerUuids.has(vm.server_uuid));
-        });
-
-        // If there are no remaining VMs, then this rule is unsatisfiable.
-        if (nearRule.remainingVms.length === 0) {
-            if (isSoft) {
-                nearRule.skip = true;
-                return;
-            } else {
-                throw new VError('cannot satisfy affinity rule "%s", '
-                    + '"!=" rules eliminate all its servers',
-                    exprFromRule(nearRule));
-            }
-        }
-
-        // Candidate servers are the intersection of servers for this rule
-        // and those from previous rules.
-        var ruleServerUuids = new Set(nearRule.remainingVms.map(
-                function (vm) { return vm.server_uuid; }));
-        if (nearServerUuids === null) {
-            nearServerUuids = ruleServerUuids;
-        } else {
-            var newCandidates = setIntersection(
-                nearServerUuids, ruleServerUuids);
-            if (newCandidates.size === 0) {
-                if (isSoft) {
-                    nearRule.skip = true;
-                    return;
-                } else {
-                    throw new VError('cannot satisfy affinity rule "%s", '
-                        + 'its servers (%s) do not intersect with servers from '
-                        + 'previous rules (%s)',
-                        exprFromRule(nearRule),
-                        setJoin(ruleServerUuids, ', '),
-                        setJoin(nearServerUuids, ', '));
-                }
-            } else {
-                nearServerUuids = newCandidates;
-            }
-        }
-    });
-
-    if (nearServerUuids !== null) {
-        /*
-         * If there are multiple candidate servers, then we must choose one
-         * here (we choose at random). We can't pass through multiple servers
-         * because you can't provision an instance on more than one server.
-         * It would be better to send through all the candidates and have
-         * sdc-designation choose the best of those servers (considering
-         * available capacity, etc.), but locality hints don't support a
-         * list of candidates.
-         */
-        assert.ok(nearServerUuids.size > 0);
-        var serverUuid = setRandomChoice(nearServerUuids);
-
-        /*
-         * Locality hints speak in terms of VMs. We'll use the first VM from
-         * the first non-skipped rule as the representative of `serverUuid`.
-         */
-        var vmUuid;
-        for (i = 0; i < nearRules.length; i++) {
-            var rule = nearRules[i];
-            if (rule.skip) {
-                continue;
-            }
-            for (var j = 0; j < rule.remainingVms.length; j++) {
-                if (rule.remainingVms[j].server_uuid === serverUuid) {
-                    vmUuid = rule.remainingVms[j].uuid;
-                    break;
-                }
-            }
-            if (vmUuid) {
-                break;
-            }
-        }
-        assert.ok(vmUuid);
-        near.push(vmUuid);
-    }
 
-
-    var locality = {
-        strict: strict
-    };
-    if (near.length > 0) {
-        locality.near = near;
-    }
-    if (far.length > 0) {
-        locality.far = far;
-    }
-
-    return locality;
+    cb(null, rules);
 }
 
 
 module.exports = {
-    localityFromDockerContainer: localityFromDockerContainer,
-    localityFromAffinity: localityFromAffinity,
-
-    // Exported for testing.
-    localityFromRulesInfo: localityFromRulesInfo,
-    ruleFromExpr: ruleFromExpr,
-    exprFromRule: exprFromRule
+    parseAffinity: parseAffinity
 };
diff --git a/package.json b/package.json
index 014d74a..411d7fc 100644
--- a/package.json
+++ b/package.json
@@ -37,14 +37,12 @@
         "restify": "4.3.3",
         "sdc-clients": "git+https://github.com/joyent/node-sdc-clients.git#01b9136799e4c76e26c59dd266cd5435cccde534",
         "semver": "5.4.1",
-        "strsplit": "1.0.0",
         "triton-metrics": "0.1.0",
         "triton-netconfig": "1.3.0",
         "ufds": "1.5.0",
         "uuid-by-string": "0.6.0",
         "vasync": "2.2.0",
-        "verror": "1.10.0",
-        "xregexp": "3.1.0"
+        "verror": "1.10.0"
     },
     "devDependencies": {
         "@smaller/tap": "11.1.4-1.0.0",
diff --git a/test/affinity-unit.test.js b/test/affinity-unit.test.js
index 5488ea3..a0bf8e9 100644
--- a/test/affinity-unit.test.js
+++ b/test/affinity-unit.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -14,298 +14,123 @@
  */
 
 var assert = require('assert-plus');
-var bunyan = require('bunyan');
-var deepEqual = require('@smaller/tap/node_modules/tsame');
 var test = require('@smaller/tap').test;
-var util = require('util');
-var VError = require('verror');
-var XRegExp = require('xregexp');
 
-var lib_affinity = require('../lib/triton-affinity');
+var affinity_lib = require('../lib/triton-affinity');
 
 
-var log = bunyan.createLogger({
-    level: process.env.LOG_LEVEL || 'warn',
-    name: 'sdccloudapitest-affinity-unit',
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
-});
-
-
-// ---- helpers
-
-/*
- * Pass in an array of server objects with a 'vms' array that is the set of
- * VMs on that server *for the single unnamed account*.
- */
-function MockDc(servers) {
-    assert.arrayOfObject(servers, 'servers');
-    var self = this;
-
-    this.servers = servers;
+// --- Helpers
 
-    this.vms = [];
-    this.vmFromUuid = {};
-    this.vmFromAlias = {};
-    this.serverFromUuid = {};
-
-    servers.forEach(function (server) {
-        self.serverFromUuid[server.uuid] = server;
-        server.vms.forEach(function (vm) {
-            vm.server_uuid = server.uuid;
-            self.vms.push(vm);
-            self.vmFromUuid[vm.uuid] = vm;
-            self.vmFromAlias[vm.alias] = vm;
-        });
+function checkOk(t, strArr, expected) {
+    affinity_lib.parseAffinity({ affinity: strArr }, function (err, affinity) {
+        t.ifError(err, 'err');
+        t.deepEqual(affinity, expected, 'check results');
     });
 }
 
-/*
- * Faking out `triton-affinity._vmsFromRule`.
- *      {
- *          key: 'instance',
- *          value: 'webhead*',
- *          valueType: 'glob',  // or 're' or 'exact'
- *          ...
- *      }
- *
- * Limitations:
- * - Not bothering with docker_id matching.
- */
-MockDc.prototype.vmsFromRule = function (rule) {
-    var self = this;
-    var key = rule.key;
-    var val = rule.value;
-    var valueType = rule.valueType;
-    var valueRe;
-    var vms = [];
-
-    if (valueType === 'exact') {
-        valueRe = new RegExp('^' + XRegExp.escape(val) + '$');
-    } else if (valueType === 'glob') {
-        // Cheat. Better would be to use minimatch.
-        valueRe = new RegExp(
-            '^'
-            + XRegExp.escape(val)
-                .replace('\\*', '.*')
-                .replace('\\?', '.')
-            + '$');
-    } else if (valueType === 're') {
-        valueRe = rule.valueRe;
-    } else {
-        throw new VError('unexpected rule data', rule);
-    }
-
-    if (key === 'instance' || key === 'container') {
-        // exact uuid
-        if (valueType === 'exact' && self.vmFromUuid[val]) {
-            vms.push(self.vmFromUuid[val]);
-        } else {
-            // alias
-            self.vms.forEach(function (vm) {
-                if (vm.alias && valueRe.test(vm.alias)) {
-                    vms.push(vm);
-                }
-            });
-        }
-    } else {
-        // tag
-        self.vms.forEach(function (vm) {
-            if (vm.tags && vm.tags.hasOwnProperty(key) &&
-                valueRe.test(vm.tags[key].toString()))
-            {
-                vms.push(vm);
-            }
-        });
-    }
-
-    return vms;
-};
-
-
-function assertLocalityFromRules(opts) {
-    var i;
-    var expectedLocality;
-    var foundMatch;
-    var locality;
-    var locSummary;
-    var rulesInfo = [];
-
-    opts.exprs.forEach(function (expr) {
-        var rule = lib_affinity.ruleFromExpr(expr);
-        // .vms is the "Info" part of rulesInfo
-        rule.vms = opts.dc.vmsFromRule(rule);
-        rulesInfo.push(rule);
+function checkErr(t, strArr, errRegex) {
+    affinity_lib.parseAffinity({ affinity: strArr }, function (err) {
+        t.ok(err, 'err');
+        t.ok(errRegex.test(err.message), 'check err msg');
     });
-
-    try {
-        locality = lib_affinity.localityFromRulesInfo(
-            {log: log, rules: rulesInfo});
-    } catch (err) {
-        if (opts.err) {
-            opts.t.ok(err, util.format(
-                'error determining locality for %j', opts.exprs));
-            if (opts.err.message) {
-                opts.t.equal(err.message, opts.err.message,
-                    util.format('error message is %j', opts.err.message));
-            }
-        } else {
-            opts.t.ifError(err, util.format(
-                'no error determining locality for %j', opts.exprs));
-        }
-    }
-    if (opts.locality) {
-        if (Array.isArray(opts.locality)) {
-            foundMatch = false;
-            for (i = 0; i < opts.locality.length; i++) {
-                expectedLocality = opts.locality[i];
-                foundMatch = deepEqual(locality, expectedLocality);
-                if (foundMatch) {
-                    break;
-                }
-            }
-            locSummary = opts.locality.map(
-                function (loc) { return JSON.stringify(loc); });
-            opts.t.assert(foundMatch, util.format('%j -> one of %s',
-                opts.exprs, locSummary.join(', ')));
-        } else {
-            opts.t.deepEqual(locality, opts.locality,
-                util.format('%j -> %j', opts.exprs, opts.locality));
-        }
-    }
 }
 
 
-
 // --- Tests
 
-test('affinity-unit', function (tt) {
-    // A layout of our (unnamed) test account's VMs in the DC. We'll run
-    // affinity->locality tests against this setup.
-    /* BEGIN JSSTYLED */
-    var dc = new MockDc([
-        {
-            uuid: 'aaaaaaaa-9f2c-11e7-8d2a-7b05237c283d',
-            hostname: 'CNa',
-            vms: [
-                { uuid: '02655ed2-9f2c-11e7-a596-8f1e118e27d6', alias: 'webhead0', tags: {} },
-                { uuid: '48195234-9f2c-11e7-8970-3f2cc6773306', alias: 'db0', tags: {role: 'database'} }
-            ]
-        },
-        {
-            uuid: 'bbbbbbbb-9f42-11e7-a98f-375a35af4e58',
-            hostname: 'CNb',
-            vms: [
-                { uuid: '0dab5820-9f2d-11e7-a5ae-8b56e717c599', alias: 'webhead1', tags: {} },
-                { uuid: '10d1edb6-9f2d-11e7-8923-2f7c2579fada', alias: 'db1', tags: {role: 'database'} }
-            ]
-        },
-        {
-            uuid: 'cccccccc-9f2d-11e7-bfaa-03c71f6e23e9',
-            hostname: 'CNc',
-            vms: [
-                { uuid: 'a22832e8-9f2d-11e7-99a4-a3ae10e549f5', alias: 'webhead2', tags: {} }
-            ]
-        },
-        {
-            uuid: 'dddddddd-9f2d-11e7-9c48-2b216115a37d',
-            hostname: 'CNd',
-            vms: [
-                { uuid: '9fec2192-9f2d-11e7-b081-fbba6b455dbd', alias: 'webhead3', tags: {} }
-            ]
-        }
-    ]);
-    /* END JSSTYLED */
-
-    tt.test('  localityFromRulesInfo', function (t) {
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: ['instance!=webhead3'],
-            locality: {
-                strict: true,
-                far: ['9fec2192-9f2d-11e7-b081-fbba6b455dbd']
-            }
-        });
-
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: ['container==webhead3'],
-            locality: {
-                strict: true,
-                near: ['9fec2192-9f2d-11e7-b081-fbba6b455dbd']
-            }
-        });
-
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: ['role!=~datab*se'],
-            locality: {
-                strict: false,
-                far: [
-                    '48195234-9f2c-11e7-8970-3f2cc6773306',
-                    '10d1edb6-9f2d-11e7-8923-2f7c2579fada'
-                ]
-            }
-        });
-
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: [
-                'role==/^data/',
-                'instance!=webhead*'
-            ],
-            err: {
-                message: 'cannot satisfy affinity rule "role==/^data/", '
-                    + '"!=" rules eliminate all its servers'
-            }
-        });
-
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: [
-                'role==/^data/',
-                'instance==webhead3'
-            ],
-            err: {
-                message: 'cannot satisfy affinity rule "instance==webhead3", '
-                    + 'its servers (dddddddd-9f2d-11e7-9c48-2b216115a37d) do '
-                    + 'not intersect with servers from previous rules '
-                    + '(aaaaaaaa-9f2c-11e7-8d2a-7b05237c283d, '
-                    + 'bbbbbbbb-9f42-11e7-a98f-375a35af4e58)'
-            }
-        });
-
-        assertLocalityFromRules({
-            t: t,
-            dc: dc,
-            exprs: [
-                'instance==webhead*',
-                'role==database',
-                'instance!=webhead3'
-            ],
-            // We expect the 'near' to be the first VM from either CNa or CNb
-            // (randomly selected).
-            locality: [
-                {
-                    strict: true,
-                    far: ['9fec2192-9f2d-11e7-b081-fbba6b455dbd'],
-                    near: ['02655ed2-9f2c-11e7-a596-8f1e118e27d6']
-                },
-                {
-                    strict: true,
-                    far: ['9fec2192-9f2d-11e7-b081-fbba6b455dbd'],
-                    near: ['0dab5820-9f2d-11e7-a5ae-8b56e717c599']
-                }
-            ]
-        });
-
-        t.end();
-    });
-
-    tt.end();
+test('affinity-unit', function (t) {
+    checkOk(t, [], undefined);
+
+    checkOk(t, ['instance!=webhead3'], [ {
+        key: 'instance',
+        operator: '!=',
+        value: 'webhead3',
+        isSoft: false,
+        valueType: 'exact'
+    } ]);
+
+    checkOk(t, ['container==webhead3'], [ {
+        key: 'container',
+        operator: '==',
+        value: 'webhead3',
+        isSoft: false,
+        valueType: 'exact'
+    } ]);
+
+    checkOk(t, ['role!=~datab*se'], [ {
+        key: 'role',
+        operator: '!=',
+        value: 'datab*se',
+        isSoft: true,
+        valueType: 'glob'
+    } ]);
+
+    checkOk(t, [
+        'role==/^data/',
+        'instance!=webhead*'
+    ], [ {
+        key: 'role',
+        operator: '==',
+        value: '/^data/',
+        isSoft: false,
+        valueType: 're'
+    }, {
+        key: 'instance',
+        operator: '!=',
+        value: 'webhead*',
+        isSoft: false,
+        valueType: 'glob'
+    } ]);
+
+    checkOk(t, [
+        'role==/^data/',
+        'instance==webhead3'
+    ], [ {
+        key: 'role',
+        operator: '==',
+        value: '/^data/',
+        isSoft: false,
+        valueType: 're'
+    }, {
+        key: 'instance',
+        operator: '==',
+        value: 'webhead3',
+        isSoft: false,
+        valueType: 'exact'
+    } ]);
+
+    checkOk(t, [
+        'instance==webhead*',
+        'role==database',
+        'instance!=webhead3'
+    ], [ {
+        key: 'instance',
+        operator: '==',
+        value: 'webhead*',
+        isSoft: false,
+        valueType: 'glob'
+    }, {
+        key: 'role',
+        operator: '==',
+        value: 'database',
+        isSoft: false,
+        valueType: 'exact'
+    }, {
+        key: 'instance',
+        operator: '!=',
+        value: 'webhead3',
+        isSoft: false,
+        valueType: 'exact'
+    } ]);
+
+    checkErr(t, ['instance=webhead3'], /could not find operator/);
+
+    checkErr(t, ['instance===webhead3'], /invalid value/);
+
+    checkErr(t, [
+        'instance==webhead3',
+        'instance=webhead3'
+    ], /could not find operator/);
+
+    t.end();
 });
diff --git a/test/machines/affinity.js b/test/machines/affinity.js
index 3fc934b..741bcd6 100644
--- a/test/machines/affinity.js
+++ b/test/machines/affinity.js
@@ -5,11 +5,10 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 var clone = require('clone');
-var format = require('util').format;
 var libuuid = require('libuuid');
 var machinesCommon = require('./common');
 
@@ -19,6 +18,25 @@ var machinesCommon = require('./common');
 var CONTAINER_PREFIX = 'sdccloudapitest_affinity_';
 
 
+// --- Helpers
+
+function getLastJob(client, vmUuid, cb) {
+    machinesCommon.waitForRunningMachine(client, vmUuid, function waitCb(_) {
+        client.vmapi.listJobs({
+            vm_uuid: vmUuid,
+            task: 'provision'
+        }, function (err, jobs) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            cb(null, jobs[0]);
+        });
+    });
+}
+
+
 // --- Tests
 
 module.exports =
@@ -39,15 +57,58 @@ function (suite, client, other, imgUuid, pkgUuid, headnodeUuid, cb) {
     }
 
 
+    // this should fail due to bad syntax
+    suite.test('CreateMachine with bad-syntax affinity', function (t) {
+        var args = createArgs('container=!' + CONTAINER_PREFIX + '*');
+
+        client.post('/my/machines', args, function postCb(err, req, res, vm) {
+            t.ok(err, 'err');
+            t.ok(/not find operator in affinity/.test(err.message), 'err.msg');
+            t.equal(res.statusCode, 409);
+            t.end();
+        });
+    });
+
+
     // This should fail: no container with name 'sdccloudapitest_affinity_*'.
     suite.test('CreateMachine with affinity "container==' + CONTAINER_PREFIX +
         '*"', function (t) {
 
         var args = createArgs('container==' + CONTAINER_PREFIX + '*');
 
-        client.post('/my/machines', args, function (err, req, res, body) {
-            t.ok(err, 'VM with false affinity should fail');
-            t.end();
+        client.post('/my/machines', args, function postCb(err, req, res, vm) {
+            t.ifError(err, 'err');
+
+            getLastJob(client, vm.uuid, function jobCb(err2, job) {
+                t.ifError(err2, 'VM with false affinity should fail');
+
+                var step = job.chain_results.pop();
+                t.equal(step.error.name, 'NoAllocatableServersError');
+
+                t.end();
+            });
+        });
+    });
+
+
+    // This should fail: no instance (different name for container) with name
+    // 'sdccloudapitest_affinity_*'.
+    suite.test('CreateMachine with affinity "instance==' + CONTAINER_PREFIX +
+        '*"', function (t) {
+
+        var args = createArgs('instance==' + CONTAINER_PREFIX + '*');
+
+        client.post('/my/machines', args, function postCb(err, req, res, vm) {
+            t.ifError(err, 'err');
+
+            getLastJob(client, vm.uuid, function jobCb(err2, job) {
+                t.ifError(err2, 'VM with false affinity should fail');
+
+                var step = job.chain_results.pop();
+                t.equal(step.error.name, 'NoAllocatableServersError');
+
+                t.end();
+            });
         });
     });
 
@@ -58,9 +119,17 @@ function (suite, client, other, imgUuid, pkgUuid, headnodeUuid, cb) {
 
         var args = createArgs('container==/^' + CONTAINER_PREFIX + '/');
 
-        client.post('/my/machines', args, function (err, req, res, body) {
-            t.ok(err, 'VM with false affinity should fail');
-            t.end();
+        client.post('/my/machines', args, function postCb(err, req, res, vm) {
+            t.ifError(err, 'err');
+
+            getLastJob(client, vm.uuid, function jobCb(err2, job) {
+                t.ifError(err2, 'VM with false affinity should fail');
+
+                var step = job.chain_results.pop();
+                t.equal(step.error.name, 'NoAllocatableServersError');
+
+                t.end();
+            });
         });
     });
 
@@ -89,23 +158,70 @@ function (suite, client, other, imgUuid, pkgUuid, headnodeUuid, cb) {
 
             client.del('/my/machines/' + VM_UUID, function (err2, req, res) {
                 t.ifError(err2, 'Cleanup test container');
-                t.end();
+
+                machinesCommon.waitForDeletedMachine(client, VM_UUID,
+                function waitCb(err3) {
+                    t.ifError(err3, 'Wait for deletion');
+                    t.end();
+                });
             });
         });
     });
 
 
-    // This should fail: no container with label foo=bar2.
-    suite.test('CreateMachine with affinity "foo==bar2', function (t) {
-        var args = createArgs('foo==bar2');
+    // same as above test, but with instance
+    suite.test('CreateMachine with affinity "instance!=' + CONTAINER_PREFIX +
+        '*"', function (t) {
+
+        var args = createArgs('instance!=' + CONTAINER_PREFIX + '*');
 
         client.post('/my/machines', args, function (err, req, res, vm) {
-            t.ok(err, 'VM with false affinity should fail');
+            t.ifError(err, 'VM affinity should succeed');
+            t.ok(vm, 'VM should be created');
+
+            VM_UUID = vm.id;
+
             t.end();
         });
     });
 
 
+    suite.test('Wait for running, then clean up', function (t) {
+        machinesCommon.waitForRunningMachine(client, VM_UUID, function (err) {
+            t.ifError(err);
+
+            client.del('/my/machines/' + VM_UUID, function (err2, req, res) {
+                t.ifError(err2, 'Cleanup test container');
+
+                machinesCommon.waitForDeletedMachine(client, VM_UUID,
+                function waitCb(err3) {
+                    t.ifError(err3, 'Wait for deletion');
+                    t.end();
+                });
+            });
+        });
+    });
+
+
+    // This should fail: no container with label foo=bar2.
+    suite.test('CreateMachine with affinity "foo==bar2"', function (t) {
+        var args = createArgs('foo==bar2');
+
+        client.post('/my/machines', args, function postCb(err, req, res, vm) {
+            t.ifError(err, 'err');
+
+            getLastJob(client, vm.uuid, function jobCb(err2, job) {
+                t.ifError(err2, 'VM with false affinity should fail');
+
+                var step = job.chain_results.pop();
+                t.equal(step.error.name, 'NoAllocatableServersError');
+
+                t.end();
+            });
+        });
+    });
+
+
     // This should work: no container with label foo=bar2, but *soft* affinity.
     suite.test('CreateMachine with affinity "foo==~bar2"', function (t) {
         var args = createArgs('foo==~bar2');
@@ -127,7 +243,12 @@ function (suite, client, other, imgUuid, pkgUuid, headnodeUuid, cb) {
 
             client.del('/my/machines/' + VM_UUID, function (err2, req, res) {
                 t.ifError(err2, 'Cleanup test container');
-                t.end();
+
+                machinesCommon.waitForDeletedMachine(client, VM_UUID,
+                function waitCb(err3) {
+                    t.ifError(err3, 'Wait for deletion');
+                    t.end();
+                });
             });
         });
     });
@@ -179,7 +300,12 @@ function (suite, client, other, imgUuid, pkgUuid, headnodeUuid, cb) {
 
             client.del('/my/machines/' + VM2_UUID, function (err2, req, res) {
                 t.ifError(err2, 'Cleanup test container');
-                t.end();
+
+                machinesCommon.waitForDeletedMachine(client, VM2_UUID,
+                function waitCb(err3) {
+                    t.ifError(err3, 'Wait for deletion');
+                    t.end();
+                });
             });
         });
     });
-- 
2.21.0

