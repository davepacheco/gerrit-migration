commit d0e3c2796e1743b351c12cd5c0cf61a61a4bf6e0 (refs/changes/90/2390/2)
Author: Tim Kordas <tim.kordas@joyent.com>
Date:   2017-08-14T16:14:18-07:00 (2 years, 2 months ago)
    
    joyent/node-sshpk#32 support dnssec format

diff --git a/bin/sshpk-conv b/bin/sshpk-conv
index 444045a..856a03e 100755
--- a/bin/sshpk-conv
+++ b/bin/sshpk-conv
@@ -1,7 +1,7 @@
 #!/usr/bin/env node
 // -*- mode: js -*-
 // vim: set filetype=javascript :
-// Copyright 2015 Joyent, Inc.  All rights reserved.
+// Copyright 2015 Joyent, Inc.	All rights reserved.
 
 var dashdash = require('dashdash');
 var sshpk = require('../lib/index');
@@ -76,11 +76,12 @@ if (require.main === module) {
 		console.error('sshpk-conv: converts between SSH key formats\n');
 		console.error(help);
 		console.error('\navailable formats:');
-		console.error('  - pem, pkcs1     eg id_rsa');
-		console.error('  - ssh            eg id_rsa.pub');
-		console.error('  - pkcs8          format you want for openssl');
-		console.error('  - openssh        like output of ssh-keygen -o');
-		console.error('  - rfc4253        raw OpenSSH wire format');
+		console.error('	 - pem, pkcs1	  eg id_rsa');
+		console.error('	 - ssh		  eg id_rsa.pub');
+		console.error('	 - pkcs8	  format you want for openssl');
+		console.error('	 - openssh	  like output of ssh-keygen -o');
+		console.error('	 - rfc4253	  raw OpenSSH wire format');
+		console.error('	 - dnssec	  dnssec-keygen format');
 		process.exit(1);
 	}
 
diff --git a/lib/dhe.js b/lib/dhe.js
index b4d3662..84cb2bc 100644
--- a/lib/dhe.js
+++ b/lib/dhe.js
@@ -3,7 +3,8 @@
 module.exports = {
 	DiffieHellman: DiffieHellman,
 	generateECDSA: generateECDSA,
-	generateED25519: generateED25519
+	generateED25519: generateED25519,
+	publicFromPrivateECDSA: publicFromPrivateECDSA
 };
 
 var assert = require('assert-plus');
@@ -369,7 +370,6 @@ function generateECDSA(curve) {
 			parts: parts
 		});
 		return (key);
-
 	} else {
 		if (ecdh === undefined)
 			ecdh = require('ecc-jsbn');
@@ -409,3 +409,26 @@ function generateECDSA(curve) {
 		return (key);
 	}
 }
+
+function publicFromPrivateECDSA(curve, priv) {
+	assert.string(curve, 'curve');
+	assert.buffer(priv);
+	if (ecdh === undefined)
+		ecdh = require('ecc-jsbn');
+	if (ec === undefined)
+		ec = require('ecc-jsbn/lib/ec');
+	if (jsbn === undefined)
+		jsbn = require('jsbn').BigInteger;
+
+	var ecParams = new X9ECParameters(curve);
+	var d = new jsbn(utils.mpNormalize(priv));
+	var pub = ecParams.getG().multiply(d);
+	pub = new Buffer(ecParams.getCurve().encodePointHex(pub), 'hex');
+
+	var parts = [];
+	parts.push({name: 'curve', data: new Buffer(curve)});
+	parts.push({name: 'Q', data: pub});
+
+	var key = new Key({type: 'ecdsa', curve: curve, parts: parts});
+	return (key);
+}
diff --git a/lib/formats/auto.js b/lib/formats/auto.js
index 973c032..9224b6a 100644
--- a/lib/formats/auto.js
+++ b/lib/formats/auto.js
@@ -13,6 +13,7 @@ var PrivateKey = require('../private-key');
 var pem = require('./pem');
 var ssh = require('./ssh');
 var rfc4253 = require('./rfc4253');
+var dnssec = require('./dnssec');
 
 function read(buf, options) {
 	if (typeof (buf) === 'string') {
@@ -29,6 +30,8 @@ function read(buf, options) {
 			return (pem.read(buf, options));
 		if (findSSHHeader(buf))
 			return (ssh.read(buf, options));
+		if (findDNSSECHeader(buf))
+			return (dnssec.read(buf, options));
 	}
 	if (buf.readUInt32BE(0) < buf.length)
 		return (rfc4253.read(buf, options));
@@ -68,6 +71,33 @@ function findPEMHeader(buf) {
 	return (true);
 }
 
+function findDNSSECHeader(buf) {
+	// private case first
+	var privateKeyHeaderString = 'Private-key-format: v1';
+	if (buf.length <= privateKeyHeaderString.length)
+		return (false);
+	if (buf.slice(0, privateKeyHeaderString.length).toString('ascii')
+	    === privateKeyHeaderString)
+		return (true);
+
+	// public-key RFC3110 ?
+	// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
+	// skip any comment-lines
+	if (typeof (buf) !== 'string') {
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	if (lines[line].toString('ascii').match(/\. IN KEY /))
+		return (true);
+	if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
+		return (true);
+	return (false);
+}
+
 function write(key, options) {
 	throw (new Error('"auto" format cannot be used for writing'));
 }
diff --git a/lib/formats/dnssec.js b/lib/formats/dnssec.js
new file mode 100644
index 0000000..a5563bf
--- /dev/null
+++ b/lib/formats/dnssec.js
@@ -0,0 +1,263 @@
+// Copyright 2017 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	write: write
+};
+
+var assert = require('assert-plus');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var utils = require('../utils');
+var SSHBuffer = require('../ssh-buffer');
+var Dhe = require('../dhe');
+
+var supportedAlgos = {
+	'rsa-sha1' : 5,
+	'rsa-sha256' : 8,
+	'rsa-sha512' : 10,
+	'ecdsa-p256-sha256' : 13,
+	'ecdsa-p384-sha384' : 14
+	/*
+	 * ed25519 is hypothetically supported with id 15
+	 * but the common tools available don't appear to be
+	 * capable of generating/using ed25519 keys
+	 */
+};
+
+var supportedAlgosById = {};
+Object.keys(supportedAlgos).forEach(function (k) {
+	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
+});
+
+function read(buf, options) {
+	if (typeof (buf) !== 'string') {
+		assert.buffer(buf, 'buf');
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	if (lines[0].match(/^Private-key-format\: v1/)) {
+		var algElems = lines[1].split(' ');
+		var algoNum = parseInt(algElems[1], 10);
+		var algoName = algElems[2];
+		if (!supportedAlgosById[algoNum])
+			throw (new Error('Unsupported algorithm: ' + algoName));
+		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
+	}
+
+	// skip any comment-lines
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	if (lines[line].match(/\. IN KEY /) ||
+	    lines[line].match(/\. IN DNSKEY /)) {
+		return (readRFC3110(lines[line]));
+	}
+	throw (new Error('Cannot parse dnssec key'));
+}
+
+function readRFC3110(keyString) {
+	var elems = keyString.split(' ');
+	//unused var flags = parseInt(elems[3], 10);
+	//unused var protocol = parseInt(elems[4], 10);
+	var algorithm = parseInt(elems[5], 10);
+	if (!supportedAlgosById[algorithm])
+		throw (new Error('Unsupported algorithm: ' + algorithm));
+	var base64key = elems.slice(6, elems.length).join();
+	var keyBuffer = Buffer.from(base64key, 'base64');
+	if (supportedAlgosById[algorithm].match(/^RSA/)) {
+		// join the rest of the body into a single base64-blob
+		var publicExponentLen = keyBuffer.readUInt8(0);
+		if (publicExponentLen != 3 && publicExponentLen != 1)
+			throw (new Error('Cannot parse dnssec key: ' +
+			    'unsupported exponent length'));
+
+		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
+		publicExponent = utils.mpNormalize(publicExponent);
+		var modulus = keyBuffer.slice(1+publicExponentLen);
+		modulus = utils.mpNormalize(modulus);
+		// now, make the key
+		var rsaKey = {
+			type: 'rsa',
+			parts: []
+		};
+		rsaKey.parts.push({ name: 'e', data: publicExponent});
+		rsaKey.parts.push({ name: 'n', data: modulus});
+		return (new Key(rsaKey));
+	}
+	if (supportedAlgosById[algorithm].match(/^ECDSA-P384-SHA384/) ||
+	    supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
+			curve = 'nistp256';
+			size = 256;
+		}
+
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'Q', data: utils.ecNormalize(keyBuffer) }
+			]
+		};
+		return (new Key(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' +
+	    supportedAlgosById[algorithm]));
+}
+
+function readDNSSECRSAPrivateKey(elements) {
+	var modulus = Buffer.from(elements[0].split(' ')[1], 'base64');
+	var publicExponent = Buffer.from(elements[1].split(' ')[1], 'base64');
+	var privateExponent = Buffer.from(elements[2].split(' ')[1], 'base64');
+	var prime1 = Buffer.from(elements[3].split(' ')[1], 'base64');
+	var prime2 = Buffer.from(elements[4].split(' ')[1], 'base64');
+	var e1 = Buffer.from(elements[5].split(' ')[1], 'base64');
+	var e2 = Buffer.from(elements[6].split(' ')[1], 'base64');
+	var coefficient = Buffer.from(elements[7].split(' ')[1], 'base64');
+	// now, make the key
+	var key = {
+		type: 'rsa',
+		parts: [
+			{ name: 'e', data: utils.mpNormalize(publicExponent)},
+			{ name: 'n', data: utils.mpNormalize(modulus) },
+			{ name: 'd', data: utils.mpNormalize(privateExponent)},
+			{ name: 'p', data: utils.mpNormalize(prime1) },
+			{ name: 'q', data: utils.mpNormalize(prime2) },
+			{ name: 'dmodp', data: utils.mpNormalize(e1) },
+			{ name: 'dmodq', data: utils.mpNormalize(e2) },
+			{ name: 'iqmp', data: utils.mpNormalize(coefficient) }
+		]
+	};
+	return (new PrivateKey(key));
+}
+
+function readDNSSECPrivateKey(alg, elements) {
+	if (supportedAlgosById[alg].match(/^RSA/)) {
+		return (readDNSSECRSAPrivateKey(elements));
+	}
+	if (supportedAlgosById[alg].match(/^ECDSA-P384-SHA384/) ||
+	    supportedAlgosById[alg].match(/^ECDSA-P256-SHA256/)) {
+		var d = Buffer.from(elements[0].split(' ')[1], 'base64');
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[alg].match(/^ECDSA-P256-SHA256/)) {
+			curve = 'nistp256';
+			size = 256;
+		}
+		// DNSSEC generates the public-key on the fly (go calculate it)
+		var publicKey = Dhe.publicFromPrivateECDSA(curve, d);
+		var Q = publicKey.part['Q'].data;
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'd', data: d },
+				{name: 'Q', data: Q }
+			]
+		};
+		return (new PrivateKey(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
+}
+
+function dnssecTimestamp(date) {
+	var year = date.getFullYear() + ''; //stringify
+	var month = (date.getMonth() + 1);
+	var timestampStr = year + month + date.getUTCDate();
+	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
+	timestampStr += date.getUTCSeconds();
+	return (timestampStr);
+}
+
+function rsaAlgFromOptions(opts) {
+	if (!opts || opts.hashAlgo === 'sha1')
+		return ('5 (RSASHA1)');
+	else if (opts.hashAlgo === 'sha256')
+		return ('8 (RSASHA256)');
+	else if (opts.hashAlgo === 'sha512')
+		return ('10 (RSASHA512)');
+	else
+		throw (new Error('Unknown or unsupported hash: ' +
+		    opts.hashAlgo));
+}
+
+function writeRSA(key, options) {
+	// if we're missing parts, add them.
+	if (!key.part.dmodp || !key.part.dmodq) {
+		utils.addRSAMissing(key);
+	}
+
+	var buf = new SSHBuffer({});
+	buf.writeCString('Private-key-format: v1.3\n');
+	buf.writeCString('Algorithm: ' + rsaAlgFromOptions(options) + '\n');
+
+	var n = utils.mpDenormalize(key.part['n'].data);
+	buf.writeCString('Modulus: ' + n.toString('base64') + '\n');
+	var e = utils.mpDenormalize(key.part['e'].data);
+	buf.writeCString('PublicExponent: ' + e.toString('base64') + '\n');
+	var d = utils.mpDenormalize(key.part['d'].data);
+	buf.writeCString('PrivateExponent: ' + d.toString('base64') + '\n');
+	var p = utils.mpDenormalize(key.part['p'].data);
+	buf.writeCString('Prime1: ' + p.toString('base64') + '\n');
+	var q = utils.mpDenormalize(key.part['q'].data);
+	buf.writeCString('Prime2: ' + q.toString('base64') + '\n');
+	var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
+	buf.writeCString('Exponent1: ' + dmodp.toString('base64') + '\n');
+	var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
+	buf.writeCString('Exponent2: ' + dmodq.toString('base64') + '\n');
+	var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
+	buf.writeCString('Coefficient: ' + iqmp.toString('base64') + '\n');
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	buf.writeCString('Created: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Publish: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Activate: ' + dnssecTimestamp(timestamp) + '\n');
+	return (buf.toBuffer());
+}
+
+function writeECDSA(key, options) {
+	var buf = new SSHBuffer({});
+	buf.writeCString('Private-key-format: v1.3\n');
+
+	if (key.curve === 'nistp256') {
+		buf.writeCString('Algorithm: 13 (ECDSAP256SHA256)\n');
+	} else if (key.curve === 'nistp384') {
+		buf.writeCString('Algorithm: 14 (ECDSAP384SHA384)\n');
+	} else {
+		throw (new Error('Unsupported curve'));
+	}
+	var base64Key = key.part['d'].data.toString('base64');
+	buf.writeCString('PrivateKey: ' + base64Key + '\n');
+
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	buf.writeCString('Created: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Publish: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Activate: ' + dnssecTimestamp(timestamp) + '\n');
+
+	return (buf.toBuffer());
+}
+
+function write(key, options) {
+	if (PrivateKey.isPrivateKey(key)) {
+		if (key.type === 'rsa') {
+			return (writeRSA(key, options));
+		} else if (key.type === 'ecdsa') {
+			return (writeECDSA(key, options));
+		} else {
+			throw (new Error('Unsupported algorithm: ' + key.type));
+		}
+	} else if (Key.isKey(key)) {
+		// RFC3110 requires a keyname, and a keytype
+		throw (new Error('Cannot output RFC3110 without key info'));
+	} else {
+		throw (new Error('key is not a Key or PrivateKey'));
+	}
+}
diff --git a/lib/key.js b/lib/key.js
index 64e24b4..64305fc 100644
--- a/lib/key.js
+++ b/lib/key.js
@@ -31,6 +31,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh'] = require('./formats/ssh');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function Key(opts) {
 	assert.object(opts, 'options');
@@ -105,7 +106,6 @@ Key.prototype.hash = function (algo) {
 
 	if (this._hashCache[algo])
 		return (this._hashCache[algo]);
-
 	var hash = crypto.createHash(algo).
 	    update(this.toBuffer('rfc4253')).digest();
 	this._hashCache[algo] = hash;
diff --git a/lib/private-key.js b/lib/private-key.js
index 36b6f8c..5b05fe0 100644
--- a/lib/private-key.js
+++ b/lib/private-key.js
@@ -37,6 +37,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
 formats['ssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function PrivateKey(opts) {
 	assert.object(opts, 'options');
diff --git a/lib/utils.js b/lib/utils.js
index 466634c..3cf278f 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -5,6 +5,7 @@ module.exports = {
 	addRSAMissing: addRSAMissing,
 	calculateDSAPublic: calculateDSAPublic,
 	mpNormalize: mpNormalize,
+	mpDenormalize: mpDenormalize,
 	ecNormalize: ecNormalize,
 	countZeros: countZeros,
 	assertCompatible: assertCompatible,
@@ -191,6 +192,13 @@ function mpNormalize(buf) {
 	return (buf);
 }
 
+function mpDenormalize(buf) {
+	assert.buffer(buf);
+	while (buf.length > 1 && buf[0] === 0x00)
+		buf = buf.slice(1);
+	return (buf);
+}
+
 function bigintToMpBuf(bigint) {
 	var buf = new Buffer(bigint.toByteArray());
 	buf = mpNormalize(buf);
