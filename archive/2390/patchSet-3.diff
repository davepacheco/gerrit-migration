From 70a0fce034e5d987f311caf0da704336e59bf677 Mon Sep 17 00:00:00 2001
From: Tim Kordas <tim.kordas@joyent.com>
Date: Mon, 14 Aug 2017 14:46:41 -0700
Subject: [PATCH] joyent/node-sshpk#32 support dnssec format

---
 bin/sshpk-conv        |  13 ++-
 lib/dhe.js            |  27 ++++-
 lib/formats/auto.js   |  32 +++++
 lib/formats/dnssec.js | 263 ++++++++++++++++++++++++++++++++++++++++++
 lib/key.js            |   2 +-
 lib/private-key.js    |   1 +
 lib/utils.js          |   8 ++
 test/dnssec.js        | 135 ++++++++++++++++++++++
 8 files changed, 472 insertions(+), 9 deletions(-)
 create mode 100644 lib/formats/dnssec.js
 create mode 100644 test/dnssec.js

diff --git a/bin/sshpk-conv b/bin/sshpk-conv
index 444045a..856a03e 100755
--- a/bin/sshpk-conv
+++ b/bin/sshpk-conv
@@ -1,7 +1,7 @@
 #!/usr/bin/env node
 // -*- mode: js -*-
 // vim: set filetype=javascript :
-// Copyright 2015 Joyent, Inc.  All rights reserved.
+// Copyright 2015 Joyent, Inc.	All rights reserved.
 
 var dashdash = require('dashdash');
 var sshpk = require('../lib/index');
@@ -76,11 +76,12 @@ if (require.main === module) {
 		console.error('sshpk-conv: converts between SSH key formats\n');
 		console.error(help);
 		console.error('\navailable formats:');
-		console.error('  - pem, pkcs1     eg id_rsa');
-		console.error('  - ssh            eg id_rsa.pub');
-		console.error('  - pkcs8          format you want for openssl');
-		console.error('  - openssh        like output of ssh-keygen -o');
-		console.error('  - rfc4253        raw OpenSSH wire format');
+		console.error('	 - pem, pkcs1	  eg id_rsa');
+		console.error('	 - ssh		  eg id_rsa.pub');
+		console.error('	 - pkcs8	  format you want for openssl');
+		console.error('	 - openssh	  like output of ssh-keygen -o');
+		console.error('	 - rfc4253	  raw OpenSSH wire format');
+		console.error('	 - dnssec	  dnssec-keygen format');
 		process.exit(1);
 	}
 
diff --git a/lib/dhe.js b/lib/dhe.js
index b4d3662..84cb2bc 100644
--- a/lib/dhe.js
+++ b/lib/dhe.js
@@ -3,7 +3,8 @@
 module.exports = {
 	DiffieHellman: DiffieHellman,
 	generateECDSA: generateECDSA,
-	generateED25519: generateED25519
+	generateED25519: generateED25519,
+	publicFromPrivateECDSA: publicFromPrivateECDSA
 };
 
 var assert = require('assert-plus');
@@ -369,7 +370,6 @@ function generateECDSA(curve) {
 			parts: parts
 		});
 		return (key);
-
 	} else {
 		if (ecdh === undefined)
 			ecdh = require('ecc-jsbn');
@@ -409,3 +409,26 @@ function generateECDSA(curve) {
 		return (key);
 	}
 }
+
+function publicFromPrivateECDSA(curve, priv) {
+	assert.string(curve, 'curve');
+	assert.buffer(priv);
+	if (ecdh === undefined)
+		ecdh = require('ecc-jsbn');
+	if (ec === undefined)
+		ec = require('ecc-jsbn/lib/ec');
+	if (jsbn === undefined)
+		jsbn = require('jsbn').BigInteger;
+
+	var ecParams = new X9ECParameters(curve);
+	var d = new jsbn(utils.mpNormalize(priv));
+	var pub = ecParams.getG().multiply(d);
+	pub = new Buffer(ecParams.getCurve().encodePointHex(pub), 'hex');
+
+	var parts = [];
+	parts.push({name: 'curve', data: new Buffer(curve)});
+	parts.push({name: 'Q', data: pub});
+
+	var key = new Key({type: 'ecdsa', curve: curve, parts: parts});
+	return (key);
+}
diff --git a/lib/formats/auto.js b/lib/formats/auto.js
index 973c032..7c40838 100644
--- a/lib/formats/auto.js
+++ b/lib/formats/auto.js
@@ -13,6 +13,7 @@ var PrivateKey = require('../private-key');
 var pem = require('./pem');
 var ssh = require('./ssh');
 var rfc4253 = require('./rfc4253');
+var dnssec = require('./dnssec');
 
 function read(buf, options) {
 	if (typeof (buf) === 'string') {
@@ -22,6 +23,8 @@ function read(buf, options) {
 			return (ssh.read(buf, options));
 		if (buf.match(/^\s*ecdsa-/))
 			return (ssh.read(buf, options));
+		if (findDNSSECHeader(buf))
+			return (dnssec.read(buf, options));
 		buf = new Buffer(buf, 'binary');
 	} else {
 		assert.buffer(buf);
@@ -29,6 +32,8 @@ function read(buf, options) {
 			return (pem.read(buf, options));
 		if (findSSHHeader(buf))
 			return (ssh.read(buf, options));
+		if (findDNSSECHeader(buf))
+			return (dnssec.read(buf, options));
 	}
 	if (buf.readUInt32BE(0) < buf.length)
 		return (rfc4253.read(buf, options));
@@ -68,6 +73,33 @@ function findPEMHeader(buf) {
 	return (true);
 }
 
+function findDNSSECHeader(buf) {
+	// private case first
+	var privateKeyHeaderString = 'Private-key-format: v1';
+	if (buf.length <= privateKeyHeaderString.length)
+		return (false);
+	if (buf.slice(0, privateKeyHeaderString.length).toString('ascii')
+	    === privateKeyHeaderString)
+		return (true);
+
+	// public-key RFC3110 ?
+	// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
+	// skip any comment-lines
+	if (typeof (buf) !== 'string') {
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	if (lines[line].toString('ascii').match(/\. IN KEY /))
+		return (true);
+	if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
+		return (true);
+	return (false);
+}
+
 function write(key, options) {
 	throw (new Error('"auto" format cannot be used for writing'));
 }
diff --git a/lib/formats/dnssec.js b/lib/formats/dnssec.js
new file mode 100644
index 0000000..a5563bf
--- /dev/null
+++ b/lib/formats/dnssec.js
@@ -0,0 +1,263 @@
+// Copyright 2017 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	write: write
+};
+
+var assert = require('assert-plus');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var utils = require('../utils');
+var SSHBuffer = require('../ssh-buffer');
+var Dhe = require('../dhe');
+
+var supportedAlgos = {
+	'rsa-sha1' : 5,
+	'rsa-sha256' : 8,
+	'rsa-sha512' : 10,
+	'ecdsa-p256-sha256' : 13,
+	'ecdsa-p384-sha384' : 14
+	/*
+	 * ed25519 is hypothetically supported with id 15
+	 * but the common tools available don't appear to be
+	 * capable of generating/using ed25519 keys
+	 */
+};
+
+var supportedAlgosById = {};
+Object.keys(supportedAlgos).forEach(function (k) {
+	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
+});
+
+function read(buf, options) {
+	if (typeof (buf) !== 'string') {
+		assert.buffer(buf, 'buf');
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	if (lines[0].match(/^Private-key-format\: v1/)) {
+		var algElems = lines[1].split(' ');
+		var algoNum = parseInt(algElems[1], 10);
+		var algoName = algElems[2];
+		if (!supportedAlgosById[algoNum])
+			throw (new Error('Unsupported algorithm: ' + algoName));
+		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
+	}
+
+	// skip any comment-lines
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	if (lines[line].match(/\. IN KEY /) ||
+	    lines[line].match(/\. IN DNSKEY /)) {
+		return (readRFC3110(lines[line]));
+	}
+	throw (new Error('Cannot parse dnssec key'));
+}
+
+function readRFC3110(keyString) {
+	var elems = keyString.split(' ');
+	//unused var flags = parseInt(elems[3], 10);
+	//unused var protocol = parseInt(elems[4], 10);
+	var algorithm = parseInt(elems[5], 10);
+	if (!supportedAlgosById[algorithm])
+		throw (new Error('Unsupported algorithm: ' + algorithm));
+	var base64key = elems.slice(6, elems.length).join();
+	var keyBuffer = Buffer.from(base64key, 'base64');
+	if (supportedAlgosById[algorithm].match(/^RSA/)) {
+		// join the rest of the body into a single base64-blob
+		var publicExponentLen = keyBuffer.readUInt8(0);
+		if (publicExponentLen != 3 && publicExponentLen != 1)
+			throw (new Error('Cannot parse dnssec key: ' +
+			    'unsupported exponent length'));
+
+		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
+		publicExponent = utils.mpNormalize(publicExponent);
+		var modulus = keyBuffer.slice(1+publicExponentLen);
+		modulus = utils.mpNormalize(modulus);
+		// now, make the key
+		var rsaKey = {
+			type: 'rsa',
+			parts: []
+		};
+		rsaKey.parts.push({ name: 'e', data: publicExponent});
+		rsaKey.parts.push({ name: 'n', data: modulus});
+		return (new Key(rsaKey));
+	}
+	if (supportedAlgosById[algorithm].match(/^ECDSA-P384-SHA384/) ||
+	    supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
+			curve = 'nistp256';
+			size = 256;
+		}
+
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'Q', data: utils.ecNormalize(keyBuffer) }
+			]
+		};
+		return (new Key(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' +
+	    supportedAlgosById[algorithm]));
+}
+
+function readDNSSECRSAPrivateKey(elements) {
+	var modulus = Buffer.from(elements[0].split(' ')[1], 'base64');
+	var publicExponent = Buffer.from(elements[1].split(' ')[1], 'base64');
+	var privateExponent = Buffer.from(elements[2].split(' ')[1], 'base64');
+	var prime1 = Buffer.from(elements[3].split(' ')[1], 'base64');
+	var prime2 = Buffer.from(elements[4].split(' ')[1], 'base64');
+	var e1 = Buffer.from(elements[5].split(' ')[1], 'base64');
+	var e2 = Buffer.from(elements[6].split(' ')[1], 'base64');
+	var coefficient = Buffer.from(elements[7].split(' ')[1], 'base64');
+	// now, make the key
+	var key = {
+		type: 'rsa',
+		parts: [
+			{ name: 'e', data: utils.mpNormalize(publicExponent)},
+			{ name: 'n', data: utils.mpNormalize(modulus) },
+			{ name: 'd', data: utils.mpNormalize(privateExponent)},
+			{ name: 'p', data: utils.mpNormalize(prime1) },
+			{ name: 'q', data: utils.mpNormalize(prime2) },
+			{ name: 'dmodp', data: utils.mpNormalize(e1) },
+			{ name: 'dmodq', data: utils.mpNormalize(e2) },
+			{ name: 'iqmp', data: utils.mpNormalize(coefficient) }
+		]
+	};
+	return (new PrivateKey(key));
+}
+
+function readDNSSECPrivateKey(alg, elements) {
+	if (supportedAlgosById[alg].match(/^RSA/)) {
+		return (readDNSSECRSAPrivateKey(elements));
+	}
+	if (supportedAlgosById[alg].match(/^ECDSA-P384-SHA384/) ||
+	    supportedAlgosById[alg].match(/^ECDSA-P256-SHA256/)) {
+		var d = Buffer.from(elements[0].split(' ')[1], 'base64');
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[alg].match(/^ECDSA-P256-SHA256/)) {
+			curve = 'nistp256';
+			size = 256;
+		}
+		// DNSSEC generates the public-key on the fly (go calculate it)
+		var publicKey = Dhe.publicFromPrivateECDSA(curve, d);
+		var Q = publicKey.part['Q'].data;
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'd', data: d },
+				{name: 'Q', data: Q }
+			]
+		};
+		return (new PrivateKey(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
+}
+
+function dnssecTimestamp(date) {
+	var year = date.getFullYear() + ''; //stringify
+	var month = (date.getMonth() + 1);
+	var timestampStr = year + month + date.getUTCDate();
+	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
+	timestampStr += date.getUTCSeconds();
+	return (timestampStr);
+}
+
+function rsaAlgFromOptions(opts) {
+	if (!opts || opts.hashAlgo === 'sha1')
+		return ('5 (RSASHA1)');
+	else if (opts.hashAlgo === 'sha256')
+		return ('8 (RSASHA256)');
+	else if (opts.hashAlgo === 'sha512')
+		return ('10 (RSASHA512)');
+	else
+		throw (new Error('Unknown or unsupported hash: ' +
+		    opts.hashAlgo));
+}
+
+function writeRSA(key, options) {
+	// if we're missing parts, add them.
+	if (!key.part.dmodp || !key.part.dmodq) {
+		utils.addRSAMissing(key);
+	}
+
+	var buf = new SSHBuffer({});
+	buf.writeCString('Private-key-format: v1.3\n');
+	buf.writeCString('Algorithm: ' + rsaAlgFromOptions(options) + '\n');
+
+	var n = utils.mpDenormalize(key.part['n'].data);
+	buf.writeCString('Modulus: ' + n.toString('base64') + '\n');
+	var e = utils.mpDenormalize(key.part['e'].data);
+	buf.writeCString('PublicExponent: ' + e.toString('base64') + '\n');
+	var d = utils.mpDenormalize(key.part['d'].data);
+	buf.writeCString('PrivateExponent: ' + d.toString('base64') + '\n');
+	var p = utils.mpDenormalize(key.part['p'].data);
+	buf.writeCString('Prime1: ' + p.toString('base64') + '\n');
+	var q = utils.mpDenormalize(key.part['q'].data);
+	buf.writeCString('Prime2: ' + q.toString('base64') + '\n');
+	var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
+	buf.writeCString('Exponent1: ' + dmodp.toString('base64') + '\n');
+	var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
+	buf.writeCString('Exponent2: ' + dmodq.toString('base64') + '\n');
+	var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
+	buf.writeCString('Coefficient: ' + iqmp.toString('base64') + '\n');
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	buf.writeCString('Created: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Publish: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Activate: ' + dnssecTimestamp(timestamp) + '\n');
+	return (buf.toBuffer());
+}
+
+function writeECDSA(key, options) {
+	var buf = new SSHBuffer({});
+	buf.writeCString('Private-key-format: v1.3\n');
+
+	if (key.curve === 'nistp256') {
+		buf.writeCString('Algorithm: 13 (ECDSAP256SHA256)\n');
+	} else if (key.curve === 'nistp384') {
+		buf.writeCString('Algorithm: 14 (ECDSAP384SHA384)\n');
+	} else {
+		throw (new Error('Unsupported curve'));
+	}
+	var base64Key = key.part['d'].data.toString('base64');
+	buf.writeCString('PrivateKey: ' + base64Key + '\n');
+
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	buf.writeCString('Created: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Publish: ' + dnssecTimestamp(timestamp) + '\n');
+	buf.writeCString('Activate: ' + dnssecTimestamp(timestamp) + '\n');
+
+	return (buf.toBuffer());
+}
+
+function write(key, options) {
+	if (PrivateKey.isPrivateKey(key)) {
+		if (key.type === 'rsa') {
+			return (writeRSA(key, options));
+		} else if (key.type === 'ecdsa') {
+			return (writeECDSA(key, options));
+		} else {
+			throw (new Error('Unsupported algorithm: ' + key.type));
+		}
+	} else if (Key.isKey(key)) {
+		// RFC3110 requires a keyname, and a keytype
+		throw (new Error('Cannot output RFC3110 without key info'));
+	} else {
+		throw (new Error('key is not a Key or PrivateKey'));
+	}
+}
diff --git a/lib/key.js b/lib/key.js
index 64e24b4..64305fc 100644
--- a/lib/key.js
+++ b/lib/key.js
@@ -31,6 +31,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh'] = require('./formats/ssh');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function Key(opts) {
 	assert.object(opts, 'options');
@@ -105,7 +106,6 @@ Key.prototype.hash = function (algo) {
 
 	if (this._hashCache[algo])
 		return (this._hashCache[algo]);
-
 	var hash = crypto.createHash(algo).
 	    update(this.toBuffer('rfc4253')).digest();
 	this._hashCache[algo] = hash;
diff --git a/lib/private-key.js b/lib/private-key.js
index 36b6f8c..5b05fe0 100644
--- a/lib/private-key.js
+++ b/lib/private-key.js
@@ -37,6 +37,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
 formats['ssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function PrivateKey(opts) {
 	assert.object(opts, 'options');
diff --git a/lib/utils.js b/lib/utils.js
index 466634c..3cf278f 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -5,6 +5,7 @@ module.exports = {
 	addRSAMissing: addRSAMissing,
 	calculateDSAPublic: calculateDSAPublic,
 	mpNormalize: mpNormalize,
+	mpDenormalize: mpDenormalize,
 	ecNormalize: ecNormalize,
 	countZeros: countZeros,
 	assertCompatible: assertCompatible,
@@ -191,6 +192,13 @@ function mpNormalize(buf) {
 	return (buf);
 }
 
+function mpDenormalize(buf) {
+	assert.buffer(buf);
+	while (buf.length > 1 && buf[0] === 0x00)
+		buf = buf.slice(1);
+	return (buf);
+}
+
 function bigintToMpBuf(bigint) {
 	var buf = new Buffer(bigint.toByteArray());
 	buf = mpNormalize(buf);
diff --git a/test/dnssec.js b/test/dnssec.js
new file mode 100644
index 0000000..06690b8
--- /dev/null
+++ b/test/dnssec.js
@@ -0,0 +1,135 @@
+// Copyright 2017 Joyent, Inc.  All rights reserved.
+
+var test = require('tape').test;
+
+var sshpk = require('../lib/index');
+
+/*
+ * Generated with:
+ *     'dnssec-keygen -T KEY -a rsasha1 -b 1024 -n USER rsatest'
+ *
+ * which outputs two files named 'Krsatest.+005+57206.private' and
+ * 'Krsatest.+005+57206.key'
+ */
+var DNSSEC_RSA =
+    'Private-key-format: v1.3\n' +
+    'Algorithm: 5 (RSASHA1)\n' +
+    'Modulus: 1cNqdYrUKnXwdoUg7mgOCUYTvxv1n+tEy7JdsFiyrLcVqRxH4SyUeWKijcisNklDdl' +
+    'ZDXkz3bn4jKfDHgKgsbPSYdn3sQbpjSzQVzzAJMv9Tgy9b801e1RAHJ1Bz4D0YaOi1dfxMLrJwY' +
+    'jO490mw/6UMh9NmxLuWhUZdvib+Fz0=\n' +
+    'PublicExponent: AQAB\n' +
+    'PrivateExponent: YNB6vPW9leWInQU6nv99q/GTK/EL0/wIUoFcMWxasCLTqp3maDN6o2dq2/' +
+    'BRHt0bstLq/CC7x81VO7+Te8+vHm3aHK8GQIuEExtJo/ydulUPFnMmmZa6kAFVrTvKs09+KAu93' +
+    'K+bGch9zvPw51uKMiqAvOsYhvqHf/Pi2qxY5YE=\n' +
+    'Prime1: 60nLFtb3pMo4xVJXCBTtkvB8JAiIyskccBvZfTR2urc8h1fciI3JjC8AfgMszPdHEGBR+jndXfbBLsQQl4hPkQ==\n' +
+    'Prime2: 6JSPWFx7WdlSMT7PQ45NF7bHM6Vp8lfXQr1zLMpdXS1O3Oy3BbpqbmnjaToeNmcvRMPhtOeK9912nNiHxgqO7Q==\n' +
+    'Exponent1: atUVxqgSx5seTdIGPGAsQwS4iS/q1JCePfUXOndg1YSvkhB9zO78LY+F3LGaXPKGLNRfRIuTjL+mlZJmqjc1UQ==\n' +
+    'Exponent2: K4QQRfIXyjnVHQ2pbfRkDDnQj6M1bXht+DjGIe1DBroBdWh83f+BBmOdfwS2vmsT9wPHaTehUrsHBFWnIbC8CQ==\n' +
+    'Coefficient: pMpjuudK7SoTi80t8JVr6x4kZdR73PVr9TVw60lZDCbsRjojEIpE08fuZ29/7aYCa5FHXF2xNEynjL5jepM6jA==\n' +
+    'Created: 20170814221729\n' +
+    'Publish: 20170814221729\n' +
+    'Activate: 20170814221729\n';
+
+var DNSSEC_RSA_PUB =
+    'rsatest. IN KEY 0 3 5 AwEAAdXDanWK1Cp18HaFIO5oDglGE78b9Z/rRMuyXbBYsqy3FakcR+Es ' +
+    'lHlioo3IrDZJQ3ZWQ15M925+Iynwx4CoLGz0mHZ97EG6Y0s0Fc8wCTL/ ' +
+    'U4MvW/NNXtUQBydQc+A9GGjotXX8TC6ycGIzuPdJsP+lDIfTZsS7loVG Xb4m/hc9';
+
+// same key as above, different format
+var PEM_RSA =
+    '-----BEGIN RSA PRIVATE KEY-----\n' +
+    'MIICXAIBAAKBgQDVw2p1itQqdfB2hSDuaA4JRhO/G/Wf60TLsl2wWLKstxWpHEfh\n' +
+    'LJR5YqKNyKw2SUN2VkNeTPdufiMp8MeAqCxs9Jh2fexBumNLNBXPMAky/1ODL1vz\n' +
+    'TV7VEAcnUHPgPRho6LV1/EwusnBiM7j3SbD/pQyH02bEu5aFRl2+Jv4XPQIDAQAB\n' +
+    'AoGAYNB6vPW9leWInQU6nv99q/GTK/EL0/wIUoFcMWxasCLTqp3maDN6o2dq2/BR\n' +
+    'Ht0bstLq/CC7x81VO7+Te8+vHm3aHK8GQIuEExtJo/ydulUPFnMmmZa6kAFVrTvK\n' +
+    's09+KAu93K+bGch9zvPw51uKMiqAvOsYhvqHf/Pi2qxY5YECQQDvvUxEkNf/ns6a\n' +
+    'zPlpS8G38MYbzGdRFHEjmlIJ9pkej/uLqyik/ojGZt9HIxZI91IYYkYwgnAXNrB9\n' +
+    'DiNkDzrBAkEA6N9rydvXo8m0PWqE0E5nY4wSiQqxNOFQJ3U0P7hDxSXcx+Mig/dF\n' +
+    '9MRA8eoYzH/7Nh3Vi/hYekTOrybmsn7L4wJATSyp5ZSfA9mydqCvVVceyEDI9V/q\n' +
+    'jm4/MY/XAwAQMId3GXICxoJtszigfbzsypZbJiBUqf8DaGWhkNBBUk+YwQJAR4nj\n' +
+    'ThbITxu20Cs589gyMMWmKA1t1OXmvshlrbGIuDbidVGUl9/N0Ny9atPUnHYwkTZn\n' +
+    'FOHNJHqg1/PmaS1EqwJBAMs2YLS1JGZsKsZPUCBtPBYxpT6CDfiKYnWT6EB1vNAg\n' +
+    'Evn/LrabG1dR6lMpcLrxezMlHSfFsMr31EG7ohfM7ME=\n' +
+    '-----END RSA PRIVATE KEY-----\n';
+
+var PEM_RSA_PUB =
+    '-----BEGIN PUBLIC KEY-----\n' +
+    'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVw2p1itQqdfB2hSDuaA4JRhO/\n' +
+    'G/Wf60TLsl2wWLKstxWpHEfhLJR5YqKNyKw2SUN2VkNeTPdufiMp8MeAqCxs9Jh2\n' +
+    'fexBumNLNBXPMAky/1ODL1vzTV7VEAcnUHPgPRho6LV1/EwusnBiM7j3SbD/pQyH\n' +
+    '02bEu5aFRl2+Jv4XPQIDAQAB\n' +
+    '-----END PUBLIC KEY-----\n';
+
+/*
+ * Generated with:
+ *     'dnssec-keygen -T KEY -a ECDSAP256SHA256 -n USER ecdsatest'
+ *
+ * which outputs two files named 'Kecdsatest.+013+43896.private' and
+ * 'Kecdsatest.+013+43896.key'
+ */
+var DNSSEC_ECDSA =
+    'Private-key-format: v1.3\n' +
+    'Algorithm: 13 (ECDSAP256SHA256)\n' +
+    'PrivateKey: uLpudyhy2gElB3DeMkqX5xjfSV8AwYOO4uUj9hHuCt8=\n' +
+    'Created: 20170814234326\n' +
+    'Publish: 20170814234326\n' +
+    'Activate: 20170814234326';
+var DNSSEC_ECDSA_PUB =
+    'ecdsatest. IN KEY 0 3 13 es1l0ZlSrePQHoKVPXcefo6ExgKfO+KkoT57saLvugu1GrnwHRpNmvk6 yOjQeu865o5vI+wtar62A5mgSf/fvQ==';
+// Same key as above, as PEM
+var PEM_ECDSA =
+    '-----BEGIN EC PRIVATE KEY-----\n' +
+    'MHcCAQEEILi6bncoctoBJQdw3jJKl+cY30lfAMGDjuLlI/YR7grfoAoGCCqGSM49\n' +
+    'AwEHoUQDQgAEes1l0ZlSrePQHoKVPXcefo6ExgKfO+KkoT57saLvugu1GrnwHRpN\n' +
+    'mvk6yOjQeu865o5vI+wtar62A5mgSf/fvQ==\n' +
+    '-----END EC PRIVATE KEY-----\n'
+
+var PEM_ECDSA_PUB =
+    '-----BEGIN PUBLIC KEY-----\n' +
+    'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEes1l0ZlSrePQHoKVPXcefo6ExgKf\n' +
+    'O+KkoT57saLvugu1GrnwHRpNmvk6yOjQeu865o5vI+wtar62A5mgSf/fvQ==\n' +
+    '-----END PUBLIC KEY-----\n'
+
+///--- Tests
+test('1024b dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'dnssec');
+	t.equal(k.toString('pem'), PEM_RSA);
+	t.end();
+});
+
+test('1024b dnssec to pem public key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'dnssec');
+	t.equal(k.toPublic().toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('1024b dnssec public key to pem', function(t) {
+	var k = sshpk.parseKey(DNSSEC_RSA_PUB, 'dnssec');
+	t.equal(k.toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('1024b auto dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'auto');
+	t.equal(k.toString('pem'), PEM_RSA);
+	t.end();
+});
+
+test('1024b auto dnssec public key to pem', function(t) {
+	var k = sshpk.parseKey(DNSSEC_RSA_PUB, 'auto');
+	t.equal(k.toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('ecdsa dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_ECDSA, 'dnssec');
+	t.equal(k.toString('pem'), PEM_ECDSA);
+	t.end();
+});
+
+test('ecdsa dnssec to pem public key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_ECDSA, 'dnssec');
+	t.equal(k.toPublic().toString('pem'), PEM_ECDSA_PUB);
+	t.end();
+});
-- 
2.21.0

