commit a3835dbd3014be44bce904321d794e3412a5735b (refs/changes/90/2390/5)
Author: Tim Kordas <tim.kordas@joyent.com>
Date:   2017-08-17T10:55:05-07:00 (2 years, 2 months ago)
    
    joyent/node-sshpk#32 support dnssec format

diff --git a/bin/sshpk-conv b/bin/sshpk-conv
index 444045a..856a03e 100755
--- a/bin/sshpk-conv
+++ b/bin/sshpk-conv
@@ -1,7 +1,7 @@
 #!/usr/bin/env node
 // -*- mode: js -*-
 // vim: set filetype=javascript :
-// Copyright 2015 Joyent, Inc.  All rights reserved.
+// Copyright 2015 Joyent, Inc.	All rights reserved.
 
 var dashdash = require('dashdash');
 var sshpk = require('../lib/index');
@@ -76,11 +76,12 @@ if (require.main === module) {
 		console.error('sshpk-conv: converts between SSH key formats\n');
 		console.error(help);
 		console.error('\navailable formats:');
-		console.error('  - pem, pkcs1     eg id_rsa');
-		console.error('  - ssh            eg id_rsa.pub');
-		console.error('  - pkcs8          format you want for openssl');
-		console.error('  - openssh        like output of ssh-keygen -o');
-		console.error('  - rfc4253        raw OpenSSH wire format');
+		console.error('	 - pem, pkcs1	  eg id_rsa');
+		console.error('	 - ssh		  eg id_rsa.pub');
+		console.error('	 - pkcs8	  format you want for openssl');
+		console.error('	 - openssh	  like output of ssh-keygen -o');
+		console.error('	 - rfc4253	  raw OpenSSH wire format');
+		console.error('	 - dnssec	  dnssec-keygen format');
 		process.exit(1);
 	}
 
diff --git a/lib/dhe.js b/lib/dhe.js
index b4d3662..f94a583 100644
--- a/lib/dhe.js
+++ b/lib/dhe.js
@@ -369,7 +369,6 @@ function generateECDSA(curve) {
 			parts: parts
 		});
 		return (key);
-
 	} else {
 		if (ecdh === undefined)
 			ecdh = require('ecc-jsbn');
diff --git a/lib/formats/auto.js b/lib/formats/auto.js
index 973c032..3986571 100644
--- a/lib/formats/auto.js
+++ b/lib/formats/auto.js
@@ -13,6 +13,9 @@ var PrivateKey = require('../private-key');
 var pem = require('./pem');
 var ssh = require('./ssh');
 var rfc4253 = require('./rfc4253');
+var dnssec = require('./dnssec');
+
+var DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';
 
 function read(buf, options) {
 	if (typeof (buf) === 'string') {
@@ -22,6 +25,8 @@ function read(buf, options) {
 			return (ssh.read(buf, options));
 		if (buf.match(/^\s*ecdsa-/))
 			return (ssh.read(buf, options));
+		if (findDNSSECHeader(buf))
+			return (dnssec.read(buf, options));
 		buf = new Buffer(buf, 'binary');
 	} else {
 		assert.buffer(buf);
@@ -29,6 +34,8 @@ function read(buf, options) {
 			return (pem.read(buf, options));
 		if (findSSHHeader(buf))
 			return (ssh.read(buf, options));
+		if (findDNSSECHeader(buf))
+			return (dnssec.read(buf, options));
 	}
 	if (buf.readUInt32BE(0) < buf.length)
 		return (rfc4253.read(buf, options));
@@ -68,6 +75,32 @@ function findPEMHeader(buf) {
 	return (true);
 }
 
+function findDNSSECHeader(buf) {
+	// private case first
+	if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
+		return (false);
+	var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
+	if (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)
+		return (true);
+
+	// public-key RFC3110 ?
+	// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
+	// skip any comment-lines
+	if (typeof (buf) !== 'string') {
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	if (lines[line].toString('ascii').match(/\. IN KEY /))
+		return (true);
+	if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
+		return (true);
+	return (false);
+}
+
 function write(key, options) {
 	throw (new Error('"auto" format cannot be used for writing'));
 }
diff --git a/lib/formats/dnssec.js b/lib/formats/dnssec.js
new file mode 100644
index 0000000..e077d73
--- /dev/null
+++ b/lib/formats/dnssec.js
@@ -0,0 +1,286 @@
+// Copyright 2017 Joyent, Inc.
+
+module.exports = {
+	read: read,
+	write: write
+};
+
+var assert = require('assert-plus');
+var Key = require('../key');
+var PrivateKey = require('../private-key');
+var utils = require('../utils');
+var SSHBuffer = require('../ssh-buffer');
+var Dhe = require('../dhe');
+
+var supportedAlgos = {
+	'rsa-sha1' : 5,
+	'rsa-sha256' : 8,
+	'rsa-sha512' : 10,
+	'ecdsa-p256-sha256' : 13,
+	'ecdsa-p384-sha384' : 14
+	/*
+	 * ed25519 is hypothetically supported with id 15
+	 * but the common tools available don't appear to be
+	 * capable of generating/using ed25519 keys
+	 */
+};
+
+var supportedAlgosById = {};
+Object.keys(supportedAlgos).forEach(function (k) {
+	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
+});
+
+function read(buf, options) {
+	if (typeof (buf) !== 'string') {
+		assert.buffer(buf, 'buf');
+		buf = buf.toString('ascii');
+	}
+	var lines = buf.split('\n');
+	if (lines[0].match(/^Private-key-format\: v1/)) {
+		var algElems = lines[1].split(' ');
+		var algoNum = parseInt(algElems[1], 10);
+		var algoName = algElems[2];
+		if (!supportedAlgosById[algoNum])
+			throw (new Error('Unsupported algorithm: ' + algoName));
+		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
+	}
+
+	// skip any comment-lines
+	var line = 0;
+	/* JSSTYLED */
+	while (lines[line].match(/^\;/))
+		line++;
+	// we should now have *one single* line left with our KEY on it.
+	if ((lines[line].match(/\. IN KEY /) ||
+	    lines[line].match(/\. IN DNSKEY /)) && lines[line+1].length === 0) {
+		return (readRFC3110(lines[line]));
+	}
+	throw (new Error('Cannot parse dnssec key'));
+}
+
+function readRFC3110(keyString) {
+	var elems = keyString.split(' ');
+	//unused var flags = parseInt(elems[3], 10);
+	//unused var protocol = parseInt(elems[4], 10);
+	var algorithm = parseInt(elems[5], 10);
+	if (!supportedAlgosById[algorithm])
+		throw (new Error('Unsupported algorithm: ' + algorithm));
+	var base64key = elems.slice(6, elems.length).join();
+	var keyBuffer = Buffer.from(base64key, 'base64');
+	if (supportedAlgosById[algorithm].match(/^RSA-/)) {
+		// join the rest of the body into a single base64-blob
+		var publicExponentLen = keyBuffer.readUInt8(0);
+		if (publicExponentLen != 3 && publicExponentLen != 1)
+			throw (new Error('Cannot parse dnssec key: ' +
+			    'unsupported exponent length'));
+
+		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
+		publicExponent = utils.mpNormalize(publicExponent);
+		var modulus = keyBuffer.slice(1+publicExponentLen);
+		modulus = utils.mpNormalize(modulus);
+		// now, make the key
+		var rsaKey = {
+			type: 'rsa',
+			parts: []
+		};
+		rsaKey.parts.push({ name: 'e', data: publicExponent});
+		rsaKey.parts.push({ name: 'n', data: modulus});
+		return (new Key(rsaKey));
+	}
+	if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
+	    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
+			curve = 'nistp256';
+			size = 256;
+		}
+
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'Q', data: utils.ecNormalize(keyBuffer) }
+			]
+		};
+		return (new Key(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' +
+	    supportedAlgosById[algorithm]));
+}
+
+function elementToBuf(e) {
+	return (Buffer.from(e.split(' ')[1], 'base64'));
+}
+
+function readDNSSECRSAPrivateKey(elements) {
+	var rsaParams = {};
+	elements.forEach(function (element) {
+		if (element.split(' ')[0] === 'Modulus:')
+			rsaParams['n'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'PublicExponent:')
+			rsaParams['e'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'PrivateExponent:')
+			rsaParams['d'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'Prime1:')
+			rsaParams['p'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'Prime2:')
+			rsaParams['q'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'Exponent1:')
+			rsaParams['dmodp'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'Exponent2:')
+			rsaParams['dmodq'] = elementToBuf(element);
+		else if (element.split(' ')[0] === 'Coefficient:')
+			rsaParams['iqmp'] = elementToBuf(element);
+	});
+	// now, make the key
+	var key = {
+		type: 'rsa',
+		parts: [
+			{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},
+			{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},
+			{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},
+			{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},
+			{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},
+			{ name: 'dmodp',
+			    data: utils.mpNormalize(rsaParams['dmodp'])},
+			{ name: 'dmodq',
+			    data: utils.mpNormalize(rsaParams['dmodq'])},
+			{ name: 'iqmp',
+			    data: utils.mpNormalize(rsaParams['iqmp'])}
+		]
+	};
+	return (new PrivateKey(key));
+}
+
+function readDNSSECPrivateKey(alg, elements) {
+	if (supportedAlgosById[alg].match(/^RSA-/)) {
+		return (readDNSSECRSAPrivateKey(elements));
+	}
+	if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
+	    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
+		var d = Buffer.from(elements[0].split(' ')[1], 'base64');
+		var curve = 'nistp384';
+		var size = 384;
+		if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
+			curve = 'nistp256';
+			size = 256;
+		}
+		// DNSSEC generates the public-key on the fly (go calculate it)
+		var publicKey = utils.publicFromPrivateECDSA(curve, d);
+		var Q = publicKey.part['Q'].data;
+		var ecdsaKey = {
+			type: 'ecdsa',
+			curve: curve,
+			size: size,
+			parts: [
+				{name: 'curve', data: Buffer.from(curve) },
+				{name: 'd', data: d },
+				{name: 'Q', data: Q }
+			]
+		};
+		return (new PrivateKey(ecdsaKey));
+	}
+	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
+}
+
+function dnssecTimestamp(date) {
+	var year = date.getFullYear() + ''; //stringify
+	var month = (date.getMonth() + 1);
+	var timestampStr = year + month + date.getUTCDate();
+	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
+	timestampStr += date.getUTCSeconds();
+	return (timestampStr);
+}
+
+function rsaAlgFromOptions(opts) {
+	if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
+		return ('5 (RSASHA1)');
+	else if (opts.hashAlgo === 'sha256')
+		return ('8 (RSASHA256)');
+	else if (opts.hashAlgo === 'sha512')
+		return ('10 (RSASHA512)');
+	else
+		throw (new Error('Unknown or unsupported hash: ' +
+		    opts.hashAlgo));
+}
+
+function writeRSA(key, options) {
+	// if we're missing parts, add them.
+	if (!key.part.dmodp || !key.part.dmodq) {
+		utils.addRSAMissing(key);
+	}
+
+	var out = '';
+	out += 'Private-key-format: v1.3\n';
+	out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
+	var n = utils.mpDenormalize(key.part['n'].data);
+	out += 'Modulus: ' + n.toString('base64') + '\n';
+	var e = utils.mpDenormalize(key.part['e'].data);
+	out += 'PublicExponent: ' + e.toString('base64') + '\n';
+	var d = utils.mpDenormalize(key.part['d'].data);
+	out += 'PrivateExponent: ' + d.toString('base64') + '\n';
+	var p = utils.mpDenormalize(key.part['p'].data);
+	out += 'Prime1: ' + p.toString('base64') + '\n';
+	var q = utils.mpDenormalize(key.part['q'].data);
+	out += 'Prime2: ' + q.toString('base64') + '\n';
+	var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
+	out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
+	var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
+	out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
+	var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
+	out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
+	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
+	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
+	return (Buffer.from(out, 'ascii'));
+}
+
+function writeECDSA(key, options) {
+	var out = '';
+	out += 'Private-key-format: v1.3\n';
+
+	if (key.curve === 'nistp256') {
+		out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
+	} else if (key.curve === 'nistp384') {
+		out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
+	} else {
+		throw (new Error('Unsupported curve'));
+	}
+	var base64Key = key.part['d'].data.toString('base64');
+	out += 'PrivateKey: ' + base64Key + '\n';
+
+	// Assume that we're valid as-of now
+	var timestamp = new Date();
+	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
+	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
+	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
+
+	return (Buffer.from(out, 'ascii'));
+}
+
+function write(key, options) {
+	if (PrivateKey.isPrivateKey(key)) {
+		if (key.type === 'rsa') {
+			return (writeRSA(key, options));
+		} else if (key.type === 'ecdsa') {
+			return (writeECDSA(key, options));
+		} else {
+			throw (new Error('Unsupported algorithm: ' + key.type));
+		}
+	} else if (Key.isKey(key)) {
+		/*
+		 * RFC3110 requires a keyname, and a keytype, which we
+		 * don't really have a mechanism for specifying such
+		 * additional metadata.
+		 */
+		throw (new Error('Format "dnssec" only supports ' +
+		    'writing private keys'));
+	} else {
+		throw (new Error('key is not a Key or PrivateKey'));
+	}
+}
diff --git a/lib/key.js b/lib/key.js
index 64e24b4..64305fc 100644
--- a/lib/key.js
+++ b/lib/key.js
@@ -31,6 +31,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh'] = require('./formats/ssh');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function Key(opts) {
 	assert.object(opts, 'options');
@@ -105,7 +106,6 @@ Key.prototype.hash = function (algo) {
 
 	if (this._hashCache[algo])
 		return (this._hashCache[algo]);
-
 	var hash = crypto.createHash(algo).
 	    update(this.toBuffer('rfc4253')).digest();
 	this._hashCache[algo] = hash;
diff --git a/lib/private-key.js b/lib/private-key.js
index 36b6f8c..5b05fe0 100644
--- a/lib/private-key.js
+++ b/lib/private-key.js
@@ -37,6 +37,7 @@ formats['rfc4253'] = require('./formats/rfc4253');
 formats['ssh-private'] = require('./formats/ssh-private');
 formats['openssh'] = formats['ssh-private'];
 formats['ssh'] = formats['ssh-private'];
+formats['dnssec'] = require('./formats/dnssec');
 
 function PrivateKey(opts) {
 	assert.object(opts, 'options');
diff --git a/lib/utils.js b/lib/utils.js
index 466634c..0eccaab 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -5,17 +5,23 @@ module.exports = {
 	addRSAMissing: addRSAMissing,
 	calculateDSAPublic: calculateDSAPublic,
 	mpNormalize: mpNormalize,
+	mpDenormalize: mpDenormalize,
 	ecNormalize: ecNormalize,
 	countZeros: countZeros,
 	assertCompatible: assertCompatible,
 	isCompatible: isCompatible,
 	opensslKeyDeriv: opensslKeyDeriv,
-	opensshCipherInfo: opensshCipherInfo
+	opensshCipherInfo: opensshCipherInfo,
+	publicFromPrivateECDSA: publicFromPrivateECDSA
 };
 
 var assert = require('assert-plus');
 var PrivateKey = require('./private-key');
+var Key = require('./key');
 var crypto = require('crypto');
+var algs = require('./algs');
+
+var ec, jsbn;
 
 var MAX_CLASS_DEPTH = 3;
 
@@ -191,6 +197,13 @@ function mpNormalize(buf) {
 	return (buf);
 }
 
+function mpDenormalize(buf) {
+	assert.buffer(buf);
+	while (buf.length > 1 && buf[0] === 0x00)
+		buf = buf.slice(1);
+	return (buf);
+}
+
 function bigintToMpBuf(bigint) {
 	var buf = new Buffer(bigint.toByteArray());
 	buf = mpNormalize(buf);
@@ -246,6 +259,32 @@ function addRSAMissing(key) {
 	}
 }
 
+function publicFromPrivateECDSA(curveName, priv) {
+	assert.string(curveName, 'curveName');
+	assert.buffer(priv);
+	if (ec === undefined)
+		ec = require('ecc-jsbn/lib/ec');
+	if (jsbn === undefined)
+		jsbn = require('jsbn').BigInteger;
+	var params = algs.curves[curveName];
+	var p = new jsbn(params.p);
+	var a = new jsbn(params.a);
+	var b = new jsbn(params.b);
+	var curve = new ec.ECCurveFp(p, a, b);
+	var G = curve.decodePointHex(params.G.toString('hex'));
+
+	var d = new jsbn(mpNormalize(priv));
+	var pub = G.multiply(d);
+	pub = new Buffer(curve.encodePointHex(pub), 'hex');
+
+	var parts = [];
+	parts.push({name: 'curve', data: new Buffer(curveName)});
+	parts.push({name: 'Q', data: pub});
+
+	var key = new Key({type: 'ecdsa', curve: curve, parts: parts});
+	return (key);
+}
+
 function opensshCipherInfo(cipher) {
 	var inf = {};
 	switch (cipher) {
diff --git a/test/assets/Kecdsatest.+013+43896.key b/test/assets/Kecdsatest.+013+43896.key
new file mode 100644
index 0000000..f3172bb
--- /dev/null
+++ b/test/assets/Kecdsatest.+013+43896.key
@@ -0,0 +1 @@
+ecdsatest. IN KEY 0 3 13 es1l0ZlSrePQHoKVPXcefo6ExgKfO+KkoT57saLvugu1GrnwHRpNmvk6 yOjQeu865o5vI+wtar62A5mgSf/fvQ==
diff --git a/test/assets/Kecdsatest.+013+43896.pem b/test/assets/Kecdsatest.+013+43896.pem
new file mode 100644
index 0000000..11cd6e1
--- /dev/null
+++ b/test/assets/Kecdsatest.+013+43896.pem
@@ -0,0 +1,5 @@
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEILi6bncoctoBJQdw3jJKl+cY30lfAMGDjuLlI/YR7grfoAoGCCqGSM49
+AwEHoUQDQgAEes1l0ZlSrePQHoKVPXcefo6ExgKfO+KkoT57saLvugu1GrnwHRpN
+mvk6yOjQeu865o5vI+wtar62A5mgSf/fvQ==
+-----END EC PRIVATE KEY-----
diff --git a/test/assets/Kecdsatest.+013+43896.private b/test/assets/Kecdsatest.+013+43896.private
new file mode 100644
index 0000000..57fd5cc
--- /dev/null
+++ b/test/assets/Kecdsatest.+013+43896.private
@@ -0,0 +1,6 @@
+Private-key-format: v1.3
+Algorithm: 13 (ECDSAP256SHA256)
+PrivateKey: uLpudyhy2gElB3DeMkqX5xjfSV8AwYOO4uUj9hHuCt8=
+Created: 20170814234326
+Publish: 20170814234326
+Activate: 20170814234326
diff --git a/test/assets/Kecdsatest.+013+43896_pub.pem b/test/assets/Kecdsatest.+013+43896_pub.pem
new file mode 100644
index 0000000..b549075
--- /dev/null
+++ b/test/assets/Kecdsatest.+013+43896_pub.pem
@@ -0,0 +1,4 @@
+-----BEGIN PUBLIC KEY-----
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEes1l0ZlSrePQHoKVPXcefo6ExgKf
+O+KkoT57saLvugu1GrnwHRpNmvk6yOjQeu865o5vI+wtar62A5mgSf/fvQ==
+-----END PUBLIC KEY-----
diff --git a/test/assets/Krsatest.+005+57206.key b/test/assets/Krsatest.+005+57206.key
new file mode 100644
index 0000000..fa9535b
--- /dev/null
+++ b/test/assets/Krsatest.+005+57206.key
@@ -0,0 +1 @@
+rsatest. IN KEY 0 3 5 AwEAAdXDanWK1Cp18HaFIO5oDglGE78b9Z/rRMuyXbBYsqy3FakcR+Es lHlioo3IrDZJQ3ZWQ15M925+Iynwx4CoLGz0mHZ97EG6Y0s0Fc8wCTL/ U4MvW/NNXtUQBydQc+A9GGjotXX8TC6ycGIzuPdJsP+lDIfTZsS7loVG Xb4m/hc9
diff --git a/test/assets/Krsatest.+005+57206.pem b/test/assets/Krsatest.+005+57206.pem
new file mode 100644
index 0000000..0acfbc8
--- /dev/null
+++ b/test/assets/Krsatest.+005+57206.pem
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQDVw2p1itQqdfB2hSDuaA4JRhO/G/Wf60TLsl2wWLKstxWpHEfh
+LJR5YqKNyKw2SUN2VkNeTPdufiMp8MeAqCxs9Jh2fexBumNLNBXPMAky/1ODL1vz
+TV7VEAcnUHPgPRho6LV1/EwusnBiM7j3SbD/pQyH02bEu5aFRl2+Jv4XPQIDAQAB
+AoGAYNB6vPW9leWInQU6nv99q/GTK/EL0/wIUoFcMWxasCLTqp3maDN6o2dq2/BR
+Ht0bstLq/CC7x81VO7+Te8+vHm3aHK8GQIuEExtJo/ydulUPFnMmmZa6kAFVrTvK
+s09+KAu93K+bGch9zvPw51uKMiqAvOsYhvqHf/Pi2qxY5YECQQDrScsW1vekyjjF
+UlcIFO2S8HwkCIjKyRxwG9l9NHa6tzyHV9yIjcmMLwB+AyzM90cQYFH6Od1d9sEu
+xBCXiE+RAkEA6JSPWFx7WdlSMT7PQ45NF7bHM6Vp8lfXQr1zLMpdXS1O3Oy3Bbpq
+bmnjaToeNmcvRMPhtOeK9912nNiHxgqO7QJAatUVxqgSx5seTdIGPGAsQwS4iS/q
+1JCePfUXOndg1YSvkhB9zO78LY+F3LGaXPKGLNRfRIuTjL+mlZJmqjc1UQJAK4QQ
+RfIXyjnVHQ2pbfRkDDnQj6M1bXht+DjGIe1DBroBdWh83f+BBmOdfwS2vmsT9wPH
+aTehUrsHBFWnIbC8CQJBAKTKY7rnSu0qE4vNLfCVa+seJGXUe9z1a/U1cOtJWQwm
+7EY6IxCKRNPH7mdvf+2mAmuRR1xdsTRMp4y+Y3qTOow=
+-----END RSA PRIVATE KEY-----
diff --git a/test/assets/Krsatest.+005+57206.private b/test/assets/Krsatest.+005+57206.private
new file mode 100644
index 0000000..c5f0f83
--- /dev/null
+++ b/test/assets/Krsatest.+005+57206.private
@@ -0,0 +1,13 @@
+Private-key-format: v1.3
+Algorithm: 5 (RSASHA1)
+Modulus: 1cNqdYrUKnXwdoUg7mgOCUYTvxv1n+tEy7JdsFiyrLcVqRxH4SyUeWKijcisNklDdlZDXkz3bn4jKfDHgKgsbPSYdn3sQbpjSzQVzzAJMv9Tgy9b801e1RAHJ1Bz4D0YaOi1dfxMLrJwYjO490mw/6UMh9NmxLuWhUZdvib+Fz0=
+PublicExponent: AQAB
+PrivateExponent: YNB6vPW9leWInQU6nv99q/GTK/EL0/wIUoFcMWxasCLTqp3maDN6o2dq2/BRHt0bstLq/CC7x81VO7+Te8+vHm3aHK8GQIuEExtJo/ydulUPFnMmmZa6kAFVrTvKs09+KAu93K+bGch9zvPw51uKMiqAvOsYhvqHf/Pi2qxY5YE=
+Prime1: 60nLFtb3pMo4xVJXCBTtkvB8JAiIyskccBvZfTR2urc8h1fciI3JjC8AfgMszPdHEGBR+jndXfbBLsQQl4hPkQ==
+Prime2: 6JSPWFx7WdlSMT7PQ45NF7bHM6Vp8lfXQr1zLMpdXS1O3Oy3BbpqbmnjaToeNmcvRMPhtOeK9912nNiHxgqO7Q==
+Exponent1: atUVxqgSx5seTdIGPGAsQwS4iS/q1JCePfUXOndg1YSvkhB9zO78LY+F3LGaXPKGLNRfRIuTjL+mlZJmqjc1UQ==
+Exponent2: K4QQRfIXyjnVHQ2pbfRkDDnQj6M1bXht+DjGIe1DBroBdWh83f+BBmOdfwS2vmsT9wPHaTehUrsHBFWnIbC8CQ==
+Coefficient: pMpjuudK7SoTi80t8JVr6x4kZdR73PVr9TVw60lZDCbsRjojEIpE08fuZ29/7aYCa5FHXF2xNEynjL5jepM6jA==
+Created: 20170814221729
+Publish: 20170814221729
+Activate: 20170814221729
diff --git a/test/assets/Krsatest.+005+57206_pub.pem b/test/assets/Krsatest.+005+57206_pub.pem
new file mode 100644
index 0000000..533b859
--- /dev/null
+++ b/test/assets/Krsatest.+005+57206_pub.pem
@@ -0,0 +1,6 @@
+-----BEGIN PUBLIC KEY-----
+MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVw2p1itQqdfB2hSDuaA4JRhO/
+G/Wf60TLsl2wWLKstxWpHEfhLJR5YqKNyKw2SUN2VkNeTPdufiMp8MeAqCxs9Jh2
+fexBumNLNBXPMAky/1ODL1vzTV7VEAcnUHPgPRho6LV1/EwusnBiM7j3SbD/pQyH
+02bEu5aFRl2+Jv4XPQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/test/dnssec.js b/test/dnssec.js
new file mode 100644
index 0000000..9eb56ac
--- /dev/null
+++ b/test/dnssec.js
@@ -0,0 +1,134 @@
+// Copyright 2017 Joyent, Inc.	All rights reserved.
+
+var test = require('tape').test;
+var fs = require('fs');
+var path = require('path');
+var sshpk = require('../lib/index');
+var testDir = path.join(__dirname, 'assets');
+
+/*
+ * Generated with:
+ *     'dnssec-keygen -T KEY -a rsasha1 -b 1024 -n USER rsatest'
+ *
+ * which outputs two files named 'Krsatest.+005+57206.private' and
+ * 'Krsatest.+005+57206.key'
+ */
+var DNSSEC_RSA, DNSSEC_RSA_PUB, PEM_RSA, PEM_RSA_PUB;
+
+/*
+ * Generated with:
+ *     'dnssec-keygen -T KEY -a ECDSAP256SHA256 -n USER ecdsatest'
+ *
+ * which outputs two files named 'Kecdsatest.+013+43896.private' and
+ * 'Kecdsatest.+013+43896.key'
+ */
+var DNSSEC_ECDSA, DNSSEC_ECDSA_PUB, PEM_ECDSA, PEM_ECDSA_PUB;
+
+function readAsString(f) {
+        var s = fs.readFileSync(path.join(testDir, f));
+        return s.toString('utf8');
+}
+
+test('setup', function (t) {
+        DNSSEC_RSA = readAsString('Krsatest.+005+57206.private');
+        DNSSEC_RSA_PUB = readAsString('Krsatest.+005+57206.key');
+        PEM_RSA = readAsString('Krsatest.+005+57206.pem');
+        PEM_RSA_PUB = readAsString('Krsatest.+005+57206_pub.pem');
+
+        DNSSEC_ECDSA = readAsString('Kecdsatest.+013+43896.private');
+        DNSSEC_ECDSA_PUB = readAsString('Kecdsatest.+013+43896.key');
+        PEM_ECDSA = readAsString('Kecdsatest.+013+43896.pem');
+        PEM_ECDSA_PUB = readAsString('Kecdsatest.+013+43896_pub.pem');
+	t.end();
+});
+
+// --- Tests
+// read tests
+test('1024b dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'dnssec');
+	t.strictEqual(k.toString('pem'), PEM_RSA);
+	t.end();
+});
+
+test('1024b dnssec to pem public key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'dnssec');
+	t.strictEqual(k.toPublic().toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('1024b dnssec public key to pem', function(t) {
+	var k = sshpk.parseKey(DNSSEC_RSA_PUB, 'dnssec');
+	t.strictEqual(k.toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('1024b auto dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_RSA, 'auto');
+	t.strictEqual(k.toString('pem'), PEM_RSA);
+	t.end();
+});
+
+test('1024b auto dnssec public key to pem', function(t) {
+	var k = sshpk.parseKey(DNSSEC_RSA_PUB, 'auto');
+	t.strictEqual(k.toString('pem'), PEM_RSA_PUB);
+	t.end();
+});
+
+test('ecdsa dnssec to pem private key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_ECDSA, 'dnssec');
+	t.strictEqual(k.toString('pem'), PEM_ECDSA);
+	t.end();
+});
+
+test('ecdsa dnssec to pem public key', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_ECDSA, 'dnssec');
+	t.strictEqual(k.toPublic().toString('pem'), PEM_ECDSA_PUB);
+	t.end();
+});
+
+// write tests
+//--- Tests
+
+function stripDNSSECTimestamp(m) {
+	var out = []
+	var lines = m.split('\n');
+	lines.forEach(function(line) {
+		if (line.match(/^Created.*/) || line.match(/^Publish.*/) ||
+		    line.match(/^Activate.*/)) {
+                        return;
+		} else {
+			if (line.length > 1)
+				out.push(line);
+		}
+	});
+	return (out.join('\n'));
+}
+
+// DNSSEC keys have timestamps -- for the comparison we'll strip them.
+test('1024b pem private key to dnssec', function(t) {
+	var k = sshpk.parsePrivateKey(PEM_RSA, 'pem');
+	k = stripDNSSECTimestamp(k.toString('dnssec'));
+	t.strictEqual(k, stripDNSSECTimestamp(DNSSEC_RSA));
+	t.end();
+});
+
+test('1024b auto pem private key to dnssec', function(t) {
+	var k = sshpk.parsePrivateKey(PEM_RSA, 'auto');
+	k = stripDNSSECTimestamp(k.toString('dnssec'));
+	t.strictEqual(k, stripDNSSECTimestamp(DNSSEC_RSA));
+	t.end();
+});
+
+test('ecdsa pem private key to dnssec', function(t) {
+	var k = sshpk.parsePrivateKey(PEM_RSA, 'pem');
+	k = stripDNSSECTimestamp(k.toString('dnssec'));
+	t.strictEqual(k, stripDNSSECTimestamp(DNSSEC_RSA));
+	t.end();
+});
+
+test('ecdsa auto pem private key to dnssec', function(t) {
+	var k = sshpk.parsePrivateKey(DNSSEC_ECDSA, 'auto');
+	k = stripDNSSECTimestamp(k.toString('dnssec'));
+	t.strictEqual(k, stripDNSSECTimestamp(DNSSEC_ECDSA));
+	t.end();
+});
