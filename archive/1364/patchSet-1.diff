commit 88856b9cc36a39684e32a35566e2cc14fd52fb91 (refs/changes/64/1364/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-01-27T12:04:02-08:00 (2 years, 8 months ago)
    
    joyent/node-cueball#77 ConnectionFSM is too complicated, should be split up
    joyent/node-cueball#72 'end' or 'close' during idle state should not be considered an error
    joyent/node-cueball#73 ConnectionFSM should stop doubling "timeout" and "delay" after max retries

diff --git a/CHANGES.adoc b/CHANGES.adoc
new file mode 100644
index 0000000..fcd27fa
--- /dev/null
+++ b/CHANGES.adoc
@@ -0,0 +1,48 @@
+:toc: macro
+
+# Changelog
+
+toc::[]
+
+## v2.x
+
+### v2.0.0
+
+New major release, due to API change in `ConnectionSet`.
+
+API changes:
+
+ - `ConnectionSet` now requires the use of handles to indicate when connections
+   have been drained.
+    * Client code must store the `handle` which is now the 3rd argument to
+      all `'added'` events.
+    * Client code must be modified to call `handle.release()` (for a successful
+      drain and clean close) or `handle.close()` (for failure) and *not* call
+      `.destroy()` on the connection, after `'removed'` is emitted.
+
+Bugs fixed:
+
+ - #77, #72, #73 rewrite of connection management FSMs. Solves a swathe of
+   issues around error handling and protocols that don't keep-alive idle
+   connections.
+
+## v1.x
+
+### v1.3.2
+
+Maintenance release.
+
+Bugs fixed:
+
+ - #70 possible crash whenever using the kang "pool monitor" feature.
+ - #76 silenced spurious EventEmitter "leak" warnings
+
+### v1.3.1
+
+Maintenance release.
+
+Bugs fixed:
+
+ - #69 clearer log messages around connection attempts, failures and delays
+ - #71 some additional assertions related to #70
+ - #61 handling `null` as well as `undefined` for optional settings
diff --git a/README.md b/README.md
index dee1800..d63ec8e 100644
--- a/README.md
+++ b/README.md
@@ -682,17 +682,28 @@ Parameters
 Emitted when a new connection becomes available in the set. This event *must*
 have a handler on it at all times.
 
+The `handle` that is given as the third argument to this event has two methods
+`.release()` and `.close()`, like a Pool handle. As with Pool handles, it can
+be used to indicate the failure of a connection (e.g. due to a protocol error
+making safe use of the connection impossible) at any time, but unlike a Pool
+handle, it is an error to call `.release()` until after a `'removed'` event
+has been emitted.
+
+The user of the ConnectionSet should store both the `connection` and `handle`
+in such a way as to be able to retrieve them using the `key`.
+
 Parameters
  - `key` -- String, a unique key to identify this connection
  - `connection` -- Object, the connection as returned by the constructor
+ - `handle` -- Object, a handle to be used in response to a 'removed' event
+   about this connection
 
 ### Event `removed`
 
 Emitted when an existing connection should be removed from the pool. This event
 *must* have a handler on it at all times. The handler is obligated to take all
-necessary actions to drain the connection of outstanding requests and then close
-it. The emission of this event must cause the connection object to emit
-`'close'` as soon as possible.
+necessary actions to drain the connection of outstanding requests and then
+call the `.release()` method on the relevant handle.
 
 Parameters
  - `key` -- String, a unique key to identify the connection
diff --git a/lib/agent.js b/lib/agent.js
index 08c8e80..fbdd00f 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -288,16 +288,27 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 		sock = socket;
 		conn = connh;
 		socket.once('free', onFree);
+		socket.once('close', onClose);
 		socket.once('agentRemove', onAgentRemove);
 		req.onSocket(socket);
 	});
 
+	function onClose() {
+		sock.removeListener('free', onFree);
+		sock.removeListener('agentRemove', onAgentRemove);
+		req.removeListener('abort', onAbort);
+		conn.release();
+		conn = undefined;
+		sock = undefined;
+	}
+
 	function onAbort() {
 		if (waiter !== undefined) {
 			waiter.cancel();
 			waiter = undefined;
 		}
 		if (conn !== undefined) {
+			sock.removeListener('close', onClose);
 			sock.removeListener('free', onFree);
 			sock.removeListener('agentRemove', onAgentRemove);
 			conn.close();
@@ -306,6 +317,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 		}
 	}
 	function onFree() {
+		sock.removeListener('close', onClose);
 		sock.removeListener('agentRemove', onAgentRemove);
 		req.removeListener('abort', onAbort);
 		conn.release();
@@ -313,6 +325,7 @@ CueBallAgent.prototype.addRequest = function (req, optionsOrHost, port) {
 		sock = undefined;
 	}
 	function onAgentRemove() {
+		sock.removeListener('close', onClose);
 		sock.removeListener('free', onFree);
 		req.removeListener('abort', onAbort);
 		conn.close();
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 9072902..50f07a0 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -6,7 +6,10 @@
  * Copyright (c) 2016, Joyent, Inc.
  */
 
-module.exports = ConnectionFSM;
+module.exports = {
+	ConnectionSlotFSM: ConnectionSlotFSM,
+	CueBallClaimHandle: CueBallClaimHandle
+};
 
 const mod_events = require('events');
 const mod_net = require('net');
@@ -29,45 +32,51 @@ const EventEmitter = mod_events.EventEmitter;
 const Queue = require('./queue');
 
 /*
- * ConnectionFSM is the state machine for a "connection" -- an abstract entity
- * that is managed by a ConnectionPool. ConnectionFSMs are associated with a
- * particular 'backend', and hold a backing object cf_conn. Typically this
- * backing object is a TCP socket, but may be any EventEmitter that emits
- * 'close' and 'error'.
+ * The "Socket Manager FSM" (SocketMgrFSM) is an abstraction for a "socket"/
+ * connection, which handles retry and backoff, as well as de-duplication of
+ * error and closure related events.
+ *
+ *                                   +------------+
+ *                                   |            |
+ *                                   |   failed   |
+ *                                   |            |
+ *                                   +------------+
+ *                                      ^
+ *                                      |
+ *                                      |retries
+ *                                      |exhausted
+ *           +------------+          +--+---------+
+ *           |            |   timeout|            |
+ *   +-----> | connecting | <--------+  backoff   | <--+
+ *   |       |            |          |            |    |
+ *   |       +--+----+----+          +------------+    |
+ *   |          |    |                  ^              |
+ *   | 'connect'|    | timeout/'error'  |              |
+ *   |          |    +---------+        |              |
+ *   |          v              |        | .retry()     |
+ *   |       +------------+    |     +--+---------+    |
+ *   |       |            |    +---> |            |    |
+ *   |       | connected  +--------> |   error    |    |
+ *   |       |            | 'error'  |            |    |
+ *   |       +--+---------+          +------------+    |
+ *   |   'close'|                                      |
+ *   |  .close()|                                      |
+ *   |          |                                      |
+ *   |          v                                      |
+ *   |       +------------+                            |
+ *   |       |            |                            |
+ *   +-------+   closed   +----------------------------+
+ * .connect()|            | .retry()
+ *           +------------+
  */
-function ConnectionFSM(options) {
+function SocketMgrFSM(options) {
 	mod_assert.object(options, 'options');
-	mod_assert.object(options.pool, 'options.pool');
 	mod_assert.func(options.constructor, 'options.constructor');
 	mod_assert.object(options.backend, 'options.backend');
 	mod_assert.object(options.log, 'options.log');
-	mod_assert.optionalFunc(options.checker, 'options.checker');
-	mod_assert.optionalNumber(options.checkTimeout, 'options.checkTimeout');
-
-	this.cf_pool = options.pool;
-	this.cf_constructor = options.constructor;
-	this.cf_backend = options.backend;
-	this.cf_claimed = false;
-	this.cf_claimStack = [];
-	this.cf_releaseStack = [];
-	this.cf_lastError = undefined;
-	this.cf_conn = undefined;
-	this.cf_shadow = undefined;
-	this.cf_closeAfter = false;
-	mod_assert.optionalBool(options.doRef, 'options.doRef');
-	this.cf_doRef = options.doRef;
-	if (this.cf_doRef === undefined && this.cf_doRef !== null)
-		this.cf_doRef = true;
-	this.cf_oldListeners = {};
-	this.cf_checkTimeout = options.checkTimeout;
-	this.cf_checker = options.checker;
-	this.cf_lastCheck = new Date();
-	this.cf_log = options.log.child({
-		component: 'CueBallConnectionFSM',
-		backend: this.cf_backend.key,
-		address: this.cf_backend.address,
-		port: this.cf_backend.port
-	});
+	mod_assert.object(options.slot, 'options.slot');
+	mod_assert.bool(options.monitor, 'options.monitor');
+	mod_assert.object(options.pool, 'options.pool');
 
 	mod_assert.object(options.recovery, 'options.recovery');
 
@@ -82,322 +91,515 @@ function ConnectionFSM(options) {
 	mod_utils.assertRecovery(connectRecov, 'recovery.connect');
 	mod_utils.assertRecovery(initialRecov, 'recovery.initial');
 
-	this.cf_initialRecov = initialRecov;
-	this.cf_connectRecov = connectRecov;
+	this.sm_initialRecov = initialRecov;
+	this.sm_connectRecov = connectRecov;
 
-	this.cf_retries = initialRecov.retries;
-	this.cf_retriesLeft = initialRecov.retries;
-	this.cf_minDelay = initialRecov.delay;
-	this.cf_delay = initialRecov.delay;
-	this.cf_maxDelay = initialRecov.maxDelay || Infinity;
-	this.cf_timeout = initialRecov.timeout;
-	this.cf_maxTimeout = initialRecov.maxTimeout || Infinity;
+	this.sm_pool = options.pool;
+	this.sm_backend = options.backend;
+	this.sm_constructor = options.constructor;
+	this.sm_slot = options.slot;
 
-	/*
-	 * If our parent pool thinks this backend is dead, resume connection
-	 * attempts with the maximum delay and timeout. Something is going
-	 * wrong, let's not retry too aggressively and make it worse.
-	 */
-	if (this.cf_pool.isDeclaredDead(this.cf_backend.key)) {
-		/*
-		 * We might be given an infinite maxDelay or maxTimeout. If
-		 * we are, then multiply it by 2^(retries) to get to what the
-		 * value would have been before.
-		 */
-		var mult = 1 << this.cf_retries;
-		this.cf_delay = this.cf_maxDelay;
-		if (!isFinite(this.cf_delay))
-			this.cf_delay = initialRecov.delay * mult;
-		this.cf_timeout = this.cf_maxTimeout;
-		if (!isFinite(this.cf_timeout))
-			this.cf_timeout = initialRecov.timeout * mult;
-		/* Keep retrying a failed backend forever */
-		this.cf_retries = Infinity;
-		this.cf_retriesLeft = Infinity;
-	}
+	this.sm_log = options.log.child({
+		component: 'CueBallSocketMgrFSM',
+		backend: this.sm_backend.key,
+		address: this.sm_backend.address,
+		port: this.sm_backend.port
+	});
 
-	this.allStateEvent('closeAsserted');
+	this.sm_lastError = undefined;
+	this.sm_socket = undefined;
 
 	FSM.call(this, 'init');
+
+	this.sm_monitor = undefined;
+	this.setMonitor(options.monitor);
 }
-mod_util.inherits(ConnectionFSM, FSM);
+mod_util.inherits(SocketMgrFSM, FSM);
 
-/*
- * Return true if this connection was closed due to retry exhaustion.
- */
-ConnectionFSM.prototype.retriesExhausted = function () {
-	return (this.isInState('closed') && this.cf_retriesLeft <= 0);
+SocketMgrFSM.prototype.setMonitor = function (value) {
+	mod_assert.ok(this.isInState('init') || this.isInState('connected'));
+	if (value === this.sm_monitor)
+		return;
+	this.sm_monitor = value;
+	this.resetBackoff();
 };
 
-ConnectionFSM.prototype.getConnection = function () {
-	mod_assert.ok(this.isInState('idle'));
-	return (this.cf_conn);
-};
+SocketMgrFSM.prototype.resetBackoff = function () {
+	var initialRecov = this.sm_initialRecov;
 
-/*
- * Mark this Connection as "claimed"; in use by a particular client of the
- * pool.
- *
- * Normally this will be called by the pool itself, which will give the 'stack'
- * argument as a copy of the stack trace from its caller.
- *
- * We keep track of the stack trace of our last claimer and releaser to aid
- * in debugging.
- */
-ConnectionFSM.prototype.claim = function (stack, cb) {
-	mod_assert.ok(this.cf_claimed === false);
-	mod_assert.strictEqual(this.getState(), 'idle');
-	if (typeof (stack) === 'function') {
-		cb = stack;
-		stack = undefined;
-	}
-	mod_assert.func(cb, 'callback');
-	if (stack === undefined) {
-		var e = mod_utils.maybeCaptureStackTrace();
-		stack = e.stack;
-	}
-	this.cf_claimStack = stack.split('\n').slice(1).
-	    map(function (l) { return (l.replace(/^[ ]*at /, '')); });
-	this.cf_claimed = true;
-	var self = this;
-	this.on('stateChanged', onStateChanged);
-	function onStateChanged(st) {
-		if (st === 'busy' && self.isInState('busy')) {
-			self.removeListener('stateChanged', onStateChanged);
-			cb(null, self.cf_shadow, self.cf_conn);
-		} else if (st === 'error' && self.cf_lastError !== undefined) {
-			self.removeListener('stateChanged', onStateChanged);
-			var err = new mod_verror.VError(self.cf_lastError,
-			    'Connection error during claim on backend %s:%d',
-			    self.cf_backend.address, self.cf_backend.port);
-			cb(err);
-		} else if (st !== 'busy') {
-			self.removeListener('stateChanged', onStateChanged);
-			cb(new mod_verror.VError('Claimed connection entered ' +
-			    'state "%s" during claim, instead of "busy"', st));
-		}
+	this.sm_retries = initialRecov.retries;
+	this.sm_retriesLeft = initialRecov.retries;
+	this.sm_minDelay = initialRecov.delay;
+	this.sm_delay = initialRecov.delay;
+	this.sm_maxDelay = initialRecov.maxDelay || Infinity;
+	this.sm_timeout = initialRecov.timeout;
+	this.sm_maxTimeout = initialRecov.maxTimeout || Infinity;
+
+	if (this.sm_monitor === true) {
+		var mult = 1 << this.sm_retries;
+		this.sm_delay = this.sm_maxDelay;
+		if (!isFinite(this.sm_delay))
+			this.sm_delay = initialRecov.delay * mult;
+		this.sm_timeout = this.sm_maxTimeout;
+		if (!isFinite(this.sm_timeout))
+			this.sm_timeout = initialRecov.timeout * mult;
+		/* Keep retrying a failed backend forever */
+		this.sm_retries = Infinity;
+		this.sm_retriesLeft = Infinity;
 	}
-	this.emit('claimAsserted');
 };
 
-/*
- * Mark this Connection as "free" and ready to be re-used. This is normally
- * called via the ConnectionHandle.
- */
-ConnectionFSM.prototype.release = function (cb) {
-	mod_assert.ok(this.cf_claimed === true);
-	mod_assert.ok(['busy', 'ping'].indexOf(this.getState()) !== -1,
-	    'connection is not held');
+SocketMgrFSM.prototype.connect = function () {
+	mod_assert.ok(this.isInState('init') || this.isInState('closed'),
+	    'SocketMgrFSM#connect may only be called in state "init" or ' +
+	    '"closed" (is in "' + this.getState() + '")');
+	this.emit('connectAsserted');
+};
 
-	var e = mod_utils.maybeCaptureStackTrace();
-	this.cf_releaseStack = e.stack.split('\n').slice(1).
-	    map(function (l) { return (l.replace(/^[ ]*at /, '')); });
-	this.once('stateChanged', function (st) {
-		mod_assert.notStrictEqual(st, 'busy');
-		if (cb)
-			cb(null);
-	});
-	this.emit('releaseAsserted');
+SocketMgrFSM.prototype.retry = function () {
+	mod_assert.ok(this.isInState('closed') || this.isInState('error'),
+	    'SocketMgrFSM#retry may only be called in state "closed" or ' +
+	    '"error" (is in "' + this.getState() + '")');
+	this.emit('retryAsserted');
 };
 
-ConnectionFSM.prototype.close = function (cb) {
-	if (cb) {
-		this.on('stateChanged', function (st) {
-			if (st === 'closed')
-				cb();
-		});
-	}
+SocketMgrFSM.prototype.close = function () {
+	mod_assert.ok(this.isInState('connected') || this.isInState('backoff'),
+	    'SocketMgrFSM#close may only be called in state "connected" or ' +
+	    '"backoff" (is in "' + this.getState() + '")');
 	this.emit('closeAsserted');
 };
 
-ConnectionFSM.prototype.start = function () {
-	this.emit('startAsserted');
+SocketMgrFSM.prototype.getLastError = function () {
+	return (this.sm_lastError);
 };
 
-ConnectionFSM.prototype.closeAfterRelease = function () {
-	this.cf_closeAfter = true;
+SocketMgrFSM.prototype.getSocket = function () {
+	mod_assert.ok(this.isInState('connected'), 'Sockets may only be ' +
+	    'retrieved from SocketMgrFSMs in "connected" state (is in ' +
+	    'state "' + this.getState() + '")');
+	return (this.sm_socket);
 };
 
-ConnectionFSM.prototype.state_init = function (S) {
-	S.validTransitions(['connect', 'closed']);
-	S.on(this, 'startAsserted', function () {
-		S.gotoState('connect');
-	});
-	S.on(this, 'closeAsserted', function () {
-		S.gotoState('closed');
+SocketMgrFSM.prototype.state_init = function (S) {
+	S.validTransitions(['connecting']);
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
 	});
 };
 
-ConnectionFSM.prototype.state_connect = function (S) {
-	S.validTransitions(['error', 'idle', 'closed']);
+SocketMgrFSM.prototype.state_connecting = function (S) {
+	S.validTransitions(['connected', 'error']);
 	var self = this;
-	S.timeout(this.cf_timeout, function () {
-		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
+
+	S.timeout(this.sm_timeout, function () {
+		self.sm_lastError = new mod_errors.ConnectionTimeoutError(self);
 		S.gotoState('error');
+		self.sm_pool._incrCounter('timeout-during-connect');
 	});
-	this.cf_log.trace('calling constructor to open new connection');
-	this.cf_conn = this.cf_constructor(this.cf_backend);
-	mod_assert.object(this.cf_conn, 'constructor return value');
-	this.cf_conn.cf_fsm = this;
-	S.on(this.cf_conn, 'connect', function () {
-		S.gotoState('idle');
+
+	this.sm_log.trace('calling constructor to open new connection');
+	this.sm_socket = this.sm_constructor(this.sm_backend);
+	mod_assert.object(this.sm_socket, 'constructor return value');
+	this.sm_socket.sm_fsm = this;
+
+	S.on(this.sm_socket, 'connect', function () {
+		S.gotoState('connected');
 	});
-	S.on(this.cf_conn, 'error', function (err) {
-		self.cf_lastError = err;
+
+	S.on(this.sm_socket, 'error', function socketMgrErrorListener(err) {
+		self.sm_lastError = err;
 		S.gotoState('error');
-		self.cf_pool._incrCounter('error-during-connect');
+		self.sm_pool._incrCounter('error-during-connect');
 	});
-	S.on(this.cf_conn, 'connectError', function (err) {
-		self.cf_lastError = err;
+	S.on(this.sm_socket, 'connectError', function (err) {
+		self.sm_lastError = err;
 		S.gotoState('error');
-		self.cf_pool._incrCounter('error-during-connect');
+		self.sm_pool._incrCounter('error-during-connect');
 	});
-	S.on(this.cf_conn, 'close', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
+	S.on(this.sm_socket, 'close', function () {
+		self.sm_lastError = new mod_errors.ConnectionClosedError(self);
 		S.gotoState('error');
-		self.cf_pool._incrCounter('close-during-connect');
+		self.sm_pool._incrCounter('close-during-connect');
 	});
-	S.on(this.cf_conn, 'timeout', function () {
-		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
+	S.on(this.sm_socket, 'timeout', function () {
+		self.sm_lastError = new mod_errors.ConnectionTimeoutError(self);
 		S.gotoState('error');
-		self.cf_pool._incrCounter('timeout-during-connect');
+		self.sm_pool._incrCounter('timeout-during-connect');
 	});
-	S.on(this.cf_conn, 'connectTimeout', function (err) {
-		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
+	S.on(this.sm_socket, 'connectTimeout', function () {
+		self.sm_lastError = new mod_errors.ConnectionTimeoutError(self);
+		S.gotoState('error');
+		self.sm_pool._incrCounter('timeout-during-connect');
+	});
+};
+
+SocketMgrFSM.prototype.state_connected = function (S) {
+	S.validTransitions(['error', 'closed']);
+	var self = this;
+
+	if (typeof (self.sm_socket.localPort) === 'number') {
+		this.sm_log = this.sm_log.child({
+			localPort: this.sm_socket.localPort
+		});
+	}
+
+	this.sm_log.trace('connected');
+
+	this.resetBackoff();
+
+	S.on(this.sm_socket, 'error', function socketMgrErrorListener(err) {
+		self.sm_lastError = err;
 		S.gotoState('error');
-		self.cf_pool._incrCounter('timeout-during-connect');
+		self.sm_pool._incrCounter('error-while-connected');
 	});
+	S.on(this.sm_socket, 'close', function () {
+		S.gotoState('closed');
+	});
+
 	S.on(this, 'closeAsserted', function () {
 		S.gotoState('closed');
 	});
 };
 
-ConnectionFSM.prototype.state_closed = function (S) {
-	S.validTransitions([]);
-	this.cf_log.trace('closed');
-	if (this.cf_conn) {
-		this.cf_conn.destroy();
-		this.cf_log = this.cf_log.child({ localPort: null });
+SocketMgrFSM.prototype.state_error = function (S) {
+	S.validTransitions(['backoff']);
+	var log = this.sm_log;
+	if (this.sm_socket) {
+		this.sm_socket.destroy();
+		this.sm_log = this.sm_log.child({ localPort: null });
 	}
-	this.cf_conn = undefined;
-	S.on(this, 'closeAsserted', function () { });
-};
+	this.sm_socket = undefined;
 
-ConnectionFSM.prototype.state_error = function (S) {
-	S.validTransitions(['delay', 'closed']);
+	log.trace(this.sm_lastError, 'got error from connection');
 
-	S.on(this, 'closeAsserted', function () { });
-
-	var log = this.cf_log;
-	if (this.cf_conn) {
-		this.cf_conn.destroy();
-		this.cf_log = this.cf_log.child({ localPort: null });
-	}
-	this.cf_conn = undefined;
+	S.on(this, 'retryAsserted', function () {
+		S.gotoState('backoff');
+	});
+};
 
-	if (this.cf_shadow) {
-		this.cf_shadow.sh_error = true;
-		this.cf_shadow = undefined;
-	}
+SocketMgrFSM.prototype.state_backoff = function (S) {
+	S.validTransitions(['failed', 'connecting']);
 
 	/*
-	 * If the closeAfter flag is set, and this is a connection to a "dead"
-	 * backend (i.e., a "monitor" watching to see when it comes back), then
-	 * exit now. For an ordinary backend, we don't want to do this,
-	 * because we want to give ourselves the opportunity to run out of
-	 * retries.
-	 *
-	 * Otherwise, in a situation where we have two connections that were
-	 * created at the same time, one to a failing backend that's already
-	 * declared dead, and one to a different failing backend not yet
-	 * declared, we may never learn that the second backend is down and
-	 * declare it dead. The already declared dead backend may exit first
-	 * during a pool reshuffle and cause this one to exit prematurely
-	 * (there's a race in who exits first and causes the planner to engage)
+	 * Unfortunately, "retries" actually means "attempts" in the cueball
+	 * API. To preserve compatibility we have to compare to 1 here instead
+	 * of 0.
 	 */
-	if (this.cf_retries === Infinity && this.cf_closeAfter) {
-		this.cf_retriesLeft = 0;
-		log.trace('backoff monitor shut down');
-		S.gotoState('closed');
+	if (this.sm_retriesLeft !== Infinity && this.sm_retriesLeft <= 1) {
+		S.gotoState('failed');
 		return;
 	}
 
-	/*
-	 * If this backend has been removed from the Resolver, we should not
-	 * attempt any kind of reconnection. Exit now.
-	 */
-	if (!this.cf_pool.shouldRetryBackend(this.cf_backend.key)) {
-		log.trace('pool no longer wants us, closing');
-		S.gotoState('closed');
-		return;
-	}
+	var delay = this.sm_delay;
 
-	if (this.cf_retries !== Infinity)
-		--this.cf_retriesLeft;
+	if (this.sm_retries !== Infinity) {
+		--this.sm_retriesLeft;
 
-	if (this.cf_retries === Infinity || this.cf_retriesLeft > 0) {
-		log.trace(this.cf_lastError, 'failed to connect to ' +
-		    'backend, %d retries left: delaying before retry',
-		    this.cf_retriesLeft);
-		S.gotoState('delay');
-	} else {
-		log.warn(this.cf_lastError, 'failed to connect to backend, ' +
-		    'retries exhausted');
-		this.cf_pool._incrCounter('retries-exhausted');
-		S.gotoState('closed');
+		this.sm_delay *= 2;
+		this.sm_timeout *= 2;
+		if (this.sm_timeout > this.sm_maxTimeout)
+			this.sm_timeout = this.sm_maxTimeout;
+		if (this.sm_delay > this.sm_maxDelay)
+			this.sm_delay = this.sm_maxDelay;
 	}
-};
-
-ConnectionFSM.prototype.state_delay = function (S) {
-	S.validTransitions(['connect', 'closed']);
-	var delay = this.cf_delay;
-
-	this.cf_delay *= 2;
-	this.cf_timeout *= 2;
-	if (this.cf_timeout > this.cf_maxTimeout)
-		this.cf_timeout = this.cf_maxTimeout;
-	if (this.cf_delay > this.cf_maxDelay)
-		this.cf_delay = this.cf_maxDelay;
 
 	var t = S.timeout(delay, function () {
-		S.gotoState('connect');
+		S.gotoState('connecting');
 	});
 	t.unref();
+
 	S.on(this, 'closeAsserted', function () {
 		S.gotoState('closed');
 	});
 };
 
-ConnectionFSM.prototype.state_idle = function (S) {
-	S.validTransitions(['busy', 'error', 'closed']);
+SocketMgrFSM.prototype.state_closed = function (S) {
+	S.validTransitions(['backoff', 'connecting']);
+	var log = this.sm_log;
+	if (this.sm_socket) {
+		this.sm_socket.destroy();
+		this.sm_log = this.sm_log.child({ localPort: null });
+	}
+	this.sm_socket = undefined;
+
+	log.trace('connection closed');
+
+	S.on(this, 'retryAsserted', function () {
+		S.gotoState('backoff');
+	});
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
+	});
+};
+
+SocketMgrFSM.prototype.state_failed = function (S) {
+	S.validTransitions([]);
+	this.sm_log.warn(this.sm_lastError, 'failed to connect to ' +
+	    'backend, retries exhausted');
+	this.sm_pool._incrCounter('retries-exhausted');
+};
+
+/*
+ * ClaimHandle is a state machine representing a "claim handle". We give
+ * these out to clients of the Cueball pool, so that they can call either
+ * release() or close() on them when their use of the connection is complete.
+ *
+ * They also handle the process of finding a Slot in the pool to fulfill the
+ * claim and getting the connection successfully returned to the user.
+ *
+ * Some ancilliary responsibilities relate to the user interface features we
+ * support, like detecting leaked event handlers on re-useable connections and
+ * cancelling the process mid-way.
+ *
+ * A ClaimHandle is created immediately when .claim() is called on a pool.
+ * The pool then chooses slots that it will attempt to use to fulfill the claim.
+ * Each time the pool tries another slot, it calls .try() on the ClaimHandle.
+ * The SlotFSM will then either call .accept() or .reject() on the handle. If
+ * .reject() is called, we try another slot. If .accept() is called, we proceed
+ * to state "claimed". From "claimed", the end-user of the cueball pool calls
+ * either one of .release() or .close() to relinquish their claim.
+ *
+ *               timeout               +--------+
+ *              +--------------------> |        |
+ *              |                      |        |
+ *              |                      | failed |
+ *         +----+----+ .fail()         |        |
+ *         |         +---------------> |        |
+ *         |         |                 +--------+
+ *         | waiting |
+ *         |         | .try() && cancel
+ *         |         +---------------------+
+ *         |         |                     |
+ *         +-+-------+                     |
+ * .try() && |    ^                        |
+ *   !cancel |    |                        |
+ *           |    |                        v
+ *           |    |                  +-----------+
+ *           |    |                  |           |
+ *           |    |                  | cancelled |
+ *           |    |                  |           |
+ *           |    | .reject()        +-----------+
+ *           v    | && !cancel             ^
+ *         +------+---+                    |
+ *         |          |                    |
+ *         | claiming +--------------------+
+ *         |          | .reject() && cancel
+ *         +----+-----+
+ *    .accept() |
+ *              |
+ *              |
+ *              v
+ *         +---------+               +--------+
+ *         |         | .close()      |        |
+ *         | claimed +-------------> | closed |
+ *         |         |               |        |
+ *         +----+----+               +--------+
+ *              | .release()
+ *              |
+ *              |
+ *              v
+ *         +----------+
+ *         |          |
+ *         | released |
+ *         |          |
+ *         +----------+
+ *
+ */
+function CueBallClaimHandle(options) {
+	mod_assert.object(options, 'options');
+
+	mod_assert.number(options.claimTimeout, 'options.claimTimeout');
+	this.ch_claimTimeout = options.claimTimeout;
+
+	mod_assert.object(options.pool, 'options.pool');
+	this.ch_pool = options.pool;
+
+	mod_assert.string(options.claimStack, 'options.claimStack');
+	this.ch_claimStack = options.claimStack.split('\n').slice(1).
+	    map(function (l) { return (l.replace(/^[ ]*at /, '')); });
+
+	/* The user callback provided to Pool#claim() */
+	mod_assert.func(options.callback, 'options.callback');
+	this.ch_callback = options.callback;
+
+	mod_assert.object(options.log, 'options.log');
+	this.ch_log = options.log.child({
+		component: 'CueBallClaimHandle'
+	});
+
+	this.ch_slot = undefined;
+	this.ch_releaseStack = undefined;
+	this.ch_connection = undefined;
+	this.ch_preListeners = {};
+	this.ch_cancelled = false;
+	this.ch_lastError = undefined;
+
+	FSM.call(this, 'waiting');
+}
+mod_util.inherits(CueBallClaimHandle, FSM);
+
+CueBallClaimHandle.prototype.try = function (slot) {
+	mod_assert.ok(this.isInState('waiting'), 'ClaimHandle#try may only ' +
+	    'be called in state "waiting" (is in "' + this.getState() + '")');
+	mod_assert.ok(slot.isInState('idle'), 'ClaimHandle#try may only ' +
+	    'be called on a slot in state "idle" (is in "' + slot.getState() +
+	    '")');
+	this.ch_slot = slot;
+	this.emit('tryAsserted');
+};
+
+CueBallClaimHandle.prototype.accept = function (connection) {
+	mod_assert.ok(this.isInState('claiming'));
+	this.ch_connection = connection;
+	this.emit('accepted');
+};
+
+CueBallClaimHandle.prototype.reject = function () {
+	mod_assert.ok(this.isInState('claiming'));
+	this.emit('rejected');
+};
+
+CueBallClaimHandle.prototype.cancel = function () {
+	if (this.isInState('claimed')) {
+		this.release();
+	} else {
+		this.ch_cancelled = true;
+	}
+};
+
+CueBallClaimHandle.prototype.fail = function (err) {
+	this.emit('error', err);
+};
+
+CueBallClaimHandle.prototype.relinquish = function (event) {
+	if (!this.isInState('claimed')) {
+		if (this.isInState('released') || this.isInState('closed')) {
+			var err = new Error('Connection not claimed by ' +
+			    'this handle, released by ' +
+			    this.ch_releaseStack[2]);
+			throw (err);
+		}
+		throw (new Error('ClaimHandle#release() called while in ' +
+		    'state "' + this.getState() + '"'));
+	}
+	var e = mod_utils.maybeCaptureStackTrace();
+	this.ch_releaseStack = e.stack.split('\n').slice(1).
+	    map(function (l) { return (l.replace(/^[ ]*at /, '')); });
+	this.emit(event);
+};
+
+CueBallClaimHandle.prototype.release = function () {
+	this.relinquish('releaseAsserted');
+};
+
+CueBallClaimHandle.prototype.close = function () {
+	this.relinquish('closeAsserted');
+};
+
+CueBallClaimHandle.prototype.state_waiting = function (S) {
+	S.validTransitions(['claiming', 'cancelled', 'failed']);
 	var self = this;
 
-	this.cf_claimed = false;
-	this.cf_claimStack = [];
+	this.ch_slot = undefined;
 
-	if (typeof (self.cf_conn.localPort) === 'number') {
-		this.cf_log = this.cf_log.child({
-			localPort: self.cf_conn.localPort
+	S.on(this, 'tryAsserted', function () {
+		if (self.ch_cancelled) {
+			S.gotoState('cancelled');
+		} else {
+			S.gotoState('claiming');
+		}
+	});
+
+	if (isFinite(this.ch_claimTimeout)) {
+		S.timeout(this.ch_claimTimeout, function () {
+			self.ch_lastError = new mod_errors.ClaimTimeoutError(
+			    self.ch_pool);
+			S.gotoState('failed');
 		});
 	}
 
-	this.cf_log.trace('connected, idling');
+	S.on(this, 'error', function (err) {
+		self.ch_lastError = err;
+		S.gotoState('failed');
+	});
+};
+
+CueBallClaimHandle.prototype.state_claiming = function (S) {
+	S.validTransitions(['claimed', 'waiting']);
+	var self = this;
+
+	S.on(this, 'accepted', function () {
+		S.gotoState('claimed');
+	});
+
+	S.on(this, 'rejected', function () {
+		if (self.ch_cancelled) {
+			S.gotoState('cancelled');
+		} else {
+			S.gotoState('waiting');
+		}
+	});
+
+	this.ch_slot.claim(this);
+};
 
-	if (this.cf_shadow) {
-		this.cf_shadow.sh_claimed = false;
-		this.cf_shadow.sh_releaseStack = this.cf_releaseStack;
-		this.cf_shadow = undefined;
+CueBallClaimHandle.prototype.state_claimed = function (S) {
+	var self = this;
+	S.validTransitions(['released', 'closed']);
+
+	S.on(this, 'releaseAsserted', function () {
+		S.gotoState('released');
+	});
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closed');
+	});
+
+	if (this.ch_cancelled) {
+		S.gotoState('released');
+		return;
 	}
 
+	this.ch_preListeners = {};
 	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var newCount = countListeners(self.cf_conn, evt);
-		var oldCount = self.cf_oldListeners[evt];
+		var count = countListeners(self.ch_connection, evt);
+		self.ch_preListeners[evt] = count;
+	});
+
+	S.on(this.ch_connection, 'error', function clHandleErrorListener(err) {
+		var count = countListeners(self.ch_connection, 'error');
+		if (count === 0) {
+			/*
+			 * Our end-user never set up an 'error' event listener
+			 * and the socket emitted 'error'. We want to act like
+			 * nothing is listening for it at all and throw.
+			 */
+			throw (err);
+		}
+	});
+
+	this.ch_log = this.ch_slot.makeChildLogger({
+		component: 'CueBallClaimHandle'
+	});
+
+	this.ch_callback(null, this, this.ch_connection);
+};
+
+CueBallClaimHandle.prototype.state_released = function (S) {
+	S.validTransitions([]);
+
+	var conn = this.ch_connection;
+	var self = this;
+
+	['close', 'error', 'readable', 'data'].forEach(function (evt) {
+		var newCount = countListeners(conn, evt);
+		var oldCount = self.ch_preListeners[evt];
 		if (oldCount !== undefined && newCount > oldCount) {
 			var info = {};
-			info.stack = self.cf_releaseStack;
+			info.stack = self.ch_stack;
 			info.countBeforeClaim = oldCount;
 			info.countAfterRelease = newCount;
-			info.handlers = self.cf_conn.listeners(evt).map(
+			info.handlers = conn.listeners(evt).map(
 			    function (f) {
 				/*
 				 * node's EventEmitter#once function is actually
@@ -413,167 +615,25 @@ ConnectionFSM.prototype.state_idle = function (S) {
 				return (f.toString());
 			});
 			info.event = evt;
-			self.cf_log.warn(info, 'connection claimer looks ' +
+			self.ch_log.warn(info, 'connection claimer looks ' +
 			    'like it leaked event handlers');
 		}
 	});
-
-	/*
-	 * Reset retries and retry delay to their defaults since we are now
-	 * connected.
-	 */
-	this.cf_retries = this.cf_connectRecov.retries;
-	this.cf_retriesLeft = this.cf_connectRecov.retries;
-	this.cf_minDelay = this.cf_connectRecov.delay;
-	this.cf_delay = this.cf_connectRecov.delay;
-	this.cf_maxDelay = this.cf_connectRecov.maxDelay || Infinity;
-	this.cf_timeout = this.cf_connectRecov.timeout;
-	this.cf_maxTimeout = this.cf_connectRecov.maxTimeout || Infinity;
-
-	if (this.cf_closeAfter === true) {
-		this.cf_closeAfter = false;
-		this.cf_lastError = undefined;
-		S.on(this, 'closeAsserted', function () { });
-		S.gotoState('closed');
-		return;
-	}
-
-	if (this.cf_doRef)
-		this.cf_conn.unref();
-
-	S.on(this, 'claimAsserted', function () {
-		S.gotoState('busy');
-	});
-	S.on(this.cf_conn, 'error', function (err) {
-		self.cf_lastError = err;
-		S.gotoState('error');
-		self.cf_pool._incrCounter('error-during-idle');
-	});
-	S.on(this.cf_conn, 'close', function () {
-		/*
-		 * If we receive 'close' while idle with our closeAfter flag
-		 * set, we were going to be removed anyway. Just go to closed.
-		 * Going to error would give us a chance to learn about a dead
-		 * backend, but a clean 'close' with no 'error' is probably
-		 * not dead.
-		 *
-		 * This is particularly important with ConnectionSets, where
-		 * this is the normal path that's taken for the Set's consumer
-		 * to notify it that this connection has drained and closed.
-		 */
-		if (self.cf_closeAfter === true) {
-			S.gotoState('closed');
-		} else {
-			self.cf_lastError =
-			    new mod_errors.ConnectionClosedError(self);
-			S.gotoState('error');
-			self.cf_pool._incrCounter('close-during-idle');
-		}
-	});
-	S.on(this.cf_conn, 'end', function () {
-		if (self.cf_closeAfter === true) {
-			S.gotoState('closed');
-		} else {
-			self.cf_lastError = new
-			    mod_errors.ConnectionClosedError(self);
-			S.gotoState('error');
-			self.cf_pool._incrCounter('end-during-idle');
-		}
-	});
-	S.on(this, 'closeAsserted', function () {
-		S.gotoState('closed');
-	});
-	if (this.cf_checkTimeout !== undefined &&
-	    this.cf_checkTimeout !== null) {
-		var now = new Date();
-		var sinceLast = (now - this.cf_lastCheck);
-		var delay;
-		if (sinceLast > this.cf_checkTimeout) {
-			delay = 1000;
-		} else {
-			delay = this.cf_checkTimeout - sinceLast;
-			if (delay < 1000)
-				delay = 1000;
-		}
-		var t = S.timeout(delay, function () {
-			S.gotoState('ping');
-		});
-		t.unref();
-	}
 };
 
-ConnectionFSM.prototype.state_ping = function (S) {
-	S.validTransitions(['error', 'closed', 'idle']);
-	this.cf_lastCheck = new Date();
+CueBallClaimHandle.prototype.state_closed = function (S) {
+	S.validTransitions([]);
+};
 
-	this.cf_claimStack = [
-	    'ConnectionFSM.prototype.state_ping',
-	    '(periodic_health_check)'];
-	this.cf_claimed = true;
+CueBallClaimHandle.prototype.state_cancelled = function (S) {
+	S.validTransitions([]);
+};
 
+CueBallClaimHandle.prototype.state_failed = function (S) {
+	S.validTransitions([]);
 	var self = this;
-	if (this.cf_doRef)
-		this.cf_conn.ref();
-
-	this.cf_releaseStack = [];
-	this.cf_log.trace('doing health check');
-
-	/*
-	 * Write down the count of event handlers on the backing object so that
-	 * we can spot if the client leaked any common ones in release().
-	 */
-	this.cf_oldListeners = {};
-	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var count = countListeners(self.cf_conn, evt);
-		self.cf_oldListeners[evt] = count;
-	});
-
-	/*
-	 * The ConnectionHandle is a one-time use object that proxies calls to
-	 * our release() and close() functions. We use it so that we can assert
-	 * that this particular client only releases us once. If we only
-	 * asserted on our current state, there could be a race where we get
-	 * claimed by a different client in the meantime.
-	 */
-	this.cf_shadow = new ConnectionHandle(this);
-
-	S.on(this, 'releaseAsserted', function () {
-		if (self.cf_closeAfter === true) {
-			S.gotoState('closed');
-		} else {
-			S.gotoState('idle');
-		}
-	});
-	S.on(this.cf_conn, 'error', function (err) {
-		self.cf_lastError = err;
-		S.gotoState('error');
-		self.cf_pool._incrCounter('error-during-ping');
-	});
-	S.on(this.cf_conn, 'close', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		S.gotoState('error');
-		self.cf_pool._incrCounter('close-during-ping');
-	});
-	S.on(this.cf_conn, 'end', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		S.gotoState('error');
-		self.cf_pool._incrCounter('end-during-ping');
-	});
-	S.on(this, 'closeAsserted', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		S.gotoState('error');
-	});
-	var t = S.timeout(this.cf_checkTimeout, function () {
-		var info = {};
-		info.stack = self.cf_claimStack;
-		self.cf_log.warn(info, 'health check is taking too ' +
-		    'long to run (has been more than %d ms)',
-		    self.cf_checkTimeout);
-	});
-	t.unref();
-
 	S.immediate(function () {
-		self.cf_checker.call(null, self.cf_shadow, self.cf_conn);
+		self.ch_callback(self.ch_lastError);
 	});
 };
 
@@ -591,111 +651,389 @@ function countListeners(eve, event) {
 		    h.listener.name === 'freeSocketErrorListener') {
 			return (false);
 		}
+		/* Don't count the error listeners set up by cueball. */
+		if (h.name === 'socketMgrErrorListener' ||
+		    h.name === 'clHandleErrorListener') {
+			return (false);
+		}
 		return (true);
 	});
 	return (ls.length);
 }
 
-ConnectionFSM.prototype.state_busy = function (S) {
-	S.validTransitions(['error', 'closed', 'idle']);
-	var self = this;
-	if (this.cf_doRef)
-		this.cf_conn.ref();
+/*
+ * ConnectionSlotFSM
+ *                                +--------+
+ *                  +-----------> | failed | <-----------+
+ *                  |             +--------+             |
+ *                  |                                    |
+ *                  |                                    |      +---------+
+ *             smgr |                               smgr |      |         |
+ *           failed |                             failed |      |         |
+ *                  |                                    |      v    smgr |
+ *         +--------+-------+                    +-------+--------+ error |
+ *         |   connecting   |     smgr error     |    retrying    +-------+
+ * (A)---> |                +------------------> |                |
+ *         | smgr.connect() |                    |  smgr.retry()  | <-+
+ *         +-------+--------+                    +-------+--------+   |
+ *                 |  ^                               ^  |            |
+ *            smgr |  |                               |  | smgr       |
+ *       connected |  |                               |  | connected  |
+ *                 |  |     smgr              smgr    |  |            |
+ *                 |  |   closed  +--------+  error   |  |            |
+ *                 |  +-----------+        +----------+  |            |
+ *                 |              |        |             |            |
+ *                 +------------> |  idle  | <-----------+            |
+ *                                |        |                          |
+ *         +----------------------+        | <-----------+            |
+ *         |     !wanted && smgr  +---+----+             |            |
+ *         |           connected      | .claim()         |            |
+ *         v                          |                  |            |
+ *  +--------------+                  |                  |            |
+ *  |   stopping   |                  v                  |            |
+ *  |              |              +--------+             |            |
+ *  | smgr.close() | <------------+        +-------------+            |
+ *  +------+-------+  hdl rel. && |        | hdl released &&          |
+ *         |         smgr conn && |        | smgr connected &&        |
+ *   smgr  |              !wanted |        | wanted                   |
+ * closed  |                      |        |                          |
+ *         |                      |  busy  +----------------->(A)     |
+ *         v                      |        | hdl released &&          |
+ *    +---------+                 |        | smgr closed              |
+ *    | stopped | <---------------+        |                          |
+ *    +---------+     hdl rel. && |        +--------------------------+
+ *                !(smgr conn) && |        | hdl closed &&            ^
+ *                        !wanted +-----+--+ !(smgr connected)        |
+ *                                      |                             |
+ *                                      | hdl closed &&               |
+ *                                      | smgr connected              |
+ *                                      |                             |
+ *                                      v                             |
+ *                                    +--------------+                |
+ *                                    |   killing    +----------------+
+ *                                    |              | smgr closed
+ *                                    | smgr.close() |
+ *                                    +--------------+
+ */
+function ConnectionSlotFSM(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.object(options.pool, 'options.pool');
+	mod_assert.func(options.constructor, 'options.constructor');
+	mod_assert.object(options.backend, 'options.backend');
+	mod_assert.object(options.log, 'options.log');
+	mod_assert.object(options.recovery, 'options.recovery');
+	mod_assert.bool(options.monitor, 'options.monitor');
 
-	this.cf_releaseStack = [];
-	this.cf_log.trace('busy, claimed by %s',
-	    this.cf_claimStack[1].split(' ')[0]);
+	mod_assert.optionalFunc(options.checker, 'options.checker');
+	mod_assert.optionalNumber(options.checkTimeout, 'options.checkTimeout');
 
-	/*
-	 * Write down the count of event handlers on the backing object so that
-	 * we can spot if the client leaked any common ones in release().
-	 */
-	this.cf_oldListeners = {};
-	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var count = countListeners(self.cf_conn, evt);
-		self.cf_oldListeners[evt] = count;
+	this.csf_pool = options.pool;
+	this.csf_backend = options.backend;
+	this.csf_wanted = true;
+	this.csf_handle = undefined;
+	this.csf_monitor = options.monitor;
+
+	this.csf_checker = options.checker;
+	this.csf_checkTimeout = options.checkTimeout;
+
+	this.csf_log = options.log.child({
+		component: 'CueBallConnectionSlotFSM',
+		backend: this.csf_backend.key,
+		address: this.csf_backend.address,
+		port: this.csf_backend.port
 	});
 
-	/*
-	 * The ConnectionHandle is a one-time use object that proxies calls to
-	 * our release() and close() functions. We use it so that we can assert
-	 * that this particular client only releases us once. If we only
-	 * asserted on our current state, there could be a race where we get
-	 * claimed by a different client in the meantime.
-	 */
-	this.cf_shadow = new ConnectionHandle(this);
+	var smgrOpts = {
+		pool: options.pool,
+		constructor: options.constructor,
+		backend: options.backend,
+		log: options.log,
+		recovery: options.recovery,
+		monitor: options.monitor,
+		slot: this
+	};
+	this.csf_smgr = new SocketMgrFSM(smgrOpts);
 
-	S.on(this, 'releaseAsserted', function () {
-		if (self.cf_closeAfter === true) {
-			S.gotoState('closed');
-		} else {
+	FSM.call(this, 'init');
+}
+mod_util.inherits(ConnectionSlotFSM, FSM);
+
+ConnectionSlotFSM.prototype.setUnwanted = function () {
+	if (this.csf_wanted === false)
+		return;
+	this.csf_wanted = false;
+	this.emit('unwanted');
+};
+
+ConnectionSlotFSM.prototype.start = function () {
+	mod_assert.ok(this.isInState('init'));
+	this.emit('startAsserted');
+};
+
+ConnectionSlotFSM.prototype.claim = function (handle) {
+	mod_assert.ok(this.isInState('idle'));
+	mod_assert.strictEqual(this.csf_handle, undefined);
+	this.csf_handle = handle;
+	this.emit('claimAsserted');
+};
+
+ConnectionSlotFSM.prototype.makeChildLogger = function (args) {
+	return (this.csf_log.child(args));
+};
+
+ConnectionSlotFSM.prototype.getSocketMgr = function () {
+	return (this.csf_smgr);
+};
+
+ConnectionSlotFSM.prototype.state_init = function (S) {
+	S.on(this, 'startAsserted', function () {
+		S.gotoState('connecting');
+	});
+};
+
+ConnectionSlotFSM.prototype.state_connecting = function (S) {
+	S.validTransitions(['failed', 'retrying', 'idle']);
+	var smgr = this.csf_smgr;
+	S.on(smgr, 'stateChanged', function (st) {
+		switch (st) {
+		case 'init':
+		case 'connecting':
+			break;
+		case 'failed':
+			S.gotoState('failed');
+			break;
+		case 'error':
+			S.gotoState('retrying');
+			break;
+		case 'connected':
 			S.gotoState('idle');
+			break;
+		default:
+			throw (new Error('Unhandled smgr state transition: ' +
+			    '.connect() => "' + st + '"'));
 		}
 	});
-	S.on(this.cf_conn, 'error', function (err) {
-		self.cf_log.error(err, 'connection emitted "error" while ' +
-		    'busy (claimed)');
-		self.cf_lastError = err;
-		S.gotoState('error');
-		self.cf_pool._incrCounter('error-during-busy');
+	smgr.connect();
+};
+
+ConnectionSlotFSM.prototype.state_failed = function (S) {
+	S.validTransitions([]);
+	mod_assert.ok(this.csf_smgr.isInState('failed'),
+	    'smgr must be failed');
+};
+
+ConnectionSlotFSM.prototype.state_retrying = function (S) {
+	S.validTransitions(['idle', 'failed', 'retrying', 'stopped',
+	    'stopping']);
+	var self = this;
+	var smgr = this.csf_smgr;
+	S.on(smgr, 'stateChanged', function (st) {
+		switch (st) {
+		case 'backoff':
+		case 'connecting':
+			break;
+		case 'failed':
+			S.gotoState('failed');
+			break;
+		case 'error':
+			if (self.csf_monitor && !self.csf_wanted) {
+				S.gotoState('stopped');
+			} else {
+				S.gotoState('retrying');
+			}
+			break;
+		case 'connected':
+			S.gotoState('idle');
+			break;
+		default:
+			throw (new Error('Unhandled smgr state transition: ' +
+			    '.retry() => "' + st + '"'));
+		}
 	});
-	S.on(this.cf_conn, 'end', function () {
-		self.cf_closeAfter = true;
-		self.cf_pool._incrCounter('end-during-busy');
+	S.on(this, 'unwanted', function () {
+		if (self.csf_monitor && smgr.isInState('backoff')) {
+			S.gotoState('stopping');
+		}
 	});
-	S.on(this.cf_conn, 'close', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		S.gotoState('error');
-		self.cf_pool._incrCounter('close-during-busy');
+	smgr.retry();
+};
+
+ConnectionSlotFSM.prototype.state_idle = function (S) {
+	var self = this;
+	var smgr = this.csf_smgr;
+
+	this.csf_handle = undefined;
+
+	if (smgr.isInState('connected')) {
+		var sock = smgr.getSocket();
+		if (typeof (sock.unref) === 'function')
+			sock.unref();
+	}
+
+	/* Monitor successfully connected: make it into a normal slot now. */
+	if (this.csf_monitor === true) {
+		this.csf_monitor = false;
+		smgr.setMonitor(false);
+	}
+
+	if (!this.csf_wanted) {
+		onUnwanted();
+		return;
+	}
+	S.on(this, 'unwanted', onUnwanted);
+
+	function onUnwanted() {
+		if (smgr.isInState('connected')) {
+			S.gotoState('stopping');
+		}
+	}
+
+	S.on(smgr, 'stateChanged', function (st) {
+		switch (st) {
+		case 'error':
+			S.gotoState('retrying');
+			break;
+		case 'closed':
+			if (!self.csf_wanted) {
+				S.gotoState('stopped');
+			} else {
+				S.gotoState('connecting');
+			}
+			break;
+		default:
+			throw (new Error('Unhandled smgr state transition: ' +
+			    'connected => "' + st + '"'));
+		}
 	});
-	S.on(this, 'closeAsserted', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		S.gotoState('error');
+
+	S.on(this, 'claimAsserted', function () {
+		S.gotoState('busy');
 	});
-	if (this.cf_checkTimeout !== undefined &&
-	    this.cf_checkTimeout !== null) {
-		var t = S.timeout(this.cf_checkTimeout, function () {
-			var info = {};
-			info.stack = self.cf_claimStack;
-			self.cf_log.warn(info, 'connection held for longer ' +
-			    'than checkTimeout (%d ms), may have been leaked',
-			    self.cf_checkTimeout);
+
+	if (this.csf_checkTimeout !== undefined &&
+	    this.csf_checker !== undefined) {
+		S.timeout(this.csf_checkTimeout, function () {
+			doPingCheck(self, self.csf_checker);
 		});
-		t.unref();
 	}
 };
 
-function ConnectionHandle(cf) {
-	this.sh_cf = cf;
-	this.sh_claimed = true;
-	this.sh_error = false;
-	this.sh_releaseStack = [];
+function doPingCheck(fsm, checker) {
+	var hdlOpts = {
+		pool: fsm.csf_pool,
+		claimStack: 'Error\n' +
+		    'at claim\n' +
+		    'at cueball.doPingCheck\n' +
+		    'at cueball.doPingCheck\n',
+		callback: checker,
+		log: fsm.csf_log,
+		claimTimeout: Infinity
+	};
+	var handle = new CueBallClaimHandle(hdlOpts);
+	/*
+	 * Don't bother handling a return to "waiting" state here: if we
+	 * fail, it's fine, just let go of this handle entirely.
+	 */
+	handle.try(fsm);
 }
-ConnectionHandle.prototype.close = function () {
-	mod_assert.ok(this.sh_claimed, 'Connection not claimed by ' +
-	    'this handle, released by ' + this.sh_releaseStack[2]);
-	if (this.sh_error) {
-		this.sh_claimed = false;
-		return (undefined);
+
+ConnectionSlotFSM.prototype.state_busy = function (S) {
+	S.validTransitions(['idle', 'stopping', 'stopped', 'retrying',
+	    'killing', 'connecting']);
+	var self = this;
+	var smgr = this.csf_smgr;
+	var hdl = this.csf_handle;
+
+	function onRelease() {
+		if (smgr.isInState('connected')) {
+			if (self.csf_wanted) {
+				S.gotoState('idle');
+			} else {
+				S.gotoState('stopping');
+			}
+		} else if (smgr.isInState('closed')) {
+			if (self.csf_wanted) {
+				S.gotoState('connecting');
+			} else {
+				S.gotoState('stopped');
+			}
+		} else if (smgr.isInState('error')) {
+			S.gotoState('retrying');
+		} else {
+			throw (new Error('Handle released while smgr was ' +
+			    'in unhandled state "' + smgr.getState() + '"'));
+		}
 	}
-	return (this.sh_cf.close.apply(this.sh_cf, arguments));
-};
-ConnectionHandle.prototype.release = function () {
-	mod_assert.ok(this.sh_claimed, 'Connection not claimed by ' +
-	    'this handle, released by ' + this.sh_releaseStack[2]);
-	if (this.sh_error) {
-		this.sh_claimed = false;
-		return (undefined);
+
+	function onClose() {
+		if (smgr.isInState('connected')) {
+			S.gotoState('killing');
+		} else {
+			S.gotoState('retrying');
+		}
 	}
-	return (this.sh_cf.release.apply(this.sh_cf, arguments));
-};
-ConnectionHandle.prototype.closeAfterRelease = function () {
-	mod_assert.ok(this.sh_claimed, 'Connection not claimed by ' +
-	    'this handle, released by ' + this.sh_releaseStack[2]);
-	if (this.sh_error) {
-		this.sh_claimed = false;
-		return (undefined);
+
+	S.on(hdl, 'stateChanged', function (st) {
+		switch (st) {
+		case 'released':
+			S.immediate(onRelease);
+			break;
+		case 'closed':
+			S.immediate(onClose);
+			break;
+		default:
+			break;
+		}
+	});
+
+	/*
+	 * It's possible that the smgr has already moved out of 'connected'
+	 * by the time we get here.
+	 *
+	 * If we lose the race, treat it like our handle was released.
+	 */
+	if (smgr.isInState('connected')) {
+		var sock = smgr.getSocket();
+		if (typeof (sock.ref) === 'function')
+			sock.ref();
+		hdl.accept(sock);
+	} else {
+		hdl.reject();
+		this.csf_handle = undefined;
+		S.immediate(onRelease);
 	}
-	return (this.sh_cf.closeAfterRelease.apply(this.sh_cf,
-	    arguments));
+};
+
+ConnectionSlotFSM.prototype.state_killing = function (S) {
+	S.validTransitions(['retrying']);
+	var smgr = this.csf_smgr;
+
+	S.on(smgr, 'stateChanged', function (st) {
+		if (st === 'closed') {
+			S.gotoState('retrying');
+		}
+	});
+
+	smgr.close();
+};
+
+ConnectionSlotFSM.prototype.state_stopping = function (S) {
+	S.validTransitions(['stopped']);
+	var smgr = this.csf_smgr;
+
+	S.on(smgr, 'stateChanged', function (st) {
+		if (st === 'closed') {
+			S.gotoState('stopped');
+		}
+	});
+
+	smgr.close();
+};
+
+ConnectionSlotFSM.prototype.state_stopped = function (S) {
+	S.validTransitions([]);
+	var smgr = this.csf_smgr;
+	mod_assert.ok(smgr.isInState('closed') || smgr.isInState('error') ||
+	    smgr.isInState('failed'), 'smgr must be stopped');
+
 };
diff --git a/lib/pool-monitor.js b/lib/pool-monitor.js
index e6041d4..12baf97 100644
--- a/lib/pool-monitor.js
+++ b/lib/pool-monitor.js
@@ -119,19 +119,17 @@ CueBallPoolMonitor.prototype.toKangOptions = function () {
 		obj.fsms = {};
 		obj.connections = Object.keys(cset.cs_connections);
 		var ks = cset.cs_keys.slice();
-		Object.keys(cset.cs_fsms).forEach(function (k) {
+		Object.keys(cset.cs_fsm).forEach(function (k) {
 			if (ks.indexOf(k) === -1)
 				ks.push(k);
 		});
 		ks.forEach(function (k) {
-			var conns = cset.cs_fsms[k] || [];
+			var fsm = cset.cs_fsm[k];
 			obj.fsms[k] = {};
-			conns.forEach(function (fsm) {
-				var s = fsm.getState();
-				if (obj.fsms[k][s] === undefined)
-					obj.fsms[k][s] = 0;
-				++obj.fsms[k][s];
-			});
+			var s = fsm.getState();
+			if (obj.fsms[k][s] === undefined)
+				obj.fsms[k][s] = 0;
+			++obj.fsms[k][s];
 		});
 		obj.dead_backends = Object.keys(cset.cs_dead);
 		if (cset.cs_lastRebalance !== undefined) {
diff --git a/lib/pool.js b/lib/pool.js
index 3c44674..9d11e01 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -28,7 +28,9 @@ const FSM = mod_mooremachine.FSM;
 const EventEmitter = mod_events.EventEmitter;
 
 const Queue = require('./queue');
-const ConnectionFSM = require('./connection-fsm');
+const mod_connfsm = require('./connection-fsm');
+const ConnectionSlotFSM = mod_connfsm.ConnectionSlotFSM;
+const CueBallClaimHandle = mod_connfsm.CueBallClaimHandle;
 
 /*
  * Parameters for the EMA/low-pass filter that is used to limit pool shrinkage
@@ -257,18 +259,31 @@ CueBallConnectionPool.prototype.on_resolver_added = function (k, backend) {
 
 CueBallConnectionPool.prototype.on_resolver_removed = function (k) {
 	var idx = this.p_keys.indexOf(k);
-	if (idx !== -1)
-		this.p_keys.splice(idx, 1);
+	mod_assert.notStrictEqual(idx, -1, 'resolver key ' + k + ' not found');
+	this.p_keys.splice(idx, 1);
 	delete (this.p_backends[k]);
-	(this.p_connections[k] || []).forEach(function (fsm) {
-		if (fsm.isInState('busy'))
-			fsm.closeAfterRelease();
-		else
-			fsm.close();
-	});
-	delete (this.p_connections[k]);
 	delete (this.p_dead[k]);
-	this.rebalance();
+
+	var self = this;
+	mod_vasync.forEachParallel({
+		func: closeBackend,
+		inputs: (this.p_connections[k] || [])
+	}, function () {
+		mod_assert.strictEqual(self.p_connections[k].length, 0);
+		delete (self.p_connections[k]);
+		self.rebalance();
+	});
+	function closeBackend(fsm, cb) {
+		fsm.setUnwanted();
+		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
+			cb();
+		} else {
+			fsm.on('stateChanged', function (st) {
+				if (st === 'stopped' || st === 'failed')
+					cb();
+			});
+		}
+	}
 };
 
 CueBallConnectionPool.prototype.state_starting = function (S) {
@@ -407,14 +422,14 @@ CueBallConnectionPool.prototype.state_stopping.backends = function (S) {
 		S.gotoState('stopped');
 	});
 	function closeBackend(fsm, cb) {
-		if (fsm.isInState('busy')) {
-			fsm.closeAfterRelease();
+		fsm.setUnwanted();
+		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
+			cb();
+		} else {
 			fsm.on('stateChanged', function (st) {
-				if (st === 'closed')
+				if (st === 'stopped' || st === 'failed')
 					cb();
 			});
-		} else {
-			fsm.close(cb);
 		}
 	}
 };
@@ -526,31 +541,15 @@ CueBallConnectionPool.prototype._rebalance = function () {
 		    busy, spares, target);
 	}
 	plan.remove.forEach(function (fsm) {
+		/* This slot is no longer wanted. */
+		fsm.setUnwanted();
 		/*
-		 * Only tell the FSM to quit *right now* if either:
-		 *   1. it's idle
-		 *   2. there are other FSMs for this backend
-		 *   2. it is connected to a backend that has been
-		 *      removed from the resolver
-		 * Otherwise get it to quit gracefully once it's done
-		 * doing whatever it's doing (using closeAfterRelease).
-		 * This way we when we have a failing backend that we
-		 * want to mark as "dead" ASAP, we don't give up early
-		 * and never figure out if it's actually dead or not.
+		 * We may have changed to stopped or failed synchronously after
+		 * setting unwanted. If we have, don't count this as a socket
+		 * against our cap (it's been destroyed).
 		 */
-		var fsmIdx = self.p_connections[fsm.cf_backend.key].
-		    indexOf(fsm);
-		if (fsm.isInState('idle')) {
-			fsm.close();
+		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
 			--total;
-		} else if (fsm.isInState('busy')) {
-			fsm.closeAfterRelease();
-		} else if (fsmIdx > 0 ||
-		    self.p_keys.indexOf(fsm.cf_backend.key) === -1) {
-			fsm.close();
-			--total;
-		} else {
-			fsm.closeAfterRelease();
 		}
 	});
 	plan.add.forEach(function (k) {
@@ -571,14 +570,15 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 	var backend = this.p_backends[key];
 	backend.key = key;
 
-	var fsm = new ConnectionFSM({
+	var fsm = new ConnectionSlotFSM({
 		constructor: this.p_constructor,
 		backend: backend,
 		log: this.p_log,
 		pool: this,
 		checker: this.p_checker,
 		checkTimeout: this.p_checkTimeout,
-		recovery: this.p_recovery
+		recovery: this.p_recovery,
+		monitor: (this.p_dead[key] === true)
 	});
 	if (this.p_connections[key] === undefined)
 		this.p_connections[key] = [];
@@ -590,8 +590,8 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 	fsm.on('stateChanged', function (newState) {
 		if (fsm.p_initq_node) {
 			/* These transitions mean we're still starting up. */
-			if (newState === 'init' || newState === 'delay' ||
-			    newState === 'error' || newState === 'connect')
+			if (newState === 'init' || newState === 'connecting' ||
+			    newState === 'retrying')
 				return;
 			/*
 			 * As soon as we transition out of the init stages
@@ -620,7 +620,7 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 
 			/* Check to see if this backend has gone away. */
 			if (self.p_backends[key] === undefined) {
-				fsm.close();
+				fsm.setUnwanted();
 				return;
 			}
 
@@ -628,10 +628,12 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 			 * Try to eat up any waiters that are waiting on a
 			 * new connection.
 			 */
-			if (self.p_waiters.length > 0) {
-				var cb = self.p_waiters.shift();
-				fsm.claim(cb.stack, cb);
-				return;
+			while (self.p_waiters.length > 0) {
+				var hdl = self.p_waiters.shift();
+				if (hdl.isInState('waiting')) {
+					hdl.try(fsm);
+					return;
+				}
 			}
 
 			/* Otherwise, onto the idle queue we go! */
@@ -648,14 +650,15 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 		if (newState === 'ping' && !fsm.p_initq_node)
 			fsm.p_initq_node = self.p_initq.push(fsm);
 
-		if (newState === 'closed') {
+		if (newState === 'failed') {
+			self.p_dead[key] = true;
+		}
+
+		if (newState === 'stopped' || newState === 'failed') {
 			if (self.p_connections[key]) {
 				var idx = self.p_connections[key].indexOf(fsm);
 				self.p_connections[key].splice(idx, 1);
 			}
-			if (fsm.retriesExhausted()) {
-				self.p_dead[key] = true;
-			}
 			self.emit('closedBackend', key, fsm);
 			self.rebalance();
 		}
@@ -676,9 +679,32 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 	fsm.start();
 };
 
+CueBallConnectionPool.prototype.printConnections = function () {
+	var self = this;
+	var obj = { connections: {} };
+	var ks = self.p_keys.slice();
+	Object.keys(self.p_connections).forEach(function (k) {
+		if (ks.indexOf(k) === -1)
+			ks.push(k);
+	});
+	ks.forEach(function (k) {
+		var conns = self.p_connections[k] || [];
+		obj.connections[k] = {};
+		conns.forEach(function (fsm) {
+			var s = fsm.getState();
+			if (obj.connections[k][s] === undefined)
+				obj.connections[k][s] = 0;
+			++obj.connections[k][s];
+		});
+	});
+	console.log('live:', obj.connections);
+	console.log('dead:', self.p_dead);
+};
+
 CueBallConnectionPool.prototype.claim = function (options, cb) {
 	var self = this;
 	var done = false;
+	var handle;
 
 	if (typeof (options) === 'function' && cb === undefined) {
 		cb = options;
@@ -717,86 +743,58 @@ CueBallConnectionPool.prototype.claim = function (options, cb) {
 
 	var e = mod_utils.maybeCaptureStackTrace();
 
-	/* If there are idle connections sitting around, take one. */
-	while (this.p_idleq.length > 0) {
-		var fsm = this.p_idleq.shift();
-		delete (fsm.p_idleq_node);
-		/*
-		 * Since 'stateChanged' is emitted async from mooremachine,
-		 * things may be on the idle queue still but not actually idle.
-		 * If we find one, just rip it off the queue (which we've
-		 * already done) and try the next thing. The state mgmt
-		 * callback from addConnection will cope.
-		 */
-		if (!fsm.isInState('idle'))
-			continue;
-
-		fsm.claim(e.stack, function (err, hdl, conn) {
-			if (err) {
-				if (!done)
-					cb(err);
-				done = true;
-				return;
-			}
-			if (done) {
-				hdl.release();
-				return;
-			}
-			done = true;
-			cb(err, hdl, conn);
-		});
-		return ({
-			cancel: function () { done = true; }
-		});
-	}
+	handle = new CueBallClaimHandle({
+		pool: this,
+		claimStack: e.stack,
+		callback: cb,
+		log: this.p_log,
+		claimTimeout: timeout
+	});
 
-	if (errOnEmpty && this.p_resolver.count() < 1) {
-		setImmediate(function () {
-			if (!done)
-				cb(new mod_errors.NoBackendsError(self));
-			done = true;
-		});
-		return ({
-			cancel: function () { done = true; }
-		});
+	function waitingListener(st) {
+		if (st === 'waiting') {
+			tryNext();
+		}
 	}
+	handle.on('stateChanged', waitingListener);
 
-	/* Otherwise add an entry on the "waiter" queue. */
-	var timer;
-	var waiter = function () {
-		if (timer !== undefined)
-			clearTimeout(timer);
-		timer = undefined;
-		done = true;
-		cb.apply(this, arguments);
-	};
-	waiter.stack = e.stack;
-	var qnode = this.p_waiters.push(waiter);
-
-	this._hwmCounter('max-claim-queue', this.p_waiters.length);
-	this._incrCounter('queued-claim');
-
-	if (timeout !== Infinity) {
-		timer = setTimeout(function () {
-			if (timer === undefined)
-				return;
+	function tryNext() {
+		if (!handle.isInState('waiting'))
+			return;
 
-			qnode.remove();
-			done = true;
-			cb(new mod_errors.ClaimTimeoutError(self));
-		}, timeout);
+		/* If there are idle connections sitting around, take one. */
+		while (self.p_idleq.length > 0) {
+			var fsm = self.p_idleq.shift();
+			delete (fsm.p_idleq_node);
+			/*
+			 * Since 'stateChanged' is emitted async from
+			 * mooremachine, things may be on the idle queue still
+			 * but not actually idle. If we find one, just rip it
+			 * off the queue (which we've already done) and try the
+			 * next thing. The state mgmt callback from
+			 * addConnection will cope.
+			 */
+			if (!fsm.isInState('idle'))
+				continue;
+
+			handle.try(fsm);
+
+			return;
+		}
+
+		if (errOnEmpty && self.p_resolver.count() < 1) {
+			var err = new mod_errors.NoBackendsError(self);
+			handle.fail(err);
+		}
+
+		/* Otherwise add an entry on the "waiter" queue. */
+		self.p_waiters.push(handle);
+
+		self._hwmCounter('max-claim-queue', self.p_waiters.length);
+		self._incrCounter('queued-claim');
+
+		self.rebalance();
 	}
-	this.rebalance();
 
-	var handle = {};
-	handle.cancel = function () {
-		mod_assert.ok(done === false, 'callback was already called ' +
-		    'for this waiter handle');
-		if (timer !== undefined)
-			clearTimeout(timer);
-		timer = undefined;
-		qnode.remove();
-		done = true;
-	};
 	return (handle);
 };
diff --git a/lib/set.js b/lib/set.js
index 38fadd8..40d5af2 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -27,7 +27,9 @@ const FSM = mod_mooremachine.FSM;
 const EventEmitter = mod_events.EventEmitter;
 
 const Queue = require('./queue');
-const ConnectionFSM = require('./connection-fsm');
+const mod_cfsm = require('./connection-fsm');
+const ConnectionSlotFSM = mod_cfsm.ConnectionSlotFSM;
+const CueBallClaimHandle = mod_cfsm.CueBallClaimHandle;
 
 function CueBallConnectionSet(options) {
 	mod_assert.object(options);
@@ -64,10 +66,12 @@ function CueBallConnectionSet(options) {
 	this.cs_keys = [];
 	/* Map of backend key => backend info objects. */
 	this.cs_backends = {};
-	/* Map of backend key => array of ConnectionFSM instances. */
-	this.cs_fsms = {};
+	/* Map of backend key => ConnectionSlotFSM instance. */
+	this.cs_fsm = {};
 	/* Map of backend key => bool, if true the backend is declared dead. */
 	this.cs_dead = {};
+	/* Map of backend key => claim handle. */
+	this.cs_handles = {};
 
 	/*
 	 * Map of backend key => integer, latest serial number for connections
@@ -80,6 +84,11 @@ function CueBallConnectionSet(options) {
 	 * cs_constructor).
 	 */
 	this.cs_connections = {};
+	/* Map of backend key => Array of connection keys. */
+	this.cs_connectionKeys = {};
+
+	/* Map of connection key => bool, if true 'removed' has been emitted. */
+	this.cs_emitted = {};
 
 	/* For debugging, track when we last rebalanced. */
 	this.cs_lastRebalance = undefined;
@@ -138,22 +147,18 @@ CueBallConnectionSet.prototype.on_resolver_removed = function (k) {
 	delete (this.cs_backends[k]);
 	delete (this.cs_dead[k]);
 
-	var cks = Object.keys(this.cs_connections).filter(function (ck) {
-		return (ck.indexOf(k + '.') === 0);
-	});
+	var fsm = self.cs_fsm[k];
+	if (fsm !== undefined)
+		fsm.setUnwanted();
 
-	var fsms = self.cs_fsms[k] || [];
-	fsms.forEach(function (fsm) {
-		if (cks.length > 0 || fsm.isInState('idle')) {
-			fsm.closeAfterRelease();
-		} else {
-			fsm.close();
-		}
-	});
-	cks.forEach(function (ck) {
+	var cks = this.cs_connectionKeys[k];
+	(cks || []).forEach(function (ck) {
 		var conn = self.cs_connections[ck];
-		delete (self.cs_connections[ck]);
-		self.assertEmit('removed', ck, conn);
+		var hdl = self.cs_handles[ck];
+		if (self.cs_emitted[ck] !== true) {
+			self.cs_emitted[ck] = true;
+			self.assertEmit('removed', ck, conn, hdl);
+		}
 	});
 };
 
@@ -262,14 +267,12 @@ CueBallConnectionSet.prototype.state_running = function (S) {
 
 CueBallConnectionSet.prototype.state_stopping = function (S) {
 	S.validTransitions(['stopped']);
-	var conns = this.cs_fsms;
+	var conns = this.cs_fsm;
 	var fsms = [];
 	var self = this;
 	this.cs_backends = {};
 	Object.keys(conns).forEach(function (k) {
-		conns[k].forEach(function (fsm) {
-			fsms.push(fsm);
-		});
+		fsms.push(conns[k]);
 	});
 	mod_vasync.forEachParallel({
 		func: closeBackend,
@@ -283,25 +286,21 @@ CueBallConnectionSet.prototype.state_stopping = function (S) {
 			return;
 		}
 
-		var k = fsm.cf_backend.key;
-		var cks = Object.keys(self.cs_connections).filter(
-		    function (ck) {
-			return (ck.indexOf(k + '.') === 0);
-		});
+		var k = fsm.csf_backend.key;
+		var cks = self.cs_connectionKeys[k];
 		fsm.on('stateChanged', function (s) {
-			if (s === 'closed')
+			if (s === 'stopped' || s === 'failed')
 				cb();
 		});
-		if (cks.length === 0 && !fsm.isInState('idle')) {
-			fsm.close();
-		} else {
-			fsm.closeAfterRelease();
-			cks.forEach(function (ck) {
-				var conn = self.cs_connections[ck];
-				delete (self.cs_connections[ck]);
-				self.assertEmit('removed', ck, conn);
-			});
-		}
+		fsm.setUnwanted();
+		cks.forEach(function (ck) {
+			var conn = self.cs_connections[ck];
+			var hdl = self.cs_handles[ck];
+			if (self.cs_emitted[ck] !== true) {
+				self.cs_emitted[ck] = true;
+				self.assertEmit('removed', ck, conn, hdl);
+			}
+		});
 	}
 };
 
@@ -309,7 +308,7 @@ CueBallConnectionSet.prototype.state_stopped = function (S) {
 	S.validTransitions([]);
 	mod_monitor.monitor.unregisterSet(this);
 	this.cs_keys = [];
-	this.cs_fsms = {};
+	this.cs_fsm = {};
 	this.cs_connections = {};
 	this.cs_backends = {};
 	clearInterval(this.cs_rebalTimerInst);
@@ -375,7 +374,9 @@ CueBallConnectionSet.prototype._rebalance = function () {
 	var conns = {};
 	var total = 0;
 	this.cs_keys.forEach(function (k) {
-		conns[k] = (self.cs_fsms[k] || []).slice();
+		conns[k] = [];
+		if (self.cs_fsm[k] !== undefined)
+			conns[k].push(self.cs_fsm[k]);
 		total += conns[k].length;
 	});
 
@@ -397,7 +398,7 @@ CueBallConnectionSet.prototype._rebalance = function () {
 		if (total <= 1)
 			return;
 
-		var k = fsm.cf_backend.key;
+		var k = fsm.csf_backend.key;
 		/*
 		 * Find any advertised connections from this FSM, and (after
 		 * setting the closeAfterRelease flag to avoid them retrying),
@@ -407,38 +408,28 @@ CueBallConnectionSet.prototype._rebalance = function () {
 		    function (ck) {
 			return (ck.indexOf(k + '.') === 0);
 		});
-		/*
-		 * We can close the FSM immediately if we aren't advertising
-		 * any connections for it, and we aren't waiting on our consumer
-		 * to close any -- i.e., the FSM is in an error state, probably
-		 * delay or connect.
-		 *
-		 * Still want to avoid doing .close() on the *last* one for a
-		 * given backend, so it has a chance to run out of retries if
-		 * the backend is in fact dead. So we do .closeAfterRelease()
-		 * instead for those.
-		 */
-		if (cks.length === 0 && !fsm.isInState('idle')) {
-			var fsmIdx = self.cs_fsms[k].indexOf(fsm);
-			if (fsmIdx > 0 || self.cs_keys.indexOf(k) === -1) {
-				fsm.close();
-				--total;
-			} else {
-				fsm.closeAfterRelease();
-			}
-		} else {
-			fsm.closeAfterRelease();
+		fsm.setUnwanted();
+		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
+			delete (self.cs_fsm[k]);
+			--total;
 		}
 		cks.forEach(function (ck) {
 			var conn = self.cs_connections[ck];
-			delete (self.cs_connections[ck]);
-			self.assertEmit('removed', ck, conn);
+			var hdl = self.cs_handles[ck];
+			if (self.cs_emitted[ck] !== true) {
+				self.cs_emitted[ck] = true;
+				self.assertEmit('removed', ck, conn, hdl);
+			}
 		});
 	});
 	plan.add.forEach(function (k) {
 		/* Make sure we never exceed our socket limit. */
 		if (++total > (self.cs_max + 1))
 			return;
+		/* Never make more than one slot for the same backend. */
+		if (self.cs_fsm[k] !== undefined)
+			return;
+
 		self.addConnection(k);
 	});
 
@@ -456,6 +447,29 @@ CueBallConnectionSet.prototype.assertEmit = function () {
 	return (this.emit.apply(this, args));
 };
 
+function forceClaim(handle, fsm) {
+	handle.on('stateChanged', hdlStateListener);
+
+	function hdlStateListener(st) {
+		if (st === 'waiting' && handle.isInState('waiting')) {
+			if (fsm.isInState('idle')) {
+				handle.try(fsm);
+			} else {
+				fsm.on('stateChanged', fsmStateListener);
+			}
+		}
+	}
+
+	function fsmStateListener(st) {
+		if (st === 'idle' && fsm.isInState('idle')) {
+			fsm.removeListener('stateChanged', fsmStateListener);
+			if (handle.isInState('waiting')) {
+				handle.try(fsm);
+			}
+		}
+	}
+}
+
 CueBallConnectionSet.prototype.addConnection = function (key) {
 	if (this.isInState('stopping') || this.isInState('stopped'))
 		return;
@@ -463,90 +477,158 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 	var backend = this.cs_backends[key];
 	backend.key = key;
 
-	var fsm = new ConnectionFSM({
+	var fsm = new ConnectionSlotFSM({
 		constructor: this.cs_constructor,
 		backend: backend,
 		log: this.cs_log,
 		pool: this,
 		recovery: this.cs_recovery,
-		doRef: false
+		monitor: (this.cs_dead[key] === true)
 	});
-	if (this.cs_fsms[key] === undefined)
-		this.cs_fsms[key] = [];
 	if (this.cs_serials[key] === undefined)
 		this.cs_serials[key] = 1;
-	this.cs_fsms[key].push(fsm);
+	if (this.cs_connectionKeys[key] === undefined)
+		this.cs_connectionKeys[key] = [];
+	mod_assert.strictEqual(this.cs_fsm[key], undefined);
+	this.cs_fsm[key] = fsm;
 	var serial;
 	var ckey;
+	var smgr = fsm.getSocketMgr();
 
 	var self = this;
 	fsm.on('stateChanged', function (newState) {
+		if (newState === 'busy' && fsm.isInState('busy')) {
+			mod_assert.notStrictEqual(ckey, undefined);
+			mod_assert.notStrictEqual(self.cs_connections[ckey],
+			    undefined);
+			return;
+		}
+
+		/*
+		 * If we already have a ckey set for this FSM, and it exists in
+		 * cs_connections, then we previously got a connection and
+		 * claimed it. Any state transition (other than to "busy",
+		 * which was excluded above) now means this connection's
+		 * claim handle has been released/closed and we must clean up
+		 * the associated entries.
+		 */
+		if (ckey !== undefined &&
+		    self.cs_connections[ckey] !== undefined) {
+			mod_assert.ok(self.cs_emitted[ckey]);
+
+			delete (self.cs_connections[ckey]);
+			delete (self.cs_emitted[ckey]);
+			delete (self.cs_handles[ckey]);
+
+			var cks = self.cs_connectionKeys[key];
+			var ckIdx = cks.indexOf(ckey);
+			mod_assert.notStrictEqual(ckIdx, -1);
+			cks.splice(ckIdx, 1);
+
+			ckey = undefined;
+		}
+
 		if (newState === 'idle' && fsm.isInState('idle')) {
 			/*
 			 * If the backend has been removed from the resolver,
 			 * stop now.
 			 */
 			if (self.cs_backends[key] === undefined) {
-				fsm.close();
+				fsm.setUnwanted();
 				return;
 			}
 
 			if (serial === undefined) {
 				self.emit('connectedToBackend', key, fsm);
 			}
-			if (ckey !== undefined && self.cs_connections[ckey]) {
-				var conn = self.cs_connections[ckey];
-				delete (self.cs_connections[ckey]);
-				self.assertEmit('removed', ckey, conn);
+
+			/* We got a connection, so we're not dead. */
+			if (self.cs_dead[key] !== undefined) {
+				delete (self.cs_dead[key]);
 			}
 
-			conn = fsm.getConnection();
 			serial = self.cs_serials[key]++;
 			ckey = key + '.' + serial;
-			conn.cs_serial = serial;
 			fsm.cs_serial = serial;
 
-			self.cs_connections[ckey] = conn;
-			self.assertEmit('added', ckey, conn);
+			var hdlOpts = {
+				pool: self,
+				claimStack: 'Error\n' +
+				    ' at claim\n' +
+				    ' at CueBallConnectionSet.addConnection\n' +
+				    ' at CueBallConnectionSet.addConnection',
+				callback: afterClaim,
+				log: self.cs_log,
+				claimTimeout: Infinity
+			};
+			var handle = new CueBallClaimHandle(hdlOpts);
 
-			self.rebalance();
-			return;
-		}
+			self.cs_handles[ckey] = handle;
+			forceClaim(handle, fsm);
+
+			function afterClaim(err, hdl, conn) {
+				mod_assert.ok(!err);
+
+				conn.cs_serial = serial;
+				conn.cs_backendKey = key;
+				self.cs_connections[ckey] = conn;
+				self.cs_connectionKeys[key].push(ckey);
+
+				self.assertEmit('added', ckey, conn, hdl);
 
-		if (newState !== 'idle') {
-			if (self.cs_connections[ckey]) {
-				conn = self.cs_connections[ckey];
-				delete (self.cs_connections[ckey]);
-				self.assertEmit('removed', ckey, conn);
+				self.rebalance();
 			}
+			return;
 		}
 
-		if (newState === 'closed') {
-			if (self.cs_fsms[key]) {
-				var idx = self.cs_fsms[key].indexOf(fsm);
-				self.cs_fsms[key].splice(idx, 1);
-			}
+		if (newState === 'failed') {
 			/*
 			 * Set the dead flag, but not on a backend that's no
 			 * longer in the resolver.
 			 */
-			if (fsm.retriesExhausted() &&
-			    self.cs_backends[key] !== undefined) {
+			if (self.cs_backends[key] !== undefined) {
 				self.cs_dead[key] = true;
 			}
+		}
+
+		if (newState === 'stopped' || newState === 'failed') {
+			delete (self.cs_fsm[key]);
 			self.emit('closedBackend', fsm);
 			self.rebalance();
 			return;
 		}
 	});
 
+	smgr.on('stateChanged', function (newState) {
+		if (!fsm.isInState('busy'))
+			return;
+		if (newState === 'connected')
+			return;
+		/*
+		 * A transition out of 'connected' while the slot is still
+		 * 'busy' indicates that we lost the connection. We should
+		 * emit 'removed' for our clients.
+		 */
+		mod_assert.string(ckey);
+		if (self.cs_emitted[ckey] !== true) {
+			self.cs_emitted[ckey] = true;
+			self.assertEmit('removed', ckey,
+			    self.cs_connections[ckey], self.cs_handles[ckey]);
+		}
+	});
+
 	fsm.start();
 };
 
 CueBallConnectionSet.prototype.getConnections = function () {
 	var self = this;
-	return (Object.keys(this.cs_connections).map(function (k) {
-		return (self.cs_connections[k]);
+	var conns = [];
+	return (Object.keys(this.cs_connections).forEach(function (k) {
+		var c = self.cs_connections[k];
+		var fsm = self.cs_fsm[c.cs_backendKey];
+		var h = self.cs_handles[k];
+		if (fsm.isInState('busy') && h.isInState('claimed'))
+			conns.push(c);
 	}));
 };
 
diff --git a/package.json b/package.json
index 66801a0..c27d844 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "1.3.2",
+  "version": "2.0.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/cset.test.js b/test/cset.test.js
index 118c558..175ff78 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -108,7 +108,7 @@ mod_tape.test('cset with one backend', function (t) {
 			t.end();
 	});
 
-	cset.on('added', function (key, conn) {
+	cset.on('added', function (key, conn, hdl) {
 		t.notStrictEqual(connections.indexOf(conn), -1);
 		t.strictEqual(conn.refd, true);
 		if (connections.length > 1) {
@@ -122,10 +122,10 @@ mod_tape.test('cset with one backend', function (t) {
 		}
 	});
 
-	cset.on('removed', function (key, conn) {
+	cset.on('removed', function (key, conn, hdl) {
 		if (!cset.isInState('stopping'))
 			t.fail('removed ' + key);
-		conn.destroy();
+		hdl.release();
 	});
 
 	resolver.start();
@@ -133,9 +133,11 @@ mod_tape.test('cset with one backend', function (t) {
 
 	resolver.emit('added', 'b1', {});
 
-	setImmediate(function () {
+	setTimeout(function () {
 		connections.forEach(function (c) { c.connect(); });
-	});
+	}, 100);
+
+	setTimeout(function () {}, 5000);
 });
 
 mod_tape.test('cset with two backends', function (t) {
@@ -158,7 +160,7 @@ mod_tape.test('cset with two backends', function (t) {
 			t.end();
 	});
 
-	cset.on('added', function (key, conn) {
+	cset.on('added', function (key, conn, hdl) {
 		t.notStrictEqual(connections.indexOf(conn), -1);
 		t.strictEqual(conn.refd, true);
 		if (connections.length > 2) {
@@ -176,10 +178,10 @@ mod_tape.test('cset with two backends', function (t) {
 		}
 	});
 
-	cset.on('removed', function (key, conn) {
+	cset.on('removed', function (key, conn, hdl) {
 		if (!cset.isInState('stopping'))
 			t.fail();
-		conn.destroy();
+		hdl.release();
 	});
 
 	resolver.start();
@@ -218,10 +220,10 @@ mod_tape.test('cset swapping', function (t) {
 		inset.push(conn);
 	});
 
-	cset.on('removed', function (key, conn) {
+	cset.on('removed', function (key, conn, hdl) {
 		t.ok(!conn.dead);
 		conn.seen = true;
-		conn.destroy();
+		hdl.release();
 		var idx = inset.indexOf(conn);
 		if (idx !== -1)
 			inset.splice(idx, 1);
@@ -289,17 +291,21 @@ mod_tape.test('removing a backend', function (t) {
 		resolver: resolver
 	});
 
+	var stopTimer;
 	cset.on('stateChanged', function (st) {
-		if (st === 'stopped')
+		if (st === 'stopped') {
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
 			t.end();
+		}
 	});
 
 	cset.on('added', function (key, conn) {
 	});
 
-	cset.on('removed', function (key, conn) {
+	cset.on('removed', function (key, conn, hdl) {
 		conn.seen = true;
-		conn.destroy();
+		hdl.release();
 	});
 
 	resolver.emit('added', 'b1', {});
@@ -334,6 +340,7 @@ mod_tape.test('removing a backend', function (t) {
 				t.deepEqual(counts, { 'b1': 1 });
 				cset.stop();
 				resolver.stop();
+				stopTimer = setTimeout(function () {}, 5000);
 			}, 500);
 		}, 500);
 	});
@@ -354,17 +361,21 @@ mod_tape.test('removing an unused backend (cueball#47)', function (t) {
 		resolver: resolver
 	});
 
+	var stopTimer;
 	cset.on('stateChanged', function (st) {
-		if (st === 'stopped')
+		if (st === 'stopped') {
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
 			t.end();
+		}
 	});
 
 	cset.on('added', function (key, conn) {
 	});
 
-	cset.on('removed', function (key, conn) {
+	cset.on('removed', function (key, conn, hdl) {
 		conn.seen = true;
-		conn.destroy();
+		hdl.release();
 	});
 
 	resolver.emit('added', 'b1', {});
@@ -396,6 +407,8 @@ mod_tape.test('removing an unused backend (cueball#47)', function (t) {
 
 			cset.stop();
 			resolver.stop();
+
+			stopTimer = setTimeout(function () { }, 5000);
 		}, 500);
 	});
 });
@@ -416,14 +429,21 @@ mod_tape.test('cset with error', function (t) {
 		resolver: resolver
 	});
 
+	var stopTimer;
 	cset.on('stateChanged', function (st) {
 		if (st === 'stopped') {
 			t.ok(errorKey === undefined);
+			if (stopTimer !== undefined)
+				clearTimeout(stopTimer);
 			t.end();
 		}
 	});
 
 	var errorKey;
+	function silentErrHandler(err) {}
+	function failErrHandler(err) {
+		t.error(err);
+	}
 	cset.on('added', function (key, conn) {
 		t.notStrictEqual(connections.indexOf(conn), -1);
 		t.strictEqual(conn.refd, true);
@@ -436,19 +456,25 @@ mod_tape.test('cset with error', function (t) {
 			}).sort();
 			t.deepEqual(backends, ['b1', 'b2']);
 
+			conn.on('error', silentErrHandler);
 			errorKey = key;
 			conn.emit('error', new Error());
+		} else {
+			conn.on('error', failErrHandler);
 		}
 	});
 
-	cset.on('removed', function (key, conn) {
-		conn.destroy();
+	cset.on('removed', function (key, conn, hdl) {
+		conn.removeListener('error', silentErrHandler);
+		conn.removeListener('error', failErrHandler);
+		hdl.release();
 		if (key === errorKey) {
 			errorKey = undefined;
 			t.ok(conn.dead);
 
 			cset.stop();
 			resolver.stop();
+			stopTimer = setTimeout(function () {}, 5000);
 			return;
 		}
 		if (!cset.isInState('stopping'))
diff --git a/test/pool.test.js b/test/pool.test.js
index a461011..bc6c93a 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -25,7 +25,7 @@ var log = mod_bunyan.createLogger({
 	level: process.env.LOGLEVEL || 'debug'
 });
 var recovery = {
-	default: {timeout: 1000, retries: 1, delay: 50 }
+	default: {timeout: 500, retries: 1, delay: 0 }
 };
 
 function summarize() {
@@ -44,7 +44,14 @@ function summarize() {
 function DummyResolver() {
 	resolver = this;
 	this.state = 'stopped';
+	this.backends = {};
 	mod_events.EventEmitter.call(this);
+	this.on('added', function (key) {
+		resolver.backends[key] = true;
+	});
+	this.on('removed', function (key) {
+		delete (resolver.backends[key]);
+	});
 	return (new mod_resolver.ResolverFSM(this, {}));
 }
 mod_util.inherits(DummyResolver, mod_events.EventEmitter);
@@ -54,6 +61,9 @@ DummyResolver.prototype.start = function () {
 DummyResolver.prototype.stop = function () {
 	this.state = 'stopped';
 };
+DummyResolver.prototype.count = function () {
+	return (Object.keys(this.backends).length);
+};
 
 function DummyConnection(backend) {
 	connections.push(this);
@@ -62,6 +72,7 @@ function DummyConnection(backend) {
 	this.refd = true;
 	this.connected = false;
 	this.dead = false;
+	this.checked = false;
 	mod_events.EventEmitter.call(this);
 }
 mod_util.inherits(DummyConnection, mod_events.EventEmitter);
@@ -79,8 +90,8 @@ DummyConnection.prototype.ref = function () {
 };
 DummyConnection.prototype.destroy = function () {
 	var idx = connections.indexOf(this);
-	mod_assert.ok(idx !== -1);
-	connections.splice(idx, 1);
+	if (idx !== -1)
+		connections.splice(idx, 1);
 	this.connected = false;
 	this.dead = true;
 };
@@ -109,14 +120,15 @@ mod_tape.test('empty pool', function (t) {
 	t.strictEqual(resolver.state, 'running');
 	t.strictEqual(connections.length, 0);
 
-	t.throws(function () {
-		pool.claim({errorOnEmpty: true}, function (err) { });
-	});
-
-	pool.claim({timeout: 100}, function (err) {
+	pool.claim({errorOnEmpty: true}, function (err) {
 		t.ok(err);
-		t.ok(err.message.match(/timed out/i));
-		t.end();
+		t.ok(err.message.match(/no backend/i));
+
+		pool.claim({timeout: 100}, function (err2) {
+			t.ok(err2);
+			t.ok(err2.message.match(/timed out/i));
+			t.end();
+		});
 	});
 });
 
@@ -143,21 +155,24 @@ mod_tape.test('pool with one backend', function (t) {
 		t.strictEqual(connections[1].backend, 'b1');
 
 		/* The connections haven't emitted connect() yet. */
-		pool.claim({timeout: 0}, function (err) {
+		pool.claim({timeout: 100}, function (err) {
 			t.ok(err);
 			t.ok(err.message.match(/timed out/i));
 
 			connections.forEach(function (c) {
 				t.strictEqual(c.refd, true);
 				c.connect();
-				t.strictEqual(c.refd, false);
 			});
 
 			setImmediate(claimAgain);
 		});
 
 		function claimAgain() {
-			pool.claim({timeout: 0}, function (err, hdl, conn) {
+			connections.forEach(function (c) {
+				t.strictEqual(c.refd, false);
+			});
+
+			pool.claim({timeout: 100}, function (err, hdl, conn) {
 				t.error(err);
 				t.ok(hdl);
 				t.notStrictEqual(connections.indexOf(conn), -1);
@@ -168,7 +183,7 @@ mod_tape.test('pool with one backend', function (t) {
 		}
 
 		function claimOnceMore() {
-			pool.claim({timeout: 0}, function (err, hdl, conn) {
+			pool.claim({timeout: 100}, function (err, hdl, conn) {
 				t.error(err);
 				t.ok(hdl);
 				t.notStrictEqual(connections.indexOf(conn), -1);
@@ -177,7 +192,7 @@ mod_tape.test('pool with one backend', function (t) {
 		}
 
 		function claimEmpty() {
-			pool.claim({timeout: 0}, function (err) {
+			pool.claim({timeout: 100}, function (err) {
 				t.ok(err);
 				t.ok(err.message.match(/timed out/i));
 				t.end();
@@ -224,16 +239,16 @@ mod_tape.test('async claim can expand up to max', function (t) {
 				});
 			});
 
-			setImmediate(function () {
+			setTimeout(function () {
 				t.equal(connections.length, 2);
 				connections[1].connect();
-			});
+			}, 50);
 		});
 
-		setImmediate(function () {
+		setTimeout(function () {
 			t.equal(connections.length, 1);
 			connections[0].connect();
-		});
+		}, 50);
 	});
 });
 
@@ -266,7 +281,7 @@ mod_tape.test('spares are evenly balanced', function (t) {
 		resolver.emit('added', 'b3', {});
 		resolver.emit('added', 'b4', {});
 
-		setImmediate(function () {
+		setTimeout(function () {
 			connections.forEach(function (c) {
 				if (!c.connected)
 					c.connect();
@@ -278,7 +293,7 @@ mod_tape.test('spares are evenly balanced', function (t) {
 			t.deepEqual(bs2.sort(), ['b1', 'b2', 'b3', 'b4']);
 
 			t.end();
-		});
+		}, 50);
 	});
 });
 
@@ -305,6 +320,9 @@ mod_tape.test('error while claimed', function (t) {
 
 		pool.claim(function (err, handle, conn) {
 			t.strictEqual(conn, connections[0]);
+			conn.once('error', function () {
+				/* do nothing */
+			});
 			conn.emit('error', new Error('testing'));
 			handle.release();
 
@@ -319,6 +337,47 @@ mod_tape.test('error while claimed', function (t) {
 	});
 });
 
+mod_tape.test('close while idle', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 1,
+		maximum: 1,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 1);
+		var conn = connections[0];
+		conn.connect();
+
+		setTimeout(function () {
+			conn.emit('close');
+
+			setImmediate(function () {
+				t.ok(conn.dead);
+				t.equal(connections.length, 1);
+				t.notStrictEqual(conn, connections[0]);
+				t.ok(!connections[0].dead);
+				connections[0].connect();
+
+				t.strictEqual(conn.sm_fsm.fsm_history.
+				    indexOf('backoff'), -1);
+				pool.stop();
+				t.end();
+			});
+		}, 100);
+	});
+});
+
 mod_tape.test('removing a backend', function (t) {
 	connections = [];
 	resolver = undefined;
@@ -369,6 +428,12 @@ mod_tape.test('removing a backend', function (t) {
 
 			resolver.emit('removed', 'b2');
 
+			setTimeout(function () {
+				summarize();
+				if (counts.b2 > 0)
+					index.b2[0].emit('error', new Error());
+			}, 800);
+
 			setTimeout(function () {
 				t.ok(conn.dead);
 				t.equal(connections.length, 2);
@@ -376,14 +441,15 @@ mod_tape.test('removing a backend', function (t) {
 				t.deepEqual(counts, { 'b1': 2 });
 
 				pool.stop();
-			}, 500);
-		}, 500);
+			}, 1000);
+		}, 400);
 	});
 });
 
 mod_tape.test('pool failure', function (t) {
 	connections = [];
 	resolver = undefined;
+	var timer;
 
 	recovery.default.retries = 2;
 	var pool = new mod_pool.ConnectionPool({
@@ -400,6 +466,8 @@ mod_tape.test('pool failure', function (t) {
 
 	pool.on('stateChanged', function (st) {
 		if (st === 'stopped') {
+			if (timer !== undefined)
+				clearTimeout(timer);
 			t.end();
 		}
 	});
@@ -441,10 +509,14 @@ mod_tape.test('pool failure', function (t) {
 
 					index.b1[0].connect();
 
-					setImmediate(function () {
+					setTimeout(function () {
 						t.ok(pool.isInState('running'));
 						pool.stop();
-					});
+
+						/* Stop tape from giving up. */
+						timer = setTimeout(
+						    function () {}, 5000);
+					}, 100);
 				}, 100);
 			}, 100);
 		}, 100);
@@ -455,6 +527,7 @@ mod_tape.test('pool failure / retry race', function (t) {
 	connections = [];
 	resolver = undefined;
 
+	var timer;
 	recovery.default.retries = 2;
 	var pool = new mod_pool.ConnectionPool({
 		log: log,
@@ -470,6 +543,8 @@ mod_tape.test('pool failure / retry race', function (t) {
 
 	pool.on('stateChanged', function (st) {
 		if (st === 'stopped') {
+			if (timer !== undefined)
+				clearTimeout(timer);
 			t.end();
 		}
 	});
@@ -511,12 +586,78 @@ mod_tape.test('pool failure / retry race', function (t) {
 					t.deepEqual(counts, { 'b1': 2 });
 
 					pool.stop();
+					/* Stop tape from giving up. */
+					timer = setTimeout(function () {},
+					    5000);
 				}, 100);
 			}, 100);
 		}, 100);
 	});
 });
 
+mod_tape.test('pool ping checker', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		checkTimeout: 100,
+		checker: doCheck,
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped')
+			t.end();
+	});
+
+	function doCheck(err, hdl, conn) {
+		if (err)
+			return;
+		conn.checked = true;
+		hdl.release();
+	}
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		t.strictEqual(connections[0].backend, 'b1');
+		t.strictEqual(connections[1].backend, 'b1');
+
+		connections.forEach(function (c) {
+			t.strictEqual(c.refd, true);
+			c.connect();
+		});
+
+		pool.claim(function (err, hdl, conn) {
+			t.error(err);
+			t.strictEqual(conn.checked, false);
+
+			setTimeout(function () {
+				verifyCheck();
+				hdl.release();
+			}, 300);
+		});
+
+		function verifyCheck() {
+			var cs = connections.map(function (c) {
+				return (c.checked);
+			});
+			cs.sort();
+			t.deepEqual(cs, [false, true]);
+
+			pool.stop();
+		}
+	});
+});
+
 mod_tape.test('cleanup sandbox', function (t) {
 	sandbox.restore();
 	t.end();
