From 359750d837ac1a620c4a14ea856b31869362055c Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Thu, 19 Jan 2017 17:41:52 +0000
Subject: [PATCH] OS-5904 pwritev64 can't write at offsets between [2 GiB, 4
 GiB)

---
 usr/src/uts/common/syscall/rw.c | 50 +++++++++++++++++++++++----------
 1 file changed, 35 insertions(+), 15 deletions(-)

diff --git a/usr/src/uts/common/syscall/rw.c b/usr/src/uts/common/syscall/rw.c
index 943b7d244e..b9ee5587dc 100644
--- a/usr/src/uts/common/syscall/rw.c
+++ b/usr/src/uts/common/syscall/rw.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015, Joyent, Inc.  All rights reserved.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -999,19 +999,19 @@ preadv(int fdes, struct iovec *iovp, int iovcnt, off_t offset,
 	int error = 0;
 	int i;
 
+	/*
+	 * In a 64-bit kernel this interface supports native 64-bit applications
+	 * as well as 32-bit applications using both standard and large-file
+	 * access. For 32-bit large-file aware applications the offset is
+	 * passed as two parameters which are joined into the actual offset
+	 * used.
+	 */
 #if defined(_SYSCALL32_IMPL) || defined(_ILP32)
 	u_offset_t fileoff = ((u_offset_t)extended_offset << 32) |
 	    (u_offset_t)offset;
 #else /* _SYSCALL32_IMPL || _ILP32 */
 	u_offset_t fileoff = (u_offset_t)(ulong_t)offset;
 #endif /* _SYSCALL32_IMPR || _ILP32 */
-#ifdef _SYSCALL32_IMPL
-	const u_offset_t maxoff = get_udatamodel() == DATAMODEL_ILP32 &&
-	    extended_offset == 0?
-	    MAXOFF32_T : MAXOFFSET_T;
-#else /* _SYSCALL32_IMPL */
-	const u_offset_t maxoff = MAXOFF32_T;
-#endif /* _SYSCALL32_IMPL */
 
 	int in_crit = 0;
 
@@ -1099,10 +1099,27 @@ preadv(int fdes, struct iovec *iovp, int iovcnt, off_t offset,
 	vp = fp->f_vnode;
 	rwflag = 0;
 	if (vp->v_type == VREG) {
+		u_offset_t maxoff;
 
 		if (bcount == 0)
 			goto out;
 
+#ifdef _SYSCALL32_IMPL
+		/*
+		 * Because this function accepts the extended_offset argument,
+		 * we must check for 32-bit non-large file aware applications
+		 * and return an error if fileoff is too large.
+		 */
+		if (get_udatamodel() == DATAMODEL_ILP32 &&
+		    (fp->f_flag & FOFFMAX) == 0) {
+			maxoff = MAXOFF32_T;
+		} else {
+			maxoff = MAXOFFSET_T;
+		}
+#else /* _SYSCALL32_IMPL */
+		maxoff = MAXOFF32_T;
+#endif /* _SYSCALL32_IMPL */
+
 		/*
 		 * return EINVAL for offsets that cannot be
 		 * represented in an off_t.
@@ -1218,19 +1235,15 @@ pwritev(int fdes, struct iovec *iovp, int iovcnt, off_t offset,
 	int error = 0;
 	int i;
 
+	/*
+	 * See the comment in preadv for how the offset is handled.
+	 */
 #if defined(_SYSCALL32_IMPL) || defined(_ILP32)
 	u_offset_t fileoff = ((u_offset_t)extended_offset << 32) |
 	    (u_offset_t)offset;
 #else /* _SYSCALL32_IMPL || _ILP32 */
 	u_offset_t fileoff = (u_offset_t)(ulong_t)offset;
 #endif /* _SYSCALL32_IMPR || _ILP32 */
-#ifdef _SYSCALL32_IMPL
-	const u_offset_t maxoff = get_udatamodel() == DATAMODEL_ILP32 &&
-	    extended_offset == 0?
-	    MAXOFF32_T : MAXOFFSET_T;
-#else /* _SYSCALL32_IMPL */
-	const u_offset_t maxoff = MAXOFF32_T;
-#endif /* _SYSCALL32_IMPL */
 
 	int in_crit = 0;
 
@@ -1318,6 +1331,13 @@ pwritev(int fdes, struct iovec *iovp, int iovcnt, off_t offset,
 	vp = fp->f_vnode;
 	rwflag = 1;
 	if (vp->v_type == VREG) {
+		/*
+		 * The maxoff is always the proper value for the native
+		 * kernel. We also check for an invalid offset against
+		 * OFFSET_MAX(fp) below and return EFBIG if an overly large
+		 * offset is provided.
+		 */
+		u_offset_t maxoff = MAXOFFSET_T;
 
 		if (bcount == 0)
 			goto out;
-- 
2.21.0

