From 191e543a3e70bf08d6f69672c761835aa8c205cf Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 27 Jul 2016 16:31:57 -0700
Subject: [PATCH] joyent/node-sshpk-agent#5 Add certificate support after sshpk
 1.9.0 Reviewed by: Cody Mello <cody.mello@joyent.com>

---
 README.md               |  31 +++++++++
 lib/client.js           | 138 ++++++++++++++++++++++++++++++++++++++++
 lib/protocol.js         |  12 +++-
 package.json            |   4 +-
 test/basic.test.js      |  35 ++++++++--
 test/id_ecdsa3          |   5 ++
 test/id_ecdsa3-cert.pub |   1 +
 test/id_ecdsa3.pub      |   1 +
 test/key-mgmt.test.js   |  85 +++++++++++++++++++++++++
 test/ssh-agent-ctl.js   |   1 +
 10 files changed, 303 insertions(+), 10 deletions(-)
 create mode 100644 test/id_ecdsa3
 create mode 100644 test/id_ecdsa3-cert.pub
 create mode 100644 test/id_ecdsa3.pub

diff --git a/README.md b/README.md
index b078031..a43b490 100644
--- a/README.md
+++ b/README.md
@@ -78,6 +78,20 @@ Parameters
                subclasses
   - `keys` -- Array of `sshpk.Key` objects, the available public keys
 
+### `Client#listCertificates([options, ]callback);`
+
+Retrieves a list of all certificates stored in the agent.
+
+Parameters
+
+- `options` -- optional Object, containg properties:
+  - `timeout` -- an optional Number, overrides the constructor timeout just for
+                 this request
+- `callback` -- function `(error, keys)` with arguments:
+  - `error` -- null if no error, otherwise an instance of `Error` or its
+               subclasses
+  - `keys` -- Array of `sshpk.Certificate` objects, the available certificates
+
 ### `Client#sign(key, data[, options], callback);`
 
 Uses a key stored in the agent to sign some data.
@@ -108,6 +122,23 @@ Parameters
 - `callback` -- function `(error)` with arguments:
   - `error` -- null if no error, otherwise instance of `Error`
 
+### `Client#addCertificate(cert, privkey[, options], callback);`
+
+Adds a new certificate and private key pair to the agent.
+
+Parameters
+
+- `cert` -- an Object, instance of `sshpk.Certificate`, cert to add
+- `privkey` -- an Object, instance of `sshpk.PrivateKey`, subject private key
+               of the certificate
+- `options` -- optional Object, containing properties:
+  - `expires` -- optional Number, seconds until this key expires. If not given,
+                 key will last indefinitely. Expiry is handled by the agent
+                 itself.
+  - `timeout` -- optional Number, overrides the constructor timeout
+- `callback` -- function `(error)` with arguments:
+  - `error` -- null if no error, otherwise instance of `Error`
+
 ### `Client#removeKey(key[, options], callback);`
 
 Removes a private key from the agent.
diff --git a/lib/client.js b/lib/client.js
index 390e62f..16e8f3d 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -2,8 +2,10 @@
 
 var assert = require('assert-plus');
 var sshpk = require('sshpk');
+var sshpkUtils = require('sshpk/lib/utils');
 var util = require('util');
 var errs = require('./errors');
+var SSHBuffer = require('sshpk/lib/ssh-buffer');
 var AgentProtocolError = errs.AgentProtocolError;
 
 var ClientFSM = require('./client-fsm');
@@ -35,6 +37,12 @@ Client.prototype.listKeys = function (opts, cb) {
 		var keys = [];
 		for (var i = 0; i < resp.identities.length; ++i) {
 			var id = resp.identities[i];
+			var sshbuf = new SSHBuffer({ buffer: id.key });
+			var type = sshbuf.readString();
+			if (type.indexOf('-cert-') !== -1) {
+				/* Just skip over any certificates */
+				continue;
+			}
 			try {
 				var key = sshpk.parseKey(id.key, 'rfc4253');
 				key.comment = id.comment;
@@ -52,6 +60,52 @@ Client.prototype.listKeys = function (opts, cb) {
 	});
 };
 
+Client.prototype.listCertificates = function (opts, cb) {
+	if (typeof (opts) === 'function' && cb === undefined) {
+		cb = opts;
+		opts = {};
+	}
+	assert.object(opts, 'options');
+	assert.optionalNumber(opts.timeout, 'options.timeout');
+	var timeout = opts.timeout || this.timeout;
+	assert.func(cb, 'callback');
+
+	var frame = {type: 'request-identities'};
+	var resps = ['identities-answer'];
+
+	this.doRequest(frame, resps, timeout, function (err, resp) {
+		if (err) {
+			cb(err);
+			return;
+		}
+
+		var certs = [];
+		for (var i = 0; i < resp.identities.length; ++i) {
+			var id = resp.identities[i];
+			var sshbuf = new SSHBuffer({ buffer: id.key });
+			var type = sshbuf.readString();
+			if (type.indexOf('-cert-') === -1) {
+				/* Just skip over any plain keys */
+				continue;
+			}
+			try {
+				var cert = sshpk.Certificate.formats.openssh.
+				    fromBuffer(id.key);
+				cert.comment = id.comment;
+				certs.push(cert);
+			} catch (e) {
+				var err2 = new AgentProtocolError(resp,
+				    'Failed to parse cert in ssh-agent ' +
+				    'response: ' + e.name + ': ' + e.message);
+				cb(err2);
+				return;
+			}
+		}
+
+		cb(null, certs);
+	});
+};
+
 Client.prototype.sign = function (key, data, opts, cb) {
 	assert.object(key, 'key');
 	if (typeof (data) === 'string')
@@ -124,6 +178,90 @@ Client.prototype.sign = function (key, data, opts, cb) {
 	});
 };
 
+/*
+ * The agent protocol encodes the private keys that go with a given certificate
+ * as simply the private-only parts of the key appended to the certificate
+ * blob. We can't really expect sshpk itself to support this encoding (as
+ * it's not even documented, let alone used anywhere else).
+ */
+function certToBuffer(cert, k) {
+	var buf = sshpk.Certificate.formats.openssh.toBuffer(cert);
+	var sshbuf = new SSHBuffer({ buffer: buf });
+	var type = sshbuf.readString();
+
+	sshbuf = new SSHBuffer({});
+	sshbuf.writeString(type);
+	sshbuf.writeBuffer(buf);
+	switch (k.type) {
+	case 'dsa':
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.x.data));
+		break;
+	case 'ecdsa':
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.d.data));
+		break;
+	case 'rsa':
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.d.data));
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.iqmp.data));
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.p.data));
+		sshbuf.writeBuffer(sshpkUtils.mpNormalize(k.part.q.data));
+		break;
+	case 'ed25519':
+		/*
+		 * For some reason the public key gets encoded again for
+		 * ed25519 certs. The mysteries will never cease.
+		 */
+		sshbuf.writePart(k.part.R);
+		sshbuf.writePart(k.part.r);
+		break;
+	default:
+		throw (new Error('Key type ' + k.type + ' not supported'));
+	}
+	return (sshbuf.toBuffer());
+}
+
+Client.prototype.addCertificate = function (cert, key, opts, cb) {
+	assert.object(cert, 'cert');
+	assert.ok(sshpk.Certificate.isCertificate(cert, [1, 0]),
+	    'cert must be an sshpk.Certificate');
+	assert.object(key, 'key');
+	assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
+	    'key must be an sshpk.PrivateKey');
+	if (typeof (opts) === 'function' && cb === undefined) {
+		cb = opts;
+		opts = {};
+	}
+	assert.object(opts, 'options');
+	assert.optionalNumber(opts.timeout, 'options.timeout');
+	assert.optionalNumber(opts.expires, 'options.expires');
+	var timeout = opts.timeout || this.timeout;
+	assert.func(cb, 'callback');
+
+	var frame = {
+		type: 'add-identity',
+		privateKey: certToBuffer(cert, key),
+		comment: cert.comment || key.comment || ''
+	};
+	if (opts.expires !== undefined) {
+		frame.type = 'add-identity-constrained';
+		frame.constraints = [
+			{type: 'lifetime', seconds: opts.expires}
+		];
+	}
+	var resps = ['success', 'failure'];
+
+	this.doRequest(frame, resps, timeout, function (err, resp) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		if (resp.type === 'failure') {
+			cb(new Error('SSH agent returned failure'));
+			return;
+		}
+		cb(null);
+	});
+};
+
 Client.prototype.addKey = function (key, opts, cb) {
 	assert.object(key, 'key');
 	assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
diff --git a/lib/protocol.js b/lib/protocol.js
index 69891cb..57ab15f 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -165,9 +165,15 @@ var PrivateKey = {
 	decodeSize: function (buf, offset) {
 		var keyBuf = buf.slice(offset);
 		var ret = {};
-		sshpk.PrivateKey.formats.rfc4253.
-		    readInternal(ret, 'private', keyBuf);
-		return (ret.consumed);
+		try {
+			sshpk.PrivateKey.formats.rfc4253.
+			    readInternal(ret, 'private', keyBuf);
+			return (ret.consumed);
+		} catch (e) {
+			sshpk.Certificate.formats.openssh.fromBuffer(
+			    keyBuf, undefined, ret);
+			return (ret.consumed);
+		}
 	},
 	decode: function (buf, offset) {
 		var size = PrivateKey.decodeSize(buf, offset);
diff --git a/package.json b/package.json
index 28648b8..fbd79c2 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "sshpk-agent",
-  "version": "1.3.0",
+  "version": "1.4.0",
   "description": "ssh-agent client for use with sshpk",
   "main": "lib/index.js",
   "scripts": {
@@ -27,7 +27,7 @@
   "homepage": "https://github.com/arekinath/node-sshpk-agent#readme",
   "dependencies": {
     "assert-plus": "^1.0.0",
-    "sshpk": ">=1.7.0 <1.9",
+    "sshpk": ">=1.9.1 < 1.10.0",
     "mooremachine": "^1.0.0"
   },
   "devDependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 086b406..a2d9e1e 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -117,6 +117,31 @@ test('Client can list multiple keys', function (t) {
 	});
 });
 
+test('Client can list certificates', function (t) {
+	var c = new sshpkAgent.Client();
+	agent.addKey(path.join(testDir, 'id_ecdsa3'), function (err) {
+		t.error(err);
+		c.listKeys(function (err, keys) {
+			t.error(err);
+			t.ok(keys instanceof Array);
+			t.equal(keys.length, 3);
+
+			c.listCertificates(function (err, certs) {
+				t.error(err);
+				t.ok(Array.isArray(certs));
+				t.equal(certs.length, 1);
+
+				var s = certs[0].subjects[0];
+				t.strictEqual(s.type, 'host');
+				t.strictEqual(s.hostname, 'foobar.com');
+				t.strictEqual(certs[0].subjectKey.type,
+				    'ecdsa');
+				t.end();
+			});
+		})
+	});
+});
+
 /* Connection re-use disabled on node 0.8 because it lacks unref() */
 if (!process.version.match(/^v0\.[0-8]\./)) {
 	test('Client can re-use connection', function (t) {
@@ -248,7 +273,7 @@ if (ver >= [6, 5, 1]) {
 			c.listKeys(function (err, keys) {
 				t.error(err);
 
-				var key = keys[2];
+				var key = keys[3];
 				t.strictEqual(key.type, 'ed25519');
 				t.ok(ID_ED25519_FP.matches(key));
 
@@ -280,7 +305,7 @@ test('Client can sign data with a dsa key', function (t) {
 		c.listKeys(function (err, keys) {
 			t.error(err);
 
-			var key = keys[usedEd ? 3 : 2];
+			var key = keys[usedEd ? 4 : 3];
 			t.strictEqual(key.type, 'dsa');
 			t.ok(ID_DSA_FP.matches(key));
 
@@ -337,7 +362,7 @@ test('disconnected Client can\'t connect to stopped agent', function (t) {
 test('agent resume, client recovers from a socket error', function (t) {
 	c.listKeys({timeout: 500}, function (err, keys) {
 		t.error(err);
-		t.equal(keys.length, usedEd ? 4 : 3);
+		t.equal(keys.length, usedEd ? 5 : 4);
 		t.end();
 	});
 	c.c_socket.emit('error', new Error('dummy error'));
@@ -349,7 +374,7 @@ test('agent resume, client recovers from a socket error', function (t) {
 test('timed out Client reconnects and works', function (t) {
 	c.listKeys({timeout: 1000}, function (err, keys) {
 		t.error(err);
-		t.equal(keys.length, usedEd ? 4 : 3);
+		t.equal(keys.length, usedEd ? 5 : 4);
 		t.end();
 	});
 });
@@ -357,7 +382,7 @@ test('timed out Client reconnects and works', function (t) {
 test('disconnected Client reconnects and works', function (t) {
 	c2.listKeys({timeout: 1000}, function (err, keys) {
 		t.error(err);
-		t.equal(keys.length, usedEd ? 4 : 3);
+		t.equal(keys.length, usedEd ? 5 : 4);
 		t.end();
 	});
 });
diff --git a/test/id_ecdsa3 b/test/id_ecdsa3
new file mode 100644
index 0000000..6b6d83d
--- /dev/null
+++ b/test/id_ecdsa3
@@ -0,0 +1,5 @@
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIK+gCIsEpzV2bP4cQSLjhALRTbwzyWTwSSDsbmFdLw5soAoGCCqGSM49
+AwEHoUQDQgAENdMiBKZRRTiGRUpiMl6K+4mb62vm14xDQ+givETOxHtngkhLfF41
+ZvP+tol1GZ0k81QwQtrLUgsxJv+dlA0/Uw==
+-----END EC PRIVATE KEY-----
diff --git a/test/id_ecdsa3-cert.pub b/test/id_ecdsa3-cert.pub
new file mode 100644
index 0000000..5550f72
--- /dev/null
+++ b/test/id_ecdsa3-cert.pub
@@ -0,0 +1 @@
+ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgTVhus8lYDD1ysP/Ag8M9YKGIlhM5LNCTuZnqbEJ8zbcAAAAIbmlzdHAyNTYAAABBBDXTIgSmUUU4hkVKYjJeivuJm+tr5teMQ0PoIrxEzsR7Z4JIS3xeNWbz/raJdRmdJPNUMELay1ILMSb/nZQNP1MAAAAAAAAAAAAAAAIAAAAHdGVzdGluZwAAAA4AAAAKZm9vYmFyLmNvbQAAAABXmShQAAAAAFl5CrMAAAAAAAAAAAAAAAAAAABoAAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDXTIgSmUUU4hkVKYjJeivuJm+tr5teMQ0PoIrxEzsR7Z4JIS3xeNWbz/raJdRmdJPNUMELay1ILMSb/nZQNP1MAAABkAAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAABJAAAAIAwldYq/YMc+kKYOsDFHRxXGQpwY3AvzFRBd7OHoj4tvAAAAIQCR+xSVssITkcHUKk70JtBA5W92M7NAD3eftG6B6jvVcw== alex.wilson@awilson-mbp.local
diff --git a/test/id_ecdsa3.pub b/test/id_ecdsa3.pub
new file mode 100644
index 0000000..49a703f
--- /dev/null
+++ b/test/id_ecdsa3.pub
@@ -0,0 +1 @@
+ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDXTIgSmUUU4hkVKYjJeivuJm+tr5teMQ0PoIrxEzsR7Z4JIS3xeNWbz/raJdRmdJPNUMELay1ILMSb/nZQNP1M= alex.wilson@awilson-mbp.local
diff --git a/test/key-mgmt.test.js b/test/key-mgmt.test.js
index daa2f46..b38e242 100644
--- a/test/key-mgmt.test.js
+++ b/test/key-mgmt.test.js
@@ -18,6 +18,8 @@ var ID_ECDSA_FP = sshpk.parseFingerprint(
     'SHA256:e34c67Npv31uMtfVUEBJln5aOcJugzDaYGsj1Uph5DE');
 var ID_DSA_FP = sshpk.parseFingerprint(
     'SHA256:PCfwpK62grBWrAJceLetSNv9CTrX8yoD0miKf11DBG8');
+var ID_ED25519_FP = sshpk.parseFingerprint(
+    'SHA256:Mu6PkebM4ksg1M+dmhz+vw7gYPrKzeO2bCVqIEKKsis');
 
 test('setup', function (t) {
 	delete (process.env['SSH_AGENT_PID']);
@@ -96,6 +98,89 @@ test('Client can add an ECDSA key', function (t) {
 	});
 });
 
+test('Client can add an RSA certificate', function (t) {
+	var pem = fs.readFileSync(path.join(testDir, 'id_rsa'));
+	var pk = sshpk.parsePrivateKey(pem, 'pem', 'test/id_rsa');
+	var id = sshpk.identityForHost('testing.rsa');
+	var cert = sshpk.createSelfSignedCertificate(id, pk);
+	client.addCertificate(cert, pk, function (err) {
+		t.error(err);
+
+		client.listKeys(function (err, keys) {
+			t.error(err);
+			t.equal(keys.length, 3);
+
+			client.listCertificates(function (err2, certs) {
+				t.error(err2);
+				t.equal(certs.length, 1);
+				t.strictEqual(certs[0].subjects[0].type,
+				    'host');
+				t.strictEqual(certs[0].subjects[0].hostname,
+				    'testing.rsa');
+				t.ok(ID_RSA_FP.matches(certs[0].subjectKey),
+				    'fingerprint matches cert key');
+				t.end();
+			});
+		});
+	});
+});
+
+test('Client can add an ECDSA certificate', function (t) {
+	var pem = fs.readFileSync(path.join(testDir, 'id_ecdsa'));
+	var pk = sshpk.parsePrivateKey(pem, 'pem', 'test/id_ecdsa');
+	var id = sshpk.identityForHost('testing.ecdsa');
+	var cert = sshpk.createSelfSignedCertificate(id, pk);
+	client.addCertificate(cert, pk, function (err) {
+		t.error(err);
+
+		client.listKeys(function (err, keys) {
+			t.error(err);
+			t.equal(keys.length, 3);
+
+			client.listCertificates(function (err2, certs) {
+				t.error(err2);
+				t.equal(certs.length, 2);
+				t.strictEqual(certs[1].subjects[0].type,
+				    'host');
+				t.strictEqual(certs[1].subjects[0].hostname,
+				    'testing.ecdsa');
+				t.ok(ID_ECDSA_FP.matches(certs[1].subjectKey),
+				    'fingerprint matches cert key');
+				t.end();
+			});
+		});
+	});
+});
+
+test('Client can add an ED25519 certificate', function (t) {
+	var pem = fs.readFileSync(path.join(testDir, 'id_ed25519'));
+	var pk = sshpk.parsePrivateKey(pem, 'pem', 'test/id_ed25519');
+	var id = sshpk.identityForHost('testing.ed25519');
+	var cert = sshpk.createSelfSignedCertificate(id, pk);
+	client.addCertificate(cert, pk, function (err) {
+		t.error(err);
+
+		client.listKeys(function (err, keys) {
+			t.error(err);
+			t.equal(keys.length, 3);
+
+			client.listCertificates(function (err2, certs) {
+				t.error(err2);
+				t.equal(certs.length, 3);
+				t.strictEqual(certs[2].subjects[0].type,
+				    'host');
+				t.strictEqual(certs[2].subjects[0].hostname,
+				    'testing.ed25519');
+				t.strictEqual(certs[2].subjectKey.type,
+				    'ed25519');
+				t.ok(ID_ED25519_FP.matches(certs[2].subjectKey),
+				    'fingerprint matches cert key');
+				t.end();
+			});
+		});
+	});
+});
+
 test('Client can remove a key', function (t) {
 	client.listKeys(function (err, keys) {
 		t.error(err);
diff --git a/test/ssh-agent-ctl.js b/test/ssh-agent-ctl.js
index 28e9cee..28e76e9 100644
--- a/test/ssh-agent-ctl.js
+++ b/test/ssh-agent-ctl.js
@@ -46,6 +46,7 @@ Agent.prototype.open = function () {
     kid.stderr.on('data', function (chunk) {
         errBuf += chunk.toString('ascii');
     });
+    kid.stderr.pipe(process.stderr);
     kid.stdout.on('data', function (chunk) {
         buf += chunk.toString('ascii');
         var lines = buf.split('\n');
-- 
2.21.0

