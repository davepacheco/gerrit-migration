commit 5079abdabdeca168bda0190f9c5546ff14e4afa3 (refs/changes/49/1649/8)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-04-07T12:33:17-04:00 (2 years, 6 months ago)
    
    OS-6006 VM.start fails for zones that don't stay running very long

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 358d6d1f..153db3cb 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -92,6 +92,7 @@ var properties = require('./props');
 var Qmp = require('/usr/vm/node_modules/qmp').Qmp;
 var spawn = cp.spawn;
 var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
+var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var tty = require('tty');
 var util = require('util');
 var utils = require('./utils');
@@ -115,8 +116,24 @@ exports.FLATTENABLE_ARRAY_HASH_KEYS = FLATTENABLE_ARRAY_HASH_KEYS;
 exports.FLATTENABLE_HASH_KEYS = FLATTENABLE_HASH_KEYS;
 exports.KVM_MEM_OVERHEAD = KVM_MEM_OVERHEAD;
 
-// global handle for the zoneevent watcher
-var zoneevent;
+/*
+ * Global handle for the zoneevent watcher
+ *
+ * Retaining a global (per-process in this case) zone watcher object ensures
+ * that only one SyseventStream (and by extension, one instance of
+ * sysevent(1M)) is running at a time.  If multiple zone watchers are needed,
+ * they will use this global zone watcher object while the ref count is greater
+ * than 0.  The stream will be torn down when the ref count hits 0,
+ *
+ * ref: the current reference count for zone watchers allocated
+ * stream: the actual SyseventStream for watching sysevents
+ *
+ * See getZoneWatcher and freeZoneWatcher for more information
+ */
+var zonewatcher = {
+    ref: 0,
+    stream: null
+};
 
 /*
  * zone states from libzonecfg/common/zonecfg_impl.h
@@ -3477,14 +3494,23 @@ exports.getSysinfo = function (args, options, callback)
  *
  * payload needs to have at least .zonename and .uuid
  *
+ * returns a function that can be called to cancel the waiter (will result
+ * in the callback being called as well)
+ *
  */
 exports.waitForZoneState = function (payload, state, options, callback)
 {
+    assert.object(payload, 'payload');
+    assert.string(payload.uuid, 'payload.uuid');
+    assert.string(payload.zonename, 'payload.zonename');
+    assert.string(state, 'state');
+
     var log;
     var sysevent_state;
     var timeout;
     var timeout_secs = PROVISION_TIMEOUT;
     var tracers_obj;
+    var transitions_opts;
     var watcher;
 
     // options is optional
@@ -3492,6 +3518,8 @@ exports.waitForZoneState = function (payload, state, options, callback)
         callback = arguments[2];
         options = {};
     }
+    assert.object(options, 'options');
+    assert.func(callback, 'func');
 
     ensureLogging(false);
     if (options.hasOwnProperty('log')) {
@@ -3517,7 +3545,7 @@ exports.waitForZoneState = function (payload, state, options, callback)
         sysevent_state = 'uninitialized';
     }
 
-    function done() {
+    function done(err) {
         if (watcher) {
             watcher.cleanup();
         }
@@ -3525,20 +3553,24 @@ exports.waitForZoneState = function (payload, state, options, callback)
             clearTimeout(timeout);
             timeout = null;
         }
+        callback(err);
     }
 
-    function waitForZoneStateHandler(err, obj) {
-        if (err) {
-            done();
-            callback(err);
-            return;
-        }
+    function waitForZoneStateHandler(obj) {
         log.trace('handler got: ' + JSON.stringify(obj));
         if (obj.zonename !== payload.zonename) {
             return;
         }
 
         if (obj.newstate === sysevent_state) {
+            log.debug('event seen: zone_state "%s" -> "%s"',
+                obj.oldstate, obj.newstate);
+
+            if (options.skipConfirmation) {
+                done();
+                return;
+            }
+
             // Load again to confirm
             VM.lookup({'zonename': obj.zonename},
                 {fields: ['zone_state'], log: log},
@@ -3546,14 +3578,12 @@ exports.waitForZoneState = function (payload, state, options, callback)
                     var handler_retry;
 
                     if (error) {
-                        done();
-                        callback(error);
+                        done(error);
                         return;
                     }
 
                     if (res.length !== 1) {
-                        done();
-                        callback(new Error('lookup could no find VM '
+                        done(new Error('lookup could not find VM '
                             + obj.zonename));
                         return;
                     }
@@ -3565,7 +3595,6 @@ exports.waitForZoneState = function (payload, state, options, callback)
                         log.debug('saw zone go to ' + obj.newstate + ' ('
                             + state + ') calling callback()');
                         done();
-                        callback();
                     } else if (timeout) {
                         // we saw a state change to a state we don't care about
                         // so if we've not timed out try reloading again in a
@@ -3574,7 +3603,7 @@ exports.waitForZoneState = function (payload, state, options, callback)
                             handler_retry = setTimeout(function () {
                                 if (timeout) {
                                     // try again if wait timeout is still set
-                                    waitForZoneStateHandler(null, obj);
+                                    waitForZoneStateHandler(obj);
                                 }
                                 handler_retry = null;
                             }, 1000);
@@ -3587,22 +3616,33 @@ exports.waitForZoneState = function (payload, state, options, callback)
                     } else {
                         // no timeout set and we're not at the correct state
                         log.error('failed to reach state: ' + state);
-                        callback(new Error('failed to reach state: ' + state));
+                        done(new Error('failed to reach state: ' + state));
                     }
                 }
             );
         }
     }
 
-    watcher = watchZoneTransitions(waitForZoneStateHandler, log);
+    transitions_opts = {
+        log: log,
+        stream: options.stream
+    };
+    watcher = watchZoneTransitions(transitions_opts, waitForZoneStateHandler,
+        function (err) {
+
+        if (err) {
+            // there was an error creating the zone watcher, we can't continue
+            done(err);
+        }
+    });
 
     timeout = setTimeout(function () {
         var err;
 
-        done();
         err = new Error('timed out waiting for zone to transition to ' + state);
         err.code = 'ETIMEOUT';
-        callback(err);
+
+        done(err);
     }, timeout_secs * 1000);
 
     // after we've started the watcher (if we checked before there'd be a race)
@@ -3612,127 +3652,148 @@ exports.waitForZoneState = function (payload, state, options, callback)
         function (err, obj) {
 
         if (err) {
-            done();
-            callback(err);
+            done(err);
         } else if (obj.hasOwnProperty('zone_state')
             && obj.zone_state === state) {
 
-            done();
             log.info('VM is in state ' + state);
-            callback(); // at correct state!
+            done(); // at correct state!
         }
     });
-};
 
-// handler() will be called with an object describing the transition for any
-// transitions seen (after any filtering).  The only filtering here is to remove
-// duplicate events.  Other filtering should be done by the caller.
-//
-// This function returns an object that includes a 'cleanup' property. The
-// value of this property is a function that must be called to free the listener
-// when the caller is done with it.
-function watchZoneTransitions(handler, log) {
-    var buffer = '';
-    var chunks;
-
-    assert(log, 'no logger passed to watchZoneTransitions()');
-
-    if (!zoneevent) {
-        zoneevent = new EventEmitter();
-
-        log.debug('/usr/vm/sbin/zoneevent');
-        zoneevent.watcher = spawn('/usr/vm/sbin/zoneevent', [],
-            {'customFds': [-1, -1, -1]});
-        log.debug('zoneevent running with pid ' + zoneevent.watcher.pid);
-
-        zoneevent.watcher.stdout.on('data', function (data) {
-            var chunk;
-            var obj;
-            var prev_msg;
-
-            buffer += data.toString();
-            chunks = buffer.split('\n');
-            while (chunks.length > 1) {
-                chunk = chunks.shift();
-                obj = JSON.parse(chunk);
-
-                if (obj === prev_msg) {
-                    // Note: sometimes sysevent emits multiple events for the
-                    // same status, we only want the first one here because just
-                    // because sysevent does it, doesn't make it right.
-                    log.debug('duplicate zoneevent message! '
-                        + JSON.stringify(obj));
-                } else if (zoneevent) {
-                    zoneevent.emit('zoneevent', null, obj);
-                }
-            }
-            buffer = chunks.pop();
-        });
+    return done;
+};
 
-        // doesn't take input.
-        zoneevent.watcher.stdin.end();
+/*
+ * watchZoneTransitions will create a sysevent zone watcher (if needed) and
+ * register handler() to be called with an object describing the transition for
+ * any transitions seen.
+ *
+ * The callback function given as the final argument will be called when the
+ * zone event watcher is ready to start receiving events.
+ *
+ * opts.stream is an optional zonewatcher stream that may have been allocated
+ * already with a call to getZoneWatcher; if this is unset, one will be
+ * allocated for you.
+ *
+ * This function returns an object that includes a 'cleanup' property. The
+ * value of this property is a function that must be called to free the listener
+ * when the caller is done with it.  This will call freeZoneWatcher for the
+ * zone watcher used (either created by this function, or passed in as an
+ * argument)
+ */
+function watchZoneTransitions(opts, handler, cb) {
+    var stream;
 
-        zoneevent.watcher.on('exit', function (code) {
-            log.warn('zoneevent watcher ' + zoneevent.watcher.pid + ' exited: ',
-                JSON.stringify(code));
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalObject(opts.zonewatcher, 'opts.zonewatcher');
+    assert.func(handler, 'handler');
+    assert.func(cb, 'cb');
 
-            // watcher is dead.
-            zoneevent.watcher = null;
+    var log = opts.log;
 
-            // tell all the listeners of this zoneevent (if there are any) that
-            // we exited.  Then null it out so next time we'll make a new one.
-            if (zoneevent) {
-                zoneevent.emit('zoneevent', new Error('zoneevent watcher exited'
-                    + ' prematurely with code: ' + code));
-                zoneevent = null;
+    if (opts.stream) {
+        stream = opts.stream;
+        ready();
+    } else {
+        getZoneWatcher({log: log}, function (err, _stream) {
+            if (err) {
+                log.error({err: err}, 'getZoneWatcher failed');
+                cb(err);
+                return;
             }
+
+            stream = _stream;
+            ready();
         });
+    }
+
+    function ready() {
+        stream.on('data', ondata);
+        cb();
+    }
 
-        zoneevent.cleanup = function _zoneeventCleanup(_handler) {
-            var res;
+    function ondata(ev) {
+        var obj = ev.data;
+        handler(obj);
+    }
 
-            log.debug('cleanup called w/ listeners: '
-                + util.inspect(zoneevent.listeners('zoneevent')));
-            zoneevent.removeListener('zoneevent', _handler);
-            if (zoneevent.listeners('zoneevent').length === 0) {
-                assert.ok(zoneevent.watcher, 'should have zoneevent.watcher');
+    // return a closure that includes the handler that was passed in
+    return ({
+        cleanup: function _handlerCleanup() {
+            if (stream) {
+                stream.removeListener('data', ondata);
+            }
+            freeZoneWatcher({log: log});
+        }
+    });
+}
 
-                log.debug('zoneevent watcher ' + zoneevent.watcher.pid
-                    + ' cleanup called');
+/*
+ * This function will return a SyseventStream set to watch for zone state
+ * related events.
+ *
+ * If a stream already exists for this process the global ref count will be
+ * bumped and the existing stream will be returned.  Otherwise, a new stream
+ * will be created.
+ *
+ * cb() will be called with the stream created when it is ready
+ */
+function getZoneWatcher(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
 
-                // destroy std{out,err} so we don't send more 'data' events
-                zoneevent.watcher.stdout.destroy();
-                zoneevent.watcher.stderr.destroy();
+    var log = opts.log;
 
-                // remove 'exit' listener so we don't fail on kill
-                zoneevent.watcher.removeAllListeners('exit');
+    if (zonewatcher.ref++ > 0) {
+        assert(zonewatcher.stream, 'ref > 0 but no zone watcher');
+        log.debug({ref: zonewatcher.ref},
+            'getZoneWatcher using existing zone watcher');
+        cb(null, zonewatcher.stream);
+        return;
+    }
 
-                // kill the watcher so zoneevent child doesn't leak
-                log.debug({watcher_pid: zoneevent.watcher.pid},
-                    'killing watcher');
-                res = zoneevent.watcher.kill();
-                assert.ok(res, 'expected zoneevent.watcher.kill() to succeed');
-                assert.ok(zoneevent.watcher.killed,
-                    'expected watcher to be killed');
+    var ses_opts = {
+        logger: opts.log,
+        class: 'status',
+        channel: 'com.sun:zones:status'
+    };
+    zonewatcher.stream = new SyseventStream(ses_opts);
+    zonewatcher.stream.on('ready', function () {
+        log.debug('getZoneWatcher new zone watcher ready');
+        cb(null, zonewatcher.stream);
+    });
+}
 
-                zoneevent = null;
-            } else {
-                log.debug({
-                    watcher_pid: zoneevent.watcher.pid,
-                    listeners: zoneevent.listeners('zoneevent').length
-                }, 'still have listeners on this zoneevent');
-            }
-        };
+/*
+ * This function will free a single zone watcher, decrement the refcount, and
+ * tear down the global zone event sysevent stream if the ref count is 0.
+ *
+ * Note that you should remove any 'data' event listener you have added to the
+ * stream while using it, as this logic only handles decrementing the ref
+ * count.
+ */
+function freeZoneWatcher(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+
+    var log = opts.log;
+
+    if (zonewatcher.ref === 0) {
+        log.debug('freeZoneWatcher no zone watchers allocated');
+        assert(!zonewatcher.stream, 'stream exists while ref count is 0');
+        return;
     }
 
-    zoneevent.on('zoneevent', handler);
+    zonewatcher.ref--;
 
-    // return a closure that includes the handler that was passed in
-    return ({
-        cleanup: function _handlerCleanup() {
-            zoneevent.cleanup(handler);
-        }
-    });
+    if (zonewatcher.ref === 0) {
+        log.debug('freeZoneWatcher ref count is zero, stopping stream');
+        zonewatcher.stream.stop();
+        delete zonewatcher.stream;
+    }
 }
 
 function fixPayloadMemory(payload, vmobj, log)
@@ -10318,6 +10379,7 @@ function startZone(vmobj, opts, callback)
     var uuid = vmobj.uuid;
     var waited = false;
     var waitErr;
+    var zonestream;
 
     assert(log, 'no logger passed to startZone()');
 
@@ -10352,18 +10414,87 @@ function startZone(vmobj, opts, callback)
             }
             cb();
         }, function (cb) {
-            // do the booting
-            zoneadm(['-u', uuid, 'boot', '-X'], log, function (err, boot_fds) {
+            // get a zone watcher object if a waiting function is not passed in
+            if (opts.state_waiter) {
+                cb();
+                return;
+            }
+
+            getZoneWatcher({log: log}, function (err, _stream) {
                 if (err) {
-                    log.error({err: err, stdout: boot_fds.stdout,
-                        stderr: boot_fds.stderr}, 'zoneadm failed to boot '
-                        + 'VM');
-                } else {
-                    log.debug({stdout: boot_fds.stdout,
-                        stderr: boot_fds.stderr}, 'zoneadm booted VM');
+                    cb(err);
+                    return;
                 }
-                cb(err);
+
+                zonestream = _stream;
+                cb();
             });
+        }, function (cb) {
+            var cancel;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    // if we already have a state_waiter we can skip blocking
+                    // on waitForZoneState
+                    if (opts.state_waiter) {
+                        assert(!zonestream,
+                            'zone stream set with state_waiter');
+                        cb2();
+                        return;
+                    }
+
+                    // call waitForZoneState with the zonestream we allocated
+                    // above
+                    assert(zonestream, 'zone stream not set');
+                    var _opts = {
+                        timeout: 30,
+                        log: log,
+                        skipConfirmation: true,
+                        stream: zonestream
+                    };
+                    cancel = VM.waitForZoneState(vmobj, 'running', _opts,
+                        function (err, result) {
+
+                        if (err) {
+                            if (err.code === 'ETIMEOUT') {
+                                log.info({err: err},
+                                    'timeout waiting for zone to go to '
+                                    + '"running"');
+                            } else {
+                                log.error({err: err},
+                                    'unknown error waiting for zone to '
+                                    + 'go to "running"');
+                            }
+                            cb2(err);
+                            return;
+                        }
+
+                        log.info('VM switched to "running"');
+                        cb2();
+                    });
+                }, function (cb2) {
+                    // do the booting
+                    zoneadm(['-u', uuid, 'boot', '-X'], log,
+                        function (err, boot_fds) {
+
+                        if (err) {
+                            log.error({err: err, stdout: boot_fds.stdout,
+                                stderr: boot_fds.stderr},
+                                'zoneadm failed to boot VM');
+                            if (cancel) {
+                                cancel();
+                            }
+                            cb2(err);
+                            return;
+                        }
+
+                        log.debug({stdout: boot_fds.stdout,
+                            stderr: boot_fds.stderr},
+                            'zoneadm booted VM');
+                        cb2();
+                    });
+                }
+            ]}, cb);
         }, function (cb) {
             // Ensure it booted. If caller passed in a function that can wait
             // for a zone to go to a state, we'll just call that.
@@ -10379,24 +10510,7 @@ function startZone(vmobj, opts, callback)
                 return;
             }
 
-            // with no opts.state_waiter, we use our own VM.waitForZoneState
-            VM.waitForZoneState(vmobj, 'running', {timeout: 30, log: log},
-                function (err, result) {
-
-                if (err) {
-                    if (err.code === 'ETIMEOUT') {
-                        log.info(err, 'timeout waiting for zone to go to '
-                            + '"running"');
-                    } else {
-                        log.error(err, 'unknown error waiting for zone to go'
-                            + ' "running"');
-                    }
-                } else {
-                    // zone got to running
-                    log.info('VM seems to have switched to "running"');
-                }
-                cb(err);
-            });
+            cb();
         }, function (cb) {
             if (vmobj.docker && vmobj.internal_metadata
                 && !vmobj.internal_metadata['docker:restartpolicy']) {
@@ -14291,38 +14405,35 @@ function doReboot(vmobj, options, callback)
     }
 
     async.series([function (cb) {
-        if (!reboot_async) {
-            watcherobj = watchZoneTransitions(function _rebootHandler(err, ze) {
-                if (!err && ze.zonename !== vmobj.zonename) {
-                    // not something we need to handle
-                    return;
-                }
+        if (reboot_async) {
+            cb();
+            return;
+        }
 
-                if (err) {
-                    // XXX what should we do here?
-                    log.error(err);
-                    return;
-                }
+        watcherobj = watchZoneTransitions({log: log},
+            function _rebootHandler(ze) {
+
+            if (ze.zonename !== vmobj.zonename) {
+                // not something we need to handle
+                return;
+            }
 
-                log.debug(ze); // TODO move to trace
+            log.trace(ze);
 
-                if (ze.newstate === 'running' && ze.oldstate !== 'running') {
-                    if (watcherobj) {
-                        // cleanup our watcher since we found what we're
-                        // looking for.
-                        if (cleanup) {
-                            cleanup();
-                            cleanup = null;
-                        }
+            if (ze.newstate === 'running' && ze.oldstate !== 'running') {
+                if (watcherobj) {
+                    // cleanup our watcher since we found what we're
+                    // looking for.
+                    if (cleanup) {
+                        cleanup();
+                        cleanup = null;
                     }
-
-                    reboot_complete = true;
                 }
-            }, log);
-            cleanup = watcherobj.cleanup;
-        }
 
-        cb();
+                reboot_complete = true;
+            }
+        }, cb);
+        cleanup = watcherobj.cleanup;
     }, function (cb) {
         var args;
 
