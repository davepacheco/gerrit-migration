From b74afa33e25aff7409f69b2b23fa0c3771cc6f45 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Thu, 16 Aug 2018 15:24:05 +0000
Subject: [PATCH] OS-7138 vmadm support for requirements.bootrom Reviewed by:
 Pedro Palazon Candel <pedro@joyent.com> Approved by: Pedro Palazon Candel
 <pedro@joyent.com>

---
 src/vm/node_modules/VM.js       |  71 ++++++++++-
 src/vm/runtest                  |  67 ++++++++++
 src/vm/tests/test-bhyve-uefi.js | 214 ++++++++++++++++++++++++++++++++
 3 files changed, 346 insertions(+), 6 deletions(-)
 create mode 100644 src/vm/tests/test-bhyve-uefi.js

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index ac43db55..5c6d76f3 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -780,6 +780,7 @@ function validateProperty(brand, prop, value, action, data, errors, log)
 /*
  * image properties:
  *
+ *  bootrom (optional, only used by some bhyve zones)
  *  size (optional, only used by zvols)
  *  type ('zvol' or 'zone-dataset')
  *  uuid
@@ -816,10 +817,12 @@ function validateImage(image, log, callback)
         }
 
         if (data.hasOwnProperty('manifest')) {
-            if (image.types.indexOf(data.manifest.type) === -1) {
+            var manifest = data.manifest;
+
+            if (image.types.indexOf(manifest.type) === -1) {
                 // image is wrong type
                 e = new Error('image ' + image.uuid + ' is type '
-                    + data.manifest.type + ', but must be one of: '
+                    + manifest.type + ', but must be one of: '
                     + JSON.stringify(image.types));
                 e.whatFailed = 'EBADTYPE';
                 log.error(e);
@@ -829,13 +832,13 @@ function validateImage(image, log, callback)
             log.info('image ' + image.uuid + ' found in imgadm');
 
             // If image_size is missing, add it. If it's wrong, error.
-            if (data.manifest.hasOwnProperty('image_size')) {
+            if (manifest.hasOwnProperty('image_size')) {
                 if (image.hasOwnProperty('size')) {
-                    if (image.size !== data.manifest.image_size) {
+                    if (image.size !== manifest.image_size) {
                         e = new Error('incorrect image_size value for image'
                             + ' ' + image.uuid + ' passed: '
                             + image.size + ' should be: '
-                            + data.manifest.image_size);
+                            + manifest.image_size);
                         e.whatFailed = 'EBADSIZE';
                         log.error(e);
                         callback(e);
@@ -843,9 +846,44 @@ function validateImage(image, log, callback)
                     }
                 } else {
                     // image doesn't have size, manifest does, add it.
-                    image.size = data.manifest.image_size;
+                    image.size = manifest.image_size;
+                }
+            }
+
+            if (manifest.hasOwnProperty('requirements')) {
+                var req = manifest.requirements;
+
+                // If requirements.bootrom is set in the manifest:
+                //  - If it is also set in the payload, verify that they match
+                //  - If not set in payload, return the found value so that the
+                //    caller may use it.
+                if (req.hasOwnProperty('bootrom')) {
+                    if (image.hasOwnProperty('bootrom')) {
+                        if (image.bootrom !== req.bootrom) {
+                            e = new Error('invalid bootrom value for image '
+                                + image.uuid + ' passed: ' + image.bootrom
+                                + ' should be: ' + req.bootrom);
+                            e.whatFailed = 'EBADBOOTROM';
+                            log.error(e);
+                            callback(e);
+                            return;
+                        }
+                    } else {
+                        image.bootrom = req.bootrom;
+                    }
+                } else if (image.hasOwnProperty('bootrom')) {
+                    if (image.bootrom !== 'bios') {
+                        e = new Error('invalid bootrom value for image '
+                            + image.uuid + ' passed: ' + image.bootrom
+                            + ' should be: bios');
+                        e.whatFailed = 'EBADBOOTROM';
+                        log.error(e);
+                        callback(e);
+                        return;
+                    }
                 }
             }
+
             // everything ok
             callback();
         } else {
@@ -899,6 +937,7 @@ function validateImages(payload, brand, errors, log, callback)
     var pool;
     var tracers_obj;
     var zoneroot_types = ['zone-dataset'];
+    var bootrom;
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('validate-images', log, callback);
@@ -910,6 +949,10 @@ function validateImages(payload, brand, errors, log, callback)
         zoneroot_types = BRAND_OPTIONS[brand].features.zoneroot_image_types;
     }
 
+    if (payload.hasOwnProperty('bootrom')) {
+        bootrom = payload.bootrom;
+    }
+
     if (payload.hasOwnProperty('image_uuid') && isUUID(payload.image_uuid)) {
         if (payload.hasOwnProperty('zpool')) {
             pool = payload.zpool;
@@ -965,6 +1008,13 @@ function validateImages(payload, brand, errors, log, callback)
             i.size = image.target.image_size;
         }
 
+        // Only worry about matching bootrom to any bootrom on the boot disk's
+        // image.
+        if (bootrom && image.target.hasOwnProperty('boot')
+            && image.target.boot) {
+            i.bootrom = bootrom;
+        }
+
         validateImage(i, log, function (err) {
             if (err) {
                 switch (err.whatFailed) {
@@ -981,6 +1031,10 @@ function validateImages(payload, brand, errors, log, callback)
                         // image.type is wrong
                         errors.bad_values.push(image.property);
                         break;
+                    case 'EBADBOOTROM':
+                        // image.bootrom is wrong
+                        errors.bad_values.push('bootrom');
+                        break;
                     default:
                         // unknown error, fail closed
                         errors.bad_values.push(image.property);
@@ -1000,6 +1054,11 @@ function validateImages(payload, brand, errors, log, callback)
                         }
                     }
                 }
+                // If bootrom is not in the payload but was on the boot image,
+                // add it to the payload.
+                if (!bootrom && i.hasOwnProperty('bootrom')) {
+                    payload.bootrom = i.bootrom;
+                }
             }
 
             cb();
diff --git a/src/vm/runtest b/src/vm/runtest
index 5df313f8..b87ce942 100755
--- a/src/vm/runtest
+++ b/src/vm/runtest
@@ -105,6 +105,73 @@ for tag in admin external; do
     fi
 done
 
+# Ensure the dummy uefi image exists
+
+uefi_img_uuid="45d86edd-8cf4-6c7c-f018-8e27b24c550e"
+if ! imgadm info "$uefi_img_uuid" >/dev/null 2>&1; then
+	uefi_zvol=zones/${uefi_img_uuid}-tmp
+	uefi_snap=${uefi_zvol}@final
+	uefi_zfs=/var/tmp/${uefi_img_uuid}.zfs
+	uefi_manifest=/var/tmp/${uefi_img_uuid}.imgmanifest
+
+	if zfs list "$uefi_zvol" >/dev/null 2>&1; then
+		if ! zfs destroy -r "$uefi_zvol"; then
+			echo "Unable to clean up earlier uefi image" >&2
+			exit 1
+		fi
+	fi
+	if ! zfs create -V 1g -s "$uefi_zvol"; then
+		echo "Unable to create uefi zvol $uefi_zvol" >&2
+		exit 1
+	fi
+	if ! zfs snapshot "$uefi_snap"; then
+		echo "Unable to create uefi snapshot $uefi_snap" >&2
+		exit 1
+	fi
+	if ! zfs send "$uefi_snap" >$uefi_zfs; then
+		echo "Unable to send uefi snapshot $uefi_snap to $uefi_zfs" >&2
+		exit 1
+	fi
+	uefi_size=$(stat -c %s "$uefi_zfs")
+	uefi_sha1=$(digest -a sha1 "$uefi_zfs")
+	cat >$uefi_manifest <<-NOMORE
+	{
+	  "v": 2,
+	  "uuid": "$uefi_img_uuid",
+	  "name": "uefi-dummy",
+	  "version": "1.0",
+	  "type": "zvol",
+	  "os": "windows",
+	  "image_size": 1024,
+	  "description": "Dummy uefi image for VM tests",
+	  "requirements": {
+	    "brand": "bhyve",
+	    "bootrom": "uefi"
+	  },
+	  "files": [
+	    {
+	      "sha1": "$uefi_sha1",
+	      "size": $uefi_size,
+	      "compression": "none"
+	    }
+	  ]
+	}
+	NOMORE
+	if (( $? != 0)); then
+		echo "Unable to create uefi manifest $uefi_manifest" >&2
+		exit 1
+	fi
+	if ! imgadm install -m "$uefi_manifest" -f "$uefi_zfs"; then
+		echo "Unable to install uefi image from $uefi_manifest and" \
+		    "$uefi_zfs" >&2
+		exit 1
+	fi
+
+	# Clean up temporary stuff, but don't freak out if it fails.
+	rm -f "$uefi_manifest" "$uefi_zfs"
+	zfs destroy -r "$uefi_zvol"
+fi
+
 set +o errexit
 set -o pipefail
 /usr/bin/ctrun -l child -o noorphan /usr/node/bin/node \
diff --git a/src/vm/tests/test-bhyve-uefi.js b/src/vm/tests/test-bhyve-uefi.js
new file mode 100644
index 00000000..4f35f47c
--- /dev/null
+++ b/src/vm/tests/test-bhyve-uefi.js
@@ -0,0 +1,214 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var fs = require('fs');
+var VM = require('/usr/vm/node_modules/VM');
+var vmtest = require('../common/vmtest.js');
+var imgadm = require('/usr/img/lib/cli.js');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+VM.loglevel = 'DEBUG';
+
+var uefi_img_uuid = '45d86edd-8cf4-6c7c-f018-8e27b24c550e';
+
+function get_payload() {
+    var payload = {
+        alias: 'test-bhyve-uefi-' + process.pid,
+        autoboot: false,
+        brand: 'bhyve',
+        ram: "512",
+        vcpus: "2",
+        do_not_inventory: true,
+        disks: [
+            {
+                image_uuid: uefi_img_uuid,
+                boot: true,
+            }
+        ],
+    };
+
+    return JSON.parse(JSON.stringify(payload))
+}
+
+test('validate unspecified requirements.bootrom with uefi image', function(t) {
+    payload = get_payload();
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.ok(payload.hasOwnProperty('bootrom') && payload.bootrom == 'uefi',
+            'payload.bootrom updated to "uefi"');
+        t.done();
+    });
+});
+
+test('validate uefi payload with uefi image as boot disk', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'uefi';
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.ok(payload.bootrom == 'uefi', 'payload.bootrom is still "uefi"');
+        t.done();
+    });
+});
+
+test('validate bios payload with uefi image as boot disk', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'bios';
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(err && err.bad_values.indexOf('bootrom') !== -1,
+            'bad bootrom detected');
+        t.done();
+    });
+});
+
+test('validate uefi payload with bios image as boot disk', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'uefi';
+    payload.disks[0].image_uuid = vmtest.CURRENT_BHYVE_CENTOS_UUID;
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(err && err.bad_values.indexOf('bootrom') !== -1,
+            'bad bootrom detected');
+        t.done();
+    });
+});
+
+test('validate bios payload with bios image as boot disk', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'bios';
+    payload.disks[0].image_uuid = vmtest.CURRENT_BHYVE_CENTOS_UUID;
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.ok(payload.bootrom == 'bios', 'payload.bootrom is still "bios"');
+        t.done();
+    });
+});
+
+test('validate bios/uefi boot/data disks with unspecified bootrom',
+    function(t) {
+    payload = get_payload();
+    payload.disks = [
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+            boot: true,
+        },
+        {
+            image_uuid: uefi_img_uuid
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.done();
+    });
+});
+
+test('validate bios/uefi boot/data disks with bios bootrom', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'bios';
+    payload.disks = [
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+            boot: true,
+        },
+        {
+            image_uuid: uefi_img_uuid
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.done();
+    });
+});
+
+test('validate bios/uefi boot/data disks with uefi bootrom', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'uefi';
+    payload.disks = [
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+            boot: true,
+        },
+        {
+            image_uuid: uefi_img_uuid
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(err && err.bad_values.indexOf('bootrom') !== -1,
+            'bad bootrom detected');
+        t.done();
+    });
+});
+
+test('validate uefi/bios boot/data disks with bios bootrom', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'bios';
+    payload.disks = [
+        {
+            image_uuid: uefi_img_uuid,
+            boot: true,
+        },
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(err && err.bad_values.indexOf('bootrom') !== -1,
+            'bad bootrom detected');
+        t.done();
+    });
+});
+
+test('validate uefi/bios boot/data disks with unspecified bootrom',
+    function(t) {
+    payload = get_payload();
+    payload.disks = [
+        {
+            image_uuid: uefi_img_uuid,
+            boot: true,
+        },
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.done();
+    });
+});
+
+test('validate uefi/bios boot/data disks with uefi bootrom', function(t) {
+    payload = get_payload();
+    payload.bootrom = 'uefi';
+    payload.disks = [
+        {
+            image_uuid: uefi_img_uuid,
+            boot: true,
+        },
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID
+        }];
+    VM.validate(payload.brand, 'create', payload, function(err) {
+        t.ok(!err, err ? JSON.stringify(err) : 'payload validated');
+        t.ok(payload.hasOwnProperty('bootrom') && payload.bootrom == 'uefi',
+            'payload.bootrom updated to "uefi"');
+        t.done();
+    });
+});
-- 
2.21.0

