commit 1f9bbdbab411aecce21d4ec4f9b8862b199521d1 (HEAD -> master)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2019-06-11T16:41:10+00:00 (4 months ago)
    
    MANTA-4039 binder load balancer never met a packet it didn't queue
    Reviewed by: Alex Wilson <alex.wilson@joyent.com>
    Approved by: Alex Wilson <alex.wilson@joyent.com>

diff --git a/bbal.h b/bbal.h
index c65ae66..e4e2367 100644
--- a/bbal.h
+++ b/bbal.h
@@ -133,6 +133,7 @@ typedef struct {
 	uint64_t be_stat_conn_error;
 	uint64_t be_stat_udp;
 	uint64_t be_stat_tcp;
+	uint64_t be_stat_stuck;
 } backend_t;
 
 typedef struct {
diff --git a/deps/libcloop/include/libcloop.h b/deps/libcloop/include/libcloop.h
index caccbef..b3c66a9 100644
--- a/deps/libcloop/include/libcloop.h
+++ b/deps/libcloop/include/libcloop.h
@@ -107,6 +107,7 @@ extern void cconn_more_data(cconn_t *ccn);
 extern int cconn_send(cconn_t *ccn, cbuf_t *);
 extern int cconn_fin(cconn_t *ccn);
 extern int cconn_abort(cconn_t *ccn);
+extern int cconn_stuck(cconn_t *ccn);
 
 extern void *cconn_data(cconn_t *ccn);
 extern void cconn_data_set(cconn_t *ccn, void *data);
diff --git a/deps/libcloop/src/cserver.c b/deps/libcloop/src/cserver.c
index a610cc9..7f3c97b 100644
--- a/deps/libcloop/src/cserver.c
+++ b/deps/libcloop/src/cserver.c
@@ -104,6 +104,12 @@ struct cconn {
 	int ccn_error_errno;
 
 	void *ccn_data;
+
+	/*
+	 * Record whether the last send() operation failed due to a full
+	 * outbound socket buffer.
+	 */
+	boolean_t ccn_stuck;
 };
 
 struct cserver {
@@ -447,6 +453,22 @@ cconn_abort(cconn_t *ccn)
 	return (0);
 }
 
+/*
+ * Returns 1 if the outbound socket buffer was full last time we tried to send
+ * data to the remote peer, or 0 if not.
+ *
+ * This can be used by the caller to make coarse-grained decisions about back
+ * pressure: if the buffer is full, this is likely because the remote peer has
+ * not yet been able to read and process data we've already sent.  To avoid
+ * unbounded queueing, the caller may discard or suspend production of data
+ * while the connection is stuck.
+ */
+int
+cconn_stuck(cconn_t *ccn)
+{
+	return (ccn->ccn_stuck == B_TRUE);
+}
+
 int
 cconn_send(cconn_t *ccn, cbuf_t *cbuf)
 {
@@ -604,6 +626,15 @@ retry:
 				goto retry;
 
 			case EAGAIN:
+				/*
+				 * If send() fails with EAGAIN/EWOULDBLOCK, the
+				 * socket send queue is likely full.  Record
+				 * this fact so that the caller can make a
+				 * decision to back off until the remote host
+				 * is able to catch up, and wait for the socket
+				 * to be writable again before retrying.
+				 */
+				ccn->ccn_stuck = B_TRUE;
 				cloop_ent_want(clent, CLOOP_CB_WRITE);
 				return;
 
@@ -618,6 +649,12 @@ retry:
 				    errno);
 				return;
 			}
+		} else {
+			/*
+			 * If we were able to send(), the outbound socket
+			 * buffer is no longer full.
+			 */
+			ccn->ccn_stuck = B_FALSE;
 		}
 	}
 
diff --git a/udp_proxy.c b/udp_proxy.c
index 5a72c47..f41d78b 100644
--- a/udp_proxy.c
+++ b/udp_proxy.c
@@ -183,6 +183,15 @@ again:
 		goto bail;
 	}
 
+	if (cconn_stuck(be->be_conn)) {
+		bunyan_trace(be->be_log, "stuck backend write queue",
+		    BUNYAN_T_END);
+
+		rem->rem_stat_udp_drop++;
+		be->be_stat_stuck++;
+		goto bail;
+	}
+
 	rem->rem_stat_udp++;
 	be->be_stat_udp++;
 
