From 49d315bb4944cf69c079da41c6b0e45ec77c3778 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Tue, 5 Dec 2017 17:03:57 -0500
Subject: [PATCH] OS-2647 add vminfod to keep track of VM state and speed up
 lookups in vmadm

---
 .gitignore                                    |    1 +
 src/Makefile                                  |   28 +-
 src/fswatcher.c                               | 1024 ++++
 src/manifest                                  |   16 +-
 src/vm/common/vmtest.js                       |   38 +-
 src/vm/lib/metadata/agent.js                  | 1042 +---
 src/vm/lib/metadata/zwatch.js                 |   64 -
 src/vm/man/vmadm.1m.md                        |   11 +
 src/vm/node_modules/VM.js                     | 5140 +++++++++++------
 src/vm/node_modules/diff.js                   |  505 ++
 src/vm/node_modules/expander.js               |    5 +-
 src/vm/node_modules/fswatcher.js              |  927 +++
 src/vm/node_modules/proptable.js              |   56 +-
 src/vm/node_modules/queue.js                  |  515 ++
 src/vm/node_modules/vminfod/client.js         | 1052 ++++
 src/vm/node_modules/vminfod/vminfod.js        | 2374 ++++++++
 src/vm/node_modules/vminfod/zonewatcher.js    |   76 +
 src/vm/node_modules/vminfod/zpoolwatcher.js   |  119 +
 src/vm/node_modules/vmload/dump-json.js       |   58 +-
 src/vm/node_modules/vmload/dump-vmobjs.js     |    9 +-
 src/vm/node_modules/vmload/dump-zonexml.js    |   11 +-
 src/vm/node_modules/vmload/index.js           |  866 +--
 src/vm/node_modules/vmload/vmload-datasets.js |   34 +-
 src/vm/node_modules/vmload/vmload-json.js     |   18 +-
 src/vm/node_modules/vmload/vmload-zoneadm.js  |    3 +-
 src/vm/node_modules/zoneevent.js              |  177 +
 src/vm/sbin/vmadm.js                          |  108 +-
 src/vm/sbin/vmadmd.js                         |   39 +-
 src/vm/sbin/vminfod.js                        |   80 +
 src/vm/smf/system-metadata.xml                |    4 +
 src/vm/smf/system-vmadmd.xml                  |    4 +
 src/vm/smf/system-vminfod                     |   49 +
 src/vm/smf/system-vminfod.xml                 |   47 +
 src/vm/tests/test-defaults.js                 |   56 +-
 src/vm/tests/test-delete.js                   |    4 +-
 src/vm/tests/test-diff.js                     |  262 +
 src/vm/tests/test-docker.js                   |  159 +-
 src/vm/tests/test-fswatcher.js                |  525 ++
 .../test-internal_metadata_namespaces.js      |  108 +-
 src/vm/tests/test-lastexited.js               |   68 +-
 src/vm/tests/test-queue.js                    |  265 +
 src/vm/tests/test-send-recv.js                |  352 +-
 src/vm/tests/test-update.js                   |  140 +-
 src/vm/tests/test-vminfod.js                  |   42 +
 src/vm/tests/test-zonewatcher.js              |  183 +
 src/vm/tests/test-zpoolwatcher.js             |  144 +
 src/vminfod.js                                |  315 +
 src/zoneevent.c                               |  144 -
 src/zoneevent.js                              |  108 +
 49 files changed, 13809 insertions(+), 3566 deletions(-)
 create mode 100644 src/fswatcher.c
 delete mode 100644 src/vm/lib/metadata/zwatch.js
 create mode 100644 src/vm/node_modules/diff.js
 create mode 100644 src/vm/node_modules/fswatcher.js
 create mode 100644 src/vm/node_modules/queue.js
 create mode 100644 src/vm/node_modules/vminfod/client.js
 create mode 100644 src/vm/node_modules/vminfod/vminfod.js
 create mode 100644 src/vm/node_modules/vminfod/zonewatcher.js
 create mode 100644 src/vm/node_modules/vminfod/zpoolwatcher.js
 create mode 100644 src/vm/node_modules/zoneevent.js
 create mode 100755 src/vm/sbin/vminfod.js
 create mode 100755 src/vm/smf/system-vminfod
 create mode 100644 src/vm/smf/system-vminfod.xml
 create mode 100644 src/vm/tests/test-diff.js
 create mode 100644 src/vm/tests/test-fswatcher.js
 create mode 100644 src/vm/tests/test-queue.js
 create mode 100644 src/vm/tests/test-vminfod.js
 create mode 100644 src/vm/tests/test-zonewatcher.js
 create mode 100644 src/vm/tests/test-zpoolwatcher.js
 create mode 100755 src/vminfod.js
 delete mode 100644 src/zoneevent.c
 create mode 100755 src/zoneevent.js

diff --git a/.gitignore b/.gitignore
index ad7f2cb3..24bf3ef3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,6 +14,7 @@
 /src/measure_terminal
 /src/bootparams
 /src/disk_size
+/src/fswatcher
 /src/removable_disk
 /src/disklist
 /src/qemu-exec
diff --git a/src/Makefile b/src/Makefile
index eb0c4abf..d22c293c 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -63,11 +63,11 @@ SMARTDCLIBDIR =	$(DESTDIR)/smartdc/lib
 #
 bootparams :	LIBS +=		-ldevinfo
 bootparams :	WARN_FLAGS +=	-Wno-unused
+fswatcher :	LIBS +=		-lthread -lnvpair -lavl
 zfs_recv :	LIBS +=		-lsocket
 zfs_send :	LIBS +=		-lsocket
 vmbundle :	CPPFLAGS +=	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
 sdc-on-tty :	CFLAGS +=	$(OPT_FLAG)
-zoneevent :	LIBS +=		-lnvpair -lsysevent
 sysevent :	LIBS +=		-lnvpair -lsysevent
 sysinfo_mod.so : CPPFLAGS +=	-D_REENTRANT
 sysinfo_mod.so : CFLAGS +=	-fpic -Wno-unused-parameter
@@ -78,11 +78,14 @@ SYSINFO_MOD_DIR = $(DESTDIR)/usr/lib/sysevent/modules
 # These files will get run through jsstyle and jslint on 'make check'
 JS_CHECK_TARGETS=\
 	filewait.js \
+	vminfod.js \
 	node_modules/{system,onlyif,net-boot-config}.js \
 	net-boot-config \
 	vm/sbin/*.js \
+	vm/node_modules/diff.js \
 	vm/node_modules/dladm.js \
 	vm/node_modules/expander.js \
+	vm/node_modules/fswatcher.js \
 	vm/node_modules/hrtime.js \
 	vm/node_modules/ip.js \
 	vm/node_modules/nic.js \
@@ -90,31 +93,39 @@ JS_CHECK_TARGETS=\
 	vm/node_modules/utils.js \
 	vm/node_modules/VM.js \
 	vm/node_modules/qmp.js \
+	vm/node_modules/queue.js \
 	vm/node_modules/openonerrlogger.js \
 	vm/node_modules/vmload/*.js \
+	vm/node_modules/vminfod/*.js \
 	vm/node_modules/sysevent-stream.js \
 	vm/node_modules/zonecfg.js \
+	vm/node_modules/zoneevent.js \
 	img/lib/*.js \
 	img/sbin/imgadm \
 	vm/common/nictag.js \
 	vm/tests/test-alias.js \
 	vm/tests/test-cleanup-on-failure.js \
-	vm/tests/test-create.js \
 	vm/tests/test-create-filesystems.js \
-	vm/tests/test-docker.js \
+	vm/tests/test-create.js \
 	vm/tests/test-defaults.js \
+	vm/tests/test-docker.js \
+	vm/tests/test-fswatcher.js \
 	vm/tests/test-hrtime.js \
 	vm/tests/test-indestructible.js \
 	vm/tests/test-internal_metadata_namespaces.js \
 	vm/tests/test-lastexited.js \
 	vm/tests/test-openonerrlogger.js \
+	vm/tests/test-queue.js \
 	vm/tests/test-reboot.js \
 	vm/tests/test-reprovision.js \
+	vm/tests/test-send-recv.js \
 	vm/tests/test-snapshots.js \
 	vm/tests/test-spoof-opts.js \
 	vm/tests/test-tmpfs.js \
 	vm/tests/test-update.js \
 	vm/tests/test-vrrp-nics.js \
+	vm/tests/test-zonewatcher.js \
+	vm/tests/test-zpoolwatcher.js \
 	vm/lib/metadata/*.js
 
 JS_CHECK_OLDSKOOL_TARGETS = \
@@ -128,6 +139,7 @@ C_CHECK_TARGETS=\
 	bootparams.c \
 	cryptpass.c \
 	disk_size.c \
+	fswatcher.c \
 	measure_terminal.c \
 	nomknod.c \
 	qemu-exec.c \
@@ -135,7 +147,6 @@ C_CHECK_TARGETS=\
 	vmunbundle.c \
 	zfs_recv.c \
 	zfs_send.c \
-	zoneevent.c \
 	sdc-on-tty.c \
 	sysinfo_mod.c \
 	sysevent.c \
@@ -280,12 +291,12 @@ TARGETS = \
 	disklayout \
 	disklist \
 	disk_size \
+	fswatcher \
 	mkzpool \
 	removable_disk \
 	vmunbundle \
 	zfs_recv \
 	zfs_send \
-	zoneevent \
 	sysevent \
 	sysinfo_mod.so \
 	nomknod.so.32 \
@@ -367,20 +378,25 @@ install: all $(SUBDIRS)
 	sed -e "s|var expat.*;|var expat = require('./expat_binding');|" \
 	    < node-expat/lib/node-expat.js \
 	    > $(PREFIX_NODE)/node_modules/node-expat.js
+	cp fswatcher $(DESTDIR)/usr/vm/sbin/fswatcher
 	cp dockerinit/build/dockerinit $(DESTDIR)/usr/vm/sbin/dockerinit
 	cp dockerinit/build/dockerexec $(DESTDIR)/usr/vm/sbin/dockerexec
-	cp zoneevent $(DESTDIR)/usr/vm/sbin/zoneevent
+	cp zoneevent.js $(DESTDIR)/usr/vm/sbin/zoneevent
 	cp zfs_send $(DESTDIR)/usr/vm/sbin/zfs_send
 	cp zfs_recv $(DESTDIR)/usr/vm/sbin/zfs_recv
 	cp vmunbundle $(DESTDIR)/usr/vm/sbin/vmunbundle
 	cp filewait.js $(DESTDIR)/usr/vm/sbin/filewait
+	cp vminfod.js $(DESTDIR)/usr/bin/vminfod
 	mkdir -p $(DESTDIR)/lib/svc/manifest/system
 	cp vm/smf/system-vmadmd.xml \
 	    $(DESTDIR)/lib/svc/manifest/system/system-vmadmd.xml
 	cp vm/smf/system-metadata.xml \
 	    $(DESTDIR)/lib/svc/manifest/system/system-metadata.xml
+	cp vm/smf/system-vminfod.xml \
+	    $(DESTDIR)/lib/svc/manifest/system/system-vminfod.xml
 	mv $(DESTDIR)/usr/vm/sbin/vmadmd.js $(DESTDIR)/usr/vm/sbin/vmadmd
 	mv $(DESTDIR)/usr/vm/sbin/vmadm.js $(DESTDIR)/usr/vm/sbin/vmadm
+	mv $(DESTDIR)/usr/vm/sbin/vminfod.js $(DESTDIR)/usr/vm/sbin/vminfod
 	mv $(DESTDIR)/usr/vm/sbin/add-userscript.js \
 	    $(DESTDIR)/usr/vm/sbin/add-userscript
 	mv $(DESTDIR)/usr/vm/sbin/metadata.js $(DESTDIR)/usr/vm/sbin/metadata
diff --git a/src/fswatcher.c b/src/fswatcher.c
new file mode 100644
index 00000000..f8f14120
--- /dev/null
+++ b/src/fswatcher.c
@@ -0,0 +1,1024 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * cc -Wall -Wextra fswatcher.c -o fswatcher -lthread -lnvpair -lavl
+ *
+ */
+
+/*
+ * On STDIN you can send:
+ *
+ * <KEY> WATCH <pathname>\n
+ * <KEY> UNWATCH <pathname>\n
+ * <KEY> STATUS\n
+ *
+ * The first will cause <pathname> to be added to the watch list. The second
+ * will cause the watch for the specified path to be removed.  The third will
+ * print this programs status to stdout. The <KEY> must be an integer in the
+ * range 1-UINT64_MAX (inclusive). Leading 0's will be removed. NOTE:  0 is a
+ * special key that will be used in output for errors which were not directly
+ * the result of a command.
+ *
+ * "pathname" can be any type of file that event ports supports (file,
+ * directory, pipe, etc. see port_associate(3C) for a full list).  This program
+ * cannot watch symlinks, but instead will watch the source file of a symlink.
+ * Note that, like a regular file, the source file for the symlink must exist
+ * to watch, and if the source file is deleted after a watch is established a
+ * FILE_DELETE event will be emitted.
+ *
+ * When watching a file, it will be rewatched every time an event is seen
+ * until an UNWATCH command for the file is received from the user, or an event
+ * indicates that the file can no longer be watched (like FILE_DELETE).
+ *
+ * On STDOUT you will see JSON messages that look like the following but are
+ * on a single line:
+ *
+ *  {
+ *     "type": <string>,
+ *     "time": [array],
+ *     "changes": [array],
+ *     "code": <number>,
+ *     "final": true|false,
+ *     "key": <number>,
+ *     "message": "human readable string",
+ *     "pathname": "/path/which/had/event",
+ *     "result": "SUCCESS|FAIL"
+ *  }
+ *
+ * Where:
+ *
+ *   - type
+ *             One of: ready, event, response, error.
+ *             Always included.
+ *   - time
+ *             Time as an array of [seconds, nanoseconds], similar to
+ *             JavaScript process.hrtime()
+ *             Always included.
+ *   - changes
+ *             An array of strings indicating which changes occurred.
+ *             Included for "event" messages.
+ *   - code
+ *             A positive integer code for an error.
+ *             Included for "response" and "error" messages.
+ *   - final
+ *             true when the event being printed is the last without re-watch.
+ *             Included for "event" messages.
+ *   - key
+ *             The <KEY> for which a response corresponds.
+ *             Included for "response" and "error" messages.
+ *   - message
+ *             Human-readable string describing response.
+ *             Included for "response" and "error" messages.
+ *   - pathname
+ *             pathname to which an event applies.
+ *             Included for "response" and "event" messages.
+ *   - result
+ *             Indicates whether a command was a "SUCCESS" or "FAILURE"
+ *             Included for "response" messages.
+ *
+ * Current values for "code" are in the ErrorCodes enum below.
+ *
+ * EXIT STATUS
+ *
+ *   Under normal operation, fswatcher will run until STDIN is closed or a fatal
+ *   error occurs.
+ *
+ *   When errors occur that are completly unexpected, fswatcher will call
+ *   abort() to generate a core dump.
+ *
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <port.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <thread.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <sys/avl.h>
+#include <libnvpair.h>
+
+#define MAX_STAT_RETRY 10  /* number of times to retry stat() before abort() */
+#define SYSTEM_KEY 0       /* reserved key for system events */
+
+/* longest command is '<KEY> UNWATCH <path>' */
+#define MAX_KEY_LEN 20     /* number of digits 0-UINT64_MAX */
+#define MAX_CMD_LEN (MAX_KEY_LEN + 1 + 7 + 1 + PATH_MAX + 1)
+
+/*
+ * Like VERIFY0, but instead of calling abort(), will print an error message
+ * to stderr and exit the program.
+ *
+ * This is used by the nvlist_* functions to ensure that we are able to create
+ * and add to an nvlist without error.  The nvlist functions used can only
+ * fail with EINVAL or ENOMEM: dumping core because of either of these failure
+ * modes would be excessive.
+ */
+#define ENSURE0(arg) {	\
+    if (arg != 0)	\
+        err(1, #arg);	\
+}
+
+/*
+ * These are possible values returned from an "error" event
+ */
+enum ErrorCodes {
+	ERR_INVALID_COMMAND = 1, /* failed to parse command from stdin line */
+	ERR_INVALID_KEY,         /* key parsed from command is invalid */
+	ERR_UNKNOWN_COMMAND,     /* line parsable, but command unknown */
+	ERR_CANNOT_ASSOCIATE     /* port_associate(3c) failed */
+};
+
+/*
+ * Values returned for "result" events
+ */
+enum ResultCodes {
+	RESULT_SUCCESS = 0,
+	RESULT_FAILURE
+};
+
+/*
+ * file_obj structs are held in memory for every file that is currently being
+ * watched.  This way we can 1. verify that incoming events are for files being
+ * watched, and 2. unwatch files at a later time if the user wants.
+ *
+ * These structs are stored in a global AVL tree that uses the filename (and a
+ * hash of it) as the key.
+ */
+static avl_tree_t files_tree;
+struct files_tree_node {
+	struct file_obj fobj;
+	char *name;
+	unsigned long name_hash;
+	avl_node_t avl_node;
+};
+
+/*
+ * This programs has 2 main threads running that block on new events from:
+ *
+ * 1. stdin (user commands)
+ * 2. event ports (filesystem events)
+ *
+ * When an event is received from either, this global "work_mutex" is acquired.
+ * This way, no other locks are necessary, and whatever method is currently
+ * processing its event can safely access members of the AVL tree and write
+ * to stdout/stderr.
+ */
+static mutex_t work_mutex = DEFAULTMUTEX;
+
+/* global event port handle */
+static int port = -1;
+
+/* CLI args */
+static struct {
+	boolean_t opt_j; /* -j, json output */
+	boolean_t opt_r; /* -r, print ready event */
+} opts;
+
+/*
+ * Print the usage message to the given FILE handle
+ */
+static void
+usage(FILE *s)
+{
+	fprintf(s,
+	    "Usage: fswatcher [-hrj]\n"
+	    "\n"
+	    "Watch files using event ports with commands sent to\n"
+	    "stdin and event notifications sent to stdout.\n"
+	    "\n"
+	    "Options\n"
+	    "  -h             print this message and exit\n"
+	    "  -j             JSON output\n"
+	    "  -r             print 'ready' event at start\n");
+}
+
+/*
+ * The unique key for the files_tree_node objects are the filenames.  When a
+ * node is created, a hash is calculated for the filename to make comparisons
+ * fast.  Only if the hash matches is a full string (strcmp) comparison done.
+ */
+static int
+files_tree_node_comparator(const void *l, const void *r)
+{
+	const struct files_tree_node *ltn = l;
+	const struct files_tree_node *rtn = r;
+	int ret;
+
+	/* first check filename hash */
+	if (ltn->name_hash < rtn->name_hash)
+		return (-1);
+	else if (ltn->name_hash > rtn->name_hash)
+		return (1);
+
+	/* hashes are the same, do string comparison */
+	ret = strcmp(ltn->name, rtn->name);
+
+	if (ret < 0)
+		return (-1);
+	else if (ret > 0)
+		return (1);
+
+	return (0);
+}
+
+/*
+ * Simple hashing algorithm pulled from http://www.cse.yorku.ca/~oz/hash.html
+ *
+ * This function is used primarily to make lookups in the AVL tree faster.
+ * Since the tree is keyed off of a files pathname, the pathname string as well
+ * as a hash of the string is stored in the tree.
+ *
+ * There is nothing inherently special or particularly useful about the "djb2"
+ * hashing algorithm, really any quick hashing algorithm will work here, since
+ * when a hash collision is detected a full strcmp() is performed.
+ */
+static unsigned long
+djb2(char *str)
+{
+	unsigned long hash = 5381;
+	int c;
+	while ((c = *str++))
+		hash = ((hash << 5) + hash) + c;
+	return (hash);
+}
+
+/*
+ * Allocate an nvlist with "type" set to the type argument given, and "time"
+ * set to the current time.  This function handles any error checking needed
+ * and will exit the program if anything fails.
+ *
+ * nvlist must be freed by the caller
+ */
+static nvlist_t *
+make_nvlist(char *type)
+{
+	uint64_t time[2];
+	nvlist_t *nvl;
+	struct timespec tv;
+
+	ENSURE0(nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0));
+
+	/* get the current hrtime */
+	if (clock_gettime(CLOCK_MONOTONIC, &tv) != 0)
+		err(1, "clock_gettime CLOCK_MONOTONIC");
+	time[0] = tv.tv_sec;
+	time[1] = tv.tv_nsec;
+
+	ENSURE0(nvlist_add_string(nvl, "type", type));
+	ENSURE0(nvlist_add_uint64_array(nvl, "time", time, 2));
+
+	return (nvl);
+}
+
+/*
+ * Print an nvlist to stdout.  Will use the proper function to print
+ * based on -j being set or not.
+ *
+ * This function handles fflushing stdout.
+ */
+static void
+print_nvlist(nvlist_t *nvl)
+{
+	if (opts.opt_j)
+		nvlist_print_json(stdout, nvl);
+	else
+		nvlist_print(stdout, nvl);
+	printf("\n");
+
+	fflush(stdout);
+}
+
+/*
+ * Handle creating and printing an "event" message.
+ */
+static void
+print_event(int event, char *pathname, boolean_t is_final)
+{
+	nvlist_t *nvl = make_nvlist("event");
+	uint_t i;
+	uint_t count = 0;
+
+	/* Map event port file event flags to strings */
+	struct flag_names {
+		int fn_flag;
+		char *fn_name;
+	};
+	static struct flag_names flags[] = {
+		{ FILE_ACCESS, "FILE_ACCESS" },
+		{ FILE_ATTRIB, "FILE_ATTRIB" },
+		{ FILE_DELETE, "FILE_DELETE" },
+		{ FILE_EXCEPTION, "FILE_EXCEPTION" },
+		{ FILE_MODIFIED, "FILE_MODIFIED" },
+		{ FILE_RENAME_FROM, "FILE_RENAME_FROM" },
+		{ FILE_RENAME_TO, "FILE_RENAME_TO" },
+		{ FILE_TRUNC, "FILE_TRUNC" },
+		{ FILE_NOFOLLOW, "FILE_NOFOLLOW" },
+		{ MOUNTEDOVER, "MOUNTEDOVER" },
+		{ UNMOUNTED, "UNMOUNTED" }
+	};
+	static const uint_t num_flags = (sizeof (flags) / sizeof (flags[0]));
+	char *changes[num_flags];
+
+	for (i = 0; i < num_flags; i++) {
+		if ((event & flags[i].fn_flag) != 0) {
+			changes[count++] = flags[i].fn_name;
+		}
+	}
+
+	ENSURE0(nvlist_add_string_array(nvl, "changes", changes, count));
+	ENSURE0(nvlist_add_string(nvl, "pathname", pathname));
+	ENSURE0(nvlist_add_int32(nvl, "revents", event));
+	ENSURE0(nvlist_add_boolean_value(nvl, "final", is_final));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * Handle creating and printing a "ready" message.
+ */
+static void
+print_ready()
+{
+	nvlist_t *nvl = make_nvlist("ready");
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * print_error() takes a key, code (one of the ErrorCodes) and message and
+ * handles creating and printing an "error" message.
+ */
+static void
+print_error(uint64_t key, uint32_t code, const char *message_fmt, ...)
+{
+	va_list arg_ptr;
+	char message[4096];
+	nvlist_t *nvl = make_nvlist("error");
+
+	va_start(arg_ptr, message_fmt);
+	if (vsnprintf(message, sizeof (message), message_fmt, arg_ptr) < 0) {
+		perror("fswatcher: vsnprintf");
+		abort();
+	}
+	va_end(arg_ptr);
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", code));
+	ENSURE0(nvlist_add_string(nvl, "message", message));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * print_response() takes a key, code (RESULT_SUCCESS||RESULT_FAILURE), pathname
+ * and message and handles creating and printing a "result" message.
+ */
+static void
+print_response(uint64_t key, uint32_t code, const char *pathname,
+    const char *message_fmt, ...)
+{
+	va_list arg_ptr;
+	char message[4096];
+	nvlist_t *nvl = make_nvlist("response");
+
+	va_start(arg_ptr, message_fmt);
+	if (vsnprintf(message, sizeof (message), message_fmt, arg_ptr) < 0) {
+		perror("fswatcher: vsnprintf");
+		abort();
+	}
+	va_end(arg_ptr);
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", code));
+	ENSURE0(nvlist_add_string(nvl, "pathname", pathname));
+	ENSURE0(nvlist_add_string(nvl, "message", message));
+	ENSURE0(nvlist_add_string(nvl, "result",
+	    code == RESULT_SUCCESS ? "SUCCESS" : "FAIL"));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * Only called from stdin thread.  Prints information about this program
+ *
+ * print_status prints a message of type "response"
+ */
+static void
+print_status(uint64_t key)
+{
+	ulong_t numnodes;
+	char **filenames;
+	struct files_tree_node *ftn;
+	ulong_t i = 0;
+	nvlist_t *nvl = make_nvlist("response");
+	nvlist_t *data_nvl = fnvlist_alloc();
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", RESULT_SUCCESS));
+	ENSURE0(nvlist_add_string(nvl, "result", "SUCCESS"));
+
+	/* get all nodes in the avl tree */
+	numnodes = avl_numnodes(&files_tree);
+	filenames = calloc(numnodes, sizeof (char *));
+
+	if (filenames == NULL)
+		err(1, "calloc");
+
+	/* walk the avl tree and add each filename */
+	for (ftn = avl_first(&files_tree); ftn != NULL;
+	    ftn = AVL_NEXT(&files_tree, ftn)) {
+
+		filenames[i++] = ftn->name;
+	}
+
+	/*
+	 * all STATUS data is stored in a separate nvl that is attached to the
+	 * "data" key of the response object.
+	 */
+	ENSURE0(nvlist_add_string_array(data_nvl, "files", filenames, i));
+	ENSURE0(nvlist_add_uint32(data_nvl, "files_count", numnodes));
+	ENSURE0(nvlist_add_int32(data_nvl, "pid", getpid()));
+
+	ENSURE0(nvlist_add_nvlist(nvl, "data", data_nvl));
+
+	print_nvlist(nvl);
+
+	nvlist_free(data_nvl);
+	nvlist_free(nvl);
+	free(filenames);
+}
+
+/*
+ * find_handle() takes a pathname and returns the files_tree_node struct from
+ * the files_tree treeh. returns NULL if no pathname matches.
+ */
+static struct files_tree_node *
+find_handle(char *pathname)
+{
+	struct files_tree_node lookup;
+
+	lookup.name = pathname;
+	lookup.name_hash = djb2(pathname);
+
+	return (avl_find(&files_tree, &lookup, NULL));
+}
+
+/*
+ * add_handle() inserts a files_tree_node struct into the files_tree tree.
+ */
+static void
+add_handle(struct files_tree_node *ftn)
+{
+	avl_add(&files_tree, ftn);
+}
+
+/*
+ * remove_handle() removes a files_tree_node struct from the files_tree tree.
+ */
+static void
+remove_handle(struct files_tree_node *ftn)
+{
+	avl_remove(&files_tree, ftn);
+}
+
+/*
+ * destroy_handle() removes and frees a files_tree_node struct from the
+ * files_tree tree.
+ */
+static void
+destroy_handle(struct files_tree_node *ftn)
+{
+	remove_handle(ftn);
+	free(ftn->name);
+	free(ftn);
+}
+
+/*
+ * stat_file() takes the same arguments as stat and calls stat for you but does
+ * retries on errors and ultimately returns either 0 (success) or one of the
+ * errno's listed in stat(2).
+ *
+ * WARNING: If it gets EINTR too many times (more than MAX_STAT_RETRY), this
+ * will call abort().
+ */
+static int
+stat_file(const char *path, struct stat *buf)
+{
+	int i;
+
+	for (i = 0; i < MAX_STAT_RETRY; i++) {
+		int stat_ret = stat(path, buf);
+		int stat_err = errno;
+
+		/* return immediately upon success */
+		if (stat_ret == 0)
+			return (0);
+
+		/* error from stat that means we can't retry, just return it */
+		if (stat_err != EINTR)
+			return (stat_err);
+
+		/* Interrupted by signal, try again... */
+	}
+
+	/* if we are here, give up */
+	fprintf(stderr, "failed to stat %s more than %d times\n",
+	    path, MAX_STAT_RETRY);
+	abort();
+
+	return (-1);
+}
+
+/*
+ * Returns:
+ *
+ *  0     - success: atime, ctime and mtime will be populated
+ *  non-0 - failed: file could not be accessed (return is stat(2) errno)
+ */
+static int
+get_stat(char *pathname, struct stat *sb)
+{
+	int stat_ret;
+
+	stat_ret = stat_file(pathname, sb);
+
+	switch (stat_ret) {
+	case 0:
+		/* SUCCESS! (sb will be populated) */
+		return (0);
+	case ELOOP:         /* symbolic links in path point to each other */
+	case ENOTDIR:       /* component of path is not a dir */
+	case EACCES:        /* permission denied */
+	case ENOENT:        /* file or component path doesn't exist */
+		/*
+		 * The above are all fixable problems. We can't open the file
+		 * right now, but we know that we shouldn't be able to either.
+		 * As such, these are non-fatal and just result in a FAIL (with
+		 * final flag set true) response if we're responding to a
+		 * request or an error line if we're dealing with an event.
+		 */
+		return (stat_ret);
+	case EFAULT:        /* filename or buffer invalid (programmer error) */
+	case EIO:           /* error reading from filesystem (system error) */
+	case ENAMETOOLONG:  /* fo_name is too long (programmer error) */
+	case ENOLINK:       /* broken link to remote machine */
+	case ENXIO:         /* path marked faulty and retired */
+	case EOVERFLOW:     /* file is broken (system error) */
+	default:
+		/*
+		 * This handles cases we don't know how to deal with, by
+		 * dumping core so that it can later be debugged.
+		 */
+		abort();
+		break;
+	}
+}
+
+/*
+ * check_and_rearm_event() is called to (re)arm watches. This can either be
+ * because of an event (in which case revents should be pe.portev_events) or to
+ * initially arm in which case revents should be 0.
+ *
+ * It also performs the required stat() and in case this is a re-arm prints
+ * the event.
+ *
+ * We keep these two functions together (rearming and printing) because we need
+ * to do the stat() before we print the results since if the file no longer
+ * exists we cannot rearm. In that case we set the 'final' flag in the response.
+ */
+static void
+check_and_rearm_event(uint64_t key, char *name, int revents,
+    struct files_tree_node *ftn)
+{
+	boolean_t is_final = B_FALSE;
+	struct stat sb;
+	int stat_ret;
+	int pa_ret;
+	struct file_obj *fobjp;
+
+	/* ftn may be passed as an argument.  if not, we look for it. */
+	if (ftn == NULL) {
+		ftn = find_handle(name);
+	}
+
+	/* we don't have a handle for this file so ignore the event */
+	if (ftn == NULL) {
+		fprintf(stderr, "got event for '%s' without a handle\n", name);
+		return;
+	}
+
+	/*
+	 * We always stat the file after an event is received, or for the
+	 * inital watch.  If the stat fails for any reason, or any event is
+	 * seen that indicates the file is gone, we mark this file as "final" -
+	 * this means we will no longer be watching this file.
+	 */
+	stat_ret = get_stat(name, &sb);
+	if (stat_ret != 0 ||
+	    revents & FILE_DELETE || revents & FILE_RENAME_FROM ||
+	    revents & UNMOUNTED || revents & MOUNTEDOVER) {
+
+		is_final = B_TRUE;
+	}
+
+	if (key != SYSTEM_KEY && stat_ret != 0) {
+		/*
+		 * We're doing the initial register for this file, so we need
+		 * to send a result.
+		 */
+		print_response(key, RESULT_FAILURE, name,
+		    "stat(2) failed with errno %d: %s",
+		    stat_ret, strerror(stat_ret));
+		assert(is_final);
+	}
+
+	if (is_final) {
+		/* We're not going to re-watch the file, so cleanup */
+		if (revents != 0) {
+			print_event(revents, name, B_TRUE);
+		}
+		destroy_handle(ftn);
+		return;
+	}
+
+	/* (re)register watch */
+	fobjp = &ftn->fobj;
+	fobjp->fo_atime = sb.st_atim;
+	fobjp->fo_mtime = sb.st_mtim;
+	fobjp->fo_ctime = sb.st_ctim;
+
+	pa_ret = port_associate(port, PORT_SOURCE_FILE, (uintptr_t)fobjp,
+	    FILE_MODIFIED|FILE_TRUNC, name);
+
+	if (key != SYSTEM_KEY) {
+		/*
+		 * We're trying to do an initial associate, so we'll print a
+		 * result whether we succeeded or failed.
+		 */
+		VERIFY3S(revents, ==, 0);
+		if (pa_ret == -1) {
+			print_response(key, RESULT_FAILURE, name,
+			    "port_associate(3c) failed with errno %d: %s",
+			    errno, strerror(errno));
+			destroy_handle(ftn);
+			return;
+		}
+
+		print_response(key, RESULT_SUCCESS, name,
+		    "port_associate(3c) started watching path");
+		return;
+	}
+
+	/*
+	 * If we are here, this function was called as a result of an event
+	 * being seen.
+	 */
+	VERIFY3S(revents, !=, 0);
+	print_event(revents, name, B_FALSE);
+
+	if (pa_ret == -1) {
+		print_error(key, ERR_CANNOT_ASSOCIATE,
+		    "port_associate(3c) failed for '%s', errno %d: %s",
+		    name, errno, strerror(errno));
+		destroy_handle(ftn);
+	}
+}
+
+/*
+ * Only called from stdin thread. Attempts to watch pathname.
+ */
+static void
+watch_path(char *pathname, uint64_t key)
+{
+	struct files_tree_node *ftn;
+	char *dupname;
+
+	if (find_handle(pathname) != NULL) {
+		print_response(key, RESULT_SUCCESS, pathname,
+		    "already watching");
+		return;
+	}
+
+	ftn = malloc(sizeof (struct files_tree_node));
+	if (ftn == NULL)
+		err(1, "malloc new watcher");
+
+	/*
+	 * Copy the pathname given here as we need to hold onto it for as long
+	 * as the file is being watched.
+	 */
+	dupname = strdup(pathname);
+	if (dupname == NULL)
+		err(1, "strdup new watcher");
+
+	ftn->fobj.fo_name = dupname;
+	ftn->name = dupname;
+	ftn->name_hash = djb2(dupname);
+
+	add_handle(ftn);
+
+	check_and_rearm_event(key, dupname, 0, ftn);
+}
+
+/*
+ * Only called from stdin thread. Attempts to unwatch pathname.
+ */
+static void
+unwatch_path(char *pathname, uint64_t key)
+{
+	struct file_obj *fobjp;
+	int ret;
+	struct files_tree_node *ftn;
+
+	ftn = find_handle(pathname);
+	if (ftn == NULL) {
+		print_response(key, RESULT_FAILURE, pathname,
+		    "not watching '%s', cannot unwatch", pathname);
+		return;
+	}
+
+	fobjp = &ftn->fobj;
+	/*
+	 * From the man page, there are 5 possible errors for port_dissociate():
+	 *
+	 * EBADF
+	 *          The port identifier is not valid.
+	 *
+	 * EBADFD
+	 *          The source argument is of type PORT_SOURCE_FD  and  the
+	 *          object argument is not a valid file descriptor.
+	 *
+	 * EINVAL
+	 *          The source argument is not valid.
+	 *
+	 * EACCES
+	 *          The process is not the owner of the association.
+	 *
+	 * ENOENT
+	 *          The specified object is not associated with the port.
+	 *
+	 *
+	 * none of these seem like they'll succeed if tried again later for this
+	 * same file, so in every case we assume that the file is no longer
+	 * associated and remove the handle.
+	 */
+	ret = port_dissociate(port, PORT_SOURCE_FILE, (uintptr_t)fobjp);
+
+	destroy_handle(ftn);
+
+	if (ret == -1) {
+		print_response(key, RESULT_FAILURE, pathname,
+		    "failed to unregister '%s' (errno %d): %s", pathname, errno,
+		    strerror(errno));
+	} else {
+		print_response(key, RESULT_SUCCESS, pathname,
+		    "no longer watching '%s'", pathname);
+	}
+}
+
+/*
+ * Process one line of stdin
+ */
+static void
+process_stdin_line(char *str)
+{
+	char cmd[MAX_CMD_LEN + 1];
+	char path[MAX_CMD_LEN + 1];
+	int res;
+	unsigned long long key;
+
+	cmd[0] = '\0';
+	path[0] = '\0';
+
+	if (strlen(str) > MAX_CMD_LEN) {
+		print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+		    "command line too long");
+		return;
+	}
+
+	res = sscanf(str, "%llu %s %s", &key, cmd, path);
+
+	if (!(res == 2 || res == 3)) {
+		print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+		    "invalid command line");
+		return;
+	}
+
+	/* this is a reserved key */
+	if (key == SYSTEM_KEY) {
+		print_error(SYSTEM_KEY, ERR_INVALID_KEY,
+		    "invalid key: %d", SYSTEM_KEY);
+		return;
+	}
+
+	if (strcmp("UNWATCH", cmd) == 0) {
+		if (path[0] == '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - UNWATCH requires pathname");
+			return;
+		}
+
+		unwatch_path(path, key);
+	} else if (strcmp("WATCH", cmd) == 0) {
+		if (path[0] == '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - WATCH requires pathname");
+			return;
+		}
+
+		watch_path(path, key);
+	} else if (strcmp("STATUS", cmd) == 0) {
+		if (path[0] != '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - STATUS takes no arguments");
+			return;
+		}
+
+		print_status(key);
+	} else {
+		print_error(key, ERR_UNKNOWN_COMMAND, "unknown command '%s'",
+		    cmd);
+	}
+}
+
+/*
+ * Worker thread waits here for stdin data.
+ */
+static void *
+wait_for_stdin(void *arg __unused)
+{
+	char str[MAX_CMD_LEN + 1];
+
+	/* read stdin line-by-line indefinitely */
+	while (fgets(str, sizeof (str), stdin) != NULL) {
+		mutex_lock(&work_mutex);
+		process_stdin_line(str);
+		mutex_unlock(&work_mutex);
+
+		str[0] = '\0';
+	}
+
+	/* stdin closed or error */
+	if (feof(stdin)) {
+		errx(0, "stdin closed");
+	} else {
+		perror("stdin fgets");
+		abort();
+	}
+}
+
+/*
+ * Worker thread waits here for event port events.
+ */
+static void *
+wait_for_events(void *arg __unused)
+{
+	port_event_t pe;
+
+	while (!port_get(port, &pe, NULL)) {
+		mutex_lock(&work_mutex);
+
+		switch (pe.portev_source) {
+		case PORT_SOURCE_FILE:
+			/* call handler for filesystem event */
+			check_and_rearm_event(0, (char *)pe.portev_user,
+			    pe.portev_events, NULL);
+			break;
+		default:
+			/*
+			 * Something's seriously wrong if we get events with a
+			 * port source other than FILE, since that's all we're
+			 * adding. So abort and hope there's enough state in
+			 * the core.
+			 */
+			fprintf(stderr, "event from unexpected source: %d",
+			    pe.portev_source);
+			abort();
+		}
+
+		mutex_unlock(&work_mutex);
+	}
+
+	/* should not be reached */
+	perror("wait_for_events thread exited (port_get)");
+	abort();
+}
+
+/*
+ * Create a thread using the given thread_func and exit the process if thread
+ * creation fails.
+ */
+static void
+create_thread(void *(*thread_func)(void *))
+{
+	int rc;
+	thread_t tid;
+
+	if ((rc = thr_create(NULL, 0, thread_func, NULL, 0, &tid)) != 0) {
+		errx(1, "thr_create: %s", strerror(rc));
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	int opt;
+
+	opts.opt_j = B_FALSE;
+	opts.opt_r = B_FALSE;
+	while ((opt = getopt(argc, argv, "hjr")) != -1) {
+		switch (opt) {
+		case 'h':
+			usage(stdout);
+			return (0);
+		case 'j':
+			opts.opt_j = B_TRUE;
+			break;
+		case 'r':
+			opts.opt_r = B_TRUE;
+			break;
+		default:
+			usage(stderr);
+			return (1);
+		}
+	}
+	argc -= optind;
+	argv += optind;
+
+	/* create event port globally */
+	if ((port = port_create()) == -1) {
+		err(1, "port_create");
+	}
+
+	/* initialize the AVL tree to hold all files currently being watched */
+	avl_create(&files_tree, files_tree_node_comparator,
+	    sizeof (struct files_tree_node),
+	    offsetof(struct files_tree_node, avl_node));
+
+	/*
+	 * If the caller wants a "ready" event to be emitted, we grab the
+	 * global mutex here, and unlock it after the threads are created.
+	 */
+	if (opts.opt_r) {
+		mutex_lock(&work_mutex);
+	}
+
+	/* create worker threads to process stdin and event ports */
+	create_thread(wait_for_events);
+	create_thread(wait_for_stdin);
+
+	/* alert that we are ready for input */
+	if (opts.opt_r) {
+		print_ready();
+		mutex_unlock(&work_mutex);
+	}
+
+	/* do nothing while threads handle the load */
+	while (thr_join(0, NULL, NULL) == 0) {
+		/* pass */
+	}
+
+	return (0);
+}
diff --git a/src/manifest b/src/manifest
index e8d151a3..d31977ad 100644
--- a/src/manifest
+++ b/src/manifest
@@ -256,6 +256,7 @@ f usr/img/test/update.test.js 0444 root bin
 # new vmadmd
 s etc/bash/bash_completion.d/vmadm=/usr/vm/etc/vmadm.completion
 f lib/svc/manifest/system/system-vmadmd.xml 0444 root bin
+f lib/svc/manifest/system/system-vminfod.xml 0444 root bin
 f usr/bin/bunyan 0555 root bin
 f usr/share/man/man1/bunyan.1 0444 root bin
 f usr/share/man/man1m/vmadmd.1m 0444 root bin
@@ -279,10 +280,12 @@ f usr/vm/sbin/add-userscript 0555 root bin
 f usr/vm/sbin/dockerexec 0555 root bin
 f usr/vm/sbin/dockerinit 0555 root bin
 f usr/vm/sbin/filewait 0555 root bin
+f usr/vm/sbin/fswatcher 0555 root bin
 f usr/vm/sbin/rotate-kvm-logs.sh 0555 root bin
 f usr/vm/sbin/rotate-logs.sh 0555 root bin
 f usr/vm/sbin/vmadm 0555 root bin
 f usr/vm/sbin/vmadmd 0555 root bin
+f usr/vm/sbin/vminfod 0555 root bin
 f usr/vm/sbin/vmunbundle 0555 root bin
 f usr/vm/sbin/zfs_recv 0555 root bin
 f usr/vm/sbin/zfs_send 0555 root bin
@@ -292,8 +295,10 @@ f usr/node/0.10/node_modules/bunyan.js 0444 root bin
 f usr/node/0.10/node_modules/expat_binding.node 0444 root bin
 f usr/node/0.10/node_modules/node-expat.js 0444 root bin
 f usr/vm/node_modules/bunyan.js 0444 root bin
+f usr/vm/node_modules/diff.js 0644 root root
 f usr/vm/node_modules/dladm.js 0444 root bin
 f usr/vm/node_modules/expander.js 0444 root bin
+f usr/vm/node_modules/fswatcher.js 0444 root root
 f usr/vm/node_modules/hrtime.js 0444 root root
 f usr/vm/node_modules/ip.js 0444 root bin
 f usr/vm/node_modules/locker.js 0444 root bin
@@ -510,6 +515,7 @@ f usr/vm/node_modules/openonerrlogger.js 0444 root bin
 f usr/vm/node_modules/props.js 0444 root bin
 f usr/vm/node_modules/proptable.js 0444 root bin
 f usr/vm/node_modules/qmp.js 0444 root bin
+f usr/vm/node_modules/queue.js 0644 root root
 f usr/vm/node_modules/sysevent-stream.js 0444 root bin
 f usr/vm/node_modules/utils.js 0444 root bin
 d usr/vm/node_modules/vasync 0755 root root
@@ -552,10 +558,18 @@ f usr/vm/node_modules/vmload/vmload-utils.js 0644 root root
 f usr/vm/node_modules/vmload/vmload-xml.js 0644 root root
 f usr/vm/node_modules/vmload/dump-json.js 0755 root root
 f usr/vm/node_modules/vmload/index.js 0644 root root
+d usr/vm/node_modules/vminfod 0755 root root
+f usr/vm/node_modules/vminfod/vminfod.js 0644 root root
+f usr/vm/node_modules/vminfod/zpoolwatcher.js 0644 root root
+f usr/vm/node_modules/vminfod/zonewatcher.js 0644 root root
+f usr/vm/node_modules/vminfod/client.js 0644 root root
 f usr/vm/node_modules/VM.js 0444 root bin
 f usr/vm/node_modules/zonecfg.js 0444 root bin
+f usr/vm/node_modules/zoneevent.js 0444 root bin
 f usr/vm/smf/system-vmadmd 0555 root bin
 f usr/vm/smf/system-vmadmd.xml 0444 root bin
+f usr/vm/smf/system-vminfod 0555 root bin
+f usr/vm/smf/system-vminfod.xml 0444 root bin
 # fwadm
 s etc/bash/bash_completion.d/fwadm=/usr/fw/etc/fwadm.completion
 d usr/fw 0555 root bin
@@ -772,7 +786,6 @@ d usr/vm/lib 0555 root bin
 d usr/vm/lib/metadata 0555 root bin
 f usr/vm/lib/metadata/common.js 0444 root bin
 f usr/vm/lib/metadata/crc32.js 0444 root bin
-f usr/vm/lib/metadata/zwatch.js 0444 root bin
 f usr/vm/lib/metadata/agent.js 0444 root bin
 f usr/vm/sbin/metadata 0555 root bin
 f usr/vm/smf/system-metadata 0555 root bin
@@ -808,6 +821,7 @@ f usr/bin/disklist 0555 root bin
 f usr/bin/disk_size 0555 root bin
 f usr/bin/removable_disk 0555 root bin
 f usr/bin/mkzpool 0555 root bin
+f usr/bin/vminfod 0555 root bin
 f usr/lib/cryptpass 0555 root bin
 f usr/lib/measure_terminal 0555 root bin
 f usr/lib/sysevent/modules/sysinfo_mod.so 0555 root bin
diff --git a/src/vm/common/vmtest.js b/src/vm/common/vmtest.js
index 2bf8d623..1d54baf6 100644
--- a/src/vm/common/vmtest.js
+++ b/src/vm/common/vmtest.js
@@ -1,9 +1,33 @@
-//
-// Copyright 2016 Joyent, Inc.  All rights reserved.
-//
-// This is the common set of functions for things like ensuring we have a
-// SmartOS and Ubuntu image to work with.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * This is the common set of functions for things like ensuring we have a
+ * SmartOS and Ubuntu image to work with.
+ */
 
 process.env['TAP'] = 1;
 var async = require('/usr/node/node_modules/async');
@@ -108,7 +132,7 @@ exports.on_new_vm = function(t, uuid, payload, state, fnlist, callback)
         if (state.hasOwnProperty('uuid')) {
             VM.delete(state.uuid, function (err) {
                 if (err) {
-                    if (err.message.match(/No such zone configured/)) {
+                    if (err.code === 'ENOENT') {
                         t.ok(true, 'tried to delete VM ' + state.uuid
                             + ' but it was already gone.');
                     } else {
diff --git a/src/vm/lib/metadata/agent.js b/src/vm/lib/metadata/agent.js
index e340892e..3b50296a 100644
--- a/src/vm/lib/metadata/agent.js
+++ b/src/vm/lib/metadata/agent.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2017, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  *
  * # OVERVIEW
@@ -146,85 +146,14 @@ var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/vm/node_modules/bunyan');
 var common = require('./common');
 var crc32 = require('./crc32');
-var execFile = require('child_process').execFile;
 var fs = require('fs');
-var getZoneinfo
-    = require('/usr/vm/node_modules/vmload/vmload-zoneinfo').getZoneinfo;
-var guessHandleType = process.binding('tty_wrap').guessHandleType;
 var net = require('net');
 var path = require('path');
-var util = require('util');
-var vasync = require('vasync');
 var VM = require('/usr/vm/node_modules/VM');
-var ZWatch = require('./zwatch');
-
-var sdc_fields = [
-    'alias',
-    'billing_id',
-    'brand',
-    'cpu_cap',
-    'cpu_shares',
-    'create_timestamp',
-    'server_uuid',
-    'image_uuid',
-    'datacenter_name',
-    'do_not_inventory',
-    'dns_domain',
-    'force_metadata_socket',
-    'fs_allowed',
-    'hostname',
-    'internal_metadata_namespaces',
-    'limit_priv',
-    'last_modified',
-    'maintain_resolvers',
-    'max_physical_memory',
-    'max_locked_memory',
-    'max_lwps',
-    'max_swap',
-    'nics',
-    'owner_uuid',
-    'package_name',
-    'package_version',
-    'quota',
-    'ram',
-    'resolvers',
-    'routes',
-    'state',
-    'tmpfs',
-    'uuid',
-    'vcpus',
-    'vnc_port',
-    'zfs_io_priority',
-    'zonepath',
-    'zonename',
-    'zone_state'
-];
-
-var KVM_CONNECT_RETRY_INTERVAL = 100; // ms
-var KVM_CONNECT_RETRY_LOG_FREQUENCY = 10; // log every X retries
-var MAX_RETRY = 300; // in seconds
-var ZONEADM_CHECK_FREQUENCY = (5 * 60 * 1000); // ms, check for deleted zones
-var MISSED_SYSEVENT_CHECK_FREQUENCY = (1 * 60 * 1000); // ms
-
-
-function zoneExists(zonename, callback) {
-    var exists = false;
-
-    fs.stat('/etc/zones/' + zonename + '.xml', function _onStat(err, stats) {
-        if (err) {
-            if (err.code !== 'ENOENT') {
-                // Should either exist or not exist but should always be
-                // readable if it does exist. If not: we don't know how to
-                // proceed so throw/abort.
-                throw (err);
-            }
-        } else {
-            exists = true;
-        }
+var VminfodWatcher
+    = require('/usr/vm/node_modules/vminfod/client').VminfodWatcher;
 
-        callback(null, exists);
-    });
-}
+function noop() {}
 
 function closeZoneConnection(zoneConn) {
     assert.object(zoneConn, 'zoneConn');
@@ -270,10 +199,8 @@ function elapsedTimer(timer) {
 var MetadataAgent = module.exports = function (options) {
     this.log = options.log;
     this.zlog = {};
-    this.zones = {};
     this.zonesDebug = {};
     this.zoneConnections = {};
-    this.zoneKvmReconnTimers = {};
 };
 
 /*
@@ -326,8 +253,8 @@ MetadataAgent.prototype.addDebug = function addDebug(zonename, field, value) {
 };
 
 MetadataAgent.prototype.createZoneLog = function (type, zonename) {
-    assert.string(type);
-    assert.string(zonename);
+    assert.string(type, 'type');
+    assert.string(zonename, 'zonename');
 
     var self = this;
     var newRingbuffer = new bunyan.RingBuffer({limit: 10});
@@ -341,461 +268,171 @@ MetadataAgent.prototype.createZoneLog = function (type, zonename) {
     return (self.zlog[zonename]);
 };
 
-MetadataAgent.prototype.updateZone = function updateZone(zonename, callback) {
+MetadataAgent.prototype.createServersOnExistingZones = function (vms) {
     var self = this;
-    var log = self.log;
-
-    assert.string(zonename, 'zonename');
-    assert.func(callback, 'callback');
+    var created = 0;
+    var keys = Object.keys(vms);
 
-    function shouldLoad(cb) {
-        if (!self.zones.hasOwnProperty(zonename)) {
-            // don't have a cache, load this guy
-            log.info({zonename: zonename},
-                'no cache for: ' + zonename + ', loading');
-            cb(null, true);
-            return;
+    async.forEach(keys, function (zonename, cb) {
+        var vm = vms[zonename];
+        if (!self.zlog[zonename]) {
+            // create a logger specific to this VM
+            self.createZoneLog(vm.brand, zonename);
         }
 
-        // We do have a cached version, we'll reload only if timestamp of the
-        // XML file changed. The vmadm operations we care about will "touch"
-        // this file to update the last_modified if they don't change it
-        // directly.
-        fs.stat('/etc/zones/' + zonename + '.xml', function (err, stats) {
-            var old_mtime;
-
-            if (err && err.code === 'ENOENT') {
-                // VM has disappeared, purge from cache
-                self.purgeZoneCache(zonename);
-                cb(null, false);
-                return;
-            } else if (err) {
-                log.error({err: err, zonename: zonename},
-                    'cannot fs.stat(), reloading');
-                cb(err);
-                return;
-            }
-
-            // we just did a successful stat, we really should have
-            // self.zones[zonename]
-            assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
-
-            old_mtime = (new Date(self.zones[zonename].last_modified));
-            if (stats.mtime.getTime() > old_mtime.getTime()) {
-                log.info({zonename: zonename},
-                    'last_modified was updated, reloading');
-                cb(null, true);
-                return;
-            }
-
-            log.trace('using cache for: ' + zonename);
-            cb(null, false);
-        });
-    }
-
-    shouldLoad(function (err, load) {
-        var start_lookup_timer = newTimer();
-
-        // fail open (meaning: force reload) when something went wrong
-        if (load || err) {
-            VM.lookup({ zonename: zonename }, { fields: sdc_fields },
-                function (error, machines) {
-                    var elapsed = elapsedTimer(start_lookup_timer);
-
-                    if (!error) {
-                        self.zones[zonename] = machines[0];
-                        self.addDebug(zonename, 'last_zone_load');
-                    }
-                    log.debug({
-                        elapsed: elapsed,
-                        err: error,
-                        zonename: zonename
-                    }, 'finished VM.lookup');
-                    callback(error);
-                    return;
-                }
-            );
-        } else {
-            // no need to reload since there's no change, use existing data
-            callback();
+        if (self.zoneConnections[zonename]) {
+            cb();
             return;
         }
-    });
-};
 
-MetadataAgent.prototype.createServersOnExistingZones = function () {
-    var self = this;
-    var created = 0;
-
-    VM.lookup({}, { fields: sdc_fields }, function (error, zones) {
-        async.forEach(zones, function (zone, cb) {
-            if (zone.zonename === 'global') {
+        if (vm.brand === 'kvm') {
+            // For KVM, the zone must be running otherwise Qemu will not
+            // have created a socket.
+            if (vm.zone_state !== 'running') {
+                self.log.debug('skipping non-running vm %s, zone_state %s',
+                    zonename, vm.zone_state);
                 cb();
                 return;
             }
 
-            self.zones[zone.zonename] = zone;
-            self.addDebug(zone.zonename, 'last_zone_load');
-
-            if (error) {
-                throw error;
-            }
-
-            if (!self.zlog[zone.zonename]) {
-                // create a logger specific to this VM
-                self.createZoneLog(zone.brand, zone.zonename);
-            }
-
-            // It is possible for VM.lookup() to take a long time. While we're
-            // waiting for it, the watcher could have seen the zone creation and
-            // created a socket for the zone. In case that happened, we ignore
-            // zones we've already got a connection for.
-            if (self.zoneConnections[zone.zonename]) {
+            self.startKVMSocketServer(zonename, function (err) {
+                if (!err) {
+                    created++;
+                }
                 cb();
-                return;
-            }
-
-            if (zone.brand === 'kvm') {
-
-                // For KVM, the zone must be running otherwise Qemu will not
-                // have created a socket.
-                if (zone.zone_state !== 'running') {
-                    self.log.debug('skipping zone ' + zone.zonename
-                        + ' which has ' + 'non-running zone_state: '
-                        + zone.zone_state);
-                    cb();
-                    return;
+            });
+        } else {
+            self.startZoneSocketServer(zonename, function (err) {
+                if (!err) {
+                    created++;
                 }
-
-                self.startKVMSocketServer(zone.zonename, function (err) {
-                    if (!err) {
-                        created++;
-                    }
-                    cb();
-                });
-            } else {
-                self.startZoneSocketServer(zone.zonename, function (err) {
-                    if (!err) {
-                        created++;
-                    }
-                    cb();
-                });
-            }
-        }, function (err) {
-            self.log.info('created zone metadata sockets on %d / %d zones',
-                created, zones.length);
-        });
+                cb();
+            });
+        }
+    }, function (err) {
+        self.log.info('created zone metadata sockets on %d / %d zones',
+            created, keys.length);
     });
 };
 
 MetadataAgent.prototype.purgeZoneCache = function purgeZoneCache(zonename) {
-    assert.string(zonename);
-
     var self = this;
 
+    assert.string(zonename, 'zonename');
+
     self.log.info(zonename + ' no longer exists, purging from cache(s) and '
         + 'stopping timeout');
 
     if (self.zonesDebug.hasOwnProperty(zonename)) {
         delete self.zonesDebug[zonename];
     }
+
     if (self.zlog.hasOwnProperty(zonename)) {
         delete self.zlog[zonename];
     }
+
     if (self.zoneConnections.hasOwnProperty(zonename)) {
         if (self.zoneConnections[zonename]) {
             // it's not undefined, so attempt to close it
             closeZoneConnection(self.zoneConnections[zonename]);
         }
-        delete self.zoneConnections[zonename];
-    }
-    if (self.zones.hasOwnProperty(zonename)) {
-        delete self.zones[zonename];
-    }
-};
 
-MetadataAgent.prototype.stopKvmReconnTimer =
-function stopKvmReconnTimer(zonename) {
-    var self = this;
-
-    self.log.warn({zonename: zonename},
-        'clearing connection retries for KVM VM.');
-
-    if (self.zoneKvmReconnTimers.hasOwnProperty(zonename)) {
-        clearTimeout(self.zoneKvmReconnTimers[zonename]);
-        delete self.zoneKvmReconnTimers[zonename];
+        delete self.zoneConnections[zonename];
     }
 };
 
-MetadataAgent.prototype.checkMissedSysevents = function checkMissedSysevents() {
-    var self = this;
-    var start_kstat_timer = newTimer();
-
-    // Reminder: getZoneinfo only returns *running* zones since it pulls its
-    // data from the kernel.
-    getZoneinfo(null, {log: self.log}, function (err, results) {
-        assert.ifError(err);
-
-        function _assumeCreated(zonename) {
-            self.addDebug(zonename, 'last_zone_found_existing');
-            self.handleZoneCreated(zonename);
-        }
-
-        self.log.debug({
-            elapsed: elapsedTimer(start_kstat_timer),
-            zoneCount: Object.keys(results).length
-        }, 'loaded VM kstats');
-
-        Object.keys(results).forEach(function _checkZoneConn(zonename) {
-            var zoneConn = self.zoneConnections[zonename]; // may be undefined
-
-            if (!zoneConn) {
-                // If we have no zoneConn, It's likely we failed a previous
-                // attempt to create one. In any case, since the zone does exist
-                // (it's in getZoneinfo) we should attempt to create a new
-                // socket for it.
-                self.log.warn({zonename: zonename}, 'zone is missing '
-                    + 'zoneConnections entry, (re)trying socket creation');
-                _assumeCreated(zonename);
-                return;
-            }
-        });
-
-        // We expect the VMs in self.zoneKvmReconnTimers to be 'running', since
-        // we're actively retrying connections to their ttyb sockets. If they
-        // went not-running unexpectedly, kill the retries.
-        Object.keys(self.zoneKvmReconnTimers).forEach(
-            function _checkTimer(zonename) {
-                if (!results.hasOwnProperty(zonename)) {
-                    self.log.warn({zonename: zonename}, 'was reconnecting for '
-                        + 'KVM zone, but it is no longer running.');
-                    self.stopKvmReconnTimer(zonename);
-
-                    // Also remove the zoneConnections entry so that the
-                    // connection will be recreated when we notice it going
-                    // running. See "The rules for zoneConnections" above.
-                    delete self.zoneConnections[zonename];
-                }
-            }
-        );
-    });
-};
-
-MetadataAgent.prototype.startPeriodicChecks = function startPeriodicChecks() {
+MetadataAgent.prototype.handleZoneCreated =
+function handleZoneCreated(vm) {
     var self = this;
 
-    // Every 5 minutes we check to see whether zones we've got in self.zones
-    // were deleted. If they are, we delete the record from the cache and close
-    // any open connection.
-
-    function _checkDeletedZones() {
-        var cmd = '/usr/sbin/zoneadm';
-        var start_zoneadm_timer = newTimer();
-
-        execFile(cmd, ['list', '-c'], function (err, stdout, stderr) {
-            var elapsed = elapsedTimer(start_zoneadm_timer);
-            var zones = {};
+    assert.object(vm, 'vm');
+    assert.string(vm.zonename, 'vm.zonename');
 
-            if (err) {
-                self.log.error({
-                    elapsed: elapsed,
-                    err: err
-                }, 'unable to get list of zones');
-                return;
-            }
-
-            // each output line is a zonename, so we turn this into an object
-            // that looks like:
-            //
-            // {
-            //   zonename: true,
-            //   zonename: true
-            //   ...
-            // }
-            //
-            // so we can then loop through all the cached zonenames and remove
-            // those that don't exist on the system any longer.
-            stdout.trim().split(/\n/).forEach(function (z) {
-                if (z !== 'global') {
-                    zones[z] = true;
-                }
-            });
-
-            self.log.debug({
-                elapsed: elapsed,
-                zonesFound: Object.keys(zones).length
-            }, 'loaded zoneadm list of existing zones');
-
-            Object.keys(self.zones).forEach(function (z) {
-                if (!zones.hasOwnProperty(z)) {
-                    self.purgeZoneCache(z);
-                }
-            });
-
-            // schedule the next check
-            setTimeout(_checkDeletedZones, ZONEADM_CHECK_FREQUENCY);
-        });
+    if (!self.zlog[vm.zonename]) {
+        // create a logger specific to this VM
+        self.createZoneLog(vm.brand, vm.zonename);
     }
 
-    // Here we check for boot messages that we might have missed due to the fact
-    // that sysevent messages are unreliable.
-
-    function _checkNewZones() {
-        self.checkMissedSysevents();
-
-        // schedule the next check
-        setTimeout(_checkNewZones, MISSED_SYSEVENT_CHECK_FREQUENCY);
+    if (vm.brand === 'kvm') {
+        self.startKVMSocketServer(vm.zonename, noop);
+    } else {
+        self.startZoneSocketServer(vm.zonename, noop);
     }
-
-    // Set the first timers to kick these checks off.
-
-    setTimeout(_checkDeletedZones, ZONEADM_CHECK_FREQUENCY);
-    self.log.info('Setup timer to purge deleted zones every %d ms',
-        ZONEADM_CHECK_FREQUENCY);
-
-    setTimeout(_checkNewZones, MISSED_SYSEVENT_CHECK_FREQUENCY);
-    self.log.info('Setup timer to detect (missed) new zones every %d ms',
-        MISSED_SYSEVENT_CHECK_FREQUENCY);
 };
 
-MetadataAgent.prototype.handleZoneCreated =
-function handleZoneCreated(zonename) {
-    assert.string(zonename, 'zonename');
+MetadataAgent.prototype.start = function start() {
     var self = this;
 
-    // We don't wait around for results from creating the sockets because on
-    // failure self.startKVMSocketServer or self.startZoneSocketServer should
-    // leave us in a place we can retry on the next periodic check. So we just
-    // pass this dummy callback instead.
-    function _dummyCb() {
-    }
+    self.vminfod_watcher = new VminfodWatcher({
+        log: self.log,
+        name: 'Metadata Agent - VminfodWatcher'
+    });
 
-    self.updateZone(zonename, function (error) {
-        if (error) {
-            self.log.error({err: error}, 'Error updating '
-                + 'attributes: ' + error.message);
+    self.vminfod_watcher.once('ready', function (ready_ev) {
+        var vms = self.vminfod_watcher.vms();
+        self.createServersOnExistingZones(vms);
+    });
 
-            // When there's an error, we'll have not set in self.zones, so we'll
-            // try again next time we see that the zone is running.
+    self.vminfod_watcher.on('create', function (ev) {
+        // ignore zones we've already (still) got a connection for
+        if (self.zoneConnections[ev.zonename])
             return;
-        }
 
-        // If the zone was not deleted between the time we saw it start and
-        // now, (we did a vmadm lookup in between via updateZone which could
-        // have taken a while) we'll start the watcher.
-        if (self.zones[zonename]) {
-            if (!self.zlog[zonename]) {
-                // create a logger specific to this VM
-                self.createZoneLog(self.zones[zonename].brand, zonename);
-            }
+        self.log.debug({
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw new zone');
 
-            if (self.zones[zonename].brand === 'kvm') {
-                self.startKVMSocketServer(zonename, _dummyCb);
-            } else {
-                self.startZoneSocketServer(zonename, _dummyCb);
-            }
-        }
+        self.addDebug(ev.zonename, 'last_zone_create');
+        self.handleZoneCreated(ev.vm);
     });
-};
-
-MetadataAgent.prototype.start = function start() {
-    var self = this;
-    var zwatch = this.zwatch = new ZWatch(self.log);
-    self.createServersOnExistingZones();
-    self.startPeriodicChecks();
-
-    zwatch.on('zone_transition', function (msg) {
-        var when = new Date(msg.when / 1000000);
 
+    self.vminfod_watcher.on('delete', function (ev) {
         // when a zone was deleted, cleanup any cached stuff for it
-        if (msg.cmd === 'delete') {
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw zone deletion');
-
-            self.purgeZoneCache(msg.zonename);
-            return;
-        }
+        self.log.debug({
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw zone deletion');
 
+        self.purgeZoneCache(ev.zonename);
+    });
+
+    self.vminfod_watcher.on('modify', function (ev) {
         // For non-KVM, we only care about create/delete since the socket
         // only needs to be created once for these zones. For KVM however,
         // the qemu process recreates the socket on every boot, so we want
         // to catch 'start' events for KVM to ensure we connect to metadata
         // as soon as possible.
-        if (msg.cmd === 'start' && self.zones.hasOwnProperty(msg.zonename)
-            && self.zones[msg.zonename].brand === 'kvm') {
-            // KVM VM started
-
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw KVM zone start');
-
-            self.addDebug(msg.zonename, 'last_zone_start');
-
-            // The "zone" wasn't technically created here, but the socket was
-            // (by qemu) so as far as we're concerned this is the same thing.
-            self.handleZoneCreated(msg.zonename);
-            return;
-        }
-
-        // If a KVM zone stops while we're trying to reconnect to its metadata
-        // socket, stop trying to reconnect.
-        if (msg.cmd === 'stop'
-            && self.zoneKvmReconnTimers.hasOwnProperty(msg.zonename)) {
-
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw retrying KVM zone stop');
-
-            self.stopKvmReconnTimer(msg.zonename);
-
-            // Also remove the zoneConnections entry so that the
-            // connection will be recreated when we notice it going
-            // running. See "The rules for zoneConnections" above.
-            delete self.zoneConnections[msg.zonename];
-
+        if (ev.vm.brand !== 'kvm')
             return;
-        }
 
-        // ignore everything else except create
-        if (msg.cmd !== 'create') {
-            return;
-        }
+        var running = ev.changes.some(function (change) {
+            return (change.path[0] === 'state' && change.to === 'running');
+        });
 
-        // ignore zones we've already (still) got a connection for
-        if (self.zoneConnections[msg.zonename]) {
+        if (!running)
             return;
-        }
 
         self.log.debug({
-            delay: (new Date()).getTime() - when.getTime(), // in ms
-            when: when,
-            zonename: msg.zonename
-        }, 'ZWatch watcher saw new zone');
-
-        zoneExists(msg.zonename, function _zoneExists(_, exists) {
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw KVM zone boot');
 
-            if (!exists) {
-                self.log.warn({transition: msg},
-                    'ignoring transition for zone that no longer exists');
-                return;
-            }
+        self.addDebug(ev.zonename, 'last_zone_start');
 
-            // we only handle create, so that's what this was
-            self.addDebug(msg.zonename, 'last_zone_create');
-            self.handleZoneCreated(msg.zonename);
-        });
+        // The "zone" wasn't technically created here, but the socket was
+        // (by qemu) so as far as we're concerned this is the same thing.
+        self.handleZoneCreated(ev.vm);
     });
 };
 
 MetadataAgent.prototype.stop = function () {
-    this.zwatch.stop();
+    var self = this;
+
+    self.vminfod_watcher.stop();
 };
 
 MetadataAgent.prototype.startKVMSocketServer = function (zonename, callback) {
@@ -803,23 +440,23 @@ MetadataAgent.prototype.startKVMSocketServer = function (zonename, callback) {
 
     assert.string(zonename, 'zonename');
     assert.func(callback, 'callback');
-    assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
-    assert.object(self.zlog[zonename], 'self.zlog[' + zonename + ']');
 
-    var vmobj = self.zones[zonename];
+    var vmobj = self.vminfod_watcher.vm(zonename);
     var zlog = self.zlog[zonename] || self.log;
+
+    assert.object(vmobj, 'vmobj');
+
     var sockpath = path.join(vmobj.zonepath, '/root/tmp/vm.ttyb');
 
     zlog.trace('starting socket server');
 
     async.waterfall([
         function (cb) {
-
             common.retryUntil(2000, 120000,
                 function (c) {
                     var err;
 
-                    if (!self.zones[zonename]) {
+                    if (!self.vminfod_watcher.vm(zonename)) {
                         // zone was removed, no need to retry any further
                         err = new Error('zone no longer exists');
                         err.code = 'ENOENT';
@@ -860,6 +497,10 @@ MetadataAgent.prototype.startKVMSocketServer = function (zonename, callback) {
 
 MetadataAgent.prototype.createKVMServer = function (zopts, callback) {
     var self = this;
+    var buffer;
+    var fd;
+    var handler;
+    var kvmstream;
     var zlog;
 
     assert.object(zopts, 'zopts');
@@ -870,7 +511,7 @@ MetadataAgent.prototype.createKVMServer = function (zopts, callback) {
     zlog = self.zlog[zopts.zone] || self.log;
 
     // Ignore zones that have been removed
-    if (!self.zones[zopts.zone]) {
+    if (!self.vminfod_watcher.vm(zopts.zone)) {
         zlog.trace({zonename: zopts.zone},
             'not creating kvm socket for zone that does not exist');
         callback();
@@ -887,6 +528,8 @@ MetadataAgent.prototype.createKVMServer = function (zopts, callback) {
     }
     self.zoneConnections[zopts.zone] = {};
 
+    kvmstream = new net.Socket();
+
     // refuse to overwrite an existing connection
     assert.ok(!self.zoneConnections[zopts.zone].hasOwnProperty('conn'),
         'should not have existing conn when creating new');
@@ -895,93 +538,41 @@ MetadataAgent.prototype.createKVMServer = function (zopts, callback) {
 
     // replace the placeholder entry with a real one.
     self.zoneConnections[zopts.zone] = {
-        conn: {}, // placeholder so we don't overwrite if we're called again
-        connectsRefused: 0,
+        conn: kvmstream,
         sockpath: zopts.sockpath
     };
 
-    function _tryConnect() {
-        var buffer = '';
-        var fd;
-        var handler;
-        var kvmstream = new net.Socket();
-
-        handler = self.makeMetadataHandler(zopts.zone, kvmstream);
-
-        self.zoneConnections[zopts.zone].conn = kvmstream;
+    buffer = '';
+    handler = self.makeMetadataHandler(zopts.zone, kvmstream);
 
-        kvmstream.on('connect', function _onConnect() {
-            // either this on('connect') handler will run or the on('error')
-            fd = kvmstream._handle.fd;
-            zlog.info({
-                conn_refused: self.zoneConnections[zopts.zone].connectsRefused,
-                zonename: zopts.zone
-            }, 'listening on fd %d', fd);
-            self.zoneConnections[zopts.zone].fd = fd;
-            // we're no longer retrying connections (since we connected)
-            delete self.zoneKvmReconnTimers[zopts.zone];
-        });
-
-        kvmstream.on('data', function (data) {
-            var chunk, chunks;
-
-            buffer += data.toString();
-            chunks = buffer.split('\n');
-            while (chunks.length > 1) {
-                chunk = chunks.shift();
-                handler(chunk);
-            }
-            buffer = chunks.pop();
-        });
-
-        kvmstream.on('error', function (e) {
-            var level = 'warn';
-            var refused = self.zoneConnections[zopts.zone].connectsRefused;
-
-            if (e.code === 'ECONNREFUSED') {
-                level = 'trace';
-
-                // Our connection was refused by Qemu, presumably because Qemu
-                // is still starting up and we're early. Try again and set a
-                // handle to our retry timer so it can be cancelled if the zone
-                // is stopped.
-                //
-                // We log every Xth retry after the first so that we don't
-                // completely spam the log.
-                if (refused > 0
-                    && (refused % KVM_CONNECT_RETRY_LOG_FREQUENCY) === 0) {
-
-                    zlog.info({
-                        conn_refused: refused,
-                        last_errcode: e.code,
-                        retry_interval: KVM_CONNECT_RETRY_INTERVAL
-                    }, 'KVM socket connection refused, still retrying');
-                }
-                self.zoneKvmReconnTimers[zopts.zone] = setTimeout(_tryConnect,
-                    KVM_CONNECT_RETRY_INTERVAL);
+    kvmstream.on('data', function (data) {
+        var chunk, chunks;
+        buffer += data.toString();
+        chunks = buffer.split('\n');
+        while (chunks.length > 1) {
+            chunk = chunks.shift();
+            handler(chunk);
+        }
+        buffer = chunks.pop();
+    });
 
-                self.zoneConnections[zopts.zone].connectsRefused++;
-            }
+    kvmstream.on('error', function (e) {
+        zlog.error({err: e}, 'KVM Socket error: ' + e.message);
+    });
 
-            zlog[level]({err: e}, 'KVM Socket error: ' + e.message);
-        });
+    kvmstream.on('close', function () {
+        // When the stream closes, we'll delete from zoneConnections so that on
+        // next boot (or periodic scan if for some reason we got closed while
+        // the zone was actually running) we re-create.
+        zlog.info('stream closed on fd %d', fd);
+        delete self.zoneConnections[zopts.zone];
+    });
 
-        kvmstream.on('close', function () {
-            // When the stream closes, we'll delete from zoneConnections so that
-            // on next boot (or periodic scan if for some reason we got closed
-            // while the zone was actually running) we re-create.
-            if (!self.zoneKvmReconnTimers.hasOwnProperty(zopts.zone)) {
-                zlog.info('stream closed on fd %d', fd);
-                delete self.zoneConnections[zopts.zone];
-            }
-        });
+    kvmstream.connect(zopts.sockpath);
 
-        zlog.trace({zonename: zopts.zone, sockpath: zopts.sockpath},
-            'attempting connection to KVM socket');
-        kvmstream.connect(zopts.sockpath);
-    }
-
-    _tryConnect();
+    fd = kvmstream._handle.fd;
+    zlog.info({zonename: zopts.zone}, 'listening on fd %d', fd);
+    self.zoneConnections[zopts.zone].fd = fd;
 
     callback();
 };
@@ -990,11 +581,11 @@ MetadataAgent.prototype.startZoneSocketServer =
 function startZoneSocketServer(zonename, callback) {
     var self = this;
 
-    assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
-    assert.string(self.zones[zonename].brand,
-        'self.zones[' + zonename + '].brand');
-    assert.string(self.zones[zonename].zonepath,
-        'self.zones[' + zonename + '].zonepath');
+    var vmobj = self.vminfod_watcher.vm(zonename);
+
+    assert.object(vmobj, 'vmobj');
+    assert.string(vmobj.brand, 'vmobj.brand');
+    assert.string(vmobj.zonepath, 'vmobj.zonename');
     assert.func(callback, 'callback');
 
     var zlog = self.zlog[zonename] || self.log;
@@ -1023,7 +614,7 @@ function createZoneSocket(zopts, callback) {
     var zlog = self.zlog[zopts.zone] || self.log;
     var zonecontrol = path.dirname(zopts.path);
 
-    if (!self.zones[zopts.zone]) {
+    if (!self.vminfod_watcher.vm(zopts.zone)) {
         zlog.info({zonename: zopts.zone},
             'zone no longer exists, not creating socket');
         callback();
@@ -1191,9 +782,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
     };
 
     return function _metadataHandler(data) {
-        // ensure sanity: we should only get metadata request for existing zones
-        assert.object(self.zones[zone], 'self.zones[' + zone + ']');
-
         var cmd;
         var ns;
         var parts;
@@ -1205,6 +793,11 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
         var vmobj;
         var want;
 
+        vmobj = self.vminfod_watcher.vm(zone);
+
+        // ensure sanity: we should only get metadata request for existing zones
+        assert.object(vmobj, 'vmobj');
+
         parts = data.toString().trimRight().replace(/\n$/, '')
             .match(/^([^\s]+)\s?(.*)/);
 
@@ -1226,8 +819,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
             return;
         }
 
-        vmobj = self.zones[zone];
-
         // Unbox V2 protocol frames:
         if (cmd === 'V2') {
             if (!parse_v2_request(want))
@@ -1252,175 +843,85 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                 // that depends on it, please add a note about that here
                 // otherwise expect it will be removed on you sometime.
                 if (want === 'nics' && vmobj.hasOwnProperty('nics')) {
-                    self.updateZone(zone, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].nics);
-                        } else {
-                            val = JSON.stringify(vmobj.nics);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+
+                    val = JSON.stringify(vmobj.nics);
+                    returnit(null, val);
+
                 } else if (want === 'resolvers'
                     && vmobj.hasOwnProperty('resolvers')) {
 
-                    // resolvers, nics and routes are special because we might
-                    // reload metadata trying to get the new ones w/o zone
-                    // reboot. To ensure these are fresh we always run
-                    // updateZone which reloads the data if stale.
-                    self.updateZone(zone, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        // See NOTE above about nics, same applies to resolvers.
-                        // It's here solely for the use of mdata-fetch.
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].resolvers);
-                        } else {
-                            val = JSON.stringify(vmobj.resolvers);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+                    val = JSON.stringify(vmobj.resolvers);
+                    returnit(null, val);
+
                 } else if (want === 'tmpfs'
                     && vmobj.hasOwnProperty('tmpfs')) {
-                    // We want tmpfs to reload the cache right away because we
-                    // might be depending on a /etc/vfstab update
-                    self.updateZone(zone, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].tmpfs);
-                        } else {
-                            val = JSON.stringify(vmobj.tmpfs);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+
+                    val = JSON.stringify(vmobj.tmpfs);
+                    returnit(null, val);
+
                 } else if (want === 'routes'
                     && vmobj.hasOwnProperty('routes')) {
 
                     var vmRoutes = [];
 
-                    self.updateZone(zone, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
+                    // The notes above about resolvers also to routes. It's
+                    // here solely for the use of mdata-fetch, and we need
+                    // to do the updateZone here so that we have latest
+                    // data.
+                    for (var r in vmobj.routes) {
+                        var route = { linklocal: false, dst: r };
+                        var nicIdx = vmobj.routes[r].match(/nics\[(\d+)\]/);
+                        if (!nicIdx) {
+                            // Non link-local route: we have all the
+                            // information we need already
+                            route.gateway = vmobj.routes[r];
+                            vmRoutes.push(route);
+                            continue;
                         }
+                        nicIdx = Number(nicIdx[1]);
 
-                        if (self.zones[zone]) {
-                            vmobj = self.zones[zone];
-                        }
+                        // Link-local route: we need the IP of the local nic
+                        if (!vmobj.hasOwnProperty('nics')
+                            || !vmobj.nics[nicIdx]
+                            || !vmobj.nics[nicIdx].hasOwnProperty('ip')
+                            || vmobj.nics[nicIdx].ip === 'dhcp') {
 
-                        // The notes above about resolvers also to routes. It's
-                        // here solely for the use of mdata-fetch, and we need
-                        // to do the updateZone here so that we have latest
-                        // data.
-                        for (var r in vmobj.routes) {
-                            var route = { linklocal: false, dst: r };
-                            var nicIdx = vmobj.routes[r].match(/nics\[(\d+)\]/);
-                            if (!nicIdx) {
-                                // Non link-local route: we have all the
-                                // information we need already
-                                route.gateway = vmobj.routes[r];
-                                vmRoutes.push(route);
-                                continue;
-                            }
-                            nicIdx = Number(nicIdx[1]);
-
-                            // Link-local route: we need the IP of the local nic
-                            if (!vmobj.hasOwnProperty('nics')
-                                || !vmobj.nics[nicIdx]
-                                || !vmobj.nics[nicIdx].hasOwnProperty('ip')
-                                || vmobj.nics[nicIdx].ip === 'dhcp') {
-
-                                continue;
-                            }
-
-                            route.gateway = vmobj.nics[nicIdx].ip;
-                            route.linklocal = true;
-                            vmRoutes.push(route);
+                            continue;
                         }
 
-                        returnit(null, JSON.stringify(vmRoutes));
-                        return;
-                    });
-                } else if (want === 'operator-script') {
-                    addMetadata(function (err) {
-                        if (err) {
-                            returnit(new Error('Unable to load metadata: '
-                                + err.message));
-                            return;
-                        }
+                        route.gateway = vmobj.nics[nicIdx].ip;
+                        route.linklocal = true;
+                        vmRoutes.push(route);
+                    }
 
-                        returnit(null,
-                            vmobj.internal_metadata['operator-script']);
-                        return;
-                    });
+                    returnit(null, JSON.stringify(vmRoutes));
+                } else if (want === 'operator-script') {
+                    returnit(null, vmobj.internal_metadata['operator-script']);
                 } else if (want === 'volumes') {
-                    addMetadata(function returnVolumes(err) {
-                        if (err) {
-                            returnit(new Error('Unable to load metadata: '
-                                + err.message));
-                            return;
-                        }
-
-                        returnit(null,
-                            vmobj.internal_metadata['sdc:volumes']);
-                        return;
-                    });
+                    returnit(null, vmobj.internal_metadata['sdc:volumes']);
                 } else {
-                    addTags(function (err) {
-                        if (!err) {
-                            val = VM.flatten(vmobj, want);
-                        }
-                        returnit(err, val);
-                        return;
-                    });
+                    val = VM.flatten(vmobj, want);
+                    returnit(null, val);
                 }
             } else {
-                // not sdc:, so key will come from *_mdata
-                addMetadata(function (err) {
-                    var which_mdata = 'customer_metadata';
-
-                    if (err) {
-                        returnit(new Error('Unable to load metadata: '
-                            + err.message));
-                        return;
-                    }
+                var which_mdata = 'customer_metadata';
 
-                    if (want.match(/_pw$/)) {
-                        which_mdata = 'internal_metadata';
-                    }
+                if (want.match(/_pw$/)) {
+                    which_mdata = 'internal_metadata';
+                }
 
-                    if (internalNamespace(vmobj, want) !== null) {
-                        which_mdata = 'internal_metadata';
-                    }
+                if (internalNamespace(vmobj, want) !== null) {
+                    which_mdata = 'internal_metadata';
+                }
 
-                    if (vmobj.hasOwnProperty(which_mdata)) {
-                        returnit(null, vmobj[which_mdata][want]);
-                        return;
-                    } else {
-                        returnit(new Error('Zone did not contain '
-                            + which_mdata));
-                        return;
-                    }
-                });
+                if (vmobj.hasOwnProperty(which_mdata)) {
+                    returnit(null, vmobj[which_mdata][want]);
+                    return;
+                } else {
+                    returnit(new Error('Zone did not contain '
+                        + which_mdata));
+                    return;
+                }
             }
         } else if (!req_is_v2 && cmd === 'NEGOTIATE') {
             if (want === 'V2') {
@@ -1505,37 +1006,28 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
 
             return;
         } else if (cmd === 'KEYS') {
-            addMetadata(function (err) {
-                var ckeys = [];
-                var ikeys = [];
-
-                if (err) {
-                    returnit(new Error('Unable to load metadata: '
-                        + err.message));
-                    return;
-                }
-
-                /*
-                 * Keys that match *_pw$ and internal_metadata_namespace
-                 * prefixed keys come from internal_metadata, everything else
-                 * comes from customer_metadata.
-                 */
-                ckeys = Object.keys(vmobj.customer_metadata)
-                    .filter(function (k) {
-
-                    return (!k.match(/_pw$/)
-                        && internalNamespace(vmobj, k) === null);
-                });
-                ikeys = Object.keys(vmobj.internal_metadata)
-                    .filter(function (k) {
-
-                    return (k.match(/_pw$/)
-                        || internalNamespace(vmobj, k) !== null);
-                });
+            var ckeys = [];
+            var ikeys = [];
+
+            /*
+             * Keys that match *_pw$ and internal_metadata_namespace
+             * prefixed keys come from internal_metadata, everything else
+             * comes from customer_metadata.
+             */
+            ckeys = Object.keys(vmobj.customer_metadata)
+                .filter(function (k) {
+
+                return (!k.match(/_pw$/)
+                    && internalNamespace(vmobj, k) === null);
+            });
+            ikeys = Object.keys(vmobj.internal_metadata)
+                .filter(function (k) {
 
-                returnit(null, ckeys.concat(ikeys).join('\n'));
-                return;
+                return (k.match(/_pw$/)
+                    || internalNamespace(vmobj, k) !== null);
             });
+
+            returnit(null, ckeys.concat(ikeys).join('\n'));
         } else {
             zlog.error('Unknown command ' + cmd);
             returnit(new Error('Unknown command ' + cmd));
@@ -1565,92 +1057,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
             _cb(err);
         }
 
-        function addTags(cb) {
-            var cbOpts = {timer: newTimer(), loadFile: 'tags'};
-            var filename;
-
-            filename = vmobj.zonepath + '/config/tags.json';
-            fs.readFile(filename, function (err, file_data) {
-
-                if (err && err.code === 'ENOENT') {
-                    vmobj.tags = {};
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                    return;
-                }
-
-                if (err) {
-                    zlog.error({err: err}, 'failed to load tags.json: '
-                        + err.message);
-                    _callCbAndLogTimer(cbOpts, err, cb);
-                    return;
-                }
-
-                try {
-                    vmobj.tags = JSON.parse(file_data.toString());
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                } catch (e) {
-                    zlog.error({err: e}, 'unable to tags.json for ' + zone
-                        + ': ' + e.message);
-                    _callCbAndLogTimer(cbOpts, e, cb);
-                }
-
-                return;
-            });
-        }
-
-        function addMetadata(cb) {
-            var cbOpts = {timer: newTimer(), loadFile: 'metadata'};
-            var filename;
-
-            // If we got here, our answer comes from metadata so read that file.
-
-            // NOTE: In the future, if the fs.readFile overhead here ends up
-            // being larger than a stat would be, we might want to cache these
-            // and reload only when mtime changes.
-            //
-            // Alternatively: when OS-2647 lands we might just use vminfod.
-
-            filename = vmobj.zonepath + '/config/metadata.json';
-
-            fs.readFile(filename, function (err, file_data) {
-                var json = {};
-                var mdata_types = [ 'customer_metadata', 'internal_metadata' ];
-
-                // start w/ both empty, if we fail partway through there will
-                // just be no metadata instead of wrong metadata.
-                vmobj.customer_metadata = {};
-                vmobj.internal_metadata = {};
-
-                if (err && err.code === 'ENOENT') {
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                    return;
-                }
-
-                if (err) {
-                    zlog.error({err: err}, 'failed to load mdata.json: '
-                        + err.message);
-                    _callCbAndLogTimer(cbOpts, err, cb);
-                    return;
-                }
-
-                try {
-                    json = JSON.parse(file_data.toString());
-                    mdata_types.forEach(function (mdata) {
-                        if (json.hasOwnProperty(mdata)) {
-                            vmobj[mdata] = json[mdata];
-                        }
-                    });
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                } catch (e) {
-                    zlog.error({err: e}, 'unable to load metadata.json for '
-                        + zone + ': ' + e.message);
-                    _callCbAndLogTimer(cbOpts, e, cb);
-                }
-
-                return;
-            });
-        }
-
         function setMetadata(_key, _value, cb) {
             var payload = {};
             var which = 'customer_metadata';
diff --git a/src/vm/lib/metadata/zwatch.js b/src/vm/lib/metadata/zwatch.js
deleted file mode 100644
index 0acfef20..00000000
--- a/src/vm/lib/metadata/zwatch.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2016 Joyent, Inc.
- */
-
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
-
-module.exports = ZWatch;
-
-function ZWatch(logger) {
-    var self = this;
-
-    // become an event emitter
-    EventEmitter.call(self);
-
-    // create a Sysevent event emitter
-    var opts = {
-        logger: logger,
-        class: 'status',
-        channel: 'com.sun:zones:status'
-    };
-    self.se = new SyseventStream(opts);
-    self.se.on('readable', function () {
-        var ev;
-        while ((ev = self.se.read()) !== null) {
-            var data = ev.data;
-            if (data.newstate === 'shutting_down'
-                && data.oldstate === 'running') {
-
-                data.cmd = 'stop';
-            } else if (data.newstate === 'running'
-                && data.oldstate === 'ready') {
-
-                data.cmd = 'start';
-            } else if (data.newstate === 'configured' && data.oldstate === '') {
-                data.cmd = 'create';
-            } else if (data.oldstate === 'configured' && data.newstate === '') {
-                data.cmd = 'delete';
-            } else {
-                data.cmd = 'unknown';
-            }
-
-            self.emit('zone_transition', data);
-        }
-    });
-}
-util.inherits(ZWatch, EventEmitter);
-
-ZWatch.prototype.stop = function stop() {
-    return this.se.stop();
-};
diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index 9f834232..64ea974a 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -94,6 +94,17 @@ tab-complete UUIDs rather than having to type them out for every command.
         See the 'SNAPSHOTS' section below for some more details on how to use
         these snapshots, and their restrictions.
 
+      events [-fjr] [uuid]
+
+        Output events seen for a given VM (all VMs on the system if the uuid
+        argument is omitted).  The command will run indefinitely outputting a
+        single line per event to stdout as they are seen.
+
+          -f, --full    Output the full event (full zone names, timestamp,
+                        etc.)  No data will be truncated.
+          -j, --json    Output in JSON.  If `-j` is supplied `-f` is ignored.
+          -r, --ready   Output an event when the event stream is ready.
+
       get <uuid>
 
         Output the JSON object describing a VM. The JSON object will be dumped
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 49210509..6d7e9d98 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -50,6 +50,7 @@
  * stop(uuid, options={[force=true]}, callback)
  * sysrq(uuid, req=[nmi|screenshot], options={}, callback)
  * update(uuid, properties, callback)
+ * events(opts, handler, callback)
  *
  * Exported variables:
  *
@@ -97,6 +98,7 @@ var tty = require('tty');
 var util = require('util');
 var utils = require('./utils');
 var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmload = require('vmload');
 var zonecfg = require('/usr/vm/node_modules/zonecfg');
 
@@ -117,25 +119,6 @@ exports.FLATTENABLE_ARRAY_HASH_KEYS = FLATTENABLE_ARRAY_HASH_KEYS;
 exports.FLATTENABLE_HASH_KEYS = FLATTENABLE_HASH_KEYS;
 exports.KVM_MEM_OVERHEAD = KVM_MEM_OVERHEAD;
 
-/*
- * Global handle for the zoneevent watcher
- *
- * Retaining a global (per-process in this case) zone watcher object ensures
- * that only one SyseventStream (and by extension, one instance of
- * sysevent(1M)) is running at a time.  If multiple zone watchers are needed,
- * they will use this global zone watcher object while the ref count is greater
- * than 0.  The stream will be torn down when the ref count hits 0,
- *
- * ref: the current reference count for zone watchers allocated
- * stream: the actual SyseventStream for watching sysevents
- *
- * See getZoneWatcher and freeZoneWatcher for more information
- */
-var zonewatcher = {
-    ref: 0,
-    stream: null
-};
-
 /*
  * zone states from libzonecfg/common/zonecfg_impl.h
  *
@@ -162,6 +145,7 @@ var PROVISION_TIMEOUT = 300;
 var SERVICE_RESTART_TIMEOUT = 60;
 var STOP_TIMEOUT = 60;
 var VM = this;
+var VMINFOD_TIMEOUT = 60 * 1000;
 
 
 VM.log = null;
@@ -187,6 +171,8 @@ var vrrpMAC = utils.vrrpMAC;
 // For keeping track of used trace names
 var trace_seen_names = {};
 
+function noop() {}
+
 // This function should be called by any exported function from this module.
 // It ensures that a logger is setup. If side_effects is true, we'll start
 // writing log messages to the file right away. If not, we'll only start
@@ -514,16 +500,17 @@ function getZpools(log, callback)
         if (error) {
             log.error('Unable to get list of zpools');
             callback(error, {'stdout': stdout, 'stderr': stderr});
-        } else {
-            // strip out any empty values (last one).
-            raw = stdout.split('\n');
-            for (idx in raw) {
-                if (raw[idx].length > 0) {
-                    zpools.push(raw[idx]);
-                }
+            return;
+        }
+
+        // strip out any empty values (last one).
+        raw = stdout.split('\n');
+        for (idx in raw) {
+            if (raw[idx].length > 0) {
+                zpools.push(raw[idx]);
             }
-            callback(null, zpools);
         }
+        callback(null, zpools);
     });
 }
 
@@ -839,28 +826,54 @@ function validateImage(image, log, callback)
 
 function createConfigDir(zonepath, log, cb) {
     var configDir = path.join(zonepath, 'config');
+    var files = [
+        'tags.json',
+        'metadata.json',
+        'routes.json'
+    ];
 
     /*
      * Zone images quite often contain the configuration of the zone
      * they were made from. We remove the old directory here so that
      * we don't accidentally end up using inherited files.
      */
-    traceExecFile('/bin/rm', [ '-rf', configDir ],
-        {}, log, 'rm-image-config', function (err) {
+    vasync.pipeline({funcs: [
+        function (_, cb2) {
+            log.debug('rm -rf %s', configDir);
+            traceExecFile('/bin/rm', ['-rf', configDir],
+                {}, log, 'rm-image-config', cb2);
+        }, function (_, cb2) {
+            /*jsl:ignore*/
+            var mode = 0755;
+            /*jsl:end*/
+
+            /*
+             * Now that any pre-existing directory is out of the way, create
+             * one for us to use:
+             */
+            log.debug('fs.mkdir(%s)', configDir);
+            fs.mkdir(configDir, mode, cb2);
+        }, function (_, cb2) {
+            /*
+             * Create skeleton files for the JSON config files.
+             */
+            vasync.forEachParallel({
+                inputs: files,
+                func: function (f, cb3) {
+                    f = path.join(configDir, f);
+                    log.debug('Writing empty metadata file %s', f);
+                    fs.writeFile(f, '{}\n', cb3);
+                }
+            }, cb2);
+        }
+    ]}, function (err) {
         if (err) {
+            log.error({err: err}, 'createConfigDir %s failed', zonepath);
             cb(err);
             return;
         }
 
-        /*jsl:ignore*/
-        var mode = 0755;
-        /*jsl:end*/
-
-        /*
-         * Now that any pre-existing directory is out of the way, create
-         * one for us to use:
-         */
-        fs.mkdir(configDir, mode, cb);
+        cb();
     });
 }
 
@@ -1265,9 +1278,10 @@ function setQuota(dataset, quota, log, callback)
         if (err) {
             log.error('setQuota() cmd failed: ' + fds.stderr);
             callback(new Error(rtrim(fds.stderr)));
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -1352,6 +1366,9 @@ exports.load = function (uuid, options, callback)
     if (options.hasOwnProperty('fields')) {
         load_opts.fields = options.fields;
     }
+    if (options.hasOwnProperty('loadManually')) {
+        load_opts.loadManually = options.loadManually;
+    }
 
     vmload.getVmobj(uuid, load_opts, function (err, vmobj) {
         if (err) {
@@ -1550,11 +1567,10 @@ exports.lookup = function (search, options, callback)
             transform(vmobj);
         }
         if (Object.keys(search).length === 0 || matcher(vmobj, search)) {
-            cb(true);
+            cb(null, true);
         } else {
-            cb(false);
+            cb(null, false);
         }
-        return;
     }
 
     lookup_opts = {log: log, fields: need_fields};
@@ -1639,9 +1655,9 @@ function checkDatasets(payload, log, callback)
                     'stderr': fds.stderr}, 'zfs list ' + dataset + ' '
                     + 'exited with' + ' code ' + err.code + ': ' + err.message);
                 cb(new Error('unable to find dataset: ' + dataset));
-            } else {
-                cb();
+                return;
             }
+            cb();
         });
     }
 
@@ -1651,10 +1667,9 @@ function checkDatasets(payload, log, callback)
             log.error(err, 'checkDatasets() failed to find required '
                 + 'volumes');
             callback(err);
-        } else {
-            // progress(100, 'we have all necessary datasets');
-            callback();
+            return;
         }
+        callback();
     });
 }
 
@@ -1715,7 +1730,7 @@ function lookupConflicts(macs, ips, ipNics, vrids, vnc_port, log, callback) {
         if (vm.state === 'failed' && vm.zone_state !== 'running') {
             // Ignore zones that are failed unless they're 'running' which they
             // shouldn't be because they get stopped on failure.
-            cb(false);
+            cb(null, false);
             return;
         }
 
@@ -1757,14 +1772,14 @@ function lookupConflicts(macs, ips, ipNics, vrids, vnc_port, log, callback) {
             conflict = true;
         }
 
-        cb(conflict);
+        cb(null, conflict);
     }, load_opts, function (err, results) {
         if (err) {
             callback(err);
-        } else {
-            log.debug('returning from conflict check');
-            callback(null, (results.length > 0) ? true : false);
+            return;
         }
+        log.debug('returning from conflict check');
+        callback(null, (results.length > 0) ? true : false);
     });
 }
 
@@ -1994,31 +2009,33 @@ function createVolume(volume, log, callback)
     async.series([
         function (cb) {
             // Ensure we've got a snapshot if we're going to make a clone
-            if (volume.hasOwnProperty('image_uuid')) {
-                snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
-                zfs(['get', '-Ho', 'value', 'name', snapshot], log,
-                    function (err, fds) {
+            if (!volume.hasOwnProperty('image_uuid')) {
+                cb();
+                return;
+            }
 
-                    if (err) {
-                        if (fds.stderr.match('dataset does not exist')) {
-                            // no @final, so we'll make a new snapshot @<uuid>
-                            snapshot = volume.zpool + '/' + volume.image_uuid
-                                + '@' + volume.uuid;
+            snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
+            zfs(['get', '-Ho', 'value', 'name', snapshot], log,
+                function (err, fds) {
 
-                            zfs(['snapshot', snapshot], log, function (e) {
-                                cb(e);
-                            });
-                        } else {
-                            cb(err);
-                        }
+                if (err) {
+                    if (fds.stderr.match('dataset does not exist')) {
+                        // no @final, so we'll make a new snapshot @<uuid>
+                        snapshot = volume.zpool + '/' + volume.image_uuid
+                            + '@' + volume.uuid;
+
+                        zfs(['snapshot', snapshot], log, function (e) {
+                            cb(e);
+                        });
                     } else {
-                        // @final is here!
-                        cb();
+                        cb(err);
                     }
-                });
-            } else {
+                    return;
+                }
+
+                // @final is here!
                 cb();
-            }
+            });
         }, function (cb) {
             var args;
             var target;
@@ -2045,10 +2062,11 @@ function createVolume(volume, log, callback)
                 zfs(args, log, function (e) {
                     if (e) {
                         cb(e);
-                    } else {
-                        volume.path = '/dev/zvol/rdsk/' + target;
-                        cb();
+                        return;
                     }
+
+                    volume.path = '/dev/zvol/rdsk/' + target;
+                    cb();
                 });
             } else {
                 // This volume is not from a template/dataset/image so we create
@@ -2067,10 +2085,11 @@ function createVolume(volume, log, callback)
                 zfs(args, log, function (err, fds) {
                     if (err) {
                         cb(err);
-                    } else {
-                        volume.path = '/dev/zvol/rdsk/' + target;
-                        cb();
+                        return;
                     }
+
+                    volume.path = '/dev/zvol/rdsk/' + target;
+                    cb();
                 });
             }
         }
@@ -2277,26 +2296,27 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             if (error) {
                 if (error.code === 'ENOENT') {
                     _createEmptyFile(f, cb);
-                    return;
                 } else {
                     log.error({err: error}, 'failed to lstat ' + f);
                     cb(error);
-                    return;
                 }
+                return;
             }
 
             if (stats.isFile()) {
                 // it's a file! great. We can mount over it.
                 cb();
                 return;
-            } else if (stats.isSymbolicLink()) {
+            }
+
+            if (stats.isSymbolicLink()) {
                 fs.unlinkSync(f);
                 _createEmptyFile(f, cb);
-            } else {
-                log.error({stats: stats}, f + ' is not a file');
-                cb(new Error(f + ' is not a file'));
                 return;
             }
+
+            log.error({stats: stats}, f + ' is not a file');
+            cb(new Error(f + ' is not a file'));
         });
     }
 
@@ -2338,7 +2358,7 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             });
         });
     }, function (err) {
-        var zcfg;
+        var cancel;
 
         if (err) {
             callback(err);
@@ -2351,26 +2371,53 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             return;
         }
 
-        zcfg = buildFilesystemZonecfg({}, fake_payload);
+        var vs = new vminfod.VminfodEventStream({
+            name: sprintf('VM.js createHostConfFileMounts (%s)', vmobj.uuid),
+            log: log
+        });
 
-        zonecfg(vmobj.uuid, [], {log: log, stdin: zcfg},
-            function (zcfg_err, fds) {
-                if (zcfg_err) {
-                    log.error({
-                        err: zcfg_err,
-                        zcfg: zcfg,
-                        stdout: fds.stdout,
-                        stderr: fds.stderr
-                    }, 'failed to modify zonecfg');
-                    callback(zcfg_err);
-                    return;
-                }
+        vs.once('ready', function () {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: vmobj.uuid,
+                        vm: {
+                            filesystems: fake_payload.add_filesystems
+                        }
+                    };
+                    var vs_opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        teardown: true,
+                        catchErrors: true
+                    };
 
-                log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                    'modified zonecfg');
-                callback();
-            }
-        );
+                    cancel = vs.watchForEvent(obj, vs_opts, cb2);
+                }, function (cb2) {
+                    var zcfg = buildFilesystemZonecfg({}, fake_payload);
+
+                    zonecfg(vmobj.uuid, [],
+                        {log: log, stdin: zcfg},
+                        function (zcfg_err, fds) {
+
+                        if (zcfg_err) {
+                            log.error({
+                                err: zcfg_err,
+                                zcfg: zcfg,
+                                stdout: fds.stdout,
+                                stderr: fds.stderr
+                            }, 'failed to modify zonecfg');
+                            cancel();
+                            cb2(zcfg_err);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'modified zonecfg');
+                        cb2();
+                    });
+                }]
+            }, callback);
+        });
     });
 }
 
@@ -2516,23 +2563,24 @@ function createFilesystems(payload, filesystems, log, callback)
         'creating filesystems');
 
     function _createParents(cb) {
-        if (create_volume_root) {
-            zfs([
-                'create',
-                payload.zfs_filesystem + '/volumes'
-            ], log, function (vols_err, vols_fds) {
-                if (vols_err
-                    && !vols_fds.stderr.match(/dataset already exists$/)) {
-
-                    cb(vols_err);
-                    return;
-                }
-
-                cb();
-            });
-        } else {
+        if (!create_volume_root) {
             cb();
+            return;
         }
+
+        zfs([
+            'create',
+            payload.zfs_filesystem + '/volumes'
+        ], log, function (vols_err, vols_fds) {
+            if (vols_err
+                && !vols_fds.stderr.match(/dataset already exists$/)) {
+
+                cb(vols_err);
+                return;
+            }
+
+            cb();
+        });
     }
 
     _createParents(function (error) {
@@ -2657,9 +2705,10 @@ function createVolumes(payload, log, callback)
             async.forEachSeries(createme, _loggedDeleteVolume, function () {
                 callback(err);
             });
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -2708,15 +2757,17 @@ function updateMetadata(vmobj, payload, log, callback)
     var imdata = {};
     var key;
     var mdata = {};
-    var mdata_filename;
     var needUpdate = false;
     var tags = {};
-    var tags_filename;
     var tracers_obj;
+    var uuid;
     var zonepath;
 
     assert(log, 'no logger passed to updateMetadata()');
 
+    uuid = vmobj.uuid || payload.uuid || vmobj.zonename || payload.zonename;
+    assert.uuid(uuid, 'uuid not found on "payload" or "vmobj"');
+
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('update-metadata', log, callback);
         callback = tracers_obj.callback;
@@ -2743,25 +2794,22 @@ function updateMetadata(vmobj, payload, log, callback)
         return;
     }
 
-    if (vmobj.hasOwnProperty('zonepath')) {
-        zonepath = vmobj.zonepath;
-    } else if (vmobj.hasOwnProperty('zpool')
-        && vmobj.hasOwnProperty('zonename')) {
-
-        zonepath = '/' + vmobj.zpool + '/' + vmobj.zonename;
-    } else {
-        callback(new Error('unable to find zonepath for '
-            + JSON.stringify(vmobj)));
+    try {
+        zonepath = calculateZonepath(vmobj);
+    } catch (e) {
+        log.error({err: e}, 'failed to calculate zonepath for %s', uuid);
+        callback(e);
         return;
     }
 
-    // paths are under zonepath but not zoneroot
-    mdata_filename = zonepath + '/config/metadata.json';
-    tags_filename = zonepath + '/config/tags.json';
-
     // customer_metadata
-    for (key in vmobj.customer_metadata) {
-        if (vmobj.customer_metadata.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('customer_metadata')
+        || payload.hasOwnProperty('set_customer_metadata')) {
+
+        for (key in vmobj.customer_metadata) {
+            if (!vmobj.customer_metadata.hasOwnProperty(key))
+                continue;
+
             cmdata[key] = vmobj.customer_metadata[key];
             if (payload.hasOwnProperty('remove_customer_metadata')
                 && payload.remove_customer_metadata.indexOf(key) !== -1) {
@@ -2770,17 +2818,25 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete cmdata[key];
             }
         }
-    }
 
-    for (key in payload.set_customer_metadata) {
-        if (payload.set_customer_metadata.hasOwnProperty(key)) {
+        for (key in payload.set_customer_metadata) {
+            if (!payload.set_customer_metadata.hasOwnProperty(key))
+                continue;
+
             cmdata[key] = payload.set_customer_metadata[key];
         }
+
+        mdata.customer_metadata = cmdata;
     }
 
     // internal_metadata
-    for (key in vmobj.internal_metadata) {
-        if (vmobj.internal_metadata.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('internal_metadata')
+        || payload.hasOwnProperty('set_internal_metadata')) {
+
+        for (key in vmobj.internal_metadata) {
+            if (!vmobj.internal_metadata.hasOwnProperty(key))
+                continue;
+
             imdata[key] = vmobj.internal_metadata[key];
             if (payload.hasOwnProperty('remove_internal_metadata')
                 && payload.remove_internal_metadata.indexOf(key) !== -1) {
@@ -2789,17 +2845,25 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete imdata[key];
             }
         }
-    }
 
-    for (key in payload.set_internal_metadata) {
-        if (payload.set_internal_metadata.hasOwnProperty(key)) {
+        for (key in payload.set_internal_metadata) {
+            if (!payload.set_internal_metadata.hasOwnProperty(key))
+                continue;
+
             imdata[key] = payload.set_internal_metadata[key];
         }
+
+        mdata.internal_metadata = imdata;
     }
 
     // same thing for tags
-    for (key in vmobj.tags) {
-        if (vmobj.tags.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('tags')
+        || payload.hasOwnProperty('set_tags')) {
+
+        for (key in vmobj.tags) {
+            if (!vmobj.tags.hasOwnProperty(key))
+                continue;
+
             tags[key] = vmobj.tags[key];
             if (payload.hasOwnProperty('remove_tags')
                 && payload.remove_tags.indexOf(key) !== -1) {
@@ -2808,26 +2872,19 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete tags[key];
             }
         }
-    }
 
-    for (key in payload.set_tags) {
-        if (payload.set_tags.hasOwnProperty(key)) {
+        for (key in payload.set_tags) {
+            if (!payload.set_tags.hasOwnProperty(key))
+                continue;
+
             tags[key] = payload.set_tags[key];
         }
-    }
 
-    mdata = {'customer_metadata': cmdata, 'internal_metadata': imdata};
+        mdata.tags = tags;
+    }
 
-    async.series([
-        function (next) {
-            writeAndRename(log, 'metadata', mdata_filename,
-                JSON.stringify(mdata, null, 2), next);
-        },
-        function (next) {
-            writeAndRename(log, 'tags', tags_filename,
-                JSON.stringify(tags, null, 2), next);
-        }
-    ], callback);
+    writeAllMetadata(uuid, zonepath, mdata,
+        {log: log, skipLockfile: true}, callback);
 }
 
 function saveMetadata(payload, log, callback)
@@ -2885,15 +2942,18 @@ function saveMetadata(payload, log, callback)
 // writes a zone's metadata JSON to /zones/<uuid>/config/routes.json
 function updateRoutes(vmobj, payload, log, callback)
 {
-    var filename;
     var key;
     var needUpdate = false;
     var routes = {};
     var tracers_obj;
+    var uuid;
     var zonepath;
 
     assert(log, 'no logger passed to updateRoutes()');
 
+    uuid = vmobj.uuid || payload.uuid || vmobj.zonename || payload.zonename;
+    assert(uuid, 'uuid not found on "payload" or "vmobj"');
+
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('update-routes', log, callback);
         callback = tracers_obj.callback;
@@ -2916,48 +2976,36 @@ function updateRoutes(vmobj, payload, log, callback)
         return;
     }
 
-    if (vmobj.hasOwnProperty('zonepath')) {
-        zonepath = vmobj.zonepath;
-    } else if (vmobj.hasOwnProperty('zpool')
-        && vmobj.hasOwnProperty('zonename')) {
-
-        zonepath = '/' + vmobj.zpool + '/' + vmobj.zonename;
-    } else {
-        callback(new Error('unable to find zonepath for '
-            + JSON.stringify(vmobj)));
+    try {
+        zonepath = calculateZonepath(vmobj);
+    } catch (e) {
+        log.error({err: e}, 'failed to calculate zonepath for %s', uuid);
+        callback(e);
         return;
     }
 
-    // paths are under zonepath but not zoneroot
-    filename = zonepath + '/config/routes.json';
-
     for (key in vmobj.routes) {
-        if (vmobj.routes.hasOwnProperty(key)) {
-            routes[key] = vmobj.routes[key];
-            if (payload.hasOwnProperty('remove_routes')
-                && payload.remove_routes.indexOf(key) !== -1) {
+        if (!vmobj.routes.hasOwnProperty(key))
+            continue;
 
-                // in the remove_* list, don't load it.
-                delete routes[key];
-            }
+        routes[key] = vmobj.routes[key];
+        if (payload.hasOwnProperty('remove_routes')
+            && payload.remove_routes.indexOf(key) !== -1) {
+
+            // in the remove_* list, don't load it.
+            delete routes[key];
         }
     }
 
     for (key in payload.set_routes) {
-        if (payload.set_routes.hasOwnProperty(key)) {
-            routes[key] = payload.set_routes[key];
-        }
+        if (!payload.set_routes.hasOwnProperty(key))
+            continue;
+
+        routes[key] = payload.set_routes[key];
     }
 
-    fs.writeFile(filename, JSON.stringify(routes, null, 2),
-        function (err) {
-            if (err) {
-                callback(err);
-            } else {
-                log.debug('wrote routes to ' + filename);
-                callback();
-            }
-        });
+    writeAllMetadata(uuid, zonepath, {routes: routes},
+        {skipLockfile: true, log: log}, callback);
 }
 
 function saveRoutes(payload, log, callback)
@@ -2994,65 +3042,282 @@ function saveRoutes(payload, log, callback)
     updateRoutes(protovm, payload, log, callback);
 }
 
-function createVM(payload, log, callback)
-{
+function writeAllMetadata(uuid, zonepath, mdata, options, callback) {
+    var lockpath = '/var/run/vm.' + uuid + '.config.lockfile';
+    var log;
+    var needsUpdate = {};
+    var mdata_filename;
+    var routes_filename;
+    var toUpdate;
+    var tags_filename;
     var tracers_obj;
+    var unlock;
+    var vs;
 
-    assert(log, 'no logger passed to createVM()');
+    assert.uuid(uuid, 'uuid');
+    assert.string(zonepath, 'zonepath');
+    assert.object(mdata, 'mdata');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+
+    log = options.log;
+    assert(log, 'log');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
-        tracers_obj = traceUntilCallback('createVM', log, callback);
+        tracers_obj = traceUntilCallback('writeAllMetadata', log,
+            callback);
         callback = tracers_obj.callback;
         log = tracers_obj.log;
     }
 
-    async.series([
-        function (cb) {
-            if (!payload.create_only) {
-                // progress(2, 'checking required datasets');
-                checkDatasets(payload, log, cb);
-            } else {
-                cb();
-            }
-        }, function (cb) {
-            if (!payload.create_only) {
-                // progress(29, 'creating volumes');
-                createVolumes(payload, log, cb);
-            } else {
-                cb();
-            }
-        }, function (cb) {
-            // progress(51, 'creating zone container');
-            createZone(payload, log, cb);
-        }
-    ], function (err, results) {
-        if (err) {
-            callback(err);
-        } else {
-            callback(null, results);
-        }
-    });
-}
+    log.debug({mdata: mdata, uuid: uuid}, 'writeAllMetadata called');
 
-function fixZoneinitMetadataSock(zoneroot, log, callback)
-{
-    var mdata_00;
-    var tracers_obj;
+    mdata_filename = zonepath + '/config/metadata.json';
+    routes_filename = zonepath + '/config/routes.json';
+    tags_filename = zonepath + '/config/tags.json';
 
-    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
-        tracers_obj = traceUntilCallback('fix-zoneinit-mdata-sock', log,
-            callback);
-        callback = tracers_obj.callback;
-        log = tracers_obj.log;
+    // Short-circuit here if nothing needs to be changed
+    toUpdate = Object.keys(mdata);
+    if (toUpdate.length === 0) {
+        log.debug('No metadata modifications required');
+        callback();
+        return;
     }
 
-    // ensure we're safe to touch these files, zone should not be running here
-    // so this just guards against malicious datasets.
-    ['/var/zoneinit/includes', '/root/zoneinit.d'].forEach(function (dir) {
-        assertSafeZonePath(zoneroot, dir, {type: 'dir', enoent_ok: true});
-    });
-
-    function replaceData(filename, cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // Acquire lockfile
+            if (options.skipLockfile) {
+                cb();
+                return;
+            }
+
+            log.debug('acquiring lock on %s', lockpath);
+            lock(lockpath, function (err, _unlock) {
+                if (err) {
+                    log.error('failed to acquire lock on %s', lockpath);
+                    cb(err);
+                    return;
+                }
+
+                log.debug('acquired lock on %s', lockpath);
+                unlock = _unlock;
+                cb();
+            });
+        }, function (_, cb) {
+            // Start Vminfod Event Stream
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js writeAllMetadata (%s: %s)', uuid,
+                    toUpdate.join(',')),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                var latest_vmobj = ready_ev.vms[uuid];
+                assert.object(latest_vmobj,
+                    'vminfod latest_vmobj writeAllMetadata');
+
+                // Ignore metadata that has not changed
+                Object.keys(mdata).forEach(function (_key) {
+                    if (!latest_vmobj.hasOwnProperty(_key)) {
+                        needsUpdate[_key] = true;
+                    } else if (!deepEqual(mdata[_key], latest_vmobj[_key])) {
+                        needsUpdate[_key] = true;
+                    }
+                });
+
+                if (needsUpdate.hasOwnProperty('customer_metadata')
+                    && !needsUpdate.hasOwnProperty('internal_metadata')) {
+                    needsUpdate.internal_metadata = true;
+                    mdata.internal_metadata = latest_vmobj.internal_metadata
+                        || {};
+                } else if (needsUpdate.hasOwnProperty('internal_metadata')
+                    && !needsUpdate.hasOwnProperty('customer_metadata')) {
+                    needsUpdate.customer_metadata = true;
+                    mdata.customer_metadata = latest_vmobj.customer_metadata
+                        || {};
+                }
+
+                toUpdate = Object.keys(needsUpdate);
+
+                // Sanity check that all keys that need to be changed are found
+                // with new values in `mdata`
+                toUpdate.forEach(function (key) {
+                    assert(mdata.hasOwnProperty(key), key + ': not found');
+                });
+
+                log.debug('metadata modified: %s',
+                    toUpdate.join(',') || '<none>');
+
+                cb();
+            });
+        }, function (_, cb) {
+            // Modify any metadata files that need to be modified while
+            // blocking on the changes to be reflected in Vminfod.
+            var cancel;
+
+            if (toUpdate.length === 0) {
+                // Nothing being modified, don't bother waiting on
+                // vminfod
+                log.debug('No metadata modifed');
+                vs.stop();
+                cb();
+                return;
+            }
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid,
+                        vm: mdata
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    vasync.pipeline({funcs: [
+                        function (__, cb3) {
+                            // write metadata
+                            var d = {};
+                            var len;
+
+                            if (needsUpdate.
+                                hasOwnProperty('internal_metadata')) {
+
+                                d.internal_metadata = mdata.internal_metadata;
+                            }
+                            if (needsUpdate.
+                                hasOwnProperty('customer_metadata')) {
+
+                                d.customer_metadata = mdata.customer_metadata;
+                            }
+
+                            len = Object.keys(d).length;
+
+                            if (len === 0) {
+                                log.debug('writeAllMetadata: skip metadata');
+                                cb3();
+                                return;
+                            }
+
+                            assert.equal(len, 2, '2 fields must be modified');
+
+                            writeAndRename(log, 'metadata', mdata_filename,
+                                JSON.stringify(d, null, 2), cb3);
+                        }, function (__, cb3) {
+                            // write tags
+                            if (!needsUpdate.hasOwnProperty('tags')) {
+                                log.debug('writeAllMetadata: skip tags');
+                                cb3();
+                                return;
+                            }
+
+                            writeAndRename(log, 'tags', tags_filename,
+                                JSON.stringify(mdata.tags, null, 2), cb3);
+                        }, function (__, cb3) {
+                            // write routes
+                            if (!needsUpdate.hasOwnProperty('routes')) {
+                                log.debug('writeAllMetadata: skip routes');
+                                cb3();
+                                return;
+                            }
+
+                            writeAndRename(log, 'routes', routes_filename,
+                                JSON.stringify(mdata.routes, null, 2), cb3);
+                        }
+                    ]}, function (err) {
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, cb);
+        }
+    ]}, function (err, results) {
+        if (err) {
+            log.error({err: err}, 'error writing metadata');
+        }
+
+        if (unlock) {
+            unlock(function (unlock_err) {
+                if (unlock_err) {
+                    log.error({err: unlock_err},
+                        'failed to unlock %s', lockpath);
+                }
+                callback(err || unlock_err);
+            });
+            return;
+        }
+
+        callback(err);
+    });
+}
+
+function createVM(payload, log, callback)
+{
+    var tracers_obj;
+
+    assert(log, 'no logger passed to createVM()');
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('createVM', log, callback);
+        callback = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    async.series([
+        function (cb) {
+            if (payload.create_only) {
+                cb();
+                return;
+            }
+
+            checkDatasets(payload, log, cb);
+        }, function (cb) {
+            if (payload.create_only) {
+                cb();
+                return;
+            }
+            createVolumes(payload, log, cb);
+        }, function (cb) {
+            createZone(payload, log, cb);
+        }
+    ], function (err, results) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, results);
+    });
+}
+
+function fixZoneinitMetadataSock(zoneroot, log, callback)
+{
+    var mdata_00;
+    var tracers_obj;
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('fix-zoneinit-mdata-sock', log,
+            callback);
+        callback = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    // ensure we're safe to touch these files, zone should not be running here
+    // so this just guards against malicious datasets.
+    ['/var/zoneinit/includes', '/root/zoneinit.d'].forEach(function (dir) {
+        assertSafeZonePath(zoneroot, dir, {type: 'dir', enoent_ok: true});
+    });
+
+    function replaceData(filename, cb) {
         fs.readFile(filename, 'utf8', function (error, data) {
             if (error) {
                 log.error(error, 'failed to load 00-mdata.sh for replacement');
@@ -3401,6 +3666,7 @@ function zoneadm(args, log, callback)
     var evtname = 'zoneadm';
 
     assert(log, 'no logger passed to zoneadm()');
+    assert.arrayOfString(args, 'zoneadm args');
 
     if (args[2]) {
         evtname = evtname + '-' + args[2];
@@ -3421,6 +3687,7 @@ function zfs(args, log, callback)
     var evtname = 'zfs.' + args[0];
 
     assert(log, 'no logger passed to zfs()');
+    assert.arrayOfString(args, 'zfs args');
 
     traceExecFile(cmd, args, log, evtname, function (error, stdout, stderr) {
         if (error) {
@@ -3459,21 +3726,22 @@ exports.getSysinfo = function (args, options, callback)
         var sysinfo;
 
         if (error) {
-            callback(error, {'stdout': stdout, 'stderr': stderr});
-        } else {
-            try {
-                sysinfo = JSON.parse(stdout.toString());
-            } catch (e) {
-                sysinfo = {};
-            }
-            callback(null, sysinfo);
+            callback(error, {stdout: stdout, stderr: stderr});
+            return;
+        }
+
+        try {
+            sysinfo = JSON.parse(stdout.toString());
+        } catch (e) {
+            sysinfo = {};
         }
+        callback(null, sysinfo);
     });
 };
 
 /*
  * This watches zone transitions and calls callback when specified
- * state is reached.  Optionally you can set a timeout which will
+ * state is reached.  Optionally you can set a timeout (in seconds) which will
  * call your callback when the timeout occurs whether the transition
  * has happened or not.
  *
@@ -3486,21 +3754,18 @@ exports.getSysinfo = function (args, options, callback)
 exports.waitForZoneState = function (payload, state, options, callback)
 {
     assert.object(payload, 'payload');
-    assert.string(payload.uuid, 'payload.uuid');
+    assert.uuid(payload.uuid, 'payload.uuid');
     assert.string(payload.zonename, 'payload.zonename');
     assert.string(state, 'state');
 
     var log;
-    var sysevent_state;
-    var timeout;
     var timeout_secs = PROVISION_TIMEOUT;
     var tracers_obj;
-    var transitions_opts;
-    var watcher;
+    var vmobj;
+    var vs;
 
-    // options is optional
-    if (arguments.length === 3) {
-        callback = arguments[2];
+    if (typeof (options) === 'function') {
+        callback = options;
         options = {};
     }
     assert.object(options, 'options');
@@ -3523,143 +3788,64 @@ exports.waitForZoneState = function (payload, state, options, callback)
         timeout_secs = options.timeout;
     }
 
-    sysevent_state = state;
-    if (state === 'installed') {
-        // Apparently the zone status 'installed' equals sysevent status
-        // 'uninitialized'
-        sysevent_state = 'uninitialized';
-    }
-
-    function done(err) {
-        if (watcher) {
-            watcher.cleanup();
-        }
-        if (timeout) {
-            clearTimeout(timeout);
-            timeout = null;
-        }
-        callback(err);
-    }
-
-    function waitForZoneStateHandler(obj) {
-        log.trace('handler got: ' + JSON.stringify(obj));
-        if (obj.zonename !== payload.zonename) {
-            return;
-        }
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js waitForZoneState (%s)', payload.uuid),
+                parseReady: true,
+                log: log
+            });
 
-        if (obj.newstate === sysevent_state) {
-            log.debug('event seen: zone_state "%s" -> "%s"',
-                obj.oldstate, obj.newstate);
+            vs.once('ready', function (ready_ev) {
+                vmobj = ready_ev.vms[payload.zonename];
+                assert.object(vmobj, sprintf('vm %s not found in vminfod',
+                    payload.zonename));
+                cb();
+            });
+        }, function (_, cb) {
+            // check the vmobj found from vminfod "ack" packet
+            if (vmobj.hasOwnProperty('zone_state')
+                && vmobj.zone_state === state) {
+                log.info('VM is already in state %s', state);
 
-            if (options.skipConfirmation) {
-                done();
+                vs.stop();
+                vs = null;
+            }
+            cb();
+        }, function (_, cb) {
+            if (!vs) {
+                // alreday in the correct state; we're done
+                cb();
                 return;
             }
 
-            // Load again to confirm
-            VM.lookup({'zonename': obj.zonename},
-                {fields: ['zone_state'], log: log},
-                function (error, res) {
-                    var handler_retry;
-
-                    if (error) {
-                        done(error);
-                        return;
-                    }
-
-                    if (res.length !== 1) {
-                        done(new Error('lookup could not find VM '
-                            + obj.zonename));
-                        return;
-                    }
-
-                    if (res[0].hasOwnProperty('zone_state')
-                        && res[0].zone_state === state) {
-
-                        // found the state we're looking for, success!
-                        log.debug('saw zone go to ' + obj.newstate + ' ('
-                            + state + ') calling callback()');
-                        done();
-                    } else if (timeout) {
-                        // we saw a state change to a state we don't care about
-                        // so if we've not timed out try reloading again in a
-                        // second.
-                        if (!handler_retry) {
-                            handler_retry = setTimeout(function () {
-                                if (timeout) {
-                                    // try again if wait timeout is still set
-                                    waitForZoneStateHandler(obj);
-                                }
-                                handler_retry = null;
-                            }, 1000);
-                            log.debug('zone state after lookup: '
-                                + res[0].zone_state + ', still waiting');
-                        } else {
-                            log.debug('zone in wrong state but we already'
-                                + ' have a handler running');
-                        }
-                    } else {
-                        // no timeout set and we're not at the correct state
-                        log.error('failed to reach state: ' + state);
-                        done(new Error('failed to reach state: ' + state));
-                    }
+            // not in the right state; block on vminfod
+            var obj = {
+                uuid: payload.uuid,
+                vm: {
+                    zone_state: state
                 }
-            );
-        }
-    }
-
-    transitions_opts = {
-        log: log,
-        stream: options.stream
-    };
-    watcher = watchZoneTransitions(transitions_opts, waitForZoneStateHandler,
-        function (err) {
-
-        if (err) {
-            // there was an error creating the zone watcher, we can't continue
-            done(err);
-        }
-    });
-
-    timeout = setTimeout(function () {
-        var err;
-
-        err = new Error('timed out waiting for zone to transition to ' + state);
-        err.code = 'ETIMEOUT';
-
-        done(err);
-    }, timeout_secs * 1000);
-
-    // after we've started the watcher (if we checked before there'd be a race)
-    // we check whether we're already in the target state, if we are close it
-    // down and return.
-    VM.load(payload.uuid, {fields: ['zone_state'], log: log},
-        function (err, obj) {
-
-        if (err) {
-            done(err);
-        } else if (obj.hasOwnProperty('zone_state')
-            && obj.zone_state === state) {
+            };
+            var opts = {
+                timeout: timeout_secs * 1000,
+                catchErrors: true,
+                teardown: true
+            };
 
-            log.info('VM is in state ' + state);
-            done(); // at correct state!
+            vs.watchForEvent(obj, opts, cb);
         }
+    ]}, function (err) {
+        callback(err);
     });
-
-    return done;
 };
 
 /*
- * watchZoneTransitions will create a sysevent zone watcher (if needed) and
- * register handler() to be called with an object describing the transition for
- * any transitions seen.
+ * watchZoneTransitions will create a vminfod zone watcher and register
+ * handler() to be called with an object describing the transition for
+ * any transition seen.
  *
  * The callback function given as the final argument will be called when the
- * zone event watcher is ready to start receiving events.
- *
- * opts.stream is an optional zonewatcher stream that may have been allocated
- * already with a call to getZoneWatcher; if this is unset, one will be
- * allocated for you.
+ * vminfod zone event watcher is ready to start receiving events.
  *
  * This function returns an object that includes a 'cleanup' property. The
  * value of this property is a function that must be called to free the listener
@@ -3668,119 +3854,55 @@ exports.waitForZoneState = function (payload, state, options, callback)
  * argument)
  */
 function watchZoneTransitions(opts, handler, cb) {
-    var stream;
-
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
-    assert.optionalObject(opts.zonewatcher, 'opts.zonewatcher');
     assert.func(handler, 'handler');
     assert.func(cb, 'cb');
 
     var log = opts.log;
 
-    if (opts.stream) {
-        stream = opts.stream;
-        ready();
-    } else {
-        getZoneWatcher({log: log}, function (err, _stream) {
-            if (err) {
-                log.error({err: err}, 'getZoneWatcher failed');
-                cb(err);
-                return;
-            }
-
-            stream = _stream;
-            ready();
-        });
-    }
+    var vs = new vminfod.VminfodEventStream({
+        name: 'VM.js watchZoneTransitions',
+        log: log
+    });
 
-    function ready() {
-        stream.on('data', ondata);
+    vs.once('ready', function () {
         cb();
-    }
-
-    function ondata(ev) {
-        var obj = ev.data;
-        handler(obj);
-    }
+    });
 
-    // return a closure that includes the handler that was passed in
-    return ({
-        cleanup: function _handlerCleanup() {
-            if (stream) {
-                stream.removeListener('data', ondata);
-            }
-            freeZoneWatcher({log: log});
+    vs.on('readable', function () {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            processVminfodEvent(ev);
         }
     });
-}
 
-/*
- * This function will return a SyseventStream set to watch for zone state
- * related events.
- *
- * If a stream already exists for this process the global ref count will be
- * bumped and the existing stream will be returned.  Otherwise, a new stream
- * will be created.
- *
- * cb() will be called with the stream created when it is ready
- */
-function getZoneWatcher(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.func(cb, 'cb');
+    function processVminfodEvent(ev) {
+        if (ev.type !== 'modify')
+            return;
 
-    var log = opts.log;
+        var obj = {
+            zonename: ev.zonename,
+            uuid: ev.uuid
+        };
 
-    if (zonewatcher.ref++ > 0) {
-        assert(zonewatcher.stream, 'ref > 0 but no zone watcher');
-        log.debug({ref: zonewatcher.ref},
-            'getZoneWatcher using existing zone watcher');
-        cb(null, zonewatcher.stream);
-        return;
+        (ev.changes || []).forEach(function (change) {
+            if (change.path.length !== 1 || change.path[0] !== 'zone_state')
+                return;
+
+            obj.newstate = change.to;
+            obj.oldstate = change.from;
+            handler(obj);
+        });
     }
 
-    var ses_opts = {
-        logger: opts.log,
-        class: 'status',
-        channel: 'com.sun:zones:status'
-    };
-    zonewatcher.stream = new SyseventStream(ses_opts);
-    zonewatcher.stream.on('ready', function () {
-        log.debug('getZoneWatcher new zone watcher ready');
-        cb(null, zonewatcher.stream);
+    return ({
+        cleanup: function _handlerCleanup() {
+            vs.stop();
+        }
     });
 }
 
-/*
- * This function will free a single zone watcher, decrement the refcount, and
- * tear down the global zone event sysevent stream if the ref count is 0.
- *
- * Note that you should remove any 'data' event listener you have added to the
- * stream while using it, as this logic only handles decrementing the ref
- * count.
- */
-function freeZoneWatcher(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-
-    var log = opts.log;
-
-    if (zonewatcher.ref === 0) {
-        log.debug('freeZoneWatcher no zone watchers allocated');
-        assert(!zonewatcher.stream, 'stream exists while ref count is 0');
-        return;
-    }
-
-    zonewatcher.ref--;
-
-    if (zonewatcher.ref === 0) {
-        log.debug('freeZoneWatcher ref count is zero, stopping stream');
-        zonewatcher.stream.stop();
-        delete zonewatcher.stream;
-    }
-}
-
 function fixPayloadMemory(payload, vmobj, log)
 {
     var brand;
@@ -3992,36 +4114,6 @@ function createZoneUUID(payload, log, callback)
         log = tracers_obj.log;
     }
 
-    /*
-     * Checks if the UUID already exists on a VM, if so: callback() is called
-     * with an error object as the first argument. If the UUID is unused,
-     * callback(null, <uuid>) is called.
-     *
-     */
-    function _assertUUIDUnique(uuid) {
-        var lookup_opts = {log: log, fields: ['uuid']};
-
-        vmload.getVmobjs(function (vmobj, cb) {
-            if (vmobj.uuid === uuid) {
-                cb(true);
-            } else {
-                cb(false);
-            }
-        }, lookup_opts, function gotVMs(err, vmobjs) {
-            if (err) {
-                callback(err);
-                return;
-            }
-
-            if (vmobjs.length > 0) {
-                callback(new Error('VM with UUID ' + uuid + ' already exists'));
-                return;
-            }
-
-            // if we got here, no other VM has this UUID so we'll use it.
-            callback(null, uuid);
-        });
-    }
 
     if (!payload.hasOwnProperty('uuid')) {
         payload.uuid = libuuid.create();
@@ -4029,7 +4121,20 @@ function createZoneUUID(payload, log, callback)
     }
 
     // Ensure that the uuid is not already used.
-    _assertUUIDUnique(payload.uuid);
+    vmload.getVmobj(payload.uuid, {log: log}, function (err, vmobj) {
+        if (!err) {
+            callback(new Error('VM with UUID ' + payload.uuid
+                + ' already exists'));
+            return;
+        }
+
+        if (err && err.code !== 'ENOENT') {
+            callback(err);
+            return;
+        }
+
+        callback(null, payload.uuid);
+    });
 }
 
 function applyZoneDefaults(payload, log)
@@ -4252,6 +4357,7 @@ function checkPayloadProperties(payload, vmobj, log, callback)
         brand = payload.brand;
     } else {
         callback(new Error('unable to determine brand for VM'));
+        return;
     }
 
     /* check types of fields that should be arrays */
@@ -5058,48 +5164,49 @@ function createDelegatedDataset(payload, log, callback)
         log = tracers_obj.log;
     }
 
-    if (payload.delegate_dataset) {
-        log.info('creating delegated dataset.');
-        if (!payload.hasOwnProperty('zfs_filesystem')) {
-            callback(new Error('payload missing zfs_filesystem'));
+    if (!payload.delegate_dataset) {
+        callback();
+        return;
+    }
+
+    log.info('creating delegated dataset.');
+    if (!payload.hasOwnProperty('zfs_filesystem')) {
+        callback(new Error('payload missing zfs_filesystem'));
+        return;
+    }
+    ds = path.join(payload.zfs_filesystem, '/data');
+
+    args = ['create'];
+    if (payload.hasOwnProperty('zfs_data_compression')) {
+        args.push('-o', 'compression=' + payload.zfs_data_compression);
+    }
+    if (payload.hasOwnProperty('zfs_data_recsize')) {
+        args.push('-o', 'recsize=' + payload.zfs_data_recsize);
+    }
+    args.push(ds);
+
+    zfs(args, log, function (err) {
+        if (err) {
+            callback(err);
             return;
         }
-        ds = path.join(payload.zfs_filesystem, '/data');
 
-        args = ['create'];
-        if (payload.hasOwnProperty('zfs_data_compression')) {
-            args.push('-o', 'compression=' + payload.zfs_data_compression);
-        }
-        if (payload.hasOwnProperty('zfs_data_recsize')) {
-            args.push('-o', 'recsize=' + payload.zfs_data_recsize);
-        }
-        args.push(ds);
+        zcfg = zcfg + 'add dataset; set name=' + ds + '; end\n';
+        zonecfg(payload.uuid, [zcfg], {log: log},
+            function (e, fds) {
 
-        zfs(args, log, function (err) {
-            if (err) {
-                callback(err);
-                return;
+            if (e) {
+                log.error({'err': e, stdout: fds.stdout,
+                    stderr: fds.stderr}, 'unable to add delegated dataset '
+                    + ds + ' to ' + payload.uuid);
+                callback(e);
+            } else {
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'added delegated dataset ' + ds);
+                callback();
             }
-
-            zcfg = zcfg + 'add dataset; set name=' + ds + '; end\n';
-            zonecfg(payload.uuid, [zcfg], {log: log},
-                function (e, fds) {
-
-                if (e) {
-                    log.error({'err': e, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'unable to add delegated dataset '
-                        + ds + ' to ' + payload.uuid);
-                    callback(e);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'added delegated dataset ' + ds);
-                    callback();
-                }
-            });
         });
-    } else {
-        callback();
-    }
+    });
 }
 
 function buildAddRemoveList(vmobj, payload, type, key, updatable)
@@ -6761,6 +6868,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
 {
     var dirname = path.join(vmobj.zonepath, 'root', '/var/svc');
     var filename = path.join(dirname, 'provisioning');
+    var is_done = false;
     var ival_h;
     var log;
     var timeout;
@@ -6787,7 +6895,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
         log = tracers_obj.log;
     }
 
-    function done() {
+    function done(e) {
         if (timeout) {
             log.debug('clearing provision timeout for ' + vmobj.uuid);
             clearTimeout(timeout);
@@ -6804,6 +6912,11 @@ exports.waitForProvisioning = function (vmobj, options, cb)
             clearInterval(ival_h);
             ival_h = null;
         }
+
+        if (!is_done) {
+            is_done = true;
+            cb(e);
+        }
     }
 
     if ((vmobj.state === 'provisioning')
@@ -6820,7 +6933,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
         // don't know what to do here we're not provisioning.
         log.warn('waitForProvisioning called when ' + vmobj.uuid
             + ' was not provisioning');
-        cb();
+        done();
         return (null);
     }
 
@@ -6840,8 +6953,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                 log.warn(err, 'markVMFailure(): ' + err.message);
             }
             log.error(errstr);
-            done();
-            cb(new Error(errstr));
+            done(new Error(errstr));
         });
     }, (timeout_remaining * 1000));
 
@@ -6852,8 +6964,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
             if (err) {
                 log.error(err, 'error in markProvisionedWhenHWSetup()');
             }
-            done();
-            cb(err);
+            done(err);
         });
         return (done);
     }
@@ -6873,8 +6984,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                         if (err) {
                             log.warn(err, 'markVMFailure(): ' + err.message);
                         }
-                        done();
-                        cb(new Error('/var/svc/provisioning exists after '
+                        done(new Error('/var/svc/provisioning exists after '
                             + 'rename!'));
                     });
                     return;
@@ -6885,7 +6995,6 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                 // matter for the state, it's provisioned now. Caller should
                 // now clear the transition.
                 done();
-                cb();
                 return;
             });
         }
@@ -6905,7 +7014,6 @@ exports.waitForProvisioning = function (vmobj, options, cb)
              * instead of throwing, we consider this success.
              */
             done();
-            cb();
             // return _noop since we called done() already.
             return (_noop);
         } else {
@@ -6956,7 +7064,7 @@ function makeIndestructible(dataset, log, callback)
 
         args = ['hold', 'do_not_destroy', snapshot];
         zfs(args, log, function _makeIndestructibleHold(hold_err, hold_out) {
-            if (hold_err && !hold_out.match(hold_exists_pattern)) {
+            if (hold_err && !hold_out.stderr.match(hold_exists_pattern)) {
                 callback(hold_err);
                 return;
             }
@@ -7075,6 +7183,7 @@ function installZone(payload, log, callback)
     var reprovisioning = false;
     var tracers_obj;
     var vmobj;
+    var vs;
     var zoneinit = {};
 
     assert(log, 'no logger passed to installZone()');
@@ -7115,8 +7224,11 @@ function installZone(payload, log, callback)
     async.series([
         function (cb) {
 
-            VM.load(payload.uuid, {fields: load_fields, log: log},
-                function (err, obj) {
+            var opts = {
+                fields: load_fields,
+                log: log
+            };
+            VM.load(payload.uuid, opts, function (err, obj) {
 
                 if (err) {
                     cb(err);
@@ -7173,66 +7285,137 @@ function installZone(payload, log, callback)
                 args.push('-t', payload.image_uuid, '-x', 'nodataset');
             }
 
-            zoneadm(args, log, function (err, fds) {
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'zoneadm failed to install: '
-                        + err.message);
-                    cb(err);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'zoneadm installed zone');
-                    cb();
-                }
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js installZone zoneadm (%s)', payload.uuid),
+                log: log
             });
-        }, function (cb) {
-            // Apply compression if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_root_compression')) {
-                args = ['set', 'compression='
-                    + payload.zfs_root_compression, payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
-                cb();
-            }
-        }, function (cb) {
-            // Apply recsize if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_root_recsize')) {
-                args = ['set', 'recsize=' + payload.zfs_root_recsize,
-                    payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
+
+            vs.once('ready', function () {
+                var cancel;
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            uuid: payload.uuid,
+                            vm: {
+                                zone_state: 'installed'
+                            }
+                        };
+                        var opts = {
+                            timeout: VMINFOD_TIMEOUT,
+                            catchErrors: true,
+                            teardown: true
+                        };
+                        cancel = vs.watchForEvent(obj, opts, cb2);
+                    },
+                    function (cb2) {
+                        zoneadm(args, log, function (err, fds) {
+                            if (err) {
+                                log.error({err: err, stdout: fds.stdout,
+                                    stderr: fds.stderr},
+                                    'zoneadm failed to install: %s',
+                                    err.message);
+                                cancel();
+                                cb2(err);
+                                return;
+                            }
+
+                            log.debug({stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'zoneadm installed zone');
+                            cb2();
+                        });
+                    }
+                ]}, function (err, results) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    cb();
                 });
-            } else {
-                cb();
-            }
+            });
         }, function (cb) {
-            // Apply zfs_filesystem_limit if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_filesystem_limit')) {
-                args = ['set', 'filesystem_limit='
-                    + payload.zfs_filesystem_limit, payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js installZone (%s)', payload.uuid),
+                log: log
+            });
+            vs.once('ready', function () {
                 cb();
-            }
+            });
         }, function (cb) {
-            // Apply zfs_snapshot_limit if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_snapshot_limit')) {
-                args = ['set', 'snapshot_limit=' + payload.zfs_snapshot_limit,
-                    payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
-                cb();
-            }
+            // Apply ZFS settings
+            var props = [
+                {
+                    key: 'zfs_root_compression',
+                    zfs_prop: 'compression'
+                },
+                {
+                    key: 'zfs_root_recsize',
+                    zfs_prop: 'recsize'
+                },
+                {
+                    key: 'zfs_snapshot_limit',
+                    zfs_prop: 'snapshot_limit'
+                },
+                {
+                    key: 'zfs_filesystem_limit',
+                    zfs_prop: 'filesystem_limit'
+                }
+            ];
+
+            vasync.forEachPipeline({
+                inputs: props,
+                func: function (o, cb2) {
+                    var key = o.key;
+                    var zfs_prop = o.zfs_prop;
+                    if (!payload.hasOwnProperty(key)) {
+                        // not setting value
+                        cb2();
+                        return;
+                    }
+
+                    if (PAYLOAD_PROPERTIES[key].hasOwnProperty('pr_default')) {
+                        var def = PAYLOAD_PROPERTIES[key].pr_default;
+                        if (payload[key] === def) {
+                            // value is set to default
+                            cb2();
+                            return;
+                        }
+                    }
+
+                    var cancel;
+                    vasync.parallel({funcs: [
+                        function (cb3) {
+                            var obj = {
+                                uuid: payload.uuid,
+                                vm: {}
+                            };
+                            obj.vm[key] = payload[key];
+
+                            var opts = {
+                                timeout: VMINFOD_TIMEOUT,
+                                catchErrors: true
+                            };
+                            cancel = vs.watchForEvent(obj, opts, cb3);
+                        },
+                        function (cb3) {
+                            var args = [
+                                'set',
+                                sprintf('%s=%s', zfs_prop, payload[key]),
+                                payload.zfs_filesystem
+                            ];
+                            zfs(args, log, function (err) {
+                                if (err) {
+                                    cancel();
+                                    cb2(err);
+                                    return;
+                                }
+
+                                cb3();
+                            });
+                        }
+                    ]}, cb2);
+                }
+            }, cb);
         }, function (cb) {
             if (reprovisioning) {
                 // reprovisioning we don't change indestructibility state
@@ -7240,64 +7423,230 @@ function installZone(payload, log, callback)
                 return;
             }
 
-            if (payload.hasOwnProperty('indestructible_zoneroot')
-                && payload.indestructible_zoneroot) {
-
-                makeIndestructible(payload.zfs_filesystem, log, cb);
-            } else {
+            if (!payload.hasOwnProperty('indestructible_zoneroot')
+                || !payload.indestructible_zoneroot) {
                 cb();
+                return;
             }
+
+            var cancel;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {
+                            indestructible_zoneroot:
+                                payload.indestructible_zoneroot
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    makeIndestructible(payload.zfs_filesystem, log,
+                        function (err) {
+
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
         }, function (cb) {
             // Some zones can have an additional 'data' dataset delegated to
             // them for use in the zone.  This will set that up.  If the option
             // is not set, the following does nothing.
-            if (!receiving && !reprovisioning) {
-                createDelegatedDataset(payload, log, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
                 cb();
+                return;
             }
-        }, function (cb) {
-            // if there's delegated and we want it indestructible, do so now
-            if (payload.delegate_dataset
-                && payload.hasOwnProperty('indestructible_delegated')) {
 
-                makeIndestructible(payload.zfs_filesystem + '/data', log, cb);
-            } else {
+            if (!payload.delegate_dataset) {
                 cb();
+                return;
             }
+
+            var obj = {
+                uuid: payload.uuid,
+                vm: {}
+            };
+
+            var keys = [
+                'zfs_data_compression',
+                'zfs_data_recsize'
+            ];
+            keys.forEach(function (key) {
+                if (!payload.hasOwnProperty(key)) {
+                    return;
+                }
+                if (PAYLOAD_PROPERTIES[key].hasOwnProperty('pr_default')) {
+                    var def = PAYLOAD_PROPERTIES[key].pr_default;
+                    if (payload[key] !== def) {
+                        obj.vm[key] = payload[key];
+                    }
+                }
+            });
+
+            var cancel;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    createDelegatedDataset(payload, log, function (err) {
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
         }, function (cb) {
-            if (receiving || reprovisioning) {
+            // if there's delegated and we want it indestructible, do so now
+            if (!payload.hasOwnProperty('indestructible_delegated')
+                || !payload.indestructible_delegated) {
                 cb();
                 return;
             }
 
-            createConfigDir(vmobj.zonepath, log, cb);
-        }, function (cb) {
-            var createFileOpts = {};
+            var cancel;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {
+                            indestructible_delegated:
+                                payload.indestructible_delegated
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    makeIndestructible(payload.zfs_filesystem + '/data', log,
+                        function (err) {
 
-            if (receiving || !vmobj.docker) {
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
+        }, function (cb) {
+            if (receiving || reprovisioning) {
                 cb();
                 return;
             }
 
-            if (reprovisioning) {
-                createFileOpts.onlyUpdateFileContents = true;
-            }
+            var cancel;
 
-            if (payload.hasOwnProperty('internal_metadata')) {
-                vmobj.internal_metadata = payload.internal_metadata;
-            }
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
 
-            createHostConfFileMounts(vmobj, createFileOpts, log, cb);
-        }, function (cb) {
-            var host_vols = {};
-            var to_create = [];
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {}
+                    };
+
+                    [
+                        'customer_metadata',
+                        'internal_metadata',
+                        'routes',
+                        'tags'
+                    ].forEach(function (key) {
+                        obj.vm[key] = {};
+
+                        if (vmobj.hasOwnProperty(key)
+                            && Object.keys(vmobj[key]).length > 1) {
+
+                            shouldBlock = true;
+                        }
+                    });
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    if (!shouldBlock) {
+                        // Nothing will be changed by the metadata removal
+                        cb2();
+                        return;
+                    }
+
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    createConfigDir(vmobj.zonepath, log, function (err) {
+                        if (err) {
+                            if (cancel) {
+                                cancel();
+                            }
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (cb) {
+            var createFileOpts = {};
+
+            if (receiving || !vmobj.docker) {
+                cb();
+                return;
+            }
+
+            if (reprovisioning) {
+                createFileOpts.onlyUpdateFileContents = true;
+            }
+
+            if (payload.hasOwnProperty('internal_metadata')) {
+                vmobj.internal_metadata = payload.internal_metadata;
+            }
+
+            createHostConfFileMounts(vmobj, createFileOpts, log, cb);
+        }, function (cb) {
+            vs.stop();
+            vs = null;
+            cb();
+        }, function (cb) {
+            var host_vols = {};
+            var to_create = [];
 
             // Create any filesystems now that have the 'create' flag set.
             // Note that currently if you reprovision, all these created volumes
@@ -7350,43 +7699,48 @@ function installZone(payload, log, callback)
             // Write out the zone's metadata
             // Note: we don't do this when receiving because dataset will
             // already contain metadata and we don't want to wipe that out.
-            if (!receiving && !reprovisioning) {
-                saveMetadata(payload, log, function (err) {
-                    if (err) {
-                        log.error(err, 'unable to save metadata: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
                 cb();
+                return;
             }
+
+            saveMetadata(payload, log, function (err) {
+                if (err) {
+                    log.error({err: err}, 'unable to save metadata: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Write out the zone's routes
             // Note: we don't do this when receiving because dataset will
             // already contain routes and we don't want to wipe that out.
-            if (!receiving && !reprovisioning) {
-                saveRoutes(payload, log, function (err) {
-                    if (err) {
-                        log.error(err, 'unable to save routes: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
                 cb();
+                return;
             }
+
+            saveRoutes(payload, log, function (err) {
+                if (err) {
+                    log.error({err: err}, 'unable to save routes: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // if we were receiving, we're done receiving now
-            if (receiving) {
-                VM.unsetTransition(vmobj, {log: log}, cb);
-            } else {
+            if (!receiving) {
                 cb();
+                return;
             }
+
+            VM.unsetTransition(vmobj, {log: log}, cb);
         }, function (cb) {
             // var zoneinit is in installZone() scope
 
@@ -7635,7 +7989,6 @@ function installZone(payload, log, callback)
         }, function (cb) {
 
             var cancel;
-            var calledback = false;
             var prov_wait = true;
             // var_svc_provisioning is at installZone() scope
 
@@ -7656,16 +8009,30 @@ function installZone(payload, log, callback)
             // from provisioning -> either provision_success, or
             // provision_failure.
 
-            if (prov_wait) {
-                // wait for /var/svc/provisioning -> provision_success/failure
-                cancel = VM.waitForProvisioning(vmobj, {log: log},
-                    function (err) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (!prov_wait) {
+                        cb2();
+                        return;
+                    }
 
-                    log.debug(err, 'waited for provisioning');
+                    // wait for /var/svc/provisioning ->
+                    // provision_success/failure
+                    cancel = VM.waitForProvisioning(vmobj, {log: log},
+                        function (err) {
+
+                        log.debug({err: err}, 'waited for provisioning');
+
+                        if (err) {
+                            log.error(err, 'error waiting for provisioning: '
+                                + err.message);
+                            cb2(err);
+                            return;
+                        }
 
-                    if (!err) {
                         log.info('provisioning complete: '
                             + '/var/svc/provisioning is gone');
+
                         // this will clear the provision transition
                         VM.unsetTransition(vmobj, {log: log},
                             function (unset_err) {
@@ -7673,58 +8040,39 @@ function installZone(payload, log, callback)
                             if (unset_err) {
                                 log.error(unset_err, 'error unsetting '
                                     + 'transition: ' + unset_err.message);
+                                cb2(unset_err);
+                                return;
                             }
-                            // this and the cb in the VM.start callback might
-                            // both run if we don't check this.
-                            if (!calledback) {
-                                calledback = true;
-                                cb(unset_err);
-                            }
+
+                            cb2();
                         });
-                    } else {
-                        // failed but might not be able to cb if VM.start's
-                        // callback already did.
-                        log.error(err, 'error waiting for provisioning: '
-                            + err.message);
-                        // this and the cb in the VM.start callback might
-                        // both run if we don't check this.
-                        if (!calledback) {
-                            calledback = true;
-                            cb(err);
+                    });
+                }, function (cb2) {
+                    VM.start(payload.uuid, {}, {log: log}, function (err, res) {
+                        if (err) {
+                            // we failed to start so we'll never see
+                            // provisioning, so cancel that and return the
+                            // error.
+                            if (cancel) {
+                                log.info('cancelling VM.waitForProvisioning');
+                                cancel();
+                            }
+
+                            cb2(err);
+                            return;
                         }
-                    }
-                });
-            }
 
-            VM.start(payload.uuid, {}, {log: log}, function (err, res) {
-                if (err) {
-                    // we failed to start so we'll never see provisioning, so
-                    // cancel that and return the error.
-                    if (cancel) {
-                        log.info('cancelling VM.waitForProvisioning');
-                        cancel();
-                    }
-                    // this and the cb in the VM.waitForProvisioning
-                    // callback might both run if we don't check this.
-                    if (!calledback) {
-                        calledback = true;
-                        cb(err);
-                    }
-                    return;
-                }
-                // if we're waiting for 'provisioning' VM.waitForProvisioning's
-                // callback will call cb().  If we're not going to wait, we call
-                // it here.
-                if (!prov_wait) {
-                    // this and the cb in the VM.waitForProvisioning
-                    // callback might both run if we don't check this.
-                    if (!calledback) {
-                        calledback = true;
-                        cb();
-                    }
+                        cb2();
+                    });
                 }
+            ]}, function (err, results) {
+                cb(err);
             });
         }], function (error) {
+            if (vs) {
+                vs.stop();
+                vs = null;
+            }
             callback(error);
         }
     );
@@ -7922,6 +8270,7 @@ function createZone(payload, log, callback)
     var timeout_multiplier;
     var tracers_obj;
     var vm_version;
+    var vs;
     var zcfg;
 
     assert(log, 'no logger passed to createZone()');
@@ -8031,25 +8380,59 @@ function createZone(payload, log, callback)
     // we're talking about a new machine.
     zcfg = zcfg + buildZonecfgUpdate({}, payload, log);
 
-    // send the zonecfg data we just generated as stdin to zonecfg,
-    // this will create the zone.
-    zonecfg(payload.zonename, [],
-        {log: log, stdin: zcfg, useZonename: true}, function (err, fds) {
+    vs = new vminfod.VminfodEventStream({
+        name: sprintf('VM.js createZone (%s)', payload.uuid),
+        log: log
+    });
 
-        if (err) {
-            log.error({err: err, zcfg: zcfg, stdout: fds.stdout,
-                stderr: fds.stderr}, 'failed to modify zonecfg');
-            callback(err);
-            return;
-        }
+    var cancel;
+    vs.once('ready', function () {
+        vasync.parallel({funcs: [
+            function (cb2) {
+                var obj = {
+                    type: 'create',
+                    uuid: payload.uuid
+                };
+                var opts = {
+                    timeout: VMINFOD_TIMEOUT,
+                    catchErrors: true,
+                    teardown: true
+                };
+                cancel = vs.watchForEvent(obj, opts, cb2);
+            },
+            function (cb2) {
+                // send the zonecfg data we just generated as a file to
+                // zonecfg, this will create the zone.
+                zonecfg(payload.zonename, [],
+                    {log: log, stdin: zcfg, useZonename: true},
+                    function (err, fds) {
 
-        log.debug({stdout: fds.stdout, stderr: fds.stderr}, 'modified zonecfg');
+                    if (err) {
+                        log.error({err: err, zcfg: zcfg, stdout: fds.stdout,
+                            stderr: fds.stderr},
+                            'failed to modify zonecfg');
 
-        if (payload.create_only) {
-            callback();
-        } else {
-            installZone(payload, log, callback);
-        }
+                        cancel();
+                        callback(err);
+                        return;
+                    }
+
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'modified zonecfg');
+                    cb2();
+                });
+            }
+        ]}, function (err, results) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            if (payload.create_only) {
+                callback();
+            } else {
+                installZone(payload, log, callback);
+            }
+        });
     });
 }
 
@@ -8102,8 +8485,10 @@ function normalizePayload(payload, vmobj, log, callback)
     var action;
     var allowed;
     var brand;
+    var docker_cmd;
+    var docker_id;
+    var mdata_key;
     var property;
-    var set_mdata_prefix = '';
     var tracers_obj;
     var uuid;
 
@@ -8255,12 +8640,6 @@ function normalizePayload(payload, vmobj, log, callback)
             }
         }
 
-        // For 'create' and 'receive', we use 'internal_metadata' and update
-        // uses 'set_internal_metadata'.
-        if (action === 'update') {
-            set_mdata_prefix = 'set_';
-        }
-
         // If we're setting docker=true and restart_init is not false, set it
         // false now. We don't want zoneadmd to try to restart us (OS-3546).
         if ((!vmobj || vmobj.restart_init !== false)
@@ -8279,22 +8658,44 @@ function normalizePayload(payload, vmobj, log, callback)
             }
         }
 
+        // For 'create' and 'receive', we use 'internal_metadata' and update
+        // uses 'set_internal_metadata'.
+        if (action === 'update') {
+            mdata_key = 'set_internal_metadata';
+        } else {
+            mdata_key = 'internal_metadata';
+        }
+
         // If we already have a docker id and this is an update setting
         // docker=true, we'll assume it's set to a correct value.
         if (!vmobj
             || !vmobj.internal_metadata
             || !vmobj.internal_metadata['docker:id']) {
 
-            // Existing VM doesn't have 'docker:id', so we'll add one.
-            if (!payload[set_mdata_prefix + 'internal_metadata']) {
-                payload[set_mdata_prefix + 'internal_metadata'] = {
-                    'docker:id': newDockerId(uuid)
+            docker_id = newDockerId(uuid);
+
+            if (!payload[mdata_key]) {
+                payload[mdata_key] = {
+                    'docker:id': docker_id
                 };
-            } else if (!payload[set_mdata_prefix
-                + 'internal_metadata']['docker:id']) {
+            } else if (!payload[mdata_key]['docker:id']) {
+                payload[mdata_key]['docker:id'] = docker_id;
+            }
+        }
+
+        // We will set docker:cmd to halt indefinitely if it is unset
+        if (!vmobj
+            || !vmobj.internal_metadata
+            || !vmobj.internal_metadata['docker:cmd']) {
 
-                payload[set_mdata_prefix + 'internal_metadata']['docker:id']
-                    = newDockerId(uuid);
+            docker_cmd = JSON.stringify(['/usr/bin/sleep', 'Inf']);
+
+            if (!payload[mdata_key]) {
+                payload[mdata_key] = {
+                    'docker:cmd': docker_cmd
+                };
+            } else if (!payload[mdata_key]['docker:cmd']) {
+                payload[mdata_key]['docker:cmd'] = docker_cmd;
             }
         }
     }
@@ -8430,8 +8831,8 @@ function normalizePayload(payload, vmobj, log, callback)
         normalizeNics(payload, vmobj);
 
         vasync.pipeline({
-            'arg': payload,
-            'funcs': [
+            arg: payload,
+            funcs: [
                 mod_nic.upgradeNicAdds,
                 mod_nic.upgradeNicUpdates.bind(null, vmobj),
                 function (_, cb) {
@@ -8506,6 +8907,7 @@ exports.unsetTransition = function (vmobj, options, callback)
 {
     var log;
     var tracers_obj;
+    var vs;
 
     // options is optional
     if (arguments.length === 2) {
@@ -8526,52 +8928,132 @@ exports.unsetTransition = function (vmobj, options, callback)
         log = tracers_obj.log;
     }
 
-    zonecfg(vmobj.uuid, ['remove -F attr name=transition'],
-        {log: log}, function (err, fds) {
-
-        if (err) {
-            // log at info because this might be because already removed
-            log.info({err: err, stdout: fds.stdout, stderr: fds.stderr},
-                'unable to remove transition for zone ' + vmobj.uuid);
-        } else {
-            log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                'removed transition for zone ' + vmobj.uuid);
-        }
-
-        zonecfg(vmobj.uuid, ['info attr name=transition'],
-            {log: log}, function (info_err, info_fds) {
-
-            if (info_err) {
-                log.error({err: info_err, stdout: info_fds.stdout,
-                    stderr: info_fds.stderr},
-                    'failed to confirm transition removal');
-                callback(info_err);
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            if (!vmobj.hasOwnProperty('transition_to')) {
+                // we can skip vminfod completely, because no change will happen
+                cb();
                 return;
             }
 
-            if (info_fds.stdout !== 'No such attr resource.\n') {
-                log.error({stdout: info_fds.stdout, stderr: info_fds.stderr},
-                    'unknown error checking transition after removal');
-                callback(new Error('transition does not appear to have been '
-                    + 'removed zonecfg said: ' + JSON.stringify(info_fds)));
-                return;
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js unsetTransition (%s)', vmobj.uuid),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                vmobj = ready_ev.vms[vmobj.uuid];
+                assert.object(vmobj, sprintf('vm %s not found in vminfod',
+                    vmobj.uuid));
+                cb();
+            });
+        }, function (_, cb) {
+            // check again
+            if (!vmobj.hasOwnProperty('transition_to')) {
+                // we can skip vminfo completely, because no change will happen
+                if (vs) {
+                    vs.stop();
+                    vs = null;
+                }
             }
 
-            // removed the transition, now attempt to start if we're rebooting.
-            if (vmobj.transition_to && vmobj.transition_to === 'start') {
-                log.debug('VM ' + vmobj.uuid + ' was stopping for reboot, '
-                    + 'transitioning to start.');
-                VM.start(vmobj.uuid, {}, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'failed to start when clearing '
-                            + 'transition');
+            cb();
+        }, function (_, cb) {
+            var cancel;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (!vs) {
+                        cb();
+                        return;
                     }
-                    callback();
-                });
-            } else {
-                callback();
+
+                    var obj = {
+                        uuid: vmobj.uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['transition_to'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var zcfg = 'remove attr name=transition';
+                    var msg = 'remove attr: No such resource with that id';
+
+                    zonecfg(vmobj.uuid, [zcfg], {log: log},
+                        function (err, fds) {
+
+                        if (err
+                            && fds.stderr
+                            && fds.stderr.trim() === msg) {
+
+                            // it was already unset, we don't need to do
+                            // anything.
+                            log.debug({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'attr name=transition already gone for VM %s',
+                                vmobj.uuid);
+
+                            if (cancel)
+                                cancel();
+                            cb2();
+                            return;
+                        }
+
+                        if (err) {
+                            // we failed for some unknown reason, we can't
+                            // continue
+                            log.error({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to remove transition for VM %s',
+                                vmobj.uuid);
+
+                            if (cancel)
+                                cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        // succeeded to remove transition, we wait on vminfod
+                        // to become aware of the changes
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'attr transition removed for VM %s',
+                            vmobj.uuid);
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (_, cb) {
+            // removed the transition, now attempt to start if we're rebooting.
+            if (vmobj.transition_to !== 'start') {
+                cb();
+                return;
             }
-        });
+
+            log.debug('VM %s was stopping for reboot, transitioning to start.',
+                vmobj.uuid);
+
+            VM.start(vmobj.uuid, {}, {log: log}, function (e) {
+                if (e) {
+                    log.error(e, 'failed to start when clearing transition');
+                }
+                cb();
+            });
+        }
+    ]}, function (err) {
+        callback(err);
     });
 };
 
@@ -8584,6 +9066,7 @@ exports.unsetTransition = function (vmobj, options, callback)
 function setTransition(vmobj, transition, target, timeout, log, callback)
 {
     var tracers_obj;
+    var vs;
 
     assert(log, 'no logger passed to setTransition()');
 
@@ -8598,35 +9081,77 @@ function setTransition(vmobj, transition, target, timeout, log, callback)
         log = tracers_obj.log;
     }
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             // unset an existing transition
             if (vmobj.hasOwnProperty('transition')) {
                 VM.unsetTransition(vmobj, {log: log}, cb);
             } else {
                 cb();
             }
-        }, function (cb) {
-            var zcfg;
+        }, function (_, cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js setTransition (%s)', vmobj.uuid),
+                log: log
+            });
 
-            zcfg = buildTransitionZonecfg(transition, target, timeout);
-            zonecfg(vmobj.uuid, [zcfg], {log: log},
-                function (err, fds) {
+            vs.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            var cancel;
 
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'failed to set transition='
-                        + transition + ' for VM ' + vmobj.uuid);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'set transition=' + transition + ' for vm '
-                        + vmobj.uuid);
-                }
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: vmobj.uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['transition_to'],
+                            action: 'added',
+                            to: target
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var zcfg = buildTransitionZonecfg(transition, target,
+                        timeout);
+
+                    zonecfg(vmobj.uuid, [zcfg], {log: log},
+                        function (err, fds) {
+
+                        if (err) {
+                            // we unset the transition attribute above, so
+                            // any error here is considered a failure
+                            log.error({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to set transition=%s for VM %s',
+                                transition, vmobj.uuid);
+
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
 
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'set transition=%s for VM %s',
+                            transition, vmobj.uuid);
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
                 cb(err);
             });
         }
-    ], function (error) {
+    ]}, function (error) {
         callback(error);
     });
 }
@@ -8702,8 +9227,9 @@ function receiveVM(json, log, callback)
     });
 }
 
-function receiveStdinChunk(type, log, callback)
+function receiveStdinChunk(type, opts, callback)
 {
+    var args;
     var child;
     var chunk_name = '';
     var chunk_size = 0;
@@ -8711,6 +9237,12 @@ function receiveStdinChunk(type, log, callback)
     var remaining = '';
     var tracers_obj;
 
+    assert.object(opts, 'opts');
+
+    var log = opts.log;
+    var vs = opts.vs;
+    var uuid = opts.uuid;
+
     assert(log, 'no logger passed to receiveStdinChunk()');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
@@ -8731,94 +9263,157 @@ function receiveStdinChunk(type, log, callback)
      *
      */
 
-    if (type === 'JSON') {
-        log.info('/usr/vm/sbin/vmunbundle json');
-        child = spawn('/usr/vm/sbin/vmunbundle', ['json'],
-            {customFds: [0, -1, -1]});
-    } else if (type === 'DATASET') {
-        log.info('/usr/vm/sbin/vmunbundle dataset');
-        child = spawn('/usr/vm/sbin/vmunbundle', ['dataset'],
-            {customFds: [0, -1, -1]});
-    } else {
+    switch (type) {
+    case 'JSON':
+        args = ['json'];
+        break;
+    case 'DATASET':
+        assert(vs, 'opts.vs');
+        assert(uuid, 'opts.uuid');
+        args = ['dataset'];
+        break;
+    default:
         callback(new Error('Unsupported chunk type ' + type));
+        return;
     }
 
-    child.stderr.on('data', function (data) {
-        var idx;
-        var line;
-        var matches;
+    var cancel;
+    vasync.parallel({funcs: [
+        function vminfod_block(cb) {
+            if (type !== 'DATASET') {
+                cancel = noop;
+                cb();
+                return;
+            }
 
-        remaining += data.toString();
+            var _opts = {
+                catchErrors: true,
+                startFresh: true,
+                timeout: VMINFOD_TIMEOUT
+            };
 
-        idx = remaining.indexOf('\n');
-        while (idx > -1) {
-            line = trim(remaining.substring(0, idx));
-            remaining = remaining.substring(idx + 1);
+            var obj = {
+                uuid: uuid
+            };
 
-            log.debug('VMUNBUNDLE: ' + line);
-            matches = line.match(/Size: ([\d]+)/);
-            if (matches) {
-                chunk_size = Number(matches[1]);
-            }
-            matches = line.match(/Name: \[(.*)\]/);
-            if (matches) {
-                chunk_name = matches[1];
-            }
+            var changes = [
+                [
+                    {
+                        path: ['disks', null, 'missing'],
+                        action: 'removed'
+                    },
+                    {
+                        path: ['zfs_filesystem'],
+                        action: 'added'
+                    }
+                ]
+            ];
 
-            idx = remaining.indexOf('\n');
-        }
-    });
+            cancel = vs.watchForChanges(obj, changes, _opts, cb);
+        }, function vmbundle(cb) {
+            log.info('/usr/vm/sbin/vmunbundle %s', args.join(' '));
+            child = spawn('/usr/vm/sbin/vmunbundle', args,
+                {customFds: [0, -1, -1]});
 
-    child.stdout.on('data', function (data) {
-        json += data.toString();
-        log.debug('json size is ' + json.length);
-    });
+            child.stderr.on('data', function (data) {
+                var idx;
+                var line;
+                var matches;
 
-    child.on('close', function (code) {
-        log.debug('vmunbundle process exited with code ' + code);
-        if (code === 3) {
-            log.debug('vmbundle: end of bundle.');
-            callback(null, 'EOF');
-            return;
-        } else if (code !== 0) {
-            callback(new Error('vmunbundle exited with code ' + code));
-            return;
-        }
+                remaining += data.toString();
 
-        // if it was a dataset, we've now imported it.
-        // if it was json, we've now got it in the json var.
+                idx = remaining.indexOf('\n');
+                while (idx > -1) {
+                    line = trim(remaining.substring(0, idx));
+                    remaining = remaining.substring(idx + 1);
 
-        if (type === 'DATASET') {
-            log.info('Imported dataset ' + chunk_name);
-            // delete 'sending' snapshot
-            zfs(['destroy', '-F', chunk_name + '@sending'], log,
-                function (err, fds) {
-                    if (err) {
-                        log.warn(err, 'Failed to destroy ' + chunk_name
-                            + '@sending: ' + err.message);
+                    log.debug('VMUNBUNDLE: ' + line);
+                    matches = line.match(/Size: ([\d]+)/);
+                    if (matches) {
+                        chunk_size = Number(matches[1]);
                     }
-                    callback();
+                    matches = line.match(/Name: \[(.*)\]/);
+                    if (matches) {
+                        chunk_name = matches[1];
+                    }
+
+                    idx = remaining.indexOf('\n');
                 }
-            );
-        } else if (type === 'JSON' && chunk_name === 'JSON'
-            && json.length <= chunk_size && json.length > 0) {
+            });
 
-            receiveVM(json, log, function (e, result) {
-                if (e) {
-                    callback(e);
+            child.stdout.on('data', function (data) {
+                json += data.toString();
+                log.debug('json size is ' + json.length);
+            });
+
+            child.on('close', function (code) {
+                log.debug('vmunbundle process exited with code ' + code);
+
+                switch (code) {
+                case 0:
+                    break;
+                case 3:
+                    log.debug('vmbundle: end of bundle.');
+                    cancel();
+                    cb(null, 'EOF');
+                    return;
+                default:
+                    cancel();
+                    cb(new Error('vmunbundle exited with code ' + code));
+                    return;
+                }
+
+                // if it was a dataset, we've now imported it.
+                // if it was json, we've now got it in the json var.
+
+                if (type === 'DATASET') {
+                    log.info('Imported dataset ' + chunk_name);
+                    // delete 'sending' snapshot
+                    var snap = chunk_name + '@sending';
+                    zfs(['destroy', '-F', snap], log, function (err, fds) {
+                        if (err) {
+                            log.warn({err: err},
+                                'Failed to destroy %s: %s',
+                                snap,
+                                err.message);
+                        }
+
+                        cb();
+                    });
+                    return;
+                }
+
+                if (type === 'JSON' && chunk_name === 'JSON'
+                    && json.length <= chunk_size && json.length > 0) {
+
+                    receiveVM(json, log, function (e, result) {
+                        if (e) {
+                            cb(e);
+                            return;
+                        }
+
+                        log.info({result: result}, 'Receive returning result');
+
+                        cb(null, {json: JSON.parse(json), result: result});
+                    });
                     return;
                 }
-                log.info('Receive returning: ' + JSON.stringify(result));
-                callback(null, result);
+
+                // error
+                log.debug('type: [' + type + ']');
+                log.debug('chunk_name: [' + chunk_name + ']');
+                log.debug('chunk_size: [' + chunk_size + ']');
+                log.debug('json.length: [' + json.length + ']');
+                log.warn('Failed to get ' + type + '!');
+                cb(new Error('Failed to get ' + type + '!'));
             });
-        } else {
-            log.debug('type: [' + type + ']');
-            log.debug('chunk_name: [' + chunk_name + ']');
-            log.debug('chunk_size: [' + chunk_size + ']');
-            log.debug('json.length: [' + json.length + ']');
-            log.warn('Failed to get ' + type + '!');
-            callback(new Error('Failed to get ' + type + '!'));
         }
+    ]}, function (err, results) {
+        var result = results.operations.filter(function (o) {
+            return o.funcname === 'vmbundle';
+        })[0].result;
+
+        callback(err, result);
     });
 }
 
@@ -8826,6 +9421,9 @@ exports.receive = function (target, options, callback)
 {
     var log;
     var tracers_obj;
+    var result;
+    var origJson;
+    var vsChunk, vsGlobal;
 
     // options is optional
     if (arguments.length === 2) {
@@ -8860,59 +9458,173 @@ exports.receive = function (target, options, callback)
         return;
     }
 
-    receiveStdinChunk('JSON', log, function (error, result) {
-        var eof = false;
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            receiveStdinChunk('JSON', {log: log}, function (error, o) {
+                if (error) {
+                    cb(error);
+                    return;
+                }
+
+                origJson = o.json;
+                result = o.result;
 
-        if (error) {
-            callback(error);
-            return;
-        }
+                if (result && result === 'EOF') {
+                    cb(new Error('unable to find JSON in stdin.'));
+                    return;
+                }
+
+                if (!result || !result.hasOwnProperty('uuid')) {
+                    cb(new Error('unable to receive JSON'));
+                    return;
+                }
+
+                log.debug({origJson: origJson, result: result},
+                    'Receive stdin JSON chunk');
+
+                cb();
+            });
+        }, function (_, cb) {
+            // This event stream is used globally while vmbundle is forked many
+            // times to ensure metadata has been added properly.
+            vsGlobal = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js receive global (%s)', result.uuid),
+                log: log
+            });
+
+            vsGlobal.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            // This event stream is used for each invocation of vmbundle with
+            // the DATASET option.  This way, we can properly block on vminfod
+            // to see the disks.* added event.
+            vsChunk = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js receive receiveStdin (%s)', result.uuid),
+                log: log
+            });
 
-        if (result && result === 'EOF') {
-            callback(new Error('unable to find JSON in stdin.'));
-        } else if (result && result.hasOwnProperty('uuid')) {
+            vsChunk.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
             // VM started receive, now need datasets
+            var eof = false;
+            var cancel;
 
             // We have JSON, so we can log better now if we need one
             if (!options.hasOwnProperty('log')) {
                 log = VM.log.child({action: 'receive', vm: result.uuid});
             }
 
-            log.info('Receiving VM ' + result.uuid);
+            log.info('Receiving VM %s', result.uuid);
             log.debug('now looking for datasets');
 
-            vasync.whilst(
-                function () { return !eof; },
-                function (cb) {
-                    receiveStdinChunk('DATASET', log, function (err, res) {
-                        if (err) {
-                            cb(err);
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
+
+                    var obj = {
+                        uuid: result.uuid,
+                        vm: {}
+                    };
+
+                    [
+                        'zpool',
+                        'quota',
+                        'internal_metadata',
+                        'customer_metadata',
+                        'tags',
+                        'routes'
+                    ].forEach(function (key) {
+                        if (!origJson.hasOwnProperty(key)) {
                             return;
                         }
-                        if (res === 'EOF') {
-                            eof = true;
+
+                        var o = origJson[key];
+                        var t = typeof (o);
+
+                        if (t !== 'object') {
+                            shouldBlock = true;
+                            obj.vm[key] = o;
+                        } else if (t === 'object'
+                            && Object.keys(o).length > 0) {
+
+                            shouldBlock = true;
+                            obj.vm[key] = o;
                         }
-                        cb();
                     });
-                }, function (err) {
-                    if (err) {
-                        callback(err);
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true,
+                        teardown: true
+                    };
+
+                    if (!shouldBlock) {
+                        cb2();
                         return;
                     }
-                    // no error so we read all the datasets, try an install.
-                    log.info('receive calling VM.install: ' + eof);
-                    VM.install(result.uuid, {log: log}, function (e) {
-                        if (e) {
-                            log.warn(e, 'couldn\'t install VM: '
-                                + e.message);
+
+                    cancel = vsGlobal.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    vasync.whilst(
+                        function () { return !eof; },
+                        function (cb3) {
+                            var opts = {
+                                log: log,
+                                uuid: result.uuid,
+                                vs: vsChunk
+                            };
+                            receiveStdinChunk('DATASET', opts,
+                                function (err, res) {
+
+                                if (err) {
+                                    cb3(err);
+                                    return;
+                                }
+
+                                if (res === 'EOF') {
+                                    eof = true;
+                                }
+                                cb3();
+                            });
+                        },
+                        function (err) {
+                            if (err) {
+                                if (cancel) {
+                                    cancel();
+                                }
+                                cb2(err);
+                                return;
+                            }
+                            cb2();
                         }
-                        callback(e, result);
-                    });
+                    );
                 }
-            );
-        } else {
-            callback(new Error('unable to receive JSON'));
+            ]}, cb);
+        }, function (_, cb) {
+            if (vsChunk) {
+                vsChunk.stop();
+                vsChunk = null;
+            }
+            cb();
+        }, function (_, cb) {
+            // no error so we read all the datasets, try an install.
+            log.info('receive calling VM.install');
+            VM.install(result.uuid, {log: log}, function (e) {
+                if (e) {
+                    log.warn({err: e}, 'couldn\'t install VM: %s', e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }
+    ]}, function (err) {
+        callback(err, result);
     });
 };
 
@@ -8924,6 +9636,7 @@ exports.reprovision = function (uuid, payload, options, callback)
     var snapshot;
     var tracers_obj;
     var vmobj;
+    var vs;
 
     // options is optional
     if (arguments.length === 3) {
@@ -8944,35 +9657,20 @@ exports.reprovision = function (uuid, payload, options, callback)
         log = tracers_obj.log;
     }
 
-    log.info('Reprovisioning VM ' + uuid + ', original payload:\n'
-            + JSON.stringify(payload, null, 2));
+    log.info({payload: payload}, 'Reprovisioning VM %s', uuid);
 
     vasync.waterfall([
         function (cb) {
-            VM.load(uuid, {
-                fields: [
-                    'brand',
-                    'datasets',
-                    'hostname',
-                    'indestructible_zoneroot',
-                    'nics',
-                    'quota',
-                    'state',
-                    'uuid',
-                    'zfs_filesystem',
-                    'zone_state',
-                    'zonename',
-                    'zonepath',
-                    'zpool'
-                ],
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js reprovision (%s)', uuid),
+                parseReady: true,
                 log: log
-            }, function (err, obj) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
-                vmobj = obj;
-                log.debug('Loaded VM is: ' + JSON.stringify(vmobj, null, 2));
+            });
+
+            vs.once('ready', function (ready_ev) {
+                vmobj = ready_ev.vms[uuid];
+                assert.object(vmobj, 'reprovision vminfod vmobj');
+                log.debug({vmobj: vmobj}, 'loaded vm %s', uuid);
                 cb();
             });
         }, function (cb) {
@@ -9033,17 +9731,21 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }, function (cb) {
             // ensure we're stopped before reprovision starts
-            if (vmobj.zone_state !== 'installed') {
-                VM.stop(uuid, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'unable to stop VM ' + uuid + ': '
-                            + e.message);
-                    }
-                    cb(e);
-                });
-            } else {
+            if (vmobj.zone_state === 'installed') {
                 cb();
+                return;
             }
+
+            VM.stop(uuid, {log: log}, function (e) {
+                if (e) {
+                    log.error({err: e}, 'unable to stop VM %s: %s',
+                        uuid, e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Set transition to provisioning now, we're going for it.
             setTransition(vmobj, 'provisioning', 'running',
@@ -9114,14 +9816,50 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }, function (cb) {
             // rename <zfs_filesystem> dataset out of the way
-            zfs(['rename', '-f', vmobj.zfs_filesystem, vmobj.zfs_filesystem
-                + '-reprovisioning-root'], log, function (err, fds) {
+            var cancel;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['zpool'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
 
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'Unable to (temporarily) rename '
-                        + vmobj.zfs_filesystem);
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var args = [
+                        'rename',
+                        '-f',
+                        vmobj.zfs_filesystem,
+                        vmobj.zfs_filesystem + '-reprovisioning-root'
+                    ];
+                    zfs(args, log, function (err, fds) {
+
+                        if (err) {
+                            log.error({
+                                err: err,
+                                stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Unable to (temporarily) rename %s',
+                                vmobj.zfs_filesystem);
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
                 }
+            ]}, function (err) {
                 cb(err);
             });
         }, function (cb) {
@@ -9193,7 +9931,7 @@ exports.reprovision = function (uuid, payload, options, callback)
             var retry_delay = 1; // second(s) between retries
 
             // clone the new image creating a new dataset for zoneroot
-            assert(snapshot);
+            assert(snapshot, 'reprovision snapshot');
 
             args = ['clone'];
             if (vmobj.hasOwnProperty('quota') && vmobj.quota > 0) {
@@ -9238,43 +9976,99 @@ exports.reprovision = function (uuid, payload, options, callback)
                 cb(err);
             });
         }, function (cb) {
-            createConfigDir(vmobj.zonepath, log, cb);
-        }, function (cb) {
-            /*
-             * Copy zones/<uuid>-reprovisioning-root/config to
-             * zones/<uuid>/config so that we keep existing metadata,
-             * IPF rules, routes, and so on.
-             */
-            var cmd = 'cp -pPR '
-                + vmobj.zonepath + '-reprovisioning-root/config/* '
-                + vmobj.zonepath + '/config/';
-
-            traceExec(cmd, log, 'cp-config', function (error, stdout, stderr) {
-                log.debug({'stdout': stdout, 'stderr': stderr}, 'cp results');
-                if (error) {
-                    error.stdout = stdout;
-                    error.stderr = stderr;
-                    cb(error);
+            createConfigDir(vmobj.zonepath, log, function (err) {
+                if (err) {
+                    cb(err);
                     return;
-                } else {
-                    cb();
                 }
-            });
-        }, function (cb) {
-            // destroy <zonepath>-reprovisioning-root, since it's no longer used
-            zfs(['destroy', '-r', vmobj.zfs_filesystem
-                + '-reprovisioning-root'], log, function (err, fds) {
 
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'Unable to destroy '
-                        + vmobj.zfs_filesystem + '-reprovisioning-root: '
-                        + err.message);
-                }
-                cb(err);
+                cb();
             });
         }, function (cb) {
-            // remount /zones/<uuid>/cores
+            var cancel;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
+
+                    var obj = {
+                        uuid: uuid,
+                        vm: {}
+                    };
+
+                    [
+                        'customer_metadata',
+                        'internal_metadata',
+                        'routes',
+                        'tags'
+                    ].forEach(function (key) {
+
+                        if (vmobj.hasOwnProperty(key)
+                            && Object.keys(vmobj[key]).length > 0) {
+
+                            obj.vm[key] = vmobj[key];
+                            shouldBlock = true;
+                        }
+                    });
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    if (!shouldBlock) {
+                        // Nothing will be changed by the metadata copy
+                        cb2();
+                        return;
+                    }
+
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    /*
+                     * Copy zones/<uuid>-reprovisioning-root/config to
+                     * zones/<uuid>/config so that we keep existing metadata,
+                     * IPF rules, routes, and so on.
+                     */
+                    var cmd = 'cp -pPR '
+                        + vmobj.zonepath + '-reprovisioning-root/config/* '
+                        + vmobj.zonepath + '/config/';
+
+                    traceExec(cmd, log, 'cp-config',
+                        function (error, stdout, stderr) {
+
+                        log.debug({stdout: stdout, stderr: stderr},
+                            'cp results');
+
+                        if (error) {
+                            cancel();
+                            error.stdout = stdout;
+                            error.stderr = stderr;
+                            cb2(error);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (cb) {
+            // destroy <zonepath>-reprovisioning-root, since it's no longer used
+            zfs(['destroy', '-r', vmobj.zfs_filesystem
+                + '-reprovisioning-root'], log, function (err, fds) {
+
+                if (err) {
+                    log.error({err: err, stdout: fds.stdout,
+                        stderr: fds.stderr}, 'Unable to destroy '
+                        + vmobj.zfs_filesystem + '-reprovisioning-root: '
+                        + err.message);
+                }
+                cb(err);
+            });
+        }, function (cb) {
+            // remount /zones/<uuid>/cores
             zfs(['mount', vmobj.zpool + '/cores/' + uuid], log,
                 function (err, fds) {
 
@@ -9398,6 +10192,10 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (err && set_transition) {
             // remove transition now, if we failed.
             VM.unsetTransition(vmobj, {log: log}, function () {
@@ -9655,60 +10453,48 @@ exports.send = function (uuid, target, options, callback)
             if (target === 'stdout' && tty.isatty(1)) {
                 log.error('Cannot send VM to a TTY.');
                 cb(new Error('Cannot send VM to a TTY.'));
-            } else {
-                cb();
+                return;
             }
+
+            cb();
         }, function (cb) {
             // NOTE: for this load we always load all fields, because we need
             // to send them all to the target machine.
             VM.load(uuid, {log: log}, function (err, obj) {
                 if (err) {
                     cb(err);
-                } else {
-                    vmobj = obj;
-                    cb();
+                    return;
                 }
+
+                vmobj = obj;
+                cb();
             });
         }, function (cb) {
             datasets = getAllDatasets(vmobj);
             if (datasets.length < 1) {
                 log.error('Cannot send VM with no datasets.');
                 cb(new Error('VM has no datasets.'));
-            } else {
-                cb();
+                return;
             }
-        }, function (cb) {
-            if (vmobj.state !== 'stopped') {
-                // In this case we need to stop it and make sure it stopped.
-                VM.stop(uuid, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'unable to stop VM ' + uuid + ': '
-                            + e.message);
-                        cb(e);
-                        return;
-                    }
-                    VM.load(uuid, {fields: ['zone_state', 'uuid'], log: log},
-                        function (error, obj) {
 
-                        if (error) {
-                            log.error(error, 'unable to reload VM ' + uuid
-                                + ': ' + error.message);
-                            return;
-                        }
-                        if (obj.zone_state !== 'installed') {
-                            log.error('after stop attempt, state is '
-                                + obj.zone_state + ' != installed');
-                            cb(new Error('state after stopping is '
-                                + obj.zone_state + ' != installed'));
-                            return;
-                        }
-                        cb();
-                    });
-                });
-            } else {
-                // already stopped, good to go!
+            cb();
+        }, function (cb) {
+            if (vmobj.state === 'stopped') {
                 cb();
+                return;
             }
+
+            // Stop the VM
+            VM.stop(uuid, {log: log}, function (e) {
+                if (e) {
+                    log.error({err: e}, 'unable to stop VM %s: %s',
+                        uuid, e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Clean up trash left from broken datasets (see OS-388)
             try {
@@ -9725,6 +10511,7 @@ exports.send = function (uuid, target, options, callback)
         }, function (cb) {
             // send JSON
             var json = JSON.stringify(vmobj, null, 2) + '\n';
+            log.debug({json: json}, 'Sending JSON to target: %s', target);
             sendJSON(target, json, log, cb);
         }, function (cb) {
             // send datasets
@@ -9732,9 +10519,12 @@ exports.send = function (uuid, target, options, callback)
                 sendDataset(target, ds, log, c);
             }, function (e) {
                 if (e) {
-                    log.error('Failed to send datasets');
+                    log.error({err: e}, 'Failed to send datasets');
+                    cb(e);
+                    return;
                 }
-                cb(e);
+
+                cb();
             });
         }
     ], function (err) {
@@ -9954,6 +10744,7 @@ function deleteZone(uuid, log, callback)
     var load_fields;
     var tracers_obj;
     var vmobj;
+    var vs;
 
     assert(log, 'no logger passed to deleteZone()');
 
@@ -9977,6 +10768,28 @@ function deleteZone(uuid, log, callback)
 
     async.series([
         function (cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js deleteZone (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                vmobj = ready_ev.vms[uuid];
+                cb();
+            });
+        }, function (cb) {
+            if (vmobj) {
+                // the vmobj was found in vminfod
+                cb();
+                return;
+            }
+
+            /*
+             * If the VM was not found in vminfod, most likely it won't be on
+             * the system at all.  Instead of throwing an error ourselves, we
+             * can do a VM.load (which will use vminfod) to try again.
+             */
             VM.load(uuid, {fields: load_fields, log: log}, function (err, obj) {
                 if (err) {
                     cb(err);
@@ -10097,7 +10910,9 @@ function deleteZone(uuid, log, callback)
             });
         }, function (cb) {
             log.debug('halting zone');
-            zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
+            zoneadm(['-u', uuid, 'halt', '-X'], log,
+                function (e, fds) {
+
                 if (e) {
                     log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
                         'Error halting zone');
@@ -10118,15 +10933,60 @@ function deleteZone(uuid, log, callback)
                 cb();
             });
         }, function (cb) {
-            log.debug('uninstalling zone');
-            zoneadm(['-u', uuid, 'uninstall', '-F'], log, function (e, fds) {
-                if (e) {
-                    log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'Error uninstalling zone: ' + e.message);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'uninstalled zone');
+            var cancel;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['zone_state'],
+                            action: 'changed',
+                            to: 'configured'
+                        },
+                        {
+                            path: ['zfs_filesystem'],
+                            action: 'removed'
+                        },
+                        {
+                            path: ['zpool'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    log.debug('uninstalling zone');
+                    zoneadm(['-u', uuid, 'uninstall', '-F'], log,
+                        function (e, fds) {
+
+                        if (e) {
+                            log.warn({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Error uninstalling zone: %s', e.message);
+                            cancel();
+                            cb2(e);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'uninstalled zone');
+                        cb2();
+                    });
+                }]
+            }, function (err, res) {
+                if (err) {
+                    cb(err);
+                    return;
                 }
+
                 cb();
             });
         }, function (cb) {
@@ -10158,36 +11018,49 @@ function deleteZone(uuid, log, callback)
                 return;
             }
 
-            log.debug('deleting zone');
-            zonecfg(uuid, ['delete', '-F'],
-                {log: log}, function (e, fds) {
+            var cancel;
 
-                if (e) {
-                    log.warn({err: e, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'Error deleting VM');
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'deleted VM ' + uuid);
-                }
-                cb();
-            });
-        }, function (cb) {
-            VM.load(uuid, {fields: ['uuid'], log: log, missing_ok: true},
-                function (err, obj) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    // block on vminfod event
+                    var obj = {
+                        type: 'delete',
+                        uuid: uuid
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
 
-                if (err && err.code === 'ENOENT') {
-                    // the zone is gone, that's good.
-                    log.debug('confirmed VM is gone.');
-                    cb();
-                } else if (err) {
-                    // there was am unexpected error.
-                    cb(err);
-                } else {
-                    // the VM still exists!
-                    err = new Error('VM still exists after delete.');
-                    err.code = 'EEXIST';
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    log.debug('deleting zone');
+                    zonecfg(uuid, ['delete', '-F'],
+                        {log: log},
+                        function (e, fds) {
+
+                        if (e) {
+                            log.warn({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Error deleting VM');
+                            cancel();
+                            cb2(e);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'deleted VM %s', uuid);
+                        cb2();
+                    });
+                }]
+            }, function (err, res) {
+                if (err) {
                     cb(err);
+                    return;
                 }
+
+                cb();
             });
         }, function (cb) {
             // delete the incoming payload if it exists
@@ -10203,6 +11076,10 @@ function deleteZone(uuid, log, callback)
             );
         }
     ], function (error) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         callback(error);
     });
 }
@@ -10300,7 +11177,6 @@ function startZone(vmobj, opts, callback)
     var uuid = vmobj.uuid;
     var waited = false;
     var waitErr;
-    var zonestream;
 
     assert(log, 'no logger passed to startZone()');
 
@@ -10320,6 +11196,7 @@ function startZone(vmobj, opts, callback)
         set_autoboot = 'select attr name=vm-autoboot; set value=true; end';
     }
 
+    var vs;
     async.series([
         function (cb) {
             // If the caller passed a waiting function, start it before we try
@@ -10335,76 +11212,54 @@ function startZone(vmobj, opts, callback)
             }
             cb();
         }, function (cb) {
-            // get a zone watcher object if a waiting function is not passed in
-            if (opts.state_waiter) {
-                cb();
-                return;
-            }
-
-            getZoneWatcher({log: log}, function (err, _stream) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
+            // create a vminfod event stream - we use this to make sure the VM
+            // transitions into the "running" state before moving on
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js startZone (%s)', vmobj.uuid),
+                log: log
+            });
 
-                zonestream = _stream;
+            vs.once('ready', function () {
                 cb();
             });
         }, function (cb) {
+            // do the booting
             var cancel;
 
             vasync.parallel({funcs: [
                 function (cb2) {
-                    // if we already have a state_waiter we can skip blocking
-                    // on waitForZoneState
-                    if (opts.state_waiter) {
-                        assert(!zonestream,
-                            'zone stream set with state_waiter');
-                        cb2();
-                        return;
-                    }
-
-                    // call waitForZoneState with the zonestream we allocated
-                    // above
-                    assert(zonestream, 'zone stream not set');
-                    var _opts = {
-                        timeout: 30,
-                        log: log,
-                        skipConfirmation: true,
-                        stream: zonestream
+                    var obj = {
+                        uuid: vmobj.uuid
                     };
-                    cancel = VM.waitForZoneState(vmobj, 'running', _opts,
-                        function (err, result) {
-
-                        if (err) {
-                            if (err.code === 'ETIMEOUT') {
-                                log.info({err: err},
-                                    'timeout waiting for zone to go to '
-                                    + '"running"');
-                            } else {
-                                log.error({err: err},
-                                    'unknown error waiting for zone to '
-                                    + 'go to "running"');
+                    var changes = [
+                        [
+                            {
+                                path: ['state'],
+                                action: 'changed',
+                                to: 'running'
+                            },
+                            {
+                                path: ['state'],
+                                action: 'changed',
+                                to: 'stopped'
                             }
-                            cb2(err);
-                            return;
-                        }
+                        ]
+                    ];
+                    var _opts = {
+                        timeout: PROVISION_TIMEOUT * 1000,
+                        catchErrors: true,
+                        startFresh: true
+                    };
 
-                        log.info('VM switched to "running"');
-                        cb2();
-                    });
+                    cancel = vs.watchForChanges(obj, changes, _opts, cb2);
                 }, function (cb2) {
-                    // do the booting
                     zoneadm(['-u', uuid, 'boot', '-X'], log,
                         function (err, boot_fds) {
-
                         if (err) {
                             log.error({err: err, stdout: boot_fds.stdout,
                                 stderr: boot_fds.stderr},
                                 'zoneadm failed to boot VM');
-                            if (cancel) {
-                                cancel();
-                            }
+                            cancel();
                             cb2(err);
                             return;
                         }
@@ -10412,27 +11267,36 @@ function startZone(vmobj, opts, callback)
                         log.debug({stdout: boot_fds.stdout,
                             stderr: boot_fds.stderr},
                             'zoneadm booted VM');
-                        cb2();
+                        cb2(err);
                     });
                 }
-            ]}, cb);
+            ]}, function (err, results) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Ensure it booted. If caller passed in a function that can wait
             // for a zone to go to a state, we'll just call that.
-            if (opts.state_waiter) {
-                function _waitWaiter() {
-                    if (waited) {
-                        cb(waitErr);
-                        return;
-                    }
-                    setTimeout(_waitWaiter, 100);
+            function _waitWaiter() {
+                if (waited) {
+                    cb(waitErr);
+                    return;
                 }
+                setTimeout(_waitWaiter, 100);
+            }
+            if (opts.state_waiter) {
                 _waitWaiter();
                 return;
             }
 
             cb();
         }, function (cb) {
+            var cancel;
+
             if (vmobj.docker && vmobj.internal_metadata
                 && !vmobj.internal_metadata['docker:restartpolicy']) {
 
@@ -10441,7 +11305,9 @@ function startZone(vmobj, opts, callback)
                     'docker VM has no restart policy, not setting autoboot');
                 cb();
                 return;
-            } else if (vmobj.docker && vmobj.internal_metadata) {
+            }
+
+            if (vmobj.docker && vmobj.internal_metadata) {
                 // all other policies currently involve rebooting at least on CN
                 // reboot.
                 log.info({
@@ -10450,26 +11316,67 @@ function startZone(vmobj, opts, callback)
                 }, 'docker VM has restart policy, setting autoboot');
             }
 
-            zonecfg(uuid, [set_autoboot], {log: log},
-                function (err, autoboot_fds) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (vmobj.autoboot) {
+                        cb2();
+                        return;
+                    }
+                    var obj = {
+                        uuid: vmobj.uuid,
+                        vm: {
+                            autoboot: true
+                        }
+                    };
+                    var _opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    cancel = vs.watchForEvent(obj, _opts, cb2);
+                }, function (cb2) {
+                    zonecfg(uuid, [set_autoboot], {log: log},
+                        function (err, autoboot_fds) {
+
+                        if (err) {
+                            // The vm is running at this point, erroring out
+                            // here would do no good, so we just log it.
+                            log.error({
+                                err: err,
+                                stdout: autoboot_fds.stdout,
+                                stderr: autoboot_fds.stderr},
+                                'startZone(): Failed to "%s" for %s',
+                                set_autoboot,
+                                uuid);
+
+                            if (cancel)
+                                cancel();
+                            cb2();
+                            return;
+                        }
+
+                        log.debug({
+                            stdout: autoboot_fds.stdout,
+                            stderr: autoboot_fds.stderr},
+                            'set autoboot for %s', uuid);
 
+                        cb2();
+                    });
+                }
+            ]}, function (err, results) {
                 if (err) {
-                    // The vm is running at this point, erroring out here would
-                    // do no good, so we just log it.
-                    log.error({err: err, stdout: autoboot_fds.stdout,
-                        stderr: autoboot_fds.stderr}, 'startZone(): Failed to '
-                        + set_autoboot + ' for ' + uuid);
-                } else {
-                    log.debug({stdout: autoboot_fds.stdout,
-                        stderr: autoboot_fds.stderr}, 'set autoboot');
+                    cb(err);
+                    return;
                 }
-                cb(err);
+                cb();
             });
         }, function (cb) {
             if (!vmobj.never_booted) {
                 cb();
                 return;
             }
+
             zonecfg(uuid, ['remove attr name=never-booted'],
                 {log: log}, function (err, neverbooted_fds) {
 
@@ -10487,8 +11394,12 @@ function startZone(vmobj, opts, callback)
             });
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (!err) {
-            log.info('Started ' + uuid);
+            log.info('Started %s', uuid);
         }
         callback(err);
     });
@@ -11165,6 +12076,7 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
         var mountpath;
         var mountpoint;
         var snap;
+        var vs;
         var zoneroot;
 
         if (err) {
@@ -11244,22 +12156,70 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
                     cb(); // XXX not fatal because might also not exist
                 });
             }, function (cb) {
-                var args;
+                vs = new vminfod.VminfodEventStream({
+                    name: sprintf('VM.js delete_snapshot (%s)', uuid),
+                    log: log
+                });
 
-                args = ['destroy', vmobj.zfs_filesystem + '@vmsnap-'
-                    + snapname];
+                vs.once('ready', function () {
+                    cb();
+                });
+            }, function (cb) {
+                var cancel;
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            uuid: uuid
+                        };
+                        var changes = [
+                            [
+                                {
+                                    path: ['snapshots', null, 'name'],
+                                    action: 'changed',
+                                    from: snapname
+                                },
+                                {
+                                    path: ['snapshots', null],
+                                    action: 'removed',
+                                    from: {
+                                        name: snapname
+                                    }
+                                }
+                            ]
+                        ];
+                        var opts = {
+                            timeout: VMINFOD_TIMEOUT,
+                            catchErrors: true,
+                            teardown: true
+                        };
+
+                        cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                    },
+                    function (cb2) {
+                        var zfssnapname = util.format('%s@vmsnap-%s',
+                            vmobj.zfs_filesystem, snapname);
+
+                        var args = ['destroy', zfssnapname];
+
+                        zfs(args, log, function (e, fds) {
+                            if (e) {
+                                log.error({err: e, stdout: fds.stdout,
+                                    stderr: fds.stdout},
+                                    'zfs destroy failed.');
+                                cancel();
+                                cb2(e);
+                                return;
+                            }
 
-                zfs(args, log, function (e, fds) {
-                    if (e) {
-                        log.error({'err': e, 'stdout': fds.stdout,
-                            'stderr': fds.stdout}, 'zfs destroy failed.');
-                        cb(e);
-                        return;
+                            log.debug({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'zfs destroy %s',
+                                zfssnapname);
+                            cb2();
+                        });
                     }
-                    log.debug({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'zfs destroy ' + vmobj.zfs_filesystem + '@vmsnap-'
-                        + snapname);
-                    cb();
+                ]}, function (err2) {
+                    cb(err2);
                 });
             }, function (cb) {
                 updateZonecfgTimestamp(vmobj, function (e) {
@@ -11326,6 +12286,7 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
         var mount_snapshot = true;
         var snap;
         var snapshot_list = [];
+        var vs;
         var zoneroot;
 
         if (err) {
@@ -11350,14 +12311,12 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        full_snapname = vmobj.zfs_filesystem + '@vmsnap-' + snapname;
-
         // Check that name not already used
         if (vmobj.hasOwnProperty('snapshots')) {
             for (snap in vmobj.snapshots) {
                 snap = vmobj.snapshots[snap];
 
-                if (snap.name === full_snapname) {
+                if (snap.name === snapname) {
                     callback(new Error('snapshot with name "' + snapname
                         + '" already exists.'));
                     return;
@@ -11367,10 +12326,9 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
             }
         }
 
+        full_snapname = vmobj.zfs_filesystem + '@vmsnap-' + snapname;
         snapshot_list.push(full_snapname);
 
-        // assert snapshot_list.length > 0
-
         log.info('Taking snapshot "' + snapname + '" of ' + uuid);
 
         zoneroot = vmobj.zonepath + '/root';
@@ -11379,19 +12337,67 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
 
         vasync.waterfall([
             function (cb) {
-                // take the snapshot
-                var args;
-                args = ['snapshot'].concat(snapshot_list);
-
-                zfs(args, log, function (zfs_err, fds) {
-                    if (zfs_err) {
-                        log.error({err: zfs_err, stdout: fds.stdout,
-                            stderr: fds.stdout}, 'zfs snapshot failed.');
-                    } else {
-                        log.debug({err: zfs_err, stdout: fds.stdout,
-                            stderr: fds.stderr}, 'zfs ' + args.join(' '));
+                vs = new vminfod.VminfodEventStream({
+                    name: sprintf('VM.js create_snapshot (%s)', uuid),
+                    log: log
+                });
+
+                vs.once('ready', function () {
+                    cb();
+                });
+            }, function (cb) {
+                var cancel;
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            uuid: uuid
+                        };
+                        var changes = [
+                            [
+                                {
+                                    path: ['snapshots', null, 'name'],
+                                    action: 'changed',
+                                    to: snapname
+                                },
+                                {
+                                    path: ['snapshots', null],
+                                    action: 'added',
+                                    to: {
+                                        name: snapname
+                                    }
+                                }
+                            ]
+                        ];
+                        var opts = {
+                            timeout: VMINFOD_TIMEOUT,
+                            catchErrors: true,
+                            teardown: true
+                        };
+
+                        cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                    },
+                    function (cb2) {
+                        // take the snapshot
+                        var args = ['snapshot'].concat(snapshot_list);
+
+                        zfs(args, log, function (zfs_err, fds) {
+                            if (zfs_err) {
+                                log.error({err: zfs_err, stdout: fds.stdout,
+                                    stderr: fds.stdout},
+                                    'zfs snapshot failed.');
+                                cancel();
+                                cb2(zfs_err);
+                                return;
+                            }
+
+                            log.debug({err: zfs_err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'zfs %s', args.join(' '));
+                            cb2();
+                        });
                     }
-                    cb(zfs_err);
+                ]}, function (err2) {
+                    cb(err2);
                 });
             }, function (cb) {
 
@@ -11520,17 +12526,18 @@ function getHostvolumeFile(url, target, log, callback) {
                     log.info('config file is %s', cfgfile);
                     cb();
                     return;
-                } else {
-                    fs.exists('/usbkey/config', function (hn_exists) {
-                        if (hn_exists) {
-                            cfgfile = '/usbkey/config';
-                            log.info('config file is %s', cfgfile);
-                            cb();
-                        } else {
-                            cb(new Error('Unable to find SDC config file.'));
-                        }
-                    });
                 }
+
+                fs.exists('/usbkey/config', function (hn_exists) {
+                    if (!hn_exists) {
+                        cb(new Error('Unable to find SDC config file.'));
+                        return;
+                    }
+
+                    cfgfile = '/usbkey/config';
+                    log.info('config file is %s', cfgfile);
+                    cb();
+                });
             });
         }, function (cb) {
             fs.readFile(cfgfile, 'utf8', function (err, data) {
@@ -11665,11 +12672,17 @@ function getHostvolumeFile(url, target, log, callback) {
     });
 }
 
-function setDockerRestartOpts(uuid, filename, options, log, callback)
+function setDockerRestartOpts(uuid, options, callback)
 {
-    var lockpath = '/var/run/vm.' + uuid + '.config.lockfile';
+    var log;
     var tracers_obj;
-    var unlock;
+
+    assert.uuid(uuid, 'uuid');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+
+    log = options.log;
+    assert(log, 'log');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('set-docker-restartopts', log,
@@ -11678,97 +12691,48 @@ function setDockerRestartOpts(uuid, filename, options, log, callback)
         log = tracers_obj.log;
     }
 
-    function _failed(err) {
-        if (unlock) {
-            unlock(function (unlock_err) {
-                log.error({err: unlock_err}, 'failed ot unlock while handling '
-                    + 'error');
-                callback(err);
-            });
-        } else {
-            callback(err);
-        }
-    }
+    VM.load(uuid, {log: log}, function (err, vmobj) {
+        var im;
+        var zonepath;
 
-    log.debug('acquiring lock on ' + lockpath);
-    lock(lockpath, function (err, _unlock) {
         if (err) {
-            log.error('failed to acquire lock on ' + lockpath);
+            log.error({err: err}, 'failed to load VM %s', uuid);
             callback(err);
             return;
         }
-        log.debug('acquired lock on ' + lockpath);
-        unlock = _unlock;
-
-        fs.readFile(filename, 'utf8', function (error, data) {
-            var mdata;
-            var msg;
-            var tmp_filename;
-
-            if (error) {
-                log.error(error, 'failed to load ' + filename);
-                _failed(error);
-                return;
-            }
 
-            try {
-                mdata = JSON.parse(data);
-            } catch (e) {
-                log.error({err: e}, 'failed to parse mdata JSON');
-                _failed(e);
-                return;
-            }
+        im = vmobj.internal_metadata || {};
 
-            if (options.hasOwnProperty('value')) {
-                mdata.internal_metadata['docker:restartcount'] = options.value;
-            } else if (options.hasOwnProperty('increment')) {
-                if (mdata.internal_metadata['docker:restartcount']) {
-                    mdata.internal_metadata['docker:restartcount'] =
-                        Number(mdata.internal_metadata['docker:restartcount'])
-                        + options.increment;
-                } else {
-                    mdata.internal_metadata['docker:restartcount'] = 1;
-                }
+        if (options.hasOwnProperty('value')) {
+            im['docker:restartcount'] = options.value;
+        } else if (options.hasOwnProperty('increment')) {
+            if (im['docker:restartcount']) {
+                im['docker:restartcount'] =
+                    parseInt(im['docker:restartcount'], 10) + options.increment;
             } else {
-                msg = 'invalid options for setDockerRestartOpts()';
-                log.error({options: options}, msg);
-                _failed(new Error(msg));
+                im['docker:restartcount'] = 1;
             }
+        } else {
+            err = new Error('invalid options for setDockerRestartOpts()');
+            log.error({err: err, options: options}, err.message);
+            callback(err);
+            return;
+        }
 
-            if (options.hasOwnProperty('delay') && options.delay) {
-                mdata.internal_metadata['docker:restartdelay'] = options.delay;
-            }
+        if (options.hasOwnProperty('delay') && options.delay) {
+            im['docker:restartdelay'] = options.delay;
+        }
 
-            tmp_filename = filename + '.tmp.' + process.pid;
-            fs.writeFile(tmp_filename, JSON.stringify(mdata, null, 2), 'utf8',
-                function (write_err) {
+        try {
+            zonepath = calculateZonepath(vmobj);
+        } catch (e) {
+            log.error({err: e}, 'failed to calculate zonepath for %s', uuid);
+            callback(e);
+            return;
+        }
 
-                if (write_err) {
-                    log.error(write_err, 'failed to write ' + tmp_filename);
-                    _failed(write_err);
-                    return;
-                } else {
-                    fs.rename(tmp_filename, filename, function (rename_err) {
-                        if (rename_err) {
-                            log.error(rename_err, 'failed to rename '
-                                + tmp_filename + ' to ' + filename);
-                            _failed(rename_err);
-                            return;
-                        }
-                        log.debug('releasing lock on ' + lockpath);
-                        unlock(function (unlock_err) {
-                            if (unlock_err) {
-                                log.error(unlock_err, 'failed to unlock');
-                                callback(unlock_err);
-                                return;
-                            }
-                            log.debug('released lock on ' + lockpath);
-                            callback();
-                        });
-                    });
-                }
-            });
-        });
+        writeAllMetadata(uuid, zonepath, {internal_metadata: im},
+            {log: log}, callback);
     });
 }
 
@@ -11861,31 +12825,31 @@ exports.start = function (uuid, extra, options, callback)
             VM.load(uuid, {log: log, fields: load_fields}, function (err, obj) {
                 if (err) {
                     cb(err);
-                } else {
-
-                    if (obj.state === 'running') {
-                        err = new Error('VM ' + obj.uuid + ' is already '
-                            + '\'running\'');
-                        err.code = 'EALREADYRUNNING';
-                        cb(err);
-                        return;
-                    }
+                    return;
+                }
 
-                    if ((obj.state !== 'stopped'
-                            && obj.state !== 'provisioning')
-                        || (obj.state === 'provisioning'
-                            && obj.zone_state !== 'installed')) {
+                if (obj.state === 'running') {
+                    err = new Error('VM ' + obj.uuid + ' is already '
+                        + '\'running\'');
+                    err.code = 'EALREADYRUNNING';
+                    cb(err);
+                    return;
+                }
 
-                        err = new Error('Cannot to start vm from state "'
-                            + obj.state + '", must be "stopped".');
-                        log.error(err);
-                        cb(err);
-                        return;
-                    }
+                if ((obj.state !== 'stopped'
+                        && obj.state !== 'provisioning')
+                    || (obj.state === 'provisioning'
+                        && obj.zone_state !== 'installed')) {
 
-                    vmobj = obj;
-                    cb();
+                    err = new Error('Cannot start vm from state "'
+                        + obj.state + '", must be "stopped".');
+                    log.error(err);
+                    cb(err);
+                    return;
                 }
+
+                vmobj = obj;
+                cb();
             });
         }, function (cb) {
             validateNicTags(vmobj.nics, log, function (e) {
@@ -11933,27 +12897,25 @@ exports.start = function (uuid, extra, options, callback)
                 return;
             }
         }, function (cb) {
-            var mdata_path;
-
             if (!vmobj.docker || !vmobj.zonepath) {
                 cb();
                 return;
             }
 
-            mdata_path = path.join(vmobj.zonepath, '/config/metadata.json');
-
             // we're about to restart now, so bump the restart counter if we're
             // restarting from vmadmd, otherwise just set it to 0.
             if (options.increment_restart_count) {
-                setDockerRestartOpts(vmobj.uuid, mdata_path, {
+                setDockerRestartOpts(vmobj.uuid, {
+                    log: log,
                     delay: options.restart_delay,
                     increment: 1
-                }, log, cb);
+                }, cb);
             } else {
-                setDockerRestartOpts(vmobj.uuid, mdata_path, {
+                setDockerRestartOpts(vmobj.uuid, {
+                    log: log,
                     delay: options.restart_delay,
                     value: 0
-                }, log, cb);
+                }, cb);
             }
         }, function (cb) {
             var err;
@@ -12010,18 +12972,20 @@ function setRctl(zonename, rctl, value, log, callback)
                             log.error(set_error, 'setRctl() failed with: '
                                 + set_stderr);
                             callback(set_error);
-                        } else {
-                            callback();
+                            return;
                         }
+
+                        callback();
                     }
                 );
             } else {
                 log.error(error, 'setRctl() failed with: ' + stderr);
                 callback(error);
             }
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -12038,9 +13002,10 @@ function removeRctl(zonename, rctl, log, callback)
         if (error) {
             log.error(error, 'setRctl() failed with: ' + stderr);
             callback(error);
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -12108,34 +13073,40 @@ function resizeDisks(disks, updates, log, callback)
         var dsk = vol.disk;
         var size = vol.new_size;
 
-        if (dsk.hasOwnProperty('zfs_filesystem')) {
-            if (dsk.size > size) {
-                cb(new Error('cannot resize ' + dsk.zfs_filesystem
-                    + ' new size must be greater than current size. ('
-                    + dsk.size + ' > ' + dsk.size + ')'));
-            } else if (dsk.size === size) {
-                // no point resizing if the old+new are the same
-                cb();
-            } else {
-                args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
-                zfs(args, log, function (err, fds) {
-                    resized++;
-                    cb(err);
-                });
-            }
-        } else {
+        if (!dsk.hasOwnProperty('zfs_filesystem')) {
             cb(new Error('could not find zfs_filesystem in '
                 + JSON.stringify(dsk)));
+            return;
+        }
+
+        if (dsk.size > size) {
+            cb(new Error('cannot resize ' + dsk.zfs_filesystem
+                + ' new size must be greater than current size. ('
+                + dsk.size + ' > ' + dsk.size + ')'));
+            return;
+        }
+
+        if (dsk.size === size) {
+            // no point resizing if the old+new are the same
+            cb();
+            return;
         }
+
+        args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
+        zfs(args, log, function (err, fds) {
+            resized++;
+            cb(err);
+        });
     }
 
     async.forEachSeries(vols, resize, function (err) {
         if (err) {
             log.error(err, 'Unable to resize disks');
             callback(err);
-        } else {
-            callback(null, resized);
+            return;
         }
+
+        callback(null, resized);
     });
 }
 
@@ -12317,9 +13288,10 @@ function updateVnicProperties(uuid, vmobj, payload, log, callback)
     }, function (err) {
         if (err) {
             callback(err);
-        } else {
-            callback(null);
+            return;
         }
+
+        callback(null);
     });
 }
 
@@ -12378,13 +13350,7 @@ function firewallVMrun(opts, callback) {
 
     // Filters out VMs that don't have firewall_enabled == true
     function fwEnabledFilter(vmobj, cb) {
-        if (vmobj.firewall_enabled) {
-            cb(true);
-            return;
-        }
-
-        cb(false);
-        return;
+        cb(null, vmobj.firewall_enabled);
     }
 
     // Return all VMs, but don't include VMs (other than the one we're
@@ -12393,16 +13359,14 @@ function firewallVMrun(opts, callback) {
     function allVmsFilter(vmobj, cb) {
         if (vmobj.hasOwnProperty('state') && vmobj.state == 'provisioning') {
             if (vmobj.hasOwnProperty('uuid') && vmobj.uuid == cur_vm_uuid) {
-                cb(true);
-                return;
+                cb(null, true);
+            } else {
+                cb(null, false);
             }
-
-            cb(false);
             return;
         }
 
-        cb(true);
-        return;
+        cb(null, true);
     }
 
     async.series([
@@ -12818,9 +13782,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_root_recsize: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -12837,9 +13802,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_filesystem_limit: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -12877,9 +13843,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_data_recsize: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -12897,9 +13864,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply '
                             + 'zfs_root_compression: ' + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -12918,9 +13886,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply '
                             + 'zfs_data_compression: ' + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -12961,63 +13930,69 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
             var disk;
             var zfs_updates = [];
 
-            if (payload.hasOwnProperty('update_disks')) {
-                // loop through the disks we updated and perform any updates.
-                for (disk in payload.update_disks) {
-                    disk = payload.update_disks[disk];
+            if (!payload.hasOwnProperty('update_disks')) {
+                cb();
+                return;
+            }
 
-                    if (!disk) {
-                        continue;
-                    }
+            // loop through the disks we updated and perform any updates.
+            for (disk in payload.update_disks) {
+                disk = payload.update_disks[disk];
 
-                    for (d in oldobj.disks) {
-                        d = oldobj.disks[d];
-                        if (d.path === disk.path
-                            && d.hasOwnProperty('zfs_filesystem')) {
+                if (!disk) {
+                    continue;
+                }
 
-                            if (disk.hasOwnProperty('compression')) {
-                                zfs_updates.push({
-                                    zfs_filesystem: d.zfs_filesystem,
-                                    property: 'compression',
-                                    value: disk.compression
-                                });
-                            }
+                for (d in oldobj.disks) {
+                    d = oldobj.disks[d];
+                    if (d.path === disk.path
+                        && d.hasOwnProperty('zfs_filesystem')) {
 
-                            if (disk.hasOwnProperty('refreservation')) {
-                                zfs_updates.push({
-                                    zfs_filesystem: d.zfs_filesystem,
-                                    property: 'refreservation',
-                                    value: disk.refreservation + 'M'
-                                });
-                            }
+                        if (disk.hasOwnProperty('compression')) {
+                            zfs_updates.push({
+                                zfs_filesystem: d.zfs_filesystem,
+                                property: 'compression',
+                                value: disk.compression
+                            });
+                        }
+
+                        if (disk.hasOwnProperty('refreservation')) {
+                            zfs_updates.push({
+                                zfs_filesystem: d.zfs_filesystem,
+                                property: 'refreservation',
+                                value: disk.refreservation + 'M'
+                            });
                         }
                     }
                 }
-                if (zfs_updates.length > 0) {
-                    log.debug('applying ' + zfs_updates.length
-                        + ' zfs updates');
-                    async.each(zfs_updates, function (props, f_cb) {
-                        zfs(['set', props.property + '=' + props.value,
-                            props.zfs_filesystem], log, function (err, fds) {
+            }
 
-                            if (err) {
-                                log.error(err, 'failed to set ' + props.property
-                                    + '=' + props.value + ' for '
-                                    + props.zfs_filesystem);
-                            }
-                            f_cb(err);
-                        });
-                    }, function (err) {
-                        log.debug({err: err}, 'end of zfs updates');
-                        cb(err);
-                    });
-                } else {
-                    log.debug('no zfs updates to apply');
-                    cb();
-                }
-            } else {
+            if (zfs_updates.length === 0) {
+                log.debug('no zfs updates to apply');
                 cb();
+                return;
             }
+
+            log.debug('applying %d zfs updates', zfs_updates.length);
+
+            async.each(zfs_updates, function (props, f_cb) {
+                zfs(['set', props.property + '=' + props.value,
+                    props.zfs_filesystem], log, function (err, fds) {
+
+                    if (err) {
+                        log.error(err, 'failed to set ' + props.property
+                            + '=' + props.value + ' for '
+                            + props.zfs_filesystem);
+                        f_cb(err);
+                        return;
+                    }
+
+                    f_cb();
+                });
+            }, function (err) {
+                log.debug({err: err}, 'end of zfs updates');
+                cb(err);
+            });
         }, function (cb) {
             var factor;
             var keys = [];
@@ -13054,30 +14029,30 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     factor = 1;
                 }
 
-                if (payload.hasOwnProperty(prop)) {
-                    if (prop === 'cpu_cap' && Number(payload[prop]) === 0) {
-                        // When cpu_cap is 0, we'll remove instead of set since
-                        // setting to 0 fails.
-                        removeRctl(newobj.zonename, rctl, log, function (err) {
-                            if (err) {
-                                log.warn(err, 'failed to remove rctl: ' + prop);
-                            }
-                            c();
-                        });
-                        return;
-                    }
-                    setRctl(newobj.zonename, rctl,
-                        Number(payload[prop]) * factor, log,
-                        function (err) {
-                            if (err) {
-                                log.warn(err, 'failed to set rctl: ' + prop);
-                            }
-                            c();
-                        }
-                    );
-                } else {
+                if (!payload.hasOwnProperty(prop)) {
                     c();
+                    return;
+                }
+                if (prop === 'cpu_cap' && Number(payload[prop]) === 0) {
+                    // When cpu_cap is 0, we'll remove instead of set since
+                    // setting to 0 fails.
+                    removeRctl(newobj.zonename, rctl, log, function (err) {
+                        if (err) {
+                            log.warn(err, 'failed to remove rctl: ' + prop);
+                        }
+                        c();
+                    });
+                    return;
                 }
+                setRctl(newobj.zonename, rctl,
+                    Number(payload[prop]) * factor, log,
+                    function (err) {
+                        if (err) {
+                            log.warn(err, 'failed to set rctl: ' + prop);
+                        }
+                        c();
+                    }
+                );
             }, function (err) {
                 cb(err);
             });
@@ -13095,9 +14070,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     if (e) {
                         cb(new Error('Unable to tell vmadmd to reload VNC: '
                             + e.message));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else if ((payload.hasOwnProperty('spice_password')
                 && (oldobj.spice_password !== newobj.spice_password))
@@ -13112,9 +14088,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     if (e) {
                         cb(new Error('Unable to tell vmadmd to reload SPICE: '
                             + e.message));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13122,30 +14099,28 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
         }, function (cb) {
             // we do this last, since we need the memory in the zone updated
             // first if we're growing this.
-            if (payload.hasOwnProperty('tmpfs')) {
-                if (oldobj.tmpfs === 0) {
-                    /*
-                     * We can't mount over existing /tmp (on zfs) for a running
-                     * VM so we skip update if it's currently not using tmpfs.
-                     */
-                    log.debug('existing tmpfs size is 0, not updating mount for'
-                        + ' running VM.');
-                    cb();
-                    return;
-                } else {
-                    resizeTmp(newobj.zonename, payload.tmpfs, log, cb);
-                }
-            } else {
+            if (!payload.hasOwnProperty('tmpfs')) {
                 cb();
+                return;
             }
-        }, function (cb) {
-            var now = new Date();
-
-            // If we changed any properties that don't involve modifying the
+            if (oldobj.tmpfs === 0) {
+                /*
+                 * We can't mount over existing /tmp (on zfs) for a running
+                 * VM so we skip update if it's currently not using tmpfs.
+                 */
+                log.debug('existing tmpfs size is 0, not updating mount for'
+                    + ' running VM.');
+                cb();
+                return;
+            }
+
+            resizeTmp(newobj.zonename, payload.tmpfs, log, cb);
+        }, function (cb) {
+            // If we changed any properties that don't involve modifying the
             // zone's xml, touch the zone xml file so that last_modified is
             // correct.
             if (changed && newobj.hasOwnProperty('zonename')) {
-                fs.utimes('/etc/zones/' + newobj.zonename + '.xml', now, now,
+                updateZonecfgTimestamp(newobj,
                     function (err) {
                         if (err) {
                             log.warn(err, 'Unable to "touch" xml file for "'
@@ -13194,12 +14169,15 @@ function newDockerId(uuid)
 
 exports.update = function (uuid, payload, options, callback)
 {
+    var changes = [];
+    var keys = {};
     var log;
     var new_vmobj;
     var vmobj;
     var unlock;
     var lockpath;
     var tracers_obj;
+    var vs;
 
     // options parameter is optional
     if (arguments.length === 3) {
@@ -13223,6 +14201,8 @@ exports.update = function (uuid, payload, options, callback)
     log.info('Updating VM ' + uuid + ' with initial payload:\n'
         + JSON.stringify(payload, null, 2));
 
+    keys = Object.keys(payload);
+
     async.series([
         function (cb) {
             lockpath = '/var/run/vm.' + uuid + '.config.lockfile';
@@ -13236,10 +14216,29 @@ exports.update = function (uuid, payload, options, callback)
                 unlock = _unlock;
                 cb();
             });
-        },
-        function (cb) {
-            // for update we currently always load the whole vmobj since the
-            // update functions may need to look at bits from the existing VM.
+        }, function (cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js update (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                vmobj = ready_ev.vms[uuid];
+                cb();
+            });
+        }, function (cb) {
+            if (vmobj) {
+                // the vmobj was found in vminfod
+                cb();
+                return;
+            }
+
+            /*
+             * If the VM was not found in vminfod, most likely it won't be on
+             * the system at all.  Instead of throwing an error ourselves, we
+             * can do a VM.load (which will use vminfod) to try again.
+             */
             VM.load(uuid, {log: log}, function (err, obj) {
                 if (err) {
                     cb(err);
@@ -13252,155 +14251,572 @@ exports.update = function (uuid, payload, options, callback)
             normalizePayload(payload, vmobj, log, function (e) {
                 log.debug('Used payload:\n'
                     + JSON.stringify(payload, null, 2));
-                cb(e);
+
+                if (e) {
+                    cb(e);
+                    return;
+                }
+
+                cb();
             });
         }, function (cb) {
-            var deletables = [];
-            var to_remove = [];
-            var n;
+            /*
+             * Loop each key from the original payload, and construct an array
+             * of changes block for on vminfod
+             */
+            keys.forEach(function (key) {
+                // Ignore keys we won't/can't change
+                // XXX: maybe there's a list of these somewhere?
+                var IGNORE_KEYS = [
+                    'zonename',
+                    'uuid',
+                    'last_modified',
+                    'server_uuid'
+                ];
+                if (IGNORE_KEYS.indexOf(key) > -1) {
+                    log.debug({key: key}, 'key "%s" cannot be modified', key);
+                    return;
+                }
 
-            // destroy remove_disks before we add in case we're recreating with
-            // an existing name.
+                var value = payload[key];
+                var m, label, existing, change, re, identifierKey;
 
-            if (payload.hasOwnProperty('remove_disks')) {
-                to_remove = payload.remove_disks;
-                for (n in vmobj.disks) {
-                    if (to_remove.indexOf(vmobj.disks[n].path) !== -1) {
-                        deletables.push(vmobj.disks[n]);
+                log.debug('processing vmobj key "%s"', key);
+
+                if (key === 'resolvers') {
+                    existing = vmobj[key] || [];
+                    assert.arrayOfString(existing, 'existing vmobj.resolvers');
+                    assert.arrayOfString(value, 'new vmobj.resolvers');
+
+                    // check if already set
+                    // TODO use diff() here
+                    if (deepEqual(existing, value))
+                        return;
+
+                    existing.filter(function (r) {
+                        return value.indexOf(r) === -1;
+                    }).forEach(function (r) {
+                        changes.push({
+                            path: [key, null],
+                            action: 'removed',
+                            from: r
+                        });
+                    });
+
+                    value.filter(function (r) {
+                        return existing.indexOf(r) === -1;
+                    }).forEach(function (r) {
+                        changes.push({
+                            path: [key, null],
+                            action: 'added',
+                            to: r
+                        });
+                    });
+
+                    return;
+                }
+
+                /* JSSTYLED */
+                re = /^(set_|remove_)?(customer_metadata|internal_metadata|tags|routes)$/;
+                if (key.match(re)) {
+                    /*
+                     * Metadata blocking logic is handleded in updateRoutes and
+                     * updateMetadata - so just short-circuit here.
+                     */
+                    return;
+                }
+
+                // add_* keys require special treatment
+                if ((m = key.match(/^add_(.*)$/))) {
+                    label = m[1];
+                    var props;
+
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
+                    }
+                    assert.arrayOfObject(value, 'value');
+
+                    switch (label) {
+                    case 'disks':
+                        props = ['model', 'size'];
+                        break;
+                    case 'nics':
+                        props = ['nic_tag', 'mac', 'interface'];
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
                     }
+
+                    value.forEach(function (thing) {
+                        var newthing = {};
+
+                        props.forEach(function (prop) {
+                            if (thing.hasOwnProperty(prop)) {
+                                newthing[prop] = thing[prop];
+                            }
+                        });
+                        assert(Object.keys(newthing).length > 0,
+                            util.format('at least one property must be'
+                                + 'set: [%s]', props));
+
+                        var localChange = {
+                            path: [label, null],
+                            to: newthing,
+                            action: 'added'
+                        };
+                        changes.push(localChange);
+                    });
+
+                    return;
                 }
-            } else {
-                // no disks to remove so all done.
-                cb();
-                return;
-            }
 
-            function _loggedDeleteVolume(volume, callbk) {
-                return deleteVolume(volume, log, callbk);
-            }
+                // update_* keys require special treatment
+                if ((m = key.match(/^update_(.*)$/))) {
+                    label = m[1];
 
-            async.forEachSeries(deletables, _loggedDeleteVolume,
-                function (err) {
-                    if (err) {
-                        log.error(err, 'Unknown error deleting volumes: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        log.info('successfully deleted volumes');
-                        cb();
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
                     }
+                    assert.arrayOfObject(value, 'value');
+
+                    switch (label) {
+                    case 'disks':
+                        identifierKey = 'path';
+                        break;
+                    case 'nics':
+                        identifierKey = 'mac';
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
+                    }
+
+                    // build a map of identifier key => object
+                    assert.arrayOfObject(vmobj[label], 'vmobj.' + label);
+                    var map = {};
+                    vmobj[label].forEach(function (d) {
+                        assert(d[identifierKey],
+                            sprintf('d[%s]', identifierKey));
+
+                        map[d[identifierKey]] = d;
+                    });
+
+                    log.debug({arr: vmobj[label], map: map},
+                        'index map built for "%s"', key);
+
+                    value.forEach(function (thing) {
+                        var ident = thing[identifierKey];
+                        var orig = map[ident];
+                        assert.object(orig, 'orig');
+
+                        Object.keys(thing).forEach(function (_key) {
+                            if (_key === identifierKey)
+                                return;
+
+                            var defaultPath = util.format('%s.*.%s',
+                                label, _key);
+                            var lookingFor = [label, null, _key];
+
+                            var localChange = {
+                                path: lookingFor,
+                                ident: ident
+                            };
+
+                            localChange.to = thing[_key];
+
+                            var prop = PAYLOAD_PROPERTIES[defaultPath];
+                            if (prop.hasOwnProperty('pr_default')) {
+                                var _def = prop.pr_default;
+
+                                if (_def === thing[_key]) {
+                                    delete localChange.to;
+                                    localChange.action = 'removed';
+                                }
+                            }
+
+                            if (orig[_key] !== thing[_key]) {
+                                changes.push(localChange);
+                            }
+                        });
+                    });
+                    return;
                 }
-            );
-        }, function (cb) {
-            var disks = [];
-            var matches;
-            var n;
-            var p;
-            var used_disk_indexes = [];
 
-            // create any new volumes we need.
-            if (payload.hasOwnProperty('add_disks')) {
-                disks = payload.add_disks;
-            }
+                // remove_* keys require special treatment
+                if ((m = key.match(/^remove_(.*)$/))) {
+                    label = m[1];
 
-            // create a list of used indexes so we can find the free ones to
-            // use in createVolume()
-            if (vmobj.hasOwnProperty('disks')) {
-                for (n in vmobj.disks) {
-                    matches = vmobj.disks[n].path.match(/^.*-disk(\d+)$/);
-                    if (matches) {
-                        used_disk_indexes.push(Number(matches[1]));
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
+                    }
+
+                    switch (label) {
+                    case 'disks':
+                        identifierKey = 'path';
+                        break;
+                    case 'nics':
+                        identifierKey = 'mac';
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
                     }
+
+                    value.forEach(function (thing) {
+                        var from = {};
+                        from[identifierKey] = thing;
+
+                        var localChange = {
+                            path: [label, null],
+                            from: from,
+                            action: 'removed'
+                        };
+                        changes.push(localChange);
+                    });
+
+                    return;
                 }
-            }
 
-            // add the bits of payload createVolumes() needs.
-            p = {'add_disks': disks};
-            p.uuid = uuid;
-            if (vmobj.hasOwnProperty('zpool')) {
-                p.zpool = vmobj.zpool;
-            }
-            p.used_disk_indexes = used_disk_indexes;
-            createVolumes(p, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateMetadata(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateRoutes(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            var zcfg;
-            // generate a payload and send as stdin to zonecfg to update the
-            // zone.
-            zcfg = buildZonecfgUpdate(vmobj, payload, log);
-            zonecfg(uuid, [], {log: log, stdin: zcfg},
-                function (e, fds) {
+                /*
+                 * "ram" is a special key which results in us setting a number
+                 * of other keys (if not set explicitly in the original
+                 * payload)
+                 */
+                if (key === 'ram') {
+                    [
+                        'max_physical_memory',
+                        'max_locked_memory',
+                        vmobj.brand === 'kvm' ? 'ram' : 'tmpfs'
+                    ].forEach(function (newkey) {
+                        var v;
+
+                        if (newkey !== 'ram' && keys.indexOf(newkey) > -1) {
+                            /*
+                             * The key we are attempting to set as a result of
+                             * the "ram" key being set is set explicitly in
+                             * the original payload - skip it
+                             */
+                            return;
+                        }
 
-                if (e) {
-                    log.error({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'unable to update zonecfg');
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'updated zonecfg');
+                        if (vmobj.brand === 'kvm' && newkey !== 'ram')
+                            v = value + KVM_MEM_OVERHEAD;
+                        else
+                            v = value;
+
+                        var localChange = {
+                            path: [newkey],
+                            to: v
+                        };
+                        if (vmobj[newkey] !== v)
+                            changes.push(localChange);
+                    });
+
+                    return;
                 }
-                cb(e);
-            });
-        }, function (cb) {
-            restartMetadataService(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateVnicProperties(uuid, vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            // Do another full reload (all fields) so we can compare in
-            // applyUpdates() and decide what's changed that we need to apply.
-            VM.load(uuid, {log: log}, function (e, newobj) {
-                if (e) {
-                    cb(e);
-                } else {
-                    new_vmobj = newobj;
-                    cb();
+
+                /*
+                 * If we are here, the key being modified does not require any
+                 * special processing, so we will just watch for it to change
+                 * to the value specified in the payload.
+                 */
+                change = {
+                    path: [key],
+                    to: value
+                };
+
+                // normalize empty values as a value removal
+                if (value === '' || value === undefined || value === null) {
+                    delete change.to;
+                    change.action = 'removed';
                 }
+
+                /*
+                 * Keys like "fs_allowed" can be set to an array like
+                 * ["ufs","pcfs","tmpfs"] by the user but will be stored as
+                 * "ufs,pcfs,tmpfs".
+                 */
+                try {
+                    assert.arrayOfString(value);
+                    change.to = value.join(',');
+                } catch (e) {
+                }
+
+                // check to see if this property has a default value
+                var o = PAYLOAD_PROPERTIES[key];
+                if (o && o.hasOwnProperty('pr_default')) {
+                    var def = o.pr_default;
+
+                    /*
+                     * If the value is being set to the default value for the
+                     * property, this is equivalent to value removal.
+                     */
+                    if (def === value) {
+                        delete change.to;
+                        change.action = 'removed';
+                    }
+                }
+
+                /*
+                 * If the current value matches the desired value, we skip it
+                 * as no work is needed to be done
+                 */
+                if ((change.action === 'removed'
+                    && !vmobj.hasOwnProperty(key))
+                    || (change.action !== 'removed'
+                    && vmobj.hasOwnProperty(key)
+                    && vmobj[key] === value)) {
+                    return;
+                }
+
+                if (change.action === 'removed') {
+                    /*
+                     * Removing a key can sometimes be equivalent to setting it
+                     * to its default.
+                     */
+                    change = [change];
+                    change.push({
+                        path: change[0].path.slice(0),
+                        to: value
+                    });
+                } else if (change.to === 0) {
+                    /*
+                     * Sometimes changing a value to 0 is equivalent to
+                     * removing that value (ex: "cpu_cap").
+                     */
+                    change = [change];
+                    change.push({
+                        path: change[0].path.slice(0),
+                        action: 'removed'
+                    });
+                }
+
+                changes.push(change);
             });
+
+            // special attention given to docker objects
+            if (vmobj.docker) {
+                var old_zlog_mode = vmobj.zlog_mode;
+                var new_zlog_mode =
+                    calculateZlogModeAndDriver(payload, vmobj).mode;
+                if (old_zlog_mode !== new_zlog_mode) {
+                    changes.push({
+                        path: ['zlog_mode'],
+                        to: new_zlog_mode
+                    });
+                }
+            }
+
+            log.debug({changes: changes}, 'vminfod changes array built');
+            cb();
         }, function (cb) {
-            applyUpdates(vmobj, new_vmobj, payload, log, function () {
-                cb();
+            /*
+             * If we are here, we have successfully loaded the VM and acquired
+             * the necessary file lock.  Now, we must fire off the next string
+             * of functions which will do the actual updating of the vm, while
+             * simultaneously blocking on vminfod to give us the necessary
+             * "modify" event letting us know it has been successfully updated.
+             */
+            var cancel;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    doupdate(function (err) {
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
             });
-        }, function (cb) {
-            // Update the firewall data
-            updateFirewallData(payload, new_vmobj, log, cb);
         }
     ], function (e) {
-        // If we were able to hold the lockfile, and thus have an unlock
-        // callback, we must call it before returning, whether or not
-        // there was an error.
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (unlock) {
-            log.debug('releasing lock on ' + lockpath);
+            log.debug('releasing lock on %s', lockpath);
             unlock(function (unlock_err) {
                 if (unlock_err) {
                     log.error(unlock_err,
-                        'unlock error! (path ' + lockpath + ')');
+                        'unlock error! (path %s)', lockpath);
                 } else {
-                    log.debug('released lock on ' + lockpath);
+                    log.debug('released lock on %s', lockpath);
                 }
                 callback(e);
             });
-        } else {
-            callback(e);
+            return;
         }
+
+        callback(e);
     });
+
+    function doupdate(done) {
+        async.series([
+            function (cb) {
+                var deletables = [];
+                var to_remove;
+                var n;
+
+                // destroy remove_disks before we add in case we're recreating
+                // with an existing name.
+
+                if (!payload.hasOwnProperty('remove_disks')) {
+                    // no disks to remove so all done.
+                    cb();
+                    return;
+                }
+
+                to_remove = payload.remove_disks;
+                for (n in vmobj.disks) {
+                    if (to_remove.indexOf(vmobj.disks[n].path) !== -1) {
+                        deletables.push(vmobj.disks[n]);
+                    }
+                }
+
+                function _loggedDeleteVolume(volume, callbk) {
+                    return deleteVolume(volume, log, callbk);
+                }
+
+                async.forEachSeries(deletables, _loggedDeleteVolume,
+                    function (err) {
+                        if (err) {
+                            log.error(err, 'Unknown error deleting volumes: '
+                                + err.message);
+                            cb(err);
+                            return;
+                        }
+
+                        log.info('successfully deleted volumes');
+                        cb();
+                    }
+                );
+            }, function (cb) {
+                var disks = [];
+                var matches;
+                var n;
+                var p;
+                var used_disk_indexes = [];
+
+                // create any new volumes we need.
+                if (payload.hasOwnProperty('add_disks')) {
+                    disks = payload.add_disks;
+                }
+
+                // create a list of used indexes so we can find the free ones to
+                // use in createVolume()
+                if (vmobj.hasOwnProperty('disks')) {
+                    for (n in vmobj.disks) {
+                        matches = vmobj.disks[n].path.match(/^.*-disk(\d+)$/);
+                        if (matches) {
+                            used_disk_indexes.push(Number(matches[1]));
+                        }
+                    }
+                }
+
+                // add the bits of payload createVolumes() needs.
+                p = {'add_disks': disks};
+                p.uuid = uuid;
+                if (vmobj.hasOwnProperty('zpool')) {
+                    p.zpool = vmobj.zpool;
+                }
+                p.used_disk_indexes = used_disk_indexes;
+                createVolumes(p, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateMetadata(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateRoutes(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                var zcfg;
+                // generate a payload and send as a file to zonecfg to update
+                // the zone.
+                zcfg = buildZonecfgUpdate(vmobj, payload, log);
+                zonecfg(uuid, [], {log: log, stdin: zcfg},
+                    function (e, fds) {
+
+                    if (e) {
+                        log.error({
+                            err: e,
+                            stdout: fds.stdout,
+                            stderr: fds.stderr
+                        }, 'unable to update zonecfg');
+                        cb(e);
+                        return;
+                    }
+
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'updated zonecfg');
+                    cb();
+                });
+            }, function (cb) {
+                restartMetadataService(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateVnicProperties(uuid, vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                // Do another full reload (all fields) so we can compare in
+                // applyUpdates() and decide what's changed that we need to
+                // apply.
+                VM.load(uuid, {log: log}, function (err, newobj) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    new_vmobj = newobj;
+                    cb();
+                });
+            }, function (cb) {
+                applyUpdates(vmobj, new_vmobj, payload, log, function () {
+                    cb();
+                });
+            }, function (cb) {
+                // Update the firewall data
+                updateFirewallData(payload, new_vmobj, log, cb);
+            }
+        ], function (e) {
+            done(e);
+        });
+    }
 };
 
 function halt(uuid, log, callback)
 {
-    var load_fields;
     var tracers_obj;
+    var vs;
+    var vmobj;
     var unset_autoboot = 'set autoboot=false';
 
     assert(log, 'no logger passed to halt()');
@@ -13413,69 +14829,134 @@ function halt(uuid, log, callback)
 
     log.info('Killing VM ' + uuid);
 
-    load_fields = [
-        'brand',
-        'state',
-        'transition_to',
-        'uuid'
-    ];
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // ensure the vm exists
+            var load_fields = [
+                'brand',
+                'state',
+                'transition_to',
+                'uuid'
+            ];
 
-    /* We load here to ensure this vm exists. */
-    VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
-        if (err) {
-            callback(err);
-            return;
-        }
+            VM.load(uuid, {fields: load_fields, log: log},
+                function (err, _vmobj) {
 
-        if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
-            unset_autoboot =
-                'select attr name=vm-autoboot; set value=false; end';
-        }
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                vmobj = _vmobj;
+
+                if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
+                    unset_autoboot =
+                        'select attr name=vm-autoboot; set value=false; end';
+                }
+
+                cb();
+            });
+        }, function (_, cb) {
+            // create a vminfod event stream - we use this to make sure the VM
+            // transitions into the "down" state before returning to the caller
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js halt (%s)', uuid),
+                log: log
+            });
+
+            vs.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            var cancel;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid,
+                        vm: {
+                            state: 'stopped'
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancel = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
+                        var msg = trim(fds.stderr);
+
+                        if (msg.match(/zone is already halted$/)) {
+                            // zone is already halted, don't block on vminfod
+                            cancel();
+
+                            // remove transition marker since vm is not running
+                            VM.unsetTransition(vmobj, {log: log}, function () {
+                                var new_err;
+
+                                new_err = new Error(sprintf(
+                                    'VM %s is already not \'running\''
+                                    + ' (currently: %s)',
+                                    vmobj.uuid, vmobj.state));
+                                new_err.code = 'ENOTRUNNING';
+                                cb2(new_err);
+                            });
+                            return;
+                        }
+
+                        if (e) {
+                            // unknown error, don't wait on vminfod
+                            log.error({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to halt VM %s', uuid);
+
+                            cancel();
+                            cb2(e, msg);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'zoneadm halted VM %s', uuid);
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (_, cb) {
+            zonecfg(uuid, [unset_autoboot], {log: log},
+                function (error, unset_fds) {
 
-        zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
-            var msg = trim(fds.stderr);
+                if (error) {
+                    // The vm is dead at this point, erroring out here
+                    // would do no good, so we just log it.
+                    log.error({err: error, stdout: unset_fds.stdout,
+                        stderr: unset_fds.stderr},
+                        'halt(): Failed to %s', unset_autoboot);
+                    cb();
+                    return;
+                }
 
-            if (msg.match(/zone is already halted$/)) {
-                // remove transition marker, since vm is not running now.
-                VM.unsetTransition(vmobj, {log: log}, function () {
-                    var new_err;
+                log.debug({stdout: unset_fds.stdout,
+                    stderr: unset_fds.stderr},
+                    'unset autoboot flag');
 
-                    new_err = new Error('VM ' + vmobj.uuid + ' is already '
-                        + 'not \'running\' (currently: ' + vmobj.state + ')');
-                    new_err.code = 'ENOTRUNNING';
-                    callback(new_err);
-                });
-            } else if (e) {
-                log.error({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                    'failed to halt VM ' + uuid);
-                callback(err, msg);
-            } else {
-                log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                    'zoneadm halted VM ' + uuid);
-                zonecfg(uuid, [unset_autoboot], {log: log},
-                    function (error, unset_fds) {
+                if (vmobj.state !== 'stopping') {
+                    cb();
+                    return;
+                }
 
-                    if (error) {
-                        // The vm is dead at this point, erroring out here would
-                        // do no good, so we just log it.
-                        log.error({err: error, stdout: unset_fds.stdout,
-                            stderr: unset_fds.stderr}, 'halt(): Failed to '
-                            + unset_autoboot);
-                    } else {
-                        log.debug({stdout: unset_fds.stdout,
-                            stderr: unset_fds.stderr}, 'unset autoboot flag');
-                    }
-                    if (vmobj.state === 'stopping') {
-                        // remove transition marker
-                        VM.unsetTransition(vmobj, {log: log}, function () {
-                            callback(null, msg);
-                        });
-                    } else {
-                        callback(null, msg);
-                    }
+                // remove transition marker
+                VM.unsetTransition(vmobj, {log: log}, function () {
+                    cb();
                 });
-            }
-        });
+            });
+        }
+    ]}, function (err, results) {
+        callback(err, results);
     });
 }
 
@@ -13691,7 +15172,7 @@ function doDockerStop(vmobj, options, callback)
     var tracers_obj;
     var waiter;
 
-    assert(vmobj.pid);
+    assert(vmobj.pid, 'vmobj.pid');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('docker-stop', log, callback);
@@ -13849,22 +15330,22 @@ function doVmadmdStop(vmobj, options, callback)
 
             zonecfg(vmobj.uuid, [unset_autoboot], {log: log},
                 function (err, fds) {
-                    if (err) {
-                        // The vm is dead at this point, failing
-                        // here would do no good, so we just log it.
-                        log.error({
-                            err: err,
-                            stdout: fds.stdout,
-                            stderr: fds.stderr
-                        }, 'stop(): Failed to ' + unset_autoboot + ' for '
-                            + vmobj.uuid + ': ' + err.message);
-                    } else {
-                        log.info({stdout: fds.stdout, stderr: fds.stderr},
-                            'Stopped ' + vmobj.uuid);
-                    }
-                    cb();
+
+                if (err) {
+                    // The vm is dead at this point, failing
+                    // here would do no good, so we just log it.
+                    log.error({
+                        err: err,
+                        stdout: fds.stdout,
+                        stderr: fds.stderr
+                    }, 'stop(): Failed to ' + unset_autoboot + ' for '
+                        + vmobj.uuid + ': ' + err.message);
+                } else {
+                    log.info({stdout: fds.stdout, stderr: fds.stderr},
+                        'Stopped ' + vmobj.uuid);
                 }
-            );
+                cb();
+            });
         }
     ], callback);
 }
@@ -13937,21 +15418,10 @@ function doShutdownStop(vmobj, options, callback)
 // options parameter is *REQUIRED* for VM.stop()
 exports.stop = function (uuid, options, callback)
 {
-    var load_fields;
     var log;
     var tracers_obj;
     var vmobj;
-
-    load_fields = [
-        'brand',
-        'docker',
-        'pid',
-        'state',
-        'uuid',
-        'zone_state',
-        'zonename',
-        'zonepath'
-    ];
+    var vs;
 
     if (!options) {
         options = {};
@@ -13992,26 +15462,33 @@ exports.stop = function (uuid, options, callback)
     async.series([
         function (cb) {
             /*
-             * We load here to ensure this vm exists, and so when docker=true
-             * we can handle stop specially. But if we're being called by
-             * something that just loaded the object, we can use that instead.
+             * Create the vminfod event stream here that wil be used below to
+             * block on the VM transitioning into the "stopped" state.  Also,
+             * use the "ready" event to get the vmobj for the VM uuid given
              */
-            if (options.vmobj && options.vmobj.uuid === uuid) {
-                log.info('using cached vmobj that was passed in to VM.stop');
-                vmobj = options.vmobj;
-                cb();
-                return;
-            }
-            VM.load(uuid, {log: log, fields: load_fields}, function (err, obj) {
-                if (err) {
-                    log.error(err);
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js VM.stop (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+            vs.once('ready', function (ready_ev) {
+                var err;
+
+                vmobj = ready_ev.vms[uuid];
+
+                if (!vmobj) {
+                    err = new Error('vm not found: ' + uuid);
+                    log.error({err: err}, err.message);
                     cb(err);
                     return;
-                } else {
-                    vmobj = obj;
-                    cb();
                 }
+
+                cb();
             });
+        },
+        function (cb) {
+            assert.object(vmobj, 'vmobj is not an object');
+            cb();
         }, function (cb) {
             var unset_autoboot = 'set autoboot=false';
 
@@ -14032,96 +15509,138 @@ exports.stop = function (uuid, options, callback)
                         'Error setting autoboot=false');
                     cb(e);
                     return;
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'set autoboot=false');
                 }
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'set autoboot=false');
                 cb();
             });
         }, function (cb) {
             var new_err;
 
-            if (vmobj.state !== 'running') {
-                new_err = new Error('VM ' + vmobj.uuid + ' is already '
-                    + 'not \'running\' (currently: ' + vmobj.state + ')');
-                new_err.code = 'ENOTRUNNING';
-                cb(new_err);
-            } else {
+            if (vmobj.state === 'running') {
                 cb();
+                return;
             }
+
+            new_err = new Error('VM ' + vmobj.uuid + ' is already '
+                + 'not \'running\' (currently: ' + vmobj.state + ')');
+            new_err.code = 'ENOTRUNNING';
+            cb(new_err);
         }, function (cb) {
-            var timeoutErr;
+            var cancel;
 
-            if (vmobj.docker) {
-                /*
-                 * When a zone has the 'docker=true' flag set, we want to stop
-                 * it the way docker does.
-                 */
-                if (!options.timeout) {
-                    options.timeout = 10;
-                }
-                doDockerStop(vmobj, {
-                    log: log,
-                    timeout: options.timeout
-                }, cb);
-            } else if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
-                /*
-                 * When use_vm_autoboot, the VM will use vmadmd to perform the
-                 * stop and will not use the 'autoboot' flag in the zonecfg.
-                 * Instead we'll use the 'vm-autoboot' attr to determine whether
-                 * the zone should be booted or not at GZ reboot.
-                 */
-                if (!options.timeout) {
-                    options.timeout = 180;
-                }
-                doVmadmdStop(vmobj, {
-                    log: log,
-                    timeout: options.timeout,
-                    transition_to: options.transition_to
-                }, cb);
-            } else {
-                // timeout is not supported for non-KVM + non-docker
-                if (options.timeout) {
-                    timeoutErr = new Error('Timeout option is only supported '
-                        + 'for KVM and docker containers.');
-                    log.warn({err: timeoutErr}, 'invalid timeout option');
-                    cb(timeoutErr);
-                    return;
-                }
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['state'],
+                            to: 'stopped'
+                        }
+                    ];
+
+                    if (BRAND_OPTIONS[vmobj.brand].features.type !== 'KVM') {
+                        changes.push([
+                            {
+                                path: ['exit_timestamp'],
+                                action: 'added'
+                            },
+                            {
+                                path: ['exit_status'],
+                                action: 'added'
+                            }
+                        ]);
+                    }
 
-                /*
-                 * When we're not using vm-autoboot, we go through the 'normal'
-                 * process of trying to shut a zone down cleanly. We do this by
-                 * calling /usr/sbin/shutdown from within the zone. Note also
-                 * that the BRAND_OPTIONS can substitute a different
-                 * shutdown_cmd for a specific brand.
-                 */
-                doShutdownStop(vmobj, {
-                    log: log
-                }, cb);
-            }
-        }, function (cb) {
-            // Verify it's shut down
-            VM.waitForZoneState(vmobj, 'installed', {log: log},
-                function (err, result) {
+                    /*
+                     * The timeout is specified here as a very large value -
+                     * this will act as a failsafe that *should* never be hit.
+                     * The individual shutdown functions below will set their
+                     * own timeout, and in the event that they are reached this
+                     * block on vminfod will be cancelled.
+                     */
+                    var opts = {
+                        timeout: 300 * 1000,
+                        catchErrors: true,
+                        teardown: false
+                    };
 
-                if (err) {
-                    if (err.code === 'ETIMEOUT') {
-                        log.info(err, 'timeout waiting for zone to go to '
-                            + '"installed"');
+                    cancel = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var timeoutErr;
+
+                    if (vmobj.docker) {
+                        /*
+                         * When a zone has the 'docker=true' flag set, we want
+                         * to stop it the way docker does.
+                         */
+                        if (!options.timeout) {
+                            options.timeout = 10;
+                        }
+                        doDockerStop(vmobj, {
+                            log: log,
+                            timeout: options.timeout
+                        }, done);
+                    } else if (BRAND_OPTIONS[vmobj.brand].
+                        features.use_vm_autoboot) {
+                        /*
+                         * When use_vm_autoboot, the VM will use vmadmd to
+                         * perform the stop and will not use the 'autoboot'
+                         * flag in the zonecfg. Instead we'll use the
+                         * 'vm-autoboot' attr to determine whether the zone
+                         * should be booted or not at GZ reboot.
+                         */
+                        if (!options.timeout) {
+                            options.timeout = 180;
+                        }
+                        doVmadmdStop(vmobj, {
+                            log: log,
+                            timeout: options.timeout,
+                            transition_to: options.transition_to
+                        }, done);
                     } else {
-                        log.error(err, 'unknown error waiting for zone to go'
-                            + ' "installed"');
+                        // timeout is not supported for non-KVM + non-docker
+                        if (options.timeout) {
+                            timeoutErr = new Error('Timeout option is only '
+                                + 'supported for KVM and docker containers.');
+                            log.warn({err: timeoutErr},
+                                'invalid timeout option');
+                            done(timeoutErr);
+                            return;
+                        }
+
+                        /*
+                         * When we're not using vm-autoboot, we go through the
+                         * 'normal' process of trying to shut a zone down
+                         * cleanly. We do this by calling /usr/sbin/shutdown
+                         * from within the zone. Note also that the
+                         * BRAND_OPTIONS can substitute a different
+                         * shutdown_cmd for a specific brand.
+                         */
+                        doShutdownStop(vmobj, {
+                            log: log
+                        }, done);
+                    }
+
+                    function done(err) {
+                        if (err) {
+                            cancel();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
                     }
-                    cb(err);
-                } else {
-                    // zone got to stopped
-                    log.info('VM seems to have switched to "installed"');
-                    cb();
                 }
-            });
+            ]}, cb);
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         callback(err);
     });
 };
@@ -14255,9 +15774,10 @@ function reset(uuid, log, callback)
                 if (e) {
                     callback(new Error('Unable to post "reset" to '
                         + 'vmadmd: ' + e.message));
-                } else {
-                    callback();
+                    return;
                 }
+
+                callback();
             });
         } else {
             zoneadm(['-u', vmobj.uuid, 'reboot', '-X'], log, function (e, fds) {
@@ -14265,11 +15785,12 @@ function reset(uuid, log, callback)
                     log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
                         'zoneadm failed to reboot VM ' + vmobj.uuid);
                     callback(new Error(rtrim(fds.stderr)));
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'zoneadm rebooted VM ' + vmobj.uuid);
-                    callback();
+                    return;
                 }
+
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'zoneadm rebooted VM ' + vmobj.uuid);
+                callback();
             });
         }
     });
@@ -14354,7 +15875,6 @@ function doReboot(vmobj, options, callback)
                         cleanup = null;
                     }
                 }
-
                 reboot_complete = true;
             }
         }, cb);
@@ -14370,9 +15890,10 @@ function doReboot(vmobj, options, callback)
             VM.stop(vmobj.uuid, options, function (err) {
                 if (err) {
                     cb(err);
-                } else {
-                    cb();
+                    return;
                 }
+
+                cb();
             });
         } else {
             // non-KVM zones
@@ -14392,9 +15913,9 @@ function doReboot(vmobj, options, callback)
                         + ' exited with code' + err.code + ': '
                         + err.message);
                     cb(err);
-                } else {
-                    cb();
+                    return;
                 }
+                cb();
             });
         }
     }, function (cb) {
@@ -14404,33 +15925,32 @@ function doReboot(vmobj, options, callback)
         if (reboot_async) {
             cb();
             return;
-        } else {
-            ticks = 180 * 10; // (180 * 10) 100ms ticks = 3m
-            ival = setInterval(function () {
-                if (reboot_complete) {
-                    log.debug('reboot marked complete, cleaning up');
-                    clearInterval(ival);
-                    if (cleanup) {
-                        cleanup();
-                        cleanup = null;
-                    }
-                    cb();
-                    return;
+        }
+        ticks = 180 * 10; // (180 * 10) 100ms ticks = 3m
+        ival = setInterval(function () {
+            if (reboot_complete) {
+                log.debug('reboot marked complete, cleaning up');
+                clearInterval(ival);
+                if (cleanup) {
+                    cleanup();
+                    cleanup = null;
                 }
-                ticks--;
-                if (ticks <= 0) {
-                    // timed out
-                    log.debug('reboot timed out, cleaning up');
-                    clearInterval(ival);
-                    if (cleanup) {
-                        cleanup();
-                        cleanup = null;
-                    }
-                    cb(new Error('timed out waiting for zone to reboot'));
-                    return;
+                cb();
+                return;
+            }
+            ticks--;
+            if (ticks <= 0) {
+                // timed out
+                log.debug('reboot timed out, cleaning up');
+                clearInterval(ival);
+                if (cleanup) {
+                    cleanup();
+                    cleanup = null;
                 }
-            }, 100);
-        }
+                cb(new Error('timed out waiting for zone to reboot'));
+                return;
+            }
+        }, 100);
     }], function (err) {
         if (cleanup) {
             cleanup();
@@ -14593,9 +16113,9 @@ exports.sysrq = function (uuid, req, options, callback)
             if (e) {
                 callback(new Error('Unable to post "sysrq" to vmadmd: '
                     + e.message));
-            } else {
-                callback();
+                return;
             }
+            callback();
         });
     });
 };
@@ -14699,6 +16219,111 @@ exports.console = function (uuid, options, callback)
     });
 };
 
+exports.events = function events(opts, handler, cb) {
+    var log;
+    var tracers_obj;
+
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.optionalString(opts.zonename, 'opts.zonename');
+    assert.optionalString(opts.name, 'opts.name');
+    assert.func(handler, 'handler');
+    assert.func(cb, 'cb');
+
+    ensureLogging(true);
+    if (opts.hasOwnProperty('log')) {
+        log = opts.log;
+    } else {
+        log = VM.log.child({action: 'events'});
+    }
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('install', log, cb);
+        cb = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    // Construct name to use for vminfod requests and logging
+    var name = 'VM.js events';
+    if (opts.zonename) {
+        name += sprintf(' (zonename: %s)', opts.zonename);
+    }
+    if (process.env.REQ_ID) {
+        name += sprintf(' - (req_id: %s)', process.env.REQ_ID);
+    }
+    if (opts.name) {
+        name += sprintf(' - %s', opts.name);
+    }
+
+    log = log.child({ident: name});
+    var vs = new vminfod.VminfodEventStream({
+        name: name,
+        parseReady: true,
+        log: log
+    });
+
+    vs.once('ready', function (ready_ev) {
+        log.debug('vminfod event stream ready');
+
+        var obj = {
+            ev: ready_ev,
+            stop: stop
+        };
+
+        /*
+         * If the user wants to watch a specific VM, ensure it exists and error
+         * early if it does not.
+         */
+        if (opts.zonename && !ready_ev.vms.hasOwnProperty(opts.zonename)) {
+            stop();
+            cb(new Error(sprintf('VM %s not found', opts.zonename)));
+            return;
+        }
+
+        cb(null, obj);
+    });
+
+    vs.on('readable', function () {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            processVminfodEvent(ev);
+        }
+    });
+
+    function processVminfodEvent(ev) {
+        log.trace({ev: ev}, 'vminfod event');
+
+        if (opts.zonename && opts.zonename !== ev.zonename) {
+            return;
+        }
+
+        handler(ev);
+    }
+
+    function stop() {
+        log.debug('stop called');
+        vs.stop();
+    }
+};
+
+function calculateZonepath(vmobj) {
+    var err;
+
+    assert.object(vmobj, 'vmobj');
+
+    if (vmobj.hasOwnProperty('zonepath')) {
+        return (vmobj.zonepath);
+    } else if (vmobj.hasOwnProperty('zpool')
+        && vmobj.hasOwnProperty('zonename')) {
+
+        return ('/' + vmobj.zpool + '/' + vmobj.zonename);
+    }
+
+    err = new Error('unable to find zonepath for ' + vmobj.uuid);
+    err.vmobj = vmobj;
+    throw err;
+}
+
 function zlogObjToString(obj) {
     assert.object(obj, 'zlogObjToString obj');
     assert.optionalBool(obj.gz, 'zlogObjToString obj.gz');
@@ -14795,3 +16420,12 @@ function calculateZlogModeAndDriver(payload, vmobj) {
         driver: log_driver
     };
 }
+
+function deepEqual(a, b) {
+    try {
+        assert.deepEqual(a, b);
+        return true;
+    } catch (e) {
+        return false;
+    }
+}
diff --git a/src/vm/node_modules/diff.js b/src/vm/node_modules/diff.js
new file mode 100644
index 00000000..54149d1a
--- /dev/null
+++ b/src/vm/node_modules/diff.js
@@ -0,0 +1,505 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * "diff" 2 JavaScript objects
+ *
+ * var a = {
+ *     foo: true,
+ *     num: 1
+ * };
+ * var b = {
+ *     bar: true,
+ *     num: 2
+ * };
+ * var changes = diff(a, b);
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "foo",
+ *     "path": ["foo"],
+ *     "action": "removed",
+ *     "from": true
+ *   },
+ *   {
+ *     "prettyPath": "num",
+ *     "path": ["num"],
+ *     "action": "changed",
+ *     "from": 1,
+ *     "to": 2
+ *   },
+ *   {
+ *     "prettyPath": "bar",
+ *     "path": ["bar"],
+ *     "action": "added",
+ *     "to": true
+ *   }
+ * ]
+ *
+ * On top of this basic functionality, this function also supports comparing
+ * objects for modifications based on an "identifierKey" supplied in a map.
+ *
+ * Consider the following two objects.
+ *
+ * var a = {
+ *     disks: [
+ *         {
+ *             name: "foo",
+ *             size: 10
+ *         }
+ *     ]
+ * };
+ * var b = {
+ *     disks: [
+ *         {
+ *             name: "foo",
+ *             size: 20
+ *         }
+ *     ]
+ * };
+ *
+ * Looking at these objects, we can see that the "disks" array has a single
+ * object with both a name and size - only the size has changed from 10 to 20.
+ * Running these objects through diff() without a map yields:
+ *
+ * var changes = diff(a, b);
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "disks.*",
+ *     "path": [
+ *       "disks",
+ *       null
+ *     ],
+ *     "action": "removed",
+ *     "from": {
+ *       "name": "foo",
+ *       "size": 10
+ *     }
+ *   },
+ *   {
+ *     "prettyPath": "disks.*",
+ *     "path": [
+ *       "disks",
+ *       null
+ *     ],
+ *     "action": "added",
+ *     "to": {
+ *       "name": "foo",
+ *       "size": 20
+ *     }
+ *   }
+ * ]
+ *
+ * Note that `null` in the `path` array means any element of the array, as
+ * this module doesn't concern itself with the indices of an array or array
+ * sort order.
+ *
+ * diff() reports that an entire object was removed from the "disks" array
+ * and replaced with a new object.  If we know ahead of time that a key
+ * (like "disks") is guaranteed to be an array of objects, we can give diff()
+ * a "map" where we can specify that "disks" -> "name"... meaning "disks"
+ * is an array of objects where "name" is a key that represents a unique
+ * identifier for the object.  This way, we can determine if an object
+ * was removed completely, or just modified in place.
+ *
+ * var map = {
+ *     disks: 'name'
+ * };
+ * var changes = diff(a, b, {map: map});
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "disks.*.size",
+ *     "path": [
+ *       "disks",
+ *       null,
+ *       "size"
+ *     ],
+ *     "action": "changed",
+ *     "from": 10,
+ *     "to": 20,
+ *     "ident": "foo"
+ *   }
+ * ]
+ *
+ * With the map supplied, only one change is reported (the size).  The "ident"
+ * key shows the value of the identifierKey for the object modified (in this
+ * case, the value of the disks "name" attribute).
+ *
+ * The keys given in the "map" object are only applied to the base object
+ * given, meaning an initial object like this won't use the map.
+ *
+ * var a = {
+ *     "root": {
+ *         "disks": [
+ *             {
+ *                 "name": "foo"
+ *             }
+ *         ]
+ *     }
+ * };
+ *
+ * As the base key considered by the map in this example is "root".
+ *
+ */
+
+var assert = require('/usr/node/node_modules/assert-plus');
+
+/*
+ * This is the entry point into this module.
+ *
+ * This function will determine the appropriate internal diffing function to
+ * call based on the input paramaters.
+ *
+ * The folliwng data types are supported by this module.
+ *
+ * - Primitives (number, string, boolean)
+ * - Array
+ * - Object
+ * - Date
+ * - null
+ * - undefined
+ *
+ * Any other data type may or may not yield unexpected results.
+ *
+ * opts is an optional object that may contain
+ *
+ *   - opts.map    A key->value mapping used for determining object differencs,
+ *                 more information about this can be found in this files block
+ *                 comment
+ *   - opts.prefix An array to keep track of how deep into an object we
+ *                 currently are.  This variable is created and maintaned by
+ *                 the internal diffing functions like objDiff and arrayDiff
+ *                 and should not be provided by the caller.
+ */
+function diff(a, b, opts) {
+    if (theSameValue(a, b)) {
+        return [];
+    } else if (Array.isArray(a) && Array.isArray(b)) {
+        return arrayDiff.apply(this, arguments);
+    } else {
+        return objDiff.apply(this, arguments);
+    }
+}
+
+/*
+ * Compare two objects - called by diff()
+ *
+ * opts is the same object document in the diff() function
+ */
+function objDiff(a, b, opts) {
+    var changes = [];
+    var prefix;
+
+    opts = opts || {};
+    opts.map = opts.map || {};
+    prefix = opts.prefix || [];
+
+    assert.object(opts, 'opts');
+    assert.object(opts.map, 'opts.map');
+    assert.array(prefix, 'prefix');
+
+    if (theSameValue(a, b))
+        return [];
+
+    assert.object(a, 'a');
+    assert.object(b, 'b');
+
+    // loop all keys on the a (from) side
+    Object.keys(a).forEach(function loopFromObject(key) {
+        var nestOpts = {};
+        var path = prefix.concat(key);
+        var prettyPath = toDotNotation(path);
+
+        // if the key is not in b, it was removed
+        if (!hasProperty(b, key)) {
+            changes.push({
+                prettyPath: prettyPath,
+                path: path,
+                action: 'removed',
+                from: a[key]
+            });
+            return;
+        }
+
+        // if the value in a is the same as the value in b, there was no change
+        // so we move on
+        if (theSameValue(a[key], b[key]))
+            return;
+
+        // if either key in a or b is not an object, then the value has changed
+        if (typeof (a[key]) !== 'object'
+            || typeof (b[key]) !== 'object') {
+
+            changes.push({
+                prettyPath: prettyPath,
+                path: path,
+                action: 'changed',
+                from: a[key],
+                to: b[key]
+            });
+
+            return;
+        }
+
+        // both values are objects (maybe Array), compare recursively
+        Object.keys(opts).forEach(function loopOpts(k) {
+            nestOpts[k] = opts[k];
+        });
+        nestOpts.prefix = path;
+
+        diff(a[key], b[key], nestOpts, key).forEach(
+            function loopNestedChanges(change) {
+
+            changes.push(change);
+        });
+    });
+
+    // loop all keys in the b (to) side to find any additions
+    Object.keys(b).forEach(function loopToObject(key) {
+        if (hasProperty(a, key))
+            return;
+
+        var path = prefix.concat(key);
+        var prettyPath = toDotNotation(path);
+
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'added',
+            to: b[key]
+        });
+    });
+
+    return changes;
+}
+
+/*
+ * Compare two arrays - called by diff()
+ *
+ * opts is the same object document in the diff() function
+ *
+ * key is optional and not to be passed by the consumer.  If key is set, it
+ * means the array we are currently calculating the differences for was nested
+ * inside an object under this key.  Using this information, we can determine
+ * if the "map" (if set) should be used to calculate differences.
+ */
+function arrayDiff(a, b, opts, key) {
+    var aSerialized;
+    var bSerialized;
+    var changes = [];
+    var identifierKey;
+    var modified = [];
+    var path;
+    var possiblyAdded = [];
+    var possiblyRemoved = [];
+    var prefix;
+    var prettyPath;
+
+    opts = opts || {};
+    opts.map = opts.map || {};
+    prefix = opts.prefix || [];
+
+    assert.array(a, 'a');
+    assert.array(b, 'b');
+    assert.object(opts, 'opts');
+    assert.object(opts.map, 'opts.map');
+    assert.array(prefix, 'prefix');
+
+    // because we are inside an array, we add `null` to the end of the current
+    // path.
+    path = prefix.concat(null);
+    prettyPath = toDotNotation(path);
+
+    // check if we should use the "map" for this array
+    if (key && path.length === 2 && hasProperty(opts.map, key))
+        identifierKey = opts.map[key];
+
+    // serialize everything in a and b to compare directly as strings
+    aSerialized = a.map(function serializeArrayA(o) {
+        return JSON.stringify(o);
+    });
+    bSerialized = b.map(function serializeArrayB(o) {
+        return JSON.stringify(o);
+    });
+
+    // all values in a not found in b have been possibly removed
+    aSerialized.forEach(function checkRemoved(o, i) {
+        if (bSerialized.indexOf(o) >= 0)
+            return;
+
+        possiblyRemoved.push(i);
+    });
+
+    // all values in b not found in a have been possibly added
+    bSerialized.forEach(function checkAdded(o, j) {
+        if (aSerialized.indexOf(o) >= 0)
+            return;
+
+        possiblyAdded.push(j);
+    });
+
+    // if an identifierKey is found - meaning the arrays we are looking at
+    // were found inside an object with a given "key" (4th arg), we treat
+    // every element inside the array as an object, and look for an
+    // "identifier" object to compare
+    if (identifierKey) {
+        possiblyRemoved = possiblyRemoved.filter(function filterRemoved(i) {
+            var found = false;
+            var oi = a[i];
+
+            assert.object(oi, 'must be an object: ' + JSON.stringify(oi));
+
+            possiblyAdded = possiblyAdded.filter(function filterAdded(j) {
+                var oj = b[j];
+
+                assert.object(oi, 'must be an object');
+
+                if (found)
+                    return true;
+
+                if (oi[identifierKey] === oj[identifierKey]) {
+                    found = true;
+
+                    // to be processed recursively below
+                    modified.push({
+                        a: oi,
+                        b: oj,
+                        ident: oi[identifierKey]
+                    });
+                    return false;
+                }
+
+                return true;
+            });
+
+            return !found;
+        });
+    }
+
+    // add the changes to the changes array to be returned
+    possiblyRemoved.forEach(function pushRemovedChanges(i) {
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'removed',
+            from: a[i]
+        });
+    });
+    modified.forEach(function pushModifiedChanges(mod) {
+        // mod.a and mod.b are guaranteed to be objects
+        var _changes = objDiff(mod.a, mod.b, {prefix: path});
+        _changes.forEach(function pushModifiedChange(change) {
+            change.ident = mod.ident;
+            changes.push(change);
+        });
+    });
+    possiblyAdded.forEach(function pushAddedChanges(j) {
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'added',
+            to: b[j]
+        });
+    });
+
+    return changes;
+}
+
+/*
+ * Check if 2 primitive values are tha same
+ */
+function theSameValue(a, b) {
+    if (a === b)
+        return true;
+
+    if (a instanceof Date && b instanceof Date)
+        return theSameValue(a.getTime(), b.getTime());
+
+    return false;
+}
+
+/*
+ * Convert a "path" (given as an array) to a pretty-formatted dot-notation
+ * string. This is solely meant for producing a human-readable path in the
+ * "changes" array given from any object or array diff.  Examples
+ *
+ * > toDotNotation(['disks', 0, 'name'])
+ * => 'disks.0.name'
+ *
+ * > toDotNotation(['disks', null, 'name']);
+ * => 'disks.*.name'
+ *
+ * > toDotNotation(['nics', '192.168.1.1', 'name'])
+ * => 'nics[192.168.1.1].name'
+ *
+ */
+function toDotNotation(arr) {
+    var s = '';
+
+    assert.array(arr, 'arr');
+
+    arr.forEach(function loopPathElements(elem) {
+        if (elem === null)
+            elem = '*';
+        elem = '' + elem;
+
+        if (elem.match(/[\.\[\]]/)) {
+            elem = elem.replace(/([\[\]])/g, '\\$1');
+            s += '[' + elem + ']';
+            return;
+        }
+
+        if (s.length > 0)
+            s += '.';
+        s += elem;
+    });
+    return s;
+}
+
+/*
+ * safe hasOwnProperty
+ */
+function hasProperty(o, p) {
+    return ({}).hasOwnProperty.call(o, p);
+}
+
+module.exports = diff;
+
+function main() {
+    var read = require('fs').readFileSync;
+    var a = JSON.parse(read(process.argv[2]));
+    var b = JSON.parse(read(process.argv[3]));
+
+    var opts;
+    if (process.argv[4])
+        opts = JSON.parse(read(process.argv[4]));
+    var key = process.argv[5];
+
+    var changes = diff(a, b, opts, key);
+    console.log(JSON.stringify(changes, null, 2));
+}
+
+if (require.main === module)
+    main();
diff --git a/src/vm/node_modules/expander.js b/src/vm/node_modules/expander.js
index 90ade844..a9b32012 100644
--- a/src/vm/node_modules/expander.js
+++ b/src/vm/node_modules/expander.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2015, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -185,6 +185,9 @@ Object.keys(proptable.properties).forEach(function (prop) {
 
     if (property.payload) {
         payload_prop = {pr_type: property.payload.type};
+        if (property.payload.hasOwnProperty('default')) {
+            payload_prop['pr_default'] = property.payload.default;
+        }
         if (property.payload.hasOwnProperty('check_as')) {
             payload_prop['pr_check_as'] = property.payload.check_as;
         }
diff --git a/src/vm/node_modules/fswatcher.js b/src/vm/node_modules/fswatcher.js
new file mode 100644
index 00000000..1def4b7e
--- /dev/null
+++ b/src/vm/node_modules/fswatcher.js
@@ -0,0 +1,927 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * This module exists to watch files for changes. It is somewhat similar to
+ * node's fs.watch except:
+ *
+ *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
+ *    it actually starts watching.
+ *  * FsWatcher works with files that do not exist yet, notifying you when they
+ *    are created.
+ *
+ * To use you should do something like:
+ *
+ *  var fsw = new FsWatcher({log: log});
+ *  fsw.once('ready', function ready() {
+ *      fsw.watch('/path/to/some/file', function (err) { ... });
+ *      fsw.unwatch('/path/to/some/file', function (err) { ... });
+ *      fsw.status(function (err, obj) { ... });
+ *      fsw.stop();
+ *  });
+ *  fsw.on(<event type>, callback(event));
+ *  fsw.start();
+ *
+ * Where the event types can be:
+ *
+ *  * event - for any event
+ *  * create - emitted when a file is created
+ *  * change - emitted when a file is modified
+ *  * delete - emitted when a file is deleted
+ *
+ * How this works:
+ *
+ *   This module is a wrapper around the fswatcher tool. That tool is driven by
+ *   commands on STDIN which start and stop watches on files. Output goes to
+ *   STDOUT (as json)  and is scraped by this module and turned into events.
+ *
+ * When `fsw.start()` is called, the companion fswatcher C program is started,
+ * and a 'ready' event is emitted when the program is fully loaded and ready to
+ * start receiving input.  Once it is ready, you may call .watch, .unwatch,
+ * etc.
+ *
+ * When a file watch is attempted, the command to watch it is sent to the
+ * fswatcher C program.  If it succeeds, the callback is fired immediately
+ * and any new events for the file will be emitted when they are seen.  If
+ * it fails however, a successful callback is still fired, but the file
+ * is moved to a retry "interval".  The term interval is used here, but it's
+ * actually a JavaScript setTimeout under the hood that calls itself as part
+ * of the retry logic.
+ *
+ * The common case is, when a .watch() command is given, the file we want to
+ * watch either exists or will exist very soon.  Because of this, if the initial
+ * watch fails, that file specifically will be retried (the WATCH command sent
+ * to the fswatcher program again) 10 times every 200ms - this is called the
+ * INITIAL_WATCH_INTERVAL.  If it succeeds during this time, the timeout will
+ * be cleared and a 'create' event for the file will be emitted.
+ *
+ * If the file fails the INITIAL_WATCH_INTERVAL, it will move over to the
+ * LONG_WATCH_INTERVAL.  This is an interval (again, actually a setTimeout
+ * that calls itself when finished) that runs every 10 seconds to retry every
+ * file that does not yet exist.  This is a single interval that runs every
+ * 5 seconds no matter what, and loops every file that we want to watch but
+ * does not yet exist.  When a WATCH command succeeds for a file in this
+ * interval it is removed from the "not_yet_watching" list and a 'create'
+ * event for the file be emitted.
+ *
+ */
+
+var cp = require('child_process');
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var LineStream = require('/usr/node/node_modules/linestream');
+var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
+var vasync = require('/usr/vm/node_modules/vasync');
+
+/*
+ * when a file is watched but does not yet exist, FsWatcher will default to
+ * retry watching the file INITIAL_WATCH_TRIES (10) tries every
+ * INITIAL_WATCH_DELAY (200) milliseconds before transitioning the file to the
+ * long watch interval.
+ */
+var INITIAL_WATCH_DELAY = 200;
+var INITIAL_WATCH_TRIES = 10;
+
+/*
+ * when a file fails to be watched during its own initial watch interval it
+ * will be transferred to a longer class-wide interval that tries to watch all
+ * unwatched files every LONG_WATCH_DELAY (10000) milliseconds.
+ */
+var LONG_WATCH_DELAY = 10 * 1000;
+
+// fswatcher.c can handle 2^64, but to be safe with JavaScript we restrict the
+// maximum key.
+var FSWATCHER_MAX_KEY = Math.pow(2, 32);
+
+// illegal characters for filenames - this limitation is in fswatcher.c
+var ILLEGAL_FILENAME_CHARS = ['\n', '\0'];
+
+// number of fswatcher stderr lines to hold in memory
+var FSWATCHER_STDERR_LINES = 100;
+
+// companion C program that is our interface to event ports
+var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
+if (process.env.FSWATCHER_CMD) {
+    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
+}
+
+// default logger if left unspecified
+var LOG = bunyan.createLogger({
+    level: 'debug',
+    name: 'fswatcher',
+    streams: [
+    {
+        stream: process.stderr,
+        level: 'debug'
+    }
+    ],
+    serializers: bunyan.stdSerializers
+});
+
+function noop() {}
+
+/*
+ * Create an FsWatcher instance
+ */
+function FsWatcher(opts) {
+    var self = this;
+
+    EventEmitter.call(self);
+
+    opts = opts || {};
+    self.log = opts.log || LOG;
+
+    assert.object(opts, 'opts');
+    assert.object(self.log, 'opts.log');
+    assert.optionalBool(opts.dedup, 'opts.dedup');
+    assert.optionalNumber(opts.initial_watch_delay,
+        'opts.initial_watch_delay');
+    assert.optionalNumber(opts.initial_watch_tries,
+        'opts.initial_watch_tries');
+    assert.optionalNumber(opts.long_watch_delay, 'opts.long_watch_delay');
+
+    // turned on when .stop() is issue and off when the process exits
+    self.stopping = false;
+
+    // if we should dedup events from the same time (millisecond resolution)
+    self.dedup = opts.dedup;
+
+    // files currently being watched
+    self.watching = {};
+
+    // files that need to be watched but don't exist yet
+    self.not_yet_watching = {};
+
+    // fswatcher stderr lines generated
+    self.stderr_buffer = new RingBuffer({limit: FSWATCHER_STDERR_LINES});
+
+    // see comments at the top of this file for "default values" for information
+    // on these variables
+    self.initial_watch_delay = opts.initial_watch_delay || INITIAL_WATCH_DELAY;
+    self.initial_watch_tries = opts.initial_watch_tries || INITIAL_WATCH_TRIES;
+    self.long_watch_delay = opts.long_watch_delay || LONG_WATCH_DELAY;
+}
+util.inherits(FsWatcher, EventEmitter);
+
+/*
+ * start the long interval
+ */
+FsWatcher.prototype.start = function start() {
+    var self = this;
+
+    assert(!self.isRunning(), 'already running');
+
+    self.cur_request_key = 0;
+    self.pending_actions = {};
+
+    /*
+     * We store the previous event seen to use for deduplication purposes -
+     * if the same exact event is seen within the same millisecond every event
+     * after the first is thrown out.
+     */
+    self.prev_event = null;
+
+    // no matter what, this loop runs to watch any unwatched files
+    function long_watch_interval() {
+        self._watchUnwatchedFiles(function _watchUnwatchedFilesDone() {
+            self.long_watch_timeout = setTimeout(long_watch_interval,
+                self.long_watch_delay);
+        });
+    }
+    self.long_watch_timeout = setTimeout(long_watch_interval,
+        self.long_watch_delay);
+
+    // start the companion C program
+    self.watcher = cp.spawn(FSWATCHER_CMD, ['-r', '-j'], {stdio: 'pipe'});
+    self.watcher_pid = self.watcher.pid;
+
+    /*
+     * stdout is newline separated JSON.  It is broken into lines here and each
+     * raw line (String) is pushed on the vasync res_queue that handles parsing
+     * and processing it.  A queue is used to add a callback to processing a
+     * single line of stdout - this way, any async work required by a stdout
+     * line is handled before the line is processed.
+     */
+    var stdoutls = new LineStream();
+    self.watcher.stdout.pipe(stdoutls).on('readable', function stdoutReady() {
+        var line;
+        while ((line = stdoutls.read()) !== null) {
+            self.log.trace({line: line}, 'fswatcher stdout line');
+            self.res_queue.push(line);
+        }
+    });
+
+    /*
+     * stderr can contain useful debugging information from the fswatcher
+     * program, so all lines are output via log.trace(), and the last
+     * FSWATCHER_STDERR_LINES lines are stored in a ring buffer and printed if
+     * a fatal error occurs
+     */
+    var stderrls = new LineStream();
+    self.watcher.stderr.pipe(stderrls).on('readable', function stderrReady() {
+        var line;
+        while ((line = stderrls.read()) !== null) {
+            self.log.trace({line: line}, 'fswatcher stderr line');
+            self.stderr_buffer.write(line);
+        }
+    });
+
+    /*
+     * handle watcher exiting.  if this is not the result of .stop(), we error
+     * loudly
+     */
+    self.watcher.on('close', function fswatcherClosed(code, signal) {
+        var e = new Error('fswatcher exited');
+        e.code = code;
+        e.signal = signal;
+        e.pid = self.watcher_pid;
+        e.stderr = self.stderr_buffer.records.join('\n');
+
+        self.stderr_buffer.records = [];
+        self.watcher = null;
+        self.watcher_pid = null;
+
+        if (self.stopping) {
+            self.log.debug({err: e, signal: signal, code: code, pid: e.pid},
+                'fswatcher exited');
+            assert.func(self.stop_cb, 'stop() not called');
+            self.stop_cb();
+            delete self.stop_cb;
+            self.stopping = false;
+        } else {
+            assert(!self.stop_cb, 'stop cb set without .stop() being called');
+            self.log.error({err: e, signal: signal, code: code, pid: e.pid},
+                'fswatcher exited');
+            self.log.error({dump: self.dump()},
+                'fswatcher .dump()');
+            self.log.error({stderr: e.stderr}, 'fswatcher stderr');
+            self.emit('error', e);
+        }
+    });
+
+    /*
+     * allow the consumer of this module to watch for errors with the child
+     * process
+     */
+    self.watcher.on('error', function fswatchError(err) {
+        self.log.error({err: err}, 'fswatcher error');
+        self.emit('error', err);
+    });
+
+    /*
+     * this queue handles line-by-line stdout responses from the fswatcher.c
+     * program
+     */
+    self.res_queue = vasync.queue(function stdoutQueue(line, cb) {
+        var err;
+        var ms1;
+        var ms2;
+        var obj;
+
+        if (!self.isRunning()) {
+            self.log.warn({line: line},
+                'stdout received while not running');
+            cb();
+            return;
+        }
+
+        try {
+            obj = JSON.parse(line);
+            assert.string(obj.type, 'stdout obj.type');
+            assert.arrayOfNumber(obj.time, 'stdout obj.time');
+        } catch (parseErr) {
+            self.log.error({
+                err: parseErr,
+                line: line
+            }, 'BAD JSON');
+            throw parseErr;
+        }
+        self.log.trace({obj: obj}, 'fswatcher event');
+
+        if (self.dedup && self.prev_event !== null) {
+            // convert both monotonic timers to milliseconds for dedup purposes
+            ms1 = (obj.time[0] * 1000) + Math.round(obj.time[1] / 1e6);
+            ms2 = (self.prev_event.time[0] * 1000)
+                + Math.round(self.prev_event.time[1] / 1e6);
+
+            if (self.prev_event.pathname === obj.pathname
+                && self.prev_event.type === obj.type
+                && ms1 === ms2) {
+
+                self.log.debug({obj: obj}, 'discarding duplicate object');
+                process.nextTick(cb);
+                return;
+            }
+        }
+        self.prev_event = deepClone(obj);
+
+        switch (obj.type) {
+        case 'ready':
+            handleReady(obj, cb);
+            break;
+        case 'event':
+            handleEvent(obj, cb);
+            break;
+        case 'response':
+            handleResponse(obj, cb);
+            break;
+        case 'error':
+        default:
+            err = new Error('dispatching error');
+            self.log.warn({err: err, obj: obj}, err.message);
+            throw err;
+        }
+    }, 1);
+
+    function handleReady(obj, cb) {
+        self.emit('ready', obj);
+        cb();
+    }
+
+    function handleEvent(obj, cb) {
+        assert.bool(obj.final, 'obj.final');
+        assert.arrayOfString(obj.changes, 'obj.changes');
+        assert.string(obj.pathname, 'obj.pathname');
+
+        var f = obj.pathname;
+        var w = self.watching[f];
+        assert.object(w, 'not watching ' + obj.pathname);
+
+        // UNWATCH is queued, ignore event
+        if (!w.active) {
+            cb();
+            return;
+        }
+
+        // fswatcher.c is done watching this file, queue a rewatch
+        if (obj.final) {
+            self.log.debug({f: f}, 'file was final, queueing rewatch');
+            delete self.watching[f];
+            self.watch(f);
+        }
+
+        if (obj.changes.indexOf('FILE_MODIFIED') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_RENAME_TO') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_TRUNC') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_DELETE') !== -1)
+            obj.type = 'delete';
+        if (obj.changes.indexOf('UNMOUNTED') !== -1)
+            obj.type = 'delete';
+
+        if (obj.final && obj.type !== 'delete') {
+            /*
+             * An event marked as "final" means that fswatcher.c will not
+             * attempt to rewatch the file.  It's possible that a file could
+             * be marked as "final" without a "delete" event being seen,
+             * because of the asynchronous nature of filesystem events.
+             *
+             * In this case, we log a warning, and pretend it was a delete -
+             * since the file is effectively gone for our purposes.
+             */
+            self.log.warn({obj: obj}, 'final event seen for non-delete type');
+            obj.type = 'delete';
+        }
+
+        if (obj.type !== 'event')
+            self.emit(obj.type, obj);
+        self.emit('event', obj);
+        cb();
+    }
+
+    function handleResponse(obj, cb) {
+        assert.number(obj.key, 'obj.key');
+        assert.number(obj.code, 'obj.code');
+        assert.string(obj.result, 'obj.result');
+        assert.optionalString(obj.pathname, 'obj.pathname');
+        assert.optionalString(obj.message, 'obj.message');
+        assert.optionalObject(obj.data, 'obj.data');
+
+        var pa = self.pending_actions[obj.key];
+
+        assert.object(pa, 'pending_action ' + obj.key);
+        assert.func(pa.cb, 'pending_action.cb ' + obj.key);
+
+        var t = process.hrtime();
+        var delta = hrtime.hrtimeDeltaPretty(t, pa.started);
+
+        self.log.trace('command %s took %s', pa.cmd, delta);
+
+        pa.cb(null, obj);
+        delete self.pending_actions[obj.key];
+        cb();
+    }
+};
+
+/*
+ * stop watching everything
+ */
+FsWatcher.prototype.stop = function stop(cb) {
+    var self = this;
+
+    assert(self.isRunning(), 'not running');
+    assert(!self.stop_cb, 'stop() aready issued');
+    assert.func(cb, 'cb');
+
+    self.stop_cb = cb;
+    self.stopping = true;
+
+    // stop the watcher
+    self.watcher.kill();
+
+    // clear all watches that haven't been established yet
+    Object.keys(self.not_yet_watching).forEach(function clearNotYetWatching(f) {
+        var o = self.not_yet_watching[f];
+
+        if (o.timeout) {
+            clearTimeout(o.timeout);
+            o.timeout = null;
+        }
+
+        delete self.not_yet_watching[f];
+    });
+
+    // clear all existing watches
+    self.watching = {};
+
+    // stop the long_watch_interval
+    clearTimeout(self.long_watch_timeout);
+    self.long_watch_timeout = null;
+};
+
+/*
+ * watch a file
+ */
+FsWatcher.prototype.watch = function watch(f, cb) {
+    var self = this;
+    cb = cb || noop;
+
+    var initial = true;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(f, 'filename unspecified');
+    assert.func(cb, 'cb');
+
+    // validate filename
+    var e = self._validFilename(f);
+    if (e) {
+        cb(e);
+        return;
+    }
+
+    /*
+     * callback with an error if we've already been instructed to watch this
+     * file
+     */
+    if (self._isWatching(f)) {
+        cb(new Error('already watchng ' + f));
+        return;
+    }
+
+    /*
+     * all new files start off in the 'not_yet_watching' bucket and are moved
+     * to the 'watching' bucket when/if a call to `fs.watch(f)` is successful
+     */
+    self.not_yet_watching[f] = {
+        tries: 0,
+        timeout: null,
+        long_watch: false
+    };
+
+    /*
+     * try to watch the file - this function will call itself multiple times
+     * based on the values set in the constructor if it fails before moving the
+     * file to the long interval
+     */
+    tryWatching();
+
+    function tryWatching() {
+        var o = self.not_yet_watching[f];
+
+        /*
+         * watch was cancelled (probably shutting down or told to unwatch),
+         * just give up
+         */
+        if (o === undefined) {
+            if (initial) {
+                initial = false;
+                cb();
+            }
+            return;
+        }
+
+        o.timeout = null;
+
+        /*
+         * we've tried too many times, just give up and let the long interval
+         * catch it
+         */
+        if (o.tries >= self.initial_watch_tries) {
+            self.log.trace('%s exceeded max tries, moving to long interval', f);
+            o.long_watch = true;
+            if (initial) {
+                initial = false;
+                cb();
+            }
+            return;
+        }
+
+        self._tryWatching(f, function _tryWatching_done(err) {
+            if (err) {
+                o.tries++;
+                o.timeout = setTimeout(tryWatching, self.initial_watch_delay);
+                self.log.trace('%d/%d %s watch failed',
+                    o.tries, self.initial_watch_tries, f);
+                if (initial) {
+                    initial = false;
+                    cb();
+                }
+                return;
+            }
+
+            // watch succeeded!
+            self.watching[f] = {
+                active: true
+            };
+            delete self.not_yet_watching[f];
+
+            var obj = {
+                type: 'create',
+                time: process.hrtime(),
+                pathname: f
+            };
+
+            if (!initial) {
+                self.emit('create', obj);
+                self.emit('event', obj);
+            }
+
+            self.log.trace('%d/%d %s watch succeeded',
+                o.tries, self.initial_watch_tries, f);
+
+            if (initial) {
+                initial = false;
+                cb();
+            }
+        });
+    }
+};
+
+/*
+ * stop watching a file
+ */
+FsWatcher.prototype.unwatch = function unwatch(f, cb) {
+    var self = this;
+    cb = cb || noop;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(f, 'filename unspecified');
+    assert.func(cb, 'cb');
+
+    // validate filename
+    var e = self._validFilename(f);
+    if (e) {
+        cb(e);
+        return;
+    }
+
+    if (self.watching[f]) {
+        if (self.watching[f].active) {
+            self.watching[f].active = false;
+            var cmd = util.format('UNWATCH %s', f);
+            self._sendCommand(cmd, function _sendCommandDone(err, obj) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                delete self.watching[f];
+                cb();
+            });
+        } else {
+            delete self.watching[f];
+            cb();
+        }
+    } else if (self.not_yet_watching[f]) {
+        if (self.not_yet_watching[f].timeout) {
+            clearTimeout(self.not_yet_watching[f].timeout);
+            self.not_yet_watching[f].timeout = null;
+        }
+        delete self.not_yet_watching[f];
+        cb();
+    } else {
+        throw new Error('not watching ' + f);
+    }
+};
+
+/*
+ * Get child process status
+ */
+FsWatcher.prototype.status = function status(cb) {
+    var self = this;
+
+    assert(self.isRunning(), 'not running');
+    assert.func(cb, 'cb');
+
+    self._sendCommand('STATUS', cb);
+};
+
+/*
+ * send stdin to the watcher program and callback when stdout
+ * is receieved.  the `cmd` arg should look something like this:
+ *
+ *   'WATCH /path/to/file|12345'
+ *   'UNWATCH /other/path'
+ *
+ * A key will be prepended to track the request as well as a trailing newline
+ * character.
+ */
+FsWatcher.prototype._sendCommand = function _sendCommand(cmd, cb) {
+    var self = this;
+
+    var key;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(cmd, 'cmd');
+    assert.func(cb, 'cb');
+
+    // ensure no newline is present
+    assert(cmd.indexOf('\n') === -1, util.format('invalid command: "%s"',
+        cmd));
+
+    // generate a unique key for the request, this will let us know
+    // which response is meant for us
+    key = self._nextRequestKey();
+
+    assert(!self.pending_actions[key], 'key already used: ' + key);
+
+    cmd = util.format('%d %s\n', key, cmd);
+
+    // when the response for this key is received, the callback will be called
+    self.pending_actions[key] = {
+        started: process.hrtime(),
+        cmd: cmd,
+        cb: cb
+    };
+
+    // write the command to the watcher
+    self.log.trace({cmd: cmd.trim()}, 'writing to fswatcher stdin');
+    try {
+        self.watcher.stdin.write(cmd);
+    } catch (err) {
+        self.log.error({err: err}, 'failed to write to stdin');
+        delete self.pending_actions[key];
+        cb(err);
+        return;
+    }
+};
+
+/*
+ * generate the next index to use for a request
+ */
+FsWatcher.prototype._nextRequestKey = function _nextRequestKey() {
+    var self = this;
+
+    self.cur_request_key = (self.cur_request_key + 1) % FSWATCHER_MAX_KEY;
+
+    return self.cur_request_key;
+};
+
+
+/*
+ * check if we are, or were instructed to, watch a file
+ */
+FsWatcher.prototype._isWatching = function _isWatching(f) {
+    var self = this;
+
+    assert.object(self.watching, 'self.watching');
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    return hasProperty(self.watching, f)
+        || hasProperty(self.not_yet_watching, f);
+};
+
+/*
+ * validate a filename string
+ *
+ * returns null on success or an Error object on failure
+ */
+FsWatcher.prototype._validFilename = function _validFilename(f) {
+    try {
+        ILLEGAL_FILENAME_CHARS.forEach(function checkFilename(c) {
+            assert.equal(f.indexOf(c), -1, 'filename contains bad char ' + c);
+        });
+    } catch (e) {
+        return e;
+    }
+    return null;
+};
+
+/*
+ * try to watch all unwatched files - this will be called at an interval
+ * specified in the constructor options or at a default of every 5 seconds
+ */
+FsWatcher.prototype._watchUnwatchedFiles =
+    function _watchUnwatchedFiles(cb) {
+
+    var self = this;
+
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    var started_watching = 0;
+    var still_waiting = 0;
+    var then = process.hrtime();
+    var not_yet_watching_keys = Object.keys(self.not_yet_watching);
+
+    vasync.forEachParallel({
+        inputs: not_yet_watching_keys,
+        func: function watchUnwatchedFile(f, cb2) {
+            var o = self.not_yet_watching[f];
+
+            // this interval only looks for files that are in the "long_watch"
+            // bucket
+            if (!o || !o.long_watch) {
+                cb2();
+                return;
+            }
+
+            self._tryWatching(f, function _tryWatchingDone(err) {
+                if (err) {
+                    // watch failed, still waiting for this file to exist
+                    still_waiting++;
+                    cb2();
+                    return;
+                }
+
+                // watch succeeded! we can now emit a 'create' event
+                // and stop waiting on this file to exist
+                self.watching[f] = {
+                    active: true
+                };
+                delete self.not_yet_watching[f];
+                started_watching++;
+
+                var obj = {
+                    type: 'create',
+                    time: process.hrtime(),
+                    pathname: f
+                };
+
+                self.emit('create', obj);
+                self.emit('event', obj);
+
+                cb2();
+            });
+        }
+    }, function _watchUnwatchedFilesDone(err) {
+        var now = process.hrtime();
+        var delta = hrtime.hrtimeDelta(now, then);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+        if (started_watching > 0 || still_waiting > 0) {
+            self.log.debug('FsWatcher _watchUnwatchedFiles: '
+                + 'looped files: %d, started watching: %d, '
+                + 'still waiting: %d, took: %s',
+                not_yet_watching_keys.length,
+                started_watching,
+                still_waiting,
+                prettyDelta);
+        }
+
+        cb();
+    });
+};
+
+/*
+ * send a command to watch the filename given, and callback when the response
+ * is seen.  an error is set if the file fails to watch, and no error on
+ * success
+ */
+FsWatcher.prototype._tryWatching = function _tryWatching(f, cb) {
+    var self = this;
+
+    var cmd = util.format('WATCH %s', f);
+
+    self._sendCommand(cmd, function _sendCommandDone(err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        switch (obj.result) {
+        case 'SUCCESS':
+            cb(null, obj);
+            break;
+        case 'FAIL':
+            cb(new Error(obj.message), obj);
+            break;
+        default:
+            throw new Error('unknown result: ' + obj.result);
+        }
+    });
+};
+
+/*
+ * Returns true if the child process is currently running and a stop() has not
+ * been issued
+ */
+FsWatcher.prototype.isRunning = function isRunning() {
+    var self = this;
+
+    return self.watcher && !self.stopping;
+};
+
+/*
+ * Return the current state as an object
+ */
+FsWatcher.prototype.dump = function dump() {
+    var self = this;
+
+    assert.object(self.watching, 'self.watching');
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    return {
+        watching: Object.keys(self.watching),
+        not_yet_watching: Object.keys(self.not_yet_watching),
+        pending_actions: self.pending_actions,
+        watcher_pid: self.watcher_pid,
+        running: self.isRunning()
+    };
+};
+
+module.exports.FsWatcher = FsWatcher;
+
+/*
+ * Clone a variable - supports primitives, Objects, Arrays and Dates
+ */
+function deepClone(src) {
+    var dst;
+    var key;
+
+    if (src instanceof Date) {
+        dst = src;
+    } else if (Array.isArray(src)) {
+        dst = [];
+        src.forEach(function arrayDeepClone(e) {
+            dst.push(deepClone(e));
+        });
+    } else if (typeof (src) === 'object') {
+        dst = {};
+        for (key in src) {
+            dst[key] = deepClone(src[key]);
+        }
+    } else {
+        dst = src;
+    }
+
+    return dst;
+}
+
+/*
+ * safe hasOwnProperty
+ */
+function hasProperty(o, p) {
+    assert.object(o, 'o');
+    assert.string(p, 'p');
+
+    return Object.prototype.hasOwnProperty.call(o, p);
+}
+
+if (require.main === module) {
+    var _f = process.argv[2];
+    var fsw = new FsWatcher();
+    fsw.once('ready', function _ready(obj) {
+        fsw.watch(_f, function _watch() {
+            console.log('watching %s', _f);
+        });
+    });
+    fsw.on('event', function _event(ev) {
+        console.log('new event: %j', ev);
+    });
+    fsw.start();
+}
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index 10629f80..dc91d02c 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2015, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -298,7 +298,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.archive-on-delete'
     }, autoboot: {
@@ -637,7 +638,8 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update'],
                 'kvm': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.do-not-inventory'
     }, docker: {
@@ -647,7 +649,8 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update'],
                 'joyent-minimal': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.docker'
     }, dns_domain: {
@@ -732,7 +735,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.firewall-enabled'
     }, fs_allowed: {
@@ -783,7 +787,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zfs: {
             fields: ['userrefs'],
@@ -798,7 +803,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zfs: {
             fields: ['userrefs'],
@@ -874,7 +880,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.maintain-resolvers'
     }, max_locked_memory: {
@@ -1026,7 +1033,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_dhcp_spoofing'
@@ -1039,7 +1047,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_ip_spoofing'
@@ -1052,7 +1061,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_mac_spoofing'
@@ -1065,7 +1075,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_restricted_traffic'
@@ -1075,7 +1086,8 @@ exports.properties = {
             allowed: {
                 'kvm': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_unfiltered_promisc'
@@ -1113,7 +1125,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.dhcp_server'
@@ -1259,7 +1272,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.primary'
@@ -1490,7 +1504,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.restart-init'
     }, routes: {
@@ -1744,7 +1759,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'string'
+            type: 'string',
+            default: 'off'
         },
         zfs: {
             fields: ['compression'],
@@ -1787,6 +1803,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 'none',
             min: 0
         },
         zfs: {
@@ -1801,7 +1818,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'string'
+            type: 'string',
+            default: 'off'
         },
         zfs: {
             fields: ['compression'],
@@ -1816,6 +1834,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 131072,
             min: 0
         },
         zfs: {
@@ -1877,6 +1896,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 'none',
             min: 0
         },
         zfs: {
diff --git a/src/vm/node_modules/queue.js b/src/vm/node_modules/queue.js
new file mode 100644
index 00000000..bda230b5
--- /dev/null
+++ b/src/vm/node_modules/queue.js
@@ -0,0 +1,515 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * Queue is a wrapper around a vasync queue with a few added features:
+ *
+ * - Ability to pause, fast-forward, and resume the queue
+ * - Optional deduplication for queued tasks with the same string identifier
+ * - Optional timeout for tasks taking too long
+ * - Tasks (functions) get a custom logger with unique task identifier
+ * - Timing stats for task create (enqueue), start, and finish.
+ *
+ * Every task pushed to the queue must contain at least a function to run, and
+ * a string identifier (called description).
+ *
+ * Example
+ *
+ * var q = new Queue({
+ *     log: log,     // [required] bunyan logger
+ *     workers: 1,   // [required] number of concurrent workers
+ *     dedup: true,  // [optional] discard enqueued tasks with same description
+ *     paused: true, // [optional] start paused, defauts to false
+ *
+ * });
+ *
+ * q.enqueue({
+ *     // used for logging, and deduplication if enabled
+ *     description: 'sysevent seen for zone foo',
+ *
+ *     // kill the task if it takes more than 30 seconds, default is no timeout
+ *     timeout: 30 * 1000,
+ *
+ *     // the function to run - cb doesn't expect any arguments
+ *     func: function myTask(extras, cb) {
+ *         // this logger contains the task object, which has the tasks UUID,
+ *         // description, and more.  This is a childlog of the logger passed
+ *         // in during queue creation.
+ *         extras.log('doing something');
+ *
+ *         somethingAsync(function somethingAsyncDone() {
+ *             cb(); // let the queue know this task is over
+ *         });
+ *     }
+ * });
+ *
+ * q.enqueue({
+ *     description: 'sysevent seen for zone bar',
+ *     func: function syseventFunc(extras, cb) { cb(); }
+ * });
+ *
+ * .enqueue() also returns a value: true if the task was queued or false if it
+ * was discarded by deduplication.  For example:
+ *
+ * ret = q.enqueue({
+ *     description: 'foo',
+ *     func: function fooFunc(extras, cb) { cb(); }
+ * });
+ * // ret => true, no task with this name is enqueued
+ *
+ * ret = q.enqueue({
+ *     description: 'foo',
+ *     func: function otherFooFunc(extras, cb) { cb(); }
+ * });
+ * // ret => false, a task with this name is enqueued so this task is discarded
+ *
+ * There are now 3 tasks on the queue but it is currently paused, we can uncork
+ * it with:
+ *
+ * q.resume();
+ *
+ * Finally, Queue supports fast-forwarding the queue.  When a task is enqueued,
+ * the current timestamp is stored for it (called "create" time).  When you
+ * call .fastForward(), you pass in an hrtime Array, and all items
+ * created on or before that time will be run through the queue, and the
+ * callback will fire when all tasks are completed.
+ *
+ * For example (queue must be paused or an error is thrown)
+ *
+ * var one_minute_ago = process.hrtime();
+ * one_minuto_ago[0] -= 60;
+ * var opts = {
+ *     timeout: 60 * 1000  [optional] timeout to error out fast-forward
+ * };
+ * q.fastForward(one_minute_ago, opts, function fastForwarded(err) {
+ *     // `err` can only be set if opts.timeout was specified and exceeded.
+ *     // In this event, the tasks are still running when this callback is
+ *     // fired, but the queue is still technically paused and not running
+ *     // any new tasks enqueued.
+ *
+ *     // Otherwise, this means the enqueued tasks created exactly or more than
+ *     // a minute ago are now complete.
+ * });
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var libuuid = require('/usr/node/node_modules/uuid');
+var vasync = require('/usr/vm/node_modules/vasync');
+
+module.exports.Queue = Queue;
+
+/*
+ * Create an event queue
+ *
+ * opts = {
+ *     log: log,     // [required] bunyan logger
+ *     workers: 1,   // [required] number of concurrent workers
+ *     dedup: true,  // [optional] discard enqueued tasks with same description
+ *     paused: true, // [optional] start paused, defauts to false
+ * };
+ */
+function Queue(opts) {
+    var self = this;
+
+    EventEmitter.call(self);
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.number(opts.workers, 'opts.workers');
+    assert.optionalBool(opts.dedup, 'opts.dedup');
+    assert.optionalBool(opts.paused, 'opts.paused');
+
+    // paused
+    self.paused = !!opts.paused;
+    self.paused_time = self.paused ? process.hrtime() : null;
+
+    // max workers
+    self.workers = opts.workers;
+
+    // logger
+    self.log = opts.log;
+
+    // should dedup
+    self.dedup = opts.dedup;
+
+    // tasks waiting to run (pushed when paused)
+    self.paused_queue = [];
+
+    // vasync queue
+    self.queue = vasync.queue(function queueTaskProcess(task, cb) {
+        assert.object(task, 'task');
+        assert.func(cb, 'cb');
+
+        task.started_at = process.hrtime();
+
+        // "extras" is passed to the user function when it is called
+        var childlog = self.log.child({task: task});
+        var extras = {
+            log: childlog
+        };
+
+        // If a task timeout is specified, create a timeout for the task to
+        // emit an error if it takes too long to execute
+        var timeout;
+        if (task.timeout) {
+            timeout = setTimeout(function queueTaskTimeout() {
+                var err = new Error('timeout exceeded');
+                childlog.fatal({err: err, timeout: task.timeout},
+                    'task took longer than %dms', task.timeout);
+                self.emit('error', err);
+            }, task.timeout);
+        }
+
+        childlog.debug('starting task');
+        task.func(extras, function queueTaskFuncDone(err) {
+            task.finished_at = process.hrtime();
+            var delta = hrtime.hrtimeDelta(task.finished_at, task.started_at);
+
+            childlog.debug({delta: delta}, 'finished task in %s',
+                hrtime.prettyHrtime(delta));
+
+            // clear the timeout
+            if (timeout) {
+                clearTimeout(timeout);
+                timeout = null;
+            }
+
+            // emit an error
+            if (err) {
+                childlog.error({err: err}, 'task failed: %s', err.message);
+                self.emit('error', err);
+            }
+
+            cb();
+        });
+    }, self.workers);
+}
+util.inherits(Queue, EventEmitter);
+
+/*
+ * Push a task to the queue.  If we are currently paused the task will be
+ * stored in the "paused_queue" array, to be pushed onto the vasync queue
+ * at a later time as either part of a .resume() or .fastForward().  If
+ * we are not paused, the task is pushed directly onto the vasync queue.
+ *
+ * A task must have a function set, as well as a string description.  If the
+ * description of a task being pushed matches the description of a task
+ * already queued to run, and opts.dedup was set in the queues constructor,
+ * the task is discarded.
+ *
+ * Returns:
+ *   true    the task was enqueued, either while paused or running
+ *   false   the task wes discarded as a dup (only happens when opts.dedup)
+ */
+Queue.prototype.enqueue = function enqueue(opts, cb) {
+    var self = this;
+    var found;
+
+    assert.object(opts, 'opts');
+    assert.func(opts.func, 'opts.func');
+    assert.string(opts.description, 'opts.description');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalFunc(cb, 'cb');
+
+    // when a task is created, we record the time and create a unique id
+    // for it
+    opts.id = libuuid.create();
+    opts.created_at = process.hrtime();
+
+    // if dedup is disabled, we push the task to either the vasync queue
+    // or the paused queue depending on the current state
+    if (!self.dedup) {
+        if (self.paused) {
+            self.log.debug({opts: opts}, 'pushing to paused queue');
+            self.paused_queue.push({opts: opts, cb: cb});
+        } else {
+            self.log.debug({opts: opts}, 'pushing to vasync queue');
+            self.queue.push(opts, cb);
+        }
+        return true;
+    }
+
+    // if we are here then dedup is enabled.  we check the existing queues for
+    // a matching task and discard the current one if a match is found
+
+    if (self.paused) {
+        // check the paused queue first if we are paused
+        found = self.paused_queue.some(function dedupPaused(o) {
+            return o.opts.description === opts.description;
+        });
+    }
+
+    if (!found) {
+        // check the vasync queue if 1. we are not paused or, 2. the paused
+        // queue didn't have a matching task
+        found = self.queue.queued.some(function dedupQueued(o) {
+            return o.task.description === opts.description;
+        });
+    }
+
+    // a matching task was found in either queue - discard this one
+    if (found) {
+        self.log.debug({opts: opts}, 'duplicate task found - discarding');
+        return false;
+    }
+
+    // no matching task was found - push it to the appropriate queue
+    if (self.paused) {
+        self.log.debug({opts: opts},
+            'no duplicate task found - pushing to paused queue');
+        self.paused_queue.push({opts: opts, cb: cb});
+    } else {
+        self.log.debug({opts: opts},
+            'no duplicate task found - pushing to vasync queue');
+        self.queue.push(opts, cb);
+    }
+
+    return true;
+};
+
+/*
+ * Pause the queue
+ *
+ * This will pause processing any newly enqueued tasks and wait for all
+ * currently running and enqueued tasks to finish.
+ *
+ * An optional timeout may be specified to callback with an
+ * error if it takes too long to stop the queue.
+ */
+Queue.prototype.pause = function pause(opts, cb) {
+    var self = this;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert(!self.paused, 'queue is already paused!');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.func(cb, 'cb');
+
+    self.paused = true;
+    self.paused_time = process.hrtime();
+
+    // short-circuit logic if no task is currently running
+    if (self.queue.npending === 0) {
+        self.log.debug('queue paused');
+        cb();
+        return;
+    }
+
+    // task(s) running - wait for finish
+    var timeout;
+    if (opts.timeout) {
+        timeout = setTimeout(function pauseTimeout() {
+            var err = new Error('pause timeout exceeded');
+            self.log.fatal({err: err, timeout: opts.timeout},
+                'pause took longer than %dms', opts.timeout);
+            self.queue.removeListener('drain', ondrain);
+            self.resume();
+            cb(err);
+        }, opts.timeout);
+    }
+
+    self.queue.once('drain', ondrain);
+
+    // vasync queue has drained, we can pause
+    function ondrain() {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        cb();
+    }
+};
+
+/*
+ * Resume the queue.
+ *
+ * This will take all of the elements of the paused_queue and push them into
+ * the vasync queue.
+ */
+Queue.prototype.resume = function resume() {
+    var self = this;
+
+    assert(self.paused, 'queue is not paused!');
+
+    self.paused = false;
+    self.paused_time = null;
+    self.log.debug('queue resumed - enqueueing %d tasks',
+        self.paused_queue.length);
+
+    self.paused_queue.forEach(function pausedForeachResume(o) {
+        self.queue.push(o.opts, o.cb);
+    });
+    self.paused_queue = [];
+};
+
+/*
+ * Fast Forward the queue to a given date.
+ *
+ * The queue must be paused for this to work.  Given an hrtime
+ * (process.hrtime()) as the first argument, this function will process every
+ * item in the queue that was queued before the time given and call the
+ * callback given when it has finished (or if it has timedout).
+ *
+ * opts.timeout   a max time (in ms) to wait for the queue to fast-forward,
+ *                this may be omitted to not create a timeout
+ *
+ */
+Queue.prototype.fastForward = function fastForward(time, opts, cb) {
+    var self = this;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert(self.paused, 'queue must be paused to fast-forward');
+    hrtime.assertHrtime(time, 'time');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.func(cb, 'cb');
+
+    // loop all queued tasks and dispatch them if they were created before or
+    // at fast-forward time given
+    var task;
+    var i = 0;
+    while ((task = self.paused_queue.shift())) {
+        if (hrtime.hrtimeComparator(task.opts.created_at, time) <= 0) {
+            i++;
+            self.queue.push(task.opts, task.cb);
+        } else {
+            self.paused_queue.unshift(task);
+            break;
+        }
+    }
+    self.log.debug('fast-forward pushed %d tasks into queue', i);
+
+    // just callback immediately if no tasks were pushed
+    if (i === 0) {
+        cb();
+        return;
+    }
+
+    // task(s) running - wait for finish
+    var timeout;
+    if (opts.timeout) {
+        timeout = setTimeout(function fastForwardTimeout() {
+            var err = new Error('fast-forward timeout exceeded');
+            self.log.error({err: err, timeout: opts.timeout},
+                'fast-forward took longer than %dms', opts.timeout);
+            self.queue.removeListener('drain', ondrain);
+            cb(err);
+        }, opts.timeout);
+    }
+
+    self.queue.once('drain', ondrain);
+
+    function ondrain() {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        cb();
+    }
+};
+
+/*
+ * Return the queue status as an object.
+ *
+ * This is useful for stringifying and outputting as part of an HTTP request
+ * for a web service, or running this and storing in memory before a process
+ * crash.
+ */
+Queue.prototype.dump = function dump() {
+    var self = this;
+
+    var now = process.hrtime();
+
+    var state = {
+        now: hrtime.hrtimeToString(now),
+        paused: self.paused,
+        vasync_queue: {
+            concurrency: self.queue.concurrency,
+            npending: self.queue.npending,
+            nqueued: self.queue.length(),
+            pending: {},
+            queued: []
+        }
+    };
+
+    Object.keys(self.queue.pending).forEach(function pendingForeach(id) {
+        var task = self.queue.pending[id].task;
+        var o = {
+            description: task.description,
+            created_at: hrtime.hrtimeToString(task.created_at),
+            started_at: hrtime.hrtimeToString(task.started_at),
+            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at),
+            started_ago: hrtime.hrtimeDeltaPretty(now, task.started_at),
+            start_latency: hrtime.hrtimeDeltaPretty(task.started_at,
+                task.created_at)
+
+        };
+        state.vasync_queue.pending[task.id] = o;
+    });
+
+    self.queue.queued.forEach(function queuedForeach(q) {
+        var task = q.task;
+        var o = {
+            description: task.description,
+            created_at: hrtime.hrtimeToString(task.created_at),
+            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at)
+        };
+        state.vasync_queue.queued.push(o);
+    });
+
+    if (self.paused) {
+        state.paused_at = hrtime.hrtimeToString(self.paused_time);
+        state.paused_ago = hrtime.hrtimeDeltaPretty(now, self.paused_time);
+        state.paused_nqueued = self.paused_queue.length;
+        state.paused_queue = [];
+        self.paused_queue.forEach(function pausedQueueForeach(task) {
+            assert.object(task, 'task');
+            assert.object(task.opts, 'task.opts');
+            var o = {
+                id: task.opts.id,
+                description: task.opts.description,
+                created_at: hrtime.hrtimeToString(task.opts.created_at),
+                created_ago: hrtime.hrtimeDeltaPretty(now, task.opts.created_at)
+            };
+            state.paused_queue.push(o);
+        });
+    }
+
+    return state;
+};
diff --git a/src/vm/node_modules/vminfod/client.js b/src/vm/node_modules/vminfod/client.js
new file mode 100644
index 00000000..7f61236e
--- /dev/null
+++ b/src/vm/node_modules/vminfod/client.js
@@ -0,0 +1,1052 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * - VminfodClient
+ *
+ * A client class that can be used to make basic GET requests to the vminfod
+ * service.
+ *
+ * var vc = new require('vminfod/client').VminfodClient();
+ *
+ * vc.ping(cb);
+ * vc.status(cb);
+ * vc.vms(cb);
+ * vc.vm(zonename, cb);
+ * vc.get(urlPath, cb); // arbitrary GET request
+ *
+ * Where `cb` has the signature function(err, result)
+ *
+ * - VminfodEventStream
+ *
+ * A class that can be used to interface directly with the vminfod events
+ * stream (GET /events).  It creates a readable stream in objectMode where each
+ * call to read returns an object parsed from the event stream that represents
+ * a single event.
+ *
+ * var vs = new require('vminfod/client').VminfodEventStream();
+ *
+ * vs.once('ready', function (ev) {
+ *     // stream ready
+ * });
+ *
+ * // create a live stream
+ * vs.on('readable', function () {
+ *     var ev;
+ *     while ((ev = vs.read())) {
+ *         console.log(JSON.stringify(ev));
+ *     }
+ * });
+ *
+ * // or instead, call a convenince function
+ *
+ * - VminfodEventStream#watchForEvent(obj, opts, cb)
+ *
+ * // wait 60 seconds for the zone_state to transition to "running"
+ * var obj = {
+ *     uuid: '<uuid>',
+ *     vm: {
+ *         zone_state: 'running'
+ *     }
+ * };
+ * var opts = {
+ *     timeout: 60 * 1000, // error after 60 seconds if event is not seen
+ *     teardown: true, // end the stream at any error or when the event is seen
+ *     startFresh: true, // clear any unread events first
+ *     catchErrors: true // bind .on('error') and callback if any is seen
+ * };
+ *
+ * // watchForEvent returns a function that can be used to cancel the watch.
+ * // It is bascially a shortcut to the callback that is fired - any arguments
+ * // passed to cancel will be applied to the callback given.
+ * var cancel = vs.watchForEvent(obj, opts, function (err, ev) {
+ *     if (err) {
+ *         // either the stream ended prematurely or the event was not seen for
+ *         // 60 seconds
+ *     }
+ *     // `ev` is the event that matched "obj"
+ *     console.log(JSON.stringify(ev, null, 2));
+ * });
+ *
+ * - VminfodEventStream#watchForChanges(obj, changes, opts, cb)
+ *
+ * // wait 30 seconds for the quota to change from 10 to 20
+ * // just like watchForEvent, this object is matched against the event object
+ * // before any further processing is done.
+ * var obj = {
+ *     uuid: '<uuid>',
+ * };
+ * // same as watchForEvent
+ * var opts = {
+ *     timeout: 30 * 1000,
+ *     teardown: true,
+ *     startFresh: true,
+ *     catchErrors: true
+ * };
+ * // every element in the array must be matched for the callback to fire
+ * // successfully (logical AND).
+ * var changes = [
+ *    {
+ *        path: ['quota'],
+ *        action: 'changed',
+ *        from: 10,
+ *        to: 20
+ *    }
+ * ];
+ * var cancel = vs.watchForChanges(obj, changes, opts, function (err) {
+ *     if (err) {
+ *         // either the stream ended prematurely or the event was not seen for
+ *         // 30 seconds
+ *     }
+ *     // matched the changes given
+ * });
+ *
+ * - VminfodWatcher
+ *
+ * A class that wraps VminfodEventStream and can be used to mirror vminfod
+ * effectively.  Under the hood, a VminfodEventStream will be created and used
+ * to manage an internal object of all VMs that vminfod is aware of.  This way,
+ * the internal object is kept up to date by getting notified of any changes
+ * from the vminfod service.  For Example:
+ *
+ * var vw = new require('vminfod/client').VminfodWatcher();
+ *
+ * vw.once('ready', function (ev) {
+ *     // returns an object that maps zonenames to vm objects
+ *     var vms = vw.vms();
+ *     // vms[<uuid>] == vmobj
+ *
+ *     var vmobj = vw.vm('uuid');
+ *     // vmobj is an object, or undefined if it is not found
+ * });
+ *
+ * vw.on('create', cb); // a VM was created
+ * vw.on('modify', cb); // a VM was modified
+ * vw.on('delete', cb); // a VM was deleted
+ * vw.on('event', cb);  // a VM was created/modified/deleted
+ *
+ * All callbacks will be called with a single argument - the event from the
+ * vminfod stream.
+ *
+ * The calls to `vs.vms` and `vs.vm` are very fast, because they just check
+ * a local JavaScript object (as opposed to making an HTTP call to the
+ * vminfod service) that is kept up to date by the VminfodEventStream.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var http = require('http');
+var stream = require('stream');
+var os = require('os');
+var util = require('util');
+var qs = require('querystring');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var diff = require('/usr/vm/node_modules/diff');
+var LineStream = require('/usr/node/node_modules/linestream');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+
+/*
+ * When creating an event stream, the daemon *should* respond with a "ready"
+ * event when the connection is established.  In the event that there is a bug,
+ * or something wrong with the daemon and it doesn't send a ready event, we
+ * ensure that we don't indefinetely for an event that won't come.
+ */
+var READY_TIMEOUT = 30 * 1000;
+
+module.exports.VminfodClient = VminfodClient;
+module.exports.VminfodEventStream = VminfodEventStream;
+module.exports.VminfodWatcher = VminfodWatcher;
+
+var log = bunyan.createLogger({
+    level: 'debug',
+    name: 'vminfod/client',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+function noop() {}
+
+/*
+ * VminfodClient class
+ */
+function VminfodClient(opts) {
+    var self = this;
+
+    assert(self instanceof VminfodClient, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    var _log = opts.log || log;
+
+    self.vc_host = opts.host || '127.0.0.1';
+    self.vc_port = opts.port || 9090;
+    self.vc_name = opts.name || _log.fields.name;
+    self.vc_logger = _log.child({client: self.vc_name});
+}
+
+/*
+ * Perform a GET request to the Vminfod daemon.
+ *
+ * @param {Object|String} opts - options to pass to http.request, if this is a
+ *                               string it is used as opts.path (the endpoint)
+ * @param {Function} cb - callback of signature cb(err, data)
+ *   - err - any possible error, including non-200 statusCode or failure to
+ *           parse JSON response
+ *   - data - the JSON.parse'd data returned from the server
+ * @return {HTTPRequest} req - the HTTP request object
+ */
+VminfodClient.prototype.get = function vminfodClientGet(opts, cb) {
+    var self = this;
+
+    if (typeof (opts) === 'string') {
+        opts = {path: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    var reqOpts = {
+        host: self.vc_host,
+        port: self.vc_port,
+        method: 'GET',
+        headers: {
+            'user-agent': makeUserAgent(self.vc_name)
+        }
+    };
+    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
+        reqOpts[key] = opts[key];
+    });
+
+    var req = http.request(reqOpts, function httpRequestMade(res) {
+        if (res.statusCode !== 200) {
+            var err = new Error('bad statusCode: ' + res.statusCode);
+            err.code = err.statusCode = res.statusCode;
+            res.destroy();
+            cb(err);
+            return;
+        }
+
+        res.setEncoding('utf8');
+        var body = '';
+        res.on('readable', function resReadable() {
+            var chunk;
+            while ((chunk = res.read()) !== null) {
+                body += chunk;
+            }
+        });
+        res.on('end', function resEnd() {
+            var d;
+            try {
+                d = JSON.parse(body);
+            } catch (e) {
+                self.vc_logger.error({err: e, opts: reqOpts},
+                    'failed to parse request body from %s %s',
+                    reqOpts.method, reqOpts.path);
+                cb(e);
+                return;
+            }
+            cb(null, d);
+        });
+    });
+
+    req.on('error', function reqError(e) {
+        cb(e);
+        req.destroy();
+    });
+
+    req.end();
+
+    return req;
+};
+
+/*
+ * shortcuts for common endpoints, equivalent to:
+ *   get('/status', cb), get('/vms', cb), etc.
+ */
+['ping', 'status', 'vms'].forEach(function makeVminfodClientFunc(s) {
+    VminfodClient.prototype[s] = function vminfodClientGetWrapper(opts, cb) {
+        var self = this;
+
+        if (typeof (opts) === 'function') {
+            cb = opts;
+            opts = {};
+        }
+
+        assert.object(opts, 'opts');
+        assert.func(cb, 'cb');
+
+        opts.path = '/' + s;
+
+        if (opts.query) {
+            opts.path += '?' + qs.stringify(opts.query);
+        }
+
+        return self.get(opts, cb);
+    };
+});
+
+/*
+ * Get a information for a specific vm given the zonename
+ *
+ * @param {String} zonename - the zonename (UUID most likely)
+ * @param {Function} cb - same signature and usage as .get()
+ */
+VminfodClient.prototype.vm = function vminfodClientVm(zonename, cb) {
+    var self = this;
+
+    var endpoint = '/vms/' + encodeURIComponent(zonename);
+    return self.get(endpoint, function vminfodClientVmWrapper(err, vmobj) {
+        if (err && err.code === 404) {
+            // XXX this is a lame hack so the vmadm command line outputs
+            // a message we expect for a zone that is missing.
+            err.message = util.format('zoneadm: %s: No such zone configured',
+                zonename);
+        }
+        cb(err, vmobj);
+    });
+};
+
+/*
+ * Create a new vminfod stream by creating a persistent HTTP request to vminfod
+ *
+ */
+function VminfodEventStream(opts) {
+    var self = this;
+
+    assert(self instanceof VminfodEventStream, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    // become a transform stream
+    stream.Transform.call(self, {objectMode: true});
+
+    var _log = opts.log || log;
+
+    // process opts
+    self.vs_host = opts.host || '127.0.0.1';
+    self.vs_port = opts.port || 9090;
+    self.vs_name = opts.name || _log.fields.name;
+    self.vs_parseReady = opts.parseReady || false;
+    self.vs_logger = _log.child({client: self.vs_name});
+
+    self.start();
+}
+util.inherits(VminfodEventStream, stream.Transform);
+
+/*
+ * start the stream by opening a persistent HTTP connection
+ */
+VminfodEventStream.prototype.start = function vminfodEventStreamStart(opts) {
+    var self = this;
+
+    opts = opts || {};
+
+    assert.object(opts, 'opts');
+    assert.ok(!self.vs_req, 'VminfodEventStream already started');
+
+    var reqOpts = {
+        host: self.vs_host,
+        port: self.vs_port,
+        method: 'GET',
+        path: '/events',
+        headers: {
+            'user-agent': makeUserAgent(self.vs_name)
+        }
+    };
+    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
+        reqOpts[key] = opts[key];
+    });
+
+    self.vs_req = http.request(reqOpts, function httpRequestMade(res) {
+        var e;
+        if (res.statusCode !== 200) {
+            e = new Error('bad statusCode: ' + res.statusCode);
+            e.code = res.statusCode;
+            res.destroy();
+            self.vs_logger.error({err: e}, '%s', e.message);
+            self.emit('error', e);
+            return;
+        }
+
+        var ls = new LineStream();
+        res.pipe(ls).pipe(self);
+        res.on('end', function resEnd() {
+            if (self.vs_req) {
+                e = new Error('VminfodEventStream ended prematurely');
+                self.vs_logger.error({err: e}, '%s', e.message);
+                self.emit('error', e);
+                return;
+            }
+        });
+    });
+    self.vs_req.setTimeout(0);
+    self.vs_req.end();
+
+    /*
+     * create a timer to ensure that the "ready" event seen.  This also allows
+     * us to ensure the "ready" event is only seen once.
+     */
+    assert(!self.vs_ready_timeout, '"ready" timeout already exists');
+    self.vs_ready_timeout = setTimeout(function readyTimeout() {
+        var e = new Error('VminfodEventStream ready timeout exceeded');
+
+        self.vs_logger.error({err: e}, e.message);
+        self.vs_ready_timeout = null;
+        self._abort(e);
+    }, READY_TIMEOUT);
+
+    /*
+     * capture any request errors and reemit them by this module
+     */
+    self.vs_req.on('error', function reqError(err) {
+        self.vs_logger.error({err: err}, 'VminfodEventStream request error');
+        self._abort(err);
+    });
+
+    return self.vs_req;
+};
+
+/*
+ * the transform method to process http body-by-line
+ */
+VminfodEventStream.prototype._transform =
+    function _transform(chunk, encoding, cb) {
+
+    var self = this;
+
+    var ev;
+    var line = chunk.toString('utf8');
+    var now;
+    var parsed;
+    var vms;
+
+    try {
+        ev = JSON.parse(line);
+        ev.date = new Date(ev.date);
+        assert.ok(isFinite(ev.date), 'invalid ev.date');
+    } catch (e) {
+        // any JSON parse failure is a fatal error
+        self.vs_logger.error({err: e, line: line},
+            'failed to parse output line');
+        self._abort(e);
+        return;
+    }
+
+    switch (ev.type) {
+    case 'ready':
+        assert(self.vs_ready_timeout, '"ready" event already seen');
+        if (self.vs_parseReady) {
+            /*
+             * This is less-than-ideal, but because vminfod pre-serializes
+             * vm data to cut down on the number of calls to JSON.stringify
+             * required, we have to JSON.parse the vms property, as its been
+             * serialized twice.
+             *
+             * Also, we convert the vms array to an object indexed off of the
+             * "zonename" (uuid) property
+             */
+            now = process.hrtime();
+            vms = {};
+            parsed = JSON.parse(ev.vms);
+            parsed.forEach(function mapEachVm(vmobj) {
+                vms[vmobj.zonename] = vmobj;
+            });
+            ev.vms = vms;
+            self.vs_logger.debug({vms: parsed.length},
+                'vminfod took %s to parse "ready" event, %d vms total',
+                hrtime.hrtimeDeltaPretty(process.hrtime(), now), parsed.length);
+        }
+        self.vs_logger.debug('vminfod event stream ready');
+        self.emit('ready', ev);
+        self._clearReadyTimeout();
+        break;
+    default:
+        self.push(ev);
+        break;
+    }
+    cb();
+};
+
+/*
+ * clear all unread objects from the internal buffer
+ */
+VminfodEventStream.prototype.exhaustEvents =
+    function vminfodEventStreamExhaustEvents() {
+
+    var self = this;
+    var i = 0;
+
+    while (self.read()) {
+        i++;
+    }
+
+    self.vs_logger.debug({i: i}, 'vminfod exhausted %d events', i);
+};
+
+/*
+ * cleanly stop the VminfodEventStream by destroying the request
+ */
+VminfodEventStream.prototype.stop = function vminfodEventStreamStop() {
+    var self = this;
+
+    if (self.vs_req) {
+        self.vs_logger.debug('vminfod event stream stopped');
+        self.vs_req.destroy();
+        self.vs_req = null;
+    }
+    self._clearReadyTimeout();
+};
+
+/*
+ * same as above, but emit an error
+ */
+VminfodEventStream.prototype._abort = function _vminfodEventStreamAbort(e) {
+    var self = this;
+
+    self.stop();
+    self.emit('error', e);
+};
+
+/*
+ * Convenience function to clear the ready timeout if it is set
+ */
+VminfodEventStream.prototype._clearReadyTimeout =
+    function _vminfodEventStreamClearReadyTimeout() {
+
+    var self = this;
+
+    if (self.vs_ready_timeout) {
+        self.vs_logger.trace('clearing ready timeout');
+        clearTimeout(self.vs_ready_timeout);
+        self.vs_ready_timeout = null;
+    }
+};
+
+/*
+ * Watch for a specific event (with an optional timeout), and
+ * optionally teardown the stream when it is received
+ */
+VminfodEventStream.prototype.watchForEvent =
+    function vminfodEventStreamWatchForEvent(obj, opts, cb) {
+
+    var self = this;
+    var events = [];
+    var timeout;
+    var isDone = false;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert.object(obj, 'obj');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalBool(opts.teardown, 'opts.teardown');
+    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
+    assert.optionalBool(opts.startFresh, 'opts.startFresh');
+    assert.func(cb, 'cb');
+
+    if (opts.timeout) {
+        timeout = setTimeout(function vminfodEventStreamWatchForEventTimeout() {
+            isDone = true;
+            self.stop();
+            self.vs_logger.error({obj: obj, events: events},
+                'vminfod watchForEvent timeout exceeded - unmatched events');
+            var e = new Error('timeout exceeded');
+            e.code = 'ETIMEOUT';
+            done(e);
+        }, opts.timeout);
+    }
+
+    self.vs_logger.debug({
+        obj: obj,
+        opts: opts
+    }, 'vminfod watchForEvent created');
+
+    self.on('readable', readable);
+    if (opts.startFresh) {
+        self.exhaustEvents();
+    } else {
+        readable();
+    }
+
+    function readable() {
+        var ev;
+        while ((ev = self.read()) !== null) {
+            processevent(ev);
+        }
+    }
+
+    function processevent(ev) {
+        if (isDone)
+            return;
+
+        events.push(ev);
+
+        if (!objSameValues(obj, ev))
+            return;
+
+        self.vs_logger.debug({obj: obj},
+            'vminfod watchForEvent matched event');
+
+        done(null, ev);
+    }
+
+    function onerror(e) {
+        self.vs_logger.error({err: e},
+            'vminfod watchForEvent stream error');
+        done(e);
+    }
+    if (opts.catchErrors) {
+        self.on('error', onerror);
+    }
+
+    function done(err, o) {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        if (opts.teardown || (opts.catchErrors && err)) {
+            self.stop();
+        }
+        if (opts.catchErrors) {
+            self.removeListener('error', onerror);
+        }
+        self.removeListener('readable', readable);
+        isDone = true;
+        cb(err, o);
+    }
+
+    function cancel(err, o) {
+        if (isDone) {
+            self.vs_logger.warn('vminfod watchForEvent cancelled after done');
+            return;
+        }
+
+        self.vs_logger.debug('vminfod watchForEvent cancelled');
+        done(err, o);
+    }
+
+    return cancel;
+};
+
+/*
+ * watch for one or more changes (with an optional timeout), and
+ * optionally teardown the stream when it is seen
+ */
+VminfodEventStream.prototype.watchForChanges =
+    function vminfodEventStreamWatchForChanges(obj, changes, opts, cb) {
+
+    var self = this;
+    var timeout;
+    var events = [];
+    var isDone = false;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert.object(obj, 'obj');
+    assert.array(changes, 'changes');
+    changes.forEach(function loopChangesBase(_changes) {
+        // change can be an object, or an array of objects
+        if (!Array.isArray(_changes)) {
+            _changes = [_changes];
+        }
+        assert.arrayOfObject(_changes, 'changes');
+        _changes.forEach(function loopChangesSecondLevel(change) {
+            /*
+             * In order for a "change" object to be valid, it must have the
+             * "path" property set, as well as any other property indicating
+             * change type.
+             */
+            assert.array(change.path, 'change.path');
+            var otherkeys = Object.keys(change).filter(
+                function filterPath(key) {
+
+                return key !== 'path';
+            });
+            assert(otherkeys.length > 0, 'change only has "path" set');
+        });
+    });
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalBool(opts.teardown, 'opts.teardown');
+    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
+    assert.optionalBool(opts.startFresh, 'opts.startFresh');
+    assert.func(cb, 'cb');
+
+    var total = changes.length;
+
+    self.vs_logger.debug({
+        obj: obj,
+        opts: opts,
+        changes: changes,
+        total: total
+    }, 'vminfod watchForChanges created');
+
+    if (total === 0) {
+        self.vs_logger.warn('vminfod watchForChanges called '
+            + 'with empty changes array');
+
+        if (opts.startFresh) {
+            self.exhaustEvents();
+        }
+
+        done();
+        return noop;
+    }
+
+    if (opts.timeout) {
+        timeout = setTimeout(
+            function vminfodEventStreamWatchForChangesTimeout() {
+
+            self.vs_logger.error({changes: changes, events: events},
+                'vminfod watchForChanges timeout exceeded - unmatched events');
+            var e = new Error('timeout exceeded');
+            e.code = 'ETIMEOUT';
+            done(e);
+        }, opts.timeout);
+    }
+
+    self.vs_logger.trace({changes: changes},
+        'beginning watch for vminfod changes');
+
+    self.on('readable', readable);
+    if (opts.startFresh) {
+        self.exhaustEvents();
+    } else {
+        readable();
+    }
+    function readable() {
+        var ev;
+        while ((ev = self.read()) !== null) {
+            processevent(ev);
+        }
+    }
+
+    function processevent(ev) {
+        if (isDone)
+            return;
+
+        // filter out events that don't match our predicate (obj)
+        if (!objSameValues(obj, ev))
+            return;
+
+        self.vs_logger.trace({ev: ev},
+            'inspecting possible match from vminfod');
+
+        // loop changes found from vminfod
+        (ev.changes || []).forEach(function processChange(change) {
+            /*
+             * Compare to changes we are looking for.  Return false to remove
+             * the item from the changes array (meaning we matched it) or true
+             * to keep it in the array (meaning it was not a match).
+             *
+             * It's possible that there are duplicate changes we are looking
+             * for, so only filter out one element per change.
+             */
+            var hasMatched = false;
+            changes = changes.filter(function (wantedArr) {
+                if (isDone)
+                    return false;
+
+                if (hasMatched)
+                    return true;
+
+                if (!Array.isArray(wantedArr))
+                    wantedArr = [wantedArr];
+
+                for (var i = 0; i < wantedArr.length; i++) {
+                    var match;
+
+                    var wanted = wantedArr[i];
+                    var originalWantedPath = wanted.path.slice(0);
+
+                    var wantedPath = wanted.path;
+                    var changePath = change.path;
+
+                    /*
+                     * Skip this change if the path of the wanted variable
+                     * doesn't match
+                     */
+                    if (wantedPath.length !== changePath.length)
+                        continue;
+
+                    // Ensure each part of the "path" match.
+                    match = true;
+                    for (var j = 0; j < wantedPath.length; j++) {
+                        var wantedPart = wantedPath[j];
+                        var changePart = changePath[j];
+                        if (!(wantedPart === null
+                            || wantedPart === changePart)) {
+                            match = false;
+                            break;
+                        }
+                    }
+                    if (!match)
+                        continue;
+
+                    /*
+                     * Compare the event fired to the event we want, omitting
+                     * the "path" variable as it was checked above
+                     */
+                    delete wanted.path;
+                    match = objSameValues(wanted, change);
+                    wanted.path = originalWantedPath;
+
+                    if (match) {
+                        /*
+                         * We matched, this change will be removed from the
+                         * array
+                         */
+                        hasMatched = true;
+                        self.vs_logger.trace({change: change, match: match},
+                            'vminfod change match');
+
+                        return false;
+                    }
+                }
+
+                /*
+                 * If we get here, the event didn't match any of the changes
+                 * wanted so we keep the change and try again when a new event
+                 * is received.  We also push the event onto the "events" array
+                 * to be logged later for debugging purposes if the changes are
+                 * never satisified.
+                 */
+                events.push(change);
+                return true;
+            });
+        });
+
+        if (isDone) {
+            changes.length = 0;
+        }
+
+        if (changes.length === 0) {
+            // No more changes to wait for, we're done!
+            self.vs_logger.debug('vminfod watchForChanges all changes matched');
+            done();
+            return;
+        }
+
+        self.vs_logger.debug({remaining: changes.length, total: total},
+            'vminfod watchForChanges %d/%d changes remaining',
+            changes.length, total);
+    }
+
+    function onerror(e) {
+        self.vs_logger.error({err: e}, 'vminfod stream error');
+        done(e);
+    }
+    if (opts.catchErrors) {
+        self.on('error', onerror);
+    }
+
+    function done(err, o) {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        if (opts.teardown || (opts.catchErrors && err)) {
+            self.stop();
+        }
+        if (opts.catchErrors) {
+            self.removeListener('error', onerror);
+        }
+        self.removeListener('readable', readable);
+        isDone = true;
+        cb(err, o);
+    }
+
+    function cancel(err, o) {
+        if (isDone) {
+            self.vs_logger.warn('vminfod watchForChanges cancelled after done');
+            return;
+        }
+
+        self.vs_logger.debug('vminfod watchForChanges cancelled');
+        done(err, o);
+    }
+
+    return cancel;
+};
+
+/*
+ * Create a new VminfodEventStream and manage an internal object that houses
+ * all known vmobjs that is updated when a new event is seen
+ *
+ */
+function VminfodWatcher(opts) {
+    var self = this;
+
+    assert(self instanceof VminfodWatcher, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    var _log = opts.log || log;
+
+    self.vw_name = opts.name || _log.fields.name;
+    self.vw_logger = _log.child({client: self.vw_name});
+    self.vw_vms = {};
+
+    self.vw_vs = new VminfodEventStream({
+        name: self.vw_name,
+        log: self.vw_logger,
+        parseReady: true
+    });
+
+    self.vw_vs.once('ready',
+        function vminfodWatcherVminfodEventStreamReady(ready_ev) {
+
+        self.vw_vms = ready_ev.vms;
+        self.emit('ready');
+    });
+
+    self.vw_vs.on('readable',
+        function vminfodWatcherVminfodEventStreamReadable() {
+
+        var ev;
+        while ((ev = self.vw_vs.read())) {
+            self._handleEvent(ev);
+        }
+    });
+}
+util.inherits(VminfodWatcher, EventEmitter);
+
+/*
+ * Handle an incoming vminfod update
+ */
+VminfodWatcher.prototype._handleEvent =
+    function _vminfodWatcherHandleEvent(ev) {
+
+    var self = this;
+
+    assert.object(ev, 'ev');
+    assert.string(ev.type, 'ev.type');
+
+    switch (ev.type) {
+    case 'create':
+    case 'modify':
+        self.vw_vms[ev.zonename] = ev.vm;
+        break;
+    case 'delete':
+        delete self.vw_vms[ev.zonename];
+        break;
+    default:
+        assert(false, 'unknown vminfod event type: ' + ev.type);
+        break;
+    }
+
+    self.emit(ev.type, ev);
+    self.emit('event', ev);
+};
+
+/*
+ * return all vms
+ */
+VminfodWatcher.prototype.vms = function vminfodWatcherVms() {
+    var self = this;
+
+    return self.vw_vms;
+};
+
+/*
+ * return a specific vm
+ */
+VminfodWatcher.prototype.vm = function vminfodWatcherVm(zonename) {
+    var self = this;
+
+    assert.string(zonename, 'zonename');
+
+    var vm;
+    if (self.vw_vms.hasOwnProperty(zonename)) {
+        vm = self.vw_vms[zonename];
+    }
+
+    return vm;
+};
+
+/*
+ * stop the watcher
+ */
+VminfodWatcher.prototype.stop = function vminfodWatcherStop() {
+    var self = this;
+
+    self.vw_vs.stop();
+};
+
+/*
+ * Check to see that all key=>value pairs in "a" are found in "b".
+ */
+function objSameValues(a, b) {
+    var d = diff(a, b).filter(function filterDiff(change) {
+        return (change.action !== 'added');
+    });
+    return (d.length === 0);
+}
+
+/*
+ * Given a name (arbitrary string) a string suitable for using as a User-Agent
+ * is returned.
+ */
+function makeUserAgent(name) {
+    assert.string(name, 'name');
+
+    return util.format('%s - %s/%d (%s)',
+        name || log.name,
+        os.hostname(),
+        process.pid,
+        process.argv[1]);
+}
+
+/*
+ * If called directly just hook a vminfo stream to stdout
+ */
+if (require.main === module) {
+    var _vs = new VminfodEventStream();
+    _vs.on('readable', function vminfodEventStreamReadable() {
+        var ev;
+        while ((ev = _vs.read()) !== null) {
+            console.log(JSON.stringify(ev));
+        }
+    });
+}
diff --git a/src/vm/node_modules/vminfod/vminfod.js b/src/vm/node_modules/vminfod/vminfod.js
new file mode 100644
index 00000000..6fe7b91a
--- /dev/null
+++ b/src/vm/node_modules/vminfod/vminfod.js
@@ -0,0 +1,2374 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * The primary function of this module is to mantain an up-to-date copy of:
+ *
+ *   1) the complete vmobj list
+ *   2) a vmload cache object.
+ *
+ * The vmload cache object will be maintained internally by this daemon while
+ * the vmobj list can be consumed from the HTTP interface:
+ *
+ *   - The complete vm list can be consumed at GET /vms
+ *   - A single vm can be consumed at GET /vms/UUID
+ *
+ * To use the daemon, you should do something like:
+ *
+ *  var vminfod = new Vminfod({log: log});
+ *  vminfod.start(callback);
+ *  vminfod.stop([callback]);
+ *  vminfod.on(<event type>, callback(data));
+ *
+ * Where the event types can be:
+ *
+ *  ready - emitted when vminfo has initialized after start()
+ *  end - emitted when vminfo has shutdown after stop()
+ *  create - emitted when a new vm is created
+ *  modify - emitted when an existing vm is modified
+ *  delete - emitted when an existing vm is deleted
+ *
+ * on 'ready' the callback will be called, passing the list of vmobjs as the
+ * first and only argument.
+ *
+ * on 'end' the callback will be called, without any arguments
+ *
+ * on 'create' the callback will be called, passing the newly created vmobj as
+ * the first and only argument.
+ *
+ * on 'modify' the callback will be called, passing the updated vmobj as the
+ * first argument, and a list of changes as the second argument.
+ *
+ * on 'delete' the callback will be called, passing the zonename of the vmobj
+ * as the first and only argument.
+ *
+ * Note: The main consumer of this module will be the daemon
+ * /usr/vm/sbin/vminfod, found under the SMF service
+ * system-smartdc-vminfod:default.
+ *
+ * To query this daemon as a client however, use the vminfod/client.js library.
+ *
+ * As a client, Events can be consumed through the webservice at GET /events.
+ * The client connection will be held open until the client explicitly closes
+ * the socket. Events will be streamed to the client in http chunks as
+ * newline-separated-JSON where each event will be a JSON object. When
+ * unwrapped, the 'type' attribute will indicate the event type. All relevant
+ * data to the event will be included in the JSON object.
+ *
+ * How this daemon works:
+ *
+ *   The tl;dr overview is that this module will listen for events within 3
+ *   broad categories: zone state, zone config files, and zfs datasets.
+ *   When an event is fired, we will delete portions of the cache object that
+ *   are relevant to the event, then ask vmload to fill in the holes with
+ *   getZoneData, which we can then update the vmobjs that were affected
+ *   by the change, and lastly inform any subscribed consumers of the specific
+ *   changes to the vmobj data.
+ *
+ *   This module is not necessarily concerned with the details of a vmobj -
+ *   meaning, the structure of the vmobj, where the data is derived, and how
+ *   the data is transformed are not the concern of this module. This module
+ *   will delegate that responsibility to the vmload modules. This module is
+ *   concerned with knowing when pieces of the cache object are likely
+ *   out-of-date, how to re-populate those pieces, and which vmobjs will be
+ *   affected by the change.
+ *
+ *   The one execption to this rule is the vmobj.last_modified key.  This key
+ *   is updated to the current timestamp whenever any other field in the vmobj
+ *   has changed.  Also, any change to 'last_modified" will be done silently,
+ *   and not be reported on the /events stream.  This way, the 'last_modified'
+ *   property of any vm will always be set and will reflect the last time
+ *   vminfod has seen any modifications to the vm.
+ *
+ *   There a 3 broad event categories that are monitored via 2 event sources to
+ *   determine if a change has happened on a machine that *may* result in the
+ *   creation, modification, or deletion of a vm.
+ *
+ *     1. Sysevents (using sysevent-stream.js)
+ *
+ *       A. zpool-watcher.js: watches ZFS sysevents for dataset modifications
+ *       B. zone-watcher.js: watches zone sysevents for zone modifications
+ *
+ *     2. File System Events (via event ports using fswatcher.js)
+ *     Each VM has 5 files that are watched for modifications
+ *
+ *       1. /etc/zones/<uuid>.xml
+ *       2. /zones/<uuid>/lastexited
+ *       3. /zones/<uuid>/config/tags.json
+ *       4. /zones/<uuid>/config/routes.json
+ *       5. /zones/<uuid>/config/metadata.json
+ *
+ *   At a routine interval, we will also force-refresh the cache and regenerate
+ *   the vmobj sets to ensure data integrity. When the refresh interval is
+ *   fired, we will first pause the event queue, then request a new cache
+ *   object. Once we have received a new cache object, we will "fastForward"
+ *   the queue to the current time, performing all modifications to our current
+ *   cache, as well as the new cache object received from the full load.  This
+ *   way, any events seen while the cacehe was being fully loaded from the
+ *   system will be accounted for in both objects (to eliminate any sort of
+ *   race). We will replace the current cache object with the new one if the
+ *   two cache objects are different.
+ *
+ *   Only if the two objects are different, we will iterate through all vmobjs
+ *   and generate a new vmobj from the new cache and report any deltas along the
+ *   way. Finally, after all vmobjs have been updated, we will resume the queue.
+ *
+ *   A new vmobj is created when a zone event is received for a uuid that we're
+ *   not currently watching, which will then register observers for relevant
+ *   config files.
+ *
+ *   A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
+ *   DELETE event. At this point, we will also remove all watchers that were
+ *   setup for that vmobj.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var http = require('http');
+var path = require('path');
+var url = require('url');
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var diff = require('/usr/vm/node_modules/diff');
+var getDatasets = require('/usr/vm/node_modules/vmload/vmload-datasets').
+    getDatasets;
+var getZoneRecords = require('/usr/vm/node_modules/vmload/vmload-zoneadm').
+    getZoneRecords;
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var libuuid = require('/usr/node/node_modules/uuid');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vmload = require('/usr/vm/node_modules/vmload');
+
+var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
+var Queue = require('/usr/vm/node_modules//queue').Queue;
+var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
+var ZoneWatcher = require('./zonewatcher').ZoneWatcher;
+var ZpoolWatcher = require('./zpoolwatcher').ZpoolWatcher;
+
+/*
+ * Files in /zones/<uuid>/config to watch
+ */
+var CONFIG_FILES = [
+    'metadata.json',
+    'routes.json',
+    'tags.json'
+];
+
+/*
+ * sysinfo(1M) cache file
+ */
+var SYSINFO_FILE = '/tmp/.sysinfo.json';
+
+/*
+ * The keys of this map (ie. "disks" and "nics") are keys to a VM's JSON
+ * payload that are:
+ * 1: Guaranteed to be arrays of objects (this is asserted and will throw
+ * if not true)
+ *
+ * The values (ie. "path" and "mac" respectively) are keys inside the objects
+ * inside the array that are used as the unique identifiers.  This helps
+ * diff.js determine what kind of changes are made to an object.
+ */
+var DIFF_MAP = {
+    disks: 'path',
+    nics: 'mac'
+};
+
+/*
+ * Default job timeout for the queue.  Each task enqueued will have 1 minute
+ * from the time it starts to finish processing.  On average, most tasks
+ * take less than 1 second - this is just a kill switch for a hanging task.
+ */
+var QUEUE_TASK_TIMEOUT = 1 * 60 * 1000;
+
+/*
+ * Default number of records to store for refresh errors and log messages.
+ */
+var DEFAULT_REFRESH_RECORDS = 5;
+
+/*
+ * Default zpool for zones
+ */
+var ZONES_ZPOOL = 'zones';
+
+module.exports = Vminfod;
+function Vminfod(options) {
+    var self = this;
+
+    // global state/status - these are used primarily for debugging purposes
+    // and should be modified with the setState/setStatus functions
+    self.state = 'stopped';
+    self.status = 'initialized';
+
+    // consumers of the '/events' stream
+    self.events_listeners = {};
+
+    /*
+     * Structures to hold the raw data.
+     *
+     * The _tmp variants are used while the queue is paused and a full system
+     * refresh is being performed.  The full system refresh data will be stored
+     * in these variables, and then compared to the live data at the end of the
+     * refresh.  We store these globally so they can be modified during the
+     * queue fastForward portion of the "reset".
+     */
+    self.vm_data = {};
+    self.vm_data_tmp = undefined;
+    self.zone_vm_data = {};
+    self.zone_vm_data_tmp = {};
+
+    // the actual vmobjs held in memory
+    self.vmobjs = {};
+
+    // structures to hold the pre-serialized data - these are managed by the
+    // serialize* functions
+    self.vm_data_json = {};
+    self.vmobjs_json = {};
+
+    // configurable options
+    self.log = options.log;
+    assert(self.log, 'must provide a logger');
+    assert.optionalNumber(options.port, 'options.port');
+    assert.optionalArrayOfString(options.ips, 'options.ips');
+    assert.optionalNumber(options.refresh_interval, 'options.refresh_interval');
+
+    // set default ips and port
+    self.ips = options.ips || ['127.0.0.1'];
+    self.port = options.port || 9090;
+
+    // set default refresh interval for the periodic_timer
+    self.refresh_interval = options.refresh_interval || (5 * 60 * 1000);
+
+    /*
+     * Keep a log of every time self.reset() finds differences from what is on
+     * the system and what is in vminfod.
+     */
+    self.refresh_log = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});
+
+    /*
+     * Sometimes, self.reset() can fail but we don't necessarily want to kill
+     * the process. Instead, store the errors in a log and expose them over
+     * /status.
+     */
+    self.refresh_errors = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});
+
+    /*
+     * We need to create intermediate event listeners between self and
+     * clients subscribed to /events so we only have to JSON.stringify
+     * once per event, instead of once per client per event.
+     */
+    self.on('create', function (vmobj) {
+        var data;
+        var json;
+
+        data = {
+            type: 'create',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid,
+            vm: vmobj
+        };
+
+        self.log.info({ev: data}, 'emitting "create" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('create-json', json);
+    });
+
+    self.on('modify', function (vmobj, changes) {
+        var data;
+        var json;
+
+        data = {
+            type: 'modify',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid,
+            vm: vmobj,
+            changes: changes
+        };
+
+        self.log.info({ev: data}, 'emitting "modify" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('modify-json', json);
+    });
+
+    self.on('delete', function (vmobj) {
+        var data;
+        var json;
+
+        data = {
+            type: 'delete',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid
+        };
+
+        self.log.info({ev: data}, 'emitting "delete" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('delete-json', json);
+    });
+}
+util.inherits(Vminfod, EventEmitter);
+
+/*
+ * Set the internal state value
+ *
+ * This, and setStatus below, are useful for tracking what vminfod is currently
+ * processing (or at least, what it shoud be).  These internal variables can
+ * be accessed over the GET /status interface, and each variable transition
+ * can be seen in the log file.
+ */
+Vminfod.prototype.setState = function (/* args */) {
+    var self = this;
+
+    var state = util.format.apply(this, arguments);
+
+    self.log.debug({
+        oldstate: self.state,
+        newstate: state
+    }, 'state changed from "%s" to "%s"', self.state, state);
+
+    self.state = state;
+};
+
+/*
+ * Set the internal status value, see setState for more information
+ */
+Vminfod.prototype.setStatus = function (/* args */) {
+    var self = this;
+
+    var status = util.format.apply(this, arguments);
+
+    self.log.debug({
+        oldstatus: self.status,
+        newstatus: status
+    }, 'status changed from "%s" to "%s"', self.status, status);
+
+    self.status = status;
+};
+
+/*
+ * start vminfod
+ */
+Vminfod.prototype.start = function (callback) {
+    var self = this;
+
+    assert.func(callback, 'callback');
+
+    var started = process.hrtime();
+    self.log.info('vminfod starting');
+
+    vasync.pipeline({funcs: [
+        // update state
+        function (_, cb) {
+            self.setState('booting');
+            cb();
+        },
+        // init queue
+        function (_, cb) {
+            self.setStatus('initializing event queue');
+            var opts = {
+                workers: 1,
+                paused: true,
+                dedup: true,
+                log: self.log
+            };
+            self.event_queue = new Queue(opts);
+            self.event_queue.on('error', function queueError(err) {
+                self.log.debug({err: err}, 'ignoring queue error: %s',
+                    err.message);
+            });
+            cb();
+        },
+        // start global watchers
+        function (_, cb) {
+            self.setStatus('starting global watchers');
+            self.startWatchers(cb);
+        },
+        // start vm watchers
+        function (_, cb) {
+            self.setStatus('starting vm watchers');
+            self.startVmWatchers(cb);
+        },
+        // set vm_data
+        function (_, cb) {
+            self.setStatus('setting initial cache data');
+            self.setVmData(cb);
+        },
+        // set vmobjs data
+        function (_, cb) {
+            self.setStatus('setting initial vmobjs data');
+            self.setVmobjs(cb);
+        },
+        // resume queue
+        function (_, cb) {
+            self.setStatus('resuming the event queue');
+            self.event_queue.resume();
+            cb();
+        },
+        // start http server
+        function (_, cb) {
+            self.setStatus('starting http server');
+            self.startHTTPHandlers(cb);
+        },
+        // start refresh timers
+        function (_, cb) {
+            self.setStatus('starting refresh timers');
+            self.startTimers(cb);
+        }
+    ]}, function (err) {
+        var delta = process.hrtime(started);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+
+        if (err) {
+            self.log.error({err: err}, 'failed to complete boot sequence');
+            callback(err);
+            return;
+        }
+
+        self.setState('running');
+        self.setStatus('working');
+        self.log.info('boot sequence complete, took %s', prettyDelta);
+        self.emit('ready', self.vmobjs);
+
+        callback();
+    });
+};
+
+/*
+ * setVmobjs() sets the initial vmobjs data
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will request vmobjs from vmload.getVmobjs, using the cache
+ * object set in vm_cache. The result will then be converted from an array
+ * into a hash where the key is the vm uuid and the value is the vmobj.
+ *
+ * called by .start()
+ *
+ */
+Vminfod.prototype.setVmobjs = function setVmobjs(callback) {
+    var self = this;
+
+    var opts = {
+        cache: self.vm_data,
+        log: self.log,
+        keepalive: true,
+        loadManually: true
+    };
+    vmload.getVmobjs(function (_, cb) {
+        cb(null, true);
+    }, opts, function (err, results) {
+        var i = 0;
+
+        if (err) {
+            self.log.error({err: err}, 'failed to vmload.getVmobjs: %s',
+                err.message);
+            callback(err);
+            return;
+        }
+
+        self.vmobjs = {};
+        results.forEach(function (vmobj) {
+            i++;
+            assert.object(vmobj, 'vmobj');
+            assert.uuid(vmobj.uuid, 'vmobj.uuid');
+            self.vmobjs[vmobj.zonename] = vmobj;
+        });
+
+        self.log.debug('setVmobjs %d VMs found', i);
+        callback();
+    });
+};
+
+/*
+ * setVmData() sets the initial vm_data
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will request a cache object from _loadVmData and set
+ * vm_data
+ *
+ */
+Vminfod.prototype.setVmData = function setVmData(callback) {
+    var self = this;
+
+    self._loadVmData(function (err, cache) {
+        if (err) {
+            self.log.error('failed to set initial vm_data');
+            callback(err);
+            return;
+        }
+        self.log.debug('setting initial vm_data: %j', cache);
+        self.vm_data = cache;
+        callback();
+    });
+};
+
+/*
+ * Start any and all periodic timers needed by vminfod
+ *
+ * called by .start()
+ */
+Vminfod.prototype.startTimers = function startTimers(callback) {
+    var self = this;
+
+    assert(!self.periodic_timeout, 'timers already started');
+
+    function makeTimer(cb) {
+        self.periodic_timeout = setTimeout(function periodicTimeout() {
+
+            refresh(function refreshDone(err) {
+                /*
+                 * In the event of an error, we log it (both with bunyan and to
+                 * the refresh_errors log that is visible on `GET /status`) and
+                 * move on.
+                 *
+                 * There are legitmate situations that can cause "refresh" to
+                 * fail where we don't actually want vminfod to crash as a
+                 * result.  An example of this is doing a full `self.reset`
+                 * which loads all VMs off of the running system using
+                 * vmload.getVmobjs.  This function is inherently racy as it
+                 * first gets a list of all zone UUIDs on the system *and then*
+                 * does a load on each zone.  It's possible that in that time a
+                 * zone that was seen doing the full UUID list could have been
+                 * deleted.  In this situtation, `self.reset` will callback
+                 * with an error but that is not cause for us to stop vminfod
+                 * when running the periodic timer.  Instead, we just log it
+                 * and try again later.
+                 */
+                if (err) {
+                    self.refresh_errors.write({
+                        err: err,
+                        time: process.hrtime()
+                    });
+                    self.log.error({err: err}, 'failed to refresh data');
+
+                }
+
+                makeTimer();
+            });
+        }, self.refresh_interval);
+
+        if (cb) {
+            cb();
+        }
+    }
+
+    function refresh(cb) {
+        self.log.info('full data refresh');
+
+        vasync.pipeline({funcs: [
+            function (_, cb2) {
+                self.log.debug('full VM reset');
+                self.reset(cb2);
+            }, function (_, cb2) {
+                self.log.debug('checking for stale files to unwatch');
+
+                var vms = Object.keys(self.vmobjs);
+                var files = Object.keys(self.fsw.watching).filter(function (f) {
+                    // Ignore sysinfo since we always watch this file
+                    if (f === SYSINFO_FILE) {
+                        return false;
+                    }
+
+                    /*
+                     * Loop every VM on the system (the UUIDs).  If the UUID is
+                     * found inside the filename of the file being watched,
+                     * then we continue watching the file (filter it out of the
+                     * array). Any files left over are files being watched for
+                     * a VM that does not exist and can be unwatched.
+                     */
+                    return !(vms.some(function (vm) {
+                        return (f.indexOf(vm) > -1);
+                    }));
+                });
+
+                if (files.length === 0) {
+                    self.log.debug('found 0 stale files');
+                    cb2();
+                    return;
+                }
+
+                self.log.error({files: files}, 'found %d stale files',
+                    files.length);
+
+                vasync.forEachPipeline({
+                    func: function (f, cb3) {
+                        self.fsw.unwatch(f, cb3);
+                    },
+                    inputs: files
+                }, cb2);
+            }
+        ]}, cb);
+    }
+
+    makeTimer(callback);
+};
+
+/*
+ * startWatchers() starts global watchers
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will:
+ *   1) Create a FsWatcher object
+ *   2) Watch for changes to the sysinfo cache file
+ *   3) Create a ZoneWatcher
+ *   4) Create a ZpoolWatcher
+ */
+Vminfod.prototype.startWatchers = function startWatchers(callback) {
+    var self = this;
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            self.fsw = new FsWatcher({log: self.log, dedup: true});
+
+            self.fsw.on('event', function (obj) {
+                self.handleFsEvent(obj);
+            });
+
+            self.fsw.once('ready', function (obj) {
+                self.log.debug('filesystem watcher ready');
+                cb();
+            });
+
+            self.fsw.start();
+        }, function (_, cb) {
+            self.fsw.watch(SYSINFO_FILE, cb);
+        }, function (_, cb) {
+            self.zonew = new ZoneWatcher({log: self.log});
+
+            self.zonew.on('event', function (obj) {
+                self.handleZoneEvent(obj);
+            });
+
+            self.zonew.once('ready', function () {
+                self.log.debug('zone watcher ready');
+                cb();
+            });
+        }, function (_, cb) {
+            self.zpoolw = new ZpoolWatcher({log: self.log});
+
+            self.zpoolw.on('event', function (obj) {
+                self.handleZpoolEvent(obj);
+            });
+
+            self.zpoolw.once('ready', function () {
+                self.log.debug('zpool watcher ready');
+                cb();
+            });
+        }
+    ]}, function () {
+        self.log.info('global watchers ready');
+        callback();
+    });
+};
+
+/*
+ * startVmWatchers() starts the watchers for a VM
+ *
+ * Arguments:
+ *   'zonename' - a specific vm zonename to start watchers on
+ *   'callback' - will be called with (err)
+ *
+ *   'zonename' argument is optional, and when omitted will start watchers
+ *   for all vms.
+ */
+Vminfod.prototype.startVmWatchers =
+    function startVmWatchers(zonename, callback) {
+
+    var self = this;
+
+    if (typeof (zonename) === 'function') {
+        callback = zonename;
+        zonename = undefined;
+    }
+
+    // start watchers for a single VM
+    if (zonename) {
+        addVMFsWatches(zonename, callback);
+        return;
+    }
+
+    // start watchers for all VMs - since this function is ran before
+    // any cached data is gathered, we must gather the list of vms manually
+    var records;
+    vasync.pipeline({funcs: [
+        // load zone records
+        function (_, cb) {
+            var opts = {
+                log: self.log
+            };
+            getZoneRecords(null, opts, function (err, _records) {
+                if (err) {
+                    self.log.debug({err: err}, 'failed to load zone records');
+                    cb(err);
+                    return;
+                }
+
+                records = _records;
+                cb();
+            });
+        },
+        // start watchers
+        function (_, cb) {
+            vasync.forEachPipeline({
+                func: function (uuid, cb2) {
+                    addVMFsWatches(records[uuid].zonename, cb2);
+                },
+                inputs: Object.keys(records)
+            }, function (err, results) {
+                cb(err);
+            });
+        }
+    ]}, function (err) {
+        if (err) {
+            self.log.error({err: err}, 'failed to start vm watchers');
+            callback(err);
+            return;
+        }
+
+        callback();
+    });
+
+
+    /*
+     * create fs watches for a given zone
+     */
+    function addVMFsWatches(zone, cb) {
+        var files = [
+            util.format('/etc/zones/%s.xml', zone),
+            util.format('/zones/%s/lastexited', zone)
+        ];
+        CONFIG_FILES.forEach(function (f) {
+            files.push(util.format('/zones/%s/config/%s', zone, f));
+        });
+
+        self.log.debug({files: files}, 'adding vm fs watchers for %s',
+            zone);
+
+        vasync.forEachPipeline({
+            func: function (f, cb2) {
+                self.fsw.watch(f, cb2);
+            },
+            inputs: files
+        }, function (err, results) {
+            self.log.debug({err: err},
+                'finished adding vm fs watchers for %s', zone);
+            cb(err);
+        });
+    }
+};
+
+
+/*
+ * Start the HTTP interface
+ *
+ * called by .start()
+ */
+Vminfod.prototype.startHTTPHandlers = function startHTTPHandlers(callback) {
+    var self = this;
+
+    vasync.forEachPipeline({
+        inputs: self.ips,
+        func: function (ip, cb) {
+            http.createServer(handler).listen(self.port, ip, function () {
+                self.log.debug('listening on http://%s:%d', ip, self.port);
+                cb();
+            });
+        }
+    }, callback);
+
+    // http handler
+    function handler(req, res) {
+        var args;
+        var c;
+        var url_parts;
+
+        url_parts = url.parse(req.url, true);
+        c = path.normalize(url_parts.pathname).split('/');
+        c.shift();
+
+        args = url_parts.query || {};
+        self.log.info({req: req}, 'HTTP request');
+
+        if (req.method !== 'GET') {
+            // Bad request
+            res.writeHead(400, {'Content-Type': 'application/json'});
+            res.end();
+        } else {
+            handleGet(c, args, req, res);
+        }
+    }
+
+    // handler specifically for GET requests
+    function handleGet(c, args, req, res) {
+        var ret;
+        var obj;
+        var uuid;
+
+        switch (c[0]) {
+        case 'ping':
+            ret = {
+                ping: 'pong'
+            };
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(JSON.stringify(ret), 'utf-8');
+            break;
+        case 'status':
+            ret = {
+                pid: process.pid,
+                uptime: process.uptime(),
+                memory: process.memoryUsage(),
+                state: self.state,
+                status: self.status,
+                numVms: Object.keys(self.vmobjs).length,
+                curDate: new Date(),
+                curTime: hrtime.hrtimeToString(process.hrtime()),
+                queue: self.event_queue.dump(),
+                refresh_errors:
+                    formatRefreshErrors(self.refresh_errors.records),
+                events_listeners: formatEventsListeners(self.events_listeners)
+            };
+            if (args.full) {
+                ret.refresh_log = formatRefreshLog(self.refresh_log.records);
+                ret.fswatcher = self.fsw.dump();
+            }
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(JSON.stringify(ret), 'utf-8');
+            break;
+        case 'vms':
+            var zonename = c[1];
+
+            if (zonename) {
+                // requesting a vmobj with zonename
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    res.writeHead(404, {'Content-Type': 'application/json'});
+                    res.write('VM Not Found: ' + zonename);
+                    res.end();
+                } else {
+                    res.writeHead(200, {'Content-Type': 'application/json'});
+                    res.end(self.serializeVm(zonename), 'utf-8');
+                }
+                break;
+            }
+
+            // requesting the vmobj list
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(self.serializeVms(), 'utf-8');
+            break;
+        case 'events':
+            uuid = libuuid.create();
+            obj = {
+                // currently vminfod listens on localhost only so
+                // the ip addresses are always the same
+                // ip: request.connection.remoteAddress,
+                userAgent: req.headers['user-agent'],
+                createdDate: new Date(),
+                createdTime: process.hrtime()
+            };
+            self.log.debug({uuid: uuid, obj: obj},
+                'new /events listener created');
+
+            res.writeHead(200, {'Content-Type': 'application/json'});
+
+            var on_create = function (json) {
+                res.write(json + '\n');
+            };
+            var on_modify = function (json) {
+                res.write(json + '\n');
+            };
+            var on_delete = function (json) {
+                res.write(json + '\n');
+            };
+            var on_close = function () {
+                res.end();
+                cleanup();
+            };
+
+            function cleanup() {
+                self.log.debug({uuid: uuid, obj: obj},
+                    '/events listener removed');
+                self.removeListener('create-json', on_create);
+                self.removeListener('modify-json', on_modify);
+                self.removeListener('delete-json', on_delete);
+                self.removeListener('close', on_close);
+                delete self.events_listeners[uuid];
+            }
+
+            self.on('create-json', on_create);
+            self.on('modify-json', on_modify);
+            self.on('delete-json', on_delete);
+            self.on('close', on_close);
+            self.events_listeners[uuid] = obj;
+
+            res.on('close', cleanup);
+
+            // let this client stay open forever
+            res.connection.setTimeout(0);
+
+            // let the client know it is subscribed
+            res.write(JSON.stringify({
+                type: 'ready',
+                date: obj.createdDate,
+                uuid: uuid,
+                vms: self.serializeVms()
+            }) + '\n');
+            break;
+        default:
+            res.writeHead(404, {'Content-Type': 'application/json'});
+            res.write('Unsupported URL Path');
+            res.end();
+            break;
+        }
+    }
+};
+
+/*
+ * Stop the vminfod daemon
+ */
+Vminfod.prototype.stop = function stop(callback) {
+    var self = this;
+
+    self.zonew.stop();
+    self.zpoolw.stop();
+
+    if (self.periodic_timer) {
+        clearTimeout(self.periodic_timer);
+        self.periodic_timer = null;
+    }
+
+    self.fsw.stop(function fswStopped() {
+        self.emit('end');
+
+        if (callback) {
+            callback();
+        }
+    });
+};
+
+
+/*
+ * stopVmWatchers() stops the watchers for a VM
+ *
+ * Arguments:
+ *   'zonename' - a specific vm zonename to stop watchers on
+ *   'callback' - will be called with (err)
+ *
+ *   'zonename' argument is optional, and when omitted will stop watchers
+ *   for all vms.
+ */
+Vminfod.prototype.stopVmWatchers = function stopVmWatchers(zonename, callback) {
+    var self = this;
+
+    if (typeof (zonename) === 'function') {
+        callback = zonename;
+        zonename = undefined;
+    }
+
+    // stop watchers for a single VM
+    if (zonename) {
+        removeVMFsWatches(zonename, callback);
+        return;
+    }
+
+    // stop watchers for all VMs
+    vasync.forEachPipeline({
+        func: removeVMFsWatches,
+        inputs: Object.keys(self.vmobjs)
+    }, function (err, results) {
+        callback(err);
+    });
+
+    /*
+     * remove fs watches for a given zone
+     */
+    function removeVMFsWatches(zone, cb) {
+        var files = [
+            util.format('/etc/zones/%s.xml', zone),
+            util.format('/zones/%s/lastexited', zone)
+        ];
+        CONFIG_FILES.forEach(function (f) {
+            files.push(util.format('/zones/%s/config/%s', zone, f));
+        });
+
+        self.log.debug({files: files}, 'removing vm fs watchers for %s',
+            zone);
+
+        vasync.forEachPipeline({
+            func: function (f, cb2) {
+                self.fsw.unwatch(f, cb2);
+            },
+            inputs: files
+        }, function (err, results) {
+            self.log.debug({err: err},
+                'finished removing vm fs watchers for %s', zone);
+            cb(err);
+        });
+    }
+};
+
+/*
+ * Return a JSON serialized string for a given vm.  This will return
+ * a cached object, or generate the contents and cache the result.
+ *
+ * Returns undefined if the vm is not found
+ */
+Vminfod.prototype.serializeVm = function serializeVm(zonename) {
+    var self = this;
+
+    if (!self.vmobjs_json.hasOwnProperty(zonename)) {
+        self.vmobjs_json[zonename] = JSON.stringify(self.vmobjs[zonename]);
+    }
+
+    return self.vmobjs_json[zonename];
+};
+
+/*
+ * Return a JSON serialized string for all zones.
+ */
+Vminfod.prototype.serializeVms = function serializeVms() {
+    var self = this;
+
+    var json = '[';
+    var zones = Object.keys(self.vmobjs);
+
+    zones.forEach(function (zone, index) {
+        json += self.serializeVm(zone);
+
+        if (index < zones.length - 1) {
+            json += ',';
+        }
+    });
+
+    json += ']';
+
+    return json;
+};
+
+/*
+ * reset() hard reset the data to ensure integrity
+ *
+ * This function will:
+ *   1- pause the event queue
+ *   2- fetch new vm_data
+ *   3- fast-forward the event queue
+ *   4- compare datasets
+ *   5- replace vm_data with vm_data_tmp if the sets are different
+ *   6- refresh vmobjs if the sets are different
+ *   7- resume the event queue
+ */
+Vminfod.prototype.reset = function reset(callback) {
+    var self = this;
+
+    var old_vm_data;
+    var obj = {
+        started: process.hrtime(),
+        vmChanges: [],
+        cacheChanges: null
+    };
+
+    vasync.pipeline({funcs: [
+        // pause the queue
+        function (_, cb) {
+            self.setState('paused');
+            self.setStatus('pausing the event queue');
+            self.log.debug('%d VMs total', Object.keys(self.vmobjs).length);
+
+            self.event_queue.pause({timeout: 5 * 60 * 1000},
+                function (err) {
+
+                if (err) {
+                    self.log.warn('failed to pause the queue: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
+        },
+        // fetch new data
+        function (_, cb) {
+            self.setStatus('fetching vm cache data');
+            self._loadVmData(function (err, results) {
+                if (err) {
+                    self.log.error('failed to fetch new vm_data');
+                    cb(err);
+                    return;
+                }
+
+                self.vm_data_tmp = results;
+                cb();
+            });
+        },
+        // fast-forward the queue
+        function (_, cb) {
+            var now = process.hrtime();
+            self.setStatus('fast-forwarding the queue to %j', now);
+            self.event_queue.fastForward(now, {timeout: 5 * 60 * 1000},
+                function (err) {
+
+                if (err) {
+                    self.log.warn('failed to fast-forward queue: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
+        },
+        // compare/update vmobjs
+        function (_, cb) {
+            self.setStatus('comparing vmobj sets');
+
+            var changes = diff(self.vm_data, self.vm_data_tmp);
+
+            // filter out "last_modified" since we handle this ourselves
+            changes = changes.filter(function (change) {
+                return change.path[0] !== 'last_modified';
+            });
+
+            // if changes are empty, we have nothing left to do
+            if (changes.length === 0) {
+                self.log.info('vmobj sets are in sync');
+                cb();
+                return;
+            }
+
+            self.log.warn({changes: changes}, 'vm_data and vm_data_tmp diff');
+
+            obj.cacheChanges = changes;
+
+            self.setStatus('synchronizing data');
+
+            // keep a temporary reference to compare against
+            old_vm_data = self.vm_data;
+
+            // replace the data with new
+            self.vm_data = self.vm_data_tmp;
+
+            vasync.pipeline({funcs: [
+                // create vmobjs we don't know about
+                function (__, cb2) {
+                    var new_objs = self.vm_data.zoneadm_objects;
+                    var keys = Object.keys(new_objs);
+
+                    vasync.forEachParallel({
+                        inputs: keys,
+                        func: function (zonename, cb3) {
+                            var old_objs = old_vm_data.zoneadm_objects;
+                            if (old_objs.hasOwnProperty(zonename)) {
+                                cb3();
+                                return;
+                            }
+
+                            obj.vmChanges.push({
+                                zonename: zonename,
+                                action: 'create'
+                            });
+                            self.createVmobj(zonename, cb3);
+                        }
+                    }, cb2);
+                },
+                // delete vmobjs we shouldn't know about
+                function (__, cb2) {
+                    var old_objs = old_vm_data.zoneadm_objects;
+                    var keys = Object.keys(old_objs);
+
+                    vasync.forEachParallel({
+                        inputs: keys,
+                        func: function (zonename, cb3) {
+                            var new_objs = self.vm_data.zoneadm_objects;
+                            if (new_objs.hasOwnProperty(zonename)) {
+                                cb3();
+                                return;
+                            }
+
+                            obj.vmChanges.push({
+                                zonename: zonename,
+                                action: 'delete'
+                            });
+                            self.deleteVmobj(zonename, cb3);
+                        }
+                    }, cb);
+                },
+                // refresh the rest
+                function (__, cb2) {
+                    vasync.forEachParallel({
+                        inputs: Object.keys(self.vmobjs),
+                        func: function (zone, cb3) {
+                            self.refreshVmobj(zone, function (err, o) {
+                                var changeObj;
+
+                                if (o && (o.changed || o.deleted)) {
+                                    changeObj = {
+                                        zonename: zone,
+                                        action: o.deleted ? 'delete' : 'modify'
+                                    };
+                                    if (changeObj.action === 'modify') {
+                                        changeObj.changes = o.changes;
+                                    }
+
+                                    obj.vmChanges.push(changeObj);
+                                }
+
+                                cb3(err);
+                            });
+                        }
+                    }, cb2);
+                }
+            ]}, cb);
+        }
+    ]}, function (err) {
+        // always make sure vminfod goes back to a running state
+        self.setState('running');
+        self.setStatus('working');
+        self.vm_data_tmp = undefined;
+
+        var ended = process.hrtime();
+        var delta = hrtime.hrtimeDelta(ended, obj.started);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+
+        if (obj.cacheChanges) {
+            obj.ended = ended;
+            obj.delta = delta;
+            obj.prettyDelta = prettyDelta;
+            self.refresh_log.write(obj);
+        }
+
+        self.log.debug({obj: obj}, 'self.reset() took %s: %d vms changed',
+            prettyDelta, obj.vmChanges.length);
+
+        self.log.info('resuming the event queue');
+        self.event_queue.resume();
+
+
+        callback(err);
+    });
+};
+
+/*
+ * loadVmData() loads a cache object from vmload.getZoneData
+ *
+ * Arguments:
+ *   'callback' - will be called with (err, cache)
+ *
+ * This function will load a cache object from vmload.getZoneData
+ * passing a nocache: true flag to ensure the cache object is generated
+ * from raw data.
+ *
+ */
+Vminfod.prototype._loadVmData = function _loadVmData(callback) {
+    var self = this;
+
+    var opts = {
+        log: self.log,
+        nocache: true,
+        keepalive: true
+    };
+    vmload.getZoneData(null, opts, function (err, cache) {
+        if (err) {
+            self.log.error({err: err}, 'failed vmload.getZoneData: %s',
+                err.message);
+            callback(err);
+            return;
+        }
+
+        callback(null, cache);
+    });
+};
+
+/*
+ * Called when a new VM is seen
+ *
+ * This will create all internal variables needed for the VM, as well as
+ * emit a "create" event
+ */
+Vminfod.prototype.createVmobj = function createVmobj(zonename, callback) {
+    var self = this;
+
+    var uuid;
+
+    if (self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.warn('createVmobj(%s) called for zone already known about',
+            zonename);
+        callback();
+        return;
+    }
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            /*
+             * Figure out the zone UUID from the zonename seen.  If the
+             * zonename is a UUID, assume that it is the zones UUID and skip
+             * the call to getZoneRecords.
+             */
+            if (isUUID(zonename)) {
+                uuid = zonename;
+                cb();
+                return;
+            }
+
+            var opts = {
+                log: self.log
+            };
+            getZoneRecords(zonename, opts, function (err, records) {
+                if (err) {
+                    self.log.debug({err: err}, 'failed to getZoneRecords(%s)',
+                        zonename);
+                    cb(err);
+                    return;
+                }
+
+                var keys = Object.keys(records);
+
+                assert.equal(keys.length, 1, 'Only 1 record found');
+
+                uuid = keys[0];
+
+                self.log.warn('VM zonename "%s" does not match uuid "%s"',
+                    zonename, uuid);
+
+                cb();
+            });
+        }, function (_, cb) {
+            assert.uuid(uuid, 'uuid');
+
+            self.log.debug({uuid: uuid, zonename: zonename},
+                'createVmobj zonename: %s -> uuid: %s', zonename, uuid);
+
+            cb();
+        }, function (_, cb) {
+            var opts = {
+                log: self.log,
+                keepalive: true
+            };
+            vmload.getZoneData(uuid, opts, function (err, res) {
+                if (err) {
+                    self.log.error('failed to getZoneData(%s): %s',
+                        uuid, err.message);
+                    cb(err);
+                    return;
+                }
+
+                if (self.vm_data_tmp !== undefined)
+                    self.zone_vm_data_tmp[zonename] = res;
+                self.zone_vm_data[zonename] = res;
+
+                cb();
+            });
+        }, function (_, cb) {
+            self.mergeZoneVmDatasets(zonename);
+            cb();
+        }, function (_, cb) {
+            vasync.forEachParallel({
+                inputs: self.vmDatasets(),
+                func: function (vm_data, cb2) {
+                    var opts = {
+                        log: self.log,
+                        cache: vm_data,
+                        keepalive: true,
+                        loadManually: true
+                    };
+                    vmload.getVmobj(uuid, opts, function (err2, vmobj) {
+                        if (err2) {
+                            self.log.error('failed to getVmobj(%s): %s',
+                                uuid, err2.message);
+                            cb2(err2);
+                            return;
+                        }
+
+                        if (self.vmobjs.hasOwnProperty(zonename)) {
+                            self.log.error('vmobj already created for %s',
+                                zonename);
+                            cb2();
+                            return;
+                        }
+
+                        assert.object(vmobj, 'vmobj');
+                        assert.uuid(vmobj.uuid, 'vmobj.uuid');
+
+                        self.vmobjs[zonename] = vmobj;
+                        self.startVmWatchers(zonename, function (err) {
+                            self.log.info('started watching %s', zonename);
+                            self.emit('create', vmobj);
+                            cb2();
+                        });
+                    });
+                }
+            }, cb);
+        }
+    ]}, function (err) {
+        if (err) {
+            /*
+             * We ignore any errors here as they will be rectified when the
+             * periodic timer runs.
+             */
+            self.log.error({err: err}, 'createVmobj(%s) (uuid: %s)',
+                zonename, uuid);
+        }
+        callback();
+    });
+};
+
+/*
+ * Called when a VM is deleted
+ *
+ * This will remove all internal variables needed by the VM as well as emit a
+ * "delete" event
+ */
+Vminfod.prototype.deleteVmobj = function deleteVmobj(zonename, callback) {
+    var self = this;
+
+    if (!self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.warn('deleteVmobj(%s) called for non-existent zone',
+            zonename);
+        callback();
+        return;
+    }
+
+    var obj = {
+        zonename: zonename,
+        uuid: self.vmobjs[zonename].uuid
+    };
+    assert.uuid(obj.uuid, 'obj.uuid for: ' + zonename);
+
+    vasync.pipeline({funcs: [
+        // delete vmobj
+        function (_, cb) {
+            delete (self.vmobjs)[zonename];
+            delete (self.vmobjs_json)[zonename];
+            cb();
+        },
+        // clean vm_data
+        function (_, cb) {
+            self.vmDatasets().forEach(function (data) {
+                for (var key in data) {
+                    if (data[key].hasOwnProperty(zonename)) {
+                        delete (data[key])[zonename];
+                    }
+                }
+            });
+            cb();
+        },
+        // unregister events
+        function (_, cb) {
+            self.stopVmWatchers(zonename, cb);
+        }
+    ]}, function (err) {
+        if (err) {
+            self.log.error({err: err}, 'deleteVmobj(%s)', zonename);
+            /*
+             * If this fails we keep going since the periodic timer refresh
+             * will handle cleaning up any stray files that haven't been
+             * unwatched.
+             */
+        }
+        self.log.info('stopped watching %s', zonename);
+        self.emit('delete', obj);
+        callback();
+    });
+};
+
+/*
+ * refreshVmobj() refreshes the cached vmobj and reports any changes
+ *
+ * Process:
+ *     1) refresh the vm_data cache by calling vmload.getZoneData
+ *     2) request a new vmobj by calling vmload.getVmobj
+ *     3) analyze vmobj delta
+ *     4) if different:
+ *       4a) replace the vmobj with the new vmobj
+ *       4b) log the delta
+ *       4c) inform any subscribers of the delta
+ */
+Vminfod.prototype.refreshVmobj =
+    function refreshVmobj(zonename, vm_datasets, callback) {
+
+    var self = this;
+
+    var ret = {
+        changed: false,
+        deleted: false,
+        changes: []
+    };
+
+    if (typeof (vm_datasets) === 'function') {
+        callback = vm_datasets;
+        self.cloneVmDatasets(zonename);
+        vm_datasets = self.vmDatasets(zonename);
+    }
+
+    // short-circuit if this vmobj doesn't exist
+    if (!self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.debug('cannot refresh vmobj, doesn\'t exist');
+        self.resetVmDatasets(zonename);
+        callback(null, ret);
+        return;
+    }
+
+    var vmobj;
+    vasync.pipeline({funcs: [
+        // refresh vm_data cache
+        function (_, cb) {
+            self.log.debug('refreshing zoneData for %s', zonename);
+            vasync.forEachParallel({
+                inputs: vm_datasets,
+                func: function (vm_data, cb2) {
+                    var opts = {
+                        log: self.log,
+                        cache: vm_data,
+                        keepalive: true
+                    };
+                    vmload.getZoneData(zonename, opts,
+                        function (err, cache) {
+
+                        /*
+                         * We don't care about cache here because we provided a
+                         * cache object that was transformed by reference. So,
+                         * cache in this case is just a reference to vm_data,
+                         * which we already store globally. The idea here is
+                         * that we just fill in the holes that we previously
+                         * created.
+                         */
+
+                        if (err) {
+                            self.log.error({err: err},
+                                'failed to refresh vmobj %s: getZoneData %s',
+                                zonename, err.message);
+
+                            if (err.code === 'ENOENT'
+                                && err.message.
+                                match(/No such zone configured$/)) {
+
+                                ret.deleted = true;
+                            }
+
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            }, cb);
+        },
+        // merge zone_vm_objs
+        function (_, cb) {
+            self.mergeZoneVmDatasets(zonename);
+            cb();
+        },
+        // request a new vmobj
+        function (_, cb) {
+            self.log.debug('requesting new vmobj for %s', zonename);
+            var opts = {
+                log: self.log,
+                keepalive: true,
+                cache: self.vm_data,
+                loadManually: true
+            };
+            vmload.getVmobj(zonename, opts, function (err, _vmobj) {
+                if (err) {
+                    self.log.error({err: err},
+                        'unable to refresh vmobj for %s, failed getVmobj',
+                        zonename);
+
+                    if (err.code === 'ENOENT'
+                        && err.message.match(/No such zone configured$/)) {
+
+                        ret.deleted = true;
+                    }
+
+                    cb(err);
+                    return;
+                }
+
+                vmobj = _vmobj;
+                cb();
+            });
+        },
+        // analyze delta, update live copy
+        function (_, cb) {
+            /*
+             * We remove both VMs "last_modified" property to compare the
+             * objects.  If there are no changes, we keep at as the current
+             * value, and if there are any changes we silently set it to the
+             * current time.
+             */
+            var cur_last_modified = self.vmobjs[zonename].last_modified;
+            delete self.vmobjs[zonename].last_modified;
+            delete vmobj.last_modified;
+
+            var changes;
+            try {
+                changes = diff(self.vmobjs[zonename], vmobj, {
+                    map: DIFF_MAP
+                });
+            } catch (err) {
+                self.log.error({
+                    from: self.vmobjs[zonename],
+                    to: vmobj,
+                    err: err},
+                    'failed to calculate object diff');
+                throw err;
+            }
+            self.vmobjs[zonename] = vmobj;
+
+            if (changes.length > 0) {
+                self.vmobjs[zonename].last_modified = new
+                    Date().toISOString();
+                delete (self.vmobjs_json[zonename]);
+                ret.changed = true;
+                ret.changes = changes;
+                self.emit('modify', vmobj, changes);
+            } else {
+                self.vmobjs[zonename].last_modified = cur_last_modified;
+            }
+
+            cb();
+        }
+    ]}, function (err) {
+        if (ret.deleted) {
+            assert(err, 'error not set when ret.deleted');
+            delete ret.changes;
+
+            self.log.debug({uuid: zonename},
+                'marking %s as deleted', zonename);
+
+            self.deleteVmobj(zonename, function (err2) {
+                if (err2) {
+                    self.log.error({uuid: zonename, err: err2},
+                        'error marking %s as deleted',
+                        zonename);
+                } else {
+                    self.log.debug({uuid: zonename},
+                        'successfully marked %s as deleted',
+                        zonename);
+                }
+
+                callback(err2, ret);
+            });
+            return;
+        }
+
+        callback(err, ret);
+    });
+};
+
+/*
+ * return the active data objects for a given zone (if zonename is set)
+ * or for all zones.
+ */
+Vminfod.prototype.vmDatasets = function vmDatasets(zonename) {
+    var self = this;
+    var ret = [];
+
+    if (zonename) {
+        ret.push(self.zone_vm_data[zonename]);
+        if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+            ret.push(self.zone_vm_data_tmp[zonename]);
+        }
+    } else {
+        ret.push(self.vm_data);
+        if (self.vm_data_tmp !== undefined) {
+            ret.push(self.vm_data_tmp);
+        }
+    }
+
+    return (ret);
+};
+
+/*
+ * remove the given zone from the internal zone data
+ */
+Vminfod.prototype.resetVmDatasets = function resetVmDatasets(zonename) {
+    var self = this;
+
+    if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+        delete (self.zone_vm_data_tmp)[zonename];
+    }
+
+    if (self.zone_vm_data.hasOwnProperty(zonename)) {
+        delete (self.zone_vm_data)[zonename];
+    }
+};
+
+/*
+ * copy a single zone's information from the "all zones" cache to an
+ * individual cache specific to the zone
+ */
+Vminfod.prototype.cloneVmDatasets = function cloneVmDatasets(zonename) {
+    var self = this;
+
+    function cloneVmDataset(from, to) {
+        Object.keys(from).forEach(function (key) {
+            switch (key) {
+            case 'dataset_objects':
+            case 'sysinfo':
+                to[key] = from[key];
+                break;
+            default:
+                if (!to.hasOwnProperty(key)) {
+                    to[key] = {};
+                }
+                if (from[key].hasOwnProperty(zonename)) {
+                    to[key][zonename] = from[key][zonename];
+                }
+                break;
+            }
+        });
+    }
+
+    if (self.vm_data_tmp !== undefined) {
+        self.zone_vm_data_tmp[zonename] = {};
+        cloneVmDataset(self.vm_data_tmp, self.zone_vm_data_tmp[zonename]);
+    }
+
+    self.zone_vm_data[zonename] = {};
+    cloneVmDataset(self.vm_data, self.zone_vm_data[zonename]);
+};
+
+/*
+ * take a zones specific information and put it in the "all zones" cache, as
+ * well as clear the individual zones cache
+ */
+Vminfod.prototype.mergeZoneVmDatasets = function mergeZoneVmDatasets(zonename) {
+    var self = this;
+
+    /*
+     * The rationale here is to iterate through all of the keys in the from
+     * object and check for a zonename key. If it exists, copy it over. Then
+     * we remove any objects containing the zonename key in the to object
+     * that aren't in the from object, to ensure we don't leave any cruft.
+     */
+    function mergeVmDataset(from, to) {
+        Object.keys(from).forEach(function (key) {
+            if (from[key].hasOwnProperty(zonename)) {
+                to[key][zonename] = from[key][zonename];
+            } else {
+                if (to[key].hasOwnProperty(zonename)) {
+                    delete (to[key])[zonename];
+                }
+            }
+        });
+    }
+
+    /*
+     * Any time a point of data has been merged, we also need to clear
+     * the cached JSON for this data. The JSON will later be generated
+     * and cached as needed by incoming requests.
+     */
+    function clearCache(from) {
+        Object.keys(from).forEach(function (key) {
+            if (from[key].hasOwnProperty(zonename)
+                && self.vm_data_json.hasOwnProperty(key)
+                && self.vm_data_json[key].hasOwnProperty(zonename)) {
+
+                delete (self.vm_data_json[key])[zonename];
+            }
+        });
+    }
+
+    if (self.vm_data_tmp !== undefined
+        && self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+
+        mergeVmDataset(self.zone_vm_data_tmp[zonename], self.vm_data_tmp);
+        clearCache(self.zone_vm_data_tmp[zonename]);
+    }
+
+    if (self.zone_vm_data.hasOwnProperty(zonename)) {
+        mergeVmDataset(self.zone_vm_data[zonename], self.vm_data);
+        clearCache(self.zone_vm_data[zonename]);
+    }
+
+    self.resetVmDatasets(zonename);
+};
+
+/*
+ * poke holes in cache objects for a specific zone
+ */
+Vminfod.prototype.invalidateZoneDataCache =
+    function invalidateZoneDataCache(zonename, vm_datasets, contexts) {
+
+    vm_datasets.forEach(function (data) {
+        contexts.forEach(function (context) {
+            if (!data.hasOwnProperty(context))
+                return;
+
+            if (data[context].hasOwnProperty(zonename))
+                delete (data[context])[zonename];
+
+            if (Object.keys(data[context]).length === 0)
+                delete data[context];
+        });
+    });
+};
+
+/*
+ * handleZoneEvent() is a callback for a ZoneWatcher
+ *
+ * Process:
+ *
+ *   First we extract the zonename property from the event, then see if we
+ *   have any vmobjs registered with that zonename. If not, then this must
+ *   be a vm create, which we will:
+ *     1) fetch the vmobj from vmload.getVmobj
+ *     2) register observers
+ *     3) inform subscribers of the new vmobj
+ *   If this is a vm that we already know about, we will:
+ *     1) invalidate the relevant pieces of the vm_data
+ *     2) refresh the vmobj by calling refreshVmobj
+ */
+Vminfod.prototype.handleZoneEvent = function handleZoneEvent(obj) {
+    var self = this;
+
+    assert.object(obj, 'obj');
+    assert.string(obj.zonename, 'obj.zonename');
+
+    var zonename = obj.zonename;
+    var meta = util.format('zonename: %s newstate: %s',
+        zonename, obj.newstate);
+    var vm_datasets;
+
+    self.log.debug({obj: obj}, 'handleZoneEvent: %s', meta);
+
+    self.event_queue.enqueue({
+        description: 'handle zone event - zonename: ' + zonename,
+        timeout: QUEUE_TASK_TIMEOUT,
+        func: function (extras, callback) {
+            if (!self.vmobjs.hasOwnProperty(zonename)) {
+                // a new vm!
+                self.createVmobj(zonename, callback);
+                return;
+            }
+
+            self.cloneVmDatasets(zonename);
+            vm_datasets = self.vmDatasets(zonename);
+
+            // remove pieces of the cache that might have been affected
+            var contexts = [
+                'pids',
+                'zoneadm_objects',
+                'zonexml_objects',
+                'zoneinfo_objects'
+            ];
+
+            self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+            self.refreshVmobj(zonename, vm_datasets, callback);
+        }
+    });
+};
+
+/*
+ * handleFsEvent() is a callback for a FsWatcher
+ */
+Vminfod.prototype.handleFsEvent = function handleFsEvent(obj) {
+    var self = this;
+
+    var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
+    var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
+    var lastexit_re = /\/zones\/(.+)\/lastexited/;
+    var contexts;
+    var matches;
+    var meta;
+    var vm_datasets;
+    var zonename;
+
+    assert.object(obj, 'obj');
+    assert.string(obj.pathname, 'obj.pathname');
+
+    meta = util.format('pathname: %s (%s)',
+        obj.pathname, obj.changes || obj.type);
+
+    self.log.debug({obj: obj}, 'handleFsEvent: %s', meta);
+
+    // zone XML file
+    if ((matches = obj.pathname.match(zonexml_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle zonexml fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function (extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    extras.log.debug('vmobj doesn\'t exist for %s',
+                        zonename);
+                    callback();
+                    return;
+                }
+
+                switch (obj.type) {
+                case 'delete':
+                    extras.log.debug('%s deleted', obj.pathname);
+                    // the show is over! teardown!
+                    self.deleteVmobj(zonename, callback);
+                    break;
+                case 'change':
+                    extras.log.debug('%s modified', obj.pathname);
+                    self.cloneVmDatasets(zonename);
+                    vm_datasets = self.vmDatasets(zonename);
+
+                    // clear the missing pieces and refresh
+                    contexts = [
+                        'zonexml_objects',
+                        'zoneinfo_objects'
+                    ];
+
+                    self.invalidateZoneDataCache(zonename, vm_datasets,
+                        contexts);
+                    self.refreshVmobj(zonename, vm_datasets, callback);
+                    break;
+                default:
+                    extras.log.warn({obj: obj},
+                        'unhandled fs change type "%s"',
+                        obj.type);
+                    callback();
+                    break;
+                }
+            }
+        });
+
+    // zone metadata file
+    } else if ((matches = obj.pathname.match(metadata_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle metadata fs update - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function (extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    extras.log.debug('vmobj doesn\'t exist for %s',
+                        zonename);
+                    callback();
+                    return;
+                }
+
+                self.cloneVmDatasets(zonename);
+                vm_datasets = self.vmDatasets(zonename);
+
+                // clear the missing pieces and refresh
+                contexts = [
+                    'json_objects'
+                ];
+
+                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+                self.refreshVmobj(zonename, vm_datasets, callback);
+            }
+        });
+    // zone lastexited file
+    } else if ((matches = obj.pathname.match(lastexit_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle lastexit fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function (extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    self.log.debug('vmobj doesn\'t exist for ' + zonename);
+                    callback();
+                    return;
+                }
+
+                self.cloneVmDatasets(zonename);
+                vm_datasets = self.vmDatasets(zonename);
+
+                // clear the missing pieces and refresh
+                contexts = [
+                    'last_exited'
+                ];
+
+                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+                self.refreshVmobj(zonename, vm_datasets, callback);
+            }
+        });
+
+    // sysinfo
+    } else if (obj.pathname === SYSINFO_FILE) {
+        self.event_queue.enqueue({
+            description: 'handle sysinfo fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function (extras, callback) {
+                vasync.forEachParallel({
+                    inputs: self.vmDatasets(),
+                    func: function (data, cb) {
+                        if (data.hasOwnProperty('sysinfo')) {
+                            delete data.sysinfo;
+                        }
+
+                        var opts = {
+                            log: extras.log,
+                            cache: data,
+                            keepalive: true
+                        };
+                        vmload.getZoneData(null, opts,
+                            function (err, cache) {
+
+                            if (err) {
+                                extras.log.error('failed to refresh '
+                                    + 'sysinfo, failed to getZoneData');
+                            }
+
+                            cb();
+                        });
+                    }
+                }, callback);
+            }
+        });
+    } else {
+        self.log.warn('unhandled event for file: %s', obj.pathname);
+    }
+};
+
+/*
+ * handleZpoolEvent() is a callback for a zpool watcher
+ *
+ * Process:
+ *
+ *   When action is clone or create:
+ *     - fetch zpool data
+ *     - merge into vm_cache
+ *     - refresh vmobj
+ *
+ *   When action is set:
+ *     - unset vm_data pieces
+ *     - fetch zpool data
+ *     - merge into vm_cache
+ *     - refresh vmobj
+ *
+ *   When action is destroy:
+ *     - unset vm_data
+ *     - refresh vmobj
+ *
+ */
+Vminfod.prototype.handleZpoolEvent = function handleZpoolEvent(obj) {
+    var self = this;
+    var action;
+    var description;
+    var sections = ['datasets', 'mountpoints', 'snapshots'];
+    var name = obj.dsname;
+    var _s = name.split('@');
+    var dsname = _s[0];
+    var snapname = _s[1];
+    var parts;
+    var uuid;
+    var zonepath;
+    var meta = util.format('dsname: %s action: %s %s',
+        obj.dsname, obj.action, obj.extras).trim();
+
+    self.log.debug({obj: obj}, 'handleZpoolEvent: %s', meta);
+
+    /*
+     * break the incoming zfs dataset into an array
+     * ex => ['zones', '<uuid>', 'config']
+     */
+    parts = dsname.split('/');
+    if (parts[1]) {
+        /*
+         * Attempt to extract a UUID from the second part.  This will succeed
+         * for KVM instances (for example) that have a dataset like
+         * /zones/<uuid>-disk0.
+         */
+        uuid = extractUUID(parts[1]);
+    }
+
+    /*
+     * If the dataset name matches "/zones/<uuid>" exactly we use that as the
+     * zonepath argument to getDatasets.  Otherwise, we use the parent dataset.
+     */
+    if (parts[0] === ZONES_ZPOOL && parts[1] === uuid && !parts[2]) {
+        zonepath = dsname;
+    } else {
+        zonepath = path.dirname(dsname);
+    }
+
+    /*
+     * Based on the "action" seen from the ZFS sysevent, we determine ahead of
+     * time what kind of action we will need to take as a response.  By doing
+     * this we can dedup the tasks pushed to the queue, because while the ZFS
+     * sysevents might differ, the actions we take as a response may be the
+     * same, in which case they only need to be done once.
+     */
+    switch (obj.action) {
+    case 'clone':
+    case 'create':
+    case 'snapshot':
+        action = 'fetchAndCopy';
+        break;
+    case 'clone swap': // rollback
+    case 'set':
+    case 'hold':
+    case 'release':
+    case 'rename':
+    case 'finish receiving':
+        action = 'fetchExpireAndCopy';
+        break;
+    case 'destroy':
+        action = 'expire';
+        break;
+    case 'receive':
+        // do nothing
+        self.log.debug('ignoring action: %s', obj.action);
+        return;
+    default:
+        self.log.fatal('unknown action: %s', obj.action);
+        return;
+    }
+    description = util.format('dsname: %s action: %s', obj.dsname, action);
+
+    function expire() {
+        function expireObjects(ds_objects) {
+            sections.forEach(function (section) {
+                if (!ds_objects.hasOwnProperty(section)) {
+                    return;
+                }
+
+                switch (section) {
+                case 'mountpoints':
+                    for (var key in ds_objects[section]) {
+                        if (ds_objects[section][key] === name) {
+                            delete (ds_objects[section])[key];
+                        }
+                    }
+                    break;
+                default:
+                    if (ds_objects[section].hasOwnProperty(name)) {
+                        delete (ds_objects[section])[name];
+                    }
+                    break;
+                }
+
+                if (snapname && section === 'snapshots') {
+                    // remove the snapshot here as well
+                    if (ds_objects[section].hasOwnProperty(dsname)) {
+                        ds_objects[section][dsname] =
+                            ds_objects[section][dsname].filter(function (o) {
+
+                            return o.snapname !== snapname;
+                        });
+                    }
+                }
+            });
+        }
+
+        self.vmDatasets().forEach(function (data) {
+            expireObjects(data.dataset_objects);
+        });
+
+        if (self.vm_data_json.hasOwnProperty('dataset_objects')) {
+            expireObjects(self.vm_data_json.dataset_objects);
+        }
+    }
+
+    function fetch(datasetObj, cb) {
+        var opts = {
+            log: self.log,
+            dataset: name
+        };
+        getDatasets(datasetObj, opts, function (err, results) {
+            if (err) {
+                self.log.warn('failed to fetch datasets');
+            }
+            cb(err, results);
+        });
+    }
+
+    function copy(cache) {
+        self.vmDatasets().forEach(function (data) {
+            sections.forEach(function (section) {
+                for (var key in cache[section]) {
+                    if (!data.hasOwnProperty('dataset_objects')) {
+                        data.dataset_objects = {};
+                    }
+                    if (!data.dataset_objects.hasOwnProperty(section)) {
+                        data.dataset_objects[section] = {};
+                    }
+                    data.dataset_objects[section][key] = cache[section][key];
+                }
+            });
+        });
+    }
+
+    self.event_queue.enqueue({
+        description: 'handle zfs event - ' + description,
+        timeout: QUEUE_TASK_TIMEOUT,
+        func: function (extras, cb) {
+            var datasetObj = {};
+            if (zonepath !== '.') {
+                datasetObj.zonepath = util.format('/%s', zonepath);
+            }
+
+            switch (action) {
+            case 'fetchAndCopy':
+                fetch(datasetObj, function (err, cache) {
+                    if (err) {
+                        finish();
+                        return;
+                    }
+                    copy(cache);
+                    finish();
+                });
+                return;
+            case 'fetchExpireAndCopy':
+                fetch(datasetObj, function (err, cache) {
+                    if (err) {
+                        finish();
+                        return;
+                    }
+                    expire();
+                    copy(cache);
+                    finish();
+                });
+                return;
+            case 'expire':
+                expire();
+                finish();
+                break;
+            default:
+                extras.log.fatal('unknown action: %s', obj.action);
+                finish();
+                break;
+            }
+
+            function finish() {
+                if (!uuid) {
+                    cb();
+                    return;
+                }
+
+                // if we happen to grab an image uuid here,
+                // the refreshVmobj will return immediately
+                extras.log.debug('refreshing vmobj %s after zfs event', uuid);
+                self.refreshVmobj(uuid, cb);
+            }
+        }
+    });
+};
+
+/*
+ * Extract a (the first) UUID from a string
+ */
+function extractUUID(s) {
+    var uuid_re = new RegExp('('
+        + '[a-f0-9]{8}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{12}'
+        + ')'
+    );
+    var match = uuid_re.exec(s);
+
+    return match && match[1];
+}
+
+function formatEventsListeners(evls) {
+    var now = process.hrtime();
+    var ret = {};
+
+    assert.object(evls, 'evls');
+
+    Object.keys(evls).forEach(function (uuid) {
+        var evl = evls[uuid];
+
+        ret[uuid] = {
+            userAgent: evl.userAgent,
+            createdTime: hrtime.hrtimeToString(evl.createdTime),
+            createdDate: evl.createdDate,
+            createdAgo: hrtime.hrtimeDeltaPretty(now, evl.createdTime)
+        };
+    });
+
+    return ret;
+}
+
+function formatRefreshErrors(refreshErrors) {
+    var now = process.hrtime();
+    var ret;
+
+    assert.arrayOfObject(refreshErrors, 'refreshErrors');
+
+    ret = refreshErrors.map(function (re) {
+        var o = {
+            err: re.err.message,
+            time: hrtime.hrtimeToString(re.time),
+            ago: hrtime.hrtimeDeltaPretty(now, re.time)
+        };
+
+        return o;
+    });
+
+    return ret;
+}
+
+function formatRefreshLog(refreshLog) {
+    assert.arrayOfObject(refreshLog, 'refreshLog');
+
+    var now = process.hrtime();
+    var ret;
+
+    ret = refreshLog.map(function (rl) {
+        var o = {
+            cacheChanges: rl.cacheChanges,
+            vmChanges: rl.vmChanges,
+            started: hrtime.hrtimeToString(rl.started),
+            ended: hrtime.hrtimeToString(rl.ended),
+            took: rl.prettyDelta,
+            endedAgo: hrtime.hrtimeDeltaPretty(now, rl.ended)
+        };
+
+        return o;
+    });
+
+    return ret;
+}
+
+function isUUID(s) {
+    try {
+        assert.uuid(s);
+        return true;
+    } catch (e) {
+        return false;
+    }
+}
diff --git a/src/vm/node_modules/vminfod/zonewatcher.js b/src/vm/node_modules/vminfod/zonewatcher.js
new file mode 100644
index 00000000..9b9a4931
--- /dev/null
+++ b/src/vm/node_modules/vminfod/zonewatcher.js
@@ -0,0 +1,76 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
+
+module.exports = ZoneWatcher;
+module.exports.ZoneWatcher = ZoneWatcher;
+function ZoneWatcher(options) {
+    var self = this;
+
+    self.options = options;
+    assert(options.log, 'no logger passed to ZoneWatcher()');
+    self.log = options.log;
+
+    // create a Sysevent stream
+    var opts = {
+        logger: self.log,
+        class: 'status',
+        channel: 'com.sun:zones:status'
+    };
+
+    self.se = new SyseventStream(opts);
+
+    self.se.once('ready', function () {
+        self.emit('ready');
+    });
+
+    self.se.on('readable', function () {
+        var ev;
+        while ((ev = self.se.read()) !== null) {
+            var o = {
+                type: 'event',
+                zonename: ev.data.zonename,
+                newstate: ev.data.newstate,
+                time: ev.time,
+                ev: ev
+            };
+
+            self.emit('event', o);
+        }
+    });
+}
+util.inherits(ZoneWatcher, EventEmitter);
+
+ZoneWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    self.se.stop();
+};
diff --git a/src/vm/node_modules/vminfod/zpoolwatcher.js b/src/vm/node_modules/vminfod/zpoolwatcher.js
new file mode 100644
index 00000000..8ab7fc1f
--- /dev/null
+++ b/src/vm/node_modules/vminfod/zpoolwatcher.js
@@ -0,0 +1,119 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
+
+module.exports = ZpoolWatcher;
+module.exports.ZpoolWatcher = ZpoolWatcher;
+function ZpoolWatcher(options) {
+    var self = this;
+
+    self.options = options;
+    assert.object(options.log, 'no logger passed to ZpoolWatcher()');
+    self.log = options.log;
+
+    // create a Sysevent stream
+    var opts = {
+        logger: self.log,
+        class: 'EC_zfs',
+        subclasses: ['ESC_ZFS_history_event']
+    };
+
+    self.se = new SyseventStream(opts);
+
+    self.se.once('ready', function () {
+        self.emit('ready');
+    });
+
+    self.se.on('readable', function () {
+        var ev;
+        while ((ev = self.se.read()) !== null)
+            self._handle_event(ev);
+    });
+}
+util.inherits(ZpoolWatcher, EventEmitter);
+
+/*
+ * called internally whenever a new sysevent is received -
+ * this method is responsible for constructing an object to emit
+ * based on the sysevent received.
+ */
+ZpoolWatcher.prototype._handle_event = function _handle_event(ev) {
+    var self = this;
+
+    // object to be emitted
+    var o = {};
+
+    // extract pool name
+    var pool = ev.data.pool_name;
+    assert.string(pool, 'invalid pool name in ZFS record');
+    o.pool = pool;
+
+    // extract and parse timestamp
+    var ts = ev.data.history_time;
+    assert.number(ts, 'invalid "history time" in ZFS record');
+    o.timestamp = new Date(ts * 1000);
+
+    // extract action, eg: "create", "destroy", "set", etc.
+    var action = ev.data.history_internal_name;
+    assert.string(action, 'invalid "internal_name" in ZFS record');
+    o.action = action;
+
+    // extract dataset
+    var dsname = ev.data.history_dsname;
+    assert.string(dsname, 'invalid "dsname" in ZFS record');
+    o.dsname = dsname;
+
+    // extract any optional extras
+    // this will typically be set by "zfs set" and will be a string like
+    // "sync=1", "atime=0", etc.
+    var extra = {};
+    var extras = ev.data.history_internal_str;
+    if (extras) {
+        var j = extras.indexOf('=');
+        if (j >= 0) {
+            var key = extras.substr(0, j);
+            var value = extras.substr(j + 1);
+            extra[key] = value;
+        }
+    }
+    o.extra = extra;
+    o.extras = extras;
+
+    self.log.trace({o: o}, 'emitting ZpoolWatcher event');
+    self.emit(o.action, o);
+    self.emit('event', o);
+};
+
+ZpoolWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    self.se.stop();
+};
diff --git a/src/vm/node_modules/vmload/dump-json.js b/src/vm/node_modules/vmload/dump-json.js
index 24862db6..0c1899ed 100755
--- a/src/vm/node_modules/vmload/dump-json.js
+++ b/src/vm/node_modules/vmload/dump-json.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -33,11 +33,10 @@
  *  that VM.
  */
 
-var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var execFile = require('child_process').execFile;
 var getVmobjJSON = require('./vmload-json').getVmobjJSON;
-var path = require('path');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var log = bunyan.createLogger({
     level: 'debug',
@@ -62,37 +61,40 @@ execFile('/usr/sbin/zoneadm', ['list', '-c', '-p'],
         argv = process.argv.slice(2);
     }
 
-    async.each(lines, function (line, cb) {
-        var fields = line.split(':');
-        var uuid;
-        var zonepath;
+    vasync.forEachParallel({
+        inputs: lines,
+        func: function (line, cb) {
+            var fields = line.split(':');
+            var uuid;
+            var zonepath;
 
-        if (fields.length < 4) {
-            cb();
-            return;
-        }
+            if (fields.length < 4) {
+                cb();
+                return;
+            }
 
-        zonepath = fields[3];
-        uuid = fields[4];
+            zonepath = fields[3];
+            uuid = fields[4];
 
-        if (uuid === '') {
-            cb();
-            return;
-        }
+            if (uuid === '') {
+                cb();
+                return;
+            }
 
-        // if there are no arguments or the arguments include this VM...
-        if (argv.length === 0 || argv.indexOf(uuid) !== -1) {
-            getVmobjJSON(zonepath, {log: log}, function (err, obj) {
-                if (err) {
-                    throw err;
-                }
-                results[uuid] = obj;
+            // if there are no arguments or the arguments include this VM...
+            if (argv.length === 0 || argv.indexOf(uuid) !== -1) {
+                getVmobjJSON(zonepath, {log: log}, function (err, obj) {
+                    if (err) {
+                        throw err;
+                    }
+                    results[uuid] = obj;
+                    cb();
+                    return;
+                });
+            } else {
                 cb();
                 return;
-            });
-        } else {
-            cb();
-            return;
+            }
         }
     }, function (err) {
         if (err) {
diff --git a/src/vm/node_modules/vmload/dump-vmobjs.js b/src/vm/node_modules/vmload/dump-vmobjs.js
index fe20e7d3..35ba0492 100755
--- a/src/vm/node_modules/vmload/dump-vmobjs.js
+++ b/src/vm/node_modules/vmload/dump-vmobjs.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -31,7 +31,6 @@
  *  in the output array.
  */
 
-var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var getVmobjs = require('vmload').getVmobjs;
 
@@ -53,12 +52,12 @@ getVmobjs(function (vm, cb) {
     if (process.argv.length >= 3) {
         args = process.argv.slice(2);
         if (args.indexOf(vm.uuid) !== -1) {
-            cb(true);
+            cb(null, true);
         } else {
-            cb(false);
+            cb(null, false);
         }
     } else {
-        cb(true);
+        cb(null, true);
     }
 }, {log: log}, function (err, results) {
 
diff --git a/src/vm/node_modules/vmload/dump-zonexml.js b/src/vm/node_modules/vmload/dump-zonexml.js
index a470bd70..235c9307 100755
--- a/src/vm/node_modules/vmload/dump-zonexml.js
+++ b/src/vm/node_modules/vmload/dump-zonexml.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -33,12 +33,12 @@
  *  (the JSONized XML properties) for each VM.
  */
 
-var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var execFile = require('child_process').execFile;
 var getVmobjXML = require('./vmload-xml').getVmobjXML;
 var getVmobjXMLFile = require('./vmload-xml').getVmobjXMLFile;
 var path = require('path');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var log = bunyan.createLogger({
     level: 'debug',
@@ -70,7 +70,10 @@ if (!process.argv[2]) {
 
 function dumpXMLs(vms)
 {
-    async.each(vms, addXML, function (err) {
+    vasync.forEachParallel({
+        inputs: vms,
+        func: addXML
+    }, function (err) {
         if (err) {
             throw (err);
         }
@@ -83,7 +86,7 @@ function addXML(vm, callback)
 {
     var filename = path.join('/etc/zones', vm + '.xml');
 
-    if (vm.length != 36) {
+    if (vm.length !== 36) {
         log.error('VM zonename ' + vm + ' is not a uuid, skipping.');
         callback();
         return;
diff --git a/src/vm/node_modules/vmload/index.js b/src/vm/node_modules/vmload/index.js
index 16476b2f..2507a9ac 100644
--- a/src/vm/node_modules/vmload/index.js
+++ b/src/vm/node_modules/vmload/index.js
@@ -21,13 +21,11 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
-var bunyan = require('/usr/node/node_modules/bunyan');
 var fs = require('fs');
 var getDatasets = require('./vmload-datasets').getDatasets;
 var getVmobjJSON = require('./vmload-json').getVmobjJSON;
@@ -39,11 +37,14 @@ var path = require('path');
 var props = require('/usr/vm/node_modules/props');
 var utils = require('utils');
 var vmload_utils = require('./vmload-utils');
+var vasync = require('/usr/vm/node_modules/vasync');
 var wantAnyFields = vmload_utils.wantAnyFields;
 var wantField = vmload_utils.wantField;
 
+var VminfodClient = require('../vminfod/client').VminfodClient;
+var vminfod = new VminfodClient('vmload/index');
+
 // utils
-var assertSafeZonePath = utils.assertSafeZonePath;
 var trim = utils.trim;
 
 // load generated tables of data
@@ -455,7 +456,7 @@ function getLastExited(zonename, zonepath, log, callback)
         }
 
         stat = Number(fields[1]);
-        log.debug('found exit_status value: ' + stat);
+        log.debug({filename: filename}, 'found exit_status value: %d', stat);
         if (stat === -1) {
             // -1 is special status (OS-3429) that indicates normal exit
             result.exit_status = 0;
@@ -495,29 +496,34 @@ function getLastModified(zonename, zonepath, log, callback)
     }
 
     // stat all files in parallel, newest will be "last_modified"
-    async.each(files, function (file, cb) {
-        fs.stat(file, function (err, stats) {
-            if (err) {
-                if (err.code !== 'ENOENT') {
-                    log.error(err, 'Unable to get timestamp for "' + file + '":'
-                        + err.message);
+    vasync.forEachParallel({
+        inputs: files,
+        func: function (file, cb) {
+            fs.stat(file, function (err, stats) {
+                if (err) {
+                    if (err.code !== 'ENOENT') {
+                        log.error({err: err},
+                            'Unable to get timestamp for "%s": %s',
+                            file, err.message);
+                    }
+                    cb();
+                    return;
                 }
-                cb();
-                return;
-            }
 
-            if (!stats.isFile()) {
-                cb();
-                return;
-            }
+                if (!stats.isFile()) {
+                    cb();
+                    return;
+                }
 
-            if ((timestamp === 0) || (Date.parse(stats.mtime) > timestamp)) {
-                // newest file so far!
-                timestamp = Date.parse(stats.mtime);
-            }
+                if ((timestamp === 0)
+                    || (Date.parse(stats.mtime) > timestamp)) {
+                    // newest file so far!
+                    timestamp = Date.parse(stats.mtime);
+                }
 
-            cb();
-        });
+                cb();
+            });
+        }
     }, function (err) {
         if (err) {
             callback(err);
@@ -567,6 +573,7 @@ function getSysinfo(log, callback)
  *  fields: an array of field names we want in this object
  *  log: a bunyan logger (required)
  *  cache: (see comment at top of getZoneData())
+ *  loadManually: skip vminfod and pull directly from the system
  *
  * If any of the members of the 'cache' are not passed in, they will be looked
  * up from the live system. This means that if you want to do multiple lookups
@@ -602,250 +609,298 @@ function getVmobj(uuid, options, callback)
 
     log.trace('getting vmobj for VM ' + uuid);
 
-    async.series([
-        function (cb) {
-            if (options.hasOwnProperty('cache')) {
-                cache = options.cache;
-                cb();
+    if (options.loadManually) {
+        log.debug('getVmobj loading manually - skipping vminfod');
+        loadManually(callback);
+    } else {
+        log.debug('getVmobj loading using vminfod');
+        loadVminfod(function (err, vm) {
+            if (err && err.code === 404) {
+                err.code = 'ENOENT';
+            }
+            callback(err, vm);
+        });
+    }
+
+    function loadVminfod(done) {
+        vminfod.vm(uuid, function (err, vm) {
+            if (err) {
+                done(err);
                 return;
             }
+            done(null, vm);
+        });
+    }
 
-            // If cache was not prepopulated, load now, just for this VM's data.
-            getZoneData(uuid, options, function (err, _cache) {
-                if (err) {
-                    cb(err);
+    function loadManually(done) {
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                if (options.hasOwnProperty('cache')) {
+                    cache = options.cache;
+                    cb();
                     return;
                 }
 
-                cache = _cache;
-                cb();
-            });
-        }, function (cb) {
-            var new_err;
-
-            // load data from zoneadm list -pc (cache.zoneadm_objectss)
-            if (cache.zoneadm_objects
-                && cache.zoneadm_objects.hasOwnProperty(uuid)) {
-
-                zoneadm_info = cache.zoneadm_objects[uuid];
-
-                // Ensure zoneadm_info has basic required properties
-                assert.equal(zoneadm_info.uuid, uuid);
-                [
-                    'brand',
-                    'state',
-                    'zonename',
-                    'zonepath'
-                ].forEach(function (f) {
-                    assert(zoneadm_info[f], 'zoneadm_info is missing "' + f
-                        + '" for VM ' + uuid);
+                // If cache was not prepopulated, load now,
+                // just for this VM's data.
+                getZoneData(uuid, options, function (err, _cache) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+
+                    cache = _cache;
+                    cb();
                 });
+            }, function (_, cb) {
+                var new_err;
+
+                // load data from zoneadm list -pc (cache.zoneadm_objectss)
+                if (cache.zoneadm_objects
+                    && cache.zoneadm_objects.hasOwnProperty(uuid)) {
+
+                    zoneadm_info = cache.zoneadm_objects[uuid];
+                    log.debug({zoneadm_info: zoneadm_info}, 'zoneadm_info');
+
+                    // Ensure zoneadm_info has basic required properties
+                    assert.equal(zoneadm_info.uuid, uuid);
+                    [
+                        'brand',
+                        'state',
+                        'zonename',
+                        'zonepath'
+                    ].forEach(function (f) {
+                        assert(zoneadm_info[f], 'zoneadm_info is missing "' + f
+                            + '" for VM ' + uuid);
+                    });
 
-                cb();
-            } else {
-                new_err = new Error('VM ' + uuid + ' not found in zoneadm');
-                new_err.code = 'ENOENT';
-                cb(new_err);
-            }
-        }, function (cb) {
-            var new_err;
+                    cb();
+                } else {
+                    new_err = new Error('VM ' + uuid + ' not found in zoneadm');
+                    new_err.code = 'ENOENT';
+                    cb(new_err);
+                }
+            }, function (_, cb) {
+                var new_err;
+
+                if (cache.zonexml_objects
+                    && cache.zonexml_objects.hasOwnProperty(uuid)) {
+
+                    // Some consumers keep a copy of cache between calls,
+                    // so we need to clone this object instead of assigning
+                    // the reference. Otherwise, the cache copy of the
+                    // zonexml_object[uuid] will be a final vmobj.
+                    for (var key in cache.zonexml_objects[uuid]) {
+                        vmobj[key] =
+                            deepClone(cache.zonexml_objects[uuid][key]);
+                    }
 
-            if (cache.zonexml_objects
-                && cache.zonexml_objects.hasOwnProperty(uuid)) {
+                    cb();
+                    return;
+                }
 
-                vmobj = cache.zonexml_objects[uuid];
-                cb();
-                return;
-            }
+                if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
+                    // didn't want any so no problem.
+                    vmobj = {};
+                    cb();
+                    return;
+                }
 
-            if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
-                // didn't want any so no problem.
-                vmobj = {};
-                cb();
+                // if we got here, we wanted xml data, so not having is an error
+                new_err = new Error('VM ' + uuid
+                    + ' XML data missing from cache');
+                cb(new_err);
                 return;
-            }
-
-            // if we got here, we wanted xml data, so not having is an error
-            new_err = new Error('VM ' + uuid + ' XML data missing from cache');
-            cb(new_err);
-            return;
 
 
-        }, function (cb) {
-            /*
-             * We got some bits from `zoneadm list` in zoneadm_info here, and
-             * since we already got that data, adding it to the object here is
-             * cheap. We also need some of these properties to be able to get
-             * others later, so we add them all now. If they're unwanted they'll
-             * be removed from the final object.
-             */
-            vmobj.brand = zoneadm_info.brand;
-            vmobj.uuid = zoneadm_info.uuid;
-            vmobj.zone_state = zoneadm_info.state;
-            vmobj.zonename = zoneadm_info.zonename;
-            vmobj.zonepath = zoneadm_info.zonepath;
-
-            if (wantField(options, 'zoneid') && zoneadm_info.zoneid !== '-') {
-                vmobj.zoneid = zoneadm_info.zoneid;
-            }
+            }, function (_, cb) {
+                /*
+                 * We got some bits from `zoneadm list` in zoneadm_info here,
+                 * and since we already got that data, adding it to the object
+                 * here is cheap. We also need some of these properties to be
+                 * able to get others later, so we add them all now. If they're
+                 * unwanted they'll be removed from the final object.
+                 */
+                vmobj.brand = zoneadm_info.brand;
+                vmobj.uuid = zoneadm_info.uuid;
+                vmobj.zone_state = zoneadm_info.state;
+                vmobj.zonename = zoneadm_info.zonename;
+                vmobj.zonepath = zoneadm_info.zonepath;
+
+                if (wantField(options, 'zoneid')
+                    && zoneadm_info.zoneid !== '-') {
+                    vmobj.zoneid = zoneadm_info.zoneid;
+                }
 
-            if (wantField(options, 'last_modified')) {
-                if (cache.hasOwnProperty('last_modified')
-                    && cache.last_modified.hasOwnProperty(vmobj.uuid)) {
+                if (wantField(options, 'last_modified')) {
+                    if (cache.hasOwnProperty('last_modified')
+                        && cache.last_modified.hasOwnProperty(vmobj.uuid)) {
 
-                    vmobj.last_modified = cache.last_modified[vmobj.uuid];
-                } else {
-                    log.warn('"last_modified" requested, but not found in cache'
-                        + ' for VM ' + vmobj.uuid);
+                        vmobj.last_modified = cache.last_modified[vmobj.uuid];
+                    } else {
+                        log.warn('"last_modified" requested, but not found in'
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            if (vmobj.zone_state !== 'running'
-                    && wantField(options, 'exit_status')) {
+                if (vmobj.zone_state !== 'running'
+                        && wantField(options, 'exit_status')) {
 
-                if (cache.hasOwnProperty('last_exited')
-                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
-                    && cache.last_exited[vmobj.uuid]
-                    .hasOwnProperty('exit_status')) {
+                    if (cache.hasOwnProperty('last_exited')
+                        && cache.last_exited.hasOwnProperty(vmobj.uuid)
+                        && cache.last_exited[vmobj.uuid]
+                        .hasOwnProperty('exit_status')) {
 
-                    vmobj.exit_status
-                        = cache.last_exited[vmobj.uuid].exit_status;
-                } else {
-                    log.warn('"exit_status" requested, but not found in cache'
-                        + ' for VM ' + vmobj.uuid);
+                        vmobj.exit_status
+                            = cache.last_exited[vmobj.uuid].exit_status;
+                    } else {
+                        log.warn('"exit_status" requested, but not found in'
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            if (vmobj.zone_state !== 'running'
-                    && wantField(options, 'exit_timestamp')) {
+                if (vmobj.zone_state !== 'running'
+                        && wantField(options, 'exit_timestamp')) {
 
-                if (cache.hasOwnProperty('last_exited')
-                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
-                    && cache.last_exited[vmobj.uuid]
-                    .hasOwnProperty('exit_timestamp')) {
+                    if (cache.hasOwnProperty('last_exited')
+                        && cache.last_exited.hasOwnProperty(vmobj.uuid)
+                        && cache.last_exited[vmobj.uuid]
+                        .hasOwnProperty('exit_timestamp')) {
 
-                    vmobj.exit_timestamp
-                        = cache.last_exited[vmobj.uuid].exit_timestamp;
-                } else {
-                    log.warn('"exit_timestamp" requested, but not found in '
-                        + 'cache for VM ' + vmobj.uuid);
+                        vmobj.exit_timestamp
+                            = cache.last_exited[vmobj.uuid].exit_timestamp;
+                    } else {
+                        log.warn('"exit_timestamp" requested, but not found in '
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            /*
-             * If we want resolvers, (eg. OS-2194) we always add the array here
-             * so you can tell that the resolvers are explicitly not set.
-             */
-            if (wantField(options, 'resolvers')
-                && !vmobj.hasOwnProperty('resolvers')) {
+                /*
+                 * If we want resolvers, (eg. OS-2194) we always add the array
+                 * here so you can tell that the resolvers are explicitly not
+                 * set.
+                 */
+                if (wantField(options, 'resolvers')
+                    && !vmobj.hasOwnProperty('resolvers')) {
 
-                vmobj.resolvers = [];
-            }
+                    vmobj.resolvers = [];
+                }
 
-            // Always include firewall_enabled, false if not set.
-            if (wantField(options, 'firewall_enabled')
-                && !vmobj.hasOwnProperty('firewall_enabled')) {
+                // Always include firewall_enabled, false if not set.
+                if (wantField(options, 'firewall_enabled')
+                    && !vmobj.hasOwnProperty('firewall_enabled')) {
 
-                vmobj.firewall_enabled = false;
-            }
+                    vmobj.firewall_enabled = false;
+                }
 
-            // sysinfo has server_uuid and potentially some DC info
-            if (cache.sysinfo) {
-                if (wantField(options, 'server_uuid')
-                    && cache.sysinfo.hasOwnProperty('UUID')) {
+                // sysinfo has server_uuid and potentially some DC info
+                if (cache.sysinfo) {
+                    if (wantField(options, 'server_uuid')
+                        && cache.sysinfo.hasOwnProperty('UUID')) {
 
-                    vmobj.server_uuid = cache.sysinfo.UUID;
-                }
-                if (wantField(options, 'datacenter_name')
-                    && cache.sysinfo.hasOwnProperty('Datacenter Name')) {
+                        vmobj.server_uuid = cache.sysinfo.UUID;
+                    }
+                    if (wantField(options, 'datacenter_name')
+                        && cache.sysinfo.hasOwnProperty('Datacenter Name')) {
 
-                    vmobj.datacenter_name = cache.sysinfo['Datacenter Name'];
-                }
-                if (wantField(options, 'platform_buildstamp')
-                    && cache.sysinfo.hasOwnProperty('Live Image')) {
+                        vmobj.datacenter_name
+                            = cache.sysinfo['Datacenter Name'];
+                    }
+                    if (wantField(options, 'platform_buildstamp')
+                        && cache.sysinfo.hasOwnProperty('Live Image')) {
 
-                    vmobj.platform_buildstamp = cache.sysinfo['Live Image'];
-                }
-                if (wantField(options, 'headnode_id')
-                    && cache.sysinfo.hasOwnProperty('Headnode ID')) {
+                        vmobj.platform_buildstamp
+                            = cache.sysinfo['Live Image'];
+                    }
+                    if (wantField(options, 'headnode_id')
+                        && cache.sysinfo.hasOwnProperty('Headnode ID')) {
 
-                    vmobj.headnode_id = cache.sysinfo['Headnode ID'];
+                        vmobj.headnode_id = cache.sysinfo['Headnode ID'];
+                    }
                 }
-            }
 
-            /*
-             * state could already be set here if it was overriden by a
-             * transition that's in progress. So we only change if that's not
-             * the case.
-             *
-             * We always add 'state' at this point regardless of 'fields'
-             * because some other checks later depend on it (eg. received means
-             * we need 'missing' member, etc). The 'state' itself will get
-             * removed later if not requested.
-             */
-            if (!vmobj.hasOwnProperty('state')) {
-                if (zoneadm_info.state === 'installed') {
-                    vmobj.state = 'stopped';
-                } else {
-                    vmobj.state = zoneadm_info.state;
+                /*
+                 * state could already be set here if it was overriden by a
+                 * transition that's in progress. So we only change if that's
+                 * not the case.
+                 *
+                 * We always add 'state' at this point regardless of 'fields'
+                 * because some other checks later depend on it (eg. received
+                 * means we need 'missing' member, etc). The 'state' itself
+                 * will get removed later if not requested.
+                 */
+                if (!vmobj.hasOwnProperty('state')) {
+                    if (zoneadm_info.state === 'installed') {
+                        vmobj.state = 'stopped';
+                    } else {
+                        vmobj.state = zoneadm_info.state;
+                    }
                 }
-            }
 
-            /*
-             * If the zone has the 'failed' property it doesn't matter what
-             * other state it might be in, we list its state as 'failed'.
-             */
-            if (vmobj.failed) {
-                vmobj.state = 'failed';
-            }
+                /*
+                 * If the zone has the 'failed' property it doesn't matter what
+                 * other state it might be in, we list its state as 'failed'.
+                 */
+                if (vmobj.failed) {
+                    vmobj.state = 'failed';
+                }
 
-            cb();
-        }, function (cb) {
-            VMOBJ_ZONEINFO_FIELDS.forEach(function (field) {
-                if (wantField(options, field)
-                    && cache.zoneinfo_objects[vmobj.uuid]
-                    && cache.zoneinfo_objects[vmobj.uuid]
-                        .hasOwnProperty(field)) {
+                cb();
+            }, function (_, cb) {
+                VMOBJ_ZONEINFO_FIELDS.forEach(function (field) {
+                    if (wantField(options, field)
+                        && cache.zoneinfo_objects[vmobj.uuid]
+                        && cache.zoneinfo_objects[vmobj.uuid]
+                            .hasOwnProperty(field)) {
+
+                        vmobj[field]
+                            = cache.zoneinfo_objects[vmobj.uuid][field];
+                    }
+                });
 
-                    vmobj[field] = cache.zoneinfo_objects[vmobj.uuid][field];
+                cb();
+            }, function (_, cb) {
+                /*
+                 * Caller's field list doesn't include any fields from JSON
+                 * files, so don't bother loading them (optimization).
+                 */
+                if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
+                    cb();
+                    return;
                 }
-            });
 
-            cb();
-        }, function (cb) {
-            /*
-             * Caller's field list doesn't include any fields from JSON files,
-             * so don't bother loading them (optimization).
-             */
-            if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
-                cb();
-                return;
-            }
+                // whatever we got back, add to the VM object
+                VMOBJ_JSON_FIELDS.forEach(function (m) {
+                    if (wantField(options, m)
+                        && cache.json_objects.hasOwnProperty(vmobj.uuid)
+                        && cache.json_objects[vmobj.uuid].hasOwnProperty(m)) {
 
-            // whatever we got back, add to the VM object
-            VMOBJ_JSON_FIELDS.forEach(function (m) {
-                if (wantField(options, m)
-                    && cache.json_objects.hasOwnProperty(vmobj.uuid)
-                    && cache.json_objects[vmobj.uuid].hasOwnProperty(m)) {
+                        vmobj[m] = cache.json_objects[vmobj.uuid][m];
+                    }
+                });
 
-                    vmobj[m] = cache.json_objects[vmobj.uuid][m];
+                cb();
+            }, function (_, cb) {
+                if (vmobj.state !== 'receiving') {
+                    log.trace('not "receiving", no need to lookup'
+                        + ' receiving.json');
+                    cb();
+                    return;
                 }
-            });
 
-            cb();
-        }, function (cb) {
-            if (vmobj.state !== 'receiving') {
-                log.trace('not "receiving", no need to lookup receiving.json');
-                cb();
-                return;
-            }
+                fs.readFile('/etc/zones/' + uuid + '-receiving.json',
+                    function (err, data) {
 
-            fs.readFile('/etc/zones/' + uuid + '-receiving.json',
-                function (err, data) {
                     var receiving_props;
 
                     if (err) {
-                        cb(err);
+                        // cb(err);
+                        // XXX really ugly "fix" for a vm state that appears
+                        // to happen only in the vminfod world.  the zone XML
+                        // file says the zone is transitioning from
+                        // "receiving" to "stopped" and `zoneadm list -cv`
+                        // shows it in state "configured".
+                        cb();
                         return;
                     }
 
@@ -864,41 +919,42 @@ function getVmobj(uuid, options, callback)
                     }
 
                     cb();
+                });
+            }, function (_, cb) {
+                /*
+                 * If we have dataset_objects, we want to ensure we add in any
+                 * fields we need from them.
+                 */
+                if (cache.dataset_objects) {
+                    addDatasetProperties(vmobj, cache.dataset_objects, options,
+                        cb);
+                    return;
                 }
-            );
-        }, function (cb) {
-            /*
-             * If we have dataset_objects, we want to ensure we add in any
-             * fields we need from them.
-             */
-            if (cache.dataset_objects) {
-                addDatasetProperties(vmobj, cache.dataset_objects, options, cb);
-                return;
-            }
 
-            // no zfs props requested, nothing to do.
-            cb();
-        }, function (cb) {
-            /*
-             * Remove non-requested 'fields' that might have been added as
-             * dependencies or because grabbing together was easier.
-             */
-            if (options.hasOwnProperty('fields')) {
-                Object.keys(vmobj).forEach(function (key) {
-                    if (!wantField(options, key)) {
-                        delete vmobj[key];
-                    }
-                });
+                // no zfs props requested, nothing to do.
+                cb();
+            }, function (_, cb) {
+                /*
+                 * Remove non-requested 'fields' that might have been added as
+                 * dependencies or because grabbing together was easier.
+                 */
+                if (options.hasOwnProperty('fields')) {
+                    Object.keys(vmobj).forEach(function (key) {
+                        if (!wantField(options, key)) {
+                            delete vmobj[key];
+                        }
+                    });
+                }
+                cb();
             }
-            cb();
-        }
-    ], function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
-        callback(null, vmobj);
-    });
+        ]}, function (err) {
+            if (err) {
+                done(err);
+                return;
+            }
+            done(null, vmobj);
+        });
+    }
 }
 
 /*
@@ -929,72 +985,90 @@ function getVmobj(uuid, options, callback)
  */
 function getVmobjs(filter, options, callback)
 {
-    var cache;
-    var vmobjs = [];
-
     assert(typeof (filter) === 'function', 'filter must be a function');
 
-    async.series([
-        function (cb) {
-            if (options.hasOwnProperty('cache')) {
-                cache = options.cache;
-                cb();
+    if (options.loadManually) {
+        loadManually(callback);
+    } else {
+        loadVminfod(callback);
+    }
+
+    function loadVminfod(done) {
+        vminfod.vms(function (err, vms) {
+            if (err) {
+                done(err);
                 return;
             }
 
-            /*
-             * If cache was not prepopulated, load now for all VMs. "options"
-             * will potentially limit which fields are in output objects.
-             */
-            getZoneData(null, options, function (err, _cache) {
-                if (err) {
-                    cb(err);
+            vasync.filterSeries(vms, filter, done);
+        });
+    }
+
+    function loadManually(done) {
+        var cache;
+        var vmobjs = [];
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                if (options.hasOwnProperty('cache')) {
+                    cache = options.cache;
+                    cb();
                     return;
                 }
 
-                cache = _cache;
-                cb();
-            });
-        }, function (cb) {
-            var vms = Object.keys(cache.zoneadm_objects);
-            async.each(vms,
-                function (uuid, vm_cb) {
-                    var get_options = options;
+                /*
+                 * If cache was not prepopulated, load now for all VMs.
+                 * "options" will potentially limit which fields are in output
+                 * objects.
+                 */
+                getZoneData(null, options, function (err, _cache) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
 
-                    /*
-                     * we've made sure we have a cache of everything, use the
-                     * same one for each getVmobj().
-                     */
-                    get_options.cache = cache;
-                    getVmobj(uuid, get_options, function (err, obj) {
-                        if (err) {
-                            vm_cb(err);
+                    cache = _cache;
+                    cb();
+                });
+            }, function (_, cb) {
+                var vms = Object.keys(cache.zoneadm_objects);
+                vasync.forEachParallel({
+                    inputs: vms,
+                    func: function (uuid, vm_cb) {
+                        var get_options = options;
+
+                        /*
+                         * we've made sure we have a cache of everything, use
+                         * the same one for each getVmobj().
+                         */
+                        get_options.cache = cache;
+                        getVmobj(uuid, get_options, function (err, obj) {
+                            if (err) {
+                                vm_cb(err);
+                                return;
+                            }
+
+                            vmobjs.push(obj);
+                            vm_cb();
                             return;
-                        }
-
-                        vmobjs.push(obj);
-                        vm_cb();
-                        return;
-                    });
+                        });
+                    }
                 }, function (err) {
                     if (err) {
                         cb(err);
                         return;
                     }
                     cb();
-                }
-            );
-        }
-    ], function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
+                });
+            }
+        ]}, function (err) {
+            if (err) {
+                done(err);
+                return;
+            }
 
-        async.filterSeries(vmobjs, filter, function (results) {
-            callback(null, results);
+            vasync.filterSeries(vmobjs, filter, done);
         });
-    });
+    }
 }
 
 /*
@@ -1094,21 +1168,24 @@ function getZoneData(uuid, options, callback)
     }
 
     // we do this in series, because later bits need the list of zones
-    async.eachSeries([
-        loadZoneadmObjects,
-        loadSysinfo,
-        loadZoneinfoObjects,
-        loadZonexmlObjects,
-        loadLastExited,
-        loadLastModified,
-        loadJsonObjects,
-        loadDatasetObjects
-    ], function _loadWrapper(fn, cb) {
-        /*
-         * we expect each parameter to read from options and set their data
-         * into cache.<whatever> when they're requested to.
-         */
-        fn(uuid, cache, options, cb);
+    vasync.forEachPipeline({
+        inputs: [
+            loadZoneadmObjects,
+            loadSysinfo,
+            loadZoneinfoObjects,
+            loadZonexmlObjects,
+            loadLastExited,
+            loadLastModified,
+            loadJsonObjects,
+            loadDatasetObjects
+        ],
+        func: function _loadWrapper(fn, cb) {
+            /*
+             * we expect each parameter to read from options and set their data
+             * into cache.<whatever> when they're requested to.
+             */
+            fn(uuid, cache, options, cb);
+        }
     }, function (err) {
         if (err) {
             callback(err);
@@ -1211,41 +1288,44 @@ function loadJsonObjects(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
 
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        getVmobjJSON(obj.zonepath, options, function (err, results) {
-            if (err) {
-                /*
-                 * when zone_state is 'incomplete' we could be deleting it
-                 * in which case metadata may already be gone, ignore
-                 * failure to load mdata when 'incomplete' because of this.
-                 */
-                if (obj.state === 'incomplete') {
-                    log.debug({err: err}, 'zone is in state incomplete '
-                        + 'ignoring error loading JSON');
-                } else {
-                    errors.push(err);
-                    log.error(err);
+            getVmobjJSON(obj.zonepath, options, function (err, results) {
+                if (err) {
+                    /*
+                     * when zone_state is 'incomplete' we could be deleting it
+                     * in which case metadata may already be gone, ignore
+                     * failure to load mdata when 'incomplete' because of this.
+                     */
+                    if (obj.state === 'incomplete') {
+                        log.debug({err: err}, 'zone is in state incomplete '
+                            + 'ignoring error loading JSON');
+                    } else {
+                        errors.push(err);
+                        log.error(err);
+                    }
+                    cb();
+                    return;
                 }
-                cb();
-                return;
-            }
 
-            json_objects[vm_uuid] = {};
+                json_objects[vm_uuid] = {};
 
-            // whatever we got back, add to the VM object
-            VMOBJ_JSON_FIELDS.forEach(function (m) {
-                if (results.hasOwnProperty(m)) {
-                    json_objects[vm_uuid][m] = results[m];
-                }
-            });
+                // whatever we got back, add to the VM object
+                VMOBJ_JSON_FIELDS.forEach(function (m) {
+                    if (results.hasOwnProperty(m)) {
+                        json_objects[vm_uuid][m] = results[m];
+                    }
+                });
 
-            cb();
-        });
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading json_objects took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1287,20 +1367,25 @@ function loadLastExited(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
 
-        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
-            + '"zonename": ' + JSON.stringify(obj));
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
+                + '"zonename": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        getLastExited(obj.zonename, obj.zonepath, log, function (err, result) {
-            if (!err) {
-                last_exited[vm_uuid] = result;
-            }
-            cb();
-        });
+            getLastExited(obj.zonename, obj.zonepath, log,
+                function (err, result) {
+
+                if (!err) {
+                    last_exited[vm_uuid] = result;
+                }
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading last_exited took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1333,20 +1418,25 @@ function loadLastModified(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
+
+            assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
+                + '"zonename": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
-            + '"zonename": ' + JSON.stringify(obj));
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            getLastModified(obj.zonename, obj.zonepath, log,
+                function (err, time) {
 
-        getLastModified(obj.zonename, obj.zonepath, log, function (err, time) {
-            if (!err) {
-                last_modified[vm_uuid] = time;
-            }
-            cb();
-        });
+                if (!err) {
+                    last_modified[vm_uuid] = time;
+                }
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading last_modified took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1492,8 +1582,9 @@ function loadZonexmlObjects(uuid, cache, options, callback)
 
     // load the XML and translate to JSON in parallel for all VMs in
     // cache.zoneadm_objects
-    async.each(Object.keys(cache.zoneadm_objects),
-        function (vm_uuid, cb) {
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
             var obj = cache.zoneadm_objects[vm_uuid];
 
             assert(obj.hasOwnProperty('brand'), 'zoneadm_object missing '
@@ -1518,20 +1609,41 @@ function loadZonexmlObjects(uuid, cache, options, callback)
                     cb();
                 }
             );
-        }, function (err) {
+        }
+    }, function (err) {
             log.debug('loading zonexml_objects took %s',
                 hrtime.prettyHrtime(process.hrtime(start_time)));
 
-            if (errors.length > 0) {
-                // XXX just return the first error for now
-                callback(errors[0]);
-                return;
-            }
+        if (errors.length > 0) {
+            // XXX just return the first error for now
+            callback(errors[0]);
+            return;
+        }
 
-            cache.zonexml_objects = vmobjs;
-            callback();
+        cache.zonexml_objects = vmobjs;
+        callback();
+    });
+}
+
+function deepClone(src)
+{
+    var dst;
+    var key;
+
+    if (Array.isArray(src)) {
+        dst = [];
+        src.forEach(function (e) {
+            dst.push(deepClone(e));
+        });
+    } else if (typeof (src) === 'object') {
+        dst = {};
+        for (key in src) {
+            dst[key] = deepClone(src[key]);
         }
-    );
+    } else {
+        dst = src;
+    }
+    return (dst);
 }
 
 module.exports = {
diff --git a/src/vm/node_modules/vmload/vmload-datasets.js b/src/vm/node_modules/vmload/vmload-datasets.js
index 6c987863..5d751065 100644
--- a/src/vm/node_modules/vmload/vmload-datasets.js
+++ b/src/vm/node_modules/vmload/vmload-datasets.js
@@ -20,17 +20,18 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
 var EventEmitter = require('events').EventEmitter;
 var hrtime = require('/usr/vm/node_modules/hrtime');
 var props = require('/usr/vm/node_modules/props');
 var spawn = require('child_process').spawn;
+var util = require('util');
 var utils = require('utils');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var VMOBJ_ZFS_DEPENDENCIES = props.VMOBJ_ZFS_DEPENDENCIES;
 var ZFS_FIELDS = props.ZFS_FIELDS;
@@ -156,14 +157,20 @@ function cleanDatasetObject(obj)
         'written'
     ];
 
+    var expected_fields = [
+        'mountpoint',
+        'name',
+        'type'
+    ];
+
     // We should always have mountpoint, dataset and type because we force them
     // to be included in zfsList()
-    assert(obj.hasOwnProperty('mountpoint'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing mountpoint');
-    assert(obj.hasOwnProperty('name'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing name');
-    assert(obj.hasOwnProperty('type'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing type');
+    expected_fields.forEach(function assertExpectedField(field) {
+        if (!obj.hasOwnProperty(field)) {
+            assert(false, util.format('cleanDatasetObject(%s): missing %s',
+                JSON.stringify(obj), field));
+        }
+    });
 
     // convert numeric fields to proper numbers
     number_fields.forEach(function (field) {
@@ -323,9 +330,12 @@ function getDatasets(obj, options, callback)
         getZfsList(_options, callback);
 
     } else {
-        async.eachSeries(parents, function (parent, cb) {
-            _options.parent = parent;
-            getZfsList(_options, cb);
+        vasync.forEachPipeline({
+            inputs: parents,
+            func: function (parent, cb) {
+                _options.parent = parent;
+                getZfsList(_options, cb);
+            }
         }, function (err) {
             if (err) {
                 callback(err);
@@ -619,7 +629,7 @@ function zfsList(options, callback) {
  * pushed onto the tail of the queue. The queue is processed serially so long
  * as there are active requests.
  */
-zfs_list_queue = async.queue(function (task, callback) {
+zfs_list_queue = vasync.queue(function (task, callback) {
 
     var log = task.log;
     var options = {};
diff --git a/src/vm/node_modules/vmload/vmload-json.js b/src/vm/node_modules/vmload/vmload-json.js
index 740b9c22..162a8016 100644
--- a/src/vm/node_modules/vmload/vmload-json.js
+++ b/src/vm/node_modules/vmload/vmload-json.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -28,11 +28,11 @@
 require('/usr/node/node_modules/platform_node_version').assert();
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
 var fs = require('fs');
 var path = require('path');
 var vmload_utils = require('./vmload-utils');
 var wantField = vmload_utils.wantField;
+var vasync = require('/usr/vm/node_modules/vasync');
 
 function getVmobjJSON(zonepath, options, callback) {
     var log;
@@ -41,8 +41,8 @@ function getVmobjJSON(zonepath, options, callback) {
     assert(options.log, 'no logger passed to getVmobjJSON()');
     log = options.log;
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             if (!wantField(options, 'customer_metadata')
                 && !wantField(options, 'internal_metadata')) {
 
@@ -50,6 +50,8 @@ function getVmobjJSON(zonepath, options, callback) {
                 return;
             }
 
+            result.customer_metadata = {};
+            result.internal_metadata = {};
             loadJsonConfig(zonepath, 'metadata', log, function (err, metadata) {
                 if (err) {
                     cb(err);
@@ -67,12 +69,13 @@ function getVmobjJSON(zonepath, options, callback) {
                 });
                 cb();
             });
-        }, function (cb) {
+        }, function (_, cb) {
             if (!wantField(options, 'tags')) {
                 cb();
                 return;
             }
 
+            result.tags = {};
             loadJsonConfig(zonepath, 'tags', log, function (err, tags) {
                 if (err) {
                     cb(err);
@@ -82,12 +85,13 @@ function getVmobjJSON(zonepath, options, callback) {
                 result.tags = tags;
                 cb();
             });
-        }, function (cb) {
+        }, function (_, cb) {
             if (!wantField(options, 'routes')) {
                 cb();
                 return;
             }
 
+            result.routes = {};
             loadJsonConfig(zonepath, 'routes', log, function (err, routes) {
                 if (err) {
                     cb(err);
@@ -98,7 +102,7 @@ function getVmobjJSON(zonepath, options, callback) {
                 cb();
             });
         }
-    ], function (err) {
+    ]}, function (err) {
         if (err) {
             callback(err);
             return;
diff --git a/src/vm/node_modules/vmload/vmload-zoneadm.js b/src/vm/node_modules/vmload/vmload-zoneadm.js
index 69ce0d78..f28b0b23 100644
--- a/src/vm/node_modules/vmload/vmload-zoneadm.js
+++ b/src/vm/node_modules/vmload/vmload-zoneadm.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -125,6 +125,7 @@ function getZoneRecords(uuid, options, callback)
                     results[obj.uuid] = obj;
                 } else if (isUUID(obj.zonename)) {
                     results[obj.zonename] = obj;
+                    results[obj.zonename].uuid = obj.zonename;
                 } else if (obj.zonename !== 'global') {
                     log.error({object: obj}, 'zoneadm object is missing uuid');
                 }
diff --git a/src/vm/node_modules/zoneevent.js b/src/vm/node_modules/zoneevent.js
new file mode 100644
index 00000000..527e4c99
--- /dev/null
+++ b/src/vm/node_modules/zoneevent.js
@@ -0,0 +1,177 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * Substitute for 'zoneevent.c' that uses `VM.events` as the event source.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var VM = require('/usr/vm/node_modules/VM');
+
+module.exports.ZoneEvent = ZoneEvent;
+
+/*
+ * ZoneEvent class
+ */
+function ZoneEvent(opts) {
+    var self = this;
+
+    assert(self instanceof ZoneEvent, 'must be called with "new"');
+
+    EventEmitter.call(self);
+
+    assert.object(opts, 'opts');
+    assert.string(opts.name, 'opts.name');
+    assert.object(opts.log, 'opts.log');
+
+    self.ze_name = opts.name;
+    self.ze_logger = opts.log.child({client: self.ze_name});
+
+    self.ze_logger.info('starting ZoneEvent');
+
+    self.start();
+}
+util.inherits(ZoneEvent, EventEmitter);
+
+
+/*
+ * Start the vmadm events stream
+ */
+ZoneEvent.prototype.start = function start() {
+    var self = this;
+
+    var opts = {
+        log: self.ze_logger,
+        name: self.ze_name
+    };
+
+    assert(!self.ze_stop, 'ZoneEvent not stopped');
+
+    VM.events(opts, handler, ready);
+
+    function ready(err, obj) {
+        if (err) {
+            self.ze_logger.error({err: err}, 'ZoneEvent error');
+        } else {
+            assert.object(obj, 'obj');
+            assert.func(obj.stop, 'obj.stop');
+            self.ze_logger.debug('ZoneEvent (VM.events) ready');
+            self.ze_stop = obj.stop;
+        }
+
+        self.emit('ready', err, obj);
+    }
+
+    function handler(ev) {
+        self._handleVmadmEvent(ev);
+    }
+};
+
+/*
+ * Handle an incoming vmadm update
+ */
+ZoneEvent.prototype._handleVmadmEvent = function _handleVmadmEvent(ev) {
+    var self = this;
+
+    assert.object(ev, 'ev');
+    assert.date(ev.date, 'ev.date');
+    assert.string(ev.type, 'ev.type');
+    assert.string(ev.zonename, 'ev.zonename');
+
+    self.ze_logger.trace({ev: ev}, 'processing vmadm event');
+
+    var zoneupdated = false;
+    var obj = {
+        date: ev.date,
+        zonename: ev.zonename
+    };
+
+    switch (ev.type) {
+    case 'create':
+        obj.oldstate = '';
+        obj.newstate = ev.vm.zone_state;
+        zoneupdated = true;
+        break;
+    case 'delete':
+        obj.newstate = '';
+        zoneupdated = true;
+        break;
+    case 'modify':
+        assert.array(ev.changes, 'ev.changes');
+        for (var i = 0; i < ev.changes.length; i++) {
+            var change = ev.changes[i];
+            if (change.path.length === 1
+                && change.path[0] === 'zone_state') {
+
+                obj.oldstate = change.from;
+                obj.newstate = change.to;
+                zoneupdated = true;
+                break;
+            }
+        }
+        break;
+    default:
+        assert(false, 'unknown vmadm event type: ' + ev.type);
+        break;
+    }
+
+    if (zoneupdated) {
+        /*
+         * There is some discrepency with vminfod and sysevents, so we
+         * translate the vminfod events to match what is expected by sysevent
+         */
+        if (obj.newstate === 'installed' && obj.oldstate !== 'incomplete') {
+            obj.newstate = 'uninitialized';
+        }
+        if (obj.oldstate === 'installed') {
+            obj.oldstate = 'uninitialized';
+        }
+        self.emit('event', obj);
+    }
+};
+
+/*
+ * stop the watcher
+ */
+ZoneEvent.prototype.stop = function vminfod_watcher_stop() {
+    var self = this;
+
+    if (self.ze_stop) {
+        self.ze_stop();
+        delete self.ze_stop;
+    }
+};
+
+/*
+ * if called directly just hook a vminfo stream to stdout
+ */
+if (require.main === module) {
+    var zw = new ZoneEvent('Module Run Directly');
+    zw.on('event', function (ev) {
+        console.log(JSON.stringify(ev));
+    });
+}
diff --git a/src/vm/sbin/vmadm.js b/src/vm/sbin/vmadm.js
index 9ad8b6fa..c95df402 100755
--- a/src/vm/sbin/vmadm.js
+++ b/src/vm/sbin/vmadm.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -52,6 +52,7 @@ var COMMANDS = [
     'create-snapshot',
     'delete', 'destroy',
     'delete-snapshot',
+    'events',
     'stop', 'halt',
     'help',
     'info',
@@ -148,6 +149,7 @@ function usage(message, code)
     out('console <uuid>');
     out('delete <uuid>');
     out('delete-snapshot <uuid> <snapname>');
+    out('events [-fjr] [uuid]');
     out('get <uuid>');
     out('info <uuid> [type,...]');
     out('install <uuid>');
@@ -243,7 +245,7 @@ function getListProperties(field)
     return undefined;
 }
 
-function getUUID(command, p)
+function getUUID(command, p, opts)
 {
     var uuid;
 
@@ -257,6 +259,10 @@ function getUUID(command, p)
         }
     }
 
+    if (opts.optional) {
+        return null;
+    }
+
     return usage('Invalid or missing UUID for ' + command);
 }
 
@@ -398,6 +404,14 @@ function addCommandOptions(command, opts, shorts)
     case 'sysrq':
         // these only take uuid or 'special' args like start order=cd
         break;
+    case 'events':
+        opts.full = Boolean;
+        shorts.f = ['--full'];
+        opts.json = Boolean;
+        shorts.j = ['--json'];
+        opts.ready = Boolean;
+        shorts.r = ['--ready'];
+        break;
     case 'lookup':
         opts.json = Boolean;
         shorts.j = ['--json'];
@@ -716,6 +730,93 @@ function readFile(filename, callback)
     });
 }
 
+function do_events(parsed, callback) {
+    var uuid = getUUID('events', parsed, {optional: true});
+
+    var opts = {
+        name: 'vmadm CLI'
+    };
+    if (process.env.VMADM_IDENT) {
+        opts.name += util.format(' - %s', process.env.VMADM_IDENT);
+    }
+    if (uuid) {
+        opts.zonename = uuid;
+    }
+
+    VM.events(opts, vmEventHandler, vmEventReady);
+
+    // Called when a vminfod event is seen
+    function vmEventHandler(ev) {
+        if (parsed.json) {
+            console.log(JSON.stringify(ev));
+            return;
+        }
+
+        var zn = formatZonename(ev.zonename);
+        var date = formatDate(ev.date);
+
+        var alias = (ev.vm || {}).alias || '-';
+        if (alias.length > 30) {
+            alias = util.format('%s...', alias.substr(0, 27));
+        }
+
+        // format the output nicely
+        var base = util.format('[%s] %s %s %s',
+            date, zn, alias, ev.type);
+
+        delete ev.vm;
+        if (ev.changes) {
+            ev.changes.forEach(function (change) {
+                console.log('%s: %s %s :: %j -> %j',
+                    base,
+                    change.prettyPath,
+                    change.action,
+                    change.from,
+                    change.to);
+            });
+        } else {
+            console.log(base);
+        }
+    }
+
+    // Called when the vminfod stream is ready
+    function vmEventReady(err, obj) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        if (!parsed.ready)
+            return;
+
+        var ev = obj.ev;
+        var date = formatDate(ev.date);
+        if (parsed.json) {
+            console.log(JSON.stringify(ev));
+        } else if (parsed.full) {
+            console.log('[%s] %s (uuid %s)', date, ev.type, ev.uuid);
+        } else {
+            console.log('[%s] %s', date, ev.type);
+        }
+    }
+
+    function formatDate(date) {
+        if (parsed.full) {
+            return date.toISOString();
+        } else {
+            return date.toISOString().split('T')[1];
+        }
+    }
+
+    function formatZonename(zonename) {
+        if (parsed.full) {
+            return zonename;
+        } else {
+            return zonename.split('-')[0];
+        }
+    }
+}
+
 function main(callback)
 {
     var args = process.argv.slice(1);
@@ -756,6 +857,9 @@ function main(callback)
     VM.loglevel = 'debug';
 
     switch (command) {
+    case 'events':
+        do_events(parsed, callback);
+        break;
     case 'start':
     case 'boot':
         uuid = getUUID(command, parsed);
diff --git a/src/vm/sbin/vmadmd.js b/src/vm/sbin/vmadmd.js
index 0cd5518d..20051c57 100755
--- a/src/vm/sbin/vmadmd.js
+++ b/src/vm/sbin/vmadmd.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  */
 
@@ -40,11 +40,11 @@ var path = require('path');
 var http = require('http');
 var Qmp = require('/usr/vm/node_modules/qmp').Qmp;
 var qs = require('querystring');
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var url = require('url');
 var util = require('util');
 var vasync = require('vasync');
 var zonecfg = require('/usr/vm/node_modules/zonecfg');
+var ZoneEvent = require('/usr/vm/node_modules/zoneevent').ZoneEvent;
 
 /*
  * The DOCKER_RUNTIME_DELAY_RESET parameter is used when restarting a Docker VM
@@ -885,15 +885,15 @@ function updateZoneStatus(ev)
 {
     var load_fields;
     var reprovisioning = false;
-    ev = ev.data;
 
     if (! ev.hasOwnProperty('zonename') || ! ev.hasOwnProperty('oldstate')
-        || ! ev.hasOwnProperty('newstate') || ! ev.hasOwnProperty('when')) {
+        || ! ev.hasOwnProperty('newstate') || ! ev.hasOwnProperty('date')) {
 
         log.debug('skipping unknown event: ' + JSON.stringify(ev, null, 2));
         return;
     }
 
+
     /*
      * With OS-4942 and OS-5011 additional states were added which occur before
      * the zone is installed. We don't care about such zones here since we're
@@ -943,14 +943,14 @@ function updateZoneStatus(ev)
     // if we've never seen this VM before, we always load once.
     if (!seen_vms.hasOwnProperty(ev.zonename)) {
         log.debug(ev.zonename + ' is a VM we haven\'t seen before and went '
-            + 'from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.when);
+            + 'from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.date);
         seen_vms[ev.zonename] = {};
         // We'll continue on to load this VM below with VM.load()
     } else if (!seen_vms[ev.zonename].hasOwnProperty('uuid')) {
         // We just saw this machine and haven't finished loading it the first
         // time.
         log.debug('Already loading VM ' + ev.zonename + ' ignoring transition'
-            + ' from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.when);
+            + ' from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.date);
         return;
     } else if (PROV_WAIT[seen_vms[ev.zonename].uuid]) {
         // We're already waiting for this machine to provision, other
@@ -969,7 +969,7 @@ function updateZoneStatus(ev)
         || ev.newstate === 'uninitialized')) {
 
         log.info('' + ev.zonename + ' (kvm) went from ' + ev.oldstate
-            + ' to ' + ev.newstate + ' at ' + ev.when);
+            + ' to ' + ev.newstate + ' at ' + ev.date);
         // Continue on to VM.load()
     } else if (seen_vms[ev.zonename].docker
         && (ev.newstate === 'uninitialized')) {
@@ -985,7 +985,7 @@ function updateZoneStatus(ev)
             'zonepath'
         ]}, function (err, vmobj) {
             log.info(ev.zonename + ' (docker) went from ' + ev.oldstate + ' to '
-                + ev.newstate + ' at ' + ev.when);
+                + ev.newstate + ' at ' + ev.date);
 
             /*
              * If we stop while autoboot is set, the user was intending for it
@@ -1025,7 +1025,7 @@ function updateZoneStatus(ev)
         if (!reprovisioning) {
             log.trace('ignoring transition for ' + ev.zonename + ' ('
                 + seen_vms[ev.zonename].brand + ') from ' + ev.oldstate + ' to '
-                + ev.newstate + ' at ' + ev.when);
+                + ev.newstate + ' at ' + ev.date);
             return;
         }
     }
@@ -1152,18 +1152,14 @@ function updateZoneStatus(ev)
     });
 }
 
-function startZoneWatcher(callback)
+function startZoneEvent(callback)
 {
-
-    var se = new SyseventStream({
-        class: 'status',
-        logger: log,
-        channel: 'com.sun:zones:status'
+    var ze = new ZoneEvent({
+        name: 'vmadmd ZoneEvent',
+        log: log
     });
-    se.on('readable', function () {
-        var ev;
-        while ((ev = se.read()) !== null)
-            callback(ev);
+    ze.on('event', function (ev) {
+        callback(ev);
     });
 }
 
@@ -2077,6 +2073,7 @@ function upgradeVM(vmobj, fields, callback)
 
                 image_uuid = origin.split('@')[0].split('/').pop();
                 log.info('setting new image_uuid: ' + image_uuid);
+
                 cmd = [
                     'add attr',
                     'set name=dataset-uuid',
@@ -2086,7 +2083,6 @@ function upgradeVM(vmobj, fields, callback)
                 ].join('; ');
 
                 zonecfg(vmobj.uuid, [cmd], {log: log},
-
                     function (add_err, add_fds) {
                         if (add_err) {
                             log.error(add_err);
@@ -2338,7 +2334,6 @@ function upgradeVM(vmobj, fields, callback)
             var cmd;
 
             log.debug('setting vm-version = 1');
-
             cmd = [
                 'add attr',
                 'set name=vm-version',
@@ -2382,7 +2377,7 @@ function main()
 {
     // XXX TODO: load fs-ext so we can flock a pid file to be exclusive
 
-    startZoneWatcher(updateZoneStatus);
+    startZoneEvent(updateZoneStatus);
     startHTTPHandler();
     startTraceLoop();
     startSeenCleaner();
diff --git a/src/vm/sbin/vminfod.js b/src/vm/sbin/vminfod.js
new file mode 100755
index 00000000..75a64de4
--- /dev/null
+++ b/src/vm/sbin/vminfod.js
@@ -0,0 +1,80 @@
+#!/usr/node/bin/node --abort_on_uncaught_exception
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * Vminfod starting point
+ */
+
+var onlyif = require('/usr/node/node_modules/onlyif');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var Vminfod = require('../node_modules/vminfod/vminfod');
+
+var log = bunyan.createLogger({
+    name: 'vminfod',
+    level: 'debug',
+    serializers: bunyan.stdSerializers
+});
+
+function startVminfod() {
+    var opts = {
+        log: log
+    };
+    var vminfod = new Vminfod(opts);
+
+    log.info('Starting vminfod');
+
+    vminfod.start(function (err) {
+        if (err) {
+            log.fatal({err: err}, 'Failed to start vminfod');
+            process.exit(1);
+        }
+
+        log.info('Started vminfod');
+    });
+
+    process.on('uncaughtException', function (err) {
+        log.fatal({err: err},
+            'Uncaught exception in vminfo process: %s',
+            err.message);
+        log.fatal('%s', err.stack);
+
+        vminfod.stop();
+        process.exit(1);
+    });
+
+    process.on('exit', function () {
+        log.info('Vminfo process exiting');
+        vminfod.stop();
+    });
+}
+
+onlyif.rootInSmartosGlobal(function (err) {
+    if (err) {
+        log.error({err: err},
+            'Fatal: cannot run because: %s', err.message);
+        process.exit(1);
+    }
+
+    startVminfod();
+});
diff --git a/src/vm/smf/system-metadata.xml b/src/vm/smf/system-metadata.xml
index 055a7cf3..ac8ec55a 100644
--- a/src/vm/smf/system-metadata.xml
+++ b/src/vm/smf/system-metadata.xml
@@ -10,6 +10,10 @@
       <service_fmri value='svc:/system/filesystem/local'/>
     </dependency>
 
+    <dependency name="vminfod" grouping="require_all" restart_on="none" type="service" >
+      <service_fmri value="svc:/system/smartdc/vminfod:default" />
+    </dependency>
+
     <exec_method
       type="method"
       name="start"
diff --git a/src/vm/smf/system-vmadmd.xml b/src/vm/smf/system-vmadmd.xml
index b55b3846..28805417 100644
--- a/src/vm/smf/system-vmadmd.xml
+++ b/src/vm/smf/system-vmadmd.xml
@@ -11,6 +11,10 @@
       <service_fmri value="svc:/system/smartdc/init"/>
     </dependency>
 
+    <dependency name="vminfod" grouping="require_all" restart_on="none" type="service" >
+      <service_fmri value="svc:/system/smartdc/vminfod:default" />
+    </dependency>
+
     <exec_method
       type="method"
       name="start"
diff --git a/src/vm/smf/system-vminfod b/src/vm/smf/system-vminfod
new file mode 100755
index 00000000..7a247c5c
--- /dev/null
+++ b/src/vm/smf/system-vminfod
@@ -0,0 +1,49 @@
+#!/bin/bash
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+# Use is subject to license terms.
+
+set -o xtrace
+
+. /lib/svc/share/smf_include.sh
+
+PATH=/usr/sbin:/usr/bin; export PATH
+
+case "$1" in
+'start')
+    ctrun -l child -o noorphan /usr/vm/sbin/vminfod 2>&1 &
+    # Don't consider the service "online" until vminfod is responsive over the
+    # HTTP interface.  If vminfod fails for any reason this line will run until
+    # SMF brings this service into maintenance mode.
+    while ! vminfod ping; do sleep 1; done
+    ;;
+
+'stop')
+    ;;
+
+*)
+    echo "Usage: $0 { start | stop }"
+    exit $SMF_EXIT_ERR_FATAL
+    ;;
+esac
+exit $SMF_EXIT_OK
diff --git a/src/vm/smf/system-vminfod.xml b/src/vm/smf/system-vminfod.xml
new file mode 100644
index 00000000..6c355110
--- /dev/null
+++ b/src/vm/smf/system-vminfod.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<service_bundle type="manifest" name="vminfod">
+  <service name="system/smartdc/vminfod" type="service" version="1.0.0">
+
+    <create_default_instance enabled="true"/>
+    <single_instance/>
+
+    <dependency name='filesystem-local' grouping='require_all' restart_on='none' type='service'>
+      <service_fmri value='svc:/system/filesystem/local'/>
+    </dependency>
+
+    <exec_method
+      type="method"
+      name="start"
+      exec="/usr/vm/smf/system-vminfod %m"
+      timeout_seconds="300">
+      <method_context working_directory='/'>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="300">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <property_group name="application" type="application">
+    </property_group>
+
+    <stability value="Evolving"/>
+
+    <template>
+      <common_name>
+        <loctext xml:lang="C">VM Info Daemon (node)</loctext>
+      </common_name>
+    </template>
+
+  </service>
+</service_bundle>
diff --git a/src/vm/tests/test-defaults.js b/src/vm/tests/test-defaults.js
index 19a5669a..346cd7f9 100644
--- a/src/vm/tests/test-defaults.js
+++ b/src/vm/tests/test-defaults.js
@@ -1,4 +1,4 @@
-// Copyright 2014 Joyent, Inc.  All rights reserved.
+// Copyright (c) 2017, Joyent, Inc.
 //
 // These tests ensure that default values don't change accidentally.
 //
@@ -6,6 +6,8 @@
 var execFile = require('child_process').execFile;
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -220,6 +222,8 @@ function check_values(t, state)
             continue;
         } else if (state.brand === 'kvm' && prop === 'pid') {
             continue;
+        } else if (prop.match(/^transition_/)) {
+            continue;
         } else if (!defaults.hasOwnProperty(prop)) {
             t.ok(false, 'unexpected property: ' + prop);
         }
@@ -279,12 +283,50 @@ test('check default create_timestamp', function (t) {
         do_not_inventory: true
     }, state, [
         function (cb) {
-            zonecfg(['-z', state.uuid, 'remove attr name=create-timestamp;'],
-                function (err, fds) {
-
-                t.ok(!err, 'removing create-timestamp: '
-                    + (err ? err.message : 'ok'));
-                cb(err);
+            var vs = new vminfod.VminfodEventStream('test-defaults.js');
+            vs.once('ready', function () {
+                vasync.parallel({
+                    funcs: [
+                        function (cb2) {
+                            var obj = {
+                                type: 'modify',
+                                zonename: state.uuid
+                            };
+                            var opts = {
+                                timeout: 30 * 1000,
+                                catchErrors: true,
+                                teardown: true
+                            };
+                            var changes = [
+                                {
+                                    path: ['create_timestamp'],
+                                    action: 'changed'
+                                }
+                            ];
+                            vs.watchForChanges(obj, changes, opts,
+                                function (err) {
+                                if (err) {
+                                    cb2(err);
+                                    return;
+                                }
+
+                                cb2();
+                            });
+                        },
+                        function (cb2) {
+                            zonecfg(['-z', state.uuid,
+                                'remove attr name=create-timestamp;'],
+                                function (err, fds) {
+
+                                t.ok(!err, 'removing create-timestamp: '
+                                    + (err ? err.message : 'ok'));
+                                cb2(err);
+                            });
+                        }
+                    ]
+                }, function (err) {
+                    cb(err);
+                });
             });
         }, function (cb) {
             VM.load(state.uuid, function (err, obj) {
diff --git a/src/vm/tests/test-delete.js b/src/vm/tests/test-delete.js
index c030b91d..0cc347ee 100644
--- a/src/vm/tests/test-delete.js
+++ b/src/vm/tests/test-delete.js
@@ -26,8 +26,8 @@
  */
 
 var libuuid = require('/usr/node/node_modules/uuid');
-var VM = require('/usr/vm/node_modules/VM');
 var vasync = require('/usr/vm/node_modules/vasync');
+var VM = require('/usr/vm/node_modules/VM');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -48,7 +48,7 @@ test('test deleting nonexistent VM', function(t) {
             var uuid = libuuid.create();
             t.ok(uuid, 'uuid is: ' + uuid);
             VM.delete(uuid, {}, function (err) {
-                if (err && err.message.match(/No such zone configured/)) {
+                if (err && err.code === 'ENOENT') {
                     t.ok(true, 'zone ' + uuid + ' already does not exist, skipping');
                 } else {
                     t.ok(!err, 'deleted VM: ' + (err ? err.message : 'success'));
diff --git a/src/vm/tests/test-diff.js b/src/vm/tests/test-diff.js
new file mode 100644
index 00000000..fb5e43db
--- /dev/null
+++ b/src/vm/tests/test-diff.js
@@ -0,0 +1,262 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var util = require('util');
+
+var diff = require('/usr/vm/node_modules/diff');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+function copy(o) {
+    return JSON.parse(JSON.stringify(o));
+}
+
+[
+    undefined,
+    null,
+    new Date(),
+    function func() {},
+    '',
+    'a',
+    5,
+    [],
+    ['foo'],
+    [['foo']],
+    [{name: 'foo'}],
+    {},
+    [function arrayFunc() {}],
+    {func: function objFunc() {}},
+    {name: 'foo'},
+    {names: ['foo','bar']},
+    {things: [{name: 'foo'}]}
+].forEach(function (o) {
+    test('test diff objects that are the same: '
+        + util.inspect(o), function (t) {
+
+        var changes = diff(o, o);
+        t.ok(Array.isArray(changes), 'changes is an array');
+        t.equal(changes.length, 0, 'changes is an empty array');
+        t.end();
+    });
+});
+
+test('test diff simple objects', function (t) {
+    var changes;
+    var change;
+
+    var o1 = {
+        id: 1,
+        name: 'foo'
+    };
+    var o2 = {
+        id: 1,
+        name: 'bar'
+    };
+
+    // compare objects
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+
+    // assert return
+    change = changes[0];
+    t.equal(change.path[0], ['name'], 'path changed');
+    t.equal(change.prettyPath, 'name', 'path changed (pretty)');
+    t.equal(change.action, 'changed', 'action changed');
+    t.equal(change.from, 'foo', 'path changed from foo');
+    t.equal(change.to, 'bar', 'path changed to bar');
+
+    // modify object and compare again
+    o2.id = 2;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 2, 'two changes');
+
+    // assert return
+    t.equal(changes[0].path[0], 'id', 'id changed');
+    t.equal(changes[0].prettyPath, 'id', 'id changed (pretty)');
+    t.equal(changes[0].action, 'changed', 'action changed');
+    t.equal(changes[0].from, o1.id, 'id changed from');
+    t.equal(changes[0].to, o2.id, 'id changed to');
+
+    t.equal(changes[1].path[0], 'name', 'name changed');
+    t.equal(changes[1].prettyPath, 'name', 'name changed (pretty)');
+    t.equal(changes[1].action, 'changed', 'action changed');
+    t.equal(changes[1].from, o1.name, 'name changed from');
+    t.equal(changes[1].to, o2.name, 'name changed to');
+
+    // make them the same
+    o2.id = o1.id;
+    o2.name = o1.name;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 0, 'no changes');
+
+    t.end();
+});
+
+test('test diff nested objects', function (t) {
+    var changes;
+    var change;
+
+    var o1 = {
+        foo: {
+            bar: {
+                baz: 'hello'
+            }
+        }
+    };
+    var o2 = {
+        foo: {
+            bar: {
+                baz: 'goodbye'
+            }
+        }
+    };
+
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo', 'bar', 'baz'], 'path is correct');
+    t.equal(change.prettyPath, 'foo.bar.baz', 'path is correct (pretty)');
+    t.equal(change.action, 'changed', 'action changed');
+    t.equal(change.from, 'hello', 'changed from');
+    t.equal(change.to, 'goodbye', 'changed to');
+
+    // make them the same
+    o2.foo.bar.baz = 'hello';
+
+    // add a new element
+    o2.foo.bar.bat = 'new';
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo', 'bar', 'bat'], 'path is correct');
+    t.equal(change.prettyPath, 'foo.bar.bat', 'path is correct (pretty)');
+    t.equal(change.action, 'added', 'action added');
+    t.equal(change.to, 'new', 'changed to');
+
+    // remove o2.foo completely
+    delete o2.foo;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo'], 'path is correct');
+    t.equal(change.prettyPath, 'foo', 'path is correct (pretty)');
+    t.equal(change.action, 'removed', 'action removed');
+    t.deepEqual(change.from, o1.foo, 'changed from');
+
+    t.end();
+});
+
+
+test('test diff vmadm payload objects', function (t) {
+    var changes;
+    var change;
+
+    var base_payload = {
+        id: 1,
+        alias: 'fake-vm',
+        disks: [
+            {
+                path: '/',
+                name: 'slash'
+            }
+        ]
+    };
+    var payload1 = copy(base_payload);
+    var payload2 = copy(base_payload);
+
+    // add a disk to payload2
+    var new_disk = {
+        path: '/data',
+        name: 'data'
+    };
+    payload2.disks.push(new_disk);
+
+    // compare objects
+    changes = diff(payload1, payload2);
+    t.equal(changes.length, 1, 'one change');
+
+    // assert return
+    change = changes[0];
+    t.deepEqual(change.path, ['disks', null], 'path changed');
+    t.equal(change.prettyPath, 'disks.*', 'path changed (pretty)');
+    t.equal(change.action, 'added', 'action changed');
+    t.equal(change.to, new_disk, 'disk added');
+
+    // reset disks
+    payload1.disks = [
+        {
+            path: '/',
+            name: 'old'
+        }
+    ];
+    payload2.disks = [
+        {
+            path: '/',
+            name: 'new'
+        }
+    ];
+
+    // without a map, this will be reported as 2 changes, 'old' being deleted
+    // and 'new' being added
+    // compare objects
+    changes = diff(payload1, payload2);
+    t.equal(changes.length, 2, 'two changes');
+
+    t.deepEqual(changes[0].path, ['disks', null], 'disks changed');
+    t.equal(changes[0].prettyPath, 'disks.*', 'disks changed (pretty)');
+    t.equal(changes[0].action, 'removed', 'action');
+    t.equal(changes[0].from, payload1.disks[0], 'disks changed from');
+
+    t.deepEqual(changes[1].path, ['disks', null], 'disks changed');
+    t.equal(changes[1].prettyPath, 'disks.*', 'disks changed (pretty)');
+    t.equal(changes[1].action, 'added', 'action');
+    t.equal(changes[1].to, payload2.disks[0], 'disks changed to');
+
+    // with a map, this will be reported as 1 change, 'disks.*.name' changing
+    // from 'old' to 'new'
+    changes = diff(payload1, payload2, {
+        map: {
+            disks: 'path'
+        }
+    });
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['disks', null, 'name'], 'disks changed');
+    t.equal(change.prettyPath, 'disks.*.name', 'disks changed (pretty)');
+    t.equal(change.action, 'changed', 'action');
+    t.equal(change.from, payload1.disks[0].name, 'disks changed from');
+    t.equal(change.to, payload2.disks[0].name, 'disks changed to');
+    t.equal(change.ident, payload1.disks[0].path, 'disks changed ident');
+
+    // assert return
+    t.end();
+});
diff --git a/src/vm/tests/test-docker.js b/src/vm/tests/test-docker.js
index 8f2af6dd..1a6c2f04 100644
--- a/src/vm/tests/test-docker.js
+++ b/src/vm/tests/test-docker.js
@@ -1,9 +1,33 @@
-// Copyright 2017 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that docker flag works as expected when setting/unsetting
-// Also test that /etc/resolv.conf, /etc/hosts and /etc/hostname are set
-// correctly.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * These tests ensure that docker flag works as expected when
+ * setting/unsetting.  Also test that /etc/resolv.conf, /etc/hosts and
+ * /etc/hostname are set correctly.
+ */
 
 var async = require('/usr/node/node_modules/async');
 var EventEmitter = require('events').EventEmitter;
@@ -11,9 +35,9 @@ var exec = require('child_process').exec;
 var fs = require('fs');
 var libuuid = require('/usr/node/node_modules/uuid');
 var path = require('path');
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var util = require('util');
 var VM = require('/usr/vm/node_modules/VM');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -1240,9 +1264,9 @@ test('test restart delay reset', function (t) {
     var emitter = new EventEmitter();
     var events = [];
     var payload = JSON.parse(JSON.stringify(common_payload));
-    var se;
     var state = {brand: payload.brand};
     var num_cycles = (cycles_fail * 2) + 1;
+    var vs;
 
     payload.autoboot = false;
     payload.brand = 'lx';
@@ -1258,59 +1282,79 @@ test('test restart delay reset', function (t) {
             + '\"mkdir -p /var/tmp; '
             + '[[ $(ls -1 /var/tmp | wc -l) == ' + cycles_fail + ' ]] '
             + '&& (sleep ' + cycle_reset_delay + '; rm -f /var/tmp/*; exit 0) '
-            + '|| (touch /var/tmp/$(/native/usr/bin/uuid); exit 1)\"]',
+            + '|| (touch /var/tmp/$(/native/usr/bin/uuid); sleep 2; exit 1)\"]',
         'docker:restartpolicy': 'always'
     };
     payload.kernel_version = '3.13.0';
 
     vmtest.on_new_vm(t, payload.image_uuid, payload, state, [
         function (cb) {
+            var restartKeys = [
+                'internal_metadata.docker:restartcount',
+                'internal_metadata.docker:restartdelay'
+            ];
+            var running = false;
             var starts = 0;
             var stops = 0;
 
-            se = new SyseventStream({
-                class: 'status',
-                channel: 'com.sun:zones:status'
-            });
-            se.on('readable', function () {
+            vs = new vminfod.VminfodEventStream('test-docker.js');
+            vs.on('readable', function () {
+                var dockerRestartKeysHaveChanged;
                 var ev;
                 var im;
 
                 // for each start/stop, if it's for the VM we just created we'll
                 // push an event on the events array.
-                while ((ev = se.read()) !== null) {
-                    if (ev.data.zonename === state.uuid) {
-                        if (ev.data.newstate === 'uninitialized') {
-                            // VM went to state === 'stopped'
-                            im = JSON.parse(fs.readFileSync('/zones/'
-                                + ev.data.zonename + '/config/metadata.json'))
-                                .internal_metadata;
-                            stops++;
-                            events.push({
-                                action: 'stop',
-                                time: ev.data.when,
-                                restartcount: im['docker:restartcount'],
-                                restartdelay: im['docker:restartdelay']
-                            });
-                        } else if (ev.data.newstate === 'running') {
-                            // VM went to state === 'running'
-                            starts++;
-                            events.push({
-                                action: 'start',
-                                time: ev.data.when
-                            });
-                        }
+                while ((ev = vs.read()) !== null) {
+                    if (ev.zonename !== state.uuid)
+                        return;
+
+                    dockerRestartKeysHaveChanged = (ev.changes || []).map(
+                        function (change) {
+
+                        return (change.prettyPath);
+                    }).filter(function (p) {
+                        return (restartKeys.indexOf(p) > -1);
+                    }).length > 0;
+
+                    if (running && ev.vm.state === 'stopped') {
+                        // VM went to state === 'stopped'
+                        running = false;
+                        stops++;
+                        events.push({
+                            action: 'stop',
+                            time: ev.date
+                        });
+                    } else if (!running && ev.vm.state === 'running') {
+                        // VM went to state === 'running'
+                        running = true;
+                        starts++;
+                        events.push({
+                            action: 'start',
+                            time: ev.date
+                        });
+                    }
+
+                    if (dockerRestartKeysHaveChanged) {
+                        im = ev.vm.internal_metadata;
+                        events.push({
+                            action: 'docker-keys-changed',
+                            time: ev.date,
+                            restartcount: im['docker:restartcount'],
+                            restartdelay: im['docker:restartdelay']
+                        });
                     }
                 }
 
                 if (starts >= num_cycles && stops >= num_cycles) {
                     // stop the zoneevent watcher
-                    se.stop();
-                    se = null;
+                    vs.stop();
+                    vs = null;
                     emitter.emit('done');
                 }
             });
-            se.once('ready', function () {
+
+            vs.once('ready', function () {
                 cb();
             });
         }, function (cb) {
@@ -1334,35 +1378,32 @@ test('test restart delay reset', function (t) {
                 // next start (this will be the restart delay + the time it
                 // actually takes to start).
                 events.forEach(function (evt) {
-                    if (evt.action === 'start') {
+                    switch (evt.action) {
+                    case 'start':
                         if (last_stop > 0) {
-                            deltas.push((evt.time - last_stop) / 1000000);
+                            deltas.push(evt.time - last_stop);
                         }
-                    } else if (evt.action === 'stop') {
+                        break;
+                    case 'stop':
                         last_stop = evt.time;
-                    } else {
+                        break;
+                    case 'docker-keys-changed':
+                        break;
+                    default:
                         throw (new Error('Unexpected action: ' + evt.action));
                     }
                 });
 
-                // Only 'stop' events have a restartcount, so create an array
-                // just of the restart counts.
+                // Create an array just of the restart counts.
                 restartcounts = events.filter(function (evt) {
-                    if (evt.action === 'stop') {
-                        return (true);
-                    }
-                    return (false);
+                    return (evt.action === 'docker-keys-changed');
                 }).map(function (evt) {
                     return (evt.restartcount);
                 });
 
-                // Only 'stop' events have a restartdelay, so create an array
-                // just of the restart delays.
+                // Create an array just of the restart delays.
                 restartdelays = events.filter(function (evt) {
-                    if (evt.action === 'stop') {
-                        return (true);
-                    }
-                    return (false);
+                    return (evt.action === 'docker-keys-changed');
                 }).map(function (evt) {
                     return (evt.restartdelay);
                 });
@@ -1433,10 +1474,10 @@ test('test restart delay reset', function (t) {
             });
         }
     ], function () {
-        // stop the zoneevent watcher
-        if (se != null) {
-            se.stop();
-            se = null;
+        // stop the vminfod watcher
+        if (vs !== null) {
+            vs.stop();
+            vs = null;
         }
 
         t.end();
diff --git a/src/vm/tests/test-fswatcher.js b/src/vm/tests/test-fswatcher.js
new file mode 100644
index 00000000..a9c59ac6
--- /dev/null
+++ b/src/vm/tests/test-fswatcher.js
@@ -0,0 +1,525 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert');
+var execFile = require('child_process').execFile;
+var fs = require('fs');
+var path = require('path');
+var util = require('util');
+
+var bunyan = require('/usr/vm/node_modules/bunyan');
+var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
+var vasync = require('/usr/vm/node_modules/vasync');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('/usr/vm/node_modules/nodeunit-plus');
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: 'fswatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'error' } ],
+    serializers: bunyan.stdSerializers
+});
+var testdir = path.join('/tmp', 'test-fswatcher-' + process.pid);
+
+test('try creating temp directory', function createTmpDir(t) {
+    execFile('/usr/bin/mkdir', ['-p', testdir],
+        function mkdir(err, stdout, stderr) {
+
+        assert(!err);
+        t.end();
+    });
+});
+
+test('try starting and stopping watcher', function startAndStopTest(t) {
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+    t.ok(!fsw.isRunning(), 'watcher not running');
+
+    fsw.once('ready', function fswOnReady() {
+        t.ok(fsw.isRunning(), 'watcher running');
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.start();
+});
+
+test('try starting already running watcher',
+    function startAlreadyRunningTest(t) {
+
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+
+    fsw.once('ready', function fswOnReady() {
+        t.ok(fsw.isRunning(), 'watcher running');
+        t.throws(function startThrow() {
+            fsw.start();
+        }, null, 'start twice');
+
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.start();
+});
+
+test('try stopping a stopped watcher', function stopAlreadyStoppedTest(t) {
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+    t.ok(!fsw.isRunning(), 'watcher not running');
+
+    t.throws(function stopThrow() {
+        fsw.stop(function noop() {});
+    }, null, 'stop stopped');
+
+    t.end();
+});
+
+test('try watching files with illegal characters',
+    function illegalFilenameTest(t) {
+
+    var fsw = new FsWatcher({log: log});
+
+
+    fsw.once('ready', function fswOnReady() {
+        vasync.forEachPipeline({
+            inputs: ['newline\nchar', 'nulbyte\0char'],
+            func: function watchInvalidFile(f, cb) {
+                fsw.watch(f, function (err) {
+                    t.ok(err, 'error is expected: '
+                        + JSON.stringify((err || {}).message));
+                    cb();
+                });
+            }
+        }, function doneWatchInvalidFile(err) {
+            fsw.stop(function fswStop() {
+                t.end();
+            });
+        });
+    });
+
+    fsw.start();
+});
+
+test('try watching an existent file and catching CHANGE and DELETE',
+    function changeAndDeleteTest(t) {
+        var filename = path.join(testdir, 'hello.txt');
+        var saw_change = false;
+        var saw_delete = false;
+
+        var fsw = new FsWatcher({log: log});
+
+        fs.writeFileSync(filename, 'hello world\n');
+        t.ok(fs.existsSync(filename), 'file was created');
+
+        fsw.on('delete', function fswOnDelete(evt) {
+            t.equal(evt.pathname, filename, 'delete was for correct filename');
+            t.ok(saw_change, 'at delete time, already saw change');
+            saw_delete = true;
+            cleanup();
+        });
+
+        fsw.on('change', function fswOnChange(evt) {
+            t.equal(evt.pathname, filename, 'change was for correct filename');
+            t.ok(!saw_delete, 'at change time, did not yet see delete');
+            if (!saw_change) {
+                // avoid doing twice if there are multiple changes
+                saw_change = true;
+                fs.unlinkSync(filename); // should trigger DELETE
+            }
+        });
+
+        fsw.once('ready', function fswOnReady(evt) {
+            fsw.watch(filename, watchcb);
+        });
+
+        fsw.start();
+
+        function watchcb(err) {
+            t.ok(!err, (err ? err.message : 'started watching ' + filename));
+            if (err) {
+                cleanup();
+                return;
+            }
+
+            // should trigger CHANGE
+            fs.writeFileSync(filename, 'goodbye world\n');
+        }
+
+        function cleanup() {
+            fsw.unwatch(filename, function fswUnwatch() {
+                fsw.stop(function fswStop() {
+                    t.ok(saw_change, 'saw change event at cleanup');
+                    t.ok(saw_delete, 'saw delete event at cleanup');
+                    t.end();
+                });
+            });
+        }
+    }
+);
+
+test('try watching a non-existent file then create it',
+    function createWatchedFileTest(t) {
+
+    var filename = path.join(testdir, '/file/that/shouldnt/exist.txt');
+    var dirname = path.dirname(filename);
+    var saw_create = false;
+
+    var fsw = new FsWatcher({log: log});
+
+    fsw.once('ready', function fswOnReady(evt) {
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                fsw.watch(filename, cb);
+            }, function (_, cb) {
+                // create directory
+                execFile('/usr/bin/mkdir', ['-p', dirname],
+                    function mkdir(err, stdout, stderr) {
+                        t.ok(!err, 'mkdir -p ' + dirname);
+                        cb(err);
+                    }
+                );
+            }, function (_, cb) {
+                t.ok(!saw_create, 'haven\'t seen "create" event yet');
+                // create file
+                fs.writeFile(filename, 'hello world\n',
+                    function writeFileDone(err) {
+
+                    t.ok(!err, 'wrote "hello world" to ' + filename);
+                    cb(err);
+                });
+            }
+        ]}, function (err) {
+            if (err) {
+                t.ok(!err, err.message);
+                cleanup();
+            }
+        });
+    });
+
+    fsw.on('create', function fswOnCreate(evt) {
+        t.equal(evt.pathname, filename, 'saw create event for ' + filename);
+        saw_create = true;
+        cleanup();
+    });
+
+    fsw.start();
+
+    function cleanup() {
+        fsw.unwatch(filename, function fswUnwatch() {
+            fsw.stop(function fswStop() {
+                t.ok(saw_create, 'saw create event at cleanup');
+                t.end();
+            });
+        });
+    }
+});
+
+test('try watching an existent file, unwatching and ensure no events',
+    function strayEventsTest(t) {
+
+    var events_after_stop = 0;
+    var filename = path.join(testdir, 'tricky.txt');
+    var saw_change = false;
+    var stopped_watching = false;
+
+    var fsw = new FsWatcher({log: log});
+
+    fs.writeFileSync(filename, 'look at me, I\'m so tricky!\n');
+    t.ok(fs.existsSync(filename), 'file was created');
+
+    fsw.on('event', function fswOnEvent(evt) {
+        if (stopped_watching) {
+            events_after_stop++;
+        }
+    });
+
+    fsw.on('change', function fswOnChange(evt) {
+        t.equal(evt.pathname, filename, 'change was for correct filename');
+        t.ok(!stopped_watching, 'when change event happened, we have not '
+            + 'stopped watching');
+
+        // avoid doing twice if there are multiple changes
+        if (saw_change)
+            return;
+
+        saw_change = true;
+
+        if (stopped_watching)
+            return;
+
+        fsw.unwatch(filename, function fswUnwatch() {
+            stopped_watching = true;
+
+            // would trigger DELETE, but we shouldn't get it.
+            fs.unlinkSync(filename);
+
+            // leave some time for rogue events to show up
+            setTimeout(function waitForMorePossibleEvents() {
+                fsw.stop(function fswStop() {
+                    t.equal(events_after_stop, 0, 'should not see events '
+                        + 'after stopping');
+                    t.end();
+                });
+            }, 2000);
+        });
+    });
+
+    fsw.once('ready', function fswOnReady(evt) {
+        fsw.watch(filename, function fswWatch(err) {
+            fs.writeFileSync(filename, 'now we are writing junk!\n');
+            // now change event should have been triggered and we should
+            //  have stopped watcher. Control should pass to
+            // fsw.on('change'... above.
+            return;
+        });
+    });
+
+    fsw.start();
+});
+
+test('create a file and ensure we get multiple modify events',
+    function multipleModifyEventsTest(t) {
+
+    var filename = path.join(testdir, 'changeme.txt');
+
+    var fsw = new FsWatcher({log: log});
+
+    fs.writeFileSync(filename, 'initial data\n');
+    t.ok(fs.existsSync(filename), 'file was created');
+
+    fsw.on('event', function fswOnEvent(evt) {
+        t.ok(evt.changes.indexOf('FILE_MODIFIED') > -1,
+            'type of "event" event is "change"');
+    });
+
+    fsw.on('change', function fswOnChange(evt) {
+        t.equal(evt.pathname, filename, 'change was for correct filename');
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.once('ready', function fswOnReady(evt) {
+        fsw.watch(filename, function fswWatch(err) {
+            fs.writeFileSync(filename, 'first modification!\n');
+            return;
+        });
+    });
+
+    fsw.start();
+});
+
+test('watch 10000 non-existent files, create them, modify them and delete them',
+    function createManyFilesTest(t) {
+
+    var then = new Date();
+
+    var count = 10000;
+    var fsw = new FsWatcher({log: log});
+    var files = [];
+
+    // events seen per file
+    var events = {};
+
+    // events seen
+    var seen = {
+        create: 0,
+        change: 0,
+        delete: 0
+    };
+
+    // array of filenames to watch and manage
+    for (var i = 0; i < count; i++) {
+        var filename = path.join(testdir, 'testfile.' + i);
+        files.push(filename);
+        events[filename] = [];
+    }
+
+    // Because we are managing a large number of files, a vasync queue is used
+    // to manage all file creations, modifications, and deletions.
+    var q = vasync.queue(function vasyncQueue(task, cb) {
+        task(cb);
+    }, 100);
+
+    // deadman switch - we stop this if it takes too long
+    var timeout = setTimeout(function killSwitch() {
+        var e = new Error('timeout exceeded');
+        cleanup(e);
+    }, 60 * 1000);
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // start the FsWatcher
+            fsw.once('ready', function fswOnReady(evt) {
+                cb();
+            });
+            fsw.start();
+        }, function (_, cb) {
+            // start watching for events
+            var done = 0;
+
+            fsw.on('create', function fswOnCreate(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.create++;
+                events[evt.pathname].push('create-seen');
+
+                // modify the file - triggers 'change' event
+                q.push(function modifyFileToTriggerChange(cb2) {
+                    events[evt.pathname].push('change');
+                    fs.truncate(evt.pathname, 0, cb2);
+                });
+            });
+
+            fsw.on('change', function fswOnChange(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                if (events[evt.pathname].indexOf('change-seen') > -1) {
+                    log.error({evt: evt},
+                        'change event already seen for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.change++;
+                events[evt.pathname].push('change-seen');
+
+                // delete the file - triggers 'delete' event
+                q.push(function deleteFileToTriggerDelete(cb2) {
+                    events[evt.pathname].push('delete');
+                    fs.unlink(evt.pathname, cb2);
+                });
+            });
+
+            fsw.on('delete', function fswOnDelete(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.delete++;
+                events[evt.pathname].push('delete-seen');
+
+                fsw.unwatch(evt.pathname, function fswUnwatch() {
+                    delete events[evt.pathname];
+                    // check if we're done
+                    if (++done === count) {
+                        clearTimeout(timeout);
+                        cleanup();
+                    }
+                });
+            });
+
+            cb();
+        }, function (_, cb) {
+            // add watches for all non-existent files
+            vasync.forEachParallel({
+                func: function watchNonexistentFile(f, cb2) {
+                    events[f].push('watch');
+                    fsw.watch(f, cb2);
+                },
+                inputs: files
+            }, function (err) {
+                t.ok(!err, (err ? err.message : 'no errors'));
+                cb();
+            });
+        }, function (_, cb) {
+            // all files are being watched, create them
+            vasync.forEachParallel({
+                func: function createNewFile(f, cb2) {
+                    q.push(function createNewFileTask(cb3) {
+                        var data = 'foo ' + f;
+                        fs.writeFile(f, data, function writeFileDone(err) {
+                            events[f].push('create');
+                            cb3(err); // tell queue we're done
+                            cb2(err); // tell forEachParallel we're done
+                        });
+                    });
+                },
+                inputs: files
+            }, function (err) {
+                t.ok(!err, (err ? err.message : 'no errors'));
+                cb();
+            });
+        }
+    ]}, function (err) {
+        // control is passed onto fsw events now
+    });
+
+    function cleanup(err) {
+        var now = new Date();
+        var delta = now - then;
+        t.ok(!err, (err ? err.message : 'no errors'));
+        t.ok(true, 'took ' + delta + 'ms to complete');
+
+        Object.keys(seen).forEach(function eventSeen(ev) {
+            t.equal(seen[ev], count,
+                util.format('have seen %d / %d %s events',
+                seen[ev], count, ev));
+        });
+
+        var keys = Object.keys(events);
+        t.equal(keys.length, 0, '0 files left');
+        if (keys.length > 0) {
+            console.error(events);
+        }
+
+        fsw.status(function fswStatus(_, obj) {
+            if (err) {
+                log.error({obj: obj}, 'fswatcher status before exit');
+            }
+            fsw.stop(function fswStop() {
+                t.end();
+            });
+        });
+    }
+});
+
+test('cleanup', function testCleanup(t) {
+    t.ok(true, 'cleaning up');
+    execFile('/usr/bin/rm', ['-rf', testdir],
+        function removeTmpDir(err, stdout, stderr) {
+            t.ok(!err, (err ? err.message : 'cleaned up'));
+            t.end();
+        }
+    );
+});
diff --git a/src/vm/tests/test-internal_metadata_namespaces.js b/src/vm/tests/test-internal_metadata_namespaces.js
index cacb8cb0..88273be2 100644
--- a/src/vm/tests/test-internal_metadata_namespaces.js
+++ b/src/vm/tests/test-internal_metadata_namespaces.js
@@ -1,20 +1,48 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that the internal_metadata_namespaces feature:
-//
-//  * shows up in KEYS when internal_metadata has namespaced key
-//  * does not allow PUT to namespaced key from in the zone
-//  * does not allow DELETE to namespaced key from in the zone
-//  * shows GET result from internal_metadata for namespaced keys
-//  * does not interfere with PUT or DELETE on non-namespaced keys
-//  * does not show non-namespaced internal_metadata keys
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * These tests ensure that the internal_metadata_namespaces feature:
+ *
+ *  * shows up in KEYS when internal_metadata has namespaced key
+ *  * does not allow PUT to namespaced key from in the zone
+ *  * does not allow DELETE to namespaced key from in the zone
+ *  * shows GET result from internal_metadata for namespaced keys
+ *  * does not interfere with PUT or DELETE on non-namespaced keys
+ *  * does not show non-namespaced internal_metadata keys
+ */
 
 var async = require('/usr/node/node_modules/async');
 var exec = require('child_process').exec;
 var fs = require('fs');
+var util = require('util');
 var utils = require('/usr/vm/node_modules/utils');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -109,17 +137,53 @@ test('test exercising internal_metadata_namespaces', function (t) {
 
     vmtest.on_new_vm(t, image_uuid, payload, state, [
         function (cb) {
-            // replace metadata.json with version that tells us which we got
-            fs.writeFile('/zones/' + state.uuid + '/config/metadata.json',
-                JSON.stringify(metadata, null, 2) + '\n',
-                function (err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    cb();
-                }
-            );
+            var vs = new vminfod.VminfodEventStream({
+                name: 'test-internal_metadata_namespaces.js'
+            });
+            vs.on('ready', function () {
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            type: 'modify',
+                            zonename: state.uuid,
+                            vm: metadata
+                        };
+
+                        var opts = {
+                            timeout: 30 * 1000,
+                            catchErrors: true,
+                            teardown: true
+                        };
+
+                        vs.watchForEvent(obj, opts,
+                            function (err) {
+                            if (err) {
+                                cb2(err);
+                                return;
+                            }
+
+                            cb2();
+                        });
+                    },
+                    function (cb2) {
+                        // replace metadata.json with version that tells us
+                        // which we got
+                        fs.writeFile('/zones/' + state.uuid
+                            + '/config/metadata.json',
+                            JSON.stringify(metadata, null, 2) + '\n',
+                            function (err) {
+                                if (err) {
+                                    cb2(err);
+                                    return;
+                                }
+                                cb2();
+                            }
+                        );
+                    }]
+                }, function (err) {
+                    cb(err);
+                });
+            });
         }, function (cb) {
             // Sanity check VM metadata
             VM.load(state.uuid, function (err, obj) {
diff --git a/src/vm/tests/test-lastexited.js b/src/vm/tests/test-lastexited.js
index 43bd35de..f35ba405 100644
--- a/src/vm/tests/test-lastexited.js
+++ b/src/vm/tests/test-lastexited.js
@@ -1,15 +1,38 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that exit_status and exit_timestamp fields work as
-// expected when starting/stopping/zone exits
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * These tests ensure that exit_status and exit_timestamp fields work as
+ * expected when starting/stopping/zone exits
+ */
 
-var async = require('/usr/node/node_modules/async');
 var child_process = require('child_process');
-var exec = child_process.exec;
 var execFile = child_process.execFile;
 var fs = require('fs');
-var libuuid = require('/usr/node/node_modules/uuid');
+var path = require('path');
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
 
@@ -29,6 +52,7 @@ var common_payload = {
     max_swap: 1024
 };
 var image_uuid = vmtest.CURRENT_SMARTOS_UUID;
+var old_timestamp;
 
 function getExitFields(t, state, callback) {
     VM.load(state.uuid, function (err, obj) {
@@ -52,31 +76,35 @@ function waitInstalled(t, uuid, callback)
 {
     function _checkExists() {
         VM.load(uuid, function (err, obj) {
-            if (!fs.existsSync('/zones/' + uuid + '/lastexited')
-                || !obj || (obj.zone_state !== 'installed')) {
+            if (obj
+                && obj.zone_state === 'installed'
+                && old_timestamp !== obj.exit_timestamp) {
 
-                setTimeout(_checkExists, 100);
-            } else {
+                old_timestamp = obj.exit_timestamp;
                 t.ok(true, 'have lastexited');
                 callback();
+                return;
             }
+
+            setTimeout(_checkExists, 100);
         });
     }
     _checkExists();
 }
 
 function writeInit(uuid, contents, callback) {
-    var filename = '/zones/' + uuid + '/root/root/init';
+    var filename = path.join('/zones', uuid, 'root/root/init');
+    var opts = {
+        encoding: 'utf8',
+        mode: parseInt('0755', 8)
+    };
 
-    fs.writeFile(filename, contents, function (err) {
+    fs.writeFile(filename, contents, opts, function (err) {
         if (err) {
             callback(err);
             return;
         }
 
-        /*jsl:ignore*/
-        fs.chmodSync(filename, 0755);
-        /*jsl:end*/
         callback();
     });
 }
@@ -144,7 +172,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, 0, 'exit status 0');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
@@ -175,7 +203,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, 13, 'exit status 13');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
@@ -206,7 +234,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, -9, 'exit status -9');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
diff --git a/src/vm/tests/test-queue.js b/src/vm/tests/test-queue.js
new file mode 100644
index 00000000..1302f172
--- /dev/null
+++ b/src/vm/tests/test-queue.js
@@ -0,0 +1,265 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var Queue = require('/usr/vm/node_modules/queue').Queue;
+var bunyan = require('/usr/vm/node_modules/bunyan');
+var vasync = require('/usr/vm/node_modules/vasync');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('/usr/vm/node_modules/nodeunit-plus');
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: 'queue-test-dummy',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+test('test queue unpaused 100 tasks', function (t) {
+    var tasks = 100;
+
+    var q = new Queue({
+        log: log,
+        workers: 10
+    });
+
+    var i = 0;
+    for (var j = 0; j < tasks; j++) {
+        q.enqueue({
+            description: 'task ' + j,
+            func: function (extras, cb) {
+                if (++i === tasks) {
+                    t.ok(true, 'tasks completed');
+                    t.end();
+                }
+                cb();
+            }
+        });
+    }
+});
+
+test('test queue paused 100 tasks', function (t) {
+    var tasks = 100;
+    var queue_running = false;
+
+    var q = new Queue({
+        log: log,
+        paused: true,
+        workers: 10
+    });
+
+    var i = 0;
+    for (var j = 0; j < tasks; j++) {
+        q.enqueue({
+            description: 'task ' + j,
+            func: function (extras, cb) {
+                if (!queue_running) {
+                    t.ok(false, 'queue started too early');
+                    t.end();
+                    return;
+                }
+
+                if (++i === tasks) {
+                    t.ok(true, 'tasks completed');
+                    t.end();
+                }
+
+                cb();
+            }
+        });
+    }
+
+    setTimeout(function () {
+        // all tasks should still be enqueued as the queue is currently paused
+        t.equal(q.paused, true, 'queue is paused');
+        t.equal(q.paused_queue.length, tasks, 'tasks currently paused: '
+            + tasks);
+
+        queue_running = true;
+        q.resume();
+    }, 10);
+});
+
+test('test queue throws to prevent unintended states', function (t) {
+    var q = new Queue({
+        log: log,
+        workers: 1
+    });
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // ensure the queue is running
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // pause the queue and ensure it is stopped, pause is async
+            q.pause(function (err) {
+                testIsPaused();
+                cb(err);
+            });
+        }, function (_, cb) {
+            // resume the queue and ensure it is running, resume is sync
+            q.resume();
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // try to resume the queue again, should throw an error
+            t.throws(function () {
+                q.resume();
+            }, null, 'queue is already running');
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // pause the queue again and ensure it is stopped
+            q.pause(function (err) {
+                testIsPaused();
+                cb(err);
+            });
+        }, function (_, cb) {
+            // try to pause the queue again
+            t.throws(function () {
+                q.pause(function () {});
+            }, null, 'queue is already paused');
+            cb();
+        }
+    ]}, function (err) {
+        t.ok(!err, 'error: ' + (err ? err.message : 'none'));
+        t.end();
+    });
+
+    function testIsRunning() {
+        t.equal(q.paused, false, 'queue is running');
+    }
+    function testIsPaused() {
+        t.equal(q.paused, true, 'queue is paused');
+    }
+});
+
+test('test queue fast-forward', function (t) {
+    var ret;
+
+    var q = new Queue({
+        log: log,
+        workers: 5,
+        paused: true
+    });
+
+    var done = {
+        foo: false,
+        bar: false,
+        bat: false
+    };
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            done.foo = true;
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task foo enqueued');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            done.bar = true;
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task bar enqueued');
+
+    var time = process.hrtime();
+
+    // enqueue the 'bat' task after we grab the timestamp
+    setTimeout(function () {
+        ret = q.enqueue({
+            description: 'bat',
+            func: function (extras, cb) {
+                done.bat = true;
+                cb();
+            }
+        });
+        t.equal(ret, true, 'task bat enqueued');
+
+        // fast forward queue: this should process foo and bar, but not bat
+        q.fastForward(time, function (err) {
+            t.ok(!err, 'error: ' + (err ? err.message : 'none'));
+            t.equal(done.foo, true, 'task foo is done');
+            t.equal(done.bar, true, 'task bar is done');
+            t.equal(done.bat, false, 'task bat is not done');
+            t.end();
+        });
+    }, 5);
+});
+
+test('test deduplication', function (t) {
+    var ret;
+
+    var q = new Queue({
+        log: log,
+        workers: 5,
+        dedup: true,
+        paused: true
+    });
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task foo enqueued');
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, false, 'task foo is discarded');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task bar enqueued');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, false, 'task bar is discarded');
+
+    t.end();
+});
diff --git a/src/vm/tests/test-send-recv.js b/src/vm/tests/test-send-recv.js
index 6749fc62..5c71dbd8 100644
--- a/src/vm/tests/test-send-recv.js
+++ b/src/vm/tests/test-send-recv.js
@@ -1,8 +1,33 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
 
-var async = require('/usr/node/node_modules/async');
 var cp = require('child_process');
-var execFile = cp.execFile;
+var fs = require('fs');
+var util = require('util');
+
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
 
@@ -12,11 +37,9 @@ require('nodeunit-plus');
 
 VM.loglevel = 'DEBUG';
 
-var abort = false;
-var bundle_filename;
 var image_uuid = vmtest.CURRENT_SMARTOS_UUID;
 var kvm_image_uuid = vmtest.CURRENT_UBUNTU_UUID;
-var vmobj;
+var VMADM = '/usr/vm/sbin/vmadm';
 
 var kvm_payload = {
     alias: 'test-send-recv-' + process.pid,
@@ -45,190 +68,251 @@ var smartos_payload = {
 };
 
 [['zone', smartos_payload], ['kvm', kvm_payload]].forEach(function (d) {
+    var abort = false;
+    var bundle_filename;
+    var vmobj;
+
     var thing_name = d[0];
     var thing_payload = d[1];
 
-    test('create ' + thing_name, function(t) {
+    test('create ' + thing_name, function (t) {
         VM.create(thing_payload, function (err, obj) {
             if (err) {
+                abort = true;
                 t.ok(false, 'error creating VM: ' + err.message);
                 t.end();
-            } else {
-                VM.load(obj.uuid, function (e, o) {
-                    // we wait 5 seconds here as there's a bug in the zone startup
-                    // where shutdown doesn't work while part of smf is still
-                    // starting itself. This should be fixed with OS-1027 when
-                    // that's in as we could then just wait for the zone to go from
-                    // 'provisioning' -> 'running' before continuing.
-                    setTimeout(function() {
-                        if (e) {
-                            t.ok(false, 'unable to load VM after create');
-                            abort = true;
-                            t.end()
-                            return;
-                        }
-                        vmobj = o;
-                        t.ok(true, 'created VM: ' + vmobj.uuid);
-                        t.end();
-                    }, 5000);
-                });
+                return;
             }
+
+            VM.load(obj.uuid, function (e, o) {
+                if (e) {
+                    t.ok(false, 'unable to load VM after create');
+                    abort = true;
+                    t.end();
+                    return;
+                }
+
+                vmobj = o;
+                t.ok(true, 'created VM: ' + vmobj.uuid);
+                t.end();
+            });
         });
     });
 
-    test('send ' + thing_name, function(t) {
+    test('send ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        bundle_filename = '/var/tmp/test.' + vmobj.uuid + '.vmbundle.' + process.pid;
 
-        cp.exec('/usr/vm/sbin/vmadm send ' + vmobj.uuid + ' > ' + bundle_filename,
-            function (error, stdout, stderr) {
-                if (error) {
-                    t.ok(false, 'vm send to ' + bundle_filename + ': ' + error.message);
+        bundle_filename = util.format('/var/tmp/test.%s.vmbundle.%d',
+            vmobj.uuid, process.pid);
+
+        var stderr = '';
+        var ws = fs.createWriteStream(bundle_filename);
+        var args = [
+            'send',
+            vmobj.uuid
+        ];
+
+        var child = cp.spawn(VMADM, args);
+        child.stdout.pipe(ws);
+        child.stderr.setEncoding('utf8');
+        child.stderr.on('data', function (data) {
+            stderr += data;
+        });
+
+        child.once('error', function (err) {
+            t.ok(false, util.format('vm send to "%s": %s',
+                bundle_filename, err.message));
+            abort = true;
+            t.end();
+        });
+
+        child.once('close', function (code) {
+            if (code !== 0) {
+                t.ok(false, util.format('vm send to "%s": code %d',
+                    bundle_filename, code));
+                abort = true;
+                console.error(stderr);
+                t.end();
+            }
+
+            VM.load(vmobj.uuid, function (e, o) {
+                if (e) {
+                    t.ok(false, 'reloading after send: ' + e.message);
                     abort = true;
                     t.end();
-                } else {
-                    VM.load(vmobj.uuid, function (e, o) {
-                        if (e) {
-                            t.ok(false, 'reloading after send: ' + e.message);
-                            abort = true;
-                        } else {
-                            t.ok(o.state === 'stopped', 'VM is stopped after send (actual: ' + o.state + ')');
-                        }
-                        t.end();
-                    });
+                    return;
                 }
-            }
-        );
+                t.ok(o.state === 'stopped', util.format(
+                    'VM is stopped after send (actual: %s)', o.state));
+                t.end();
+            });
+        });
     });
 
-    test('delete after sending ' + thing_name, function(t) {
+    test('delete after sending ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        if (vmobj.uuid) {
-            VM.delete(vmobj.uuid, function (err) {
-                if (err) {
-                    t.ok(false, 'error deleting VM: ' + err.message);
-                    abort = true;
-                } else {
-                    t.ok(true, 'deleted VM: ' + vmobj.uuid);
-                }
-                t.end();
-            });
-        } else {
+
+        if (!vmobj.uuid) {
             t.ok(false, 'no VM to delete');
             abort = true;
             t.end();
+            return;
         }
+
+        VM.delete(vmobj.uuid, function (err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + err.message);
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            t.end();
+        });
     });
 
-    test('receive ' + thing_name, function(t) {
+    test('receive ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
 
-        cp.exec('/usr/vm/sbin/vmadm recv < ' + bundle_filename,
-            function (error, stdout, stderr) {
-                var ival;
-                var loading = false;
-                var loops = 0;
+        var rs = fs.createReadStream(bundle_filename);
+        var stderr = '';
+
+        var child = cp.spawn(VMADM, ['recv']);
+        rs.pipe(child.stdin);
+        child.stderr.setEncoding('utf8');
+        child.stderr.on('data', function (data) {
+            stderr += data;
+        });
+
+        child.once('error', function (err) {
+            t.ok(false, util.format('vm send to "%s": %s',
+                bundle_filename, err.message));
+            abort = true;
+            t.end();
+        });
+
+        child.once('close', function (code) {
+            // we don't really care if this works, this is just cleanup.
+            try {
+                fs.unlinkSync(bundle_filename);
+            } catch (e) {}
+
+            if (code !== 0) {
+                t.ok(false, util.format('vm send to "%s": code %d',
+                    bundle_filename, code));
+                console.error(stderr);
+                abort = true;
+                t.end();
+            }
 
-                // we don't really care if this works, this is just cleanup.
-                cp.exec('rm -f ' + bundle_filename, function() {});
+            var started = Math.floor(Date.now() / 1000);
+            function waitForZoneToSettle() {
+                var now = Math.floor(Date.now() / 1000);
 
-                if (error) {
-                    t.ok(false, 'vm recv from ' + bundle_filename + ': ' + error.message);
+                if (now - started > 120) {
+                    t.ok(false, 'Timeout waiting for zone to settle');
                     abort = true;
                     t.end();
-                } else {
-                    obj = {};
-
-                    ival = setInterval(function () {
-                        if (loading === false) {
-                            loading = true;
-                        } else {
-                            // already loading, skip;
-                            loops = loops + 5;
+                    return;
+                }
+
+                VM.load(vmobj.uuid, function (err, obj) {
+                    if (err) {
+                        // give up
+                        t.ok(false, 'reloading after receive: ' + err.message);
+                        abort = true;
+                        t.end();
+                        return;
+                    }
+
+                    if (obj.hasOwnProperty('transition')
+                        || ['running', 'stopped'].indexOf(obj.state) === -1) {
+
+                        // wait for zone to settle
+                        t.ok(true, util.format(
+                            'Zone in state: %s - waiting to settle',
+                            obj.state));
+                        setTimeout(waitForZoneToSettle, 5 * 1000);
+                        return;
+                    }
+
+                    // zone settled!
+                    t.ok(true, 'Zone went to state: ' + obj.state);
+
+                    Object.keys(vmobj).forEach(function (prop) {
+                        // we expect these properties to be different.
+                        var skipProps = [
+                            'boot_timestamp',
+                            'last_modified',
+                            'pid',
+                            'zoneid'
+                        ];
+                        if (skipProps.indexOf(prop) !== -1) {
                             return;
                         }
-                        if (loops > 120) {
-                            clearInterval(ival);
-                            t.ok(false, "Timed out after 2 mins waiting for zone to settle.");
-                            abort = true;
+
+                        t.ok(obj.hasOwnProperty(prop),
+                            'new object still has property ' + prop);
+
+                        if (obj.hasOwnProperty(prop)) {
+                            var old_vm = JSON.stringify(vmobj[prop]);
+                            var new_vm = JSON.stringify(obj[prop]);
+                            t.ok(new_vm === old_vm, util.format(
+                                'matching properties "%s": [%s][%s]',
+                                prop, old_vm, new_vm));
                         }
-                        VM.load(vmobj.uuid, function (err, obj) {
-                            if (err) {
-                                clearInterval(ival);
-                                t.ok(false, 'reloading after receive: ' + err.message);
-                                abort = true;
-                                t.end();
-                                // leave loading since we don't want any more runs.
-                                return;
-                            } else {
-                                if (!obj.hasOwnProperty('transition') && (obj.state === 'running' || obj.state === 'stopped')) {
-                                    // DONE!
-                                    clearInterval(ival);
-                                    t.ok(true, 'Zone went to state: ' + obj.state);
-
-                                    for (prop in vmobj) {
-                                        if (['boot_timestamp', 'last_modified', 'pid', 'zoneid'].indexOf(prop) !== -1) {
-                                            // we expect these properties to be different.
-                                            continue;
-                                        }
-                                        t.ok(obj.hasOwnProperty(prop), 'new object still has property ' + prop);
-                                        if (obj.hasOwnProperty(prop)) {
-                                            old_vm = JSON.stringify(vmobj[prop]);
-                                            new_vm = JSON.stringify(obj[prop]);
-                                            t.ok(new_vm == old_vm, 'matching properties ' + prop + ': [' + old_vm + '][' + new_vm + ']');
-                                        }
-                                    }
-                                    for (prop in obj) {
-                                        if (!vmobj.hasOwnProperty(prop)) {
-                                            t.ok(false, 'new object has extra property ' + JSON.stringify(prop));
-                                        }
-                                    }
-
-                                    t.end();
-                                    return;
-                                } else {
-                                    t.ok(true, 'Zone in state: ' + obj.state + ' waiting to settle.');
-                                }
-                                loading = false;
-                            }
-                        });
-                        loops = loops + 5;
-                    }, 5000);
-                }
+                    });
+
+                    Object.keys(obj).forEach(function (prop) {
+                        if (!vmobj.hasOwnProperty(prop)) {
+                            t.ok(false, util.format(
+                                'new object has extra property %s', prop));
+                        }
+                    });
+
+                    t.end();
+                });
             }
-        );
+
+            waitForZoneToSettle();
+        });
     });
 
-    test('delete after receiving ' + thing_name, function(t) {
+    test('delete after receiving ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        if (vmobj.uuid) {
-            VM.delete(vmobj.uuid, function (err) {
-                if (err) {
-                    t.ok(false, 'error deleting VM: ' + err.message);
-                } else {
-                    t.ok(true, 'deleted VM: ' + vmobj.uuid);
-                }
-                t.end();
-            });
-        } else {
+
+        if (!vmobj.uuid) {
             t.ok(false, 'no VM to delete');
             t.end();
+            return;
         }
+
+        VM.delete(vmobj.uuid, function (err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + err.message);
+                t.end();
+                return;
+            }
+
+            t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            t.end();
+        });
     });
 });
diff --git a/src/vm/tests/test-update.js b/src/vm/tests/test-update.js
index 4b6441a5..79886dbe 100644
--- a/src/vm/tests/test-update.js
+++ b/src/vm/tests/test-update.js
@@ -1,8 +1,34 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// NOTE: we use 169.254.169.x as *non-Private* here because it's not in the
-// designated private ranges we're concerned with. It may cause problems in
-// which case it can be changed to some other non-Private address.
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * NOTE: we use 169.254.169.x as *non-Private* here because it's not in the
+ * designated private ranges we're concerned with. It may cause problems in
+ * which case it can be changed to some other non-Private address.
+ */
 
 var async = require('/usr/node/node_modules/async');
 var execFile = require('child_process').execFile;
@@ -1062,67 +1088,77 @@ test('update max_locked_memory', function (t) {
     });
 });
 
-function zonecfg(args, callback)
-{
-    var cmd = '/usr/sbin/zonecfg';
-
-    execFile(cmd, args, function (error, stdout, stderr) {
-        if (error) {
-            callback(error, {stdout: stdout, stderr: stderr});
-        } else {
-            callback(null, {stdout: stdout, stderr: stderr});
+test('update resolvers when empty', function (t) {
+    var payload = {
+        resolvers: ['4.2.2.1', '4.2.2.2']
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
         }
-    });
-}
-
-test('update resolvers when no resolvers', function (t) {
 
-    zonecfg([
-        '-z', vm_uuid,
-        'remove attr name=resolvers;'
-    ], function (err, fds) {
-        VM.update(vm_uuid, {resolvers: ['4.2.2.1', '4.2.2.2']},
-            function (up_err) {
-                t.ok(!up_err, 'no error adding resolvers: '
-                    + (up_err ? up_err.message : 'ok'));
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
                 t.end();
+                return;
             }
-        );
+
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
+        });
     });
 });
 
-test('update resolvers to empty when already empty', function (t) {
-    zonecfg(['-z', vm_uuid, 'remove attr name=resolvers;'],
-        function (err, fds) {
+test('update resolvers to empty when filled', function (t) {
+    var payload = {
+        resolvers: []
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
+        }
 
-        VM.load(vm_uuid, function (l_err, before_obj) {
-            if (l_err) {
-                t.ok(false, 'loading VM: ' + l_err.message);
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
                 t.end();
                 return;
             }
 
-            t.deepEqual(before_obj.resolvers, [], 'initial state has no '
-                + 'resolvers: ' + JSON.stringify(before_obj.resolvers));
-            VM.update(vm_uuid, {'resolvers': []}, function (up_err) {
-                if (up_err) {
-                    t.ok(false, 'updating resolvers: ' + up_err.message);
-                    t.end();
-                    return;
-                }
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
+        });
+    });
+});
 
-                VM.load(vm_uuid, function (error, after_obj) {
-                    if (error) {
-                        t.ok(false, 'loading VM (after): ' + error.message);
-                        t.end();
-                        return;
-                    }
+test('update resolvers to empty when empty', function (t) {
+    var payload = {
+        resolvers: []
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
+        }
 
-                    t.deepEqual(after_obj.resolvers, [], 'no resolvers after '
-                        + 'update: ' + JSON.stringify(after_obj.resolvers));
-                    t.end();
-                });
-            });
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
+                t.end();
+                return;
+            }
+
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
         });
     });
 });
diff --git a/src/vm/tests/test-vminfod.js b/src/vm/tests/test-vminfod.js
new file mode 100644
index 00000000..0734b68d
--- /dev/null
+++ b/src/vm/tests/test-vminfod.js
@@ -0,0 +1,42 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+test('create VminfodClient object and test /status', function (t) {
+    var vc = new vminfod.VminfodClient();
+    t.ok(vc, 'VminfodClient created');
+
+    vc.status(function (err, stats) {
+        t.ifError(err, 'vc.status no error');
+        t.ok(stats, 'vc.status object found');
+        t.end();
+    });
+});
diff --git a/src/vm/tests/test-zonewatcher.js b/src/vm/tests/test-zonewatcher.js
new file mode 100644
index 00000000..66d00195
--- /dev/null
+++ b/src/vm/tests/test-zonewatcher.js
@@ -0,0 +1,183 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var assert = require('assert');
+var async = require('/usr/node/node_modules/async');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var fs = require('fs');
+var path = require('path');
+var spawn = require('child_process').spawn;
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+var ZoneWatcher = require('vminfod/zonewatcher').ZoneWatcher;
+var log = bunyan.createLogger({
+        level: 'trace',
+        name: 'zonewatcher-test-dummy',
+        streams: [ { stream: process.stderr, level: 'error' } ],
+        serializers: bunyan.stdSerializers
+});
+var testdir = '/tmp/' + process.pid;
+var zonew;
+
+test('create a ZoneWatcher object', function (t) {
+    zonew = new ZoneWatcher({log: log});
+    t.ok(zonew, 'created ZoneWatcher');
+    zonew.once('ready', function () {
+        t.ok(true, 'ZoneWatcher ready');
+        t.end();
+    });
+});
+
+function vmadm(args, stdin, callback)
+{
+    var buffers = {stdout: '', stderr: ''};
+    var child;
+    var stderr = [];
+    var stdout = [];
+
+    child = spawn('/usr/vm/sbin/vmadm', args, {stdio: 'pipe'});
+    log.debug('vmadm running with pid ' + child.pid);
+
+    if (stdin) {
+        child.stdin.write(stdin);
+    }
+
+    child.stdin.end();
+
+    child.stdout.on('data', function (data) {
+        lineChunk(data, 'stdout', function (chunk) {
+            stdout.push(chunk);
+        });
+    });
+
+    child.stderr.on('data', function (data) {
+        lineChunk(data, 'stderr', function (chunk) {
+            stderr.push(chunk);
+        });
+    });
+
+    child.on('close', function (code, signal) {
+        var err = null;
+        var msg;
+
+        msg = 'vmadm ' + child.pid + ' exited. code: ' + code
+            + ' signal: ' + signal;
+
+        log.warn(msg);
+
+        if (code !== 0) {
+            err = new Error(msg);
+        }
+
+        callback(err, {stdout: stdout.join('\n'), stderr: stderr.join('\n')});
+    });
+
+    function lineChunk(data, buffer, handler) {
+        var chunk;
+        var chunks;
+
+        buffers[buffer] += data.toString();
+        chunks = buffers[buffer].split('\n');
+
+        while (chunks.length > 1) {
+            chunk = chunks.shift();
+            handler(chunk);
+        }
+        buffers[buffer] = chunks.pop(); // remainder
+    }
+}
+
+test('create zone (autoboot=true) and stop and destroy',
+    function (t) {
+        var payload;
+        var running = [];
+        var saw_running = false;
+        var vm_uuid = null;
+
+        payload = {
+            autoboot: true,
+            brand: 'joyent-minimal',
+            do_not_inventory: true,
+            image_uuid: '01b2c898-945f-11e1-a523-af1afbe22822'
+        };
+
+        function finish() {
+            zonew.stop();
+            t.end();
+        }
+
+        function onRunning() {
+            vmadm(['stop', vm_uuid, '-F'], null, function (err, stdio) {
+                t.ok(!err, (err ? err.message : 'stopped VM'));
+                log.debug({err: err, stdio: stdio}, 'vmadm stop');
+            });
+        }
+
+        zonew.on('event', function (evt) {
+            log.debug('saw change (looking for ' + vm_uuid + '): '
+                + JSON.stringify(evt));
+            if (evt.newstate === 'running') {
+                saw_running = true;
+                running.push(evt.zonename);
+                if (vm_uuid) {
+                    onRunning();
+                }
+            } else if (evt.newstate == 'uninitialized'
+                && vm_uuid && saw_running) {
+
+                vmadm(['delete', vm_uuid], null, function (err, stdio) {
+                    t.ok(!err, (err ? err.message : 'deleted VM'));
+                    log.debug({err: err, stdio: stdio}, 'vmadm delete');
+                    finish();
+                });
+            }
+        });
+
+        /* start the ball rolling by creating a VM */
+        vmadm(['create'], JSON.stringify(payload), function (err, stdio) {
+            var match;
+            t.ok(!err, (err ? err.message : 'created VM'));
+            log.debug({err: err, stdio: stdio}, 'vmadm create');
+
+            match = stdio.stderr /* JSSTYLED */
+                .match(/Successfully created VM ([0-9a-f\-]*)/);
+            if (match) {
+                vm_uuid = match[1];
+            } else {
+                t.ok(false, 'failed to get uuid from new VM');
+                finish();
+                return;
+            }
+
+            if (running.indexOf(vm_uuid) !== -1) {
+                onRunning();
+            }
+        });
+    }
+);
diff --git a/src/vm/tests/test-zpoolwatcher.js b/src/vm/tests/test-zpoolwatcher.js
new file mode 100644
index 00000000..4259a7e7
--- /dev/null
+++ b/src/vm/tests/test-zpoolwatcher.js
@@ -0,0 +1,144 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var bunyan = require('/usr/vm/node_modules/bunyan');
+
+var execFile = require('child_process').execFile;
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+var TIMEOUT = 10 * 1000;
+var DATASET = 'zones/zpoolwatcher-test-dummy-' + process.pid;
+
+function zfs(args, cb) {
+    var opts = {encoding: 'utf8'};
+    execFile('zfs', args, opts, function (err, stdout, stderr) {
+        if (err) {
+            cb(err);
+            return;
+        } else if (stderr) {
+            cb(new Error('stderr produced: ' + stderr));
+            return;
+        }
+        cb(null, stdout);
+    });
+}
+
+var ZpoolWatcher = require('vminfod/zpoolwatcher').ZpoolWatcher;
+var log = bunyan.createLogger({
+    level: 'warn',
+    name: 'zpoolwatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'warn' } ],
+    serializers: bunyan.stdSerializers
+});
+var zw;
+
+test('create a ZpoolWatcher object', function (t) {
+    zw = new ZpoolWatcher({log: log});
+    t.ok(zw, 'ZpoolWatcher');
+    zw.once('ready', function () {
+        t.ok(true, 'zw.once(ready)');
+        t.end();
+    });
+});
+
+test('creating a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'create'
+            && ev.pool === 'zones') {
+            clearTimeout(timeout);
+            zw.removeAllListeners('event');
+            t.end();
+        }
+    });
+
+    zfs(['create', DATASET], function (err, out) {
+        t.ifError(err, 'error creating dataset');
+    });
+});
+
+test('modifying a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    var found = 0;
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'set'
+            && ev.pool === 'zones') {
+
+            if (ev.extra.atime === '1')
+                found++;
+            if (ev.extra.sync === '1')
+                found++;
+
+            if (found >= 2) {
+                clearTimeout(timeout);
+                zw.removeAllListeners('event');
+                t.end();
+            }
+        }
+    });
+
+    zfs(['set', 'atime=on', 'sync=always', DATASET], function (err, out) {
+        t.ifError(err, 'error modifying dataset');
+    });
+});
+
+test('destroying a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'destroy'
+            && ev.pool === 'zones') {
+            clearTimeout(timeout);
+            zw.removeAllListeners('event');
+            t.end();
+        }
+    });
+
+    zfs(['destroy', DATASET], function (err, out) {
+        t.ifError(err, 'error destroying dataset');
+    });
+});
+
+
+test('cleanup', function (t) {
+    t.ok(true, 'cleaning up');
+    zw.stop();
+    t.end();
+});
diff --git a/src/vminfod.js b/src/vminfod.js
new file mode 100755
index 00000000..2bd4ac57
--- /dev/null
+++ b/src/vminfod.js
@@ -0,0 +1,315 @@
+#!/usr/node/bin/node
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var getopt = require('/usr/node/node_modules/getopt');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+
+var f = util.format;
+
+var name = 'Vminfod CLI';
+if (process.env.VMINFOD_NAME) {
+    name = f('%s (Vminfod CLI)', process.env.VMINFOD_NAME);
+}
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: name,
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+var client = new vminfod.VminfodClient({
+    name: name,
+    log: log
+});
+
+function usage() {
+    var _args = Array.prototype.slice.call(arguments);
+    var msg = f.apply(null, _args);
+    var out = [
+        'Usage: vminfod [command] [args]',
+        '',
+        'Commands',
+        '  ping               get vminfod ping     (GET /ping)',
+        '  status [-f]        get vminfod status   (GET /status)',
+        '  vms                get all vms          (GET /vms)',
+        '  vm <uuid>          get vm info          (GET /vms/:uuid)',
+        '  events [-jfr]      trace vminfod events (GET /events)'
+    ];
+    if (msg) {
+        out.unshift('');
+        out.unshift(msg);
+    }
+    console.log(out.join('\n'));
+}
+
+function do_ping(args) {
+    client.ping(function (err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+        assert.string(msg.ping, 'msg.ping');
+
+        console.log(msg.ping);
+    });
+}
+
+function do_status(args) {
+    var opts = [
+        'f(full)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, args);
+
+    opts = {};
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'f':
+            opts.query = opts.query || {};
+            opts.query.full = true;
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    client.status(opts, function (err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        console.log(JSON.stringify(msg, null, 2));
+    });
+}
+
+function do_vms(args) {
+    client.vms(function (err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        console.log(JSON.stringify(msg, null, 2));
+    });
+}
+
+function do_vm(args) {
+    var zonename = args[2];
+
+    if (!zonename) {
+        usage('vm zonename must be specified');
+        process.exit(1);
+    }
+
+    client.vm(zonename, function (err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        console.log(JSON.stringify(msg, null, 2));
+    });
+}
+
+function do_events(args) {
+    var opts = [
+        'f(full)',
+        'j(json)',
+        'r(ready)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, args);
+
+    var opt_f = false;
+    var opt_j = false;
+    var opt_r = false;
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'f':
+            opt_f = true;
+            break;
+        case 'j':
+            opt_j = true;
+            break;
+        case 'r':
+            opt_r = true;
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    var vs = new vminfod.VminfodEventStream({
+        name: name,
+        log: log
+    });
+
+    vs.once('ready', function (ev) {
+        if (!opt_r)
+            return;
+
+        var date = formatDate(ev.date);
+        if (opt_j) {
+            console.log(JSON.stringify(ev));
+        } else if (opt_f) {
+            console.log('[%s] %s (uuid %s)', date, ev.type, ev.uuid);
+        } else {
+            console.log('[%s] %s', date, ev.type);
+        }
+    });
+
+    vs.on('readable', function () {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            if (opt_j) {
+                console.log(JSON.stringify(ev));
+                return;
+            }
+
+            var zn = formatZonename(ev.zonename);
+            var date = formatDate(ev.date);
+
+            var alias = (ev.vm || {}).alias || '-';
+            if (alias.length > 30) {
+                alias = f('%s...', alias.substr(0, 27));
+            }
+
+            // format the output nicely
+            var base = f('[%s] %s %s %s',
+                date, zn, alias, ev.type);
+
+            delete ev.vm;
+            if (ev.changes) {
+                ev.changes.forEach(function (change) {
+                    console.log('%s: %s %s :: %j -> %j',
+                        base,
+                        change.prettyPath,
+                        change.action,
+                        change.from,
+                        change.to);
+                });
+            } else {
+                console.log(base);
+            }
+        }
+    });
+
+    function formatDate(date) {
+        if (opt_f) {
+            return date.toISOString();
+        } else {
+            return date.toISOString().split('T')[1];
+        }
+    }
+
+    function formatZonename(zonename) {
+        if (opt_f) {
+            return zonename;
+        } else {
+            return zonename.split('-')[0];
+        }
+    }
+}
+
+function main() {
+    var opts = [
+        'h(help)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, process.argv);
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'h':
+            usage();
+            process.exit(0);
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    var args = process.argv.slice(parser.optind());
+    var cmd = args.shift();
+
+    // put 2 empty elements in front of the existing "args"
+    // this can be removed if posix-getopt is updated
+    args = ['', ''].concat(args);
+
+    switch (cmd) {
+    case 'ping':
+        do_ping(args);
+        break;
+    case 'status':
+        do_status(args);
+        break;
+    case 'vms':
+        do_vms(args);
+        break;
+    case 'vm':
+        do_vm(args);
+        break;
+    case 'events':
+        do_events(args);
+        break;
+    case 'help':
+        usage();
+        process.exit(0);
+        break;
+    case undefined:
+        usage('Command must be specified as the first argument');
+        process.exit(1);
+        break;
+    default:
+        usage('Unknown command: %s', cmd);
+        process.exit(1);
+        break;
+    }
+}
+main();
diff --git a/src/zoneevent.c b/src/zoneevent.c
deleted file mode 100644
index a07742b5..00000000
--- a/src/zoneevent.c
+++ /dev/null
@@ -1,144 +0,0 @@
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <libsysevent.h>
-#include <sys/nvpair.h>
-
-void sysev_handler(sysevent_t *ev);
-sysevent_handle_t * sysev_register(const char *klass,
-    void (*handler)(sysevent_t *));
-evchan_t * sysev_register_evc(const char *channel, const char *klass,
-    int (*handler)(sysevent_t *, void *));
-
-static void
-exit_on_sigpipe(int signo) {
-    // no point outputing anything, parent is gone.
-    signo = signo; // quiet -Wall
-    exit(2);
-}
-
-static int
-sysev_evc_handler(sysevent_t *ev, void *cookie)
-{
-    nvlist_t *nvlist;
-    nvpair_t *next;
-    nvpair_t *curr;
-    data_type_t type;
-    char *string;
-    uint32_t uint32;
-    int32_t int32;
-    uint64_t uint64;
-    int64_t int64;
-
-    if (sysevent_get_attr_list(ev, &nvlist) != 0) {
-        // XXX Error
-        return (1);
-    }
-
-    curr = nvlist_next_nvpair(nvlist, NULL);
-
-    printf("{");
-    while (curr != NULL) {
-        type = nvpair_type(curr);
-
-        switch (type) {
-            case DATA_TYPE_STRING:
-                nvpair_value_string(curr, &string);
-                printf("\"%s\": \"%s\", ", nvpair_name(curr), string);
-                break;
-            case DATA_TYPE_UINT32:
-                nvpair_value_uint32(curr, &uint32);
-                printf("\"%s\": \"%u\", ", nvpair_name(curr), uint32);
-                break;
-            case DATA_TYPE_INT32:
-                nvpair_value_int32(curr, &int32);
-                printf("\"%s\": \"%d\", ", nvpair_name(curr), int32);
-                break;
-            case DATA_TYPE_UINT64:
-                nvpair_value_uint64(curr, &uint64);
-                printf("\"%s\": \"%llu\", ", nvpair_name(curr), uint64);
-                break;
-            case DATA_TYPE_INT64:
-                nvpair_value_int64(curr, &int64);
-                printf("\"%s\": \"%lld\", ", nvpair_name(curr), int64);
-                break;
-                break;
-            default:
-                (void) fprintf(stderr,
-                    "don't know what to do with '%s', type: %d\n",
-                    nvpair_name(curr), type);
-                break;
-        }
-        next = nvlist_next_nvpair(nvlist, curr);
-        curr = next;
-    }
-
-    printf("\"channel\": \"%s\", \"class\": \"%s\", \"subclass\": \"%s\"}\n",
-        (const char *) cookie,
-        sysevent_get_class_name(ev),
-        sysevent_get_subclass_name(ev));
-
-    fflush(stdout);
-
-    nvlist_free(nvlist);
-
-    return (0);
-}
-
-evchan_t *
-sysev_register_evc(const char *channel, const char *klass,
-    int (*handler)(sysevent_t *, void *))
-{
-    int res;
-    evchan_t *ch;
-    char subid[16];
-
-    if ((res = sysevent_evc_bind(channel, &ch, 0)) != 0) {
-        (void) fprintf(stderr, "failed to bind to sysevent channel: %d\n", res);
-        return (NULL);
-    }
-
-    (void) snprintf(subid, sizeof (subid), "node-%ld", getpid());
-
-    if ((res = sysevent_evc_subscribe(ch, subid, klass, handler,
-        (void *)channel, 0)) != 0) {
-
-        (void) fprintf(stderr, "failed to subscribe to channel: %d\n", res);
-        return (NULL);
-    }
-
-    return (ch);
-}
-
-int
-main(int argc, char **argv)
-{
-    evchan_t *ch;
-
-    // quiet -Wall
-    argc = argc;
-    argv = argv;
-
-    if (signal(SIGPIPE, exit_on_sigpipe) == SIG_ERR) {
-        fprintf(stderr, "failed to register SIGPIPE handler: %s\n",
-            strerror(errno));
-        exit(1);
-    }
-
-    ch = sysev_register_evc("com.sun:zones:status", "status",
-        sysev_evc_handler);
-    if (!ch) {
-        fprintf(stderr, "failed to register event handler.\n");
-        exit(1);
-    }
-
-    for (;;) {
-        (void) pause();
-    }
-
-    exit(0);
-}
diff --git a/src/zoneevent.js b/src/zoneevent.js
new file mode 100755
index 00000000..2ff9fd41
--- /dev/null
+++ b/src/zoneevent.js
@@ -0,0 +1,108 @@
+#!/usr/node/bin/node
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
+
+/*
+ * Substitute for 'zoneevent.c' that uses Vminfod or sysevents (as appropriate)
+ * as an event source
+ */
+
+var f = require('util').format;
+
+var bunyan = require('/usr/node/node_modules/bunyan');
+var ZoneEvent = require('/usr/vm/node_modules/zoneevent').ZoneEvent;
+var zone = require('/usr/node/node_modules/zonename');
+
+var name = 'zoneevent CLI';
+
+if (process.argv[2]) {
+    name += f(' (%s)', process.argv[2]);
+}
+
+var log = bunyan.createLogger({
+    level: 'fatal',
+    name: 'zoneevent',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+var zw = new ZoneEvent({
+    name: name,
+    log: log
+});
+
+zw.on('ready', function (err, obj) {
+    if (err)
+        throw err;
+
+    // It's unfortunate, but `zoneevent.c` never published a "ready" event, so
+    // we just silently ignore this if everything works as expected.
+});
+
+zw.on('event', function (ev) {
+    /*
+     * ZoneEvent returns an object that looks like this:
+     *
+     * {
+     *   "date": "2017-05-12T19:33:33.097Z",
+     *   "zonename": "fb622681-3d62-413b-dc8a-c7515367464f",
+     *   "newstate": "running",
+     *   "oldstate": "ready"
+     * }
+     *
+     * Which must be transformed to look like this:
+     *
+     * {
+     *   "zonename": "fb622681-3d62-413b-dc8a-c7515367464f",
+     *   "newstate": "running",
+     *   "oldstate": "ready",
+     *   "when": "1494617613097227838",
+     *   "channel": "com.sun:zones:status",
+     *   "class": "status",
+     *   "zoneid": "463",
+     *   "subclass": "change"
+     * }
+     *
+     * With channel, class and subclass omitted
+     */
+
+    var zoneid;
+    try {
+        zoneid = zone.getzoneidbyname(ev.zonename);
+    } catch (e) {
+        zoneid = -1;
+    }
+
+    var obj = {
+        zonename: ev.zonename,
+        oldstate: ev.oldstate,
+        newstate: ev.newstate,
+        zoneid: zoneid.toString(),
+        when: (ev.date.getTime().toString()) + '000000'
+    };
+
+    console.log(JSON.stringify(obj));
+});
-- 
2.21.0

