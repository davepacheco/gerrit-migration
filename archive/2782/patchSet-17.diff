commit 3cae56242acf432d489dbd8fe27fb3dd752436ea (refs/changes/82/2782/17)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2018-07-16T12:35:05-04:00 (1 year, 3 months ago)
    
    OS-2647 add vminfod to keep track of VM state and speed up lookups in vmadm

diff --git a/.gitignore b/.gitignore
index ad7f2cb3..24bf3ef3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,6 +14,7 @@
 /src/measure_terminal
 /src/bootparams
 /src/disk_size
+/src/fswatcher
 /src/removable_disk
 /src/disklist
 /src/qemu-exec
diff --git a/overlay/generic/etc/logadm.conf b/overlay/generic/etc/logadm.conf
index 6b11f89f..39eea575 100644
--- a/overlay/generic/etc/logadm.conf
+++ b/overlay/generic/etc/logadm.conf
@@ -19,7 +19,7 @@
 # CDDL HEADER END
 #
 # Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 #
 # logadm.conf
 #
@@ -45,6 +45,7 @@
 vm_logs /var/log/vm/vmadm.log -b '/usr/vm/sbin/rotate-logs.sh -m /var/log/vm/logs/ /var/log/vm/vmadm.log' -t '/var/log/vm/vmadm_$nodename_%FT%H:%M:%S.log' -C 168 -S 1g -p 1h
 fw_logs /var/log/fw/fwadm.log -b '/usr/vm/sbin/rotate-logs.sh -i /var/log/fw/logs/ /var/log/fw/fwadm.log' -t '/var/log/fw/fwadm_$nodename_%FT%H:%M:%S.log' -C 168 -S 1g -p 1h
 vmadmd_logs /var/svc/log/*vmadmd*.log -C 168 -S 1g -c -p 1h -t '/var/log/vm/vmadmd_$nodename_%FT%H:%M:%S.log'
+vminfod_logs /var/svc/log/*vminfod*.log -C 168 -S 1g -c -p 1h -t '/var/log/vm/vminfod_$nodename_%FT%H:%M:%S.log'
 /var/log/*.log -C 2 -s 5m -c
 /var/log/*.debug -C 2 -s 5m -c
 smf_logs /var/svc/log/*.log -C 8 -s 1m -c
diff --git a/src/Makefile b/src/Makefile
index eb0c4abf..e465286f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 include Makefile.defs
@@ -63,11 +63,11 @@ SMARTDCLIBDIR =	$(DESTDIR)/smartdc/lib
 #
 bootparams :	LIBS +=		-ldevinfo
 bootparams :	WARN_FLAGS +=	-Wno-unused
+fswatcher :	LIBS +=		-lthread -lnvpair -lavl
 zfs_recv :	LIBS +=		-lsocket
 zfs_send :	LIBS +=		-lsocket
 vmbundle :	CPPFLAGS +=	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
 sdc-on-tty :	CFLAGS +=	$(OPT_FLAG)
-zoneevent :	LIBS +=		-lnvpair -lsysevent
 sysevent :	LIBS +=		-lnvpair -lsysevent
 sysinfo_mod.so : CPPFLAGS +=	-D_REENTRANT
 sysinfo_mod.so : CFLAGS +=	-fpic -Wno-unused-parameter
@@ -81,8 +81,10 @@ JS_CHECK_TARGETS=\
 	node_modules/{system,onlyif,net-boot-config}.js \
 	net-boot-config \
 	vm/sbin/*.js \
+	vm/node_modules/diff.js \
 	vm/node_modules/dladm.js \
 	vm/node_modules/expander.js \
+	vm/node_modules/fswatcher.js \
 	vm/node_modules/hrtime.js \
 	vm/node_modules/ip.js \
 	vm/node_modules/nic.js \
@@ -90,31 +92,41 @@ JS_CHECK_TARGETS=\
 	vm/node_modules/utils.js \
 	vm/node_modules/VM.js \
 	vm/node_modules/qmp.js \
+	vm/node_modules/queue.js \
 	vm/node_modules/openonerrlogger.js \
 	vm/node_modules/vmload/*.js \
+	vm/node_modules/vminfod/*.js \
 	vm/node_modules/sysevent-stream.js \
 	vm/node_modules/zonecfg.js \
+	vm/node_modules/zoneevent.js \
 	img/lib/*.js \
 	img/sbin/imgadm \
 	vm/common/nictag.js \
+	vm/tests/common.js \
 	vm/tests/test-alias.js \
 	vm/tests/test-cleanup-on-failure.js \
-	vm/tests/test-create.js \
 	vm/tests/test-create-filesystems.js \
-	vm/tests/test-docker.js \
+	vm/tests/test-create.js \
 	vm/tests/test-defaults.js \
+	vm/tests/test-docker.js \
+	vm/tests/test-fswatcher.js \
 	vm/tests/test-hrtime.js \
 	vm/tests/test-indestructible.js \
 	vm/tests/test-internal_metadata_namespaces.js \
 	vm/tests/test-lastexited.js \
 	vm/tests/test-openonerrlogger.js \
+	vm/tests/test-queue.js \
 	vm/tests/test-reboot.js \
 	vm/tests/test-reprovision.js \
+	vm/tests/test-send-recv.js \
 	vm/tests/test-snapshots.js \
 	vm/tests/test-spoof-opts.js \
 	vm/tests/test-tmpfs.js \
 	vm/tests/test-update.js \
 	vm/tests/test-vrrp-nics.js \
+	vm/tests/test-vminfod-zonewatcher.js \
+	vm/tests/test-vminfod-zonewatcher-overflow.js \
+	vm/tests/test-vminfod-zpoolwatcher.js \
 	vm/lib/metadata/*.js
 
 JS_CHECK_OLDSKOOL_TARGETS = \
@@ -128,6 +140,7 @@ C_CHECK_TARGETS=\
 	bootparams.c \
 	cryptpass.c \
 	disk_size.c \
+	fswatcher.c \
 	measure_terminal.c \
 	nomknod.c \
 	qemu-exec.c \
@@ -135,7 +148,6 @@ C_CHECK_TARGETS=\
 	vmunbundle.c \
 	zfs_recv.c \
 	zfs_send.c \
-	zoneevent.c \
 	sdc-on-tty.c \
 	sysinfo_mod.c \
 	sysevent.c \
@@ -280,12 +292,12 @@ TARGETS = \
 	disklayout \
 	disklist \
 	disk_size \
+	fswatcher \
 	mkzpool \
 	removable_disk \
 	vmunbundle \
 	zfs_recv \
 	zfs_send \
-	zoneevent \
 	sysevent \
 	sysinfo_mod.so \
 	nomknod.so.32 \
@@ -367,9 +379,10 @@ install: all $(SUBDIRS)
 	sed -e "s|var expat.*;|var expat = require('./expat_binding');|" \
 	    < node-expat/lib/node-expat.js \
 	    > $(PREFIX_NODE)/node_modules/node-expat.js
+	cp fswatcher $(DESTDIR)/usr/vm/sbin/fswatcher
 	cp dockerinit/build/dockerinit $(DESTDIR)/usr/vm/sbin/dockerinit
 	cp dockerinit/build/dockerexec $(DESTDIR)/usr/vm/sbin/dockerexec
-	cp zoneevent $(DESTDIR)/usr/vm/sbin/zoneevent
+	cp zoneevent.js $(DESTDIR)/usr/vm/sbin/zoneevent
 	cp zfs_send $(DESTDIR)/usr/vm/sbin/zfs_send
 	cp zfs_recv $(DESTDIR)/usr/vm/sbin/zfs_recv
 	cp vmunbundle $(DESTDIR)/usr/vm/sbin/vmunbundle
@@ -379,8 +392,12 @@ install: all $(SUBDIRS)
 	    $(DESTDIR)/lib/svc/manifest/system/system-vmadmd.xml
 	cp vm/smf/system-metadata.xml \
 	    $(DESTDIR)/lib/svc/manifest/system/system-metadata.xml
+	cp vm/smf/system-vminfod.xml \
+	    $(DESTDIR)/lib/svc/manifest/system/system-vminfod.xml
 	mv $(DESTDIR)/usr/vm/sbin/vmadmd.js $(DESTDIR)/usr/vm/sbin/vmadmd
 	mv $(DESTDIR)/usr/vm/sbin/vmadm.js $(DESTDIR)/usr/vm/sbin/vmadm
+	mv $(DESTDIR)/usr/vm/sbin/vminfo.js $(DESTDIR)/usr/vm/sbin/vminfo
+	mv $(DESTDIR)/usr/vm/sbin/vminfod.js $(DESTDIR)/usr/vm/sbin/vminfod
 	mv $(DESTDIR)/usr/vm/sbin/add-userscript.js \
 	    $(DESTDIR)/usr/vm/sbin/add-userscript
 	mv $(DESTDIR)/usr/vm/sbin/metadata.js $(DESTDIR)/usr/vm/sbin/metadata
diff --git a/src/fswatcher.c b/src/fswatcher.c
new file mode 100644
index 00000000..f0017b97
--- /dev/null
+++ b/src/fswatcher.c
@@ -0,0 +1,1031 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ * cc -Wall -Wextra fswatcher.c -o fswatcher -lthread -lnvpair -lavl
+ *
+ */
+
+/*
+ * `fswatcher` will run indefinitely when invoked.  It listens for messages
+ * over stdin, and emits events and responses over stdout, and errors over
+ * stderr.
+ *
+ * On stdin you can send:
+ *
+ * <KEY> WATCH <pathname>\n
+ * <KEY> UNWATCH <pathname>\n
+ * <KEY> STATUS\n
+ *
+ * The first will cause <pathname> to be added to the watch list. The second
+ * will cause the watch for the specified path to be removed.  The third will
+ * print this programs status to stdout. The <KEY> must be an integer in the
+ * range 1-UINT64_MAX (inclusive). Leading 0's will be removed. The key is for
+ * the caller to know which response by `fswatcher` is related to which command
+ * given since commands are processed asynchronously.
+ *
+ * NOTE: 0 is a special key that will be used in output for errors which were
+ * not directly the result of a command.
+ *
+ * "pathname" can be any type of file that event ports supports (file,
+ * directory, pipe, etc. see port_associate(3C) for a full list).  This program
+ * cannot watch symlinks, but instead will watch the source file of a symlink.
+ * Note that, like a regular file, the source file for the symlink must exist
+ * to watch, and if the source file is deleted after a watch is established a
+ * FILE_DELETE event will be emitted.
+ *
+ * When watching a file, it will be rewatched every time an event is seen
+ * until an UNWATCH command for the file is received from the user, or an event
+ * indicates that the file can no longer be watched (like FILE_DELETE).
+ *
+ * On stdout you will see JSON messages that look like the following but are
+ * on a single line:
+ *
+ *  {
+ *     "type": <string>,
+ *     "time": [array],
+ *     "changes": [array],
+ *     "code": <number>,
+ *     "final": true|false,
+ *     "key": <number>,
+ *     "message": "human readable string",
+ *     "pathname": "/path/which/had/event",
+ *     "result": "SUCCESS|FAIL"
+ *  }
+ *
+ * Where:
+ *
+ *   - type
+ *             One of: ready, event, response, error.
+ *             Always included.
+ *   - time
+ *             Time as an array of [seconds, nanoseconds], similar to
+ *             Node's process.hrtime()
+ *             Always included.
+ *   - changes
+ *             An array of strings indicating which changes occurred.
+ *             Included for "event" messages.
+ *   - code
+ *             A positive integer code for an error.
+ *             Included for "response" and "error" messages.
+ *   - final
+ *             true when the event being printed is the last without re-watch.
+ *             Included for "event" messages.
+ *   - key
+ *             The <KEY> for which a response corresponds.
+ *             Included for "response" and "error" messages.
+ *   - message
+ *             Human-readable string describing response.
+ *             Included for "response" and "error" messages.
+ *   - pathname
+ *             pathname to which an event applies.
+ *             Included for "response" and "event" messages.
+ *   - result
+ *             Indicates whether a command was a "SUCCESS" or "FAILURE"
+ *             Included for "response" messages.
+ *
+ * Current values for "code" are in the ErrorCodes enum below.
+ *
+ * EXIT STATUS
+ *
+ *   Under normal operation, fswatcher will run until stdin is closed or a fatal
+ *   error occurs.
+ *
+ *   When errors occur that are completly unexpected, fswatcher will call
+ *   abort() to generate a core dump.
+ *
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <port.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <thread.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <sys/avl.h>
+#include <libnvpair.h>
+
+#define MAX_STAT_RETRY 10  /* number of times to retry stat() before abort() */
+#define SYSTEM_KEY 0       /* reserved key for system events */
+
+/* longest command is '<KEY> UNWATCH <path>' */
+#define MAX_KEY_LEN 20     /* number of digits 0-UINT64_MAX */
+#define MAX_CMD_LEN (MAX_KEY_LEN + 1 + 7 + 1 + PATH_MAX + 1)
+
+/*
+ * Like VERIFY0, but instead of calling abort(), will print an error message
+ * to stderr and exit the program.
+ *
+ * This is used by the nvlist_* functions to ensure that we are able to create
+ * and add to an nvlist without error.  The nvlist functions used can only
+ * fail with EINVAL or ENOMEM: dumping core because of either of these failure
+ * modes would be excessive.
+ */
+#define ENSURE0(arg) {	\
+    if (arg != 0)	\
+        err(1, #arg);	\
+}
+
+/*
+ * These are possible values returned from an "error" event
+ */
+enum ErrorCodes {
+	ERR_INVALID_COMMAND = 1, /* failed to parse command from stdin line */
+	ERR_INVALID_KEY,         /* key parsed from command is invalid */
+	ERR_UNKNOWN_COMMAND,     /* line parsable, but command unknown */
+	ERR_CANNOT_ASSOCIATE     /* port_associate(3c) failed */
+};
+
+/*
+ * Values returned for "result" events
+ */
+enum ResultCodes {
+	RESULT_SUCCESS = 0,
+	RESULT_FAILURE
+};
+
+/*
+ * file_obj structs are held in memory for every file that is currently being
+ * watched.  This way we can 1. verify that incoming events are for files being
+ * watched, and 2. unwatch files at a later time if the user wants.
+ *
+ * These structs are stored in a global AVL tree that uses the filename (and a
+ * hash of it) as the key.
+ */
+static avl_tree_t files_tree;
+struct files_tree_node {
+	struct file_obj fobj;
+	char *name;
+	unsigned long name_hash;
+	avl_node_t avl_node;
+};
+
+/*
+ * This programs has 2 main threads running that block on new events from:
+ *
+ * 1. stdin (user commands)
+ * 2. event ports (filesystem events)
+ *
+ * When an event is received from either, this global "work_mutex" is acquired.
+ * This way, no other locks are necessary, and whatever method is currently
+ * processing its event can safely access members of the AVL tree and write
+ * to stdout/stderr.
+ */
+static mutex_t work_mutex = DEFAULTMUTEX;
+
+/* global event port handle */
+static int port = -1;
+
+/* CLI args */
+static struct {
+	boolean_t opt_j; /* -j, json output */
+	boolean_t opt_r; /* -r, print ready event */
+} opts;
+
+/*
+ * Print the usage message to the given FILE handle
+ */
+static void
+usage(FILE *s)
+{
+	fprintf(s,
+	    "Usage: fswatcher [-hrj]\n"
+	    "\n"
+	    "Watch files using event ports with commands sent to\n"
+	    "stdin and event notifications sent to stdout.\n"
+	    "\n"
+	    "Options\n"
+	    "  -h             print this message and exit\n"
+	    "  -j             JSON output\n"
+	    "  -r             print 'ready' event at start\n");
+}
+
+/*
+ * The unique key for the files_tree_node objects are the filenames.  When a
+ * node is created, a hash is calculated for the filename to make comparisons
+ * fast.  Only if the hash matches is a full string (strcmp) comparison done.
+ */
+static int
+files_tree_node_comparator(const void *l, const void *r)
+{
+	const struct files_tree_node *ltn = l;
+	const struct files_tree_node *rtn = r;
+	int ret;
+
+	/* first check filename hash */
+	if (ltn->name_hash < rtn->name_hash)
+		return (-1);
+	else if (ltn->name_hash > rtn->name_hash)
+		return (1);
+
+	/* hashes are the same, do string comparison */
+	ret = strcmp(ltn->name, rtn->name);
+
+	if (ret < 0)
+		return (-1);
+	else if (ret > 0)
+		return (1);
+
+	return (0);
+}
+
+/*
+ * Simple hashing algorithm pulled from http://www.cse.yorku.ca/~oz/hash.html
+ *
+ * This function is used primarily to make lookups in the AVL tree faster.
+ * Since the tree is keyed off of a files pathname, the pathname string as well
+ * as a hash of the string is stored in the tree.
+ *
+ * There is nothing inherently special or particularly useful about the "djb2"
+ * hashing algorithm, really any quick hashing algorithm will work here, since
+ * when a hash collision is detected a full strcmp() is performed.
+ */
+static unsigned long
+djb2(char *str)
+{
+	unsigned long hash = 5381;
+	int c;
+	while ((c = *str++))
+		hash = ((hash << 5) + hash) + c;
+	return (hash);
+}
+
+/*
+ * Allocate an nvlist with "type" set to the type argument given, and "time"
+ * set to the current time.  This function handles any error checking needed
+ * and will exit the program if anything fails.
+ *
+ * nvlist must be freed by the caller
+ */
+static nvlist_t *
+make_nvlist(char *type)
+{
+	uint64_t time[2];
+	nvlist_t *nvl;
+	struct timespec tv;
+
+	ENSURE0(nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0));
+
+	/* get the current hrtime */
+	if (clock_gettime(CLOCK_MONOTONIC, &tv) != 0)
+		err(1, "clock_gettime CLOCK_MONOTONIC");
+	time[0] = tv.tv_sec;
+	time[1] = tv.tv_nsec;
+
+	ENSURE0(nvlist_add_string(nvl, "type", type));
+	ENSURE0(nvlist_add_uint64_array(nvl, "time", time, 2));
+
+	return (nvl);
+}
+
+/*
+ * Print an nvlist to stdout.  Will use the proper function to print
+ * based on -j being set or not.
+ *
+ * This function handles fflushing stdout.
+ */
+static void
+print_nvlist(nvlist_t *nvl)
+{
+	if (opts.opt_j)
+		nvlist_print_json(stdout, nvl);
+	else
+		nvlist_print(stdout, nvl);
+	printf("\n");
+
+	fflush(stdout);
+}
+
+/*
+ * Handle creating and printing an "event" message.
+ */
+static void
+print_event(int event, char *pathname, boolean_t is_final)
+{
+	nvlist_t *nvl = make_nvlist("event");
+	uint_t i;
+	uint_t count = 0;
+
+	/* Map event port file event flags to strings */
+	struct flag_names {
+		int fn_flag;
+		char *fn_name;
+	};
+	static struct flag_names flags[] = {
+		{ FILE_ACCESS, "FILE_ACCESS" },
+		{ FILE_ATTRIB, "FILE_ATTRIB" },
+		{ FILE_DELETE, "FILE_DELETE" },
+		{ FILE_EXCEPTION, "FILE_EXCEPTION" },
+		{ FILE_MODIFIED, "FILE_MODIFIED" },
+		{ FILE_RENAME_FROM, "FILE_RENAME_FROM" },
+		{ FILE_RENAME_TO, "FILE_RENAME_TO" },
+		{ FILE_TRUNC, "FILE_TRUNC" },
+		{ FILE_NOFOLLOW, "FILE_NOFOLLOW" },
+		{ MOUNTEDOVER, "MOUNTEDOVER" },
+		{ UNMOUNTED, "UNMOUNTED" }
+	};
+	static const uint_t num_flags = (sizeof (flags) / sizeof (flags[0]));
+	char *changes[num_flags];
+
+	for (i = 0; i < num_flags; i++) {
+		if ((event & flags[i].fn_flag) != 0) {
+			changes[count++] = flags[i].fn_name;
+		}
+	}
+
+	ENSURE0(nvlist_add_string_array(nvl, "changes", changes, count));
+	ENSURE0(nvlist_add_string(nvl, "pathname", pathname));
+	ENSURE0(nvlist_add_int32(nvl, "revents", event));
+	ENSURE0(nvlist_add_boolean_value(nvl, "final", is_final));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * Handle creating and printing a "ready" message.
+ */
+static void
+print_ready()
+{
+	nvlist_t *nvl = make_nvlist("ready");
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * print_error() takes a key, code (one of the ErrorCodes) and message and
+ * handles creating and printing an "error" message.
+ */
+static void
+print_error(uint64_t key, uint32_t code, const char *message_fmt, ...)
+{
+	va_list arg_ptr;
+	char message[4096];
+	nvlist_t *nvl = make_nvlist("error");
+
+	va_start(arg_ptr, message_fmt);
+	if (vsnprintf(message, sizeof (message), message_fmt, arg_ptr) < 0) {
+		perror("fswatcher: vsnprintf");
+		abort();
+	}
+	va_end(arg_ptr);
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", code));
+	ENSURE0(nvlist_add_string(nvl, "message", message));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * print_response() takes a key, code (RESULT_SUCCESS||RESULT_FAILURE), pathname
+ * and message and handles creating and printing a "result" message.
+ */
+static void
+print_response(uint64_t key, uint32_t code, const char *pathname,
+    const char *message_fmt, ...)
+{
+	va_list arg_ptr;
+	char message[4096];
+	nvlist_t *nvl = make_nvlist("response");
+
+	va_start(arg_ptr, message_fmt);
+	if (vsnprintf(message, sizeof (message), message_fmt, arg_ptr) < 0) {
+		perror("fswatcher: vsnprintf");
+		abort();
+	}
+	va_end(arg_ptr);
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", code));
+	ENSURE0(nvlist_add_string(nvl, "pathname", pathname));
+	ENSURE0(nvlist_add_string(nvl, "message", message));
+	ENSURE0(nvlist_add_string(nvl, "result",
+	    code == RESULT_SUCCESS ? "SUCCESS" : "FAIL"));
+
+	print_nvlist(nvl);
+
+	nvlist_free(nvl);
+}
+
+/*
+ * Only called from stdin thread.  Prints information about this program
+ *
+ * print_status prints a message of type "response"
+ */
+static void
+print_status(uint64_t key)
+{
+	ulong_t numnodes;
+	char **filenames;
+	struct files_tree_node *ftn;
+	ulong_t i = 0;
+	nvlist_t *nvl = make_nvlist("response");
+	nvlist_t *data_nvl = fnvlist_alloc();
+
+	ENSURE0(nvlist_add_uint64(nvl, "key", key));
+	ENSURE0(nvlist_add_uint32(nvl, "code", RESULT_SUCCESS));
+	ENSURE0(nvlist_add_string(nvl, "result", "SUCCESS"));
+
+	/* get all nodes in the avl tree */
+	numnodes = avl_numnodes(&files_tree);
+	filenames = calloc(numnodes, sizeof (char *));
+
+	if (filenames == NULL)
+		err(1, "calloc");
+
+	/* walk the avl tree and add each filename */
+	for (ftn = avl_first(&files_tree); ftn != NULL;
+	    ftn = AVL_NEXT(&files_tree, ftn)) {
+
+		filenames[i++] = ftn->name;
+	}
+
+	/*
+	 * all STATUS data is stored in a separate nvl that is attached to the
+	 * "data" key of the response object.
+	 */
+	ENSURE0(nvlist_add_string_array(data_nvl, "files", filenames, i));
+	ENSURE0(nvlist_add_uint32(data_nvl, "files_count", numnodes));
+	ENSURE0(nvlist_add_int32(data_nvl, "pid", getpid()));
+
+	ENSURE0(nvlist_add_nvlist(nvl, "data", data_nvl));
+
+	print_nvlist(nvl);
+
+	nvlist_free(data_nvl);
+	nvlist_free(nvl);
+	free(filenames);
+}
+
+/*
+ * find_handle() takes a pathname and returns the files_tree_node struct from
+ * the files_tree treeh. returns NULL if no pathname matches.
+ */
+static struct files_tree_node *
+find_handle(char *pathname)
+{
+	struct files_tree_node lookup;
+
+	lookup.name = pathname;
+	lookup.name_hash = djb2(pathname);
+
+	return (avl_find(&files_tree, &lookup, NULL));
+}
+
+/*
+ * add_handle() inserts a files_tree_node struct into the files_tree tree.
+ */
+static void
+add_handle(struct files_tree_node *ftn)
+{
+	avl_add(&files_tree, ftn);
+}
+
+/*
+ * remove_handle() removes a files_tree_node struct from the files_tree tree.
+ */
+static void
+remove_handle(struct files_tree_node *ftn)
+{
+	avl_remove(&files_tree, ftn);
+}
+
+/*
+ * destroy_handle() removes and frees a files_tree_node struct from the
+ * files_tree tree.
+ */
+static void
+destroy_handle(struct files_tree_node *ftn)
+{
+	remove_handle(ftn);
+	free(ftn->name);
+	free(ftn);
+}
+
+/*
+ * stat_file() takes the same arguments as stat and calls stat for you but does
+ * retries on errors and ultimately returns either 0 (success) or one of the
+ * errno's listed in stat(2).
+ *
+ * WARNING: If it gets EINTR too many times (more than MAX_STAT_RETRY), this
+ * will call abort().
+ */
+static int
+stat_file(const char *path, struct stat *buf)
+{
+	int i;
+
+	for (i = 0; i < MAX_STAT_RETRY; i++) {
+		int stat_ret = stat(path, buf);
+		int stat_err = errno;
+
+		/* return immediately upon success */
+		if (stat_ret == 0)
+			return (0);
+
+		/* error from stat that means we can't retry, just return it */
+		if (stat_err != EINTR)
+			return (stat_err);
+
+		/* Interrupted by signal, try again... */
+	}
+
+	/* if we are here, give up */
+	fprintf(stderr, "failed to stat %s more than %d times\n",
+	    path, MAX_STAT_RETRY);
+	abort();
+
+	return (-1);
+}
+
+/*
+ * Returns:
+ *
+ *  0     - success: atime, ctime and mtime will be populated
+ *  non-0 - failed: file could not be accessed (return is stat(2) errno)
+ */
+static int
+get_stat(char *pathname, struct stat *sb)
+{
+	int stat_ret;
+
+	stat_ret = stat_file(pathname, sb);
+
+	switch (stat_ret) {
+	case 0:
+		/* SUCCESS! (sb will be populated) */
+		return (0);
+	case ELOOP:         /* symbolic links in path point to each other */
+	case ENOTDIR:       /* component of path is not a dir */
+	case EACCES:        /* permission denied */
+	case ENOENT:        /* file or component path doesn't exist */
+		/*
+		 * The above are all fixable problems. We can't open the file
+		 * right now, but we know that we shouldn't be able to either.
+		 * As such, these are non-fatal and just result in a FAIL (with
+		 * final flag set true) response if we're responding to a
+		 * request or an error line if we're dealing with an event.
+		 */
+		return (stat_ret);
+	case EFAULT:        /* filename or buffer invalid (programmer error) */
+	case EIO:           /* error reading from filesystem (system error) */
+	case ENAMETOOLONG:  /* fo_name is too long (programmer error) */
+	case ENOLINK:       /* broken link to remote machine */
+	case ENXIO:         /* path marked faulty and retired */
+	case EOVERFLOW:     /* file is broken (system error) */
+	default:
+		/*
+		 * This handles cases we don't know how to deal with, by
+		 * dumping core so that it can later be debugged.
+		 */
+		abort();
+		break;
+	}
+}
+
+/*
+ * check_and_rearm_event() is called to (re)arm watches. This can either be
+ * because of an event (in which case revents should be pe.portev_events) or to
+ * initially arm in which case revents should be 0.
+ *
+ * It also performs the required stat() and in case this is a re-arm prints
+ * the event.
+ *
+ * We keep these two functions together (rearming and printing) because we need
+ * to do the stat() before we print the results since if the file no longer
+ * exists we cannot rearm. In that case we set the 'final' flag in the response.
+ */
+static void
+check_and_rearm_event(uint64_t key, char *name, int revents,
+    struct files_tree_node *ftn)
+{
+	boolean_t is_final = B_FALSE;
+	struct stat sb;
+	int stat_ret;
+	int pa_ret;
+	struct file_obj *fobjp;
+
+	/* ftn may be passed as an argument.  if not, we look for it. */
+	if (ftn == NULL) {
+		ftn = find_handle(name);
+	}
+
+	/* we don't have a handle for this file so ignore the event */
+	if (ftn == NULL) {
+		fprintf(stderr, "got event for '%s' without a handle\n", name);
+		return;
+	}
+
+	/*
+	 * We always stat the file after an event is received, or for the
+	 * inital watch.  If the stat fails for any reason, or any event is
+	 * seen that indicates the file is gone, we mark this file as "final" -
+	 * this means we will no longer be watching this file.
+	 */
+	stat_ret = get_stat(name, &sb);
+	if (stat_ret != 0 ||
+	    revents & FILE_DELETE || revents & FILE_RENAME_FROM ||
+	    revents & UNMOUNTED || revents & MOUNTEDOVER) {
+
+		is_final = B_TRUE;
+	}
+
+	if (key != SYSTEM_KEY && stat_ret != 0) {
+		/*
+		 * We're doing the initial register for this file, so we need
+		 * to send a result.
+		 */
+		print_response(key, RESULT_FAILURE, name,
+		    "stat(2) failed with errno %d: %s",
+		    stat_ret, strerror(stat_ret));
+		assert(is_final);
+	}
+
+	if (is_final) {
+		/* We're not going to re-watch the file, so cleanup */
+		if (revents != 0) {
+			print_event(revents, name, B_TRUE);
+		}
+		destroy_handle(ftn);
+		return;
+	}
+
+	/* (re)register watch */
+	fobjp = &ftn->fobj;
+	fobjp->fo_atime = sb.st_atim;
+	fobjp->fo_mtime = sb.st_mtim;
+	fobjp->fo_ctime = sb.st_ctim;
+
+	pa_ret = port_associate(port, PORT_SOURCE_FILE, (uintptr_t)fobjp,
+	    FILE_MODIFIED|FILE_TRUNC, name);
+
+	if (key != SYSTEM_KEY) {
+		/*
+		 * We're trying to do an initial associate, so we'll print a
+		 * result whether we succeeded or failed.
+		 */
+		VERIFY3S(revents, ==, 0);
+		if (pa_ret == -1) {
+			print_response(key, RESULT_FAILURE, name,
+			    "port_associate(3c) failed with errno %d: %s",
+			    errno, strerror(errno));
+			destroy_handle(ftn);
+			return;
+		}
+
+		print_response(key, RESULT_SUCCESS, name,
+		    "port_associate(3c) started watching path");
+		return;
+	}
+
+	/*
+	 * If we are here, this function was called as a result of an event
+	 * being seen.
+	 */
+	VERIFY3S(revents, !=, 0);
+	print_event(revents, name, B_FALSE);
+
+	if (pa_ret == -1) {
+		print_error(key, ERR_CANNOT_ASSOCIATE,
+		    "port_associate(3c) failed for '%s', errno %d: %s",
+		    name, errno, strerror(errno));
+		destroy_handle(ftn);
+	}
+}
+
+/*
+ * Only called from stdin thread. Attempts to watch pathname.
+ */
+static void
+watch_path(char *pathname, uint64_t key)
+{
+	struct files_tree_node *ftn;
+	char *dupname;
+
+	if (find_handle(pathname) != NULL) {
+		print_response(key, RESULT_SUCCESS, pathname,
+		    "already watching");
+		return;
+	}
+
+	ftn = malloc(sizeof (struct files_tree_node));
+	if (ftn == NULL)
+		err(1, "malloc new watcher");
+
+	/*
+	 * Copy the pathname given here as we need to hold onto it for as long
+	 * as the file is being watched.
+	 */
+	dupname = strdup(pathname);
+	if (dupname == NULL)
+		err(1, "strdup new watcher");
+
+	ftn->fobj.fo_name = dupname;
+	ftn->name = dupname;
+	ftn->name_hash = djb2(dupname);
+
+	add_handle(ftn);
+
+	check_and_rearm_event(key, dupname, 0, ftn);
+}
+
+/*
+ * Only called from stdin thread. Attempts to unwatch pathname.
+ */
+static void
+unwatch_path(char *pathname, uint64_t key)
+{
+	struct file_obj *fobjp;
+	int ret;
+	struct files_tree_node *ftn;
+
+	ftn = find_handle(pathname);
+	if (ftn == NULL) {
+		print_response(key, RESULT_FAILURE, pathname,
+		    "not watching '%s', cannot unwatch", pathname);
+		return;
+	}
+
+	fobjp = &ftn->fobj;
+	/*
+	 * From the man page, there are 5 possible errors for port_dissociate():
+	 *
+	 * EBADF
+	 *          The port identifier is not valid.
+	 *
+	 * EBADFD
+	 *          The source argument is of type PORT_SOURCE_FD  and  the
+	 *          object argument is not a valid file descriptor.
+	 *
+	 * EINVAL
+	 *          The source argument is not valid.
+	 *
+	 * EACCES
+	 *          The process is not the owner of the association.
+	 *
+	 * ENOENT
+	 *          The specified object is not associated with the port.
+	 *
+	 *
+	 * none of these seem like they'll succeed if tried again later for this
+	 * same file, so in every case we assume that the file is no longer
+	 * associated and remove the handle.
+	 */
+	ret = port_dissociate(port, PORT_SOURCE_FILE, (uintptr_t)fobjp);
+
+	destroy_handle(ftn);
+
+	if (ret == -1) {
+		print_response(key, RESULT_FAILURE, pathname,
+		    "failed to unregister '%s' (errno %d): %s", pathname, errno,
+		    strerror(errno));
+	} else {
+		print_response(key, RESULT_SUCCESS, pathname,
+		    "no longer watching '%s'", pathname);
+	}
+}
+
+/*
+ * Process one line of stdin
+ */
+static void
+process_stdin_line(char *str)
+{
+	char cmd[MAX_CMD_LEN + 1];
+	char path[MAX_CMD_LEN + 1];
+	int res;
+	unsigned long long key;
+
+	cmd[0] = '\0';
+	path[0] = '\0';
+
+	if (strlen(str) > MAX_CMD_LEN) {
+		print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+		    "command line too long");
+		return;
+	}
+
+	res = sscanf(str, "%llu %s %s", &key, cmd, path);
+
+	if (!(res == 2 || res == 3)) {
+		print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+		    "invalid command line");
+		return;
+	}
+
+	/* this is a reserved key */
+	if (key == SYSTEM_KEY) {
+		print_error(SYSTEM_KEY, ERR_INVALID_KEY,
+		    "invalid key: %d", SYSTEM_KEY);
+		return;
+	}
+
+	if (strcmp("UNWATCH", cmd) == 0) {
+		if (path[0] == '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - UNWATCH requires pathname");
+			return;
+		}
+
+		unwatch_path(path, key);
+	} else if (strcmp("WATCH", cmd) == 0) {
+		if (path[0] == '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - WATCH requires pathname");
+			return;
+		}
+
+		watch_path(path, key);
+	} else if (strcmp("STATUS", cmd) == 0) {
+		if (path[0] != '\0') {
+			print_error(SYSTEM_KEY, ERR_INVALID_COMMAND,
+			    "invalid command line - STATUS takes no arguments");
+			return;
+		}
+
+		print_status(key);
+	} else {
+		print_error(key, ERR_UNKNOWN_COMMAND, "unknown command '%s'",
+		    cmd);
+	}
+}
+
+/*
+ * Worker thread waits here for stdin data.
+ */
+static void *
+wait_for_stdin(void *arg __unused)
+{
+	char str[MAX_CMD_LEN + 1];
+
+	/* read stdin line-by-line indefinitely */
+	while (fgets(str, sizeof (str), stdin) != NULL) {
+		mutex_lock(&work_mutex);
+		process_stdin_line(str);
+		mutex_unlock(&work_mutex);
+
+		str[0] = '\0';
+	}
+
+	/* stdin closed or error */
+	if (feof(stdin)) {
+		errx(0, "stdin closed");
+	} else {
+		perror("stdin fgets");
+		abort();
+	}
+}
+
+/*
+ * Worker thread waits here for event port events.
+ */
+static void *
+wait_for_events(void *arg __unused)
+{
+	port_event_t pe;
+
+	while (!port_get(port, &pe, NULL)) {
+		mutex_lock(&work_mutex);
+
+		switch (pe.portev_source) {
+		case PORT_SOURCE_FILE:
+			/* call handler for filesystem event */
+			check_and_rearm_event(0, (char *)pe.portev_user,
+			    pe.portev_events, NULL);
+			break;
+		default:
+			/*
+			 * Something's seriously wrong if we get events with a
+			 * port source other than FILE, since that's all we're
+			 * adding. So abort and hope there's enough state in
+			 * the core.
+			 */
+			fprintf(stderr, "event from unexpected source: %d",
+			    pe.portev_source);
+			abort();
+		}
+
+		mutex_unlock(&work_mutex);
+	}
+
+	/* should not be reached */
+	perror("wait_for_events thread exited (port_get)");
+	abort();
+}
+
+/*
+ * Create a thread using the given thread_func and exit the process if thread
+ * creation fails.
+ */
+static void
+create_thread(void *(*thread_func)(void *))
+{
+	int rc;
+	thread_t tid;
+
+	if ((rc = thr_create(NULL, 0, thread_func, NULL, 0, &tid)) != 0) {
+		errx(1, "thr_create: %s", strerror(rc));
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	int opt;
+
+	opts.opt_j = B_FALSE;
+	opts.opt_r = B_FALSE;
+	while ((opt = getopt(argc, argv, "hjr")) != -1) {
+		switch (opt) {
+		case 'h':
+			usage(stdout);
+			return (0);
+		case 'j':
+			opts.opt_j = B_TRUE;
+			break;
+		case 'r':
+			opts.opt_r = B_TRUE;
+			break;
+		default:
+			usage(stderr);
+			return (1);
+		}
+	}
+	argc -= optind;
+	argv += optind;
+
+	/* create event port globally */
+	if ((port = port_create()) == -1) {
+		err(1, "port_create");
+	}
+
+	/* initialize the AVL tree to hold all files currently being watched */
+	avl_create(&files_tree, files_tree_node_comparator,
+	    sizeof (struct files_tree_node),
+	    offsetof(struct files_tree_node, avl_node));
+
+	/*
+	 * If the caller wants a "ready" event to be emitted, we grab the
+	 * global mutex here, and unlock it after the threads are created.
+	 */
+	if (opts.opt_r) {
+		mutex_lock(&work_mutex);
+	}
+
+	/* create worker threads to process stdin and event ports */
+	create_thread(wait_for_events);
+	create_thread(wait_for_stdin);
+
+	/* alert that we are ready for input */
+	if (opts.opt_r) {
+		print_ready();
+		mutex_unlock(&work_mutex);
+	}
+
+	/* do nothing while threads handle the load */
+	while (thr_join(0, NULL, NULL) == 0) {
+		/* pass */
+	}
+
+	return (0);
+}
diff --git a/src/manifest b/src/manifest
index 05bb95a7..dd410f20 100644
--- a/src/manifest
+++ b/src/manifest
@@ -438,6 +438,7 @@ f usr/img/test/update.test.js 0444 root bin
 # new vmadmd
 s etc/bash/bash_completion.d/vmadm=/usr/vm/etc/vmadm.completion
 f lib/svc/manifest/system/system-vmadmd.xml 0444 root bin
+f lib/svc/manifest/system/system-vminfod.xml 0444 root bin
 f usr/bin/bunyan 0555 root bin
 f usr/share/man/man1/bunyan.1 0444 root bin
 f usr/share/man/man1m/vmadmd.1m 0444 root bin
@@ -461,10 +462,13 @@ f usr/vm/sbin/add-userscript 0555 root bin
 f usr/vm/sbin/dockerexec 0555 root bin
 f usr/vm/sbin/dockerinit 0555 root bin
 f usr/vm/sbin/filewait 0555 root bin
+f usr/vm/sbin/fswatcher 0555 root bin
 f usr/vm/sbin/rotate-kvm-logs.sh 0555 root bin
 f usr/vm/sbin/rotate-logs.sh 0555 root bin
 f usr/vm/sbin/vmadm 0555 root bin
 f usr/vm/sbin/vmadmd 0555 root bin
+f usr/vm/sbin/vminfo 0555 root bin
+f usr/vm/sbin/vminfod 0555 root bin
 f usr/vm/sbin/vmunbundle 0555 root bin
 f usr/vm/sbin/zfs_recv 0555 root bin
 f usr/vm/sbin/zfs_send 0555 root bin
@@ -474,10 +478,43 @@ f usr/node/0.10/node_modules/bunyan.js 0444 root bin
 f usr/node/0.10/node_modules/expat_binding.node 0444 root bin
 f usr/node/0.10/node_modules/node-expat.js 0444 root bin
 f usr/vm/node_modules/bunyan.js 0444 root bin
+f usr/vm/node_modules/diff.js 0644 root root
 f usr/vm/node_modules/dladm.js 0444 root bin
 f usr/vm/node_modules/expander.js 0444 root bin
+f usr/vm/node_modules/fswatcher.js 0444 root root
 f usr/vm/node_modules/hrtime.js 0444 root root
 f usr/vm/node_modules/ip.js 0444 root bin
+d usr/vm/node_modules/jsprim 0755 root root
+d usr/vm/node_modules/jsprim/node_modules 0755 root root
+d usr/vm/node_modules/jsprim/node_modules/json-schema 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/json-schema/README.md 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/json-schema/package.json 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/json-schema/lib 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/json-schema/lib/links.js 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/json-schema/lib/validate.js 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/extsprintf 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/extsprintf/LICENSE 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/extsprintf/lib 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/extsprintf/lib/extsprintf.js 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/extsprintf/package.json 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/verror 0755 root root
+d usr/vm/node_modules/jsprim/node_modules/verror/lib 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/lib/verror.js 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/verror/node_modules 0755 root root
+d usr/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/package.json 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/LICENSE 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/lib 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/lib/util.js 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/package.json 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/verror/LICENSE 0644 root root
+d usr/vm/node_modules/jsprim/node_modules/assert-plus 0755 root root
+f usr/vm/node_modules/jsprim/node_modules/assert-plus/package.json 0644 root root
+f usr/vm/node_modules/jsprim/node_modules/assert-plus/assert.js 0644 root root
+d usr/vm/node_modules/jsprim/lib 0755 root root
+f usr/vm/node_modules/jsprim/lib/jsprim.js 0644 root root
+f usr/vm/node_modules/jsprim/LICENSE 0644 root root
+f usr/vm/node_modules/jsprim/package.json 0644 root root
 f usr/vm/node_modules/locker.js 0444 root bin
 f usr/vm/node_modules/nic.js 0444 root bin
 d usr/vm/node_modules/macaddr/ 0755 root root
@@ -727,6 +764,7 @@ f usr/vm/node_modules/openonerrlogger.js 0444 root bin
 f usr/vm/node_modules/props.js 0444 root bin
 f usr/vm/node_modules/proptable.js 0444 root bin
 f usr/vm/node_modules/qmp.js 0444 root bin
+f usr/vm/node_modules/queue.js 0644 root root
 f usr/vm/node_modules/sysevent-stream.js 0444 root bin
 f usr/vm/node_modules/utils.js 0444 root bin
 d usr/vm/node_modules/vasync 0755 root root
@@ -769,10 +807,18 @@ f usr/vm/node_modules/vmload/vmload-utils.js 0644 root root
 f usr/vm/node_modules/vmload/vmload-xml.js 0644 root root
 f usr/vm/node_modules/vmload/dump-json.js 0755 root root
 f usr/vm/node_modules/vmload/index.js 0644 root root
+d usr/vm/node_modules/vminfod 0755 root root
+f usr/vm/node_modules/vminfod/vminfod.js 0644 root root
+f usr/vm/node_modules/vminfod/zpoolwatcher.js 0644 root root
+f usr/vm/node_modules/vminfod/zonewatcher.js 0644 root root
+f usr/vm/node_modules/vminfod/client.js 0644 root root
 f usr/vm/node_modules/VM.js 0444 root bin
 f usr/vm/node_modules/zonecfg.js 0444 root bin
+f usr/vm/node_modules/zoneevent.js 0444 root bin
 f usr/vm/smf/system-vmadmd 0555 root bin
 f usr/vm/smf/system-vmadmd.xml 0444 root bin
+f usr/vm/smf/system-vminfod 0555 root bin
+f usr/vm/smf/system-vminfod.xml 0444 root bin
 # fwadm
 s etc/bash/bash_completion.d/fwadm=/usr/fw/etc/fwadm.completion
 d usr/fw 0555 root bin
@@ -995,7 +1041,6 @@ d usr/vm/lib 0555 root bin
 d usr/vm/lib/metadata 0555 root bin
 f usr/vm/lib/metadata/common.js 0444 root bin
 f usr/vm/lib/metadata/crc32.js 0444 root bin
-f usr/vm/lib/metadata/zwatch.js 0444 root bin
 f usr/vm/lib/metadata/agent.js 0444 root bin
 f usr/vm/sbin/metadata 0555 root bin
 f usr/vm/smf/system-metadata 0555 root bin
@@ -1039,6 +1084,7 @@ f usr/lib/sdc/net-boot-config 0555 root bin
 f usr/sbin/sysevent 0555 root bin
 s usr/sbin/fwadm=../fw/sbin/fwadm
 s usr/sbin/vmadm=../vm/sbin/vmadm
+s usr/sbin/vminfo=../vm/sbin/vminfo
 d usr/node 0755 root bin
 d usr/node/0.10 0755 root bin
 d usr/node/0.10/node_modules 0755 root bin
diff --git a/src/vm/common/vmtest.js b/src/vm/common/vmtest.js
index 93819999..939eccba 100644
--- a/src/vm/common/vmtest.js
+++ b/src/vm/common/vmtest.js
@@ -1,9 +1,33 @@
-//
-// Copyright 2018 Joyent, Inc.  All rights reserved.
-//
-// This is the common set of functions for things like ensuring we have a
-// SmartOS and Ubuntu image to work with.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * This is the common set of functions for things like ensuring we have a
+ * SmartOS and Ubuntu image to work with.
+ */
 
 process.env['TAP'] = 1;
 var async = require('/usr/node/node_modules/async');
@@ -115,7 +139,7 @@ exports.on_new_vm = function(t, uuid, payload, state, fnlist, callback)
         if (state.hasOwnProperty('uuid')) {
             VM.delete(state.uuid, function (err) {
                 if (err) {
-                    if (err.message.match(/No such zone configured/)) {
+                    if (err.code === 'ENOENT') {
                         t.ok(true, 'tried to delete VM ' + state.uuid
                             + ' but it was already gone.');
                     } else {
diff --git a/src/vm/lib/metadata/agent.js b/src/vm/lib/metadata/agent.js
index d141a40d..f3295805 100644
--- a/src/vm/lib/metadata/agent.js
+++ b/src/vm/lib/metadata/agent.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  *
  * # OVERVIEW
@@ -31,13 +31,8 @@
  *
  * This agent then:
  *
- *   - attempts to create a metadata socket for all existing VMs on the CN
- *   - starts an interval timer so that we check every 5 minutes for VMs that
- *     have been deleted
- *   - starts an interval timer so that we check every minute for VMs that have
- *     started running without us getting a ZWatch event
- *   - starts a ZWatch watcher that calls a callback whenever a VM is started
- *     and does not already have an active connection
+ *   - starts a VminfodWatcher that handles VM creation, VM deletion, and VM
+ *     state changes.
  *
  * Either at agent startup or whenever we see a zone boot that does not have a
  * metadata socket, we attempt to create the appropriate socket for the type of
@@ -146,87 +141,18 @@ var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/vm/node_modules/bunyan');
 var common = require('./common');
 var crc32 = require('./crc32');
-var execFile = require('child_process').execFile;
 var fs = require('fs');
-var getZoneinfo
-    = require('/usr/vm/node_modules/vmload/vmload-zoneinfo').getZoneinfo;
-var guessHandleType = process.binding('tty_wrap').guessHandleType;
 var macaddr = require('/usr/vm/node_modules/macaddr');
 var net = require('net');
 var path = require('path');
-var util = require('util');
-var vasync = require('vasync');
 var VM = require('/usr/vm/node_modules/VM');
-var vmload = require('/usr/vm/node_modules/vmload');
-var ZWatch = require('./zwatch');
-
-var sdc_fields = [
-    'alias',
-    'billing_id',
-    'brand',
-    'cpu_cap',
-    'cpu_shares',
-    'create_timestamp',
-    'server_uuid',
-    'image_uuid',
-    'datacenter_name',
-    'do_not_inventory',
-    'dns_domain',
-    'force_metadata_socket',
-    'fs_allowed',
-    'hostname',
-    'internal_metadata_namespaces',
-    'limit_priv',
-    'last_modified',
-    'maintain_resolvers',
-    'max_physical_memory',
-    'max_locked_memory',
-    'max_lwps',
-    'max_swap',
-    'nics',
-    'owner_uuid',
-    'package_name',
-    'package_version',
-    'quota',
-    'ram',
-    'resolvers',
-    'routes',
-    'state',
-    'tmpfs',
-    'uuid',
-    'vcpus',
-    'vnc_port',
-    'zfs_io_priority',
-    'zonepath',
-    'zonename',
-    'zone_state'
-];
+var VminfodWatcher
+    = require('/usr/vm/node_modules/vminfod/client').VminfodWatcher;
 
 var KVM_CONNECT_RETRY_INTERVAL = 100; // ms
 var KVM_CONNECT_RETRY_LOG_FREQUENCY = 10; // log every X retries
-var MAX_RETRY = 300; // in seconds
-var ZONEADM_CHECK_FREQUENCY = (5 * 60 * 1000); // ms, check for deleted zones
-var MISSED_SYSEVENT_CHECK_FREQUENCY = (1 * 60 * 1000); // ms
 
-
-function zoneExists(zonename, callback) {
-    var exists = false;
-
-    fs.stat('/etc/zones/' + zonename + '.xml', function _onStat(err, stats) {
-        if (err) {
-            if (err.code !== 'ENOENT') {
-                // Should either exist or not exist but should always be
-                // readable if it does exist. If not: we don't know how to
-                // proceed so throw/abort.
-                throw (err);
-            }
-        } else {
-            exists = true;
-        }
-
-        callback(null, exists);
-    });
-}
+function noop() {}
 
 function closeZoneConnection(zoneConn) {
     assert.object(zoneConn, 'zoneConn');
@@ -272,7 +198,6 @@ function elapsedTimer(timer) {
 var MetadataAgent = module.exports = function (options) {
     this.log = options.log;
     this.zlog = {};
-    this.zones = {};
     this.zonesDebug = {};
     this.zoneConnections = {};
     this.zoneKvmReconnTimers = {};
@@ -328,8 +253,8 @@ MetadataAgent.prototype.addDebug = function addDebug(zonename, field, value) {
 };
 
 MetadataAgent.prototype.createZoneLog = function (type, zonename) {
-    assert.string(type);
-    assert.string(zonename);
+    assert.string(type, 'type');
+    assert.string(zonename, 'zonename');
 
     var self = this;
     var newRingbuffer = new bunyan.RingBuffer({limit: 10});
@@ -343,212 +268,77 @@ MetadataAgent.prototype.createZoneLog = function (type, zonename) {
     return (self.zlog[zonename]);
 };
 
-/**
- * Update the zones cache for the zone with name "zonename", and call "callback"
- * when done.
- *
- * @param zonename {String} the name of the zone for which to update the cache
- * @param opts {Object} an object with the following properties:
- *   - forceReload {Boolean} if true, bypasses the cache and always reload that
- *     zone's information from disk. False by default.
- * @param callback {Function} a function called when the operation is complete.
- *   The signature of that function is callback(err), where "err" is an Error
- *   object that represents the cause of failure if updating the zone cache
- *   failed.
- */
-MetadataAgent.prototype.updateZone =
-function updateZone(zonename, opts, callback) {
-    assert.string(zonename, 'zonename');
-    assert.object(opts, 'opts');
-    assert.optionalBool(opts.forceReload, 'opts.forceReload');
-    assert.func(callback, 'callback');
-
+MetadataAgent.prototype.createServersOnExistingZones = function (vms) {
     var self = this;
-    var log = self.log;
-
-    assert.string(zonename, 'zonename');
-    assert.func(callback, 'callback');
-
-    function shouldLoad(cb) {
-        if (opts.forceReload) {
-            cb(null, true);
-            return;
-        }
+    var created = 0;
+    var keys = Object.keys(vms);
 
-        if (!self.zones.hasOwnProperty(zonename)) {
-            // don't have a cache, load this guy
-            log.info({zonename: zonename},
-                'no cache for: ' + zonename + ', loading');
-            cb(null, true);
-            return;
+    async.forEach(keys, function (zonename, cb) {
+        var vm = vms[zonename];
+        if (!self.zlog[zonename]) {
+            // create a logger specific to this VM
+            self.createZoneLog(vm.brand, zonename);
         }
 
-        // We do have a cached version, we'll reload only if its last modified
-        // timestamp changed.
-        vmload.getLastModified(zonename, path.join('/zones', zonename), log,
-            function onLastModifiedLoaded(get_last_mod_err, last_modified_iso) {
-                var old_mtime_iso;
-
-                if (get_last_mod_err) {
-                    log.error({
-                        err: get_last_mod_err,
-                        zonename: zonename
-                    }, 'Error when getting last_modified for zone');
-                    // We couldn't find the last modified time for this zone,
-                    // the VM probably disappeared, so we're removing it from
-                    // the cache.
-                    self.purgeZoneCache(zonename);
-                    cb(null, false);
-                    return;
-                }
-
-                // We just retrieved the last modified time for the zone, which
-                // means it exists, so we really should have
-                // self.zones[zonename].
-                assert.object(self.zones[zonename],
-                    'self.zones[' + zonename + ']');
-
-                old_mtime_iso = self.zones[zonename].last_modified;
-                assert.string(old_mtime_iso, 'old_mtime_iso');
-                assert.string(last_modified_iso, 'last_modified_iso');
-
-                log.info({
-                    old_mtime_ms: old_mtime_iso,
-                    last_modified_ms: last_modified_iso,
-                    zonename: zonename
-                }, 'old last_modified vs newly-loaded last_modifed for zone');
-
-                if (last_modified_iso > old_mtime_iso) {
-                    log.info({zonename: zonename},
-                        'last_modified was updated, reloading');
-                    cb(null, true);
-                    return;
-                }
-
-                log.trace('using cache for: ' + zonename);
-                cb(null, false);
-            });
-    }
-
-    shouldLoad(function (err, load) {
-        var start_lookup_timer = newTimer();
-
-        // fail open (meaning: force reload) when something went wrong
-        if (load || err) {
-            VM.lookup({ zonename: zonename }, { fields: sdc_fields },
-                function (error, machines) {
-                    var elapsed = elapsedTimer(start_lookup_timer);
-
-                    if (!error) {
-                        self.zones[zonename] = machines[0];
-                        self.addDebug(zonename, 'last_zone_load');
-                    }
-                    log.debug({
-                        elapsed: elapsed,
-                        err: error,
-                        zonename: zonename
-                    }, 'finished VM.lookup');
-                    callback(error);
-                    return;
-                }
-            );
-        } else {
-            // no need to reload since there's no change, use existing data
-            callback();
+        if (self.zoneConnections[zonename]) {
+            cb();
             return;
         }
-    });
-};
 
-MetadataAgent.prototype.createServersOnExistingZones = function () {
-    var self = this;
-    var created = 0;
-
-    VM.lookup({}, { fields: sdc_fields }, function (error, zones) {
-        async.forEach(zones, function (zone, cb) {
-            if (zone.zonename === 'global') {
+        if (vm.brand === 'kvm' || vm.brand === 'bhyve') {
+            // For KVM, the zone must be running otherwise Qemu will not
+            // have created a socket.
+            if (vm.zone_state !== 'running') {
+                self.log.debug('skipping non-running vm %s, zone_state %s',
+                    zonename, vm.zone_state);
                 cb();
                 return;
             }
 
-            self.zones[zone.zonename] = zone;
-            self.addDebug(zone.zonename, 'last_zone_load');
-
-            if (error) {
-                throw error;
-            }
-
-            if (!self.zlog[zone.zonename]) {
-                // create a logger specific to this VM
-                self.createZoneLog(zone.brand, zone.zonename);
-            }
-
-            // It is possible for VM.lookup() to take a long time. While we're
-            // waiting for it, the watcher could have seen the zone creation and
-            // created a socket for the zone. In case that happened, we ignore
-            // zones we've already got a connection for.
-            if (self.zoneConnections[zone.zonename]) {
+            self.startKVMSocketServer(zonename, function (err) {
+                if (!err) {
+                    created++;
+                }
                 cb();
-                return;
-            }
-
-            if (zone.brand === 'kvm' || zone.brand === 'bhyve') {
-
-                // For KVM, the zone must be running otherwise Qemu will not
-                // have created a socket.  A similar situation exists for bhyve.
-                if (zone.zone_state !== 'running') {
-                    self.log.debug('skipping zone ' + zone.zonename
-                        + ' which has ' + 'non-running zone_state: '
-                        + zone.zone_state);
-                    cb();
-                    return;
+            });
+        } else {
+            self.startZoneSocketServer(zonename, function (err) {
+                if (!err) {
+                    created++;
                 }
-
-                self.startKVMSocketServer(zone.zonename, function (err) {
-                    if (!err) {
-                        created++;
-                    }
-                    cb();
-                });
-            } else {
-                self.startZoneSocketServer(zone.zonename, function (err) {
-                    if (!err) {
-                        created++;
-                    }
-                    cb();
-                });
-            }
-        }, function (err) {
-            self.log.info('created zone metadata sockets on %d / %d zones',
-                created, zones.length);
-        });
+                cb();
+            });
+        }
+    }, function (err) {
+        self.log.info('created zone metadata sockets on %d / %d zones',
+            created, keys.length);
     });
 };
 
 MetadataAgent.prototype.purgeZoneCache = function purgeZoneCache(zonename) {
-    assert.string(zonename);
-
     var self = this;
 
+    assert.string(zonename, 'zonename');
+
     self.log.info(zonename + ' no longer exists, purging from cache(s) and '
         + 'stopping timeout');
 
     if (self.zonesDebug.hasOwnProperty(zonename)) {
         delete self.zonesDebug[zonename];
     }
+
     if (self.zlog.hasOwnProperty(zonename)) {
         delete self.zlog[zonename];
     }
+
     if (self.zoneConnections.hasOwnProperty(zonename)) {
         if (self.zoneConnections[zonename]) {
             // it's not undefined, so attempt to close it
             closeZoneConnection(self.zoneConnections[zonename]);
         }
+
         delete self.zoneConnections[zonename];
     }
-    if (self.zones.hasOwnProperty(zonename)) {
-        delete self.zones[zonename];
-    }
 };
 
 MetadataAgent.prototype.stopKvmReconnTimer =
@@ -564,277 +354,124 @@ function stopKvmReconnTimer(zonename) {
     }
 };
 
-MetadataAgent.prototype.checkMissedSysevents = function checkMissedSysevents() {
-    var self = this;
-    var start_kstat_timer = newTimer();
-
-    // Reminder: getZoneinfo only returns *running* zones since it pulls its
-    // data from the kernel.
-    getZoneinfo(null, {log: self.log}, function (err, results) {
-        assert.ifError(err);
-
-        function _assumeCreated(zonename) {
-            self.addDebug(zonename, 'last_zone_found_existing');
-            self.handleZoneCreated(zonename);
-        }
-
-        self.log.debug({
-            elapsed: elapsedTimer(start_kstat_timer),
-            zoneCount: Object.keys(results).length
-        }, 'loaded VM kstats');
-
-        Object.keys(results).forEach(function _checkZoneConn(zonename) {
-            var zoneConn = self.zoneConnections[zonename]; // may be undefined
-
-            if (!zoneConn) {
-                // If we have no zoneConn, It's likely we failed a previous
-                // attempt to create one. In any case, since the zone does exist
-                // (it's in getZoneinfo) we should attempt to create a new
-                // socket for it.
-                self.log.warn({zonename: zonename}, 'zone is missing '
-                    + 'zoneConnections entry, (re)trying socket creation');
-                _assumeCreated(zonename);
-                return;
-            }
-        });
-
-        // We expect the VMs in self.zoneKvmReconnTimers to be 'running', since
-        // we're actively retrying connections to their ttyb sockets. If they
-        // went not-running unexpectedly, kill the retries.
-        Object.keys(self.zoneKvmReconnTimers).forEach(
-            function _checkTimer(zonename) {
-                if (!results.hasOwnProperty(zonename)) {
-                    self.log.warn({zonename: zonename}, 'was reconnecting for '
-                        + 'KVM zone, but it is no longer running.');
-                    self.stopKvmReconnTimer(zonename);
-
-                    // Also remove the zoneConnections entry so that the
-                    // connection will be recreated when we notice it going
-                    // running. See "The rules for zoneConnections" above.
-                    delete self.zoneConnections[zonename];
-                }
-            }
-        );
-    });
-};
-
-MetadataAgent.prototype.startPeriodicChecks = function startPeriodicChecks() {
+MetadataAgent.prototype.handleZoneCreated =
+function handleZoneCreated(vm) {
     var self = this;
 
-    // Every 5 minutes we check to see whether zones we've got in self.zones
-    // were deleted. If they are, we delete the record from the cache and close
-    // any open connection.
+    assert.object(vm, 'vm');
+    assert.string(vm.zonename, 'vm.zonename');
+    assert.string(vm.brand, 'vm.brand');
 
-    function _checkDeletedZones() {
-        var cmd = '/usr/sbin/zoneadm';
-        var start_zoneadm_timer = newTimer();
-
-        execFile(cmd, ['list', '-c'], function (err, stdout, stderr) {
-            var elapsed = elapsedTimer(start_zoneadm_timer);
-            var zones = {};
-
-            if (err) {
-                self.log.error({
-                    elapsed: elapsed,
-                    err: err
-                }, 'unable to get list of zones');
-                return;
-            }
-
-            // each output line is a zonename, so we turn this into an object
-            // that looks like:
-            //
-            // {
-            //   zonename: true,
-            //   zonename: true
-            //   ...
-            // }
-            //
-            // so we can then loop through all the cached zonenames and remove
-            // those that don't exist on the system any longer.
-            stdout.trim().split(/\n/).forEach(function (z) {
-                if (z !== 'global') {
-                    zones[z] = true;
-                }
-            });
-
-            self.log.debug({
-                elapsed: elapsed,
-                zonesFound: Object.keys(zones).length
-            }, 'loaded zoneadm list of existing zones');
-
-            Object.keys(self.zones).forEach(function (z) {
-                if (!zones.hasOwnProperty(z)) {
-                    self.purgeZoneCache(z);
-                }
-            });
-
-            // schedule the next check
-            setTimeout(_checkDeletedZones, ZONEADM_CHECK_FREQUENCY);
-        });
+    if (!self.zlog[vm.zonename]) {
+        // create a logger specific to this VM
+        self.createZoneLog(vm.brand, vm.zonename);
     }
 
-    // Here we check for boot messages that we might have missed due to the fact
-    // that sysevent messages are unreliable.
-
-    function _checkNewZones() {
-        self.checkMissedSysevents();
-
-        // schedule the next check
-        setTimeout(_checkNewZones, MISSED_SYSEVENT_CHECK_FREQUENCY);
+    if (vm.brand === 'kvm' || vm.brand === 'bhyve') {
+        self.startKVMSocketServer(vm.zonename, noop);
+    } else {
+        self.startZoneSocketServer(vm.zonename, noop);
     }
-
-    // Set the first timers to kick these checks off.
-
-    setTimeout(_checkDeletedZones, ZONEADM_CHECK_FREQUENCY);
-    self.log.info('Setup timer to purge deleted zones every %d ms',
-        ZONEADM_CHECK_FREQUENCY);
-
-    setTimeout(_checkNewZones, MISSED_SYSEVENT_CHECK_FREQUENCY);
-    self.log.info('Setup timer to detect (missed) new zones every %d ms',
-        MISSED_SYSEVENT_CHECK_FREQUENCY);
 };
 
-MetadataAgent.prototype.handleZoneCreated =
-function handleZoneCreated(zonename) {
-    assert.string(zonename, 'zonename');
+MetadataAgent.prototype.start = function start() {
     var self = this;
 
-    // We don't wait around for results from creating the sockets because on
-    // failure self.startKVMSocketServer or self.startZoneSocketServer should
-    // leave us in a place we can retry on the next periodic check. So we just
-    // pass this dummy callback instead.
-    function _dummyCb() {
-    }
+    self.vminfod_watcher = new VminfodWatcher({
+        log: self.log,
+        name: 'Metadata Agent - VminfodWatcher'
+    });
 
-    self.updateZone(zonename, {}, function (error) {
-        if (error) {
-            self.log.error({err: error}, 'Error updating '
-                + 'attributes: ' + error.message);
+    self.vminfod_watcher.once('ready', function (ready_ev) {
+        var vms = self.vminfod_watcher.vms();
+        self.createServersOnExistingZones(vms);
+    });
 
-            // When there's an error, we'll have not set in self.zones, so we'll
-            // try again next time we see that the zone is running.
+    self.vminfod_watcher.on('create', function (ev) {
+        // ignore zones we've already (still) got a connection for
+        if (self.zoneConnections[ev.zonename]) {
             return;
         }
 
-        // If the zone was not deleted between the time we saw it start and
-        // now, (we did a vmadm lookup in between via updateZone which could
-        // have taken a while) we'll start the watcher.
-        if (self.zones[zonename]) {
-            if (!self.zlog[zonename]) {
-                // create a logger specific to this VM
-                self.createZoneLog(self.zones[zonename].brand, zonename);
-            }
+        self.log.debug({
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw new zone');
 
-            if (self.zones[zonename].brand === 'kvm'
-                || self.zones[zonename].brand === 'bhyve') {
-                self.startKVMSocketServer(zonename, _dummyCb);
-            } else {
-                self.startZoneSocketServer(zonename, _dummyCb);
-            }
-        }
+        self.addDebug(ev.zonename, 'last_zone_create');
+        self.handleZoneCreated(ev.vm);
     });
-};
 
-MetadataAgent.prototype.start = function start() {
-    var self = this;
-    var zwatch = this.zwatch = new ZWatch(self.log);
-    self.createServersOnExistingZones();
-    self.startPeriodicChecks();
+    self.vminfod_watcher.on('delete', function (ev) {
+        // when a zone was deleted, cleanup any cached stuff for it
+        self.log.debug({
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw zone deletion');
 
-    zwatch.on('zone_transition', function (msg) {
-        var when = new Date(msg.when / 1000000);
+        self.purgeZoneCache(ev.zonename);
+    });
 
-        // when a zone was deleted, cleanup any cached stuff for it
-        if (msg.cmd === 'delete') {
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw zone deletion');
-
-            self.purgeZoneCache(msg.zonename);
+    self.vminfod_watcher.on('modify', function (ev) {
+        var state;
+
+        /*
+         * For non-KVM and non-bhyve, we only care about create/delete since
+         * the socket only needs to be created once for these zones. For KVM
+         * however, the qemu process recreates the socket on every boot, so we
+         * want to catch 'start' events for KVM to ensure we connect to
+         * metadata as soon as possible.
+         */
+        if (ev.vm.brand !== 'kvm' && ev.vm.brand !== 'bhyve') {
             return;
         }
 
-        // For non-KVM and non-bhyve, we only care about create/delete since the
-        // socket only needs to be created once for these zones. For KVM and
-        // bhyve however, the qemu or zhyve process recreates the socket on
-        // every boot, so we want to catch 'start' events for KVM or zhyve to
-        // ensure we connect to metadata as soon as possible.
-        if (msg.cmd === 'start' && self.zones.hasOwnProperty(msg.zonename)
-            && (self.zones[msg.zonename].brand === 'kvm'
-            || self.zones[msg.zonename].brand === 'bhyve')) {
-            // KVM or bhyve VM started
-
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw KVM zone start');
-
-            self.addDebug(msg.zonename, 'last_zone_start');
-
-            // The "zone" wasn't technically created here, but the socket was
-            // (by qemu) so as far as we're concerned this is the same thing.
-            self.handleZoneCreated(msg.zonename);
+        // Find state transition
+        state = ev.changes.filter(function (change) {
+            return (change.path.length === 1 && change.path[0] === 'state');
+        });
+        if (state.length !== 1) {
             return;
         }
+        state = state[0];
 
         // If a KVM zone stops while we're trying to reconnect to its metadata
         // socket, stop trying to reconnect.
-        if (msg.cmd === 'stop'
-            && self.zoneKvmReconnTimers.hasOwnProperty(msg.zonename)) {
+        if (state === 'stopped'
+            && self.zoneKvmReconnTimers.hasOwnProperty(ev.zonename)) {
 
-            self.log.debug({
-                delay: (new Date()).getTime() - when.getTime(), // in ms
-                when: when,
-                zonename: msg.zonename
-            }, 'ZWatch watcher saw retrying KVM zone stop');
-
-            self.stopKvmReconnTimer(msg.zonename);
+            self.stopKvmReconnTimer(ev.zonename);
 
             // Also remove the zoneConnections entry so that the
             // connection will be recreated when we notice it going
             // running. See "The rules for zoneConnections" above.
-            delete self.zoneConnections[msg.zonename];
-
-            return;
-        }
-
-        // ignore everything else except create
-        if (msg.cmd !== 'create') {
-            return;
+            delete self.zoneConnections[ev.zonename];
         }
 
-        // ignore zones we've already (still) got a connection for
-        if (self.zoneConnections[msg.zonename]) {
+        if (state !== 'running') {
             return;
         }
 
         self.log.debug({
-            delay: (new Date()).getTime() - when.getTime(), // in ms
-            when: when,
-            zonename: msg.zonename
-        }, 'ZWatch watcher saw new zone');
+            delay: (new Date()) - ev.date,
+            when: ev.date,
+            zonename: ev.zonename
+        }, 'VminfodWatcher saw KVM zone boot');
 
-        zoneExists(msg.zonename, function _zoneExists(_, exists) {
+        self.addDebug(ev.zonename, 'last_zone_start');
 
-            if (!exists) {
-                self.log.warn({transition: msg},
-                    'ignoring transition for zone that no longer exists');
-                return;
-            }
-
-            // we only handle create, so that's what this was
-            self.addDebug(msg.zonename, 'last_zone_create');
-            self.handleZoneCreated(msg.zonename);
-        });
+        // The "zone" wasn't technically created here, but the socket was
+        // (by qemu) so as far as we're concerned this is the same thing.
+        self.handleZoneCreated(ev.vm);
     });
 };
 
 MetadataAgent.prototype.stop = function () {
-    this.zwatch.stop();
+    var self = this;
+
+    self.vminfod_watcher.stop();
 };
 
 MetadataAgent.prototype.startKVMSocketServer = function (zonename, callback) {
@@ -842,23 +479,23 @@ MetadataAgent.prototype.startKVMSocketServer = function (zonename, callback) {
 
     assert.string(zonename, 'zonename');
     assert.func(callback, 'callback');
-    assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
-    assert.object(self.zlog[zonename], 'self.zlog[' + zonename + ']');
 
-    var vmobj = self.zones[zonename];
+    var vmobj = self.vminfod_watcher.vm(zonename);
     var zlog = self.zlog[zonename] || self.log;
+
+    assert.object(vmobj, 'vmobj');
+
     var sockpath = path.join(vmobj.zonepath, '/root/tmp/vm.ttyb');
 
     zlog.trace('starting socket server');
 
     async.waterfall([
         function (cb) {
-
             common.retryUntil(2000, 120000,
                 function (c) {
                     var err;
 
-                    if (!self.zones[zonename]) {
+                    if (!self.vminfod_watcher.vm(zonename)) {
                         // zone was removed, no need to retry any further
                         err = new Error('zone no longer exists');
                         err.code = 'ENOENT';
@@ -909,7 +546,7 @@ MetadataAgent.prototype.createKVMServer = function (zopts, callback) {
     zlog = self.zlog[zopts.zone] || self.log;
 
     // Ignore zones that have been removed
-    if (!self.zones[zopts.zone]) {
+    if (!self.vminfod_watcher.vm(zopts.zone)) {
         zlog.trace({zonename: zopts.zone},
             'not creating kvm socket for zone that does not exist');
         callback();
@@ -1056,11 +693,11 @@ MetadataAgent.prototype.startZoneSocketServer =
 function startZoneSocketServer(zonename, callback) {
     var self = this;
 
-    assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
-    assert.string(self.zones[zonename].brand,
-        'self.zones[' + zonename + '].brand');
-    assert.string(self.zones[zonename].zonepath,
-        'self.zones[' + zonename + '].zonepath');
+    var vmobj = self.vminfod_watcher.vm(zonename);
+
+    assert.object(vmobj, 'vmobj');
+    assert.string(vmobj.brand, 'vmobj.brand');
+    assert.string(vmobj.zonepath, 'vmobj.zonename');
     assert.func(callback, 'callback');
 
     var zlog = self.zlog[zonename] || self.log;
@@ -1089,7 +726,7 @@ function createZoneSocket(zopts, callback) {
     var zlog = self.zlog[zopts.zone] || self.log;
     var zonecontrol = path.dirname(zopts.path);
 
-    if (!self.zones[zopts.zone]) {
+    if (!self.vminfod_watcher.vm(zopts.zone)) {
         zlog.info({zonename: zopts.zone},
             'zone no longer exists, not creating socket');
         callback();
@@ -1257,9 +894,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
     };
 
     return function _metadataHandler(data) {
-        // ensure sanity: we should only get metadata request for existing zones
-        assert.object(self.zones[zone], 'self.zones[' + zone + ']');
-
         var cmd;
         var ns;
         var parts;
@@ -1271,6 +905,11 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
         var vmobj;
         var want;
 
+        vmobj = self.vminfod_watcher.vm(zone);
+
+        // ensure sanity: we should only get metadata request for existing zones
+        assert.object(vmobj, 'vmobj');
+
         parts = data.toString().trimRight().replace(/\n$/, '')
             .match(/^([^\s]+)\s?(.*)/);
 
@@ -1292,8 +931,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
             return;
         }
 
-        vmobj = self.zones[zone];
-
         // Unbox V2 protocol frames:
         if (cmd === 'V2') {
             if (!parse_v2_request(want))
@@ -1318,251 +955,137 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                 // that depends on it, please add a note about that here
                 // otherwise expect it will be removed on you sometime.
                 if (want === 'nics' && vmobj.hasOwnProperty('nics')) {
-                    self.updateZone(zone, {}, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].nics);
-                        } else {
-                            val = JSON.stringify(vmobj.nics);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+
+                    val = JSON.stringify(vmobj.nics);
+                    returnit(null, val);
+
                 } else if (want === 'resolvers'
                     && vmobj.hasOwnProperty('resolvers')) {
 
-                    // resolvers, nics and routes are special because we might
-                    // reload metadata trying to get the new ones w/o zone
-                    // reboot. To ensure these are fresh we always run
-                    // updateZone which reloads the data if stale.
-                    self.updateZone(zone, {}, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        // See NOTE above about nics, same applies to resolvers.
-                        // It's here solely for the use of mdata-fetch.
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].resolvers);
-                        } else {
-                            val = JSON.stringify(vmobj.resolvers);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+                    val = JSON.stringify(vmobj.resolvers);
+                    returnit(null, val);
+
                 } else if (want === 'tmpfs'
                     && vmobj.hasOwnProperty('tmpfs')) {
-                    // We want tmpfs to reload the cache right away because we
-                    // might be depending on a /etc/vfstab update
-                    self.updateZone(zone, {}, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-                        if (self.zones[zone]) {
-                            val = JSON.stringify(self.zones[zone].tmpfs);
-                        } else {
-                            val = JSON.stringify(vmobj.tmpfs);
-                        }
-                        returnit(null, val);
-                        return;
-                    });
+
+                    val = JSON.stringify(vmobj.tmpfs);
+                    returnit(null, val);
+
                 } else if (want === 'routes'
                     && vmobj.hasOwnProperty('routes')) {
 
                     var vmRoutes = [];
 
-                    /*
-                     * Always reload the information about the zone, including
-                     * its routes, so that the instance can have the most up to
-                     * date information about them when it sets static routes.
-                     * This should not have a significant performance impact
-                     * since the sdc:routes metadata information is queried only
-                     * once at boot time, and we don't expect users to query
-                     * that information frequently. Using the last modified time
-                     * of the zones cache to compare it with the last modified
-                     * time of the routes.json zone configuration file would not
-                     * allow us to determine when to use the cache and when to
-                     * reload the zone's information because with node v0.10.x,
-                     * which is the version used by vmadm, fs.stat's output
-                     * resolution is 1 second. Any change to the routes
-                     * information happening in the same second as the previous
-                     * change to a zone configuration would not trigger a
-                     * reload. We could write a binary add-on to handle that,
-                     * but it seems it would introduce a lot of complexity for
-                     * no significant benefit. Hopefully we can move to node
-                     * v0.12.x or later at some point and rely on a better
-                     * resolution for fs.*stat APIs.
-                     */
-                    self.updateZone(zone, {
-                        forceReload: true
-                    }, function (error) {
-                        if (error) {
-                            // updating our cache for this VM failed, so we'll
-                            // use the existing data.
-                            zlog.error({err: error, zone: zone},
-                                'Failed to reload vmobj using cached values');
-                        }
-
-                        if (self.zones[zone]) {
-                            vmobj = self.zones[zone];
+                    // The notes above about resolvers also to routes. It's
+                    // here solely for the use of mdata-fetch, and we need
+                    // to do the updateZone here so that we have latest
+                    // data.
+                    for (var r in vmobj.routes) {
+                        var gateway;
+                        var foundNic = null;
+                        var route = { linklocal: false, dst: r };
+                        var mac;
+                        var macMatch = vmobj.routes[r]
+                            .match(/^macs\[(.+)\]$/);
+                        var nicMac;
+                        var nicIdx = vmobj.routes[r]
+                            .match(/^nics\[(\d+)\]$/);
+
+                        if (!nicIdx && !macMatch) {
+                            // Non link-local route: we have all the
+                            // information we need already
+                            route.gateway = vmobj.routes[r];
+                            vmRoutes.push(route);
+                            continue;
                         }
 
-                        // The notes above about resolvers also to routes. It's
-                        // here solely for the use of mdata-fetch, and we need
-                        // to do the updateZone here so that we have latest
-                        // data.
-                        for (var r in vmobj.routes) {
-                            var gateway;
-                            var foundNic = null;
-                            var route = { linklocal: false, dst: r };
-                            var mac;
-                            var macMatch = vmobj.routes[r]
-                                .match(/^macs\[(.+)\]$/);
-                            var nicMac;
-                            var nicIdx = vmobj.routes[r]
-                                .match(/^nics\[(\d+)\]$/);
-
-                            if (!nicIdx && !macMatch) {
-                                // Non link-local route: we have all the
-                                // information we need already
-                                route.gateway = vmobj.routes[r];
-                                vmRoutes.push(route);
+                        if (macMatch) {
+                            try {
+                                mac = macaddr.parse(macMatch[1]);
+                            } catch (parseErr) {
+                                zlog.warn(parseErr, 'failed to parse mac'
+                                    + ' addr');
                                 continue;
                             }
 
-                            if (macMatch) {
+                            if (!vmobj.hasOwnProperty('nics'))
+                                continue;
+
+                            // Link-local route: we need the IP of the
+                            // local nic with the provided mac address
+                            for (var i = 0; i < vmobj.nics.length; i++) {
                                 try {
-                                    mac = macaddr.parse(macMatch[1]);
+                                    nicMac = macaddr.parse(vmobj.nics[i]
+                                        .mac);
                                 } catch (parseErr) {
-                                    zlog.warn(parseErr, 'failed to parse mac'
-                                        + ' addr');
+                                    zlog.warn(parseErr, 'failed to parse'
+                                        + ' nic mac addr');
                                     continue;
                                 }
-
-                                if (!vmobj.hasOwnProperty('nics'))
-                                    continue;
-
-                                // Link-local route: we need the IP of the
-                                // local nic with the provided mac address
-                                for (var i = 0; i < vmobj.nics.length; i++) {
-                                    try {
-                                        nicMac = macaddr.parse(vmobj.nics[i]
-                                            .mac);
-                                    } catch (parseErr) {
-                                        zlog.warn(parseErr, 'failed to parse'
-                                            + ' nic mac addr');
-                                        continue;
-                                    }
-                                    if (nicMac.compare(mac) === 0) {
-                                        foundNic = vmobj.nics[i];
-                                        break;
-                                    }
+                                if (nicMac.compare(mac) === 0) {
+                                    foundNic = vmobj.nics[i];
+                                    break;
                                 }
+                            }
 
-                                if (!foundNic || !foundNic.hasOwnProperty('ip')
-                                    || foundNic.ip === 'dhcp') {
-
-                                    continue;
-                                }
+                            if (!foundNic || !foundNic.hasOwnProperty('ip')
+                                || foundNic.ip === 'dhcp') {
 
-                                gateway = foundNic.ip;
+                                continue;
+                            }
 
-                            } else {
-                                nicIdx = Number(nicIdx[1]);
+                            gateway = foundNic.ip;
 
-                                // Link-local route: we need the IP of the
-                                // local nic
-                                if (!vmobj.hasOwnProperty('nics')
-                                    || !vmobj.nics[nicIdx]
-                                    || !vmobj.nics[nicIdx].hasOwnProperty('ip')
-                                    || vmobj.nics[nicIdx].ip === 'dhcp') {
+                        } else {
+                            nicIdx = Number(nicIdx[1]);
 
-                                    continue;
-                                }
+                            // Link-local route: we need the IP of the
+                            // local nic
+                            if (!vmobj.hasOwnProperty('nics')
+                                || !vmobj.nics[nicIdx]
+                                || !vmobj.nics[nicIdx].hasOwnProperty('ip')
+                                || vmobj.nics[nicIdx].ip === 'dhcp') {
 
-                                gateway = vmobj.nics[nicIdx].ip;
+                                continue;
                             }
 
-                            assert.string(gateway, 'gateway');
-                            route.gateway = gateway;
-                            route.linklocal = true;
-                            vmRoutes.push(route);
+                            gateway = vmobj.nics[nicIdx].ip;
                         }
 
-                        returnit(null, JSON.stringify(vmRoutes));
-                        return;
-                    });
-                } else if (want === 'operator-script') {
-                    addMetadata(function (err) {
-                        if (err) {
-                            returnit(new Error('Unable to load metadata: '
-                                + err.message));
-                            return;
-                        }
+                        assert.string(gateway, 'gateway');
+                        route.gateway = gateway;
+                        route.linklocal = true;
+                        vmRoutes.push(route);
+                    }
 
-                        returnit(null,
-                            vmobj.internal_metadata['operator-script']);
-                        return;
-                    });
+                    returnit(null, JSON.stringify(vmRoutes));
+                } else if (want === 'operator-script') {
+                    returnit(null, vmobj.internal_metadata['operator-script']);
                 } else if (want === 'volumes') {
-                    addMetadata(function returnVolumes(err) {
-                        if (err) {
-                            returnit(new Error('Unable to load metadata: '
-                                + err.message));
-                            return;
-                        }
-
-                        returnit(null,
-                            vmobj.internal_metadata['sdc:volumes']);
-                        return;
-                    });
+                    returnit(null, vmobj.internal_metadata['sdc:volumes']);
                 } else {
-                    addTags(function (err) {
-                        if (!err) {
-                            val = VM.flatten(vmobj, want);
-                        }
-                        returnit(err, val);
-                        return;
-                    });
+                    val = VM.flatten(vmobj, want);
+                    returnit(null, val);
                 }
             } else {
-                // not sdc:, so key will come from *_mdata
-                addMetadata(function (err) {
-                    var which_mdata = 'customer_metadata';
+                var which_mdata = 'customer_metadata';
 
-                    if (err) {
-                        returnit(new Error('Unable to load metadata: '
-                            + err.message));
-                        return;
-                    }
-
-                    if (want.match(/_pw$/)) {
-                        which_mdata = 'internal_metadata';
-                    }
+                if (want.match(/_pw$/)) {
+                    which_mdata = 'internal_metadata';
+                }
 
-                    if (internalNamespace(vmobj, want) !== null) {
-                        which_mdata = 'internal_metadata';
-                    }
+                if (internalNamespace(vmobj, want) !== null) {
+                    which_mdata = 'internal_metadata';
+                }
 
-                    if (vmobj.hasOwnProperty(which_mdata)) {
-                        returnit(null, vmobj[which_mdata][want]);
-                        return;
-                    } else {
-                        returnit(new Error('Zone did not contain '
-                            + which_mdata));
-                        return;
-                    }
-                });
+                if (vmobj.hasOwnProperty(which_mdata)) {
+                    returnit(null, vmobj[which_mdata][want]);
+                    return;
+                } else {
+                    returnit(new Error('Zone did not contain '
+                        + which_mdata));
+                    return;
+                }
             }
         } else if (!req_is_v2 && cmd === 'NEGOTIATE') {
             if (want === 'V2') {
@@ -1647,37 +1170,28 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
 
             return;
         } else if (cmd === 'KEYS') {
-            addMetadata(function (err) {
-                var ckeys = [];
-                var ikeys = [];
-
-                if (err) {
-                    returnit(new Error('Unable to load metadata: '
-                        + err.message));
-                    return;
-                }
-
-                /*
-                 * Keys that match *_pw$ and internal_metadata_namespace
-                 * prefixed keys come from internal_metadata, everything else
-                 * comes from customer_metadata.
-                 */
-                ckeys = Object.keys(vmobj.customer_metadata)
-                    .filter(function (k) {
-
-                    return (!k.match(/_pw$/)
-                        && internalNamespace(vmobj, k) === null);
-                });
-                ikeys = Object.keys(vmobj.internal_metadata)
-                    .filter(function (k) {
-
-                    return (k.match(/_pw$/)
-                        || internalNamespace(vmobj, k) !== null);
-                });
+            var ckeys = [];
+            var ikeys = [];
+
+            /*
+             * Keys that match *_pw$ and internal_metadata_namespace
+             * prefixed keys come from internal_metadata, everything else
+             * comes from customer_metadata.
+             */
+            ckeys = Object.keys(vmobj.customer_metadata)
+                .filter(function (k) {
+
+                return (!k.match(/_pw$/)
+                    && internalNamespace(vmobj, k) === null);
+            });
+            ikeys = Object.keys(vmobj.internal_metadata)
+                .filter(function (k) {
 
-                returnit(null, ckeys.concat(ikeys).join('\n'));
-                return;
+                return (k.match(/_pw$/)
+                    || internalNamespace(vmobj, k) !== null);
             });
+
+            returnit(null, ckeys.concat(ikeys).join('\n'));
         } else {
             zlog.error('Unknown command ' + cmd);
             returnit(new Error('Unknown command ' + cmd));
@@ -1707,92 +1221,6 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
             _cb(err);
         }
 
-        function addTags(cb) {
-            var cbOpts = {timer: newTimer(), loadFile: 'tags'};
-            var filename;
-
-            filename = vmobj.zonepath + '/config/tags.json';
-            fs.readFile(filename, function (err, file_data) {
-
-                if (err && err.code === 'ENOENT') {
-                    vmobj.tags = {};
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                    return;
-                }
-
-                if (err) {
-                    zlog.error({err: err}, 'failed to load tags.json: '
-                        + err.message);
-                    _callCbAndLogTimer(cbOpts, err, cb);
-                    return;
-                }
-
-                try {
-                    vmobj.tags = JSON.parse(file_data.toString());
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                } catch (e) {
-                    zlog.error({err: e}, 'unable to tags.json for ' + zone
-                        + ': ' + e.message);
-                    _callCbAndLogTimer(cbOpts, e, cb);
-                }
-
-                return;
-            });
-        }
-
-        function addMetadata(cb) {
-            var cbOpts = {timer: newTimer(), loadFile: 'metadata'};
-            var filename;
-
-            // If we got here, our answer comes from metadata so read that file.
-
-            // NOTE: In the future, if the fs.readFile overhead here ends up
-            // being larger than a stat would be, we might want to cache these
-            // and reload only when mtime changes.
-            //
-            // Alternatively: when OS-2647 lands we might just use vminfod.
-
-            filename = vmobj.zonepath + '/config/metadata.json';
-
-            fs.readFile(filename, function (err, file_data) {
-                var json = {};
-                var mdata_types = [ 'customer_metadata', 'internal_metadata' ];
-
-                // start w/ both empty, if we fail partway through there will
-                // just be no metadata instead of wrong metadata.
-                vmobj.customer_metadata = {};
-                vmobj.internal_metadata = {};
-
-                if (err && err.code === 'ENOENT') {
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                    return;
-                }
-
-                if (err) {
-                    zlog.error({err: err}, 'failed to load mdata.json: '
-                        + err.message);
-                    _callCbAndLogTimer(cbOpts, err, cb);
-                    return;
-                }
-
-                try {
-                    json = JSON.parse(file_data.toString());
-                    mdata_types.forEach(function (mdata) {
-                        if (json.hasOwnProperty(mdata)) {
-                            vmobj[mdata] = json[mdata];
-                        }
-                    });
-                    _callCbAndLogTimer(cbOpts, null, cb);
-                } catch (e) {
-                    zlog.error({err: e}, 'unable to load metadata.json for '
-                        + zone + ': ' + e.message);
-                    _callCbAndLogTimer(cbOpts, e, cb);
-                }
-
-                return;
-            });
-        }
-
         function setMetadata(_key, _value, cb) {
             var payload = {};
             var which = 'customer_metadata';
diff --git a/src/vm/lib/metadata/zwatch.js b/src/vm/lib/metadata/zwatch.js
deleted file mode 100644
index 0acfef20..00000000
--- a/src/vm/lib/metadata/zwatch.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2016 Joyent, Inc.
- */
-
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
-
-module.exports = ZWatch;
-
-function ZWatch(logger) {
-    var self = this;
-
-    // become an event emitter
-    EventEmitter.call(self);
-
-    // create a Sysevent event emitter
-    var opts = {
-        logger: logger,
-        class: 'status',
-        channel: 'com.sun:zones:status'
-    };
-    self.se = new SyseventStream(opts);
-    self.se.on('readable', function () {
-        var ev;
-        while ((ev = self.se.read()) !== null) {
-            var data = ev.data;
-            if (data.newstate === 'shutting_down'
-                && data.oldstate === 'running') {
-
-                data.cmd = 'stop';
-            } else if (data.newstate === 'running'
-                && data.oldstate === 'ready') {
-
-                data.cmd = 'start';
-            } else if (data.newstate === 'configured' && data.oldstate === '') {
-                data.cmd = 'create';
-            } else if (data.oldstate === 'configured' && data.newstate === '') {
-                data.cmd = 'delete';
-            } else {
-                data.cmd = 'unknown';
-            }
-
-            self.emit('zone_transition', data);
-        }
-    });
-}
-util.inherits(ZWatch, EventEmitter);
-
-ZWatch.prototype.stop = function stop() {
-    return this.se.stop();
-};
diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index cd419449..b1620b1f 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -94,6 +94,18 @@ tab-complete UUIDs rather than having to type them out for every command.
         See the 'SNAPSHOTS' section below for some more details on how to use
         these snapshots, and their restrictions.
 
+      events [-fjr] [uuid]
+
+        Output events seen for a given VM (all VMs on the system if the uuid
+        argument is omitted).  The command will run indefinitely outputting a
+        single line per event to stdout as they are seen.
+
+          -f, --full    Output the full event (full zone names, timestamp,
+                        etc.)  No data will be truncated.
+          -j, --json    Output in JSON.  If `-j` is supplied `-f` is ignored.
+          -r, --ready   Output an extra event when the event stream is first
+                        opened and ready.
+
       get <uuid>
 
         Output the JSON object describing a VM. The JSON object will be dumped
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index ac43db55..63a97f43 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -50,6 +50,7 @@
  * stop(uuid, options={[force=true]}, callback)
  * sysrq(uuid, req=[nmi|screenshot], options={}, callback)
  * update(uuid, properties, callback)
+ * events(opts, handler, callback)
  *
  * Exported variables:
  *
@@ -69,19 +70,19 @@ require('/usr/node/node_modules/platform_node_version').assert();
 
 var assert = require('/usr/node/node_modules/assert-plus');
 var async = require('/usr/node/node_modules/async');
-var bunyan = require('/usr/node/node_modules/bunyan');
 var cp = require('child_process');
+var diff = require('/usr/vm/node_modules/diff');
 var dladm = require('/usr/vm/node_modules/dladm');
 var lock = require('/usr/vm/node_modules/locker').lock;
 var EventEmitter = require('events').EventEmitter;
 var exec = cp.exec;
 var execFile = cp.execFile;
-var expat = require('/usr/node/node_modules/node-expat');
 var fs = require('fs');
 var fw = require('/usr/fw/lib/fw');
 var fwlog = require('/usr/fw/lib/util/log');
 var http = require('http');
 var ipaddr = require('/usr/vm/node_modules/ip');
+var jsprim = require('/usr/vm/node_modules/jsprim');
 var libuuid = require('/usr/node/node_modules/uuid');
 var macaddr = require('/usr/vm/node_modules/macaddr');
 var mkdirp = require('/usr/vm/node_modules/mkdirp');
@@ -93,11 +94,11 @@ var properties = require('./props');
 var Qmp = require('/usr/vm/node_modules/qmp').Qmp;
 var spawn = cp.spawn;
 var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var tty = require('tty');
 var util = require('util');
 var utils = require('./utils');
 var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmload = require('vmload');
 var zonecfg = require('/usr/vm/node_modules/zonecfg');
 
@@ -121,25 +122,6 @@ exports.FLATTENABLE_ARRAY_HASH_KEYS = FLATTENABLE_ARRAY_HASH_KEYS;
 exports.FLATTENABLE_HASH_KEYS = FLATTENABLE_HASH_KEYS;
 exports.KVM_MEM_OVERHEAD = KVM_MEM_OVERHEAD;
 
-/*
- * Global handle for the zoneevent watcher
- *
- * Retaining a global (per-process in this case) zone watcher object ensures
- * that only one SyseventStream (and by extension, one instance of
- * sysevent(1M)) is running at a time.  If multiple zone watchers are needed,
- * they will use this global zone watcher object while the ref count is greater
- * than 0.  The stream will be torn down when the ref count hits 0,
- *
- * ref: the current reference count for zone watchers allocated
- * stream: the actual SyseventStream for watching sysevents
- *
- * See getZoneWatcher and freeZoneWatcher for more information
- */
-var zonewatcher = {
-    ref: 0,
-    stream: null
-};
-
 /*
  * zone states from libzonecfg/common/zonecfg_impl.h
  *
@@ -166,6 +148,7 @@ var PROVISION_TIMEOUT = 300;
 var SERVICE_RESTART_TIMEOUT = 60;
 var STOP_TIMEOUT = 60;
 var VM = this;
+var VMINFOD_TIMEOUT = 60 * 1000;
 
 
 VM.log = null;
@@ -191,6 +174,8 @@ var vrrpMAC = utils.vrrpMAC;
 // For keeping track of used trace names
 var trace_seen_names = {};
 
+function noop() {}
+
 // This function should be called by any exported function from this module.
 // It ensures that a logger is setup. If side_effects is true, we'll start
 // writing log messages to the file right away. If not, we'll only start
@@ -522,16 +507,17 @@ function getZpools(log, callback)
         if (error) {
             log.error('Unable to get list of zpools');
             callback(error, {'stdout': stdout, 'stderr': stderr});
-        } else {
-            // strip out any empty values (last one).
-            raw = stdout.split('\n');
-            for (idx in raw) {
-                if (raw[idx].length > 0) {
-                    zpools.push(raw[idx]);
-                }
+            return;
+        }
+
+        // strip out any empty values (last one).
+        raw = stdout.split('\n');
+        for (idx in raw) {
+            if (raw[idx].length > 0) {
+                zpools.push(raw[idx]);
             }
-            callback(null, zpools);
         }
+        callback(null, zpools);
     });
 }
 
@@ -861,28 +847,54 @@ function validateImage(image, log, callback)
 
 function createConfigDir(zonepath, log, cb) {
     var configDir = path.join(zonepath, 'config');
+    var files = [
+        'tags.json',
+        'metadata.json',
+        'routes.json'
+    ];
 
     /*
      * Zone images quite often contain the configuration of the zone
      * they were made from. We remove the old directory here so that
      * we don't accidentally end up using inherited files.
      */
-    traceExecFile('/bin/rm', [ '-rf', configDir ],
-        {}, log, 'rm-image-config', function (err) {
+    vasync.pipeline({funcs: [
+        function (_, cb2) {
+            log.debug('rm -rf %s', configDir);
+            traceExecFile('/bin/rm', ['-rf', configDir],
+                {}, log, 'rm-image-config', cb2);
+        }, function (_, cb2) {
+            /*jsl:ignore*/
+            var mode = 0755;
+            /*jsl:end*/
+
+            /*
+             * Now that any pre-existing directory is out of the way, create
+             * one for us to use:
+             */
+            log.debug('fs.mkdir(%s)', configDir);
+            fs.mkdir(configDir, mode, cb2);
+        }, function (_, cb2) {
+            /*
+             * Create skeleton files for the JSON config files.
+             */
+            vasync.forEachParallel({
+                inputs: files,
+                func: function (f, cb3) {
+                    f = path.join(configDir, f);
+                    log.debug('Writing empty metadata file %s', f);
+                    fs.writeFile(f, '{}\n', cb3);
+                }
+            }, cb2);
+        }
+    ]}, function (err) {
         if (err) {
+            log.error({err: err}, 'createConfigDir %s failed', zonepath);
             cb(err);
             return;
         }
 
-        /*jsl:ignore*/
-        var mode = 0755;
-        /*jsl:end*/
-
-        /*
-         * Now that any pre-existing directory is out of the way, create
-         * one for us to use:
-         */
-        fs.mkdir(configDir, mode, cb);
+        cb();
     });
 }
 
@@ -1349,9 +1361,10 @@ function setQuota(opts, callback)
         if (err) {
             log.error('setQuota() cmd failed: ' + fds.stderr);
             callback(new Error(rtrim(fds.stderr)));
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -1436,6 +1449,9 @@ exports.load = function (uuid, options, callback)
     if (options.hasOwnProperty('fields')) {
         load_opts.fields = options.fields;
     }
+    if (options.hasOwnProperty('loadManually')) {
+        load_opts.loadManually = options.loadManually;
+    }
 
     vmload.getVmobj(uuid, load_opts, function (err, vmobj) {
         if (err) {
@@ -1634,11 +1650,10 @@ exports.lookup = function (search, options, callback)
             transform(vmobj);
         }
         if (Object.keys(search).length === 0 || matcher(vmobj, search)) {
-            cb(true);
+            cb(null, true);
         } else {
-            cb(false);
+            cb(null, false);
         }
-        return;
     }
 
     lookup_opts = {log: log, fields: need_fields};
@@ -1723,9 +1738,9 @@ function checkDatasets(payload, log, callback)
                     'stderr': fds.stderr}, 'zfs list ' + dataset + ' '
                     + 'exited with' + ' code ' + err.code + ': ' + err.message);
                 cb(new Error('unable to find dataset: ' + dataset));
-            } else {
-                cb();
+                return;
             }
+            cb();
         });
     }
 
@@ -1735,10 +1750,9 @@ function checkDatasets(payload, log, callback)
             log.error(err, 'checkDatasets() failed to find required '
                 + 'volumes');
             callback(err);
-        } else {
-            // progress(100, 'we have all necessary datasets');
-            callback();
+            return;
         }
+        callback();
     });
 }
 
@@ -1799,7 +1813,7 @@ function lookupConflicts(macs, ips, ipNics, vrids, vnc_port, log, callback) {
         if (vm.state === 'failed' && vm.zone_state !== 'running') {
             // Ignore zones that are failed unless they're 'running' which they
             // shouldn't be because they get stopped on failure.
-            cb(false);
+            cb(null, false);
             return;
         }
 
@@ -1841,14 +1855,14 @@ function lookupConflicts(macs, ips, ipNics, vrids, vnc_port, log, callback) {
             conflict = true;
         }
 
-        cb(conflict);
+        cb(null, conflict);
     }, load_opts, function (err, results) {
         if (err) {
             callback(err);
-        } else {
-            log.debug('returning from conflict check');
-            callback(null, (results.length > 0) ? true : false);
+            return;
         }
+        log.debug('returning from conflict check');
+        callback(null, (results.length > 0) ? true : false);
     });
 }
 
@@ -2098,31 +2112,33 @@ function createVolume(volume, opts, callback)
     async.series([
         function (cb) {
             // Ensure we've got a snapshot if we're going to make a clone
-            if (volume.hasOwnProperty('image_uuid')) {
-                snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
-                zfs(['get', '-Ho', 'value', 'name', snapshot], log,
-                    function (err, fds) {
+            if (!volume.hasOwnProperty('image_uuid')) {
+                cb();
+                return;
+            }
 
-                    if (err) {
-                        if (fds.stderr.match('dataset does not exist')) {
-                            // no @final, so we'll make a new snapshot @<uuid>
-                            snapshot = volume.zpool + '/' + volume.image_uuid
-                                + '@' + volume.uuid;
+            snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
+            zfs(['get', '-Ho', 'value', 'name', snapshot], log,
+                function (err, fds) {
 
-                            zfs(['snapshot', snapshot], log, function (e) {
-                                cb(e);
-                            });
-                        } else {
-                            cb(err);
-                        }
+                if (err) {
+                    if (fds.stderr.match('dataset does not exist')) {
+                        // no @final, so we'll make a new snapshot @<uuid>
+                        snapshot = volume.zpool + '/' + volume.image_uuid
+                            + '@' + volume.uuid;
+
+                        zfs(['snapshot', snapshot], log, function (e) {
+                            cb(e);
+                        });
                     } else {
-                        // @final is here!
-                        cb();
+                        cb(err);
                     }
-                });
-            } else {
+                    return;
+                }
+
+                // @final is here!
                 cb();
-            }
+            });
         }, function (cb) {
             var args;
             var target;
@@ -2151,10 +2167,11 @@ function createVolume(volume, opts, callback)
                 zfs(args, log, function (e) {
                     if (e) {
                         cb(e);
-                    } else {
-                        volume.path = '/dev/zvol/rdsk/' + target;
-                        cb();
+                        return;
                     }
+
+                    volume.path = '/dev/zvol/rdsk/' + target;
+                    cb();
                 });
             } else {
                 // This volume is not from a template/dataset/image so we create
@@ -2175,10 +2192,11 @@ function createVolume(volume, opts, callback)
                 zfs(args, log, function (err, fds) {
                     if (err) {
                         cb(err);
-                    } else {
-                        volume.path = '/dev/zvol/rdsk/' + target;
-                        cb();
+                        return;
                     }
+
+                    volume.path = '/dev/zvol/rdsk/' + target;
+                    cb();
                 });
             }
         }
@@ -2385,26 +2403,27 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             if (error) {
                 if (error.code === 'ENOENT') {
                     _createEmptyFile(f, cb);
-                    return;
                 } else {
                     log.error({err: error}, 'failed to lstat ' + f);
                     cb(error);
-                    return;
                 }
+                return;
             }
 
             if (stats.isFile()) {
                 // it's a file! great. We can mount over it.
                 cb();
                 return;
-            } else if (stats.isSymbolicLink()) {
+            }
+
+            if (stats.isSymbolicLink()) {
                 fs.unlinkSync(f);
                 _createEmptyFile(f, cb);
-            } else {
-                log.error({stats: stats}, f + ' is not a file');
-                cb(new Error(f + ' is not a file'));
                 return;
             }
+
+            log.error({stats: stats}, f + ' is not a file');
+            cb(new Error(f + ' is not a file'));
         });
     }
 
@@ -2435,6 +2454,9 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
                     return;
                 }
 
+                log.debug({file: d.raw_filename, contents: d.contents},
+                    'wrote docker conf file: %s', d.raw_filename);
+
                 fake_payload.add_filesystems.push({
                     source: d.raw_filename,
                     target: d.filename,
@@ -2446,7 +2468,7 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             });
         });
     }, function (err) {
-        var zcfg;
+        var cancelFn;
 
         if (err) {
             callback(err);
@@ -2459,26 +2481,53 @@ function createHostConfFileMounts(vmobj, opts, log, callback) {
             return;
         }
 
-        zcfg = buildFilesystemZonecfg({}, fake_payload);
+        var vs = new vminfod.VminfodEventStream({
+            name: sprintf('VM.js createHostConfFileMounts (%s)', vmobj.uuid),
+            log: log
+        });
 
-        zonecfg(vmobj.uuid, [], {log: log, stdin: zcfg},
-            function (zcfg_err, fds) {
-                if (zcfg_err) {
-                    log.error({
-                        err: zcfg_err,
-                        zcfg: zcfg,
-                        stdout: fds.stdout,
-                        stderr: fds.stderr
-                    }, 'failed to modify zonecfg');
-                    callback(zcfg_err);
-                    return;
-                }
+        vs.once('ready', function () {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: vmobj.uuid,
+                        vm: {
+                            filesystems: fake_payload.add_filesystems
+                        }
+                    };
+                    var vs_opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        teardown: true,
+                        catchErrors: true
+                    };
 
-                log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                    'modified zonecfg');
-                callback();
-            }
-        );
+                    cancelFn = vs.watchForEvent(obj, vs_opts, cb2);
+                }, function (cb2) {
+                    var zcfg = buildFilesystemZonecfg({}, fake_payload);
+
+                    zonecfg(vmobj.uuid, [],
+                        {log: log, stdin: zcfg},
+                        function (zcfg_err, fds) {
+
+                        if (zcfg_err) {
+                            log.error({
+                                err: zcfg_err,
+                                zcfg: zcfg,
+                                stdout: fds.stdout,
+                                stderr: fds.stderr
+                            }, 'failed to modify zonecfg');
+                            cancelFn();
+                            cb2(zcfg_err);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'modified zonecfg');
+                        cb2();
+                    });
+                }]
+            }, callback);
+        });
     });
 }
 
@@ -2624,23 +2673,24 @@ function createFilesystems(payload, filesystems, log, callback)
         'creating filesystems');
 
     function _createParents(cb) {
-        if (create_volume_root) {
-            zfs([
-                'create',
-                payload.zfs_filesystem + '/volumes'
-            ], log, function (vols_err, vols_fds) {
-                if (vols_err
-                    && !vols_fds.stderr.match(/dataset already exists$/)) {
-
-                    cb(vols_err);
-                    return;
-                }
-
-                cb();
-            });
-        } else {
+        if (!create_volume_root) {
             cb();
+            return;
         }
+
+        zfs([
+            'create',
+            payload.zfs_filesystem + '/volumes'
+        ], log, function (vols_err, vols_fds) {
+            if (vols_err
+                && !vols_fds.stderr.match(/dataset already exists$/)) {
+
+                cb(vols_err);
+                return;
+            }
+
+            cb();
+        });
     }
 
     _createParents(function (error) {
@@ -2772,9 +2822,10 @@ function createVolumes(payload, log, callback)
             async.forEachSeries(createme, _loggedDeleteVolume, function () {
                 callback(err);
             });
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -2823,15 +2874,17 @@ function updateMetadata(vmobj, payload, log, callback)
     var imdata = {};
     var key;
     var mdata = {};
-    var mdata_filename;
     var needUpdate = false;
     var tags = {};
-    var tags_filename;
     var tracers_obj;
+    var uuid;
     var zonepath;
 
     assert(log, 'no logger passed to updateMetadata()');
 
+    uuid = vmobj.uuid || payload.uuid || vmobj.zonename || payload.zonename;
+    assert.uuid(uuid, 'uuid not found on "payload" or "vmobj"');
+
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('update-metadata', log, callback);
         callback = tracers_obj.callback;
@@ -2858,25 +2911,22 @@ function updateMetadata(vmobj, payload, log, callback)
         return;
     }
 
-    if (vmobj.hasOwnProperty('zonepath')) {
-        zonepath = vmobj.zonepath;
-    } else if (vmobj.hasOwnProperty('zpool')
-        && vmobj.hasOwnProperty('zonename')) {
-
-        zonepath = '/' + vmobj.zpool + '/' + vmobj.zonename;
-    } else {
-        callback(new Error('unable to find zonepath for '
-            + JSON.stringify(vmobj)));
+    try {
+        zonepath = calculateZonepath(vmobj);
+    } catch (e) {
+        log.error({err: e}, 'failed to calculate zonepath for %s', uuid);
+        callback(e);
         return;
     }
 
-    // paths are under zonepath but not zoneroot
-    mdata_filename = zonepath + '/config/metadata.json';
-    tags_filename = zonepath + '/config/tags.json';
-
     // customer_metadata
-    for (key in vmobj.customer_metadata) {
-        if (vmobj.customer_metadata.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('customer_metadata')
+        || payload.hasOwnProperty('set_customer_metadata')) {
+
+        for (key in vmobj.customer_metadata) {
+            if (!vmobj.customer_metadata.hasOwnProperty(key))
+                continue;
+
             cmdata[key] = vmobj.customer_metadata[key];
             if (payload.hasOwnProperty('remove_customer_metadata')
                 && payload.remove_customer_metadata.indexOf(key) !== -1) {
@@ -2885,17 +2935,25 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete cmdata[key];
             }
         }
-    }
 
-    for (key in payload.set_customer_metadata) {
-        if (payload.set_customer_metadata.hasOwnProperty(key)) {
+        for (key in payload.set_customer_metadata) {
+            if (!payload.set_customer_metadata.hasOwnProperty(key))
+                continue;
+
             cmdata[key] = payload.set_customer_metadata[key];
         }
+
+        mdata.customer_metadata = cmdata;
     }
 
     // internal_metadata
-    for (key in vmobj.internal_metadata) {
-        if (vmobj.internal_metadata.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('internal_metadata')
+        || payload.hasOwnProperty('set_internal_metadata')) {
+
+        for (key in vmobj.internal_metadata) {
+            if (!vmobj.internal_metadata.hasOwnProperty(key))
+                continue;
+
             imdata[key] = vmobj.internal_metadata[key];
             if (payload.hasOwnProperty('remove_internal_metadata')
                 && payload.remove_internal_metadata.indexOf(key) !== -1) {
@@ -2904,17 +2962,25 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete imdata[key];
             }
         }
-    }
 
-    for (key in payload.set_internal_metadata) {
-        if (payload.set_internal_metadata.hasOwnProperty(key)) {
+        for (key in payload.set_internal_metadata) {
+            if (!payload.set_internal_metadata.hasOwnProperty(key))
+                continue;
+
             imdata[key] = payload.set_internal_metadata[key];
         }
+
+        mdata.internal_metadata = imdata;
     }
 
     // same thing for tags
-    for (key in vmobj.tags) {
-        if (vmobj.tags.hasOwnProperty(key)) {
+    if (vmobj.hasOwnProperty('tags')
+        || payload.hasOwnProperty('set_tags')) {
+
+        for (key in vmobj.tags) {
+            if (!vmobj.tags.hasOwnProperty(key))
+                continue;
+
             tags[key] = vmobj.tags[key];
             if (payload.hasOwnProperty('remove_tags')
                 && payload.remove_tags.indexOf(key) !== -1) {
@@ -2923,26 +2989,19 @@ function updateMetadata(vmobj, payload, log, callback)
                 delete tags[key];
             }
         }
-    }
 
-    for (key in payload.set_tags) {
-        if (payload.set_tags.hasOwnProperty(key)) {
+        for (key in payload.set_tags) {
+            if (!payload.set_tags.hasOwnProperty(key))
+                continue;
+
             tags[key] = payload.set_tags[key];
         }
-    }
 
-    mdata = {'customer_metadata': cmdata, 'internal_metadata': imdata};
+        mdata.tags = tags;
+    }
 
-    async.series([
-        function (next) {
-            writeAndRename(log, 'metadata', mdata_filename,
-                JSON.stringify(mdata, null, 2), next);
-        },
-        function (next) {
-            writeAndRename(log, 'tags', tags_filename,
-                JSON.stringify(tags, null, 2), next);
-        }
-    ], callback);
+    writeAllMetadata(uuid, zonepath, mdata,
+        {log: log, skipLockfile: true}, callback);
 }
 
 function saveMetadata(payload, log, callback)
@@ -3000,15 +3059,18 @@ function saveMetadata(payload, log, callback)
 // writes a zone's metadata JSON to /zones/<uuid>/config/routes.json
 function updateRoutes(vmobj, payload, log, callback)
 {
-    var filename;
     var key;
     var needUpdate = false;
     var routes = {};
     var tracers_obj;
+    var uuid;
     var zonepath;
 
     assert(log, 'no logger passed to updateRoutes()');
 
+    uuid = vmobj.uuid || payload.uuid || vmobj.zonename || payload.zonename;
+    assert(uuid, 'uuid not found on "payload" or "vmobj"');
+
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('update-routes', log, callback);
         callback = tracers_obj.callback;
@@ -3031,48 +3093,36 @@ function updateRoutes(vmobj, payload, log, callback)
         return;
     }
 
-    if (vmobj.hasOwnProperty('zonepath')) {
-        zonepath = vmobj.zonepath;
-    } else if (vmobj.hasOwnProperty('zpool')
-        && vmobj.hasOwnProperty('zonename')) {
-
-        zonepath = '/' + vmobj.zpool + '/' + vmobj.zonename;
-    } else {
-        callback(new Error('unable to find zonepath for '
-            + JSON.stringify(vmobj)));
+    try {
+        zonepath = calculateZonepath(vmobj);
+    } catch (e) {
+        log.error({err: e}, 'failed to calculate zonepath for %s', uuid);
+        callback(e);
         return;
     }
 
-    // paths are under zonepath but not zoneroot
-    filename = zonepath + '/config/routes.json';
-
     for (key in vmobj.routes) {
-        if (vmobj.routes.hasOwnProperty(key)) {
-            routes[key] = vmobj.routes[key];
-            if (payload.hasOwnProperty('remove_routes')
-                && payload.remove_routes.indexOf(key) !== -1) {
+        if (!vmobj.routes.hasOwnProperty(key))
+            continue;
 
-                // in the remove_* list, don't load it.
-                delete routes[key];
-            }
+        routes[key] = vmobj.routes[key];
+        if (payload.hasOwnProperty('remove_routes')
+            && payload.remove_routes.indexOf(key) !== -1) {
+
+            // in the remove_* list, don't load it.
+            delete routes[key];
         }
     }
 
     for (key in payload.set_routes) {
-        if (payload.set_routes.hasOwnProperty(key)) {
-            routes[key] = payload.set_routes[key];
-        }
+        if (!payload.set_routes.hasOwnProperty(key))
+            continue;
+
+        routes[key] = payload.set_routes[key];
     }
 
-    fs.writeFile(filename, JSON.stringify(routes, null, 2),
-        function (err) {
-            if (err) {
-                callback(err);
-            } else {
-                log.debug('wrote routes to ' + filename);
-                callback();
-            }
-        });
+    writeAllMetadata(uuid, zonepath, {routes: routes},
+        {skipLockfile: true, log: log}, callback);
 }
 
 function saveRoutes(payload, log, callback)
@@ -3109,66 +3159,287 @@ function saveRoutes(payload, log, callback)
     updateRoutes(protovm, payload, log, callback);
 }
 
-function createVM(payload, log, callback)
-{
-    var created_zoneroot = false;
+function writeAllMetadata(uuid, zonepath, mdata, options, callback) {
+    var lockpath;
+    var log;
+    var needsUpdate = {};
+    var mdata_filename;
+    var routes_filename;
+    var toUpdate;
+    var tags_filename;
     var tracers_obj;
+    var unlock;
+    var vmobj;
+    var vs;
 
-    assert(log, 'no logger passed to createVM()');
+    assert.uuid(uuid, 'uuid');
+    assert.string(zonepath, 'zonepath');
+    assert.object(mdata, 'mdata');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+
+    log = options.log;
+    assert(log, 'log');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
-        tracers_obj = traceUntilCallback('createVM', log, callback);
+        tracers_obj = traceUntilCallback('writeAllMetadata', log,
+            callback);
         callback = tracers_obj.callback;
         log = tracers_obj.log;
     }
 
-    async.series([
-        function (cb) {
-            if (!payload.create_only) {
-                // progress(2, 'checking required datasets');
-                checkDatasets(payload, log, cb);
-            } else {
-                cb();
-            }
-        }, function _createZoneroot(cb) {
-            var args;
+    log.debug({mdata: mdata, uuid: uuid}, 'writeAllMetadata called');
 
-            if (payload.brand !== 'bhyve') {
+    lockpath = zoneConfigLockpath(uuid);
+    mdata_filename = zonepath + '/config/metadata.json';
+    routes_filename = zonepath + '/config/routes.json';
+    tags_filename = zonepath + '/config/tags.json';
+
+    // Short-circuit here if nothing needs to be changed
+    toUpdate = Object.keys(mdata);
+    if (toUpdate.length === 0) {
+        log.debug('No metadata modifications required');
+        callback();
+        return;
+    }
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // Acquire lockfile
+            if (options.skipLockfile) {
                 cb();
                 return;
             }
 
-            assert.number(payload.quota, 'payload.quota');
-            assert.uuid(payload.uuid, 'payload.uuid');
-            assert.string(payload.zpool, 'payload.zpool');
-
-            // For bhyve we want to create the zonepath dataset here since we
-            // want disks to be child datasets, e.g.:
-            //
-            //  zones/<uuid>/disk0
-            //
-            args = ['create', '-o', 'refquota=' + payload.quota + 'G',
-                payload.zpool + '/' + payload.uuid];
-
-            zfs(args, log, function _onZfsCreate(err) {
-                if (!err) {
-                    created_zoneroot = true;
+            log.debug('acquiring lock on %s', lockpath);
+            lock(lockpath, function (err, _unlock) {
+                if (err) {
+                    log.error('failed to acquire lock on %s', lockpath);
+                    cb(err);
+                    return;
                 }
-                cb(err);
+
+                log.debug('acquired lock on %s', lockpath);
+                unlock = _unlock;
+                cb();
+            });
+        }, function (_, cb) {
+            // Start Vminfod Event Stream
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js writeAllMetadata (%s: %s)', uuid,
+                    toUpdate.join(',')),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
+        }, function (_, cb) {
+            // Ignore metadata that has not changed
+            Object.keys(mdata).forEach(function (_key) {
+                if (!vmobj.hasOwnProperty(_key)) {
+                    needsUpdate[_key] = true;
+                } else if (!deepEqual(mdata[_key], vmobj[_key])) {
+                    needsUpdate[_key] = true;
+                }
+            });
+
+            if (needsUpdate.hasOwnProperty('customer_metadata')
+                && !needsUpdate.hasOwnProperty('internal_metadata')) {
+                needsUpdate.internal_metadata = true;
+                mdata.internal_metadata = vmobj.internal_metadata || {};
+            } else if (needsUpdate.hasOwnProperty('internal_metadata')
+                && !needsUpdate.hasOwnProperty('customer_metadata')) {
+                needsUpdate.customer_metadata = true;
+                mdata.customer_metadata = vmobj.customer_metadata || {};
+            }
+
+            toUpdate = Object.keys(needsUpdate);
+
+            // Sanity check that all keys that need to be changed are found
+            // with new values in `mdata`
+            toUpdate.forEach(function (key) {
+                assert(mdata.hasOwnProperty(key), key + ': not found');
+            });
+
+            log.debug('metadata modified: %s', toUpdate.join(',') || '<none>');
+
+            cb();
+        }, function (_, cb) {
+            // Modify any metadata files that need to be modified while
+            // blocking on the changes to be reflected in Vminfod.
+            var cancelFn;
+
+            if (toUpdate.length === 0) {
+                // Nothing being modified, don't bother waiting on
+                // vminfod
+                log.debug('No metadata modifed');
+                vs.stop();
+                cb();
+                return;
+            }
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid,
+                        vm: mdata
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    vasync.pipeline({funcs: [
+                        function (__, cb3) {
+                            // write metadata
+                            var d = {};
+                            var len;
+
+                            if (needsUpdate.
+                                hasOwnProperty('internal_metadata')) {
+
+                                d.internal_metadata = mdata.internal_metadata;
+                            }
+                            if (needsUpdate.
+                                hasOwnProperty('customer_metadata')) {
+
+                                d.customer_metadata = mdata.customer_metadata;
+                            }
+
+                            len = Object.keys(d).length;
+
+                            if (len === 0) {
+                                log.debug('writeAllMetadata: skip metadata');
+                                cb3();
+                                return;
+                            }
+
+                            assert.equal(len, 2, '2 fields must be modified');
+
+                            writeAndRename(log, 'metadata', mdata_filename,
+                                JSON.stringify(d, null, 2), cb3);
+                        }, function (__, cb3) {
+                            // write tags
+                            if (!needsUpdate.hasOwnProperty('tags')) {
+                                log.debug('writeAllMetadata: skip tags');
+                                cb3();
+                                return;
+                            }
+
+                            writeAndRename(log, 'tags', tags_filename,
+                                JSON.stringify(mdata.tags, null, 2), cb3);
+                        }, function (__, cb3) {
+                            // write routes
+                            if (!needsUpdate.hasOwnProperty('routes')) {
+                                log.debug('writeAllMetadata: skip routes');
+                                cb3();
+                                return;
+                            }
+
+                            writeAndRename(log, 'routes', routes_filename,
+                                JSON.stringify(mdata.routes, null, 2), cb3);
+                        }
+                    ]}, function (err) {
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, cb);
+        }
+    ]}, function (err, results) {
+        if (err) {
+            log.error({err: err}, 'error writing metadata');
+        }
+
+        if (unlock) {
+            unlock(function (unlock_err) {
+                if (unlock_err) {
+                    log.error({err: unlock_err},
+                        'failed to unlock %s', lockpath);
+                }
+                callback(err || unlock_err);
+            });
+            return;
+        }
+
+        callback(err);
+    });
+}
+
+function createVM(payload, log, callback)
+{
+    var created_zoneroot = false;
+    var tracers_obj;
+
+    assert(log, 'no logger passed to createVM()');
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('createVM', log, callback);
+        callback = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    async.series([
+        function (cb) {
+            if (payload.create_only) {
+                cb();
+                return;
+            }
+
+            checkDatasets(payload, log, cb);
+        }, function _createZoneroot(cb) {
+            var args;
+
+            if (payload.brand !== 'bhyve') {
+                cb();
+                return;
+            }
+
+            assert.number(payload.quota, 'payload.quota');
+            assert.uuid(payload.uuid, 'payload.uuid');
+            assert.string(payload.zpool, 'payload.zpool');
+
+            // For bhyve we want to create the zonepath dataset here since we
+            // want disks to be child datasets, e.g.:
+            //
+            //  zones/<uuid>/disk0
+            //
+            args = ['create', '-o', 'refquota=' + payload.quota + 'G',
+                payload.zpool + '/' + payload.uuid];
+
+            zfs(args, log, function _onZfsCreate(err) {
+                if (!err) {
+                    created_zoneroot = true;
+                }
+                cb(err);
             });
         }, function (cb) {
-            if (!payload.create_only) {
-                // progress(29, 'creating volumes');
-                createVolumes(payload, log, cb);
-            } else {
+            if (payload.create_only) {
                 cb();
+                return;
             }
+            createVolumes(payload, log, cb);
         }, function (cb) {
-            // progress(51, 'creating zone container');
             createZone(payload, log, cb);
         }
     ], function (err, results) {
-        var zonecfg_file = '/etc/zones/' + payload.uuid + '.xml';
+        var zonecfg_file = zoneXMLPath(payload.uuid);
         var zonepath_ds = payload.zpool + '/' + payload.uuid;
 
         if (!err) {
@@ -3583,6 +3854,7 @@ function zoneadm(args, log, callback)
     var evtname = 'zoneadm';
 
     assert(log, 'no logger passed to zoneadm()');
+    assert.arrayOfString(args, 'zoneadm args');
 
     if (args[2]) {
         evtname = evtname + '-' + args[2];
@@ -3603,6 +3875,7 @@ function zfs(args, log, callback)
     var evtname = 'zfs.' + args[0];
 
     assert(log, 'no logger passed to zfs()');
+    assert.arrayOfString(args, 'zfs args');
 
     traceExecFile(cmd, args, log, evtname, function (error, stdout, stderr) {
         if (error) {
@@ -3641,21 +3914,22 @@ exports.getSysinfo = function (args, options, callback)
         var sysinfo;
 
         if (error) {
-            callback(error, {'stdout': stdout, 'stderr': stderr});
-        } else {
-            try {
-                sysinfo = JSON.parse(stdout.toString());
-            } catch (e) {
-                sysinfo = {};
-            }
-            callback(null, sysinfo);
+            callback(error, {stdout: stdout, stderr: stderr});
+            return;
         }
+
+        try {
+            sysinfo = JSON.parse(stdout.toString());
+        } catch (e) {
+            sysinfo = {};
+        }
+        callback(null, sysinfo);
     });
 };
 
 /*
  * This watches zone transitions and calls callback when specified
- * state is reached.  Optionally you can set a timeout which will
+ * state is reached.  Optionally you can set a timeout (in seconds) which will
  * call your callback when the timeout occurs whether the transition
  * has happened or not.
  *
@@ -3668,21 +3942,18 @@ exports.getSysinfo = function (args, options, callback)
 exports.waitForZoneState = function (payload, state, options, callback)
 {
     assert.object(payload, 'payload');
-    assert.string(payload.uuid, 'payload.uuid');
+    assert.uuid(payload.uuid, 'payload.uuid');
     assert.string(payload.zonename, 'payload.zonename');
     assert.string(state, 'state');
 
     var log;
-    var sysevent_state;
-    var timeout;
     var timeout_secs = PROVISION_TIMEOUT;
     var tracers_obj;
-    var transitions_opts;
-    var watcher;
+    var vmobj;
+    var vs;
 
-    // options is optional
-    if (arguments.length === 3) {
-        callback = arguments[2];
+    if (typeof (options) === 'function') {
+        callback = options;
         options = {};
     }
     assert.object(options, 'options');
@@ -3705,143 +3976,68 @@ exports.waitForZoneState = function (payload, state, options, callback)
         timeout_secs = options.timeout;
     }
 
-    sysevent_state = state;
-    if (state === 'installed') {
-        // Apparently the zone status 'installed' equals sysevent status
-        // 'uninitialized'
-        sysevent_state = 'uninitialized';
-    }
-
-    function done(err) {
-        if (watcher) {
-            watcher.cleanup();
-        }
-        if (timeout) {
-            clearTimeout(timeout);
-            timeout = null;
-        }
-        callback(err);
-    }
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js waitForZoneState (%s)', payload.uuid),
+                parseReady: true,
+                log: log
+            });
 
-    function waitForZoneStateHandler(obj) {
-        log.trace('handler got: ' + JSON.stringify(obj));
-        if (obj.zonename !== payload.zonename) {
-            return;
-        }
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(payload.uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
+                    return;
+                }
 
-        if (obj.newstate === sysevent_state) {
-            log.debug('event seen: zone_state "%s" -> "%s"',
-                obj.oldstate, obj.newstate);
+                cb();
+            });
+        }, function (_, cb) {
+            // check the vmobj found from vminfod "ack" packet
+            if (vmobj.hasOwnProperty('zone_state')
+                && vmobj.zone_state === state) {
+                log.info('VM is already in state %s', state);
 
-            if (options.skipConfirmation) {
-                done();
+                vs.stop();
+                vs = null;
+            }
+            cb();
+        }, function (_, cb) {
+            if (!vs) {
+                // alreday in the correct state; we're done
+                cb();
                 return;
             }
 
-            // Load again to confirm
-            VM.lookup({'zonename': obj.zonename},
-                {fields: ['zone_state'], log: log},
-                function (error, res) {
-                    var handler_retry;
-
-                    if (error) {
-                        done(error);
-                        return;
-                    }
-
-                    if (res.length !== 1) {
-                        done(new Error('lookup could not find VM '
-                            + obj.zonename));
-                        return;
-                    }
-
-                    if (res[0].hasOwnProperty('zone_state')
-                        && res[0].zone_state === state) {
-
-                        // found the state we're looking for, success!
-                        log.debug('saw zone go to ' + obj.newstate + ' ('
-                            + state + ') calling callback()');
-                        done();
-                    } else if (timeout) {
-                        // we saw a state change to a state we don't care about
-                        // so if we've not timed out try reloading again in a
-                        // second.
-                        if (!handler_retry) {
-                            handler_retry = setTimeout(function () {
-                                if (timeout) {
-                                    // try again if wait timeout is still set
-                                    waitForZoneStateHandler(obj);
-                                }
-                                handler_retry = null;
-                            }, 1000);
-                            log.debug('zone state after lookup: '
-                                + res[0].zone_state + ', still waiting');
-                        } else {
-                            log.debug('zone in wrong state but we already'
-                                + ' have a handler running');
-                        }
-                    } else {
-                        // no timeout set and we're not at the correct state
-                        log.error('failed to reach state: ' + state);
-                        done(new Error('failed to reach state: ' + state));
-                    }
+            // not in the right state; block on vminfod
+            var obj = {
+                uuid: payload.uuid,
+                vm: {
+                    zone_state: state
                 }
-            );
-        }
-    }
-
-    transitions_opts = {
-        log: log,
-        stream: options.stream
-    };
-    watcher = watchZoneTransitions(transitions_opts, waitForZoneStateHandler,
-        function (err) {
-
-        if (err) {
-            // there was an error creating the zone watcher, we can't continue
-            done(err);
-        }
-    });
-
-    timeout = setTimeout(function () {
-        var err;
-
-        err = new Error('timed out waiting for zone to transition to ' + state);
-        err.code = 'ETIMEOUT';
-
-        done(err);
-    }, timeout_secs * 1000);
-
-    // after we've started the watcher (if we checked before there'd be a race)
-    // we check whether we're already in the target state, if we are close it
-    // down and return.
-    VM.load(payload.uuid, {fields: ['zone_state'], log: log},
-        function (err, obj) {
-
-        if (err) {
-            done(err);
-        } else if (obj.hasOwnProperty('zone_state')
-            && obj.zone_state === state) {
+            };
+            var opts = {
+                timeout: timeout_secs * 1000,
+                catchErrors: true,
+                teardown: true
+            };
 
-            log.info('VM is in state ' + state);
-            done(); // at correct state!
+            vs.watchForEvent(obj, opts, cb);
         }
+    ]}, function (err) {
+        callback(err);
     });
-
-    return done;
 };
 
 /*
- * watchZoneTransitions will create a sysevent zone watcher (if needed) and
- * register handler() to be called with an object describing the transition for
- * any transitions seen.
+ * watchZoneTransitions will create a vminfod zone watcher and register
+ * handler() to be called with an object describing the transition for
+ * any transition seen.
  *
  * The callback function given as the final argument will be called when the
- * zone event watcher is ready to start receiving events.
- *
- * opts.stream is an optional zonewatcher stream that may have been allocated
- * already with a call to getZoneWatcher; if this is unset, one will be
- * allocated for you.
+ * vminfod zone event watcher is ready to start receiving events.
  *
  * This function returns an object that includes a 'cleanup' property. The
  * value of this property is a function that must be called to free the listener
@@ -3850,133 +4046,69 @@ exports.waitForZoneState = function (payload, state, options, callback)
  * argument)
  */
 function watchZoneTransitions(opts, handler, cb) {
-    var stream;
-
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
-    assert.optionalObject(opts.zonewatcher, 'opts.zonewatcher');
     assert.func(handler, 'handler');
     assert.func(cb, 'cb');
 
     var log = opts.log;
 
-    if (opts.stream) {
-        stream = opts.stream;
-        ready();
-    } else {
-        getZoneWatcher({log: log}, function (err, _stream) {
-            if (err) {
-                log.error({err: err}, 'getZoneWatcher failed');
-                cb(err);
-                return;
-            }
-
-            stream = _stream;
-            ready();
-        });
-    }
+    var vs = new vminfod.VminfodEventStream({
+        name: 'VM.js watchZoneTransitions',
+        log: log
+    });
 
-    function ready() {
-        stream.on('data', ondata);
+    vs.once('ready', function () {
         cb();
-    }
+    });
+
+    vs.on('readable', function () {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            processVminfodEvent(ev);
+        }
+    });
+
+    function processVminfodEvent(ev) {
+        if (ev.type !== 'modify')
+            return;
+
+        var obj = {
+            zonename: ev.zonename,
+            uuid: ev.uuid
+        };
+
+        (ev.changes || []).forEach(function (change) {
+            if (change.path.length !== 1 || change.path[0] !== 'zone_state')
+                return;
 
-    function ondata(ev) {
-        var obj = ev.data;
-        handler(obj);
+            obj.newstate = change.newValue;
+            obj.oldstate = change.oldValue;
+            handler(obj);
+        });
     }
 
-    // return a closure that includes the handler that was passed in
     return ({
         cleanup: function _handlerCleanup() {
-            if (stream) {
-                stream.removeListener('data', ondata);
-            }
-            freeZoneWatcher({log: log});
+            vs.stop();
         }
     });
 }
 
-/*
- * This function will return a SyseventStream set to watch for zone state
- * related events.
- *
- * If a stream already exists for this process the global ref count will be
- * bumped and the existing stream will be returned.  Otherwise, a new stream
- * will be created.
- *
- * cb() will be called with the stream created when it is ready
- */
-function getZoneWatcher(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.func(cb, 'cb');
+function fixPayloadMemory(payload, vmobj, log)
+{
+    var brand;
+    var max_locked;
+    var max_phys;
+    var min_overhead;
+    var ram;
 
-    var log = opts.log;
+    assert(log, 'no logger passed to fixPayloadMemory()');
 
-    if (zonewatcher.ref++ > 0) {
-        assert(zonewatcher.stream, 'ref > 0 but no zone watcher');
-        log.debug({ref: zonewatcher.ref},
-            'getZoneWatcher using existing zone watcher');
-        cb(null, zonewatcher.stream);
-        return;
-    }
-
-    var ses_opts = {
-        logger: opts.log,
-        class: 'status',
-        channel: 'com.sun:zones:status'
-    };
-    zonewatcher.stream = new SyseventStream(ses_opts);
-    zonewatcher.stream.on('ready', function () {
-        log.debug('getZoneWatcher new zone watcher ready');
-        cb(null, zonewatcher.stream);
-    });
-}
-
-/*
- * This function will free a single zone watcher, decrement the refcount, and
- * tear down the global zone event sysevent stream if the ref count is 0.
- *
- * Note that you should remove any 'data' event listener you have added to the
- * stream while using it, as this logic only handles decrementing the ref
- * count.
- */
-function freeZoneWatcher(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-
-    var log = opts.log;
-
-    if (zonewatcher.ref === 0) {
-        log.debug('freeZoneWatcher no zone watchers allocated');
-        assert(!zonewatcher.stream, 'stream exists while ref count is 0');
-        return;
-    }
-
-    zonewatcher.ref--;
-
-    if (zonewatcher.ref === 0) {
-        log.debug('freeZoneWatcher ref count is zero, stopping stream');
-        zonewatcher.stream.stop();
-        delete zonewatcher.stream;
-    }
-}
-
-function fixPayloadMemory(payload, vmobj, log)
-{
-    var brand;
-    var max_locked;
-    var max_phys;
-    var min_overhead;
-    var ram;
-
-    assert(log, 'no logger passed to fixPayloadMemory()');
-
-    if (vmobj.hasOwnProperty('brand')) {
-        brand = vmobj.brand;
-    } else if (payload.hasOwnProperty('brand')) {
-        brand = payload.brand;
+    if (vmobj.hasOwnProperty('brand')) {
+        brand = vmobj.brand;
+    } else if (payload.hasOwnProperty('brand')) {
+        brand = payload.brand;
     }
 
     if (BRAND_OPTIONS[brand].features.default_memory_overhead
@@ -4174,36 +4306,6 @@ function createZoneUUID(payload, log, callback)
         log = tracers_obj.log;
     }
 
-    /*
-     * Checks if the UUID already exists on a VM, if so: callback() is called
-     * with an error object as the first argument. If the UUID is unused,
-     * callback(null, <uuid>) is called.
-     *
-     */
-    function _assertUUIDUnique(uuid) {
-        var lookup_opts = {log: log, fields: ['uuid']};
-
-        vmload.getVmobjs(function (vmobj, cb) {
-            if (vmobj.uuid === uuid) {
-                cb(true);
-            } else {
-                cb(false);
-            }
-        }, lookup_opts, function gotVMs(err, vmobjs) {
-            if (err) {
-                callback(err);
-                return;
-            }
-
-            if (vmobjs.length > 0) {
-                callback(new Error('VM with UUID ' + uuid + ' already exists'));
-                return;
-            }
-
-            // if we got here, no other VM has this UUID so we'll use it.
-            callback(null, uuid);
-        });
-    }
 
     if (!payload.hasOwnProperty('uuid')) {
         payload.uuid = libuuid.create();
@@ -4211,7 +4313,20 @@ function createZoneUUID(payload, log, callback)
     }
 
     // Ensure that the uuid is not already used.
-    _assertUUIDUnique(payload.uuid);
+    vmload.getVmobj(payload.uuid, {log: log}, function (err, vmobj) {
+        if (!err) {
+            callback(new Error('VM with UUID ' + payload.uuid
+                + ' already exists'));
+            return;
+        }
+
+        if (err && err.code !== 'ENOENT') {
+            callback(err);
+            return;
+        }
+
+        callback(null, payload.uuid);
+    });
 }
 
 function applyZoneDefaults(payload, log)
@@ -4435,6 +4550,7 @@ function checkPayloadProperties(payload, vmobj, log, callback)
         brand = payload.brand;
     } else {
         callback(new Error('unable to determine brand for VM'));
+        return;
     }
 
     /* check types of fields that should be arrays */
@@ -5325,48 +5441,49 @@ function createDelegatedDataset(payload, log, callback)
         log = tracers_obj.log;
     }
 
-    if (payload.delegate_dataset) {
-        log.info('creating delegated dataset.');
-        if (!payload.hasOwnProperty('zfs_filesystem')) {
-            callback(new Error('payload missing zfs_filesystem'));
+    if (!payload.delegate_dataset) {
+        callback();
+        return;
+    }
+
+    log.info('creating delegated dataset.');
+    if (!payload.hasOwnProperty('zfs_filesystem')) {
+        callback(new Error('payload missing zfs_filesystem'));
+        return;
+    }
+    ds = path.join(payload.zfs_filesystem, '/data');
+
+    args = ['create'];
+    if (payload.hasOwnProperty('zfs_data_compression')) {
+        args.push('-o', 'compression=' + payload.zfs_data_compression);
+    }
+    if (payload.hasOwnProperty('zfs_data_recsize')) {
+        args.push('-o', 'recsize=' + payload.zfs_data_recsize);
+    }
+    args.push(ds);
+
+    zfs(args, log, function (err) {
+        if (err) {
+            callback(err);
             return;
         }
-        ds = path.join(payload.zfs_filesystem, '/data');
 
-        args = ['create'];
-        if (payload.hasOwnProperty('zfs_data_compression')) {
-            args.push('-o', 'compression=' + payload.zfs_data_compression);
-        }
-        if (payload.hasOwnProperty('zfs_data_recsize')) {
-            args.push('-o', 'recsize=' + payload.zfs_data_recsize);
-        }
-        args.push(ds);
+        zcfg = zcfg + 'add dataset; set name=' + ds + '; end\n';
+        zonecfg(payload.uuid, [zcfg], {log: log},
+            function (e, fds) {
 
-        zfs(args, log, function (err) {
-            if (err) {
-                callback(err);
-                return;
+            if (e) {
+                log.error({'err': e, stdout: fds.stdout,
+                    stderr: fds.stderr}, 'unable to add delegated dataset '
+                    + ds + ' to ' + payload.uuid);
+                callback(e);
+            } else {
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'added delegated dataset ' + ds);
+                callback();
             }
-
-            zcfg = zcfg + 'add dataset; set name=' + ds + '; end\n';
-            zonecfg(payload.uuid, [zcfg], {log: log},
-                function (e, fds) {
-
-                if (e) {
-                    log.error({'err': e, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'unable to add delegated dataset '
-                        + ds + ' to ' + payload.uuid);
-                    callback(e);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'added delegated dataset ' + ds);
-                    callback();
-                }
-            });
         });
-    } else {
-        callback();
-    }
+    });
 }
 
 function buildAddRemoveList(vmobj, payload, type, key, updatable)
@@ -6684,7 +6801,7 @@ function archiveVM(uuid, options, callback)
             });
         }, function (cb) {
             patterns_to_archive.push({
-                src: path.join('/etc/zones/', vmobj.zonename + '.xml'),
+                src: zoneXMLPath(vmobj.zonename),
                 dst: path.join(archive_dirname, 'zone.xml')
             });
             patterns_to_archive.push({
@@ -6863,72 +6980,11 @@ exports.markVMFailure = function (vmobj, options, callback)
         log = tracers_obj.log;
     }
 
-    function dumpDebugInfo(zonename, debug_cb) {
-        var errors = {};
-
-        async.series([
-            function (ptree_cb) {
-                // note: if the zone is not running this returns empty but still
-                // exits 0
-                traceExecFile('/usr/bin/ptree', ['-z', zonename], log, 'ptree',
-                    function (ptree_err, ptree_stdout, ptree_stderr) {
-
-                        if (ptree_err) {
-                            log.error(ptree_err, 'unable to get ptree from '
-                                + zonename + ': ' + ptree_stderr);
-                            errors.ptree_err = ptree_err;
-                        } else {
-                            log.warn('processes running in ' + zonename
-                                + ' at fail time:\n' + ptree_stdout);
-                        }
-
-                        ptree_cb(); // don't fail on error here.
-                    }
-                );
-            }, function (svcs_cb) {
-                traceExecFile('/usr/bin/svcs', ['-xv', '-z', zonename], log,
-                    'svcs', function (svcs_err, svcs_stdout, svcs_stderr) {
-
-                        if (svcs_err) {
-                            log.error(svcs_err, 'unable to get svcs from '
-                                + zonename + ': ' + svcs_stderr);
-                            errors.svcs_err = svcs_err;
-                        } else {
-                            log.warn('svcs -xv output for ' + zonename
-                                + ' at fail time:\n' + svcs_stdout);
-                        }
-
-                        svcs_cb(); // don't fail on error here.
-                    }
-                );
-            }, function (kstat_cb) {
-                traceExecFile('/usr/bin/kstat', ['-n', zonename.substr(0, 30)],
-                    log, 'kstat',
-                    function (kstat_err, kstat_stdout, kstat_stderr) {
-
-                        if (kstat_err) {
-                            log.error(kstat_err, 'unable to get kstats from '
-                                + zonename + ': ' + kstat_stderr);
-                            errors.kstat_err = kstat_err;
-                        } else {
-                            log.warn('kstat output for ' + zonename
-                                + ' at fail time:\n' + kstat_stdout);
-                        }
-
-                        kstat_cb(); // don't fail on error here.
-                    }
-                );
-            }
-        ], function () {
-            debug_cb(errors);
-        });
-    }
-
     async.series([function (debug_cb) {
-        dumpDebugInfo(vmobj.zonename, function (debug_err) {
+        logDebugZoneInfo(vmobj.zonename, {log: log}, function (debug_err) {
             // note: we don't treat failure to dump debug info as a fatal error.
-            log.warn(debug_err, 'zone setup failed, zone is being stopped '
-                + 'for manual investigation.');
+            log.warn({err: debug_err}, 'zone setup failed, zone is being '
+                + 'stopped for manual investigation.');
             debug_cb();
         });
     }, function (zonecfg_cb) {
@@ -7051,6 +7107,85 @@ exports.markVMFailure = function (vmobj, options, callback)
     });
 };
 
+function logDebugZoneInfo(zonename, options, callback) {
+    assert.string(zonename, 'zonename');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.func(callback, 'callback');
+
+    var errors = {};
+    var log = options.log;
+
+    vasync.pipeline({funcs: [
+        function (_, ptree_cb) {
+            // note: if the zone is not running this returns empty but still
+            // exits 0
+            traceExecFile('/usr/bin/ptree', ['-z', zonename], log, 'ptree',
+                function (ptree_err, ptree_stdout, ptree_stderr) {
+
+                    if (ptree_err) {
+                        log.error({err: ptree_err},
+                            'unable to get ptree from %s: %s',
+                            zonename, ptree_stderr);
+                        errors.ptree_err = ptree_err;
+                    } else {
+                        log.warn('processes running in %s at fail time:\n%s',
+                            zonename, ptree_stdout);
+                    }
+
+                    ptree_cb(); // don't fail on error here.
+                }
+            );
+        }, function (_, svcs_cb) {
+            traceExecFile('/usr/bin/svcs', ['-xv', '-z', zonename], log,
+                'svcs', function (svcs_err, svcs_stdout, svcs_stderr) {
+
+                    if (svcs_err) {
+                        log.error({err: svcs_err},
+                            'unable to get svcs from %s: %s',
+                            zonename, svcs_stderr);
+                        errors.svcs_err = svcs_err;
+                    } else {
+                        log.warn('svcs -xv output for %s at fail time:\n%s',
+                            zonename, svcs_stdout);
+                    }
+
+                    svcs_cb(); // don't fail on error here.
+                }
+            );
+        }, function (_, kstat_cb) {
+            traceExecFile('/usr/bin/kstat', ['-n', zonename.substr(0, 30)],
+                log, 'kstat',
+                function (kstat_err, kstat_stdout, kstat_stderr) {
+
+                    if (kstat_err) {
+                        log.error({err: kstat_err},
+                            'unable to get kstats from %s: %s',
+                            zonename, kstat_stderr);
+                        errors.kstat_err = kstat_err;
+                    } else {
+                        log.warn('kstat output for %s at fail time:\n%s',
+                            zonename, kstat_stdout);
+                    }
+
+                    kstat_cb(); // don't fail on error here.
+                }
+            );
+        }
+    ]}, function () {
+        var errorNames = Object.keys(errors);
+        var err;
+        if (errorNames.length > 0) {
+            err = new Error(sprintf(
+                'errors encountered gathering debug zone info: %s',
+                errorNames.join(', ')));
+            err.errors = errors;
+        }
+        callback(err);
+    });
+}
+
+
 function svccfg(zonepath, args, log, callback)
 {
     var cmd = '/usr/sbin/svccfg';
@@ -7109,6 +7244,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
 {
     var dirname = path.join(vmobj.zonepath, 'root', '/var/svc');
     var filename = path.join(dirname, 'provisioning');
+    var is_done = false;
     var ival_h;
     var log;
     var timeout;
@@ -7135,7 +7271,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
         log = tracers_obj.log;
     }
 
-    function done() {
+    function done(e) {
         if (timeout) {
             log.debug('clearing provision timeout for ' + vmobj.uuid);
             clearTimeout(timeout);
@@ -7152,6 +7288,11 @@ exports.waitForProvisioning = function (vmobj, options, cb)
             clearInterval(ival_h);
             ival_h = null;
         }
+
+        if (!is_done) {
+            is_done = true;
+            cb(e);
+        }
     }
 
     if ((vmobj.state === 'provisioning')
@@ -7168,7 +7309,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
         // don't know what to do here we're not provisioning.
         log.warn('waitForProvisioning called when ' + vmobj.uuid
             + ' was not provisioning');
-        cb();
+        done();
         return (null);
     }
 
@@ -7188,8 +7329,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                 log.warn(err, 'markVMFailure(): ' + err.message);
             }
             log.error(errstr);
-            done();
-            cb(new Error(errstr));
+            done(new Error(errstr));
         });
     }, (timeout_remaining * 1000));
 
@@ -7200,8 +7340,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
             if (err) {
                 log.error(err, 'error in markProvisionedWhenHWSetup()');
             }
-            done();
-            cb(err);
+            done(err);
         });
         return (done);
     }
@@ -7221,8 +7360,7 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                         if (err) {
                             log.warn(err, 'markVMFailure(): ' + err.message);
                         }
-                        done();
-                        cb(new Error('/var/svc/provisioning exists after '
+                        done(new Error('/var/svc/provisioning exists after '
                             + 'rename!'));
                     });
                     return;
@@ -7233,7 +7371,6 @@ exports.waitForProvisioning = function (vmobj, options, cb)
                 // matter for the state, it's provisioned now. Caller should
                 // now clear the transition.
                 done();
-                cb();
                 return;
             });
         }
@@ -7253,7 +7390,6 @@ exports.waitForProvisioning = function (vmobj, options, cb)
              * instead of throwing, we consider this success.
              */
             done();
-            cb();
             // return _noop since we called done() already.
             return (_noop);
         } else {
@@ -7304,7 +7440,7 @@ function makeIndestructible(dataset, log, callback)
 
         args = ['hold', 'do_not_destroy', snapshot];
         zfs(args, log, function _makeIndestructibleHold(hold_err, hold_out) {
-            if (hold_err && !hold_out.match(hold_exists_pattern)) {
+            if (hold_err && !hold_out.stderr.match(hold_exists_pattern)) {
                 callback(hold_err);
                 return;
             }
@@ -7423,6 +7559,7 @@ function installZone(payload, log, callback)
     var reprovisioning = false;
     var tracers_obj;
     var vmobj;
+    var vs;
     var zoneinit = {};
 
     assert(log, 'no logger passed to installZone()');
@@ -7463,8 +7600,11 @@ function installZone(payload, log, callback)
     async.series([
         function (cb) {
 
-            VM.load(payload.uuid, {fields: load_fields, log: log},
-                function (err, obj) {
+            var opts = {
+                fields: load_fields,
+                log: log
+            };
+            VM.load(payload.uuid, opts, function (err, obj) {
 
                 if (err) {
                     cb(err);
@@ -7526,66 +7666,142 @@ function installZone(payload, log, callback)
                 args.push('-x', 'nodataset');
             }
 
-            zoneadm(args, log, function (err, fds) {
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'zoneadm failed to install: '
-                        + err.message);
-                    cb(err);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'zoneadm installed zone');
-                    cb();
-                }
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js installZone zoneadm (%s)', payload.uuid),
+                log: log
             });
-        }, function (cb) {
-            // Apply compression if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_root_compression')) {
-                args = ['set', 'compression='
-                    + payload.zfs_root_compression, payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
-                cb();
-            }
-        }, function (cb) {
-            // Apply recsize if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_root_recsize')) {
-                args = ['set', 'recsize=' + payload.zfs_root_recsize,
-                    payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
+
+            vs.once('ready', function () {
+                var cancelFn;
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            uuid: payload.uuid,
+                            vm: {
+                                zone_state: 'installed'
+                            }
+                        };
+                        var opts = {
+                            timeout: VMINFOD_TIMEOUT,
+                            catchErrors: true,
+                            teardown: true
+                        };
+                        cancelFn = vs.watchForEvent(obj, opts, cb2);
+                    },
+                    function (cb2) {
+                        zoneadm(args, log, function (err, fds) {
+                            if (err) {
+                                log.error({err: err, stdout: fds.stdout,
+                                    stderr: fds.stderr},
+                                    'zoneadm failed to install: %s',
+                                    err.message);
+                                cancelFn();
+                                cb2(err);
+                                return;
+                            }
+
+                            log.debug({stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'zoneadm installed zone');
+                            cb2();
+                        });
+                    }
+                ]}, function (err, results) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    cb();
                 });
-            } else {
-                cb();
-            }
+            });
         }, function (cb) {
-            // Apply zfs_filesystem_limit if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_filesystem_limit')) {
-                args = ['set', 'filesystem_limit='
-                    + payload.zfs_filesystem_limit, payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js installZone (%s)', payload.uuid),
+                log: log
+            });
+            vs.once('ready', function () {
                 cb();
-            }
+            });
         }, function (cb) {
-            // Apply zfs_snapshot_limit if set
-            var args = [];
-            if (payload.hasOwnProperty('zfs_snapshot_limit')) {
-                args = ['set', 'snapshot_limit=' + payload.zfs_snapshot_limit,
-                    payload.zfs_filesystem];
-                zfs(args, log, function (err) {
-                    cb(err);
-                });
-            } else {
-                cb();
-            }
+            /*
+             * Apply ZFS settings
+             *
+             * These are run as separate invocations of zfs(1M) to make
+             * debugging easier in the event of a failure.
+             */
+            var props = [
+                {
+                    key: 'zfs_root_compression',
+                    zfs_prop: 'compression'
+                },
+                {
+                    key: 'zfs_root_recsize',
+                    zfs_prop: 'recsize'
+                },
+                {
+                    key: 'zfs_snapshot_limit',
+                    zfs_prop: 'snapshot_limit'
+                },
+                {
+                    key: 'zfs_filesystem_limit',
+                    zfs_prop: 'filesystem_limit'
+                }
+            ];
+
+            vasync.forEachPipeline({
+                inputs: props,
+                func: function (o, cb2) {
+                    var key = o.key;
+                    var zfs_prop = o.zfs_prop;
+                    if (!payload.hasOwnProperty(key)) {
+                        // not setting value
+                        cb2();
+                        return;
+                    }
+
+                    if (PAYLOAD_PROPERTIES[key].hasOwnProperty('pr_default')) {
+                        var def = PAYLOAD_PROPERTIES[key].pr_default;
+                        if (payload[key] === def) {
+                            // value is set to default
+                            cb2();
+                            return;
+                        }
+                    }
+
+                    var cancelFn;
+                    vasync.parallel({funcs: [
+                        function (cb3) {
+                            var obj = {
+                                uuid: payload.uuid,
+                                vm: {}
+                            };
+                            obj.vm[key] = payload[key];
+
+                            var opts = {
+                                timeout: VMINFOD_TIMEOUT,
+                                catchErrors: true
+                            };
+                            cancelFn = vs.watchForEvent(obj, opts, cb3);
+                        },
+                        function (cb3) {
+                            var args = [
+                                'set',
+                                sprintf('%s=%s', zfs_prop, payload[key]),
+                                payload.zfs_filesystem
+                            ];
+                            zfs(args, log, function (err) {
+                                if (err) {
+                                    cancelFn();
+                                    cb2(err);
+                                    return;
+                                }
+
+                                cb3();
+                            });
+                        }
+                    ]}, cb2);
+                }
+            }, cb);
         }, function (cb) {
             if (reprovisioning) {
                 // reprovisioning we don't change indestructibility state
@@ -7593,44 +7809,216 @@ function installZone(payload, log, callback)
                 return;
             }
 
-            if (payload.hasOwnProperty('indestructible_zoneroot')
-                && payload.indestructible_zoneroot) {
-
-                makeIndestructible(payload.zfs_filesystem, log, cb);
-            } else {
+            if (!payload.hasOwnProperty('indestructible_zoneroot')
+                || !payload.indestructible_zoneroot) {
                 cb();
+                return;
             }
+
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {
+                            indestructible_zoneroot:
+                                payload.indestructible_zoneroot
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    makeIndestructible(payload.zfs_filesystem, log,
+                        function (err) {
+
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
         }, function (cb) {
             // Some zones can have an additional 'data' dataset delegated to
             // them for use in the zone.  This will set that up.  If the option
             // is not set, the following does nothing.
-            if (!receiving && !reprovisioning) {
-                createDelegatedDataset(payload, log, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
+                cb();
+                return;
+            }
+
+            if (!payload.delegate_dataset) {
                 cb();
+                return;
             }
+
+            var obj = {
+                uuid: payload.uuid,
+                vm: {}
+            };
+
+            var keys = [
+                'zfs_data_compression',
+                'zfs_data_recsize'
+            ];
+            keys.forEach(function (key) {
+                if (!payload.hasOwnProperty(key)) {
+                    return;
+                }
+                if (PAYLOAD_PROPERTIES[key].hasOwnProperty('pr_default')) {
+                    var def = PAYLOAD_PROPERTIES[key].pr_default;
+                    if (payload[key] !== def) {
+                        obj.vm[key] = payload[key];
+                    }
+                }
+            });
+
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    createDelegatedDataset(payload, log, function (err) {
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
         }, function (cb) {
             // if there's delegated and we want it indestructible, do so now
-            if (payload.delegate_dataset
-                && payload.hasOwnProperty('indestructible_delegated')) {
-
-                makeIndestructible(payload.zfs_filesystem + '/data', log, cb);
-            } else {
+            if (!payload.hasOwnProperty('indestructible_delegated')
+                || !payload.indestructible_delegated) {
                 cb();
+                return;
             }
+
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {
+                            indestructible_delegated:
+                                payload.indestructible_delegated
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true
+                    };
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                },
+                function (cb2) {
+                    makeIndestructible(payload.zfs_filesystem + '/data', log,
+                        function (err) {
+
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (e) {
+                    cb(e);
+                }
+            );
         }, function (cb) {
             if (receiving || reprovisioning) {
                 cb();
                 return;
             }
 
-            createConfigDir(vmobj.zonepath, log, cb);
+            var cancelFn;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
+
+                    var obj = {
+                        uuid: payload.uuid,
+                        vm: {}
+                    };
+
+                    /*
+                     * Check the following keys for modifications.  If any key
+                     * has been modified then shouldBlock will be set to true,
+                     * and we will block on vminfod below for the changes to be
+                     * reflected.
+                     */
+                    [
+                        'customer_metadata',
+                        'internal_metadata',
+                        'routes',
+                        'tags'
+                    ].forEach(function (key) {
+                        obj.vm[key] = {};
+
+                        if (vmobj.hasOwnProperty(key)
+                            && Object.keys(vmobj[key]).length > 1) {
+
+                            shouldBlock = true;
+                        }
+                    });
+
+                    /*
+                     * Skip blocking on vminfod if no metadata has been
+                     * modified
+                     */
+                    if (!shouldBlock) {
+                        cb2();
+                        return;
+                    }
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    createConfigDir(vmobj.zonepath, log, function (err) {
+                        if (err) {
+                            if (cancelFn) {
+                                cancelFn();
+                            }
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
         }, function (cb) {
             var createFileOpts = {};
 
@@ -7648,6 +8036,10 @@ function installZone(payload, log, callback)
             }
 
             createHostConfFileMounts(vmobj, createFileOpts, log, cb);
+        }, function (cb) {
+            vs.stop();
+            vs = null;
+            cb();
         }, function (cb) {
             var host_vols = {};
             var to_create = [];
@@ -7703,43 +8095,48 @@ function installZone(payload, log, callback)
             // Write out the zone's metadata
             // Note: we don't do this when receiving because dataset will
             // already contain metadata and we don't want to wipe that out.
-            if (!receiving && !reprovisioning) {
-                saveMetadata(payload, log, function (err) {
-                    if (err) {
-                        log.error(err, 'unable to save metadata: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
                 cb();
+                return;
             }
+
+            saveMetadata(payload, log, function (err) {
+                if (err) {
+                    log.error({err: err}, 'unable to save metadata: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Write out the zone's routes
             // Note: we don't do this when receiving because dataset will
             // already contain routes and we don't want to wipe that out.
-            if (!receiving && !reprovisioning) {
-                saveRoutes(payload, log, function (err) {
-                    if (err) {
-                        log.error(err, 'unable to save routes: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        cb();
-                    }
-                });
-            } else {
+            if (receiving || reprovisioning) {
                 cb();
+                return;
             }
+
+            saveRoutes(payload, log, function (err) {
+                if (err) {
+                    log.error({err: err}, 'unable to save routes: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // if we were receiving, we're done receiving now
-            if (receiving) {
-                VM.unsetTransition(vmobj, {log: log}, cb);
-            } else {
+            if (!receiving) {
                 cb();
+                return;
             }
+
+            VM.unsetTransition(vmobj, {log: log}, cb);
         }, function (cb) {
             // var zoneinit is in installZone() scope
 
@@ -7987,8 +8384,7 @@ function installZone(payload, log, callback)
             addFirewallData(payload, vmobj, log, cb);
         }, function (cb) {
 
-            var cancel;
-            var calledback = false;
+            var cancelFn;
             var prov_wait = true;
             // var_svc_provisioning is at installZone() scope
 
@@ -8009,16 +8405,30 @@ function installZone(payload, log, callback)
             // from provisioning -> either provision_success, or
             // provision_failure.
 
-            if (prov_wait) {
-                // wait for /var/svc/provisioning -> provision_success/failure
-                cancel = VM.waitForProvisioning(vmobj, {log: log},
-                    function (err) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (!prov_wait) {
+                        cb2();
+                        return;
+                    }
 
-                    log.debug(err, 'waited for provisioning');
+                    // wait for /var/svc/provisioning ->
+                    // provision_success/failure
+                    cancelFn = VM.waitForProvisioning(vmobj, {log: log},
+                        function (err) {
+
+                        log.debug({err: err}, 'waited for provisioning');
+
+                        if (err) {
+                            log.error(err, 'error waiting for provisioning: '
+                                + err.message);
+                            cb2(err);
+                            return;
+                        }
 
-                    if (!err) {
                         log.info('provisioning complete: '
                             + '/var/svc/provisioning is gone');
+
                         // this will clear the provision transition
                         VM.unsetTransition(vmobj, {log: log},
                             function (unset_err) {
@@ -8026,58 +8436,39 @@ function installZone(payload, log, callback)
                             if (unset_err) {
                                 log.error(unset_err, 'error unsetting '
                                     + 'transition: ' + unset_err.message);
+                                cb2(unset_err);
+                                return;
                             }
-                            // this and the cb in the VM.start callback might
-                            // both run if we don't check this.
-                            if (!calledback) {
-                                calledback = true;
-                                cb(unset_err);
-                            }
+
+                            cb2();
                         });
-                    } else {
-                        // failed but might not be able to cb if VM.start's
-                        // callback already did.
-                        log.error(err, 'error waiting for provisioning: '
-                            + err.message);
-                        // this and the cb in the VM.start callback might
-                        // both run if we don't check this.
-                        if (!calledback) {
-                            calledback = true;
-                            cb(err);
+                    });
+                }, function (cb2) {
+                    VM.start(payload.uuid, {}, {log: log}, function (err, res) {
+                        if (err) {
+                            // we failed to start so we'll never see
+                            // provisioning, so cancel that and return the
+                            // error.
+                            if (cancelFn) {
+                                log.info('cancelling VM.waitForProvisioning');
+                                cancelFn();
+                            }
+
+                            cb2(err);
+                            return;
                         }
-                    }
-                });
-            }
 
-            VM.start(payload.uuid, {}, {log: log}, function (err, res) {
-                if (err) {
-                    // we failed to start so we'll never see provisioning, so
-                    // cancel that and return the error.
-                    if (cancel) {
-                        log.info('cancelling VM.waitForProvisioning');
-                        cancel();
-                    }
-                    // this and the cb in the VM.waitForProvisioning
-                    // callback might both run if we don't check this.
-                    if (!calledback) {
-                        calledback = true;
-                        cb(err);
-                    }
-                    return;
-                }
-                // if we're waiting for 'provisioning' VM.waitForProvisioning's
-                // callback will call cb().  If we're not going to wait, we call
-                // it here.
-                if (!prov_wait) {
-                    // this and the cb in the VM.waitForProvisioning
-                    // callback might both run if we don't check this.
-                    if (!calledback) {
-                        calledback = true;
-                        cb();
-                    }
+                        cb2();
+                    });
                 }
+            ]}, function (err, results) {
+                cb(err);
             });
         }], function (error) {
+            if (vs) {
+                vs.stop();
+                vs = null;
+            }
             callback(error);
         }
     );
@@ -8275,6 +8666,7 @@ function createZone(payload, log, callback)
     var timeout_multiplier;
     var tracers_obj;
     var vm_version;
+    var vs;
     var zcfg;
 
     assert(log, 'no logger passed to createZone()');
@@ -8386,25 +8778,59 @@ function createZone(payload, log, callback)
     // we're talking about a new machine.
     zcfg = zcfg + buildZonecfgUpdate({}, payload, log);
 
-    // send the zonecfg data we just generated as stdin to zonecfg,
-    // this will create the zone.
-    zonecfg(payload.zonename, [],
-        {log: log, stdin: zcfg, useZonename: true}, function (err, fds) {
+    vs = new vminfod.VminfodEventStream({
+        name: sprintf('VM.js createZone (%s)', payload.uuid),
+        log: log
+    });
 
-        if (err) {
-            log.error({err: err, zcfg: zcfg, stdout: fds.stdout,
-                stderr: fds.stderr}, 'failed to modify zonecfg');
-            callback(err);
-            return;
-        }
+    var cancelFn;
+    vs.once('ready', function () {
+        vasync.parallel({funcs: [
+            function (cb2) {
+                var obj = {
+                    type: 'create',
+                    uuid: payload.uuid
+                };
+                var opts = {
+                    timeout: VMINFOD_TIMEOUT,
+                    catchErrors: true,
+                    teardown: true
+                };
+                cancelFn = vs.watchForEvent(obj, opts, cb2);
+            },
+            function (cb2) {
+                // send the zonecfg data we just generated as a file to
+                // zonecfg, this will create the zone.
+                zonecfg(payload.zonename, [],
+                    {log: log, stdin: zcfg, useZonename: true},
+                    function (err, fds) {
 
-        log.debug({stdout: fds.stdout, stderr: fds.stderr}, 'modified zonecfg');
+                    if (err) {
+                        log.error({err: err, zcfg: zcfg, stdout: fds.stdout,
+                            stderr: fds.stderr},
+                            'failed to modify zonecfg');
 
-        if (payload.create_only) {
-            callback();
-        } else {
-            installZone(payload, log, callback);
-        }
+                        cancelFn();
+                        callback(err);
+                        return;
+                    }
+
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'modified zonecfg');
+                    cb2();
+                });
+            }
+        ]}, function (err, results) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            if (payload.create_only) {
+                callback();
+            } else {
+                installZone(payload, log, callback);
+            }
+        });
     });
 }
 
@@ -8457,8 +8883,9 @@ function normalizePayload(payload, vmobj, log, callback)
     var action;
     var allowed;
     var brand;
+    var docker_id;
+    var mdata_key;
     var property;
-    var set_mdata_prefix = '';
     var tracers_obj;
     var uuid;
 
@@ -8470,6 +8897,8 @@ function normalizePayload(payload, vmobj, log, callback)
         log = tracers_obj.log;
     }
 
+    log.debug({vmobj: vmobj, payload: payload}, 'normalizePayload called');
+
     for (property in payload) {
         if (payload.hasOwnProperty(property)) {
             // fix type of arguments that should be numbers, do this here so
@@ -8610,12 +9039,6 @@ function normalizePayload(payload, vmobj, log, callback)
             }
         }
 
-        // For 'create' and 'receive', we use 'internal_metadata' and update
-        // uses 'set_internal_metadata'.
-        if (action === 'update') {
-            set_mdata_prefix = 'set_';
-        }
-
         // If we're setting docker=true and restart_init is not false, set it
         // false now. We don't want zoneadmd to try to restart us (OS-3546).
         if ((!vmobj || vmobj.restart_init !== false)
@@ -8634,22 +9057,28 @@ function normalizePayload(payload, vmobj, log, callback)
             }
         }
 
+        // For 'create' and 'receive', we use 'internal_metadata' and update
+        // uses 'set_internal_metadata'.
+        if (action === 'update') {
+            mdata_key = 'set_internal_metadata';
+        } else {
+            mdata_key = 'internal_metadata';
+        }
+
         // If we already have a docker id and this is an update setting
         // docker=true, we'll assume it's set to a correct value.
         if (!vmobj
             || !vmobj.internal_metadata
             || !vmobj.internal_metadata['docker:id']) {
 
-            // Existing VM doesn't have 'docker:id', so we'll add one.
-            if (!payload[set_mdata_prefix + 'internal_metadata']) {
-                payload[set_mdata_prefix + 'internal_metadata'] = {
-                    'docker:id': newDockerId(uuid)
-                };
-            } else if (!payload[set_mdata_prefix
-                + 'internal_metadata']['docker:id']) {
+            docker_id = newDockerId(uuid);
 
-                payload[set_mdata_prefix + 'internal_metadata']['docker:id']
-                    = newDockerId(uuid);
+            if (!payload[mdata_key]) {
+                payload[mdata_key] = {
+                    'docker:id': docker_id
+                };
+            } else if (!payload[mdata_key]['docker:id']) {
+                payload[mdata_key]['docker:id'] = docker_id;
             }
         }
     }
@@ -8796,8 +9225,8 @@ function normalizePayload(payload, vmobj, log, callback)
         normalizeNics(payload, vmobj);
 
         vasync.pipeline({
-            'arg': payload,
-            'funcs': [
+            arg: payload,
+            funcs: [
                 mod_nic.upgradeNicAdds,
                 mod_nic.upgradeNicUpdates.bind(null, vmobj),
                 function (_, cb) {
@@ -8872,6 +9301,7 @@ exports.unsetTransition = function (vmobj, options, callback)
 {
     var log;
     var tracers_obj;
+    var vs;
 
     // options is optional
     if (arguments.length === 2) {
@@ -8892,52 +9322,136 @@ exports.unsetTransition = function (vmobj, options, callback)
         log = tracers_obj.log;
     }
 
-    zonecfg(vmobj.uuid, ['remove -F attr name=transition'],
-        {log: log}, function (err, fds) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            if (!vmobj.hasOwnProperty('transition_to')) {
+                // we can skip vminfod completely, because no change will happen
+                cb();
+                return;
+            }
 
-        if (err) {
-            // log at info because this might be because already removed
-            log.info({err: err, stdout: fds.stdout, stderr: fds.stderr},
-                'unable to remove transition for zone ' + vmobj.uuid);
-        } else {
-            log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                'removed transition for zone ' + vmobj.uuid);
-        }
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js unsetTransition (%s)', vmobj.uuid),
+                parseReady: true,
+                log: log
+            });
 
-        zonecfg(vmobj.uuid, ['info attr name=transition'],
-            {log: log}, function (info_err, info_fds) {
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(vmobj.uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
+                    return;
+                }
 
-            if (info_err) {
-                log.error({err: info_err, stdout: info_fds.stdout,
-                    stderr: info_fds.stderr},
-                    'failed to confirm transition removal');
-                callback(info_err);
-                return;
+                cb();
+            });
+        }, function (_, cb) {
+            // check again
+            if (!vmobj.hasOwnProperty('transition_to')) {
+                // we can skip vminfo completely, because no change will happen
+                if (vs) {
+                    vs.stop();
+                    vs = null;
+                }
             }
 
-            if (info_fds.stdout !== 'No such attr resource.\n') {
-                log.error({stdout: info_fds.stdout, stderr: info_fds.stderr},
-                    'unknown error checking transition after removal');
-                callback(new Error('transition does not appear to have been '
-                    + 'removed zonecfg said: ' + JSON.stringify(info_fds)));
-                return;
-            }
+            cb();
+        }, function (_, cb) {
+            var cancelFn;
 
-            // removed the transition, now attempt to start if we're rebooting.
-            if (vmobj.transition_to && vmobj.transition_to === 'start') {
-                log.debug('VM ' + vmobj.uuid + ' was stopping for reboot, '
-                    + 'transitioning to start.');
-                VM.start(vmobj.uuid, {}, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'failed to start when clearing '
-                            + 'transition');
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (!vs) {
+                        cb();
+                        return;
                     }
-                    callback();
-                });
-            } else {
-                callback();
+
+                    var obj = {
+                        uuid: vmobj.uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['transition_to'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var zcfg = 'remove attr name=transition';
+                    var msg = 'remove attr: No such resource with that id';
+
+                    zonecfg(vmobj.uuid, [zcfg], {log: log},
+                        function (err, fds) {
+
+                        if (err
+                            && fds.stderr
+                            && fds.stderr.trim() === msg) {
+
+                            // it was already unset, we don't need to do
+                            // anything.
+                            log.debug({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'attr name=transition already gone for VM %s',
+                                vmobj.uuid);
+
+                            if (cancelFn)
+                                cancelFn();
+                            cb2();
+                            return;
+                        }
+
+                        if (err) {
+                            // we failed for some unknown reason, we can't
+                            // continue
+                            log.error({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to remove transition for VM %s',
+                                vmobj.uuid);
+
+                            if (cancelFn)
+                                cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        // succeeded to remove transition, we wait on vminfod
+                        // to become aware of the changes
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'attr transition removed for VM %s',
+                            vmobj.uuid);
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (_, cb) {
+            // removed the transition, now attempt to start if we're rebooting.
+            if (vmobj.transition_to !== 'start') {
+                cb();
+                return;
             }
-        });
+
+            log.debug('VM %s was stopping for reboot, transitioning to start.',
+                vmobj.uuid);
+
+            VM.start(vmobj.uuid, {}, {log: log}, function (e) {
+                if (e) {
+                    log.error(e, 'failed to start when clearing transition');
+                }
+                cb();
+            });
+        }
+    ]}, function (err) {
+        callback(err);
     });
 };
 
@@ -8950,6 +9464,7 @@ exports.unsetTransition = function (vmobj, options, callback)
 function setTransition(vmobj, transition, target, timeout, log, callback)
 {
     var tracers_obj;
+    var vs;
 
     assert(log, 'no logger passed to setTransition()');
 
@@ -8964,35 +9479,77 @@ function setTransition(vmobj, transition, target, timeout, log, callback)
         log = tracers_obj.log;
     }
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             // unset an existing transition
             if (vmobj.hasOwnProperty('transition')) {
                 VM.unsetTransition(vmobj, {log: log}, cb);
             } else {
                 cb();
             }
-        }, function (cb) {
-            var zcfg;
+        }, function (_, cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js setTransition (%s)', vmobj.uuid),
+                log: log
+            });
 
-            zcfg = buildTransitionZonecfg(transition, target, timeout);
-            zonecfg(vmobj.uuid, [zcfg], {log: log},
-                function (err, fds) {
+            vs.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            var cancelFn;
 
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'failed to set transition='
-                        + transition + ' for VM ' + vmobj.uuid);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'set transition=' + transition + ' for vm '
-                        + vmobj.uuid);
-                }
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: vmobj.uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['transition_to'],
+                            action: 'added',
+                            newValue: target
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var zcfg = buildTransitionZonecfg(transition, target,
+                        timeout);
 
+                    zonecfg(vmobj.uuid, [zcfg], {log: log},
+                        function (err, fds) {
+
+                        if (err) {
+                            // we unset the transition attribute above, so
+                            // any error here is considered a failure
+                            log.error({err: err, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to set transition=%s for VM %s',
+                                transition, vmobj.uuid);
+
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'set transition=%s for VM %s',
+                            transition, vmobj.uuid);
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
                 cb(err);
             });
         }
-    ], function (error) {
+    ]}, function (error) {
         callback(error);
     });
 }
@@ -9068,8 +9625,9 @@ function receiveVM(json, log, callback)
     });
 }
 
-function receiveStdinChunk(type, log, callback)
+function receiveStdinChunk(type, opts, callback)
 {
+    var args;
     var child;
     var chunk_name = '';
     var chunk_size = 0;
@@ -9077,6 +9635,12 @@ function receiveStdinChunk(type, log, callback)
     var remaining = '';
     var tracers_obj;
 
+    assert.object(opts, 'opts');
+
+    var log = opts.log;
+    var vs = opts.vs;
+    var uuid = opts.uuid;
+
     assert(log, 'no logger passed to receiveStdinChunk()');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
@@ -9097,94 +9661,157 @@ function receiveStdinChunk(type, log, callback)
      *
      */
 
-    if (type === 'JSON') {
-        log.info('/usr/vm/sbin/vmunbundle json');
-        child = spawn('/usr/vm/sbin/vmunbundle', ['json'],
-            {customFds: [0, -1, -1]});
-    } else if (type === 'DATASET') {
-        log.info('/usr/vm/sbin/vmunbundle dataset');
-        child = spawn('/usr/vm/sbin/vmunbundle', ['dataset'],
-            {customFds: [0, -1, -1]});
-    } else {
+    switch (type) {
+    case 'JSON':
+        args = ['json'];
+        break;
+    case 'DATASET':
+        assert(vs, 'opts.vs');
+        assert(uuid, 'opts.uuid');
+        args = ['dataset'];
+        break;
+    default:
         callback(new Error('Unsupported chunk type ' + type));
+        return;
     }
 
-    child.stderr.on('data', function (data) {
-        var idx;
-        var line;
-        var matches;
+    var cancelFn;
+    vasync.parallel({funcs: [
+        function vminfod_block(cb) {
+            if (type !== 'DATASET') {
+                cancelFn = noop;
+                cb();
+                return;
+            }
 
-        remaining += data.toString();
+            var _opts = {
+                catchErrors: true,
+                startFresh: true,
+                timeout: VMINFOD_TIMEOUT
+            };
 
-        idx = remaining.indexOf('\n');
-        while (idx > -1) {
-            line = trim(remaining.substring(0, idx));
-            remaining = remaining.substring(idx + 1);
+            var obj = {
+                uuid: uuid
+            };
 
-            log.debug('VMUNBUNDLE: ' + line);
-            matches = line.match(/Size: ([\d]+)/);
-            if (matches) {
-                chunk_size = Number(matches[1]);
-            }
-            matches = line.match(/Name: \[(.*)\]/);
-            if (matches) {
-                chunk_name = matches[1];
-            }
+            var changes = [
+                [
+                    {
+                        path: ['disks', null, 'missing'],
+                        action: 'removed'
+                    },
+                    {
+                        path: ['zfs_filesystem'],
+                        action: 'added'
+                    }
+                ]
+            ];
 
-            idx = remaining.indexOf('\n');
-        }
-    });
+            cancelFn = vs.watchForChanges(obj, changes, _opts, cb);
+        }, function vmbundle(cb) {
+            log.info('/usr/vm/sbin/vmunbundle %s', args.join(' '));
+            child = spawn('/usr/vm/sbin/vmunbundle', args,
+                {customFds: [0, -1, -1]});
 
-    child.stdout.on('data', function (data) {
-        json += data.toString();
-        log.debug('json size is ' + json.length);
-    });
+            child.stderr.on('data', function (data) {
+                var idx;
+                var line;
+                var matches;
 
-    child.on('close', function (code) {
-        log.debug('vmunbundle process exited with code ' + code);
-        if (code === 3) {
-            log.debug('vmbundle: end of bundle.');
-            callback(null, 'EOF');
-            return;
-        } else if (code !== 0) {
-            callback(new Error('vmunbundle exited with code ' + code));
-            return;
-        }
+                remaining += data.toString();
 
-        // if it was a dataset, we've now imported it.
-        // if it was json, we've now got it in the json var.
+                idx = remaining.indexOf('\n');
+                while (idx > -1) {
+                    line = trim(remaining.substring(0, idx));
+                    remaining = remaining.substring(idx + 1);
 
-        if (type === 'DATASET') {
-            log.info('Imported dataset ' + chunk_name);
-            // delete 'sending' snapshot
-            zfs(['destroy', '-F', chunk_name + '@sending'], log,
-                function (err, fds) {
-                    if (err) {
-                        log.warn(err, 'Failed to destroy ' + chunk_name
-                            + '@sending: ' + err.message);
+                    log.debug('VMUNBUNDLE: ' + line);
+                    matches = line.match(/Size: ([\d]+)/);
+                    if (matches) {
+                        chunk_size = Number(matches[1]);
                     }
-                    callback();
+                    matches = line.match(/Name: \[(.*)\]/);
+                    if (matches) {
+                        chunk_name = matches[1];
+                    }
+
+                    idx = remaining.indexOf('\n');
                 }
-            );
-        } else if (type === 'JSON' && chunk_name === 'JSON'
-            && json.length <= chunk_size && json.length > 0) {
+            });
 
-            receiveVM(json, log, function (e, result) {
-                if (e) {
-                    callback(e);
+            child.stdout.on('data', function (data) {
+                json += data.toString();
+                log.debug('json size is ' + json.length);
+            });
+
+            child.on('close', function (code) {
+                log.debug('vmunbundle process exited with code ' + code);
+
+                switch (code) {
+                case 0:
+                    break;
+                case 3:
+                    log.debug('vmbundle: end of bundle.');
+                    cancelFn();
+                    cb(null, 'EOF');
+                    return;
+                default:
+                    cancelFn();
+                    cb(new Error('vmunbundle exited with code ' + code));
+                    return;
+                }
+
+                // if it was a dataset, we've now imported it.
+                // if it was json, we've now got it in the json var.
+
+                if (type === 'DATASET') {
+                    log.info('Imported dataset ' + chunk_name);
+                    // delete 'sending' snapshot
+                    var snap = chunk_name + '@sending';
+                    zfs(['destroy', '-F', snap], log, function (err, fds) {
+                        if (err) {
+                            log.warn({err: err},
+                                'Failed to destroy %s: %s',
+                                snap,
+                                err.message);
+                        }
+
+                        cb();
+                    });
+                    return;
+                }
+
+                if (type === 'JSON' && chunk_name === 'JSON'
+                    && json.length <= chunk_size && json.length > 0) {
+
+                    receiveVM(json, log, function (e, result) {
+                        if (e) {
+                            cb(e);
+                            return;
+                        }
+
+                        log.info({result: result}, 'Receive returning result');
+
+                        cb(null, {json: JSON.parse(json), result: result});
+                    });
                     return;
                 }
-                log.info('Receive returning: ' + JSON.stringify(result));
-                callback(null, result);
+
+                // error
+                log.debug('type: [' + type + ']');
+                log.debug('chunk_name: [' + chunk_name + ']');
+                log.debug('chunk_size: [' + chunk_size + ']');
+                log.debug('json.length: [' + json.length + ']');
+                log.warn('Failed to get ' + type + '!');
+                cb(new Error('Failed to get ' + type + '!'));
             });
-        } else {
-            log.debug('type: [' + type + ']');
-            log.debug('chunk_name: [' + chunk_name + ']');
-            log.debug('chunk_size: [' + chunk_size + ']');
-            log.debug('json.length: [' + json.length + ']');
-            log.warn('Failed to get ' + type + '!');
-            callback(new Error('Failed to get ' + type + '!'));
         }
+    ]}, function (err, results) {
+        var result = results.operations.filter(function (o) {
+            return o.funcname === 'vmbundle';
+        })[0].result;
+
+        callback(err, result);
     });
 }
 
@@ -9192,6 +9819,9 @@ exports.receive = function (target, options, callback)
 {
     var log;
     var tracers_obj;
+    var result;
+    var origJson;
+    var vsChunk, vsGlobal;
 
     // options is optional
     if (arguments.length === 2) {
@@ -9226,59 +9856,173 @@ exports.receive = function (target, options, callback)
         return;
     }
 
-    receiveStdinChunk('JSON', log, function (error, result) {
-        var eof = false;
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            receiveStdinChunk('JSON', {log: log}, function (error, o) {
+                if (error) {
+                    cb(error);
+                    return;
+                }
+
+                origJson = o.json;
+                result = o.result;
 
-        if (error) {
-            callback(error);
-            return;
-        }
+                if (result && result === 'EOF') {
+                    cb(new Error('unable to find JSON in stdin.'));
+                    return;
+                }
+
+                if (!result || !result.hasOwnProperty('uuid')) {
+                    cb(new Error('unable to receive JSON'));
+                    return;
+                }
+
+                log.debug({origJson: origJson, result: result},
+                    'Receive stdin JSON chunk');
+
+                cb();
+            });
+        }, function (_, cb) {
+            // This event stream is used globally while vmbundle is forked many
+            // times to ensure metadata has been added properly.
+            vsGlobal = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js receive global (%s)', result.uuid),
+                log: log
+            });
+
+            vsGlobal.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            // This event stream is used for each invocation of vmbundle with
+            // the DATASET option.  This way, we can properly block on vminfod
+            // to see the disks.* added event.
+            vsChunk = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js receive receiveStdin (%s)', result.uuid),
+                log: log
+            });
 
-        if (result && result === 'EOF') {
-            callback(new Error('unable to find JSON in stdin.'));
-        } else if (result && result.hasOwnProperty('uuid')) {
+            vsChunk.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
             // VM started receive, now need datasets
+            var eof = false;
+            var cancelFn;
 
             // We have JSON, so we can log better now if we need one
             if (!options.hasOwnProperty('log')) {
                 log = VM.log.child({action: 'receive', vm: result.uuid});
             }
 
-            log.info('Receiving VM ' + result.uuid);
+            log.info('Receiving VM %s', result.uuid);
             log.debug('now looking for datasets');
 
-            vasync.whilst(
-                function () { return !eof; },
-                function (cb) {
-                    receiveStdinChunk('DATASET', log, function (err, res) {
-                        if (err) {
-                            cb(err);
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
+
+                    var obj = {
+                        uuid: result.uuid,
+                        vm: {}
+                    };
+
+                    [
+                        'zpool',
+                        'quota',
+                        'internal_metadata',
+                        'customer_metadata',
+                        'tags',
+                        'routes'
+                    ].forEach(function (key) {
+                        if (!origJson.hasOwnProperty(key)) {
                             return;
                         }
-                        if (res === 'EOF') {
-                            eof = true;
+
+                        var o = origJson[key];
+                        var t = typeof (o);
+
+                        if (t !== 'object') {
+                            shouldBlock = true;
+                            obj.vm[key] = o;
+                        } else if (t === 'object'
+                            && Object.keys(o).length > 0) {
+
+                            shouldBlock = true;
+                            obj.vm[key] = o;
                         }
-                        cb();
                     });
-                }, function (err) {
-                    if (err) {
-                        callback(err);
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true,
+                        teardown: true
+                    };
+
+                    if (!shouldBlock) {
+                        cb2();
                         return;
                     }
-                    // no error so we read all the datasets, try an install.
-                    log.info('receive calling VM.install: ' + eof);
-                    VM.install(result.uuid, {log: log}, function (e) {
-                        if (e) {
-                            log.warn(e, 'couldn\'t install VM: '
-                                + e.message);
+
+                    cancelFn = vsGlobal.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    vasync.whilst(
+                        function () { return !eof; },
+                        function (cb3) {
+                            var opts = {
+                                log: log,
+                                uuid: result.uuid,
+                                vs: vsChunk
+                            };
+                            receiveStdinChunk('DATASET', opts,
+                                function (err, res) {
+
+                                if (err) {
+                                    cb3(err);
+                                    return;
+                                }
+
+                                if (res === 'EOF') {
+                                    eof = true;
+                                }
+                                cb3();
+                            });
+                        },
+                        function (err) {
+                            if (err) {
+                                if (cancelFn) {
+                                    cancelFn();
+                                }
+                                cb2(err);
+                                return;
+                            }
+                            cb2();
                         }
-                        callback(e, result);
-                    });
+                    );
                 }
-            );
-        } else {
-            callback(new Error('unable to receive JSON'));
+            ]}, cb);
+        }, function (_, cb) {
+            if (vsChunk) {
+                vsChunk.stop();
+                vsChunk = null;
+            }
+            cb();
+        }, function (_, cb) {
+            // no error so we read all the datasets, try an install.
+            log.info('receive calling VM.install');
+            VM.install(result.uuid, {log: log}, function (e) {
+                if (e) {
+                    log.warn({err: e}, 'couldn\'t install VM: %s', e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }
+    ]}, function (err) {
+        callback(err, result);
     });
 };
 
@@ -9290,6 +10034,7 @@ exports.reprovision = function (uuid, payload, options, callback)
     var snapshot;
     var tracers_obj;
     var vmobj;
+    var vs;
 
     // options is optional
     if (arguments.length === 3) {
@@ -9310,35 +10055,24 @@ exports.reprovision = function (uuid, payload, options, callback)
         log = tracers_obj.log;
     }
 
-    log.info('Reprovisioning VM ' + uuid + ', original payload:\n'
-            + JSON.stringify(payload, null, 2));
+    log.info({payload: payload}, 'Reprovisioning VM %s', uuid);
 
     vasync.waterfall([
         function (cb) {
-            VM.load(uuid, {
-                fields: [
-                    'brand',
-                    'datasets',
-                    'hostname',
-                    'indestructible_zoneroot',
-                    'nics',
-                    'quota',
-                    'state',
-                    'uuid',
-                    'zfs_filesystem',
-                    'zone_state',
-                    'zonename',
-                    'zonepath',
-                    'zpool'
-                ],
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js reprovision (%s)', uuid),
+                parseReady: true,
                 log: log
-            }, function (err, obj) {
-                if (err) {
-                    cb(err);
+            });
+
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
                     return;
                 }
-                vmobj = obj;
-                log.debug('Loaded VM is: ' + JSON.stringify(vmobj, null, 2));
+
                 cb();
             });
         }, function (cb) {
@@ -9399,17 +10133,21 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }, function (cb) {
             // ensure we're stopped before reprovision starts
-            if (vmobj.zone_state !== 'installed') {
-                VM.stop(uuid, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'unable to stop VM ' + uuid + ': '
-                            + e.message);
-                    }
-                    cb(e);
-                });
-            } else {
+            if (vmobj.zone_state === 'installed') {
                 cb();
+                return;
             }
+
+            VM.stop(uuid, {log: log}, function (e) {
+                if (e) {
+                    log.error({err: e}, 'unable to stop VM %s: %s',
+                        uuid, e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Set transition to provisioning now, we're going for it.
             setTransition(vmobj, 'provisioning', 'running',
@@ -9480,14 +10218,50 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }, function (cb) {
             // rename <zfs_filesystem> dataset out of the way
-            zfs(['rename', '-f', vmobj.zfs_filesystem, vmobj.zfs_filesystem
-                + '-reprovisioning-root'], log, function (err, fds) {
-
-                if (err) {
-                    log.error({err: err, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'Unable to (temporarily) rename '
-                        + vmobj.zfs_filesystem);
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['zpool'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var args = [
+                        'rename',
+                        '-f',
+                        vmobj.zfs_filesystem,
+                        vmobj.zfs_filesystem + '-reprovisioning-root'
+                    ];
+                    zfs(args, log, function (err, fds) {
+
+                        if (err) {
+                            log.error({
+                                err: err,
+                                stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Unable to (temporarily) rename %s',
+                                vmobj.zfs_filesystem);
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
                 }
+            ]}, function (err) {
                 cb(err);
             });
         }, function (cb) {
@@ -9559,7 +10333,7 @@ exports.reprovision = function (uuid, payload, options, callback)
             var retry_delay = 1; // second(s) between retries
 
             // clone the new image creating a new dataset for zoneroot
-            assert(snapshot);
+            assert(snapshot, 'reprovision snapshot');
 
             args = ['clone'];
             if (vmobj.hasOwnProperty('quota') && vmobj.quota > 0) {
@@ -9604,27 +10378,83 @@ exports.reprovision = function (uuid, payload, options, callback)
                 cb(err);
             });
         }, function (cb) {
-            createConfigDir(vmobj.zonepath, log, cb);
+            createConfigDir(vmobj.zonepath, log, function (err) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
-            /*
-             * Copy zones/<uuid>-reprovisioning-root/config to
-             * zones/<uuid>/config so that we keep existing metadata,
-             * IPF rules, routes, and so on.
-             */
-            var cmd = 'cp -pPR '
-                + vmobj.zonepath + '-reprovisioning-root/config/* '
-                + vmobj.zonepath + '/config/';
+            var cancelFn;
 
-            traceExec(cmd, log, 'cp-config', function (error, stdout, stderr) {
-                log.debug({'stdout': stdout, 'stderr': stderr}, 'cp results');
-                if (error) {
-                    error.stdout = stdout;
-                    error.stderr = stderr;
-                    cb(error);
-                    return;
-                } else {
-                    cb();
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var shouldBlock = false;
+
+                    var obj = {
+                        uuid: uuid,
+                        vm: {}
+                    };
+
+                    [
+                        'customer_metadata',
+                        'internal_metadata',
+                        'routes',
+                        'tags'
+                    ].forEach(function (key) {
+
+                        if (vmobj.hasOwnProperty(key)
+                            && Object.keys(vmobj[key]).length > 0) {
+
+                            obj.vm[key] = vmobj[key];
+                            shouldBlock = true;
+                        }
+                    });
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    if (!shouldBlock) {
+                        // Nothing will be changed by the metadata copy
+                        cb2();
+                        return;
+                    }
+
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    /*
+                     * Copy zones/<uuid>-reprovisioning-root/config to
+                     * zones/<uuid>/config so that we keep existing metadata,
+                     * IPF rules, routes, and so on.
+                     */
+                    var cmd = 'cp -pPR '
+                        + vmobj.zonepath + '-reprovisioning-root/config/* '
+                        + vmobj.zonepath + '/config/';
+
+                    traceExec(cmd, log, 'cp-config',
+                        function (error, stdout, stderr) {
+
+                        log.debug({stdout: stdout, stderr: stderr},
+                            'cp results');
+
+                        if (error) {
+                            cancelFn();
+                            error.stdout = stdout;
+                            error.stderr = stderr;
+                            cb2(error);
+                            return;
+                        }
+
+                        cb2();
+                    });
                 }
+            ]}, function (err) {
+                cb(err);
             });
         }, function (cb) {
             // destroy <zonepath>-reprovisioning-root, since it's no longer used
@@ -9764,6 +10594,10 @@ exports.reprovision = function (uuid, payload, options, callback)
             });
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (err && set_transition) {
             // remove transition now, if we failed.
             VM.unsetTransition(vmobj, {log: log}, function () {
@@ -10021,60 +10855,48 @@ exports.send = function (uuid, target, options, callback)
             if (target === 'stdout' && tty.isatty(1)) {
                 log.error('Cannot send VM to a TTY.');
                 cb(new Error('Cannot send VM to a TTY.'));
-            } else {
-                cb();
+                return;
             }
+
+            cb();
         }, function (cb) {
             // NOTE: for this load we always load all fields, because we need
             // to send them all to the target machine.
             VM.load(uuid, {log: log}, function (err, obj) {
                 if (err) {
                     cb(err);
-                } else {
-                    vmobj = obj;
-                    cb();
+                    return;
                 }
+
+                vmobj = obj;
+                cb();
             });
         }, function (cb) {
             datasets = getAllDatasets(vmobj);
             if (datasets.length < 1) {
                 log.error('Cannot send VM with no datasets.');
                 cb(new Error('VM has no datasets.'));
-            } else {
-                cb();
+                return;
             }
-        }, function (cb) {
-            if (vmobj.state !== 'stopped') {
-                // In this case we need to stop it and make sure it stopped.
-                VM.stop(uuid, {log: log}, function (e) {
-                    if (e) {
-                        log.error(e, 'unable to stop VM ' + uuid + ': '
-                            + e.message);
-                        cb(e);
-                        return;
-                    }
-                    VM.load(uuid, {fields: ['zone_state', 'uuid'], log: log},
-                        function (error, obj) {
 
-                        if (error) {
-                            log.error(error, 'unable to reload VM ' + uuid
-                                + ': ' + error.message);
-                            return;
-                        }
-                        if (obj.zone_state !== 'installed') {
-                            log.error('after stop attempt, state is '
-                                + obj.zone_state + ' != installed');
-                            cb(new Error('state after stopping is '
-                                + obj.zone_state + ' != installed'));
-                            return;
-                        }
-                        cb();
-                    });
-                });
-            } else {
-                // already stopped, good to go!
+            cb();
+        }, function (cb) {
+            if (vmobj.state === 'stopped') {
                 cb();
+                return;
             }
+
+            // Stop the VM
+            VM.stop(uuid, {log: log}, function (e) {
+                if (e) {
+                    log.error({err: e}, 'unable to stop VM %s: %s',
+                        uuid, e.message);
+                    cb(e);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Clean up trash left from broken datasets (see OS-388)
             try {
@@ -10091,6 +10913,7 @@ exports.send = function (uuid, target, options, callback)
         }, function (cb) {
             // send JSON
             var json = JSON.stringify(vmobj, null, 2) + '\n';
+            log.debug({json: json}, 'Sending JSON to target: %s', target);
             sendJSON(target, json, log, cb);
         }, function (cb) {
             // send datasets
@@ -10098,9 +10921,12 @@ exports.send = function (uuid, target, options, callback)
                 sendDataset(target, ds, log, c);
             }, function (e) {
                 if (e) {
-                    log.error('Failed to send datasets');
+                    log.error({err: e}, 'Failed to send datasets');
+                    cb(e);
+                    return;
                 }
-                cb(e);
+
+                cb();
             });
         }
     ], function (err) {
@@ -10348,9 +11174,9 @@ function deleteVolume(volume, log, callback)
 
 function deleteZone(uuid, log, callback)
 {
-    var load_fields;
     var tracers_obj;
     var vmobj;
+    var vs;
 
     assert(log, 'no logger passed to deleteZone()');
 
@@ -10360,26 +11186,22 @@ function deleteZone(uuid, log, callback)
         log = tracers_obj.log;
     }
 
-    load_fields = [
-        'archive_on_delete',
-        'disks',
-        'docker',
-        'filesystems',
-        'indestructible_delegated',
-        'indestructible_zoneroot',
-        'uuid',
-        'zonename',
-        'zonepath'
-    ];
-
     async.series([
         function (cb) {
-            VM.load(uuid, {fields: load_fields, log: log}, function (err, obj) {
-                if (err) {
-                    cb(err);
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js deleteZone (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
                     return;
                 }
-                vmobj = obj;
+
                 cb();
             });
         }, function (cb) {
@@ -10494,7 +11316,9 @@ function deleteZone(uuid, log, callback)
             });
         }, function (cb) {
             log.debug('halting zone');
-            zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
+            zoneadm(['-u', uuid, 'halt', '-X'], log,
+                function (e, fds) {
+
                 if (e) {
                     log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
                         'Error halting zone');
@@ -10515,15 +11339,60 @@ function deleteZone(uuid, log, callback)
                 cb();
             });
         }, function (cb) {
-            log.debug('uninstalling zone');
-            zoneadm(['-u', uuid, 'uninstall', '-F'], log, function (e, fds) {
-                if (e) {
-                    log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'Error uninstalling zone: ' + e.message);
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'uninstalled zone');
+            var cancelFn;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['zone_state'],
+                            action: 'changed',
+                            newValue: 'configured'
+                        },
+                        {
+                            path: ['zfs_filesystem'],
+                            action: 'removed'
+                        },
+                        {
+                            path: ['zpool'],
+                            action: 'removed'
+                        }
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    log.debug('uninstalling zone');
+                    zoneadm(['-u', uuid, 'uninstall', '-F'], log,
+                        function (e, fds) {
+
+                        if (e) {
+                            log.warn({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Error uninstalling zone: %s', e.message);
+                            cancelFn();
+                            cb2(e);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'uninstalled zone');
+                        cb2();
+                    });
+                }]
+            }, function (err, res) {
+                if (err) {
+                    cb(err);
+                    return;
                 }
+
                 cb();
             });
         }, function (cb) {
@@ -10555,36 +11424,49 @@ function deleteZone(uuid, log, callback)
                 return;
             }
 
-            log.debug('deleting zone');
-            zonecfg(uuid, ['delete', '-F'],
-                {log: log}, function (e, fds) {
+            var cancelFn;
 
-                if (e) {
-                    log.warn({err: e, stdout: fds.stdout,
-                        stderr: fds.stderr}, 'Error deleting VM');
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'deleted VM ' + uuid);
-                }
-                cb();
-            });
-        }, function (cb) {
-            VM.load(uuid, {fields: ['uuid'], log: log, missing_ok: true},
-                function (err, obj) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    // block on vminfod event
+                    var obj = {
+                        type: 'delete',
+                        uuid: uuid
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
 
-                if (err && err.code === 'ENOENT') {
-                    // the zone is gone, that's good.
-                    log.debug('confirmed VM is gone.');
-                    cb();
-                } else if (err) {
-                    // there was am unexpected error.
-                    cb(err);
-                } else {
-                    // the VM still exists!
-                    err = new Error('VM still exists after delete.');
-                    err.code = 'EEXIST';
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    log.debug('deleting zone');
+                    zonecfg(uuid, ['delete', '-F'],
+                        {log: log},
+                        function (e, fds) {
+
+                        if (e) {
+                            log.warn({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'Error deleting VM');
+                            cancelFn();
+                            cb2(e);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'deleted VM %s', uuid);
+                        cb2();
+                    });
+                }]
+            }, function (err, res) {
+                if (err) {
                     cb(err);
+                    return;
                 }
+
+                cb();
             });
         }, function (cb) {
             // delete the incoming payload if it exists
@@ -10600,6 +11482,10 @@ function deleteZone(uuid, log, callback)
             );
         }
     ], function (error) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         callback(error);
     });
 }
@@ -10697,7 +11583,6 @@ function startZone(vmobj, opts, callback)
     var uuid = vmobj.uuid;
     var waited = false;
     var waitErr;
-    var zonestream;
 
     assert(log, 'no logger passed to startZone()');
 
@@ -10717,6 +11602,7 @@ function startZone(vmobj, opts, callback)
         set_autoboot = 'select attr name=vm-autoboot; set value=true; end';
     }
 
+    var vs;
     async.series([
         function (cb) {
             // If the caller passed a waiting function, start it before we try
@@ -10732,76 +11618,54 @@ function startZone(vmobj, opts, callback)
             }
             cb();
         }, function (cb) {
-            // get a zone watcher object if a waiting function is not passed in
-            if (opts.state_waiter) {
-                cb();
-                return;
-            }
-
-            getZoneWatcher({log: log}, function (err, _stream) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
+            // create a vminfod event stream - we use this to make sure the VM
+            // transitions into the "running" state before moving on
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js startZone (%s)', vmobj.uuid),
+                log: log
+            });
 
-                zonestream = _stream;
+            vs.once('ready', function () {
                 cb();
             });
         }, function (cb) {
-            var cancel;
+            // do the booting
+            var cancelFn;
 
             vasync.parallel({funcs: [
                 function (cb2) {
-                    // if we already have a state_waiter we can skip blocking
-                    // on waitForZoneState
-                    if (opts.state_waiter) {
-                        assert(!zonestream,
-                            'zone stream set with state_waiter');
-                        cb2();
-                        return;
-                    }
-
-                    // call waitForZoneState with the zonestream we allocated
-                    // above
-                    assert(zonestream, 'zone stream not set');
-                    var _opts = {
-                        timeout: 30,
-                        log: log,
-                        skipConfirmation: true,
-                        stream: zonestream
+                    var obj = {
+                        uuid: vmobj.uuid
                     };
-                    cancel = VM.waitForZoneState(vmobj, 'running', _opts,
-                        function (err, result) {
-
-                        if (err) {
-                            if (err.code === 'ETIMEOUT') {
-                                log.info({err: err},
-                                    'timeout waiting for zone to go to '
-                                    + '"running"');
-                            } else {
-                                log.error({err: err},
-                                    'unknown error waiting for zone to '
-                                    + 'go to "running"');
+                    var changes = [
+                        [
+                            {
+                                path: ['state'],
+                                action: 'changed',
+                                newValue: 'running'
+                            },
+                            {
+                                path: ['state'],
+                                action: 'changed',
+                                newValue: 'stopped'
                             }
-                            cb2(err);
-                            return;
-                        }
+                        ]
+                    ];
+                    var _opts = {
+                        timeout: PROVISION_TIMEOUT * 1000,
+                        catchErrors: true,
+                        startFresh: true
+                    };
 
-                        log.info('VM switched to "running"');
-                        cb2();
-                    });
+                    cancelFn = vs.watchForChanges(obj, changes, _opts, cb2);
                 }, function (cb2) {
-                    // do the booting
                     zoneadm(['-u', uuid, 'boot', '-X'], log,
                         function (err, boot_fds) {
-
                         if (err) {
                             log.error({err: err, stdout: boot_fds.stdout,
                                 stderr: boot_fds.stderr},
                                 'zoneadm failed to boot VM');
-                            if (cancel) {
-                                cancel();
-                            }
+                            cancelFn();
                             cb2(err);
                             return;
                         }
@@ -10809,27 +11673,36 @@ function startZone(vmobj, opts, callback)
                         log.debug({stdout: boot_fds.stdout,
                             stderr: boot_fds.stderr},
                             'zoneadm booted VM');
-                        cb2();
+                        cb2(err);
                     });
                 }
-            ]}, cb);
+            ]}, function (err, results) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
         }, function (cb) {
             // Ensure it booted. If caller passed in a function that can wait
             // for a zone to go to a state, we'll just call that.
-            if (opts.state_waiter) {
-                function _waitWaiter() {
-                    if (waited) {
-                        cb(waitErr);
-                        return;
-                    }
-                    setTimeout(_waitWaiter, 100);
+            function _waitWaiter() {
+                if (waited) {
+                    cb(waitErr);
+                    return;
                 }
+                setTimeout(_waitWaiter, 100);
+            }
+            if (opts.state_waiter) {
                 _waitWaiter();
                 return;
             }
 
             cb();
         }, function (cb) {
+            var cancelFn;
+
             if (vmobj.docker && vmobj.internal_metadata
                 && !vmobj.internal_metadata['docker:restartpolicy']) {
 
@@ -10838,7 +11711,9 @@ function startZone(vmobj, opts, callback)
                     'docker VM has no restart policy, not setting autoboot');
                 cb();
                 return;
-            } else if (vmobj.docker && vmobj.internal_metadata) {
+            }
+
+            if (vmobj.docker && vmobj.internal_metadata) {
                 // all other policies currently involve rebooting at least on CN
                 // reboot.
                 log.info({
@@ -10847,26 +11722,67 @@ function startZone(vmobj, opts, callback)
                 }, 'docker VM has restart policy, setting autoboot');
             }
 
-            zonecfg(uuid, [set_autoboot], {log: log},
-                function (err, autoboot_fds) {
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    if (vmobj.autoboot) {
+                        cb2();
+                        return;
+                    }
+                    var obj = {
+                        uuid: vmobj.uuid,
+                        vm: {
+                            autoboot: true
+                        }
+                    };
+                    var _opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        startFresh: true
+                    };
+
+                    cancelFn = vs.watchForEvent(obj, _opts, cb2);
+                }, function (cb2) {
+                    zonecfg(uuid, [set_autoboot], {log: log},
+                        function (err, autoboot_fds) {
+
+                        if (err) {
+                            // The vm is running at this point, erroring out
+                            // here would do no good, so we just log it.
+                            log.error({
+                                err: err,
+                                stdout: autoboot_fds.stdout,
+                                stderr: autoboot_fds.stderr},
+                                'startZone(): Failed to "%s" for %s',
+                                set_autoboot,
+                                uuid);
+
+                            if (cancelFn)
+                                cancelFn();
+                            cb2();
+                            return;
+                        }
+
+                        log.debug({
+                            stdout: autoboot_fds.stdout,
+                            stderr: autoboot_fds.stderr},
+                            'set autoboot for %s', uuid);
 
+                        cb2();
+                    });
+                }
+            ]}, function (err, results) {
                 if (err) {
-                    // The vm is running at this point, erroring out here would
-                    // do no good, so we just log it.
-                    log.error({err: err, stdout: autoboot_fds.stdout,
-                        stderr: autoboot_fds.stderr}, 'startZone(): Failed to '
-                        + set_autoboot + ' for ' + uuid);
-                } else {
-                    log.debug({stdout: autoboot_fds.stdout,
-                        stderr: autoboot_fds.stderr}, 'set autoboot');
+                    cb(err);
+                    return;
                 }
-                cb(err);
+                cb();
             });
         }, function (cb) {
             if (!vmobj.never_booted) {
                 cb();
                 return;
             }
+
             zonecfg(uuid, ['remove attr name=never-booted'],
                 {log: log}, function (err, neverbooted_fds) {
 
@@ -10884,8 +11800,12 @@ function startZone(vmobj, opts, callback)
             });
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (!err) {
-            log.info('Started ' + uuid);
+            log.info('Started %s', uuid);
         }
         callback(err);
     });
@@ -11399,16 +12319,24 @@ function performSnapshotRollback(snapshots, log, callback)
     });
 }
 
-function updateZonecfgTimestamp(vmobj, callback)
+function updateZonecfgTimestamp(vmobj, options, callback)
 {
     var file;
     var now;
 
-    assert(vmobj.zonename, 'updateZonecfgTimestamp() vmobj must have '
-        + '.zonename');
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(vmobj, 'vmobj');
+    assert.string(vmobj.zonename, 'vmobj.zonename');
+    assert.object(options, 'options');
+    assert.optionalDate(options.date, 'options.date');
+    assert.func(callback, 'callback');
 
-    file = path.join('/etc/zones/', vmobj.zonename + '.xml');
-    now = new Date();
+    file = zoneXMLPath(vmobj.zonename);
+    now = options.date || new Date();
 
     fs.utimes(file, now, now, callback);
 }
@@ -11532,9 +12460,16 @@ exports.rollback_snapshot = function (uuid, snapname, options, callback)
 
 exports.delete_snapshot = function (uuid, snapname, options, callback)
 {
-    var load_fields;
+    var found;
+    var lockpath;
     var log;
+    var mountpath;
+    var mountpoint;
     var tracers_obj;
+    var unlock;
+    var vmobj;
+    var vs;
+    var zoneroot;
 
     // options is optional
     if (arguments.length === 3) {
@@ -11555,143 +12490,279 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
         log = tracers_obj.log;
     }
 
+    assert.uuid(uuid, 'uuid');
+    assert.string(snapname, 'snapname');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+    assert(log, 'log');
+
     if (!validSnapshotName(snapname, log)) {
         callback(new Error('Invalid snapshot name'));
         return;
     }
 
-    load_fields = [
-        'brand',
-        'snapshots',
-        'zfs_filesystem',
-        'zonepath',
-        'zonename'
-    ];
-
-    VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
-        var found;
-        var mountpath;
-        var mountpoint;
-        var snap;
-        var zoneroot;
-
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
-            callback(new Error('snapshots for ' + vmobj.brand
-                + ' VMs currently unsupported'));
-            return;
-        }
+    lockpath = zoneConfigLockpath(uuid);
 
-        found = false;
-        if (vmobj.hasOwnProperty('snapshots')) {
-            for (snap in vmobj.snapshots) {
-                if (vmobj.snapshots[snap].name === snapname) {
-                    found = true;
-                    break;
+    vasync.waterfall([
+        function (cb) {
+            // Acquire lockfile
+            log.debug('acquiring lock on %s', lockpath);
+            lock(lockpath, function (err, _unlock) {
+                if (err) {
+                    log.error('failed to acquire lock on %s', lockpath);
+                    cb(err);
+                    return;
                 }
-            }
-        }
-        if (!found) {
-            callback(new Error('No snapshot named "' + snapname + '" for '
-                + uuid));
-            return;
-        }
 
-        zoneroot = vmobj.zonepath + '/root';
-        mountpath = '/checkpoints/' + snapname;
-        mountpoint = zoneroot + '/' + mountpath;
+                log.debug('acquired lock on %s', lockpath);
+                unlock = _unlock;
+                cb();
+            });
+        }, function (cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js delete_snapshot (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
 
-        vasync.waterfall([
-            function (cb) {
-                // Ensure it's safe for us to be doing something in this dir
+            vs.once('ready', function (ready_ev) {
                 try {
-                    assertSafeZonePath(zoneroot, mountpath,
-                        {type: 'dir', enoent_ok: true});
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
                 } catch (e) {
-                    log.error(e, 'Unsafe mountpoint for checkpoints: '
-                        + e.message);
                     cb(e);
                     return;
                 }
-                cb();
-            }, function (cb) {
-                // umount snapshot
-                var argv;
-                var cmd = '/usr/sbin/umount';
 
-                argv = [mountpoint];
+                cb();
+            });
+        }, function (cb) {
+            var snap;
 
-                traceExecFile(cmd, argv, log, 'umount-snapshot',
-                    function (e, stdout, stderr) {
+            if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+                callback(new Error('snapshots for ' + vmobj.brand
+                    + ' VMs currently unsupported'));
+                return;
+            }
 
-                    if (e) {
-                        log.error({err: e}, 'There was an error while '
-                            + 'unmounting the snapshot: ' + e.message);
-                        // we treat an error here as fatal only if the error
-                        // was something other than 'not mounted'
-                        if (!stderr.match(/ not mounted/)) {
-                            cb(e);
-                            return;
-                        }
-                    } else {
-                        log.trace('umounted ' + mountpoint);
-                    }
-                    cb();
-                });
-            }, function (cb) {
-                // remove the mountpoint directory
-                fs.rmdir(mountpoint, function (e) {
-                    if (e) {
-                        log.error(e);
-                    } else {
-                        log.trace('removed directory ' + mountpoint);
+            found = false;
+            if (vmobj.hasOwnProperty('snapshots')) {
+                for (snap in vmobj.snapshots) {
+                    if (vmobj.snapshots[snap].name === snapname) {
+                        found = true;
+                        break;
                     }
-                    cb(); // XXX not fatal because might also not exist
-                });
-            }, function (cb) {
-                var args;
+                }
+            }
+            if (!found) {
+                cb(new Error('No snapshot named "' + snapname + '" for '
+                    + uuid));
+                return;
+            }
 
-                args = ['destroy', vmobj.zfs_filesystem + '@vmsnap-'
-                    + snapname];
+            zoneroot = vmobj.zonepath + '/root';
+            mountpath = '/checkpoints/' + snapname;
+            mountpoint = zoneroot + '/' + mountpath;
 
-                zfs(args, log, function (e, fds) {
-                    if (e) {
-                        log.error({'err': e, 'stdout': fds.stdout,
-                            'stderr': fds.stdout}, 'zfs destroy failed.');
+            cb();
+        }, function (cb) {
+            // Ensure it's safe for us to be doing something in this dir
+            try {
+                assertSafeZonePath(zoneroot, mountpath,
+                    {type: 'dir', enoent_ok: true});
+            } catch (e) {
+                log.error(e, 'Unsafe mountpoint for checkpoints: '
+                    + e.message);
+                cb(e);
+                return;
+            }
+            cb();
+        }, function (cb) {
+            // umount snapshot
+            var argv;
+            var cmd = '/usr/sbin/umount';
+
+            argv = [mountpoint];
+
+            traceExecFile(cmd, argv, log, 'umount-snapshot',
+                function (e, stdout, stderr) {
+
+                if (e) {
+                    log.error({err: e}, 'There was an error while '
+                        + 'unmounting the snapshot: ' + e.message);
+                    // we treat an error here as fatal only if the error
+                    // was something other than 'not mounted'
+                    if (!stderr.match(/ not mounted/)) {
                         cb(e);
                         return;
                     }
-                    log.debug({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'zfs destroy ' + vmobj.zfs_filesystem + '@vmsnap-'
-                        + snapname);
-                    cb();
-                });
-            }, function (cb) {
-                updateZonecfgTimestamp(vmobj, function (e) {
-                    if (e) {
-                        log.warn(e, 'failed to update timestamp after deleting '
-                            + 'snapshot');
+                } else {
+                    log.trace('umounted ' + mountpoint);
+                }
+                cb();
+            });
+        }, function (cb) {
+            // remove the mountpoint directory
+            fs.rmdir(mountpoint, function (e) {
+                if (e) {
+                    log.error(e);
+                } else {
+                    log.trace('removed directory ' + mountpoint);
+                }
+                cb(); // XXX not fatal because might also not exist
+            });
+        }, function (cb) {
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        [
+                            {
+                                path: ['snapshots', null, 'name'],
+                                action: 'changed',
+                                oldValue: snapname
+                            },
+                            {
+                                path: ['snapshots', null],
+                                action: 'removed',
+                                oldValue: {
+                                    name: snapname
+                                }
+                            }
+                        ]
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: false
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    var zfssnapname = util.format('%s@vmsnap-%s',
+                        vmobj.zfs_filesystem, snapname);
+
+                    var args = ['destroy', zfssnapname];
+
+                    zfs(args, log, function (e, fds) {
+                        if (e) {
+                            log.error({err: e, stdout: fds.stdout,
+                                stderr: fds.stdout},
+                                'zfs destroy failed.');
+                            cancelFn();
+                            cb2(e);
+                            return;
+                        }
+
+                        log.debug({err: e, stdout: fds.stdout,
+                            stderr: fds.stderr},
+                            'zfs destroy %s',
+                            zfssnapname);
+                        cb2();
+                    });
+                }
+            ]}, function (err2) {
+                cb(err2);
+            });
+        }, function (cb) {
+            var cancelFn;
+            var now = new Date();
+            var lastModified = new Date(vmobj.last_modified);
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    /*
+                     * The last modified timestamp has second resolution, so it
+                     * is possible that updating this timestamp could result in
+                     * no effective change, meaning vminfod will not consider
+                     * it an update.
+                     *
+                     * To remedy this, we check the current time (in seconds)
+                     * against the current last_modified time (in seconds), and
+                     * only block for a change if they are different.
+                     */
+
+                    var changes = [];
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var nowSecs = Math.floor(now.getTime() / 1000);
+                    var thenSecs = Math.floor(lastModified.getTime() / 1000);
+
+                    if (thenSecs !== nowSecs) {
+                        changes.push({
+                            path: ['last_modified'],
+                            action: 'changed',
+                            oldValue: new Date(thenSecs * 1000).toISOString(),
+                            newValue: new Date(nowSecs * 1000).toISOString()
+                        });
                     }
-                    // don't pass err because there's no recovery possible
-                    // (the snapshot's gone)
-                    cb();
-                });
-            }
-        ], function (error) {
-            callback(error);
-        });
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: false
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    // update timestamp so last_modified gets bumped
+                    updateZonecfgTimestamp(vmobj, {date: now}, function (e) {
+                        if (e) {
+                            log.warn({err: e}, 'failed to update '
+                                + 'timestamp after deleting snapshot');
+                            cancelFn();
+                            // don't pass err because there's no recovery
+                            // possible (the snapshot's gone)
+                            cb2();
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err2) {
+                cb(err2);
+            });
+        }
+    ], function (error) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
+
+        if (unlock) {
+            unlock(function (unlock_err) {
+                if (unlock_err) {
+                    log.error({err: unlock_err},
+                        'failed to unlock %s', lockpath);
+                }
+                callback(error || unlock_err);
+            });
+            return;
+        }
+
+        callback(error);
     });
 };
 
 exports.create_snapshot = function (uuid, snapname, options, callback)
 {
-    var load_fields;
+    var lockpath;
     var log;
+    var mount_snapshot = true;
+    var mountpath;
+    var mountpoint;
+    var snapshot_list = [];
     var tracers_obj;
+    var unlock;
+    var vmobj;
+    var vs;
+    var zoneroot;
 
     // options is optional
     if (arguments.length === 3) {
@@ -11713,197 +12784,317 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
         log = tracers_obj.log;
     }
 
+    assert.uuid(uuid, 'uuid');
+    assert.string(snapname, 'snapname');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+    assert(log, 'log');
+
     if (!validSnapshotName(snapname, log)) {
         callback(new Error('Invalid snapshot name'));
         return;
     }
 
-    load_fields = [
-        'brand',
-        'datasets',
-        'zone_state',
-        'snapshots',
-        'zfs_filesystem',
-        'zonepath',
-        'zonename'
-    ];
+    lockpath = zoneConfigLockpath(uuid);
 
-    VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
-        var full_snapname;
-        var mountpath;
-        var mountpoint;
-        var mount_snapshot = true;
-        var snap;
-        var snapshot_list = [];
-        var zoneroot;
+    vasync.waterfall([
+        function (cb) {
+            // Acquire lockfile
+            log.debug('acquiring lock on %s', lockpath);
+            lock(lockpath, function (err, _unlock) {
+                if (err) {
+                    log.error('failed to acquire lock on %s', lockpath);
+                    cb(err);
+                    return;
+                }
 
-        if (err) {
-            callback(err);
-            return;
-        }
+                log.debug('acquired lock on %s', lockpath);
+                unlock = _unlock;
+                cb();
+            });
+        }, function (cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js create_snapshot (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
 
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
-            callback(new Error('snapshots for ' + vmobj.brand
-                + ' VMs currently unsupported'));
-            return;
-        }
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
+                    return;
+                }
 
-        if (vmobj.hasOwnProperty('datasets') && vmobj.datasets.length > 0) {
-            callback(new Error('Cannot currently snapshot zones that have '
-                + 'datasets'));
-            return;
-        }
+                cb();
+            });
+        }, function (cb) {
+            var full_snapname;
+            var snap;
 
-        if (!vmobj.hasOwnProperty('zfs_filesystem')) {
-            callback(new Error('vmobj missing zfs_filesystem, cannot create '
-                + 'snapshot'));
-            return;
-        }
+            if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+                cb(new Error('snapshots for ' + vmobj.brand
+                    + ' VMs currently unsupported'));
+                return;
+            }
 
-        full_snapname = vmobj.zfs_filesystem + '@vmsnap-' + snapname;
+            if (vmobj.hasOwnProperty('datasets') && vmobj.datasets.length > 0) {
+                cb(new Error('Cannot currently snapshot zones that have '
+                    + 'datasets'));
+                return;
+            }
 
-        // Check that name not already used
-        if (vmobj.hasOwnProperty('snapshots')) {
-            for (snap in vmobj.snapshots) {
-                snap = vmobj.snapshots[snap];
+            if (!vmobj.hasOwnProperty('zfs_filesystem')) {
+                cb(new Error('vmobj missing zfs_filesystem, cannot create '
+                    + 'snapshot'));
+                return;
+            }
 
-                if (snap.name === full_snapname) {
-                    callback(new Error('snapshot with name "' + snapname
-                        + '" already exists.'));
-                    return;
-                } else {
-                    log.debug('SKIPPING ' + snap.name);
+            // Check that name not already used
+            if (vmobj.hasOwnProperty('snapshots')) {
+                for (snap in vmobj.snapshots) {
+                    snap = vmobj.snapshots[snap];
+
+                    if (snap.name === snapname) {
+                        cb(new Error('snapshot with name "' + snapname
+                            + '" already exists.'));
+                        return;
+                    } else {
+                        log.debug('SKIPPING ' + snap.name);
+                    }
                 }
             }
-        }
 
-        snapshot_list.push(full_snapname);
+            full_snapname = vmobj.zfs_filesystem + '@vmsnap-' + snapname;
+            snapshot_list.push(full_snapname);
 
-        // assert snapshot_list.length > 0
+            log.info('Taking snapshot "%s" of %s', snapname, uuid);
 
-        log.info('Taking snapshot "' + snapname + '" of ' + uuid);
+            zoneroot = vmobj.zonepath + '/root';
+            mountpath = '/checkpoints/' + snapname;
+            mountpoint = zoneroot + '/' + mountpath;
 
-        zoneroot = vmobj.zonepath + '/root';
-        mountpath = '/checkpoints/' + snapname;
-        mountpoint = zoneroot + '/' + mountpath;
+            cb();
+        }, function (cb) {
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        [
+                            {
+                                path: ['snapshots', null, 'name'],
+                                action: 'changed',
+                                newValue: snapname
+                            },
+                            {
+                                path: ['snapshots', null],
+                                action: 'added',
+                                newValue: {
+                                    name: snapname
+                                }
+                            }
+                        ]
+                    ];
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: false
+                    };
 
-        vasync.waterfall([
-            function (cb) {
-                // take the snapshot
-                var args;
-                args = ['snapshot'].concat(snapshot_list);
-
-                zfs(args, log, function (zfs_err, fds) {
-                    if (zfs_err) {
-                        log.error({err: zfs_err, stdout: fds.stdout,
-                            stderr: fds.stdout}, 'zfs snapshot failed.');
-                    } else {
-                        log.debug({err: zfs_err, stdout: fds.stdout,
-                            stderr: fds.stderr}, 'zfs ' + args.join(' '));
-                    }
-                    cb(zfs_err);
-                });
-            }, function (cb) {
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    // take the snapshot
+                    var args = ['snapshot'].concat(snapshot_list);
+
+                    zfs(args, log, function (zfs_err, fds) {
+                        if (zfs_err) {
+                            log.error({err: zfs_err, stdout: fds.stdout,
+                                stderr: fds.stdout},
+                                'zfs snapshot failed.');
+                            cancelFn();
+                            cb2(zfs_err);
+                            return;
+                        }
 
-                if (vmobj.zone_state !== 'running') {
-                    log.info('Not mounting snapshot as zone is in state '
-                        + vmobj.zone_state + ', must be: running');
-                    mount_snapshot = false;
-                    cb();
-                    return;
+                        log.debug({err: zfs_err, stdout: fds.stdout,
+                            stderr: fds.stderr},
+                            'zfs %s', args.join(' '));
+                        cb2();
+                    });
                 }
+            ]}, function (err2) {
+                cb(err2);
+            });
+        }, function (cb) {
+            if (vmobj.zone_state !== 'running') {
+                log.info('Not mounting snapshot as zone is in state '
+                    + vmobj.zone_state + ', must be: running');
+                mount_snapshot = false;
+                cb();
+                return;
+            }
 
-                // Ensure it's safe for us to be doing something in this dir
-                try {
-                    assertSafeZonePath(zoneroot, mountpath,
-                        {type: 'dir', enoent_ok: true});
-                } catch (e) {
-                    log.error(e, 'Unsafe mountpoint for checkpoints: '
-                        + e.message);
-                    cb(e);
-                    return;
-                }
+            // Ensure it's safe for us to be doing something in this dir
+            try {
+                assertSafeZonePath(zoneroot, mountpath,
+                    {type: 'dir', enoent_ok: true});
+            } catch (e) {
+                log.error(e, 'Unsafe mountpoint for checkpoints: '
+                    + e.message);
+                cb(e);
+                return;
+            }
+            cb();
+        }, function (cb) {
+            // Make the mountpoint directory and parent
+            var newmode;
+
+            if (mount_snapshot === false) {
                 cb();
-            }, function (cb) {
-                // Make the mountpoint directory and parent
-                var newmode;
+                return;
+            }
 
-                if (mount_snapshot === false) {
-                    cb();
+            /*jsl:ignore*/
+            newmode = 0755;
+            /*jsl:end*/
+
+            function doMkdir(dir, callbk) {
+                fs.mkdir(dir, newmode, function (e) {
+                    if (e && e.code !== 'EEXIST') {
+                        log.error({err: e}, 'unable to create mountpoint '
+                            + 'for checkpoints: ' + e.message);
+                        callbk(e);
+                        return;
+                    }
+                    callbk();
+                });
+            }
+
+            doMkdir(path.dirname(mountpoint), function (parent_e) {
+                if (parent_e) {
+                    cb(parent_e);
                     return;
                 }
+                doMkdir(mountpoint, function (dir_e) {
+                    if (dir_e) {
+                        cb(dir_e);
+                        return;
+                    }
 
-                /*jsl:ignore*/
-                newmode = 0755;
-                /*jsl:end*/
+                    log.debug('created ' + mountpoint);
+                    cb();
+                });
+            });
+        }, function (cb) {
+            var argv;
+            var cmd = '/usr/sbin/mount';
+            var snapdir;
 
-                function doMkdir(dir, callbk) {
-                    fs.mkdir(dir, newmode, function (e) {
-                        if (e && e.code !== 'EEXIST') {
-                            log.error({err: e}, 'unable to create mountpoint '
-                                + 'for checkpoints: ' + e.message);
-                            callbk(e);
-                            return;
-                        }
-                        callbk();
-                    });
+            if (mount_snapshot === false) {
+                cb();
+                return;
+            }
+
+            snapdir = vmobj.zonepath + '/.zfs/snapshot/vmsnap-' + snapname
+                + '/root';
+            argv = [ '-F', 'lofs', '-o', 'ro,setuid,nodevices', snapdir,
+                mountpoint];
+
+            traceExecFile(cmd, argv, log, 'mount-snapshot',
+                function (e, stdout, stderr) {
+
+                if (e) {
+                    log.error({err: e}, 'unable to mount snapshot: '
+                        + e.message);
                 }
+                // not fatal becase snapshot was already created.
+                cb();
+            });
+        }, function (cb) {
+            var cancelFn;
+            var now = new Date();
+            var lastModified = new Date(vmobj.last_modified);
 
-                doMkdir(path.dirname(mountpoint), function (parent_e) {
-                    if (parent_e) {
-                        cb(parent_e);
-                        return;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    /*
+                     * The last modified timestamp has second resolution, so it
+                     * is possible that updating this timestamp could result in
+                     * no effective change, meaning vminfod will not consider
+                     * it an update.
+                     *
+                     * To remedy this, we check the current time (in seconds)
+                     * against the current last_modified time (in seconds), and
+                     * only block for a change if they are different.
+                     */
+
+                    var changes = [];
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var nowSecs = Math.floor(now.getTime() / 1000);
+                    var thenSecs = Math.floor(lastModified.getTime() / 1000);
+
+                    if (thenSecs !== nowSecs) {
+                        changes.push({
+                            path: ['last_modified'],
+                            action: 'changed',
+                            oldValue: new Date(thenSecs * 1000).toISOString(),
+                            newValue: new Date(nowSecs * 1000).toISOString()
+                        });
                     }
-                    doMkdir(mountpoint, function (dir_e) {
-                        if (dir_e) {
-                            cb(dir_e);
+
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: false
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    // update timestamp so last_modified gets bumped
+                    updateZonecfgTimestamp(vmobj, {date: now}, function (e) {
+                        if (e) {
+                            log.warn({err: e},
+                                'failed to update timestamp after snapshot');
+                            cancelFn();
+                            // ignore error since there's no recovery
+                            // (snapshot was created)
+                            cb2();
                             return;
                         }
 
-                        log.debug('created ' + mountpoint);
-                        cb();
+                        cb2();
                     });
-                });
-            }, function (cb) {
-                var argv;
-                var cmd = '/usr/sbin/mount';
-                var snapdir;
-
-                if (mount_snapshot === false) {
-                    cb();
-                    return;
                 }
+            ]}, function (err2) {
+                cb(err2);
+            });
+        }
+    ], function (error) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
 
-                snapdir = vmobj.zonepath + '/.zfs/snapshot/vmsnap-' + snapname
-                    + '/root';
-                argv = [ '-F', 'lofs', '-o', 'ro,setuid,nodevices', snapdir,
-                    mountpoint];
-
-                traceExecFile(cmd, argv, log, 'mount-snapshot',
-                    function (e, stdout, stderr) {
+        if (unlock) {
+            unlock(function (unlock_err) {
+                if (unlock_err) {
+                    log.error({err: unlock_err},
+                        'failed to unlock %s', lockpath);
+                }
+                callback(error || unlock_err);
+            });
+            return;
+        }
 
-                    if (e) {
-                        log.error({err: e}, 'unable to mount snapshot: '
-                            + e.message);
-                    }
-                    // not fatal becase snapshot was already created.
-                    cb();
-                });
-            }, function (cb) {
-                // update timestamp so last_modified gets bumped
-                updateZonecfgTimestamp(vmobj, function (e) {
-                    if (e) {
-                        log.warn(e,
-                            'failed to update timestamp after snapshot');
-                    }
-                    // ignore error since there's no recovery
-                    // (snapshot was created)
-                    cb();
-                });
-            }
-        ], function (error) {
-            callback(error);
-        });
+        callback(error);
     });
 };
 
@@ -11930,17 +13121,18 @@ function getHostvolumeFile(url, target, log, callback) {
                     log.info('config file is %s', cfgfile);
                     cb();
                     return;
-                } else {
-                    fs.exists('/usbkey/config', function (hn_exists) {
-                        if (hn_exists) {
-                            cfgfile = '/usbkey/config';
-                            log.info('config file is %s', cfgfile);
-                            cb();
-                        } else {
-                            cb(new Error('Unable to find SDC config file.'));
-                        }
-                    });
                 }
+
+                fs.exists('/usbkey/config', function (hn_exists) {
+                    if (!hn_exists) {
+                        cb(new Error('Unable to find SDC config file.'));
+                        return;
+                    }
+
+                    cfgfile = '/usbkey/config';
+                    log.info('config file is %s', cfgfile);
+                    cb();
+                });
             });
         }, function (cb) {
             fs.readFile(cfgfile, 'utf8', function (err, data) {
@@ -12075,11 +13267,19 @@ function getHostvolumeFile(url, target, log, callback) {
     });
 }
 
-function setDockerRestartOpts(uuid, filename, options, log, callback)
-{
-    var lockpath = '/var/run/vm.' + uuid + '.config.lockfile';
+function setDockerRestartOpts(uuid, options, callback) {
+    var log;
+    var lockpath;
     var tracers_obj;
     var unlock;
+    var vmobj;
+
+    assert.uuid(uuid, 'uuid');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+
+    log = options.log;
+    assert(log, 'log');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('set-docker-restartopts', log,
@@ -12088,97 +13288,90 @@ function setDockerRestartOpts(uuid, filename, options, log, callback)
         log = tracers_obj.log;
     }
 
-    function _failed(err) {
-        if (unlock) {
-            unlock(function (unlock_err) {
-                log.error({err: unlock_err}, 'failed ot unlock while handling '
-                    + 'error');
-                callback(err);
-            });
-        } else {
-            callback(err);
-        }
-    }
+    lockpath = zoneConfigLockpath(uuid);
 
-    log.debug('acquiring lock on ' + lockpath);
-    lock(lockpath, function (err, _unlock) {
-        if (err) {
-            log.error('failed to acquire lock on ' + lockpath);
-            callback(err);
-            return;
-        }
-        log.debug('acquired lock on ' + lockpath);
-        unlock = _unlock;
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            log.debug('acquiring lock on %s', lockpath);
 
-        fs.readFile(filename, 'utf8', function (error, data) {
-            var mdata;
-            var msg;
-            var tmp_filename;
+            lock(lockpath, function (err, _unlock) {
+                if (err) {
+                    log.error('failed to acquire lock on %s', lockpath);
+                    cb(err);
+                    return;
+                }
 
-            if (error) {
-                log.error(error, 'failed to load ' + filename);
-                _failed(error);
-                return;
-            }
+                log.debug('acquired lock on %s', lockpath);
+                unlock = _unlock;
+                cb();
+            });
+        }, function (_, cb) {
+            VM.load(uuid, {log: log}, function (err, _vmobj) {
+                if (err) {
+                    log.error({err: err}, 'failed to load VM %s', uuid);
+                    cb(err);
+                    return;
+                }
 
-            try {
-                mdata = JSON.parse(data);
-            } catch (e) {
-                log.error({err: e}, 'failed to parse mdata JSON');
-                _failed(e);
-                return;
-            }
+                vmobj = _vmobj;
+                cb();
+            });
+        }, function (_, cb) {
+            var err;
+            var im;
+            var zonepath;
+
+            im = vmobj.internal_metadata || {};
 
             if (options.hasOwnProperty('value')) {
-                mdata.internal_metadata['docker:restartcount'] = options.value;
+                im['docker:restartcount'] = options.value;
             } else if (options.hasOwnProperty('increment')) {
-                if (mdata.internal_metadata['docker:restartcount']) {
-                    mdata.internal_metadata['docker:restartcount'] =
-                        Number(mdata.internal_metadata['docker:restartcount'])
-                        + options.increment;
+                if (im['docker:restartcount']) {
+                    im['docker:restartcount'] =
+                        Number(im['docker:restartcount']) + options.increment;
                 } else {
-                    mdata.internal_metadata['docker:restartcount'] = 1;
+                    im['docker:restartcount'] = 1;
                 }
             } else {
-                msg = 'invalid options for setDockerRestartOpts()';
-                log.error({options: options}, msg);
-                _failed(new Error(msg));
+                err = new Error('invalid options for setDockerRestartOpts()');
+                log.error({err: err, options: options}, err.message);
+                cb(err);
+                return;
             }
 
             if (options.hasOwnProperty('delay') && options.delay) {
-                mdata.internal_metadata['docker:restartdelay'] = options.delay;
+                im['docker:restartdelay'] = options.delay;
+            }
+
+            try {
+                zonepath = calculateZonepath(vmobj);
+            } catch (e) {
+                log.error({err: e}, 'failed to calculate zonepath for %s',
+                    uuid);
+                cb(e);
+                return;
             }
 
-            tmp_filename = filename + '.tmp.' + process.pid;
-            fs.writeFile(tmp_filename, JSON.stringify(mdata, null, 2), 'utf8',
-                function (write_err) {
+            writeAllMetadata(uuid, zonepath, {internal_metadata: im},
+                {log: log, skipLockfile: true}, cb);
+        }
+    ]}, function (err) {
+        if (err) {
+            log.error({err: err}, 'error setting docker restart opts');
+        }
 
-                if (write_err) {
-                    log.error(write_err, 'failed to write ' + tmp_filename);
-                    _failed(write_err);
-                    return;
-                } else {
-                    fs.rename(tmp_filename, filename, function (rename_err) {
-                        if (rename_err) {
-                            log.error(rename_err, 'failed to rename '
-                                + tmp_filename + ' to ' + filename);
-                            _failed(rename_err);
-                            return;
-                        }
-                        log.debug('releasing lock on ' + lockpath);
-                        unlock(function (unlock_err) {
-                            if (unlock_err) {
-                                log.error(unlock_err, 'failed to unlock');
-                                callback(unlock_err);
-                                return;
-                            }
-                            log.debug('released lock on ' + lockpath);
-                            callback();
-                        });
-                    });
+        if (unlock) {
+            unlock(function (unlock_err) {
+                if (unlock_err) {
+                    log.error({err: unlock_err}, 'failed to unlock %s',
+                        lockpath);
                 }
+                callback(err || unlock_err);
             });
-        });
+            return;
+        }
+
+        callback(err);
     });
 }
 
@@ -12293,31 +13486,31 @@ exports.start = function (uuid, extra, options, callback)
             VM.load(uuid, {log: log, fields: load_fields}, function (err, obj) {
                 if (err) {
                     cb(err);
-                } else {
-
-                    if (obj.state === 'running') {
-                        err = new Error('VM ' + obj.uuid + ' is already '
-                            + '\'running\'');
-                        err.code = 'EALREADYRUNNING';
-                        cb(err);
-                        return;
-                    }
+                    return;
+                }
 
-                    if ((obj.state !== 'stopped'
-                            && obj.state !== 'provisioning')
-                        || (obj.state === 'provisioning'
-                            && obj.zone_state !== 'installed')) {
+                if (obj.state === 'running') {
+                    err = new Error('VM ' + obj.uuid + ' is already '
+                        + '\'running\'');
+                    err.code = 'EALREADYRUNNING';
+                    cb(err);
+                    return;
+                }
 
-                        err = new Error('Cannot to start vm from state "'
-                            + obj.state + '", must be "stopped".');
-                        log.error(err);
-                        cb(err);
-                        return;
-                    }
+                if ((obj.state !== 'stopped'
+                        && obj.state !== 'provisioning')
+                    || (obj.state === 'provisioning'
+                        && obj.zone_state !== 'installed')) {
 
-                    vmobj = obj;
-                    cb();
+                    err = new Error('Cannot start vm from state "'
+                        + obj.state + '", must be "stopped".');
+                    log.error(err);
+                    cb(err);
+                    return;
                 }
+
+                vmobj = obj;
+                cb();
             });
         }, function (cb) {
             validateNicTags(vmobj.nics, log, function (e) {
@@ -12365,27 +13558,25 @@ exports.start = function (uuid, extra, options, callback)
                 return;
             }
         }, function (cb) {
-            var mdata_path;
-
             if (!vmobj.docker || !vmobj.zonepath) {
                 cb();
                 return;
             }
 
-            mdata_path = path.join(vmobj.zonepath, '/config/metadata.json');
-
             // we're about to restart now, so bump the restart counter if we're
             // restarting from vmadmd, otherwise just set it to 0.
             if (options.increment_restart_count) {
-                setDockerRestartOpts(vmobj.uuid, mdata_path, {
+                setDockerRestartOpts(vmobj.uuid, {
+                    log: log,
                     delay: options.restart_delay,
                     increment: 1
-                }, log, cb);
+                }, cb);
             } else {
-                setDockerRestartOpts(vmobj.uuid, mdata_path, {
+                setDockerRestartOpts(vmobj.uuid, {
+                    log: log,
                     delay: options.restart_delay,
                     value: 0
-                }, log, cb);
+                }, cb);
             }
         }, function (cb) {
             var err;
@@ -12443,18 +13634,20 @@ function setRctl(zonename, rctl, value, log, callback)
                             log.error(set_error, 'setRctl() failed with: '
                                 + set_stderr);
                             callback(set_error);
-                        } else {
-                            callback();
+                            return;
                         }
+
+                        callback();
                     }
                 );
             } else {
                 log.error(error, 'setRctl() failed with: ' + stderr);
                 callback(error);
             }
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -12471,9 +13664,10 @@ function removeRctl(zonename, rctl, log, callback)
         if (error) {
             log.error(error, 'setRctl() failed with: ' + stderr);
             callback(error);
-        } else {
-            callback();
+            return;
         }
+
+        callback();
     });
 }
 
@@ -12541,35 +13735,41 @@ function resizeDisks(disks, updates, log, callback)
         var dsk = vol.disk;
         var size = vol.new_size;
 
-        if (dsk.hasOwnProperty('zfs_filesystem')) {
-            if (dsk.size > size) {
-                cb(new Error('cannot resize ' + dsk.zfs_filesystem
-                    + ' new size must be greater than current size. ('
-                    + dsk.size + ' > ' + dsk.size + ')'));
-            } else if (dsk.size === size) {
-                // no point resizing if the old+new are the same
-                cb();
-            } else {
-                args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
-                zfs(args, log, function (err, fds) {
-                    resized++;
-                    cb(err);
-                });
-            }
-        } else {
+        if (!dsk.hasOwnProperty('zfs_filesystem')) {
             cb(new Error('could not find zfs_filesystem in '
                 + JSON.stringify(dsk)));
+            return;
         }
-    }
 
-    async.forEachSeries(vols, resize, function (err) {
-        if (err) {
-            log.error(err, 'Unable to resize disks');
-            callback(err);
-        } else {
-            callback(null, resized);
+        if (dsk.size > size) {
+            cb(new Error('cannot resize ' + dsk.zfs_filesystem
+                + ' new size must be greater than current size. ('
+                + dsk.size + ' > ' + dsk.size + ')'));
+            return;
         }
-    });
+
+        if (dsk.size === size) {
+            // no point resizing if the old+new are the same
+            cb();
+            return;
+        }
+
+        args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
+        zfs(args, log, function (err, fds) {
+            resized++;
+            cb(err);
+        });
+    }
+
+    async.forEachSeries(vols, resize, function (err) {
+        if (err) {
+            log.error(err, 'Unable to resize disks');
+            callback(err);
+            return;
+        }
+
+        callback(null, resized);
+    });
 }
 
 function updateVnicAllowedCIDs(uuid, nic, log, callback) {
@@ -12906,13 +14106,7 @@ function firewallVMrun(opts, callback) {
 
     // Filters out VMs that don't have firewall_enabled == true
     function fwEnabledFilter(vmobj, cb) {
-        if (vmobj.firewall_enabled) {
-            cb(true);
-            return;
-        }
-
-        cb(false);
-        return;
+        cb(null, vmobj.firewall_enabled);
     }
 
     // Return all VMs, but don't include VMs (other than the one we're
@@ -12921,16 +14115,14 @@ function firewallVMrun(opts, callback) {
     function allVmsFilter(vmobj, cb) {
         if (vmobj.hasOwnProperty('state') && vmobj.state == 'provisioning') {
             if (vmobj.hasOwnProperty('uuid') && vmobj.uuid == cur_vm_uuid) {
-                cb(true);
-                return;
+                cb(null, true);
+            } else {
+                cb(null, false);
             }
-
-            cb(false);
             return;
         }
 
-        cb(true);
-        return;
+        cb(null, true);
     }
 
     async.series([
@@ -13349,9 +14541,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_root_recsize: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13368,9 +14561,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_filesystem_limit: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13408,9 +14602,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply zfs_data_recsize: '
                             + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13428,9 +14623,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply '
                             + 'zfs_root_compression: ' + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13449,9 +14645,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                         log.error(err, 'failed to apply '
                             + 'zfs_data_compression: ' + fds.stderr);
                         cb(new Error(rtrim(fds.stderr)));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13492,63 +14689,69 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
             var disk;
             var zfs_updates = [];
 
-            if (payload.hasOwnProperty('update_disks')) {
-                // loop through the disks we updated and perform any updates.
-                for (disk in payload.update_disks) {
-                    disk = payload.update_disks[disk];
+            if (!payload.hasOwnProperty('update_disks')) {
+                cb();
+                return;
+            }
+
+            // loop through the disks we updated and perform any updates.
+            for (disk in payload.update_disks) {
+                disk = payload.update_disks[disk];
 
-                    if (!disk) {
-                        continue;
-                    }
+                if (!disk) {
+                    continue;
+                }
 
-                    for (d in oldobj.disks) {
-                        d = oldobj.disks[d];
-                        if (d.path === disk.path
-                            && d.hasOwnProperty('zfs_filesystem')) {
+                for (d in oldobj.disks) {
+                    d = oldobj.disks[d];
+                    if (d.path === disk.path
+                        && d.hasOwnProperty('zfs_filesystem')) {
 
-                            if (disk.hasOwnProperty('compression')) {
-                                zfs_updates.push({
-                                    zfs_filesystem: d.zfs_filesystem,
-                                    property: 'compression',
-                                    value: disk.compression
-                                });
-                            }
+                        if (disk.hasOwnProperty('compression')) {
+                            zfs_updates.push({
+                                zfs_filesystem: d.zfs_filesystem,
+                                property: 'compression',
+                                value: disk.compression
+                            });
+                        }
 
-                            if (disk.hasOwnProperty('refreservation')) {
-                                zfs_updates.push({
-                                    zfs_filesystem: d.zfs_filesystem,
-                                    property: 'refreservation',
-                                    value: disk.refreservation + 'M'
-                                });
-                            }
+                        if (disk.hasOwnProperty('refreservation')) {
+                            zfs_updates.push({
+                                zfs_filesystem: d.zfs_filesystem,
+                                property: 'refreservation',
+                                value: disk.refreservation + 'M'
+                            });
                         }
                     }
                 }
-                if (zfs_updates.length > 0) {
-                    log.debug('applying ' + zfs_updates.length
-                        + ' zfs updates');
-                    async.each(zfs_updates, function (props, f_cb) {
-                        zfs(['set', props.property + '=' + props.value,
-                            props.zfs_filesystem], log, function (err, fds) {
+            }
 
-                            if (err) {
-                                log.error(err, 'failed to set ' + props.property
-                                    + '=' + props.value + ' for '
-                                    + props.zfs_filesystem);
-                            }
-                            f_cb(err);
-                        });
-                    }, function (err) {
-                        log.debug({err: err}, 'end of zfs updates');
-                        cb(err);
-                    });
-                } else {
-                    log.debug('no zfs updates to apply');
-                    cb();
-                }
-            } else {
+            if (zfs_updates.length === 0) {
+                log.debug('no zfs updates to apply');
                 cb();
+                return;
             }
+
+            log.debug('applying %d zfs updates', zfs_updates.length);
+
+            async.each(zfs_updates, function (props, f_cb) {
+                zfs(['set', props.property + '=' + props.value,
+                    props.zfs_filesystem], log, function (err, fds) {
+
+                    if (err) {
+                        log.error(err, 'failed to set ' + props.property
+                            + '=' + props.value + ' for '
+                            + props.zfs_filesystem);
+                        f_cb(err);
+                        return;
+                    }
+
+                    f_cb();
+                });
+            }, function (err) {
+                log.debug({err: err}, 'end of zfs updates');
+                cb(err);
+            });
         }, function (cb) {
             var factor;
             var keys = [];
@@ -13585,30 +14788,30 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     factor = 1;
                 }
 
-                if (payload.hasOwnProperty(prop)) {
-                    if (prop === 'cpu_cap' && Number(payload[prop]) === 0) {
-                        // When cpu_cap is 0, we'll remove instead of set since
-                        // setting to 0 fails.
-                        removeRctl(newobj.zonename, rctl, log, function (err) {
-                            if (err) {
-                                log.warn(err, 'failed to remove rctl: ' + prop);
-                            }
-                            c();
-                        });
-                        return;
-                    }
-                    setRctl(newobj.zonename, rctl,
-                        Number(payload[prop]) * factor, log,
-                        function (err) {
-                            if (err) {
-                                log.warn(err, 'failed to set rctl: ' + prop);
-                            }
-                            c();
-                        }
-                    );
-                } else {
+                if (!payload.hasOwnProperty(prop)) {
                     c();
+                    return;
+                }
+                if (prop === 'cpu_cap' && Number(payload[prop]) === 0) {
+                    // When cpu_cap is 0, we'll remove instead of set since
+                    // setting to 0 fails.
+                    removeRctl(newobj.zonename, rctl, log, function (err) {
+                        if (err) {
+                            log.warn(err, 'failed to remove rctl: ' + prop);
+                        }
+                        c();
+                    });
+                    return;
                 }
+                setRctl(newobj.zonename, rctl,
+                    Number(payload[prop]) * factor, log,
+                    function (err) {
+                        if (err) {
+                            log.warn(err, 'failed to set rctl: ' + prop);
+                        }
+                        c();
+                    }
+                );
             }, function (err) {
                 cb(err);
             });
@@ -13626,9 +14829,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     if (e) {
                         cb(new Error('Unable to tell vmadmd to reload VNC: '
                             + e.message));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else if ((payload.hasOwnProperty('spice_password')
                 && (oldobj.spice_password !== newobj.spice_password))
@@ -13643,9 +14847,10 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
                     if (e) {
                         cb(new Error('Unable to tell vmadmd to reload SPICE: '
                             + e.message));
-                    } else {
-                        cb();
+                        return;
                     }
+
+                    cb();
                 });
             } else {
                 cb();
@@ -13653,30 +14858,28 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
         }, function (cb) {
             // we do this last, since we need the memory in the zone updated
             // first if we're growing this.
-            if (payload.hasOwnProperty('tmpfs')) {
-                if (oldobj.tmpfs === 0) {
-                    /*
-                     * We can't mount over existing /tmp (on zfs) for a running
-                     * VM so we skip update if it's currently not using tmpfs.
-                     */
-                    log.debug('existing tmpfs size is 0, not updating mount for'
-                        + ' running VM.');
-                    cb();
-                    return;
-                } else {
-                    resizeTmp(newobj.zonename, payload.tmpfs, log, cb);
-                }
-            } else {
+            if (!payload.hasOwnProperty('tmpfs')) {
                 cb();
+                return;
+            }
+            if (oldobj.tmpfs === 0) {
+                /*
+                 * We can't mount over existing /tmp (on zfs) for a running
+                 * VM so we skip update if it's currently not using tmpfs.
+                 */
+                log.debug('existing tmpfs size is 0, not updating mount for'
+                    + ' running VM.');
+                cb();
+                return;
             }
-        }, function (cb) {
-            var now = new Date();
 
+            resizeTmp(newobj.zonename, payload.tmpfs, log, cb);
+        }, function (cb) {
             // If we changed any properties that don't involve modifying the
             // zone's xml, touch the zone xml file so that last_modified is
             // correct.
             if (changed && newobj.hasOwnProperty('zonename')) {
-                fs.utimes('/etc/zones/' + newobj.zonename + '.xml', now, now,
+                updateZonecfgTimestamp(newobj,
                     function (err) {
                         if (err) {
                             log.warn(err, 'Unable to "touch" xml file for "'
@@ -13725,12 +14928,16 @@ function newDockerId(uuid)
 
 exports.update = function (uuid, payload, options, callback)
 {
+    var changes = [];
+    var keys = {};
     var log;
     var new_vmobj;
+    var orig_vmobj;
     var vmobj;
     var unlock;
     var lockpath;
     var tracers_obj;
+    var vs;
 
     // options parameter is optional
     if (arguments.length === 3) {
@@ -13754,9 +14961,12 @@ exports.update = function (uuid, payload, options, callback)
     log.info('Updating VM ' + uuid + ' with initial payload:\n'
         + JSON.stringify(payload, null, 2));
 
+    keys = Object.keys(payload);
+
     async.series([
         function (cb) {
-            lockpath = '/var/run/vm.' + uuid + '.config.lockfile';
+            lockpath = zoneConfigLockpath(uuid);
+
             log.debug('acquiring lock on ' + lockpath);
             lock(lockpath, function (err, _unlock) {
                 log.debug('acquired lock on ' + lockpath);
@@ -13767,171 +14977,641 @@ exports.update = function (uuid, payload, options, callback)
                 unlock = _unlock;
                 cb();
             });
-        },
-        function (cb) {
-            // for update we currently always load the whole vmobj since the
-            // update functions may need to look at bits from the existing VM.
-            VM.load(uuid, {log: log}, function (err, obj) {
-                if (err) {
-                    cb(err);
+        }, function (cb) {
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js update (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
                     return;
                 }
-                vmobj = obj;
+
                 cb();
             });
         }, function (cb) {
+            var diff_map = {
+                disks: 'path',
+                nics: 'mac'
+            };
+
+            orig_vmobj = jsprim.deepCopy(vmobj);
+
             normalizePayload(payload, vmobj, log, function (e) {
                 log.debug('Used payload:\n'
                     + JSON.stringify(payload, null, 2));
-                cb(e);
+
+                log.debug({oldVmobj: orig_vmobj, newVmobj: vmobj,
+                    diff: diff(orig_vmobj, vmobj, {map: diff_map})},
+                    'payload normalized');
+
+                if (e) {
+                    cb(e);
+                    return;
+                }
+
+                cb();
             });
         }, function (cb) {
-            var deletables = [];
-            var to_remove = [];
-            var n;
+            /*
+             * Loop each key from the original payload, and construct an array
+             * of changes to block for on vminfod
+             */
+            keys.forEach(function (key) {
+                // Ignore keys we won't/can't change
+                // XXX: maybe there's a list of these somewhere?
+                var IGNORE_KEYS = [
+                    // these cannot be changed
+                    'zonename',
+                    'uuid',
+                    'last_modified',
+                    'server_uuid',
+
+                    // these are modified via set/remove/add/update
+                    'nics',
+                    'disks',
+                    'customer_metadata',
+                    'internal_metadata',
+                    'tags',
+                    'routes'
+                ];
+                if (IGNORE_KEYS.indexOf(key) > -1) {
+                    log.debug({key: key}, 'key "%s" cannot be updated', key);
+                    return;
+                }
 
-            // destroy remove_disks before we add in case we're recreating with
-            // an existing name.
+                var value = payload[key];
+                var m, label, existing, change, re, identifierKey;
 
-            if (payload.hasOwnProperty('remove_disks')) {
-                to_remove = payload.remove_disks;
-                for (n in vmobj.disks) {
-                    if (to_remove.indexOf(vmobj.disks[n].path) !== -1) {
-                        deletables.push(vmobj.disks[n]);
-                    }
+                log.debug('processing vmobj key "%s"', key);
+
+                if (key === 'resolvers') {
+                    existing = vmobj[key] || [];
+                    assert.arrayOfString(existing, 'existing vmobj.resolvers');
+                    assert.arrayOfString(value, 'new vmobj.resolvers');
+
+                    diff(existing, value).forEach(function (difference) {
+                        var o = {
+                            path: [key, null]
+                        };
+
+                        switch (difference.action) {
+                        case 'added':
+                            assert.string(difference.newValue,
+                                'difference.newValue');
+                            o.action = 'added';
+                            o.newValue = difference.newValue;
+                            break;
+                        case 'removed':
+                            assert.string(difference.oldValue,
+                                'difference.oldValue');
+                            o.action = 'removed';
+                            o.oldValue = difference.oldValue;
+                            break;
+                        default:
+                            assert(false,
+                                'unknown action: ' + difference.action);
+                            break;
+                        }
+
+                        changes.push(o);
+                    });
+
+                    return;
                 }
-            } else {
-                // no disks to remove so all done.
-                cb();
-                return;
-            }
 
-            function _loggedDeleteVolume(volume, callbk) {
-                return deleteVolume(volume, log, callbk);
-            }
+                /* JSSTYLED */
+                re = /^(set_|remove_)?(customer_metadata|internal_metadata|tags|routes)$/;
+                if (key.match(re)) {
+                    /*
+                     * Metadata blocking logic is handleded in updateRoutes and
+                     * updateMetadata - so just short-circuit here.
+                     */
+                    return;
+                }
 
-            async.forEachSeries(deletables, _loggedDeleteVolume,
-                function (err) {
-                    if (err) {
-                        log.error(err, 'Unknown error deleting volumes: '
-                            + err.message);
-                        cb(err);
-                    } else {
-                        log.info('successfully deleted volumes');
-                        cb();
+                // add_* keys require special treatment
+                if ((m = key.match(/^add_(.*)$/))) {
+                    label = m[1];
+                    var props;
+
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
+                    }
+                    assert.arrayOfObject(value, 'value');
+
+                    switch (label) {
+                    case 'disks':
+                        props = ['model', 'size'];
+                        break;
+                    case 'nics':
+                        props = ['nic_tag', 'mac', 'interface'];
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
                     }
+
+                    value.forEach(function (thing) {
+                        var newthing = {};
+
+                        props.forEach(function (prop) {
+                            if (thing.hasOwnProperty(prop)) {
+                                newthing[prop] = thing[prop];
+                            }
+                        });
+                        assert(Object.keys(newthing).length > 0,
+                            util.format('at least one property must be'
+                                + 'set: [%s]', props));
+
+                        var localChange = {
+                            path: [label, null],
+                            newValue: newthing,
+                            action: 'added'
+                        };
+                        changes.push(localChange);
+                    });
+
+                    return;
                 }
-            );
-        }, function (cb) {
-            var disks = [];
-            var matches;
-            var n;
-            var p;
-            var used_disk_indexes = [];
 
-            // create any new volumes we need.
-            if (payload.hasOwnProperty('add_disks')) {
-                disks = payload.add_disks;
-            }
+                // update_* keys require special treatment
+                if ((m = key.match(/^update_(.*)$/))) {
+                    label = m[1];
 
-            // create a list of used indexes so we can find the free ones to
-            // use in createVolume()
-            if (vmobj.hasOwnProperty('disks')) {
-                for (n in vmobj.disks) {
-                    matches = vmobj.disks[n].path.match(/^.*-disk(\d+)$/);
-                    if (matches) {
-                        used_disk_indexes.push(Number(matches[1]));
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
                     }
-                }
-            }
+                    assert.arrayOfObject(value, 'value');
 
-            // add the bits of payload createVolumes() needs.
-            p = {add_disks: disks, brand: vmobj.brand};
-            p.uuid = uuid;
-            if (vmobj.hasOwnProperty('zpool')) {
-                p.zpool = vmobj.zpool;
-            }
-            p.used_disk_indexes = used_disk_indexes;
-            createVolumes(p, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateMetadata(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateRoutes(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            var zcfg;
-            // generate a payload and send as stdin to zonecfg to update the
-            // zone.
-            zcfg = buildZonecfgUpdate(vmobj, payload, log);
-            zonecfg(uuid, [], {log: log, stdin: zcfg},
-                function (e, fds) {
+                    switch (label) {
+                    case 'disks':
+                        identifierKey = 'path';
+                        break;
+                    case 'nics':
+                        identifierKey = 'mac';
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
+                    }
 
-                if (e) {
-                    log.error({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                        'unable to update zonecfg');
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'updated zonecfg');
-                }
-                cb(e);
-            });
-        }, function (cb) {
-            restartMetadataService(vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            updateVnicProperties(uuid, vmobj, payload, log, function (e) {
-                cb(e);
-            });
-        }, function (cb) {
-            // Do another full reload (all fields) so we can compare in
-            // applyUpdates() and decide what's changed that we need to apply.
-            VM.load(uuid, {log: log}, function (e, newobj) {
-                if (e) {
-                    cb(e);
-                } else {
-                    new_vmobj = newobj;
-                    cb();
+                    // build a map of identifier key => object
+                    assert.arrayOfObject(vmobj[label], 'vmobj.' + label);
+                    var map = {};
+                    vmobj[label].forEach(function (d, i) {
+                        assert(d[identifierKey],
+                            sprintf('d[%s]', identifierKey));
+
+                        map[d[identifierKey]] = i;
+                    });
+
+                    log.debug({arr: vmobj[label], map: map},
+                        'index map built for "%s"', key);
+
+                    value.forEach(function (thing) {
+                        var ident = thing[identifierKey];
+                        var index = map[ident];
+                        assert.number(index, 'index');
+                        assert(index >= 0, 'index');
+
+                        var orig = vmobj[label][index];
+                        assert.object(orig, 'orig');
+
+                        Object.keys(thing).forEach(function (_key) {
+                            if (_key === identifierKey)
+                                return;
+
+                            var defaultPath = util.format('%s.*.%s',
+                                label, _key);
+                            var lookingFor = [label, null, _key];
+
+                            var localChange = {
+                                path: lookingFor,
+                                ident: ident,
+                                newValue: thing[_key]
+                            };
+
+                            var prop = PAYLOAD_PROPERTIES[defaultPath];
+                            if (prop.hasOwnProperty('pr_default')) {
+                                var _def = prop.pr_default;
+
+                                if (_def === thing[_key]) {
+                                    delete localChange.newValue;
+                                    localChange.action = 'removed';
+                                }
+                            }
+
+                            if (orig[_key] !== thing[_key]) {
+                                changes.push(localChange);
+                            }
+
+                            /*
+                             * It is a very special case unfortunately if which
+                             * nic is primary is changed.  normalizePayload
+                             * will modify the `nics` portion of the vmobj
+                             * given making the soon-to-be-primary nic already
+                             * appear to be primary, so the logic above to
+                             * block vminfod on changes won't see this change.
+                             * Also, the implicit change is that any nic
+                             * becoming primary will result in all other nics
+                             * losing that property.
+                             *
+                             * To remedy this, we use a copy of the vmobj
+                             * before normalizePayload was called to see if the
+                             * primary flag is being moved to a new nic.
+                             */
+                            if (label === 'nics' && _key === 'primary') {
+                                var oldNic = orig_vmobj.nics[index];
+                                assert.object(oldNic, 'oldNic');
+                                assert.bool(thing.primary, 'thing.primary');
+                                if (oldNic.primary !== thing.primary) {
+                                    changes.push(localChange);
+                                }
+                            }
+                        });
+                    });
+                    return;
+                }
+
+                // remove_* keys require special treatment
+                if ((m = key.match(/^remove_(.*)$/))) {
+                    label = m[1];
+
+                    if (!value) {
+                        log.warn({key: key, value: value},
+                            'key "%s" specified with empty value', key);
+                        return;
+                    }
+
+                    switch (label) {
+                    case 'disks':
+                        identifierKey = 'path';
+                        break;
+                    case 'nics':
+                        identifierKey = 'mac';
+                        break;
+                    default:
+                        log.warn({key: key}, 'skipping unknown key "%s"', key);
+                        return;
+                    }
+
+                    value.forEach(function (thing) {
+                        var from = {};
+                        from[identifierKey] = thing;
+
+                        var localChange = {
+                            path: [label, null],
+                            oldValue: from,
+                            action: 'removed'
+                        };
+                        changes.push(localChange);
+                    });
+
+                    return;
+                }
+
+                /*
+                 * "ram" is a special key which results in us setting a number
+                 * of other keys (if not set explicitly in the original
+                 * payload)
+                 */
+                if (key === 'ram') {
+                    [
+                        'max_physical_memory',
+                        'max_locked_memory',
+                        vmobj.brand === 'kvm' ? 'ram' : 'tmpfs'
+                    ].forEach(function (newkey) {
+                        var v;
+
+                        if (newkey !== 'ram' && keys.indexOf(newkey) > -1) {
+                            /*
+                             * The key we are attempting to set as a result of
+                             * the "ram" key being set is set explicitly in
+                             * the original payload - skip it
+                             */
+                            return;
+                        }
+
+                        if (vmobj.brand === 'kvm' && newkey !== 'ram')
+                            v = value + KVM_MEM_OVERHEAD;
+                        else
+                            v = value;
+
+                        var localChange = {
+                            path: [newkey],
+                            newValue: v
+                        };
+                        if (vmobj[newkey] !== v)
+                            changes.push(localChange);
+                    });
+
+                    return;
+                }
+
+                /*
+                 * If we are here, the key being modified does not require any
+                 * special processing, so we will just watch for it to change
+                 * to the value specified in the payload.
+                 */
+                change = {
+                    path: [key],
+                    newValue: value
+                };
+
+                // normalize empty values as a value removal
+                if (value === '' || value === undefined || value === null) {
+                    delete change.newValue;
+                    change.action = 'removed';
+                }
+
+                /*
+                 * Keys like "fs_allowed" can be set to an array like
+                 * ["ufs","pcfs","tmpfs"] by the user but will be stored as
+                 * "ufs,pcfs,tmpfs".
+                 */
+                try {
+                    assert.arrayOfString(value);
+                    change.newValue = value.join(',');
+                } catch (e) {
+                }
+
+                // check to see if this property has a default value
+                if (PAYLOAD_PROPERTIES.hasOwnProperty(key)
+                    && PAYLOAD_PROPERTIES[key].hasOwnProperty('pr_default')) {
+
+                    /*
+                     * If the value is being set to the default value for the
+                     * property, this is equivalent to value removal.
+                     */
+                    if (PAYLOAD_PROPERTIES[key].pr_default === value) {
+                        delete change.newValue;
+                        change.action = 'removed';
+                    }
+                }
+
+                /*
+                 * If the current value matches the desired value, we skip it
+                 * as no work is needed to be done
+                 */
+                if ((change.action === 'removed'
+                    && !vmobj.hasOwnProperty(key))
+                    || (change.action !== 'removed'
+                    && vmobj.hasOwnProperty(key)
+                    && vmobj[key] === value)) {
+                    return;
+                }
+
+                if (change.action === 'removed') {
+                    /*
+                     * Removing a key can sometimes be equivalent to setting it
+                     * to its default.
+                     */
+                    change = [change];
+                    change.push({
+                        path: change[0].path.slice(0),
+                        newValue: value
+                    });
+                } else if (change.newValue === 0) {
+                    /*
+                     * Sometimes changing a value to 0 is equivalent to
+                     * removing that value (ex: "cpu_cap").
+                     */
+                    change = [change];
+                    change.push({
+                        path: change[0].path.slice(0),
+                        action: 'removed'
+                    });
                 }
+
+                changes.push(change);
             });
+
+            // special attention given to docker objects
+            if (vmobj.docker) {
+                var old_zlog_mode = vmobj.zlog_mode;
+                var new_zlog_mode =
+                    calculateZlogModeAndDriver(payload, vmobj).mode;
+                if (old_zlog_mode !== new_zlog_mode) {
+                    changes.push({
+                        path: ['zlog_mode'],
+                        newValue: new_zlog_mode
+                    });
+                }
+            }
+
+            log.debug({changes: changes}, 'vminfod changes array built');
+            cb();
         }, function (cb) {
-            applyUpdates(vmobj, new_vmobj, payload, log, function () {
-                cb();
+            /*
+             * If we are here, we have successfully loaded the VM and acquired
+             * the necessary file lock.  Now, we must fire off the next string
+             * of functions which will do the actual updating of the vm, while
+             * simultaneously blocking on vminfod to give us the necessary
+             * "modify" event letting us know it has been successfully updated.
+             */
+            var cancelFn;
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                },
+                function (cb2) {
+                    doupdate(function (err) {
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
             });
-        }, function (cb) {
-            // Update the firewall data
-            updateFirewallData(payload, new_vmobj, log, cb);
         }
     ], function (e) {
-        // If we were able to hold the lockfile, and thus have an unlock
-        // callback, we must call it before returning, whether or not
-        // there was an error.
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         if (unlock) {
-            log.debug('releasing lock on ' + lockpath);
+            log.debug('releasing lock on %s', lockpath);
             unlock(function (unlock_err) {
                 if (unlock_err) {
                     log.error(unlock_err,
-                        'unlock error! (path ' + lockpath + ')');
+                        'unlock error! (path %s)', lockpath);
                 } else {
-                    log.debug('released lock on ' + lockpath);
+                    log.debug('released lock on %s', lockpath);
                 }
                 callback(e);
             });
-        } else {
-            callback(e);
+            return;
         }
+
+        callback(e);
     });
+
+    function doupdate(done) {
+        async.series([
+            function (cb) {
+                var deletables = [];
+                var to_remove;
+                var n;
+
+                // destroy remove_disks before we add in case we're recreating
+                // with an existing name.
+
+                if (!payload.hasOwnProperty('remove_disks')) {
+                    // no disks to remove so all done.
+                    cb();
+                    return;
+                }
+
+                to_remove = payload.remove_disks;
+                for (n in vmobj.disks) {
+                    if (to_remove.indexOf(vmobj.disks[n].path) !== -1) {
+                        deletables.push(vmobj.disks[n]);
+                    }
+                }
+
+                function _loggedDeleteVolume(volume, callbk) {
+                    return deleteVolume(volume, log, callbk);
+                }
+
+                async.forEachSeries(deletables, _loggedDeleteVolume,
+                    function (err) {
+                        if (err) {
+                            log.error(err, 'Unknown error deleting volumes: '
+                                + err.message);
+                            cb(err);
+                            return;
+                        }
+
+                        log.info('successfully deleted volumes');
+                        cb();
+                    }
+                );
+            }, function (cb) {
+                var disks = [];
+                var matches;
+                var n;
+                var p;
+                var used_disk_indexes = [];
+
+                // create any new volumes we need.
+                if (payload.hasOwnProperty('add_disks')) {
+                    disks = payload.add_disks;
+                }
+
+                // create a list of used indexes so we can find the free ones to
+                // use in createVolume()
+                if (vmobj.hasOwnProperty('disks')) {
+                    for (n in vmobj.disks) {
+                        matches = vmobj.disks[n].path.match(/^.*-disk(\d+)$/);
+                        if (matches) {
+                            used_disk_indexes.push(Number(matches[1]));
+                        }
+                    }
+                }
+
+                // add the bits of payload createVolumes() needs.
+                p = {add_disks: disks, brand: vmobj.brand};
+                p.uuid = uuid;
+                if (vmobj.hasOwnProperty('zpool')) {
+                    p.zpool = vmobj.zpool;
+                }
+                p.used_disk_indexes = used_disk_indexes;
+                createVolumes(p, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateMetadata(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateRoutes(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                var zcfg;
+                // generate a payload and send as stdin to zonecfg to update
+                // the zone.
+                zcfg = buildZonecfgUpdate(vmobj, payload, log);
+                zonecfg(uuid, [], {log: log, stdin: zcfg},
+                    function (e, fds) {
+
+                    if (e) {
+                        log.error({
+                            err: e,
+                            stdout: fds.stdout,
+                            stderr: fds.stderr
+                        }, 'unable to update zonecfg');
+                        cb(e);
+                        return;
+                    }
+
+                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                        'updated zonecfg');
+                    cb();
+                });
+            }, function (cb) {
+                restartMetadataService(vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                updateVnicProperties(uuid, vmobj, payload, log, function (e) {
+                    cb(e);
+                });
+            }, function (cb) {
+                // Do another full reload (all fields) so we can compare in
+                // applyUpdates() and decide what's changed that we need to
+                // apply.
+                VM.load(uuid, {log: log}, function (err, newobj) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    new_vmobj = newobj;
+                    cb();
+                });
+            }, function (cb) {
+                applyUpdates(vmobj, new_vmobj, payload, log, function () {
+                    cb();
+                });
+            }, function (cb) {
+                // Update the firewall data
+                updateFirewallData(payload, new_vmobj, log, cb);
+            }
+        ], function (e) {
+            done(e);
+        });
+    }
 };
 
 function halt(uuid, log, callback)
 {
-    var load_fields;
     var tracers_obj;
+    var vs;
+    var vmobj;
     var unset_autoboot = 'set autoboot=false';
 
     assert(log, 'no logger passed to halt()');
@@ -13944,69 +15624,134 @@ function halt(uuid, log, callback)
 
     log.info('Killing VM ' + uuid);
 
-    load_fields = [
-        'brand',
-        'state',
-        'transition_to',
-        'uuid'
-    ];
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // ensure the vm exists
+            var load_fields = [
+                'brand',
+                'state',
+                'transition_to',
+                'uuid'
+            ];
 
-    /* We load here to ensure this vm exists. */
-    VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
-        if (err) {
-            callback(err);
-            return;
-        }
+            VM.load(uuid, {fields: load_fields, log: log},
+                function (err, _vmobj) {
 
-        if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
-            unset_autoboot =
-                'select attr name=vm-autoboot; set value=false; end';
-        }
+                if (err) {
+                    cb(err);
+                    return;
+                }
 
-        zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
-            var msg = trim(fds.stderr);
+                vmobj = _vmobj;
 
-            if (msg.match(/zone is already halted$/)) {
-                // remove transition marker, since vm is not running now.
-                VM.unsetTransition(vmobj, {log: log}, function () {
-                    var new_err;
+                if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
+                    unset_autoboot =
+                        'select attr name=vm-autoboot; set value=false; end';
+                }
 
-                    new_err = new Error('VM ' + vmobj.uuid + ' is already '
-                        + 'not \'running\' (currently: ' + vmobj.state + ')');
-                    new_err.code = 'ENOTRUNNING';
-                    callback(new_err);
-                });
-            } else if (e) {
-                log.error({err: e, stdout: fds.stdout, stderr: fds.stderr},
-                    'failed to halt VM ' + uuid);
-                callback(err, msg);
-            } else {
-                log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                    'zoneadm halted VM ' + uuid);
-                zonecfg(uuid, [unset_autoboot], {log: log},
-                    function (error, unset_fds) {
+                cb();
+            });
+        }, function (_, cb) {
+            // create a vminfod event stream - we use this to make sure the VM
+            // transitions into the "down" state before returning to the caller
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js halt (%s)', uuid),
+                log: log
+            });
 
-                    if (error) {
-                        // The vm is dead at this point, erroring out here would
-                        // do no good, so we just log it.
-                        log.error({err: error, stdout: unset_fds.stdout,
-                            stderr: unset_fds.stderr}, 'halt(): Failed to '
-                            + unset_autoboot);
-                    } else {
-                        log.debug({stdout: unset_fds.stdout,
-                            stderr: unset_fds.stderr}, 'unset autoboot flag');
-                    }
-                    if (vmobj.state === 'stopping') {
-                        // remove transition marker
-                        VM.unsetTransition(vmobj, {log: log}, function () {
-                            callback(null, msg);
-                        });
-                    } else {
-                        callback(null, msg);
-                    }
+            vs.once('ready', function () {
+                cb();
+            });
+        }, function (_, cb) {
+            var cancelFn;
+
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid,
+                        vm: {
+                            state: 'stopped'
+                        }
+                    };
+                    var opts = {
+                        timeout: VMINFOD_TIMEOUT,
+                        catchErrors: true,
+                        teardown: true
+                    };
+
+                    cancelFn = vs.watchForEvent(obj, opts, cb2);
+                }, function (cb2) {
+                    zoneadm(['-u', uuid, 'halt', '-X'], log, function (e, fds) {
+                        var msg = trim(fds.stderr);
+
+                        if (msg.match(/zone is already halted$/)) {
+                            // zone is already halted, don't block on vminfod
+                            cancelFn();
+
+                            // remove transition marker since vm is not running
+                            VM.unsetTransition(vmobj, {log: log}, function () {
+                                var new_err;
+
+                                new_err = new Error(sprintf(
+                                    'VM %s is already not \'running\''
+                                    + ' (currently: %s)',
+                                    vmobj.uuid, vmobj.state));
+                                new_err.code = 'ENOTRUNNING';
+                                cb2(new_err);
+                            });
+                            return;
+                        }
+
+                        if (e) {
+                            // unknown error, don't wait on vminfod
+                            log.error({err: e, stdout: fds.stdout,
+                                stderr: fds.stderr},
+                                'failed to halt VM %s', uuid);
+
+                            cancelFn();
+                            cb2(e, msg);
+                            return;
+                        }
+
+                        log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                            'zoneadm halted VM %s', uuid);
+                        cb2();
+                    });
+                }
+            ]}, function (err) {
+                cb(err);
+            });
+        }, function (_, cb) {
+            zonecfg(uuid, [unset_autoboot], {log: log},
+                function (error, unset_fds) {
+
+                if (error) {
+                    // The vm is dead at this point, erroring out here
+                    // would do no good, so we just log it.
+                    log.error({err: error, stdout: unset_fds.stdout,
+                        stderr: unset_fds.stderr},
+                        'halt(): Failed to %s', unset_autoboot);
+                    cb();
+                    return;
+                }
+
+                log.debug({stdout: unset_fds.stdout,
+                    stderr: unset_fds.stderr},
+                    'unset autoboot flag');
+
+                if (vmobj.state !== 'stopping') {
+                    cb();
+                    return;
+                }
+
+                // remove transition marker
+                VM.unsetTransition(vmobj, {log: log}, function () {
+                    cb();
                 });
-            }
-        });
+            });
+        }
+    ]}, function (err, results) {
+        callback(err, results);
     });
 }
 
@@ -14220,7 +15965,7 @@ function doTermStop(vmobj, options, callback)
     var timer;
     var tracers_obj;
 
-    assert(vmobj.pid);
+    assert(vmobj.pid, 'vmobj.pid');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('term-stop', log, callback);
@@ -14360,22 +16105,22 @@ function doVmadmdStop(vmobj, options, callback)
 
             zonecfg(vmobj.uuid, [unset_autoboot], {log: log},
                 function (err, fds) {
-                    if (err) {
-                        // The vm is dead at this point, failing
-                        // here would do no good, so we just log it.
-                        log.error({
-                            err: err,
-                            stdout: fds.stdout,
-                            stderr: fds.stderr
-                        }, 'stop(): Failed to ' + unset_autoboot + ' for '
-                            + vmobj.uuid + ': ' + err.message);
-                    } else {
-                        log.info({stdout: fds.stdout, stderr: fds.stderr},
-                            'Stopped ' + vmobj.uuid);
-                    }
-                    cb();
+
+                if (err) {
+                    // The vm is dead at this point, failing
+                    // here would do no good, so we just log it.
+                    log.error({
+                        err: err,
+                        stdout: fds.stdout,
+                        stderr: fds.stderr
+                    }, 'stop(): Failed to ' + unset_autoboot + ' for '
+                        + vmobj.uuid + ': ' + err.message);
+                } else {
+                    log.info({stdout: fds.stdout, stderr: fds.stderr},
+                        'Stopped ' + vmobj.uuid);
                 }
-            );
+                cb();
+            });
         }
     ], callback);
 }
@@ -14448,21 +16193,10 @@ function doShutdownStop(vmobj, options, callback)
 // options parameter is *REQUIRED* for VM.stop()
 exports.stop = function (uuid, options, callback)
 {
-    var load_fields;
     var log;
     var tracers_obj;
     var vmobj;
-
-    load_fields = [
-        'brand',
-        'docker',
-        'pid',
-        'state',
-        'uuid',
-        'zone_state',
-        'zonename',
-        'zonepath'
-    ];
+    var vs;
 
     if (!options) {
         options = {};
@@ -14503,25 +16237,24 @@ exports.stop = function (uuid, options, callback)
     async.series([
         function (cb) {
             /*
-             * We load here to ensure this vm exists, and so when docker=true
-             * we can handle stop specially. But if we're being called by
-             * something that just loaded the object, we can use that instead.
+             * Create the vminfod event stream here that wil be used below to
+             * block on the VM transitioning into the "stopped" state.  Also,
+             * use the "ready" event to get the vmobj for the VM uuid given
              */
-            if (options.vmobj && options.vmobj.uuid === uuid) {
-                log.info('using cached vmobj that was passed in to VM.stop');
-                vmobj = options.vmobj;
-                cb();
-                return;
-            }
-            VM.load(uuid, {log: log, fields: load_fields}, function (err, obj) {
-                if (err) {
-                    log.error(err);
-                    cb(err);
+            vs = new vminfod.VminfodEventStream({
+                name: sprintf('VM.js VM.stop (%s)', uuid),
+                parseReady: true,
+                log: log
+            });
+            vs.once('ready', function (ready_ev) {
+                try {
+                    vmobj = vminfodEventGetVM(uuid, ready_ev);
+                } catch (e) {
+                    cb(e);
                     return;
-                } else {
-                    vmobj = obj;
-                    cb();
                 }
+
+                cb();
             });
         }, function (cb) {
             var unset_autoboot = 'set autoboot=false';
@@ -14543,107 +16276,150 @@ exports.stop = function (uuid, options, callback)
                         'Error setting autoboot=false');
                     cb(e);
                     return;
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'set autoboot=false');
                 }
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'set autoboot=false');
                 cb();
             });
         }, function (cb) {
             var new_err;
 
-            if (vmobj.state !== 'running') {
-                new_err = new Error('VM ' + vmobj.uuid + ' is already '
-                    + 'not \'running\' (currently: ' + vmobj.state + ')');
-                new_err.code = 'ENOTRUNNING';
-                cb(new_err);
-            } else {
+            if (vmobj.state === 'running') {
                 cb();
+                return;
             }
+
+            new_err = new Error('VM ' + vmobj.uuid + ' is already '
+                + 'not \'running\' (currently: ' + vmobj.state + ')');
+            new_err.code = 'ENOTRUNNING';
+            cb(new_err);
         }, function (cb) {
-            var timeoutErr;
+            var cancelFn;
 
-            if (vmobj.docker) {
-                /*
-                 * When a zone has the 'docker=true' flag set, we want to stop
-                 * it the way docker does.
-                 */
-                if (!options.timeout) {
-                    options.timeout = 10;
-                }
-                doTermStop(vmobj, {
-                    log: log,
-                    killOnTimeout: true,
-                    timeout: options.timeout
-                }, cb);
-            } else if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
-                /*
-                 * When use_vm_autoboot, the VM will use vmadmd to perform the
-                 * stop and will not use the 'autoboot' flag in the zonecfg.
-                 * Instead we'll use the 'vm-autoboot' attr to determine whether
-                 * the zone should be booted or not at GZ reboot.
-                 */
-                if (!options.timeout) {
-                    options.timeout = 180;
-                }
-                doVmadmdStop(vmobj, {
-                    log: log,
-                    timeout: options.timeout,
-                    transition_to: options.transition_to
-                }, cb);
-            } else if (vmobj.brand === 'bhyve') {
-                if (!options.timeout) {
-                    options.timeout = 180;
-                }
+            vasync.parallel({funcs: [
+                function (cb2) {
+                    var obj = {
+                        uuid: uuid
+                    };
+                    var changes = [
+                        {
+                            path: ['state'],
+                            newValue: 'stopped'
+                        }
+                    ];
+
+                    if (['bhyve', 'kvm'].indexOf(vmobj.brand) < 0) {
+                        changes.push(
+                            {
+                                path: ['exit_timestamp'],
+                                action: 'added'
+                            },
+                            {
+                                path: ['exit_status'],
+                                action: 'added'
+                            }
+                        );
+                    }
 
-                doTermStop(vmobj, {
-                    log: log,
-                    killOnTimeout: false,
-                    timeout: options.timeout
-                }, cb);
-            } else {
-                // timeout is not supported for non-KVM + non-docker
-                if (options.timeout) {
-                    timeoutErr = new Error('Timeout option is only supported '
-                        + 'for bhyve, KVM and docker containers.');
-                    log.warn({err: timeoutErr}, 'invalid timeout option');
-                    cb(timeoutErr);
-                    return;
-                }
+                    /*
+                     * The timeout is specified here as a very large value -
+                     * this will act as a failsafe that *should* never be hit.
+                     * The individual shutdown functions below will set their
+                     * own timeout, and in the event that they are reached this
+                     * block on vminfod will be cancelled.
+                     */
+                    var opts = {
+                        timeout: 300 * 1000,
+                        catchErrors: true,
+                        teardown: false
+                    };
 
-                /*
-                 * When we're not using vm-autoboot, we go through the 'normal'
-                 * process of trying to shut a zone down cleanly. We do this by
-                 * calling /usr/sbin/shutdown from within the zone. Note also
-                 * that the BRAND_OPTIONS can substitute a different
-                 * shutdown_cmd for a specific brand.
-                 */
-                doShutdownStop(vmobj, {
-                    log: log
-                }, cb);
-            }
-        }, function (cb) {
-            // Verify it's shut down
-            VM.waitForZoneState(vmobj, 'installed', {log: log},
-                function (err, result) {
+                    cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
+                }, function (cb2) {
+                    var timeoutErr;
 
-                if (err) {
-                    if (err.code === 'ETIMEOUT') {
-                        log.info(err, 'timeout waiting for zone to go to '
-                            + '"installed"');
+                    if (vmobj.docker) {
+                        /*
+                         * When a zone has the 'docker=true' flag set, we want
+                         * to stop it the way docker does.
+                         */
+                        if (!options.timeout) {
+                            options.timeout = 10;
+                        }
+                        doTermStop(vmobj, {
+                            log: log,
+                            killOnTimeout: true,
+                            timeout: options.timeout
+                        }, done);
+                    } else if (
+                        BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
+                        /*
+                         * When use_vm_autoboot, the VM will use vmadmd to
+                         * perform the stop and will not use the 'autoboot'
+                         * flag in the zonecfg. Instead we'll use the
+                         * 'vm-autoboot' attr to determine whether the zone
+                         * should be booted or not at GZ reboot.
+                         */
+                        if (!options.timeout) {
+                            options.timeout = 180;
+                        }
+                        doVmadmdStop(vmobj, {
+                            log: log,
+                            timeout: options.timeout,
+                            transition_to: options.transition_to
+                        }, done);
+                    } else if (vmobj.brand === 'bhyve') {
+                        if (!options.timeout) {
+                            options.timeout = 180;
+                        }
+
+                        doTermStop(vmobj, {
+                            log: log,
+                            killOnTimeout: false,
+                            timeout: options.timeout
+                        }, done);
                     } else {
-                        log.error(err, 'unknown error waiting for zone to go'
-                            + ' "installed"');
+                        // timeout is not supported for non-KVM + non-docker
+                        if (options.timeout) {
+                            timeoutErr = new Error('Timeout option is only '
+                                + 'supported for bhyve, KVM and docker '
+                                + 'containers.');
+                            log.warn({err: timeoutErr},
+                                'invalid timeout option');
+                            done(timeoutErr);
+                            return;
+                        }
+
+                        /*
+                         * When we're not using vm-autoboot, we go through the
+                         * 'normal' process of trying to shut a zone down
+                         * cleanly. We do this by calling /usr/sbin/shutdown
+                         * from within the zone. Note also that the
+                         * BRAND_OPTIONS can substitute a different
+                         * shutdown_cmd for a specific brand.
+                         */
+                        doShutdownStop(vmobj, {
+                            log: log
+                        }, done);
+                    }
+
+                    function done(err) {
+                        if (err) {
+                            cancelFn();
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
                     }
-                    cb(err);
-                } else {
-                    // zone got to stopped
-                    log.info('VM seems to have switched to "installed"');
-                    cb();
                 }
-            });
+            ]}, cb);
         }
     ], function (err) {
+        if (vs) {
+            vs.stop();
+            vs = null;
+        }
         callback(err);
     });
 };
@@ -14777,9 +16553,10 @@ function reset(uuid, log, callback)
                 if (e) {
                     callback(new Error('Unable to post "reset" to '
                         + 'vmadmd: ' + e.message));
-                } else {
-                    callback();
+                    return;
                 }
+
+                callback();
             });
         } else {
             zoneadm(['-u', vmobj.uuid, 'reboot', '-X'], log, function (e, fds) {
@@ -14787,11 +16564,12 @@ function reset(uuid, log, callback)
                     log.warn({err: e, stdout: fds.stdout, stderr: fds.stderr},
                         'zoneadm failed to reboot VM ' + vmobj.uuid);
                     callback(new Error(rtrim(fds.stderr)));
-                } else {
-                    log.debug({stdout: fds.stdout, stderr: fds.stderr},
-                        'zoneadm rebooted VM ' + vmobj.uuid);
-                    callback();
+                    return;
                 }
+
+                log.debug({stdout: fds.stdout, stderr: fds.stderr},
+                    'zoneadm rebooted VM ' + vmobj.uuid);
+                callback();
             });
         }
     });
@@ -14876,7 +16654,6 @@ function doReboot(vmobj, options, callback)
                         cleanup = null;
                     }
                 }
-
                 reboot_complete = true;
             }
         }, cb);
@@ -14892,9 +16669,10 @@ function doReboot(vmobj, options, callback)
             VM.stop(vmobj.uuid, options, function (err) {
                 if (err) {
                     cb(err);
-                } else {
-                    cb();
+                    return;
                 }
+
+                cb();
             });
         } else {
             // non-KVM zones
@@ -14914,9 +16692,9 @@ function doReboot(vmobj, options, callback)
                         + ' exited with code' + err.code + ': '
                         + err.message);
                     cb(err);
-                } else {
-                    cb();
+                    return;
                 }
+                cb();
             });
         }
     }, function (cb) {
@@ -14926,33 +16704,44 @@ function doReboot(vmobj, options, callback)
         if (reboot_async) {
             cb();
             return;
-        } else {
-            ticks = 180 * 10; // (180 * 10) 100ms ticks = 3m
-            ival = setInterval(function () {
-                if (reboot_complete) {
-                    log.debug('reboot marked complete, cleaning up');
-                    clearInterval(ival);
-                    if (cleanup) {
-                        cleanup();
-                        cleanup = null;
-                    }
-                    cb();
-                    return;
+        }
+        ticks = 180 * 10; // (180 * 10) 100ms ticks = 3m
+        ival = setInterval(function () {
+            if (reboot_complete) {
+                log.debug('reboot marked complete, cleaning up');
+                clearInterval(ival);
+                if (cleanup) {
+                    cleanup();
+                    cleanup = null;
                 }
-                ticks--;
-                if (ticks <= 0) {
-                    // timed out
-                    log.debug('reboot timed out, cleaning up');
-                    clearInterval(ival);
-                    if (cleanup) {
-                        cleanup();
-                        cleanup = null;
+                cb();
+                return;
+            }
+            ticks--;
+            if (ticks <= 0) {
+                // timed out
+                log.debug('reboot timed out, cleaning up');
+                clearInterval(ival);
+                if (cleanup) {
+                    cleanup();
+                    cleanup = null;
+                }
+
+                logDebugZoneInfo(vmobj.zonename, {log: log}, function (err) {
+                    if (err) {
+                        /*
+                         * Any errors encountered by this function will have
+                         * already been logged, and any failure to log debug
+                         * info will not be considered a fatal error.
+                         */
+                        log.warn({err: err}, 'logDebugZoneInfo failed');
                     }
+
                     cb(new Error('timed out waiting for zone to reboot'));
-                    return;
-                }
-            }, 100);
-        }
+                });
+                return;
+            }
+        }, 100);
     }], function (err) {
         if (cleanup) {
             cleanup();
@@ -15169,9 +16958,9 @@ exports.sysrq = function (uuid, req, options, callback)
             if (e) {
                 callback(new Error('Unable to post "sysrq" to vmadmd: '
                     + e.message));
-            } else {
-                callback();
+                return;
             }
+            callback();
         });
     });
 };
@@ -15275,6 +17064,116 @@ exports.console = function (uuid, options, callback)
     });
 };
 
+exports.events = function events(opts, handler, cb) {
+    var emitter = new EventEmitter();
+    var log;
+    var tracers_obj;
+
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.optionalString(opts.zonename, 'opts.zonename');
+    assert.optionalString(opts.name, 'opts.name');
+    assert.func(handler, 'handler');
+    assert.func(cb, 'cb');
+
+    ensureLogging(true);
+    if (opts.hasOwnProperty('log')) {
+        log = opts.log;
+    } else {
+        log = VM.log.child({action: 'events'});
+    }
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('install', log, cb);
+        cb = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    // Construct name to use for vminfod requests and logging
+    var name = 'VM.js events';
+    if (opts.zonename) {
+        name += sprintf(' (zonename: %s)', opts.zonename);
+    }
+    if (process.env.REQ_ID) {
+        name += sprintf(' - (req_id: %s)', process.env.REQ_ID);
+    }
+    if (opts.name) {
+        name += sprintf(' - %s', opts.name);
+    }
+
+    log = log.child({ident: name});
+    var vs = new vminfod.VminfodEventStream({
+        name: name,
+        parseReady: true,
+        log: log
+    });
+
+    vs.once('ready', function (ready_ev) {
+        var obj = {
+            ev: ready_ev,
+            stop: stop
+        };
+
+        /*
+         * If the user wants to watch a specific VM, ensure it exists and error
+         * early if it does not.
+         */
+        if (opts.zonename && !ready_ev.vms.hasOwnProperty(opts.zonename)) {
+            stop();
+            cb(new Error(sprintf('VM %s not found', opts.zonename)));
+            return;
+        }
+
+        cb(null, obj);
+    });
+
+    vs.on('readable', function () {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            processVminfodEvent(ev);
+        }
+    });
+
+    vs.on('error', function (err) {
+        emitter.emit('error', err);
+    });
+
+    function processVminfodEvent(ev) {
+        log.trace({ev: ev}, 'vminfod event');
+
+        if (opts.zonename && opts.zonename !== ev.zonename) {
+            return;
+        }
+
+        handler(ev);
+    }
+
+    function stop() {
+        log.debug('stop called');
+        vs.stop();
+    }
+
+    return emitter;
+};
+
+function calculateZonepath(vmobj) {
+    var err;
+
+    assert.object(vmobj, 'vmobj');
+
+    if (vmobj.hasOwnProperty('zonepath')) {
+        return (vmobj.zonepath);
+    } else if (vmobj.hasOwnProperty('zpool')
+        && vmobj.hasOwnProperty('zonename')) {
+
+        return ('/' + vmobj.zpool + '/' + vmobj.zonename);
+    }
+
+    err = new Error('unable to find zonepath for ' + vmobj.uuid);
+    err.vmobj = vmobj;
+    throw err;
+}
+
 function zlogObjToString(obj) {
     assert.object(obj, 'zlogObjToString obj');
     assert.optionalBool(obj.gz, 'zlogObjToString obj.gz');
@@ -15371,3 +17270,45 @@ function calculateZlogModeAndDriver(payload, vmobj) {
         driver: log_driver
     };
 }
+
+function deepEqual(a, b) {
+    try {
+        assert.deepEqual(a, b);
+        return true;
+    } catch (e) {
+        return false;
+    }
+}
+
+function vminfodEventGetVM(uuid, ready_ev) {
+    assert.uuid(uuid, 'uuid');
+    assert.object(ready_ev, 'ready_ev');
+    assert.object(ready_ev.vms, 'ready_ev.vms (parseReady must be enabled)');
+
+    var err;
+    var vmobj;
+
+    vmobj = ready_ev.vms[uuid];
+
+    if (!vmobj) {
+        err = new Error(sprintf('VM %s not found', uuid));
+        err.code = 'ENOENT';
+        throw err;
+    }
+
+    assert.object(vmobj, 'vmobj');
+
+    return vmobj;
+}
+
+function zoneXMLPath(zonename) {
+    assert.uuid(zonename, 'zonename');
+
+    return sprintf('/etc/zones/%s.xml', zonename);
+}
+
+function zoneConfigLockpath(uuid) {
+    assert.uuid(uuid, 'uuid');
+
+    return sprintf('/var/run/vm.%s.config.lockfile', uuid);
+}
diff --git a/src/vm/node_modules/diff.js b/src/vm/node_modules/diff.js
new file mode 100644
index 00000000..09da483a
--- /dev/null
+++ b/src/vm/node_modules/diff.js
@@ -0,0 +1,505 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ * "diff" 2 JavaScript objects
+ *
+ * var a = {
+ *     foo: true,
+ *     num: 1
+ * };
+ * var b = {
+ *     bar: true,
+ *     num: 2
+ * };
+ * var changes = diff(a, b);
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "foo",
+ *     "path": ["foo"],
+ *     "action": "removed",
+ *     "oldValue": true
+ *   },
+ *   {
+ *     "prettyPath": "num",
+ *     "path": ["num"],
+ *     "action": "changed",
+ *     "oldValue": 1,
+ *     "newValue": 2
+ *   },
+ *   {
+ *     "prettyPath": "bar",
+ *     "path": ["bar"],
+ *     "action": "added",
+ *     "newValue": true
+ *   }
+ * ]
+ *
+ * On top of this basic functionality, this function also supports comparing
+ * objects for modifications based on an "identifierKey" supplied in a map.
+ *
+ * Consider the following two objects.
+ *
+ * var a = {
+ *     disks: [
+ *         {
+ *             name: "foo",
+ *             size: 10
+ *         }
+ *     ]
+ * };
+ * var b = {
+ *     disks: [
+ *         {
+ *             name: "foo",
+ *             size: 20
+ *         }
+ *     ]
+ * };
+ *
+ * Looking at these objects, we can see that the "disks" array has a single
+ * object with both a name and size - only the size has changed from 10 to 20.
+ * Running these objects through diff() without a map yields:
+ *
+ * var changes = diff(a, b);
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "disks.*",
+ *     "path": [
+ *       "disks",
+ *       null
+ *     ],
+ *     "action": "removed",
+ *     "oldValue": {
+ *       "name": "foo",
+ *       "size": 10
+ *     }
+ *   },
+ *   {
+ *     "prettyPath": "disks.*",
+ *     "path": [
+ *       "disks",
+ *       null
+ *     ],
+ *     "action": "added",
+ *     "newValue": {
+ *       "name": "foo",
+ *       "size": 20
+ *     }
+ *   }
+ * ]
+ *
+ * Note that `null` in the `path` array means any element of the array, as
+ * this module doesn't concern itself with the indices of an array or array
+ * sort order.
+ *
+ * diff() reports that an entire object was removed from the "disks" array
+ * and replaced with a new object.  If we know ahead of time that a key
+ * (like "disks") is guaranteed to be an array of objects, we can give diff()
+ * a "map" where we can specify that "disks" -> "name"... meaning "disks"
+ * is an array of objects where "name" is a key that represents a unique
+ * identifier for the object.  This way, we can determine if an object
+ * was removed completely, or just modified in place.
+ *
+ * var map = {
+ *     disks: 'name'
+ * };
+ * var changes = diff(a, b, {map: map});
+ * console.log(changes);
+ * [
+ *   {
+ *     "prettyPath": "disks.*.size",
+ *     "path": [
+ *       "disks",
+ *       null,
+ *       "size"
+ *     ],
+ *     "action": "changed",
+ *     "oldValue": 10,
+ *     "newValue": 20,
+ *     "ident": "foo"
+ *   }
+ * ]
+ *
+ * With the map supplied, only one change is reported (the size).  The "ident"
+ * key shows the value of the identifierKey for the object modified (in this
+ * case, the value of the disks "name" attribute).
+ *
+ * The keys given in the "map" object are only applied to the base object
+ * given, meaning an initial object like this won't use the map.
+ *
+ * var a = {
+ *     "root": {
+ *         "disks": [
+ *             {
+ *                 "name": "foo"
+ *             }
+ *         ]
+ *     }
+ * };
+ *
+ * As the base key considered by the map in this example is "root".
+ *
+ */
+
+var assert = require('/usr/node/node_modules/assert-plus');
+
+/*
+ * This is the entry point into this module.
+ *
+ * This function will determine the appropriate internal diffing function to
+ * call based on the input paramaters.
+ *
+ * The folliwng data types are supported by this module.
+ *
+ * - Primitives (number, string, boolean)
+ * - Array
+ * - Object
+ * - Date
+ * - null
+ * - undefined
+ *
+ * Any other data type may or may not yield unexpected results.
+ *
+ * opts is an optional object that may contain
+ *
+ *   - opts.map    A key->value mapping used for determining object differencs,
+ *                 more information about this can be found in this files block
+ *                 comment
+ *   - opts.prefix An array to keep track of how deep into an object we
+ *                 currently are.  This variable is created and maintaned by
+ *                 the internal diffing functions like objDiff and arrayDiff
+ *                 and should not be provided by the caller.
+ */
+function diff(a, b, opts) {
+    if (theSameValue(a, b)) {
+        return [];
+    } else if (Array.isArray(a) && Array.isArray(b)) {
+        return arrayDiff.apply(this, arguments);
+    } else {
+        return objDiff.apply(this, arguments);
+    }
+}
+
+/*
+ * Compare two objects - called by diff()
+ *
+ * opts is the same object document in the diff() function
+ */
+function objDiff(a, b, opts) {
+    var changes = [];
+    var prefix;
+
+    opts = opts || {};
+    opts.map = opts.map || {};
+    prefix = opts.prefix || [];
+
+    assert.object(opts, 'opts');
+    assert.object(opts.map, 'opts.map');
+    assert.array(prefix, 'prefix');
+
+    if (theSameValue(a, b))
+        return [];
+
+    assert.object(a, 'a');
+    assert.object(b, 'b');
+
+    // loop all keys on the a (from) side
+    Object.keys(a).forEach(function loopFromObject(key) {
+        var nestOpts = {};
+        var path = prefix.concat(key);
+        var prettyPath = toDotNotation(path);
+
+        // if the key is not in b, it was removed
+        if (!hasProperty(b, key)) {
+            changes.push({
+                prettyPath: prettyPath,
+                path: path,
+                action: 'removed',
+                oldValue: a[key]
+            });
+            return;
+        }
+
+        // if the value in a is the same as the value in b, there was no change
+        // so we move on
+        if (theSameValue(a[key], b[key]))
+            return;
+
+        // if either key in a or b is not an object, then the value has changed
+        if (typeof (a[key]) !== 'object'
+            || typeof (b[key]) !== 'object') {
+
+            changes.push({
+                prettyPath: prettyPath,
+                path: path,
+                action: 'changed',
+                oldValue: a[key],
+                newValue: b[key]
+            });
+
+            return;
+        }
+
+        // both values are objects (maybe Array), compare recursively
+        Object.keys(opts).forEach(function loopOpts(k) {
+            nestOpts[k] = opts[k];
+        });
+        nestOpts.prefix = path;
+
+        diff(a[key], b[key], nestOpts, key).forEach(
+            function loopNestedChanges(change) {
+
+            changes.push(change);
+        });
+    });
+
+    // loop all keys in the b (to) side to find any additions
+    Object.keys(b).forEach(function loopToObject(key) {
+        if (hasProperty(a, key))
+            return;
+
+        var path = prefix.concat(key);
+        var prettyPath = toDotNotation(path);
+
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'added',
+            newValue: b[key]
+        });
+    });
+
+    return changes;
+}
+
+/*
+ * Compare two arrays - called by diff()
+ *
+ * opts is the same object document in the diff() function
+ *
+ * key is optional and not to be passed by the consumer.  If key is set, it
+ * means the array we are currently calculating the differences for was nested
+ * inside an object under this key.  Using this information, we can determine
+ * if the "map" (if set) should be used to calculate differences.
+ */
+function arrayDiff(a, b, opts, key) {
+    var aSerialized;
+    var bSerialized;
+    var changes = [];
+    var identifierKey;
+    var modified = [];
+    var path;
+    var possiblyAdded = [];
+    var possiblyRemoved = [];
+    var prefix;
+    var prettyPath;
+
+    opts = opts || {};
+    opts.map = opts.map || {};
+    prefix = opts.prefix || [];
+
+    assert.array(a, 'a');
+    assert.array(b, 'b');
+    assert.object(opts, 'opts');
+    assert.object(opts.map, 'opts.map');
+    assert.array(prefix, 'prefix');
+
+    // because we are inside an array, we add `null` to the end of the current
+    // path.
+    path = prefix.concat(null);
+    prettyPath = toDotNotation(path);
+
+    // check if we should use the "map" for this array
+    if (key && path.length === 2 && hasProperty(opts.map, key))
+        identifierKey = opts.map[key];
+
+    // serialize everything in a and b to compare directly as strings
+    aSerialized = a.map(function serializeArrayA(o) {
+        return JSON.stringify(o);
+    });
+    bSerialized = b.map(function serializeArrayB(o) {
+        return JSON.stringify(o);
+    });
+
+    // all values in a not found in b have been possibly removed
+    aSerialized.forEach(function checkRemoved(o, i) {
+        if (bSerialized.indexOf(o) >= 0)
+            return;
+
+        possiblyRemoved.push(i);
+    });
+
+    // all values in b not found in a have been possibly added
+    bSerialized.forEach(function checkAdded(o, j) {
+        if (aSerialized.indexOf(o) >= 0)
+            return;
+
+        possiblyAdded.push(j);
+    });
+
+    // if an identifierKey is found - meaning the arrays we are looking at
+    // were found inside an object with a given "key" (4th arg), we treat
+    // every element inside the array as an object, and look for an
+    // "identifier" object to compare
+    if (identifierKey) {
+        possiblyRemoved = possiblyRemoved.filter(function filterRemoved(i) {
+            var found = false;
+            var oi = a[i];
+
+            assert.object(oi, 'must be an object: ' + JSON.stringify(oi));
+
+            possiblyAdded = possiblyAdded.filter(function filterAdded(j) {
+                var oj = b[j];
+
+                assert.object(oi, 'must be an object');
+
+                if (found)
+                    return true;
+
+                if (oi[identifierKey] === oj[identifierKey]) {
+                    found = true;
+
+                    // to be processed recursively below
+                    modified.push({
+                        a: oi,
+                        b: oj,
+                        ident: oi[identifierKey]
+                    });
+                    return false;
+                }
+
+                return true;
+            });
+
+            return !found;
+        });
+    }
+
+    // add the changes to the changes array to be returned
+    possiblyRemoved.forEach(function pushRemovedChanges(i) {
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'removed',
+            oldValue: a[i]
+        });
+    });
+    modified.forEach(function pushModifiedChanges(mod) {
+        // mod.a and mod.b are guaranteed to be objects
+        var _changes = objDiff(mod.a, mod.b, {prefix: path});
+        _changes.forEach(function pushModifiedChange(change) {
+            change.ident = mod.ident;
+            changes.push(change);
+        });
+    });
+    possiblyAdded.forEach(function pushAddedChanges(j) {
+        changes.push({
+            prettyPath: prettyPath,
+            path: path,
+            action: 'added',
+            newValue: b[j]
+        });
+    });
+
+    return changes;
+}
+
+/*
+ * Check if 2 primitive values are the same
+ */
+function theSameValue(a, b) {
+    if (a === b)
+        return true;
+
+    if (a instanceof Date && b instanceof Date)
+        return theSameValue(a.getTime(), b.getTime());
+
+    return false;
+}
+
+/*
+ * Convert a "path" (given as an array) to a pretty-formatted dot-notation
+ * string. This is solely meant for producing a human-readable path in the
+ * "changes" array given from any object or array diff.  Examples
+ *
+ * > toDotNotation(['disks', 0, 'name'])
+ * => 'disks.0.name'
+ *
+ * > toDotNotation(['disks', null, 'name']);
+ * => 'disks.*.name'
+ *
+ * > toDotNotation(['nics', '192.168.1.1', 'name'])
+ * => 'nics[192.168.1.1].name'
+ *
+ */
+function toDotNotation(arr) {
+    var s = '';
+
+    assert.array(arr, 'arr');
+
+    arr.forEach(function loopPathElements(elem) {
+        if (elem === null)
+            elem = '*';
+        elem = '' + elem;
+
+        if (elem.match(/[\.\[\]]/)) {
+            elem = elem.replace(/([\[\]])/g, '\\$1');
+            s += '[' + elem + ']';
+            return;
+        }
+
+        if (s.length > 0)
+            s += '.';
+        s += elem;
+    });
+    return s;
+}
+
+/*
+ * safe hasOwnProperty
+ */
+function hasProperty(o, p) {
+    return ({}).hasOwnProperty.call(o, p);
+}
+
+module.exports = diff;
+
+function main() {
+    var read = require('fs').readFileSync;
+    var a = JSON.parse(read(process.argv[2]));
+    var b = JSON.parse(read(process.argv[3]));
+
+    var opts;
+    if (process.argv[4])
+        opts = JSON.parse(read(process.argv[4]));
+    var key = process.argv[5];
+
+    var changes = diff(a, b, opts, key);
+    console.log(JSON.stringify(changes, null, 2));
+}
+
+if (require.main === module)
+    main();
diff --git a/src/vm/node_modules/expander.js b/src/vm/node_modules/expander.js
index fc07d45f..c56ab5cc 100644
--- a/src/vm/node_modules/expander.js
+++ b/src/vm/node_modules/expander.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -53,7 +53,7 @@ console.log(
     + ' */\n'
     + '\n'
     + '/*\n'
-    + ' * Copyright (c) 2018, Joyent, Inc. All rights reserved.\n'
+    + ' * Copyright (c) 2018, Joyent, Inc.\n'
     + ' *\n'
     + ' * THIS FILE IS AUTOGENERATED FROM proptable.js DO NOT EDIT!!!\n'
     + ' * CHANGES WILL BE LOST.\n'
@@ -192,6 +192,9 @@ Object.keys(proptable.properties).forEach(function (prop) {
 
     if (property.payload) {
         payload_prop = {pr_type: property.payload.type};
+        if (property.payload.hasOwnProperty('default')) {
+            payload_prop['pr_default'] = property.payload.default;
+        }
         if (property.payload.hasOwnProperty('check_as')) {
             payload_prop['pr_check_as'] = property.payload.check_as;
         }
diff --git a/src/vm/node_modules/fswatcher.js b/src/vm/node_modules/fswatcher.js
new file mode 100644
index 00000000..f33871d9
--- /dev/null
+++ b/src/vm/node_modules/fswatcher.js
@@ -0,0 +1,943 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ * This module exists to watch files for changes. It is somewhat similar to
+ * node's fs.watch except:
+ *
+ *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
+ *    it actually starts watching.
+ *  * FsWatcher works with files that do not exist yet, notifying you when they
+ *    are created.
+ *
+ * To use you should do something like:
+ *
+ *  var fsw = new FsWatcher({log: log});
+ *  fsw.once('ready', function ready() {
+ *      fsw.watch('/path/to/some/file', function (err) { ... });
+ *      fsw.unwatch('/path/to/some/file', function (err) { ... });
+ *      fsw.status(function (err, obj) { ... });
+ *      fsw.stop();
+ *  });
+ *  fsw.on(<event type>, callback(event));
+ *  fsw.start();
+ *
+ * Where the event types can be:
+ *
+ *  * event - for any event
+ *  * create - emitted when a file is created
+ *  * change - emitted when a file is modified
+ *  * delete - emitted when a file is deleted
+ *
+ * How this works:
+ *
+ *   This module is a wrapper around the fswatcher tool. That tool is driven by
+ *   commands on STDIN which start and stop watches on files. Output goes to
+ *   STDOUT (as json)  and is scraped by this module and turned into events.
+ *
+ * When `fsw.start()` is called, the companion fswatcher C program is started,
+ * and a 'ready' event is emitted when the program is fully loaded and ready to
+ * start receiving input.  Once it is ready, you may call .watch, .unwatch,
+ * etc.
+ *
+ * When a file watch is attempted, the command to watch it is sent to the
+ * fswatcher C program.  If it succeeds, the callback is fired immediately
+ * and any new events for the file will be emitted when they are seen.  If
+ * it fails however, a successful callback is still fired, but the file
+ * is moved to a retry "interval".  The term interval is used here, but it's
+ * actually a JavaScript setTimeout under the hood that calls itself as part
+ * of the retry logic.
+ *
+ * The common case is, when a .watch() command is given, the file we want to
+ * watch either exists or will exist very soon.  Because of this, if the initial
+ * watch fails, that file specifically will be retried (the WATCH command sent
+ * to the fswatcher program again) 10 times every 200ms - this is called the
+ * INITIAL_WATCH_INTERVAL.  If it succeeds during this time, the timeout will
+ * be cleared and a 'create' event for the file will be emitted.
+ *
+ * If the file fails the INITIAL_WATCH_INTERVAL, it will move over to the
+ * LONG_WATCH_INTERVAL.  This is an interval (again, actually a setTimeout
+ * that calls itself when finished) that runs every 10 seconds to retry every
+ * file that does not yet exist.  This is a single interval that runs every
+ * 10 seconds no matter what, and loops every file that we want to watch but
+ * does not yet exist.  When a WATCH command succeeds for a file in this
+ * interval it is removed from the "not_yet_watching" list and a 'create'
+ * event for the file be emitted.
+ *
+ */
+
+var cp = require('child_process');
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var jsprim = require('/usr/vm/node_modules/jsprim');
+var LineStream = require('/usr/node/node_modules/linestream');
+var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
+var vasync = require('/usr/vm/node_modules/vasync');
+
+/*
+ * when a file is watched but does not yet exist, FsWatcher will default to
+ * retry watching the file INITIAL_WATCH_TRIES (10) tries every
+ * INITIAL_WATCH_DELAY (200) milliseconds before transitioning the file to the
+ * long watch interval.
+ */
+var INITIAL_WATCH_DELAY = 200;
+var INITIAL_WATCH_TRIES = 10;
+
+/*
+ * when a file fails to be watched during its own initial watch interval it
+ * will be transferred to a longer class-wide interval that tries to watch all
+ * unwatched files every LONG_WATCH_DELAY (10000) milliseconds.
+ */
+var LONG_WATCH_DELAY = 10 * 1000;
+
+// fswatcher.c can handle 2^64, but to be safe with JavaScript we restrict the
+// maximum key.
+var FSWATCHER_MAX_KEY = Math.pow(2, 32);
+
+// illegal characters for filenames - this limitation is in fswatcher.c
+var ILLEGAL_FILENAME_CHARS = ['\n', '\0'];
+
+// number of fswatcher stderr lines to hold in memory
+var FSWATCHER_STDERR_LINES = 100;
+
+// number of messages to store to calculate delay
+var MESSAGE_DELAY_BUFFER_SIZE = 1000;
+
+// minimum allowable time in ms before a warning log is emitted
+var MESSAGE_DELAY_LOG_THRESHOLD = 10;
+
+// companion C program that is our interface to event ports
+var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
+if (process.env.FSWATCHER_CMD) {
+    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
+}
+
+// default logger if left unspecified
+var LOG = bunyan.createLogger({
+    level: 'debug',
+    name: 'fswatcher',
+    streams: [
+    {
+        stream: process.stderr,
+        level: 'debug'
+    }
+    ],
+    serializers: bunyan.stdSerializers
+});
+
+function noop() {}
+
+/*
+ * Create an FsWatcher instance
+ */
+function FsWatcher(opts) {
+    var self = this;
+
+    EventEmitter.call(self);
+
+    opts = opts || {};
+    self.log = opts.log || LOG;
+
+    assert.object(opts, 'opts');
+    assert.object(self.log, 'opts.log');
+    assert.optionalBool(opts.dedup, 'opts.dedup');
+    assert.optionalNumber(opts.initial_watch_delay,
+        'opts.initial_watch_delay');
+    assert.optionalNumber(opts.initial_watch_tries,
+        'opts.initial_watch_tries');
+    assert.optionalNumber(opts.long_watch_delay, 'opts.long_watch_delay');
+
+    // turned on when .stop() is issue and off when the process exits
+    self.stopping = false;
+
+    // if we should dedup events from the same time (millisecond resolution)
+    self.dedup = opts.dedup;
+
+    // files currently being watched
+    self.watching = {};
+
+    // files that need to be watched but don't exist yet
+    self.not_yet_watching = {};
+
+    // fswatcher stderr lines generated
+    self.stderr_buffer = new RingBuffer({limit: FSWATCHER_STDERR_LINES});
+
+    // time delta from when messages are generated by fswatcher.c, to when they
+    // are processed by this module.
+    self.message_delay_buffer = new RingBuffer({
+        limit: MESSAGE_DELAY_BUFFER_SIZE
+    });
+
+    // see comments at the top of this file for "default values" for information
+    // on these variables
+    self.initial_watch_delay = opts.initial_watch_delay || INITIAL_WATCH_DELAY;
+    self.initial_watch_tries = opts.initial_watch_tries || INITIAL_WATCH_TRIES;
+    self.long_watch_delay = opts.long_watch_delay || LONG_WATCH_DELAY;
+}
+util.inherits(FsWatcher, EventEmitter);
+
+/*
+ * start the long interval
+ */
+FsWatcher.prototype.start = function start() {
+    var self = this;
+
+    assert(!self.isRunning(), 'already running');
+
+    self.cur_request_key = 0;
+    self.pending_actions = {};
+
+    /*
+     * We store the previous event seen to use for deduplication purposes -
+     * if the same exact event is seen within the same millisecond every event
+     * after the first is thrown out.
+     */
+    self.prev_event = null;
+
+    // no matter what, this loop runs to watch any unwatched files
+    function long_watch_interval() {
+        self._watchUnwatchedFiles(function _watchUnwatchedFilesDone() {
+            self.long_watch_timeout = setTimeout(long_watch_interval,
+                self.long_watch_delay);
+        });
+    }
+    self.long_watch_timeout = setTimeout(long_watch_interval,
+        self.long_watch_delay);
+
+    // start the companion C program
+    self.watcher = cp.spawn(FSWATCHER_CMD, ['-r', '-j'], {stdio: 'pipe'});
+    self.watcher_pid = self.watcher.pid;
+
+    /*
+     * stdout is newline separated JSON.  It is broken into lines here and each
+     * raw line (String) is pushed on the vasync res_queue that handles parsing
+     * and processing it.  A queue is used to add a callback to processing a
+     * single line of stdout - this way, any async work required by a stdout
+     * line is handled before the line is processed.
+     */
+    var stdoutls = new LineStream();
+    self.watcher.stdout.pipe(stdoutls).on('readable', function stdoutReady() {
+        var line;
+        while ((line = stdoutls.read()) !== null) {
+            self.log.trace({line: line}, 'fswatcher stdout line');
+            self.res_queue.push(line);
+        }
+    });
+
+    /*
+     * stderr can contain useful debugging information from the fswatcher
+     * program, so all lines are output via log.trace(), and the last
+     * FSWATCHER_STDERR_LINES lines are stored in a ring buffer and printed if
+     * a fatal error occurs
+     */
+    var stderrls = new LineStream();
+    self.watcher.stderr.pipe(stderrls).on('readable', function stderrReady() {
+        var line;
+        while ((line = stderrls.read()) !== null) {
+            self.log.trace({line: line}, 'fswatcher stderr line');
+            self.stderr_buffer.write(line);
+        }
+    });
+
+    /*
+     * handle watcher exiting.  if this is not the result of .stop(), we error
+     * loudly
+     */
+    self.watcher.on('close', function fswatcherClosed(code, signal) {
+        var e = new Error('fswatcher exited');
+        e.code = code;
+        e.signal = signal;
+        e.pid = self.watcher_pid;
+        e.stderr = self.stderr_buffer.records.join('\n');
+
+        self.stderr_buffer.records = [];
+        self.watcher = null;
+        self.watcher_pid = null;
+
+        if (self.stopping) {
+            self.log.debug({err: e, signal: signal, code: code, pid: e.pid},
+                'fswatcher exited');
+            assert.func(self.stop_cb, 'stop() not called');
+            self.stop_cb();
+            delete self.stop_cb;
+            self.stopping = false;
+        } else {
+            assert(!self.stop_cb, 'stop cb set without .stop() being called');
+            self.log.error({err: e, signal: signal, code: code, pid: e.pid},
+                'fswatcher exited');
+            self.log.error({dump: self.dump()},
+                'fswatcher .dump()');
+            self.log.error({stderr: e.stderr}, 'fswatcher stderr');
+            self.emit('error', e);
+        }
+    });
+
+    /*
+     * allow the consumer of this module to watch for errors with the child
+     * process
+     */
+    self.watcher.on('error', function fswatchError(err) {
+        self.log.error({err: err}, 'fswatcher error');
+        self.emit('error', err);
+    });
+
+    /*
+     * this queue handles line-by-line stdout responses from the fswatcher.c
+     * program
+     */
+    self.res_queue = vasync.queue(function stdoutQueue(line, cb) {
+        var err;
+        var delta;
+        var ms1;
+        var ms2;
+        var obj;
+
+        if (!self.isRunning()) {
+            self.log.warn({line: line},
+                'stdout received while not running');
+            cb();
+            return;
+        }
+
+        try {
+            obj = JSON.parse(line);
+            assert.string(obj.type, 'stdout obj.type');
+            hrtime.assertHrtime(obj.time, 'stdout obj.time');
+        } catch (parseErr) {
+            self.log.error({
+                err: parseErr,
+                line: line
+            }, 'BAD JSON');
+            throw parseErr;
+        }
+        self.log.trace({obj: obj}, 'fswatcher event');
+
+        if (self.dedup && self.prev_event !== null) {
+            // convert both monotonic timers to milliseconds for dedup purposes
+            ms1 = jsprim.hrtimeMillisec(obj.time);
+            ms2 = jsprim.hrtimeMillisec(self.prev_event.time);
+
+            if (self.prev_event.pathname === obj.pathname
+                && self.prev_event.type === obj.type
+                && ms1 === ms2) {
+
+                self.log.debug({obj: obj}, 'discarding duplicate object');
+                process.nextTick(cb);
+                return;
+            }
+        }
+        self.prev_event = jsprim.deepCopy(obj);
+
+        delta = jsprim.hrtimeMillisec(process.hrtime(obj.time));
+        self.message_delay_buffer.write(delta);
+        if (delta > MESSAGE_DELAY_LOG_THRESHOLD) {
+            self.log.warn({deltaMs: delta, avg: self.messageDelays()},
+                'message took %dms to process (> %dms)',
+                delta, MESSAGE_DELAY_LOG_THRESHOLD);
+        }
+
+        switch (obj.type) {
+        case 'ready':
+            handleReady(obj, cb);
+            break;
+        case 'event':
+            handleEvent(obj, cb);
+            break;
+        case 'response':
+            handleResponse(obj, cb);
+            break;
+        case 'error':
+        default:
+            err = new Error('dispatching error');
+            self.log.warn({err: err, obj: obj}, err.message);
+            throw err;
+        }
+    }, 1);
+
+    function handleReady(obj, cb) {
+        self.emit('ready', obj);
+        cb();
+    }
+
+    function handleEvent(obj, cb) {
+        assert.bool(obj.final, 'obj.final');
+        assert.arrayOfString(obj.changes, 'obj.changes');
+        assert.string(obj.pathname, 'obj.pathname');
+
+        var f = obj.pathname;
+        var w = self.watching[f];
+        assert.object(w, 'not watching ' + obj.pathname);
+
+        // UNWATCH is queued, ignore event
+        if (!w.active) {
+            cb();
+            return;
+        }
+
+        // fswatcher.c is done watching this file, queue a rewatch
+        if (obj.final) {
+            self.log.debug({f: f}, 'file was final, queueing rewatch');
+            delete self.watching[f];
+            self.watch(f);
+        }
+
+        if (obj.changes.indexOf('FILE_MODIFIED') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_RENAME_TO') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_TRUNC') !== -1)
+            obj.type = 'change';
+        if (obj.changes.indexOf('FILE_DELETE') !== -1)
+            obj.type = 'delete';
+        if (obj.changes.indexOf('UNMOUNTED') !== -1)
+            obj.type = 'delete';
+
+        if (obj.final && obj.type !== 'delete') {
+            /*
+             * An event marked as "final" means that fswatcher.c will not
+             * attempt to rewatch the file.  It's possible that a file could
+             * be marked as "final" without a "delete" event being seen,
+             * because of the asynchronous nature of filesystem events.
+             *
+             * In this case, we log a warning, and pretend it was a delete -
+             * since the file is effectively gone for our purposes.
+             */
+            self.log.warn({obj: obj}, 'final event seen for non-delete type');
+            obj.type = 'delete';
+        }
+
+        if (obj.type !== 'event')
+            self.emit(obj.type, obj);
+        self.emit('event', obj);
+        cb();
+    }
+
+    function handleResponse(obj, cb) {
+        assert.number(obj.key, 'obj.key');
+        assert.number(obj.code, 'obj.code');
+        assert.string(obj.result, 'obj.result');
+        assert.optionalString(obj.pathname, 'obj.pathname');
+        assert.optionalString(obj.message, 'obj.message');
+        assert.optionalObject(obj.data, 'obj.data');
+
+        var pa = self.pending_actions[obj.key];
+
+        assert.object(pa, 'pending_action ' + obj.key);
+        assert.func(pa.cb, 'pending_action.cb ' + obj.key);
+
+        var t = process.hrtime();
+        var delta = hrtime.hrtimeDeltaPretty(t, pa.started);
+
+        self.log.trace('command %s took %s', pa.cmd, delta);
+
+        pa.cb(null, obj);
+        delete self.pending_actions[obj.key];
+        cb();
+    }
+};
+
+/*
+ * stop watching everything
+ */
+FsWatcher.prototype.stop = function stop(cb) {
+    var self = this;
+
+    assert(self.isRunning(), 'not running');
+    assert(!self.stop_cb, 'stop() aready issued');
+    assert.func(cb, 'cb');
+
+    self.stop_cb = cb;
+    self.stopping = true;
+
+    // stop the watcher
+    self.watcher.kill();
+
+    // clear all watches that haven't been established yet
+    Object.keys(self.not_yet_watching).forEach(function clearNotYetWatching(f) {
+        var o = self.not_yet_watching[f];
+
+        if (o.timeout) {
+            clearTimeout(o.timeout);
+            o.timeout = null;
+        }
+
+        delete self.not_yet_watching[f];
+    });
+
+    // clear all existing watches
+    self.watching = {};
+
+    // stop the long_watch_interval
+    clearTimeout(self.long_watch_timeout);
+    self.long_watch_timeout = null;
+};
+
+/*
+ * watch a file
+ */
+FsWatcher.prototype.watch = function watch(f, cb) {
+    var self = this;
+    cb = cb || noop;
+
+    var initial = true;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(f, 'filename unspecified');
+    assert.func(cb, 'cb');
+
+    // validate filename
+    var e = self._validFilename(f);
+    if (e) {
+        cb(e);
+        return;
+    }
+
+    /*
+     * callback with an error if we've already been instructed to watch this
+     * file
+     */
+    if (self._isWatching(f)) {
+        cb(new Error('already watchng ' + f));
+        return;
+    }
+
+    /*
+     * all new files start off in the 'not_yet_watching' bucket and are moved
+     * to the 'watching' bucket when/if a call to `fs.watch(f)` is successful
+     */
+    self.not_yet_watching[f] = {
+        tries: 0,
+        timeout: null,
+        long_watch: false
+    };
+
+    /*
+     * try to watch the file - this function will call itself multiple times
+     * based on the values set in the constructor if it fails before moving the
+     * file to the long interval
+     */
+    tryWatching();
+
+    function tryWatching() {
+        var o = self.not_yet_watching[f];
+
+        /*
+         * watch was cancelled (probably shutting down or told to unwatch),
+         * just give up
+         */
+        if (o === undefined) {
+            if (initial) {
+                initial = false;
+                cb();
+            }
+            return;
+        }
+
+        o.timeout = null;
+
+        /*
+         * we've tried too many times, just give up and let the long interval
+         * catch it
+         */
+        if (o.tries >= self.initial_watch_tries) {
+            self.log.trace('%s exceeded max tries, moving to long interval', f);
+            o.long_watch = true;
+            if (initial) {
+                initial = false;
+                cb();
+            }
+            return;
+        }
+
+        self._tryWatching(f, function _tryWatching_done(err) {
+            if (err) {
+                o.tries++;
+                o.timeout = setTimeout(tryWatching, self.initial_watch_delay);
+                self.log.trace('%d/%d %s watch failed',
+                    o.tries, self.initial_watch_tries, f);
+                if (initial) {
+                    initial = false;
+                    cb();
+                }
+                return;
+            }
+
+            // watch succeeded!
+            self.watching[f] = {
+                active: true
+            };
+            delete self.not_yet_watching[f];
+
+            var obj = {
+                type: 'create',
+                time: process.hrtime(),
+                pathname: f
+            };
+
+            if (!initial) {
+                self.emit('create', obj);
+                self.emit('event', obj);
+            }
+
+            self.log.trace('%d/%d %s watch succeeded',
+                o.tries, self.initial_watch_tries, f);
+
+            if (initial) {
+                initial = false;
+                cb();
+            }
+        });
+    }
+};
+
+/*
+ * stop watching a file
+ */
+FsWatcher.prototype.unwatch = function unwatch(f, cb) {
+    var self = this;
+    cb = cb || noop;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(f, 'filename unspecified');
+    assert.func(cb, 'cb');
+
+    // validate filename
+    var e = self._validFilename(f);
+    if (e) {
+        cb(e);
+        return;
+    }
+
+    if (self.watching[f]) {
+        if (self.watching[f].active) {
+            self.watching[f].active = false;
+            var cmd = util.format('UNWATCH %s', f);
+            self._sendCommand(cmd, function _sendCommandDone(err, obj) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                delete self.watching[f];
+                cb();
+            });
+        } else {
+            delete self.watching[f];
+            cb();
+        }
+    } else if (self.not_yet_watching[f]) {
+        if (self.not_yet_watching[f].timeout) {
+            clearTimeout(self.not_yet_watching[f].timeout);
+            self.not_yet_watching[f].timeout = null;
+        }
+        delete self.not_yet_watching[f];
+        cb();
+    } else {
+        throw new Error('not watching ' + f);
+    }
+};
+
+/*
+ * Get child process status
+ */
+FsWatcher.prototype.status = function status(cb) {
+    var self = this;
+
+    assert(self.isRunning(), 'not running');
+    assert.func(cb, 'cb');
+
+    self._sendCommand('STATUS', cb);
+};
+
+/*
+ * send stdin to the watcher program and callback when stdout
+ * is receieved.  the `cmd` arg should look something like this:
+ *
+ *   'WATCH /path/to/file|12345'
+ *   'UNWATCH /other/path'
+ *
+ * A key will be prepended to track the request as well as a trailing newline
+ * character.
+ */
+FsWatcher.prototype._sendCommand = function _sendCommand(cmd, cb) {
+    var self = this;
+
+    var key;
+
+    assert(self.isRunning(), 'not running');
+    assert.string(cmd, 'cmd');
+    assert.func(cb, 'cb');
+
+    // ensure no newline is present
+    assert(cmd.indexOf('\n') === -1, util.format('invalid command: "%s"',
+        cmd));
+
+    // generate a unique key for the request, this will let us know
+    // which response is meant for us
+    key = self._nextRequestKey();
+
+    assert(!self.pending_actions[key], 'key already used: ' + key);
+
+    cmd = util.format('%d %s\n', key, cmd);
+
+    // when the response for this key is received, the callback will be called
+    self.pending_actions[key] = {
+        started: process.hrtime(),
+        cmd: cmd,
+        cb: cb
+    };
+
+    // write the command to the watcher
+    self.log.trace({cmd: cmd.trim()}, 'writing to fswatcher stdin');
+    try {
+        self.watcher.stdin.write(cmd);
+    } catch (err) {
+        self.log.error({err: err}, 'failed to write to stdin');
+        delete self.pending_actions[key];
+        cb(err);
+        return;
+    }
+};
+
+/*
+ * generate the next index to use for a request
+ */
+FsWatcher.prototype._nextRequestKey = function _nextRequestKey() {
+    var self = this;
+
+    self.cur_request_key = (self.cur_request_key + 1) % FSWATCHER_MAX_KEY;
+
+    return self.cur_request_key;
+};
+
+
+/*
+ * check if we are, or were instructed to, watch a file
+ */
+FsWatcher.prototype._isWatching = function _isWatching(f) {
+    var self = this;
+
+    assert.object(self.watching, 'self.watching');
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    return jsprim.hasKey(self.watching, f)
+        || jsprim.hasKey(self.not_yet_watching, f);
+};
+
+/*
+ * validate a filename string
+ *
+ * returns null on success or an Error object on failure
+ */
+FsWatcher.prototype._validFilename = function _validFilename(f) {
+    try {
+        ILLEGAL_FILENAME_CHARS.forEach(function checkFilename(c) {
+            assert.equal(f.indexOf(c), -1, 'filename contains bad char ' + c);
+        });
+    } catch (e) {
+        return e;
+    }
+    return null;
+};
+
+/*
+ * try to watch all unwatched files - this will be called at an interval
+ * specified in the constructor options or at a default of every 10 seconds
+ */
+FsWatcher.prototype._watchUnwatchedFiles =
+    function _watchUnwatchedFiles(cb) {
+
+    var self = this;
+
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    var started_watching = 0;
+    var still_waiting = 0;
+    var then = process.hrtime();
+    var not_yet_watching_keys = Object.keys(self.not_yet_watching);
+
+    vasync.forEachParallel({
+        inputs: not_yet_watching_keys,
+        func: function watchUnwatchedFile(f, cb2) {
+            var o = self.not_yet_watching[f];
+
+            // this interval only looks for files that are in the "long_watch"
+            // bucket
+            if (!o || !o.long_watch) {
+                cb2();
+                return;
+            }
+
+            self._tryWatching(f, function _tryWatchingDone(err) {
+                if (err) {
+                    // watch failed, still waiting for this file to exist
+                    still_waiting++;
+                    cb2();
+                    return;
+                }
+
+                // watch succeeded! we can now emit a 'create' event
+                // and stop waiting on this file to exist
+                self.watching[f] = {
+                    active: true
+                };
+                delete self.not_yet_watching[f];
+                started_watching++;
+
+                var obj = {
+                    type: 'create',
+                    time: process.hrtime(),
+                    pathname: f
+                };
+
+                self.emit('create', obj);
+                self.emit('event', obj);
+
+                cb2();
+            });
+        }
+    }, function _watchUnwatchedFilesDone(err) {
+        var now = process.hrtime();
+        var delta = hrtime.hrtimeDelta(now, then);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+        if (started_watching > 0 || still_waiting > 0) {
+            self.log.debug('FsWatcher _watchUnwatchedFiles: '
+                + 'looped files: %d, started watching: %d, '
+                + 'still waiting: %d, took: %s',
+                not_yet_watching_keys.length,
+                started_watching,
+                still_waiting,
+                prettyDelta);
+        }
+
+        cb();
+    });
+};
+
+/*
+ * send a command to watch the filename given, and callback when the response
+ * is seen.  an error is set if the file fails to watch, and no error on
+ * success
+ */
+FsWatcher.prototype._tryWatching = function _tryWatching(f, cb) {
+    var self = this;
+
+    var cmd = util.format('WATCH %s', f);
+
+    self._sendCommand(cmd, function _sendCommandDone(err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        switch (obj.result) {
+        case 'SUCCESS':
+            cb(null, obj);
+            break;
+        case 'FAIL':
+            cb(new Error(obj.message), obj);
+            break;
+        default:
+            throw new Error('unknown result: ' + obj.result);
+        }
+    });
+};
+
+/*
+ * Returns true if the child process is currently running and a stop() has not
+ * been issued
+ */
+FsWatcher.prototype.isRunning = function isRunning() {
+    var self = this;
+
+    return self.watcher && !self.stopping;
+};
+
+/*
+ * Return the current state as an object
+ */
+FsWatcher.prototype.dump = function dump() {
+    var self = this;
+
+    assert.object(self.watching, 'self.watching');
+    assert.object(self.not_yet_watching, 'self.not_yet_watching');
+
+    return {
+        message_delays: self.messageDelays(),
+        watching: Object.keys(self.watching),
+        not_yet_watching: Object.keys(self.not_yet_watching),
+        pending_actions: self.pending_actions,
+        watcher_pid: self.watcher_pid,
+        running: self.isRunning()
+    };
+};
+
+/*
+ * Calculate the averages for the message delay buffer
+ */
+FsWatcher.prototype.messageDelays = function messageDelays() {
+    var self = this;
+
+    assert.object(self.message_delay_buffer, 'self.message_delay_buffer');
+
+    var avg;
+    var i;
+    var o = {};
+    var records = self.message_delay_buffer.records.slice(0).reverse();
+    var sum;
+
+    /*
+     * Calculate delays using the last N messages where N is a number that
+     * increments 10x every iteration.  i.e. this will process the averages for
+     * the last 1, 10, 100, and 1000 messages averaged.
+     */
+    for (i = 1; i <= records.length; i *= 10) {
+        sum = records.slice(0, i).reduce(function sumRecords(a, b) {
+            return a + b;
+        }, 0);
+        avg = sum / i;
+        o[i] = avg;
+    }
+
+    return o;
+};
+
+module.exports.FsWatcher = FsWatcher;
+
+if (require.main === module) {
+    var _f = process.argv[2];
+    var fsw = new FsWatcher();
+    fsw.once('ready', function _ready(obj) {
+        fsw.watch(_f, function _watch() {
+            console.log('watching %s', _f);
+        });
+    });
+    fsw.on('event', function _event(ev) {
+        console.log('new event: %j', ev);
+    });
+    fsw.start();
+}
diff --git a/src/vm/node_modules/jsprim/LICENSE b/src/vm/node_modules/jsprim/LICENSE
new file mode 100644
index 00000000..cbc0bb3b
--- /dev/null
+++ b/src/vm/node_modules/jsprim/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2012, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/src/vm/node_modules/jsprim/lib/jsprim.js b/src/vm/node_modules/jsprim/lib/jsprim.js
new file mode 100644
index 00000000..4f5eea6f
--- /dev/null
+++ b/src/vm/node_modules/jsprim/lib/jsprim.js
@@ -0,0 +1,735 @@
+/*
+ * lib/jsprim.js: utilities for primitive JavaScript types
+ */
+
+var mod_assert = require('assert-plus');
+var mod_util = require('util');
+
+var mod_extsprintf = require('extsprintf');
+var mod_verror = require('verror');
+var mod_jsonschema = require('json-schema');
+
+/*
+ * Public interface
+ */
+exports.deepCopy = deepCopy;
+exports.deepEqual = deepEqual;
+exports.isEmpty = isEmpty;
+exports.hasKey = hasKey;
+exports.forEachKey = forEachKey;
+exports.pluck = pluck;
+exports.flattenObject = flattenObject;
+exports.flattenIter = flattenIter;
+exports.validateJsonObject = validateJsonObjectJS;
+exports.validateJsonObjectJS = validateJsonObjectJS;
+exports.randElt = randElt;
+exports.extraProperties = extraProperties;
+exports.mergeObjects = mergeObjects;
+
+exports.startsWith = startsWith;
+exports.endsWith = endsWith;
+
+exports.parseInteger = parseInteger;
+
+exports.iso8601 = iso8601;
+exports.rfc1123 = rfc1123;
+exports.parseDateTime = parseDateTime;
+
+exports.hrtimediff = hrtimeDiff;
+exports.hrtimeDiff = hrtimeDiff;
+exports.hrtimeAccum = hrtimeAccum;
+exports.hrtimeAdd = hrtimeAdd;
+exports.hrtimeNanosec = hrtimeNanosec;
+exports.hrtimeMicrosec = hrtimeMicrosec;
+exports.hrtimeMillisec = hrtimeMillisec;
+
+
+/*
+ * Deep copy an acyclic *basic* Javascript object.  This only handles basic
+ * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
+ * containing these.  This does *not* handle instances of other classes.
+ */
+function deepCopy(obj)
+{
+	var ret, key;
+	var marker = '__deepCopy';
+
+	if (obj && obj[marker])
+		throw (new Error('attempted deep copy of cyclic object'));
+
+	if (obj && obj.constructor == Object) {
+		ret = {};
+		obj[marker] = true;
+
+		for (key in obj) {
+			if (key == marker)
+				continue;
+
+			ret[key] = deepCopy(obj[key]);
+		}
+
+		delete (obj[marker]);
+		return (ret);
+	}
+
+	if (obj && obj.constructor == Array) {
+		ret = [];
+		obj[marker] = true;
+
+		for (key = 0; key < obj.length; key++)
+			ret.push(deepCopy(obj[key]));
+
+		delete (obj[marker]);
+		return (ret);
+	}
+
+	/*
+	 * It must be a primitive type -- just return it.
+	 */
+	return (obj);
+}
+
+function deepEqual(obj1, obj2)
+{
+	if (typeof (obj1) != typeof (obj2))
+		return (false);
+
+	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
+		return (obj1 === obj2);
+
+	if (obj1.constructor != obj2.constructor)
+		return (false);
+
+	var k;
+	for (k in obj1) {
+		if (!(k in obj2))
+			return (false);
+
+		if (!deepEqual(obj1[k], obj2[k]))
+			return (false);
+	}
+
+	for (k in obj2) {
+		if (!(k in obj1))
+			return (false);
+	}
+
+	return (true);
+}
+
+function isEmpty(obj)
+{
+	var key;
+	for (key in obj)
+		return (false);
+	return (true);
+}
+
+function hasKey(obj, key)
+{
+	mod_assert.equal(typeof (key), 'string');
+	return (Object.prototype.hasOwnProperty.call(obj, key));
+}
+
+function forEachKey(obj, callback)
+{
+	for (var key in obj) {
+		if (hasKey(obj, key)) {
+			callback(key, obj[key]);
+		}
+	}
+}
+
+function pluck(obj, key)
+{
+	mod_assert.equal(typeof (key), 'string');
+	return (pluckv(obj, key));
+}
+
+function pluckv(obj, key)
+{
+	if (obj === null || typeof (obj) !== 'object')
+		return (undefined);
+
+	if (obj.hasOwnProperty(key))
+		return (obj[key]);
+
+	var i = key.indexOf('.');
+	if (i == -1)
+		return (undefined);
+
+	var key1 = key.substr(0, i);
+	if (!obj.hasOwnProperty(key1))
+		return (undefined);
+
+	return (pluckv(obj[key1], key.substr(i + 1)));
+}
+
+/*
+ * Invoke callback(row) for each entry in the array that would be returned by
+ * flattenObject(data, depth).  This is just like flattenObject(data,
+ * depth).forEach(callback), except that the intermediate array is never
+ * created.
+ */
+function flattenIter(data, depth, callback)
+{
+	doFlattenIter(data, depth, [], callback);
+}
+
+function doFlattenIter(data, depth, accum, callback)
+{
+	var each;
+	var key;
+
+	if (depth === 0) {
+		each = accum.slice(0);
+		each.push(data);
+		callback(each);
+		return;
+	}
+
+	mod_assert.ok(data !== null);
+	mod_assert.equal(typeof (data), 'object');
+	mod_assert.equal(typeof (depth), 'number');
+	mod_assert.ok(depth >= 0);
+
+	for (key in data) {
+		each = accum.slice(0);
+		each.push(key);
+		doFlattenIter(data[key], depth - 1, each, callback);
+	}
+}
+
+function flattenObject(data, depth)
+{
+	if (depth === 0)
+		return ([ data ]);
+
+	mod_assert.ok(data !== null);
+	mod_assert.equal(typeof (data), 'object');
+	mod_assert.equal(typeof (depth), 'number');
+	mod_assert.ok(depth >= 0);
+
+	var rv = [];
+	var key;
+
+	for (key in data) {
+		flattenObject(data[key], depth - 1).forEach(function (p) {
+			rv.push([ key ].concat(p));
+		});
+	}
+
+	return (rv);
+}
+
+function startsWith(str, prefix)
+{
+	return (str.substr(0, prefix.length) == prefix);
+}
+
+function endsWith(str, suffix)
+{
+	return (str.substr(
+	    str.length - suffix.length, suffix.length) == suffix);
+}
+
+function iso8601(d)
+{
+	if (typeof (d) == 'number')
+		d = new Date(d);
+	mod_assert.ok(d.constructor === Date);
+	return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
+	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
+	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
+	    d.getUTCMilliseconds()));
+}
+
+var RFC1123_MONTHS = [
+    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
+    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
+var RFC1123_DAYS = [
+    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
+
+function rfc1123(date) {
+	return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
+	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
+	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
+	    date.getUTCHours(), date.getUTCMinutes(),
+	    date.getUTCSeconds()));
+}
+
+/*
+ * Parses a date expressed as a string, as either a number of milliseconds since
+ * the epoch or any string format that Date accepts, giving preference to the
+ * former where these two sets overlap (e.g., small numbers).
+ */
+function parseDateTime(str)
+{
+	/*
+	 * This is irritatingly implicit, but significantly more concise than
+	 * alternatives.  The "+str" will convert a string containing only a
+	 * number directly to a Number, or NaN for other strings.  Thus, if the
+	 * conversion succeeds, we use it (this is the milliseconds-since-epoch
+	 * case).  Otherwise, we pass the string directly to the Date
+	 * constructor to parse.
+	 */
+	var numeric = +str;
+	if (!isNaN(numeric)) {
+		return (new Date(numeric));
+	} else {
+		return (new Date(str));
+	}
+}
+
+
+/*
+ * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
+ * the ES6 definitions here, while allowing for them to someday be higher.
+ */
+var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
+var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
+
+
+/*
+ * Default options for parseInteger().
+ */
+var PI_DEFAULTS = {
+	base: 10,
+	allowSign: true,
+	allowPrefix: false,
+	allowTrailing: false,
+	allowImprecise: false,
+	trimWhitespace: false,
+	leadingZeroIsOctal: false
+};
+
+var CP_0 = 0x30;
+var CP_9 = 0x39;
+
+var CP_A = 0x41;
+var CP_B = 0x42;
+var CP_O = 0x4f;
+var CP_T = 0x54;
+var CP_X = 0x58;
+var CP_Z = 0x5a;
+
+var CP_a = 0x61;
+var CP_b = 0x62;
+var CP_o = 0x6f;
+var CP_t = 0x74;
+var CP_x = 0x78;
+var CP_z = 0x7a;
+
+var PI_CONV_DEC = 0x30;
+var PI_CONV_UC = 0x37;
+var PI_CONV_LC = 0x57;
+
+
+/*
+ * A stricter version of parseInt() that provides options for changing what
+ * is an acceptable string (for example, disallowing trailing characters).
+ */
+function parseInteger(str, uopts)
+{
+	mod_assert.string(str, 'str');
+	mod_assert.optionalObject(uopts, 'options');
+
+	var baseOverride = false;
+	var options = PI_DEFAULTS;
+
+	if (uopts) {
+		baseOverride = hasKey(uopts, 'base');
+		options = mergeObjects(options, uopts);
+		mod_assert.number(options.base, 'options.base');
+		mod_assert.ok(options.base >= 2, 'options.base >= 2');
+		mod_assert.ok(options.base <= 36, 'options.base <= 36');
+		mod_assert.bool(options.allowSign, 'options.allowSign');
+		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
+		mod_assert.bool(options.allowTrailing,
+		    'options.allowTrailing');
+		mod_assert.bool(options.allowImprecise,
+		    'options.allowImprecise');
+		mod_assert.bool(options.trimWhitespace,
+		    'options.trimWhitespace');
+		mod_assert.bool(options.leadingZeroIsOctal,
+		    'options.leadingZeroIsOctal');
+
+		if (options.leadingZeroIsOctal) {
+			mod_assert.ok(!baseOverride,
+			    '"base" and "leadingZeroIsOctal" are ' +
+			    'mutually exclusive');
+		}
+	}
+
+	var c;
+	var pbase = -1;
+	var base = options.base;
+	var start;
+	var mult = 1;
+	var value = 0;
+	var idx = 0;
+	var len = str.length;
+
+	/* Trim any whitespace on the left side. */
+	if (options.trimWhitespace) {
+		while (idx < len && isSpace(str.charCodeAt(idx))) {
+			++idx;
+		}
+	}
+
+	/* Check the number for a leading sign. */
+	if (options.allowSign) {
+		if (str[idx] === '-') {
+			idx += 1;
+			mult = -1;
+		} else if (str[idx] === '+') {
+			idx += 1;
+		}
+	}
+
+	/* Parse the base-indicating prefix if there is one. */
+	if (str[idx] === '0') {
+		if (options.allowPrefix) {
+			pbase = prefixToBase(str.charCodeAt(idx + 1));
+			if (pbase !== -1 && (!baseOverride || pbase === base)) {
+				base = pbase;
+				idx += 2;
+			}
+		}
+
+		if (pbase === -1 && options.leadingZeroIsOctal) {
+			base = 8;
+		}
+	}
+
+	/* Parse the actual digits. */
+	for (start = idx; idx < len; ++idx) {
+		c = translateDigit(str.charCodeAt(idx));
+		if (c !== -1 && c < base) {
+			value *= base;
+			value += c;
+		} else {
+			break;
+		}
+	}
+
+	/* If we didn't parse any digits, we have an invalid number. */
+	if (start === idx) {
+		return (new Error('invalid number: ' + JSON.stringify(str)));
+	}
+
+	/* Trim any whitespace on the right side. */
+	if (options.trimWhitespace) {
+		while (idx < len && isSpace(str.charCodeAt(idx))) {
+			++idx;
+		}
+	}
+
+	/* Check for trailing characters. */
+	if (idx < len && !options.allowTrailing) {
+		return (new Error('trailing characters after number: ' +
+		    JSON.stringify(str.slice(idx))));
+	}
+
+	/* If our value is 0, we return now, to avoid returning -0. */
+	if (value === 0) {
+		return (0);
+	}
+
+	/* Calculate our final value. */
+	var result = value * mult;
+
+	/*
+	 * If the string represents a value that cannot be precisely represented
+	 * by JavaScript, then we want to check that:
+	 *
+	 * - We never increased the value past MAX_SAFE_INTEGER
+	 * - We don't make the result negative and below MIN_SAFE_INTEGER
+	 *
+	 * Because we only ever increment the value during parsing, there's no
+	 * chance of moving past MAX_SAFE_INTEGER and then dropping below it
+	 * again, losing precision in the process. This means that we only need
+	 * to do our checks here, at the end.
+	 */
+	if (!options.allowImprecise &&
+	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
+		return (new Error('number is outside of the supported range: ' +
+		    JSON.stringify(str.slice(start, idx))));
+	}
+
+	return (result);
+}
+
+
+/*
+ * Interpret a character code as a base-36 digit.
+ */
+function translateDigit(d)
+{
+	if (d >= CP_0 && d <= CP_9) {
+		/* '0' to '9' -> 0 to 9 */
+		return (d - PI_CONV_DEC);
+	} else if (d >= CP_A && d <= CP_Z) {
+		/* 'A' - 'Z' -> 10 to 35 */
+		return (d - PI_CONV_UC);
+	} else if (d >= CP_a && d <= CP_z) {
+		/* 'a' - 'z' -> 10 to 35 */
+		return (d - PI_CONV_LC);
+	} else {
+		/* Invalid character code */
+		return (-1);
+	}
+}
+
+
+/*
+ * Test if a value matches the ECMAScript definition of trimmable whitespace.
+ */
+function isSpace(c)
+{
+	return (c === 0x20) ||
+	    (c >= 0x0009 && c <= 0x000d) ||
+	    (c === 0x00a0) ||
+	    (c === 0x1680) ||
+	    (c === 0x180e) ||
+	    (c >= 0x2000 && c <= 0x200a) ||
+	    (c === 0x2028) ||
+	    (c === 0x2029) ||
+	    (c === 0x202f) ||
+	    (c === 0x205f) ||
+	    (c === 0x3000) ||
+	    (c === 0xfeff);
+}
+
+
+/*
+ * Determine which base a character indicates (e.g., 'x' indicates hex).
+ */
+function prefixToBase(c)
+{
+	if (c === CP_b || c === CP_B) {
+		/* 0b/0B (binary) */
+		return (2);
+	} else if (c === CP_o || c === CP_O) {
+		/* 0o/0O (octal) */
+		return (8);
+	} else if (c === CP_t || c === CP_T) {
+		/* 0t/0T (decimal) */
+		return (10);
+	} else if (c === CP_x || c === CP_X) {
+		/* 0x/0X (hexadecimal) */
+		return (16);
+	} else {
+		/* Not a meaningful character */
+		return (-1);
+	}
+}
+
+
+function validateJsonObjectJS(schema, input)
+{
+	var report = mod_jsonschema.validate(input, schema);
+
+	if (report.errors.length === 0)
+		return (null);
+
+	/* Currently, we only do anything useful with the first error. */
+	var error = report.errors[0];
+
+	/* The failed property is given by a URI with an irrelevant prefix. */
+	var propname = error['property'];
+	var reason = error['message'].toLowerCase();
+	var i, j;
+
+	/*
+	 * There's at least one case where the property error message is
+	 * confusing at best.  We work around this here.
+	 */
+	if ((i = reason.indexOf('the property ')) != -1 &&
+	    (j = reason.indexOf(' is not defined in the schema and the ' +
+	    'schema does not allow additional properties')) != -1) {
+		i += 'the property '.length;
+		if (propname === '')
+			propname = reason.substr(i, j - i);
+		else
+			propname = propname + '.' + reason.substr(i, j - i);
+
+		reason = 'unsupported property';
+	}
+
+	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
+	rv.jsv_details = error;
+	return (rv);
+}
+
+function randElt(arr)
+{
+	mod_assert.ok(Array.isArray(arr) && arr.length > 0,
+	    'randElt argument must be a non-empty array');
+
+	return (arr[Math.floor(Math.random() * arr.length)]);
+}
+
+function assertHrtime(a)
+{
+	mod_assert.ok(a[0] >= 0 && a[1] >= 0,
+	    'negative numbers not allowed in hrtimes');
+	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
+}
+
+/*
+ * Compute the time elapsed between hrtime readings A and B, where A is later
+ * than B.  hrtime readings come from Node's process.hrtime().  There is no
+ * defined way to represent negative deltas, so it's illegal to diff B from A
+ * where the time denoted by B is later than the time denoted by A.  If this
+ * becomes valuable, we can define a representation and extend the
+ * implementation to support it.
+ */
+function hrtimeDiff(a, b)
+{
+	assertHrtime(a);
+	assertHrtime(b);
+	mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
+	    'negative differences not allowed');
+
+	var rv = [ a[0] - b[0], 0 ];
+
+	if (a[1] >= b[1]) {
+		rv[1] = a[1] - b[1];
+	} else {
+		rv[0]--;
+		rv[1] = 1e9 - (b[1] - a[1]);
+	}
+
+	return (rv);
+}
+
+/*
+ * Convert a hrtime reading from the array format returned by Node's
+ * process.hrtime() into a scalar number of nanoseconds.
+ */
+function hrtimeNanosec(a)
+{
+	assertHrtime(a);
+
+	return (Math.floor(a[0] * 1e9 + a[1]));
+}
+
+/*
+ * Convert a hrtime reading from the array format returned by Node's
+ * process.hrtime() into a scalar number of microseconds.
+ */
+function hrtimeMicrosec(a)
+{
+	assertHrtime(a);
+
+	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
+}
+
+/*
+ * Convert a hrtime reading from the array format returned by Node's
+ * process.hrtime() into a scalar number of milliseconds.
+ */
+function hrtimeMillisec(a)
+{
+	assertHrtime(a);
+
+	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
+}
+
+/*
+ * Add two hrtime readings A and B, overwriting A with the result of the
+ * addition.  This function is useful for accumulating several hrtime intervals
+ * into a counter.  Returns A.
+ */
+function hrtimeAccum(a, b)
+{
+	assertHrtime(a);
+	assertHrtime(b);
+
+	/*
+	 * Accumulate the nanosecond component.
+	 */
+	a[1] += b[1];
+	if (a[1] >= 1e9) {
+		/*
+		 * The nanosecond component overflowed, so carry to the seconds
+		 * field.
+		 */
+		a[0]++;
+		a[1] -= 1e9;
+	}
+
+	/*
+	 * Accumulate the seconds component.
+	 */
+	a[0] += b[0];
+
+	return (a);
+}
+
+/*
+ * Add two hrtime readings A and B, returning the result as a new hrtime array.
+ * Does not modify either input argument.
+ */
+function hrtimeAdd(a, b)
+{
+	assertHrtime(a);
+
+	var rv = [ a[0], a[1] ];
+
+	return (hrtimeAccum(rv, b));
+}
+
+
+/*
+ * Check an object for unexpected properties.  Accepts the object to check, and
+ * an array of allowed property names (strings).  Returns an array of key names
+ * that were found on the object, but did not appear in the list of allowed
+ * properties.  If no properties were found, the returned array will be of
+ * zero length.
+ */
+function extraProperties(obj, allowed)
+{
+	mod_assert.ok(typeof (obj) === 'object' && obj !== null,
+	    'obj argument must be a non-null object');
+	mod_assert.ok(Array.isArray(allowed),
+	    'allowed argument must be an array of strings');
+	for (var i = 0; i < allowed.length; i++) {
+		mod_assert.ok(typeof (allowed[i]) === 'string',
+		    'allowed argument must be an array of strings');
+	}
+
+	return (Object.keys(obj).filter(function (key) {
+		return (allowed.indexOf(key) === -1);
+	}));
+}
+
+/*
+ * Given three sets of properties "provided" (may be undefined), "overrides"
+ * (required), and "defaults" (may be undefined), construct an object containing
+ * the union of these sets with "overrides" overriding "provided", and
+ * "provided" overriding "defaults".  None of the input objects are modified.
+ */
+function mergeObjects(provided, overrides, defaults)
+{
+	var rv, k;
+
+	rv = {};
+	if (defaults) {
+		for (k in defaults)
+			rv[k] = defaults[k];
+	}
+
+	if (provided) {
+		for (k in provided)
+			rv[k] = provided[k];
+	}
+
+	if (overrides) {
+		for (k in overrides)
+			rv[k] = overrides[k];
+	}
+
+	return (rv);
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/assert-plus/assert.js b/src/vm/node_modules/jsprim/node_modules/assert-plus/assert.js
new file mode 100644
index 00000000..26f944ee
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/assert-plus/assert.js
@@ -0,0 +1,211 @@
+// Copyright (c) 2012, Mark Cavage. All rights reserved.
+// Copyright 2015 Joyent, Inc.
+
+var assert = require('assert');
+var Stream = require('stream').Stream;
+var util = require('util');
+
+
+///--- Globals
+
+/* JSSTYLED */
+var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
+
+
+///--- Internal
+
+function _capitalize(str) {
+    return (str.charAt(0).toUpperCase() + str.slice(1));
+}
+
+function _toss(name, expected, oper, arg, actual) {
+    throw new assert.AssertionError({
+        message: util.format('%s (%s) is required', name, expected),
+        actual: (actual === undefined) ? typeof (arg) : actual(arg),
+        expected: expected,
+        operator: oper || '===',
+        stackStartFunction: _toss.caller
+    });
+}
+
+function _getClass(arg) {
+    return (Object.prototype.toString.call(arg).slice(8, -1));
+}
+
+function noop() {
+    // Why even bother with asserts?
+}
+
+
+///--- Exports
+
+var types = {
+    bool: {
+        check: function (arg) { return typeof (arg) === 'boolean'; }
+    },
+    func: {
+        check: function (arg) { return typeof (arg) === 'function'; }
+    },
+    string: {
+        check: function (arg) { return typeof (arg) === 'string'; }
+    },
+    object: {
+        check: function (arg) {
+            return typeof (arg) === 'object' && arg !== null;
+        }
+    },
+    number: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg);
+        }
+    },
+    finite: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
+        }
+    },
+    buffer: {
+        check: function (arg) { return Buffer.isBuffer(arg); },
+        operator: 'Buffer.isBuffer'
+    },
+    array: {
+        check: function (arg) { return Array.isArray(arg); },
+        operator: 'Array.isArray'
+    },
+    stream: {
+        check: function (arg) { return arg instanceof Stream; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    date: {
+        check: function (arg) { return arg instanceof Date; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    regexp: {
+        check: function (arg) { return arg instanceof RegExp; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    uuid: {
+        check: function (arg) {
+            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
+        },
+        operator: 'isUUID'
+    }
+};
+
+function _setExports(ndebug) {
+    var keys = Object.keys(types);
+    var out;
+
+    /* re-export standard assert */
+    if (process.env.NODE_NDEBUG) {
+        out = noop;
+    } else {
+        out = function (arg, msg) {
+            if (!arg) {
+                _toss(msg, 'true', arg);
+            }
+        };
+    }
+
+    /* standard checks */
+    keys.forEach(function (k) {
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        var type = types[k];
+        out[k] = function (arg, msg) {
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* optional checks */
+    keys.forEach(function (k) {
+        var name = 'optional' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* arrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'arrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* optionalArrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'optionalArrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* re-export built-in assertions */
+    Object.keys(assert).forEach(function (k) {
+        if (k === 'AssertionError') {
+            out[k] = assert[k];
+            return;
+        }
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        out[k] = assert[k];
+    });
+
+    /* export ourselves (for unit tests _only_) */
+    out._setExports = _setExports;
+
+    return out;
+}
+
+module.exports = _setExports(process.env.NODE_NDEBUG);
diff --git a/src/vm/node_modules/jsprim/node_modules/assert-plus/package.json b/src/vm/node_modules/jsprim/node_modules/assert-plus/package.json
new file mode 100644
index 00000000..cd5da05c
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/assert-plus/package.json
@@ -0,0 +1,82 @@
+{
+  "author": {
+    "name": "Mark Cavage",
+    "email": "mcavage@gmail.com"
+  },
+  "name": "assert-plus",
+  "description": "Extra assertions on top of node's assert module",
+  "version": "1.0.0",
+  "license": "MIT",
+  "main": "./assert.js",
+  "devDependencies": {
+    "tape": "4.2.2",
+    "faucet": "0.0.1"
+  },
+  "optionalDependencies": {},
+  "scripts": {
+    "test": "tape tests/*.js | ./node_modules/.bin/faucet"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/mcavage/node-assert-plus.git"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "contributors": [
+    {
+      "name": "Dave Eddy",
+      "email": "dave@daveeddy.com"
+    },
+    {
+      "name": "Fred Kuo",
+      "email": "fred.kuo@joyent.com"
+    },
+    {
+      "name": "Lars-Magnus Skog",
+      "email": "ralphtheninja@riseup.net"
+    },
+    {
+      "name": "Mark Cavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "Patrick Mooney",
+      "email": "pmooney@pfmooney.com"
+    },
+    {
+      "name": "Rob Gulewich",
+      "email": "robert.gulewich@joyent.com"
+    }
+  ],
+  "bugs": {
+    "url": "https://github.com/mcavage/node-assert-plus/issues"
+  },
+  "homepage": "https://github.com/mcavage/node-assert-plus#readme",
+  "dependencies": {},
+  "_id": "assert-plus@1.0.0",
+  "_shasum": "f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525",
+  "_resolved": "http://10.0.1.33:8354/assert-plus/-/assert-plus-1.0.0.tgz",
+  "_from": "assert-plus@1.0.0",
+  "_npmVersion": "3.3.9",
+  "_nodeVersion": "0.10.40",
+  "_npmUser": {
+    "name": "pfmooney",
+    "email": "patrick.f.mooney@gmail.com"
+  },
+  "maintainers": [
+    {
+      "name": "mcavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "pfmooney",
+      "email": "patrick.f.mooney@gmail.com"
+    }
+  ],
+  "dist": {
+    "shasum": "f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525",
+    "tarball": "http://10.0.1.33:8354/assert-plus/-/assert-plus-1.0.0.tgz"
+  },
+  "directories": {}
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/extsprintf/LICENSE b/src/vm/node_modules/jsprim/node_modules/extsprintf/LICENSE
new file mode 100644
index 00000000..cbc0bb3b
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/extsprintf/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2012, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/src/vm/node_modules/jsprim/node_modules/extsprintf/lib/extsprintf.js b/src/vm/node_modules/jsprim/node_modules/extsprintf/lib/extsprintf.js
new file mode 100644
index 00000000..ed883d32
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/extsprintf/lib/extsprintf.js
@@ -0,0 +1,183 @@
+/*
+ * extsprintf.js: extended POSIX-style sprintf
+ */
+
+var mod_assert = require('assert');
+var mod_util = require('util');
+
+/*
+ * Public interface
+ */
+exports.sprintf = jsSprintf;
+exports.printf = jsPrintf;
+exports.fprintf = jsFprintf;
+
+/*
+ * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
+ * exception when given a format string we don't understand, rather than
+ * ignoring it, so that we won't break existing programs if/when we go implement
+ * the rest of this.
+ *
+ * This implementation currently supports specifying
+ *	- field alignment ('-' flag),
+ * 	- zero-pad ('0' flag)
+ *	- always show numeric sign ('+' flag),
+ *	- field width
+ *	- conversions for strings, decimal integers, and floats (numbers).
+ *	- argument size specifiers.  These are all accepted but ignored, since
+ *	  Javascript has no notion of the physical size of an argument.
+ *
+ * Everything else is currently unsupported, most notably precision, unsigned
+ * numbers, non-decimal numbers, and characters.
+ */
+function jsSprintf(fmt)
+{
+	var regex = [
+	    '([^%]*)',				/* normal text */
+	    '%',				/* start of format */
+	    '([\'\\-+ #0]*?)',			/* flags (optional) */
+	    '([1-9]\\d*)?',			/* width (optional) */
+	    '(\\.([1-9]\\d*))?',		/* precision (optional) */
+	    '[lhjztL]*?',			/* length mods (ignored) */
+	    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
+	].join('');
+
+	var re = new RegExp(regex);
+	var args = Array.prototype.slice.call(arguments, 1);
+	var flags, width, precision, conversion;
+	var left, pad, sign, arg, match;
+	var ret = '';
+	var argn = 1;
+
+	mod_assert.equal('string', typeof (fmt));
+
+	while ((match = re.exec(fmt)) !== null) {
+		ret += match[1];
+		fmt = fmt.substring(match[0].length);
+
+		flags = match[2] || '';
+		width = match[3] || 0;
+		precision = match[4] || '';
+		conversion = match[6];
+		left = false;
+		sign = false;
+		pad = ' ';
+
+		if (conversion == '%') {
+			ret += '%';
+			continue;
+		}
+
+		if (args.length === 0)
+			throw (new Error('too few args to sprintf'));
+
+		arg = args.shift();
+		argn++;
+
+		if (flags.match(/[\' #]/))
+			throw (new Error(
+			    'unsupported flags: ' + flags));
+
+		if (precision.length > 0)
+			throw (new Error(
+			    'non-zero precision not supported'));
+
+		if (flags.match(/-/))
+			left = true;
+
+		if (flags.match(/0/))
+			pad = '0';
+
+		if (flags.match(/\+/))
+			sign = true;
+
+		switch (conversion) {
+		case 's':
+			if (arg === undefined || arg === null)
+				throw (new Error('argument ' + argn +
+				    ': attempted to print undefined or null ' +
+				    'as a string'));
+			ret += doPad(pad, width, left, arg.toString());
+			break;
+
+		case 'd':
+			arg = Math.floor(arg);
+			/*jsl:fallthru*/
+		case 'f':
+			sign = sign && arg > 0 ? '+' : '';
+			ret += sign + doPad(pad, width, left,
+			    arg.toString());
+			break;
+
+		case 'x':
+			ret += doPad(pad, width, left, arg.toString(16));
+			break;
+
+		case 'j': /* non-standard */
+			if (width === 0)
+				width = 10;
+			ret += mod_util.inspect(arg, false, width);
+			break;
+
+		case 'r': /* non-standard */
+			ret += dumpException(arg);
+			break;
+
+		default:
+			throw (new Error('unsupported conversion: ' +
+			    conversion));
+		}
+	}
+
+	ret += fmt;
+	return (ret);
+}
+
+function jsPrintf() {
+	var args = Array.prototype.slice.call(arguments);
+	args.unshift(process.stdout);
+	jsFprintf.apply(null, args);
+}
+
+function jsFprintf(stream) {
+	var args = Array.prototype.slice.call(arguments, 1);
+	return (stream.write(jsSprintf.apply(this, args)));
+}
+
+function doPad(chr, width, left, str)
+{
+	var ret = str;
+
+	while (ret.length < width) {
+		if (left)
+			ret += chr;
+		else
+			ret = chr + ret;
+	}
+
+	return (ret);
+}
+
+/*
+ * This function dumps long stack traces for exceptions having a cause() method.
+ * See node-verror for an example.
+ */
+function dumpException(ex)
+{
+	var ret;
+
+	if (!(ex instanceof Error))
+		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
+
+	/* Note that V8 prepends "ex.stack" with ex.toString(). */
+	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
+
+	if (ex.cause && typeof (ex.cause) === 'function') {
+		var cex = ex.cause();
+		if (cex) {
+			ret += '\nCaused by: ' + dumpException(cex);
+		}
+	}
+
+	return (ret);
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/extsprintf/package.json b/src/vm/node_modules/jsprim/node_modules/extsprintf/package.json
new file mode 100644
index 00000000..e393f3a1
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/extsprintf/package.json
@@ -0,0 +1,41 @@
+{
+  "name": "extsprintf",
+  "version": "1.3.0",
+  "description": "extended POSIX-style sprintf",
+  "main": "./lib/extsprintf.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/davepacheco/node-extsprintf.git"
+  },
+  "engines": [
+    "node >=0.6.0"
+  ],
+  "license": "MIT",
+  "gitHead": "accc9f2774189a416f294546ed03b626eec3f80c",
+  "bugs": {
+    "url": "https://github.com/davepacheco/node-extsprintf/issues"
+  },
+  "homepage": "https://github.com/davepacheco/node-extsprintf",
+  "_id": "extsprintf@1.3.0",
+  "scripts": {},
+  "_shasum": "96918440e3041a7a414f8c52e3c574eb3c3e1e05",
+  "_from": "extsprintf@1.3.0",
+  "_npmVersion": "2.5.1",
+  "_nodeVersion": "0.12.0",
+  "_npmUser": {
+    "name": "dap",
+    "email": "dap@cs.brown.edu"
+  },
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "dist": {
+    "shasum": "96918440e3041a7a414f8c52e3c574eb3c3e1e05",
+    "tarball": "http://10.0.1.33:8354/extsprintf/-/extsprintf-1.3.0.tgz"
+  },
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/extsprintf/-/extsprintf-1.3.0.tgz"
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/json-schema/README.md b/src/vm/node_modules/jsprim/node_modules/json-schema/README.md
new file mode 100644
index 00000000..ccc591b6
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/json-schema/README.md
@@ -0,0 +1,5 @@
+JSON Schema is a repository for the JSON Schema specification, reference schemas and a CommonJS implementation of JSON Schema (not the only JavaScript implementation of JSON Schema, JSV is another excellent JavaScript validator).
+
+Code is licensed under the AFL or BSD license as part of the Persevere 
+project which is administered under the Dojo foundation,
+and all contributions require a Dojo CLA.
\ No newline at end of file
diff --git a/src/vm/node_modules/jsprim/node_modules/json-schema/lib/links.js b/src/vm/node_modules/jsprim/node_modules/json-schema/lib/links.js
new file mode 100644
index 00000000..8a87f02d
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/json-schema/lib/links.js
@@ -0,0 +1,66 @@
+/** 
+ * JSON Schema link handler
+ * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
+ * Licensed under the MIT (MIT-LICENSE.txt) license.
+ */
+(function (root, factory) {
+    if (typeof define === 'function' && define.amd) {
+        // AMD. Register as an anonymous module.
+        define([], function () {
+            return factory();
+        });
+    } else if (typeof module === 'object' && module.exports) {
+        // Node. Does not work with strict CommonJS, but
+        // only CommonJS-like environments that support module.exports,
+        // like Node.
+        module.exports = factory();
+    } else {
+        // Browser globals
+        root.jsonSchemaLinks = factory();
+    }
+}(this, function () {// setup primitive classes to be JSON Schema types
+var exports = {};
+exports.cacheLinks = true;
+exports.getLink = function(relation, instance, schema){
+	// gets the URI of the link for the given relation based on the instance and schema
+	// for example:
+	// getLink(
+	// 		"brother", 
+	// 		{"brother_id":33}, 
+	// 		{links:[{rel:"brother", href:"Brother/{brother_id}"}]}) ->
+	//	"Brother/33"
+	var links = schema.__linkTemplates; 
+	if(!links){
+		links = {};
+		var schemaLinks = schema.links;
+		if(schemaLinks && schemaLinks instanceof Array){
+			schemaLinks.forEach(function(link){
+	/*			// TODO: allow for multiple same-name relations
+				if(links[link.rel]){
+					if(!(links[link.rel] instanceof Array)){
+						links[link.rel] = [links[link.rel]];
+					}
+				}*/
+				links[link.rel] = link.href;
+			});
+		}
+		if(exports.cacheLinks){
+			schema.__linkTemplates = links;
+		}
+	}
+	var linkTemplate = links[relation];
+	return linkTemplate && exports.substitute(linkTemplate, instance);
+};
+
+exports.substitute = function(linkTemplate, instance){
+	return linkTemplate.replace(/\{([^\}]*)\}/g, function(t, property){
+			var value = instance[decodeURIComponent(property)];
+			if(value instanceof Array){
+				// the value is an array, it should produce a URI like /Table/(4,5,8) and store.get() should handle that as an array of values
+				return '(' + value.join(',') + ')';
+			}
+			return value;
+		});
+};
+return exports;
+}));
\ No newline at end of file
diff --git a/src/vm/node_modules/jsprim/node_modules/json-schema/lib/validate.js b/src/vm/node_modules/jsprim/node_modules/json-schema/lib/validate.js
new file mode 100644
index 00000000..e4dc1511
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/json-schema/lib/validate.js
@@ -0,0 +1,273 @@
+/**
+ * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
+ *	(http://www.json.com/json-schema-proposal/)
+ *
+ * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
+ * Licensed under the MIT (MIT-LICENSE.txt) license.
+To use the validator call the validate function with an instance object and an optional schema object.
+If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
+that schema will be used to validate and the schema parameter is not necessary (if both exist,
+both validations will occur).
+The validate method will return an array of validation errors. If there are no errors, then an
+empty list will be returned. A validation error will have two properties:
+"property" which indicates which property had the error
+"message" which indicates what the error was
+ */
+(function (root, factory) {
+    if (typeof define === 'function' && define.amd) {
+        // AMD. Register as an anonymous module.
+        define([], function () {
+            return factory();
+        });
+    } else if (typeof module === 'object' && module.exports) {
+        // Node. Does not work with strict CommonJS, but
+        // only CommonJS-like environments that support module.exports,
+        // like Node.
+        module.exports = factory();
+    } else {
+        // Browser globals
+        root.jsonSchema = factory();
+    }
+}(this, function () {// setup primitive classes to be JSON Schema types
+var exports = validate
+exports.Integer = {type:"integer"};
+var primitiveConstructors = {
+	String: String,
+	Boolean: Boolean,
+	Number: Number,
+	Object: Object,
+	Array: Array,
+	Date: Date
+}
+exports.validate = validate;
+function validate(/*Any*/instance,/*Object*/schema) {
+		// Summary:
+		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
+		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
+		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
+		// 		both validations will occur).
+		// 		The validate method will return an object with two properties:
+		// 			valid: A boolean indicating if the instance is valid by the schema
+		// 			errors: An array of validation errors. If there are no errors, then an
+		// 					empty list will be returned. A validation error will have two properties:
+		// 						property: which indicates which property had the error
+		// 						message: which indicates what the error was
+		//
+		return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
+	};
+exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
+		// Summary:
+		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
+		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
+		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
+		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
+		// 		information.
+		//
+		return validate(value, schema, {changing: property || "property"});
+	};
+var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {
+
+	if (!options) options = {};
+	var _changing = options.changing;
+
+	function getType(schema){
+		return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
+	}
+	var errors = [];
+	// validate a value against a property definition
+	function checkProp(value, schema, path,i){
+
+		var l;
+		path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
+		function addError(message){
+			errors.push({property:path,message:message});
+		}
+
+		if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
+			if(typeof schema == 'function'){
+				if(!(value instanceof schema)){
+					addError("is not an instance of the class/constructor " + schema.name);
+				}
+			}else if(schema){
+				addError("Invalid schema/property definition " + schema);
+			}
+			return null;
+		}
+		if(_changing && schema.readonly){
+			addError("is a readonly field, it can not be changed");
+		}
+		if(schema['extends']){ // if it extends another schema, it must pass that schema as well
+			checkProp(value,schema['extends'],path,i);
+		}
+		// validate a value against a type definition
+		function checkType(type,value){
+			if(type){
+				if(typeof type == 'string' && type != 'any' &&
+						(type == 'null' ? value !== null : typeof value != type) &&
+						!(value instanceof Array && type == 'array') &&
+						!(value instanceof Date && type == 'date') &&
+						!(type == 'integer' && value%1===0)){
+					return [{property:path,message:(typeof value) + " value found, but a " + type + " is required"}];
+				}
+				if(type instanceof Array){
+					var unionErrors=[];
+					for(var j = 0; j < type.length; j++){ // a union type
+						if(!(unionErrors=checkType(type[j],value)).length){
+							break;
+						}
+					}
+					if(unionErrors.length){
+						return unionErrors;
+					}
+				}else if(typeof type == 'object'){
+					var priorErrors = errors;
+					errors = [];
+					checkProp(value,type,path);
+					var theseErrors = errors;
+					errors = priorErrors;
+					return theseErrors;
+				}
+			}
+			return [];
+		}
+		if(value === undefined){
+			if(schema.required){
+				addError("is missing and it is required");
+			}
+		}else{
+			errors = errors.concat(checkType(getType(schema),value));
+			if(schema.disallow && !checkType(schema.disallow,value).length){
+				addError(" disallowed value was matched");
+			}
+			if(value !== null){
+				if(value instanceof Array){
+					if(schema.items){
+						var itemsIsArray = schema.items instanceof Array;
+						var propDef = schema.items;
+						for (i = 0, l = value.length; i < l; i += 1) {
+							if (itemsIsArray)
+								propDef = schema.items[i];
+							if (options.coerce)
+								value[i] = options.coerce(value[i], propDef);
+							errors.concat(checkProp(value[i],propDef,path,i));
+						}
+					}
+					if(schema.minItems && value.length < schema.minItems){
+						addError("There must be a minimum of " + schema.minItems + " in the array");
+					}
+					if(schema.maxItems && value.length > schema.maxItems){
+						addError("There must be a maximum of " + schema.maxItems + " in the array");
+					}
+				}else if(schema.properties || schema.additionalProperties){
+					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
+				}
+				if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
+					addError("does not match the regex pattern " + schema.pattern);
+				}
+				if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
+					addError("may only be " + schema.maxLength + " characters long");
+				}
+				if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
+					addError("must be at least " + schema.minLength + " characters long");
+				}
+				if(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&
+						schema.minimum > value){
+					addError("must have a minimum value of " + schema.minimum);
+				}
+				if(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&
+						schema.maximum < value){
+					addError("must have a maximum value of " + schema.maximum);
+				}
+				if(schema['enum']){
+					var enumer = schema['enum'];
+					l = enumer.length;
+					var found;
+					for(var j = 0; j < l; j++){
+						if(enumer[j]===value){
+							found=1;
+							break;
+						}
+					}
+					if(!found){
+						addError("does not have a value in the enumeration " + enumer.join(", "));
+					}
+				}
+				if(typeof schema.maxDecimal == 'number' &&
+					(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
+					addError("may only have " + schema.maxDecimal + " digits of decimal places");
+				}
+			}
+		}
+		return null;
+	}
+	// validate an object against a schema
+	function checkObj(instance,objTypeDef,path,additionalProp){
+
+		if(typeof objTypeDef =='object'){
+			if(typeof instance != 'object' || instance instanceof Array){
+				errors.push({property:path,message:"an object is required"});
+			}
+			
+			for(var i in objTypeDef){ 
+				if(objTypeDef.hasOwnProperty(i)){
+					var value = instance[i];
+					// skip _not_ specified properties
+					if (value === undefined && options.existingOnly) continue;
+					var propDef = objTypeDef[i];
+					// set default
+					if(value === undefined && propDef["default"]){
+						value = instance[i] = propDef["default"];
+					}
+					if(options.coerce && i in instance){
+						value = instance[i] = options.coerce(value, propDef);
+					}
+					checkProp(value,propDef,path,i);
+				}
+			}
+		}
+		for(i in instance){
+			if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
+				if (options.filter) {
+					delete instance[i];
+					continue;
+				} else {
+					errors.push({property:path,message:(typeof value) + "The property " + i +
+						" is not defined in the schema and the schema does not allow additional properties"});
+				}
+			}
+			var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
+			if(requires && !(requires in instance)){
+				errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
+			}
+			value = instance[i];
+			if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
+				if(options.coerce){
+					value = instance[i] = options.coerce(value, additionalProp);
+				}
+				checkProp(value,additionalProp,path,i);
+			}
+			if(!_changing && value && value.$schema){
+				errors = errors.concat(checkProp(value,value.$schema,path,i));
+			}
+		}
+		return errors;
+	}
+	if(schema){
+		checkProp(instance,schema,'',_changing || '');
+	}
+	if(!_changing && instance && instance.$schema){
+		checkProp(instance,instance.$schema,'','');
+	}
+	return {valid:!errors.length,errors:errors};
+};
+exports.mustBeValid = function(result){
+	//	summary:
+	//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
+	// result: the result returned from checkPropertyChange or validate
+	if(!result.valid){
+		throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
+	}
+}
+
+return exports;
+}));
diff --git a/src/vm/node_modules/jsprim/node_modules/json-schema/package.json b/src/vm/node_modules/jsprim/node_modules/json-schema/package.json
new file mode 100644
index 00000000..a3797862
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/json-schema/package.json
@@ -0,0 +1,65 @@
+{
+  "name": "json-schema",
+  "version": "0.2.3",
+  "author": {
+    "name": "Kris Zyp"
+  },
+  "description": "JSON Schema validation and specifications",
+  "maintainers": [
+    {
+      "name": "kriszyp",
+      "email": "kriszyp@gmail.com"
+    }
+  ],
+  "keywords": [
+    "json",
+    "schema"
+  ],
+  "licenses": [
+    {
+      "type": "AFLv2.1",
+      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L43"
+    },
+    {
+      "type": "BSD",
+      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13"
+    }
+  ],
+  "repository": {
+    "type": "git",
+    "url": "git+ssh://git@github.com/kriszyp/json-schema.git"
+  },
+  "directories": {
+    "lib": "./lib"
+  },
+  "main": "./lib/validate.js",
+  "devDependencies": {
+    "vows": "*"
+  },
+  "scripts": {
+    "test": "echo TESTS DISABLED vows --spec test/*.js"
+  },
+  "gitHead": "07ae2c618b5f581dbc108e065f4f95dcf0a1d85f",
+  "bugs": {
+    "url": "https://github.com/kriszyp/json-schema/issues"
+  },
+  "homepage": "https://github.com/kriszyp/json-schema#readme",
+  "_id": "json-schema@0.2.3",
+  "_shasum": "b480c892e59a2f05954ce727bd3f2a4e882f9e13",
+  "_from": "json-schema@0.2.3",
+  "_npmVersion": "3.8.9",
+  "_nodeVersion": "6.1.0",
+  "_npmUser": {
+    "name": "kriszyp",
+    "email": "kriszyp@gmail.com"
+  },
+  "dist": {
+    "shasum": "b480c892e59a2f05954ce727bd3f2a4e882f9e13",
+    "tarball": "http://10.0.1.33:8354/json-schema/-/json-schema-0.2.3.tgz"
+  },
+  "_npmOperationalInternal": {
+    "host": "packages-12-west.internal.npmjs.com",
+    "tmp": "tmp/json-schema-0.2.3.tgz_1473699189380_0.7420965158380568"
+  },
+  "_resolved": "http://10.0.1.33:8354/json-schema/-/json-schema-0.2.3.tgz"
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/LICENSE b/src/vm/node_modules/jsprim/node_modules/verror/LICENSE
new file mode 100644
index 00000000..82a5cb86
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/lib/verror.js b/src/vm/node_modules/jsprim/node_modules/verror/lib/verror.js
new file mode 100644
index 00000000..8663ddea
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/lib/verror.js
@@ -0,0 +1,451 @@
+/*
+ * verror.js: richer JavaScript errors
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_util = require('util');
+
+var mod_extsprintf = require('extsprintf');
+var mod_isError = require('core-util-is').isError;
+var sprintf = mod_extsprintf.sprintf;
+
+/*
+ * Public interface
+ */
+
+/* So you can 'var VError = require('verror')' */
+module.exports = VError;
+/* For compatibility */
+VError.VError = VError;
+/* Other exported classes */
+VError.SError = SError;
+VError.WError = WError;
+VError.MultiError = MultiError;
+
+/*
+ * Common function used to parse constructor arguments for VError, WError, and
+ * SError.  Named arguments to this function:
+ *
+ *     strict		force strict interpretation of sprintf arguments, even
+ *     			if the options in "argv" don't say so
+ *
+ *     argv		error's constructor arguments, which are to be
+ *     			interpreted as described in README.md.  For quick
+ *     			reference, "argv" has one of the following forms:
+ *
+ *          [ sprintf_args... ]           (argv[0] is a string)
+ *          [ cause, sprintf_args... ]    (argv[0] is an Error)
+ *          [ options, sprintf_args... ]  (argv[0] is an object)
+ *
+ * This function normalizes these forms, producing an object with the following
+ * properties:
+ *
+ *    options           equivalent to "options" in third form.  This will never
+ *    			be a direct reference to what the caller passed in
+ *    			(i.e., it may be a shallow copy), so it can be freely
+ *    			modified.
+ *
+ *    shortmessage      result of sprintf(sprintf_args), taking options.strict
+ *    			into account as described in README.md.
+ */
+function parseConstructorArguments(args)
+{
+	var argv, options, sprintf_args, shortmessage, k;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.bool(args.strict, 'args.strict');
+	mod_assertplus.array(args.argv, 'args.argv');
+	argv = args.argv;
+
+	/*
+	 * First, figure out which form of invocation we've been given.
+	 */
+	if (argv.length === 0) {
+		options = {};
+		sprintf_args = [];
+	} else if (mod_isError(argv[0])) {
+		options = { 'cause': argv[0] };
+		sprintf_args = argv.slice(1);
+	} else if (typeof (argv[0]) === 'object') {
+		options = {};
+		for (k in argv[0]) {
+			options[k] = argv[0][k];
+		}
+		sprintf_args = argv.slice(1);
+	} else {
+		mod_assertplus.string(argv[0],
+		    'first argument to VError, SError, or WError ' +
+		    'constructor must be a string, object, or Error');
+		options = {};
+		sprintf_args = argv;
+	}
+
+	/*
+	 * Now construct the error's message.
+	 *
+	 * extsprintf (which we invoke here with our caller's arguments in order
+	 * to construct this Error's message) is strict in its interpretation of
+	 * values to be processed by the "%s" specifier.  The value passed to
+	 * extsprintf must actually be a string or something convertible to a
+	 * String using .toString().  Passing other values (notably "null" and
+	 * "undefined") is considered a programmer error.  The assumption is
+	 * that if you actually want to print the string "null" or "undefined",
+	 * then that's easy to do that when you're calling extsprintf; on the
+	 * other hand, if you did NOT want that (i.e., there's actually a bug
+	 * where the program assumes some variable is non-null and tries to
+	 * print it, which might happen when constructing a packet or file in
+	 * some specific format), then it's better to stop immediately than
+	 * produce bogus output.
+	 *
+	 * However, sometimes the bug is only in the code calling VError, and a
+	 * programmer might prefer to have the error message contain "null" or
+	 * "undefined" rather than have the bug in the error path crash the
+	 * program (making the first bug harder to identify).  For that reason,
+	 * by default VError converts "null" or "undefined" arguments to their
+	 * string representations and passes those to extsprintf.  Programmers
+	 * desiring the strict behavior can use the SError class or pass the
+	 * "strict" option to the VError constructor.
+	 */
+	mod_assertplus.object(options);
+	if (!options.strict && !args.strict) {
+		sprintf_args = sprintf_args.map(function (a) {
+			return (a === null ? 'null' :
+			    a === undefined ? 'undefined' : a);
+		});
+	}
+
+	if (sprintf_args.length === 0) {
+		shortmessage = '';
+	} else {
+		shortmessage = sprintf.apply(null, sprintf_args);
+	}
+
+	return ({
+	    'options': options,
+	    'shortmessage': shortmessage
+	});
+}
+
+/*
+ * See README.md for reference documentation.
+ */
+function VError()
+{
+	var args, obj, parsed, cause, ctor, message, k;
+
+	args = Array.prototype.slice.call(arguments, 0);
+
+	/*
+	 * This is a regrettable pattern, but JavaScript's built-in Error class
+	 * is defined to work this way, so we allow the constructor to be called
+	 * without "new".
+	 */
+	if (!(this instanceof VError)) {
+		obj = Object.create(VError.prototype);
+		VError.apply(obj, arguments);
+		return (obj);
+	}
+
+	/*
+	 * For convenience and backwards compatibility, we support several
+	 * different calling forms.  Normalize them here.
+	 */
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
+
+	/*
+	 * If we've been given a name, apply it now.
+	 */
+	if (parsed.options.name) {
+		mod_assertplus.string(parsed.options.name,
+		    'error\'s "name" must be a string');
+		this.name = parsed.options.name;
+	}
+
+	/*
+	 * For debugging, we keep track of the original short message (attached
+	 * this Error particularly) separately from the complete message (which
+	 * includes the messages of our cause chain).
+	 */
+	this.jse_shortmsg = parsed.shortmessage;
+	message = parsed.shortmessage;
+
+	/*
+	 * If we've been given a cause, record a reference to it and update our
+	 * message appropriately.
+	 */
+	cause = parsed.options.cause;
+	if (cause) {
+		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
+		this.jse_cause = cause;
+
+		if (!parsed.options.skipCauseMessage) {
+			message += ': ' + cause.message;
+		}
+	}
+
+	/*
+	 * If we've been given an object with properties, shallow-copy that
+	 * here.  We don't want to use a deep copy in case there are non-plain
+	 * objects here, but we don't want to use the original object in case
+	 * the caller modifies it later.
+	 */
+	this.jse_info = {};
+	if (parsed.options.info) {
+		for (k in parsed.options.info) {
+			this.jse_info[k] = parsed.options.info[k];
+		}
+	}
+
+	this.message = message;
+	Error.call(this, message);
+
+	if (Error.captureStackTrace) {
+		ctor = parsed.options.constructorOpt || this.constructor;
+		Error.captureStackTrace(this, ctor);
+	}
+
+	return (this);
+}
+
+mod_util.inherits(VError, Error);
+VError.prototype.name = 'VError';
+
+VError.prototype.toString = function ve_toString()
+{
+	var str = (this.hasOwnProperty('name') && this.name ||
+		this.constructor.name || this.constructor.prototype.name);
+	if (this.message)
+		str += ': ' + this.message;
+
+	return (str);
+};
+
+/*
+ * This method is provided for compatibility.  New callers should use
+ * VError.cause() instead.  That method also uses the saner `null` return value
+ * when there is no cause.
+ */
+VError.prototype.cause = function ve_cause()
+{
+	var cause = VError.cause(this);
+	return (cause === null ? undefined : cause);
+};
+
+/*
+ * Static methods
+ *
+ * These class-level methods are provided so that callers can use them on
+ * instances of Errors that are not VErrors.  New interfaces should be provided
+ * only using static methods to eliminate the class of programming mistake where
+ * people fail to check whether the Error object has the corresponding methods.
+ */
+
+VError.cause = function (err)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
+};
+
+VError.info = function (err)
+{
+	var rv, cause, k;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	cause = VError.cause(err);
+	if (cause !== null) {
+		rv = VError.info(cause);
+	} else {
+		rv = {};
+	}
+
+	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
+		for (k in err.jse_info) {
+			rv[k] = err.jse_info[k];
+		}
+	}
+
+	return (rv);
+};
+
+VError.findCauseByName = function (err, name)
+{
+	var cause;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.string(name, 'name');
+	mod_assertplus.ok(name.length > 0, 'name cannot be empty');
+
+	for (cause = err; cause !== null; cause = VError.cause(cause)) {
+		mod_assertplus.ok(mod_isError(cause));
+		if (cause.name == name) {
+			return (cause);
+		}
+	}
+
+	return (null);
+};
+
+VError.hasCauseWithName = function (err, name)
+{
+	return (VError.findCauseByName(err, name) !== null);
+};
+
+VError.fullStack = function (err)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+
+	var cause = VError.cause(err);
+
+	if (cause) {
+		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
+	}
+
+	return (err.stack);
+};
+
+VError.errorFromList = function (errors)
+{
+	mod_assertplus.arrayOfObject(errors, 'errors');
+
+	if (errors.length === 0) {
+		return (null);
+	}
+
+	errors.forEach(function (e) {
+		mod_assertplus.ok(mod_isError(e));
+	});
+
+	if (errors.length == 1) {
+		return (errors[0]);
+	}
+
+	return (new MultiError(errors));
+};
+
+VError.errorForEach = function (err, func)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.func(func, 'func');
+
+	if (err instanceof MultiError) {
+		err.errors().forEach(function iterError(e) { func(e); });
+	} else {
+		func(err);
+	}
+};
+
+
+/*
+ * SError is like VError, but stricter about types.  You cannot pass "null" or
+ * "undefined" as string arguments to the formatter.
+ */
+function SError()
+{
+	var args, obj, parsed, options;
+
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof SError)) {
+		obj = Object.create(SError.prototype);
+		SError.apply(obj, arguments);
+		return (obj);
+	}
+
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': true
+	});
+
+	options = parsed.options;
+	VError.call(this, options, '%s', parsed.shortmessage);
+
+	return (this);
+}
+
+/*
+ * We don't bother setting SError.prototype.name because once constructed,
+ * SErrors are just like VErrors.
+ */
+mod_util.inherits(SError, VError);
+
+
+/*
+ * Represents a collection of errors for the purpose of consumers that generally
+ * only deal with one error.  Callers can extract the individual errors
+ * contained in this object, but may also just treat it as a normal single
+ * error, in which case a summary message will be printed.
+ */
+function MultiError(errors)
+{
+	mod_assertplus.array(errors, 'list of errors');
+	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
+	this.ase_errors = errors;
+
+	VError.call(this, {
+	    'cause': errors[0]
+	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
+}
+
+mod_util.inherits(MultiError, VError);
+MultiError.prototype.name = 'MultiError';
+
+MultiError.prototype.errors = function me_errors()
+{
+	return (this.ase_errors.slice(0));
+};
+
+
+/*
+ * See README.md for reference details.
+ */
+function WError()
+{
+	var args, obj, parsed, options;
+
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof WError)) {
+		obj = Object.create(WError.prototype);
+		WError.apply(obj, args);
+		return (obj);
+	}
+
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
+
+	options = parsed.options;
+	options['skipCauseMessage'] = true;
+	VError.call(this, options, '%s', parsed.shortmessage);
+
+	return (this);
+}
+
+mod_util.inherits(WError, VError);
+WError.prototype.name = 'WError';
+
+WError.prototype.toString = function we_toString()
+{
+	var str = (this.hasOwnProperty('name') && this.name ||
+		this.constructor.name || this.constructor.prototype.name);
+	if (this.message)
+		str += ': ' + this.message;
+	if (this.jse_cause && this.jse_cause.message)
+		str += '; caused by ' + this.jse_cause.toString();
+
+	return (str);
+};
+
+/*
+ * For purely historical reasons, WError's cause() function allows you to set
+ * the cause.
+ */
+WError.prototype.cause = function we_cause(c)
+{
+	if (mod_isError(c))
+		this.jse_cause = c;
+
+	return (this.jse_cause);
+};
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/LICENSE b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/LICENSE
new file mode 100644
index 00000000..d8d7f943
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/LICENSE
@@ -0,0 +1,19 @@
+Copyright Node.js contributors. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to
+deal in the Software without restriction, including without limitation the
+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+IN THE SOFTWARE.
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/lib/util.js b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/lib/util.js
new file mode 100644
index 00000000..ff4c851c
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/lib/util.js
@@ -0,0 +1,107 @@
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+// NOTE: These type checking functions intentionally don't use `instanceof`
+// because it is fragile and can be easily faked with `Object.create()`.
+
+function isArray(arg) {
+  if (Array.isArray) {
+    return Array.isArray(arg);
+  }
+  return objectToString(arg) === '[object Array]';
+}
+exports.isArray = isArray;
+
+function isBoolean(arg) {
+  return typeof arg === 'boolean';
+}
+exports.isBoolean = isBoolean;
+
+function isNull(arg) {
+  return arg === null;
+}
+exports.isNull = isNull;
+
+function isNullOrUndefined(arg) {
+  return arg == null;
+}
+exports.isNullOrUndefined = isNullOrUndefined;
+
+function isNumber(arg) {
+  return typeof arg === 'number';
+}
+exports.isNumber = isNumber;
+
+function isString(arg) {
+  return typeof arg === 'string';
+}
+exports.isString = isString;
+
+function isSymbol(arg) {
+  return typeof arg === 'symbol';
+}
+exports.isSymbol = isSymbol;
+
+function isUndefined(arg) {
+  return arg === void 0;
+}
+exports.isUndefined = isUndefined;
+
+function isRegExp(re) {
+  return objectToString(re) === '[object RegExp]';
+}
+exports.isRegExp = isRegExp;
+
+function isObject(arg) {
+  return typeof arg === 'object' && arg !== null;
+}
+exports.isObject = isObject;
+
+function isDate(d) {
+  return objectToString(d) === '[object Date]';
+}
+exports.isDate = isDate;
+
+function isError(e) {
+  return (objectToString(e) === '[object Error]' || e instanceof Error);
+}
+exports.isError = isError;
+
+function isFunction(arg) {
+  return typeof arg === 'function';
+}
+exports.isFunction = isFunction;
+
+function isPrimitive(arg) {
+  return arg === null ||
+         typeof arg === 'boolean' ||
+         typeof arg === 'number' ||
+         typeof arg === 'string' ||
+         typeof arg === 'symbol' ||  // ES6 symbol
+         typeof arg === 'undefined';
+}
+exports.isPrimitive = isPrimitive;
+
+exports.isBuffer = Buffer.isBuffer;
+
+function objectToString(o) {
+  return Object.prototype.toString.call(o);
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/package.json b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/package.json
new file mode 100644
index 00000000..e0da971f
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/node_modules/core-util-is/package.json
@@ -0,0 +1,59 @@
+{
+  "name": "core-util-is",
+  "version": "1.0.2",
+  "description": "The `util.is*` functions introduced in Node v0.12.",
+  "main": "lib/util.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/core-util-is.git"
+  },
+  "keywords": [
+    "util",
+    "isBuffer",
+    "isArray",
+    "isNumber",
+    "isString",
+    "isRegExp",
+    "isThis",
+    "isThat",
+    "polyfill"
+  ],
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "license": "MIT",
+  "bugs": {
+    "url": "https://github.com/isaacs/core-util-is/issues"
+  },
+  "scripts": {
+    "test": "tap test.js"
+  },
+  "devDependencies": {
+    "tap": "^2.3.0"
+  },
+  "gitHead": "a177da234df5638b363ddc15fa324619a38577c8",
+  "homepage": "https://github.com/isaacs/core-util-is#readme",
+  "_id": "core-util-is@1.0.2",
+  "_shasum": "b5fd54220aa2bc5ab57aab7140c940754503c1a7",
+  "_from": "core-util-is@1.0.2",
+  "_npmVersion": "3.3.2",
+  "_nodeVersion": "4.0.0",
+  "_npmUser": {
+    "name": "isaacs",
+    "email": "i@izs.me"
+  },
+  "dist": {
+    "shasum": "b5fd54220aa2bc5ab57aab7140c940754503c1a7",
+    "tarball": "http://10.0.1.33:8354/core-util-is/-/core-util-is-1.0.2.tgz"
+  },
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/core-util-is/-/core-util-is-1.0.2.tgz"
+}
diff --git a/src/vm/node_modules/jsprim/node_modules/verror/package.json b/src/vm/node_modules/jsprim/node_modules/verror/package.json
new file mode 100644
index 00000000..1bb51aa9
--- /dev/null
+++ b/src/vm/node_modules/jsprim/node_modules/verror/package.json
@@ -0,0 +1,50 @@
+{
+  "name": "verror",
+  "version": "1.10.0",
+  "description": "richer JavaScript errors",
+  "main": "./lib/verror.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/davepacheco/node-verror.git"
+  },
+  "dependencies": {
+    "assert-plus": "^1.0.0",
+    "core-util-is": "1.0.2",
+    "extsprintf": "^1.2.0"
+  },
+  "engines": [
+    "node >=0.6.0"
+  ],
+  "scripts": {
+    "test": "make test"
+  },
+  "license": "MIT",
+  "bugs": {
+    "url": "https://github.com/davepacheco/node-verror/issues"
+  },
+  "homepage": "https://github.com/davepacheco/node-verror",
+  "_id": "verror@1.10.0",
+  "_shasum": "3a105ca17053af55d6e270c1f8288682e18da400",
+  "_from": "verror@1.10.0",
+  "_npmVersion": "1.4.9",
+  "_npmUser": {
+    "name": "dap",
+    "email": "dap@cs.brown.edu"
+  },
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "dist": {
+    "shasum": "3a105ca17053af55d6e270c1f8288682e18da400",
+    "tarball": "http://10.0.1.33:8354/verror/-/verror-1.10.0.tgz"
+  },
+  "_npmOperationalInternal": {
+    "host": "packages-12-west.internal.npmjs.com",
+    "tmp": "tmp/verror-1.10.0.tgz_1493743247437_0.7535550429020077"
+  },
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/verror/-/verror-1.10.0.tgz"
+}
diff --git a/src/vm/node_modules/jsprim/package.json b/src/vm/node_modules/jsprim/package.json
new file mode 100644
index 00000000..a2f56c9b
--- /dev/null
+++ b/src/vm/node_modules/jsprim/package.json
@@ -0,0 +1,51 @@
+{
+  "name": "jsprim",
+  "version": "2.0.0",
+  "description": "utilities for primitive JavaScript types",
+  "main": "./lib/jsprim.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/node-jsprim.git"
+  },
+  "dependencies": {
+    "assert-plus": "1.0.0",
+    "extsprintf": "1.3.0",
+    "json-schema": "0.2.3",
+    "verror": "1.10.0"
+  },
+  "engines": [
+    "node >=0.6.0"
+  ],
+  "license": "MIT",
+  "gitHead": "e65bdabbc1abdf83ba1e8d121e5a877ec29e6fe1",
+  "bugs": {
+    "url": "https://github.com/joyent/node-jsprim/issues"
+  },
+  "homepage": "https://github.com/joyent/node-jsprim#readme",
+  "_id": "jsprim@2.0.0",
+  "scripts": {},
+  "_shasum": "5a5d9a35770978600a1caa095c78c7831ecf4f7c",
+  "_from": "jsprim@latest",
+  "_npmVersion": "2.15.9",
+  "_nodeVersion": "0.10.46",
+  "_npmUser": {
+    "name": "dap",
+    "email": "dap@cs.brown.edu"
+  },
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "dist": {
+    "shasum": "5a5d9a35770978600a1caa095c78c7831ecf4f7c",
+    "tarball": "http://10.0.1.33:8354/jsprim/-/jsprim-2.0.0.tgz"
+  },
+  "_npmOperationalInternal": {
+    "host": "s3://npm-registry-packages",
+    "tmp": "tmp/jsprim-2.0.0.tgz_1508978212851_0.908593182452023"
+  },
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/jsprim/-/jsprim-2.0.0.tgz"
+}
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index ef8ec240..36198549 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -321,7 +321,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.archive-on-delete'
     }, autoboot: {
@@ -718,7 +719,8 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update'],
                 'kvm': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.do-not-inventory'
     }, docker: {
@@ -728,7 +730,8 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update'],
                 'joyent-minimal': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.docker'
     }, dns_domain: {
@@ -814,7 +817,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.firewall-enabled'
     }, fs_allowed: {
@@ -868,7 +872,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zfs: {
             fields: ['userrefs'],
@@ -884,7 +889,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zfs: {
             fields: ['userrefs'],
@@ -963,7 +969,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         zonexml: 'zone.attr.maintain-resolvers'
     }, max_locked_memory: {
@@ -1125,7 +1132,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_dhcp_spoofing'
@@ -1139,7 +1147,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_ip_spoofing'
@@ -1153,7 +1162,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_mac_spoofing'
@@ -1167,7 +1177,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_restricted_traffic'
@@ -1178,7 +1189,8 @@ exports.properties = {
                 'bhyve': ['add', 'update'],
                 'kvm': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.allow_unfiltered_promisc'
@@ -1232,7 +1244,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.dhcp_server'
@@ -1391,7 +1404,8 @@ exports.properties = {
                 'kvm': ['add', 'update'],
                 'lx': ['add', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: false
         },
         updatable: true,
         zonexml: 'zone.network.net-attr.primary'
@@ -1670,7 +1684,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'boolean'
+            type: 'boolean',
+            default: true
         },
         zonexml: 'zone.attr.restart-init'
     }, routes: {
@@ -1947,7 +1962,8 @@ exports.properties = {
                 'joyent-minimal': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'string'
+            type: 'string',
+            default: 'off'
         },
         zfs: {
             fields: ['compression'],
@@ -1992,6 +2008,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 'none',
             min: 0
         },
         zfs: {
@@ -2007,7 +2024,8 @@ exports.properties = {
                 'kvm': ['create', 'receive', 'update'],
                 'lx': ['create', 'receive', 'update']
             },
-            type: 'string'
+            type: 'string',
+            default: 'off'
         },
         zfs: {
             fields: ['compression'],
@@ -2023,6 +2041,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 131072,
             min: 0
         },
         zfs: {
@@ -2090,6 +2109,7 @@ exports.properties = {
                 'lx': ['create', 'receive', 'update']
             },
             type: 'integer',
+            default: 'none',
             min: 0
         },
         zfs: {
diff --git a/src/vm/node_modules/queue.js b/src/vm/node_modules/queue.js
new file mode 100644
index 00000000..0f788603
--- /dev/null
+++ b/src/vm/node_modules/queue.js
@@ -0,0 +1,589 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * Queue is a wrapper around a vasync queue with a few added features:
+ *
+ * - Ability to pause, fast-forward, and resume the queue
+ * - Optional deduplication for queued tasks with the same string identifier
+ * - Optional timeout for tasks taking too long
+ * - Tasks (functions) get a custom logger with unique task identifier
+ * - Timing stats for task create (enqueue), start, and finish.
+ * - 'idle' event for the queue X ms after the vasync queue has drained
+ *
+ * Every task pushed to the queue must contain at least a function to run, and
+ * a string identifier (called description).
+ *
+ * Example
+ *
+ * var q = new Queue({
+ *     log: log,     // [required] bunyan logger
+ *     workers: 1,   // [required] number of concurrent workers
+ *     dedup: true,  // [optional] discard enqueued tasks with same description
+ *     paused: true, // [optional] start paused, defauts to false
+ *     idleTime: 200 // [optional] time in ms to be considered, defaults to
+ *                                 instant ('drain' is 'idle')
+ *
+ * });
+ *
+ * q.enqueue({
+ *     // used for logging, and deduplication if enabled
+ *     description: 'sysevent seen for zone foo',
+ *
+ *     // kill the task if it takes more than 30 seconds, default is no timeout
+ *     timeout: 30 * 1000,
+ *
+ *     // the function to run - cb doesn't expect any arguments
+ *     func: function myTask(extras, cb) {
+ *         // this logger contains the task object, which has the tasks UUID,
+ *         // description, and more.  This is a childlog of the logger passed
+ *         // in during queue creation.
+ *         extras.log('doing something');
+ *
+ *         somethingAsync(function somethingAsyncDone() {
+ *             cb(); // let the queue know this task is over
+ *         });
+ *     }
+ * });
+ *
+ * q.enqueue({
+ *     description: 'sysevent seen for zone bar',
+ *     func: function syseventFunc(extras, cb) { cb(); }
+ * });
+ *
+ * .enqueue() also returns a value: true if the task was queued or false if it
+ * was discarded by deduplication.  For example:
+ *
+ * ret = q.enqueue({
+ *     description: 'foo',
+ *     func: function fooFunc(extras, cb) { cb(); }
+ * });
+ * // ret => true, no task with this name is enqueued
+ *
+ * ret = q.enqueue({
+ *     description: 'foo',
+ *     func: function otherFooFunc(extras, cb) { cb(); }
+ * });
+ * // ret => false, a task with this name is enqueued so this task is discarded
+ *
+ * There are now 3 tasks on the queue but it is currently paused, we can uncork
+ * it with:
+ *
+ * q.resume();
+ *
+ * Finally, Queue supports fast-forwarding the queue.  When a task is enqueued,
+ * the current timestamp is stored for it (called "create" time).  When you
+ * call .fastForward(), you pass in an hrtime Array, and all items
+ * created on or before that time will be run through the queue, and the
+ * callback will fire when all tasks are completed.
+ *
+ * For example (queue must be paused or an error is thrown)
+ *
+ * var one_minute_ago = process.hrtime();
+ * one_minute_ago[0] -= 60;
+ * var opts = {
+ *     timeout: 60 * 1000  [optional] timeout to error out fast-forward
+ * };
+ * q.fastForward(one_minute_ago, opts, function fastForwarded(err) {
+ *     // `err` can only be set if opts.timeout was specified and exceeded.
+ *     // In this event, the tasks are still running when this callback is
+ *     // fired, but the queue is still technically paused and not running
+ *     // any new tasks enqueued.
+ *
+ *     // Otherwise, this means the enqueued tasks created exactly or more than
+ *     // a minute ago are now complete.
+ * });
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var libuuid = require('/usr/node/node_modules/uuid');
+var vasync = require('/usr/vm/node_modules/vasync');
+
+module.exports.Queue = Queue;
+
+/*
+ * Create an event queue
+ *
+ * opts = {
+ *     log: log,       // [required] bunyan logger
+ *     workers: 1,     // [required] number of concurrent workers
+ *     dedup: true,    // [optional] discard enqueued tasks with same
+ *                        description
+ *     paused: true,   // [optional] start paused, defauts to false
+ *     idleTime: 1000, // [optional] time in ms from when the vasync queue
+ *                        drains to when the 'idle' event is emitted, defaults
+ *                        to 0ms (instant)
+ * };
+ */
+function Queue(opts) {
+    var self = this;
+
+    EventEmitter.call(self);
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.number(opts.workers, 'opts.workers');
+    assert.optionalBool(opts.dedup, 'opts.dedup');
+    assert.optionalBool(opts.paused, 'opts.paused');
+    assert.optionalNumber(opts.idleTime, 'opts.idleTime');
+
+    // paused
+    self.paused = !!opts.paused;
+    self.paused_time = self.paused ? process.hrtime() : null;
+
+    // idle timer
+    self.idleTime = opts.hasOwnProperty('idleTime') ? opts.idleTime : 0;
+    self.idle = !self.paused;
+
+    assert.number(self.idleTime, 'self.idleTime');
+    assert(self.idleTime >= 0, 'self.idleTime cannot be negative');
+
+    // max workers
+    self.workers = opts.workers;
+
+    // logger
+    self.log = opts.log;
+
+    // should dedup
+    self.dedup = opts.dedup;
+
+    // tasks waiting to run (pushed when paused)
+    self.paused_queue = [];
+
+    // vasync queue
+    self.queue = vasync.queue(function queueTaskProcess(task, cb) {
+        assert.object(task, 'task');
+        assert.func(cb, 'cb');
+
+        task.started_at = process.hrtime();
+
+        // "extras" is passed to the user function when it is called
+        var childlog = self.log.child({task: task});
+        var extras = {
+            log: childlog
+        };
+
+        // If a task timeout is specified, create a timeout for the task to
+        // emit an error if it takes too long to execute
+        var timeout;
+        if (task.timeout) {
+            timeout = setTimeout(function queueTaskTimeout() {
+                var err = new Error('timeout exceeded');
+                childlog.fatal({err: err, timeout: task.timeout},
+                    'task took longer than %dms', task.timeout);
+                self.emit('error', err);
+            }, task.timeout);
+        }
+
+        childlog.debug('starting task');
+        task.func(extras, function queueTaskFuncDone(err) {
+            task.finished_at = process.hrtime();
+            var delta = hrtime.hrtimeDelta(task.finished_at, task.started_at);
+
+            childlog.debug({delta: delta}, 'finished task in %s',
+                hrtime.prettyHrtime(delta));
+
+            // clear the timeout
+            if (timeout) {
+                clearTimeout(timeout);
+                timeout = null;
+            }
+
+            // emit an error
+            if (err) {
+                childlog.error({err: err}, 'task failed: %s', err.message);
+                self.emit('error', err);
+            }
+
+            cb();
+        });
+    }, self.workers);
+
+    self.queue.on('drain', function queueOnDrain() {
+        if (self.paused) {
+            return;
+        }
+
+        self._clearIdleTimer();
+
+        if (self.idleTime === 0) {
+            self._emitIdleEvent();
+            return;
+        }
+
+        self.idleTimer = setTimeout(function queueIdle() {
+            self.idleTimer = null;
+            self._emitIdleEvent();
+        }, self.idleTime);
+    });
+}
+util.inherits(Queue, EventEmitter);
+
+/*
+ * Push a task to the queue.  If we are currently paused the task will be
+ * stored in the "paused_queue" array, to be pushed onto the vasync queue
+ * at a later time as either part of a .resume() or .fastForward().  If
+ * we are not paused, the task is pushed directly onto the vasync queue.
+ *
+ * A task must have a function set, as well as a string description.  If the
+ * description of a task being pushed matches the description of a task
+ * already queued to run, and opts.dedup was set in the queues constructor,
+ * the task is discarded.
+ *
+ * Returns:
+ *   true    the task was enqueued, either while paused or running
+ *   false   the task wes discarded as a dup (only happens when opts.dedup)
+ */
+Queue.prototype.enqueue = function enqueue(opts, cb) {
+    var self = this;
+    var found;
+
+    assert.object(opts, 'opts');
+    assert.func(opts.func, 'opts.func');
+    assert.string(opts.description, 'opts.description');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalFunc(cb, 'cb');
+
+    // when a task is created, we record the time and create a unique id
+    // for it
+    opts.id = libuuid.create();
+    opts.created_at = process.hrtime();
+
+    // if dedup is disabled, we push the task to either the vasync queue
+    // or the paused queue depending on the current state
+    if (!self.dedup) {
+        if (self.paused) {
+            self.log.debug({opts: opts}, 'pushing to paused queue');
+            self.paused_queue.push({opts: opts, cb: cb});
+        } else {
+            self.log.debug({opts: opts}, 'pushing to vasync queue');
+            self._clearIdleTimer();
+            self.queue.push(opts, cb);
+        }
+        return true;
+    }
+
+    // if we are here then dedup is enabled.  we check the existing queues for
+    // a matching task and discard the current one if a match is found
+
+    if (self.paused) {
+        // check the paused queue first if we are paused
+        found = self.paused_queue.some(function dedupPaused(o) {
+            return o.opts.description === opts.description;
+        });
+    }
+
+    if (!found) {
+        // check the vasync queue if 1. we are not paused or, 2. the paused
+        // queue didn't have a matching task
+        found = self.queue.queued.some(function dedupQueued(o) {
+            return o.task.description === opts.description;
+        });
+    }
+
+    // a matching task was found in either queue - discard this one
+    if (found) {
+        self.log.debug({opts: opts}, 'duplicate task found - discarding');
+        return false;
+    }
+
+    // no matching task was found - push it to the appropriate queue
+    if (self.paused) {
+        self.log.debug({opts: opts},
+            'no duplicate task found - pushing to paused queue');
+        self.paused_queue.push({opts: opts, cb: cb});
+    } else {
+        self.log.debug({opts: opts},
+            'no duplicate task found - pushing to vasync queue');
+        self._clearIdleTimer();
+        self.queue.push(opts, cb);
+    }
+
+    return true;
+};
+
+/*
+ * Pause the queue
+ *
+ * This will pause processing any newly enqueued tasks and wait for all
+ * currently running and enqueued tasks to finish.
+ *
+ * An optional timeout may be specified to callback with an
+ * error if it takes too long to stop the queue.
+ */
+Queue.prototype.pause = function pause(opts, cb) {
+    var self = this;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert(!self.paused, 'queue is already paused!');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.func(cb, 'cb');
+
+    self.paused = true;
+    self.paused_time = process.hrtime();
+
+    // pausing the queue disables the 'idle' event from being emitted
+    self._clearIdleTimer();
+
+    // short-circuit logic if no task is currently running
+    if (self.queue.npending === 0) {
+        self.log.debug('queue paused');
+        cb();
+        return;
+    }
+
+    // task(s) running - wait for finish
+    var timeout;
+    if (opts.timeout) {
+        timeout = setTimeout(function pauseTimeout() {
+            var err = new Error('pause timeout exceeded');
+            self.log.fatal({err: err, timeout: opts.timeout},
+                'pause took longer than %dms', opts.timeout);
+            self.queue.removeListener('drain', ondrain);
+            self.resume();
+            cb(err);
+        }, opts.timeout);
+    }
+
+    self.queue.once('drain', ondrain);
+
+    // vasync queue has drained, we can pause
+    function ondrain() {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        cb();
+    }
+};
+
+/*
+ * Resume the queue.
+ *
+ * This will take all of the elements of the paused_queue and push them into
+ * the vasync queue.
+ */
+Queue.prototype.resume = function resume() {
+    var self = this;
+
+    assert(self.paused, 'queue is not paused!');
+    assert(!self.idle, 'idle set while paused');
+    assert(!self.idleTimer, 'idleTimer set while paused');
+
+    self.paused = false;
+    self.paused_time = null;
+    self.log.debug('queue resumed - enqueueing %d tasks',
+        self.paused_queue.length);
+
+    if (self.paused_queue.length === 0) {
+        self._emitIdleEvent();
+        return;
+    }
+
+    self.paused_queue.forEach(function pausedForeachResume(o) {
+        self.queue.push(o.opts, o.cb);
+    });
+    self.paused_queue = [];
+};
+
+/*
+ * Fast Forward the queue to a given date.
+ *
+ * The queue must be paused for this to work.  Given an hrtime
+ * (process.hrtime()) as the first argument, this function will process every
+ * item in the queue that was queued before the time given and call the
+ * callback given when it has finished (or if it has timedout).
+ *
+ * opts.timeout   a max time (in ms) to wait for the queue to fast-forward,
+ *                this may be omitted to not create a timeout
+ *
+ */
+Queue.prototype.fastForward = function fastForward(time, opts, cb) {
+    var self = this;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert(self.paused, 'queue must be paused to fast-forward');
+    hrtime.assertHrtime(time, 'time');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.func(cb, 'cb');
+
+    // loop all queued tasks and dispatch them if they were created before or
+    // at fast-forward time given
+    var task;
+    var i = 0;
+    while ((task = self.paused_queue.shift())) {
+        if (hrtime.hrtimeComparator(task.opts.created_at, time) <= 0) {
+            i++;
+            self.queue.push(task.opts, task.cb);
+        } else {
+            self.paused_queue.unshift(task);
+            break;
+        }
+    }
+    self.log.debug('fast-forward pushed %d tasks into queue', i);
+
+    // just callback immediately if no tasks were pushed
+    if (i === 0) {
+        cb();
+        return;
+    }
+
+    // task(s) running - wait for finish
+    var timeout;
+    if (opts.timeout) {
+        timeout = setTimeout(function fastForwardTimeout() {
+            var err = new Error('fast-forward timeout exceeded');
+            self.log.error({err: err, timeout: opts.timeout},
+                'fast-forward took longer than %dms', opts.timeout);
+            self.queue.removeListener('drain', ondrain);
+            cb(err);
+        }, opts.timeout);
+    }
+
+    self.queue.once('drain', ondrain);
+
+    function ondrain() {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        cb();
+    }
+};
+
+/*
+ * Clear the idleTimer if it is set
+ */
+Queue.prototype._clearIdleTimer = function _clearIdleTimer() {
+    var self = this;
+
+    self.idle = false;
+    if (self.idleTimer) {
+        self.log.debug('clearing idleTimer');
+        clearTimeout(self.idleTimer);
+        self.idleTimer = null;
+    }
+};
+
+/*
+ * Emit the idle event
+ */
+Queue.prototype._emitIdleEvent = function _emitIdleEvent() {
+    var self = this;
+
+    assert(!self.idle, 'idle set while _emitIdleEvent called');
+    assert(!self.idleTimer, 'idleTimer set while _emitIdleEvent called');
+
+    self.log.debug('queue is idle');
+    self.idle = true;
+    self.emit('idle');
+};
+
+/*
+ * Return the queue status as an object.
+ *
+ * This is useful for stringifying and outputting as part of an HTTP request
+ * for a web service, or running this and storing in memory before a process
+ * crash.
+ */
+Queue.prototype.dump = function dump() {
+    var self = this;
+
+    var now = process.hrtime();
+
+    var state = {
+        now: hrtime.hrtimeToString(now),
+        paused: self.paused,
+        idle: self.idle,
+        vasync_queue: {
+            concurrency: self.queue.concurrency,
+            npending: self.queue.npending,
+            nqueued: self.queue.length(),
+            pending: {},
+            queued: []
+        }
+    };
+
+    Object.keys(self.queue.pending).forEach(function pendingForeach(id) {
+        var task = self.queue.pending[id].task;
+        var o = {
+            description: task.description,
+            created_at: hrtime.hrtimeToString(task.created_at),
+            started_at: hrtime.hrtimeToString(task.started_at),
+            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at),
+            started_ago: hrtime.hrtimeDeltaPretty(now, task.started_at),
+            start_latency: hrtime.hrtimeDeltaPretty(task.started_at,
+                task.created_at)
+
+        };
+        state.vasync_queue.pending[task.id] = o;
+    });
+
+    self.queue.queued.forEach(function queuedForeach(q) {
+        var task = q.task;
+        var o = {
+            description: task.description,
+            created_at: hrtime.hrtimeToString(task.created_at),
+            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at)
+        };
+        state.vasync_queue.queued.push(o);
+    });
+
+    if (self.paused) {
+        state.paused_at = hrtime.hrtimeToString(self.paused_time);
+        state.paused_ago = hrtime.hrtimeDeltaPretty(now, self.paused_time);
+        state.paused_nqueued = self.paused_queue.length;
+        state.paused_queue = [];
+        self.paused_queue.forEach(function pausedQueueForeach(task) {
+            assert.object(task, 'task');
+            assert.object(task.opts, 'task.opts');
+            var o = {
+                id: task.opts.id,
+                description: task.opts.description,
+                created_at: hrtime.hrtimeToString(task.opts.created_at),
+                created_ago: hrtime.hrtimeDeltaPretty(now, task.opts.created_at)
+            };
+            state.paused_queue.push(o);
+        });
+    }
+
+    return state;
+};
diff --git a/src/vm/node_modules/sysevent-stream.js b/src/vm/node_modules/sysevent-stream.js
index c9d86e6b..9e88afcf 100644
--- a/src/vm/node_modules/sysevent-stream.js
+++ b/src/vm/node_modules/sysevent-stream.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  * SyseventStream subscriptions Stream
  */
@@ -120,6 +120,10 @@ module.exports = SyseventStream;
 function SyseventStream(opts) {
     var self = this;
 
+    assert.optionalObject(opts, 'opts');
+    opts = opts || {};
+    assert.optionalNumber(opts.highWaterMark, 'opts.highWaterMark');
+
     self.ses_stopped = false;
     self.ses_started = process.hrtime();
 
@@ -127,10 +131,10 @@ function SyseventStream(opts) {
     stream.Transform.call(self, {objectMode: true});
 
     // process opts
-    opts = opts || {};
     self.ses_class = opts.class;
     self.ses_subclasses = opts.subclasses;
     self.ses_channel = opts.channel;
+    self.ses_highWaterMark = opts.highWaterMark;
 
     // create child logger
     if (opts.logger) {
@@ -195,7 +199,13 @@ function SyseventStream(opts) {
     self.ses_child.stdin.end();
 
     // parse stdout line by line by piping to ourselves
-    var stdoutls = new LineStream();
+    var lstreamOpts = {
+        encoding: 'utf8'
+    };
+    if (self.ses_highWaterMark) {
+        lstreamOpts.highWaterMark = self.ses_highWaterMark;
+    }
+    var stdoutls = new LineStream(lstreamOpts);
     self.ses_child.stdout.pipe(stdoutls).pipe(self);
 
     // parse stderr line by line - any stderr produced is a fatal error
diff --git a/src/vm/node_modules/vasync/package.json b/src/vm/node_modules/vasync/package.json
index 3fb51250..7febf3a4 100644
--- a/src/vm/node_modules/vasync/package.json
+++ b/src/vm/node_modules/vasync/package.json
@@ -24,6 +24,7 @@
   "gitHead": "b267712029d0b7e3e5fe30a8426400027076dfe0",
   "readme": "# vasync: observable asynchronous control flow\n\nThis module provides several functions for asynchronous control flow.  There are\nmany modules that do this already (notably async.js).  This one's claim to fame\nis improved debuggability.\n\n\n## Observability is important\n\nWorking with Node's asynchronous, callback-based model is much easier with a\nhandful of simple control-flow abstractions, like:\n\n* waterfalls and pipelines (which invoke a list of asynchronous callbacks\n  sequentially)\n* parallel pipelines (which invoke a list of asynchronous callbacks in parallel\n  and invoke a top-level callback when the last one completes).\n* queues\n* barriers\n\nBut these structures also introduce new types of programming errors: failing to\ninvoke the callback can cause the program to hang, and inadvertently invoking it\ntwice can cause all kinds of mayhem that's very difficult to debug.\n\nThe functions in this module keep track of what's going on so that you can\nfigure out what happened when your program goes wrong.  They generally return an\nobject describing details of the current state.  If your program goes wrong, you\nhave several ways of getting at this state:\n\n* On illumos-based systems, use MDB to [find the status object](http://dtrace.org/blogs/bmc/2012/05/05/debugging-node-js-memory-leaks/)\n  and then [print it out](http://dtrace.org/blogs/dap/2012/01/13/playing-with-nodev8-postmortem-debugging/).\n* Provide an HTTP API (or AMQP, or whatever) that returns these pending status\n  objects as JSON (see [kang](https://github.com/davepacheco/kang)).\n* Incorporate a REPL into your program and print out the status object.\n* Use the Node debugger to print out the status object.\n\n## Functions\n\n* [parallel](#parallel-invoke-n-functions-in-parallel): invoke N functions in\n  parallel (and merge the results)\n* [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):\n  invoke the same function on N inputs in parallel\n* [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke\n  N functions in series (and stop on failure)\n* [tryEach](#tryeach-invoke-n-functions-in-series-and-stop-on-success): invoke\n  N functions in series (and stop on success)\n* [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):\n  invoke the same function on N inputs in series (and stop on failure)\n* [filter/filterSeries/filterLimit](#filterfilterlimitfilterseries-filter-n-inputs-serially-or-concurrently):\n  filter N inputs serially or concurrently\n* [whilst](#whilst-invoke-a-function-repeatedly-until-a-stopping-condition-is-met):\n  invoke a function repeatedly until a stopping condition is met\n* [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):\n  like pipeline, but propagating results between stages\n* [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate\n  multiple concurrent operations\n* [queue/queuev](#queuequeuev-fixed-size-worker-queue): fixed-size worker queue\n\n### parallel: invoke N functions in parallel\n\nSynopsis: `parallel(args, callback)`\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\n`callback(err, result)`.  The error and result will be saved and made available\nto the original caller when all of these functions complete.\n\nThis function returns the same \"result\" object it passes to the callback, and\nyou can use the fields in this object to debug or observe progress:\n\n* `operations`: array corresponding to the input functions, with\n    * `func`: input function,\n    * `status`: \"pending\", \"ok\", or \"fail\",\n    * `err`: returned \"err\" value, if any, and\n    * `result`: returned \"result\" value, if any\n* `successes`: \"result\" field for each of \"operations\" where\n  \"status\" == \"ok\" (in no particular order)\n* `ndone`: number of input operations that have completed\n* `nerrors`: number of input operations that have failed\n\nThis status object lets you see in a debugger exactly which functions have\ncompleted, what they returned, and which ones are outstanding.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).\n\nExample usage:\n\n```js\nconsole.log(mod_vasync.parallel({\n    'funcs': [\n        function f1 (callback) { mod_dns.resolve('joyent.com', callback); },\n        function f2 (callback) { mod_dns.resolve('github.com', callback); },\n        function f3 (callback) { mod_dns.resolve('asdfaqsdfj.com', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nIn the first tick, this outputs:\n\n```js\nstatus: { operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'pending' },\n     { func: [Function: f3], status: 'pending' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: queryA ENOTFOUND\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n```js\nif (err)\n  return (callback(err));\n```\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n```js\nresults: { operations:\n   [ { func: [Function: f1],\n       funcname: 'f1',\n       status: 'ok',\n       err: null,\n       result: [ '165.225.132.33' ] },\n     { func: [Function: f2],\n       funcname: 'f2',\n       status: 'ok',\n       err: null,\n       result: [ '207.97.227.239' ] },\n     { func: [Function: f3],\n       funcname: 'f3',\n       status: 'fail',\n       err: { [Error: queryA ENOTFOUND] code: 'ENOTFOUND',\n          errno: 'ENOTFOUND', syscall: 'queryA' },\n       result: undefined } ],\n  successes: [ [ '165.225.132.33' ], [ '207.97.227.239' ] ],\n  ndone: 3,\n  nerrors: 1 }\n```\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\nNote that \"successes\" is provided as a convenience and the order of items in\nthat array may not correspond to the order of the inputs.  To consume output in\nan ordered manner, you should iterate over \"operations\" and pick out the result\nfrom each item.\n\n\n### forEachParallel: invoke the same function on N inputs in parallel\n\nSynopsis: `forEachParallel(args, callback)`\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachParallel({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### pipeline: invoke N functions in series (and stop on failure)\n\nSynopsis: `pipeline(args, callback)`\n\nThe named arguments (that go inside `args`) are:\n\n* `funcs`: input functions, to be invoked in series\n* `arg`: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n```js\nconsole.log(mod_vasync.pipeline({\n    'funcs': [\n        function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n        function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (_, callback) { mod_fs.stat('/var', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nAs a result, the status after the first tick looks like this:\n\n```js\n{ operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'waiting' },\n     { func: [Function: f3], status: 'waiting' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nNote that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.  The error and complete result look just like the\nparallel case.\n\n### tryEach: invoke N functions in series (and stop on success)\n\nSynopsis: `tryEach(funcs, callback)`\n\nThe `tryEach` function invokes each of the asynchronous functions in `funcs`\nserially. Each function takes a single argument: an interstitial-callback.\n`tryEach` will keep calling the functions until one of them succeeds (or they\nall fail).  At the end, the terminating-callback is invoked with the error\nand/or results provided by the last function that was called (either the last\none that failed or the first one that succeeded).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `tryEach` stops on the first success:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { mod_fs.stat('/notreal', callback); },\n        function f2 (callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (callback) { mod_fs.stat('/var', callback); },\n        function f4 (callback) { mod_fs.stat('/noexist', callback); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nThe above code will stop when it finishes f3, and we will only print a single\nresult and no errors:\n\n```js\nerror: null\nresults: { dev: 65760,\n  mode: 16877,\n  nlink: 41,\n  uid: 0,\n  gid: 3,\n  rdev: -1,\n  blksize: 2560,\n  ino: 11,\n  size: 41,\n  blocks: 7,\n  atime: Thu May 28 2015 16:21:25 GMT+0000 (UTC),\n  mtime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC),\n  ctime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC) }\n```\n\nIf we comment out `f3`, we get the following output:\n\n```js\nerror: Error: ENOENT, stat '/noexist'\nresults: undefined\n```\n\nNote that: there is a mismatch (inherited from `async`) between the semantics\nof the interstitial callback and the sematics of the terminating callback. See\nthe following example:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { callback(new Error()); },\n        function f2 (callback) { callback(new Error()); },\n        function f3 (callback) { callback(null, 1, 2, 3); },\n        function f4 (callback) { callback(null, 1); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nWe pass one or more results to the terminating-callback via the\ninterstitial-callback's arglist -- `(err, res1, res2, ...)`. From the\ncallback-implementor's perspective, the results get wrapped up in an array\n`(err, [res1, res2, ...])` -- unless there is only one result, which simply\ngets passed through as the terminating callback's second argument. This means\nthat when we call the callback in `f3` above, the terminating callback receives\nthe list `[1, 2, 3]` as its second argument. If, we comment out `f3`, we will\nend up calling the callback in `f4` which will end up invoking the terminating\ncallback with a single result: `1`, instead of `[1]`.\n\n\nIn short, be mindful that there is not always a 1:1 correspondence between the\nterminating callback that you define, and the interstitial callback that gets\ncalled from the function.\n\n\n\n### forEachPipeline: invoke the same function on N inputs in series (and stop on failure)\n\nSynopsis: `forEachPipeline(args, callback)`\n\nThis function is exactly like `pipeline`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in series.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachPipeline({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### waterfall: invoke N functions in series, stop on failure, and propagate results\n\nSynopsis: `waterfall(funcs, callback)`\n\nThis function works like `pipeline` except for argument passing.\n\nEach function is passed any values emitted by the previous function (none for\nthe first function), followed by the callback to invoke upon completion.  This\ncallback must be invoked exactly once, regardless of success or failure.  As\nconventional in Node, the first argument to the callback indicates an error (if\nnon-null).  Subsequent arguments are passed to the next function in the \"funcs\"\nchain.\n\nIf any function fails (i.e., calls its callback with an Error), then the\nremaining functions are not invoked and \"callback\" is invoked with the error.\n\nThe only difference between waterfall() and pipeline() are the arguments passed\nto each function in the chain.  pipeline() always passes the same argument\nfollowed by the callback, while waterfall() passes whatever values were emitted\nby the previous function followed by the callback.\n\nHere's an example:\n\n```js\nmod_vasync.waterfall([\n    function func1(callback) {\n \tsetImmediate(function () {\n\t\tcallback(null, 37);\n\t});\n    },\n    function func2(extra, callback) {\n\tconsole.log('func2 got \"%s\" from func1', extra);\n\tcallback();\n    }\n], function () {\n\tconsole.log('done');\n});\n```\n\nThis prints:\n\n```\nfunc2 got \"37\" from func1\nbetter stop early\n```\n\n### filter/filterLimit/filterSeries: filter N inputs serially or concurrently\n\nSynopsis: `filter(inputs, filterFunc, callback)`\n\nSynopsis: `filterSeries(inputs, filterFunc, callback)`\n\nSynopsis: `filterLimit(inputs, limit, filterFunc, callback)`\n\nThese functions take an array (of anything) and a function to call on each\nelement of the array.  The function must callback with a true or false value as\nthe second argument or an error object as the first argument.  False values\nwill result in the element being filtered out of the results array.  An error\nobject passed as the first argument will cause the filter function to stop\nprocessing new elements and callback to the caller with the error immediately.\nOriginal input array order is maintained.\n\n`filter` and `filterSeries` are analogous to calling `filterLimit` with\na limit of `Infinity` and `1` respectively.\n\n\n```js\nvar inputs = [\n    'joyent.com',\n    'github.com',\n    'asdfaqsdfj.com'\n];\nfunction filterFunc(input, cb) {\n    mod_dns.resolve(input, function (err, results) {\n        if (err) {\n            cb(null, false);\n        } else {\n            cb(null, true);\n        }\n    }\n}\nmod_vasync.filter(inputs, filterFunc, function (err, results) {\n    // err => undefined\n    // results => ['joyent.com', 'github.com']\n});\n```\n\n### whilst: invoke a function repeatedly until a stopping condition is met\n\nSynopsis: `whilst(testFunc, iterateFunc, callback)`\n\nRepeatedly invoke `iterateFunc` while `testFunc` returns a true value.\n`iterateFunc` is an asychronous function that must call its callback (the first\nand only argument given to it) when it is finished with an optional error\nobject as the first argument, and any other arbitrary arguments.  If an error\nobject is given as the first argument, `whilst` will finish and call `callback`\nwith the error object.  `testFunc` is a synchronous function that must return\na value - if the value resolves to true `whilst` will invoke `iterateFunc`, if\nit resolves to false `whilst` will finish and invoke `callback` with the last\nset of arguments `iterateFunc` called back with.\n\n`whilst` also returns an object suitable for introspecting the current state of\nthe specific `whilst` invocation which contains the following properties:\n\n* `finished`: boolean if this invocation has finished or is in progress\n* `iterations`: number of iterations performed (calls to `iterateFunc`)\n\nCompatible with `async.whilst`\n\n```js\nvar n = 0;\n\nvar w = mod_vasync.whilst(\n    function testFunc() {\n        return (n < 5);\n    },\n    function iterateFunc(cb) {\n        n++;\n        cb(null, {n: n});\n    },\n    function whilstDone(err, arg) {\n        // err => undefined\n        // arg => {n: 5}\n        // w => {finished: true, iterations: 5}\n    }\n);\n\n// w => {finished: false, iterations: 0}\n```\n\n### barrier: coordinate multiple concurrent operations\n\nSynopsis: `barrier([args])`\n\nReturns a new barrier object.  Like `parallel`, barriers are useful for\ncoordinating several concurrent operations, but instead of specifying a list of\nfunctions to invoke, you just say how many (and optionally which ones) are\noutstanding, and this object emits `'drain'` when they've all completed.  This\nis syntactically lighter-weight, and more flexible.\n\n* Methods:\n\n    * start(name): Indicates that the named operation began.  The name must not\n      match an operation which is already ongoing.\n    * done(name): Indicates that the named operation ended.\n\n\n* Read-only public properties (for debugging):\n\n    * pending: Set of pending operations.  Keys are names passed to \"start\", and\n      values are timestamps when the operation began.\n    * recent: Array of recent completed operations.  Each element is an object\n      with a \"name\", \"start\", and \"done\" field.  By default, 10 operations are\n      remembered.\n\n\n* Options:\n\n    * nrecent: number of recent operations to remember (for debugging)\n\nExample: printing sizes of files in a directory\n\n```js\nvar mod_fs = require('fs');\nvar mod_path = require('path');\nvar mod_vasync = require('../lib/vasync');\n\nvar barrier = mod_vasync.barrier();\n\nbarrier.on('drain', function () {\n  console.log('all files checked');\n});\n\nbarrier.start('readdir');\n\nmod_fs.readdir(__dirname, function (err, files) {\n  barrier.done('readdir');\n\n  if (err)\n    throw (err);\n\n  files.forEach(function (file) {\n    barrier.start('stat ' + file);\n\n    var path = mod_path.join(__dirname, file);\n\n    mod_fs.stat(path, function (err2, stat) {\n      barrier.done('stat ' + file);\n      console.log('%s: %d bytes', file, stat['size']);\n    });\n  });\n});\n```\n\nThis emits:\n\n    barrier-readdir.js: 602 bytes\n    foreach-parallel.js: 358 bytes\n    barrier-basic.js: 552 bytes\n    nofail.js: 384 bytes\n    pipeline.js: 490 bytes\n    parallel.js: 481 bytes\n    queue-serializer.js: 441 bytes\n    queue-stat.js: 529 bytes\n    all files checked\n\n\n### queue/queuev: fixed-size worker queue\n\nSynopsis: `queue(worker, concurrency)`\n\nSynopsis: `queuev(args)`\n\nThis function returns an object that allows up to a fixed number of tasks to be\ndispatched at any given time.  The interface is compatible with that provided\nby the \"async\" Node library, except that the returned object's fields represent\na public interface you can use to introspect what's going on.\n\n* Arguments\n\n    * worker: a function invoked as `worker(task, callback)`, where `task` is a\n      task dispatched to this queue and `callback` should be invoked when the\n      task completes.\n    * concurrency: a positive integer indicating the maximum number of tasks\n      that may be dispatched at any time.  With concurrency = 1, the queue\n      serializes all operations.\n\n\n* Methods\n\n    * push(task, [callback]): add a task (or array of tasks) to the queue, with\n      an optional callback to be invoked when each task completes.  If a list of\n      tasks are added, the callback is invoked for each one.\n    * length(): for compatibility with node-async.\n    * close(): signal that no more tasks will be enqueued.  Further attempts to\n      enqueue tasks to this queue will throw.  Once all pending and queued\n      tasks are completed the object will emit the \"end\" event.  The \"end\"\n      event is the last event the queue will emit, and it will be emitted even\n      if no tasks were ever enqueued.\n    * kill(): clear enqueued tasks and implicitly close the queue.  Several\n      caveats apply when kill() is called:\n        * The completion callback will _not_ be called for items purged from\n          the queue.\n        * The drain handler is cleared (for node-async compatibility)\n        * Subsequent calls to kill() or close() are no-ops.\n        * As with close(), it is not legal to call push() after kill().\n\n\n* Read-only public properties (for debugging):\n\n    * concurrency: for compatibility with node-async\n    * worker: worker function, as passed into \"queue\"/\"queuev\"\n    * worker\\_name: worker function's \"name\" field\n    * npending: the number of tasks currently being processed\n    * pending: an object (*not* an array) describing the tasks currently being\n      processed\n    * queued: array of tasks currently queued for processing\n    * closed: true when close() has been called on the queue\n    * ended: true when all tasks have completed processing, and no more\n      processing will occur\n    * killed: true when kill() has been called on the queue\n\n\n* Hooks (for compatibility with node-async):\n\n    * saturated\n    * empty\n    * drain\n\n* Events\n\n    * 'end': see close()\n\nIf the tasks are themselves simple objects, then the entire queue may be\nserialized (as via JSON.stringify) for debugging and monitoring tools.  Using\nthe above fields, you can see what this queue is doing (worker\\_name), which\ntasks are queued, which tasks are being processed, and so on.\n\n### Example 1: Stat several files\n\nHere's an example demonstrating the queue:\n\n```js\nvar mod_fs = require('fs');\nvar mod_vasync = require('../lib/vasync');\n\nvar queue;\n\nfunction doneOne()\n{\n  console.log('task completed; queue state:\\n%s\\n',\n      JSON.stringify(queue, null, 4));\n}\n\nqueue = mod_vasync.queue(mod_fs.stat, 2);\n\nconsole.log('initial queue state:\\n%s\\n', JSON.stringify(queue, null, 4));\n\nqueue.push('/tmp/file1', doneOne);\nqueue.push('/tmp/file2', doneOne);\nqueue.push('/tmp/file3', doneOne);\nqueue.push('/tmp/file4', doneOne);\n\nconsole.log('all tasks dispatched:\\n%s\\n', JSON.stringify(queue, null, 4));\n```\n\nThe initial queue state looks like this:\n\n```js\ninitial queue state:\n{\n    \"nextid\": 0,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\nAfter four tasks have been pushed, we see that two of them have been dispatched\nand the remaining two are queued up:\n\n```js\nall tasks pushed:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 2,\n    \"pending\": {\n        \"1\": {\n            \"id\": 1,\n            \"task\": \"/tmp/file1\"\n        },\n        \"2\": {\n            \"id\": 2,\n            \"task\": \"/tmp/file2\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        },\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nAs they complete, we see tasks moving from \"queued\" to \"pending\", and completed\ntasks disappear:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 1,\n    \"pending\": {\n        \"3\": {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nWhen all tasks have completed, the queue state looks like it started:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\n\n\n### Example 2: A simple serializer\n\nYou can use a queue with concurrency 1 and where the tasks are themselves\nfunctions to ensure that an arbitrary asynchronous function never runs\nconcurrently with another one, no matter what each one does.  Since the tasks\nare the actual functions to be invoked, the worker function just invokes each\none:\n\n```js\nvar mod_vasync = require('../lib/vasync');\n\nvar queue = mod_vasync.queue(\n    function (task, callback) { task(callback); }, 1);\n\nqueue.push(function (callback) {\n  console.log('first task begins');\n  setTimeout(function () {\n    console.log('first task ends');\n    callback();\n  }, 500);\n});\n\nqueue.push(function (callback) {\n  console.log('second task begins');\n  process.nextTick(function () {\n    console.log('second task ends');\n    callback();\n  });\n});\n```\n\nThis example outputs:\n\n    $ node examples/queue-serializer.js\n    first task begins\n    first task ends\n    second task begins\n    second task ends\n",
   "readmeFilename": "README.md",
+  "gitHead": "c99965d04df49ddec0d613d740f3ad6e7065727c",
   "bugs": {
     "url": "https://github.com/davepacheco/node-vasync/issues"
   },
diff --git a/src/vm/node_modules/vminfod/client.js b/src/vm/node_modules/vminfod/client.js
new file mode 100644
index 00000000..c8cd782d
--- /dev/null
+++ b/src/vm/node_modules/vminfod/client.js
@@ -0,0 +1,1112 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * - VminfodClient
+ *
+ * A client class that can be used to make basic GET requests to the vminfod
+ * service.
+ *
+ * var vc = new require('vminfod/client').VminfodClient();
+ *
+ * vc.ping(cb);
+ * vc.status(cb);
+ * vc.vms(cb);
+ * vc.vm(zonename, cb);
+ * vc.get(urlPath, cb); // arbitrary GET request
+ *
+ * Where `cb` has the signature function(err, result)
+ *
+ * - VminfodEventStream
+ *
+ * A class that can be used to interface directly with the vminfod events
+ * stream (GET /events).  It creates a readable stream in objectMode where each
+ * call to read returns an object parsed from the event stream that represents
+ * a single event.
+ *
+ * var vs = new require('vminfod/client').VminfodEventStream();
+ *
+ * vs.once('ready', function (ev) {
+ *     // stream ready
+ * });
+ *
+ * // create a live stream
+ * vs.on('readable', function () {
+ *     var ev;
+ *     while ((ev = vs.read())) {
+ *         console.log(JSON.stringify(ev));
+ *     }
+ * });
+ *
+ * // or instead, call a convenince function
+ *
+ * - VminfodEventStream#watchForEvent(obj, opts, cb)
+ *
+ * // wait 60 seconds for the zone_state to transition to "running"
+ * var obj = {
+ *     uuid: '<uuid>',
+ *     vm: {
+ *         zone_state: 'running'
+ *     }
+ * };
+ * var opts = {
+ *     timeout: 60 * 1000, // error after 60 seconds if event is not seen
+ *     teardown: true, // end the stream at any error or when the event is seen
+ *     startFresh: true, // clear any unread events first
+ *     catchErrors: true // bind .on('error') and callback if any is seen
+ * };
+ *
+ * // watchForEvent returns a function that can be used to cancel the watch.
+ * // It is bascially a shortcut to the callback that is fired - any arguments
+ * // passed to cancel will be applied to the callback given.
+ * var cancel = vs.watchForEvent(obj, opts, function (err, ev) {
+ *     if (err) {
+ *         // either the stream ended prematurely or the event was not seen for
+ *         // 60 seconds
+ *     }
+ *     // `ev` is the event that matched "obj"
+ *     console.log(JSON.stringify(ev, null, 2));
+ * });
+ *
+ * - VminfodEventStream#watchForChanges(obj, changes, opts, cb)
+ *
+ * // wait 30 seconds for the quota to change from 10 to 20
+ * // just like watchForEvent, this object is matched against the event object
+ * // before any further processing is done.
+ * var obj = {
+ *     uuid: '<uuid>',
+ * };
+ * // same as watchForEvent
+ * var opts = {
+ *     timeout: 30 * 1000,
+ *     teardown: true,
+ *     startFresh: true,
+ *     catchErrors: true
+ * };
+ * // every element in the array must be matched for the callback to fire
+ * // successfully (logical AND).
+ * var changes = [
+ *    {
+ *        path: ['quota'],
+ *        action: 'changed',
+ *        from: 10,
+ *        to: 20
+ *    }
+ * ];
+ * var cancel = vs.watchForChanges(obj, changes, opts, function (err) {
+ *     if (err) {
+ *         // either the stream ended prematurely or the event was not seen for
+ *         // 30 seconds
+ *     }
+ *     // matched the changes given
+ * });
+ *
+ * - VminfodWatcher
+ *
+ * A class that wraps VminfodEventStream and can be used to mirror vminfod
+ * effectively.  Under the hood, a VminfodEventStream will be created and used
+ * to manage an internal object of all VMs that vminfod is aware of.  This way,
+ * the internal object is kept up to date by getting notified of any changes
+ * from the vminfod service.  For Example:
+ *
+ * var vw = new require('vminfod/client').VminfodWatcher();
+ *
+ * vw.once('ready', function (ev) {
+ *     // returns an object that maps zonenames to vm objects
+ *     var vms = vw.vms();
+ *     // vms[<uuid>] == vmobj
+ *
+ *     var vmobj = vw.vm('uuid');
+ *     // vmobj is an object, or undefined if it is not found
+ * });
+ *
+ * vw.on('create', cb); // a VM was created
+ * vw.on('modify', cb); // a VM was modified
+ * vw.on('delete', cb); // a VM was deleted
+ * vw.on('event', cb);  // a VM was created/modified/deleted
+ *
+ * All callbacks will be called with a single argument - the event from the
+ * vminfod stream.
+ *
+ * The calls to `vw.vms` and `vw.vm` are very fast, because they just check
+ * a local JavaScript object (as opposed to making an HTTP call to the
+ * vminfod service) that is kept up to date by the VminfodEventStream.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var http = require('http');
+var stream = require('stream');
+var os = require('os');
+var util = require('util');
+var qs = require('querystring');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var diff = require('/usr/vm/node_modules/diff');
+var LineStream = require('/usr/node/node_modules/linestream');
+var hrtime = require('/usr/vm/node_modules/hrtime');
+
+/*
+ * When creating an event stream, the daemon *should* respond with a "ready"
+ * event when the connection is established.  In the event that there is a bug,
+ * or something wrong with the daemon and it doesn't send a ready event, we
+ * ensure that we don't indefinetely for an event that won't come.
+ */
+var DEFAULT_READY_TIMEOUT = 30 * 1000;
+
+module.exports.VminfodClient = VminfodClient;
+module.exports.VminfodEventStream = VminfodEventStream;
+module.exports.VminfodWatcher = VminfodWatcher;
+
+var log = bunyan.createLogger({
+    level: 'debug',
+    name: 'vminfod/client',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+function noop() {}
+
+/*
+ * VminfodClient class
+ */
+function VminfodClient(opts) {
+    var self = this;
+
+    var _log;
+
+    assert(self instanceof VminfodClient, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    _log = opts.log || log;
+
+    self.vc_host = opts.host || '127.0.0.1';
+    self.vc_port = opts.port || 9090;
+    self.vc_name = opts.name || _log.fields.name;
+    self.vc_logger = _log.child({client: self.vc_name});
+
+    assert.string(self.vc_host, 'self.vc_host');
+    assert.number(self.vc_port, 'self.vc_port');
+    assert.string(self.vc_name, 'self.vc_name');
+    assert.object(self.vc_logger, 'self.vc_logger');
+}
+
+/*
+ * Perform a GET request to the Vminfod daemon.
+ *
+ * @param {Object|String} opts - options to pass to http.request, if this is a
+ *                               string it is used as opts.path (the endpoint)
+ * @param {Function} cb - callback of signature cb(err, data)
+ *   - err - any possible error, including non-200 statusCode or failure to
+ *           parse JSON response
+ *   - data - the JSON.parse'd data returned from the server
+ * @return {HTTPRequest} req - the HTTP request object
+ */
+VminfodClient.prototype.get = function vminfodClientGet(opts, cb) {
+    var self = this;
+
+    var reqOpts;
+    var req;
+
+    if (typeof (opts) === 'string') {
+        opts = {path: opts};
+    }
+
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    reqOpts = {
+        host: self.vc_host,
+        port: self.vc_port,
+        method: 'GET',
+        headers: {
+            'user-agent': makeUserAgent(self.vc_name)
+        }
+    };
+    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
+        reqOpts[key] = opts[key];
+    });
+
+    req = http.request(reqOpts, function httpRequestMade(res) {
+        var body = '';
+        var err;
+
+        if (res.statusCode !== 200) {
+            err = new Error('bad statusCode: ' + res.statusCode);
+            err.code = err.statusCode = res.statusCode;
+            res.destroy();
+            cb(err);
+            return;
+        }
+
+        res.setEncoding('utf8');
+        body = '';
+        res.on('readable', function resReadable() {
+            var chunk;
+            while ((chunk = res.read()) !== null) {
+                body += chunk;
+            }
+        });
+        res.on('end', function resEnd() {
+            var d;
+            try {
+                d = JSON.parse(body);
+            } catch (e) {
+                self.vc_logger.error({err: e, opts: reqOpts},
+                    'failed to parse request body from %s %s',
+                    reqOpts.method, reqOpts.path);
+                cb(e);
+                return;
+            }
+            cb(null, d);
+        });
+    });
+
+    req.on('error', function reqError(e) {
+        cb(e);
+        req.destroy();
+    });
+
+    req.end();
+
+    return req;
+};
+
+/*
+ * shortcuts for common endpoints, equivalent to:
+ *   get('/status', cb), get('/vms', cb), etc.
+ */
+['ping', 'status', 'vms'].forEach(function makeVminfodClientFunc(s) {
+    VminfodClient.prototype[s] = function vminfodClientGetWrapper(opts, cb) {
+        var self = this;
+
+        if (typeof (opts) === 'function') {
+            cb = opts;
+            opts = {};
+        }
+
+        assert.object(opts, 'opts');
+        assert.func(cb, 'cb');
+
+        opts.path = '/' + s;
+
+        if (opts.query) {
+            opts.path += '?' + qs.stringify(opts.query);
+        }
+
+        return self.get(opts, cb);
+    };
+});
+
+/*
+ * Get a information for a specific vm given the zonename
+ *
+ * @param {String} zonename - the zonename (UUID most likely)
+ * @param {Function} cb - same signature and usage as .get()
+ */
+VminfodClient.prototype.vm = function vminfodClientVm(zonename, cb) {
+    var self = this;
+
+    assert.string(zonename, 'zonename');
+    assert.func(cb, 'cb');
+
+    var endpoint = '/vms/' + encodeURIComponent(zonename);
+
+    return self.get(endpoint, cb);
+};
+
+/*
+ * Create a new vminfod stream by creating a persistent HTTP request to vminfod
+ *
+ */
+function VminfodEventStream(opts) {
+    var self = this;
+
+    var _log;
+
+    assert(self instanceof VminfodEventStream, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    // become a transform stream
+    stream.Transform.call(self, {objectMode: true});
+
+    _log = opts.log || log;
+
+    // process opts
+    self.vs_host = opts.host || '127.0.0.1';
+    self.vs_port = opts.port || 9090;
+    self.vs_name = opts.name || _log.fields.name;
+    self.vs_parseReady = opts.parseReady || false;
+    self.vs_readyTimeout = opts.hasOwnProperty('readyTimeout') ?
+        opts.readyTimeout : DEFAULT_READY_TIMEOUT;
+    self.vs_logger = _log.child({client: self.vs_name});
+
+    assert.string(self.vs_host, 'self.vs_host');
+    assert.number(self.vs_port, 'self.vs_port');
+    assert.string(self.vs_name, 'self.vs_name');
+    assert.bool(self.vs_parseReady, 'self.vs_parseReady');
+    assert.number(self.vs_readyTimeout, 'self.vs_readyTimeout');
+    assert.object(self.vs_logger, 'self.vs_logger');
+
+    self.start();
+}
+util.inherits(VminfodEventStream, stream.Transform);
+
+/*
+ * start the stream by opening a persistent HTTP connection
+ */
+VminfodEventStream.prototype.start = function vminfodEventStreamStart(opts) {
+    var self = this;
+
+    var reqOpts;
+
+    opts = opts || {};
+
+    assert.object(opts, 'opts');
+    assert.ok(!self.vs_req, 'VminfodEventStream already started');
+
+    self.vs_startedTime = process.hrtime();
+
+    reqOpts = {
+        host: self.vs_host,
+        port: self.vs_port,
+        method: 'GET',
+        path: '/events',
+        headers: {
+            'user-agent': makeUserAgent(self.vs_name)
+        }
+    };
+    Object.keys(opts).forEach(function copyOptToReqOpts(key) {
+        reqOpts[key] = opts[key];
+    });
+
+    self.vs_req = http.request(reqOpts, function httpRequestMade(res) {
+        var err;
+        var ls;
+
+        if (res.statusCode !== 200) {
+            err = new Error('bad statusCode: ' + res.statusCode);
+            err.code = res.statusCode;
+            res.destroy();
+            self.vs_logger.error({err: err}, '%s', err.message);
+            self.emit('error', err);
+            return;
+        }
+
+        ls = new LineStream();
+        res.pipe(ls).pipe(self);
+        res.on('end', function resEnd() {
+            if (self.vs_req) {
+                err = new Error('VminfodEventStream ended prematurely');
+                self.vs_logger.error({err: err}, '%s', err.message);
+                self.emit('error', err);
+                return;
+            }
+        });
+    });
+    self.vs_req.setTimeout(0);
+    self.vs_req.end();
+
+    /*
+     * create a timer to ensure that the "ready" event seen.  This also allows
+     * us to ensure the "ready" event is only seen once.
+     */
+    assert(!self.vs_ready_timeout, '"ready" timeout already exists');
+    self.vs_ready_timeout = setTimeout(function readyTimeout() {
+        var err = new Error(util.format(
+            'VminfodEventStream ready timeout (%dms) exceeded',
+            self.vs_readyTimeout));
+
+        self.vs_logger.error({err: err}, '%s', err.message);
+        self.vs_ready_timeout = null;
+        self._abort(err);
+    }, self.vs_readyTimeout);
+
+    /*
+     * capture any request errors and reemit them by this module
+     */
+    self.vs_req.on('error', function reqError(err) {
+        self.vs_logger.error({err: err}, 'VminfodEventStream request error');
+        self._abort(err);
+    });
+
+    return self.vs_req;
+};
+
+/*
+ * the transform method to process http body-by-line
+ */
+VminfodEventStream.prototype._transform =
+    function _transform(chunk, encoding, cb) {
+
+    var self = this;
+
+    var ev;
+    var line = chunk.toString('utf8');
+    var now;
+    var parsed;
+    var vms;
+
+    try {
+        ev = JSON.parse(line);
+        ev.date = new Date(ev.date);
+        assert.ok(isFinite(ev.date), 'invalid ev.date');
+    } catch (e) {
+        // any JSON parse failure is a fatal error
+        self.vs_logger.error({err: e, line: line},
+            'failed to parse output line');
+        self._abort(e);
+        return;
+    }
+
+    switch (ev.type) {
+    case 'ready':
+        assert(self.vs_ready_timeout, '"ready" event already seen');
+        if (self.vs_parseReady) {
+            /*
+             * This is less-than-ideal, but because vminfod pre-serializes
+             * vm data to cut down on the number of calls to JSON.stringify
+             * required, we have to JSON.parse the vms property, as its been
+             * serialized twice.
+             *
+             * Also, we convert the vms array to an object indexed off of the
+             * "zonename" (uuid) property
+             */
+            now = process.hrtime();
+            vms = {};
+            parsed = JSON.parse(ev.vms);
+            parsed.forEach(function mapEachVm(vmobj) {
+                vms[vmobj.zonename] = vmobj;
+            });
+            ev.vms = vms;
+            self.vs_logger.debug({vms: parsed.length},
+                'vminfod took %s to parse "ready" event, %d vms total',
+                hrtime.hrtimeDeltaPretty(process.hrtime(), now), parsed.length);
+        }
+        self.vs_logger.debug('vminfod event stream ready - took %s',
+            hrtime.hrtimeDeltaPretty(process.hrtime(), self.vs_startedTime));
+        self.emit('ready', ev);
+        self._clearReadyTimeout();
+        break;
+    default:
+        self.push(ev);
+        break;
+    }
+    cb();
+};
+
+/*
+ * clear all unread objects from the internal buffer
+ */
+VminfodEventStream.prototype._clearEvents =
+    function vminfodEventStreamClearEvents() {
+
+    var self = this;
+
+    var i = 0;
+
+    while (self.read()) {
+        i++;
+    }
+
+    self.vs_logger.debug({i: i}, 'vminfod cleared %d events', i);
+};
+
+/*
+ * cleanly stop the VminfodEventStream by destroying the request
+ */
+VminfodEventStream.prototype.stop = function vminfodEventStreamStop() {
+    var self = this;
+
+    if (self.vs_req) {
+        self.vs_logger.debug('vminfod event stream stopped');
+        self.vs_req.destroy();
+        self.vs_req = null;
+    }
+    self._clearReadyTimeout();
+};
+
+/*
+ * same as above, but emit an error
+ */
+VminfodEventStream.prototype._abort = function _vminfodEventStreamAbort(e) {
+    var self = this;
+
+    self.stop();
+    self.emit('error', e);
+};
+
+/*
+ * Convenience function to clear the ready timeout if it is set
+ */
+VminfodEventStream.prototype._clearReadyTimeout =
+    function _vminfodEventStreamClearReadyTimeout() {
+
+    var self = this;
+
+    if (self.vs_ready_timeout) {
+        self.vs_logger.trace('clearing ready timeout');
+        clearTimeout(self.vs_ready_timeout);
+        self.vs_ready_timeout = null;
+    }
+};
+
+/*
+ * Watch for a specific event (with an optional timeout), and
+ * optionally teardown the stream when it is received
+ */
+VminfodEventStream.prototype.watchForEvent =
+    function vminfodEventStreamWatchForEvent(obj, opts, cb) {
+
+    var self = this;
+
+    var events = [];
+    var isDone = false;
+    var timeout;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert.object(obj, 'obj');
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalBool(opts.teardown, 'opts.teardown');
+    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
+    assert.optionalBool(opts.startFresh, 'opts.startFresh');
+    assert.func(cb, 'cb');
+
+    if (opts.timeout) {
+        timeout = setTimeout(function vminfodEventStreamWatchForEventTimeout() {
+            isDone = true;
+            self.stop();
+            self.vs_logger.error({obj: obj, events: events},
+                'vminfod watchForEvent timeout exceeded - unmatched events');
+            var err = new Error('timeout exceeded');
+            err.code = 'ETIMEOUT';
+            done(err);
+        }, opts.timeout);
+    }
+
+    self.vs_logger.debug({
+        obj: obj,
+        opts: opts
+    }, 'vminfod watchForEvent created');
+
+    self.on('readable', processEvents);
+    if (opts.startFresh) {
+        self._clearEvents();
+    } else {
+        processEvents();
+    }
+
+    function processEvents() {
+        var ev;
+        while ((ev = self.read()) !== null) {
+            processEvent(ev);
+        }
+    }
+
+    function processEvent(ev) {
+        if (isDone) {
+            return;
+        }
+
+        events.push(ev);
+
+        if (!objSameValues(obj, ev)) {
+            return;
+        }
+
+        self.vs_logger.debug({obj: obj},
+            'vminfod watchForEvent matched event');
+
+        done(null, ev);
+    }
+
+    function onerror(e) {
+        self.vs_logger.error({err: e},
+            'vminfod watchForEvent stream error');
+        done(e);
+    }
+    if (opts.catchErrors) {
+        self.on('error', onerror);
+    }
+
+    function done(err, o) {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        if (opts.teardown || (opts.catchErrors && err)) {
+            self.stop();
+        }
+        if (opts.catchErrors) {
+            self.removeListener('error', onerror);
+        }
+        self.removeListener('readable', processEvents);
+        isDone = true;
+        cb(err, o);
+    }
+
+    function cancelFn(err, o) {
+        if (isDone) {
+            self.vs_logger.warn('vminfod watchForEvent cancelled after done');
+            return;
+        }
+
+        self.vs_logger.debug('vminfod watchForEvent cancelled');
+        done(err, o);
+    }
+
+    return cancelFn;
+};
+
+/*
+ * watch for one or more changes (with an optional timeout), and
+ * optionally teardown the stream when it is seen
+ */
+VminfodEventStream.prototype.watchForChanges =
+    function vminfodEventStreamWatchForChanges(obj, changes, opts, cb) {
+
+    var self = this;
+
+    var events = [];
+    var isDone = false;
+    var timeout;
+    var total;
+
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
+
+    assert.object(obj, 'obj');
+    assert.array(changes, 'changes');
+    changes.forEach(function loopChangesBase(_changes) {
+        // change can be an object, or an array of objects
+        if (!Array.isArray(_changes)) {
+            _changes = [_changes];
+        }
+        assert.arrayOfObject(_changes, 'changes');
+        _changes.forEach(function loopChangesSecondLevel(change) {
+            /*
+             * In order for a "change" object to be valid, it must have the
+             * "path" property set, as well as any other property indicating
+             * change type.
+             */
+            assert.array(change.path, 'change.path');
+            var otherkeys = Object.keys(change).filter(
+                function filterPath(key) {
+
+                return key !== 'path';
+            });
+            assert(otherkeys.length > 0, 'change only has "path" set');
+        });
+    });
+    assert.object(opts, 'opts');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalBool(opts.teardown, 'opts.teardown');
+    assert.optionalBool(opts.catchErrors, 'opts.catchErrors');
+    assert.optionalBool(opts.startFresh, 'opts.startFresh');
+    assert.func(cb, 'cb');
+
+    total = changes.length;
+
+    self.vs_logger.debug({
+        obj: obj,
+        opts: opts,
+        changes: changes,
+        total: total
+    }, 'vminfod watchForChanges created');
+
+    if (total === 0) {
+        self.vs_logger.warn('vminfod watchForChanges called '
+            + 'with empty changes array');
+
+        if (opts.startFresh) {
+            self._clearEvents();
+        }
+
+        done();
+        return noop;
+    }
+
+    if (opts.timeout) {
+        timeout = setTimeout(
+            function vminfodEventStreamWatchForChangesTimeout() {
+
+            self.vs_logger.error({changes: changes, events: events},
+                'vminfod watchForChanges timeout exceeded - unmatched events');
+            var e = new Error('timeout exceeded');
+            e.code = 'ETIMEOUT';
+            done(e);
+        }, opts.timeout);
+    }
+
+    self.vs_logger.trace({changes: changes},
+        'beginning watch for vminfod changes');
+
+    self.on('readable', processEvents);
+    if (opts.startFresh) {
+        self._clearEvents();
+    } else {
+        processEvents();
+    }
+    function processEvents() {
+        var ev;
+        while ((ev = self.read()) !== null) {
+            processEvent(ev);
+        }
+    }
+
+    function processEvent(ev) {
+        if (isDone) {
+            return;
+        }
+
+        // filter out events that don't match our predicate (obj)
+        if (!objSameValues(obj, ev)) {
+            return;
+        }
+
+        self.vs_logger.trace({ev: ev},
+            'inspecting possible match from vminfod');
+
+        // loop changes found from vminfod
+        (ev.changes || []).forEach(function processChange(changeSeen) {
+            /*
+             * Compare to changes we are looking for.  Return false to remove
+             * the item from the changes array (meaning we matched it) or true
+             * to keep it in the array (meaning it was not a match).
+             *
+             * It's possible that there are duplicate changes we are looking
+             * for, so only filter out one element per change.
+             */
+            var hasMatched = false;
+            changes = changes.filter(function filterChanges(wantedArr) {
+                var changePart;
+                var changePath;
+                var match;
+                var originalWantedPath;
+                var wanted;
+                var wantedPart;
+                var wantedPath;
+
+                if (isDone) {
+                    return false;
+                }
+
+                if (hasMatched) {
+                    return true;
+                }
+
+                if (!Array.isArray(wantedArr)) {
+                    wantedArr = [wantedArr];
+                }
+
+                for (var i = 0; i < wantedArr.length; i++) {
+                    wanted = wantedArr[i];
+                    originalWantedPath = wanted.path.slice(0);
+
+                    wantedPath = wanted.path;
+                    changePath = changeSeen.path;
+
+                    /*
+                     * Skip this change if the path of the wanted variable
+                     * doesn't match
+                     */
+                    if (wantedPath.length !== changePath.length) {
+                        continue;
+                    }
+
+                    // Ensure each part of the "path" match.
+                    match = true;
+                    for (var j = 0; j < wantedPath.length; j++) {
+                        wantedPart = wantedPath[j];
+                        changePart = changePath[j];
+                        if (!(wantedPart === null
+                            || wantedPart === changePart)) {
+                            match = false;
+                            break;
+                        }
+                    }
+                    if (!match) {
+                        continue;
+                    }
+
+                    /*
+                     * Compare the event fired to the event we want, omitting
+                     * the "path" variable as it was checked above
+                     */
+                    delete wanted.path;
+                    match = objSameValues(wanted, changeSeen);
+                    wanted.path = originalWantedPath;
+
+                    if (match) {
+                        /*
+                         * We matched, this change will be removed from the
+                         * array
+                         */
+                        hasMatched = true;
+                        self.vs_logger.trace({changeSeen: changeSeen,
+                            match: match}, 'vminfod change match');
+
+                        return false;
+                    }
+                }
+
+                /*
+                 * If we get here, the event didn't match any of the changes
+                 * wanted so we keep the change and try again when a new event
+                 * is received.  We also push the event onto the "events" array
+                 * to be logged later for debugging purposes if the changes are
+                 * never satisified.
+                 */
+                events.push(changeSeen);
+                return true;
+            });
+        });
+
+        if (isDone) {
+            changes.length = 0;
+        }
+
+        if (changes.length === 0) {
+            // No more changes to wait for, we're done!
+            self.vs_logger.debug('vminfod watchForChanges all changes matched');
+            done();
+            return;
+        }
+
+        self.vs_logger.debug({remaining: changes.length, total: total},
+            'vminfod watchForChanges %d/%d changes remaining',
+            changes.length, total);
+    }
+
+    function onerror(e) {
+        self.vs_logger.error({err: e}, 'vminfod stream error');
+        done(e);
+    }
+    if (opts.catchErrors) {
+        self.on('error', onerror);
+    }
+
+    function done(err, o) {
+        if (timeout) {
+            clearTimeout(timeout);
+            timeout = null;
+        }
+        if (opts.teardown || (opts.catchErrors && err)) {
+            self.stop();
+        }
+        if (opts.catchErrors) {
+            self.removeListener('error', onerror);
+        }
+        self.removeListener('readable', processEvents);
+        isDone = true;
+        cb(err, o);
+    }
+
+    function cancelFn(err, o) {
+        if (isDone) {
+            self.vs_logger.warn('vminfod watchForChanges cancelled after done');
+            return;
+        }
+
+        self.vs_logger.debug('vminfod watchForChanges cancelled');
+        done(err, o);
+    }
+
+    return cancelFn;
+};
+
+/*
+ * Create a new VminfodEventStream and manage an internal object that houses
+ * all known vmobjs that is updated when a new event is seen
+ *
+ */
+function VminfodWatcher(opts) {
+    var self = this;
+
+    var _log;
+
+    assert(self instanceof VminfodWatcher, 'must be called with "new"');
+
+    opts = opts || {};
+    if (typeof (opts) === 'string') {
+        opts = {name: opts};
+    }
+
+    assert.object(opts, 'opts');
+
+    _log = opts.log || log;
+
+    self.vw_name = opts.name || _log.fields.name;
+    self.vw_logger = _log.child({client: self.vw_name});
+    self.vw_vms = {};
+
+    assert.string(self.vw_name, 'self.vw_name');
+    assert.object(self.vw_logger, 'self.vw_logger');
+
+    self.vw_vs = new VminfodEventStream({
+        name: self.vw_name,
+        log: self.vw_logger,
+        parseReady: true
+    });
+
+    self.vw_vs.once('ready',
+        function vminfodWatcherVminfodEventStreamReady(ready_ev) {
+
+        self.vw_vms = ready_ev.vms;
+        self.emit('ready');
+    });
+
+    self.vw_vs.on('readable',
+        function vminfodWatcherVminfodEventStreamReadable() {
+
+        var ev;
+        while ((ev = self.vw_vs.read())) {
+            self._handleEvent(ev);
+        }
+    });
+}
+util.inherits(VminfodWatcher, EventEmitter);
+
+/*
+ * Handle an incoming vminfod update
+ */
+VminfodWatcher.prototype._handleEvent =
+    function _vminfodWatcherHandleEvent(ev) {
+
+    var self = this;
+
+    assert.object(ev, 'ev');
+    assert.string(ev.type, 'ev.type');
+
+    switch (ev.type) {
+    case 'create':
+    case 'modify':
+        self.vw_vms[ev.zonename] = ev.vm;
+        break;
+    case 'delete':
+        delete self.vw_vms[ev.zonename];
+        break;
+    default:
+        assert(false, 'unknown vminfod event type: ' + ev.type);
+        break;
+    }
+
+    self.emit(ev.type, ev);
+    self.emit('event', ev);
+};
+
+/*
+ * return all vms
+ */
+VminfodWatcher.prototype.vms = function vminfodWatcherVms() {
+    var self = this;
+
+    return self.vw_vms;
+};
+
+/*
+ * return a specific vm
+ */
+VminfodWatcher.prototype.vm = function vminfodWatcherVm(zonename) {
+    var self = this;
+
+    var vm;
+
+    assert.string(zonename, 'zonename');
+
+    if (self.vw_vms.hasOwnProperty(zonename)) {
+        vm = self.vw_vms[zonename];
+    }
+
+    return vm;
+};
+
+/*
+ * stop the watcher
+ */
+VminfodWatcher.prototype.stop = function vminfodWatcherStop() {
+    var self = this;
+
+    self.vw_vs.stop();
+};
+
+/*
+ * Check to see that all key=>value pairs in "a" are found in "b".
+ */
+function objSameValues(a, b) {
+    var d = diff(a, b).filter(function filterDiff(change) {
+        return (change.action !== 'added');
+    });
+    return (d.length === 0);
+}
+
+/*
+ * Given a name (arbitrary string) a string suitable for using as a User-Agent
+ * is returned.
+ */
+function makeUserAgent(name) {
+    assert.string(name, 'name');
+
+    return util.format('%s - %s/%d (%s)',
+        name || log.name,
+        os.hostname(),
+        process.pid,
+        process.argv[1]);
+}
+
+/*
+ * If called directly just hook a vminfo stream to stdout
+ */
+if (require.main === module) {
+    var _vs = new VminfodEventStream();
+
+    _vs.on('readable', function vminfodEventStreamReadable() {
+        var ev;
+
+        while ((ev = _vs.read()) !== null) {
+            console.log(JSON.stringify(ev));
+        }
+    });
+}
diff --git a/src/vm/node_modules/vminfod/vminfod.js b/src/vm/node_modules/vminfod/vminfod.js
new file mode 100644
index 00000000..3c78fada
--- /dev/null
+++ b/src/vm/node_modules/vminfod/vminfod.js
@@ -0,0 +1,2446 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * The primary function of this module is to mantain an up-to-date copy of:
+ *
+ *   1) the complete vmobj list
+ *   2) a vmload cache object.
+ *
+ * The vmload cache object will be maintained internally by this daemon while
+ * the vmobj list can be consumed from the HTTP interface:
+ *
+ *   - The complete vm list can be consumed at GET /vms
+ *   - A single vm can be consumed at GET /vms/UUID
+ *
+ * To use the daemon, you should do something like:
+ *
+ *  var vminfod = new Vminfod({log: log});
+ *  vminfod.start(callback);
+ *  vminfod.stop([callback]);
+ *  vminfod.on(<event type>, callback(data));
+ *
+ * Where the event types can be:
+ *
+ *  ready - emitted when vminfo has initialized after start()
+ *  end - emitted when vminfo has shutdown after stop()
+ *  create - emitted when a new vm is created
+ *  modify - emitted when an existing vm is modified
+ *  delete - emitted when an existing vm is deleted
+ *
+ * on 'ready' the callback will be called, passing the list of vmobjs as the
+ * first and only argument.
+ *
+ * on 'end' the callback will be called, without any arguments
+ *
+ * on 'create' the callback will be called, passing the newly created vmobj as
+ * the first and only argument.
+ *
+ * on 'modify' the callback will be called, passing the updated vmobj as the
+ * first argument, and a list of changes as the second argument.
+ *
+ * on 'delete' the callback will be called, passing the zonename of the vmobj
+ * as the first and only argument.
+ *
+ * Note: The main consumer of this module will be the daemon
+ * /usr/vm/sbin/vminfod, found under the SMF service
+ * system-smartdc-vminfod:default.
+ *
+ * To query this daemon as a client however, use the vminfod/client.js library.
+ *
+ * As a client, Events can be consumed through the webservice at GET /events.
+ * The client connection will be held open until the client explicitly closes
+ * the socket. Events will be streamed to the client in http chunks as
+ * newline-separated-JSON where each event will be a JSON object. When
+ * unwrapped, the 'type' attribute will indicate the event type. All relevant
+ * data to the event will be included in the JSON object.
+ *
+ * How this daemon works:
+ *
+ *   The tl;dr overview is that this module will listen for events within 3
+ *   broad categories: zone state, zone config files, and zfs datasets.
+ *   When an event is fired, we will delete portions of the cache object that
+ *   are relevant to the event, then ask vmload to fill in the holes with
+ *   getZoneData, which we can then update the vmobjs that were affected
+ *   by the change, and lastly inform any subscribed consumers of the specific
+ *   changes to the vmobj data.
+ *
+ *   This module is not necessarily concerned with the details of a vmobj -
+ *   meaning, the structure of the vmobj, where the data is derived, and how
+ *   the data is transformed are not the concern of this module. This module
+ *   will delegate that responsibility to the vmload modules. This module is
+ *   concerned with knowing when pieces of the cache object are likely
+ *   out-of-date, how to re-populate those pieces, and which vmobjs will be
+ *   affected by the change.
+ *
+ *   There a 3 broad event categories that are monitored via 2 event sources to
+ *   determine if a change has happened on a machine that *may* result in the
+ *   creation, modification, or deletion of a vm.
+ *
+ *     1. Sysevents (using sysevent-stream.js)
+ *
+ *       A. zpoolwatcher.js: watches ZFS sysevents for dataset modifications
+ *       B. zonewatcher.js: watches zone sysevents for zone modifications
+ *
+ *     2. File System Events (via event ports using fswatcher.js)
+ *     Each VM has 5 files that are watched for modifications
+ *
+ *       1. /etc/zones/<uuid>.xml
+ *       2. /zones/<uuid>/lastexited
+ *       3. /zones/<uuid>/config/tags.json
+ *       4. /zones/<uuid>/config/routes.json
+ *       5. /zones/<uuid>/config/metadata.json
+ *
+ *   At a routine interval, we will also force-refresh the cache and regenerate
+ *   the vmobj sets to ensure data integrity. This is because sysevents are
+ *   emitted "best-effort" from the kernel, so it is possible that this module
+ *   may be unaware of changes to a zfs dataset or a zanoe.  The refresh
+ *   interval will also do its best to run when the queue is idle, but will
+ *   eventually just force run if its taking too long (if the system is
+ *   particularly busy with zone or zfs operations).  When the refresh interval
+ *   is fired, we will first pause the event queue, then request a new cache
+ *   object. Once we have received a new cache object, we will "fastForward"
+ *   the queue to the current time, performing all modifications to our current
+ *   cache, as well as the new cache object received from the full load.  This
+ *   way, any events seen while the cacehe was being fully loaded from the
+ *   system will be accounted for in both objects (to eliminate any sort of
+ *   race). We will replace the current cache object with the new one if the
+ *   two cache objects are different.
+ *
+ *   Only if the two objects are different, we will iterate through all vmobjs
+ *   and generate a new vmobj from the new cache and report any deltas along the
+ *   way. Finally, after all vmobjs have been updated, we will resume the queue.
+ *
+ *   A new vmobj is created when a zone event is received for a uuid that we're
+ *   not currently watching, which will then register observers for relevant
+ *   config files.
+ *
+ *   A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
+ *   DELETE event. At this point, we will also remove all watchers that were
+ *   setup for that vmobj.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var http = require('http');
+var path = require('path');
+var url = require('url');
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var diff = require('/usr/vm/node_modules/diff');
+var getDatasets = require('/usr/vm/node_modules/vmload/vmload-datasets').
+    getDatasets;
+var getZoneRecords = require('/usr/vm/node_modules/vmload/vmload-zoneadm').
+    getZoneRecords;
+var hrtime = require('/usr/vm/node_modules/hrtime');
+var utils = require('/usr/vm/node_modules/utils');
+var libuuid = require('/usr/node/node_modules/uuid');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vmload = require('/usr/vm/node_modules/vmload');
+
+var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
+var Queue = require('/usr/vm/node_modules//queue').Queue;
+var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
+var ZoneWatcher = require('./zonewatcher').ZoneWatcher;
+var ZpoolWatcher = require('./zpoolwatcher').ZpoolWatcher;
+
+/*
+ * Files in /zones/<uuid>/config to watch
+ */
+var CONFIG_FILES = [
+    'metadata.json',
+    'routes.json',
+    'tags.json'
+];
+
+/*
+ * sysinfo(1M) cache file
+ */
+var SYSINFO_FILE = '/tmp/.sysinfo.json';
+
+/*
+ * The keys of this map (ie. "disks" and "nics") are keys to a VM's JSON
+ * payload that are:
+ * 1: Guaranteed to be arrays of objects (this is asserted and will throw
+ * if not true)
+ *
+ * The values (ie. "path" and "mac" respectively) are keys inside the objects
+ * inside the array that are used as the unique identifiers.  This helps
+ * diff.js determine what kind of changes are made to an object.
+ */
+var DIFF_MAP = {
+    disks: 'path',
+    nics: 'mac'
+};
+
+/*
+ * Default job timeout for the queue.  Each task enqueued will have 1 minute
+ * from the time it starts to finish processing.  On average, most tasks
+ * take less than 1 second - this is just a kill switch for a hanging task.
+ */
+var QUEUE_TASK_TIMEOUT = 1 * 60 * 1000;
+
+/*
+ * Default number of records to store for refresh errors and log messages.
+ */
+var DEFAULT_REFRESH_RECORDS = 5;
+
+/*
+ * Default zpool for zones
+ */
+var ZONES_ZPOOL = 'zones';
+
+/*
+ * Default interval timer to do a full system refresh of the vminfod cache.
+ */
+var DEFAULT_REFRESH_INTERVAL = 5 * 60 * 1000;
+
+/*
+ * How long to wait for the event queue to become idle before forcing a full
+ * refresh.
+ */
+var KILL_TIMER_WAIT = 5 * 60 * 1000;
+
+module.exports = Vminfod;
+function Vminfod(options) {
+    var self = this;
+
+    // global state/status - these are used primarily for debugging purposes
+    // and should be modified with the setState/setStatus functions
+    self.state = 'stopped';
+    self.status = 'initialized';
+
+    // consumers of the '/events' stream
+    self.events_listeners = {};
+
+    /*
+     * Structures to hold the raw data.
+     *
+     * The _tmp variants are used while the queue is paused and a full system
+     * refresh is being performed.  The full system refresh data will be stored
+     * in these variables, and then compared to the live data at the end of the
+     * refresh.  We store these globally so they can be modified during the
+     * queue fastForward portion of the "reset".
+     */
+    self.vm_data = {};
+    self.vm_data_tmp = undefined;
+    self.zone_vm_data = {};
+    self.zone_vm_data_tmp = {};
+
+    // the actual vmobjs held in memory
+    self.vmobjs = {};
+
+    // structures to hold the pre-serialized data - these are managed by the
+    // serialize* functions
+    self.vm_data_json = {};
+    self.vmobjs_json = {};
+
+    // configurable options
+    self.log = options.log;
+    assert(self.log, 'must provide a logger');
+    assert.optionalNumber(options.port, 'options.port');
+    assert.optionalArrayOfString(options.ips, 'options.ips');
+    assert.optionalNumber(options.refresh_interval, 'options.refresh_interval');
+
+    // set default ips and port
+    self.ips = options.ips || ['127.0.0.1'];
+    self.port = options.port || 9090;
+
+    // set default refresh interval for the periodic_timer
+    self.refresh_interval = options.refresh_interval
+        || DEFAULT_REFRESH_INTERVAL;
+
+    /*
+     * Keep a log of every time self.reset() finds differences from what is on
+     * the system and what is in vminfod.
+     */
+    self.refresh_log = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});
+
+    /*
+     * Sometimes, self.reset() can fail but we don't necessarily want to kill
+     * the process. Instead, store the errors in a log and expose them over
+     * /status.
+     */
+    self.refresh_errors = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});
+
+    /*
+     * The last time a full refresh was performed
+     */
+    self.last_refresh_time = null;
+
+    /*
+     * We need to create intermediate event listeners between self and
+     * clients subscribed to /events so we only have to JSON.stringify
+     * once per event, instead of once per client per event.
+     */
+    self.on('create', function vminfodVmCreated(vmobj) {
+        var data;
+        var json;
+
+        data = {
+            type: 'create',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid,
+            vm: vmobj
+        };
+
+        self.log.info({ev: data}, 'emitting "create" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('create-json', json);
+    });
+
+    self.on('modify', function vminfodVmModified(vmobj, changes) {
+        var data;
+        var json;
+
+        data = {
+            type: 'modify',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid,
+            vm: vmobj,
+            changes: changes
+        };
+
+        self.log.info({ev: data}, 'emitting "modify" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('modify-json', json);
+    });
+
+    self.on('delete', function vminfodVmDeleted(vmobj) {
+        var data;
+        var json;
+
+        data = {
+            type: 'delete',
+            date: new Date(),
+            zonename: vmobj.zonename,
+            uuid: vmobj.uuid
+        };
+
+        self.log.info({ev: data}, 'emitting "delete" event, %d VMs total',
+            Object.keys(self.vmobjs).length);
+
+        json = JSON.stringify(data);
+
+        self.emit('delete-json', json);
+    });
+}
+util.inherits(Vminfod, EventEmitter);
+
+/*
+ * Set the internal state value
+ *
+ * This, and setStatus below, are useful for tracking what vminfod is currently
+ * processing (or at least, what it shoud be).  These internal variables can
+ * be accessed over the GET /status interface, and each variable transition
+ * can be seen in the log file.
+ */
+Vminfod.prototype.setState = function setState(/* args */) {
+    var self = this;
+
+    var state = util.format.apply(this, arguments);
+
+    self.log.debug({
+        oldstate: self.state,
+        newstate: state
+    }, 'state changed from "%s" to "%s"', self.state, state);
+
+    self.state = state;
+};
+
+/*
+ * Set the internal status value, see setState for more information
+ */
+Vminfod.prototype.setStatus = function setStatus(/* args */) {
+    var self = this;
+
+    var status = util.format.apply(this, arguments);
+
+    self.log.debug({
+        oldstatus: self.status,
+        newstatus: status
+    }, 'status changed from "%s" to "%s"', self.status, status);
+
+    self.status = status;
+};
+
+/*
+ * start vminfod
+ */
+Vminfod.prototype.start = function start(callback) {
+    var self = this;
+
+    assert.func(callback, 'callback');
+
+    self.started_time = process.hrtime();
+    self.log.info('vminfod starting');
+
+    vasync.pipeline({funcs: [
+        // update state
+        function startSetInitialState(_, cb) {
+            self.setState('booting');
+            cb();
+        },
+        // init queue
+        function startInitQueue(_, cb) {
+            self.setStatus('initializing event queue');
+            var opts = {
+                workers: 1,
+                paused: true,
+                dedup: true,
+                idleTime: 1000,
+                log: self.log
+            };
+            self.event_queue = new Queue(opts);
+            self.event_queue.on('error', function queueError(err) {
+                self.log.debug({err: err}, 'ignoring queue error: %s',
+                    err.message);
+            });
+            cb();
+        },
+        // start global watchers
+        function startInitGlobalWatchers(_, cb) {
+            self.setStatus('starting global watchers');
+            self.startWatchers(cb);
+        },
+        // start vm watchers
+        function startInitVmWatchers(_, cb) {
+            self.setStatus('starting vm watchers');
+            self.startVmWatchers(cb);
+        },
+        // set vm_data
+        function startInitVmData(_, cb) {
+            self.setStatus('setting initial cache data');
+            self.setVmData(cb);
+        },
+        // set vmobjs data
+        function startInitVmobjs(_, cb) {
+            self.setStatus('setting initial vmobjs data');
+            self.setVmobjs(cb);
+        },
+        // store last "refresh" time
+        function startRefreshTime(_, cb) {
+            self.last_refresh_time = process.hrtime();
+            cb();
+        },
+        // resume queue
+        function startResumeQueue(_, cb) {
+            self.setStatus('resuming the event queue');
+            self.event_queue.resume();
+            cb();
+        },
+        // start http server
+        function startHTTPServer(_, cb) {
+            self.setStatus('starting http server');
+            self.startHTTPHandlers(cb);
+        },
+        // start refresh timers
+        function startInitRefreshTimers(_, cb) {
+            self.setStatus('starting refresh timers');
+            self.startTimers(cb);
+        }
+    ]}, function startPipelineDone(err) {
+        var delta = process.hrtime(self.started_time);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+
+        if (err) {
+            self.log.error({err: err}, 'failed to complete boot sequence');
+            callback(err);
+            return;
+        }
+
+        self.setState('running');
+        self.setStatus('working');
+        self.log.info('boot sequence complete, took %s', prettyDelta);
+        self.emit('ready', self.vmobjs);
+
+        callback();
+    });
+};
+
+/*
+ * setVmobjs() sets the initial vmobjs data
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will request vmobjs from vmload.getVmobjs, using the cache
+ * object set in vm_cache. The result will then be converted from an array
+ * into a hash where the key is the vm uuid and the value is the vmobj.
+ *
+ * called by .start()
+ *
+ */
+Vminfod.prototype.setVmobjs = function setVmobjs(callback) {
+    var self = this;
+
+    var opts = {
+        cache: self.vm_data,
+        log: self.log,
+        keepalive: true,
+        loadManually: true
+    };
+    vmload.getVmobjs(function vmloadGetVmobjsFilter(_, cb) {
+        cb(null, true);
+    }, opts, function vmloadGetVmobjsCallback(err, results) {
+        var i = 0;
+
+        if (err) {
+            self.log.error({err: err}, 'failed to vmload.getVmobjs: %s',
+                err.message);
+            callback(err);
+            return;
+        }
+
+        self.vmobjs = {};
+        results.forEach(function forEachVmobjs(vmobj) {
+            i++;
+            assert.object(vmobj, 'vmobj');
+            assert.uuid(vmobj.uuid, 'vmobj.uuid');
+            self.vmobjs[vmobj.zonename] = vmobj;
+        });
+
+        self.log.debug('setVmobjs %d VMs found', i);
+        callback();
+    });
+};
+
+/*
+ * setVmData() sets the initial vm_data
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will request a cache object from _loadVmData and set
+ * vm_data
+ *
+ */
+Vminfod.prototype.setVmData = function setVmData(callback) {
+    var self = this;
+
+    self._loadVmData(function loadVmDataCallback(err, cache) {
+        if (err) {
+            self.log.error('failed to set initial vm_data');
+            callback(err);
+            return;
+        }
+        self.log.debug('setting initial vm_data: %j', cache);
+        self.vm_data = cache;
+        callback();
+    });
+};
+
+/*
+ * Start any and all periodic timers needed by vminfod
+ *
+ * called by .start()
+ */
+Vminfod.prototype.startTimers = function startTimers(callback) {
+    var self = this;
+
+    assert(!self.periodic_timeout, 'timers already started');
+
+    function makeTimer(cb) {
+        self.periodic_timeout = setTimeout(function periodicTimeout() {
+            var started;
+            var killTimer;
+
+            if (self.event_queue.idle) {
+                self.log.debug(
+                    'event queue idle - starting full refresh immediately');
+                go();
+            } else {
+                self.log.debug('event queue busy - queueing full refresh');
+                started = process.hrtime();
+
+                /*
+                 * Set a kill switch so we don't potentially wait forever for
+                 * an idle event.
+                 */
+                killTimer = setTimeout(function killTimerTimeout() {
+                    self.log.warn('event queue idle timeout exceeded (%dms) - '
+                        + 'forcing refresh', KILL_TIMER_WAIT);
+                    self.event_queue.removeListener('idle', go);
+                    started = null;
+                    killTimer = null;
+                    go();
+                }, KILL_TIMER_WAIT);
+
+                self.event_queue.once('idle', go);
+            }
+
+            function go() {
+                var now;
+                var deltaPretty;
+
+                if (killTimer) {
+                    clearTimeout(killTimer);
+                    killTimer = null;
+                }
+
+                if (started) {
+                    now = process.hrtime();
+                    deltaPretty = hrtime.hrtimeDeltaPretty(now, started);
+
+                    self.log.debug('event queue now idle - took %s',
+                        deltaPretty);
+                }
+                refresh(function refreshDone(err) {
+                    /*
+                     * In the event of an error, we log it (both with bunyan
+                     * and to the refresh_errors log that is visible on `GET
+                     * /status`) and move on.
+                     *
+                     * There are legitmate situations that can cause "refresh"
+                     * to fail where we don't actually want vminfod to crash as
+                     * a result.  An example of this is doing a full
+                     * `self.reset` which loads all VMs off of the running
+                     * system using vmload.getVmobjs.  This function is
+                     * inherently racy as it first gets a list of all zone
+                     * UUIDs on the system *and then* does a load on each zone.
+                     * It's possible that in that time a zone that was seen
+                     * doing the full UUID list could have been deleted.  In
+                     * this situtation, `self.reset` will callback with an
+                     * error but that is not cause for us to stop vminfod when
+                     * running the periodic timer.  Instead, we just log it and
+                     * try again later.
+                     */
+                    if (err) {
+                        self.refresh_errors.write({
+                            err: err,
+                            time: process.hrtime()
+                        });
+                        self.log.error({err: err}, 'failed to refresh data');
+
+                    }
+
+                    makeTimer();
+                });
+            }
+        }, self.refresh_interval);
+
+        if (cb) {
+            cb();
+        }
+    }
+
+    function refresh(cb) {
+        self.log.info('full data refresh');
+        var started = process.hrtime();
+
+        vasync.pipeline({funcs: [
+            function refreshResetData(_, cb2) {
+                self.log.debug('full VM reset');
+                self.reset(cb2);
+            }, function refreshFindStaleFiles(_, cb2) {
+                self.log.debug('checking for stale files to unwatch');
+
+                var vms = Object.keys(self.vmobjs);
+                var files = Object.keys(self.fsw.watching).filter(
+                    function filterSysinfoFile(f) {
+
+                    // Ignore sysinfo since we always watch this file
+                    if (f === SYSINFO_FILE) {
+                        return false;
+                    }
+
+                    /*
+                     * Loop every VM on the system (the UUIDs).  If the UUID is
+                     * found inside the filename of the file being watched,
+                     * then we continue watching the file (filter it out of the
+                     * array). Any files left over are files being watched for
+                     * a VM that does not exist and can be unwatched.
+                     */
+                    return !(vms.some(function someVms(vm) {
+                        return (f.indexOf(vm) > -1);
+                    }));
+                });
+
+                if (files.length === 0) {
+                    self.log.debug('found 0 stale files');
+                    cb2();
+                    return;
+                }
+
+                self.log.error({files: files}, 'found %d stale files',
+                    files.length);
+
+                vasync.forEachPipeline({
+                    func: function refreshFswUnwatch(f, cb3) {
+                        self.fsw.unwatch(f, cb3);
+                    },
+                    inputs: files
+                }, cb2);
+            }
+        ]}, function refreshDone(err) {
+            var now = process.hrtime();
+            var deltaPretty = hrtime.hrtimeDeltaPretty(now, started);
+
+            self.log.debug('full data refresh took %s', deltaPretty);
+
+            self.last_refresh_time = now;
+            cb(err);
+        });
+    }
+
+    makeTimer(callback);
+};
+
+/*
+ * startWatchers() starts global watchers
+ *
+ * Arguments:
+ *   'callback' - will be called with (err)
+ *
+ * This function will:
+ *   1) Create a FsWatcher object
+ *   2) Watch for changes to the sysinfo cache file
+ *   3) Create a ZoneWatcher
+ *   4) Create a ZpoolWatcher
+ */
+Vminfod.prototype.startWatchers = function startWatchers(callback) {
+    var self = this;
+
+    vasync.pipeline({funcs: [
+        function startFsWatcher(_, cb) {
+            self.fsw = new FsWatcher({log: self.log, dedup: true});
+
+            self.fsw.on('event', function fswOnEvent(obj) {
+                self.handleFsEvent(obj);
+            });
+
+            self.fsw.once('ready', function fswOnReady(obj) {
+                self.log.debug('filesystem watcher ready');
+                cb();
+            });
+
+            self.fsw.start();
+        }, function startFsWatcherSysinfoWatcher(_, cb) {
+            self.fsw.watch(SYSINFO_FILE, cb);
+        }, function startZoneWatcher(_, cb) {
+            self.zonew = new ZoneWatcher({log: self.log});
+
+            self.zonew.on('event', function zonewOnEvent(obj) {
+                self.handleZoneEvent(obj);
+            });
+
+            self.zonew.once('ready', function fswOnReady() {
+                self.log.debug('zone watcher ready');
+                cb();
+            });
+        }, function startZpoolWatcher(_, cb) {
+            self.zpoolw = new ZpoolWatcher({log: self.log});
+
+            self.zpoolw.on('event', function zpoolwOnEvent(obj) {
+                self.handleZpoolEvent(obj);
+            });
+
+            self.zpoolw.once('ready', function zpoolwOnReady() {
+                self.log.debug('zpool watcher ready');
+                cb();
+            });
+        }
+    ]}, function startWatchersDone() {
+        self.log.info('global watchers ready');
+        callback();
+    });
+};
+
+/*
+ * startVmWatchers() starts the watchers for a VM
+ *
+ * Arguments:
+ *   'zonename' - a specific vm zonename to start watchers on
+ *   'callback' - will be called with (err)
+ *
+ *   'zonename' argument is optional, and when omitted will start watchers
+ *   for all vms.
+ */
+Vminfod.prototype.startVmWatchers =
+    function startVmWatchers(zonename, callback) {
+
+    var self = this;
+
+    if (typeof (zonename) === 'function') {
+        callback = zonename;
+        zonename = undefined;
+    }
+
+    // start watchers for a single VM
+    if (zonename) {
+        addVmFsWatches(zonename, callback);
+        return;
+    }
+
+    // start watchers for all VMs - since this function is ran before
+    // any cached data is gathered, we must gather the list of vms manually
+    var records;
+    vasync.pipeline({funcs: [
+        // load zone records
+        function startVmWatchersLoadZoneRecords(_, cb) {
+            var opts = {
+                log: self.log
+            };
+            getZoneRecords(null, opts,
+                function getZoneRecordsDone(err, _records) {
+
+                if (err) {
+                    self.log.debug({err: err}, 'failed to load zone records');
+                    cb(err);
+                    return;
+                }
+
+                records = _records;
+                cb();
+            });
+        },
+        // start watchers
+        function startVmWatchersAddVmWatchers(_, cb) {
+            vasync.forEachPipeline({
+                func: function startVmWatcherAddVmFsWatcher(uuid, cb2) {
+                    addVmFsWatches(records[uuid].zonename, cb2);
+                },
+                inputs: Object.keys(records)
+            }, function addVmFsWatcherDone(err, results) {
+                cb(err);
+            });
+        }
+    ]}, function startVmWatchersDone(err) {
+        if (err) {
+            self.log.error({err: err}, 'failed to start vm watchers');
+            callback(err);
+            return;
+        }
+
+        callback();
+    });
+
+
+    /*
+     * create fs watches for a given zone
+     */
+    function addVmFsWatches(zone, cb) {
+        var files = [
+            util.format('/etc/zones/%s.xml', zone),
+            util.format('/zones/%s/lastexited', zone)
+        ];
+        CONFIG_FILES.forEach(function forEachConfigFile(f) {
+            files.push(util.format('/zones/%s/config/%s', zone, f));
+        });
+
+        self.log.debug({files: files}, 'adding vm fs watchers for %s',
+            zone);
+
+        vasync.forEachPipeline({
+            func: function fswWatchFile(f, cb2) {
+                self.fsw.watch(f, cb2);
+            },
+            inputs: files
+        }, function fswWatchFileDone(err, results) {
+            self.log.debug({err: err},
+                'finished adding vm fs watchers for %s', zone);
+            cb(err);
+        });
+    }
+};
+
+
+/*
+ * Start the HTTP interface
+ *
+ * called by .start()
+ */
+Vminfod.prototype.startHTTPHandlers = function startHTTPHandlers(callback) {
+    var self = this;
+
+    vasync.forEachPipeline({
+        inputs: self.ips,
+        func: function startHTTPServer(ip, cb) {
+            http.createServer(handler).listen(self.port, ip,
+                function serverListening() {
+
+                self.log.debug('listening on http://%s:%d', ip, self.port);
+                cb();
+            });
+        }
+    }, callback);
+
+    // http handler
+    function handler(req, res) {
+        var args;
+        var c;
+        var url_parts;
+
+        url_parts = url.parse(req.url, true);
+        c = path.normalize(url_parts.pathname).split('/');
+        c.shift();
+
+        args = url_parts.query || {};
+        self.log.info({req: req}, 'HTTP request');
+
+        if (req.method !== 'GET') {
+            // Bad request
+            res.writeHead(400, {'Content-Type': 'application/json'});
+            res.end();
+        } else {
+            handleGet(c, args, req, res);
+        }
+    }
+
+    // handler specifically for GET requests
+    function handleGet(c, args, req, res) {
+        var ret;
+        var uuid;
+        var now;
+
+        switch (c[0]) {
+        case 'ping':
+            ret = {
+                ping: 'pong'
+            };
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(JSON.stringify(ret), 'utf-8');
+            break;
+        case 'status':
+            now = process.hrtime();
+            ret = {
+                pid: process.pid,
+                uptime: hrtime.hrtimeDeltaPretty(now, self.started_time),
+                memory: process.memoryUsage(),
+                state: self.state,
+                status: self.status,
+                numVms: Object.keys(self.vmobjs).length,
+                curDate: new Date(),
+                curTime: hrtime.hrtimeToString(now),
+                queue: self.event_queue.dump(),
+                lastRefresh: self.last_refresh_time ?
+                    hrtime.hrtimeDeltaPretty(now, self.last_refresh_time) :
+                    null,
+                refreshErrors:
+                    formatRefreshErrors(self.refresh_errors.records),
+                eventsListeners: formatEventsListeners(self.events_listeners)
+            };
+            if (args.full) {
+                ret.refreshLog = formatRefreshLog(self.refresh_log.records);
+                ret.fswatcher = self.fsw.dump();
+            }
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(JSON.stringify(ret), 'utf-8');
+            break;
+        case 'vms':
+            var zonename = c[1];
+
+            if (zonename) {
+                // requesting a vmobj with zonename
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    res.writeHead(404, {'Content-Type': 'application/json'});
+                    res.write('VM Not Found: ' + zonename);
+                    res.end();
+                } else {
+                    res.writeHead(200, {'Content-Type': 'application/json'});
+                    res.end(self.serializeVm(zonename), 'utf-8');
+                }
+                break;
+            }
+
+            // requesting the vmobj list
+            res.writeHead(200, {'Content-Type': 'application/json'});
+            res.end(self.serializeVms(), 'utf-8');
+            break;
+        case 'events':
+            uuid = libuuid.create();
+            ret = {
+                // currently vminfod listens on localhost only so
+                // the ip addresses are always the same
+                // ip: request.connection.remoteAddress,
+                userAgent: req.headers['user-agent'],
+                createdDate: new Date(),
+                createdTime: process.hrtime()
+            };
+            self.log.debug({uuid: uuid, ret: ret},
+                'new /events listener created');
+
+            res.writeHead(200, {'Content-Type': 'application/json'});
+
+            var on_create = function onCreate(json) {
+                res.write(json + '\n');
+            };
+            var on_modify = function onModify(json) {
+                res.write(json + '\n');
+            };
+            var on_delete = function onDelete(json) {
+                res.write(json + '\n');
+            };
+            var on_close = function onClose() {
+                res.end();
+                cleanup();
+            };
+
+            function cleanup() {
+                self.log.debug({uuid: uuid, ret: ret},
+                    '/events listener removed');
+                self.removeListener('create-json', on_create);
+                self.removeListener('modify-json', on_modify);
+                self.removeListener('delete-json', on_delete);
+                self.removeListener('close', on_close);
+                delete self.events_listeners[uuid];
+            }
+
+            self.on('create-json', on_create);
+            self.on('modify-json', on_modify);
+            self.on('delete-json', on_delete);
+            self.on('close', on_close);
+            self.events_listeners[uuid] = ret;
+
+            res.on('close', cleanup);
+
+            // let this client stay open forever
+            res.connection.setTimeout(0);
+
+            // let the client know it is subscribed
+            res.write(JSON.stringify({
+                type: 'ready',
+                date: ret.createdDate,
+                uuid: uuid,
+                vms: self.serializeVms()
+            }) + '\n');
+            break;
+        default:
+            res.writeHead(404, {'Content-Type': 'application/json'});
+            res.write('Unsupported URL Path');
+            res.end();
+            break;
+        }
+    }
+};
+
+/*
+ * Stop the vminfod daemon
+ */
+Vminfod.prototype.stop = function stop(callback) {
+    var self = this;
+
+    self.zonew.stop();
+    self.zpoolw.stop();
+
+    if (self.periodic_timer) {
+        clearTimeout(self.periodic_timer);
+        self.periodic_timer = null;
+    }
+
+    self.fsw.stop(function fswStopped() {
+        self.emit('end');
+
+        if (callback) {
+            callback();
+        }
+    });
+};
+
+
+/*
+ * stopVmWatchers() stops the watchers for a VM
+ *
+ * Arguments:
+ *   'zonename' - a specific vm zonename to stop watchers on
+ *   'callback' - will be called with (err)
+ *
+ *   'zonename' argument is optional, and when omitted will stop watchers
+ *   for all vms.
+ */
+Vminfod.prototype.stopVmWatchers = function stopVmWatchers(zonename, callback) {
+    var self = this;
+
+    if (typeof (zonename) === 'function') {
+        callback = zonename;
+        zonename = undefined;
+    }
+
+    // stop watchers for a single VM
+    if (zonename) {
+        removeVmFsWatches(zonename, callback);
+        return;
+    }
+
+    // stop watchers for all VMs
+    vasync.forEachPipeline({
+        func: removeVmFsWatches,
+        inputs: Object.keys(self.vmobjs)
+    }, function removeVmFsWatchesDone(err, results) {
+        callback(err);
+    });
+
+    /*
+     * remove fs watches for a given zone
+     */
+    function removeVmFsWatches(zone, cb) {
+        var files = [
+            util.format('/etc/zones/%s.xml', zone),
+            util.format('/zones/%s/lastexited', zone)
+        ];
+        CONFIG_FILES.forEach(function configFileForEach(f) {
+            files.push(util.format('/zones/%s/config/%s', zone, f));
+        });
+
+        self.log.debug({files: files}, 'removing vm fs watchers for %s',
+            zone);
+
+        vasync.forEachPipeline({
+            func: function FsWatcherUnwatchFile(f, cb2) {
+                self.fsw.unwatch(f, cb2);
+            },
+            inputs: files
+        }, function FsWatcherUnwatchFilesDone(err, results) {
+            self.log.debug({err: err},
+                'finished removing vm fs watchers for %s', zone);
+            cb(err);
+        });
+    }
+};
+
+/*
+ * Return a JSON serialized string for a given vm.  This will return
+ * a cached object, or generate the contents and cache the result.
+ *
+ * Returns undefined if the vm is not found
+ */
+Vminfod.prototype.serializeVm = function serializeVm(zonename) {
+    var self = this;
+
+    if (!self.vmobjs_json.hasOwnProperty(zonename)) {
+        self.vmobjs_json[zonename] = JSON.stringify(self.vmobjs[zonename]);
+    }
+
+    return self.vmobjs_json[zonename];
+};
+
+/*
+ * Return a JSON serialized string for all zones.
+ */
+Vminfod.prototype.serializeVms = function serializeVms() {
+    var self = this;
+
+    var json = '[';
+    var zones = Object.keys(self.vmobjs);
+
+    zones.forEach(function forEachZoneSerialize(zone, index) {
+        json += self.serializeVm(zone);
+
+        if (index < zones.length - 1) {
+            json += ',';
+        }
+    });
+
+    json += ']';
+
+    return json;
+};
+
+/*
+ * reset() hard reset the data to ensure integrity
+ *
+ * This function will:
+ *   1- pause the event queue
+ *   2- fetch new vm_data
+ *   3- fast-forward the event queue
+ *   4- compare datasets
+ *   5- replace vm_data with vm_data_tmp if the sets are different
+ *   6- refresh vmobjs if the sets are different
+ *   7- resume the event queue
+ */
+Vminfod.prototype.reset = function reset(callback) {
+    var self = this;
+
+    var old_vm_data;
+    var obj = {
+        started: process.hrtime(),
+        vmChanges: [],
+        cacheChanges: null
+    };
+
+    vasync.pipeline({funcs: [
+        // pause the queue
+        function resetPauseQueue(_, cb) {
+            self.setState('paused');
+            self.setStatus('pausing the event queue');
+            self.log.debug('%d VMs total', Object.keys(self.vmobjs).length);
+
+            self.event_queue.pause({timeout: 5 * 60 * 1000},
+                function queuePaused(err) {
+
+                if (err) {
+                    self.log.warn('failed to pause the queue: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
+        },
+        // fetch new data
+        function resetFetchNewData(_, cb) {
+            self.setStatus('fetching vm cache data');
+            self._loadVmData(function loadVmDataDone(err, results) {
+                if (err) {
+                    self.log.error('failed to fetch new vm_data');
+                    cb(err);
+                    return;
+                }
+
+                self.vm_data_tmp = results;
+                cb();
+            });
+        },
+        // fast-forward the queue
+        function resetFastForwardQueue(_, cb) {
+            var now = process.hrtime();
+            self.setStatus('fast-forwarding the queue to %j', now);
+            self.event_queue.fastForward(now, {timeout: 5 * 60 * 1000},
+                function queueFastForwarded(err) {
+
+                if (err) {
+                    self.log.warn('failed to fast-forward queue: %s',
+                        err.message);
+                    cb(err);
+                    return;
+                }
+
+                cb();
+            });
+        },
+        // compare/update vmobjs
+        function resetCompareVmobjSets(_, cb) {
+            self.setStatus('comparing vmobj sets');
+
+            var changes = diff(self.vm_data, self.vm_data_tmp);
+
+            // if changes are empty, we have nothing left to do
+            if (changes.length === 0) {
+                self.log.info('vmobj sets are in sync');
+                cb();
+                return;
+            }
+
+            self.log.warn({changes: changes}, 'vm_data and vm_data_tmp diff');
+
+            obj.cacheChanges = changes;
+
+            self.setStatus('synchronizing data');
+
+            // keep a temporary reference to compare against
+            old_vm_data = self.vm_data;
+
+            // replace the data with new
+            self.vm_data = self.vm_data_tmp;
+
+            vasync.pipeline({funcs: [
+                // create vmobjs we don't know about
+                function createNewVmobjs(__, cb2) {
+                    var new_objs = self.vm_data.zoneadm_objects;
+                    var keys = Object.keys(new_objs);
+
+                    vasync.forEachParallel({
+                        inputs: keys,
+                        func: function createNewVmobj(zonename, cb3) {
+                            var old_objs = old_vm_data.zoneadm_objects;
+                            if (old_objs.hasOwnProperty(zonename)) {
+                                cb3();
+                                return;
+                            }
+
+                            obj.vmChanges.push({
+                                zonename: zonename,
+                                action: 'create'
+                            });
+                            self.createVmobj(zonename, cb3);
+                        }
+                    }, cb2);
+                },
+                // delete vmobjs we shouldn't know about
+                function deleteOldVmobjs(__, cb2) {
+                    var old_objs = old_vm_data.zoneadm_objects;
+                    var keys = Object.keys(old_objs);
+
+                    vasync.forEachParallel({
+                        inputs: keys,
+                        func: function deleteOldVmobj(zonename, cb3) {
+                            var new_objs = self.vm_data.zoneadm_objects;
+                            if (new_objs.hasOwnProperty(zonename)) {
+                                cb3();
+                                return;
+                            }
+
+                            obj.vmChanges.push({
+                                zonename: zonename,
+                                action: 'delete'
+                            });
+                            self.deleteVmobj(zonename, cb3);
+                        }
+                    }, cb2);
+                },
+                // refresh the rest
+                function refreshModifiedVmobjs(__, cb2) {
+                    vasync.forEachParallel({
+                        inputs: Object.keys(self.vmobjs),
+                        func: function refreshModifiedVmobj(zone, cb3) {
+                            self.refreshVmobj(zone,
+                                function refreshVmobjDone(err, o) {
+
+                                var changeObj;
+
+                                if (o && (o.changed || o.deleted)) {
+                                    changeObj = {
+                                        zonename: zone,
+                                        action: o.deleted ? 'delete' : 'modify'
+                                    };
+                                    if (changeObj.action === 'modify') {
+                                        changeObj.changes = o.changes;
+                                    }
+
+                                    obj.vmChanges.push(changeObj);
+                                }
+
+                                cb3(err);
+                            });
+                        }
+                    }, cb2);
+                }
+            ]}, cb);
+        }
+    ]}, function resetDone(err) {
+        // always make sure vminfod goes back to a running state
+        self.setState('running');
+        self.setStatus('working');
+        self.vm_data_tmp = undefined;
+
+        var ended = process.hrtime();
+        var delta = hrtime.hrtimeDelta(ended, obj.started);
+        var prettyDelta = hrtime.prettyHrtime(delta);
+
+        if (obj.cacheChanges) {
+            obj.ended = ended;
+            obj.delta = delta;
+            obj.prettyDelta = prettyDelta;
+            self.refresh_log.write(obj);
+        }
+
+        self.log.debug({obj: obj}, 'self.reset() took %s: %d vms changed',
+            prettyDelta, obj.vmChanges.length);
+
+        self.log.info('resuming the event queue');
+        self.event_queue.resume();
+
+
+        callback(err);
+    });
+};
+
+/*
+ * loadVmData() loads a cache object from vmload.getZoneData
+ *
+ * Arguments:
+ *   'callback' - will be called with (err, cache)
+ *
+ * This function will load a cache object from vmload.getZoneData
+ * passing a nocache: true flag to ensure the cache object is generated
+ * from raw data.
+ *
+ */
+Vminfod.prototype._loadVmData = function _loadVmData(callback) {
+    var self = this;
+
+    var opts = {
+        log: self.log,
+        nocache: true,
+        keepalive: true
+    };
+    vmload.getZoneData(null, opts, function getZoneDataDone(err, cache) {
+        if (err) {
+            self.log.error({err: err}, 'failed vmload.getZoneData: %s',
+                err.message);
+            callback(err);
+            return;
+        }
+
+        callback(null, cache);
+    });
+};
+
+/*
+ * Called when a new VM is seen
+ *
+ * This will create all internal variables needed for the VM, as well as
+ * emit a "create" event
+ */
+Vminfod.prototype.createVmobj = function createVmobj(zonename, callback) {
+    var self = this;
+
+    var uuid;
+
+    if (self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.warn('createVmobj(%s) called for zone already known about',
+            zonename);
+        callback();
+        return;
+    }
+
+    vasync.pipeline({funcs: [
+        function createVmobjGetUUID(_, cb) {
+            /*
+             * Figure out the zone UUID from the zonename seen.  If the
+             * zonename is a UUID, assume that it is the zones UUID and skip
+             * the call to getZoneRecords.
+             */
+            if (utils.isUUID(zonename)) {
+                uuid = zonename;
+                cb();
+                return;
+            }
+
+            var opts = {
+                log: self.log
+            };
+            getZoneRecords(zonename, opts,
+                function getZoneRecordsDone(err, records) {
+
+                if (err) {
+                    self.log.debug({err: err}, 'failed to getZoneRecords(%s)',
+                        zonename);
+                    cb(err);
+                    return;
+                }
+
+                var keys = Object.keys(records);
+
+                assert.equal(keys.length, 1, 'Only 1 record found');
+
+                uuid = keys[0];
+
+                self.log.warn('VM zonename "%s" does not match uuid "%s"',
+                    zonename, uuid);
+
+                cb();
+            });
+        }, function createVmobjAssertUUID(_, cb) {
+            assert.uuid(uuid, 'uuid');
+
+            self.log.debug({uuid: uuid, zonename: zonename},
+                'createVmobj zonename: %s -> uuid: %s', zonename, uuid);
+
+            cb();
+        }, function createVmobjGetZoneData(_, cb) {
+            var opts = {
+                log: self.log,
+                keepalive: true
+            };
+            vmload.getZoneData(uuid, opts, function getZoneDataDone(err, res) {
+                if (err) {
+                    self.log.error('failed to getZoneData(%s): %s',
+                        uuid, err.message);
+                    cb(err);
+                    return;
+                }
+
+                if (self.vm_data_tmp !== undefined)
+                    self.zone_vm_data_tmp[zonename] = res;
+                self.zone_vm_data[zonename] = res;
+
+                cb();
+            });
+        }, function createVmobjMergeVmDatasets(_, cb) {
+            self.mergeZoneVmDatasets(zonename);
+            cb();
+        }, function createVmobjGetVmobj(_, cb) {
+            vasync.forEachParallel({
+                inputs: self.vmDatasets(),
+                func: function getVmobj(vm_data, cb2) {
+                    var opts = {
+                        log: self.log,
+                        cache: vm_data,
+                        keepalive: true,
+                        loadManually: true
+                    };
+                    vmload.getVmobj(uuid, opts,
+                        function getVmobjDone(err2, vmobj) {
+
+                        if (err2) {
+                            self.log.error('failed to getVmobj(%s): %s',
+                                uuid, err2.message);
+                            cb2(err2);
+                            return;
+                        }
+
+                        if (self.vmobjs.hasOwnProperty(zonename)) {
+                            self.log.error('vmobj already created for %s',
+                                zonename);
+                            cb2();
+                            return;
+                        }
+
+                        assert.object(vmobj, 'vmobj');
+                        assert.uuid(vmobj.uuid, 'vmobj.uuid');
+
+                        self.vmobjs[zonename] = vmobj;
+                        self.startVmWatchers(zonename,
+                            function startVmWatchersDone(err) {
+
+                            self.log.info('started watching %s', zonename);
+                            self.emit('create', vmobj);
+                            cb2();
+                        });
+                    });
+                }
+            }, cb);
+        }
+    ]}, function createVmobjDone(err) {
+        if (err) {
+            /*
+             * We ignore any errors here as they will be rectified when the
+             * periodic timer runs.
+             */
+            self.log.error({err: err}, 'createVmobj(%s) (uuid: %s)',
+                zonename, uuid);
+        }
+        callback();
+    });
+};
+
+/*
+ * Called when a VM is deleted
+ *
+ * This will remove all internal variables needed by the VM as well as emit a
+ * "delete" event
+ */
+Vminfod.prototype.deleteVmobj = function deleteVmobj(zonename, callback) {
+    var self = this;
+
+    if (!self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.warn('deleteVmobj(%s) called for non-existent zone',
+            zonename);
+        callback();
+        return;
+    }
+
+    var obj = {
+        zonename: zonename,
+        uuid: self.vmobjs[zonename].uuid
+    };
+    assert.uuid(obj.uuid, 'obj.uuid for: ' + zonename);
+
+    vasync.pipeline({funcs: [
+        // delete vmobj
+        function deleteVmobjRemoveCache(_, cb) {
+            delete (self.vmobjs)[zonename];
+            delete (self.vmobjs_json)[zonename];
+            cb();
+        },
+        // clean vm_data
+        function deleteVmobjCleanVmData(_, cb) {
+            self.vmDatasets().forEach(function forEachVmDataset(data) {
+                for (var key in data) {
+                    if (data[key].hasOwnProperty(zonename)) {
+                        delete (data[key])[zonename];
+                    }
+                }
+            });
+            cb();
+        },
+        // unregister events
+        function deleteVmobjStopWatchers(_, cb) {
+            self.stopVmWatchers(zonename, cb);
+        }
+    ]}, function deleteVmobjDone(err) {
+        if (err) {
+            self.log.error({err: err}, 'deleteVmobj(%s)', zonename);
+            /*
+             * If this fails we keep going since the periodic timer refresh
+             * will handle cleaning up any stray files that haven't been
+             * unwatched.
+             */
+        }
+        self.log.info('stopped watching %s', zonename);
+        self.emit('delete', obj);
+        callback();
+    });
+};
+
+/*
+ * refreshVmobj() refreshes the cached vmobj and reports any changes
+ *
+ * Process:
+ *     1) refresh the vm_data cache by calling vmload.getZoneData
+ *     2) request a new vmobj by calling vmload.getVmobj
+ *     3) analyze vmobj delta
+ *     4) if different:
+ *       4a) replace the vmobj with the new vmobj
+ *       4b) log the delta
+ *       4c) inform any subscribers of the delta
+ */
+Vminfod.prototype.refreshVmobj =
+    function refreshVmobj(zonename, vm_datasets, callback) {
+
+    var self = this;
+
+    var ret = {
+        changed: false,
+        deleted: false,
+        changes: []
+    };
+
+    if (typeof (vm_datasets) === 'function') {
+        callback = vm_datasets;
+        self.cloneVmDatasets(zonename);
+        vm_datasets = self.vmDatasets(zonename);
+    }
+
+    // short-circuit if this vmobj doesn't exist
+    if (!self.vmobjs.hasOwnProperty(zonename)) {
+        self.log.debug('cannot refresh vmobj, doesn\'t exist');
+        self.resetVmDatasets(zonename);
+        callback(null, ret);
+        return;
+    }
+
+    var vmobj;
+    vasync.pipeline({funcs: [
+        // refresh vm_data cache
+        function refreshVmobjRefreshZoneData(_, cb) {
+            self.log.debug('refreshing zoneData for %s', zonename);
+            vasync.forEachParallel({
+                inputs: vm_datasets,
+                func: function getZoneData(vm_data, cb2) {
+                    var opts = {
+                        log: self.log,
+                        cache: vm_data,
+                        keepalive: true
+                    };
+                    vmload.getZoneData(zonename, opts,
+                        function getZoneDataDone(err, cache) {
+
+                        /*
+                         * We don't care about cache here because we provided a
+                         * cache object that was transformed by reference. So,
+                         * cache in this case is just a reference to vm_data,
+                         * which we already store globally. The idea here is
+                         * that we just fill in the holes that we previously
+                         * created.
+                         */
+
+                        if (err) {
+                            self.log.error({err: err},
+                                'failed to refresh vmobj %s: getZoneData %s',
+                                zonename, err.message);
+
+                            if (err.code === 'ENOENT'
+                                && err.message.
+                                match(/No such zone configured$/)) {
+
+                                ret.deleted = true;
+                            }
+
+                            cb2(err);
+                            return;
+                        }
+
+                        cb2();
+                    });
+                }
+            }, cb);
+        },
+        // merge zone_vm_objs
+        function refreshVmobjMergeZoneDataset(_, cb) {
+            self.mergeZoneVmDatasets(zonename);
+            cb();
+        },
+        // request a new vmobj
+        function refreshVmobjRequestNewVmobj(_, cb) {
+            self.log.debug('requesting new vmobj for %s', zonename);
+            var opts = {
+                log: self.log,
+                keepalive: true,
+                cache: self.vm_data,
+                loadManually: true
+            };
+            vmload.getVmobj(zonename, opts,
+                function getVmobjDone(err, _vmobj) {
+
+                if (err) {
+                    self.log.error({err: err},
+                        'unable to refresh vmobj for %s, failed getVmobj',
+                        zonename);
+
+                    if (err.code === 'ENOENT'
+                        && err.message.match(/No such zone configured$/)) {
+
+                        ret.deleted = true;
+                    }
+
+                    cb(err);
+                    return;
+                }
+
+                vmobj = _vmobj;
+                cb();
+            });
+        },
+        // analyze delta, update live copy
+        function refreshVmobjAnalyzeDelte(_, cb) {
+            var changes;
+            try {
+                changes = diff(self.vmobjs[zonename], vmobj, {
+                    map: DIFF_MAP
+                });
+            } catch (err) {
+                self.log.error({
+                    from: self.vmobjs[zonename],
+                    to: vmobj,
+                    err: err},
+                    'failed to calculate object diff');
+                throw err;
+            }
+
+            if (changes.length > 0) {
+                self.vmobjs[zonename] = vmobj;
+                delete (self.vmobjs_json[zonename]);
+                ret.changed = true;
+                ret.changes = changes;
+                self.emit('modify', vmobj, changes);
+            }
+
+            cb();
+        }
+    ]}, function refreshVmobjDone(err) {
+        if (ret.deleted) {
+            assert(err, 'error not set when ret.deleted');
+            delete ret.changes;
+
+            self.log.debug({uuid: zonename},
+                'marking %s as deleted', zonename);
+
+            self.deleteVmobj(zonename, function deleteVmobjDone(err2) {
+                if (err2) {
+                    self.log.error({uuid: zonename, err: err2},
+                        'error marking %s as deleted',
+                        zonename);
+                } else {
+                    self.log.debug({uuid: zonename},
+                        'successfully marked %s as deleted',
+                        zonename);
+                }
+
+                callback(err2, ret);
+            });
+            return;
+        }
+
+        callback(err, ret);
+    });
+};
+
+/*
+ * return the active data objects for a given zone (if zonename is set)
+ * or for all zones.
+ */
+Vminfod.prototype.vmDatasets = function vmDatasets(zonename) {
+    var self = this;
+    var ret = [];
+
+    if (zonename) {
+        ret.push(self.zone_vm_data[zonename]);
+        if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+            ret.push(self.zone_vm_data_tmp[zonename]);
+        }
+    } else {
+        ret.push(self.vm_data);
+        if (self.vm_data_tmp !== undefined) {
+            ret.push(self.vm_data_tmp);
+        }
+    }
+
+    return (ret);
+};
+
+/*
+ * remove the given zone from the internal zone data
+ */
+Vminfod.prototype.resetVmDatasets = function resetVmDatasets(zonename) {
+    var self = this;
+
+    if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+        delete (self.zone_vm_data_tmp)[zonename];
+    }
+
+    if (self.zone_vm_data.hasOwnProperty(zonename)) {
+        delete (self.zone_vm_data)[zonename];
+    }
+};
+
+/*
+ * copy a single zone's information from the "all zones" cache to an
+ * individual cache specific to the zone
+ */
+Vminfod.prototype.cloneVmDatasets = function cloneVmDatasets(zonename) {
+    var self = this;
+
+    function cloneVmDataset(from, to) {
+        Object.keys(from).forEach(function cloneForEach(key) {
+            switch (key) {
+            case 'dataset_objects':
+            case 'sysinfo':
+                to[key] = from[key];
+                break;
+            default:
+                if (!to.hasOwnProperty(key)) {
+                    to[key] = {};
+                }
+                if (from[key].hasOwnProperty(zonename)) {
+                    to[key][zonename] = from[key][zonename];
+                }
+                break;
+            }
+        });
+    }
+
+    if (self.vm_data_tmp !== undefined) {
+        self.zone_vm_data_tmp[zonename] = {};
+        cloneVmDataset(self.vm_data_tmp, self.zone_vm_data_tmp[zonename]);
+    }
+
+    self.zone_vm_data[zonename] = {};
+    cloneVmDataset(self.vm_data, self.zone_vm_data[zonename]);
+};
+
+/*
+ * take a zones specific information and put it in the "all zones" cache, as
+ * well as clear the individual zones cache
+ */
+Vminfod.prototype.mergeZoneVmDatasets = function mergeZoneVmDatasets(zonename) {
+    var self = this;
+
+    /*
+     * The rationale here is to iterate through all of the keys in the from
+     * object and check for a zonename key. If it exists, copy it over. Then
+     * we remove any objects containing the zonename key in the to object
+     * that aren't in the from object, to ensure we don't leave any cruft.
+     */
+    function mergeVmDataset(from, to) {
+        Object.keys(from).forEach(function mergeForEach(key) {
+            if (from[key].hasOwnProperty(zonename)) {
+                to[key][zonename] = from[key][zonename];
+            } else {
+                if (to[key].hasOwnProperty(zonename)) {
+                    delete (to[key])[zonename];
+                }
+            }
+        });
+    }
+
+    /*
+     * Any time a point of data has been merged, we also need to clear
+     * the cached JSON for this data. The JSON will later be generated
+     * and cached as needed by incoming requests.
+     */
+    function clearCache(from) {
+        Object.keys(from).forEach(function clearForEach(key) {
+            if (from[key].hasOwnProperty(zonename)
+                && self.vm_data_json.hasOwnProperty(key)
+                && self.vm_data_json[key].hasOwnProperty(zonename)) {
+
+                delete (self.vm_data_json[key])[zonename];
+            }
+        });
+    }
+
+    if (self.vm_data_tmp !== undefined
+        && self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
+
+        mergeVmDataset(self.zone_vm_data_tmp[zonename], self.vm_data_tmp);
+        clearCache(self.zone_vm_data_tmp[zonename]);
+    }
+
+    if (self.zone_vm_data.hasOwnProperty(zonename)) {
+        mergeVmDataset(self.zone_vm_data[zonename], self.vm_data);
+        clearCache(self.zone_vm_data[zonename]);
+    }
+
+    self.resetVmDatasets(zonename);
+};
+
+/*
+ * poke holes in cache objects for a specific zone
+ */
+Vminfod.prototype.invalidateZoneDataCache =
+    function invalidateZoneDataCache(zonename, vm_datasets, contexts) {
+
+    vm_datasets.forEach(function invalidateForEach(data) {
+        contexts.forEach(function contextForEach(context) {
+            if (!data.hasOwnProperty(context))
+                return;
+
+            if (data[context].hasOwnProperty(zonename))
+                delete (data[context])[zonename];
+
+            if (Object.keys(data[context]).length === 0)
+                delete data[context];
+        });
+    });
+};
+
+/*
+ * handleZoneEvent() is a callback for a ZoneWatcher
+ *
+ * Process:
+ *
+ *   First we extract the zonename property from the event, then see if we
+ *   have any vmobjs registered with that zonename. If not, then this must
+ *   be a vm create, which we will:
+ *     1) fetch the vmobj from vmload.getVmobj
+ *     2) register observers
+ *     3) inform subscribers of the new vmobj
+ *   If this is a vm that we already know about, we will:
+ *     1) invalidate the relevant pieces of the vm_data
+ *     2) refresh the vmobj by calling refreshVmobj
+ */
+Vminfod.prototype.handleZoneEvent = function handleZoneEvent(obj) {
+    var self = this;
+
+    assert.object(obj, 'obj');
+    assert.string(obj.zonename, 'obj.zonename');
+
+    var zonename = obj.zonename;
+    var meta = util.format('zonename: %s newstate: %s',
+        zonename, obj.newstate);
+    var vm_datasets;
+
+    self.log.debug({obj: obj}, 'handleZoneEvent: %s', meta);
+
+    self.event_queue.enqueue({
+        description: 'handle zone event - zonename: ' + zonename,
+        timeout: QUEUE_TASK_TIMEOUT,
+        func: function handleZoneEventTask(extras, callback) {
+            if (!self.vmobjs.hasOwnProperty(zonename)) {
+                // a new vm!
+                self.createVmobj(zonename, callback);
+                return;
+            }
+
+            self.cloneVmDatasets(zonename);
+            vm_datasets = self.vmDatasets(zonename);
+
+            // remove pieces of the cache that might have been affected
+            var contexts = [
+                'last_modified',
+                'pids',
+                'zoneadm_objects',
+                'zonexml_objects',
+                'zoneinfo_objects'
+            ];
+
+            self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+            self.refreshVmobj(zonename, vm_datasets, callback);
+        }
+    });
+};
+
+/*
+ * handleFsEvent() is a callback for a FsWatcher
+ */
+Vminfod.prototype.handleFsEvent = function handleFsEvent(obj) {
+    var self = this;
+
+    var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
+    var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
+    var lastexit_re = /\/zones\/(.+)\/lastexited/;
+    var contexts;
+    var matches;
+    var meta;
+    var vm_datasets;
+    var zonename;
+
+    assert.object(obj, 'obj');
+    assert.string(obj.pathname, 'obj.pathname');
+
+    meta = util.format('pathname: %s (%s)',
+        obj.pathname, obj.changes || obj.type);
+
+    self.log.debug({obj: obj}, 'handleFsEvent: %s', meta);
+
+    // zone XML file
+    if ((matches = obj.pathname.match(zonexml_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle zonexml fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function handleZoneXMLEventTask(extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    extras.log.debug('vmobj doesn\'t exist for %s',
+                        zonename);
+                    callback();
+                    return;
+                }
+
+                switch (obj.type) {
+                case 'delete':
+                    // delete the zone from the cache
+                    extras.log.debug('%s deleted', obj.pathname);
+                    self.deleteVmobj(zonename, callback);
+                    break;
+                case 'change':
+                    extras.log.debug('%s modified', obj.pathname);
+                    self.cloneVmDatasets(zonename);
+                    vm_datasets = self.vmDatasets(zonename);
+
+                    // clear the missing pieces and refresh
+                    contexts = [
+                        'last_modified',
+                        'zonexml_objects',
+                        'zoneinfo_objects'
+                    ];
+
+                    self.invalidateZoneDataCache(zonename, vm_datasets,
+                        contexts);
+                    self.refreshVmobj(zonename, vm_datasets, callback);
+                    break;
+                default:
+                    extras.log.warn({obj: obj},
+                        'unhandled fs change type "%s"',
+                        obj.type);
+                    callback();
+                    break;
+                }
+            }
+        });
+
+    // zone metadata file
+    } else if ((matches = obj.pathname.match(metadata_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle metadata fs update - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function handleMetadataEventTask(extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    extras.log.debug('vmobj doesn\'t exist for %s',
+                        zonename);
+                    callback();
+                    return;
+                }
+
+                self.cloneVmDatasets(zonename);
+                vm_datasets = self.vmDatasets(zonename);
+
+                // clear the missing pieces and refresh
+                contexts = [
+                    'last_modified',
+                    'json_objects'
+                ];
+
+                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+                self.refreshVmobj(zonename, vm_datasets, callback);
+            }
+        });
+    // zone lastexited file
+    } else if ((matches = obj.pathname.match(lastexit_re))) {
+        zonename = matches[1];
+
+        self.event_queue.enqueue({
+            description: 'handle lastexit fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function handleLastExitEventTask(extras, callback) {
+                // short-circuit if this vmobj doesn't exist
+                if (!self.vmobjs.hasOwnProperty(zonename)) {
+                    self.log.debug('vmobj doesn\'t exist for ' + zonename);
+                    callback();
+                    return;
+                }
+
+                self.cloneVmDatasets(zonename);
+                vm_datasets = self.vmDatasets(zonename);
+
+                // clear the missing pieces and refresh
+                contexts = [
+                    'last_modified',
+                    'last_exited'
+                ];
+
+                self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
+                self.refreshVmobj(zonename, vm_datasets, callback);
+            }
+        });
+
+    // sysinfo
+    } else if (obj.pathname === SYSINFO_FILE) {
+        self.event_queue.enqueue({
+            description: 'handle sysinfo fs change - ' + meta,
+            timeout: QUEUE_TASK_TIMEOUT,
+            func: function handleSysinfoEventTask(extras, callback) {
+                vasync.forEachParallel({
+                    inputs: self.vmDatasets(),
+                    func: function getZoneData(data, cb) {
+                        if (data.hasOwnProperty('sysinfo')) {
+                            delete data.sysinfo;
+                        }
+
+                        var opts = {
+                            log: extras.log,
+                            cache: data,
+                            keepalive: true
+                        };
+                        vmload.getZoneData(null, opts,
+                            function getZoneDataDone(err, cache) {
+
+                            if (err) {
+                                extras.log.error('failed to refresh '
+                                    + 'sysinfo, failed to getZoneData');
+                            }
+
+                            cb();
+                        });
+                    }
+                }, callback);
+            }
+        });
+    } else {
+        self.log.warn('unhandled event for file: %s', obj.pathname);
+    }
+};
+
+/*
+ * handleZpoolEvent() is a callback for a zpool watcher
+ *
+ * Process:
+ *
+ *   When action is clone or create:
+ *     - fetch zpool data
+ *     - merge into vm_cache
+ *     - refresh vmobj
+ *
+ *   When action is set:
+ *     - unset vm_data pieces
+ *     - fetch zpool data
+ *     - merge into vm_cache
+ *     - refresh vmobj
+ *
+ *   When action is destroy:
+ *     - unset vm_data
+ *     - refresh vmobj
+ *
+ */
+Vminfod.prototype.handleZpoolEvent = function handleZpoolEvent(obj) {
+    var self = this;
+    var action;
+    var description;
+    var sections = ['datasets', 'mountpoints', 'snapshots'];
+    var name = obj.dsname;
+    var _s = name.split('@');
+    var dsname = _s[0];
+    var snapname = _s[1];
+    var parts;
+    var uuid;
+    var zonepath;
+    var meta = util.format('dsname: %s action: %s %s',
+        obj.dsname, obj.action, obj.extras).trim();
+
+    self.log.debug({obj: obj}, 'handleZpoolEvent: %s', meta);
+
+    /*
+     * break the incoming zfs dataset into an array
+     * ex => ['zones', '<uuid>', 'config']
+     */
+    parts = dsname.split('/');
+    if (parts[1]) {
+        /*
+         * Attempt to extract a UUID from the second part.  This will succeed
+         * for KVM instances (for example) that have a dataset like
+         * /zones/<uuid>-disk0.
+         */
+        uuid = extractUUID(parts[1]);
+    }
+
+    /*
+     * If the dataset name matches "/zones/<uuid>" exactly we use that as the
+     * zonepath argument to getDatasets.  Otherwise, we use the parent dataset.
+     */
+    if (parts[0] === ZONES_ZPOOL && parts[1] === uuid && !parts[2]) {
+        zonepath = dsname;
+    } else {
+        zonepath = path.dirname(dsname);
+    }
+
+    /*
+     * Based on the "action" seen from the ZFS sysevent, we determine ahead of
+     * time what kind of action we will need to take as a response.  By doing
+     * this we can dedup the tasks pushed to the queue, because while the ZFS
+     * sysevents might differ, the actions we take as a response may be the
+     * same, in which case they only need to be done once.
+     */
+    switch (obj.action) {
+    case 'clone':
+    case 'create':
+    case 'snapshot':
+        action = 'fetchAndCopy';
+        break;
+    case 'clone swap': // rollback
+    case 'set':
+    case 'hold':
+    case 'release':
+    case 'rename':
+    case 'finish receiving':
+        action = 'fetchExpireAndCopy';
+        break;
+    case 'destroy':
+        action = 'expire';
+        break;
+    case 'receive':
+        // do nothing
+        self.log.debug('ignoring action: %s', obj.action);
+        return;
+    default:
+        self.log.fatal('unknown action: %s', obj.action);
+        return;
+    }
+    description = util.format('dsname: %s action: %s', obj.dsname, action);
+
+    function expire() {
+        function expireObjects(ds_objects) {
+            sections.forEach(function forEachSection(section) {
+                if (!ds_objects.hasOwnProperty(section)) {
+                    return;
+                }
+
+                switch (section) {
+                case 'mountpoints':
+                    for (var key in ds_objects[section]) {
+                        if (ds_objects[section][key] === name) {
+                            delete (ds_objects[section])[key];
+                        }
+                    }
+                    break;
+                default:
+                    if (ds_objects[section].hasOwnProperty(name)) {
+                        delete (ds_objects[section])[name];
+                    }
+                    break;
+                }
+
+                if (snapname && section === 'snapshots') {
+                    // remove the snapshot here as well
+                    if (ds_objects[section].hasOwnProperty(dsname)) {
+                        ds_objects[section][dsname] =
+                            ds_objects[section][dsname].filter(
+                            function filterSnap(o) {
+
+                            return o.snapname !== snapname;
+                        });
+                    }
+                }
+            });
+        }
+
+        self.vmDatasets().forEach(function forEachDatasetExpire(data) {
+            expireObjects(data.dataset_objects);
+        });
+
+        if (self.vm_data_json.hasOwnProperty('dataset_objects')) {
+            expireObjects(self.vm_data_json.dataset_objects);
+        }
+    }
+
+    function fetch(datasetObj, cb) {
+        var opts = {
+            log: self.log,
+            dataset: name
+        };
+        getDatasets(datasetObj, opts, function getDatasetsDone(err, results) {
+            if (err) {
+                self.log.warn('failed to fetch datasets');
+            }
+            cb(err, results);
+        });
+    }
+
+    function copy(cache) {
+        self.vmDatasets().forEach(function forEachDateset(data) {
+            sections.forEach(function forEachSection(section) {
+                for (var key in cache[section]) {
+                    if (!data.hasOwnProperty('dataset_objects')) {
+                        data.dataset_objects = {};
+                    }
+                    if (!data.dataset_objects.hasOwnProperty(section)) {
+                        data.dataset_objects[section] = {};
+                    }
+                    data.dataset_objects[section][key] = cache[section][key];
+                }
+            });
+        });
+    }
+
+    self.event_queue.enqueue({
+        description: 'handle zfs event - ' + description,
+        timeout: QUEUE_TASK_TIMEOUT,
+        func: function handleZfsEventTask(extras, cb) {
+            var datasetObj = {};
+            if (zonepath !== '.') {
+                datasetObj.zonepath = util.format('/%s', zonepath);
+            }
+
+            switch (action) {
+            case 'fetchAndCopy':
+                fetch(datasetObj, function fetchAndCopyDone(err, cache) {
+                    if (err) {
+                        finish();
+                        return;
+                    }
+                    copy(cache);
+                    finish();
+                });
+                return;
+            case 'fetchExpireAndCopy':
+                fetch(datasetObj, function fetchExpireAndDone(err, cache) {
+                    if (err) {
+                        finish();
+                        return;
+                    }
+                    expire();
+                    copy(cache);
+                    finish();
+                });
+                return;
+            case 'expire':
+                expire();
+                finish();
+                break;
+            default:
+                extras.log.fatal('unknown action: %s', obj.action);
+                finish();
+                break;
+            }
+
+            function finish() {
+                if (!uuid) {
+                    cb();
+                    return;
+                }
+                // if we happen to grab an image uuid here,
+                // the refreshVmobj will return immediately
+                extras.log.debug('refreshing vmobj %s after zfs event', uuid);
+
+                self.refreshVmobj(uuid, cb);
+            }
+        }
+    });
+};
+
+/*
+ * Extract a (the first) UUID from a string
+ */
+function extractUUID(s) {
+    var uuid_re = new RegExp('('
+        + '[a-f0-9]{8}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{4}-'
+        + '[a-f0-9]{12}'
+        + ')'
+    );
+    var match = uuid_re.exec(s);
+
+    return match && match[1];
+}
+
+function formatEventsListeners(evls) {
+    var now = process.hrtime();
+    var ret = {};
+
+    assert.object(evls, 'evls');
+
+    Object.keys(evls).forEach(function forEachListener(uuid) {
+        var evl = evls[uuid];
+
+        ret[uuid] = {
+            userAgent: evl.userAgent,
+            createdTime: hrtime.hrtimeToString(evl.createdTime),
+            createdDate: evl.createdDate,
+            createdAgo: hrtime.hrtimeDeltaPretty(now, evl.createdTime)
+        };
+    });
+
+    return ret;
+}
+
+function formatRefreshErrors(refreshErrors) {
+    var now = process.hrtime();
+    var ret;
+
+    assert.arrayOfObject(refreshErrors, 'refreshErrors');
+
+    ret = refreshErrors.map(function forEachRefreshError(re) {
+        var o = {
+            err: re.err.message,
+            time: hrtime.hrtimeToString(re.time),
+            ago: hrtime.hrtimeDeltaPretty(now, re.time)
+        };
+
+        return o;
+    });
+
+    return ret;
+}
+
+function formatRefreshLog(refreshLog) {
+    assert.arrayOfObject(refreshLog, 'refreshLog');
+
+    var now = process.hrtime();
+    var ret;
+
+    ret = refreshLog.map(function forEachRefreshLog(rl) {
+        var o = {
+            cacheChanges: rl.cacheChanges,
+            vmChanges: rl.vmChanges,
+            started: hrtime.hrtimeToString(rl.started),
+            ended: hrtime.hrtimeToString(rl.ended),
+            took: rl.prettyDelta,
+            endedAgo: hrtime.hrtimeDeltaPretty(now, rl.ended)
+        };
+
+        return o;
+    });
+
+    return ret;
+}
diff --git a/src/vm/node_modules/vminfod/zonewatcher.js b/src/vm/node_modules/vminfod/zonewatcher.js
new file mode 100644
index 00000000..7df21c18
--- /dev/null
+++ b/src/vm/node_modules/vminfod/zonewatcher.js
@@ -0,0 +1,82 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
+
+module.exports = ZoneWatcher;
+module.exports.ZoneWatcher = ZoneWatcher;
+function ZoneWatcher(options) {
+    var self = this;
+
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.optionalNumber(options.highWaterMark, 'options.highWaterMark');
+
+    self.options = options;
+    self.log = options.log;
+
+    // create a Sysevent stream
+    var opts = {
+        logger: self.log,
+        class: 'status',
+        channel: 'com.sun:zones:status'
+    };
+    if (options.hasOwnProperty('highWaterMark')) {
+        opts.highWaterMark = options.highWaterMark;
+    }
+
+    self.se = new SyseventStream(opts);
+
+    self.se.once('ready', function syseventStreamReady() {
+        self.emit('ready');
+    });
+
+    self.se.on('readable', function syseventStreamReadable() {
+        var ev;
+        while ((ev = self.se.read()) !== null) {
+            var o = {
+                type: 'event',
+                zonename: ev.data.zonename,
+                newstate: ev.data.newstate,
+                time: ev.time,
+                ev: ev
+            };
+
+            self.emit('event', o);
+        }
+    });
+}
+util.inherits(ZoneWatcher, EventEmitter);
+
+ZoneWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    self.se.stop();
+};
diff --git a/src/vm/node_modules/vminfod/zpoolwatcher.js b/src/vm/node_modules/vminfod/zpoolwatcher.js
new file mode 100644
index 00000000..0deffa62
--- /dev/null
+++ b/src/vm/node_modules/vminfod/zpoolwatcher.js
@@ -0,0 +1,121 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
+
+module.exports = ZpoolWatcher;
+module.exports.ZpoolWatcher = ZpoolWatcher;
+function ZpoolWatcher(options) {
+    var self = this;
+
+    self.options = options;
+    assert.object(options.log, 'no logger passed to ZpoolWatcher()');
+    self.log = options.log;
+
+    // create a Sysevent stream
+    var opts = {
+        logger: self.log,
+        class: 'EC_zfs',
+        subclasses: ['ESC_ZFS_history_event']
+    };
+
+    self.se = new SyseventStream(opts);
+
+    self.se.once('ready', function syseventStreamReady() {
+        self.emit('ready');
+    });
+
+    self.se.on('readable', function syseventStreamReadable() {
+        var ev;
+        while ((ev = self.se.read()) !== null)
+            self._handle_event(ev);
+    });
+}
+util.inherits(ZpoolWatcher, EventEmitter);
+
+/*
+ * called internally whenever a new sysevent is received -
+ * this method is responsible for constructing an object to emit
+ * based on the sysevent received.
+ */
+ZpoolWatcher.prototype._handle_event = function _handle_event(ev) {
+    var self = this;
+    var item;
+    var i;
+    var key;
+    var value;
+
+    // object to be emitted
+    var o = {};
+
+    // extract pool name
+    item = ev.data.pool_name;
+    assert.string(item, 'invalid pool name in ZFS record');
+    o.pool = item;
+
+    // extract and parse timestamp
+    item = ev.data.history_time;
+    assert.number(item, 'invalid "history time" in ZFS record');
+    o.timestamp = new Date(item * 1000);
+
+    // extract action, eg: "create", "destroy", "set", etc.
+    item = ev.data.history_internal_name;
+    assert.string(item, 'invalid "internal_name" in ZFS record');
+    o.action = item;
+
+    // extract dataset
+    item = ev.data.history_dsname;
+    assert.string(item, 'invalid "dsname" in ZFS record');
+    o.dsname = item;
+
+    // extract any optional extras
+    // this will typically be set by "zfs set" and will be a string like
+    // "sync=1", "atime=0", etc.
+    o.extra = {};
+    o.extras = ev.data.history_internal_str;
+    if (o.extras) {
+        i = o.extras.indexOf('=');
+        if (i >= 0) {
+            key = o.extras.substr(0, i);
+            value = o.extras.substr(i + 1);
+            o.extra[key] = value;
+        }
+    }
+
+    self.log.trace({o: o}, 'emitting ZpoolWatcher event');
+    self.emit(o.action, o);
+    self.emit('event', o);
+};
+
+ZpoolWatcher.prototype.stop = function stop() {
+    var self = this;
+
+    self.se.stop();
+};
diff --git a/src/vm/node_modules/vmload/dump-json.js b/src/vm/node_modules/vmload/dump-json.js
index 24862db6..34ad4869 100755
--- a/src/vm/node_modules/vmload/dump-json.js
+++ b/src/vm/node_modules/vmload/dump-json.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -33,11 +33,11 @@
  *  that VM.
  */
 
-var async = require('/usr/node/node_modules/async');
+var assert = require('/usr/node/node_modules/assert-plus');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var execFile = require('child_process').execFile;
 var getVmobjJSON = require('./vmload-json').getVmobjJSON;
-var path = require('path');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var log = bunyan.createLogger({
     level: 'debug',
@@ -62,37 +62,38 @@ execFile('/usr/sbin/zoneadm', ['list', '-c', '-p'],
         argv = process.argv.slice(2);
     }
 
-    async.each(lines, function (line, cb) {
-        var fields = line.split(':');
-        var uuid;
-        var zonepath;
+    vasync.forEachParallel({
+        inputs: lines,
+        func: function (line, cb) {
+            var fields = line.split(':');
+            var uuid;
+            var zonepath;
 
-        if (fields.length < 4) {
-            cb();
-            return;
-        }
+            if (fields.length < 4) {
+                cb();
+                return;
+            }
 
-        zonepath = fields[3];
-        uuid = fields[4];
+            zonepath = fields[3];
+            uuid = fields[4];
 
-        if (uuid === '') {
-            cb();
-            return;
-        }
+            if (uuid === '') {
+                cb();
+                return;
+            }
 
-        // if there are no arguments or the arguments include this VM...
-        if (argv.length === 0 || argv.indexOf(uuid) !== -1) {
-            getVmobjJSON(zonepath, {log: log}, function (err, obj) {
-                if (err) {
-                    throw err;
-                }
-                results[uuid] = obj;
+            // if there are no arguments or the arguments include this VM...
+            if (argv.length === 0 || argv.indexOf(uuid) !== -1) {
+                getVmobjJSON(zonepath, {log: log}, function (err, obj) {
+                    assert.ifError(err);
+                    results[uuid] = obj;
+                    cb();
+                    return;
+                });
+            } else {
                 cb();
                 return;
-            });
-        } else {
-            cb();
-            return;
+            }
         }
     }, function (err) {
         if (err) {
diff --git a/src/vm/node_modules/vmload/dump-vmobjs.js b/src/vm/node_modules/vmload/dump-vmobjs.js
index fe20e7d3..6d24a261 100755
--- a/src/vm/node_modules/vmload/dump-vmobjs.js
+++ b/src/vm/node_modules/vmload/dump-vmobjs.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -31,7 +31,6 @@
  *  in the output array.
  */
 
-var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var getVmobjs = require('vmload').getVmobjs;
 
@@ -53,12 +52,12 @@ getVmobjs(function (vm, cb) {
     if (process.argv.length >= 3) {
         args = process.argv.slice(2);
         if (args.indexOf(vm.uuid) !== -1) {
-            cb(true);
+            cb(null, true);
         } else {
-            cb(false);
+            cb(null, false);
         }
     } else {
-        cb(true);
+        cb(null, true);
     }
 }, {log: log}, function (err, results) {
 
diff --git a/src/vm/node_modules/vmload/dump-zonexml.js b/src/vm/node_modules/vmload/dump-zonexml.js
index a470bd70..4d245e36 100755
--- a/src/vm/node_modules/vmload/dump-zonexml.js
+++ b/src/vm/node_modules/vmload/dump-zonexml.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  * SUMMARY:
  *
@@ -33,12 +33,12 @@
  *  (the JSONized XML properties) for each VM.
  */
 
-var async = require('/usr/node/node_modules/async');
 var bunyan = require('/usr/node/node_modules/bunyan');
 var execFile = require('child_process').execFile;
 var getVmobjXML = require('./vmload-xml').getVmobjXML;
 var getVmobjXMLFile = require('./vmload-xml').getVmobjXMLFile;
 var path = require('path');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var log = bunyan.createLogger({
     level: 'debug',
@@ -70,7 +70,10 @@ if (!process.argv[2]) {
 
 function dumpXMLs(vms)
 {
-    async.each(vms, addXML, function (err) {
+    vasync.forEachParallel({
+        inputs: vms,
+        func: addXML
+    }, function (err) {
         if (err) {
             throw (err);
         }
@@ -83,7 +86,7 @@ function addXML(vm, callback)
 {
     var filename = path.join('/etc/zones', vm + '.xml');
 
-    if (vm.length != 36) {
+    if (vm.length !== 36) {
         log.error('VM zonename ' + vm + ' is not a uuid, skipping.');
         callback();
         return;
diff --git a/src/vm/node_modules/vmload/index.js b/src/vm/node_modules/vmload/index.js
index 962e2a41..0629976b 100644
--- a/src/vm/node_modules/vmload/index.js
+++ b/src/vm/node_modules/vmload/index.js
@@ -21,13 +21,11 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
-var bunyan = require('/usr/node/node_modules/bunyan');
 var fs = require('fs');
 var getDatasets = require('./vmload-datasets').getDatasets;
 var getVmobjJSON = require('./vmload-json').getVmobjJSON;
@@ -35,15 +33,19 @@ var getVmobjXMLFile = require('./vmload-xml').getVmobjXMLFile;
 var getZoneinfo = require('./vmload-zoneinfo').getZoneinfo;
 var getZoneRecords = require('./vmload-zoneadm').getZoneRecords;
 var hrtime = require('/usr/vm/node_modules/hrtime');
+var jsprim = require('/usr/vm/node_modules/jsprim');
 var path = require('path');
 var props = require('/usr/vm/node_modules/props');
 var utils = require('utils');
 var vmload_utils = require('./vmload-utils');
+var vasync = require('/usr/vm/node_modules/vasync');
 var wantAnyFields = vmload_utils.wantAnyFields;
 var wantField = vmload_utils.wantField;
 
+var VminfodClient = require('../vminfod/client').VminfodClient;
+var vminfod = new VminfodClient('vmload/index');
+
 // utils
-var assertSafeZonePath = utils.assertSafeZonePath;
 var trim = utils.trim;
 
 // load generated tables of data
@@ -463,7 +465,7 @@ function getLastExited(zonename, zonepath, log, callback)
         }
 
         stat = Number(fields[1]);
-        log.debug('found exit_status value: ' + stat);
+        log.debug({filename: filename}, 'found exit_status value: %d', stat);
         if (stat === -1) {
             // -1 is special status (OS-3429) that indicates normal exit
             result.exit_status = 0;
@@ -503,29 +505,34 @@ function getLastModified(zonename, zonepath, log, callback)
     }
 
     // stat all files in parallel, newest will be "last_modified"
-    async.each(files, function (file, cb) {
-        fs.stat(file, function (err, stats) {
-            if (err) {
-                if (err.code !== 'ENOENT') {
-                    log.error(err, 'Unable to get timestamp for "' + file + '":'
-                        + err.message);
+    vasync.forEachParallel({
+        inputs: files,
+        func: function (file, cb) {
+            fs.stat(file, function (err, stats) {
+                if (err) {
+                    if (err.code !== 'ENOENT') {
+                        log.error({err: err},
+                            'Unable to get timestamp for "%s": %s',
+                            file, err.message);
+                    }
+                    cb();
+                    return;
                 }
-                cb();
-                return;
-            }
 
-            if (!stats.isFile()) {
-                cb();
-                return;
-            }
+                if (!stats.isFile()) {
+                    cb();
+                    return;
+                }
 
-            if ((timestamp === 0) || (Date.parse(stats.mtime) > timestamp)) {
-                // newest file so far!
-                timestamp = Date.parse(stats.mtime);
-            }
+                if ((timestamp === 0)
+                    || (Date.parse(stats.mtime) > timestamp)) {
+                    // newest file so far!
+                    timestamp = Date.parse(stats.mtime);
+                }
 
-            cb();
-        });
+                cb();
+            });
+        }
     }, function (err) {
         if (err) {
             callback(err);
@@ -575,6 +582,7 @@ function getSysinfo(log, callback)
  *  fields: an array of field names we want in this object
  *  log: a bunyan logger (required)
  *  cache: (see comment at top of getZoneData())
+ *  loadManually: skip vminfod and pull directly from the system
  *
  * If any of the members of the 'cache' are not passed in, they will be looked
  * up from the live system. This means that if you want to do multiple lookups
@@ -610,254 +618,304 @@ function getVmobj(uuid, options, callback)
 
     log.trace('getting vmobj for VM ' + uuid);
 
-    async.series([
-        function (cb) {
-            if (options.hasOwnProperty('cache')) {
-                cache = options.cache;
-                cb();
+    if (options.loadManually) {
+        log.debug('getVmobj loading manually - skipping vminfod');
+        loadManually(callback);
+    } else {
+        log.debug('getVmobj loading using vminfod');
+        loadVminfod(function (err, vm) {
+            if (err && err.code === 404) {
+                err.code = 'ENOENT';
+            }
+            callback(err, vm);
+        });
+    }
+
+    function loadVminfod(done) {
+        vminfod.vm(uuid, function (err, vm) {
+            if (err) {
+                done(err);
                 return;
             }
+            done(null, vm);
+        });
+    }
 
-            // If cache was not prepopulated, load now, just for this VM's data.
-            getZoneData(uuid, options, function (err, _cache) {
-                if (err) {
-                    cb(err);
+    function loadManually(done) {
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                if (options.hasOwnProperty('cache')) {
+                    cache = options.cache;
+                    cb();
                     return;
                 }
 
-                cache = _cache;
-                cb();
-            });
-        }, function (cb) {
-            var new_err;
-
-            // load data from zoneadm list -pc (cache.zoneadm_objectss)
-            if (cache.zoneadm_objects
-                && cache.zoneadm_objects.hasOwnProperty(uuid)) {
-
-                zoneadm_info = cache.zoneadm_objects[uuid];
-
-                // Ensure zoneadm_info has basic required properties
-                assert.equal(zoneadm_info.uuid, uuid);
-                [
-                    'brand',
-                    'state',
-                    'zonename',
-                    'zonepath'
-                ].forEach(function (f) {
-                    assert(zoneadm_info[f], 'zoneadm_info is missing "' + f
-                        + '" for VM ' + uuid);
+                // If cache was not prepopulated, load now,
+                // just for this VM's data.
+                getZoneData(uuid, options, function (err, _cache) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+
+                    cache = _cache;
+                    cb();
                 });
+            }, function (_, cb) {
+                var new_err;
+
+                // load data from zoneadm list -pc (cache.zoneadm_objectss)
+                if (cache.zoneadm_objects
+                    && cache.zoneadm_objects.hasOwnProperty(uuid)) {
+
+                    zoneadm_info = cache.zoneadm_objects[uuid];
+                    log.debug({zoneadm_info: zoneadm_info}, 'zoneadm_info');
+
+                    // Ensure zoneadm_info has basic required properties
+                    assert.equal(zoneadm_info.uuid, uuid);
+                    [
+                        'brand',
+                        'state',
+                        'zonename',
+                        'zonepath'
+                    ].forEach(function (f) {
+                        assert(zoneadm_info[f], 'zoneadm_info is missing "' + f
+                            + '" for VM ' + uuid);
+                    });
+
+                    cb();
+                    return;
+
+                }
 
-                cb();
-            } else {
                 new_err = new Error('VM ' + uuid + ' not found in zoneadm');
                 new_err.code = 'ENOENT';
                 cb(new_err);
-            }
-        }, function (cb) {
-            var new_err;
+            }, function (_, cb) {
+                var new_err;
+
+                if (cache.zonexml_objects
+                    && cache.zonexml_objects.hasOwnProperty(uuid)) {
+
+                    // Some consumers keep a copy of cache between calls,
+                    // so we need to clone this object instead of assigning
+                    // the reference. Otherwise, the cache copy of the
+                    // zonexml_object[uuid] will be a final vmobj.
+                    for (var key in cache.zonexml_objects[uuid]) {
+                        vmobj[key] =
+                            jsprim.deepCopy(cache.zonexml_objects[uuid][key]);
+                    }
 
-            if (cache.zonexml_objects
-                && cache.zonexml_objects.hasOwnProperty(uuid)) {
+                    cb();
+                    return;
+                }
 
-                vmobj = cache.zonexml_objects[uuid];
-                cb();
-                return;
-            }
+                if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
+                    // didn't want any so no problem.
+                    vmobj = {};
+                    cb();
+                    return;
+                }
 
-            if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
-                // didn't want any so no problem.
-                vmobj = {};
-                cb();
+                // if we got here, we wanted xml data, so not having is an error
+                new_err = new Error('VM ' + uuid
+                    + ' XML data missing from cache');
+                cb(new_err);
                 return;
-            }
 
-            // if we got here, we wanted xml data, so not having is an error
-            new_err = new Error('VM ' + uuid + ' XML data missing from cache');
-            cb(new_err);
-            return;
 
+            }, function (_, cb) {
+                /*
+                 * We got some bits from `zoneadm list` in zoneadm_info here,
+                 * and since we already got that data, adding it to the object
+                 * here is cheap. We also need some of these properties to be
+                 * able to get others later, so we add them all now. If they're
+                 * unwanted they'll be removed from the final object.
+                 */
+                vmobj.brand = zoneadm_info.brand;
+                vmobj.uuid = zoneadm_info.uuid;
+                vmobj.zone_state = zoneadm_info.state;
+                vmobj.zonename = zoneadm_info.zonename;
+                vmobj.zonepath = zoneadm_info.zonepath;
+
+                if (wantField(options, 'zoneid')
+                    && zoneadm_info.zoneid !== '-') {
+                    vmobj.zoneid = zoneadm_info.zoneid;
+                }
 
-        }, function (cb) {
-            /*
-             * We got some bits from `zoneadm list` in zoneadm_info here, and
-             * since we already got that data, adding it to the object here is
-             * cheap. We also need some of these properties to be able to get
-             * others later, so we add them all now. If they're unwanted they'll
-             * be removed from the final object.
-             */
-            vmobj.brand = zoneadm_info.brand;
-            vmobj.uuid = zoneadm_info.uuid;
-            vmobj.zone_state = zoneadm_info.state;
-            vmobj.zonename = zoneadm_info.zonename;
-            vmobj.zonepath = zoneadm_info.zonepath;
-
-            if (wantField(options, 'zoneid') && zoneadm_info.zoneid !== '-') {
-                vmobj.zoneid = zoneadm_info.zoneid;
-            }
-
-            if (wantField(options, 'zonedid') && zoneadm_info.zonedid !== '-') {
-                vmobj.zonedid = zoneadm_info.zonedid;
-            }
-
-            if (wantField(options, 'last_modified')) {
-                if (cache.hasOwnProperty('last_modified')
-                    && cache.last_modified.hasOwnProperty(vmobj.uuid)) {
+                if (wantField(options, 'zonedid')
+                    && zoneadm_info.zonedid !== '-') {
+                    vmobj.zonedid = zoneadm_info.zonedid;
+                }
 
-                    vmobj.last_modified = cache.last_modified[vmobj.uuid];
-                } else {
-                    log.warn('"last_modified" requested, but not found in cache'
-                        + ' for VM ' + vmobj.uuid);
+                if (wantField(options, 'last_modified')) {
+                    if (cache.hasOwnProperty('last_modified')
+                        && cache.last_modified.hasOwnProperty(vmobj.uuid)) {
+                        vmobj.last_modified = cache.last_modified[vmobj.uuid];
+                    } else {
+                        log.warn('"last_modified" requested, but not found in'
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            if (vmobj.zone_state !== 'running'
-                    && wantField(options, 'exit_status')) {
+                if (vmobj.zone_state !== 'running'
+                        && wantField(options, 'exit_status')) {
 
-                if (cache.hasOwnProperty('last_exited')
-                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
-                    && cache.last_exited[vmobj.uuid]
-                    .hasOwnProperty('exit_status')) {
+                    if (cache.hasOwnProperty('last_exited')
+                        && cache.last_exited.hasOwnProperty(vmobj.uuid)
+                        && cache.last_exited[vmobj.uuid]
+                        .hasOwnProperty('exit_status')) {
 
-                    vmobj.exit_status
-                        = cache.last_exited[vmobj.uuid].exit_status;
-                } else {
-                    log.warn('"exit_status" requested, but not found in cache'
-                        + ' for VM ' + vmobj.uuid);
+                        vmobj.exit_status
+                            = cache.last_exited[vmobj.uuid].exit_status;
+                    } else {
+                        log.warn('"exit_status" requested, but not found in'
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            if (vmobj.zone_state !== 'running'
-                    && wantField(options, 'exit_timestamp')) {
+                if (vmobj.zone_state !== 'running'
+                        && wantField(options, 'exit_timestamp')) {
 
-                if (cache.hasOwnProperty('last_exited')
-                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
-                    && cache.last_exited[vmobj.uuid]
-                    .hasOwnProperty('exit_timestamp')) {
+                    if (cache.hasOwnProperty('last_exited')
+                        && cache.last_exited.hasOwnProperty(vmobj.uuid)
+                        && cache.last_exited[vmobj.uuid]
+                        .hasOwnProperty('exit_timestamp')) {
 
-                    vmobj.exit_timestamp
-                        = cache.last_exited[vmobj.uuid].exit_timestamp;
-                } else {
-                    log.warn('"exit_timestamp" requested, but not found in '
-                        + 'cache for VM ' + vmobj.uuid);
+                        vmobj.exit_timestamp
+                            = cache.last_exited[vmobj.uuid].exit_timestamp;
+                    } else {
+                        log.warn('"exit_timestamp" requested, but not found in '
+                            + 'cache for VM ' + vmobj.uuid);
+                    }
                 }
-            }
 
-            /*
-             * If we want resolvers, (eg. OS-2194) we always add the array here
-             * so you can tell that the resolvers are explicitly not set.
-             */
-            if (wantField(options, 'resolvers')
-                && !vmobj.hasOwnProperty('resolvers')) {
+                /*
+                 * If we want resolvers, (eg. OS-2194) we always add the array
+                 * here so you can tell that the resolvers are explicitly not
+                 * set.
+                 */
+                if (wantField(options, 'resolvers')
+                    && !vmobj.hasOwnProperty('resolvers')) {
 
-                vmobj.resolvers = [];
-            }
+                    vmobj.resolvers = [];
+                }
 
-            // Always include firewall_enabled, false if not set.
-            if (wantField(options, 'firewall_enabled')
-                && !vmobj.hasOwnProperty('firewall_enabled')) {
+                // Always include firewall_enabled, false if not set.
+                if (wantField(options, 'firewall_enabled')
+                    && !vmobj.hasOwnProperty('firewall_enabled')) {
 
-                vmobj.firewall_enabled = false;
-            }
+                    vmobj.firewall_enabled = false;
+                }
 
-            // sysinfo has server_uuid and potentially some DC info
-            if (cache.sysinfo) {
-                if (wantField(options, 'server_uuid')
-                    && cache.sysinfo.hasOwnProperty('UUID')) {
+                // sysinfo has server_uuid and potentially some DC info
+                if (cache.sysinfo) {
+                    if (wantField(options, 'server_uuid')
+                        && cache.sysinfo.hasOwnProperty('UUID')) {
 
-                    vmobj.server_uuid = cache.sysinfo.UUID;
-                }
-                if (wantField(options, 'datacenter_name')
-                    && cache.sysinfo.hasOwnProperty('Datacenter Name')) {
+                        vmobj.server_uuid = cache.sysinfo.UUID;
+                    }
+                    if (wantField(options, 'datacenter_name')
+                        && cache.sysinfo.hasOwnProperty('Datacenter Name')) {
 
-                    vmobj.datacenter_name = cache.sysinfo['Datacenter Name'];
-                }
-                if (wantField(options, 'platform_buildstamp')
-                    && cache.sysinfo.hasOwnProperty('Live Image')) {
+                        vmobj.datacenter_name
+                            = cache.sysinfo['Datacenter Name'];
+                    }
+                    if (wantField(options, 'platform_buildstamp')
+                        && cache.sysinfo.hasOwnProperty('Live Image')) {
 
-                    vmobj.platform_buildstamp = cache.sysinfo['Live Image'];
-                }
-                if (wantField(options, 'headnode_id')
-                    && cache.sysinfo.hasOwnProperty('Headnode ID')) {
+                        vmobj.platform_buildstamp
+                            = cache.sysinfo['Live Image'];
+                    }
+                    if (wantField(options, 'headnode_id')
+                        && cache.sysinfo.hasOwnProperty('Headnode ID')) {
 
-                    vmobj.headnode_id = cache.sysinfo['Headnode ID'];
+                        vmobj.headnode_id = cache.sysinfo['Headnode ID'];
+                    }
                 }
-            }
 
-            /*
-             * state could already be set here if it was overriden by a
-             * transition that's in progress. So we only change if that's not
-             * the case.
-             *
-             * We always add 'state' at this point regardless of 'fields'
-             * because some other checks later depend on it (eg. received means
-             * we need 'missing' member, etc). The 'state' itself will get
-             * removed later if not requested.
-             */
-            if (!vmobj.hasOwnProperty('state')) {
-                if (zoneadm_info.state === 'installed') {
-                    vmobj.state = 'stopped';
-                } else {
-                    vmobj.state = zoneadm_info.state;
+                /*
+                 * state could already be set here if it was overriden by a
+                 * transition that's in progress. So we only change if that's
+                 * not the case.
+                 *
+                 * We always add 'state' at this point regardless of 'fields'
+                 * because some other checks later depend on it (eg. received
+                 * means we need 'missing' member, etc). The 'state' itself
+                 * will get removed later if not requested.
+                 */
+                if (!vmobj.hasOwnProperty('state')) {
+                    if (zoneadm_info.state === 'installed') {
+                        vmobj.state = 'stopped';
+                    } else {
+                        vmobj.state = zoneadm_info.state;
+                    }
                 }
-            }
 
-            /*
-             * If the zone has the 'failed' property it doesn't matter what
-             * other state it might be in, we list its state as 'failed'.
-             */
-            if (vmobj.failed) {
-                vmobj.state = 'failed';
-            }
+                /*
+                 * If the zone has the 'failed' property it doesn't matter what
+                 * other state it might be in, we list its state as 'failed'.
+                 */
+                if (vmobj.failed) {
+                    vmobj.state = 'failed';
+                }
 
-            cb();
-        }, function (cb) {
-            VMOBJ_ZONEINFO_FIELDS.forEach(function (field) {
-                if (wantField(options, field)
-                    && cache.zoneinfo_objects[vmobj.uuid]
-                    && cache.zoneinfo_objects[vmobj.uuid]
-                        .hasOwnProperty(field)) {
+                cb();
+            }, function (_, cb) {
+                VMOBJ_ZONEINFO_FIELDS.forEach(function (field) {
+                    if (wantField(options, field)
+                        && cache.zoneinfo_objects[vmobj.uuid]
+                        && cache.zoneinfo_objects[vmobj.uuid]
+                            .hasOwnProperty(field)) {
+
+                        vmobj[field]
+                            = cache.zoneinfo_objects[vmobj.uuid][field];
+                    }
+                });
 
-                    vmobj[field] = cache.zoneinfo_objects[vmobj.uuid][field];
+                cb();
+            }, function (_, cb) {
+                /*
+                 * Caller's field list doesn't include any fields from JSON
+                 * files, so don't bother loading them (optimization).
+                 */
+                if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
+                    cb();
+                    return;
                 }
-            });
 
-            cb();
-        }, function (cb) {
-            /*
-             * Caller's field list doesn't include any fields from JSON files,
-             * so don't bother loading them (optimization).
-             */
-            if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
-                cb();
-                return;
-            }
+                // whatever we got back, add to the VM object
+                VMOBJ_JSON_FIELDS.forEach(function (m) {
+                    if (wantField(options, m)
+                        && cache.json_objects.hasOwnProperty(vmobj.uuid)
+                        && cache.json_objects[vmobj.uuid].hasOwnProperty(m)) {
 
-            // whatever we got back, add to the VM object
-            VMOBJ_JSON_FIELDS.forEach(function (m) {
-                if (wantField(options, m)
-                    && cache.json_objects.hasOwnProperty(vmobj.uuid)
-                    && cache.json_objects[vmobj.uuid].hasOwnProperty(m)) {
+                        vmobj[m] = cache.json_objects[vmobj.uuid][m];
+                    }
+                });
 
-                    vmobj[m] = cache.json_objects[vmobj.uuid][m];
+                cb();
+            }, function (_, cb) {
+                if (vmobj.state !== 'receiving') {
+                    log.trace('not "receiving", no need to lookup'
+                        + ' receiving.json');
+                    cb();
+                    return;
                 }
-            });
 
-            cb();
-        }, function (cb) {
-            if (vmobj.state !== 'receiving') {
-                log.trace('not "receiving", no need to lookup receiving.json');
-                cb();
-                return;
-            }
+                fs.readFile('/etc/zones/' + uuid + '-receiving.json',
+                    function (err, data) {
 
-            fs.readFile('/etc/zones/' + uuid + '-receiving.json',
-                function (err, data) {
                     var receiving_props;
 
                     if (err) {
-                        cb(err);
+                        // cb(err);
+                        // XXX really ugly "fix" for a vm state that appears
+                        // to happen only in the vminfod world.  the zone XML
+                        // file says the zone is transitioning from
+                        // "receiving" to "stopped" and `zoneadm list -cv`
+                        // shows it in state "configured".
+                        cb();
                         return;
                     }
 
@@ -876,41 +934,42 @@ function getVmobj(uuid, options, callback)
                     }
 
                     cb();
+                });
+            }, function (_, cb) {
+                /*
+                 * If we have dataset_objects, we want to ensure we add in any
+                 * fields we need from them.
+                 */
+                if (cache.dataset_objects) {
+                    addDatasetProperties(vmobj, cache.dataset_objects, options,
+                        cb);
+                    return;
                 }
-            );
-        }, function (cb) {
-            /*
-             * If we have dataset_objects, we want to ensure we add in any
-             * fields we need from them.
-             */
-            if (cache.dataset_objects) {
-                addDatasetProperties(vmobj, cache.dataset_objects, options, cb);
-                return;
-            }
 
-            // no zfs props requested, nothing to do.
-            cb();
-        }, function (cb) {
-            /*
-             * Remove non-requested 'fields' that might have been added as
-             * dependencies or because grabbing together was easier.
-             */
-            if (options.hasOwnProperty('fields')) {
-                Object.keys(vmobj).forEach(function (key) {
-                    if (!wantField(options, key)) {
-                        delete vmobj[key];
-                    }
-                });
+                // no zfs props requested, nothing to do.
+                cb();
+            }, function (_, cb) {
+                /*
+                 * Remove non-requested 'fields' that might have been added as
+                 * dependencies or because grabbing together was easier.
+                 */
+                if (options.hasOwnProperty('fields')) {
+                    Object.keys(vmobj).forEach(function (key) {
+                        if (!wantField(options, key)) {
+                            delete vmobj[key];
+                        }
+                    });
+                }
+                cb();
             }
-            cb();
-        }
-    ], function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
-        callback(null, vmobj);
-    });
+        ]}, function (err) {
+            if (err) {
+                done(err);
+                return;
+            }
+            done(null, vmobj);
+        });
+    }
 }
 
 /*
@@ -941,72 +1000,90 @@ function getVmobj(uuid, options, callback)
  */
 function getVmobjs(filter, options, callback)
 {
-    var cache;
-    var vmobjs = [];
-
     assert(typeof (filter) === 'function', 'filter must be a function');
 
-    async.series([
-        function (cb) {
-            if (options.hasOwnProperty('cache')) {
-                cache = options.cache;
-                cb();
+    if (options.loadManually) {
+        loadManually(callback);
+    } else {
+        loadVminfod(callback);
+    }
+
+    function loadVminfod(done) {
+        vminfod.vms(function (err, vms) {
+            if (err) {
+                done(err);
                 return;
             }
 
-            /*
-             * If cache was not prepopulated, load now for all VMs. "options"
-             * will potentially limit which fields are in output objects.
-             */
-            getZoneData(null, options, function (err, _cache) {
-                if (err) {
-                    cb(err);
+            vasync.filterSeries(vms, filter, done);
+        });
+    }
+
+    function loadManually(done) {
+        var cache;
+        var vmobjs = [];
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                if (options.hasOwnProperty('cache')) {
+                    cache = options.cache;
+                    cb();
                     return;
                 }
 
-                cache = _cache;
-                cb();
-            });
-        }, function (cb) {
-            var vms = Object.keys(cache.zoneadm_objects);
-            async.each(vms,
-                function (uuid, vm_cb) {
-                    var get_options = options;
+                /*
+                 * If cache was not prepopulated, load now for all VMs.
+                 * "options" will potentially limit which fields are in output
+                 * objects.
+                 */
+                getZoneData(null, options, function (err, _cache) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
 
-                    /*
-                     * we've made sure we have a cache of everything, use the
-                     * same one for each getVmobj().
-                     */
-                    get_options.cache = cache;
-                    getVmobj(uuid, get_options, function (err, obj) {
-                        if (err) {
-                            vm_cb(err);
+                    cache = _cache;
+                    cb();
+                });
+            }, function (_, cb) {
+                var vms = Object.keys(cache.zoneadm_objects);
+                vasync.forEachParallel({
+                    inputs: vms,
+                    func: function (uuid, vm_cb) {
+                        var get_options = options;
+
+                        /*
+                         * we've made sure we have a cache of everything, use
+                         * the same one for each getVmobj().
+                         */
+                        get_options.cache = cache;
+                        getVmobj(uuid, get_options, function (err, obj) {
+                            if (err) {
+                                vm_cb(err);
+                                return;
+                            }
+
+                            vmobjs.push(obj);
+                            vm_cb();
                             return;
-                        }
-
-                        vmobjs.push(obj);
-                        vm_cb();
-                        return;
-                    });
+                        });
+                    }
                 }, function (err) {
                     if (err) {
                         cb(err);
                         return;
                     }
                     cb();
-                }
-            );
-        }
-    ], function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
+                });
+            }
+        ]}, function (err) {
+            if (err) {
+                done(err);
+                return;
+            }
 
-        async.filterSeries(vmobjs, filter, function (results) {
-            callback(null, results);
+            vasync.filterSeries(vmobjs, filter, done);
         });
-    });
+    }
 }
 
 /*
@@ -1106,21 +1183,24 @@ function getZoneData(uuid, options, callback)
     }
 
     // we do this in series, because later bits need the list of zones
-    async.eachSeries([
-        loadZoneadmObjects,
-        loadSysinfo,
-        loadZoneinfoObjects,
-        loadZonexmlObjects,
-        loadLastExited,
-        loadLastModified,
-        loadJsonObjects,
-        loadDatasetObjects
-    ], function _loadWrapper(fn, cb) {
-        /*
-         * we expect each parameter to read from options and set their data
-         * into cache.<whatever> when they're requested to.
-         */
-        fn(uuid, cache, options, cb);
+    vasync.forEachPipeline({
+        inputs: [
+            loadZoneadmObjects,
+            loadSysinfo,
+            loadZoneinfoObjects,
+            loadZonexmlObjects,
+            loadLastExited,
+            loadLastModified,
+            loadJsonObjects,
+            loadDatasetObjects
+        ],
+        func: function _loadWrapper(fn, cb) {
+            /*
+             * we expect each parameter to read from options and set their data
+             * into cache.<whatever> when they're requested to.
+             */
+            fn(uuid, cache, options, cb);
+        }
     }, function (err) {
         if (err) {
             callback(err);
@@ -1223,41 +1303,44 @@ function loadJsonObjects(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
 
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        getVmobjJSON(obj.zonepath, options, function (err, results) {
-            if (err) {
-                /*
-                 * when zone_state is 'incomplete' we could be deleting it
-                 * in which case metadata may already be gone, ignore
-                 * failure to load mdata when 'incomplete' because of this.
-                 */
-                if (obj.state === 'incomplete') {
-                    log.debug({err: err}, 'zone is in state incomplete '
-                        + 'ignoring error loading JSON');
-                } else {
-                    errors.push(err);
-                    log.error(err);
+            getVmobjJSON(obj.zonepath, options, function (err, results) {
+                if (err) {
+                    /*
+                     * when zone_state is 'incomplete' we could be deleting it
+                     * in which case metadata may already be gone, ignore
+                     * failure to load mdata when 'incomplete' because of this.
+                     */
+                    if (obj.state === 'incomplete') {
+                        log.debug({err: err}, 'zone is in state incomplete '
+                            + 'ignoring error loading JSON');
+                    } else {
+                        errors.push(err);
+                        log.error(err);
+                    }
+                    cb();
+                    return;
                 }
-                cb();
-                return;
-            }
 
-            json_objects[vm_uuid] = {};
+                json_objects[vm_uuid] = {};
 
-            // whatever we got back, add to the VM object
-            VMOBJ_JSON_FIELDS.forEach(function (m) {
-                if (results.hasOwnProperty(m)) {
-                    json_objects[vm_uuid][m] = results[m];
-                }
-            });
+                // whatever we got back, add to the VM object
+                VMOBJ_JSON_FIELDS.forEach(function (m) {
+                    if (results.hasOwnProperty(m)) {
+                        json_objects[vm_uuid][m] = results[m];
+                    }
+                });
 
-            cb();
-        });
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading json_objects took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1299,20 +1382,25 @@ function loadLastExited(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
 
-        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
-            + '"zonename": ' + JSON.stringify(obj));
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
+                + '"zonename": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        getLastExited(obj.zonename, obj.zonepath, log, function (err, result) {
-            if (!err) {
-                last_exited[vm_uuid] = result;
-            }
-            cb();
-        });
+            getLastExited(obj.zonename, obj.zonepath, log,
+                function (err, result) {
+
+                if (!err) {
+                    last_exited[vm_uuid] = result;
+                }
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading last_exited took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1345,20 +1433,25 @@ function loadLastModified(uuid, cache, options, callback)
     start_time = process.hrtime();
 
     // (parallel)
-    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
-        var obj = cache.zoneadm_objects[vm_uuid];
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
+            var obj = cache.zoneadm_objects[vm_uuid];
+
+            assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
+                + '"zonename": ' + JSON.stringify(obj));
+            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
+                + '"zonepath": ' + JSON.stringify(obj));
 
-        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
-            + '"zonename": ' + JSON.stringify(obj));
-        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
-            + '"zonepath": ' + JSON.stringify(obj));
+            getLastModified(obj.zonename, obj.zonepath, log,
+                function (err, time) {
 
-        getLastModified(obj.zonename, obj.zonepath, log, function (err, time) {
-            if (!err) {
-                last_modified[vm_uuid] = time;
-            }
-            cb();
-        });
+                if (!err) {
+                    last_modified[vm_uuid] = time;
+                }
+                cb();
+            });
+        }
     }, function (err) {
         log.debug('loading last_modified took %s',
             hrtime.prettyHrtime(process.hrtime(start_time)));
@@ -1504,8 +1597,9 @@ function loadZonexmlObjects(uuid, cache, options, callback)
 
     // load the XML and translate to JSON in parallel for all VMs in
     // cache.zoneadm_objects
-    async.each(Object.keys(cache.zoneadm_objects),
-        function (vm_uuid, cb) {
+    vasync.forEachParallel({
+        inputs: Object.keys(cache.zoneadm_objects),
+        func: function (vm_uuid, cb) {
             var obj = cache.zoneadm_objects[vm_uuid];
 
             assert(obj.hasOwnProperty('brand'), 'zoneadm_object missing '
@@ -1530,20 +1624,20 @@ function loadZonexmlObjects(uuid, cache, options, callback)
                     cb();
                 }
             );
-        }, function (err) {
+        }
+    }, function (err) {
             log.debug('loading zonexml_objects took %s',
                 hrtime.prettyHrtime(process.hrtime(start_time)));
 
-            if (errors.length > 0) {
-                // XXX just return the first error for now
-                callback(errors[0]);
-                return;
-            }
-
-            cache.zonexml_objects = vmobjs;
-            callback();
+        if (errors.length > 0) {
+            // XXX just return the first error for now
+            callback(errors[0]);
+            return;
         }
-    );
+
+        cache.zonexml_objects = vmobjs;
+        callback();
+    });
 }
 
 module.exports = {
diff --git a/src/vm/node_modules/vmload/vmload-datasets.js b/src/vm/node_modules/vmload/vmload-datasets.js
index 54a43b06..90e5a01d 100644
--- a/src/vm/node_modules/vmload/vmload-datasets.js
+++ b/src/vm/node_modules/vmload/vmload-datasets.js
@@ -20,17 +20,18 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
 var EventEmitter = require('events').EventEmitter;
 var hrtime = require('/usr/vm/node_modules/hrtime');
 var props = require('/usr/vm/node_modules/props');
 var spawn = require('child_process').spawn;
+var util = require('util');
 var utils = require('utils');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 var VMOBJ_ZFS_DEPENDENCIES = props.VMOBJ_ZFS_DEPENDENCIES;
 var ZFS_FIELDS = props.ZFS_FIELDS;
@@ -156,14 +157,20 @@ function cleanDatasetObject(obj)
         'written'
     ];
 
+    var expected_fields = [
+        'mountpoint',
+        'name',
+        'type'
+    ];
+
     // We should always have mountpoint, dataset and type because we force them
     // to be included in zfsList()
-    assert(obj.hasOwnProperty('mountpoint'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing mountpoint');
-    assert(obj.hasOwnProperty('name'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing name');
-    assert(obj.hasOwnProperty('type'), 'cleanDatasetObject('
-        + JSON.stringify(obj) + '): missing type');
+    expected_fields.forEach(function assertExpectedField(field) {
+        if (!obj.hasOwnProperty(field)) {
+            assert(false, util.format('cleanDatasetObject(%s): missing %s',
+                JSON.stringify(obj), field));
+        }
+    });
 
     // convert numeric fields to proper numbers
     number_fields.forEach(function (field) {
@@ -323,9 +330,12 @@ function getDatasets(obj, options, callback)
         getZfsList(_options, callback);
 
     } else {
-        async.eachSeries(parents, function (parent, cb) {
-            _options.parent = parent;
-            getZfsList(_options, cb);
+        vasync.forEachPipeline({
+            inputs: parents,
+            func: function (parent, cb) {
+                _options.parent = parent;
+                getZfsList(_options, cb);
+            }
         }, function (err) {
             if (err) {
                 callback(err);
@@ -619,7 +629,7 @@ function zfsList(options, callback) {
  * pushed onto the tail of the queue. The queue is processed serially so long
  * as there are active requests.
  */
-zfs_list_queue = async.queue(function (task, callback) {
+zfs_list_queue = vasync.queue(function (task, callback) {
 
     var log = task.log;
     var options = {};
diff --git a/src/vm/node_modules/vmload/vmload-json.js b/src/vm/node_modules/vmload/vmload-json.js
index 740b9c22..c8e45f34 100644
--- a/src/vm/node_modules/vmload/vmload-json.js
+++ b/src/vm/node_modules/vmload/vmload-json.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -28,11 +28,11 @@
 require('/usr/node/node_modules/platform_node_version').assert();
 
 var assert = require('assert');
-var async = require('/usr/node/node_modules/async');
 var fs = require('fs');
 var path = require('path');
 var vmload_utils = require('./vmload-utils');
 var wantField = vmload_utils.wantField;
+var vasync = require('/usr/vm/node_modules/vasync');
 
 function getVmobjJSON(zonepath, options, callback) {
     var log;
@@ -41,8 +41,8 @@ function getVmobjJSON(zonepath, options, callback) {
     assert(options.log, 'no logger passed to getVmobjJSON()');
     log = options.log;
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             if (!wantField(options, 'customer_metadata')
                 && !wantField(options, 'internal_metadata')) {
 
@@ -50,6 +50,8 @@ function getVmobjJSON(zonepath, options, callback) {
                 return;
             }
 
+            result.customer_metadata = {};
+            result.internal_metadata = {};
             loadJsonConfig(zonepath, 'metadata', log, function (err, metadata) {
                 if (err) {
                     cb(err);
@@ -67,12 +69,13 @@ function getVmobjJSON(zonepath, options, callback) {
                 });
                 cb();
             });
-        }, function (cb) {
+        }, function (_, cb) {
             if (!wantField(options, 'tags')) {
                 cb();
                 return;
             }
 
+            result.tags = {};
             loadJsonConfig(zonepath, 'tags', log, function (err, tags) {
                 if (err) {
                     cb(err);
@@ -82,12 +85,13 @@ function getVmobjJSON(zonepath, options, callback) {
                 result.tags = tags;
                 cb();
             });
-        }, function (cb) {
+        }, function (_, cb) {
             if (!wantField(options, 'routes')) {
                 cb();
                 return;
             }
 
+            result.routes = {};
             loadJsonConfig(zonepath, 'routes', log, function (err, routes) {
                 if (err) {
                     cb(err);
@@ -98,7 +102,7 @@ function getVmobjJSON(zonepath, options, callback) {
                 cb();
             });
         }
-    ], function (err) {
+    ]}, function (err) {
         if (err) {
             callback(err);
             return;
diff --git a/src/vm/node_modules/vmload/vmload-zoneadm.js b/src/vm/node_modules/vmload/vmload-zoneadm.js
index 76033b7f..92825195 100644
--- a/src/vm/node_modules/vmload/vmload-zoneadm.js
+++ b/src/vm/node_modules/vmload/vmload-zoneadm.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -129,6 +129,7 @@ function getZoneRecords(uuid, options, callback)
                     results[obj.uuid] = obj;
                 } else if (isUUID(obj.zonename)) {
                     results[obj.zonename] = obj;
+                    results[obj.zonename].uuid = obj.zonename;
                 } else if (obj.zonename !== 'global') {
                     log.error({object: obj}, 'zoneadm object is missing uuid');
                 }
diff --git a/src/vm/node_modules/zoneevent.js b/src/vm/node_modules/zoneevent.js
new file mode 100644
index 00000000..16742cb7
--- /dev/null
+++ b/src/vm/node_modules/zoneevent.js
@@ -0,0 +1,182 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * Substitute for 'zoneevent.c' that uses Vminfod or sysevents (as appropriate)
+ * as an event source
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var VM = require('/usr/vm/node_modules/VM');
+
+module.exports.ZoneEvent = ZoneEvent;
+
+/*
+ * ZoneEvent class
+ */
+function ZoneEvent(opts) {
+    var self = this;
+
+    assert(self instanceof ZoneEvent, 'must be called with "new"');
+
+    EventEmitter.call(self);
+
+    assert.object(opts, 'opts');
+    assert.string(opts.name, 'opts.name');
+    assert.object(opts.log, 'opts.log');
+
+    self.ze_name = opts.name;
+    self.ze_logger = opts.log.child({client: self.ze_name});
+
+    self.ze_logger.info('starting ZoneEvent');
+
+    self.start();
+}
+util.inherits(ZoneEvent, EventEmitter);
+
+
+/*
+ * Start the vmadm events stream
+ */
+ZoneEvent.prototype.start = function start() {
+    var self = this;
+
+    var opts = {
+        log: self.ze_logger,
+        name: self.ze_name
+    };
+
+    assert(!self.ze_stop, 'ZoneEvent not stopped');
+
+    VM.events(opts, handler, ready).on('error', function (err) {
+        self.emit('error', err);
+    });
+
+    function ready(err, obj) {
+        if (err) {
+            self.ze_logger.error({err: err}, 'ZoneEvent error');
+        } else {
+            assert.object(obj, 'obj');
+            assert.func(obj.stop, 'obj.stop');
+            self.ze_logger.debug('ZoneEvent (VM.events) ready');
+            self.ze_stop = obj.stop;
+        }
+
+        self.emit('ready', err, obj);
+    }
+
+    function handler(ev) {
+        self._handleVmadmEvent(ev);
+    }
+};
+
+/*
+ * Handle an incoming vmadm update
+ */
+ZoneEvent.prototype._handleVmadmEvent = function _handleVmadmEvent(ev) {
+    var self = this;
+
+    assert.object(ev, 'ev');
+    assert.date(ev.date, 'ev.date');
+    assert.string(ev.type, 'ev.type');
+    assert.string(ev.zonename, 'ev.zonename');
+
+    self.ze_logger.trace({ev: ev}, 'processing vmadm event');
+
+    var zoneupdated = false;
+    var obj = {
+        date: ev.date,
+        zonename: ev.zonename
+    };
+
+    switch (ev.type) {
+    case 'create':
+        obj.oldstate = '';
+        obj.newstate = ev.vm.zone_state;
+        zoneupdated = true;
+        break;
+    case 'delete':
+        obj.newstate = '';
+        zoneupdated = true;
+        break;
+    case 'modify':
+        assert.array(ev.changes, 'ev.changes');
+        for (var i = 0; i < ev.changes.length; i++) {
+            var change = ev.changes[i];
+            if (change.path.length === 1
+                && change.path[0] === 'zone_state') {
+
+                obj.oldstate = change.oldValue;
+                obj.newstate = change.newValue;
+                zoneupdated = true;
+                break;
+            }
+        }
+        break;
+    default:
+        assert(false, 'unknown vmadm event type: ' + ev.type);
+        break;
+    }
+
+    if (zoneupdated) {
+        /*
+         * There is some discrepency with vminfod and sysevents, so we
+         * translate the vminfod events to match what is expected by sysevent
+         */
+        if (obj.newstate === 'installed' && obj.oldstate !== 'incomplete') {
+            obj.newstate = 'uninitialized';
+        }
+        if (obj.oldstate === 'installed') {
+            obj.oldstate = 'uninitialized';
+        }
+        self.emit('event', obj);
+    }
+};
+
+/*
+ * stop the watcher
+ */
+ZoneEvent.prototype.stop = function vminfod_watcher_stop() {
+    var self = this;
+
+    if (self.ze_stop) {
+        self.ze_stop();
+        delete self.ze_stop;
+    }
+};
+
+/*
+ * if called directly just hook a vminfo stream to stdout
+ */
+if (require.main === module) {
+    var zw = new ZoneEvent('Module Run Directly');
+    zw.on('event', function (ev) {
+        console.log(JSON.stringify(ev));
+    });
+}
diff --git a/src/vm/runtests b/src/vm/runtests
index f5fae201..3ff6904b 100755
--- a/src/vm/runtests
+++ b/src/vm/runtests
@@ -35,7 +35,8 @@ test_errors=0
 failed_tests=
 
 pwd=$(unset CDPATH; cd $(dirname $0); pwd)
-for test in $(ls $pwd/tests | grep "\.js$"); do
+for test in "$pwd/tests"/test-*.js; do
+    test=${test##*/}
     set +o errexit
     set -o pipefail
     (/usr/vm/test/runtest $pwd/tests/${test} 2>&1) > >(tee -a /tmp/test.output.$$)
diff --git a/src/vm/sbin/vmadm.js b/src/vm/sbin/vmadm.js
index b1003e75..c2952478 100755
--- a/src/vm/sbin/vmadm.js
+++ b/src/vm/sbin/vmadm.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -52,6 +52,7 @@ var COMMANDS = [
     'create-snapshot',
     'delete', 'destroy',
     'delete-snapshot',
+    'events',
     'stop', 'halt',
     'help',
     'info',
@@ -148,6 +149,7 @@ function usage(message, code)
     out('console <uuid>');
     out('delete <uuid>');
     out('delete-snapshot <uuid> <snapname>');
+    out('events [-fjr] [uuid]');
     out('get <uuid>');
     out('info <uuid> [type,...]');
     out('install <uuid>');
@@ -243,7 +245,7 @@ function getListProperties(field)
     return undefined;
 }
 
-function getUUID(command, p)
+function getUUID(command, p, opts)
 {
     var uuid;
 
@@ -257,6 +259,10 @@ function getUUID(command, p)
         }
     }
 
+    if (opts && opts.optional) {
+        return null;
+    }
+
     return usage('Invalid or missing UUID for ' + command);
 }
 
@@ -395,6 +401,14 @@ function addCommandOptions(command, opts, shorts)
     case 'sysrq':
         // these only take uuid or 'special' args like start order=cd
         break;
+    case 'events':
+        opts.full = Boolean;
+        shorts.f = ['--full'];
+        opts.json = Boolean;
+        shorts.j = ['--json'];
+        opts.ready = Boolean;
+        shorts.r = ['--ready'];
+        break;
     case 'lookup':
         opts.json = Boolean;
         shorts.j = ['--json'];
@@ -714,6 +728,93 @@ function readFile(filename, callback)
     });
 }
 
+function do_events(parsed, callback) {
+    var uuid = getUUID('events', parsed, {optional: true});
+
+    var opts = {
+        name: 'vmadm CLI'
+    };
+    if (process.env.VMADM_IDENT) {
+        opts.name += util.format(' - %s', process.env.VMADM_IDENT);
+    }
+    if (uuid) {
+        opts.zonename = uuid;
+    }
+
+    VM.events(opts, vmEventHandler, vmEventReady);
+
+    // Called when a vminfod event is seen
+    function vmEventHandler(ev) {
+        if (parsed.json) {
+            console.log(JSON.stringify(ev));
+            return;
+        }
+
+        var zn = formatZonename(ev.zonename);
+        var date = formatDate(ev.date);
+
+        var alias = (ev.vm || {}).alias || '-';
+        if (alias.length > 30) {
+            alias = util.format('%s...', alias.substr(0, 27));
+        }
+
+        // format the output nicely
+        var base = util.format('[%s] %s %s %s',
+            date, zn, alias, ev.type);
+
+        delete ev.vm;
+        if (ev.changes) {
+            ev.changes.forEach(function (change) {
+                console.log('%s: %s %s :: %j -> %j',
+                    base,
+                    change.prettyPath,
+                    change.action,
+                    change.oldValue,
+                    change.newValue);
+            });
+        } else {
+            console.log(base);
+        }
+    }
+
+    // Called when the vminfod stream is ready
+    function vmEventReady(err, obj) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        if (!parsed.ready)
+            return;
+
+        var ev = obj.ev;
+        var date = formatDate(ev.date);
+        if (parsed.json) {
+            console.log(JSON.stringify(ev));
+        } else if (parsed.full) {
+            console.log('[%s] %s (uuid %s)', date, ev.type, ev.uuid);
+        } else {
+            console.log('[%s] %s', date, ev.type);
+        }
+    }
+
+    function formatDate(date) {
+        if (parsed.full) {
+            return date.toISOString();
+        } else {
+            return date.toISOString().split('T')[1];
+        }
+    }
+
+    function formatZonename(zonename) {
+        if (parsed.full) {
+            return zonename;
+        } else {
+            return zonename.split('-')[0];
+        }
+    }
+}
+
 function main(callback)
 {
     var args = process.argv.slice(1);
@@ -754,6 +855,9 @@ function main(callback)
     VM.loglevel = 'debug';
 
     switch (command) {
+    case 'events':
+        do_events(parsed, callback);
+        break;
     case 'start':
     case 'boot':
         uuid = getUUID(command, parsed);
@@ -961,6 +1065,17 @@ function main(callback)
     case 'json':
         uuid = getUUID(command, parsed);
         VM.load(uuid, function (err, obj) {
+            if (err && err.code === 'ENOENT' && err.statusCode === 404) {
+                /*
+                 * In the vminfod world, a VM not found error is expressed a
+                 * 404 instead of a failure message directly from zoneadm(1M).
+                 * Certain tools and scripts (`node-vmadm` for example) rely on
+                 * this specific output, so we make vmadm(1M) mimic that here.
+                 */
+                err.message = util.format(
+                    'zoneadm: %s: No such zone configured', uuid);
+            }
+
             if (err) {
                 callback(err);
             } else {
diff --git a/src/vm/sbin/vmadmd.js b/src/vm/sbin/vmadmd.js
index 4c1f7338..0e47ed93 100755
--- a/src/vm/sbin/vmadmd.js
+++ b/src/vm/sbin/vmadmd.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
@@ -40,11 +40,11 @@ var path = require('path');
 var http = require('http');
 var Qmp = require('/usr/vm/node_modules/qmp').Qmp;
 var qs = require('querystring');
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var url = require('url');
 var util = require('util');
 var vasync = require('vasync');
 var zonecfg = require('/usr/vm/node_modules/zonecfg');
+var ZoneEvent = require('/usr/vm/node_modules/zoneevent').ZoneEvent;
 
 /*
  * The DOCKER_RUNTIME_DELAY_RESET parameter is used when restarting a Docker VM
@@ -827,8 +827,8 @@ function applyDockerRestartPolicy(vmobj)
 /*
  * This function waits for a VM (vmUuid) to change to a specified state. It is
  * passed to VM.start() so that we avoid creating an additional zoneevent
- * watcher for each, and instead re-use the existing sysevent watcher that we've
- * already got.
+ * watcher for each, and instead re-use the existing zoneevent watcher that
+ * we've already got.
  */
 function stateWaiter(vmUuid, state, opts, callback) {
     assert.uuid(vmUuid, 'vmUuid');
@@ -888,15 +888,15 @@ function updateZoneStatus(ev)
 {
     var load_fields;
     var reprovisioning = false;
-    ev = ev.data;
 
     if (! ev.hasOwnProperty('zonename') || ! ev.hasOwnProperty('oldstate')
-        || ! ev.hasOwnProperty('newstate') || ! ev.hasOwnProperty('when')) {
+        || ! ev.hasOwnProperty('newstate') || ! ev.hasOwnProperty('date')) {
 
         log.debug('skipping unknown event: ' + JSON.stringify(ev, null, 2));
         return;
     }
 
+
     /*
      * With OS-4942 and OS-5011 additional states were added which occur before
      * the zone is installed. We don't care about such zones here since we're
@@ -946,14 +946,14 @@ function updateZoneStatus(ev)
     // if we've never seen this VM before, we always load once.
     if (!seen_vms.hasOwnProperty(ev.zonename)) {
         log.debug(ev.zonename + ' is a VM we haven\'t seen before and went '
-            + 'from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.when);
+            + 'from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.date);
         seen_vms[ev.zonename] = {};
         // We'll continue on to load this VM below with VM.load()
     } else if (!seen_vms[ev.zonename].hasOwnProperty('uuid')) {
         // We just saw this machine and haven't finished loading it the first
         // time.
         log.debug('Already loading VM ' + ev.zonename + ' ignoring transition'
-            + ' from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.when);
+            + ' from ' + ev.oldstate + ' to ' + ev.newstate + ' at ' + ev.date);
         return;
     } else if (PROV_WAIT[seen_vms[ev.zonename].uuid]) {
         // We're already waiting for this machine to provision, other
@@ -989,7 +989,7 @@ function updateZoneStatus(ev)
             'zonepath'
         ]}, function (err, vmobj) {
             log.info(ev.zonename + ' (docker) went from ' + ev.oldstate + ' to '
-                + ev.newstate + ' at ' + ev.when);
+                + ev.newstate + ' at ' + ev.date);
 
             /*
              * If we stop while autoboot is set, the user was intending for it
@@ -1029,7 +1029,7 @@ function updateZoneStatus(ev)
         if (!reprovisioning) {
             log.trace('ignoring transition for ' + ev.zonename + ' ('
                 + seen_vms[ev.zonename].brand + ') from ' + ev.oldstate + ' to '
-                + ev.newstate + ' at ' + ev.when);
+                + ev.newstate + ' at ' + ev.date);
             return;
         }
     }
@@ -1158,18 +1158,14 @@ function updateZoneStatus(ev)
     });
 }
 
-function startZoneWatcher(callback)
+function startZoneEvent(callback)
 {
-
-    var se = new SyseventStream({
-        class: 'status',
-        logger: log,
-        channel: 'com.sun:zones:status'
+    var ze = new ZoneEvent({
+        name: 'vmadmd ZoneEvent',
+        log: log
     });
-    se.on('readable', function () {
-        var ev;
-        while ((ev = se.read()) !== null)
-            callback(ev);
+    ze.on('event', function (ev) {
+        callback(ev);
     });
 }
 
@@ -2091,6 +2087,7 @@ function upgradeVM(vmobj, fields, callback)
 
                 image_uuid = origin.split('@')[0].split('/').pop();
                 log.info('setting new image_uuid: ' + image_uuid);
+
                 cmd = [
                     'add attr',
                     'set name=dataset-uuid',
@@ -2100,7 +2097,6 @@ function upgradeVM(vmobj, fields, callback)
                 ].join('; ');
 
                 zonecfg(vmobj.uuid, [cmd], {log: log},
-
                     function (add_err, add_fds) {
                         if (add_err) {
                             log.error(add_err);
@@ -2353,7 +2349,6 @@ function upgradeVM(vmobj, fields, callback)
             var cmd;
 
             log.debug('setting vm-version = 1');
-
             cmd = [
                 'add attr',
                 'set name=vm-version',
@@ -2397,7 +2392,7 @@ function main()
 {
     // XXX TODO: load fs-ext so we can flock a pid file to be exclusive
 
-    startZoneWatcher(updateZoneStatus);
+    startZoneEvent(updateZoneStatus);
     startHTTPHandler();
     startTraceLoop();
     startSeenCleaner();
diff --git a/src/vm/sbin/vminfo.js b/src/vm/sbin/vminfo.js
new file mode 100755
index 00000000..5e46e9aa
--- /dev/null
+++ b/src/vm/sbin/vminfo.js
@@ -0,0 +1,391 @@
+#!/usr/node/bin/node
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var getopt = require('/usr/node/node_modules/getopt');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+
+var f = util.format;
+
+var name = 'Vminfod CLI';
+if (process.env.VMINFOD_NAME) {
+    name = f('%s (Vminfod CLI)', process.env.VMINFOD_NAME);
+}
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: name,
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+var client = new vminfod.VminfodClient({
+    name: name,
+    log: log
+});
+
+function usage() {
+    var _args = Array.prototype.slice.call(arguments);
+    var msg = f.apply(null, _args);
+    var out = [
+        'Usage: vminfo [command] [args]',
+        '',
+        'Commands',
+        '  ping               get vminfod ping     (GET /ping)',
+        '  status [-jf]       get vminfod status   (GET /status)',
+        '  vms                get all vms          (GET /vms)',
+        '  vm <uuid>          get vm info          (GET /vms/:uuid)',
+        '  events [-jfr]      trace vminfod events (GET /events)'
+    ];
+    if (msg) {
+        out.unshift('');
+        out.unshift(msg);
+    }
+    console.log(out.join('\n'));
+}
+
+function do_ping(args) {
+    client.ping(function vminfodPingDone(err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+        assert.string(msg.ping, 'msg.ping');
+
+        console.log(msg.ping);
+    });
+}
+
+function do_status(args) {
+    var opts = [
+        'f(full)',
+        'j(json)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, args);
+
+    var opt_f = false;
+    var opt_j = false;
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'f':
+            opt_f = true;
+            break;
+        case 'j':
+            opt_j = true;
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    opts = {};
+    if (opt_f) {
+        opts.query = {
+            full: true
+        };
+    }
+
+    client.status(opts, function vminfodStatusDone(err, msg) {
+        var output = [];
+        var evls;
+
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        if (opt_j) {
+            console.log(JSON.stringify(msg, null, 2));
+            return;
+        }
+
+        // format the status object for output
+        output.push(f('state: %s (%s)', msg.state, msg.status));
+        output.push(f('pid: %d', msg.pid));
+        output.push(f('uptime: %s', msg.uptime));
+        output.push(f('rss: %smb', (msg.memory.rss / 1024 / 1024).toFixed(2)));
+        output.push(f('numVms: %d', msg.numVms));
+
+        output.push('queue');
+        output.push(f('  paused: %s', msg.queue.paused));
+        output.push(f('  idle: %s', msg.queue.idle));
+        output.push(f('  npending: %d', msg.queue.vasync_queue.npending));
+        output.push(f('  nqueued: %d', msg.queue.vasync_queue.nqueued));
+
+        output.push('fullRefresh');
+        output.push(f('  lastRefresh: %s', msg.lastRefresh));
+
+        if (msg.refreshErrors.length > 0) {
+            output.push(f('  refreshErrors: (%d items)'),
+                msg.refreshErrors.length);
+            msg.refreshErrors.forEach(function forEachRefreshError(o) {
+                output.push(f('    - %s (%s)', o.err, o.ago));
+            });
+        }
+
+        // included with full=true
+        if (msg.refreshLog && msg.refreshLog.length > 0) {
+            output.push(f('  refreshLog: (%d items)', msg.refreshLog.length));
+            msg.refreshLog.forEach(function forEachRefreshLog(o) {
+                output.push(f('    - %d cacheChanges / %d vmChanges - %s ago',
+                    o.cacheChanges.length, o.vmChanges.length, o.endedAgo));
+            });
+        }
+
+        // included with full=true
+        if (msg.fswatcher) {
+            output.push('fswatcher');
+            output.push(f('  running: %s', msg.fswatcher.running));
+            output.push(f('  pid: %d', msg.fswatcher.watcher_pid));
+            output.push(f('  watching: %d', msg.fswatcher.watching.length));
+            output.push(f('  tryingToWatch: %d',
+                msg.fswatcher.not_yet_watching.length));
+            output.push(f('  pendingActions: %d',
+                Object.keys(msg.fswatcher.pending_actions).length));
+        }
+
+        evls = Object.keys(msg.eventsListeners);
+        output.push(f('eventsListeners: (%d listeners)', evls.length));
+        evls.forEach(function forEachEvLs(uuid) {
+            var el = msg.eventsListeners[uuid];
+            output.push(f('  - %s', el.userAgent));
+            output.push(f('    %s created %s ago', uuid, el.createdAgo));
+            output.push('');
+        });
+
+        console.log(output.join('\n'));
+    });
+}
+
+function do_vms(args) {
+    client.vms(function vminfodVmsDone(err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        console.log(JSON.stringify(msg, null, 2));
+    });
+}
+
+function do_vm(args) {
+    var zonename = args[2];
+
+    if (!zonename) {
+        usage('vm zonename must be specified');
+        process.exit(1);
+    }
+
+    client.vm(zonename, function vminfodVmDone(err, msg) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        assert.object(msg, 'msg');
+
+        console.log(JSON.stringify(msg, null, 2));
+    });
+}
+
+function do_events(args) {
+    var opts = [
+        'f(full)',
+        'j(json)',
+        'r(ready)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, args);
+
+    var opt_f = false;
+    var opt_j = false;
+    var opt_r = false;
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'f':
+            opt_f = true;
+            break;
+        case 'j':
+            opt_j = true;
+            break;
+        case 'r':
+            opt_r = true;
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    var vs = new vminfod.VminfodEventStream({
+        name: name,
+        log: log
+    });
+
+    vs.once('ready', function vminfodEventStreamReady(ev) {
+        if (!opt_r)
+            return;
+
+        var date = formatDate(ev.date);
+        if (opt_j) {
+            console.log(JSON.stringify(ev));
+        } else if (opt_f) {
+            console.log('[%s] %s (uuid %s)', date, ev.type, ev.uuid);
+        } else {
+            console.log('[%s] %s', date, ev.type);
+        }
+    });
+
+    vs.on('readable', function vminfodEventStreamReadable() {
+        var ev;
+        while ((ev = vs.read()) !== null) {
+            if (opt_j) {
+                console.log(JSON.stringify(ev));
+                return;
+            }
+
+            var zn = formatZonename(ev.zonename);
+            var date = formatDate(ev.date);
+
+            var alias = (ev.vm || {}).alias || '-';
+            if (alias.length > 30) {
+                alias = f('%s...', alias.substr(0, 27));
+            }
+
+            // format the output nicely
+            var base = f('[%s] %s %s %s',
+                date, zn, alias, ev.type);
+
+            delete ev.vm;
+            if (ev.changes) {
+                ev.changes.forEach(function forEachChanges(change) {
+                    console.log('%s: %s %s :: %j -> %j',
+                        base,
+                        change.prettyPath,
+                        change.action,
+                        change.oldValue,
+                        change.newValue);
+                });
+            } else {
+                console.log(base);
+            }
+        }
+    });
+
+    function formatDate(date) {
+        if (opt_f) {
+            return date.toISOString();
+        } else {
+            return date.toISOString().split('T')[1];
+        }
+    }
+
+    function formatZonename(zonename) {
+        if (opt_f) {
+            return zonename;
+        } else {
+            return zonename.split('-')[0];
+        }
+    }
+}
+
+function main() {
+    var opts = [
+        'h(help)'
+    ].join('');
+    var parser = new getopt.BasicParser(opts, process.argv);
+
+    var option;
+    while ((option = parser.getopt())) {
+        switch (option.option) {
+        case 'h':
+            usage();
+            process.exit(0);
+            break;
+        default:
+            usage();
+            process.exit(1);
+            break;
+        }
+    }
+
+    var args = process.argv.slice(parser.optind());
+    var cmd = args.shift();
+
+    /*
+     * Put 2 empty elements in front of the existing "args" this can be removed
+     * if posix-getopt is updated to v1.2.0. see: davepacheco/node-getopt pull
+     * request #3
+     */
+    args = ['', ''].concat(args);
+
+    switch (cmd) {
+    case 'ping':
+        do_ping(args);
+        break;
+    case 'status':
+        do_status(args);
+        break;
+    case 'vms':
+        do_vms(args);
+        break;
+    case 'vm':
+        do_vm(args);
+        break;
+    case 'events':
+        do_events(args);
+        break;
+    case 'help':
+        usage();
+        process.exit(0);
+        break;
+    case undefined:
+        usage('Command must be specified as the first argument');
+        process.exit(1);
+        break;
+    default:
+        usage('Unknown command: %s', cmd);
+        process.exit(1);
+        break;
+    }
+}
+main();
diff --git a/src/vm/sbin/vminfod.js b/src/vm/sbin/vminfod.js
new file mode 100755
index 00000000..80d03aad
--- /dev/null
+++ b/src/vm/sbin/vminfod.js
@@ -0,0 +1,68 @@
+#!/usr/node/bin/node --abort_on_uncaught_exception
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * Vminfod starting point
+ */
+
+var onlyif = require('/usr/node/node_modules/onlyif');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var Vminfod = require('../node_modules/vminfod/vminfod');
+
+var log = bunyan.createLogger({
+    name: 'vminfod',
+    level: 'debug',
+    serializers: bunyan.stdSerializers
+});
+
+function startVminfod() {
+    var opts = {
+        log: log
+    };
+    var vminfod = new Vminfod(opts);
+
+    log.info('Starting vminfod');
+
+    vminfod.start(function vminfodStartDone(err) {
+        if (err) {
+            log.fatal({err: err}, 'Failed to start vminfod');
+            process.exit(1);
+        }
+
+        log.info('Started vminfod');
+    });
+}
+
+onlyif.rootInSmartosGlobal(function rootInSmartosGlobalDone(err) {
+    if (err) {
+        log.error({err: err},
+            'Fatal: cannot run because: %s', err.message);
+        process.exit(1);
+    }
+
+    startVminfod();
+});
diff --git a/src/vm/smf/system-metadata.xml b/src/vm/smf/system-metadata.xml
index 055a7cf3..ac8ec55a 100644
--- a/src/vm/smf/system-metadata.xml
+++ b/src/vm/smf/system-metadata.xml
@@ -10,6 +10,10 @@
       <service_fmri value='svc:/system/filesystem/local'/>
     </dependency>
 
+    <dependency name="vminfod" grouping="require_all" restart_on="none" type="service" >
+      <service_fmri value="svc:/system/smartdc/vminfod:default" />
+    </dependency>
+
     <exec_method
       type="method"
       name="start"
diff --git a/src/vm/smf/system-vmadmd.xml b/src/vm/smf/system-vmadmd.xml
index b55b3846..28805417 100644
--- a/src/vm/smf/system-vmadmd.xml
+++ b/src/vm/smf/system-vmadmd.xml
@@ -11,6 +11,10 @@
       <service_fmri value="svc:/system/smartdc/init"/>
     </dependency>
 
+    <dependency name="vminfod" grouping="require_all" restart_on="none" type="service" >
+      <service_fmri value="svc:/system/smartdc/vminfod:default" />
+    </dependency>
+
     <exec_method
       type="method"
       name="start"
diff --git a/src/vm/smf/system-vminfod b/src/vm/smf/system-vminfod
new file mode 100755
index 00000000..bb37543b
--- /dev/null
+++ b/src/vm/smf/system-vminfod
@@ -0,0 +1,53 @@
+#!/bin/bash
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+# Use is subject to license terms.
+
+set -o xtrace
+
+. /lib/svc/share/smf_include.sh
+
+PATH=/usr/sbin:/usr/bin; export PATH
+
+case "$1" in
+'start')
+    ctrun -l child -o noorphan /usr/vm/sbin/vminfod 2>&1 &
+    pid=$!
+    # Don't consider the service "online" until vminfod is responsive over the
+    # HTTP interface.  If vminfod fails for any reason this line will run until
+    # SMF brings this service into maintenance mode, or until the vminfod
+    # process dies.
+    while ! vminfo ping && kill -0 "$pid"; do
+        sleep 1
+    done
+    ;;
+
+'stop')
+    ;;
+
+*)
+    echo "Usage: $0 { start | stop }"
+    exit $SMF_EXIT_ERR_FATAL
+    ;;
+esac
+exit $SMF_EXIT_OK
diff --git a/src/vm/smf/system-vminfod.xml b/src/vm/smf/system-vminfod.xml
new file mode 100644
index 00000000..6c355110
--- /dev/null
+++ b/src/vm/smf/system-vminfod.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<service_bundle type="manifest" name="vminfod">
+  <service name="system/smartdc/vminfod" type="service" version="1.0.0">
+
+    <create_default_instance enabled="true"/>
+    <single_instance/>
+
+    <dependency name='filesystem-local' grouping='require_all' restart_on='none' type='service'>
+      <service_fmri value='svc:/system/filesystem/local'/>
+    </dependency>
+
+    <exec_method
+      type="method"
+      name="start"
+      exec="/usr/vm/smf/system-vminfod %m"
+      timeout_seconds="300">
+      <method_context working_directory='/'>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="300">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <property_group name="application" type="application">
+    </property_group>
+
+    <stability value="Evolving"/>
+
+    <template>
+      <common_name>
+        <loctext xml:lang="C">VM Info Daemon (node)</loctext>
+      </common_name>
+    </template>
+
+  </service>
+</service_bundle>
diff --git a/src/vm/tests/common.js b/src/vm/tests/common.js
new file mode 100644
index 00000000..f7474da4
--- /dev/null
+++ b/src/vm/tests/common.js
@@ -0,0 +1,129 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var f = require('util').format;
+var cp = require('child_process');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+
+function vmadm(args, opts, callback) {
+    assert.arrayOfString(args, 'args');
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.stdin, 'opts.stdin');
+    assert.func(callback, 'callback');
+
+    var child;
+    var fds = {stdout: '', stderr: ''};
+    var log = opts.log;
+
+    child = cp.spawn('/usr/vm/sbin/vmadm', args, {stdio: 'pipe'});
+    log.debug('vmadm running with pid %d', child.pid);
+
+    if (opts.stdin) {
+        child.stdin.write(opts.stdin);
+    }
+    child.stdin.end();
+
+    child.stdout.setEncoding = 'utf8';
+    child.stdout.on('data', function (d) {
+        fds.stdout += d;
+    });
+
+    child.stderr.setEncoding = 'utf8';
+    child.stderr.on('data', function (d) {
+        fds.stderr += d;
+    });
+
+    child.on('close', function (code, signal) {
+        var err = null;
+        var msg;
+
+        msg = f('vmadm [%d] exited. code %d signal %s',
+            child.pid, code, signal);
+
+        log.warn({pid: child.pid, code: code, signal: signal}, msg);
+
+        if (code !== 0) {
+            err = new Error(msg);
+        }
+
+        callback(err, fds);
+    });
+}
+
+function zfs(args, callback) {
+    assert.arrayOfString(args, 'args');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        encoding: 'utf8'
+    };
+    cp.execFile('/usr/sbin/zfs', args, opts, function (err, stdout, stderr) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        if (stderr) {
+            callback(new Error('stderr produced: ' + stderr));
+            return;
+        }
+
+        callback(null, stdout);
+    });
+}
+
+/*
+ * nodeunit-plus `t.ifError` is weird and ignores the second (msg) argument.
+ * This function is meant to be a replacement for `t.ifError` that honors the
+ * message.
+ */
+function ifError(t, err, msg) {
+    assert.object(t, 't');
+    assert.optionalObject(err, 'err');
+    assert.optionalString(msg, 'msg');
+
+    var result;
+
+    if (err) {
+        assert.object(err, 'err');
+        assert.string(err.message, 'err.message');
+    }
+
+    msg = msg || '(unnamed assert)';
+    result = err ? err.message : 'success';
+
+    msg = f('%s: %s', msg, result);
+
+    t.ok(!err, msg);
+}
+
+module.exports = {
+    ifError: ifError,
+    vmadm: vmadm,
+    zfs: zfs
+};
diff --git a/src/vm/tests/test-defaults.js b/src/vm/tests/test-defaults.js
index c541a850..244abf6a 100644
--- a/src/vm/tests/test-defaults.js
+++ b/src/vm/tests/test-defaults.js
@@ -1,11 +1,35 @@
-// Copyright 2018 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that default values don't change accidentally.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ * These tests ensure that default values don't change accidentally.
+ */
 
 var execFile = require('child_process').execFile;
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -220,6 +244,8 @@ function check_values(t, state)
             continue;
         } else if (state.brand === 'kvm' && prop === 'pid') {
             continue;
+        } else if (prop.match(/^transition_/)) {
+            continue;
         } else if (!defaults.hasOwnProperty(prop)) {
             t.ok(false, 'unexpected property: ' + prop);
         }
@@ -279,12 +305,50 @@ test('check default create_timestamp', function (t) {
         do_not_inventory: true
     }, state, [
         function (cb) {
-            zonecfg(['-z', state.uuid, 'remove attr name=create-timestamp;'],
-                function (err, fds) {
-
-                t.ok(!err, 'removing create-timestamp: '
-                    + (err ? err.message : 'ok'));
-                cb(err);
+            var vs = new vminfod.VminfodEventStream('test-defaults.js');
+            vs.once('ready', function () {
+                vasync.parallel({
+                    funcs: [
+                        function (cb2) {
+                            var obj = {
+                                type: 'modify',
+                                zonename: state.uuid
+                            };
+                            var opts = {
+                                timeout: 30 * 1000,
+                                catchErrors: true,
+                                teardown: true
+                            };
+                            var changes = [
+                                {
+                                    path: ['create_timestamp'],
+                                    action: 'changed'
+                                }
+                            ];
+                            vs.watchForChanges(obj, changes, opts,
+                                function (err) {
+                                if (err) {
+                                    cb2(err);
+                                    return;
+                                }
+
+                                cb2();
+                            });
+                        },
+                        function (cb2) {
+                            zonecfg(['-z', state.uuid,
+                                'remove attr name=create-timestamp;'],
+                                function (err, fds) {
+
+                                t.ok(!err, 'removing create-timestamp: '
+                                    + (err ? err.message : 'ok'));
+                                cb2(err);
+                            });
+                        }
+                    ]
+                }, function (err) {
+                    cb(err);
+                });
             });
         }, function (cb) {
             VM.load(state.uuid, function (err, obj) {
diff --git a/src/vm/tests/test-delete.js b/src/vm/tests/test-delete.js
index c030b91d..b10d3e0c 100644
--- a/src/vm/tests/test-delete.js
+++ b/src/vm/tests/test-delete.js
@@ -20,14 +20,14 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  * These tests ensure that delete behaves correctly.
  */
 
 var libuuid = require('/usr/node/node_modules/uuid');
-var VM = require('/usr/vm/node_modules/VM');
 var vasync = require('/usr/vm/node_modules/vasync');
+var VM = require('/usr/vm/node_modules/VM');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -48,7 +48,7 @@ test('test deleting nonexistent VM', function(t) {
             var uuid = libuuid.create();
             t.ok(uuid, 'uuid is: ' + uuid);
             VM.delete(uuid, {}, function (err) {
-                if (err && err.message.match(/No such zone configured/)) {
+                if (err && err.code === 'ENOENT') {
                     t.ok(true, 'zone ' + uuid + ' already does not exist, skipping');
                 } else {
                     t.ok(!err, 'deleted VM: ' + (err ? err.message : 'success'));
diff --git a/src/vm/tests/test-diff.js b/src/vm/tests/test-diff.js
new file mode 100644
index 00000000..5ddf68d2
--- /dev/null
+++ b/src/vm/tests/test-diff.js
@@ -0,0 +1,262 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var util = require('util');
+
+var diff = require('/usr/vm/node_modules/diff');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+function copy(o) {
+    return JSON.parse(JSON.stringify(o));
+}
+
+[
+    undefined,
+    null,
+    new Date(),
+    function func() {},
+    '',
+    'a',
+    5,
+    [],
+    ['foo'],
+    [['foo']],
+    [{name: 'foo'}],
+    {},
+    [function arrayFunc() {}],
+    {func: function objFunc() {}},
+    {name: 'foo'},
+    {names: ['foo','bar']},
+    {things: [{name: 'foo'}]}
+].forEach(function (o) {
+    test('test diff objects that are the same: '
+        + util.inspect(o), function (t) {
+
+        var changes = diff(o, o);
+        t.ok(Array.isArray(changes), 'changes is an array');
+        t.equal(changes.length, 0, 'changes is an empty array');
+        t.end();
+    });
+});
+
+test('test diff simple objects', function (t) {
+    var changes;
+    var change;
+
+    var o1 = {
+        id: 1,
+        name: 'foo'
+    };
+    var o2 = {
+        id: 1,
+        name: 'bar'
+    };
+
+    // compare objects
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+
+    // assert return
+    change = changes[0];
+    t.equal(change.path[0], ['name'], 'path changed');
+    t.equal(change.prettyPath, 'name', 'path changed (pretty)');
+    t.equal(change.action, 'changed', 'action changed');
+    t.equal(change.oldValue, 'foo', 'path changed from foo');
+    t.equal(change.newValue, 'bar', 'path changed to bar');
+
+    // modify object and compare again
+    o2.id = 2;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 2, 'two changes');
+
+    // assert return
+    t.equal(changes[0].path[0], 'id', 'id changed');
+    t.equal(changes[0].prettyPath, 'id', 'id changed (pretty)');
+    t.equal(changes[0].action, 'changed', 'action changed');
+    t.equal(changes[0].oldValue, o1.id, 'id changed from');
+    t.equal(changes[0].newValue, o2.id, 'id changed to');
+
+    t.equal(changes[1].path[0], 'name', 'name changed');
+    t.equal(changes[1].prettyPath, 'name', 'name changed (pretty)');
+    t.equal(changes[1].action, 'changed', 'action changed');
+    t.equal(changes[1].oldValue, o1.name, 'name changed from');
+    t.equal(changes[1].newValue, o2.name, 'name changed to');
+
+    // make them the same
+    o2.id = o1.id;
+    o2.name = o1.name;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 0, 'no changes');
+
+    t.end();
+});
+
+test('test diff nested objects', function (t) {
+    var changes;
+    var change;
+
+    var o1 = {
+        foo: {
+            bar: {
+                baz: 'hello'
+            }
+        }
+    };
+    var o2 = {
+        foo: {
+            bar: {
+                baz: 'goodbye'
+            }
+        }
+    };
+
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo', 'bar', 'baz'], 'path is correct');
+    t.equal(change.prettyPath, 'foo.bar.baz', 'path is correct (pretty)');
+    t.equal(change.action, 'changed', 'action changed');
+    t.equal(change.oldValue, 'hello', 'changed from');
+    t.equal(change.newValue, 'goodbye', 'changed to');
+
+    // make them the same
+    o2.foo.bar.baz = 'hello';
+
+    // add a new element
+    o2.foo.bar.bat = 'new';
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo', 'bar', 'bat'], 'path is correct');
+    t.equal(change.prettyPath, 'foo.bar.bat', 'path is correct (pretty)');
+    t.equal(change.action, 'added', 'action added');
+    t.equal(change.newValue, 'new', 'changed to');
+
+    // remove o2.foo completely
+    delete o2.foo;
+    changes = diff(o1, o2);
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['foo'], 'path is correct');
+    t.equal(change.prettyPath, 'foo', 'path is correct (pretty)');
+    t.equal(change.action, 'removed', 'action removed');
+    t.deepEqual(change.oldValue, o1.foo, 'changed from');
+
+    t.end();
+});
+
+
+test('test diff vmadm payload objects', function (t) {
+    var changes;
+    var change;
+
+    var base_payload = {
+        id: 1,
+        alias: 'fake-vm',
+        disks: [
+            {
+                path: '/',
+                name: 'slash'
+            }
+        ]
+    };
+    var payload1 = copy(base_payload);
+    var payload2 = copy(base_payload);
+
+    // add a disk to payload2
+    var new_disk = {
+        path: '/data',
+        name: 'data'
+    };
+    payload2.disks.push(new_disk);
+
+    // compare objects
+    changes = diff(payload1, payload2);
+    t.equal(changes.length, 1, 'one change');
+
+    // assert return
+    change = changes[0];
+    t.deepEqual(change.path, ['disks', null], 'path changed');
+    t.equal(change.prettyPath, 'disks.*', 'path changed (pretty)');
+    t.equal(change.action, 'added', 'action changed');
+    t.equal(change.newValue, new_disk, 'disk added');
+
+    // reset disks
+    payload1.disks = [
+        {
+            path: '/',
+            name: 'old'
+        }
+    ];
+    payload2.disks = [
+        {
+            path: '/',
+            name: 'new'
+        }
+    ];
+
+    // without a map, this will be reported as 2 changes, 'old' being deleted
+    // and 'new' being added
+    // compare objects
+    changes = diff(payload1, payload2);
+    t.equal(changes.length, 2, 'two changes');
+
+    t.deepEqual(changes[0].path, ['disks', null], 'disks changed');
+    t.equal(changes[0].prettyPath, 'disks.*', 'disks changed (pretty)');
+    t.equal(changes[0].action, 'removed', 'action');
+    t.equal(changes[0].oldValue, payload1.disks[0], 'disks changed from');
+
+    t.deepEqual(changes[1].path, ['disks', null], 'disks changed');
+    t.equal(changes[1].prettyPath, 'disks.*', 'disks changed (pretty)');
+    t.equal(changes[1].action, 'added', 'action');
+    t.equal(changes[1].newValue, payload2.disks[0], 'disks changed to');
+
+    // with a map, this will be reported as 1 change, 'disks.*.name' changing
+    // from 'old' to 'new'
+    changes = diff(payload1, payload2, {
+        map: {
+            disks: 'path'
+        }
+    });
+    t.equal(changes.length, 1, 'one change');
+    change = changes[0];
+
+    t.deepEqual(change.path, ['disks', null, 'name'], 'disks changed');
+    t.equal(change.prettyPath, 'disks.*.name', 'disks changed (pretty)');
+    t.equal(change.action, 'changed', 'action');
+    t.equal(change.oldValue, payload1.disks[0].name, 'disks changed from');
+    t.equal(change.newValue, payload2.disks[0].name, 'disks changed to');
+    t.equal(change.ident, payload1.disks[0].path, 'disks changed ident');
+
+    // assert return
+    t.end();
+});
diff --git a/src/vm/tests/test-docker.js b/src/vm/tests/test-docker.js
index 19050933..58a30567 100644
--- a/src/vm/tests/test-docker.js
+++ b/src/vm/tests/test-docker.js
@@ -1,9 +1,34 @@
-// Copyright (c) 2018, Joyent, Inc.
-//
-// These tests ensure that docker flag works as expected when setting/unsetting
-// Also test that /etc/resolv.conf, /etc/hosts and /etc/hostname are set
-// correctly.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * These tests ensure that docker flag works as expected when
+ * setting/unsetting.  Also test that /etc/resolv.conf, /etc/hosts and
+ * /etc/hostname are set correctly.
+ */
 
 var async = require('/usr/node/node_modules/async');
 var EventEmitter = require('events').EventEmitter;
@@ -11,9 +36,9 @@ var exec = require('child_process').exec;
 var fs = require('fs');
 var libuuid = require('/usr/node/node_modules/uuid');
 var path = require('path');
-var SyseventStream = require('/usr/vm/node_modules/sysevent-stream');
 var util = require('util');
 var VM = require('/usr/vm/node_modules/VM');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -738,7 +763,8 @@ test('test docker VM with "docker:extraHosts"', function (t) {
     payload.docker = true;
     payload.autoboot = false;
     payload.internal_metadata = {
-        'docker:extraHosts': '["foo:1.2.3.4"]'
+        'docker:extraHosts': '["foo:1.2.3.4"]',
+        'docker:cmd': '["sleep","5"]'
     };
 
     vmtest.on_new_vm(t, image_uuid, payload, state, [
@@ -1242,9 +1268,9 @@ test('test restart delay reset', function (t) {
     var emitter = new EventEmitter();
     var events = [];
     var payload = JSON.parse(JSON.stringify(common_payload));
-    var se;
     var state = {brand: payload.brand};
     var num_cycles = (cycles_fail * 2) + 1;
+    var vs;
 
     payload.autoboot = false;
     payload.brand = 'lx';
@@ -1260,59 +1286,79 @@ test('test restart delay reset', function (t) {
             + '\"mkdir -p /var/tmp; '
             + '[[ $(ls -1 /var/tmp | wc -l) == ' + cycles_fail + ' ]] '
             + '&& (sleep ' + cycle_reset_delay + '; rm -f /var/tmp/*; exit 0) '
-            + '|| (touch /var/tmp/$(/native/usr/bin/uuid); exit 1)\"]',
+            + '|| (touch /var/tmp/$(/native/usr/bin/uuid); sleep 2; exit 1)\"]',
         'docker:restartpolicy': 'always'
     };
     payload.kernel_version = '3.13.0';
 
     vmtest.on_new_vm(t, payload.image_uuid, payload, state, [
         function (cb) {
+            var restartKeys = [
+                'internal_metadata.docker:restartcount',
+                'internal_metadata.docker:restartdelay'
+            ];
+            var running = false;
             var starts = 0;
             var stops = 0;
 
-            se = new SyseventStream({
-                class: 'status',
-                channel: 'com.sun:zones:status'
-            });
-            se.on('readable', function () {
+            vs = new vminfod.VminfodEventStream('test-docker.js');
+            vs.on('readable', function () {
+                var dockerRestartKeysHaveChanged;
                 var ev;
                 var im;
 
                 // for each start/stop, if it's for the VM we just created we'll
                 // push an event on the events array.
-                while ((ev = se.read()) !== null) {
-                    if (ev.data.zonename === state.uuid) {
-                        if (ev.data.newstate === 'uninitialized') {
-                            // VM went to state === 'stopped'
-                            im = JSON.parse(fs.readFileSync('/zones/'
-                                + ev.data.zonename + '/config/metadata.json'))
-                                .internal_metadata;
-                            stops++;
-                            events.push({
-                                action: 'stop',
-                                time: ev.data.when,
-                                restartcount: im['docker:restartcount'],
-                                restartdelay: im['docker:restartdelay']
-                            });
-                        } else if (ev.data.newstate === 'running') {
-                            // VM went to state === 'running'
-                            starts++;
-                            events.push({
-                                action: 'start',
-                                time: ev.data.when
-                            });
-                        }
+                while ((ev = vs.read()) !== null) {
+                    if (ev.zonename !== state.uuid)
+                        return;
+
+                    dockerRestartKeysHaveChanged = (ev.changes || []).map(
+                        function (change) {
+
+                        return (change.prettyPath);
+                    }).filter(function (p) {
+                        return (restartKeys.indexOf(p) > -1);
+                    }).length > 0;
+
+                    if (running && ev.vm.state === 'stopped') {
+                        // VM went to state === 'stopped'
+                        running = false;
+                        stops++;
+                        events.push({
+                            action: 'stop',
+                            time: ev.date
+                        });
+                    } else if (!running && ev.vm.state === 'running') {
+                        // VM went to state === 'running'
+                        running = true;
+                        starts++;
+                        events.push({
+                            action: 'start',
+                            time: ev.date
+                        });
+                    }
+
+                    if (dockerRestartKeysHaveChanged) {
+                        im = ev.vm.internal_metadata;
+                        events.push({
+                            action: 'docker-keys-changed',
+                            time: ev.date,
+                            restartcount: im['docker:restartcount'],
+                            restartdelay: im['docker:restartdelay']
+                        });
                     }
                 }
 
                 if (starts >= num_cycles && stops >= num_cycles) {
                     // stop the zoneevent watcher
-                    se.stop();
-                    se = null;
+                    vs.stop();
+                    vs = null;
                     emitter.emit('done');
                 }
             });
-            se.once('ready', function () {
+
+            vs.once('ready', function () {
                 cb();
             });
         }, function (cb) {
@@ -1336,35 +1382,32 @@ test('test restart delay reset', function (t) {
                 // next start (this will be the restart delay + the time it
                 // actually takes to start).
                 events.forEach(function (evt) {
-                    if (evt.action === 'start') {
+                    switch (evt.action) {
+                    case 'start':
                         if (last_stop > 0) {
-                            deltas.push((evt.time - last_stop) / 1000000);
+                            deltas.push(evt.time - last_stop);
                         }
-                    } else if (evt.action === 'stop') {
+                        break;
+                    case 'stop':
                         last_stop = evt.time;
-                    } else {
+                        break;
+                    case 'docker-keys-changed':
+                        break;
+                    default:
                         throw (new Error('Unexpected action: ' + evt.action));
                     }
                 });
 
-                // Only 'stop' events have a restartcount, so create an array
-                // just of the restart counts.
+                // Create an array just of the restart counts.
                 restartcounts = events.filter(function (evt) {
-                    if (evt.action === 'stop') {
-                        return (true);
-                    }
-                    return (false);
+                    return (evt.action === 'docker-keys-changed');
                 }).map(function (evt) {
                     return (evt.restartcount);
                 });
 
-                // Only 'stop' events have a restartdelay, so create an array
-                // just of the restart delays.
+                // Create an array just of the restart delays.
                 restartdelays = events.filter(function (evt) {
-                    if (evt.action === 'stop') {
-                        return (true);
-                    }
-                    return (false);
+                    return (evt.action === 'docker-keys-changed');
                 }).map(function (evt) {
                     return (evt.restartdelay);
                 });
@@ -1435,10 +1478,10 @@ test('test restart delay reset', function (t) {
             });
         }
     ], function () {
-        // stop the zoneevent watcher
-        if (se != null) {
-            se.stop();
-            se = null;
+        // stop the vminfod watcher
+        if (vs !== null) {
+            vs.stop();
+            vs = null;
         }
 
         t.end();
diff --git a/src/vm/tests/test-fswatcher.js b/src/vm/tests/test-fswatcher.js
new file mode 100644
index 00000000..c3598934
--- /dev/null
+++ b/src/vm/tests/test-fswatcher.js
@@ -0,0 +1,525 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var execFile = require('child_process').execFile;
+var fs = require('fs');
+var path = require('path');
+var util = require('util');
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/vm/node_modules/bunyan');
+var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
+var vasync = require('/usr/vm/node_modules/vasync');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('/usr/vm/node_modules/nodeunit-plus');
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: 'fswatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'error' } ],
+    serializers: bunyan.stdSerializers
+});
+var testdir = path.join('/tmp', 'test-fswatcher-' + process.pid);
+
+test('try creating temp directory', function createTmpDir(t) {
+    execFile('/usr/bin/mkdir', ['-p', testdir],
+        function mkdir(err, stdout, stderr) {
+
+        assert.ifError(err);
+        t.end();
+    });
+});
+
+test('try starting and stopping watcher', function startAndStopTest(t) {
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+    t.ok(!fsw.isRunning(), 'watcher not running');
+
+    fsw.once('ready', function fswOnReady() {
+        t.ok(fsw.isRunning(), 'watcher running');
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.start();
+});
+
+test('try starting already running watcher',
+    function startAlreadyRunningTest(t) {
+
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+
+    fsw.once('ready', function fswOnReady() {
+        t.ok(fsw.isRunning(), 'watcher running');
+        t.throws(function startThrow() {
+            fsw.start();
+        }, null, 'start twice');
+
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.start();
+});
+
+test('try stopping a stopped watcher', function stopAlreadyStoppedTest(t) {
+    var fsw = new FsWatcher({log: log});
+    t.ok(fsw, 'created watcher');
+    t.ok(!fsw.isRunning(), 'watcher not running');
+
+    t.throws(function stopThrow() {
+        fsw.stop(function noop() {});
+    }, null, 'stop stopped');
+
+    t.end();
+});
+
+test('try watching files with illegal characters',
+    function illegalFilenameTest(t) {
+
+    var fsw = new FsWatcher({log: log});
+
+    fsw.once('ready', function fswOnReady() {
+        vasync.forEachPipeline({
+            inputs: ['newline\nchar', 'nulbyte\0char'],
+            func: function watchInvalidFile(f, cb) {
+                fsw.watch(f, function (err) {
+                    t.ok(err, 'error is expected: '
+                        + JSON.stringify((err || {}).message));
+                    cb();
+                });
+            }
+        }, function doneWatchInvalidFile(err) {
+            fsw.stop(function fswStop() {
+                t.end();
+            });
+        });
+    });
+
+    fsw.start();
+});
+
+test('try watching an existent file and catching CHANGE and DELETE',
+    function changeAndDeleteTest(t) {
+        var filename = path.join(testdir, 'hello.txt');
+        var saw_change = false;
+        var saw_delete = false;
+
+        var fsw = new FsWatcher({log: log});
+
+        fs.writeFileSync(filename, 'hello world\n');
+        t.ok(fs.existsSync(filename), 'file was created');
+
+        fsw.on('delete', function fswOnDelete(evt) {
+            t.equal(evt.pathname, filename, 'delete was for correct filename');
+            t.ok(saw_change, 'at delete time, already saw change');
+            saw_delete = true;
+            cleanup();
+        });
+
+        fsw.on('change', function fswOnChange(evt) {
+            t.equal(evt.pathname, filename, 'change was for correct filename');
+            t.ok(!saw_delete, 'at change time, did not yet see delete');
+            if (!saw_change) {
+                // avoid doing twice if there are multiple changes
+                saw_change = true;
+                fs.unlinkSync(filename); // should trigger DELETE
+            }
+        });
+
+        fsw.once('ready', function fswOnReady(evt) {
+            fsw.watch(filename, watchcb);
+        });
+
+        fsw.start();
+
+        function watchcb(err) {
+            t.ok(!err, (err ? err.message : 'started watching ' + filename));
+            if (err) {
+                cleanup();
+                return;
+            }
+
+            // should trigger CHANGE
+            fs.writeFileSync(filename, 'goodbye world\n');
+        }
+
+        function cleanup() {
+            fsw.unwatch(filename, function fswUnwatch() {
+                fsw.stop(function fswStop() {
+                    t.ok(saw_change, 'saw change event at cleanup');
+                    t.ok(saw_delete, 'saw delete event at cleanup');
+                    t.end();
+                });
+            });
+        }
+    }
+);
+
+test('try watching a non-existent file then create it',
+    function createWatchedFileTest(t) {
+
+    var filename = path.join(testdir, '/file/that/shouldnt/exist.txt');
+    var dirname = path.dirname(filename);
+    var saw_create = false;
+
+    var fsw = new FsWatcher({log: log});
+
+    fsw.once('ready', function fswOnReady(evt) {
+        vasync.pipeline({funcs: [
+            function (_, cb) {
+                fsw.watch(filename, cb);
+            }, function (_, cb) {
+                // create directory
+                execFile('/usr/bin/mkdir', ['-p', dirname],
+                    function mkdir(err, stdout, stderr) {
+                        t.ok(!err, 'mkdir -p ' + dirname);
+                        cb(err);
+                    }
+                );
+            }, function (_, cb) {
+                t.ok(!saw_create, 'haven\'t seen "create" event yet');
+                // create file
+                fs.writeFile(filename, 'hello world\n',
+                    function writeFileDone(err) {
+
+                    t.ok(!err, 'wrote "hello world" to ' + filename);
+                    cb(err);
+                });
+            }
+        ]}, function (err) {
+            if (err) {
+                t.ok(!err, err.message);
+                cleanup();
+            }
+        });
+    });
+
+    fsw.on('create', function fswOnCreate(evt) {
+        t.equal(evt.pathname, filename, 'saw create event for ' + filename);
+        saw_create = true;
+        cleanup();
+    });
+
+    fsw.start();
+
+    function cleanup() {
+        fsw.unwatch(filename, function fswUnwatch() {
+            fsw.stop(function fswStop() {
+                t.ok(saw_create, 'saw create event at cleanup');
+                t.end();
+            });
+        });
+    }
+});
+
+test('try watching an existent file, unwatching and ensure no events',
+    function strayEventsTest(t) {
+
+    var events_after_stop = 0;
+    var filename = path.join(testdir, 'tricky.txt');
+    var saw_change = false;
+    var stopped_watching = false;
+
+    var fsw = new FsWatcher({log: log});
+
+    fs.writeFileSync(filename, 'look at me, I\'m so tricky!\n');
+    t.ok(fs.existsSync(filename), 'file was created');
+
+    fsw.on('event', function fswOnEvent(evt) {
+        if (stopped_watching) {
+            events_after_stop++;
+        }
+    });
+
+    fsw.on('change', function fswOnChange(evt) {
+        t.equal(evt.pathname, filename, 'change was for correct filename');
+        t.ok(!stopped_watching, 'when change event happened, we have not '
+            + 'stopped watching');
+
+        // avoid doing twice if there are multiple changes
+        if (saw_change)
+            return;
+
+        saw_change = true;
+
+        if (stopped_watching)
+            return;
+
+        fsw.unwatch(filename, function fswUnwatch() {
+            stopped_watching = true;
+
+            // would trigger DELETE, but we shouldn't get it.
+            fs.unlinkSync(filename);
+
+            // leave some time for rogue events to show up
+            setTimeout(function waitForMorePossibleEvents() {
+                fsw.stop(function fswStop() {
+                    t.equal(events_after_stop, 0, 'should not see events '
+                        + 'after stopping');
+                    t.end();
+                });
+            }, 2000);
+        });
+    });
+
+    fsw.once('ready', function fswOnReady(evt) {
+        fsw.watch(filename, function fswWatch(err) {
+            fs.writeFileSync(filename, 'now we are writing junk!\n');
+            // now change event should have been triggered and we should
+            //  have stopped watcher. Control should pass to
+            // fsw.on('change'... above.
+            return;
+        });
+    });
+
+    fsw.start();
+});
+
+test('create a file and ensure we get multiple modify events',
+    function multipleModifyEventsTest(t) {
+
+    var filename = path.join(testdir, 'changeme.txt');
+
+    var fsw = new FsWatcher({log: log});
+
+    fs.writeFileSync(filename, 'initial data\n');
+    t.ok(fs.existsSync(filename), 'file was created');
+
+    fsw.on('event', function fswOnEvent(evt) {
+        t.ok(evt.changes.indexOf('FILE_MODIFIED') > -1,
+            'type of "event" event is "change"');
+    });
+
+    fsw.on('change', function fswOnChange(evt) {
+        t.equal(evt.pathname, filename, 'change was for correct filename');
+        fsw.stop(function fswStop() {
+            t.end();
+        });
+    });
+
+    fsw.once('ready', function fswOnReady(evt) {
+        fsw.watch(filename, function fswWatch(err) {
+            fs.writeFileSync(filename, 'first modification!\n');
+            return;
+        });
+    });
+
+    fsw.start();
+});
+
+test('watch 10000 non-existent files, create them, modify them and delete them',
+    function createManyFilesTest(t) {
+
+    var then = new Date();
+
+    var count = 10000;
+    var fsw = new FsWatcher({log: log});
+    var files = [];
+
+    // events seen per file
+    var events = {};
+
+    // events seen
+    var seen = {
+        create: 0,
+        change: 0,
+        delete: 0
+    };
+
+    // array of filenames to watch and manage
+    for (var i = 0; i < count; i++) {
+        var filename = path.join(testdir, 'testfile.' + i);
+        files.push(filename);
+        events[filename] = [];
+    }
+
+    // Because we are managing a large number of files, a vasync queue is used
+    // to manage all file creations, modifications, and deletions.
+    var q = vasync.queue(function vasyncQueue(task, cb) {
+        task(cb);
+    }, 100);
+
+    // deadman switch - we stop this if it takes too long
+    var timeout = setTimeout(function killSwitch() {
+        var e = new Error('timeout exceeded');
+        cleanup(e);
+    }, 60 * 1000);
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // start the FsWatcher
+            fsw.once('ready', function fswOnReady(evt) {
+                cb();
+            });
+            fsw.start();
+        }, function (_, cb) {
+            // start watching for events
+            var done = 0;
+
+            fsw.on('create', function fswOnCreate(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.create++;
+                events[evt.pathname].push('create-seen');
+
+                // modify the file - triggers 'change' event
+                q.push(function modifyFileToTriggerChange(cb2) {
+                    events[evt.pathname].push('change');
+                    fs.truncate(evt.pathname, 0, cb2);
+                });
+            });
+
+            fsw.on('change', function fswOnChange(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                if (events[evt.pathname].indexOf('change-seen') > -1) {
+                    log.error({evt: evt},
+                        'change event already seen for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.change++;
+                events[evt.pathname].push('change-seen');
+
+                // delete the file - triggers 'delete' event
+                q.push(function deleteFileToTriggerDelete(cb2) {
+                    events[evt.pathname].push('delete');
+                    fs.unlink(evt.pathname, cb2);
+                });
+            });
+
+            fsw.on('delete', function fswOnDelete(evt) {
+                if (!evt.pathname.match(/\/testfile.[0-9]+$/)) {
+                    log.error({evt: evt},
+                        'throwing out event for file %s',
+                        evt.pathname);
+                    return;
+                }
+
+                seen.delete++;
+                events[evt.pathname].push('delete-seen');
+
+                fsw.unwatch(evt.pathname, function fswUnwatch() {
+                    delete events[evt.pathname];
+                    // check if we're done
+                    if (++done === count) {
+                        clearTimeout(timeout);
+                        cleanup();
+                    }
+                });
+            });
+
+            cb();
+        }, function (_, cb) {
+            // add watches for all non-existent files
+            vasync.forEachParallel({
+                func: function watchNonexistentFile(f, cb2) {
+                    events[f].push('watch');
+                    fsw.watch(f, cb2);
+                },
+                inputs: files
+            }, function (err) {
+                t.ok(!err, (err ? err.message : 'no errors'));
+                cb();
+            });
+        }, function (_, cb) {
+            // all files are being watched, create them
+            vasync.forEachParallel({
+                func: function createNewFile(f, cb2) {
+                    q.push(function createNewFileTask(cb3) {
+                        var data = 'foo ' + f;
+                        fs.writeFile(f, data, function writeFileDone(err) {
+                            events[f].push('create');
+                            cb3(err); // tell queue we're done
+                            cb2(err); // tell forEachParallel we're done
+                        });
+                    });
+                },
+                inputs: files
+            }, function (err) {
+                t.ok(!err, (err ? err.message : 'no errors'));
+                cb();
+            });
+        }
+    ]}, function (err) {
+        // control is passed onto fsw events now
+    });
+
+    function cleanup(err) {
+        var now = new Date();
+        var delta = now - then;
+        t.ok(!err, (err ? err.message : 'no errors'));
+        t.ok(true, 'took ' + delta + 'ms to complete');
+
+        Object.keys(seen).forEach(function eventSeen(ev) {
+            t.equal(seen[ev], count,
+                util.format('have seen %d / %d %s events',
+                seen[ev], count, ev));
+        });
+
+        var keys = Object.keys(events);
+        t.equal(keys.length, 0, '0 files left');
+        if (keys.length > 0) {
+            console.error(events);
+        }
+
+        fsw.status(function fswStatus(_, obj) {
+            if (err) {
+                log.error({obj: obj}, 'fswatcher status before exit');
+            }
+            fsw.stop(function fswStop() {
+                t.end();
+            });
+        });
+    }
+});
+
+test('cleanup', function testCleanup(t) {
+    t.ok(true, 'cleaning up');
+    execFile('/usr/bin/rm', ['-rf', testdir],
+        function removeTmpDir(err, stdout, stderr) {
+            t.ok(!err, (err ? err.message : 'cleaned up'));
+            t.end();
+        }
+    );
+});
diff --git a/src/vm/tests/test-internal_metadata_namespaces.js b/src/vm/tests/test-internal_metadata_namespaces.js
index cacb8cb0..e80256f2 100644
--- a/src/vm/tests/test-internal_metadata_namespaces.js
+++ b/src/vm/tests/test-internal_metadata_namespaces.js
@@ -1,20 +1,48 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that the internal_metadata_namespaces feature:
-//
-//  * shows up in KEYS when internal_metadata has namespaced key
-//  * does not allow PUT to namespaced key from in the zone
-//  * does not allow DELETE to namespaced key from in the zone
-//  * shows GET result from internal_metadata for namespaced keys
-//  * does not interfere with PUT or DELETE on non-namespaced keys
-//  * does not show non-namespaced internal_metadata keys
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * These tests ensure that the internal_metadata_namespaces feature:
+ *
+ *  * shows up in KEYS when internal_metadata has namespaced key
+ *  * does not allow PUT to namespaced key from in the zone
+ *  * does not allow DELETE to namespaced key from in the zone
+ *  * shows GET result from internal_metadata for namespaced keys
+ *  * does not interfere with PUT or DELETE on non-namespaced keys
+ *  * does not show non-namespaced internal_metadata keys
+ */
 
 var async = require('/usr/node/node_modules/async');
 var exec = require('child_process').exec;
 var fs = require('fs');
+var util = require('util');
 var utils = require('/usr/vm/node_modules/utils');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -109,17 +137,53 @@ test('test exercising internal_metadata_namespaces', function (t) {
 
     vmtest.on_new_vm(t, image_uuid, payload, state, [
         function (cb) {
-            // replace metadata.json with version that tells us which we got
-            fs.writeFile('/zones/' + state.uuid + '/config/metadata.json',
-                JSON.stringify(metadata, null, 2) + '\n',
-                function (err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    cb();
-                }
-            );
+            var vs = new vminfod.VminfodEventStream({
+                name: 'test-internal_metadata_namespaces.js'
+            });
+            vs.on('ready', function () {
+                vasync.parallel({funcs: [
+                    function (cb2) {
+                        var obj = {
+                            type: 'modify',
+                            zonename: state.uuid,
+                            vm: metadata
+                        };
+
+                        var opts = {
+                            timeout: 30 * 1000,
+                            catchErrors: true,
+                            teardown: true
+                        };
+
+                        vs.watchForEvent(obj, opts,
+                            function (err) {
+                            if (err) {
+                                cb2(err);
+                                return;
+                            }
+
+                            cb2();
+                        });
+                    },
+                    function (cb2) {
+                        // replace metadata.json with version that tells us
+                        // which we got
+                        fs.writeFile('/zones/' + state.uuid
+                            + '/config/metadata.json',
+                            JSON.stringify(metadata, null, 2) + '\n',
+                            function (err) {
+                                if (err) {
+                                    cb2(err);
+                                    return;
+                                }
+                                cb2();
+                            }
+                        );
+                    }]
+                }, function (err) {
+                    cb(err);
+                });
+            });
         }, function (cb) {
             // Sanity check VM metadata
             VM.load(state.uuid, function (err, obj) {
diff --git a/src/vm/tests/test-lastexited.js b/src/vm/tests/test-lastexited.js
index 43bd35de..393ea0f6 100644
--- a/src/vm/tests/test-lastexited.js
+++ b/src/vm/tests/test-lastexited.js
@@ -1,15 +1,38 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that exit_status and exit_timestamp fields work as
-// expected when starting/stopping/zone exits
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * These tests ensure that exit_status and exit_timestamp fields work as
+ * expected when starting/stopping/zone exits
+ */
 
-var async = require('/usr/node/node_modules/async');
 var child_process = require('child_process');
-var exec = child_process.exec;
 var execFile = child_process.execFile;
 var fs = require('fs');
-var libuuid = require('/usr/node/node_modules/uuid');
+var path = require('path');
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
 
@@ -29,6 +52,7 @@ var common_payload = {
     max_swap: 1024
 };
 var image_uuid = vmtest.CURRENT_SMARTOS_UUID;
+var old_timestamp;
 
 function getExitFields(t, state, callback) {
     VM.load(state.uuid, function (err, obj) {
@@ -52,31 +76,35 @@ function waitInstalled(t, uuid, callback)
 {
     function _checkExists() {
         VM.load(uuid, function (err, obj) {
-            if (!fs.existsSync('/zones/' + uuid + '/lastexited')
-                || !obj || (obj.zone_state !== 'installed')) {
+            if (obj
+                && obj.zone_state === 'installed'
+                && old_timestamp !== obj.exit_timestamp) {
 
-                setTimeout(_checkExists, 100);
-            } else {
+                old_timestamp = obj.exit_timestamp;
                 t.ok(true, 'have lastexited');
                 callback();
+                return;
             }
+
+            setTimeout(_checkExists, 100);
         });
     }
     _checkExists();
 }
 
 function writeInit(uuid, contents, callback) {
-    var filename = '/zones/' + uuid + '/root/root/init';
+    var filename = path.join('/zones', uuid, 'root/root/init');
+    var opts = {
+        encoding: 'utf8',
+        mode: parseInt('0755', 8)
+    };
 
-    fs.writeFile(filename, contents, function (err) {
+    fs.writeFile(filename, contents, opts, function (err) {
         if (err) {
             callback(err);
             return;
         }
 
-        /*jsl:ignore*/
-        fs.chmodSync(filename, 0755);
-        /*jsl:end*/
         callback();
     });
 }
@@ -144,7 +172,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, 0, 'exit status 0');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
@@ -175,7 +203,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, 13, 'exit status 13');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
@@ -206,7 +234,7 @@ test('test lastexited not set, then set', function (t) {
 
                 t.equal(fields.zone_state, 'installed', 'zone is stopped');
                 t.equal(fields.exit_status, -9, 'exit status -9');
-                t.ok(fields.exit_timestamp != undefined, 'exit timestamp: '
+                t.ok(fields.exit_timestamp !== undefined, 'exit timestamp: '
                     + fields.exit_timestamp);
                 cb();
             });
diff --git a/src/vm/tests/test-queue.js b/src/vm/tests/test-queue.js
new file mode 100644
index 00000000..12358dc3
--- /dev/null
+++ b/src/vm/tests/test-queue.js
@@ -0,0 +1,361 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var Queue = require('/usr/vm/node_modules/queue').Queue;
+var bunyan = require('/usr/vm/node_modules/bunyan');
+var vasync = require('/usr/vm/node_modules/vasync');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('/usr/vm/node_modules/nodeunit-plus');
+
+var log = bunyan.createLogger({
+    level: 'error',
+    name: 'queue-test-dummy',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+test('test queue unpaused 100 tasks', function (t) {
+    var tasks = 100;
+
+    var q = new Queue({
+        log: log,
+        workers: 10
+    });
+
+    var i = 0;
+    for (var j = 0; j < tasks; j++) {
+        q.enqueue({
+            description: 'task ' + j,
+            func: function (extras, cb) {
+                i++;
+
+                if (i < tasks) {
+                    cb();
+                    return;
+                }
+
+                if (i === tasks) {
+                    t.ok(true, 'tasks completed');
+                    t.end();
+                    cb();
+                    return;
+                }
+
+                // something is wrong if we are here
+                t.ok(false, 'task ' + i + ' called');
+                cb();
+            }
+        });
+    }
+});
+
+test('test queue paused 100 tasks', function (t) {
+    var tasks = 100;
+    var queue_running = false;
+
+    var q = new Queue({
+        log: log,
+        paused: true,
+        workers: 10
+    });
+
+    var i = 0;
+    for (var j = 0; j < tasks; j++) {
+        q.enqueue({
+            description: 'task ' + j,
+            func: function (extras, cb) {
+                if (!queue_running) {
+                    t.ok(false, 'queue started too early');
+                    t.end();
+                    return;
+                }
+
+                if (++i === tasks) {
+                    t.ok(true, 'tasks completed');
+                    t.end();
+                }
+
+                cb();
+            }
+        });
+    }
+
+    setTimeout(function () {
+        // all tasks should still be enqueued as the queue is currently paused
+        t.equal(q.paused, true, 'queue is paused');
+        t.equal(q.paused_queue.length, tasks, 'tasks currently paused: '
+            + tasks);
+
+        queue_running = true;
+        q.resume();
+    }, 10);
+});
+
+test('test queue throws to prevent unintended states', function (t) {
+    var q = new Queue({
+        log: log,
+        workers: 1
+    });
+
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // ensure the queue is running
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // pause the queue and ensure it is stopped, pause is async
+            q.pause(function (err) {
+                testIsPaused();
+                cb(err);
+            });
+        }, function (_, cb) {
+            // resume the queue and ensure it is running, resume is sync
+            q.resume();
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // try to resume the queue again, should throw an error
+            t.throws(function () {
+                q.resume();
+            }, null, 'queue is already running');
+            testIsRunning();
+            cb();
+        }, function (_, cb) {
+            // pause the queue again and ensure it is stopped
+            q.pause(function (err) {
+                testIsPaused();
+                cb(err);
+            });
+        }, function (_, cb) {
+            // try to pause the queue again
+            t.throws(function () {
+                q.pause(function () {});
+            }, null, 'queue is already paused');
+            cb();
+        }
+    ]}, function (err) {
+        t.ok(!err, 'error: ' + (err ? err.message : 'none'));
+        t.end();
+    });
+
+    function testIsRunning() {
+        t.equal(q.paused, false, 'queue is running');
+    }
+    function testIsPaused() {
+        t.equal(q.paused, true, 'queue is paused');
+    }
+});
+
+test('test queue fast-forward', function (t) {
+    var ret;
+
+    var q = new Queue({
+        log: log,
+        workers: 5,
+        paused: true
+    });
+
+    var done = {
+        foo: false,
+        bar: false,
+        bat: false
+    };
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            done.foo = true;
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task foo enqueued');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            done.bar = true;
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task bar enqueued');
+
+    var time = process.hrtime();
+
+    // enqueue the 'bat' task after we grab the timestamp
+    setTimeout(function () {
+        ret = q.enqueue({
+            description: 'bat',
+            func: function (extras, cb) {
+                done.bat = true;
+                cb();
+            }
+        });
+        t.equal(ret, true, 'task bat enqueued');
+
+        // fast forward queue: this should process foo and bar, but not bat
+        q.fastForward(time, function (err) {
+            t.ok(!err, 'error: ' + (err ? err.message : 'none'));
+            t.equal(done.foo, true, 'task foo is done');
+            t.equal(done.bar, true, 'task bar is done');
+            t.equal(done.bat, false, 'task bat is not done');
+            t.end();
+        });
+    }, 5);
+});
+
+test('test deduplication', function (t) {
+    var ret;
+
+    var q = new Queue({
+        log: log,
+        workers: 5,
+        dedup: true,
+        paused: true
+    });
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task foo enqueued');
+
+    ret = q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, false, 'task foo is discarded');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, true, 'task bar enqueued');
+
+    ret = q.enqueue({
+        description: 'bar',
+        func: function (extras, cb) {
+            cb();
+        }
+    });
+    t.equal(ret, false, 'task bar is discarded');
+
+    t.end();
+});
+
+test('test queue idleTime instant', function (t) {
+    var isIdleCalled = false;
+
+    var q = new Queue({
+        log: log,
+        workers: 1,
+        paused: true
+    });
+
+    t.expect(6);
+
+    t.equal(q.idle, false, 'queue is not idle while paused');
+
+    q.resume();
+
+    t.equal(q.idle, true, 'queue idle when resumed');
+
+    q.enqueue({
+        description: 'foo',
+        func: function (extras, cb) {
+            t.equal(q.idle, false, 'queue not idle when running task');
+            setTimeout(cb, 5);
+        }
+    });
+
+    t.equal(q.idle, false, 'queue not idle when task was pushed');
+
+    q.once('idle', function () {
+        isIdleCalled = true;
+        t.equal(q.idle, true, 'queue idle when once("idle") called');
+    });
+
+    // sometime in the future after the task is done
+    setTimeout(function () {
+        t.equal(isIdleCalled, true, '"idle" event seen');
+        t.end();
+    }, 250);
+});
+
+test('test queue idleTime delay', function (t) {
+    var maxTasks = 10;
+
+    var tasksDone = [];
+    var i;
+
+    var q = new Queue({
+        log: log,
+        workers: 1,
+        idleTime: maxTasks * 10
+    });
+
+    t.expect(maxTasks + 2);
+
+    t.equal(q.idle, true, 'queue idle when created');
+
+    q.once('idle', function () {
+        t.equal(tasksDone.length, maxTasks, maxTasks + ' tasks done');
+        t.end();
+    });
+
+    function pushTask(_i) {
+        var ret = q.enqueue({
+            description: 'idleTime: ' + _i,
+            func: function (extras, cb) {
+                // the quickest possible task
+                tasksDone.push(_i);
+                cb();
+            }
+        });
+        t.equal(ret, true, 'task enqueued: ' + _i);
+    }
+
+    function enqueueDelayedTask(_i, delay) {
+        setTimeout(function () {
+            pushTask(_i);
+        }, delay);
+    }
+
+    for (i = 0; i < maxTasks; i++) {
+        enqueueDelayedTask(i, i*5);
+    }
+});
diff --git a/src/vm/tests/test-send-recv.js b/src/vm/tests/test-send-recv.js
index f1d19c1f..38166add 100644
--- a/src/vm/tests/test-send-recv.js
+++ b/src/vm/tests/test-send-recv.js
@@ -1,8 +1,33 @@
-// Copyright 2018 Joyent, Inc.  All rights reserved.
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
 
-var async = require('/usr/node/node_modules/async');
 var cp = require('child_process');
-var execFile = cp.execFile;
+var fs = require('fs');
+var util = require('util');
+
 var VM = require('/usr/vm/node_modules/VM');
 var vmtest = require('../common/vmtest.js');
 
@@ -12,11 +37,9 @@ require('nodeunit-plus');
 
 VM.loglevel = 'DEBUG';
 
-var abort = false;
-var bundle_filename;
 var image_uuid = vmtest.CURRENT_SMARTOS_UUID;
 var kvm_image_uuid = vmtest.CURRENT_UBUNTU_UUID;
-var vmobj;
+var VMADM = '/usr/vm/sbin/vmadm';
 
 var kvm_payload = {
     alias: 'test-send-recv-' + process.pid,
@@ -45,196 +68,252 @@ var smartos_payload = {
 };
 
 [['zone', smartos_payload], ['kvm', kvm_payload]].forEach(function (d) {
+    var abort = false;
+    var bundle_filename;
+    var vmobj;
+
     var thing_name = d[0];
     var thing_payload = d[1];
 
-    test('create ' + thing_name, function(t) {
+    test('create ' + thing_name, function (t) {
         VM.create(thing_payload, function (err, obj) {
             if (err) {
+                abort = true;
                 t.ok(false, 'error creating VM: ' + err.message);
                 t.end();
-            } else {
-                VM.load(obj.uuid, function (e, o) {
-                    // we wait 5 seconds here as there's a bug in the zone startup
-                    // where shutdown doesn't work while part of smf is still
-                    // starting itself. This should be fixed with OS-1027 when
-                    // that's in as we could then just wait for the zone to go from
-                    // 'provisioning' -> 'running' before continuing.
-                    setTimeout(function() {
-                        if (e) {
-                            t.ok(false, 'unable to load VM after create');
-                            abort = true;
-                            t.end()
-                            return;
-                        }
-                        vmobj = o;
-                        t.ok(true, 'created VM: ' + vmobj.uuid);
-                        t.end();
-                    }, 5000);
-                });
+                return;
             }
+
+            VM.load(obj.uuid, function (e, o) {
+                if (e) {
+                    t.ok(false, 'unable to load VM after create');
+                    abort = true;
+                    t.end();
+                    return;
+                }
+
+                vmobj = o;
+                t.ok(true, 'created VM: ' + vmobj.uuid);
+                t.end();
+            });
         });
     });
 
-    test('send ' + thing_name, function(t) {
+    test('send ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        bundle_filename = '/var/tmp/test.' + vmobj.uuid + '.vmbundle.' + process.pid;
 
-        cp.exec('/usr/vm/sbin/vmadm send ' + vmobj.uuid + ' > ' + bundle_filename,
-            function (error, stdout, stderr) {
-                if (error) {
-                    t.ok(false, 'vm send to ' + bundle_filename + ': ' + error.message);
+        bundle_filename = util.format('/var/tmp/test.%s.vmbundle.%d',
+            vmobj.uuid, process.pid);
+
+        var stderr = '';
+        var ws = fs.createWriteStream(bundle_filename);
+        var args = [
+            'send',
+            vmobj.uuid
+        ];
+
+        var child = cp.spawn(VMADM, args);
+        child.stdout.pipe(ws);
+        child.stderr.setEncoding('utf8');
+        child.stderr.on('data', function (data) {
+            stderr += data;
+        });
+
+        child.once('error', function (err) {
+            t.ok(false, util.format('vm send to "%s": %s',
+                bundle_filename, err.message));
+            abort = true;
+            t.end();
+        });
+
+        child.once('close', function (code) {
+            if (code !== 0) {
+                t.ok(false, util.format('vm send to "%s": code %d',
+                    bundle_filename, code));
+                abort = true;
+                console.error(stderr);
+                t.end();
+            }
+
+            VM.load(vmobj.uuid, function (e, o) {
+                if (e) {
+                    t.ok(false, 'reloading after send: ' + e.message);
                     abort = true;
                     t.end();
-                } else {
-                    VM.load(vmobj.uuid, function (e, o) {
-                        if (e) {
-                            t.ok(false, 'reloading after send: ' + e.message);
-                            abort = true;
-                        } else {
-                            t.ok(o.state === 'stopped', 'VM is stopped after send (actual: ' + o.state + ')');
-                        }
-                        t.end();
-                    });
+                    return;
                 }
-            }
-        );
+                t.ok(o.state === 'stopped', util.format(
+                    'VM is stopped after send (actual: %s)', o.state));
+                t.end();
+            });
+        });
     });
 
-    test('delete after sending ' + thing_name, function(t) {
+    test('delete after sending ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        if (vmobj.uuid) {
-            VM.delete(vmobj.uuid, function (err) {
-                if (err) {
-                    t.ok(false, 'error deleting VM: ' + err.message);
-                    abort = true;
-                } else {
-                    t.ok(true, 'deleted VM: ' + vmobj.uuid);
-                }
-                t.end();
-            });
-        } else {
+
+        if (!vmobj.uuid) {
             t.ok(false, 'no VM to delete');
             abort = true;
             t.end();
+            return;
         }
+
+        VM.delete(vmobj.uuid, function (err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + err.message);
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            t.end();
+        });
     });
 
-    test('receive ' + thing_name, function(t) {
+    test('receive ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
 
-        cp.exec('/usr/vm/sbin/vmadm recv < ' + bundle_filename,
-            function (error, stdout, stderr) {
-                var ival;
-                var loading = false;
-                var loops = 0;
+        var rs = fs.createReadStream(bundle_filename);
+        var stderr = '';
+
+        var child = cp.spawn(VMADM, ['recv']);
+        rs.pipe(child.stdin);
+        child.stderr.setEncoding('utf8');
+        child.stderr.on('data', function (data) {
+            stderr += data;
+        });
+
+        child.once('error', function (err) {
+            t.ok(false, util.format('vm send to "%s": %s',
+                bundle_filename, err.message));
+            abort = true;
+            t.end();
+        });
+
+        child.once('close', function (code) {
+            // we don't really care if this works, this is just cleanup.
+            try {
+                fs.unlinkSync(bundle_filename);
+            } catch (e) {}
+
+            if (code !== 0) {
+                t.ok(false, util.format('vm send to "%s": code %d',
+                    bundle_filename, code));
+                console.error(stderr);
+                abort = true;
+                t.end();
+            }
 
-                // we don't really care if this works, this is just cleanup.
-                cp.exec('rm -f ' + bundle_filename, function() {});
+            var started = Math.floor(Date.now() / 1000);
+            function waitForZoneToSettle() {
+                var now = Math.floor(Date.now() / 1000);
 
-                if (error) {
-                    t.ok(false, 'vm recv from ' + bundle_filename + ': ' + error.message);
+                if (now - started > 120) {
+                    t.ok(false, 'Timeout waiting for zone to settle');
                     abort = true;
                     t.end();
-                } else {
-                    obj = {};
-
-                    ival = setInterval(function () {
-                        if (loading === false) {
-                            loading = true;
-                        } else {
-                            // already loading, skip;
-                            loops = loops + 5;
+                    return;
+                }
+
+                VM.load(vmobj.uuid, function (err, obj) {
+                    if (err) {
+                        // give up
+                        t.ok(false, 'reloading after receive: ' + err.message);
+                        abort = true;
+                        t.end();
+                        return;
+                    }
+
+                    if (obj.hasOwnProperty('transition')
+                        || ['running', 'stopped'].indexOf(obj.state) === -1) {
+
+                        // wait for zone to settle
+                        t.ok(true, util.format(
+                            'Zone in state: %s - waiting to settle',
+                            obj.state));
+                        setTimeout(waitForZoneToSettle, 5 * 1000);
+                        return;
+                    }
+
+                    // zone settled!
+                    t.ok(true, 'Zone went to state: ' + obj.state);
+
+                    Object.keys(vmobj).forEach(function (prop) {
+                        // we expect these properties to be different.
+                        var skipProps = [
+                            'boot_timestamp',
+                            'last_modified',
+                            'pid',
+                            'zonedid',
+                            'zoneid'
+                        ];
+                        if (skipProps.indexOf(prop) !== -1) {
                             return;
                         }
-                        if (loops > 120) {
-                            clearInterval(ival);
-                            t.ok(false, "Timed out after 2 mins waiting for zone to settle.");
-                            abort = true;
+
+                        t.ok(obj.hasOwnProperty(prop),
+                            'new object still has property ' + prop);
+
+                        if (obj.hasOwnProperty(prop)) {
+                            var old_vm = JSON.stringify(vmobj[prop]);
+                            var new_vm = JSON.stringify(obj[prop]);
+                            t.ok(new_vm === old_vm, util.format(
+                                'matching properties "%s": [%s][%s]',
+                                prop, old_vm, new_vm));
                         }
-                        VM.load(vmobj.uuid, function (err, obj) {
-                            if (err) {
-                                clearInterval(ival);
-                                t.ok(false, 'reloading after receive: ' + err.message);
-                                abort = true;
-                                t.end();
-                                // leave loading since we don't want any more runs.
-                                return;
-                            } else {
-                                if (!obj.hasOwnProperty('transition') && (obj.state === 'running' || obj.state === 'stopped')) {
-                                    // DONE!
-                                    clearInterval(ival);
-                                    t.ok(true, 'Zone went to state: ' + obj.state);
-
-                                    for (prop in vmobj) {
-                                        if ([
-                                            'boot_timestamp',
-                                            'last_modified',
-                                            'pid',
-                                            'zonedid',
-                                            'zoneid'
-                                        ].indexOf(prop) !== -1) {
-                                            // we expect these properties to be different.
-                                            continue;
-                                        }
-                                        t.ok(obj.hasOwnProperty(prop), 'new object still has property ' + prop);
-                                        if (obj.hasOwnProperty(prop)) {
-                                            old_vm = JSON.stringify(vmobj[prop]);
-                                            new_vm = JSON.stringify(obj[prop]);
-                                            t.ok(new_vm == old_vm, 'matching properties ' + prop + ': [' + old_vm + '][' + new_vm + ']');
-                                        }
-                                    }
-                                    for (prop in obj) {
-                                        if (!vmobj.hasOwnProperty(prop)) {
-                                            t.ok(false, 'new object has extra property ' + JSON.stringify(prop));
-                                        }
-                                    }
-
-                                    t.end();
-                                    return;
-                                } else {
-                                    t.ok(true, 'Zone in state: ' + obj.state + ' waiting to settle.');
-                                }
-                                loading = false;
-                            }
-                        });
-                        loops = loops + 5;
-                    }, 5000);
-                }
+                    });
+
+                    Object.keys(obj).forEach(function (prop) {
+                        if (!vmobj.hasOwnProperty(prop)) {
+                            t.ok(false, util.format(
+                                'new object has extra property %s', prop));
+                        }
+                    });
+
+                    t.end();
+                });
             }
-        );
+
+            waitForZoneToSettle();
+        });
     });
 
-    test('delete after receiving ' + thing_name, function(t) {
+    test('delete after receiving ' + thing_name, function (t) {
         if (abort) {
             t.ok(false, 'skipping send as test run is aborted.');
             t.end();
             return;
         }
-        if (vmobj.uuid) {
-            VM.delete(vmobj.uuid, function (err) {
-                if (err) {
-                    t.ok(false, 'error deleting VM: ' + err.message);
-                } else {
-                    t.ok(true, 'deleted VM: ' + vmobj.uuid);
-                }
-                t.end();
-            });
-        } else {
+
+        if (!vmobj.uuid) {
             t.ok(false, 'no VM to delete');
             t.end();
+            return;
         }
+
+        VM.delete(vmobj.uuid, function (err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + err.message);
+                t.end();
+                return;
+            }
+
+            t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            t.end();
+        });
     });
 });
diff --git a/src/vm/tests/test-snapshots.js b/src/vm/tests/test-snapshots.js
index b718026f..9c8cc58f 100644
--- a/src/vm/tests/test-snapshots.js
+++ b/src/vm/tests/test-snapshots.js
@@ -20,10 +20,11 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  *
  */
 
+var common = require('./common');
 var cp = require('child_process');
 var execFile = cp.execFile;
 var fs = require('fs');
@@ -84,7 +85,7 @@ test('create joyent-minimal VM with delegated dataset', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                common.ifError(t, err, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
@@ -167,7 +168,7 @@ test('create KVM VM', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                common.ifError(t, err, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'VM has no snapshots');
                     vmobj = o;
@@ -257,7 +258,7 @@ test('create joyent-minimal VM w/o delegated', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                common.ifError(t, err, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
@@ -278,13 +279,11 @@ function (t) {
     var snapshot = dataset + '@manual-snapshot';
 
     execFile('/usr/sbin/zfs', ['snapshot', snapshot], function (error) {
-        t.ok(!error, 'created manual snapshot'
-            + (error ? ': ' + error.message : ''));
+        common.ifError(t, error, 'created manual snapshot');
         if (!error) {
             execFile('/usr/sbin/zfs',
                 ['list', '-t', 'snapshot', snapshot], function (err) {
-                t.ok(!err, 'manual snapshot exists'
-                    + (err ? ': ' + err.message : ''));
+                common.ifError(t, err, 'manual snapshot exists');
                 if (!err) {
                     VM.load(vmobj.uuid, function (e, o) {
                         t.ok(!e, 'reload VM after snap'
@@ -352,7 +351,8 @@ test('create snapshot with bad name', function (t) {
         inputs: bad_names,
         func: caller
     }, function (err) {
-        t.ok(!err, 'no extra errors from creating all the bad snapshots');
+        common.ifError(t, err,
+            'no extra errors from creating all the bad snapshots');
         t.end();
     });
 });
@@ -370,14 +370,14 @@ test('write file to joyent-minimal zoneroot then snapshot1', function (t) {
     filename = path.join(vmobj.zonepath, 'root', '/root/hello.txt');
 
     fs.writeFile(filename, MAGIC_STRING1, function (err) {
-        t.ok(!err, 'no error writing file to zoneroot');
+        common.ifError(t, err, 'writing file to zoneroot');
         if (err) {
             abort = true;
             t.end();
         } else {
             VM.create_snapshot(vmobj.uuid, 'snapshot1', {}, function (snaperr) {
-                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid
-                    + (snaperr ? ' ' + snaperr.message : ''));
+                common.ifError(t, snaperr, 'creating snapshot of '
+                    + vmobj.uuid);
                 VM.load(vmobj.uuid, function (e, o) {
                     t.ok(!e, 'loading VM after create');
                     if (!e) {
@@ -408,14 +408,13 @@ function (t) {
     filename = path.join(vmobj.zonepath, 'root', '/root/hello.txt');
 
     fs.writeFile(filename, MAGIC_STRING2, function (err) {
-        t.ok(!err, 'no error writing file to zoneroot'
-            + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'writing file to zoneroot');
         if (err) {
             abort = true;
             t.end();
         } else {
             VM.create_snapshot(vmobj.uuid, 'snapshot2', {}, function (snaperr) {
-                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid);
+                t.ok(!snaperr, 'creating snapshot of ' + vmobj.uuid);
                 VM.load(vmobj.uuid, function (e, o) {
                     t.ok(!e, 'loading VM after create');
                     if (!e) {
@@ -463,14 +462,13 @@ function (t) {
     filename = path.join(vmobj.zonepath, 'root', '/root/hello.txt');
 
     fs.writeFile(filename, MAGIC_STRING3, function (err) {
-        t.ok(!err, 'no error writing file to zoneroot'
-            + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'writing file to zoneroot');
         if (err) {
             abort = true;
             t.end();
         } else {
             VM.create_snapshot(vmobj.uuid, 'snapshot3', {}, function (snaperr) {
-                t.ok(!snaperr, 'no error creating snapshot of ' + vmobj.uuid);
+                t.ok(!snaperr, 'creating snapshot of ' + vmobj.uuid);
                 VM.load(vmobj.uuid, function (e, o) {
                     t.ok(!e, 'loading VM after create');
                     if (!e) {
@@ -502,11 +500,10 @@ test('rollback joyent-minimal to snapshot2 and test data', function (t) {
     var filename = path.join(vmobj.zonepath, 'root', '/root/hello.txt');
 
     VM.rollback_snapshot(vmobj.uuid, 'snapshot2', {}, function (err) {
-        t.ok(!err, 'no error rolling back snapshot2 of '
-            + vmobj.uuid + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'rolling back snapshot2 of ' + vmobj.uuid);
 
         fs.readFile(filename, function (error, data) {
-            t.ok(!error, 'no error reading file from ' + filename);
+            common.ifError(t, error, 'reading file from ' + filename);
             if (error) {
                 abort = true;
                 t.end();
@@ -545,11 +542,11 @@ test('rollback joyent-minimal to snapshot1 and test data', function (t) {
     var filename = path.join(vmobj.zonepath, 'root', '/root/hello.txt');
 
     VM.rollback_snapshot(vmobj.uuid, 'snapshot1', {}, function (err) {
-        t.ok(!err, 'no error rolling back snapshot1 of ' + vmobj.uuid
-            + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'rolling back snapshot1 of '
+            + vmobj.uuid);
 
         fs.readFile(filename, function (error, data) {
-            t.ok(!error, 'no error reading file from ' + filename);
+            common.ifError(t, error, 'reading file from ' + filename);
             if (error) {
                 abort = true;
                 t.end();
@@ -585,8 +582,7 @@ test('delete snapshot1 from joyent-minimal', function (t) {
     }
 
     deleteSnapshot(t, vmobj.uuid, 'snapshot1', 0, function (err) {
-        t.ok(!err, 'no error deleting snapshot1 of ' + vmobj.uuid
-            + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'deleting snapshot1 of ' + vmobj.uuid);
         if (err) {
             abort = true;
         }
@@ -603,7 +599,7 @@ function (t) {
     }
 
     VM.create_snapshot(vmobj.uuid, '20130131180505', {}, function (err) {
-        t.ok(!err, 'no error creating 20130131180505 snapshot of '
+        common.ifError(t, err, 'creating 20130131180505 snapshot of '
             + vmobj.uuid);
         VM.load(vmobj.uuid, function (e, o) {
             t.ok(!e, 'loading VM after create');
@@ -616,8 +612,8 @@ function (t) {
                 '20130131180505 after create');
             deleteSnapshot(t, vmobj.uuid, '20130131180505', 0,
                 function (delerr) {
-                    t.ok(!delerr, 'no error deleting 20130131180505 of '
-                        + vmobj.uuid + (delerr ? ' ' + delerr.message : ''));
+                    common.ifError(t, delerr, 'deleting 20130131180505 of '
+                        + vmobj.uuid);
                     if (err) {
                         abort = true;
                     }
@@ -636,8 +632,8 @@ function createSnapshot(t, uuid, snapname, expected_count, cb) {
     }
 
     VM.create_snapshot(vmobj.uuid, snapname, {}, function (err) {
-        t.ok(!err, 'no error creating snapshot ' + snapname + ' of '
-            + vmobj.uuid + (err ? ': ' + err.message : ''));
+        common.ifError(t, err, 'creating snapshot ' + snapname + ' of '
+            + vmobj.uuid);
         VM.load(vmobj.uuid, function (e, o) {
             t.ok(!e, 'loading VM after create');
             if (!e) {
@@ -659,8 +655,7 @@ function deleteSnapshot(t, uuid, snapname, expected_remaining, cb) {
     }
 
     VM.delete_snapshot(vmobj.uuid, snapname, {}, function (err) {
-        t.ok(!err, 'no error deleting ' + snapname + ' of '
-            + vmobj.uuid + (err ? ' ' + err.message : ''));
+        common.ifError(t, err, 'deleting ' + snapname + ' of ' + vmobj.uuid);
         VM.load(vmobj.uuid, function (e, o) {
             t.ok(!e, 'loading VM after delete of ' + snapname);
             if (e) {
@@ -696,8 +691,8 @@ function createXSnapshots(t, x, callback)
         createSnapshot(t, vmobj.uuid, snapname, (creates + 1),
             function (create_err) {
                 if (create_err) {
-                    t.ok(!create_err, 'no errors creating snapshot "' + snapname
-                        + '" ' + (create_err ? ' ' + create_err.message : ''));
+                    common.ifError(t, create_err,
+                        'creating snapshot "' + snapname + '"');
                 }
                 creates++;
                 cb(create_err);
@@ -705,8 +700,7 @@ function createXSnapshots(t, x, callback)
         );
     },
     function (err) {
-        t.ok(!err, 'no errors creating ' + x + ' snapshots'
-            + (err ? ': ' + err.message : ''));
+        common.ifError(t, err, 'creating ' + x + ' snapshots');
         if (err) {
             abort = true;
         }
@@ -740,16 +734,15 @@ test('delete 50 snapshots on joyent-minimal', function (t) {
         snapname = 'snapshot' + deletes;
         deleteSnapshot(t, vmobj.uuid, snapname, deletes, function (delete_err) {
             if (delete_err) {
-                t.ok(!delete_err, 'no errors deleting snapshot "' + snapname
-                    + '" ' + (delete_err ? ' ' + delete_err.message : ''));
+                common.ifError(t, delete_err, 'deleting snapshot "'
+                    + snapname + '"');
             }
             deletes--;
             callback(delete_err);
         });
     },
     function (err) {
-        t.ok(!err, 'no errors deleting 50 snapshots'
-            + (err ? ': ' + err.message : ''));
+        common.ifError(t, err, 'deleting 50 snapshots');
         if (err) {
             abort = true;
         }
@@ -774,7 +767,8 @@ function (t) {
     vasync.pipeline({funcs: [
         function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
-                t.ok(!err, 'loading VM before last_modified snapshot');
+                common.ifError(t, err,
+                    'loading VM before last_modified snapshot');
                 if (!err) {
                     pre_snap_timestamp = obj.last_modified;
                 }
@@ -783,13 +777,14 @@ function (t) {
         }, function (_, cb) {
             setTimeout(function () {
                 createSnapshot(t, vmobj.uuid, 'modifyme', 1, function (err) {
-                    t.ok(!err, 'created snapshot for last_modified test');
+                    common.ifError(t, err,
+                        'created snapshot for last_modified test');
                     cb(err);
                 });
             }, 1000);
         }, function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
-                t.ok(!err, 'loaded VM after snapshot');
+                common.ifError(t, err, 'loaded VM after snapshot');
                 if (!err) {
                     post_snap_timestamp = obj.last_modified;
                 }
@@ -798,13 +793,14 @@ function (t) {
         }, function (_, cb) {
             setTimeout(function () {
                 deleteSnapshot(t, vmobj.uuid, 'modifyme', 0, function (err) {
-                    t.ok(!err, 'deleted snapshot for last_modified test');
+                    common.ifError(t, err,
+                        'deleted snapshot for last_modified test');
                     cb(err);
                 });
             }, 1000);
         }, function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
-                t.ok(!err, 'loaded VM after delete snapshot');
+                common.ifError(t, err, 'loaded VM after delete snapshot');
                 if (!err) {
                     post_delete_timestamp = obj.last_modified;
                 }
@@ -842,7 +838,8 @@ test('create/delete joyent-minimal snapshot should handle mounting '
         function (_, cb) {
             createSnapshot(t, vmobj.uuid, snapname, vmobj.snapshots.length + 1,
                 function (err) {
-                    t.ok(!err, 'created snapshot for last_modified test');
+                    common.ifError(t, err,
+                        'created snapshot for last_modified test');
                     cb(err);
                 }
             );
@@ -860,7 +857,7 @@ test('create/delete joyent-minimal snapshot should handle mounting '
             });
         }, function (_, cb) {
             deleteSnapshot(t, vmobj.uuid, snapname, 0, function (err) {
-                t.ok(!err, 'deleted ' + snapname + ' snapshot for '
+                common.ifError(t, err, 'deleted ' + snapname + ' snapshot for '
                     + vmobj.uuid);
                 cb(err);
             });
@@ -877,7 +874,7 @@ test('create/delete joyent-minimal snapshot should handle mounting '
             });
         }
     ]}, function (err) {
-        t.ok(!err, 'testing /checkpoints: ' + (err ? err.message : 'success'));
+        common.ifError(t, err, 'testing /checkpoints');
         t.end();
     });
 });
@@ -934,7 +931,7 @@ test('create stopped joyent-minimal VM', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                common.ifError(t, err, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
@@ -959,7 +956,7 @@ function (t) {
     }
 
     VM.create_snapshot(vmobj.uuid, 'shouldntmount', {}, function (err) {
-        t.ok(!err, 'no error creating snapshot of ' + vmobj.uuid);
+        common.ifError(t, err, 'creating snapshot of ' + vmobj.uuid);
         VM.load(vmobj.uuid, function (e, o) {
             t.ok(!e, 'loading VM after create');
             if (!e) {
@@ -1026,7 +1023,7 @@ function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                t.ok(!err, 'loading VM after create');
+                common.ifError(t, err, 'loading VM after create');
                 if (!err) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
@@ -1080,8 +1077,7 @@ test('snapshot zone with garbage metadata.sock', function (t) {
 
     execFile('/usr/sbin/zfs',
         ['snapshot', vmobj.zfs_filesystem + '@garbage_mdata'], function (err) {
-        t.ok(!err, 'create garbage_mdata snapshot: '
-            + (err ? err.message : 'success'));
+        common.ifError(t, err, 'create garbage_mdata snapshot');
         t.end();
     });
 });
@@ -1096,7 +1092,7 @@ test('boot zone with garbage metadata.sock, try mdata-get', function (t) {
 
     // we boot with zoneadm to mimic marlin-agent
     execFile('/usr/sbin/zoneadm', ['-z', vmobj.uuid, 'boot'], function (err) {
-        t.ok(!err, 'boot zone: ' + (err ? err.message : 'success'));
+        common.ifError(t, err, 'boot zone');
         // Try to load our own uuid from metadata. Should work because this
         // will be first boot and metadata agent will create its socket the
         // first time replacing our garbage one.
@@ -1120,7 +1116,7 @@ test('rollback to garbage snapshot, try mdata-get again', function (t) {
 
     // we halt with zoneadm to mimic marlin-agent
     execFile('/usr/sbin/zoneadm', ['-z', vmobj.uuid, 'halt'], function (err) {
-        t.ok(!err, 'halt zone: ' + (err ? err.message : 'success'));
+        common.ifError(t, err, 'halt zone');
         execFile('/usr/sbin/zfs',
             ['rollback', vmobj.zfs_filesystem + '@garbage_mdata'],
             function (e) {
@@ -1158,7 +1154,7 @@ test('delete VM with garbage snapshot', function (t) {
     }
 
     VM.delete(vmobj.uuid, function (err) {
-        t.ok(!err, 'delete VM: ' + (err ? err.message : 'success'));
+        common.ifError(t, err, 'delete VM');
         t.end();
         vmobj = {};
     });
diff --git a/src/vm/tests/test-update.js b/src/vm/tests/test-update.js
index 4b6441a5..8174b935 100644
--- a/src/vm/tests/test-update.js
+++ b/src/vm/tests/test-update.js
@@ -1,8 +1,34 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// NOTE: we use 169.254.169.x as *non-Private* here because it's not in the
-// designated private ranges we're concerned with. It may cause problems in
-// which case it can be changed to some other non-Private address.
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * NOTE: we use 169.254.169.x as *non-Private* here because it's not in the
+ * designated private ranges we're concerned with. It may cause problems in
+ * which case it can be changed to some other non-Private address.
+ */
 
 var async = require('/usr/node/node_modules/async');
 var execFile = require('child_process').execFile;
@@ -1062,67 +1088,77 @@ test('update max_locked_memory', function (t) {
     });
 });
 
-function zonecfg(args, callback)
-{
-    var cmd = '/usr/sbin/zonecfg';
-
-    execFile(cmd, args, function (error, stdout, stderr) {
-        if (error) {
-            callback(error, {stdout: stdout, stderr: stderr});
-        } else {
-            callback(null, {stdout: stdout, stderr: stderr});
+test('update resolvers when empty', function (t) {
+    var payload = {
+        resolvers: ['4.2.2.1', '4.2.2.2']
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
         }
-    });
-}
-
-test('update resolvers when no resolvers', function (t) {
 
-    zonecfg([
-        '-z', vm_uuid,
-        'remove attr name=resolvers;'
-    ], function (err, fds) {
-        VM.update(vm_uuid, {resolvers: ['4.2.2.1', '4.2.2.2']},
-            function (up_err) {
-                t.ok(!up_err, 'no error adding resolvers: '
-                    + (up_err ? up_err.message : 'ok'));
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
                 t.end();
+                return;
             }
-        );
+
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
+        });
     });
 });
 
-test('update resolvers to empty when already empty', function (t) {
-    zonecfg(['-z', vm_uuid, 'remove attr name=resolvers;'],
-        function (err, fds) {
+test('update resolvers to empty when filled', function (t) {
+    var payload = {
+        resolvers: []
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
+        }
 
-        VM.load(vm_uuid, function (l_err, before_obj) {
-            if (l_err) {
-                t.ok(false, 'loading VM: ' + l_err.message);
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
                 t.end();
                 return;
             }
 
-            t.deepEqual(before_obj.resolvers, [], 'initial state has no '
-                + 'resolvers: ' + JSON.stringify(before_obj.resolvers));
-            VM.update(vm_uuid, {'resolvers': []}, function (up_err) {
-                if (up_err) {
-                    t.ok(false, 'updating resolvers: ' + up_err.message);
-                    t.end();
-                    return;
-                }
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
+        });
+    });
+});
 
-                VM.load(vm_uuid, function (error, after_obj) {
-                    if (error) {
-                        t.ok(false, 'loading VM (after): ' + error.message);
-                        t.end();
-                        return;
-                    }
+test('update resolvers to empty when empty', function (t) {
+    var payload = {
+        resolvers: []
+    };
+    VM.update(vm_uuid, payload, function (up_err) {
+        if (up_err) {
+            t.ok(false, 'updating resolvers: ' + up_err.message);
+            t.end();
+            return;
+        }
 
-                    t.deepEqual(after_obj.resolvers, [], 'no resolvers after '
-                        + 'update: ' + JSON.stringify(after_obj.resolvers));
-                    t.end();
-                });
-            });
+        VM.load(vm_uuid, function (load_err, vmobj) {
+            if (load_err) {
+                t.ok(false, 'loading VM (after): ' + load_err.message);
+                t.end();
+                return;
+            }
+
+            t.deepEqual(vmobj.resolvers, payload.resolvers,
+                'resolvers after update: ' + JSON.stringify(vmobj.resolvers));
+            t.end();
         });
     });
 });
diff --git a/src/vm/tests/test-vminfod-zonewatcher-overflow.js b/src/vm/tests/test-vminfod-zonewatcher-overflow.js
new file mode 100644
index 00000000..bad115bd
--- /dev/null
+++ b/src/vm/tests/test-vminfod-zonewatcher-overflow.js
@@ -0,0 +1,308 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var execFile = require('child_process').execFile;
+var f = require('util').format;
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var bunyan = require('/usr/node/node_modules/bunyan');
+var vasync = require('/usr/vm/node_modules/vasync');
+
+var common = require('./common');
+var vmadm = common.vmadm;
+
+var ZoneWatcher = require('vminfod/zonewatcher').ZoneWatcher;
+var log = bunyan.createLogger({
+    level: 'trace',
+    name: 'zonewatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'error' } ],
+    serializers: bunyan.stdSerializers
+});
+var zonew;
+
+var vmEvents = {};
+var createdVms = [];
+
+/* CONFIG */
+var NUM_VMS = 10;
+var NUM_RESTARTS_PER_VM = 25;
+var STRAGGLER_WAIT = 5 * 1000;
+// HIGH_WATER_MARK sets the highWaterMark for the lstream in ZoneeventWatcher.
+// default is 16k! takes too long to get there, so we set to a lower value to
+// ensure that we're going to overrun it with events.
+var HIGH_WATER_MARK = 32;
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+test('create a ZoneWatcher object', function (t) {
+    zonew = new ZoneWatcher({
+        log: log,
+        highWaterMark: HIGH_WATER_MARK
+    });
+    t.ok(zonew, 'created ZoneWatcher');
+
+    zonew.on('event', function (evt) {
+        assert.object(evt, 'evt');
+        assert.uuid(evt.zonename, 'evt.zonename');
+        assert.string(evt.newstate, 'evt.newstate');
+
+        // Happens when the VM is deleted - use a custom event name
+        if (evt.newstate === '') {
+            evt.newstate = '_deleted';
+        }
+
+        if (!vmEvents.hasOwnProperty(evt.zonename)) {
+            vmEvents[evt.zonename] = {};
+        }
+        if (!vmEvents[evt.zonename].hasOwnProperty(evt.newstate)) {
+            vmEvents[evt.zonename][evt.newstate] = 0;
+        }
+        vmEvents[evt.zonename][evt.newstate]++;
+    });
+
+    zonew.once('ready', function () {
+        t.ok(true, 'ZoneWatcher ready');
+        t.end();
+    });
+});
+
+test('create VMs', function (t) {
+    var i;
+    var vmsToCreate = [];
+
+    for (i = 0; i < NUM_VMS; i++) {
+        vmsToCreate.push(i);
+    }
+
+    function _createVm(idx, cb) {
+        assert.number(idx, 'idx');
+        assert.func(cb, 'cb');
+
+        var payload = {
+            alias: 'test-vminfod-zonewatcher-overflow-' + idx,
+            autoboot: true,
+            brand: 'joyent-minimal',
+            image_uuid: '01b2c898-945f-11e1-a523-af1afbe22822',
+            do_not_inventory: true,
+            quota: 10
+        };
+        var opts = {
+            log: log,
+            stdin: JSON.stringify(payload)
+        };
+
+        vmadm(['create'], opts, function (err, stdio) {
+            var match;
+            var uuid;
+
+            log.debug({err: err, stdio: stdio}, 'vmadm create');
+
+            match = stdio.stderr /* JSSTYLED */
+                .match(/Successfully created VM ([0-9a-f\-]*)/);
+            if (match) {
+                uuid = match[1];
+                assert.uuid(uuid, 'uuid');
+                createdVms.push(uuid);
+            } else {
+                t.ok(false, 'failed to get uuid from new VM');
+            }
+
+            common.ifError(t, err, f('create VM %s (%s)', uuid, payload.alias));
+            cb(err);
+        });
+    }
+
+
+    vasync.forEachParallel({
+        inputs: vmsToCreate,
+        func: _createVm
+    }, function _afterForEachParallel(err) {
+        common.ifError(t, err, 'VMs should have been created successfully');
+        t.end();
+    });
+});
+
+test('restart VMs', function (t) {
+    /*
+     * restart with zoneadm because we're doing this fast and want to test
+     * sysevents and not vminfod.
+     */
+    function _restartVm(o, cb) {
+        assert.object(o, 'o');
+        assert.number(o.idx, 'o.idx');
+        assert.uuid(o.uuid, 'o.uuid');
+        assert.func(cb, 'cb');
+
+        var idx = o.idx;
+        var uuid = o.uuid;
+        var args = ['-z', uuid, 'reboot', '-X'];
+        var cmd = '/usr/sbin/zoneadm';
+
+        execFile(cmd, args, function _onExecFile(err, stdout, stderr) {
+            common.ifError(t, err, f('reboot VM %s (%d)',
+                uuid, idx));
+
+            cb(err);
+        });
+    }
+
+    function _multiRestartVm(uuid, cb) {
+        assert.uuid(uuid, 'uuid');
+        assert.func(cb, 'cb');
+
+        var i = 0;
+
+        vasync.whilst(
+            function _whilstTest() {
+                return (i++ < NUM_RESTARTS_PER_VM);
+            },
+            function _whilstIterate(next) {
+                var opts = {
+                    uuid: uuid,
+                    idx: i
+                };
+                _restartVm(opts, next);
+            },
+            function _whilstDone(err) {
+                cb(err);
+            }
+        );
+    }
+
+    vasync.forEachParallel({
+        inputs: createdVms,
+        func: _multiRestartVm
+    }, function _afterForEachParallel(err) {
+        common.ifError(t, err, 'done restarting');
+        t.end();
+    });
+});
+
+test('delete VMs', function (t) {
+    function _deleteVm(uuid, cb) {
+        assert.uuid(uuid, 'uuid');
+        assert.func(cb, 'cb');
+
+        vmadm(['delete', uuid], {log: log}, function _vmadmDeleteCb(err) {
+            common.ifError(t, err, f('delete VM %s', uuid));
+            cb(err);
+        });
+    }
+
+    vasync.forEachParallel({
+        inputs: createdVms,
+        func: _deleteVm
+    }, function _afterForEachParallel(err) {
+        common.ifError(t, err, 'done deleting');
+        t.end();
+    });
+});
+
+test('stop zone watcher', function (t) {
+    setTimeout(function () {
+        zonew.stop();
+        t.ok(true, 'ZoneWatcher stopped');
+        t.end();
+    }, STRAGGLER_WAIT);
+});
+
+test('check final state', function (t) {
+    var statesSeen = {};
+    var statesExpected;
+
+    /*
+     * At this point, the vmEvents object will look something like this:
+     * {
+     *   "<uuid>": {
+     *     "initialized": 1,
+     *     "running": 4,
+     *     "configured": 2,
+     *     ...
+     *  },
+     *  "<uuid>": {
+     *    ...
+     *  }
+     * };
+     */
+
+    /*
+     * Loop each key in the vmEvents object and ensure that the same number of
+     * events were seen for each vm created as a port of this test.  Then,
+     * store the values in a new object at the root.
+     */
+    t.ok(true, f('ensuring events seen for %d VMs are the same',
+        createdVms.length));
+    createdVms.forEach(function (uuid) {
+        var events = vmEvents[uuid];
+
+        assert.object(events, f('events (%s)', uuid));
+
+        Object.keys(events).forEach(function (state) {
+            if (!statesSeen.hasOwnProperty(state)) {
+                statesSeen[state] = events[state];
+                return;
+            }
+
+            if (statesSeen[state] !== events[state]) {
+                t.ok(false, f('VM %s had %d %s events, expectd %d',
+                    uuid, events[state], state, statesSeen[state]));
+            }
+        });
+    });
+
+    /*
+     * Because we know the number of VMs created and how many times each was
+     * restarted, we know which states to expect and how many.  This is meant
+     * to a low estimate, or a minimum - there should be at least this many but
+     * possibly more.
+     */
+    statesExpected = {
+        configured: 2,
+        incomplete: 2,
+        installed: 1,
+        initialized: 1 + NUM_RESTARTS_PER_VM,
+        uninitialized: 1 + NUM_RESTARTS_PER_VM,
+        running: 1 + NUM_RESTARTS_PER_VM,
+        ready: 2 + NUM_RESTARTS_PER_VM,
+        shutting_down: 2 + NUM_RESTARTS_PER_VM,
+        _deleted: 1
+    };
+
+    /*
+     * Ensure that we have seen at least as many state events as we expected
+     * per VM
+     */
+    t.ok(true, 'ensuring eventsSeen >= eventsExpected');
+    Object.keys(statesExpected).forEach(function (state) {
+        t.ok(statesSeen[state] >= statesExpected[state],
+            f('statesSeen[%s] %d >= statesExpected[%s] %d',
+            state, statesSeen[state], state, statesExpected[state]));
+    });
+
+    t.end();
+});
diff --git a/src/vm/tests/test-vminfod-zonewatcher.js b/src/vm/tests/test-vminfod-zonewatcher.js
new file mode 100644
index 00000000..49676c7d
--- /dev/null
+++ b/src/vm/tests/test-vminfod-zonewatcher.js
@@ -0,0 +1,123 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var bunyan = require('/usr/node/node_modules/bunyan');
+
+var common = require('./common');
+var vmadm = common.vmadm;
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+var ZoneWatcher = require('vminfod/zonewatcher').ZoneWatcher;
+var log = bunyan.createLogger({
+    level: 'trace',
+    name: 'zonewatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'error' } ],
+    serializers: bunyan.stdSerializers
+});
+var zonew;
+
+test('create a ZoneWatcher object', function (t) {
+    zonew = new ZoneWatcher({log: log});
+    t.ok(zonew, 'created ZoneWatcher');
+    zonew.once('ready', function () {
+        t.ok(true, 'ZoneWatcher ready');
+        t.end();
+    });
+});
+
+test('create zone (autoboot=true) and stop and destroy',
+    function (t) {
+        var payload;
+        var running = [];
+        var saw_running = false;
+        var vm_uuid = null;
+
+        payload = {
+            autoboot: true,
+            brand: 'joyent-minimal',
+            do_not_inventory: true,
+            image_uuid: '01b2c898-945f-11e1-a523-af1afbe22822'
+        };
+
+        function finish() {
+            zonew.stop();
+            t.end();
+        }
+
+        function onRunning() {
+            vmadm(['stop', vm_uuid, '-F'], {log: log}, function (err, stdio) {
+                t.ok(!err, (err ? err.message : 'stopped VM'));
+                log.debug({err: err, stdio: stdio}, 'vmadm stop');
+            });
+        }
+
+        zonew.on('event', function (evt) {
+            log.debug('saw change (looking for ' + vm_uuid + '): '
+                + JSON.stringify(evt));
+            if (evt.newstate === 'running') {
+                saw_running = true;
+                running.push(evt.zonename);
+                if (vm_uuid) {
+                    onRunning();
+                }
+            } else if (evt.newstate == 'uninitialized'
+                && vm_uuid && saw_running) {
+
+                vmadm(['delete', vm_uuid], {log: log}, function (err, stdio) {
+                    t.ok(!err, (err ? err.message : 'deleted VM'));
+                    log.debug({err: err, stdio: stdio}, 'vmadm delete');
+                    finish();
+                });
+            }
+        });
+
+        /* start the ball rolling by creating a VM */
+        vmadm(['create'], {log: log, stdin: JSON.stringify(payload)},
+            function (err, stdio) {
+
+            var match;
+            t.ok(!err, (err ? err.message : 'created VM'));
+            log.debug({err: err, stdio: stdio}, 'vmadm create');
+
+            match = stdio.stderr /* JSSTYLED */
+                .match(/Successfully created VM ([0-9a-f\-]*)/);
+            if (match) {
+                vm_uuid = match[1];
+            } else {
+                t.ok(false, 'failed to get uuid from new VM');
+                finish();
+                return;
+            }
+
+            if (running.indexOf(vm_uuid) !== -1) {
+                onRunning();
+            }
+        });
+    }
+);
diff --git a/src/vm/tests/test-vminfod-zpoolwatcher.js b/src/vm/tests/test-vminfod-zpoolwatcher.js
new file mode 100644
index 00000000..8976d924
--- /dev/null
+++ b/src/vm/tests/test-vminfod-zpoolwatcher.js
@@ -0,0 +1,131 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var bunyan = require('/usr/vm/node_modules/bunyan');
+
+var common = require('./common');
+var zfs = common.zfs;
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+var TIMEOUT = 10 * 1000;
+var DATASET = 'zones/zpoolwatcher-test-dummy-' + process.pid;
+
+var ZpoolWatcher = require('vminfod/zpoolwatcher').ZpoolWatcher;
+var log = bunyan.createLogger({
+    level: 'warn',
+    name: 'zpoolwatcher-test-dummy',
+    streams: [ { stream: process.stderr, level: 'warn' } ],
+    serializers: bunyan.stdSerializers
+});
+var zw;
+
+test('create a ZpoolWatcher object', function (t) {
+    zw = new ZpoolWatcher({log: log});
+    t.ok(zw, 'ZpoolWatcher');
+    zw.once('ready', function () {
+        t.ok(true, 'zw.once(ready)');
+        t.end();
+    });
+});
+
+test('creating a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'create'
+            && ev.pool === 'zones') {
+            clearTimeout(timeout);
+            zw.removeAllListeners('event');
+            t.end();
+        }
+    });
+
+    zfs(['create', DATASET], function (err, out) {
+        t.ifError(err, 'error creating dataset');
+    });
+});
+
+test('modifying a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    var found = 0;
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'set'
+            && ev.pool === 'zones') {
+
+            if (ev.extra.atime === '1')
+                found++;
+            if (ev.extra.sync === '1')
+                found++;
+
+            if (found >= 2) {
+                clearTimeout(timeout);
+                zw.removeAllListeners('event');
+                t.end();
+            }
+        }
+    });
+
+    zfs(['set', 'atime=on', 'sync=always', DATASET], function (err, out) {
+        t.ifError(err, 'error modifying dataset');
+    });
+});
+
+test('destroying a ZFS dataset and catching the event', function (t) {
+    var timeout = setTimeout(function () {
+        t.ok(false, 'timeout');
+        t.end();
+    }, TIMEOUT);
+
+    zw.on('event', function (ev) {
+        if (ev.dsname === DATASET && ev.action === 'destroy'
+            && ev.pool === 'zones') {
+            clearTimeout(timeout);
+            zw.removeAllListeners('event');
+            t.end();
+        }
+    });
+
+    zfs(['destroy', DATASET], function (err, out) {
+        t.ifError(err, 'error destroying dataset');
+    });
+});
+
+
+test('cleanup', function (t) {
+    t.ok(true, 'cleaning up');
+    zw.stop();
+    t.end();
+});
diff --git a/src/vm/tests/test-vminfod.js b/src/vm/tests/test-vminfod.js
new file mode 100644
index 00000000..c8702057
--- /dev/null
+++ b/src/vm/tests/test-vminfod.js
@@ -0,0 +1,42 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+test('create VminfodClient object and test /status', function (t) {
+    var vc = new vminfod.VminfodClient();
+    t.ok(vc, 'VminfodClient created');
+
+    vc.status(function (err, stats) {
+        t.ifError(err, 'vc.status no error');
+        t.ok(stats, 'vc.status object found');
+        t.end();
+    });
+});
diff --git a/src/zoneevent.c b/src/zoneevent.c
deleted file mode 100644
index a07742b5..00000000
--- a/src/zoneevent.c
+++ /dev/null
@@ -1,144 +0,0 @@
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <libsysevent.h>
-#include <sys/nvpair.h>
-
-void sysev_handler(sysevent_t *ev);
-sysevent_handle_t * sysev_register(const char *klass,
-    void (*handler)(sysevent_t *));
-evchan_t * sysev_register_evc(const char *channel, const char *klass,
-    int (*handler)(sysevent_t *, void *));
-
-static void
-exit_on_sigpipe(int signo) {
-    // no point outputing anything, parent is gone.
-    signo = signo; // quiet -Wall
-    exit(2);
-}
-
-static int
-sysev_evc_handler(sysevent_t *ev, void *cookie)
-{
-    nvlist_t *nvlist;
-    nvpair_t *next;
-    nvpair_t *curr;
-    data_type_t type;
-    char *string;
-    uint32_t uint32;
-    int32_t int32;
-    uint64_t uint64;
-    int64_t int64;
-
-    if (sysevent_get_attr_list(ev, &nvlist) != 0) {
-        // XXX Error
-        return (1);
-    }
-
-    curr = nvlist_next_nvpair(nvlist, NULL);
-
-    printf("{");
-    while (curr != NULL) {
-        type = nvpair_type(curr);
-
-        switch (type) {
-            case DATA_TYPE_STRING:
-                nvpair_value_string(curr, &string);
-                printf("\"%s\": \"%s\", ", nvpair_name(curr), string);
-                break;
-            case DATA_TYPE_UINT32:
-                nvpair_value_uint32(curr, &uint32);
-                printf("\"%s\": \"%u\", ", nvpair_name(curr), uint32);
-                break;
-            case DATA_TYPE_INT32:
-                nvpair_value_int32(curr, &int32);
-                printf("\"%s\": \"%d\", ", nvpair_name(curr), int32);
-                break;
-            case DATA_TYPE_UINT64:
-                nvpair_value_uint64(curr, &uint64);
-                printf("\"%s\": \"%llu\", ", nvpair_name(curr), uint64);
-                break;
-            case DATA_TYPE_INT64:
-                nvpair_value_int64(curr, &int64);
-                printf("\"%s\": \"%lld\", ", nvpair_name(curr), int64);
-                break;
-                break;
-            default:
-                (void) fprintf(stderr,
-                    "don't know what to do with '%s', type: %d\n",
-                    nvpair_name(curr), type);
-                break;
-        }
-        next = nvlist_next_nvpair(nvlist, curr);
-        curr = next;
-    }
-
-    printf("\"channel\": \"%s\", \"class\": \"%s\", \"subclass\": \"%s\"}\n",
-        (const char *) cookie,
-        sysevent_get_class_name(ev),
-        sysevent_get_subclass_name(ev));
-
-    fflush(stdout);
-
-    nvlist_free(nvlist);
-
-    return (0);
-}
-
-evchan_t *
-sysev_register_evc(const char *channel, const char *klass,
-    int (*handler)(sysevent_t *, void *))
-{
-    int res;
-    evchan_t *ch;
-    char subid[16];
-
-    if ((res = sysevent_evc_bind(channel, &ch, 0)) != 0) {
-        (void) fprintf(stderr, "failed to bind to sysevent channel: %d\n", res);
-        return (NULL);
-    }
-
-    (void) snprintf(subid, sizeof (subid), "node-%ld", getpid());
-
-    if ((res = sysevent_evc_subscribe(ch, subid, klass, handler,
-        (void *)channel, 0)) != 0) {
-
-        (void) fprintf(stderr, "failed to subscribe to channel: %d\n", res);
-        return (NULL);
-    }
-
-    return (ch);
-}
-
-int
-main(int argc, char **argv)
-{
-    evchan_t *ch;
-
-    // quiet -Wall
-    argc = argc;
-    argv = argv;
-
-    if (signal(SIGPIPE, exit_on_sigpipe) == SIG_ERR) {
-        fprintf(stderr, "failed to register SIGPIPE handler: %s\n",
-            strerror(errno));
-        exit(1);
-    }
-
-    ch = sysev_register_evc("com.sun:zones:status", "status",
-        sysev_evc_handler);
-    if (!ch) {
-        fprintf(stderr, "failed to register event handler.\n");
-        exit(1);
-    }
-
-    for (;;) {
-        (void) pause();
-    }
-
-    exit(0);
-}
diff --git a/src/zoneevent.js b/src/zoneevent.js
new file mode 100755
index 00000000..21b7dd2a
--- /dev/null
+++ b/src/zoneevent.js
@@ -0,0 +1,183 @@
+#!/usr/node/bin/node
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+/*
+ * Substitute for 'zoneevent.c' that uses `VM.events` as the event source.
+ */
+
+var f = require('util').format;
+
+var bunyan = require('/usr/node/node_modules/bunyan');
+var getopt = require('/usr/node/node_modules/getopt');
+var ZoneEvent = require('/usr/vm/node_modules/zoneevent').ZoneEvent;
+var zone = require('/usr/node/node_modules/zonename');
+
+// Number of times to retry VM.events if it fails (can happen if vminfod is
+// down or starting)
+var MAX_TRIES = 10;
+
+// ms to wait before retrying VM.events
+var TRY_TIMEOUT = 1000;
+
+// ms to wait to reset the number of tries back to 0.  For example, if
+// VM.events works for 30 seconds the failcount is reset.
+var TRY_RESET_TIMEOUT = 30 * 1000;
+
+// Timeout to reset the failcount to 0
+var tryTimeout;
+
+// failcount - number of times VM.events has failed to start
+var tries = 0;
+
+var opts = [
+    'h(help)',
+    'i:(ident)',
+    'l:(level)'
+].join('');
+var parser = new getopt.BasicParser(opts, process.argv);
+
+var name = 'zoneevent CLI';
+var logLevel = 'fatal';
+var option;
+while ((option = parser.getopt())) {
+    switch (option.option) {
+    case 'h':
+        usage();
+        process.exit(0);
+        break;
+    case 'i':
+        name += f(' (%s)', option.optarg);
+        break;
+    case 'l':
+        logLevel = option.optarg;
+        break;
+    default:
+        usage();
+        process.exit(1);
+        break;
+    }
+}
+
+var log = bunyan.createLogger({
+    level: logLevel,
+    name: 'zoneevent',
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+function usage() {
+    var out = [
+        'Usage: zoneevent [-i <ident>] [-l <level>] [-h]',
+        '',
+        'Options',
+        '  -h, --help           Print this help message and exit',
+        '  -i, --ident <ident>  Identifier string to be used for this',
+        '                       invocation (used for vminfod user-agent)',
+        '  -l, --level <level>  Bunyan log level to use, defaults to fatal'
+    ];
+    console.log(out.join('\n'));
+}
+
+function start() {
+    var ze = new ZoneEvent({
+        name: name,
+        log: log
+    });
+
+    ze.on('ready', function zoneEventReady(err, obj) {
+        if (err)
+            throw err;
+
+        // It's unfortunate, but `zoneevent.c` never published a "ready" event, so
+        // we just silently ignore this if everything works as expected.
+        tryTimeout = setTimeout(function zoneEventRetry() {
+            tries = 0;
+        }, TRY_RESET_TIMEOUT);
+    });
+
+    ze.on('event', function zoneEventEventReceived(ev) {
+        /*
+         * ZoneEvent returns an object that looks like this:
+         *
+         * {
+         *   "date": "2017-05-12T19:33:33.097Z",
+         *   "zonename": "fb622681-3d62-413b-dc8a-c7515367464f",
+         *   "newstate": "running",
+         *   "oldstate": "ready"
+         * }
+         *
+         * Which must be transformed to look like this:
+         *
+         * {
+         *   "zonename": "fb622681-3d62-413b-dc8a-c7515367464f",
+         *   "newstate": "running",
+         *   "oldstate": "ready",
+         *   "when": "1494617613097227838",
+         *   "channel": "com.sun:zones:status",
+         *   "class": "status",
+         *   "zoneid": "463",
+         *   "subclass": "change"
+         * }
+         *
+         * With channel, class and subclass omitted
+         */
+
+        var zoneid;
+        try {
+            zoneid = zone.getzoneidbyname(ev.zonename);
+        } catch (e) {
+            zoneid = -1;
+        }
+
+        var obj = {
+            zonename: ev.zonename,
+            oldstate: ev.oldstate,
+            newstate: ev.newstate,
+            zoneid: zoneid.toString(),
+            when: (ev.date.getTime().toString()) + '000000'
+        };
+
+        console.log(JSON.stringify(obj));
+    });
+
+    ze.on('error', function zoneEventError(err) {
+        log.warn({err: err}, 'zoneEventError');
+        if (++tries === MAX_TRIES) {
+            log.fatal({err: err}, 'failed %d times', tries);
+            process.exit(1);
+        }
+
+        if (tryTimeout) {
+            clearTimeout(tryTimeout);
+            tryTimeout = null;
+        }
+
+        setTimeout(start, TRY_TIMEOUT);
+    });
+}
+
+start();
