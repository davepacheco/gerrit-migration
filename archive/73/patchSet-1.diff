From 08477835e1f8e67a7cf079ef5d3c8ac7239f1c20 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Wed, 13 Jul 2016 15:58:05 -0700
Subject: [PATCH] joyent/node-forkexec#3 optionally include stderr in error
 message

---
 README.md                                 |  3 +++
 lib/forkexec.js                           | 26 ++++++++++++++++++-----
 test/tst.forkExecWaitCmdFailedNoStderr.js | 25 ++++++++++++++++++++++
 test/tst.forkExecWaitCmdFailedStderr.js   | 26 +++++++++++++++++++++++
 tools/failer                              | 10 +++++++++
 5 files changed, 85 insertions(+), 5 deletions(-)
 create mode 100644 test/tst.forkExecWaitCmdFailedNoStderr.js
 create mode 100644 test/tst.forkExecWaitCmdFailedStderr.js
 create mode 100755 tools/failer

diff --git a/README.md b/README.md
index 95f189c..64d8ba2 100644
--- a/README.md
+++ b/README.md
@@ -90,6 +90,9 @@ The following arguments have the same semantics as for Node's built-in
 * **maxBuffer** (int): bytes of stdout and stderr that will be buffered
 * **uid** (int): uid for child process
 * **gid** (int): gid for child process
+* **includeStderr** (boolean): if the process exits with a non-zero status,
+  the output of `stderr` will be trimmed and included in the error message.
+  Defaults to `false`.
 
 ### Return value
 
diff --git a/lib/forkexec.js b/lib/forkexec.js
index 65caabc..cde4d21 100644
--- a/lib/forkexec.js
+++ b/lib/forkexec.js
@@ -26,6 +26,7 @@ function forkExecWait(args, callback)
 	mod_assertplus.optionalNumber(args.maxBuffer, 'args.maxBuffer');
 	mod_assertplus.optionalNumber(args.uid, 'args.uid');
 	mod_assertplus.optionalNumber(args.gid, 'args.gid');
+	mod_assertplus.optionalBool(args.includeStderr, 'args.stderr');
 
 	cmd = args.argv[0];
 	cmdstr = JSON.stringify(args.argv.join(' '));
@@ -49,23 +50,32 @@ function forkExecWait(args, callback)
 	try {
 		rv = mod_child.execFile(cmd, cmdargs, options,
 		    function (error, stdout, stderr) {
-			onChildExited(cmdstr, callback, error, stdout, stderr);
+			onChildExited(cmdstr, callback, error, stdout, stderr,
+			    args.includeStderr);
 		    });
 	} catch (ex) {
 		rv = null;
-		setImmediate(onChildExited, cmdstr, callback, ex, '', '');
+		setImmediate(onChildExited, cmdstr, callback, ex, '', '',
+		    args.includeStderr);
 	}
 
 	return (rv);
 }
 
-function onChildExited(cmdstr, callback, error, stdout, stderr)
+function onChildExited(cmdstr, callback, error, stdout, stderr, includeStderr)
 {
 	var info;
+	var extra;
+
+	if (!includeStderr || typeof (stderr) !== 'string' ||
+	    (extra = stderr.trim()) === '') {
+		extra = null;
+	}
 
 	info = interpretChildProcessResult({
 	    'label': cmdstr,
-	    'error': error
+	    'error': error,
+	    '_extra': extra
 	});
 
 	info.stdout = stdout;
@@ -94,6 +104,7 @@ function interpretChildProcessResult(args)
 
 	mod_assertplus.object(args, 'args');
 	mod_assertplus.string(args.label, 'args.label');
+	mod_assertplus.optionalString(args._extra, 'args._extra');
 
 	error = args.error;
 	info = {
@@ -124,7 +135,12 @@ function interpretChildProcessResult(args)
 		info.signal = error.signal;
 	} else if (typeof (error.code) == 'number') {
 		/* See above. */
-		err = new VError('exited with status %d', error.code);
+		if (args._extra) {
+			err = new VError('exited with status %d: %s',
+			    error.code, args._extra);
+		} else {
+			err = new VError('exited with status %d', error.code);
+		}
 		info.status = error.code;
 	} else {
 		/*
diff --git a/test/tst.forkExecWaitCmdFailedNoStderr.js b/test/tst.forkExecWaitCmdFailedNoStderr.js
new file mode 100644
index 0000000..39e7a65
--- /dev/null
+++ b/test/tst.forkExecWaitCmdFailedNoStderr.js
@@ -0,0 +1,25 @@
+var assert = require('assert-plus');
+var path = require('path');
+var forkExecWait = require('../lib/forkexec').forkExecWait;
+
+var done = false;
+process.on('exit', function () { assert.ok(done); });
+
+var program = path.join(__dirname, '..', 'tools', 'failer');
+
+forkExecWait({
+    'argv': [ program ],
+    'includeStderr': false
+}, function (err, info) {
+	console.log(info);
+	assert.ok(!done);
+	done = true;
+	assert.ok(err instanceof Error);
+	assert.ok(info.error == err);
+	assert.equal(err.message, 'exec "' + program + '": exited with ' +
+	    'status 23');
+	assert.equal(info.status, 23);
+	assert.ok(info.signal === null);
+	assert.ok(info.stdout === '');
+	assert.equal(info.stderr, 'He has killed me, mother.\n');
+});
diff --git a/test/tst.forkExecWaitCmdFailedStderr.js b/test/tst.forkExecWaitCmdFailedStderr.js
new file mode 100644
index 0000000..96ddc52
--- /dev/null
+++ b/test/tst.forkExecWaitCmdFailedStderr.js
@@ -0,0 +1,26 @@
+var assert = require('assert-plus');
+var path = require('path');
+var forkExecWait = require('../lib/forkexec').forkExecWait;
+
+var done = false;
+process.on('exit', function () { assert.ok(done); });
+
+var program = path.join(__dirname, '..', 'tools', 'failer');
+var expected = 'He has killed me, mother';
+
+forkExecWait({
+    'argv': [ program ],
+    'includeStderr': true
+}, function (err, info) {
+	console.log(info);
+	assert.ok(!done);
+	done = true;
+	assert.ok(err instanceof Error);
+	assert.ok(info.error == err);
+	assert.equal(err.message, 'exec "' + program + '": exited with ' +
+	    'status 23: He has killed me, mother.');
+	assert.equal(info.status, 23);
+	assert.ok(info.signal === null);
+	assert.ok(info.stdout === '');
+	assert.equal(info.stderr, 'He has killed me, mother.\n');
+});
diff --git a/tools/failer b/tools/failer
new file mode 100755
index 0000000..d854896
--- /dev/null
+++ b/tools/failer
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+#
+# Emit a constant message to stderr and exit non-zero.  For use in the test
+# suite.
+#
+
+echo 'He has killed me, mother.' >&2
+exit 23
+
-- 
2.21.0

