commit 40d72b6730316c8a39a48ea8e241b38f019749eb (refs/changes/42/642/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-10-10T16:15:03-07:00 (3 years ago)
    
    joyent/node-mname#6 want TSIG support

diff --git a/lib/dns-buffer.js b/lib/dns-buffer.js
index b220748..fbbc197 100644
--- a/lib/dns-buffer.js
+++ b/lib/dns-buffer.js
@@ -41,7 +41,7 @@ DNSBuffer.prototype.toBuffer = function () {
 };
 
 DNSBuffer.prototype.atEnd = function () {
-        return (this._offset >= this._buffer.length);
+        return (this._offset >= this._size);
 };
 
 DNSBuffer.prototype.remainder = function () {
@@ -160,6 +160,27 @@ DNSBuffer.prototype.writeName = function (name) {
         }
 };
 
+DNSBuffer.prototype.writeNamePlain = function (name) {
+        assert.string(name, 'name');
+
+        if (name === '' || name === '.') {
+                this.writeUInt8(0);
+                return;
+        }
+        var rparts = name.split('.');
+
+        var rlen;
+        while (rparts.length > 0) {
+                var part = rparts.shift();
+                rlen = part.length;
+                assert.ok(rlen < 64, 'segment "' + part + '" of name "' +
+                    name + '" is too long');
+                this.writeUInt8(rlen);
+                this.write(new Buffer(part, 'ascii'));
+        }
+        this.writeUInt8(0);
+};
+
 DNSBuffer.prototype.writeUInt32 = function (v) {
         while (this._offset + 4 > this._size)
                 this.expand();
diff --git a/lib/index.js b/lib/index.js
index c5c2288..7c36603 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -30,6 +30,7 @@ var bunyan = require('bunyan');
 var Server = require('./server');
 var Query = require('./query');
 var Protocol = require('./protocol');
+var tsig = require('./tsig');
 
 
 
@@ -71,6 +72,8 @@ module.exports = {
 
         Protocol: Protocol,
 
+        tsig: tsig,
+
         bunyan: { serializers: BUNYAN_SERIALIZERS }
 
 };
diff --git a/lib/protocol.js b/lib/protocol.js
index 6f4a20b..7f2614d 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -105,6 +105,41 @@ Formats.srv = {
         target: { type: '_nsName' }
 };
 
+Formats.tsig = {
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        mac: { type: '_lp16Binary' },
+        origid: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
+Formats.tsigSignDataReq = {
+        message: { type: '_binary' },
+        rname: { type: '_nsNamePlain' },
+        rclass: { type: 'UInt16BE' },
+        rttl: { type: 'UInt32BE' },
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
+Formats.tsigSignDataResp = {
+        rmac: { type: '_lp16Binary' },
+        message: { type: '_binary' },
+        rname: { type: '_nsNamePlain' },
+        rclass: { type: 'UInt16BE' },
+        rttl: { type: 'UInt32BE' },
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
 Formats.message = {
         header: { type: { format: 'header' } },
         question: { type: { format: 'question' },
@@ -154,6 +189,23 @@ function parseIPv6(addr) {
 // each of these serializers are functions which accept a value to serialize
 // and must returns the serialized value as a buffer
 var serializers = {
+        'DateTime48': {
+                encoder: function (buf, v, ctx) {
+                        assert.date(v, ctx.field);
+                        var secs = v.getTime() / 1000;
+                        var highPart = Math.floor(secs / 4294967296);
+                        var lowPart = secs & 0xffffffff;
+                        buf.writeUInt16(highPart);
+                        buf.writeUInt32(lowPart);
+                },
+                decoder: function (buf, ctx) {
+                        var highPart = buf.readUInt16();
+                        var lowPart = buf.readUInt32();
+                        var d = new Date();
+                        d.setTime((highPart * 4294967296 + lowPart) * 1000);
+                        return (d);
+                }
+        },
         'UInt32BE': {
                 encoder: function (buf, v, ctx) {
                         assert.number(v, ctx.field);
@@ -232,9 +284,20 @@ var serializers = {
                         return (parts.join(':'));
                 }
         },
+        '_binary': {
+                encoder: function (buf, v, ctx) {
+                        assert.buffer(v, ctx.field);
+                        buf.write(v);
+                },
+                decoder: function (buf, ctx) {
+                        throw (new Error('Direct binaries are write only'));
+                }
+        },
         '_ednsOptions': {
                 encoder: function (buf, v, ctx) {
-                        assert.arrayOfObject(v, 'edns options');
+                        assert.optionalArrayOfObject(v, 'edns options');
+                        if (v === undefined)
+                                return;
                         v.forEach(function (opt) {
                                 assert.number(opt.code);
                                 assert.buffer(opt.data);
@@ -250,7 +313,7 @@ var serializers = {
                                 var opt = {};
                                 opt.code = buf.readUInt16();
                                 buf.readLengthPrefixed(2, function (cbuf) {
-                                        opt.data = cbuf.toBuffer();
+                                        opt.data = cbuf.remainder();
                                 });
                                 opts.push(opt);
                         }
@@ -267,6 +330,15 @@ var serializers = {
                         return (buf.readName());
                 }
         },
+        '_nsNamePlain': {
+                encoder: function (buf, v, ctx) {
+                        assert.string(v, ctx.field);
+                        buf.writeNamePlain(v);
+                },
+                decoder: function (buf, ctx) {
+                        return (buf.readName());
+                }
+        },
         '_nsText': {
                 encoder: function (buf, v, ctx) {
                         assert.string(v);
@@ -281,6 +353,20 @@ var serializers = {
                         return (r);
                 }
         },
+        '_lp16Binary': {
+                encoder: function (buf, v, ctx) {
+                        assert.buffer(v);
+                        buf.writeUInt16(v.length);
+                        buf.write(v);
+                },
+                decoder: function (buf, ctx) {
+                        var r;
+                        buf.readLengthPrefixed(2, function (cbuf) {
+                                r = cbuf.remainder();
+                        });
+                        return (r);
+                }
+        },
         '_nsData': {
                 encoder: function (buf, v, ctx) {
                         buf.writeLengthPrefixed(2, function (cbuf) {
@@ -315,6 +401,9 @@ var serializers = {
                                 case queryTypes['OPT']:
                                         _encode(cbuf, v, 'opt', ctx);
                                         break;
+                                case queryTypes['TSIG']:
+                                        _encode(cbuf, v, 'tsig', ctx);
+                                        break;
                                 default:
                                         throw new Error('unrecognized nsdata' +
                                             ' type');
@@ -359,6 +448,9 @@ var serializers = {
                                 case queryTypes['OPT']:
                                         r = _decode(cbuf, 'opt', ctx);
                                         break;
+                                case queryTypes['TSIG']:
+                                        r = _decode(cbuf, 'tsig', ctx);
+                                        break;
                                 default:
                                         throw (new Error('unsupported nsdata ' +
                                             'type: ' +
@@ -555,10 +647,12 @@ var qClasses = {
         CS   : 0x02, // obsolete
         CH   : 0x03, // chaos class. yes this actually exists
         HS   : 0x04, // Hesiod
+        ANY  : 0xff,
         0x01 : 'IN',
         0x02 : 'CS',
         0x03 : 'CH',
-        0x04 : 'HS'
+        0x04 : 'HS',
+        0xff : 'ANY'
 };
 
 var queryTypes = {
diff --git a/lib/query.js b/lib/query.js
index 97bda80..e0ccd89 100644
--- a/lib/query.js
+++ b/lib/query.js
@@ -26,7 +26,7 @@ var queryTypes = protocol.queryTypes;
 var nsRecord = require('./records/ns');
 var soaRecord = require('./records/soa');
 var assert = require('assert-plus');
-
+var mod_tsig = require('./tsig');
 
 function Query(opts) {
         assert.object(opts, 'options');
@@ -42,6 +42,7 @@ function Query(opts) {
 
         this.id = q.header.id;
         this.query = q;
+        this.tsigKey = undefined;
 
         this.reset();
         this.response.header.qdCount = q.header.qdCount;
@@ -140,6 +141,29 @@ Query.prototype.ixfrBase = function ixfrBase() {
         return (q.authority[0].rdata.serial);
 };
 
+Query.prototype.isSigned = function isSigned() {
+        var tsig = this.query.additional[this.query.additional.length - 1];
+        return (tsig.rtype === queryTypes.TSIG);
+};
+
+Query.prototype.verify = function verify(keys) {
+        var tsig = this.query.additional[this.query.additional.length - 1];
+        if (tsig.rtype !== queryTypes.TSIG)
+                return (false);
+        try {
+                var result = mod_tsig.verifyRequest(this.query, keys);
+        } catch (err) {
+                var log = this._log || this.log;
+                if (log) {
+                        log.warn({err: err}, 'error processing TSIG');
+                }
+                return (false);
+        }
+        if (result)
+                this.tsigKey = keys[tsig.name];
+        return (result);
+};
+
 Query.prototype.setError = function setError(name) {
         var code = protocol.rCodes[name.toUpperCase()];
         if (code === undefined) {
@@ -167,6 +191,9 @@ Query.prototype.operation = function operation() {
 };
 
 Query.prototype.encode = function encode(recur) {
+        if (this.tsigKey !== undefined)
+                mod_tsig.signResponse(this.response, this.tsigKey, this.query);
+
         var encoded = protocol.encode(this.response, 'message');
 
         if (encoded.length > this.maxReplySize) {
diff --git a/lib/tsig.js b/lib/tsig.js
new file mode 100644
index 0000000..d2731f1
--- /dev/null
+++ b/lib/tsig.js
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+module.exports = {
+	signRequest: signRequest,
+	signResponse: signResponse,
+	verifyRequest: verifyRequest,
+	verifyResponse: verifyResponse
+};
+
+var protocol = require('./protocol');
+var assert = require('assert-plus');
+var crypto = require('crypto');
+
+var ALGOS = {
+	'hmac-md5': 'md5',
+	'hmac-md5.sig-alg.reg.int': 'md5',
+	'hmac-sha1': 'sha1',
+	'hmac-sha256': 'sha256',
+	'hmac-sha384': 'sha384',
+	'hmac-sha512': 'sha512'
+};
+var ALGOREV = {};
+Object.keys(ALGOS).forEach(function (k) {
+	ALGOREV[ALGOS[k]] = k;
+});
+
+function assertKey(key) {
+	assert.string(key.name, 'key.name');
+	assert.string(key.algorithm, 'key.algorithm');
+	assert.buffer(key.data, 'key.data');
+	assert.string(ALGOS[key.algorithm], 'supported algorithm');
+}
+
+function verifyRequest(msg, keys) {
+	assert.object(msg, 'message');
+	assert.object(msg.header, 'message.header');
+	assert.object(keys, 'keys');
+	assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+	return (verify(msg, keys, 'tsigSignDataReq'));
+}
+
+function verifyResponse(msg, keys, reqMsg) {
+	assert.object(msg, 'message');
+	assert.object(msg.header, 'message.header');
+	assert.object(keys, 'keys');
+	assert.object(reqMsg, 'signedRequestMessage');
+	assert.object(reqMsg.header, 'signedRequestMessage.header');
+	assert.arrayOfObject(reqMsg.additional,
+	    'signedRequestMessage.additional');
+	var tsigs = reqMsg.additional.filter(function (rr) {
+		return (rr.rtype === protocol.queryTypes.TSIG);
+	});
+	assert.ok(tsigs.length === 1, 'signedRequestMessage TSIG signature');
+	assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+	return (verify(msg, keys, 'tsigSignDataResp', tsigs[0].rdata.mac));
+}
+
+function signRequest(msg, key) {
+	assert.object(msg, 'message');
+	assert.object(msg.header, 'message.header');
+	assertKey(key);
+	return (sign(msg, key, 'tsigSignDataReq'));
+}
+
+function signResponse(msg, key, reqMsg) {
+	assert.object(msg, 'message');
+	assert.object(msg.header, 'message.header');
+	assertKey(key);
+	assert.object(reqMsg.header, 'signedRequestMessage.header');
+	assert.arrayOfObject(reqMsg.additional,
+	    'signedRequestMessage.additional');
+	var tsigs = reqMsg.additional.filter(function (rr) {
+		return (rr.rtype === protocol.queryTypes.TSIG);
+	});
+	assert.ok(tsigs.length === 1, 'signedRequestMessage TSIG signature');
+	return (sign(msg, key, 'tsigSignDataResp', tsigs[0].rdata.mac));
+}
+
+function verify(msg, keys, format, reqMac) {
+	var newMsg = Object.create(msg);
+	newMsg.header = Object.create(msg.header);
+	newMsg.additional = msg.additional.slice();
+	var tsig = newMsg.additional.pop();
+	assert.strictEqual(tsig.rtype, protocol.queryTypes.TSIG);
+	newMsg.header.arCount--;
+
+	var kname = tsig.name;
+	var key = keys[kname];
+	if (key === undefined)
+		throw (new Error('Unknown TSIG key "' + kname + '"'));
+	assertKey(key);
+
+	var algo = ALGOS[tsig.rdata.algorithm];
+	assert.strictEqual(algo, ALGOS[key.algorithm], 'matching algorithm');
+
+	var tsign = {};
+	tsign.message = protocol.encode(newMsg, 'message');
+	tsign.rname = tsig.name;
+	assert.strictEqual(tsig.rclass, protocol.qClasses.ANY);
+	tsign.rclass = tsig.rclass;
+	assert.strictEqual(tsig.rttl, 0);
+	tsign.rttl = tsig.rttl;
+
+	tsign.algorithm = tsig.rdata.algorithm;
+	tsign.time = tsig.rdata.time;
+	tsign.fudge = tsig.rdata.fudge;
+	tsign.error = tsig.rdata.error;
+	tsign.other = tsig.rdata.other;
+	if (reqMac !== undefined)
+		tsign.rmac = reqMac;
+
+	var now = new Date();
+	var delta = now.getTime() - tsign.time.getTime();
+
+	var blob = protocol.encode(tsign, format);
+	assert.buffer(blob);
+
+	var hmac = crypto.createHmac(algo, key.data);
+	hmac.update(blob);
+	var digest = hmac.digest();
+
+	var comp1 = crypto.createHmac(algo, key.data).
+	    update(tsig.rdata.mac).digest().toString('base64');
+	var comp2 = crypto.createHmac(algo, key.data).
+	    update(digest).digest().toString('base64');
+
+	return (comp1 === comp2 && delta > 0 && delta < tsign.fudge * 1000);
+}
+
+function sign(msg, key, format, reqMac) {
+	var algo = ALGOS[key.algorithm];
+
+	var tsign = {};
+	if (reqMac !== undefined)
+		tsign.rmac = reqMac;
+
+	tsign.message = protocol.encode(msg, 'message');
+	tsign.rname = key.name;
+	tsign.rclass = protocol.qClasses.ANY;
+	tsign.rttl = 0;
+
+	tsign.algorithm = ALGOREV[algo];
+	tsign.time = new Date();
+	tsign.fudge = 300;
+	tsign.error = 0;
+	tsign.other = new Buffer(0);
+
+	var blob = protocol.encode(tsign, format);
+	assert.buffer(blob);
+
+	var hmac = crypto.createHmac(algo, key.data);
+	hmac.update(blob);
+	var digest = hmac.digest();
+
+	var tsig = {};
+	tsig.name = tsign.rname;
+	tsig.rtype = protocol.queryTypes.TSIG;
+	tsig.rclass = tsign.rclass;
+	tsig.rttl = tsign.rttl;
+	tsig.rdata = {};
+	tsig.rdata.algorithm = tsign.algorithm;
+	tsig.rdata.time = tsign.time;
+	tsig.rdata.fudge = tsign.fudge;
+	tsig.rdata.origid = msg.header.id;
+	tsig.rdata.error = tsign.error;
+	tsig.rdata.other = tsign.other;
+
+	tsig.rdata.mac = digest;
+
+	msg.header.arCount++;
+	msg.additional.push(tsig);
+}
diff --git a/package.json b/package.json
index 77a5f27..8429213 100644
--- a/package.json
+++ b/package.json
@@ -18,7 +18,7 @@
     "node": ">=0.6"
   },
   "dependencies": {
-    "assert-plus": "^0.1.5",
+    "assert-plus": "^1.0.0",
     "bunyan": "^1.5.1",
     "ipaddr.js": "^1.0.0"
   },
diff --git a/test/dig.js b/test/dig.js
index fa7979f..1800693 100644
--- a/test/dig.js
+++ b/test/dig.js
@@ -20,13 +20,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */
- 
+
 // Quick and dirty 'dig' wrapper
 
 var assert = require('assert');
-var exec = require('child_process').exec;
+var spawn = require('child_process').spawn;
 var sprintf = require('util').format;
-
+var path = require('path');
 
 
 ///--- Globals
@@ -58,6 +58,8 @@ function parseDig(output) {
         var section = 'header';
 
         var results = {
+                id: null,
+                status: null,
                 question: null,
                 answers: [],
                 additional: [],
@@ -92,6 +94,13 @@ function parseDig(output) {
                                         results.answers.push(answer);
                         }
                 }
+
+                if (/^;; ->>HEADER<<-/.test(l)) {
+                        var m = l.match(/status: ([A-Z]+)/)
+                        results.status = m[1].toLowerCase();
+                        m = l.match(/id: ([0-9]+)/);
+                        results.id = parseInt(m[1], 10);
+                }
         });
 
         return (results);
@@ -113,19 +122,40 @@ function dig(name, type, options, callback) {
 
         type = type.toUpperCase();
 
-        var opts = '';
-        if (options.server)
-                opts += ' @' + options.server;
-        if (options.port)
-                opts += ' -p ' + options.port;
-
-        var cmd = sprintf('dig %s -t %s %s +time=1 +retry=0', opts, type, name);
-        exec(cmd, function (err, stdout, stderr) {
-                if (err)
-                        return (callback(err));
-
+        var opts = [];
+        if (options.server) {
+                opts.push('@' + options.server);
+        }
+        if (options.port) {
+                opts.push('-p');
+                opts.push(options.port);
+        }
+        if (options.key) {
+                opts.push('-y');
+                var key = options.key;
+                opts.push(key.algorithm + ':' + key.name + ':' +
+                    key.data.toString('base64'));
+        }
+        opts = opts.concat(['-t', type, name, '+time=1', '+retry=0']);
 
-                return (callback(null, parseDig(stdout)));
+        var kid = spawn('dig', opts, {
+                stdio: ['pipe', 'pipe', 'inherit'],
+        });
+        kid.stdin.end();
+        var stdout = [];
+        kid.stdout.on('readable', function () {
+                var b;
+                while ((b = kid.stdout.read()) !== null) {
+                        stdout.push(b);
+                }
+        });
+        kid.on('exit', function (exitStatus) {
+                if (exitStatus !== 0) {
+                        return (callback(
+                            new Error('dig exited with status ' + exitStatus)));
+                }
+                return (callback(null, parseDig(
+                    Buffer.concat(stdout).toString('ascii'))));
         });
 }
 
diff --git a/test/tsig.test.js b/test/tsig.test.js
new file mode 100644
index 0000000..b00df4c
--- /dev/null
+++ b/test/tsig.test.js
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+var mod_mname = require('../lib');
+var dig = require('./dig');
+var mod_crypto = require('crypto');
+
+if (require.cache[__dirname + '/helper.js'])
+        delete require.cache[__dirname + '/helper.js']
+var helper = require('./helper');
+
+var test = helper.test;
+var before = helper.before;
+var after = helper.after;
+
+var options = { port: 9999, server: '::1' };
+
+var KEY_MD5 = {
+        name: 'md5test',
+        algorithm: 'hmac-md5',
+        data: mod_crypto.randomBytes(8)
+};
+
+var KEY_SHA1 = {
+        name: 'shatest',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEY_SHA1_2 = {
+        name: 'shatest2',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEY_SHA1_3 = {
+        name: 'shatest',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEYS = {
+        'shatest': KEY_SHA1,
+        'md5test': KEY_MD5
+};
+
+before(function (callback) {
+        this.server = mod_mname.createServer({
+                log: helper.getLog('server')
+        });
+
+        this.server.on('query', function (query, cb) {
+                if (!query.isSigned() || !query.verify(KEYS)) {
+                        query.setError('notauth');
+                        query.send();
+                        cb();
+                        return;
+                }
+                var domain = query.name();
+                var record = new mod_mname.ARecord('127.0.0.1');
+                query.addAnswer(domain, record, 300);
+                query.send();
+                cb();
+        });
+
+        this.server.listen(options.port, options.server, function () {
+                process.nextTick(callback);
+        });
+});
+
+after(function (cb) {
+        this.server.close(cb);
+});
+
+process.on('uncaughtException', function(err) {
+  console.error(err.stack);
+});
+
+test('tsig required', function (t) {
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+test('tsig md5', function (t) {
+        options.key = KEY_MD5;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'noerror');
+                t.deepEqual(results.answers, [{
+                        name: 'example.com.',
+                        ttl: 300, type: 'A',
+                        target: '127.0.0.1'
+                }]);
+                t.end();
+        });
+});
+
+test('tsig sha1', function (t) {
+        options.key = KEY_SHA1;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'noerror');
+                t.deepEqual(results.answers, [{
+                        name: 'example.com.',
+                        ttl: 300, type: 'A',
+                        target: '127.0.0.1'
+                }]);
+                t.end();
+        });
+});
+
+test('tsig sha1 with unknown key', function (t) {
+        options.key = KEY_SHA1_2;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+test('tsig sha1 with wrong key', function (t) {
+        options.key = KEY_SHA1_3;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
