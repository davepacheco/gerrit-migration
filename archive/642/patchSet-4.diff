From 5c61fefd557dd3045e5ef92d0a8f1ce3d4ec0996 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Mon, 10 Oct 2016 16:15:03 -0700
Subject: [PATCH] joyent/node-mname#6 want TSIG support

---
 lib/dns-buffer.js |  23 ++++-
 lib/index.js      |   3 +
 lib/protocol.js   | 113 +++++++++++++++++++++--
 lib/query.js      |  40 +++++++-
 lib/tsig.js       | 228 ++++++++++++++++++++++++++++++++++++++++++++++
 package.json      |   2 +-
 test/dig.js       |  72 ++++++++++++---
 test/tsig.test.js | 197 +++++++++++++++++++++++++++++++++++++++
 8 files changed, 654 insertions(+), 24 deletions(-)
 create mode 100644 lib/tsig.js
 create mode 100644 test/tsig.test.js

diff --git a/lib/dns-buffer.js b/lib/dns-buffer.js
index b220748..fbbc197 100644
--- a/lib/dns-buffer.js
+++ b/lib/dns-buffer.js
@@ -41,7 +41,7 @@ DNSBuffer.prototype.toBuffer = function () {
 };
 
 DNSBuffer.prototype.atEnd = function () {
-        return (this._offset >= this._buffer.length);
+        return (this._offset >= this._size);
 };
 
 DNSBuffer.prototype.remainder = function () {
@@ -160,6 +160,27 @@ DNSBuffer.prototype.writeName = function (name) {
         }
 };
 
+DNSBuffer.prototype.writeNamePlain = function (name) {
+        assert.string(name, 'name');
+
+        if (name === '' || name === '.') {
+                this.writeUInt8(0);
+                return;
+        }
+        var rparts = name.split('.');
+
+        var rlen;
+        while (rparts.length > 0) {
+                var part = rparts.shift();
+                rlen = part.length;
+                assert.ok(rlen < 64, 'segment "' + part + '" of name "' +
+                    name + '" is too long');
+                this.writeUInt8(rlen);
+                this.write(new Buffer(part, 'ascii'));
+        }
+        this.writeUInt8(0);
+};
+
 DNSBuffer.prototype.writeUInt32 = function (v) {
         while (this._offset + 4 > this._size)
                 this.expand();
diff --git a/lib/index.js b/lib/index.js
index c5c2288..7c36603 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -30,6 +30,7 @@ var bunyan = require('bunyan');
 var Server = require('./server');
 var Query = require('./query');
 var Protocol = require('./protocol');
+var tsig = require('./tsig');
 
 
 
@@ -71,6 +72,8 @@ module.exports = {
 
         Protocol: Protocol,
 
+        tsig: tsig,
+
         bunyan: { serializers: BUNYAN_SERIALIZERS }
 
 };
diff --git a/lib/protocol.js b/lib/protocol.js
index 6f4a20b..c6ea187 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -105,6 +105,48 @@ Formats.srv = {
         target: { type: '_nsName' }
 };
 
+Formats.tsig = {
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        mac: { type: '_lp16Binary' },
+        origid: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
+Formats.tsigSignDataReq = {
+        message: { type: '_binary' },
+        rname: { type: '_nsNamePlain' },
+        rclass: { type: 'UInt16BE' },
+        rttl: { type: 'UInt32BE' },
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
+Formats.tsigSignDataResp = {
+        rmac: { type: '_lp16Binary' },
+        message: { type: '_binary' },
+        rname: { type: '_nsNamePlain' },
+        rclass: { type: 'UInt16BE' },
+        rttl: { type: 'UInt32BE' },
+        algorithm: { type: '_nsNamePlain' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' },
+        error: { type: 'UInt16BE' },
+        other: { type: '_lp16Binary' }
+};
+
+Formats.tsigSignTcp = {
+        rmac: { type: '_lp16Binary' },
+        message: { type: '_binary' },
+        time: { type: 'DateTime48' },
+        fudge: { type: 'UInt16BE' }
+};
+
 Formats.message = {
         header: { type: { format: 'header' } },
         question: { type: { format: 'question' },
@@ -152,8 +194,25 @@ function parseIPv6(addr) {
 
 
 // each of these serializers are functions which accept a value to serialize
-// and must returns the serialized value as a buffer
+// and must return the serialized value as a buffer
 var serializers = {
+        'DateTime48': {
+                encoder: function (buf, v, ctx) {
+                        assert.date(v, ctx.field);
+                        var secs = v.getTime() / 1000;
+                        var highPart = Math.floor(secs / 4294967296);
+                        var lowPart = secs & 0xffffffff;
+                        buf.writeUInt16(highPart);
+                        buf.writeUInt32(lowPart);
+                },
+                decoder: function (buf, ctx) {
+                        var highPart = buf.readUInt16();
+                        var lowPart = buf.readUInt32();
+                        var d = new Date();
+                        d.setTime((highPart * 4294967296 + lowPart) * 1000);
+                        return (d);
+                }
+        },
         'UInt32BE': {
                 encoder: function (buf, v, ctx) {
                         assert.number(v, ctx.field);
@@ -232,9 +291,20 @@ var serializers = {
                         return (parts.join(':'));
                 }
         },
+        '_binary': {
+                encoder: function (buf, v, ctx) {
+                        assert.buffer(v, ctx.field);
+                        buf.write(v);
+                },
+                decoder: function (buf, ctx) {
+                        throw (new Error('Direct binaries are write only'));
+                }
+        },
         '_ednsOptions': {
                 encoder: function (buf, v, ctx) {
-                        assert.arrayOfObject(v, 'edns options');
+                        assert.optionalArrayOfObject(v, 'edns options');
+                        if (v === undefined)
+                                return;
                         v.forEach(function (opt) {
                                 assert.number(opt.code);
                                 assert.buffer(opt.data);
@@ -250,7 +320,7 @@ var serializers = {
                                 var opt = {};
                                 opt.code = buf.readUInt16();
                                 buf.readLengthPrefixed(2, function (cbuf) {
-                                        opt.data = cbuf.toBuffer();
+                                        opt.data = cbuf.remainder();
                                 });
                                 opts.push(opt);
                         }
@@ -267,6 +337,15 @@ var serializers = {
                         return (buf.readName());
                 }
         },
+        '_nsNamePlain': {
+                encoder: function (buf, v, ctx) {
+                        assert.string(v, ctx.field);
+                        buf.writeNamePlain(v);
+                },
+                decoder: function (buf, ctx) {
+                        return (buf.readName());
+                }
+        },
         '_nsText': {
                 encoder: function (buf, v, ctx) {
                         assert.string(v);
@@ -281,6 +360,20 @@ var serializers = {
                         return (r);
                 }
         },
+        '_lp16Binary': {
+                encoder: function (buf, v, ctx) {
+                        assert.buffer(v);
+                        buf.writeUInt16(v.length);
+                        buf.write(v);
+                },
+                decoder: function (buf, ctx) {
+                        var r;
+                        buf.readLengthPrefixed(2, function (cbuf) {
+                                r = cbuf.remainder();
+                        });
+                        return (r);
+                }
+        },
         '_nsData': {
                 encoder: function (buf, v, ctx) {
                         buf.writeLengthPrefixed(2, function (cbuf) {
@@ -315,6 +408,9 @@ var serializers = {
                                 case queryTypes['OPT']:
                                         _encode(cbuf, v, 'opt', ctx);
                                         break;
+                                case queryTypes['TSIG']:
+                                        _encode(cbuf, v, 'tsig', ctx);
+                                        break;
                                 default:
                                         throw new Error('unrecognized nsdata' +
                                             ' type');
@@ -359,6 +455,9 @@ var serializers = {
                                 case queryTypes['OPT']:
                                         r = _decode(cbuf, 'opt', ctx);
                                         break;
+                                case queryTypes['TSIG']:
+                                        r = _decode(cbuf, 'tsig', ctx);
+                                        break;
                                 default:
                                         throw (new Error('unsupported nsdata ' +
                                             'type: ' +
@@ -555,10 +654,12 @@ var qClasses = {
         CS   : 0x02, // obsolete
         CH   : 0x03, // chaos class. yes this actually exists
         HS   : 0x04, // Hesiod
+        ANY  : 0xff,
         0x01 : 'IN',
         0x02 : 'CS',
         0x03 : 'CH',
-        0x04 : 'HS'
+        0x04 : 'HS',
+        0xff : 'ANY'
 };
 
 var queryTypes = {
@@ -582,7 +683,7 @@ var queryTypes = {
         SRV   : 0x21,    // srv records
         OPT   : 0x29,
         TKEY  : 0xF9,
-        TSIG  : 0xFA,
+        TSIG  : 0xFA,    // transaction signatures (RFC2845)
         IXFR  : 0xFB,    // request for incremental transfer
         AXFR  : 0xFC,    // request to transfer entire zone
         MAILA : 0xFE,    // request for mailbox related records
@@ -608,7 +709,7 @@ var queryTypes = {
         0x21  : 'SRV',   // srv records
         0x29  : 'OPT',
         0xF9  : 'TKEY',
-        0xFA  : 'TSIG',
+        0xFA  : 'TSIG',  // transaction signatures (RFC2845)
         0xFB  : 'IXFR',  // req for incremental transfer
         0xFC  : 'AXFR',  // request to transfer entire zone
         0xFE  : 'MAILA', // request for mailbox related records
diff --git a/lib/query.js b/lib/query.js
index 97bda80..d28178d 100644
--- a/lib/query.js
+++ b/lib/query.js
@@ -26,7 +26,7 @@ var queryTypes = protocol.queryTypes;
 var nsRecord = require('./records/ns');
 var soaRecord = require('./records/soa');
 var assert = require('assert-plus');
-
+var mod_tsig = require('./tsig');
 
 function Query(opts) {
         assert.object(opts, 'options');
@@ -42,6 +42,9 @@ function Query(opts) {
 
         this.id = q.header.id;
         this.query = q;
+        this.envelopeCount = 1;
+        this.tsigKey = undefined;
+        this.lastResponse = undefined;
 
         this.reset();
         this.response.header.qdCount = q.header.qdCount;
@@ -52,7 +55,9 @@ function Query(opts) {
 
 Query.prototype.reset = function () {
         var q = this.query;
+        this.lastResponse = this.response;
         var r = this.response = {};
+        ++this.envelopeCount;
 
         r.header = {
                 id: q.header.id,
@@ -140,6 +145,29 @@ Query.prototype.ixfrBase = function ixfrBase() {
         return (q.authority[0].rdata.serial);
 };
 
+Query.prototype.isSigned = function isSigned() {
+        var tsig = this.query.additional[this.query.additional.length - 1];
+        return (tsig && tsig.rtype === queryTypes.TSIG);
+};
+
+Query.prototype.verify = function verify(keys) {
+        var tsig = this.query.additional[this.query.additional.length - 1];
+        if (tsig.rtype !== queryTypes.TSIG)
+                return (false);
+        try {
+                var result = mod_tsig.verifyRequest(this.query, keys);
+        } catch (err) {
+                var log = this._log || this.log;
+                if (log) {
+                        log.warn({err: err}, 'error processing TSIG');
+                }
+                return (false);
+        }
+        if (result)
+                this.tsigKey = keys[tsig.name];
+        return (result);
+};
+
 Query.prototype.setError = function setError(name) {
         var code = protocol.rCodes[name.toUpperCase()];
         if (code === undefined) {
@@ -167,6 +195,16 @@ Query.prototype.operation = function operation() {
 };
 
 Query.prototype.encode = function encode(recur) {
+        if (this.tsigKey !== undefined) {
+                if (this.lastResponse === undefined) {
+                        mod_tsig.signResponse(this.response, this.tsigKey,
+                            this.query);
+                } else {
+                        mod_tsig.signTcpContinuation(this.response,
+                            this.tsigKey, this.lastResponse);
+                }
+        }
+
         var encoded = protocol.encode(this.response, 'message');
 
         if (encoded.length > this.maxReplySize) {
diff --git a/lib/tsig.js b/lib/tsig.js
new file mode 100644
index 0000000..182ca68
--- /dev/null
+++ b/lib/tsig.js
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Transaction Signatures for DNS (see RFC2845)
+ */
+
+module.exports = {
+        signRequest: signRequest,
+        signResponse: signResponse,
+        signTcpContinuation: signTcpContinuation,
+        verifyRequest: verifyRequest,
+        verifyResponse: verifyResponse,
+        verifyTcpContinuation: verifyTcpContinuation
+};
+
+var protocol = require('./protocol');
+var assert = require('assert-plus');
+var crypto = require('crypto');
+
+var ALGOS = {
+        'hmac-md5': 'md5',
+        'hmac-md5.sig-alg.reg.int': 'md5',
+        'hmac-sha1': 'sha1',
+        'hmac-sha256': 'sha256',
+        'hmac-sha384': 'sha384',
+        'hmac-sha512': 'sha512'
+};
+var ALGOREV = {};
+Object.keys(ALGOS).forEach(function (k) {
+        ALGOREV[ALGOS[k]] = k;
+});
+
+function assertKey(key) {
+        assert.string(key.name, 'key.name');
+        assert.string(key.algorithm, 'key.algorithm');
+        assert.buffer(key.data, 'key.data');
+        assert.string(ALGOS[key.algorithm], 'supported algorithm');
+}
+
+function verifyRequest(msg, keys) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assert.object(keys, 'keys');
+        assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+        return (verify(msg, keys, 'tsigSignDataReq'));
+}
+
+function verifyResponse(msg, keys, reqMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assert.object(keys, 'keys');
+        assert.object(reqMsg, 'signedRequestMessage');
+        assert.object(reqMsg.header, 'signedRequestMessage.header');
+        assert.arrayOfObject(reqMsg.additional,
+            'signedRequestMessage.additional');
+        var tsigs = reqMsg.additional.filter(function (rr) {
+                return (rr.rtype === protocol.queryTypes.TSIG);
+        });
+        assert.ok(tsigs.length === 1, 'signedRequestMessage TSIG signature');
+        assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+        return (verify(msg, keys, 'tsigSignDataResp', tsigs[0].rdata.mac));
+}
+
+function verifyTcpContinuation(msg, keys, lastMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assert.object(keys, 'keys');
+        assert.object(lastMsg, 'signedLastMessage');
+        assert.object(lastMsg.header, 'signedLastMessage.header');
+        assert.arrayOfObject(lastMsg.additional,
+            'signedLastMessage.additional');
+        var tsigs = lastMsg.additional.filter(function (rr) {
+                return (rr.rtype === protocol.queryTypes.TSIG);
+        });
+        assert.ok(tsigs.length === 1, 'signedLastMessage TSIG signature');
+        assert.ok(Object.keys(keys).length > 0, 'non-empty keys object');
+        return (verify(msg, keys, 'tsigSignTcp', tsigs[0].rdata.mac));
+}
+
+function signRequest(msg, key) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assertKey(key);
+        return (sign(msg, key, 'tsigSignDataReq'));
+}
+
+function signResponse(msg, key, reqMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assertKey(key);
+        assert.object(reqMsg.header, 'signedRequestMessage.header');
+        assert.arrayOfObject(reqMsg.additional,
+            'signedRequestMessage.additional');
+        var tsigs = reqMsg.additional.filter(function (rr) {
+                return (rr.rtype === protocol.queryTypes.TSIG);
+        });
+        assert.ok(tsigs.length === 1, 'signedRequestMessage TSIG signature');
+        return (sign(msg, key, 'tsigSignDataResp', tsigs[0].rdata.mac));
+}
+
+function signTcpContinuation(msg, key, lastMsg) {
+        assert.object(msg, 'message');
+        assert.object(msg.header, 'message.header');
+        assertKey(key);
+        assert.object(lastMsg.header, 'signedLastMessage.header');
+        assert.arrayOfObject(lastMsg.additional,
+            'signedLastMessage.additional');
+        var tsigs = lastMsg.additional.filter(function (rr) {
+                return (rr.rtype === protocol.queryTypes.TSIG);
+        });
+        assert.ok(tsigs.length === 1, 'signedLastMessage TSIG signature');
+        return (sign(msg, key, 'tsigSignTcp', tsigs[0].rdata.mac));
+}
+
+function verify(msg, keys, format, reqMac) {
+        var newMsg = Object.create(msg);
+        newMsg.header = Object.create(msg.header);
+        newMsg.additional = msg.additional.slice();
+        var tsig = newMsg.additional.pop();
+        assert.strictEqual(tsig.rtype, protocol.queryTypes.TSIG);
+        newMsg.header.arCount--;
+
+        var kname = tsig.name;
+        var key = keys[kname];
+        if (key === undefined)
+                throw (new Error('Unknown TSIG key "' + kname + '"'));
+        assertKey(key);
+
+        var algo = ALGOS[tsig.rdata.algorithm];
+        assert.strictEqual(algo, ALGOS[key.algorithm], 'matching algorithm');
+
+        var tsign = {};
+        tsign.message = protocol.encode(newMsg, 'message');
+        tsign.rname = tsig.name;
+        assert.strictEqual(tsig.rclass, protocol.qClasses.ANY);
+        tsign.rclass = tsig.rclass;
+        assert.strictEqual(tsig.rttl, 0);
+        tsign.rttl = tsig.rttl;
+
+        tsign.algorithm = tsig.rdata.algorithm;
+        tsign.time = tsig.rdata.time;
+        tsign.fudge = tsig.rdata.fudge;
+        tsign.error = tsig.rdata.error;
+        tsign.other = tsig.rdata.other;
+        if (reqMac !== undefined)
+                tsign.rmac = reqMac;
+
+        var now = new Date();
+        var delta = now.getTime() - tsign.time.getTime();
+
+        var blob = protocol.encode(tsign, format);
+        assert.buffer(blob);
+
+        var hmac = crypto.createHmac(algo, key.data);
+        hmac.update(blob);
+        var digest = hmac.digest();
+
+        var comp1 = crypto.createHmac(algo, key.data).
+            update(tsig.rdata.mac).digest().toString('base64');
+        var comp2 = crypto.createHmac(algo, key.data).
+            update(digest).digest().toString('base64');
+
+        return (comp1 === comp2 && delta > 0 && delta < tsign.fudge * 1000);
+}
+
+function sign(msg, key, format, reqMac) {
+        var algo = ALGOS[key.algorithm];
+
+        var tsign = {};
+        if (reqMac !== undefined)
+                tsign.rmac = reqMac;
+
+        tsign.message = protocol.encode(msg, 'message');
+        tsign.rname = key.name;
+        tsign.rclass = protocol.qClasses.ANY;
+        tsign.rttl = 0;
+
+        tsign.algorithm = ALGOREV[algo];
+        tsign.time = new Date();
+        tsign.fudge = 300;
+        tsign.error = 0;
+        tsign.other = new Buffer(0);
+
+        var blob = protocol.encode(tsign, format);
+        assert.buffer(blob);
+
+        var hmac = crypto.createHmac(algo, key.data);
+        hmac.update(blob);
+        var digest = hmac.digest();
+
+        var tsig = {};
+        tsig.name = tsign.rname;
+        tsig.rtype = protocol.queryTypes.TSIG;
+        tsig.rclass = tsign.rclass;
+        tsig.rttl = tsign.rttl;
+        tsig.rdata = {};
+        tsig.rdata.algorithm = tsign.algorithm;
+        tsig.rdata.time = tsign.time;
+        tsig.rdata.fudge = tsign.fudge;
+        tsig.rdata.origid = msg.header.id;
+        tsig.rdata.error = tsign.error;
+        tsig.rdata.other = tsign.other;
+
+        tsig.rdata.mac = digest;
+
+        msg.header.arCount++;
+        msg.additional.push(tsig);
+}
diff --git a/package.json b/package.json
index 77a5f27..8429213 100644
--- a/package.json
+++ b/package.json
@@ -18,7 +18,7 @@
     "node": ">=0.6"
   },
   "dependencies": {
-    "assert-plus": "^0.1.5",
+    "assert-plus": "^1.0.0",
     "bunyan": "^1.5.1",
     "ipaddr.js": "^1.0.0"
   },
diff --git a/test/dig.js b/test/dig.js
index fa7979f..a31307d 100644
--- a/test/dig.js
+++ b/test/dig.js
@@ -20,13 +20,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */
- 
+
 // Quick and dirty 'dig' wrapper
 
 var assert = require('assert');
-var exec = require('child_process').exec;
+var spawn = require('child_process').spawn;
 var sprintf = require('util').format;
-
+var path = require('path');
 
 
 ///--- Globals
@@ -58,7 +58,10 @@ function parseDig(output) {
         var section = 'header';
 
         var results = {
+                id: null,
+                status: null,
                 question: null,
+                tsigFail: false,
                 answers: [],
                 additional: [],
                 authority: []
@@ -75,6 +78,8 @@ function parseDig(output) {
                         section = 'additional';
                 } else if (/^;; AUTHORITY SECTION:/.test(l)) {
                         section = 'authority';
+                } else if (/^; <<>> DiG.* axfr /i.test(l)) {
+                        section = 'answer';
                 }
 
                 if (section === 'question') {
@@ -92,6 +97,22 @@ function parseDig(output) {
                                         results.answers.push(answer);
                         }
                 }
+
+                if (/^;; ->>HEADER<<-/.test(l)) {
+                        var m = l.match(/status: ([A-Z]+)/)
+                        results.status = m[1].toLowerCase();
+                        m = l.match(/id: ([0-9]+)/);
+                        results.id = parseInt(m[1], 10);
+                }
+
+                if (/Some TSIG could not be validated/.test(l) ||
+                    /tsig verify failure/.test(l)) {
+                        results.tsigFail = true;
+                }
+
+                if (/^; Transfer failed/.test(l)) {
+                        results.status = 'failed';
+                }
         });
 
         return (results);
@@ -113,19 +134,40 @@ function dig(name, type, options, callback) {
 
         type = type.toUpperCase();
 
-        var opts = '';
-        if (options.server)
-                opts += ' @' + options.server;
-        if (options.port)
-                opts += ' -p ' + options.port;
-
-        var cmd = sprintf('dig %s -t %s %s +time=1 +retry=0', opts, type, name);
-        exec(cmd, function (err, stdout, stderr) {
-                if (err)
-                        return (callback(err));
-
+        var opts = [];
+        if (options.server) {
+                opts.push('@' + options.server);
+        }
+        if (options.port) {
+                opts.push('-p');
+                opts.push(options.port);
+        }
+        if (options.key) {
+                opts.push('-y');
+                var key = options.key;
+                opts.push(key.algorithm + ':' + key.name + ':' +
+                    key.data.toString('base64'));
+        }
+        opts = opts.concat(['-t', type, name, '+time=1', '+retry=0']);
 
-                return (callback(null, parseDig(stdout)));
+        var kid = spawn('dig', opts, {
+                stdio: ['pipe', 'pipe', 'inherit'],
+        });
+        kid.stdin.end();
+        var stdout = [];
+        kid.stdout.on('readable', function () {
+                var b;
+                while ((b = kid.stdout.read()) !== null) {
+                        stdout.push(b);
+                }
+        });
+        kid.on('exit', function (exitStatus) {
+                if (exitStatus !== 0) {
+                        return (callback(
+                            new Error('dig exited with status ' + exitStatus)));
+                }
+                return (callback(null, parseDig(
+                    Buffer.concat(stdout).toString('ascii'))));
         });
 }
 
diff --git a/test/tsig.test.js b/test/tsig.test.js
new file mode 100644
index 0000000..6903ec8
--- /dev/null
+++ b/test/tsig.test.js
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+var mod_mname = require('../lib');
+var dig = require('./dig');
+var mod_crypto = require('crypto');
+
+if (require.cache[__dirname + '/helper.js'])
+        delete require.cache[__dirname + '/helper.js']
+var helper = require('./helper');
+
+var test = helper.test;
+var before = helper.before;
+var after = helper.after;
+
+var options = { port: 9999, server: '::1' };
+
+var KEY_MD5 = {
+        name: 'md5test',
+        algorithm: 'hmac-md5',
+        data: mod_crypto.randomBytes(8)
+};
+
+var KEY_SHA1 = {
+        name: 'shatest',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEY_SHA1_2 = {
+        name: 'shatest2',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEY_SHA1_3 = {
+        name: 'shatest',
+        algorithm: 'hmac-sha1',
+        data: mod_crypto.randomBytes(12)
+};
+
+var KEYS = {
+        'shatest': KEY_SHA1,
+        'md5test': KEY_MD5
+};
+
+before(function (callback) {
+        this.server = mod_mname.createServer({
+                log: helper.getLog('server')
+        });
+        var server = this.server;
+
+        this.server.on('query', function (query, cb) {
+                if (!query.isSigned() || !query.verify(KEYS)) {
+                        query.setError('notauth');
+                        query.send();
+                        cb();
+                        return;
+                }
+                var domain = query.name();
+                var record;
+                if (query.type() === 'AXFR') {
+                        var soa = new mod_mname.SOARecord(domain);
+                        query.addAnswer(domain, soa, 300);
+                        query.send();
+                        record = new mod_mname.ARecord('127.0.0.1');
+                        query.addAnswer(domain, record, 300);
+                        query.send();
+                        query.addAnswer(domain, soa, 300);
+                        query.send();
+                        cb();
+                } else {
+                        record = new mod_mname.ARecord('127.0.0.1');
+                        query.addAnswer(domain, record, 300);
+                        query.send();
+                        cb();
+                }
+        });
+
+        this.server.listenUdp({port: options.port, address: options.server},
+            function () {
+                server.listenTcp({port: options.port, address: options.server},
+                    function () {
+                        process.nextTick(callback);
+                });
+        });
+});
+
+after(function (cb) {
+        this.server.close(cb);
+});
+
+process.on('uncaughtException', function(err) {
+  console.error(err.stack);
+});
+
+test('tsig required', function (t) {
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+test('tsig md5', function (t) {
+        options.key = KEY_MD5;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'noerror');
+                t.ok(!results.tsigFail);
+                t.deepEqual(results.answers, [{
+                        name: 'example.com.',
+                        ttl: 300, type: 'A',
+                        target: '127.0.0.1'
+                }]);
+                t.end();
+        });
+});
+
+test('tsig sha1', function (t) {
+        options.key = KEY_SHA1;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'noerror');
+                t.ok(!results.tsigFail);
+                t.deepEqual(results.answers, [{
+                        name: 'example.com.',
+                        ttl: 300, type: 'A',
+                        target: '127.0.0.1'
+                }]);
+                t.end();
+        });
+});
+
+test('tsig sha1 with unknown key', function (t) {
+        options.key = KEY_SHA1_2;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+test('tsig sha1 with wrong key', function (t) {
+        options.key = KEY_SHA1_3;
+        dig('example.com', 'A', options, function (err, results) {
+                t.ifError(err);
+                t.equal(results.status, 'notauth');
+                t.end();
+        });
+});
+
+test('tsig axfr', function (t) {
+        options.key = KEY_SHA1;
+        dig('example.com', 'AXFR', options, function (err, results) {
+                t.ifError(err);
+                t.strictEqual(results.status, null);
+                t.ok(!results.tsigFail);
+                var noTsig = results.answers.filter(function (rec) {
+                        return (rec.type !== 'TSIG');
+                });
+                t.deepEqual(noTsig, [{
+                        name: 'example.com.',
+                        ttl: 300, type: 'SOA',
+                        target: 'example.com. hostmaster.example.com. ' +
+                            '0 86400 7200 1209600 10800'
+                }, {
+                        name: 'example.com.',
+                        ttl: 300, type: 'A',
+                        target: '127.0.0.1'
+                }, {
+                        name: 'example.com.',
+                        ttl: 300, type: 'SOA',
+                        target: 'example.com. hostmaster.example.com. ' +
+                            '0 86400 7200 1209600 10800'
+                }]);
+                t.end();
+        });
+});
-- 
2.21.0

