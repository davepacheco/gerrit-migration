commit c8a81528205f13bd5a1584c120499cb9645ddf38 (refs/changes/07/307/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2016-08-23T19:29:54+00:00 (3 years, 2 months ago)
    
    OS-5548 Update platform's node-lockfd to 1.1.0

diff --git a/src/node-lockfd/README.md b/src/node-lockfd/README.md
index b976c016..3c7187ee 100644
--- a/src/node-lockfd/README.md
+++ b/src/node-lockfd/README.md
@@ -1,15 +1,28 @@
+
+<!--
+    Copyright 2016, Joyent, Inc.
+-->
+
 # node-lockfd
 
-A trivial wrapper around `fcntl(F_SETLK)` (or `F_SETLKW`).  Presently allows
-a synchronous or asynchronous call to get a whole-file, exclusive, advisory
-write lock on a file, or to block until one is possible.
+A trivial wrapper around [flock(3C)](https://illumos.org/man/3C/flock) and
+`fcntl(F_SETLKW)`. The provided interfaces presently allow a synchronous or
+asynchronous call to get a whole-file, exclusive, advisory write lock on a file,
+or to block until one is possible. The `flock()` wrappers additionally allow
+acquiring a shared lock.
 
 This module has been crafted specifically to work on SmartOS, and may not work
-anywhere else.  Please see [fcntl(2)](http://illumos.org/man/2/fcntl) for more
-details on the locking semantics.  In general, the lock will be released when
-either the file descriptor is closed, or the process exits.  The manual page
+anywhere else. The `flock` functions manipulate Open File Description (OFD)
+style advisory locks, while the `lockfd` family of functions manipulate
+POSIX-style advisory locks. Please see the `FILE LOCKING` section of
+[fcntl(2)](http://illumos.org/man/2/fcntl#file-locking) for more details on the
+locking semantics of each style. In general, the lock will be released when
+either the file descriptor is closed, or the process exits. The manual page
 contains information on exceptions to this behaviour.
 
+Note that `flock()` was added to libc in SmartOS in the 20150219 release, so
+building and running on older platforms will fail.
+
 ## Usage
 
 ### lockfd(fd, callback)
@@ -22,6 +35,17 @@ called.
 
 Synchronous version of `lockfd(fd)`.
 
+### flock(fd, op, callback)
+
+This will call [flock(3C)](http://illumos.org/man/3C/flock) and perform the
+specified operation, which is a bitwise inclusive OR of LOCK\_SH, LOCK\_EX,
+LOCK\_UN, and LOCK\_NB. These constants are exported with this module for
+convenience. Once the operation completes, the callback will be invoked.
+
+### flockSync(fd, op, callback)
+
+Synchronous version of `flock(fd, op)`.
+
 ## Examples
 
 ```javascript
@@ -43,6 +67,40 @@ mod_fs.closeSync(fd);
 process.exit(0);
 ```
 
+Using OFD-style locking:
+
+
+```javascript
+var mod_fs = require('fs');
+var mod_lockfd = require('lockfd');
+
+var lockfileA = mod_fs.openSync('/tmp/.lockfile', 'r+');
+var lockfileB = mod_fs.openSync('/tmp/.lockfile', 'r+');
+console.error('opened fds %d and %d', lockfileA, lockfileB);
+
+mod_lockfd.flock(lockfileA, mod_lockfd.LOCK_EX, function (err) {
+    if (err) {
+        throw err;
+    }
+
+    doSomeWork(function () {
+        mod_lockfd.flockSync(lockfileA, mod_lockfd.LOCK_UN);
+        mod_fs.closeSync(lockfileA);
+    });
+});
+
+mod_lockfd.flock(lockfileB, mod_lockfd.LOCK_EX, function (err) {
+    if (err) {
+        throw err;
+    }
+
+    doConflictingWork(function () {
+        mod_lockfd.flockSync(lockfileB, mod_lockfd.LOCK_UN);
+        mod_fs.closeSync(lockfileB);
+    });
+});
+```
+
 ## License
 
 MIT.
diff --git a/src/node-lockfd/lib/index.js b/src/node-lockfd/lib/index.js
index 5c76bb9d..de2d58b7 100644
--- a/src/node-lockfd/lib/index.js
+++ b/src/node-lockfd/lib/index.js
@@ -1,5 +1,9 @@
 /* vim: set syntax=javascript ts=8 sts=8 sw=8 noet: */
 
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
 var BINDING = require('./lockfd_binding');
 
 function
@@ -17,7 +21,7 @@ lockfd(fd, callback)
 	check_arg(1, 'fd', fd, 'number');
 	check_arg(2, 'callback', callback, 'function');
 
-	BINDING.lock_fd(fd, "write", false, function (ret, errmsg, errno) {
+	BINDING.lock_fd(fd, 'write', false, function (ret, errmsg, errno) {
 		if (ret === -1) {
 			var err = new Error('File Locking Error: ' + errmsg);
 			err.code = errno;
@@ -38,7 +42,7 @@ lockfdSync(fd)
 
 	check_arg(1, 'fd', fd, 'number');
 
-	BINDING.lock_fd(fd, "write", true, function (ret, errno, errmsg) {
+	BINDING.lock_fd(fd, 'write', true, function (ret, errno, errmsg) {
 		cb_fired = true;
 
 		if (ret === -1) {
@@ -57,7 +61,61 @@ lockfdSync(fd)
 	return (null);
 }
 
+function
+flock(fd, op, callback)
+{
+	check_arg(1, 'fd', fd, 'number');
+	check_arg(2, 'op', op, 'number');
+	check_arg(3, 'callback', callback, 'function');
+
+	BINDING.flock(fd, op, false, function (ret, errmsg, errno) {
+		if (ret === -1) {
+			var err = new Error('File Locking Error: ' + errmsg);
+			err.code = errno;
+
+			callback(err);
+			return;
+		}
+
+		callback(null);
+	});
+}
+
+function
+flockSync(fd, op)
+{
+	var cb_fired = false;
+	var err;
+
+	check_arg(1, 'fd', fd, 'number');
+	check_arg(2, 'op', op, 'number');
+
+	BINDING.flock(fd, op, true, function (ret, errmsg, errno) {
+		cb_fired = true;
+
+		if (ret === -1) {
+			err = new Error('File Locking Error: ' + errmsg);
+			err.code = errno;
+			return;
+		}
+	});
+
+	if (!cb_fired) {
+		throw (new Error('flockSync: CALLBACK NOT FIRED'));
+	} else if (err) {
+		throw (err);
+	}
+
+	return (null);
+}
+
 module.exports = {
+	LOCK_SH: 1,
+	LOCK_EX: 2,
+	LOCK_NB: 4,
+	LOCK_UN: 8,
+	flock: flock,
+	flockSync: flockSync,
 	lockfd: lockfd,
 	lockfdSync: lockfdSync
 };
diff --git a/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.defs b/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.defs
index f4c1356c..c7c33f77 100644
--- a/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.defs
+++ b/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.defs
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+# Copyright (c) 2014 Joyent, Inc.  All rights reserved.
 #
 
 #
@@ -13,7 +13,7 @@ CC =		gcc
 CXX =		g++
 CTFCONVERT =	/opt/onbld/bin/i386/ctfconvert
 CTFMERGE =	/opt/onbld/bin/i386/ctfmerge
-CTF_LABEL =	v8plus_0.2.0
+CTF_LABEL =	v8plus_0.3.0
 
 NODE_EXEC =	$(PREFIX_NODE)/bin/node
 
@@ -37,7 +37,7 @@ CXXFLAGS =	$(DEBUG_FLAGS) \
 		$(OPT_FLAGS) \
 		$(CXX_STDFLAGS)
 
-STD_DEFS =	-D_GNU_SOURCE
+v8plus_csup.o : STD_DEFS =	-D_GNU_SOURCE -D__EXTENSIONS__
 NODE_DEFS =	-DBUILDING_NODE_EXTENSION -DMODULE=$(MODULE)
 LF64_DEFS =	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
 PIC_DEFS =	-DPIC
diff --git a/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.targ b/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.targ
index 999bcf64..60500398 100644
--- a/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.targ
+++ b/src/node-lockfd/node_modules/v8plus/Makefile.v8plus.targ
@@ -1,14 +1,14 @@
 #
-# Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+# Copyright (c) 2014 Joyent, Inc.  All rights reserved.
 #
 
 all: $(MODULE_DIR)/$(MODULE).node
 
-$(ERRNO_C): $(GENERRNO_JS) $(ERRNO_JSON)
-	$(GENERRNO) -c -o $@ $(ERRNO_JSON)
+$(ERRNO_C): $(GENERRNO_JS) $(V8PLUS)/errno.json
+	$(GENERRNO) -c -o $@ $(V8PLUS)/errno.json
 
-$(ERRNO_H): $(GENERRNO_JS) $(ERRNO_JSON)
-	$(GENERRNO) -h -o $@ $(ERRNO_JSON)
+$(ERRNO_H): $(GENERRNO_JS) $(V8PLUS)/errno.json
+	$(GENERRNO) -h -o $@ $(V8PLUS)/errno.json
 
 $(OBJS): $(ERRNO_H)
 
diff --git a/src/node-lockfd/node_modules/v8plus/README.md b/src/node-lockfd/node_modules/v8plus/README.md
index 12cb65b0..959fa813 100644
--- a/src/node-lockfd/node_modules/v8plus/README.md
+++ b/src/node-lockfd/node_modules/v8plus/README.md
@@ -53,9 +53,6 @@ The overall outline for creating a v8+ module looks something like this:
 
 3. Create a skeleton makefile.  See below for details.
 
-4. Create a JSON file defining the error codes your module will use.  See
-Errors below.
-
 You should not (and need not) modify either of the delivered makefiles;
 override the definitions in Makefile.v8plus.defs in your makefile as
 appropriate.
@@ -102,8 +99,8 @@ things:
         include $(V8PLUS)/Makefile.v8plus.defs
 
 3. Variable assignments specific to your module.  In particular, you must
-   define `SRCS`, `MODULE`, and `ERRNO_JSON`.  Additional customisation is
-   optional.
+   define `SRCS` and `MODULE`  Note that `ERRNO_JSON` is no longer required
+   nor used in v8plus 0.3 and later.  Additional customisation is optional.
 
 4. The exact line:
 
@@ -208,9 +205,9 @@ that you are actually an object factory; the C++ function associated with
 the JavaScript constructor is called for you.  Your encoded arguments are in
 `ap`.  Allocate and populate a C object, stuff it into `*opp`, and return
 `v8plus_void()`.  If you need to throw an exception you can do so by
-returning `v8plus_error()` or one of its wrappers, or by setting
-`_v8plus_errno` using one of those functions and then returning an nvlist
-with an `err` member representing a decorated exception.
+calling `v8plus_throw_exception()` or any of its wrappers.  As of v8plus
+0.3, you may no longer return an nvlist with an `err` member to throw an
+exception, and the `_v8plus_errno` global variable is no longer available.
 
 ### void v8plus_c_dtor_f(void *op)
 
@@ -306,8 +303,8 @@ In most cases, the behaviour is straightforward: the value pointer parameter
 provides a location into which the C value of the specified argument should
 be stored.  If the entire argument list matches the template, each
 argument's C value is stored in its respective location.  If not, no values
-are stored, in the return value locations, `_v8plus_errno` is set
-appropriately, and -1 is returned.
+are stored, in the return value locations, an exception is set pending, and
+-1 is returned.
 
 Three data types warrant further explanation: an argument of type
 `V8PLUS_TYPE_INVALID` is any argument that may or may not match one of the
@@ -344,7 +341,7 @@ A simple example:
 This function simply returns the v8+ data type corresponding to the
 name/value pair `pp`.  If the value's type does not match the v8+ encoding
 rules, `V8PLUS_TYPE_INVALID` is returned.  This function cannot fail and
-does not modify `_v8plus_errno`.
+does not set pending any exceptions.
 
 ### Returning Values
 
@@ -356,11 +353,10 @@ as their primitive types, not objects.  If you need to return something
 containing these object types, you cannot use v8+.  Other data types
 cannot be represented.  If you need to return them, you cannot use v8+.
 
-The nvlist being returned must have one of two members: "res", an nvpair
-containing the result of the call to be returned, or "err", an nvlist
-containing members to be added to an exception.  You may return a value of
-any decodable type, and likewise may decorate an exception with properties
-of any decodable type.
+The nvlist being returned must have a single member named: "res", an nvpair
+containing the result of the call to be returned.  The use of "err" to
+decorate an exception is no longer supported as of v8plus 0.3.  You may
+return a value of any decodable type.
 
 For convenience, you may return v8plus_void() instead of an nvlist,
 which indicates successful execution of a function that returns nothing.
@@ -370,9 +366,9 @@ JavaScript objects to return.
 
 ### nvlist_t *v8plus_void(void)
 
-This function clears `_v8plus_errno` and returns NULL.  This is used to
-indicate to internal v8+ code that the method or function should not return
-a value.
+This function clears any pending exception and returns NULL.  This is used
+to indicate to internal v8+ code that the method or function should not
+return a value.
 
 ### nvlist_t *v8plus_obj(v8plus_type_t t, ...)
 
@@ -412,8 +408,8 @@ values:
 
 A simple example, in which we return a JavaScript object with two members,
 one number and one embedded object with a 64-bit integer property.  Note
-that if this function fails, we will return `NULL` with `_v8plus_errno` set
-appropriately, so v8+ will generate and throw an appropriate exception.
+that if this function fails, we will return `NULL` with an exception
+pending.
 
 	int x;
 	const char *s;
@@ -448,87 +444,153 @@ on the fly from your argument list.  The interpretation of the argument list
 is the same as for `v8plus_obj()`, and the two functions are implemented
 using the same logic.
 
-### Exceptions
+## Exceptions and Errors
+
+Prior to v8plus 0.3.0, the v8plus_errno_t enumerated type was controlled by
+a consumer-supplied JSON file, allowing the consumer to specify the set of
+error values.  In v8plus 0.3.0 and newer, this type is fixed and contains
+only a small set of basic errors that can be used with the `v8plus_error()`
+routine for compatibility with previous versions.  In v8plus 0.3.0 and
+later, consumers should explicitly throw exceptions instead.
+
+In v8plus 0.3.0 and later, the `_v8plus_errno` global no longer exists.  If
+your code examined this variable, there are two alternatives:
+
+- If you were comparing against V8PLUSERR_NOERROR, instead use
+  `v8plus_exception_pending() to determine whether a previously invoked
+  function failed.
+- If you wish to inspect the previous error state,
+  `v8plus_pending_exception()` will provide an nvlist-encoded representation
+  of the pending exception object.
+
+A survey of consumers indicated that custom error codes, `_v8plus_errno`,
+and nontrivial uses of `_v8plus_error()` did not exist in consumers;
+therefore this functionality has been removed.
+
+All exceptions are generated and made pending by `v8plus_throw_exception()`
+or its wrappers, identified below.  Only one exception may be pending at one
+time, and a call to `v8plus_throw_exception()` or its wrappers with an
+exception already pending has no effect.  Functions are provided for
+clearing any pending exceptions, testing for the existence of a pending
+exception, and obtaining (to inspect or modify) the current pending
+exception; see API details below.
+
+A pending exception will be ignored and will not be thrown if any of the
+following occurs prior to your C function (method, static method, or
+constructor) returning:
+
+- `v8plus_clear_exception()` is invoked, or
+- You return `v8plus_void()`, or
+- Your method or static method routine returns non-NULL, or
+- Your constructor sets its object pointer to a non-NULL value
+
+It is programmer error for a constructor to set its object pointer to NULL
+(or to not set it at all) and return without an exception pending.
+
+Because a common source of exceptions is out-of-memory conditions, the space
+used by exceptions is obtained statically and is limited in size.  This
+allows for exceptions to be thrown into V8 reliably, with enough information
+to debug the original failure even if that failure was, or was caused by, an
+out of memory condition.  V8 may or may not provide a similar mechanism for
+ensuring that the C++ representation of exceptions is reliable.
+
+Exceptions may be raised in any context; however, raising an exception in a
+context other than the V8 event thread will not by itself cause any
+JavaScript exception to be thrown; it is the consumer's responsibility to
+provide for an exception to be set pending in the event thread if it is to
+be made visible from JavaScript.  Functions used to inspect or alter the
+state of the pending exception, if any, also work in any context.
 
-If you are unable to create an nvlist to hold exception data, or you want a
-generic exception to be thrown, return the value returned by v8plus_error().
-In this case, the error code will be translated to an exception type and the
-message string will be used as the message member of the exception.  Other
-members will not be present in the exception unless you also return an
-nvlist containing an 'err' member (or, from a constructor, any nvlist) Only
-basic v8-provided exception types can be thrown; if your addon needs to
-throw some other kind of exception, you will need to either use v8 directly
-or catch and re-throw from a JavaScript wrapper.
+### nvlist_t *v8plus_error(v8plus_errno_t e, const char *fmt, ...)
 
-## Errors
+This function generates and makes pending a default exception based on the
+value of `e` and a message based on the formatted string `fmt` using the
+argument list that follows.  The format string and arguments are interpreted
+as by `vsnprintf(3c)`.  NULL is returned, suitable for returning directly
+from a C function that provides a method if no exception decoration is
+required.
 
-The v8plus_errno_t enumerated type and a family of utility functions are
-automatically generated by generrno.js from a simple JSON file.  The schema
-of this file is as follows:
+If `fmt` is NULL, a generic default message is used.
 
-	{
-		"error_base": <string>,
-		"errors": [
-		{
-			"code": <string>,
-			"msg": <string>,
-			"exception": <string>
-		},
-		...  ]
-	}
+This function is a wrapper for `v8plus_throw_exception()`.
 
-For each entry in the errors array, an identifier V8PLUSERR_code will be
-added to v8plus_errno_t.  By convention, code should be all upper case.  The
-default error message (present in JavaScript exceptions if a more specific
-error message is not provided to v8plus_error()) is given by the msg
-property.  The exception property must be one of "Error", "TypeError",
-"ReferenceError", "RangeError", or "SyntaxError"; i.e., the standard
-exception types available in v8.  This is the type of exception that will be
-generated and thrown when a C function returns NULL with this error code
-set.  In addition, the built-in error codes V8PLUSERR_NOMEM,
-V8PLUSERR_YOUSUCK, and V8PLUSERR_UNKNOWN are available for your use,
-indicating an out of memory condition, programmer error (e.g., failure of
-something you would assert in JavaScript), and an error code that cannot be
-translated, respectively.
+### nvlist_t *v8plus_nverr(int err, const char *propname)
 
-Set the make variable ERRNO_JSON to the name of this file.
+This function generates and makes pending an exception based on the system
+error code `err` and sets the error message to a non-localised explanation
+of the problem.  The string `propname`, if non-NULL, is indicated in the
+message as the name of the nvlist property being manipulated when the error
+occurred.  NULL is returned.
 
-To set the value of `_v8plus_errno`, use one of the following functions.  It
-is a bug to manipulate this variable directly.
+This function is a wrapper for `v8plus_throw_exception()`.
 
-### nvlist_t *v8plus_verror(v8plus_errno_t e, const char *fmt, va_list)
+### nvlist_t *v8plus_syserr(int err, const char *fmt, ...)
 
-This is the varargs analogue to `v8plus_error()` and has identical
-semantics.  Use this if you want to wrap manipulation of the v8+ error state
-within your own varargs functions.
+Analogous to `v8plus_error()`, this function instead generates and sets
+pending an exception derived from the system error code `err`.  Not all
+error codes can be mapped; those that are not known are mapped onto an
+unknown error string.  The generated exception will contain additional
+properties similar to those provided by node.js's `ErrnoException()`
+routine.  See also `v8plus_throw_errno_exception()`.
 
-### nvlist_t *v8plus_error(v8plus_errno_t e, const char *fmt, ...)
+This function is a wrapper for `v8plus_throw_exception()`.
 
-This function sets the value of `_v8plus_errno` to `e` and sets the
-associated error message string to the formatted string `fmt` using the
-argument list that follows.  The format string and arguments are interpreted
-as by `vsnprintf(3c)`.  NULL is returned, suitable for returning directly
-from a C function that provides a method if no exception decoration is
-required.
+### nvlist_t *v8plus_throw_exception(const char *type, const char *msg, v8plus_type_t t, ...)
+
+Generate and set pending an exception whose JavaScript type is `type`, with
+message `msg` (or the empty string, if `msg` is NULL), and optionally
+additional properties as specified by a series type, name, value triples.
+These triples have the same syntax as the arguments to `v8plus_obj()` and
+are likewise terminated by V8PLUS_TYPE_NONE.
+
+The generated JavaScript exception will be thrown upon return from the
+current constructor or method, unless `v8plus_clear_exception()` is invoked
+first, or `v8plus_void()` is returned.  The exception may be obtained via
+`v8plus_pending_exception()` and its presence or absence tested via
+`v8plus_exception_pending()`.
+
+### nvlist_t *v8plus_throw_errno_exception(int err, const char *syscall, const char *msg, const char *path, v8plus_type_t t, ...)
+
+Generate and set pending an exception with type `Error` and message `msg`
+(if `msg` is NULL, the message will be automatically generated from your
+system's `strerror()` value for this error number).  The exception will
+further be decorated with properties indicating the relevant system call and
+path, if the `syscall` and `path` arguments, respectively, are non-NULL, and
+any additional properties specified as in `v8plus_throw_exception()`.
+
+This function is a wrapper for `v8plus_throw_exception()`.
+
+### boolean_t v8plus_exception_pending(void)
+
+This function returns B_TRUE if and only if an exception is pending.
+
+### nvlist_t *v8plus_pending_exception(void)
+
+This function returns a pointer to the nvlist-encoded pending exception, if
+any exists; NULL, otherwise.  This object may be inspected and properties
+added to or removed from it.
+
+### void v8plus_clear_exception(void)
 
-If `fmt` is NULL, a generic default message is used; for consumer-defined
-error codes, that message is the one provided in `errno.json`.
+Clear the pending exception, if any.
 
-### nvlist_t *v8plus_nverr(int errno, const char *propname)
+### void v8plus_rethrow_pending_exception(void)
 
-This function sets the value of `_v8plus_errno` to a value mapped from the
-system error code `errno` and sets the error message to a non-localised
-explanation of the problem.  The string `propname`, if non-NULL, is
-indicated in the message as the name of the nvlist property being
-manipulated when the error occurred.  NULL is returned.
+Immediately throw the pending exception.  This is appropriate only in
+the context of an asynchronous callback, in which there is no return
+value; in all other cases, return the exception as the `err` member of
+the function's return value.  Note that this is slightly different from
+`node::FatalException()` in that it is still possible for a JavaScript
+caller to catch and handle it.  If it is absolutely essential that the
+process terminate immediately, use `v8plus_panic()` instead.
 
-### nvlist_t *v8plus_syserr(int errno, const char *fmt, ...)
+The main purpose of this facility is to allow re-throwing an exception
+generated by a JavaScript callback invoked from an asynchronous
+completion routine.  The completion routine has no way to return a
+value, so this is the only way to propagate the exception out of the
+native completion routine.
 
-Analogous to `v8plus_error()`, this function instead sets the error code to
-a mapped value derived from the system error code `errno`.  Not all error
-codes can be mapped; those that are not known are mapped onto
-`V8PLUSERR_UNKNOWN`.  This function's semantics are otherwise identical to
-those of `v8plus_error()`.
+This function may be called only on the main event loop thread.
 
 ### void v8plus_panic(const char *fmt, ...) __NORETURN
 
diff --git a/src/node-lockfd/node_modules/v8plus/errno.json b/src/node-lockfd/node_modules/v8plus/errno.json
new file mode 100644
index 00000000..98dd2007
--- /dev/null
+++ b/src/node-lockfd/node_modules/v8plus/errno.json
@@ -0,0 +1,32 @@
+[
+	{
+		"code": "NOMEM",
+		"msg": "out of memory",
+		"exception": "Error"
+	},
+	{
+		"code": "YOUSUCK",
+		"msg": "programmer error",
+		"exception": "Error"
+	},
+	{
+		"code": "UNKNOWN",
+		"msg": "unknown error",
+		"exception": "Error"
+	},
+	{
+		"code": "MISSINGARG",
+		"msg": "missing argument is required",
+		"exception": "TypeError"
+	},
+	{
+		"code": "BADARG",
+		"msg": "argument is of incorrect type",
+		"exception": "TypeError"
+	},
+	{
+		"code": "EXTRAARG",
+		"msg": "superfluous argument(s) detected",
+		"exception": "TypeError"
+	}
+]
diff --git a/src/node-lockfd/node_modules/v8plus/examples/errno.json b/src/node-lockfd/node_modules/v8plus/examples/errno.json
deleted file mode 100644
index 395d59e3..00000000
--- a/src/node-lockfd/node_modules/v8plus/examples/errno.json
+++ /dev/null
@@ -1,19 +0,0 @@
-{
-	"error_base": "0x2000",
-	"errors": [
-	{
-		"code": "IMPRECISE",
-		"msg": "numerical value lacks adequate precision",
-		"exception": "TypeError"
-	},
-	{
-		"code": "RANGE",
-		"msg": "value out of range",
-		"exception": "RangeError"
-	},
-	{
-		"code": "MALFORMED",
-		"msg": "value is malformed or unparseable",
-		"exception": "TypeError"
-	} ]
-}
diff --git a/src/node-lockfd/node_modules/v8plus/examples/example.c b/src/node-lockfd/node_modules/v8plus/examples/example.c
index 299cc74d..3a4df5c4 100644
--- a/src/node-lockfd/node_modules/v8plus/examples/example.c
+++ b/src/node-lockfd/node_modules/v8plus/examples/example.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/ccompile.h>
@@ -21,8 +21,10 @@ example_set_impl(example_t *ep, nvpair_t *pp)
 	case V8PLUS_TYPE_NUMBER:
 		(void) nvpair_value_double(pp, &dv);
 		if (dv > (1ULL << DBL_MANT_DIG) - 1) {
-			return (v8plus_error(V8PLUSERR_IMPRECISE,
-			    "large number lacks integer precision"));
+			return (v8plus_throw_exception("TypeError",
+			    "large number lacks integer precision",
+			    V8PLUS_TYPE_NUMBER, "approx_value", dv,
+			    V8PLUS_TYPE_NONE));
 		}
 		ep->e_val = (uint64_t)dv;
 		break;
@@ -31,12 +33,16 @@ example_set_impl(example_t *ep, nvpair_t *pp)
 		errno = 0;
 		v = (uint64_t)strtoull(sv, (char **)&ev, 0);
 		if (errno == ERANGE) {
-			return (v8plus_error(V8PLUSERR_RANGE,
-			    "value '%s' is out of range", sv));
+			return (v8plus_throw_exception("RangeError",
+			    "value is out of range",
+			    V8PLUS_TYPE_STRING, "value", sv,
+			    V8PLUS_TYPE_NONE));
 		}
 		if (ev != NULL && *ev != '\0') {
-			return (v8plus_error(V8PLUSERR_MALFORMED,
-			    "value '%s' is malformed", sv));
+			return (v8plus_throw_exception("TypeError",
+			    "value is malformed",
+			    V8PLUS_TYPE_STRING, "value", sv,
+			    V8PLUS_TYPE_NONE));
 		}
 		ep->e_val = v;
 		break;
@@ -66,7 +72,7 @@ example_ctor(const nvlist_t *ap, void **epp)
 		return (v8plus_error(V8PLUSERR_NOMEM, NULL));
 
 	(void) example_set_impl(ep, pp);
-	if (_v8plus_errno != V8PLUSERR_NOERROR) {
+	if (v8plus_exception_pending()) {
 		free(ep);
 		return (NULL);
 	}
@@ -94,7 +100,7 @@ example_set(void *op, const nvlist_t *ap)
 		return (NULL);
 
 	(void) example_set_impl(ep, pp);
-	if (_v8plus_errno != V8PLUSERR_NOERROR)
+	if (v8plus_exception_pending())
 		return (NULL);
 
 	return (v8plus_void());
@@ -114,7 +120,7 @@ example_add(void *op, const nvlist_t *ap)
 		return (NULL);
 
 	(void) example_set_impl(&ae, pp);
-	if (_v8plus_errno != V8PLUSERR_NOERROR)
+	if (v8plus_exception_pending())
 		return (NULL);
 
 	ep->e_val += ae.e_val;
@@ -143,11 +149,11 @@ example_static_add(const nvlist_t *ap)
 		return (NULL);
 
 	(void) example_set_impl(&ae0, pp0);
-	if (_v8plus_errno != V8PLUSERR_NOERROR)
+	if (v8plus_exception_pending())
 		return (NULL);
 
 	(void) example_set_impl(&ae1, pp1);
-	if (_v8plus_errno != V8PLUSERR_NOERROR)
+	if (v8plus_exception_pending())
 		return (NULL);
 
 	rv = ae0.e_val + ae1.e_val;
@@ -169,7 +175,7 @@ example_multiply(void *op, const nvlist_t *ap)
 		return (NULL);
 
 	(void) example_set_impl(&ae, pp);
-	if (_v8plus_errno != V8PLUSERR_NOERROR)
+	if (v8plus_exception_pending())
 		return (NULL);
 
 	ep->e_val *= ae.e_val;
@@ -232,7 +238,7 @@ example_multiplyAsync(void *op, const nvlist_t *ap)
 		return (v8plus_error(V8PLUSERR_NOMEM, "no memory for context"));
 
 	(void) example_set_impl(&cp->amc_operand, pp);
-	if (_v8plus_errno != V8PLUSERR_NOERROR) {
+	if (v8plus_exception_pending()) {
 		free(cp);
 		return (NULL);
 	}
@@ -249,6 +255,7 @@ static nvlist_t *
 example_toString(void *op, const nvlist_t *ap)
 {
 	example_t *ep = op;
+	nvlist_t *lp;
 	nvpair_t *pp;
 
 	/*
@@ -257,13 +264,13 @@ example_toString(void *op, const nvlist_t *ap)
 	if (v8plus_args(ap, 0,
 	    V8PLUS_TYPE_ANY, &pp, V8PLUS_TYPE_NONE) == 0) {
 		(void) v8plus_error(V8PLUSERR_EXTRAARG, NULL);
-		return (v8plus_obj(
-		    V8PLUS_TYPE_INL_OBJECT, "err",
-			V8PLUS_TYPE_NUMBER, "example_argument", (double)0,
-			V8PLUS_TYPE_NUMBER, "example_type",
+		lp = v8plus_pending_exception();
+		v8plus_obj_setprops(lp,
+		    V8PLUS_TYPE_NUMBER, "example_argument", (double)0,
+		    V8PLUS_TYPE_NUMBER, "example_type",
 			    (double)v8plus_typeof(pp),
-			V8PLUS_TYPE_NONE,
-		    V8PLUS_TYPE_NONE));
+		    V8PLUS_TYPE_NONE);
+		return (NULL);
 	}
 
 	return (v8plus_obj(
@@ -272,8 +279,18 @@ example_toString(void *op, const nvlist_t *ap)
 }
 
 static nvlist_t *
-example_static_object(const nvlist_t *ap __UNUSED)
+example_static_object(const nvlist_t *ap)
 {
+	nvpair_t *pp;
+
+	if (v8plus_args(ap, 0,
+	    V8PLUS_TYPE_ANY, &pp, V8PLUS_TYPE_NONE) == 0) {
+		return (v8plus_throw_errno_exception(ENOENT, "open",
+		    NULL, "/no/such/file",
+		    V8PLUS_TYPE_STRING, "relevance", "example",
+		    V8PLUS_TYPE_NONE));
+	}
+
 	return (v8plus_obj(
 	    V8PLUS_TYPE_INL_OBJECT, "res",
 		V8PLUS_TYPE_NUMBER, "fred", (double)555.5,
@@ -290,6 +307,102 @@ example_static_object(const nvlist_t *ap __UNUSED)
 	    V8PLUS_TYPE_NONE));
 }
 
+typedef struct static_async_multiply_ctx {
+	example_t samc_operand0;
+	example_t samc_operand1;
+	uint64_t samc_result;
+	v8plus_jsfunc_t samc_cb;
+} static_async_multiply_ctx_t;
+
+static void *
+static_async_multiply_worker(void *op __UNUSED, void *ctx)
+{
+	static_async_multiply_ctx_t *cp = ctx;
+	example_t *ep = &cp->samc_operand0;
+	example_t *ap = &cp->samc_operand1;
+
+	cp->samc_result = ep->e_val * ap->e_val;
+
+	return (NULL);
+}
+
+static void
+static_async_multiply_done(void *op __UNUSED, void *ctx, void *res __UNUSED)
+{
+	static_async_multiply_ctx_t *cp = ctx;
+	nvlist_t *rp;
+	nvlist_t *ap;
+
+	ap = v8plus_obj(
+	    V8PLUS_TYPE_STRNUMBER64, "0", cp->samc_result,
+	    V8PLUS_TYPE_NONE);
+
+	if (ap != NULL) {
+		rp = v8plus_call(cp->samc_cb, ap);
+		nvlist_free(ap);
+		nvlist_free(rp);
+	}
+
+	v8plus_jsfunc_rele(cp->samc_cb);
+	free(cp);
+}
+
+static nvlist_t *
+example_static_multiplyAsync(const nvlist_t *ap)
+{
+	nvpair_t *pp0, *pp1;
+	v8plus_jsfunc_t cb;
+	static_async_multiply_ctx_t *cp;
+
+	if (v8plus_args(ap, V8PLUS_ARG_F_NOEXTRA,
+	    V8PLUS_TYPE_ANY, &pp0,
+	    V8PLUS_TYPE_ANY, &pp1,
+	    V8PLUS_TYPE_JSFUNC, &cb,
+	    V8PLUS_TYPE_NONE) != 0)
+		return (NULL);
+
+	if ((cp = malloc(sizeof (static_async_multiply_ctx_t))) == NULL)
+		return (v8plus_error(V8PLUSERR_NOMEM, "no memory for context"));
+
+	(void) example_set_impl(&cp->samc_operand0, pp0);
+	if (v8plus_exception_pending()) {
+		free(cp);
+		return (NULL);
+	}
+	(void) example_set_impl(&cp->samc_operand1, pp1);
+	if (v8plus_exception_pending()) {
+		free(cp);
+		return (NULL);
+	}
+
+	v8plus_jsfunc_hold(cb);
+	cp->samc_cb = cb;
+
+	v8plus_defer(NULL, cp, static_async_multiply_worker,
+	    static_async_multiply_done);
+
+	return (v8plus_void());
+}
+
+static nvlist_t *
+example_static_exception(const nvlist_t *ap)
+{
+	v8plus_jsfunc_t cb;
+	nvlist_t *lp;
+
+	(void) nvlist_alloc(&lp, NV_UNIQUE_NAME, 0);
+
+	if (v8plus_args(ap, 0,
+	    V8PLUS_TYPE_JSFUNC, &cb,
+	    V8PLUS_TYPE_NONE) != 0)
+		return (NULL);
+
+	(void) v8plus_call(cb, lp);
+	v8plus_rethrow_pending_exception();
+
+	return (NULL);
+}
+
 /*
  * v8+ boilerplate
  */
@@ -330,6 +443,14 @@ const v8plus_static_descr_t v8plus_static_methods[] = {
 	{
 		sd_name: "static_object",
 		sd_c_func: example_static_object
+	},
+	{
+		sd_name: "static_multiplyAsync",
+		sd_c_func: example_static_multiplyAsync
+	},
+	{
+		sd_name: "static_exception",
+		sd_c_func: example_static_exception
 	}
 };
 const uint_t v8plus_static_method_count =
diff --git a/src/node-lockfd/node_modules/v8plus/examples/test.js b/src/node-lockfd/node_modules/v8plus/examples/test.js
index 0c08ebb1..1e8ccb45 100644
--- a/src/node-lockfd/node_modules/v8plus/examples/test.js
+++ b/src/node-lockfd/node_modules/v8plus/examples/test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 /*
@@ -16,6 +16,13 @@ var EventEmitter = require('events').EventEmitter;
 var e = example.create();
 var f = example.create('8000000000');
 
+try {
+	example.static_object('throw!');
+} catch (e) {
+	console.log('got exception: ' + e.name + ' (' + e.message + ')');
+	console.log(util.inspect(e, false, null));
+}
+
 console.log('e = ' + e.toString());
 console.log('f = ' + f.toString());
 
@@ -26,6 +33,7 @@ try {
 	e.set(0x1111111111111111);
 } catch (e) {
 	console.log('got exception: ' + e.name + ' (' + e.message + ')');
+	console.log(util.inspect(e, false, null));
 }
 
 e.set('0x1111111111111111');
@@ -52,6 +60,10 @@ e.multiplyAsync(100, function () {
 	console.log('background e = ' + e.toString());
 });
 
+example.static_multiplyAsync(2345, 6789, function (r) {
+	console.log('background multiply 2345 * 6789 = ' + r.toString());
+});
+
 function
 Wrapper(ex)
 {
@@ -80,3 +92,7 @@ console.log('1000000000000000000 + 3333333333333333333 = ' +
     example.static_add('1000000000000000000', '3333333333333333333'));
 
 console.log(example.static_object());
+
+example.static_exception(function () {
+	throw new Error('test.js exception');
+});
diff --git a/src/node-lockfd/node_modules/v8plus/generrno.js b/src/node-lockfd/node_modules/v8plus/generrno.js
index 5470a0b2..945aebbf 100644
--- a/src/node-lockfd/node_modules/v8plus/generrno.js
+++ b/src/node-lockfd/node_modules/v8plus/generrno.js
@@ -1,7 +1,7 @@
 #! /usr/bin/env node
 
 /*
- * Copyright (c) 2012 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 var util = require('util');
@@ -23,7 +23,7 @@ var guard_prologue =
     '#endif\t/* __cplusplus */\n';
 
 var decl_prologue =
-    '#define\tV8PLUS_ERRNO_BASE\t%s\n\n' +
+    '#define\tV8PLUS_ERRNO_BASE\t0x10000\n\n' +
     'typedef enum _v8plus_errno {\n' +
     '\tV8PLUSERR_NOERROR = 0,\n' +
     '\tV8PLUSERR_%s = V8PLUS_ERRNO_BASE + 1,\n';
@@ -63,44 +63,6 @@ var func_epilogue =
     '\t}\n' +
     '}\n';
 
-var BUILTIN_ERRORS = [
-	{
-		code: 'NOMEM',
-		msg: 'out of memory',
-		exception: 'Error'
-	},
-	{
-		code: 'YOUSUCK',
-		msg: 'programmer error',
-		exception: 'Error'
-	},
-	{
-		code: 'UNKNOWN',
-		msg: 'unknown error',
-		exception: 'Error'
-	},
-	{
-		code: 'MISSINGARG',
-		msg: 'missing argument is required',
-		exception: 'TypeError'
-	},
-	{
-		code: 'BADARG',
-		msg: 'argument is of incorrect type',
-		exception: 'TypeError'
-	},
-	{
-		code: 'EXTRAARG',
-		msg: 'superfluous argument(s) detected',
-		exception: 'TypeError'
-	},
-	{
-		code: 'BADF',
-		msg: 'bad file descriptor',
-		exception: 'Error'
-	}
-];
-
 function
 usage()
 {
@@ -149,10 +111,6 @@ parse_arguments(argv)
 	defs = fs.readFileSync(obj.input);
 	obj.defs = JSON.parse(defs);
 
-	BUILTIN_ERRORS.forEach(function _prepend_err(e) {
-		obj.defs.errors.unshift(e);
-	});
-
 	return (obj);
 }
 
@@ -174,21 +132,21 @@ write_c(defs, output)
 	out += include;
 
 	out += util.format(func_prologue, 'strerror');
-	defs.errors.forEach(function _append_str(e) {
+	defs.forEach(function _append_str(e) {
 		out += util.format(generic_case, e.code, e.msg);
 	});
 	out += util.format(func_epilogue, 'unknown v8+ error code');
 	out += '\n';
 
 	out += util.format(func_prologue, 'errname');
-	defs.errors.forEach(function _append_name(e) {
+	defs.forEach(function _append_name(e) {
 		out += util.format(errname_case, e.code, e.code);
 	});
 	out += util.format(func_epilogue, 'unknown v8+ error code');
 	out += '\n';
 
 	out += util.format(func_prologue, 'excptype');
-	defs.errors.forEach(function _append_excp(e) {
+	defs.forEach(function _append_excp(e) {
 		out += util.format(generic_case, e.code, e.exception);
 	});
 	out += util.format(func_epilogue, 'Error');
@@ -203,8 +161,8 @@ write_header(defs, output)
 
 	out += prologue;
 	out += guard_prologue;
-	out += util.format(decl_prologue, defs.error_base, defs.errors[0].code);
-	defs.errors.forEach(function _spew_decl(e, i) {
+	out += util.format(decl_prologue, defs[0].code);
+	defs.forEach(function _spew_decl(e, i) {
 		if (i > 0)
 			out += util.format(decl_one, e.code);
 	});
diff --git a/src/node-lockfd/node_modules/v8plus/node_modules/posix-getopt/package.json b/src/node-lockfd/node_modules/v8plus/node_modules/posix-getopt/package.json
index 20f9b32b..4fb5fc25 100644
--- a/src/node-lockfd/node_modules/v8plus/node_modules/posix-getopt/package.json
+++ b/src/node-lockfd/node_modules/v8plus/node_modules/posix-getopt/package.json
@@ -10,12 +10,20 @@
     "node": "*"
   },
   "main": "./lib/getopt",
-  "readme": "\nnode-getopt\n==============\n\nOverview\n--------\n\nnode-getopt is a Node.js module providing an interface to the POSIX-defined\ngetopt() function, a general-purpose command line parser that follows the POSIX\nguidelines for command-line utilities.  Using these guidelines encourages\ncommon conventions among applications, including use of:\n\n    o short option names (e.g., \"-r\")\n    o options with arguments (e.g., \"-f filename or -ffilename\")\n    o chaining short option names when options have no arguments (e.g., \"-ra\")\n\nThis implementation mirrors the Solaris getopt() implementation and supports\nlong option names (e.g., \"--recurse\"), potentially with values specified using\n\"=\" (e.g., \"--file=/path/to/file\").\n\nUnlike other option parsers available for Node.js, the POSIX getopt() interface\nsupports using the same option multiple times (e.g., \"-vvv\", commonly used to\nindicate level of verbosity).\n\nFor further reference on the relevant POSIX standards, see the following:\n\n    http://pubs.opengroup.org/onlinepubs/009695399/functions/getopt.html\n    http://pubs.opengroup.org/onlinepubs/009695399/utilities/getopts.html\n\nThe Utility Syntax Guidelines are described here:\n\n    http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html\n\n\nStatus\n------\n\nThis module is considered complete except that\n\n    o test coverage is pretty minimal\n    o npm install has not been tested\n    o the source is not javascriptlint-clean\n\nThere are no known bugs, but the module has not been extensively tested.\n\n\nPlatforms\n---------\n\nThis module should work on all platforms that support node.js.  The module is\ntested on MacOS X 10.6.5 and OpenSolaris based on build 111b and Illumos build\n147.\n\n\nInstallation\n------------\n\nAs an npm package, node-getopt is installed in the usual way:\n\n      % npm install posix-getopt\n\n\nAPI\n---\n\n### `new getopt.BasicParser(optstring, argv)`\n\nInstantiates a new object for parsing the specified arguments using the\nspecified option string.  This interface is closest to the traditional getopt()\nC function.  Callers first instantiate a BasicParser and then invoke the\ngetopt() method to iterate the options as they would in C.  (This interface\nallows the same option to be specified multiple times.)  The first two arguments\nin \"argv\" are ignored, since they generally denote the path to the node\nexecutable and the script being run, so options start with the third element.\n\nThe option string consists of an optional leading \":\" (see below) followed by a\nsequence of option-specifiers.  Each option-specifier consists of a single\ncharacter denoting the short option name, optionally followed by a colon if the\noption takes an argument and/or a sequence of strings in parentheses\nrepresenting long-option aliases for the option name.\n\nExample option strings:\n        ':r'            Command takes one option with no args: -r\n        ':ra'           Command takes two option with no args: -r and -a\n        ':raf:'         Command takes two option with no args: -r and -a\n                        and a single option that takes an arg: -f\n        ':f:(file)'     Command takes a single option with an argument: -f\n                        -f can also be specified as --file\n\nThe presence of a leading colon in the option string determines the behavior\nwhen an argument is not specified for an option which takes an argument.  See\ngetopt() below.  Additionally, if no colon is specified, then error messages are\nprinted to stderr when invalid options, options with missing arguments, or\noptions with unexpected arguments are encountered.\n\n\n### `parser.optind()`\n\nReturns the next argv-argument to be parsed.  When options are specified as\nseparate \"argv\" arguments, this value is incremented with each option parsed.\nWhen multiple options are specified in the same argv-argument, the returned\nvalue is unspecified.  This matches the variable \"OPTIND\" from the POSIX\nstandard, but is read-only.  (If you want to reset OPTIND, you must create a new\nBasicParser instance.)  This is most useful after parsing has finished to\nexamine the non-option arguments.\n\nThis value starts at \"2\" as described under \"Departures from POSIX\" below.\n\n\n### `parser.getopt()`\n\nReturns the next argument specified in \"argv\" (the object's constructor\nargument).  The returned value is either undefined or an object with at least\nthe following members:\n\n\toption\t\tsingle-character option name\n\nThe following members may also be present:\n\n\toptarg\t\targument value, if any\n\n\toptopt\t\toption character that caused the error, if any\n\n\terror\t\tif true, this object represents an error\n\nThis function scans \"argv\" starting at the current value of \"optind\" and returns\nan object describing the next argument based on the following cases:\n\n    o If the end of command line arguments is reached, an undefined value is\n      returned.  The end of arguments is signified by a single '-' argument, a\n      single '--' argument, an argument that's neither an option nor a previous\n      option's argument, the end of argv, or an error.\n\n    o If an unrecognized command line option is found (i.e. an option character\n      not defined in \"optstring\"), the returned object's \"option\" member\n      is just \"?\".  \"optopt\" is set to the unrecognized option letter.  \"error\"\n      is set to a true value.\n\n    o If a known command line option is found and the option takes no arguments\n      then the returned object's \"option\" member is the option's short name\n      (i.e.  the single character specifier in \"optstring\").\n      \n    o If a known command line option is found and that option takes an argument\n      and the argument is also found, then the returned object's \"option\"\n      member is the option's short name and the \"optarg\" member contains the\n      argument's value.\n\n    o If a known command line option is found and that option takes an argument\n      but the argument is not found, then the returned object's \"option\" member\n      is \"?\" unless the first character of \"optstring\" was a colon, in which\n      case the \"option\" member is set to \":\".  Either way, the \"optopt\" member\n      is set to the option character that caused the error and \"error\" is set to\n      a true value.\n\n\nDepartures from POSIX\n--------\n\n    o Global state in the C implementation (e.g., optind, optarg, and optopt) is\n      encapsulated in the BasicParser object.  optind is available as a method\n      call on the parser object.  optarg and optopt are returned directly by\n      getopt().\n\n    o Rather than returning an integer or character, getopt() returns an object\n      with the \"option\" field corresponding to the processed option character\n      and possibly the additional \"optarg\" and \"optopt\" fields.  If an error\n      occurs on a particular option, \"error\" is also set.  If an error occurs on\n      no particular option or if the end of input is encountered, undefined is\n      returned.\n\n    o Long option forms are supported as described above.  This introduces an\n      additional error case which is where an argument of the form\n      --option=value is encountered, where \"option\" does not take a value.\n\n    o POSIX starts \"optind\" at 1, since argv[0] is generally the name of the\n      command and options start at argv[1].  This implementation starts \"optind\"\n      at 2, since argv[0] is generally the path to the node binary and argv[1]\n      is the path to the script, so options start with argv[2].\n\n\nExamples\n--------\n\n### Example 1: simple short options\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-a', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\n### Example 2: invalid option specified\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-b', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\tconsole.error(option);\n\n### Example 3: long options\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('lar(recurse)',\n\t    ['node', 'script', '-l', '--recurse', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\n### Example 4: options with arguments\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('f:lad:',\n\t    ['node', 'script', '-l', '-f', 'filename', '-dtype', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\n### Example 5: options with missing arguments\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('f:la',\n\t    ['node', 'script', '-l', '-a', '-f']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\tconsole.error(option);\n\n### Example 6: options specified multiple times\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-a', '-l']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n",
-  "readmeFilename": "README.md",
   "_id": "posix-getopt@0.0.1",
+  "dependencies": {},
+  "devDependencies": {},
+  "_engineSupported": true,
+  "_npmVersion": "1.0.6",
+  "_nodeVersion": "v0.4.8",
+  "_defaultsLoaded": true,
   "dist": {
-    "shasum": "277212c1c581fa94fba40b587d30abb6bfe45bfb"
+    "shasum": "7a315be479bf693a57280fb27260e9b06b9e6f5f",
+    "tarball": "http://registry.npmjs.org/posix-getopt/-/posix-getopt-0.0.1.tgz"
   },
-  "_from": "posix-getopt@~0.0.1",
-  "_resolved": "https://registry.npmjs.org/posix-getopt/-/posix-getopt-0.0.1.tgz"
+  "scripts": {},
+  "directories": {},
+  "_shasum": "7a315be479bf693a57280fb27260e9b06b9e6f5f",
+  "_resolved": "https://registry.npmjs.org/posix-getopt/-/posix-getopt-0.0.1.tgz",
+  "_from": "posix-getopt@>=0.0.1 <0.1.0"
 }
diff --git a/src/node-lockfd/node_modules/v8plus/package.json b/src/node-lockfd/node_modules/v8plus/package.json
index 62cd8901..f35e2318 100644
--- a/src/node-lockfd/node_modules/v8plus/package.json
+++ b/src/node-lockfd/node_modules/v8plus/package.json
@@ -1,21 +1,52 @@
 {
-	"author": "Keith M Wesolowski <keith.wesolowski@joyent.com>",
-	"name": "v8plus",
-	"description": "utility environment for writing addons in C",
-	"version": "0.2.0",
-	"contributors": [
-		"Joshua M. Clulow <jmc@joyent.com>"
-	],
-	"repository": {
-		"type": "git",
-		"url": "git://github.com/joyent/v8plus.git"
-	},
-	"bugs": {
-		"url": "http://github.com/joyent/v8plus/issues"
-	},
-	"dependencies": {
-		"posix-getopt": "~0.0.1"
-	},
-	"main": "origin.js",
-	"license": "MIT"
+  "author": {
+    "name": "Keith M Wesolowski",
+    "email": "keith.wesolowski@joyent.com"
+  },
+  "name": "v8plus",
+  "description": "utility environment for writing addons in C",
+  "version": "0.3.1",
+  "contributors": [
+    {
+      "name": "Joshua M. Clulow",
+      "email": "jmc@joyent.com"
+    }
+  ],
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/v8plus.git"
+  },
+  "bugs": {
+    "url": "http://github.com/joyent/v8plus/issues"
+  },
+  "dependencies": {
+    "posix-getopt": "~0.0.1"
+  },
+  "main": "origin.js",
+  "license": "MIT",
+  "homepage": "https://github.com/joyent/v8plus",
+  "_id": "v8plus@0.3.1",
+  "dist": {
+    "shasum": "5288a7895254e67f3be11db225b3dd2614ef4a31",
+    "tarball": "https://registry.npmjs.org/v8plus/-/v8plus-0.3.1.tgz"
+  },
+  "_from": "v8plus@>=0.3.1 <0.4.0",
+  "_npmVersion": "1.3.24",
+  "_npmUser": {
+    "name": "wesolows",
+    "email": "keith.wesolowski@joyent.com"
+  },
+  "maintainers": [
+    {
+      "name": "wesolows",
+      "email": "keith.wesolowski@joyent.com"
+    },
+    {
+      "name": "jclulow",
+      "email": "josh@sysmgr.org"
+    }
+  ],
+  "directories": {},
+  "_shasum": "5288a7895254e67f3be11db225b3dd2614ef4a31",
+  "_resolved": "https://registry.npmjs.org/v8plus/-/v8plus-0.3.1.tgz"
 }
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_c_impl.h b/src/node-lockfd/node_modules/v8plus/v8plus_c_impl.h
new file mode 100644
index 00000000..1847b675
--- /dev/null
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_c_impl.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
+ */
+
+#ifndef	_V8PLUS_C_IMPL_H
+#define	_V8PLUS_C_IMPL_H
+
+#include <stdarg.h>
+#include <libnvpair.h>
+#include "v8plus_errno.h"
+
+#ifdef	__cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+#define	V8PLUS_OBJ_TYPE_MEMBER	".__v8plus_type"
+#define	V8PLUS_JSF_COOKIE	".__v8plus_jsfunc_cookie"
+
+#define	V8PLUS_STRINGIFY_HELPER(_x)	#_x
+#define	V8PLUS_STRINGIFY(_x)	V8PLUS_STRINGIFY_HELPER(_x)
+
+extern __thread nv_alloc_t _v8plus_nva;
+extern __thread char _v8plus_exception_buf[1024];
+extern __thread nvlist_t *_v8plus_pending_exception;
+
+/*
+ * Private methods.
+ */
+extern void v8plus_clear_exception(void);
+extern boolean_t v8plus_in_event_thread(void);
+extern void v8plus_crossthread_init(void);
+extern nvlist_t *_v8plus_alloc_exception(void);
+
+#ifdef	__cplusplus
+}
+#endif	/* __cplusplus */
+
+#endif	/* _V8PLUS_C_IMPL_H */
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_csup.c b/src/node-lockfd/node_modules/v8plus/v8plus_csup.c
index 26ccab4f..89cc95b3 100644
--- a/src/node-lockfd/node_modules/v8plus/v8plus_csup.c
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_csup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/ccompile.h>
@@ -14,10 +14,26 @@
 #include <uv.h>
 #include <node_version.h>
 #include <pthread.h>
+#include <alloca.h>
+#include <libnvpair.h>
+#include "v8plus_c_impl.h"
 #include "v8plus_glue.h"
 
-__thread v8plus_errno_t _v8plus_errno;
-__thread char _v8plus_errmsg[V8PLUS_ERRMSG_LEN];
+/*
+ * Because we strictly require throwing an exception any time an error occurs
+ * (other than for consumers who wish to return their own error objects), we
+ * must have our own means of creating the exception nvlist and a separate
+ * buffer that's always available.  Otherwise we can end up losing error
+ * information.  If we fail to construct the C++ object analogue to the nvlist,
+ * we will still at least have the original exception in the core.
+ *
+ * If we did not do this and were out of memory, we could end up returning
+ * undefined to JS callers instead of throwing or aborting.
+ */
+__thread nv_alloc_t _v8plus_nva;
+__thread char _v8plus_exception_buf[1024];
+__thread nvlist_t *_v8plus_pending_exception;
+
 static uint_t init_done;
 
 typedef struct v8plus_uv_ctx {
@@ -49,7 +65,6 @@ typedef enum v8plus_async_call_flags {
 	ACF_NOREPLY	= 0x02
 } v8plus_async_call_flags_t;
 
-
 typedef struct v8plus_async_call {
 	v8plus_async_call_type_t vac_type;
 	v8plus_async_call_flags_t vac_flags;
@@ -310,6 +325,9 @@ v8plus_crossthread_init(void)
 	if (atomic_swap_uint(&init_done, 1) != 0)
 		return;
 
+	(void) nv_alloc_init(&_v8plus_nva, nv_fixed_ops,
+	    _v8plus_exception_buf, sizeof (_v8plus_exception_buf));
+
 	_v8plus_uv_event_thread = pthread_self();
 	if (uv_async_init(uv_default_loop(), &_v8plus_uv_async,
 	    v8plus_async_callback) != 0)
@@ -361,108 +379,112 @@ v8plus_eventloop_rele(void)
 	(void) v8plus_cross_thread_call(vac);
 }
 
-nvlist_t *
-v8plus_verror(v8plus_errno_t e, const char *fmt, va_list ap)
+void
+v8plus_clear_exception(void)
 {
-	if (fmt == NULL) {
-		if (e == V8PLUSERR_NOERROR) {
-			*_v8plus_errmsg = '\0';
-		} else {
-			(void) snprintf(_v8plus_errmsg, V8PLUS_ERRMSG_LEN,
-			    "%s", v8plus_strerror(e));
-		}
-	} else {
-		(void) vsnprintf(_v8plus_errmsg, V8PLUS_ERRMSG_LEN, fmt, ap);
+	if (_v8plus_pending_exception != NULL) {
+		nvlist_free(_v8plus_pending_exception);
+		nv_alloc_reset(&_v8plus_nva);
+		_v8plus_pending_exception = NULL;
 	}
-	_v8plus_errno = e;
-
-	return (NULL);
 }
 
 nvlist_t *
-v8plus_error(v8plus_errno_t e, const char *fmt, ...)
+_v8plus_throw_error(v8plus_errno_t e, const char *file, uint_t line,
+    const char *fmt, ...)
 {
+	size_t len;
+	char *msg;
 	va_list ap;
 
+	if (fmt == NULL) {
+		return (_v8plus_throw_exception(v8plus_excptype(e),
+		    v8plus_strerror(e), file, line,
+		    V8PLUS_TYPE_STRING, "code", v8plus_errname(e),
+		    V8PLUS_TYPE_NUMBER, "v8plus_errno", (double)e,
+		    V8PLUS_TYPE_NONE));
+	}
+
 	va_start(ap, fmt);
-	(void) v8plus_verror(e, fmt, ap);
+	len = vsnprintf(NULL, 0, fmt, ap) + 1;
 	va_end(ap);
 
-	return (NULL);
-}
-
-static void __NORETURN
-v8plus_vpanic(const char *fmt, va_list ap)
-{
-	(void) vfprintf(stderr, fmt, ap);
-	(void) fflush(stderr);
-	abort();
-}
-
-void
-v8plus_panic(const char *fmt, ...)
-{
-	va_list ap;
-
+	msg = alloca(len);
 	va_start(ap, fmt);
-	v8plus_vpanic(fmt, ap);
+	(void) vsnprintf(msg, len, fmt, ap);
 	va_end(ap);
+
+	return (_v8plus_throw_exception(v8plus_excptype(e), msg, file, line,
+	    V8PLUS_TYPE_STRING, "code", v8plus_errname(e),
+	    V8PLUS_TYPE_NUMBER, "v8plus_errno", (double)e,
+	    V8PLUS_TYPE_NONE));
 }
 
 nvlist_t *
-v8plus_nverr(int nverr, const char *member)
+_v8plus_throw_nverr(int nverr, const char *member,
+    const char *file, uint_t line)
 {
-	(void) snprintf(_v8plus_errmsg, V8PLUS_ERRMSG_LEN,
-	    "nvlist manipulation error on member %s: %s",
-	    member == NULL ? "<none>" : member, strerror(nverr));
+	v8plus_errno_t e;
 
 	switch (nverr) {
 	case ENOMEM:
-		_v8plus_errno = V8PLUSERR_NOMEM;
+		e = V8PLUSERR_NOMEM;
 		break;
 	case EINVAL:
-		_v8plus_errno = V8PLUSERR_YOUSUCK;
+		e = V8PLUSERR_YOUSUCK;
 		break;
 	default:
-		_v8plus_errno = V8PLUSERR_UNKNOWN;
+		e = V8PLUSERR_UNKNOWN;
 		break;
 	}
 
-	return (NULL);
+	return (_v8plus_throw_error(e, file, line,
+	    "nvlist manipulation error on member %s: %s",
+	    member == NULL ? "<none>" : member, strerror(nverr)));
 }
 
 nvlist_t *
-v8plus_syserr(int syserr, const char *fmt, ...)
+_v8plus_throw_syserr(int syserr, const char *file, uint_t line,
+    const char *fmt, ...)
 {
-	v8plus_errno_t e;
+	size_t len;
+	char *msg;
 	va_list ap;
 
-	switch (syserr) {
-	case ENOMEM:
-		e = V8PLUSERR_NOMEM;
-		break;
-	case EBADF:
-		e = V8PLUSERR_BADF;
-		break;
-	default:
-		e = V8PLUSERR_UNKNOWN;
-		break;
+	if (fmt == NULL) {
+		return (v8plus_throw_errno_exception(syserr, NULL,
+		    strerror(syserr), NULL, V8PLUS_TYPE_NONE));
 	}
 
 	va_start(ap, fmt);
-	(void) v8plus_verror(e, fmt, ap);
+	len = vsnprintf(NULL, 0, fmt, ap) + 1;
 	va_end(ap);
 
-	return (NULL);
+	msg = alloca(len);
+	va_start(ap, fmt);
+	(void) vsnprintf(msg, len, fmt, ap);
+	va_end(ap);
+
+	return (_v8plus_throw_errno_exception(syserr, NULL, msg, NULL,
+	    file, line, V8PLUS_TYPE_NONE));
 }
 
-/*
- * The NULL nvlist with V8PLUSERR_NOERROR means we are returning void.
- */
-nvlist_t *
-v8plus_void(void)
+static void __NORETURN
+v8plus_vpanic(const char *fmt, va_list ap)
 {
-	return (v8plus_error(V8PLUSERR_NOERROR, NULL));
+	(void) vfprintf(stderr, fmt, ap);
+	(void) fflush(stderr);
+	abort();
+}
+
+void
+v8plus_panic(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	v8plus_vpanic(fmt, ap);
+	va_end(ap);
 }
 
 v8plus_type_t
@@ -633,7 +655,7 @@ v8plus_args(const nvlist_t *lp, uint_t flags, v8plus_type_t t, ...)
 			return (-1);
 		}
 
-		nt = va_arg(ap, data_type_t);
+		nt = va_arg(ap, v8plus_type_t);
 	}
 
 	va_end(ap);
@@ -663,7 +685,7 @@ v8plus_args(const nvlist_t *lp, uint_t flags, v8plus_type_t t, ...)
 		VERIFY(nvlist_lookup_nvpair((nvlist_t *)lp, buf, &pp) == 0);
 		VERIFY(v8plus_arg_value(nt, pp, vp) == 0);
 
-		nt = va_arg(ap, data_type_t);
+		nt = va_arg(ap, v8plus_type_t);
 	}
 
 	va_end(ap);
@@ -843,6 +865,416 @@ v8plus_obj_setprops(nvlist_t *lp, v8plus_type_t t, ...)
 	return (err);
 }
 
+boolean_t
+v8plus_exception_pending(void)
+{
+	return (_v8plus_pending_exception != NULL);
+}
+
+nvlist_t *
+v8plus_pending_exception(void)
+{
+	return (_v8plus_pending_exception);
+}
+
+nvlist_t *
+v8plus_void(void)
+{
+	v8plus_clear_exception();
+	return (NULL);
+}
+
+nvlist_t *
+_v8plus_alloc_exception(void)
+{
+	int err;
+	nvlist_t *lp;
+
+	if (_v8plus_pending_exception != NULL)
+		return (NULL);
+
+	if ((err = nvlist_xalloc(&lp, NV_UNIQUE_NAME, &_v8plus_nva)) != 0) {
+		v8plus_panic("unable to allocate nvlist for exception: %s",
+		    strerror(err));
+	}
+
+	_v8plus_pending_exception = lp;
+
+	return (lp);
+}
+
+nvlist_t *
+_v8plus_throw_exception(const char *type, const char *msg, const char *file,
+    uint_t line, v8plus_type_t t, ...)
+{
+	nvlist_t *lp;
+	va_list ap;
+	int err;
+
+	/*
+	 * Preserve the first exception thrown, even if more are thrown later.
+	 */
+	if (_v8plus_pending_exception != NULL)
+		return (NULL);
+
+	if ((err = nvlist_xalloc(&lp, NV_UNIQUE_NAME, &_v8plus_nva)) != 0) {
+		v8plus_panic("unable to allocate nvlist for exception: %s",
+		    strerror(err));
+	}
+
+	_v8plus_pending_exception = lp;
+
+	if (type == NULL)
+		type = "Error";
+
+	va_start(ap, t);
+	err = v8plus_obj_vsetprops(lp, t, &ap);
+	va_end(ap);
+
+	if (err != 0) {
+		v8plus_panic("unable to set exception properties: %s",
+		    v8plus_strerror(err));
+	}
+
+	err = v8plus_obj_setprops(lp,
+	    V8PLUS_TYPE_STRING, V8PLUS_OBJ_TYPE_MEMBER, type,
+	    V8PLUS_TYPE_STRING, "message", msg == NULL ? "" : msg,
+	    V8PLUS_TYPE_STRING, "file", file,
+	    V8PLUS_TYPE_NUMBER, "line", (double)line,
+	    V8PLUS_TYPE_NONE);
+
+	if (err != 0) {
+		v8plus_panic("unable to set exception properties: %s",
+		    v8plus_strerror(err));
+	}
+
+	return (NULL);
+}
+
+static const char *
+strerrcode(int err)
+{
+#define	ERRNO_CASE(e)	case e: return #e;
+	switch (err) {
+	case 0:
+		return ("<No error>");
+#ifdef EACCES
+	ERRNO_CASE(EACCES);
+#endif
+#ifdef EADDRINUSE
+	ERRNO_CASE(EADDRINUSE);
+#endif
+#ifdef EADDRNOTAVAIL
+	ERRNO_CASE(EADDRNOTAVAIL);
+#endif
+#ifdef EAFNOSUPPORT
+	ERRNO_CASE(EAFNOSUPPORT);
+#endif
+#ifdef EAGAIN
+	ERRNO_CASE(EAGAIN);
+#endif
+#ifdef EWOULDBLOCK
+#if EAGAIN != EWOULDBLOCK
+	ERRNO_CASE(EWOULDBLOCK);
+#endif
+#endif
+#ifdef EALREADY
+	ERRNO_CASE(EALREADY);
+#endif
+#ifdef EBADF
+	ERRNO_CASE(EBADF);
+#endif
+#ifdef EBADMSG
+	ERRNO_CASE(EBADMSG);
+#endif
+#ifdef EBUSY
+	ERRNO_CASE(EBUSY);
+#endif
+#ifdef ECANCELED
+	ERRNO_CASE(ECANCELED);
+#endif
+#ifdef ECHILD
+	ERRNO_CASE(ECHILD);
+#endif
+#ifdef ECONNABORTED
+	ERRNO_CASE(ECONNABORTED);
+#endif
+#ifdef ECONNREFUSED
+	ERRNO_CASE(ECONNREFUSED);
+#endif
+#ifdef ECONNRESET
+	ERRNO_CASE(ECONNRESET);
+#endif
+#ifdef EDEADLK
+	ERRNO_CASE(EDEADLK);
+#endif
+#ifdef EDESTADDRREQ
+	ERRNO_CASE(EDESTADDRREQ);
+#endif
+#ifdef EDOM
+	ERRNO_CASE(EDOM);
+#endif
+#ifdef EDQUOT
+	ERRNO_CASE(EDQUOT);
+#endif
+#ifdef EEXIST
+	ERRNO_CASE(EEXIST);
+#endif
+#ifdef EFAULT
+	ERRNO_CASE(EFAULT);
+#endif
+#ifdef EFBIG
+	ERRNO_CASE(EFBIG);
+#endif
+#ifdef EHOSTUNREACH
+	ERRNO_CASE(EHOSTUNREACH);
+#endif
+#ifdef EIDRM
+	ERRNO_CASE(EIDRM);
+#endif
+#ifdef EILSEQ
+	ERRNO_CASE(EILSEQ);
+#endif
+#ifdef EINPROGRESS
+	ERRNO_CASE(EINPROGRESS);
+#endif
+#ifdef EINTR
+	ERRNO_CASE(EINTR);
+#endif
+#ifdef EINVAL
+	ERRNO_CASE(EINVAL);
+#endif
+#ifdef EIO
+	ERRNO_CASE(EIO);
+#endif
+#ifdef EISCONN
+	ERRNO_CASE(EISCONN);
+#endif
+#ifdef EISDIR
+	ERRNO_CASE(EISDIR);
+#endif
+#ifdef ELOOP
+	ERRNO_CASE(ELOOP);
+#endif
+#ifdef EMFILE
+	ERRNO_CASE(EMFILE);
+#endif
+#ifdef EMLINK
+	ERRNO_CASE(EMLINK);
+#endif
+#ifdef EMSGSIZE
+	ERRNO_CASE(EMSGSIZE);
+#endif
+#ifdef EMULTIHOP
+	ERRNO_CASE(EMULTIHOP);
+#endif
+#ifdef ENAMETOOLONG
+	ERRNO_CASE(ENAMETOOLONG);
+#endif
+#ifdef ENETDOWN
+	ERRNO_CASE(ENETDOWN);
+#endif
+#ifdef ENETRESET
+	ERRNO_CASE(ENETRESET);
+#endif
+#ifdef ENETUNREACH
+	ERRNO_CASE(ENETUNREACH);
+#endif
+#ifdef ENFILE
+	ERRNO_CASE(ENFILE);
+#endif
+#ifdef ENOBUFS
+	ERRNO_CASE(ENOBUFS);
+#endif
+#ifdef ENODATA
+	ERRNO_CASE(ENODATA);
+#endif
+#ifdef ENODEV
+	ERRNO_CASE(ENODEV);
+#endif
+#ifdef ENOENT
+	ERRNO_CASE(ENOENT);
+#endif
+#ifdef ENOEXEC
+	ERRNO_CASE(ENOEXEC);
+#endif
+#ifdef ENOLINK
+	ERRNO_CASE(ENOLINK);
+#endif
+#ifdef ENOLCK
+#if ENOLINK != ENOLCK
+	ERRNO_CASE(ENOLCK);
+#endif
+#endif
+#ifdef ENOMEM
+	ERRNO_CASE(ENOMEM);
+#endif
+#ifdef ENOMSG
+	ERRNO_CASE(ENOMSG);
+#endif
+#ifdef ENOPROTOOPT
+	ERRNO_CASE(ENOPROTOOPT);
+#endif
+#ifdef ENOSPC
+	ERRNO_CASE(ENOSPC);
+#endif
+#ifdef ENOSR
+	ERRNO_CASE(ENOSR);
+#endif
+#ifdef ENOSTR
+	ERRNO_CASE(ENOSTR);
+#endif
+#ifdef ENOSYS
+	ERRNO_CASE(ENOSYS);
+#endif
+#ifdef ENOTCONN
+	ERRNO_CASE(ENOTCONN);
+#endif
+#ifdef ENOTDIR
+	ERRNO_CASE(ENOTDIR);
+#endif
+#ifdef ENOTEMPTY
+	ERRNO_CASE(ENOTEMPTY);
+#endif
+#ifdef ENOTSOCK
+	ERRNO_CASE(ENOTSOCK);
+#endif
+#ifdef ENOTSUP
+	ERRNO_CASE(ENOTSUP);
+#else
+#ifdef EOPNOTSUPP
+	ERRNO_CASE(EOPNOTSUPP);
+#endif
+#endif
+#ifdef ENOTTY
+	ERRNO_CASE(ENOTTY);
+#endif
+#ifdef ENXIO
+	ERRNO_CASE(ENXIO);
+#endif
+#ifdef EOVERFLOW
+	ERRNO_CASE(EOVERFLOW);
+#endif
+#ifdef EPERM
+	ERRNO_CASE(EPERM);
+#endif
+#ifdef EPIPE
+	ERRNO_CASE(EPIPE);
+#endif
+#ifdef EPROTO
+	ERRNO_CASE(EPROTO);
+#endif
+#ifdef EPROTONOSUPPORT
+	ERRNO_CASE(EPROTONOSUPPORT);
+#endif
+#ifdef EPROTOTYPE
+	ERRNO_CASE(EPROTOTYPE);
+#endif
+#ifdef ERANGE
+	ERRNO_CASE(ERANGE);
+#endif
+#ifdef EROFS
+	ERRNO_CASE(EROFS);
+#endif
+#ifdef ESPIPE
+	ERRNO_CASE(ESPIPE);
+#endif
+#ifdef ESRCH
+	ERRNO_CASE(ESRCH);
+#endif
+#ifdef ESTALE
+	ERRNO_CASE(ESTALE);
+#endif
+#ifdef ETIME
+	ERRNO_CASE(ETIME);
+#endif
+#ifdef ETIMEDOUT
+	ERRNO_CASE(ETIMEDOUT);
+#endif
+#ifdef ETXTBSY
+	ERRNO_CASE(ETXTBSY);
+#endif
+#ifdef EXDEV
+	ERRNO_CASE(EXDEV);
+#endif
+	default:
+		return ("<Unknown>");
+	}
+}
+
+nvlist_t *
+_v8plus_throw_errno_exception(int errorno, const char *syscall, const char *msg,
+    const char *path, const char *file, uint_t line, v8plus_type_t t, ...)
+{
+	char msgbuf[512];
+	const char *codestr;
+	nvlist_t *lp;
+	va_list ap;
+	int err;
+
+	if ((err = nvlist_xalloc(&lp, NV_UNIQUE_NAME, &_v8plus_nva)) != 0) {
+		v8plus_panic("unable to allocate nvlist for exception: %s",
+		    strerror(err));
+	}
+
+	_v8plus_pending_exception = lp;
+
+	va_start(ap, t);
+	err = v8plus_obj_vsetprops(lp, t, &ap);
+	va_end(ap);
+
+	if (err != 0) {
+		v8plus_panic("unable to set exception properties: %s",
+		    strerror(err));
+	}
+
+	codestr = strerrcode(errorno);
+
+	(void) snprintf(msgbuf, sizeof (msgbuf), "%s, %s",
+	    codestr, msg == NULL ? strerror(errorno) : msg);
+	if (path != NULL) {
+		(void) strlcat(msgbuf, " '", sizeof (msgbuf));
+		(void) strlcat(msgbuf, path, sizeof (msgbuf));
+		(void) strlcat(msgbuf, "'", sizeof (msgbuf));
+	}
+
+	err = v8plus_obj_setprops(lp,
+	    V8PLUS_TYPE_STRING, V8PLUS_OBJ_TYPE_MEMBER, "Error",
+	    V8PLUS_TYPE_NUMBER, "errno", (double)errorno,
+	    V8PLUS_TYPE_STRING, "code", codestr,
+	    V8PLUS_TYPE_STRING, "message", msgbuf,
+	    V8PLUS_TYPE_STRING, "file", file,
+	    V8PLUS_TYPE_NUMBER, "line", (double)line,
+	    V8PLUS_TYPE_NONE);
+
+	if (err != 0) {
+		v8plus_panic("unable to set exception properties: %s",
+		    strerror(err));
+	}
+
+	if (path != NULL) {
+		err = v8plus_obj_setprops(lp,
+		    V8PLUS_TYPE_STRING, "path", path,
+		    V8PLUS_TYPE_NONE);
+		if (err != 0) {
+			v8plus_panic("unable to set exception properties: %s",
+			    strerror(err));
+		}
+	}
+
+	if (syscall != NULL) {
+		err = v8plus_obj_setprops(lp,
+		    V8PLUS_TYPE_STRING, "syscall", syscall,
+		    V8PLUS_TYPE_NONE);
+		if (err != 0) {
+			v8plus_panic("unable to set exception properties: %s",
+			    strerror(err));
+		}
+	}
+
+	return (NULL);
+}
+
 static void
 v8plus_uv_worker(uv_work_t *wp)
 {
@@ -861,7 +1293,8 @@ v8plus_uv_completion(uv_work_t *wp)
 	v8plus_uv_ctx_t *cp = wp->data;
 
 	cp->vuc_completion(cp->vuc_obj, cp->vuc_ctx, cp->vuc_result);
-	v8plus_obj_rele(cp->vuc_obj);
+	if (cp->vuc_obj != NULL)
+		v8plus_obj_rele(cp->vuc_obj);
 	free(cp);
 	free(wp);
 }
@@ -876,8 +1309,10 @@ v8plus_defer(void *cop, void *ctxp, v8plus_worker_f worker,
 	bzero(wp, sizeof (uv_work_t));
 	bzero(cp, sizeof (v8plus_uv_ctx_t));
 
-	v8plus_obj_hold(cop);
-	cp->vuc_obj = cop;
+	if (cop != NULL) {
+		v8plus_obj_hold(cop);
+		cp->vuc_obj = cop;
+	}
 	cp->vuc_ctx = ctxp;
 	cp->vuc_worker = worker;
 	cp->vuc_completion = completion;
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_glue.h b/src/node-lockfd/node_modules/v8plus/v8plus_glue.h
index d318ff49..2b4517a4 100644
--- a/src/node-lockfd/node_modules/v8plus/v8plus_glue.h
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_glue.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #ifndef	_V8PLUS_GLUE_H
@@ -17,12 +17,7 @@ extern "C" {
 
 #define	V8PLUS_ARG_F_NOEXTRA	0x01
 
-#define	V8PLUS_ERRMSG_LEN	512
-#define	V8PLUS_JSF_COOKIE	".__v8plus_jsfunc_cookie"
-
 #define	V8PLUS_MODULE_VERSION	1
-#define	V8PLUS_STRINGIFY_HELPER(_x)	#_x
-#define	V8PLUS_STRINGIFY(_x)	V8PLUS_STRINGIFY_HELPER(_x)
 
 typedef enum v8plus_type {
 	V8PLUS_TYPE_NONE = 0,		/* N/A */
@@ -59,24 +54,16 @@ typedef struct v8plus_static_descr {
 	v8plus_c_static_f sd_c_func;
 } v8plus_static_descr_t;
 
-extern __thread v8plus_errno_t _v8plus_errno;
-extern __thread char _v8plus_errmsg[V8PLUS_ERRMSG_LEN];
-
 /*
- * Set the errno and message, indicating an error.  The code and
- * printf-formatted message, if one is given, will be used in constructing
- * an exception to be thrown in JavaScript if your method later returns NULL
- * or an nvlist with an "err" member.
- */
-extern nvlist_t *v8plus_verror(v8plus_errno_t, const char *, va_list);
-extern nvlist_t *v8plus_error(v8plus_errno_t, const char *, ...);
-
-/*
- * Suicide.  It's always an option.  Try to avoid using this as it's not
- * very nice to kill the entire node process; if at all possible we need
- * to throw a JavaScript exception instead.
+ * Throw an exception from a v8plus_errno_t and an optional text message.
+ * This mechanism is included only for backward compatibility with older
+ * source code and should not be used by new modules; see
+ * v8plus_throw_exception() below.
  */
-extern void v8plus_panic(const char *, ...) __PRINTFLIKE(1) __NORETURN;
+extern nvlist_t *_v8plus_throw_error(v8plus_errno_t, const char *, uint_t,
+    const char *, ...);
+#define	v8plus_error(_e, _f, _args...)	\
+	_v8plus_throw_error((_e), __FILE__, __LINE__, (_f), ## _args)
 
 /*
  * As above, this convenience function sets the error code and message based
@@ -84,21 +71,63 @@ extern void v8plus_panic(const char *, ...) __PRINTFLIKE(1) __NORETURN;
  * argument, which may be NULL, should contain the name of the member on
  * which the error occurred.
  */
-extern nvlist_t *v8plus_nverr(int, const char *);
+extern nvlist_t *_v8plus_throw_nverr(int, const char *, const char *, uint_t);
+#define	v8plus_nverr(_e, _m)	\
+	_v8plus_throw_nverr((_e), (_m), __FILE__, __LINE__)
+
+/*
+ * Similarly, for system errors.  This mechanism is similar to
+ * v8plus_throw_errno_exception(); however, the latter allows one to attach
+ * additional properties to the resulting exception while this one allows
+ * a formatted message string.
+ */
+extern nvlist_t *_v8plus_throw_syserr(int, const char *, uint_t,
+    const char *, ...);
+#define	v8plus_syserr(_e, _f, _args...)	\
+	_v8plus_throw_syserr((_e), __FILE__, __LINE__, (_f), ## _args)
+
+/*
+ * General interface to throw an exception.  The exception is not returned;
+ * instead, it is made pending and NULL is returned to facilitate the idiom
+ *
+ * return (v8plus_throw_exception(...));
+ *
+ * for failed method calls.
+ */
+extern nvlist_t *_v8plus_throw_exception(const char *, const char *,
+    const char *, uint_t, v8plus_type_t, ...);
+#define	v8plus_throw_exception(_e, _m, _t, _args...)	\
+	_v8plus_throw_exception((_e), (_m), __FILE__, __LINE__, (_t), ## _args)
 
 /*
- * Similarly, for system errors.  Not all possible errno values are handled.
+ * Interface for throwing exceptions derived from system errors, akin to the
+ * node-internal node::ErrnoException().
  */
-extern nvlist_t *v8plus_syserr(int, const char *, ...);
+extern nvlist_t *_v8plus_throw_errno_exception(int, const char *, const char *,
+    const char *, const char *, uint_t, v8plus_type_t, ...);
+#define	v8plus_throw_errno_exception(_e, _s, _m, _p, _t, _args...)	\
+	_v8plus_throw_errno_exception((_e), (_s), (_m), (_p), __FILE__,	\
+	    __LINE__, (_t), ## _args)
+
+extern boolean_t v8plus_exception_pending(void);
+extern nvlist_t *v8plus_pending_exception(void);
+extern void v8plus_rethrow_pending_exception(void);
 
 /*
- * Clear the errno and message.  This is needed only when one wishes to return
- * NULL from a C method whose return type is effectively void.  The idiom is
+ * Clear any pending exceptions and return a value suitable for returning
+ * from a method call to indicate returning no value.
  *
  * return (v8plus_void());
  */
 extern nvlist_t *v8plus_void(void);
 
+/*
+ * Suicide.  It's always an option.  Try to avoid using this as it's not
+ * very nice to kill the entire node process; if at all possible we need
+ * to throw a JavaScript exception instead.
+ */
+extern void v8plus_panic(const char *, ...) __PRINTFLIKE(1) __NORETURN;
+
 /*
  * Find the named V8 function in the nvlist.  Analogous to other lookup
  * routines; see libnvpair(3lib), with an important exception: the
@@ -250,12 +279,6 @@ extern const uint_t v8plus_static_method_count;
 
 extern void v8plus_module_register(v8plus_module_defn_t *);
 
-/*
- * Private methods.
- */
-extern boolean_t v8plus_in_event_thread(void);
-extern void v8plus_crossthread_init(void);
-
 #ifdef	__cplusplus
 }
 #endif	/* __cplusplus */
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_impl.h b/src/node-lockfd/node_modules/v8plus/v8plus_impl.h
index c9b228d5..dbd2e121 100644
--- a/src/node-lockfd/node_modules/v8plus/v8plus_impl.h
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_impl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #ifndef	_V8PLUS_IMPL_H
@@ -25,10 +25,8 @@
  * included from C code and contains nothing usable by consumers.
  */
 
-#define	V8PLUS_THROW(_t, _e, _f, _args...) \
-    v8::ThrowException(v8plus::exception((_t), (_e), (_f), ## _args))
-#define	V8PLUS_THROW_DEFAULT()		V8PLUS_THROW(NULL, NULL, NULL)
-#define	V8PLUS_THROW_DECORATED(_e)	V8PLUS_THROW(NULL, (_e), NULL)
+#define	V8PLUS_THROW_PENDING()		\
+    v8::ThrowException(v8plus::exception(_v8plus_pending_exception))
 
 /*
  * This is all very gross.  V8 has a lot of pointless churn in the form of
@@ -67,7 +65,8 @@ do {						\
 })
 
 #define	V8_JS_FUNC_DECL(_f)	\
-void _f(const v8::FunctionCallbackInfo<v8::Value> &)
+void \
+_f(const v8::FunctionCallbackInfo<v8::Value> &)
 
 #define	V8_JS_FUNC_DEFN(_f, _p)	\
 void \
@@ -218,8 +217,7 @@ private:
 
 extern nvlist_t *v8_Arguments_to_nvlist(const V8_ARGUMENTS &);
 extern v8::Handle<v8::Value> nvpair_to_v8_Value(const nvpair_t *);
-extern v8::Local<v8::Value> exception(const char *, const nvlist_t *,
-    const char *, ...) __PRINTFLIKE(3);
+extern v8::Handle<v8::Value> exception(const nvlist_t *);
 
 }; /* namespace v8plus */
 
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_objectwrap.cc b/src/node-lockfd/node_modules/v8plus/v8plus_objectwrap.cc
index 11040406..4af3d6c0 100644
--- a/src/node-lockfd/node_modules/v8plus/v8plus_objectwrap.cc
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_objectwrap.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -9,6 +9,7 @@
 #include <unordered_map>
 #include <stdlib.h>
 #include <node.h>
+#include "v8plus_c_impl.h"
 #include "v8plus_impl.h"
 #include "v8plus_glue.h"
 
@@ -200,19 +201,27 @@ V8_JS_FUNC_DEFN(v8plus::ObjectWrap::_new, args)
 	    reinterpret_cast<v8plus_func_ctx_t *>(ext->Value());
 	v8plus_c_ctor_f cp = fcp->vfc_defn->vmd_ctor;
 	v8plus::ObjectWrap *op = new v8plus::ObjectWrap();
-	nvlist_t *c_excp;
 	nvlist_t *c_args;
 
-	if ((c_args = v8plus::v8_Arguments_to_nvlist(args)) == NULL)
-		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
+	v8plus_clear_exception();
+
+	if ((c_args = v8plus::v8_Arguments_to_nvlist(args)) == NULL) {
+		delete op;
+		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
+	}
 
-	c_excp = cp(c_args, &op->_c_impl);
+	(void) cp(c_args, &op->_c_impl);
 	nvlist_free(c_args);
 	if (op->_c_impl == NULL) {
-		if (c_excp == NULL)
-			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
-		else
-			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DECORATED(c_excp));
+		/*
+		 * It is programmer error to fail to set the object pointer
+		 * without throwing an exception.  We used to try to cover this
+		 * up by throwing something ourselves, but we're not going
+		 * to bother any more.  Just abort.
+		 */
+		delete op;
+		VERIFY(v8plus_exception_pending());
+		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
 	}
 
 	op->_defn = fcp->vfc_defn;
@@ -277,7 +286,6 @@ V8_JS_FUNC_DEFN(v8plus::ObjectWrap::_entry, args)
 	    node::ObjectWrap::Unwrap<v8plus::ObjectWrap>(args.This());
 	nvlist_t *c_args;
 	nvlist_t *c_out;
-	nvlist_t *excp;
 	nvpair_t *rpp;
 	v8::Local<v8::String> self = args.Callee()->GetName()->ToString();
 	v8::String::Utf8Value selfsv(self);
@@ -287,29 +295,27 @@ V8_JS_FUNC_DEFN(v8plus::ObjectWrap::_entry, args)
 	if (c_method == NULL)
 		v8plus_panic("impossible method name %s\n", fn);
 
+	v8plus_clear_exception();
+
 	if ((c_args = v8plus::v8_Arguments_to_nvlist(args)) == NULL)
-		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
+		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
 
 	c_out = c_method(op->_c_impl, c_args);
 	nvlist_free(c_args);
 
 	if (c_out == NULL) {
-		if (_v8plus_errno == V8PLUSERR_NOERROR)
-			V8_JS_FUNC_RETURN_UNDEFINED_CLOSE(scope);
+		if (v8plus_exception_pending())
+			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
 		else
-			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
+			V8_JS_FUNC_RETURN_UNDEFINED_CLOSE(scope);
 	} else {
-		if (nvlist_lookup_nvlist(c_out, "err", &excp) == 0) {
-			v8::Handle<v8::Value> x = V8PLUS_THROW_DECORATED(excp);
-			nvlist_free(c_out);
-			V8_JS_FUNC_RETURN(args, x);
-		} else if (nvlist_lookup_nvpair(c_out, "res", &rpp) == 0) {
+		if (nvlist_lookup_nvpair(c_out, "res", &rpp) != 0) {
+			v8plus_panic("bad encoded value in return");
+		} else {
 			v8::Handle<v8::Value> r =
 			    v8plus::nvpair_to_v8_Value(rpp);
 			nvlist_free(c_out);
 			V8_JS_FUNC_RETURN_CLOSE(args, scope, r);
-		} else {
-			v8plus_panic("bad encoded object in return");
 		}
 	}
 
@@ -327,7 +333,6 @@ V8_JS_FUNC_DEFN(v8plus::ObjectWrap::_static_entry, args)
 	    reinterpret_cast<v8plus_func_ctx_t *>(ext->Value());
 	nvlist_t *c_args;
 	nvlist_t *c_out;
-	nvlist_t *excp;
 	nvpair_t *rpp;
 	v8::Local<v8::String> self = args.Callee()->GetName()->ToString();
 	v8::String::Utf8Value selfsv(self);
@@ -337,29 +342,27 @@ V8_JS_FUNC_DEFN(v8plus::ObjectWrap::_static_entry, args)
 	if (c_static == NULL)
 		v8plus_panic("impossible static method name %s\n", fn);
 
+	v8plus_clear_exception();
+
 	if ((c_args = v8plus::v8_Arguments_to_nvlist(args)) == NULL)
-		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
+		V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
 
 	c_out = c_static(c_args);
 	nvlist_free(c_args);
 
 	if (c_out == NULL) {
-		if (_v8plus_errno == V8PLUSERR_NOERROR)
-			V8_JS_FUNC_RETURN_UNDEFINED_CLOSE(scope);
+		if (v8plus_exception_pending())
+			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_PENDING());
 		else
-			V8_JS_FUNC_RETURN(args, V8PLUS_THROW_DEFAULT());
+			V8_JS_FUNC_RETURN_UNDEFINED_CLOSE(scope);
 	} else {
-		if (nvlist_lookup_nvlist(c_out, "err", &excp) == 0) {
-			v8::Handle<v8::Value> x = V8PLUS_THROW_DECORATED(excp);
-			nvlist_free(c_out);
-			V8_JS_FUNC_RETURN(args, x);
-		} else if (nvlist_lookup_nvpair(c_out, "res", &rpp) == 0) {
+		if (nvlist_lookup_nvpair(c_out, "res", &rpp) != 0) {
+			v8plus_panic("bad encoded value in return");
+		} else {
 			v8::Handle<v8::Value> r =
 			    v8plus::nvpair_to_v8_Value(rpp);
 			nvlist_free(c_out);
 			V8_JS_FUNC_RETURN_CLOSE(args, scope, r);
-		} else {
-			v8plus_panic("bad encoded object in return");
 		}
 	}
 
diff --git a/src/node-lockfd/node_modules/v8plus/v8plus_subr.cc b/src/node-lockfd/node_modules/v8plus/v8plus_subr.cc
index 38f76ba7..36cc8452 100644
--- a/src/node-lockfd/node_modules/v8plus/v8plus_subr.cc
+++ b/src/node-lockfd/node_modules/v8plus/v8plus_subr.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -13,9 +13,9 @@
 #include <v8.h>
 #include <unordered_map>
 #include <string>
+#include "v8plus_c_impl.h"
 #include "v8plus_impl.h"
 
-#define	V8PLUS_OBJ_TYPE_MEMBER	".__v8plus_type"
 #define	V8_EXCEPTION_CTOR_FMT \
 	"_ZN2v89Exception%u%sENS_6HandleINS_6StringEEE"
 
@@ -61,6 +61,8 @@ typedef struct cb_hdl {
 static std::unordered_map<uint64_t, cb_hdl_t> cbhash;
 static uint64_t cbnext;
 static void (*__real_nvlist_free)(nvlist_t *);
+static int nvlist_add_v8_Value(nvlist_t *,
+    const char *, const v8::Handle<v8::Value> &);
 
 static const char *
 cstr(const v8::String::Utf8Value &v)
@@ -87,6 +89,86 @@ cstr(const v8::String::Utf8Value &v)
 	if (((_e) = nvlist_add_##_t##_array((_l), (_n), (_v), (_c))) != 0) \
 		return (_e)
 
+static int
+v8_Object_to_nvlist(const v8::Handle<v8::Value> &vh, nvlist_t *lp)
+{
+	v8::Local<v8::Object> oh = vh->ToObject();
+	v8::Local<v8::Array> keys = oh->GetPropertyNames();
+	v8::Local<v8::String> th = oh->GetConstructorName();
+	v8::String::Utf8Value tv(th);
+	const char *type = cstr(tv);
+	boolean_t is_excp = _B_FALSE;
+	uint_t i;
+	int err;
+
+	/* XXX this is vile; can we handle this generally? */
+	if (strcmp(type, "Object") != 0) {
+		if (strcmp(type, "Error") == 0 ||
+		    strcmp(type, "TypeError") == 0 ||
+		    strcmp(type, "RangeError") == 0 ||
+		    strcmp(type, "ReferenceError") == 0 ||
+		    strcmp(type, "SyntaxError") == 0 ||
+		    strcmp(type, "EvalError") == 0 ||
+		    strcmp(type, "InternalError") == 0 ||
+		    strcmp(type, "URIError") == 0) {
+			is_excp = _B_TRUE;
+			if ((err = nvlist_add_string(lp,
+			    V8PLUS_OBJ_TYPE_MEMBER, type)) != 0) {
+				return (err);
+			}
+		} else if (strcmp(type, "Array") == 0) {
+			if ((err = nvlist_add_string(lp,
+			    V8PLUS_OBJ_TYPE_MEMBER, type)) != 0) {
+				return (err);
+			}
+		} else {
+			/*
+			 * XXX This is (C) programmer error.  Should
+			 * we plumb up a way to throw here?
+			 */
+			(void) v8plus_panic("can't handle %s", type);
+		}
+	}
+
+	if (is_excp) {
+		v8::Local<v8::Value> mv;
+
+		mv = oh->Get(v8::String::New("message"));
+
+		if ((err = nvlist_add_v8_Value(lp, "message", mv)) != 0)
+			return (err);
+	}
+
+	for (i = 0; i < keys->Length(); i++) {
+		char knname[11];
+		v8::Local<v8::Value> mk;
+		v8::Local<v8::Value> mv;
+		const char *k;
+
+		(void) snprintf(knname, sizeof (knname), "%u", i);
+		mk = keys->Get(v8::String::New(knname));
+		mv = oh->Get(mk);
+		v8::String::Utf8Value mks(mk);
+		k = cstr(mks);
+
+		if ((err = nvlist_add_v8_Value(lp, k, mv)) != 0)
+			return (err);
+	}
+
+	return (0);
+}
+
+static void
+v8plus_throw_v8_exception(const v8::Handle<v8::Value> &vh)
+{
+	nvlist_t *lp = _v8plus_alloc_exception();
+
+	if (lp == NULL)
+		return;
+
+	(void) v8_Object_to_nvlist(vh, lp);
+}
+
 /*
  * Add an element named <name> to list <lp> with a transcoded value
  * corresponding to <vh> if possible.  Only primitive types, objects that are
@@ -158,50 +240,14 @@ nvlist_add_v8_Value(nvlist_t *lp, const char *name,
 		LA_VA(lp, string, V8PLUS_JSF_COOKIE, NULL, 0, err);
 		LA_VA(lp, uint64, name, &cbnext, 1, err);
 	} else if (vh->IsObject()) {
-		v8::Local<v8::Object> oh = vh->ToObject();
-		v8::Local<v8::Array> keys = oh->GetOwnPropertyNames();
-		v8::Local<v8::String> th = oh->GetConstructorName();
-		v8::String::Utf8Value tv(th);
-		const char *type = cstr(tv);
 		nvlist_t *vlp;
-		uint_t i;
 
 		if ((err = nvlist_alloc(&vlp, NV_UNIQUE_NAME, 0)) != 0)
 			return (err);
 
-		/* XXX this is vile; can we handle this generally? */
-		if (strcmp(type, "Object") != 0) {
-			if (strcmp(type, "Array") == 0) {
-				if ((err = nvlist_add_string(vlp,
-				    V8PLUS_OBJ_TYPE_MEMBER, type)) != 0) {
-					nvlist_free(vlp);
-					return (err);
-				}
-			} else {
-				/*
-				 * XXX This is (C) programmer error.  Should
-				 * we plumb up a way to throw here?
-				 */
-				(void) v8plus_panic("can't handle %s", type);
-			}
-		}
-
-		for (i = 0; i < keys->Length(); i++) {
-			char knname[16];
-			v8::Local<v8::Value> mk;
-			v8::Local<v8::Value> mv;
-			const char *k;
-
-			(void) snprintf(knname, sizeof (knname), "%u", i);
-			mk = keys->Get(v8::String::New(knname));
-			mv = oh->Get(mk);
-			v8::String::Utf8Value mks(mk);
-			k = cstr(mks);
-
-			if ((err = nvlist_add_v8_Value(vlp, k, mv)) != 0) {
-				nvlist_free(vlp);
-				return (err);
-			}
+		if ((err = v8_Object_to_nvlist(vh, vlp)) != 0) {
+			nvlist_free(vlp);
+			return (err);
 		}
 
 		LA_V(lp, nvlist, name, vlp, err);
@@ -245,11 +291,80 @@ decorate_object(v8::Local<v8::Object> &oh, const nvlist_t *lp)
 
 	while ((pp =
 	    nvlist_next_nvpair(const_cast<nvlist_t *>(lp), pp)) != NULL) {
+		if (strcmp(nvpair_name(pp), V8PLUS_OBJ_TYPE_MEMBER) == 0)
+			continue;
 		oh->Set(v8::String::New(nvpair_name(pp)),
 		    v8plus::nvpair_to_v8_Value(pp));
 	}
 }
 
+static v8::Handle<v8::Value>
+create_and_populate(const nvlist_t *lp, const char *deftype)
+{
+	v8::Local<v8::Object> oh;
+	const char *type;
+	const char *msg;
+	char *ctor_name;
+	v8::Local<v8::Value> (*excp_ctor)(v8::Handle<v8::String>);
+	v8::Local<v8::Value> array;
+	void *obj_hdl;
+	size_t len;
+	boolean_t is_array = _B_FALSE;
+	boolean_t is_excp = _B_FALSE;
+	v8::Local<v8::Value> excp;
+	v8::Local<v8::String> jsmsg;
+
+	if (nvlist_lookup_string(const_cast<nvlist_t *>(lp),
+	    V8PLUS_OBJ_TYPE_MEMBER, const_cast<char **>(&type)) != 0)
+		type = deftype;
+
+	if (strcmp(type, "Array") == 0) {
+		array = v8::Array::New();
+		oh = array->ToObject();
+		is_array = _B_TRUE;
+	} else if (strcmp(type, "Object") == 0) {
+		oh = v8::Object::New();
+	} else {
+		msg = "";
+		(void) nvlist_lookup_string(const_cast<nvlist_t *>(lp),
+		    "message", const_cast<char **>(&msg));
+		jsmsg = v8::String::New(msg);
+
+		len = snprintf(NULL, 0, V8_EXCEPTION_CTOR_FMT,
+		    (uint_t)strlen(type), type);
+		ctor_name = reinterpret_cast<char *>(alloca(len + 1));
+		(void) snprintf(ctor_name, len + 1, V8_EXCEPTION_CTOR_FMT,
+		    (uint_t)strlen(type), type);
+
+		obj_hdl = dlopen(NULL, RTLD_NOLOAD);
+		if (obj_hdl == NULL)
+			v8plus_panic("%s\n", dlerror());
+
+		excp_ctor = (v8::Local<v8::Value>(*)(v8::Handle<v8::String>))(
+		    dlsym(obj_hdl, ctor_name));
+
+		if (excp_ctor == NULL) {
+			(void) dlclose(obj_hdl);
+			v8plus_panic("Unencodable type %s, aborting\n", type);
+		}
+
+		is_excp = _B_TRUE;
+		excp = excp_ctor(jsmsg);
+		(void) dlclose(obj_hdl);
+
+		oh = excp->ToObject();
+	}
+
+	decorate_object(oh, lp);
+
+	if (is_array)
+		return (array);
+	else if (is_excp)
+		return (excp);
+
+	return (oh);
+}
+
 #define	RETURN_JS(_p, _jt, _ct, _xt, _pt) \
 	do { \
 		_ct _v; \
@@ -260,8 +375,6 @@ decorate_object(v8::Local<v8::Object> &oh, const nvlist_t *lp)
 v8::Handle<v8::Value>
 v8plus::nvpair_to_v8_Value(const nvpair_t *pp)
 {
-	const char *type;
-
 	switch (nvpair_type(const_cast<nvpair_t *>(pp))) {
 	case DATA_TYPE_BOOLEAN:
 		return (v8::Undefined());
@@ -318,23 +431,10 @@ v8plus::nvpair_to_v8_Value(const nvpair_t *pp)
 	case DATA_TYPE_NVLIST:
 	{
 		nvlist_t *lp;
-		v8::Local<v8::Object> oh;
 
 		(void) nvpair_value_nvlist(const_cast<nvpair_t *>(pp), &lp);
 
-		if (nvlist_lookup_string(const_cast<nvlist_t *>(lp),
-		    V8PLUS_OBJ_TYPE_MEMBER, const_cast<char **>(&type)) != 0)
-			type = "Object";
-
-		if (strcmp(type, "Array") == 0)
-			oh = v8::Array::New()->ToObject();
-		else if (strcmp(type, "Object") != 0)
-			v8plus_panic("bad object type %s\n", type);
-		else
-			oh = v8::Object::New();
-
-		decorate_object(oh, lp);
-		return (oh);
+		return (create_and_populate(lp, "Object"));
 	}
 	default:
 		v8plus_panic("bad data type %d\n",
@@ -378,84 +478,10 @@ nvlist_to_v8_argv(const nvlist_t *lp, int *argcp, v8::Handle<v8::Value> *argv)
 	*argcp = i;
 }
 
-static v8::Local<v8::Value>
-sexception(const char *type, const nvlist_t *lp, const char *msg)
-{
-	char *ctor_name;
-	v8::Local<v8::Value> (*excp_ctor)(v8::Handle<v8::String>);
-	void *obj_hdl;
-	size_t len;
-	v8::Local<v8::Value> excp;
-	v8::Local<v8::Object> obj;
-	v8::Local<v8::String> jsmsg = v8::String::New(msg);
-
-	if (type == NULL) {
-		type = v8plus_excptype(_v8plus_errno);
-		if (type == NULL)
-			type = "Error";
-	}
-
-	len = snprintf(NULL, 0, V8_EXCEPTION_CTOR_FMT,
-	    (uint_t)strlen(type), type);
-	ctor_name = reinterpret_cast<char *>(alloca(len + 1));
-	(void) snprintf(ctor_name, len + 1, V8_EXCEPTION_CTOR_FMT,
-	    (uint_t)strlen(type), type);
-
-	obj_hdl = dlopen(NULL, RTLD_NOLOAD);
-	if (obj_hdl == NULL)
-		v8plus_panic("%s\n", dlerror());
-
-	excp_ctor = (v8::Local<v8::Value>(*)(v8::Handle<v8::String>))(
-	    dlsym(obj_hdl, ctor_name));
-
-	if (excp_ctor == NULL) {
-		(void) dlclose(obj_hdl);
-		if (strcmp(type, "Error") == 0) {
-			v8plus_panic("Unable to find %s, aborting\n",
-			    ctor_name);
-		} else {
-			excp = v8::Exception::Error(v8::String::New(
-			    "Nested exception: illegal exception type"));
-			return (excp);
-		}
-	}
-
-	excp = excp_ctor(jsmsg);
-	(void) dlclose(obj_hdl);
-
-	if (lp == NULL)
-		return (excp);
-
-	obj = excp->ToObject();
-	decorate_object(obj, lp);
-
-	return (excp);
-}
-
-v8::Local<v8::Value>
-v8plus::exception(const char *type, const nvlist_t *lp, const char *fmt, ...)
+v8::Handle<v8::Value>
+v8plus::exception(const nvlist_t *lp)
 {
-	v8::Local<v8::Value> exception;
-	char *msg;
-	size_t len;
-	va_list ap;
-
-	if (fmt != NULL) {
-		va_start(ap, fmt);
-		len = vsnprintf(NULL, 0, fmt, ap);
-		va_end(ap);
-		msg = reinterpret_cast<char *>(alloca(len + 1));
-
-		va_start(ap, fmt);
-		(void) vsnprintf(msg, len + 1, fmt, ap);
-		va_end(ap);
-	} else {
-		msg = _v8plus_errmsg;
-	}
-
-	exception = sexception(type, lp, msg);
-
-	return (exception);
+	return (create_and_populate(lp, "Error"));
 }
 
 extern "C" nvlist_t *
@@ -487,12 +513,10 @@ v8plus_call_direct(v8plus_jsfunc_t f, const nvlist_t *lp)
 		    v8::Context::GetCurrent()->Global(), argc, argv);
 	}
 	if (tc.HasCaught()) {
-		err = nvlist_add_v8_Value(rp, "err", tc.Exception());
+		v8plus_throw_v8_exception(tc.Exception());
 		tc.Reset();
-		if (err != 0) {
-			nvlist_free(rp);
-			return (v8plus_nverr(err, "err"));
-		}
+		nvlist_free(rp);
+		return (NULL);
 	} else if ((err = nvlist_add_v8_Value(rp, "res", res)) != 0) {
 		nvlist_free(rp);
 		return (v8plus_nverr(err, "res"));
@@ -524,12 +548,10 @@ v8plus_method_call_direct(void *cop, const char *name, const nvlist_t *lp)
 	v8::TryCatch tc;
 	res = op->call(name, argc, argv);
 	if (tc.HasCaught()) {
-		err = nvlist_add_v8_Value(rp, "err", tc.Exception());
+		v8plus_throw_v8_exception(tc.Exception());
 		tc.Reset();
-		if (err != 0) {
-			nvlist_free(rp);
-			return (v8plus_nverr(err, "err"));
-		}
+		nvlist_free(rp);
+		return (NULL);
 	} else if ((err = nvlist_add_v8_Value(rp, "res", res)) != 0) {
 		nvlist_free(rp);
 		return (v8plus_nverr(err, "res"));
@@ -714,3 +736,9 @@ v8plus_obj_rele_direct(const void *cop)
 	 */
 	v8plus_eventloop_rele_direct();
 }
+
+extern "C" void
+v8plus_rethrow_pending_exception(void)
+{
+	V8PLUS_THROW_PENDING();
+}
diff --git a/src/node-lockfd/package.json b/src/node-lockfd/package.json
index 5646407d..2d48522a 100644
--- a/src/node-lockfd/package.json
+++ b/src/node-lockfd/package.json
@@ -1,14 +1,21 @@
 {
   "name": "lockfd",
-  "description": "thin wrapper around fcntl(F_SETLK)",
-  "version": "0.0.3",
+  "description": "thin wrapper around fcntl(F_SETLK) and flock()",
+  "version": "1.1.0",
   "author": "Joshua M. Clulow <jmc@joyent.com>",
   "repository": "git://github.com/joyent/node-lockfd.git",
+  "main": "./lib/index.js",
   "dependencies": {
-    "v8plus": "~0.2.0"
+    "v8plus": "~0.3.1"
   },
   "scripts": {
-    "postinstall": "cd src && gmake $(eval echo ${MAKE_OVERRIDES})"
+    "postinstall": "cd src && gmake $(eval echo ${MAKE_OVERRIDES})",
+    "check": "jshint lib/*.js"
+  },
+  "devDependencies": {
+    "tape": "4.5.1",
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.0.1"
   },
   "license": "MIT"
 }
diff --git a/src/node-lockfd/src/Makefile b/src/node-lockfd/src/Makefile
index 4ca22ad6..1fe068ee 100644
--- a/src/node-lockfd/src/Makefile
+++ b/src/node-lockfd/src/Makefile
@@ -17,9 +17,9 @@ ERRNO_JSON =	errno.json
 CC =		/opt/local/bin/gcc
 CXX =		/opt/local/bin/g++
 
-CFLAGS +=	-pthread
+CFLAGS +=	-pthread -D__EXTENSIONS__
 
-#WARN_FLAGS +=	-Wno-error=unused-parameter
+WARN_FLAGS +=	-Wno-error=unused-parameter
 
 #LDFLAGS +=	-L/usr/lib/fm -R/usr/lib/fm
 LIBS +=		-lumem
diff --git a/src/node-lockfd/src/lockfd.c b/src/node-lockfd/src/lockfd.c
index 48372cd4..a73fe323 100644
--- a/src/node-lockfd/src/lockfd.c
+++ b/src/node-lockfd/src/lockfd.c
@@ -1,3 +1,8 @@
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -6,6 +11,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <sys/file.h>
 
 #include <libnvpair.h>
 
@@ -18,14 +24,34 @@ typedef struct lockfd_args {
 	boolean_t lfa_run_sync;
 } lockfd_args_t;
 
+typedef struct flock_args {
+	v8plus_jsfunc_t fla_cb;
+	int fla_fd;
+	int fla_op;
+	boolean_t fla_run_sync;
+} flock_args_t;
+
 static const char *
 errno_to_code(int en)
 {
-	return (en == EAGAIN ? "EAGAIN" :
-	    en == ENOLCK ? "ENOLCK" :
-	    en == EINTR ? "EINTR" :
-	    en == EDEADLK ? "EDEADLK" :
-	    "");
+	switch (en) {
+	case EAGAIN:
+		return ("EAGAIN");
+	case ENOLCK:
+		return ("ENOLCK");
+	case EINTR:
+		return ("EINTR");
+	case EDEADLK:
+		return ("EDEADLK");
+	case EBADF:
+		return ("EBADF");
+	case EINVAL:
+		return ("EINVAL");
+	case EOPNOTSUPP:
+		return ("EOPNOTSUPP");
+	default:
+		return ("<unknown errno>");
+	}
 }
 
 /*
@@ -46,7 +72,7 @@ lockfd_thread(void *arg)
 	 * Call back into JS:
 	 */
 	ap = v8plus_obj(
-	    V8PLUS_TYPE_NUMBER, "0", (double) ret,
+	    V8PLUS_TYPE_NUMBER, "0", (double)ret,
 	    V8PLUS_TYPE_STRING, "1", strerror(en),
 	    V8PLUS_TYPE_STRING, "2", errno_to_code(en),
 	    V8PLUS_TYPE_NONE);
@@ -55,7 +81,7 @@ lockfd_thread(void *arg)
 
 	if (!lfa->lfa_run_sync) {
 		/*
-		 * Release our callback, held from the ititial call:
+		 * Release our callback, held from the initial call:
 		 */
 		v8plus_jsfunc_rele(lfa->lfa_cb);
 	}
@@ -66,7 +92,70 @@ lockfd_thread(void *arg)
 }
 
 /*
- * Primary entrypoint from Javascript:
+ * Worker thread for blocking flock() calls:
+ */
+static void *
+flock_worker(void *cop, void *arg)
+{
+	flock_args_t *fla = arg;
+	nvlist_t *ap;
+	int ret, en = 0;
+
+	errno = 0;
+	while ((ret = flock(fla->fla_fd, fla->fla_op)) == -1) {
+		if (errno != EINTR) {
+			en = errno;
+			break;
+		}
+	}
+
+	/*
+	 * Create object to pass back into JS:
+	 */
+	ap = v8plus_obj(
+	    V8PLUS_TYPE_NUMBER, "0", (double)ret,
+	    V8PLUS_TYPE_STRING, "1", strerror(en),
+	    V8PLUS_TYPE_STRING, "2", errno_to_code(en),
+	    V8PLUS_TYPE_NONE);
+
+	return (ap);
+}
+
+/*
+ * Function called upon completion of the flock_worker() thread
+ */
+static void
+flock_completion(void *cop, void *arg, void *resp)
+{
+	flock_args_t *fla = arg;
+	nvlist_t *ap = resp;
+
+	/*
+	 * Call callback with response object, if object allocation succeeded.
+	 * An exception will have been queued if it failed.
+	 */
+	if (ap != NULL) {
+		(void) v8plus_call(fla->fla_cb, ap);
+		nvlist_free(ap);
+	}
+
+	if (!fla->fla_run_sync) {
+		/* Release our callback, held from the initial call: */
+		v8plus_jsfunc_rele(fla->fla_cb);
+	}
+
+	free(fla);
+}
+
+static void *
+flock_thread(void *fla)
+{
+	flock_completion(NULL, fla, flock_worker(NULL, fla));
+	return (NULL);
+}
+
+/*
+ * Primary entrypoint from Javascript to lock_fd function:
  */
 static nvlist_t *
 lockfd_lockfd(const nvlist_t *ap)
@@ -118,12 +207,75 @@ lockfd_lockfd(const nvlist_t *ap)
 		v8plus_jsfunc_hold(lfa->lfa_cb);
 
 		/*
-		 * Create a thread for the blocking fcntl(F_SETLKW) call:
+		 * Create a worker thread for the blocking fcntl(F_SETLKW) call:
 		 */
 		if (pthread_create(&newthr, NULL, lockfd_thread, lfa) != 0) {
 			return (v8plus_error(V8PLUSERR_UNKNOWN,
 			    "could not create thread"));
 		}
+		if (pthread_detach(newthr) != 0) {
+			return (v8plus_error(V8PLUSERR_UNKNOWN,
+			    "could not detach thread"));
+		}
+	}
+
+	return (v8plus_void());
+}
+
+/*
+ * Primary entrypoint from JavaScript to flock function:
+ */
+static nvlist_t *
+lockfd_flock(const nvlist_t *ap)
+{
+	flock_args_t *fla = calloc(1, sizeof (*fla));
+	pthread_t newthr;
+	double double_fd;
+	double double_op;
+
+	if (v8plus_args(ap, V8PLUS_ARG_F_NOEXTRA,
+	    V8PLUS_TYPE_NUMBER, &double_fd,
+	    V8PLUS_TYPE_NUMBER, &double_op,
+	    V8PLUS_TYPE_BOOLEAN, &fla->fla_run_sync,
+	    V8PLUS_TYPE_JSFUNC, &fla->fla_cb,
+	    V8PLUS_TYPE_NONE) != 0) {
+		free(fla);
+		return (v8plus_error(V8PLUSERR_BADARG, "bad args"));
+	}
+	fla->fla_fd = double_fd;
+	fla->fla_op = double_op;
+
+	if (fla->fla_run_sync) {
+		/*
+		 * Run the blocking flock() call in the current thread:
+		 */
+		flock_completion(NULL, fla, flock_worker(NULL, fla));
+	} else {
+		/*
+		 * Hold the function so that we can call it later from
+		 * the deferred worker thread:
+		 */
+		v8plus_jsfunc_hold(fla->fla_cb);
+
+		/*
+		 * If we were using the libuv workers, this would just be:
+		 *
+		 * v8plus_defer(NULL, fla, flock_worker, flock_completion);
+		 *
+		 * But since v0.10.x has 4 workers by default, it would be very
+		 * easy to queue up threads blocking on acquiring the lock, and
+		 * therefore prevent any I/O from happening, which may prevent
+		 * the holder of the lock from ever finishing their work. To
+		 * avoid this, we create a new thread:
+		 */
+		if (pthread_create(&newthr, NULL, flock_thread, fla) != 0) {
+			return (v8plus_error(V8PLUSERR_UNKNOWN,
+			    "could not create thread"));
+		}
+		if (pthread_detach(newthr) != 0) {
+			return (v8plus_error(V8PLUSERR_UNKNOWN,
+			    "could not detach thread"));
+		}
 	}
 
 	return (v8plus_void());
@@ -142,6 +294,10 @@ const uint_t v8plus_method_count =
     sizeof (v8plus_methods) / sizeof (v8plus_methods[0]);
 
 const v8plus_static_descr_t v8plus_static_methods[] = {
+	{
+		sd_name: "flock",
+		sd_c_func: lockfd_flock
+	},
 	{
 		sd_name: "lock_fd",
 		sd_c_func: lockfd_lockfd
