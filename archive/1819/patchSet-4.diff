From a749aeffb4c34bf6dcc28368b129bb2114b1799b Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 20 Apr 2017 15:47:32 -0700
Subject: [PATCH] joyent/node-cueball#108 crash: unhandled smgr state
 transition Reviewed by: David Pacheco <dap@joyent.com>

---
 lib/connection-fsm.js | 34 +++++++++++++++++-------
 package.json          |  2 +-
 test/pool.test.js     | 60 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 86 insertions(+), 10 deletions(-)

diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 0ed4d8e..8c117e3 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -1074,21 +1074,26 @@ ConnectionSlotFSM.prototype.state_busy = function (S) {
 	var self = this;
 	var smgr = this.csf_smgr;
 	var hdl = this.csf_handle;
+	var smgrState = 'connected';
+
+	S.on(smgr, 'stateChanged', function (st) {
+		smgrState = st;
+	});
 
 	function onRelease() {
-		if (smgr.isInState('connected')) {
+		if (smgrState === 'connected') {
 			if (self.csf_wanted) {
 				S.gotoState('idle');
 			} else {
 				S.gotoState('stopping');
 			}
-		} else if (smgr.isInState('closed')) {
+		} else if (smgrState === 'closed') {
 			if (self.csf_wanted) {
 				S.gotoState('connecting');
 			} else {
 				S.gotoState('stopped');
 			}
-		} else if (smgr.isInState('error')) {
+		} else if (smgrState === 'error') {
 			S.gotoState('retrying');
 		} else {
 			throw (new Error('Handle released while smgr was ' +
@@ -1097,7 +1102,7 @@ ConnectionSlotFSM.prototype.state_busy = function (S) {
 	}
 
 	function onClose() {
-		if (smgr.isInState('connected')) {
+		if (smgrState === 'connected') {
 			S.gotoState('killing');
 		} else {
 			S.gotoState('retrying');
@@ -1107,10 +1112,10 @@ ConnectionSlotFSM.prototype.state_busy = function (S) {
 	S.on(hdl, 'stateChanged', function (st) {
 		switch (st) {
 		case 'released':
-			S.immediate(onRelease);
+			onRelease();
 			break;
 		case 'closed':
-			S.immediate(onClose);
+			onClose();
 			break;
 		default:
 			break;
@@ -1129,7 +1134,7 @@ ConnectionSlotFSM.prototype.state_busy = function (S) {
 	} else {
 		hdl.reject();
 		this.csf_handle = undefined;
-		S.immediate(onRelease);
+		onRelease();
 	}
 };
 
@@ -1143,7 +1148,14 @@ ConnectionSlotFSM.prototype.state_killing = function (S) {
 		}
 	});
 
-	smgr.close();
+	/*
+	 * It's possible to get to this state when something else has already
+	 * caused the socket to close, but we haven't received the
+	 * 'stateChanged' event yet. If so, don't call .close(), just wait for
+	 * the event.
+	 */
+	if (!smgr.isInState('closed'))
+		smgr.close();
 };
 
 ConnectionSlotFSM.prototype.state_stopping = function (S) {
@@ -1156,7 +1168,11 @@ ConnectionSlotFSM.prototype.state_stopping = function (S) {
 		}
 	});
 
-	smgr.close();
+	/*
+	 * See above (deal with possible pending stateChanged event).
+	 */
+	if (!smgr.isInState('closed'))
+		smgr.close();
 };
 
 ConnectionSlotFSM.prototype.state_stopped = function (S) {
diff --git a/package.json b/package.json
index 067bb6e..30d2e3e 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.2.5",
+  "version": "2.2.6",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/pool.test.js b/test/pool.test.js
index ce47c0a..e960b1b 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -777,6 +777,66 @@ mod_tape.test('claim cancellation', function (t) {
 	});
 });
 
+mod_tape.test('cueball#108', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	recovery.default.retries = 2;
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 2 });
+
+		index.b1[0].connect();
+		index.b1[1].connect();
+
+		setTimeout(function () {
+			t.ok(pool.isInState('running'));
+
+			t.equal(connections.length, 2);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2 });
+
+			pool.claim(function (err, hdl, conn) {
+				t.ifError(err);
+
+				setTimeout(doFail, 100);
+
+				function doFail() {
+					hdl.close();
+					setImmediate(function () {
+						conn.emit('close');
+						setTimeout(end, 100);
+					});
+				}
+
+				function end() {
+					pool.stop();
+				}
+			});
+		}, 100);
+	});
+});
+
 mod_tape.test('cleanup sandbox', function (t) {
 	sandbox.restore();
 	t.end();
-- 
2.21.0

