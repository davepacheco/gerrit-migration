commit 3e5d74f4a0c1d14f62c6ce277b15bdf5b6f77de2 (refs/changes/66/2566/2)
Author: Brittany Wald <brittany.wald@joyent.com>
Date:   2017-09-14T01:54:27+00:00 (2 years, 1 month ago)
    
    MANTA-3382 node-fash data structure exposure

diff --git a/README.md b/README.md
index 4e8f232..29fee7a 100644
--- a/README.md
+++ b/README.md
@@ -4,65 +4,49 @@
 [![NPM](https://nodei.co/npm-dl/fash.png)](https://nodei.co/npm/fash/)
 
 
-This module provides a consistent hashing library. Notably, this module the
+This module provides a consistent hashing library. Notably, this module has the
 ability to **deterministically generate the same hash ring topology across a
 set of distributed hosts**. Fash also handles collisions of nodes on the ring
 and ensures no two nodes will share the same spot on the ring. Additionally,
 fash provides the ability to add, remove, or remap physical nodes on the ring
 -- useful when a particular physical node has hit its scaling bottleneck.
 
-# Design
+<a name="index"></a>
+# Index
+
+<a href="#design">Design Summary</a><br>
+<a href="#consumers">Examples for Consumers</a><br>
+--<a href="#consumers-new-ring">Boostrapping a New Hash Ring</a><br>
+--<a href="#consumers-add-pnodes">Adding More Pnodes to the Ring</a><br>
+--<a href="#consumers-add-data">Adding Optional Data to a Virtual Node</a><br>
+<a href="#dev">Development Information</a><br>
+--<a href="#dev-create">Command Line Ring Creation</a><br>
+----<a href="#backend">Backends: an interlude</a><br>
+--<a href="#walkthrough">Walkthrough: working with the hash ring</a><br>
+----<a href="#sample-add">Adding Data to Vnodes</a><br>
+----<a href="#sample-remap">Remapping Vnodes</a><br>
+----<a href="#sample-rmpnode">Removing Pnodes</a><br>
+--<a href="#schema">LevelDB schema</a><br>
+--<a href="#api">LevelDB-supported CLI</a><br>
+--<a href="#tests">Running Tests</a><br>
+
+<a name="design"></a>
+# Design Summary
 
 Fash consists of a mapping of a set of fixed virtual nodes (vnodes) -- usually
 a large number, say 1000000 -- distributed across the hash ring. It is then
 possible to map these virtual nodes to a set of physical nodes (pnodes).  In
-practice, pnodes are usually physical shards or servers in a distributed system.
-This gives the flexibility of mutating the hashspace of pnodes and the number
-of pnodes by re-mapping the vnode assignments.
+practice, pnodes are usually physical shards or servers in a distributed
+system. This gives the flexibility of mutating the hashspace of pnodes and the
+number of pnodes by re-mapping the vnode assignments.  For a more in-depth
+explanation, see the <a href="#dev">Development Information</a> section.
 
-# Backends
+<a name="consumers"></a>
+# Examples for Consumers
 
-As of version 2, Fash supports both a leveldb backend as well as an in-memory
-backend. The leveldb backend has several advantages over the in-memory backend.
-Notably, performance at scale should be faster since the ring is no longer in
-v8. Also the ring can be persisted on disk via leveldb, removing the need to
-load the ring into memory when the process is restarted.
-
-To select a backend, simply pass in a backend object like so to fash.create();
-
-```javascript
-
-    var fash = require('fash');
-    var Logger = require('bunyan');
-
-    var LOG = new Logger({
-        name: 'fash',
-        level: 'info'
-    });
-
-    fash.create({
-        log: LOG, // optional [bunyan](https://github.com/trentm/node-bunyan) log object.
-        algorithm: 'sha-256', // Can be any algorithm supported by openssl.
-        pnodes: ['A', 'B', 'C', 'D', 'E'], // The set of physical nodes to insert into the ring.
-        vnodes: 1000000 // The virtual nodes to place onto the ring. Once set, this can't be changed for the lifetime of the ring.
-        backend: fash.BACKEND.LEVEL_DB,
-        location: '/tmp/chash'
-    }, function(err, chash) {
-        console.log('chash created');
-    });
-```
-
-Or from, the command line:
-
-```
-./bin/fash.js create -v 1000000 -b leveldb -l {filepath/to/hash_ring} -p '{pnodename}''
-
-```
-
-# Example
-
-Most examples can be found in the unit tests. Here are a few.
+Examples can be found in the unit tests. Here are a few.
 
+<a name="consumers-new-ring"></a>
 ## Boostrapping a New Hash Ring
 
     var fash = require('fash');
@@ -89,13 +73,13 @@ ring toplogy will be the same as well. By default, fash will evenly distribute
 vnodes across the set of pnodes. If you wish to have a custom mapping of pnodes
 to vnodes, see the later section on serialization.
 
-## Remapping Pnodes in the Ring
-Fash gives you the ability to add and rebalance the pnodes in the ring by using
-the remapNode() function, which returns an optional callback.
+## Remapping Vnodes in the Ring
+Fash gives you the ability to add and rebalance the vnodes in the ring by using
+the remapVnode() function, which returns an optional callback.
 
 You can also remove pnodes from the ring, but **you must first rebalance the
 ring by reassigning its vnodes to other pnodes** via remapVnode(). Then you can
-invoke removeNode(), which will return an optional callback.
+invoke removePnode(), which will return an optional callback.
 
 You can assign an arbitrary number of vnodes to the new pnode -- also -- the
 pnode can be a new node, or an existing one.  Again, as long as the order of
@@ -128,6 +112,7 @@ consistent as well.
         console.log('changed pnode->vnode mappings', pnodes);
     });
 
+<a name="consumers-add-pnodes"></a>
 ## Adding More Pnodes to the Ring
 You can add additional pnodes to the ring after fash has been initialized by
 invoking remapVnode(), which optionally returns a callback. Note that adding
@@ -195,6 +180,7 @@ vnodes to another pnode, and then removing the pnode.
         });
     });
 
+<a name="consumers-add-data"></a>
 ## Adding Optional Data to a Virtual Node
 Sometimes, it might be helpful to associate state with a set of vnodes. An
 example of this would be during routine system maintenance, an administrator
@@ -264,13 +250,577 @@ mentioned in the earlier bootstrapping section.
 
 That's it, chash and chash2 now contain the same ring toplogy.
 
+<a name="dev"></a>
+# Development Information
+
+The following information is intended to serve developers making changes or
+enhancements to this repository.  The command-line interface provides insight
+into the structure of the hash ring topology at a deeper level than is made
+available by the functions exposed for consumers of the node program.  Though
+`help` can be a good reference once the data structure is understood, this
+documentation seeks to give an overview of this structure more comprehensively
+than makes sense to include in the tool itself.
+
+The "data structure" is, at a high level, a mapping of pnodes or "physical
+nodes" to vnodes or "virtual nodes."  It is intended to provide database-level
+associations for an operator's (your) key-value store.  The advantage of this
+setup is the flexibility to move vnodes between pnodes, while the association
+between the key-value pairings (where the "key" is hashed to an integer value
+and the "value" is a piece of plaintext data) and their assigned vnode is
+preserved.  This gives users the ability to retain relative groupings of keys
+(such as entries in the same file directory) that you've stored even in the
+event that you need to move data around.  For example, if the data set grows
+large enough that additional hardware (pnodes) are necessary to contain it all,
+this would necessitate re-assignment of key-value pairings as some are moved to
+the new pnode.  The level of abstraction the vnodes enable makes it possible to
+keep different key-value pairings associated with one another in a granular and
+simple way.
+
+<a name="dev-create"></a>
+## Command Line Ring Creation
+Here is the <a name="sample-create">creation</a> of a LevelDB-backed (meaning
+the key-value store is represented by the specs of LevelDB -- more information
+on that can be found <a href="#schema">here</a>) hash ring for distributing 6
+vnodes throughout 2 pnodes using the default hashing algorithm, sha256, which
+will be stored at the location `/var/tmp/rings/readme_sample`.
+
+    $ ./bin/fash.js create -l /var/tmp/rings/readme_sample -v 6 -a sha256 -p "tcp://1.moray.emy-11.joyent.us:2020, tcp://2.moray.emy-11.joyent.us:2020" -b leveldb
+
+Here is a <a name="diagram">diagram</a> of what that ring would then look like:
+
+```
+                   PNODES                                       VNODES
+
+                                                             +-----------+
++-------------------------------------------+   +--------+   |  "0": 1   |
+|                                           |                +-----------+
+|                                           |                             
+|   "tcp://1.moray.emy-11.joyent.us:2020"   |                +-----------+
+|                                           |   +--------+   |  "2": 1   |
+|                                           |                +-----------+
+|                                           |                             
++-------------------------------------------+                +-----------+
+                                                +--------+   |  "4": 1   |
+                                                             +-----------+
+
+                                                             +-----------+
++-------------------------------------------+   +--------+   |  "1": 1   |
+|                                           |                +-----------+
+|                                           |                             
+|   "tcp://2.moray.emy-11.joyent.us:2020"   |                +-----------+
+|                                           |   +--------+   |  "3": 1   |
+|                                           |                +-----------+
+|                                           |                             
++-------------------------------------------+                +-----------+
+                                                +--------+   |  "5": 1   |
+                                                             +-----------+
+```
+
+There is another way to create a ring topology if you already have a JSON file
+representation of one.  If you want to manufacture one, you can use the <a href="#print"><code>print-hash</code></a>
+command to print a JSON representation of a ring after creating it from scratch
+(as above).  Copying that into a <code>.json</code> file will give you the raw
+materials for testing out the <a href="#deserialize"><a name="sample-deserialize"><code>deserialize-ring</code></a></a>
+method of ring creation below.
+
+This is what the `.json` file should look like:
+
+    $ cat readme_sample.json 
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":1},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+And then to actually generate and store that LevelDB-backed ring:
+
+    $ ./bin/fash.js deserialize-ring -l /var/tmp/rings/readme_sample_deserialized -f /var/tmp/rings/readme_sample.json
+
+To see that the deserialized ring is the same as the original, the new ring can
+be viewed with the same <a name="sample-print"><code>print-hash</code></a>
+command used to show the original.
+
+    $ ./bin/fash.js print-hash -l /var/tmp/rings/readme_sample_deserialized -b leveldb
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":1},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+The fash tool can also do a direct comparison on its own with the
+<a name="sample-diff"><code>diff</code></a> command:
+
+    $ ./bin/fash.js diff -b leveldb /var/tmp/rings/readme_sample /var/tmp/rings/readme_sample_deserialized
+    {"tcp://1.moray.emy-11.joyent.us:2020":{"removed":[0],"added":[0]},"tcp://2.moray.emy-11.joyent.us:2020":{"removed":[1],"added":[1]}}
+
+<a name="backends"></a>
+### Backends: an interlude
+
+Please note that for commands added before 2017 (of which <code>create</code>
+is one), the <code>-b</code> option has to be specified.  This command's
+purpose is to indicate whether the topology is backed by a LevelDB or in-memory
+data store. 
+
+As of version 2, fash supported a LevelDB backend in addition to its original
+in-memory backend. The LevelDB backend has several advantages over the
+in-memory backend.  Notably, performance at scale should be faster since the
+ring is no longer in v8.  Also the ring can be persisted on disk via LevelDB,
+removing the need to load the ring into memory when the process is restarted.
+
+For these reasons, at the time of writing, the <b>in-memory option</b> for
+creating hash rings <b>is considered deprecated</b>, and may be removed in the
+future, once any existing dependencies on it can be verified and mitigated.
+That is why this section focuses on working with the LevelDB-backed hash ring
+functionality, though it would be remiss not to explain why some commands will
+not work without passing in `-b leveldb`.
+
+The way to create a ring -- specifying a backend -- from the command line is
+<a href="#sample-create">demonstrated above</a>.  Choosing a backend as a
+consumer is done during fash initialization via the `backend` field.
+
+```javascript
+
+    var fash = require('fash');
+    var Logger = require('bunyan');
+
+    var LOG = new Logger({
+        name: 'fash',
+        level: 'info'
+    });
+
+    fash.create({
+        log: LOG, // optional [bunyan](https://github.com/trentm/node-bunyan) log object.
+        algorithm: 'sha-256', // Can be any algorithm supported by openssl.
+        pnodes: ['A', 'B', 'C', 'D', 'E'], // The set of physical nodes to insert into the ring.
+        vnodes: 1000000 // The virtual nodes to place onto the ring. Once set, this can't be changed for the lifetime of the ring.
+        <b>backend: fash.BACKEND.LEVEL_DB,</b>
+        location: '/tmp/chash'
+    }, function(err, chash) {
+        console.log('chash created');
+    });
+```
+
+<a name="walkthrough"></a>
+## Walkthrough: examples of working with the hash ring
+
+Getting back to the <a href="#diagram">example topology created above</a>; in
+order to understand how this is related to both the LevelDB key-value store and
+also the pnode-vnode mapping, we will take just one "vnode" and break down the
+information inside it.
+
+                        +-----------+
+                        | "4": 1    |
+                        +-----------+
+
+The `4` is the vnode number.  It is also the post-hash key in the sense of the
+key-value LevelDB store.  What I mean by this is that if you have the key
+`/yunong/yunong.txt`, and then hash it using one of the available algorithms --
+say, sha256 -- you will get back, in this ring topology, the value `4`.  So
+vnode `4` is where any data (value) you wanted to associate with the `/yunong/yunong.txt`
+key will be stored.  In this case, we are storing the default value of 1 in
+that vnode, associated with the key `/yunong/yunong.txt`.  To help illustrate
+this point, there is a <a name="sample-node"><code>get-node</code></a> command
+to show operators what any key is associated with in terms of its data, pnode,
+and vnode mapping.
+
+    $ ./bin/fash.js get-node "/yunong/yunong.txt" -l /var/tmp/rings/readme_sample -b leveldb
+    { pnode: 'tcp://1.moray.emy-11.joyent.us:2020',
+      vnode: 4,
+      data: 1 }
+
+This operation is idempotent *as long as the topology does not change*. So `/yunong/yunong.txt`
+will always map to vnode `4` UNLESS the number of pnodes or vnodes changes.
+For this reason, remapping vnodes must *always be a manual process* -- we
+cannot recreate the ring with more pnodes or vnodes and expect that `/yunong/yunong.txt`
+will still map to vnode `4` on the `tcp://1.moray.emy-11.joyent.us:2020` pnode.
+
+<a name="sample-add"></a>
+### Adding Data to Vnodes
+
+So in an example where we are approaching full capacity on our two pnodes and
+need to add a third, it might make sense to mark the vnodes we're going to move
+in some way.  Then our application can check for that demarcation and, say, not
+accept writes that might be lost during a move.  If the chosen identifer was `ro`
+(for READ ONLY), we could assign the value `ro` to the vnodes with the keys
+we're shifting over.  This is done with the <a href="#add"><code>add-data</code></a>
+command:
+
+    $ ./bin/fash.js add-data -v 4 -d 'ro' -l /var/tmp/rings/readme_sample -b leveldb -o
+    {"4":"ro"}
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":"ro"},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+To achieve this:
+
+                        +-----------+
+                        | "4": "ro" |
+                        +-----------+
+
+So now vnode `4`, to which the key `/yunong/yunong.txt` maps, contains the
+value `ro`.
+
+<a name="sample-remap"></a>
+### Remapping Vnodes
+
+Now that the vnode we want to move can be identified, we will want to actually
+move it to the new hardware.  To see a full list of vnodes you have marked use
+the command <a href="#datav"><a name="sample-datav"><code>get-data-vnodes</code></a></a>:
+
+    $ ./bin/fash.js get-data-vnodes -l /var/tmp/rings/readme_sample
+    vnodeArray:  [ 4 ]
+
+If this array were much larger, say, hundreds or thousands of vnodes, but you
+were still just interested in knowing what data vnode `4` contained (or if at
+any point you needed to know which pnode it was assigned to) the <a href="#datapv"><a name="sample-datapv"><code>get-vnode-pnode-and-data</code></a></a>
+command displays all available information about a given vnode:
+
+    $ ./bin/fash.js get-vnode-pnode-and-data -v 4 -l /var/tmp/rings/readme_sample
+    vnodes:  { '4': { pnode: 'tcp://1.moray.emy-11.joyent.us:2020', vnodeData: 1 } }
+
+In our example, from this you could conclude that vnode 4 was marked as
+read-only for relocation, so it is intended to be remapped to a new pnode `tcp://3.moray.emy-11.joyent.us:2020`
+with <a href=#remap><code>remap-vnode</code></a>:
+
+    $ ./bin/fash.js remap-vnode -v 4 -b leveldb -p "tcp://3.moray.emy-11.joyent.us:2020" -l /var/tmp/rings/readme_sample -o
+    {"tcp://3.moray.emy-11.joyent.us:2020":"4"}
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1},"tcp://3.moray.emy-11.joyent.us:2020":{"4":"ro"}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+So that the topology now looks like this:
+
+```
+                   PNODES                                       VNODES
+
+                                                             +-----------+
++-------------------------------------------+   +--------+   |  "0": 1   |
+|                                           |                +-----------+
+|                                           |
+|   "tcp://1.moray.emy-11.joyent.us:2020"   |                +-----------+
+|                                           |   +--------+   |  "2": 1   |
+|                                           |                +-----------+
+|                                           |
++-------------------------------------------+
+
+
+                                                             +-----------+
++-------------------------------------------+   +--------+   |  "1": 1   |
+|                                           |                +-----------+
+|                                           |
+|   "tcp://2.moray.emy-11.joyent.us:2020"   |                +-----------+
+|                                           |   +--------+   |  "3": 1   |
+|                                           |                +-----------+
+|                                           |
++-------------------------------------------+                +-----------+
+                                                +--------+   |  "5": 1   |
+                                                             +-----------+
+
++-------------------------------------------+
+|                                           |
+|                                           |
+|   "tcp://3.moray.emy-11.joyent.us:2020"   |                +-----------+
+|                                           |   +--------+   | "4": "ro" |
+|                                           |                +-----------+
+|                                           |
++-------------------------------------------+
+```
+
+This command will also take a comma-separated list of vnodes (rather than just
+a single one) to move a group of vnodes to the same pnode in one batch.  It is
+also possible to remap vnodes to an existing pnode, rather than a new one.
+
+<a name="sample-rmpnode"></a>
+### Removing Pnodes
+
+If you've decided that you no longer need a particular pnode, you can remove
+it.  There is one caveat, which is that you have to remap the vnodes it
+contains first.  A list of vnodes on any pnode is available with the <a href="#vnodes"><a name="sample-vnodes"></a><code>get-vnodes</code></a></a>
+command.
+
+    $ ./bin/fash.js get-vnodes 'tcp://3.moray.emy-11.joyent.us:2020' -l /var/tmp/rings/readme_sample -b leveldb
+    [ 4 ]
+
+So now we would remap vnode `4`, this time to an existing pnode:
+
+    $ ./bin/fash.js remap-vnode -v 4 -b leveldb -p "tcp://1.moray.emy-11.joyent.us:2020" -l /var/tmp/rings/readme_sample -o
+    {"tcp://1.moray.emy-11.joyent.us:2020":"4"}
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":"ro"},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+Although it appears from that output that the vnode
+"tcp://3.moray.emy-11.joyent.us:2020" is already gone, that is not true.  This
+is because the LevelDB keys the <a href="#print">print-hash</a> command uses to
+display the LevelDB keys does not use the `/PNODE` key, which keeps track of
+all the pnodes in the ring.  This behavior is also present in <a href='#o-flag-commands'>
+the -o flag available on some commands</a>. In any case, we can see the full
+list of the pnodes on the ring using <a href="#pnodes"><a name="sample-pnodes"></a><code>get-pnodes</code></a></a>:
+
+    $ ./bin/fash.js get-pnodes -l /var/tmp/rings/readme_sample -b leveldb
+    [ 'tcp://1.moray.emy-11.joyent.us:2020',
+      'tcp://2.moray.emy-11.joyent.us:2020',
+      'tcp://3.moray.emy-11.joyent.us:2020' ]
+
+So now we can remove the pnode from LevelDB:
+
+    $ ./bin/fash.js remove-pnode -p "tcp://3.moray.emy-11.joyent.us:2020" -b leveldb -l /var/tmp/rings/readme_sample -o
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":"ro"},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+And check that it's really gone:
+
+    $ ./bin/fash.js get-pnodes -l /var/tmp/rings/readme_sample -b leveldb
+    [ 'tcp://1.moray.emy-11.joyent.us:2020',
+       'tcp://2.moray.emy-11.joyent.us:2020' ]
+
+<a name="schema"></a>
+## LevelDB Schema
+
+The key-value store that we use is called LevelDB.  For more information on how
+LevelDB works generally, see https://github.com/google/leveldb.  For
+information on the LevelDOWN library that serves as a Node.js binding for
+LevelDB, see https://github.com/level/leveldown/.
+
+In fash's setup, we create the following keys to manipulate and describe the
+structure (LevelDB key-value store) that underlies a ring topology (pnode-vnode
+mapping).  In the `leveldb.js` file, each of these are assigned to a constant
+variable prefaced with `LKEY_` with `P` and `V` standing in for `%s` and `%d`.
+The fact that the key names resemble file paths does not imply that a navigable
+file system backs this structure. (For example, there is no key that
+corresponds to `/VNODE`).
+
+```
+    KEY               VALUE
+```
+<a name="lkey_vnode_count"></a>
+```
+VNODE_COUNT      |    The total number of vnodes in the ring
+```
+<a name="lkey_vnode_data"></a>
+```
+VNODE_DATA       |    The array of vnodes that contain optional data
+```
+<a name="lkey_vnode_v"></a>
+```
+/VNODE/%d        |    The pnode a given vnode (%d) is assigned to
+```
+<a name="lkey_pnodes"></a>
+```
+/PNODE           |    The array of all pnodes in the hash ring
+```
+<a name="lkey_vnodes"></a>
+```
+/PNODE/%s        |    The array of all vnodes that are assigned to the given pnode (%s)
+```
+<a name="lkey_data"></a>
+```
+/PNODE/%s/%d     |    The value of the data on the given vnode (%d), which is on the given pnode (%s)
+```
+<a name="lkey_algorithm"></a>
+```
+ALGORITHM        |    The hashing algorithm used to create the ring topology
+```
+<a name="lkey_version"></a>
+```
+VERSION          |    Supposedly the version of fash we are on -- at this time, hard-coded to 2.1.0
+```
+<a name="lkey_complete"></a>
+```
+COMPLETE         |    Essentially a flag that is set to 1 when the ring creation finishes
+```
+
+<a name="api"></a>
+## LevelDB-supported CLI
+
+The purpose of these descriptions is to identify and explain each command's
+relationship to the LevelDB keys it needs to function.  Many of these are
+explained in the context of their use in the <a href="#walkthrough">walkthrough</a>
+section.  This section will describe them in terms of their relationship to
+LevelDB.
+
+  * <a href="#create"><code><b>create</b></code></a>
+  * <a href="#deserialize"><code><b>deserialize-ring</b></code></a>
+  * <a href="#add"><code><b>add-data</b></code></a>
+  * <a href="#remap"><code><b>remap-vnode</b></code></a>
+  * <a href="#rmpnode"><code><b>remove-pnode</b></code></a>
+  * <a href="#pnodes"><code><b>get-pnodes</b></code></a>
+  * <a href="#vnodes"><code><b>get-vnodes</b></code></a>
+  * <a href="#datapv"><code><b>get-vnode-pnode-and-data</b></code></a>
+  * <a href="#datav"><code><b>get_data_vnodes</b></code></a>
+  * <a href="#node"><code><b>get_node</b></code></a>
+  * <a href="#print"><code><b>print_hash</b></code></a>
+  * <a href="#diff"><code><b>diff</b></code></a>
+
+<a name="create"></a>
+### create
+<a href="#sample-create">Click here to see an example</a>
+<br>
+`create` opens the LevelDB database and populates all of the keys in the
+schema.  A step-by-step listing of the order in which the keys are populated is
+below:
+
+1. First, the count of vnodes is stored in <a href="#lkey_vnode_count"><code>VNODE_COUNT</code></a>.
+2. In batches of 1000, each <a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>
+key is written to its correspondent pnode.
+3. Each <a href="#lkey_data"><code>/PNODE/%s/%d</code></a> key is assigned the
+`LVAL_NULL` default data value of `1`.
+4. The <a href="#lkey_vnodes"><code>/PNODE/%s</code></a> keys are written from
+the `pnodeToVnodeMap` created during the previous step, and the <a href="#lkey_pnodes"><code>/PNODE</code></a>
+array is populated from the keys of the `pnodeMap` object created from the
+pnode options passed in this command.
+5. (and 6 and 7) The <a href="#lkey_algorithm"><code>ALGORITHM</code></a>,
+<a href="#lkey_version"><code>VERSION</code></a>, and <a href="#lkey_complete"><code>COMPLETE</code></a>
+keys are written -- the latter two hard-coded to default values.  The algorithm
+is taken from the options passed, and, if none are found, defaults to sha256.
+
+The effect of this is to create a hash ring with a one-to-many relationship
+between pnodes and vnodes, and a one-to-one relationship between vnodes and the
+data they hold.  The <a href="#schema">LevelDB keys</a> end up serving as a
+kind of metadata for describing aspects of this structure.
+
+<a name="deserialize"></a>
+### deserialize-ring
+<a href="#sample-deserialize">Click here to see an example</a>
+<br>
+`deserialize-ring` takes a json representation of a topology from a file or
+stdin and turns it into a LevelDB data structure.  In this case, only the
+LevelDB keys used for accessing the underlying mappings will be written.  Since
+the hashing has already necessarily completed in order to create the input
+given, <a href="#lkey_algorithm"><code>ALGORITHM</code></a>, <a href="#lkey_version"><code>VERSION</code></a>,
+and <a href="#lkey_complete"><code>COMPLETE</code></a> do not need to be
+written. This command writes
+<a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>, <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>,
+<a href="#lkey_vnodes"><code>/PNODE/%s</code></a>, and <a href="#lkey_vnode_data"><code>VNODE_DATA</code></a>.
+
+<a name="add"></a>
+### add-data
+<a href="#sample-add">Click here to see an example</a>
+<br>
+`add-data` takes a vnode number and allows you to assign any data to it.  If
+there is any use-case for which the consuming application needs to
+differentiate between arbitrary vnodes, assigning an identifiable data string
+to it is the way to do that.  The way it works is that the value of the key <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>
+has to be overwritten to contain the data you've passed, and the vnode chosen
+to put the data inside has to be added to the array stored in <a href="#lkey_vnode_data"><code>VNODE_DATA</code></a>.
+To access <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>, you need the
+pnode name, the function does a lookup of the <a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>
+key to find the pnode that the vnode you passed in is assigned to, and then
+assigns the data to that key.  For <a href="#lkey_vnode_data"><code>VNODE_DATA</code></a>,
+the function does a lookup of the current value of the key (an array <code>vnodeArray</code>),
+and if the chosen vnode isn't in that array, and the data is not null, it is
+pushed into <code>vnodeArray</code>, which is reassigned to <a href="#lkey_vnode_data"><code>VNODE_DATA</code></a>.
+
+<a name="remap"></a>
+### remap-vnode
+<a href="#sample-remap">Click here to see an example</a>
+<br>
+`remap-vnode`  takes a list of vnodes (which can be just one vnode) and a
+target pnode, and moves those vnodes from their current location onto the
+target pnode.  This is a multi-step process that involves multiple LevelDB
+keys.
+
+1. First there is an attempt to look up the vnodes under the target pnode using
+the <a href="#lkey_vnodes"><code>/PNODE/%s</code></a> key, not to retrieve the
+list of vnodes, but to see if a <code>NotFoundError</code> is generated.  By
+recording this if/else in a boolean variable, this gives the rest of the
+function access to whether or not the pnode is a new or an existing one.
+2. Next there is a lookup on the <a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>
+key to retrieve the current pnode of the vnode(s) set to be remapped.  If the
+current and intended pnode are the same, an error is thrown and the operation
+errors out.
+3. Then there is a lookup of the <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>
+key to get the data on the vnode.
+4. Next the keys to assign data to the moving vnodes -- <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>
+-- are deleted.  The vnodes for the old pnode are retrieved from the <a href="#lkey_vnodes"><code>/PNODE/%s</code></a> 
+key, then put into a batch for later.  Then, the <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>
+keys are deleted.
+5. The new vnodes-from-pnode mappings key (<a href="#lkey_vnodes"><code>/PNODE/%s</code></a>),
+data keys (<a href="#lkey_data"><code>/PNODE/%s/%d</code></a>), and
+pnode-from-vnode (<a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>) are put
+into batches to be committed as LevelDB keys in the final commit step.
+6. The new pnode is written to the <a href="#lkey_pnodes"><code>/PNODE</code></a>
+key.
+
+<a name="rmpnode"></a>
+### remove-pnode
+<a href="#sample-rmpnode">Click here to see an example</a>
+<br>
+`remove-pnode` checks that the <a href="#lkey_vnodes"><code>/PNODE/%s</code></a>
+key exists, and if it has any vnodes.  If it has vnodes, it will ask the
+operator to re-assign those first.  If not, it will delete the the <a href="#lkey_vnodes"><code>/PNODE/%s</code></a>
+key and alter the the <a href="#lkey_pnodes"><code>/PNODE</code></a> key's
+array so that it no longer contains the pnode in question.
+
+<a name="pnodes"></a>
+### get-pnodes
+<a href="#sample-pnodes">Click here to see an example</a>
+<br>
+`get-pnodes` lists the array of pnodes in the hash ring.  It does this by doing
+a get on the <a href="#lkey_pnodes"><code>/PNODE</code></a> key in LevelDB.
+
+<a name="vnodes"></a>
+### get-vnodes
+<a href="#sample-vnodes">Click here to see an example</a>
+<br>
+`get-vnodes` lists the array of vnodes in a given pnode in the hash ring.  It
+does this by doing a get on the <a href="#lkey_vnodes"><code>/PNODE/%s</code></a>
+key in LevelDB, where <code>%s</code> is the argument you pass to the <code>-p</code>
+flag when invoking this command.
+
+<a name="datapv"></a>
+### get-vnode-pnode-and-data
+<a href="#sample-datapv">Click here to see an example</a>
+<br>
+`get-vnode-pnode-and-data` takes a vnode, and from that returns the values of
+the pnode it is assigned to via the <a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>
+key and also the data it contains via the <a href="#lkey_data"><code>/PNODE/%s/%d</code></a>
+key.
+
+<a name="datav"></a>
+### get-data-vnodes
+<a href="#sample-datav">Click here to see an example</a>
+<br>
+`get-data-vnodes` returns the value of the <a href="#lkey_vnode_data"><code>VNODE_DATA</code></a>
+key.  This will return any vnode that has a value other than the default value
+of 1 -- it cannot, at the time of writing, select on different data values held
+in vnodes.
+
+<a name="node"></a>
+### get-node
+<a href="#sample-node">Click here to see an example</a>
+<br>
+`get-node` takes a key, runs it through fash's deterministic hashing algorithm
+to determine the vnode it is on, and does a get on the <a href="#lkey_vnode_v"><code>/VNODE/%d</code></a>
+key in LevelDB, which returns the pnode information needed to do a get on the <a href="lkey_data"><code>/PNODE/%s/%d</code></a>
+key in LevelDB, which gives back the data on the vnode and pnode derived from
+the key.
+
+<a name="print"></a>
+### print-hash
+<a href="#sample-print">Click here to see an example</a>
+<br>
+`print-hash` lets you view the hash ring topology.  This operation is also
+invoked by passing the -o flag to the <a name='o-flag-commands'>commands</a>
+<a href="#create">create</a>, <a href="#add">add-data</a>, <a href="#remap">remap-vnode</a>,
+or <a href="#rmpnode">remove-pnode</a> -- but do so *WITH EXTREME CAUTION*.
+For large hash rings, such as those with a million or more vnodes, this
+operation will be extremely slow, or may not even complete.
+
+    ./bin/fash.js print-hash -l /var/tmp/rings/readme_sample -b leveldb
+    {"vnodes":6,"pnodeToVnodeMap":{"tcp://1.moray.emy-11.joyent.us:2020":{"0":1,"2":1,"4":"ro"},"tcp://2.moray.emy-11.joyent.us:2020":{"1":1,"3":1,"5":1}},"algorithm":{"NAME":"sha256","MAX":"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","VNODE_HASH_INTERVAL":"2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},"version":"2.1.0"}
+
+<a name="diff"></a>
+### diff
+<a href="#sample-diff">Click here to see an example</a>
+<br>
+`diff` shows certain differences between two hash ring topologies.  The first
+topology you pass will be compared to the second -- bear this in mind for the
+differences returned will be in a format that uses the words "added" and
+"removed."  In particular, the names of the pnodes in the ring, as well as the
+number and allocations of vnodes, will be compared.  <b>Data within each vnode
+will be ignored.</b>  A sample return is below:
+
+    $ ./bin/fash.js diff -b leveldb /var/tmp/rings/sample1 /var/tmp/rings/sample2
+    {"tcp://1.moray.emy-11.joyent.us:2020":{"added":[20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]}}
+
+In terms of schema keys, the function gets the values of <a href="#lkey_pnodes"><code>/PNODE</code></a>
+from the two topologies passed to the command, then looks up the values of <a href="#lkey_vnodes"><code>/PNODE/%s</code></a>
+to get the complete set of data it compares.
+
+<a name="tests"></a>
 ## Running Tests
 
-Just run `make test`, first exporting the `DB_LOCATION` variable for the load
-test file to give it the location of your hash ring.
+Just run `make prepush` or `make test`, first exporting the `DB_LOCATION`
+variable for the load test file to give it the location of your hash ring.
 
 Copyright (c) 2017, Joyent, Inc.
 
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
-file, You can obtain one at http://mozilla.org/MPL/2.0/.
\ No newline at end of file
+file, You can obtain one at http://mozilla.org/MPL/2.0/.
diff --git a/bin/fash.js b/bin/fash.js
index ea04d9c..cd5eed2 100755
--- a/bin/fash.js
+++ b/bin/fash.js
@@ -585,7 +585,7 @@ Fash.prototype.do_remove_pnode.options = [ {
 }, {
     names: [ 'p', 'pnode' ],
     type: 'string',
-    help: 'the pnode to remap the vnode(s) to'
+    help: 'the pnode being removed'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -802,7 +802,7 @@ Fash.prototype.do_get_vnodes.help = (
     + '{{options}}'
 );
 
-Fash.prototype.do_get_vnode_pnode_and_data =
+Fash.prototype.do_get_vnode_pnode_and_data = 
     function (subcmd, opts, args, callback) {
     var self = this;
 
@@ -896,6 +896,78 @@ Fash.prototype.do_get_vnode_pnode_and_data.help = (
     + '{{options}}'
 );
 
+/*
+ * This returns vnodes that contain non-default data i.e. 'ro'
+ * But, importantly, if data other than 'ro' is set, vnodes that
+ * contain that data will also be returned in the vnodeArray.
+ */
+Fash.prototype.do_get_data_vnodes = function (subcmd, opts, args, callback) {
+    var self = this;
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], function (err) {
+            return callback(err ? err : true);
+        });
+    }
+
+    var hashOptions = {
+        log: self.log
+    };
+    var hash;
+    var constructor;
+
+    vasync.pipeline({funcs: [
+        function prepInput(_, cb) {
+            if (!opts.l) {
+                console.error('leveldb backend requires a location');
+                self.do_help('help', {}, [subcmd], function (err) {
+                    return callback(err ? err : true);
+                });
+            } else {
+                hashOptions.location = opts.l;
+                return cb();
+            }
+            return (undefined);
+        },
+        function loadRing(_, cb) {
+            // We choose not to support an IN_MEMORY backend.
+            hashOptions.backend = fash.BACKEND.LEVEL_DB;
+            constructor = fash.load;
+            hash = constructor(hashOptions, cb);
+        },
+        function getDataVnodes(_, cb) {
+            hash.getDataVnodes(function (err, vnodeArray) {
+                if (err) {
+                    return cb(verror.VError(err,
+                        'unable to get vnode(s) for data '));
+                }
+                console.log('vnodeArray: ', vnodeArray);
+                return cb();
+            });
+        }
+    ], arg: {}}, function (err) {
+        if (err)
+            console.error(new verror.VError(err));
+    });
+
+    return (undefined);
+};
+Fash.prototype.do_get_data_vnodes.options = [ {
+    names: [ 'l', 'location' ],
+    type: 'string',
+    help: 'the location of the topology, if using the in_memory backend, \n' +
+          'this is the location of the serialized ring on disk, if using \n ' +
+          'the leveldb backend, this is the path to the leveldb on disk.'
+}];
+Fash.prototype.do_get_data_vnodes.help = (
+    'get the vnode(s) that hold optional data'
+    + '\n'
+    + 'usage:\n'
+    + '     fash get-data-vnodes [options]\n'
+    + '\n'
+    + '{{options}}'
+);
+
 Fash.prototype.do_get_node = function (subcmd, opts, args, callback) {
     var self = this;
 
diff --git a/lib/backend/leveldb.js b/lib/backend/leveldb.js
index 5472e19..b5fa327 100644
--- a/lib/backend/leveldb.js
+++ b/lib/backend/leveldb.js
@@ -838,7 +838,6 @@ ConsistentHash.prototype.getVnodePnodeAndData =
 
 /*
  * Get the list of vnodes with data in them.
- * This is a helper that is used in tests.
  *
  * @param {function} cb The callback f(err, {})
  */
@@ -863,7 +862,7 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
  * Remaps a vnode on the hash ring. The node can be on an existing pnode,
  * or a new one.
  *
- * @param {String} node The name of the node.
+ * @param {String} pnode The name of the pnode.
  * @param {Number} The vnode to add to this pnode. Implicitly removes the
  *                   vnode from its previous pnode owner.
  * @param {function} cb The callback f(err).
@@ -1265,4 +1264,4 @@ module.exports.LKEY_PNODE_P = LKEY_PNODE_P;
 module.exports.LKEY_PNODE_P_V = LKEY_PNODE_P_V;
 module.exports.LKEY_VERSION = LKEY_VERSION;
 module.exports.LKEY_VNODE_COUNT = LKEY_VNODE_COUNT;
-module.exports.LKEY_VNODE_V = LKEY_VNODE_V;
\ No newline at end of file
+module.exports.LKEY_VNODE_V = LKEY_VNODE_V;
diff --git a/package.json b/package.json
index 8935c96..0fce254 100644
--- a/package.json
+++ b/package.json
@@ -8,6 +8,10 @@
     {
       "name": "Fred Kuo",
       "email": "deepevil@gmail.com"
+    },
+    {
+      "name": "Brittany Wald",
+      "email": "brittany.wald@joyent.com"
     }
   ],
   "name": "fash",
@@ -21,7 +25,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.4.0",
+  "version": "2.5.0",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
