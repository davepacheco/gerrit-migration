From 1a71c742538226cff48dc80e8411fa95641fe322 Mon Sep 17 00:00:00 2001
From: Mike Zeller <mike.zeller@joyent.com>
Date: Wed, 31 Jan 2018 16:11:13 -0800
Subject: [PATCH] PUBAPI-1475 Want additional tests for PUBAPI-1081

---
 test/common.js        |  75 ++++++++++-
 test/machines.test.js | 193 ++++++++++++++++++++++++++---
 test/nics.test.js     | 281 ++++++++++++++++++++++++++++++++++--------
 3 files changed, 481 insertions(+), 68 deletions(-)

diff --git a/test/common.js b/test/common.js
index 4a5659b..6697db3 100644
--- a/test/common.js
+++ b/test/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -1048,6 +1048,75 @@ function napiDeleteNicTagByName(opts, cb) {
     });
 }
 
+
+function externalNicMacFromServer(server) {
+    assert.object(server, 'server');
+    assert.object(server.sysinfo, 'server.sysinfo');
+
+    var mac;
+    var ifaces = server.sysinfo['Network Interfaces'];
+    assert.object(ifaces, 'ifaces');
+
+    var nic = Object.keys(ifaces).map(function (iname) {
+        return ifaces[iname];
+    }).filter(function findExternalNic(iface) {
+        assert.object(iface, 'iface');
+        var nicNames = iface['NIC Names'];
+        assert.arrayOfString(nicNames, 'nicNames');
+        return nicNames.indexOf('external') !== -1;
+    })[0];
+
+    assert.object(nic, 'nic');
+    mac = nic['MAC Address'];
+    assert.string(mac, 'mac');
+
+    return mac;
+}
+
+
+/*
+ * Add the given NIC tags to the server's external NIC.
+ *
+ * Calls back with `function (err, job)` where `job` is the the CNAPI
+ * NicUpdate response body (i.e. `job.job_uuid` is the workflow job UUID).
+ */
+function addNicTagsToServer(nicTags, server, client, callback) {
+    assert.arrayOfString(nicTags, 'nicTags');
+    assert.object(server, 'server');
+    assert.object(client, 'client');
+    assert.func(callback, 'callback');
+
+    var args = {
+        action: 'update',
+        nics: [ {
+            mac: externalNicMacFromServer(server),
+            nic_tags_provided: nicTags
+        } ]
+    };
+    client.cnapi.updateNics(server.uuid, args, function (err, body, res) {
+        callback(err, body);
+    });
+}
+
+
+function removeTagsFromServer(nicTags, server, client, callback) {
+    assert.arrayOfString(nicTags, 'nicTags');
+    assert.object(server, 'server');
+    assert.object(client, 'client');
+    assert.func(callback, 'callback');
+
+    var args = {
+        action: 'delete',
+        nics: [ {
+            mac: externalNicMacFromServer(server),
+            nic_tags_provided: nicTags
+        } ]
+    };
+    client.cnapi.updateNics(server.uuid, args, function (err, body, res) {
+        callback(err, body);
+    });
+}
+
 /*
  * Make the already imported image with name "imageName" provisionable by making
  * it public.
@@ -1168,6 +1237,10 @@ module.exports = {
     napiDeleteNetworkByName: napiDeleteNetworkByName,
     napiDeletePoolByName: napiDeletePoolByName,
 
+    // common functions to add/remove nic tags in tests
+    addNicTagsToServer: addNicTagsToServer,
+    removeTagsFromServer: removeTagsFromServer,
+
     sdc_128_package: SDC_128_PACKAGE,
 
     getCfg: function () {
diff --git a/test/machines.test.js b/test/machines.test.js
index 848f19c..d5d3a1e 100644
--- a/test/machines.test.js
+++ b/test/machines.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 var util = require('util');
@@ -91,8 +91,14 @@ var SDC_512 = {
 var SERVER_UUID;
 var IMAGE_UUID;
 var MACHINE_UUID;
-var NETWORK_UUID;
-var NETWORK_IP = '10.99.66.50';
+var NETWORK1_UUID;
+var NETWORK2_UUID;
+var NETWORK1_IP = '10.99.66.50';
+var NETWORK2_IP = '10.99.67.50';
+
+var TEST_SERVER;
+var NIC_TAG;
+var NIC_TAG_NAME = 'cloudapi_test_machines_nictag';
 
 var CLIENTS;
 var CLIENT;
@@ -147,13 +153,56 @@ test('setup', function (t) {
 
 
 test('Get test server', function (t) {
-    common.getTestServer(CLIENT, function (err, testServer) {
+    common.getTestServer(CLIENT, function onGetTestServer(err, testServer) {
         t.ifError(err);
+        TEST_SERVER = testServer;
         SERVER_UUID = testServer.uuid;
         t.end();
     });
 });
 
+test('Create nic tag', function (t) {
+    CLIENT.napi.getNicTag(NIC_TAG_NAME, function onGetNicTag(err, nicTag) {
+        if (err) {
+            if (err.statusCode === 404) {
+                createNicTag();
+            } else {
+                t.ifError(err, 'getNicTag');
+                t.end();
+            }
+        } else {
+            NIC_TAG = nicTag;
+            t.end();
+        }
+    });
+
+    function createNicTag() {
+        CLIENT.napi.createNicTag(NIC_TAG_NAME, function onCreateNicTag(err,
+            nicTag) {
+            t.ifError(err, 'createNicTag: nicTag ' + NIC_TAG_NAME);
+            NIC_TAG = nicTag;
+            t.end();
+        });
+    }
+});
+
+test('Add nic tag to test server', function (t) {
+    if (!NIC_TAG) {
+        t.end();
+        return;
+    }
+    var nicTags = [NIC_TAG_NAME];
+
+    common.addNicTagsToServer(nicTags, TEST_SERVER, CLIENT,
+        function onAddNicTagsToServer(addNicTagsErr, job) {
+        t.ifError(addNicTagsErr, 'add NIC tags to server: ' + nicTags);
+        waitForJob(CLIENT, job.job_uuid, function (jobErr) {
+            t.ifError(jobErr);
+            t.end();
+        });
+    });
+});
+
 
 test('Get base image', function (t) {
     common.getTestImage(CLIENT, function (err, img) {
@@ -1564,16 +1613,15 @@ test('Create Machine using network and IP', function (t) {
     CLIENT.napi.createNetwork(netDetails, function (err, net) {
         t.ifError(err);
 
-        NETWORK_UUID = net.uuid;
+        NETWORK1_UUID = net.uuid;
 
         obj.networks = [
             {
-                ipv4_uuid: NETWORK_UUID,
-                ipv4_ips: [ NETWORK_IP ]
+                ipv4_uuid: NETWORK1_UUID,
+                ipv4_ips: [ NETWORK1_IP ]
             }
         ];
 
-
         machinesCommon.createMachine(t, CLIENT, obj, function (_, machineUuid) {
             MACHINE_UUID = machineUuid;
             t.end();
@@ -1596,7 +1644,7 @@ test('Verify the machines IP', function (t) {
         t.ifError(err);
 
         var found = nics.some(function nicHasIp(n) {
-            return n.ip === NETWORK_IP;
+            return n.ip === NETWORK1_IP;
         });
 
         t.ok(found, 'nic with correct ip found');
@@ -1612,8 +1660,8 @@ test('Create Machine using network and in use IP', function (t) {
         server_uuid: SERVER_UUID,
         networks: [
             {
-                ipv4_uuid: NETWORK_UUID,
-                ipv4_ips: [ NETWORK_IP ]
+                ipv4_uuid: NETWORK1_UUID,
+                ipv4_ips: [ NETWORK1_IP ]
             }
         ]
     };
@@ -1659,7 +1707,7 @@ test('CreateMachine using network and invalid number of ips', function (t) {
         server_uuid: SERVER_UUID,
         networks: [
             {
-                ipv4_uuid: NETWORK_UUID,
+                ipv4_uuid: NETWORK1_UUID,
                 // IP set to any value just for this test
                 ipv4_ips: ['10.99.66.10', '10.99.66.10']
             }
@@ -1675,16 +1723,111 @@ test('CreateMachine using network and invalid number of ips', function (t) {
         t.deepEqual(body, {
             code: 'InvalidArgument',
             message: 'ipv4_ips: network with ipv4_uuid ' +
-                    NETWORK_UUID + ' should contain a single IP array'
+                    NETWORK1_UUID + ' should contain a single IP array'
+        });
+
+        t.end();
+    });
+});
+
+test('Create Machine using multiple networks and IPs', function (t) {
+    var netDetails = {
+        name: 'machines-test-network-and-ip-2',
+        vlan_id: 97,
+        subnet: '10.99.67.0/24',
+        provision_start_ip: '10.99.67.5',
+        provision_end_ip: '10.99.67.250',
+        nic_tag: NIC_TAG_NAME,
+        owner_uuids: [CLIENT.account.uuid]
+    };
+
+    var obj = {
+        image: IMAGE_UUID,
+        package: SDC_128.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        NETWORK2_UUID = net.uuid;
+
+        obj.networks = [
+            {
+                ipv4_uuid: NETWORK1_UUID,
+                ipv4_ips: [ NETWORK1_IP ]
+            },
+            {
+                ipv4_uuid: NETWORK2_UUID,
+                ipv4_ips: [ NETWORK2_IP ]
+            }
+        ];
+
+
+        machinesCommon.createMachine(t, CLIENT, obj, function (_, machineUuid) {
+            MACHINE_UUID = machineUuid;
+            t.end();
         });
 
+    });
+});
+
+
+test('Wait For Running Machine provisioned with multiple IPs', waitForRunning);
+
+
+test('Verify the machines IPs', function (t) {
+    var params = {
+        belongs_to_uuid: MACHINE_UUID,
+        belongs_to_type: 'zone'
+    };
+
+    CLIENT.napi.listNics(params, function napiListNics(err, nics) {
+        t.ifError(err);
+
+        t.equal(nics.length, 2, 'machine has 2 NICs');
+
+        var ip1 = nics.some(function nicHasIp1(n) {
+            return n.ip === NETWORK1_IP;
+        });
+
+        var ip2 = nics.some(function nicHasIp2(n) {
+            return n.ip === NETWORK2_IP;
+        });
+
+        t.ok(ip1, 'nic with ip ' + NETWORK1_IP + ' found');
+        t.ok(ip2, 'nic with ip ' + NETWORK2_IP + ' found');
         t.end();
     });
 });
 
 
-test('Destroy machines-test-network-and-ip network', function (t) {
-    CLIENT.napi.deleteNetwork(NETWORK_UUID,
+test('Destroy machine created with multiple IPs', function (t) {
+    CLIENT.vmapi.deleteVm({
+        uuid: MACHINE_UUID,
+        owner_uuid: CLIENT.account.uuid
+    }, function (err, job) {
+        t.ifError(err, 'Deleting machine ' + MACHINE_UUID);
+
+        waitForJob(CLIENT, job.job_uuid, function (deleteJobErr) {
+            t.ifError(deleteJobErr, 'waiting for job ' + job.job_uuid);
+            t.end();
+        });
+    });
+});
+
+
+test('Destroy machines-test-network-and-ip network-1', function (t) {
+    CLIENT.napi.deleteNetwork(NETWORK1_UUID,
+        function napiDeleteNetwork(err, res) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('Destroy machines-test-network-and-ip network-2', function (t) {
+    CLIENT.napi.deleteNetwork(NETWORK2_UUID,
         function napiDeleteNetwork(err, res) {
         t.ifError(err);
         t.end();
@@ -1692,6 +1835,26 @@ test('Destroy machines-test-network-and-ip network', function (t) {
 });
 
 
+test('Remove test server nic tag', function (t) {
+    if (!NIC_TAG) {
+        t.end();
+        return;
+    }
+    var nicTags = [NIC_TAG_NAME];
+
+    common.removeTagsFromServer(nicTags, TEST_SERVER, CLIENT,
+        function (err, job) {
+        t.ifError(err, 'remove NIC tags from server: '
+            + nicTags);
+
+        waitForJob(CLIENT, job.job_uuid, function (jobErr) {
+            t.ifError(jobErr, 'waitForJob ' + job.job_uuid);
+            t.end();
+        });
+    });
+});
+
+
 test('teardown', function (t) {
     common.deletePackage(CLIENT, SDC_256, function (err) {
         common.deletePackage(CLIENT, SDC_256_INACTIVE, function (err2) {
diff --git a/test/nics.test.js b/test/nics.test.js
index fc53fa1..9173998 100644
--- a/test/nics.test.js
+++ b/test/nics.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -154,6 +154,31 @@ function deleteFixtures(t, fixtures, cb) {
                 });
             }
         },
+        function getSecondTestInstId(ctx, next) {
+            if (fixtures && fixtures.secondInstId) {
+                ctx.secondInstId = fixtures.secondInstId;
+                next();
+                return;
+            }
+
+            CLIENT.vmapi.listVms({
+                state: 'active',
+                alias: FIXTURE_DATA.inst.name + '2'
+            }, function onListVms(err, vms) {
+                t.ifError(err, 'listVms for vm ' + FIXTURE_DATA.inst.name +
+                    2);
+                if (err) {
+                    next(err);
+                } else if (vms.length === 0) {
+                    next();
+                } else {
+                    ctx.secondInstId = vms[0].uuid;
+                    t.equal(vms.length, 1, 'found a match: ' +
+                        ctx.secondInstId);
+                    next();
+                }
+            });
+        },
         function deleteTestInst(ctx, next) {
             if (!ctx.instId) {
                 next();
@@ -179,6 +204,35 @@ function deleteFixtures(t, fixtures, cb) {
                 next(err);
             });
         },
+        function deleteSecondTestInst(ctx, next) {
+            var secondInstId = ctx.secondInstId;
+
+            if (!secondInstId) {
+                next();
+                return;
+            }
+            CLIENT.vmapi.deleteVm({uuid: secondInstId}, function (err,
+                job) {
+                t.ifError(err, 'deleteSecondTestInst ' + secondInstId);
+                if (job) {
+                    ctx.deleteJobUuid2 = job.job_uuid;
+                    t.ok(ctx.deleteJobUuid2,
+                        'delete job uuid: ' + ctx.deleteJobUuid2);
+                }
+                next(err);
+            });
+        },
+        function waitTilSecondMachineDeleted(ctx, next) {
+            var deleteJobUuid2 = ctx.deleteJobUuid2;
+            if (!deleteJobUuid2) {
+                next();
+                return;
+            }
+            waitForJob(CLIENT, deleteJobUuid2, function (err) {
+                t.ifError(err, 'waitForJob ' + deleteJobUuid2);
+                next(err);
+            });
+        },
 
         function getATestServer(ctx, next) {
             if (fixtures) {
@@ -206,7 +260,8 @@ function deleteFixtures(t, fixtures, cb) {
                 nicTags.push(fixtures.internal.nicTag.name);
             }
 
-            removeTagsFromServer(t, nicTags, ctx.server, function (err, job) {
+            common.removeTagsFromServer(nicTags, ctx.server, CLIENT,
+                function (err, job) {
                 t.ifError(err, 'remove NIC tags from server: '
                     + nicTags);
 
@@ -305,9 +360,9 @@ function createFixtures(t, cb) {
                 nicTags.push(fixtures.internal.nicTag.name);
             }
 
-            addNicTagsToServer(t, nicTags, fixtures.server,
+            common.addNicTagsToServer(nicTags, fixtures.server, CLIENT,
                     function (err, job) {
-                t.ifError(err);
+                t.ifError(err, 'add NIC tags to server: ' + nicTags);
                 waitForJob(CLIENT, job.job_uuid, function (err2) {
                     t.ifError(err2);
                     next();
@@ -347,6 +402,39 @@ function createFixtures(t, cb) {
             });
         },
 
+        function createSecondTestInst(_, next) {
+            common.getTestImage(CLIENT, function onGetTestImage(err, image) {
+                t.ifError(err, 'getTestImage');
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                var obj = {
+                    image: image.id,
+                    package: SDC_128.name,
+                    name: FIXTURE_DATA.inst.name + 2,
+                    server_uuid: fixtures.server.uuid,
+                    firewall_enabled: true
+                };
+                machinesCommon.createMachine(t, CLIENT, obj,
+                        function onCreateMachine(err2, instId) {
+                    t.ifError(err2, 'createSecondTestInst');
+                    fixtures.secondInstId = instId;
+                    next(err2);
+                });
+            });
+        },
+
+        function waitForTestSecondInst(_, next) {
+            machinesCommon.waitForRunningMachine(CLIENT, fixtures.secondInstId,
+                    function onWaitForMachine(err) {
+                t.ifError(err, 'waitForRunningMachine ' +
+                    fixtures.secondInstId);
+                next(err);
+            });
+        },
+
         /*
          * `fixtures.otherVm` is a machine owned by someone else.
          * We use one owned by 'admin' for this.
@@ -538,53 +626,6 @@ function deleteTestNetwork(t, data, fixture, cb) {
 }
 
 
-function externalNicMacFromServer(server) {
-    var ifaces = server.sysinfo['Network Interfaces'];
-    var nic = Object.keys(ifaces).map(function (iname) {
-        return ifaces[iname];
-    }).filter(function (iface) {
-        return iface['NIC Names'].indexOf('external') !== -1;
-    })[0];
-    return nic['MAC Address'];
-}
-
-
-/*
- * Add the given NIC tags to the server's external NIC.
- *
- * Calls back with `function (err, job)` where `job` is the the CNAPI
- * NicUpdate response body (i.e. `job.job_uuid` is the workflow job UUID).
- */
-function addNicTagsToServer(t, nicTags, server, callback) {
-    var args = {
-        action: 'update',
-        nics: [ {
-            mac: externalNicMacFromServer(server),
-            nic_tags_provided: nicTags
-        } ]
-    };
-    CLIENT.cnapi.updateNics(server.uuid, args, function (err, body, res) {
-        t.ifError(err);
-        callback(null, body);
-    });
-}
-
-
-function removeTagsFromServer(t, nicTags, server, callback) {
-    var args = {
-        action: 'delete',
-        nics: [ {
-            mac: externalNicMacFromServer(server),
-            nic_tags_provided: nicTags
-        } ]
-    };
-    CLIENT.cnapi.updateNics(server.uuid, args, function (err, body, res) {
-        t.ifError(err);
-        callback(null, body);
-    });
-}
-
-
 function getErr(t, path, expectedErr) {
     CLIENT.get(path, function (err, req, res, body) {
         t.equal(res.statusCode, expectedErr.statusCode);
@@ -766,7 +807,7 @@ function waitTilNicDeleted(t, apiPath) {
 
         CLIENT.get(apiPath, function (err, req, res, nic) {
             if (err) {
-                t.equal(err.statusCode, 404);
+                t.equal(err.statusCode, 404, 'NIC path 404');
                 t.end();
             } else {
                 setTimeout(check, 5000);
@@ -1786,6 +1827,9 @@ test('nics', function (tt) {
             t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
                 fabricNetwork.id, fabricNetwork.name));
 
+            t.ok(fabricNetworkIp, format('using fabrickNetworkIp %s',
+                fabricNetworkIp));
+
             var path = '/my/machines/' + fixtures.instId + '/nics';
             var networkParams = {
                 ipv4_uuid: fabricNetwork.id,
@@ -1807,12 +1851,145 @@ test('nics', function (tt) {
         });
     });
 
+    tt.test('  Add fabric network NIC with in use ip', FABRIC_TEST_OPTS,
+        function (t) {
+        CLIENT.get('/my/networks', function (err, req, res, networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.secondInstId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fabricNetworkIp ]
+            };
+            var args = { network: networkParams };
+            CLIENT.post(path, args, function onNicCreate(nicCreateErr,
+                nicCreateReq, nicCreateRes, nic) {
+                var expectedErr = {
+                    jse_info: {},
+                    jse_shortmsg: '',
+                    message: 'Invalid parameters',
+                    statusCode: 422,
+                    restCode: 'InvalidParameters',
+                    name: 'InvalidParametersError',
+                    body: {
+                        code: 'InvalidParameters',
+                        errors: [
+                            {
+                                code: 'UsedBy',
+                                message: 'IP in use'
+                            }
+                        ],
+                        message: 'Invalid parameters'
+                    }
+                };
+
+                postErr(t, path, args, expectedErr);
+            });
+        });
+    });
+
+
     tt.test('  Remove NIC using fabric network and ip', FABRIC_TEST_OPTS,
             function (t) {
+        t.ok(instNic, 'instNic okay to remove');
+        if (!instNic) {
+            t.end();
+            return;
+        }
         removeNic(t, fixtures.instId, instNic);
     });
 
 
+    // ---- Invalid IPs tests (actually testing vmapi/napi errors)
+
+    tt.test('  Add fabric network NIC with ip not in subnet', FABRIC_TEST_OPTS,
+        function (t) {
+        var fakeIp = '1.2.3.4'; // gross - we hope subnet doesn't actually match
+        CLIENT.get('/my/networks', function onGetNetworks(err, req, res,
+            networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.secondInstId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fakeIp ]
+            };
+            var args = { network: networkParams };
+            CLIENT.post(path, args, function onNicCreate(nicCreateErr,
+                nicCreateReq, nicCreateRes, nic) {
+                var expectedErr = {
+                    jse_info: {},
+                    jse_shortmsg: '',
+                    message: 'cannot validate ' + fakeIp +
+                        ': IP is not in subnet',
+                    statusCode: 404,
+                    restCode: 'ResourceNotFound',
+                    name: 'ResourceNotFoundError',
+                    body: {
+                        code: 'ResourceNotFound',
+                        message: 'cannot validate ' + fakeIp +
+                            ': IP is not in subnet'
+                    }
+                };
+
+                postErr(t, path, args, expectedErr);
+            });
+        });
+    });
+
+    tt.test('  Add fabric network NIC with invalid ip', FABRIC_TEST_OPTS,
+        function (t) {
+        CLIENT.get('/my/networks', function onGetNetworks(err, req, res,
+            networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.secondInstId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ '111' + fabricNetworkIp ]
+            };
+            var args = { network: networkParams };
+            CLIENT.post(path, args, function onNicCreate(nicCreateErr,
+                nicCreateReq, nicCreateRes, nic) {
+                var expectedErr = {
+                    jse_info: {},
+                    jse_shortmsg: '',
+                    message: 'cannot validate ' + '111' + fabricNetworkIp +
+                        ': Invalid IP address',
+                    statusCode: 404,
+                    restCode: 'ResourceNotFound',
+                    name: 'ResourceNotFoundError',
+                    body: {
+                        code: 'ResourceNotFound',
+                        message: 'cannot validate ' + '111' + fabricNetworkIp +
+                            ': Invalid IP address'
+                    }
+                };
+
+                postErr(t, path, args, expectedErr);
+            });
+        });
+    });
+
+
     tt.test('  teardown', function (t) {
         deleteFixtures(t, fixtures, function (err) {
             t.ifError(err, 'deleteFixtures');
-- 
2.21.0

