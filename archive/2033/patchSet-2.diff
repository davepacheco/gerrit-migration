commit 8a4bd2629e3c5ae37d93bb6f8e77e18cda915196 (refs/changes/33/2033/2)
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2017-06-05T13:47:04-07:00 (2 years, 4 months ago)
    
    VOLAPI-50 Add ListVolumeSizes endpoint
    Reviewed by: Julien Gilli <julien.gilli@joyent.com>
    Approved by: Julien Gilli <julien.gilli@joyent.com>

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index cff4582..0abbb77 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -73,6 +73,30 @@ function _selectBestPackage(requestedSize, packagesList, options, callback) {
     callback(err, bestPackage);
 }
 
+//
+// opts is an object that must include at least:
+//
+//   opts.papiClient which is a sdc-clients PAPI client object
+//
+// callback will be called as:
+//
+//   callback(err, pkgs, count);
+//
+function getAllNfsSharedVolumesPackages(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.papiClient, 'opts.papiClient');
+    assert.func(callback, 'callback');
+
+    opts.papiClient.list({}, {
+        active: true,
+        name: 'sdc_volume_nfs*'
+    }, function onListDone(err, pkgs, count) {
+        // explicitly call callback with these args so we're clear about our API
+        // rather than passing callback to papiClient.list.
+        callback(err, pkgs, count);
+    });
+}
+
 function _getBestPackage(volumeParams, options, callback) {
     assert.object(volumeParams, 'volumeParams');
     assert.object(options, 'options');
@@ -93,8 +117,8 @@ function _getBestPackage(volumeParams, options, callback) {
     vasync.pipeline({
         funcs: [
             function getNfsSharedVolumesPackages(ctx, next) {
-                papiClient.list({}, {
-                    name: 'sdc_volume_nfs*'
+                getAllNfsSharedVolumesPackages({
+                    papiClient: papiClient
                 }, function onListDone(err, pkgs, count) {
                     ctx.nfsSharedVolumesPkgs = pkgs;
                     next(err);
@@ -740,6 +764,87 @@ function listVolumes(req, res, next) {
     });
 }
 
+function validateListVolumeSizes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var validationErr;
+
+    // if type=<type> is passed, must be a valid type
+    if (req.params.type) {
+        validationErr = volumesValidation.validateVolumeType(req.params.type);
+    }
+
+    next(validationErr);
+}
+
+function listVolumeSizes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.query, 'req.query');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var papiClient = req._papiClient;
+
+    assert.object(papiClient, 'papiClient');
+
+    getAllNfsSharedVolumesPackages({
+        papiClient: papiClient
+    }, function onListDone(err, pkgs /* , count */) {
+        if (!err) {
+            req.nfsSharedVolumesPkgs = pkgs;
+        }
+        next(err);
+    });
+}
+
+function volumeSizeDescription(pkg) {
+    assert.object(pkg, 'pkg');
+    assert.number(pkg.quota, 'pkg.quota');
+
+    var pkgSizeGiB = Math.floor(pkg.quota / 1024);
+
+    return pkgSizeGiB + ' GiB';
+}
+
+function formatVolumeSizes(volumePkgs) {
+    assert.arrayOfObject(volumePkgs, 'volumePkgs');
+
+    //
+    // return an array of:
+    //
+    //  {
+    //      "description": "100 GiB",
+    //      "size": 102400
+    //   },
+    //
+    // objects, sorted by size (ascending)
+    //
+    return volumePkgs.map(function formatPkg(pkg) {
+        assert.object(pkg, 'pkg');
+        assert.number(pkg.quota, 'pkg.quota');
+
+        return {
+            description: volumeSizeDescription(pkg),
+            size: pkg.quota
+        };
+    }).sort(function sortPkgs(a, b) {
+        return (a.size - b.size);
+    });
+}
+
+function renderVolumeSizes(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+    assert.object(req.nfsSharedVolumesPkgs, 'req.nfsSharedVolumesPkgs');
+
+    req.renderedResponse = formatVolumeSizes(req.nfsSharedVolumesPkgs);
+
+    next();
+}
+
 function _getVolumeReferences(volumeObject, options, callback) {
     assert.object(volumeObject, 'volumeObject');
     assert.object(options, 'options');
@@ -1384,6 +1489,16 @@ function mount(config, server, applicationState) {
             statusCode: 200
         }));
 
+    server.get({
+        path: '/volumes/sizes',
+        name: 'ListVolumeSizes',
+        version: '1.0.0'
+    }, restify.queryParser(), validateListVolumeSizes, listVolumeSizes,
+        renderVolumeSizes,
+        makeSendResponseHandler({
+            statusCode: 200
+        }));
+
      server.get({
          path: '/volumes/:uuid',
          name: 'GetVolume',
diff --git a/test/integration/nfs-shared-volumes-list-volume-sizes.test.js b/test/integration/nfs-shared-volumes-list-volume-sizes.test.js
new file mode 100644
index 0000000..33e0b88
--- /dev/null
+++ b/test/integration/nfs-shared-volumes-list-volume-sizes.test.js
@@ -0,0 +1,142 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var test = require('tape');
+
+var clientsSetup = require('./lib/clients-setup');
+
+var CLIENTS;
+var NETWORKS;
+var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
+var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+// volume package we're going to deactivate and re-activate as part of this test
+var VICTIM_PACKAGE_SIZE = 10240;
+var VICTIM_PACKAGE_NAME = 'sdc_volume_nfs_10';
+var VICTIM_PACKAGE_UUID;
+
+test('setup', function (tt) {
+    tt.test(' setup clients', function (t) {
+        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
+            CLIENTS = clients;
+            t.ok(CLIENTS.volapi, 'should have volapi client');
+            t.end();
+        });
+    });
+});
+
+test('listVolumeSizes', function (tt) {
+    tt.test(' GET /volumes/sizes should return array of sizes', function (t) {
+        CLIENTS.volapi.listVolumeSizes({type: 'tritonnfs'},
+            function onListVolumeSizes(err, volumeSizes) {
+                var idx = 0;
+                var sorted = true;
+
+                t.ifErr(err, 'listing volume sizes should succeed');
+                t.ok(volumeSizes, 'should have received volumeSizes object');
+                t.ok(Array.isArray(volumeSizes), 'volumeSizes should be array');
+                t.ok(volumeSizes.length > 0,
+                    'should have at least one volumeSize');
+                t.ok(volumeSizes[0].size, 'first volumeSize should have size,' +
+                    ' got: ' + volumeSizes[0].size);
+                t.ok(volumeSizes[0].description, 'first volumeSize should ' +
+                    'have description, got: ' + volumeSizes[0].description);
+
+                // check that volume sizes are in ascending order
+                for (idx = 0; idx < volumeSizes.length; idx++) {
+                    if (idx > 0 && volumeSizes[idx - 1] > volumeSizes[idx]) {
+                        sorted = false;
+                    }
+                }
+
+                t.ok(sorted, 'volume sizes should be in ascending order');
+                t.end();
+            });
+    });
+
+    tt.test(' Deactivate ' + VICTIM_PACKAGE_NAME, function (t) {
+        CLIENTS.papi.list({name: VICTIM_PACKAGE_NAME}, {},
+            function onList(err, pkgs) {
+                t.ifErr(err, 'should succeed to "list" packages');
+                t.ok(pkgs, 'should have received a package list');
+                t.ok(Array.isArray(pkgs), 'package list should be array');
+                t.equal(pkgs.length, 1, 'should have exactly 1 package');
+                t.equal(pkgs[0].name, VICTIM_PACKAGE_NAME,
+                    'package found should be our victim');
+                t.ok(pkgs[0].uuid, 'package should have uuid, got: ' +
+                    pkgs[0].uuid);
+
+                VICTIM_PACKAGE_UUID = pkgs[0].uuid;
+
+                if (pkgs[0].name === VICTIM_PACKAGE_NAME) {
+                    CLIENTS.papi.update(pkgs[0].uuid, {active: false},
+                        function onUpdate(updateErr) {
+                            t.ifErr(updateErr, 'update should succeed');
+                            t.end();
+                        });
+                } else {
+                    t.end();
+                }
+            });
+    });
+
+    tt.test(' Deactivated package should not be visible', function (t) {
+        CLIENTS.volapi.listVolumeSizes({type: 'tritonnfs'},
+            function onListVolumeSizes(err, volumeSizes) {
+                var foundVictim = false;
+                var idx = 0;
+
+                t.ifErr(err, 'listing volume sizes should succeed');
+                t.ok(volumeSizes, 'should have received volumeSizes object');
+                t.ok(Array.isArray(volumeSizes), 'volumeSizes should be array');
+                for (idx = 0; idx < volumeSizes.length; idx++) {
+                    if (volumeSizes[idx].size === VICTIM_PACKAGE_SIZE) {
+                        foundVictim = true;
+                    }
+                }
+                t.ok(!foundVictim, 'should not have found size=' +
+                    VICTIM_PACKAGE_SIZE);
+                t.end();
+            });
+    });
+
+    tt.test(' Reactivate ' + VICTIM_PACKAGE_NAME, function (t) {
+        t.ok(VICTIM_PACKAGE_UUID, 'have victim uuid');
+        if (VICTIM_PACKAGE_UUID) {
+            CLIENTS.papi.update(VICTIM_PACKAGE_UUID, {active: true},
+                function onUpdate(updateErr) {
+                    t.ifErr(updateErr, 'update should succeed');
+                    t.end();
+                });
+        } else {
+            t.end();
+        }
+    });
+
+    tt.test(' Reactivated package should be visible', function (t) {
+        CLIENTS.volapi.listVolumeSizes({type: 'tritonnfs'},
+            function onListVolumeSizes(err, volumeSizes) {
+                var foundVictim = false;
+                var idx = 0;
+
+                t.ifErr(err, 'listing volume sizes should succeed');
+                t.ok(volumeSizes, 'should have received volumeSizes object');
+                t.ok(Array.isArray(volumeSizes), 'volumeSizes should be array');
+                for (idx = 0; idx < volumeSizes.length; idx++) {
+                    if (volumeSizes[idx].size === VICTIM_PACKAGE_SIZE) {
+                        foundVictim = true;
+                    }
+                }
+                t.ok(foundVictim, 'should have found size=' +
+                    VICTIM_PACKAGE_SIZE);
+                t.end();
+            });
+    });
+
+});
