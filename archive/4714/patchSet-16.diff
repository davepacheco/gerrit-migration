From 5d3f688c7eb872f714030575b68d20f61a96e5c3 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Mon, 24 Sep 2018 13:44:46 -0400
Subject: [PATCH] joyent/node-manta#335 Want option to confim removal of files
 for `mrm` Reviewed by: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
 Approved by: Jordan Hendricks <jordan.hendricks@joyent.com>

---
 CHANGES.md          |   4 +
 bin/mrm             |  66 +++++++++---
 bin/mrmdir          |  46 ++++++---
 docs/man/mrm.md     |   5 +-
 docs/man/mrmdir.md  |   5 +-
 lib/index.js        |   3 +-
 lib/utils.js        |  21 +++-
 man/man1/mrm.1      |   5 +-
 man/man1/mrmdir.1   |   5 +-
 test/lib/utils.js   |  49 +++++++++
 test/mrm.test.js    | 244 ++++++++++++++++++++++++++++++++++++++++++++
 test/mrmdir.test.js | 152 +++++++++++++++++++++++++++
 12 files changed, 570 insertions(+), 35 deletions(-)
 create mode 100644 test/lib/utils.js
 create mode 100644 test/mrm.test.js
 create mode 100644 test/mrmdir.test.js

diff --git a/CHANGES.md b/CHANGES.md
index fd93aa5..0ea5692 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -6,6 +6,10 @@ See `CONTRIBUTING.md` for details on how to update this file
 
 - [#349](https://github.com/joyent/node-manta/issues/349) issue numbers in
   CHANGES.md should link to GitHub issues
+- [#335](https://github.com/joyent/node-manta/issues/335) Want option to confim
+  removal of files for `mrm`
+
+  `mrm -I` and `mrmdir -I` now supported
 
 ## 5.2.1
 
diff --git a/bin/mrm b/bin/mrm
index 3e6efdf..2bdc032 100755
--- a/bin/mrm
+++ b/bin/mrm
@@ -4,8 +4,9 @@
  * Copyright 2018 Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var f = require('util').format;
 var path = require('path');
-var url = require('url');
 
 var bunyan = require('bunyan');
 var dashdash = require('dashdash');
@@ -20,6 +21,11 @@ function optionsParser(name) {
             {
                 group: name + ' options'
             },
+            {
+                names: ['interactive', 'I'],
+                type: 'bool',
+                help: 'confirm before deleting objects'
+            },
             {
                 names: ['parallel', 'p'],
                 type: 'positiveInteger',
@@ -46,12 +52,6 @@ function ifError(err) {
     }
 }
 
-
-function printEntry(obj) {
-    console.log('%j', obj);
-}
-
-
 ///--- Mainline
 
 (function main() {
@@ -70,11 +70,14 @@ function printEntry(obj) {
         log: log
     };
     var options = manta.parseOptions(parseArgs);
-
-
     var client = manta.createBinClient(options);
     var i = -1;
 
+    if (options.interactive && !process.stdin.isTTY) {
+        console.error('stdin must be a tty when interactive specified');
+        process.exit(1);
+    }
+
     (function rm(cb_err) {
         ifError(cb_err);
 
@@ -95,16 +98,47 @@ function printEntry(obj) {
             }
 
             if (info.extension === 'directory') {
-                if (options.recursive) {
-                    client.rmr(p, options, rm);
-                } else {
-                    console.error(p + ' is not an object');
+                // entry is a directory
+                if (!options.recursive) {
+                    console.error('%s is not an object', p);
                     process.exit(1);
                 }
-                return;
-            }
 
-            client.unlink(p, rm);
+                if (!options.interactive) {
+                    client.rmr(p, options, rm);
+                    return;
+                }
+
+                manta.promptConfirm(
+                    f('recursively remove directory `%s` [y/N]?: ', p),
+                    function (ans) {
+
+                    if (!ans) {
+                        // skip removing
+                        rm();
+                        return;
+                    }
+
+                    client.rmr(p, options, rm);
+                });
+            } else {
+                // entry is an object
+                if (!options.interactive) {
+                    client.unlink(p, rm);
+                    return;
+                }
+
+                manta.promptConfirm(f('remove object `%s` [y/N]?: ', p),
+                    function (ans) {
+
+                    if (!ans) {
+                        rm();
+                        return;
+                    }
+
+                    client.unlink(p, rm);
+                });
+            }
         });
     })();
 })();
diff --git a/bin/mrmdir b/bin/mrmdir
index 83393aa..d095aed 100755
--- a/bin/mrmdir
+++ b/bin/mrmdir
@@ -4,8 +4,9 @@
  * Copyright 2018 Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var f = require('util').format;
 var path = require('path');
-var url = require('url');
 
 var bunyan = require('bunyan');
 var dashdash = require('dashdash');
@@ -17,7 +18,16 @@ var manta = require('../lib');
 
 function optionsParser(name) {
     var parser = dashdash.createParser({
-        options: manta.DEFAULT_CLI_OPTIONS
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['interactive', 'I'],
+                type: 'bool',
+                help: 'confirm before deleting directories'
+            }
+        ])
     });
 
     return (parser);
@@ -31,12 +41,6 @@ function ifError(err) {
     }
 }
 
-
-function printEntry(obj) {
-    console.log('%j', obj);
-}
-
-
 ///--- Mainline
 
 (function main() {
@@ -55,10 +59,14 @@ function printEntry(obj) {
         log: log
     };
     var options = manta.parseOptions(parseArgs);
-
     var client = manta.createBinClient(options);
     var i = -1;
 
+    if (options.interactive && !process.stdin.isTTY) {
+        console.error('stdin must be a tty when interactive specified');
+        process.exit(1);
+    }
+
     (function rmdir(cb_err) {
         ifError(cb_err);
 
@@ -79,13 +87,25 @@ function printEntry(obj) {
             }
 
             if (info.extension !== 'directory') {
-                console.error(p + ' is not a directory');
+                console.error('%s is not a directory', p);
                 process.exit(1);
             }
 
-            client.unlink(p, function (err2) {
-                ifError(err2);
-                process.exit(0);
+            if (!options.interactive) {
+                client.unlink(p, rmdir);
+                return;
+            }
+
+            manta.promptConfirm(f('remove directory `%s` [y/N]?: ', p),
+                function (ans) {
+
+                if (!ans) {
+                    // skip removing this file
+                    rmdir();
+                    return;
+                }
+
+                client.unlink(p, rmdir);
             });
         });
     })();
diff --git a/docs/man/mrm.md b/docs/man/mrm.md
index 0ee9411..36a9d07 100644
--- a/docs/man/mrm.md
+++ b/docs/man/mrm.md
@@ -1,4 +1,4 @@
-mrm 1 "May 2013" Manta "Manta Commands"
+mrm 1 "August 2018" Manta "Manta Commands"
 =======================================
 
 NAME
@@ -37,6 +37,9 @@ OPTIONS
   SSL connections are attempted to be made secure by using the CA certificate
   bundle installed by default.
 
+`-I, --interactive`
+  Confirm before deleting objects.
+
 `-k, --key fingerprint`
   Authenticate using the SSH key described by FINGERPRINT.  The key must
   either be in `~/.ssh` or loaded in the SSH agent via `ssh-add`.
diff --git a/docs/man/mrmdir.md b/docs/man/mrmdir.md
index d68e55d..db4c894 100644
--- a/docs/man/mrmdir.md
+++ b/docs/man/mrmdir.md
@@ -1,4 +1,4 @@
-mrmdir 1 "May 2013" Manta "Manta Commands"
+mrmdir 1 "August 2018" Manta "Manta Commands"
 =======================================
 
 NAME
@@ -35,6 +35,9 @@ OPTIONS
   SSL connections are attempted to be made secure by using the CA certificate
   bundle installed by default.
 
+`-I, --interactive`
+  Confirm before deleting directories.
+
 `-k, --key fingerprint`
   Authenticate using the SSH key described by FINGERPRINT.  The key must
   either be in `~/.ssh` or loaded in the SSH agent via `ssh-add`.
diff --git a/lib/index.js b/lib/index.js
index ef4d665..fa56668 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -40,5 +40,6 @@ module.exports = {
     path: manta.path,
     jobPath: manta.jobPath,
     escapePath: utils.escapePath,
-    parseOptions: options.parseOptions
+    parseOptions: options.parseOptions,
+    promptConfirm: utils.promptConfirm
 };
diff --git a/lib/utils.js b/lib/utils.js
index f3b55a9..3dddb69 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -1,11 +1,14 @@
 // Copyright (c) 2018, Joyent, Inc. All rights reserved.
 
 var assert = require('assert-plus');
+var readline = require('readline');
+
 var manta = require('./client');
 
 module.exports = {
     assertPath: assertPath,
-    escapePath: escapePath
+    escapePath: escapePath,
+    promptConfirm: promptConfirm
 };
 
 function escapePath(s) {
@@ -25,3 +28,19 @@ function assertPath(p, noThrow) {
     }
     return (null);
 }
+
+function promptConfirm(msg, cb) {
+    assert.string(msg, 'msg');
+    assert.func(cb, 'cb');
+    assert(process.stdin.isTTY, 'stdin must be a TTY');
+
+    var rl = readline.createInterface({
+        input: process.stdin,
+        output: process.stdout
+    });
+
+    rl.question(msg, function (ans) {
+        rl.close();
+        cb(ans === 'y' || ans === 'Y');
+    });
+}
diff --git a/man/man1/mrm.1 b/man/man1/mrm.1
index dc0a994..1e70afc 100644
--- a/man/man1/mrm.1
+++ b/man/man1/mrm.1
@@ -1,4 +1,4 @@
-.TH mrm 1 "May 2013" Manta "Manta Commands"
+.TH mrm 1 "August 2018" Manta "Manta Commands"
 .SH NAME
 .PP
 mrm \- remove objects or directories
@@ -30,6 +30,9 @@ This option explicitly allows "insecure" SSL connections and transfers.  All
 SSL connections are attempted to be made secure by using the CA certificate
 bundle installed by default.
 .TP
+\fB\fC\-I, \-\-interactive\fR
+Confirm before deleting objects.
+.TP
 \fB\fC\-k, \-\-key fingerprint\fR
 Authenticate using the SSH key described by FINGERPRINT.  The key must
 either be in \fB\fC~/.ssh\fR or loaded in the SSH agent via \fB\fCssh\-add\fR\&.
diff --git a/man/man1/mrmdir.1 b/man/man1/mrmdir.1
index 81651b2..3a149d0 100644
--- a/man/man1/mrmdir.1
+++ b/man/man1/mrmdir.1
@@ -1,4 +1,4 @@
-.TH mrmdir 1 "May 2013" Manta "Manta Commands"
+.TH mrmdir 1 "August 2018" Manta "Manta Commands"
 .SH NAME
 .PP
 mrmdir \- remove empty directories
@@ -28,6 +28,9 @@ This option explicitly allows "insecure" SSL connections and transfers.  All
 SSL connections are attempted to be made secure by using the CA certificate
 bundle installed by default.
 .TP
+\fB\fC\-I, \-\-interactive\fR
+Confirm before deleting directories.
+.TP
 \fB\fC\-k, \-\-key fingerprint\fR
 Authenticate using the SSH key described by FINGERPRINT.  The key must
 either be in \fB\fC~/.ssh\fR or loaded in the SSH agent via \fB\fCssh\-add\fR\&.
diff --git a/test/lib/utils.js b/test/lib/utils.js
new file mode 100644
index 0000000..cf2658b
--- /dev/null
+++ b/test/lib/utils.js
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var path = require('path');
+
+var forkExecWait = require('forkexec').forkExecWait;
+
+var BINDIR = path.resolve(__dirname, '../../bin');
+var MLS = path.resolve(BINDIR, 'mls');
+
+/*
+ * Call `mls` on the given path and return a JSON array of objects for each
+ * object/directory found, or an error
+ */
+function mls(p, cb) {
+    assert.string(p, 'p');
+    assert.func(cb, 'cb');
+
+    forkExecWait({
+        argv: [MLS, '-j', p]
+    }, function (err, info) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var out = info.stdout.trim();
+        if (out.length === 0) {
+            cb(null, []);
+            return;
+        }
+
+        var files;
+        try {
+            files = out.split('\n').map(function (j) {
+                return (JSON.parse(j));
+            });
+        } catch (e) {
+            cb(e);
+            return;
+        }
+
+        cb(null, files);
+    });
+}
+
+module.exports.mls = mls;
diff --git a/test/mrm.test.js b/test/mrm.test.js
new file mode 100644
index 0000000..1cb3988
--- /dev/null
+++ b/test/mrm.test.js
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Test the "mrm" command.
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var forkExecWait = require('forkexec').forkExecWait;
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var utils = require('./lib/utils');
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MPUT = path.resolve(BINDIR, 'mput');
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mrm-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+
+var NUMSUBDIRS = 5;
+var SUBDIRS = [];
+var OBJECTS = [];
+var TMPFILE = '/var/tmp/node-manta-mrm-test-tmp-file-' + process.pid;
+
+fs.writeFileSync(TMPFILE, 'foo');
+
+for (var i = 0; i < NUMSUBDIRS; i++) {
+    SUBDIRS.push(path.join(TESTDIR, 'dir' + i.toString()));
+    OBJECTS.push(path.join(TESTDIR, 'object' + i.toString()));
+}
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+function safePath(p) {
+    assert.string(p);
+    assert(p.indexOf('node-manta-test') !== -1);
+}
+
+// ---- tests
+test('setup: create test tree at ' + TESTDIR, function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // create the test directory
+            forkExecWait({
+                argv: [MMKDIR, TESTDIR]
+            }, cb);
+        },
+        function (_, cb) {
+            // create sub directories
+            forkExecWait({
+                argv: [MMKDIR].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            // create objects
+            vasync.forEachPipeline({
+                inputs: OBJECTS,
+                func: function (input, cb2) {
+                    forkExecWait({
+                        argv: [MPUT, '-f', TMPFILE, input]
+                    }, cb2);
+                }
+            }, cb);
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrm (no arguments)', function (t) {
+    forkExecWait({
+        argv: [MRM]
+    }, function (err, info) {
+        t.ok(err, 'mrm should fail');
+        t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
+        t.done();
+    });
+});
+
+test('mrm -I fails without tty', function (t) {
+    forkExecWait({
+        argv: [MRM, '-I', TESTDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrm should fail');
+        t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
+        t.done();
+    });
+});
+
+test('mrm 1 directory', function (t) {
+    var p = SUBDIRS.pop();
+
+    safePath(p);
+
+    forkExecWait({
+        argv: [MRM, '-r', p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining directories', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var dirs = list.filter(function (o) {
+                    return (o.type === 'directory');
+                });
+
+                t.equal(dirs.length, SUBDIRS.length, 'remaining dirs');
+                cb();
+            });
+        },
+        function (_, cb) {
+            SUBDIRS.forEach(function (subdir) {
+                safePath(subdir);
+            });
+
+            forkExecWait({
+                argv: [MRM, '-r'].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var dirs = list.filter(function (o) {
+                    return (o.type === 'directory');
+                });
+
+                t.equal(dirs.length, 0, '0 remaining dirs');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrm 1 object', function (t) {
+    var p = OBJECTS.pop();
+
+    safePath(p);
+
+    forkExecWait({
+        argv: [MRM, p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining objects', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, OBJECTS.length, 'remaining objects');
+                cb();
+            });
+        },
+        function (_, cb) {
+            OBJECTS.forEach(function (object) {
+                safePath(object);
+            });
+
+            forkExecWait({
+                argv: [MRM].concat(OBJECTS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, 0, '0 remaining objects');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('ensure test tree is empty', function (t) {
+    utils.mls(TESTDIR, function (err, list) {
+        if (err) {
+            t.ifError(err, err);
+            t.done();
+            return;
+        }
+
+        t.equal(list.length, 0, '0 remaining entities');
+        t.done();
+    });
+});
+
+test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    // Sanity checks that we don't `mrm -r` a non-test dir.
+    safePath(TESTDIR);
+
+    forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
diff --git a/test/mrmdir.test.js b/test/mrmdir.test.js
new file mode 100644
index 0000000..fb4fc86
--- /dev/null
+++ b/test/mrmdir.test.js
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Test the "mrmdir" command.
+ */
+
+var assert = require('assert-plus');
+var forkExecWait = require('forkexec').forkExecWait;
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var utils = require('./lib/utils');
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MRMDIR = path.resolve(BINDIR, 'mrmdir');
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mrmdir-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+
+var NUMSUBDIRS = 5;
+var SUBDIRS = [];
+for (var i = 0; i < NUMSUBDIRS; i++) {
+    SUBDIRS.push(path.join(TESTDIR, i.toString()));
+}
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+// ---- tests
+test('setup: create test tree at ' + TESTDIR, function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // create the test directory
+            forkExecWait({
+                argv: [MMKDIR, TESTDIR]
+            }, cb);
+        },
+        function (_, cb) {
+            // create sub directories
+            forkExecWait({
+                argv: [MMKDIR].concat(SUBDIRS)
+            }, cb);
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrmdir (no arguments)', function (t) {
+    forkExecWait({
+        argv: [MRMDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrmdir should fail');
+        t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
+        t.done();
+    });
+});
+
+test('mrmdir -I fails without tty', function (t) {
+    forkExecWait({
+        argv: [MRMDIR, '-I', TESTDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrmdir should fail');
+        t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
+        t.done();
+    });
+});
+
+test('mrmdir 1 directory', function (t) {
+    var p = SUBDIRS.pop();
+
+    forkExecWait({
+        argv: [MRMDIR, p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining directories', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, files) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                t.equal(files.length, SUBDIRS.length, 'remaining dirs');
+                cb();
+            });
+        },
+        function (_, cb) {
+            forkExecWait({
+                argv: [MRMDIR].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, 0, '0 remaining objects');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('ensure test tree is empty', function (t) {
+    utils.mls(TESTDIR, function (err, list) {
+        if (err) {
+            t.ifError(err, err);
+            t.done();
+            return;
+        }
+
+        t.equal(list.length, 0, '0 remaining entities');
+        t.done();
+    });
+});
+
+test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    // Sanity checks that we don't `mrm -r` a non-test dir.
+    assert.ok(TESTDIR);
+    assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
+
+    forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
-- 
2.21.0

