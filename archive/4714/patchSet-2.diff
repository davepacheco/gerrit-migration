commit 1d825a9b1710e54d27dfead94646c0f226f77ce7 (refs/changes/14/4714/2)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2018-08-17T13:34:34-04:00 (1 year, 2 months ago)
    
    joyent/node-manta#335 Want option to confim removal of files for `mrm`

diff --git a/bin/mrm b/bin/mrm
index 3e6efdf..715cc28 100755
--- a/bin/mrm
+++ b/bin/mrm
@@ -4,8 +4,9 @@
  * Copyright 2018 Joyent, Inc.
  */
 
+var f = require('util').format;
 var path = require('path');
-var url = require('url');
+var readline = require('readline');
 
 var bunyan = require('bunyan');
 var dashdash = require('dashdash');
@@ -20,6 +21,11 @@ function optionsParser(name) {
             {
                 group: name + ' options'
             },
+            {
+                names: ['interactive', 'I'],
+                type: 'bool',
+                help: 'confirm before deleting objects'
+            },
             {
                 names: ['parallel', 'p'],
                 type: 'positiveInteger',
@@ -46,12 +52,6 @@ function ifError(err) {
     }
 }
 
-
-function printEntry(obj) {
-    console.log('%j', obj);
-}
-
-
 ///--- Mainline
 
 (function main() {
@@ -70,10 +70,33 @@ function printEntry(obj) {
         log: log
     };
     var options = manta.parseOptions(parseArgs);
-
-
     var client = manta.createBinClient(options);
     var i = -1;
+    var rl;
+
+    if (options.interactive) {
+        if (!process.stdin.isTTY) {
+            console.error('stdin must be a tty when interactive specified');
+            process.exit(1);
+        }
+        rl = readline.createInterface({
+            input: process.stdin,
+            output: process.stdout
+        });
+    }
+
+    function promptConfirm(msg, cb) {
+        // if rl is not defined then we are not running in interactive mode,
+        // assume yes for all confirmations
+        if (!rl) {
+            cb(true);
+            return;
+        }
+
+        rl.question(msg, function (ans) {
+            cb(ans === 'y' || ans === 'Y');
+        });
+    }
 
     (function rm(cb_err) {
         ifError(cb_err);
@@ -81,6 +104,9 @@ function printEntry(obj) {
         var p = options.paths[++i];
         if (!p) {
             client.close();
+            if (rl) {
+                rl.close();
+            }
             return;
         }
 
@@ -96,7 +122,17 @@ function printEntry(obj) {
 
             if (info.extension === 'directory') {
                 if (options.recursive) {
-                    client.rmr(p, options, rm);
+                    promptConfirm(
+                        f('recursively remove directory `%s` [y/N]?: ', p),
+                        function (ans) {
+
+                        if (!ans) {
+                            rm();
+                            return;
+                        }
+
+                        client.rmr(p, options, rm);
+                    });
                 } else {
                     console.error(p + ' is not an object');
                     process.exit(1);
@@ -104,7 +140,14 @@ function printEntry(obj) {
                 return;
             }
 
-            client.unlink(p, rm);
+            promptConfirm(f('remove object `%s` [y/N]?: ', p), function (ans) {
+                if (!ans) {
+                    rm();
+                    return;
+                }
+
+                client.unlink(p, rm);
+            });
         });
     })();
 })();
diff --git a/bin/mrmdir b/bin/mrmdir
index 83393aa..0c035ab 100755
--- a/bin/mrmdir
+++ b/bin/mrmdir
@@ -4,8 +4,9 @@
  * Copyright 2018 Joyent, Inc.
  */
 
+var f = require('util').format;
 var path = require('path');
-var url = require('url');
+var readline = require('readline');
 
 var bunyan = require('bunyan');
 var dashdash = require('dashdash');
@@ -17,7 +18,16 @@ var manta = require('../lib');
 
 function optionsParser(name) {
     var parser = dashdash.createParser({
-        options: manta.DEFAULT_CLI_OPTIONS
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['interactive', 'I'],
+                type: 'bool',
+                help: 'confirm before deleting objects'
+            }
+        ])
     });
 
     return (parser);
@@ -31,12 +41,6 @@ function ifError(err) {
     }
 }
 
-
-function printEntry(obj) {
-    console.log('%j', obj);
-}
-
-
 ///--- Mainline
 
 (function main() {
@@ -55,9 +59,33 @@ function printEntry(obj) {
         log: log
     };
     var options = manta.parseOptions(parseArgs);
-
     var client = manta.createBinClient(options);
     var i = -1;
+    var rl;
+
+    if (options.interactive) {
+        if (!process.stdin.isTTY) {
+            console.error('stdin must be a tty when interactive specified');
+            process.exit(1);
+        }
+        rl = readline.createInterface({
+            input: process.stdin,
+            output: process.stdout
+        });
+    }
+
+    function promptConfirm(msg, cb) {
+        // if rl is not defined then we are not running in interactive mode,
+        // assume yes for all confirmations
+        if (!rl) {
+            cb(true);
+            return;
+        }
+
+        rl.question(msg, function (ans) {
+            cb(ans === 'y' || ans === 'Y');
+        });
+    }
 
     (function rmdir(cb_err) {
         ifError(cb_err);
@@ -65,6 +93,9 @@ function printEntry(obj) {
         var p = options.paths[++i];
         if (!p) {
             client.close();
+            if (rl) {
+                rl.close();
+            }
             return;
         }
 
@@ -83,9 +114,13 @@ function printEntry(obj) {
                 process.exit(1);
             }
 
-            client.unlink(p, function (err2) {
-                ifError(err2);
-                process.exit(0);
+            promptConfirm(f('remove directory `%s` [y/N]?: ', p), function (ans) {
+                if (!ans) {
+                    rmdir();
+                    return;
+                }
+
+                client.unlink(p, rmdir);
             });
         });
     })();
diff --git a/docs/man/mrm.md b/docs/man/mrm.md
index 0ee9411..36a9d07 100644
--- a/docs/man/mrm.md
+++ b/docs/man/mrm.md
@@ -1,4 +1,4 @@
-mrm 1 "May 2013" Manta "Manta Commands"
+mrm 1 "August 2018" Manta "Manta Commands"
 =======================================
 
 NAME
@@ -37,6 +37,9 @@ OPTIONS
   SSL connections are attempted to be made secure by using the CA certificate
   bundle installed by default.
 
+`-I, --interactive`
+  Confirm before deleting objects.
+
 `-k, --key fingerprint`
   Authenticate using the SSH key described by FINGERPRINT.  The key must
   either be in `~/.ssh` or loaded in the SSH agent via `ssh-add`.
diff --git a/docs/man/mrmdir.md b/docs/man/mrmdir.md
index d68e55d..2a673f6 100644
--- a/docs/man/mrmdir.md
+++ b/docs/man/mrmdir.md
@@ -1,4 +1,4 @@
-mrmdir 1 "May 2013" Manta "Manta Commands"
+mrmdir 1 "August 2018" Manta "Manta Commands"
 =======================================
 
 NAME
@@ -35,6 +35,9 @@ OPTIONS
   SSL connections are attempted to be made secure by using the CA certificate
   bundle installed by default.
 
+`-I, --interactive`
+  Confirm before deleting objects.
+
 `-k, --key fingerprint`
   Authenticate using the SSH key described by FINGERPRINT.  The key must
   either be in `~/.ssh` or loaded in the SSH agent via `ssh-add`.
diff --git a/man/man1/mrm.1 b/man/man1/mrm.1
index dc0a994..1e70afc 100644
--- a/man/man1/mrm.1
+++ b/man/man1/mrm.1
@@ -1,4 +1,4 @@
-.TH mrm 1 "May 2013" Manta "Manta Commands"
+.TH mrm 1 "August 2018" Manta "Manta Commands"
 .SH NAME
 .PP
 mrm \- remove objects or directories
@@ -30,6 +30,9 @@ This option explicitly allows "insecure" SSL connections and transfers.  All
 SSL connections are attempted to be made secure by using the CA certificate
 bundle installed by default.
 .TP
+\fB\fC\-I, \-\-interactive\fR
+Confirm before deleting objects.
+.TP
 \fB\fC\-k, \-\-key fingerprint\fR
 Authenticate using the SSH key described by FINGERPRINT.  The key must
 either be in \fB\fC~/.ssh\fR or loaded in the SSH agent via \fB\fCssh\-add\fR\&.
diff --git a/man/man1/mrmdir.1 b/man/man1/mrmdir.1
index 81651b2..cdfd766 100644
--- a/man/man1/mrmdir.1
+++ b/man/man1/mrmdir.1
@@ -1,4 +1,4 @@
-.TH mrmdir 1 "May 2013" Manta "Manta Commands"
+.TH mrmdir 1 "August 2018" Manta "Manta Commands"
 .SH NAME
 .PP
 mrmdir \- remove empty directories
@@ -28,6 +28,9 @@ This option explicitly allows "insecure" SSL connections and transfers.  All
 SSL connections are attempted to be made secure by using the CA certificate
 bundle installed by default.
 .TP
+\fB\fC\-I, \-\-interactive\fR
+Confirm before deleting objects.
+.TP
 \fB\fC\-k, \-\-key fingerprint\fR
 Authenticate using the SSH key described by FINGERPRINT.  The key must
 either be in \fB\fC~/.ssh\fR or loaded in the SSH agent via \fB\fCssh\-add\fR\&.
diff --git a/test/lib/utils.js b/test/lib/utils.js
new file mode 100644
index 0000000..f0d2dbc
--- /dev/null
+++ b/test/lib/utils.js
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var path = require('path');
+
+var forkExecWait = require('forkexec').forkExecWait;
+
+var BINDIR = path.resolve(__dirname, '../../bin');
+var MLS = path.resolve(BINDIR, 'mls');
+
+/*
+ * Call `mls` on the given path and return a JSON array of objects for each
+ * object/directory found, or an error
+ */
+function mls(p, cb) {
+    assert.string(p, 'p');
+    assert.func(cb, 'cb');
+
+    forkExecWait({
+        argv: [MLS, '-j', p]
+    }, function (err, info) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var out = info.stdout.trim();
+        if (out.length === 0) {
+            cb(null, []);
+            return;
+        }
+
+        var files;
+        try {
+            files = info.stdout.trim().split('\n').map(function (j) {
+                return (JSON.parse(j));
+            });
+        } catch (e) {
+            cb(e);
+            return;
+        }
+
+        cb(null, files);
+    });
+}
+
+module.exports.mls = mls;
diff --git a/test/mrm.test.js b/test/mrm.test.js
new file mode 100644
index 0000000..1cb3988
--- /dev/null
+++ b/test/mrm.test.js
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Test the "mrm" command.
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var forkExecWait = require('forkexec').forkExecWait;
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var utils = require('./lib/utils');
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MPUT = path.resolve(BINDIR, 'mput');
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mrm-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+
+var NUMSUBDIRS = 5;
+var SUBDIRS = [];
+var OBJECTS = [];
+var TMPFILE = '/var/tmp/node-manta-mrm-test-tmp-file-' + process.pid;
+
+fs.writeFileSync(TMPFILE, 'foo');
+
+for (var i = 0; i < NUMSUBDIRS; i++) {
+    SUBDIRS.push(path.join(TESTDIR, 'dir' + i.toString()));
+    OBJECTS.push(path.join(TESTDIR, 'object' + i.toString()));
+}
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+function safePath(p) {
+    assert.string(p);
+    assert(p.indexOf('node-manta-test') !== -1);
+}
+
+// ---- tests
+test('setup: create test tree at ' + TESTDIR, function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // create the test directory
+            forkExecWait({
+                argv: [MMKDIR, TESTDIR]
+            }, cb);
+        },
+        function (_, cb) {
+            // create sub directories
+            forkExecWait({
+                argv: [MMKDIR].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            // create objects
+            vasync.forEachPipeline({
+                inputs: OBJECTS,
+                func: function (input, cb2) {
+                    forkExecWait({
+                        argv: [MPUT, '-f', TMPFILE, input]
+                    }, cb2);
+                }
+            }, cb);
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrm (no arguments)', function (t) {
+    forkExecWait({
+        argv: [MRM]
+    }, function (err, info) {
+        t.ok(err, 'mrm should fail');
+        t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
+        t.done();
+    });
+});
+
+test('mrm -I fails without tty', function (t) {
+    forkExecWait({
+        argv: [MRM, '-I', TESTDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrm should fail');
+        t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
+        t.done();
+    });
+});
+
+test('mrm 1 directory', function (t) {
+    var p = SUBDIRS.pop();
+
+    safePath(p);
+
+    forkExecWait({
+        argv: [MRM, '-r', p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining directories', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var dirs = list.filter(function (o) {
+                    return (o.type === 'directory');
+                });
+
+                t.equal(dirs.length, SUBDIRS.length, 'remaining dirs');
+                cb();
+            });
+        },
+        function (_, cb) {
+            SUBDIRS.forEach(function (subdir) {
+                safePath(subdir);
+            });
+
+            forkExecWait({
+                argv: [MRM, '-r'].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var dirs = list.filter(function (o) {
+                    return (o.type === 'directory');
+                });
+
+                t.equal(dirs.length, 0, '0 remaining dirs');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrm 1 object', function (t) {
+    var p = OBJECTS.pop();
+
+    safePath(p);
+
+    forkExecWait({
+        argv: [MRM, p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining objects', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, OBJECTS.length, 'remaining objects');
+                cb();
+            });
+        },
+        function (_, cb) {
+            OBJECTS.forEach(function (object) {
+                safePath(object);
+            });
+
+            forkExecWait({
+                argv: [MRM].concat(OBJECTS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, 0, '0 remaining objects');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('ensure test tree is empty', function (t) {
+    utils.mls(TESTDIR, function (err, list) {
+        if (err) {
+            t.ifError(err, err);
+            t.done();
+            return;
+        }
+
+        t.equal(list.length, 0, '0 remaining entities');
+        t.done();
+    });
+});
+
+test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    // Sanity checks that we don't `mrm -r` a non-test dir.
+    safePath(TESTDIR);
+
+    forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
diff --git a/test/mrmdir.test.js b/test/mrmdir.test.js
new file mode 100644
index 0000000..fb4fc86
--- /dev/null
+++ b/test/mrmdir.test.js
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Test the "mrmdir" command.
+ */
+
+var assert = require('assert-plus');
+var forkExecWait = require('forkexec').forkExecWait;
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var utils = require('./lib/utils');
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MRMDIR = path.resolve(BINDIR, 'mrmdir');
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mrmdir-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+
+var NUMSUBDIRS = 5;
+var SUBDIRS = [];
+for (var i = 0; i < NUMSUBDIRS; i++) {
+    SUBDIRS.push(path.join(TESTDIR, i.toString()));
+}
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+// ---- tests
+test('setup: create test tree at ' + TESTDIR, function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            // create the test directory
+            forkExecWait({
+                argv: [MMKDIR, TESTDIR]
+            }, cb);
+        },
+        function (_, cb) {
+            // create sub directories
+            forkExecWait({
+                argv: [MMKDIR].concat(SUBDIRS)
+            }, cb);
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('mrmdir (no arguments)', function (t) {
+    forkExecWait({
+        argv: [MRMDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrmdir should fail');
+        t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
+        t.done();
+    });
+});
+
+test('mrmdir -I fails without tty', function (t) {
+    forkExecWait({
+        argv: [MRMDIR, '-I', TESTDIR]
+    }, function (err, info) {
+        t.ok(err, 'mrmdir should fail');
+        t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
+        t.done();
+    });
+});
+
+test('mrmdir 1 directory', function (t) {
+    var p = SUBDIRS.pop();
+
+    forkExecWait({
+        argv: [MRMDIR, p]
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('remove remaining directories', function (t) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, files) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                t.equal(files.length, SUBDIRS.length, 'remaining dirs');
+                cb();
+            });
+        },
+        function (_, cb) {
+            forkExecWait({
+                argv: [MRMDIR].concat(SUBDIRS)
+            }, cb);
+        },
+        function (_, cb) {
+            utils.mls(TESTDIR, function (err, list) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                var objects = list.filter(function (o) {
+                    return (o.type === 'object');
+                });
+
+                t.equal(objects.length, 0, '0 remaining objects');
+                cb();
+            });
+        }
+    ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+test('ensure test tree is empty', function (t) {
+    utils.mls(TESTDIR, function (err, list) {
+        if (err) {
+            t.ifError(err, err);
+            t.done();
+            return;
+        }
+
+        t.equal(list.length, 0, '0 remaining entities');
+        t.done();
+    });
+});
+
+test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    // Sanity checks that we don't `mrm -r` a non-test dir.
+    assert.ok(TESTDIR);
+    assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
+
+    forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
