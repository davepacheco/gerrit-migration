From 2ce540dc32c8c788f04e21e2f41f202e72ea91c4 Mon Sep 17 00:00:00 2001
From: Bryan Cantrill <bryan@joyent.com>
Date: Fri, 18 Nov 2016 21:28:41 +0000
Subject: [PATCH] joyent/node-kstat#11 reimplement node-kstat to be in terms of
 v8plus

---
 LICENSE             |    3 +-
 Makefile            |   48 +++
 Makefile.check.targ |  173 ++++++++
 binding.gyp         |   11 -
 examples/filter.js  |   94 ----
 examples/kstat.js   |   28 +-
 examples/mpstat.js  |   10 +-
 kstat.c             |  613 ++++++++++++++++++++++++++
 kstat.cc            |  764 ---------------------------------
 package.json        |   14 +-
 test/basic.js       |  133 ++++++
 test/close.js       |   26 ++
 test/filter.js      |   92 ++++
 tools/bashstyle     |  175 ++++++++
 tools/cstyle.pl     | 1002 +++++++++++++++++++++++++++++++++++++++++++
 tools/jsl.node.conf |  139 ++++++
 tools/jsstyle       |  967 +++++++++++++++++++++++++++++++++++++++++
 tools/multinode     |  365 ++++++++++++++++
 wscript             |   17 -
 19 files changed, 3766 insertions(+), 908 deletions(-)
 create mode 100644 Makefile
 create mode 100644 Makefile.check.targ
 delete mode 100644 binding.gyp
 delete mode 100644 examples/filter.js
 create mode 100644 kstat.c
 delete mode 100644 kstat.cc
 create mode 100644 test/basic.js
 create mode 100644 test/close.js
 create mode 100644 test/filter.js
 create mode 100755 tools/bashstyle
 create mode 100755 tools/cstyle.pl
 create mode 100644 tools/jsl.node.conf
 create mode 100755 tools/jsstyle
 create mode 100755 tools/multinode
 delete mode 100644 wscript

diff --git a/LICENSE b/LICENSE
index a5a8730..d91b319 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,5 @@
-Copyright 2010 Bryan Cantrill. All rights reserved.
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
+
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..bc342c2
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,48 @@
+#
+# Copyright (c) 2016 Joyent, Inc.  All rights reserved.
+#
+
+PREFIX_NODE :=	$(shell dirname $$(bash -c 'hash node; hash -t node'))/..
+V8PLUS :=       $(shell $(PREFIX_NODE)/bin/node -e 'require("v8plus");')
+BIT :=		$(shell file $$(which node) | awk '{ print $$3 }' | cut -d- -f1)
+
+include $(V8PLUS)/Makefile.v8plus.defs
+
+MODULE =	kstat
+MODULE_DIR =	.
+
+SRCS =	\
+		kstat.c
+
+ERRNO_JSON =	errno.json
+
+CC =		/opt/local/bin/gcc
+CXX =		/opt/local/bin/g++
+
+#
+# v8plus assumes the presence of ctfconvert and ctfmerge, which is about as
+# practical as requiring a Sun Microsystems badge number; we set these to be
+# /bin/true to override this behavior.
+#
+CTFCONVERT =	/bin/true
+CTFMERGE =	/bin/true
+
+CFLAGS +=	-pthread -D__EXTENSIONS__ -DV8PLUS_NEW_API -D_REENTRANT -m$(BIT)
+
+CXXFLAGS +=	-m$(BIT)
+
+LIBS +=		-lumem -lkstat -m$(BIT)
+
+JSSTYLE = 	./tools/jsstyle
+BASH_FILES =	./tools/multinode
+JSSTYLE_FILES =	$(shell find test examples -name "*.js")
+
+JSL_CONF_NODE =	./tools/jsl.node.conf
+JSL_FILES_NODE = $(shell find test examples -name "*.js")
+
+CSTYLE = 	./tools/cstyle.pl
+CSTYLE_FILES =	$(SRCS)
+
+include $(V8PLUS)/Makefile.v8plus.targ
+include Makefile.check.targ
+
diff --git a/Makefile.check.targ b/Makefile.check.targ
new file mode 100644
index 0000000..cbf5951
--- /dev/null
+++ b/Makefile.check.targ
@@ -0,0 +1,173 @@
+# -*- mode: makefile -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2016, Joyent, Inc.
+#
+
+#
+# Makefile.check.targ: common check targets.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This Makefile defines several useful targets and rules. You can use it by
+# including it from a Makefile that specifies some of the variables below.
+#
+# Targets defined in this Makefile:
+#
+#	check	Checks JavaScript files for lint and style
+#		Checks bash scripts for syntax
+#		Checks SMF manifests for validity against the SMF DTD
+#
+
+# For details on what this target is supposed to do, see the Joyent
+# Engineering Guide.
+#
+# To make use of these targets, you'll need to set some of these variables. Any
+# variables left unset will simply not be used.
+#
+#	BASH_FILES	Bash scripts to check for syntax
+#			(paths relative to top-level Makefile)
+#
+#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
+#	JSL_CONF_WEB	(paths relative to top-level Makefile)
+#
+#			Node.js and Web configuration files are separate
+#			because you'll usually want different global variable
+#			configurations.  If no file is specified, none is given
+#			to jsl, which causes it to use a default configuration,
+#			which probably isn't what you want.
+#
+#	JSL_FILES_NODE	JavaScript files to check with Node config file.
+#	JSL_FILES_WEB	JavaScript files to check with Web config file.
+#
+#	JSON_FILES	JSON files to be validated
+#
+#	JSSTYLE_FILES	JavaScript files to be style-checked
+#
+# You can also override these variables:
+#
+#	BASH		Path to bash (default: "bash")
+#
+#	JSL		Path to JavaScriptLint (default: "jsl")
+#
+#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
+#	JSL_FLAGS_WEB
+#	JSL_FLAGS
+#
+#	JSON		Path to json tool (default: "json")
+#
+#	JSSTYLE		Path to jsstyle (default: "jsstyle")
+#
+#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
+#
+
+#
+# Defaults for the various tools we use.
+#
+BASH		?= bash
+BASHSTYLE	?= tools/bashstyle
+JSL		?= jsl
+JSON		?= json
+JSSTYLE		?= jsstyle
+JSL_FLAGS  	?= --nologo --nosummary
+CSTYLE		?= cstyle
+
+#
+# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
+#
+ifneq ($(origin JSL_CONF_NODE), undefined)
+	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
+endif
+
+ifneq ($(origin JSL_CONF_WEB), undefined)
+	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
+endif
+
+#
+# Targets. For descriptions on what these are supposed to do, see the
+# Joyent Engineering Guide.
+#
+
+#
+# Instruct make to keep around temporary files. We have rules below that
+# automatically update git submodules as needed, but they employ a deps/*/.git
+# temporary file. Without this directive, make tries to remove these .git
+# directories after the build has completed.
+#
+.SECONDARY: $($(wildcard deps/*):%=%/.git)
+
+#
+# This rule enables other rules that use files from a git submodule to have
+# those files depend on deps/module/.git and have "make" automatically check
+# out the submodule as needed.
+#
+deps/%/.git:
+	git submodule update --init deps/$*
+
+#
+# These recipes make heavy use of dynamically-created phony targets. The parent
+# Makefile defines a list of input files like BASH_FILES. We then say that each
+# of these files depends on a fake target called filename.bashchk, and then we
+# define a pattern rule for those targets that runs bash in check-syntax-only
+# mode. This mechanism has the nice properties that if you specify zero files,
+# the rule becomes a noop (unlike a single rule to check all bash files, which
+# would invoke bash with zero files), and you can check individual files from
+# the command line with "make filename.bashchk".
+#
+.PHONY: check-bash
+check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
+
+%.bashchk: %
+	$(BASH) -n $^
+
+%.bashstyle: %
+	$(BASHSTYLE) $^
+
+.PHONY: check-json
+check-json: $(JSON_FILES:%=%.jsonchk)
+
+%.jsonchk: %
+	$(JSON) --validate -f $^
+
+#
+# The above approach can be slow when there are many files to check because it
+# requires that "make" invoke the check tool once for each file, rather than
+# passing in several files at once.  For the JavaScript check targets, we define
+# a variable for the target itself *only if* the list of input files is
+# non-empty.  This avoids invoking the tool if there are no files to check.
+#
+JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
+.PHONY: check-jsl-node
+check-jsl-node: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
+
+JSL_WEB_TARGET = $(if $(JSL_FILES_WEB), check-jsl-web)
+.PHONY: check-jsl-web
+check-jsl-web: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $(JSL_FILES_WEB)
+
+.PHONY: check-jsl
+check-jsl: $(JSL_NODE_TARGET) $(JSL_WEB_TARGET)
+
+JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
+.PHONY: check-jsstyle
+check-jsstyle:  $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
+
+CSTYLE_TARGET = $(if $(CSTYLE_FILES), check-cstyle)
+.PHONY: check-cstyle
+check-cstyle:  $(CSTYLE_EXEC)
+	$(CSTYLE) $(CSTYLE_FILES)
+
+.PHONY: check
+check:: check-jsl check-json $(JSSTYLE_TARGET) check-cstyle check-bash
+	@echo check ok
+
diff --git a/binding.gyp b/binding.gyp
deleted file mode 100644
index 874e610..0000000
--- a/binding.gyp
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  'targets': [
-    {
-      'target_name': 'kstat',
-      'sources': [ 'kstat.cc' ],
-      'libraries': [ '-lkstat' ],
-      'cflags_cc': [ '-Wno-write-strings' ],
-      'cflags_cc!': [ '-fno-exceptions' ],
-    }
-  ]
-}
diff --git a/examples/filter.js b/examples/filter.js
deleted file mode 100644
index 5576df1..0000000
--- a/examples/filter.js
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * filter.js: tests filtering in both the Reader constructor and read().
- */
-
-var assert = require('assert');
-var kstat = require('kstat');
-
-function kstatToIdent(kstat)
-{
-	return ({
-	    'module': kstat['module'],
-	    'name': kstat['name'],
-	    'class': kstat['class'],
-	    'instance': kstat['instance'],
-	});
-}
-
-function identCompare(k1, k2)
-{
-	var key1 = k1['module'] + '.' + k1['name'] + '.' + k1['class'] + '.' +
-	    k1['instance'];
-	var key2 = k2['module'] + '.' + k2['name'] + '.' + k2['class'] + '.' +
-	    k2['instance'];
-	if (key1 < key2)
-		return (-1);
-	if (key1 > key2)
-		return (1);
-	return (0);
-}
-
-var all_reader = new kstat.Reader({});
-var cpu_reader = new kstat.Reader({ 'module': 'cpu' });
-
-/*
- * Test constructor-based filtering.
- */
-var allstats = all_reader.read();
-assert.ok(allstats.length > 0);
-console.log('%d total stats', allstats.length);
-
-var cpustats = cpu_reader.read();
-assert.ok(cpustats.length > 0);
-assert.ok(allstats.length > cpustats.length);
-console.log('%d cpu stats', cpustats.length);
-
-var ncpustats = 0;
-allstats.forEach(function (kstat) {
-	if (kstat['module'] == 'cpu')
-		ncpustats++;
-});
-
-assert.ok(cpustats.length == ncpustats);
-
-
-/*
- * Test read-based filtering.
- */
-var filteredstats = all_reader.read({ 'module': 'cpu' });
-assert.equal(filteredstats.length, ncpustats);
-assert.deepEqual(filteredstats.map(kstatToIdent).sort(identCompare),
-    cpustats.map(kstatToIdent).sort(identCompare));
-
-filteredstats = all_reader.read({ 'instance': 1 });
-assert.ok(filteredstats.length < allstats.length);
-assert.ok(filteredstats.length > 0);
-filteredstats.forEach(
-    function (kstat) { assert.equal(kstat['instance'], 1); });
-console.log('%d stats with instance == 1', filteredstats.length);
-
-filteredstats = all_reader.read({ 'class': 'net' });
-assert.ok(filteredstats.length < allstats.length);
-assert.ok(filteredstats.length > 0);
-filteredstats.forEach(
-    function (kstat) { assert.equal(kstat['class'], 'net'); });
-console.log('%d stats with class == "net"', filteredstats.length);
-
-filteredstats = all_reader.read({ 'name': 'intrstat' });
-assert.ok(filteredstats.length < allstats.length);
-assert.ok(filteredstats.length > 0);
-filteredstats.forEach(
-    function (kstat) { assert.equal(kstat['name'], 'intrstat'); });
-console.log('%d stats with name == "intrstat"', filteredstats.length);
-
-/*
- * Test both kinds of filtering at once.
- */
-filteredstats = cpu_reader.read({ 'instance': 0 });
-assert.ok(filteredstats.length < cpustats.length);
-assert.ok(filteredstats.length > 0);
-filteredstats.forEach(
-    function (kstat) { assert.ok(kstat['instance'] === 0); });
-console.log('%d cpu stats with instance === 0', filteredstats.length);
-
-console.log('test passed');
diff --git a/examples/kstat.js b/examples/kstat.js
index f0311a9..1448260 100644
--- a/examples/kstat.js
+++ b/examples/kstat.js
@@ -5,21 +5,21 @@
  * name and/or instance will be displayed.  If the "-v" option is specified,
  * all fields in the named kstat (and their values) will be printed.
  */
-var sys = require('sys');
 var kstat = require('kstat');
 
 var options = { c: 'class', n: 'name', m: 'module', i: 'instance', v: true };
 var stats = {};
 var verbose = false;
+var i;
 
 for (i = 2; i < process.argv.length; i++) {
 	var arg = process.argv[i];
 	var opt = arg.charAt(1);
 
 	if (arg.charAt(0) != '-' || !opt || !options[opt]) {
-		sys.puts('invalid option "' + arg + '"');
+		console.log('invalid option "' + arg + '"');
 		process.exit(1);
-        }
+	}
 
 	if (opt == 'v') {
 		verbose = true;
@@ -27,7 +27,7 @@ for (i = 2; i < process.argv.length; i++) {
 	}
 
 	if (!(arg = process.argv[++i])) {
-		sys.puts('expected argument for option "' + opt + '"');
+		console.log('expected argument for option "' + opt + '"');
 		process.exit(1);
 	}
 
@@ -38,9 +38,9 @@ if (stats.hasOwnProperty('instance'))
 	stats.instance = parseInt(stats.instance, 10);
 
 var fixed = function (str, len) {
-	var rval = str, i;
+	var rval = str, j;
 
-	for (i = 0; i < len - str.length; i++)
+	for (j = 0; j < len - str.length; j++)
 		rval += ' ';
 
 	return (rval);
@@ -62,8 +62,8 @@ var header = function () {
 
 	for (f in fields)
 		str += fixed(f.toUpperCase(), fields[f]);
-	sys.puts(str);
-}
+	console.log(str);
+};
 
 header();
 
@@ -82,23 +82,23 @@ data.sort(function (l, r) {
 });
 
 for (i = 0; i < data.length; i++) {
-	str = '';
+	var s = '', f;
 
 	for (f in fields)
-		str += fixed(data[i][f], fields[f] + '');
+		s += fixed(data[i][f], fields[f] + '');
 
-	sys.puts(str);
+	console.log(s);
 
 	if (!verbose || !data[i].data)
 		continue;
 
-	sys.puts('|\n+--> ' + fixed('FIELD', 35) + 'VALUE');
+	console.log('|\n+--> ' + fixed('FIELD', 35) + 'VALUE');
 
 	for (f in data[i].data)
-		sys.puts('     ' + fixed(f, 35) + data[i].data[f] + '');
+		console.log('     ' + fixed(f, 35) + data[i].data[f] + '');
 
 	if (i < data.length - 1) {
-		sys.puts('');
+		console.log('');
 		header();
 	}
 }
diff --git a/examples/mpstat.js b/examples/mpstat.js
index 849d56f..9cbbf68 100644
--- a/examples/mpstat.js
+++ b/examples/mpstat.js
@@ -29,9 +29,12 @@ var fields = {
 };
 
 var reader = {};
+var field;
 
-for (f in fields) {
-	for (stat in fields[f]) {
+for (field in fields) {
+	var stat;
+
+	for (stat in fields[field]) {
 		if (reader[stat])
 			continue;
 
@@ -53,7 +56,7 @@ var pad = function (str, len) {
 
 var outputheader = function ()
 {
-	var f, s;
+	var f, s, w;
 	var str = '';
 
 	for (f in fields) {
@@ -75,6 +78,7 @@ var outputcpu = function (now, last)
 {
 	var f, s;
 	var line = '', i;
+	var value;
 
 	for (f in fields) {
 		for (s in fields[f])
diff --git a/kstat.c b/kstat.c
new file mode 100644
index 0000000..63e1734
--- /dev/null
+++ b/kstat.c
@@ -0,0 +1,613 @@
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <thread.h>
+#include <errno.h>
+#include <kstat.h>
+
+#include <node_version.h>
+#include "v8plus_glue.h"
+
+typedef struct kstatjs_stat {
+	kstat_t *ksjs_ksp;		/* underlying kstat */
+	struct kstatjs_stat *ksjs_next;	/* next stat of interest */
+} kstatjs_stat_t;
+
+typedef struct kstatjs {
+	kstat_ctl_t *ksj_ctl;		/* kstat handle */
+	kid_t ksj_kid;			/* kstat chain ID */
+	kstatjs_stat_t *ksj_stats;	/* statistics of interest */
+	char *ksj_module;		/* module name to match, if any */
+	char *ksj_class;		/* class name to match, if any */
+	char *ksj_name;			/* name to match, if any */
+	int ksj_instance;		/* instance to match, or -1 if any */
+} kstatjs_t;
+
+#define	KSTATJS_ASSERT(cond) \
+	if (!(cond)) { \
+		v8plus_panic("kstat assertion failed in %s at line %d: %s\n", \
+		    __FILE__, __LINE__, #cond); \
+	}
+
+static void
+kstatjs_finalize(kstatjs_t *ksj)
+{
+	kstatjs_stat_t *ksjs, *next;
+
+	free(ksj->ksj_module);
+	ksj->ksj_module = NULL;
+
+	free(ksj->ksj_class);
+	ksj->ksj_class = NULL;
+
+	free(ksj->ksj_name);
+	ksj->ksj_name = NULL;
+
+	ksj->ksj_instance = -1;
+
+	if (ksj->ksj_ctl != NULL) {
+		kstat_close(ksj->ksj_ctl);
+		ksj->ksj_ctl = NULL;
+	}
+
+	for (ksjs = ksj->ksj_stats; ksjs != NULL; ksjs = next) {
+		next = ksjs->ksjs_next;
+		free(ksjs);
+	}
+
+	ksj->ksj_stats = NULL;
+}
+
+static void
+kstatjs_dtor(void *op)
+{
+	kstatjs_t *ksj = op;
+
+	kstatjs_finalize(ksj);
+	free(ksj);
+}
+
+static int
+kstatjs_lookup_nvpair(const nvlist_t *arg, const char *str, nvpair_t **nvpp)
+{
+	int err;
+
+	if ((err = nvlist_lookup_nvpair((nvlist_t *)arg, str, nvpp)) != 0) {
+		/*
+		 * Disappointingly, nvlist_lookup_nvpair() conflates the
+		 * EINVAL and ENOENT case -- so we must check for EINVAL here
+		 * and assume that it was actually ENOENT that was intended.
+		 */
+		if (err == EINVAL) {
+			*nvpp = NULL;
+			return (0);
+		}
+
+		(void) v8plus_nverr(err, str);
+		return (-1);
+	}
+
+	return (0);
+}
+
+static int
+kstatjs_parsearg_string(const nvlist_t *arg, const char *str, char **p)
+{
+	nvpair_t *nvp;
+	char *val;
+
+	if (kstatjs_lookup_nvpair(arg, str, &nvp) != 0)
+		return (-1);
+
+	if (nvp == NULL)
+		return (0);
+
+	if (nvpair_type(nvp) != DATA_TYPE_STRING) {
+		(void) v8plus_throw_exception("TypeError",
+		    "illegal kstat specifier (expected string)",
+		    V8PLUS_TYPE_STRING, "field", str,
+		    V8PLUS_TYPE_NONE);
+
+		return (-1);
+	}
+
+	(void) nvpair_value_string(nvp, &val);
+
+	if ((*p = strdup(val)) == NULL)
+		v8plus_panic("kstats_arg_string(): %s", strerror(errno));
+
+	return (0);
+}
+
+static int
+kstatjs_parsearg_int(const nvlist_t *arg, const char *str, int *p)
+{
+	nvpair_t *nvp;
+	double val;
+
+	if (kstatjs_lookup_nvpair(arg, str, &nvp) != 0)
+		return (-1);
+
+	if (nvp == NULL)
+		return (0);
+
+	if (nvpair_type(nvp) != DATA_TYPE_DOUBLE) {
+		(void) v8plus_throw_exception("TypeError",
+		    "illegal kstat specifier (expected number)",
+		    V8PLUS_TYPE_STRING, "field", str,
+		    V8PLUS_TYPE_NONE);
+
+		return (-1);
+	}
+
+	(void) nvpair_value_double(nvp, &val);
+
+	*p = (int)val;
+
+	return (0);
+}
+
+static int
+kstatjs_parsearg(const nvlist_t *args, char **modulep,
+    char **classp, char **namep, int *instancep)
+{
+	nvpair_t *arg0, *arg1;
+	nvlist_t *arg;
+
+	*modulep = *classp = *namep = NULL;
+	*instancep = -1;
+
+	if (kstatjs_lookup_nvpair(args, "0", &arg0) != 0)
+		return (-1);
+
+	if (arg0 == NULL)
+		return (0);
+
+	if (nvpair_type(arg0) != DATA_TYPE_NVLIST) {
+		(void) v8plus_throw_exception("TypeError",
+		    "illegal kstat specifier (expected object)",
+		    V8PLUS_TYPE_NONE);
+
+		return (-1);
+	}
+
+	(void) nvpair_value_nvlist(arg0, &arg);
+
+	if (nvlist_lookup_nvpair((nvlist_t *)args, "1", &arg1) == 0) {
+		(void) v8plus_throw_exception("Error",
+		    "illegal kstat specifier (spurious argument)",
+		    V8PLUS_TYPE_NONE);
+		return (-1);
+	}
+
+	if (kstatjs_parsearg_string(arg, "module", modulep) != 0 ||
+	    kstatjs_parsearg_string(arg, "class", classp) != 0 ||
+	    kstatjs_parsearg_string(arg, "name", namep) != 0) {
+		return (-1);
+	}
+
+	if (kstatjs_parsearg_int(arg, "instance", instancep) != 0)
+		return (-1);
+
+	return (0);
+}
+
+static nvlist_t *
+kstatjs_ctor(const nvlist_t *args, void **opp)
+{
+	kstatjs_t *ksj;
+
+	if ((ksj = malloc(sizeof (kstatjs_t))) == NULL)
+		v8plus_panic("malloc(): %s", strerror(errno));
+
+	bzero(ksj, sizeof (kstatjs_t));
+	ksj->ksj_kid = -1;
+
+	*opp = NULL;
+
+	if (kstatjs_parsearg(args, &ksj->ksj_module, &ksj->ksj_class,
+	    &ksj->ksj_name, &ksj->ksj_instance) != 0) {
+		kstatjs_dtor(ksj);
+		return (NULL);
+	}
+
+	if ((ksj->ksj_ctl = kstat_open()) == NULL) {
+		kstatjs_dtor(ksj);
+		return (v8plus_syserr(errno, V8PLUS_TYPE_NONE));
+	}
+
+	*opp = ksj;
+
+	return (v8plus_void());
+}
+
+#define	KSTATJS_READSTAT_IO_ADD(width, field) \
+	if ((err = nvlist_add_uint##width(nvl, #field, io->field)) != 0) { \
+		(void) v8plus_nverr(err, #field); \
+		nvlist_free(nvl); \
+		return (NULL); \
+	}
+
+static nvlist_t *
+kstatjs_readstat_io(kstat_t *ksp)
+{
+	nvlist_t *nvl;
+	int err;
+	kstat_io_t *io = KSTAT_IO_PTR(ksp);
+
+	KSTATJS_ASSERT(ksp->ks_type == KSTAT_TYPE_IO);
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0) {
+		(void) v8plus_nverr(err, NULL);
+		return (NULL);
+	}
+
+	KSTATJS_READSTAT_IO_ADD(64, nread);
+	KSTATJS_READSTAT_IO_ADD(64, nwritten);
+	KSTATJS_READSTAT_IO_ADD(32, reads);
+	KSTATJS_READSTAT_IO_ADD(32, writes);
+	KSTATJS_READSTAT_IO_ADD(64, wtime);
+	KSTATJS_READSTAT_IO_ADD(64, wlentime);
+	KSTATJS_READSTAT_IO_ADD(64, wlastupdate);
+	KSTATJS_READSTAT_IO_ADD(64, rtime);
+	KSTATJS_READSTAT_IO_ADD(64, rlentime);
+	KSTATJS_READSTAT_IO_ADD(64, rlastupdate);
+	KSTATJS_READSTAT_IO_ADD(64, wcnt);
+	KSTATJS_READSTAT_IO_ADD(64, rcnt);
+
+	return (nvl);
+}
+
+#undef	KSTATJS_READSTAT_IO_ADD
+
+static nvlist_t *
+kstatjs_readstat_named(kstat_t *ksp)
+{
+	nvlist_t *nvl;
+	kstat_named_t *nm = KSTAT_NAMED_PTR(ksp);
+	int err;
+	unsigned i;
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0) {
+		(void) v8plus_nverr(err, NULL);
+		return (NULL);
+	}
+
+	for (i = 0; i < ksp->ks_ndata; i++, nm++) {
+		char buf[256];
+
+		switch (nm->data_type) {
+		case KSTAT_DATA_CHAR:
+			err = nvlist_add_uint8(nvl, nm->name, nm->value.c[0]);
+			break;
+
+		case KSTAT_DATA_INT32:
+			err = nvlist_add_int32(nvl, nm->name, nm->value.i32);
+			break;
+
+		case KSTAT_DATA_UINT32:
+			err = nvlist_add_uint32(nvl, nm->name, nm->value.ui32);
+			break;
+
+		case KSTAT_DATA_INT64:
+			err = nvlist_add_int64(nvl, nm->name, nm->value.i64);
+			break;
+
+		case KSTAT_DATA_UINT64:
+			err = nvlist_add_uint64(nvl, nm->name, nm->value.ui64);
+			break;
+
+		case KSTAT_DATA_STRING:
+			err = nvlist_add_string(nvl, nm->name,
+			    KSTAT_NAMED_STR_PTR(nm));
+			break;
+
+		default:
+			(void) snprintf(buf, sizeof (buf), "unrecognized data "
+			    "type %d for member \"%s\" in instance %d of stat "
+			    "\"%s\" (module \"%s\", class \"%s\")\n",
+			    nm->data_type, nm->name, ksp->ks_instance,
+			    ksp->ks_name, ksp->ks_module, ksp->ks_class);
+
+			(void) v8plus_throw_exception("Error",
+			    buf, V8PLUS_TYPE_NONE);
+			nvlist_free(nvl);
+
+			return (NULL);
+		}
+
+		if (err != 0) {
+			(void) v8plus_nverr(err, nm->name);
+			nvlist_free(nvl);
+			return (NULL);
+		}
+	}
+
+	return (nvl);
+}
+
+static nvlist_t *
+kstatjs_readstat(kstatjs_t *ksj, kstatjs_stat_t *ksjs)
+{
+	kstat_t *ksp = ksjs->ksjs_ksp;
+	nvlist_t *nvl, *data;
+	int err;
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0) {
+		(void) v8plus_nverr(err, "nvlist_alloc");
+		return (NULL);
+	}
+
+	if ((err = nvlist_add_string(nvl, "class", ksp->ks_class)) != 0 ||
+	    (err = nvlist_add_string(nvl, "module", ksp->ks_module)) != 0 ||
+	    (err = nvlist_add_string(nvl, "name", ksp->ks_name)) != 0 ||
+	    (err = nvlist_add_int32(nvl, "instance", ksp->ks_instance))) {
+		goto err;
+	}
+
+	if (kstat_read(ksj->ksj_ctl, ksp, NULL) == -1) {
+		/*
+		 * It is deeply annoying, but some kstats can return errors
+		 * under otherwise routine conditions.  (ACPI is one
+		 * offender; there are surely others.)  To prevent these
+		 * fouled kstats from completely ruining our day, we assign
+		 * an "error" member to the return value that consists of
+		 * the strerror().
+		 */
+		if ((err = nvlist_add_string(nvl,
+		    "error", strerror(errno))) != 0) {
+			goto err;
+		}
+
+		return (nvl);
+	}
+
+	if ((err = nvlist_add_int32(nvl, "instance", ksp->ks_instance)) != 0 ||
+	    (err = nvlist_add_uint64(nvl, "snaptime", ksp->ks_snaptime)) != 0 ||
+	    (err = nvlist_add_uint64(nvl, "crtime", ksp->ks_crtime)) != 0) {
+		goto err;
+	}
+
+	if (ksp->ks_type == KSTAT_TYPE_NAMED) {
+		data = kstatjs_readstat_named(ksp);
+	} else if (ksp->ks_type == KSTAT_TYPE_IO) {
+		data = kstatjs_readstat_io(ksp);
+	} else {
+		return (nvl);
+	}
+
+	if (data == NULL) {
+		nvlist_free(nvl);
+		return (NULL);
+	}
+
+	if ((err = nvlist_add_nvlist(nvl, "data", data)) != 0) {
+		nvlist_free(data);
+		goto err;
+	}
+
+	nvlist_free(data);
+
+	return (nvl);
+err:
+	(void) v8plus_nverr(err, NULL);
+	nvlist_free(nvl);
+	return (NULL);
+}
+
+static boolean_t
+kstatjs_match(kstat_t *ksp, char *module, char *class,
+    char *name, int instance)
+{
+	if (module != NULL && strcmp(ksp->ks_module, module) != 0)
+		return (B_FALSE);
+
+	if (class != NULL && strcmp(ksp->ks_class, class) != 0)
+		return (B_FALSE);
+
+	if (name != NULL && strcmp(ksp->ks_name, name) != 0)
+		return (B_FALSE);
+
+	if (instance != -1 && ksp->ks_instance != instance)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static int
+kstatjs_update(kstatjs_t *ksj)
+{
+	kstat_ctl_t *ctl = ksj->ksj_ctl;
+	kstatjs_stat_t *freelist, *ksjs, *tail = NULL;
+	kstat_t *ksp;
+	kid_t kid;
+
+	if ((kid = kstat_chain_update(ctl)) == 0 && ksj->ksj_kid != -1)
+		return (0);
+
+	if (kid == -1) {
+		(void) v8plus_syserr(errno, "kstat_chain_update()");
+		return (-1);
+	}
+
+	ksj->ksj_kid = kid;
+
+	/*
+	 * After a chain update, we need to update all of our kstat headers.
+	 */
+	freelist = ksj->ksj_stats;
+	ksj->ksj_stats = NULL;
+
+	for (ksp = ctl->kc_chain; ksp != NULL; ksp = ksp->ks_next) {
+		if (!kstatjs_match(ksp, ksj->ksj_module,
+		    ksj->ksj_class, ksj->ksj_name, ksj->ksj_instance)) {
+			continue;
+		}
+
+		if (freelist == NULL) {
+			if ((ksjs = malloc(sizeof (kstatjs_stat_t))) == NULL) {
+				/*
+				 * To increase the odds of actually surviving
+				 * memory allocation failure enough to be able
+				 * throw an exception, we'll free all of our
+				 * kstats and set our kid to -1 to force any
+				 * subsequent read to re-process the kstat
+				 * header chain.
+				 */
+				ksjs = ksj->ksj_stats;
+
+				while ((ksjs = ksj->ksj_stats) != NULL) {
+					ksj->ksj_stats = ksjs->ksjs_next;
+					free(ksjs);
+				}
+
+				(void) v8plus_syserr(errno, "malloc()");
+				return (-1);
+			}
+		} else {
+			ksjs = freelist;
+			freelist = freelist->ksjs_next;
+		}
+
+		ksjs->ksjs_ksp = ksp;
+		ksjs->ksjs_next = NULL;
+
+		if (tail != NULL) {
+			tail->ksjs_next = ksjs;
+		} else {
+			ksj->ksj_stats = ksjs;
+		}
+
+		tail = ksjs;
+	}
+
+	/*
+	 * If there's anything left on the freelist, we need to free it.
+	 */
+	while ((ksjs = freelist) != NULL) {
+		freelist = ksjs->ksjs_next;
+		free(ksjs);
+	}
+
+	return (0);
+}
+
+static nvlist_t *
+kstatjs_read(void *op, const nvlist_t *args)
+{
+	kstatjs_t *ksj = op;
+	kstatjs_stat_t *ksjs;
+	nvlist_t *nvl, *data, *rval = NULL;
+	int nstats = 0, err;
+	char *module = NULL, *class = NULL, *name = NULL;
+	int instance = -1;
+
+	if (kstatjs_parsearg(args, &module, &class, &name, &instance) != 0)
+		return (NULL);
+
+	if (ksj->ksj_ctl == NULL) {
+		rval = v8plus_throw_exception("Error",
+		    "kstat reader has already been closed", V8PLUS_TYPE_NONE);
+		goto out;
+	}
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0) {
+		(void) v8plus_nverr(err, "nvlist_alloc");
+		goto out;
+	}
+
+	/*
+	 * One indicates to v8plus that an nvlist is actually of an array type
+	 * by setting a magic property.  No, it's not documented -- and yes, a
+	 * better interface is sorely needed!  (Indeed, it would be difficult
+	 * to have a worse one.)
+	 */
+	if ((err = nvlist_add_string(nvl, ".__v8plus_type", "Array")) != 0) {
+		(void) v8plus_nverr(err, NULL);
+		nvlist_free(nvl);
+		goto out;
+	}
+
+	if (kstatjs_update(ksj) != 0) {
+		nvlist_free(nvl);
+		goto out;
+	}
+
+	for (ksjs = ksj->ksj_stats; ksjs != NULL; ksjs = ksjs->ksjs_next) {
+		char buf[12];
+
+		if (!kstatjs_match(ksjs->ksjs_ksp, module,
+		    class, name, instance)) {
+			continue;
+		}
+
+		if ((data = kstatjs_readstat(ksj, ksjs)) == NULL) {
+			nvlist_free(nvl);
+			goto out;
+		}
+
+		(void) snprintf(buf, sizeof (buf), "%d", nstats++);
+		KSTATJS_ASSERT(nstats > 0);
+
+		if (nvlist_add_nvlist(nvl, buf, data) != 0) {
+			(void) v8plus_nverr(err, NULL);
+			nvlist_free(nvl);
+			goto out;
+		}
+
+		nvlist_free(data);
+	}
+
+	rval = v8plus_obj(V8PLUS_TYPE_OBJECT, "res", nvl, V8PLUS_TYPE_NONE);
+
+out:
+	free(module);
+	free(class);
+	free(name);
+
+	return (rval);
+}
+
+static nvlist_t *
+kstatjs_close(void *op, const nvlist_t *args __UNUSED)
+{
+	kstatjs_t *ksj = op;
+
+	if (ksj->ksj_ctl == NULL) {
+		return (v8plus_throw_exception("Error",
+		    "kstat reader has already been closed", V8PLUS_TYPE_NONE));
+	}
+
+	kstatjs_finalize(ksj);
+
+	return (v8plus_void());
+}
+
+static v8plus_module_defn_t vmd = {
+	.vmd_version = V8PLUS_MODULE_VERSION,
+	.vmd_js_class_name = "Reader",
+	.vmd_js_factory_name = "Reader",
+	.vmd_methods = (v8plus_method_descr_t[]) {
+		{
+			.md_name = "read",
+			.md_c_func = kstatjs_read
+		}, {
+			.md_name = "close",
+			.md_c_func = kstatjs_close
+		}
+	},
+	.vmd_method_count = 2,
+	.vmd_ctor = kstatjs_ctor,
+	.vmd_dtor = kstatjs_dtor
+};
+
+__attribute__((constructor))
+static void
+_init(void)
+{
+	v8plus_module_register(&vmd);
+}
diff --git a/kstat.cc b/kstat.cc
deleted file mode 100644
index 99a63b6..0000000
--- a/kstat.cc
+++ /dev/null
@@ -1,764 +0,0 @@
-#include <v8.h>
-#include <node.h>
-#include <string.h>
-#include <unistd.h>
-#include <nfs/nfs_clnt.h>
-#include <node_object_wrap.h>
-#include <kstat.h>
-#include <errno.h>
-#include <string>
-#include <vector>
-#include <sys/dnlc.h>
-#include <sys/varargs.h>
-#include <sys/sysinfo.h>
-#include <sys/time.h>
-#include <sys/var.h>
-
-using namespace v8;
-using std::string;
-using std::vector;
-
-class KStatReader : node::ObjectWrap {
-public:
-	static void Initialize(Handle<Object> target);
-
-protected:
-	static Persistent<FunctionTemplate> templ;
-
-	KStatReader(string *module, string *classname,
-	    string *name, int instance);
-	void close();
-	Handle<Value> error(const char *fmt, ...);
-	Handle<Value> read(kstat_t *);
-	bool matches(kstat_t *, string *, string *, string *, int64_t);
-	int update();
-	~KStatReader();
-
-	static Handle<Value> Close(const Arguments& args);
-	static Handle<Value> New(const Arguments& args);
-	static Handle<Value> Read(const Arguments& args);
-
-
-private:
-	static string *stringMember(Local<Value>, char *, char *);
-	static int64_t intMember(Local<Value>, char *, int64_t);
-	Handle<Object> data_raw_cpu_stat(kstat_t *);
-	Handle<Object> data_raw_var(kstat_t *);
-	Handle<Object> data_raw_ncstats(kstat_t *);
-	Handle<Object> data_raw_sysinfo(kstat_t *);
-	Handle<Object> data_raw_vminfo(kstat_t *);
-	Handle<Object> data_raw_mntinfo(kstat_t *);
-	Handle<Object> data_raw(kstat_t *);
-	Handle<Object> data_named(kstat_t *);
-	Handle<Object> data_intr(kstat_t *);
-	Handle<Object> data_io(kstat_t *);
-	Handle<Object> data_timer(kstat_t *);
-
-	string *ksr_module;
-	string *ksr_class;
-	string *ksr_name;
-	int ksr_instance;
-	kid_t ksr_kid;
-	kstat_ctl_t *ksr_ctl;
-	vector<kstat_t *> ksr_kstats;
-};
-
-Persistent<FunctionTemplate> KStatReader::templ;
-
-KStatReader::KStatReader(string *module, string *classname,
-    string *name, int instance)
-    : node::ObjectWrap(), ksr_module(module), ksr_class(classname),
-    ksr_name(name), ksr_instance(instance), ksr_kid(-1)
-{
-	if ((ksr_ctl = kstat_open()) == NULL)
-		throw "could not open kstat";
-};
-
-KStatReader::~KStatReader()
-{
-	delete ksr_module;
-	delete ksr_class;
-	delete ksr_name;
-
-	if (ksr_ctl != NULL)
-		this->close();
-}
-
-void
-KStatReader::close()
-{
-	kstat_close(ksr_ctl);
-	ksr_ctl = NULL;
-}
-
-bool
-KStatReader::matches(kstat_t *ksp, string* fmodule, string* fclass,
-    string* fname, int64_t finstance)
-{
-	if (!fmodule->empty() && fmodule->compare(ksp->ks_module) != 0)
-		return (false);
-
-	if (!fclass->empty() && fclass->compare(ksp->ks_class) != 0)
-		return (false);
-
-	if (!fname->empty() && fname->compare(ksp->ks_name) != 0)
-		return (false);
-
-	return (finstance == -1 || ksp->ks_instance == finstance);
-}
-
-int
-KStatReader::update()
-{
-	kstat_t *ksp;
-	kid_t kid;
-
-	if ((kid = kstat_chain_update(ksr_ctl)) == 0 && ksr_kid != -1)
-		return (0);
-
-	if (kid == -1)
-		return (-1);
-
-	ksr_kid = kid;
-	ksr_kstats.clear();
-
-	for (ksp = ksr_ctl->kc_chain; ksp != NULL; ksp = ksp->ks_next) {
-		if (!this->matches(ksp,
-		    ksr_module, ksr_class, ksr_name, ksr_instance))
-			continue;
-
-		ksr_kstats.push_back(ksp);
-	}
-
-	return (0);
-}
-
-void
-KStatReader::Initialize(Handle<Object> target)
-{
-	HandleScope scope;
-
-	Local<FunctionTemplate> k = FunctionTemplate::New(KStatReader::New);
-
-	templ = Persistent<FunctionTemplate>::New(k);
-	templ->InstanceTemplate()->SetInternalFieldCount(1);
-	templ->SetClassName(String::NewSymbol("Reader"));
-
-	NODE_SET_PROTOTYPE_METHOD(templ, "read", KStatReader::Read);
-	NODE_SET_PROTOTYPE_METHOD(templ, "close", KStatReader::Close);
-
-	target->Set(String::NewSymbol("Reader"), templ->GetFunction());
-}
-
-string *
-KStatReader::stringMember(Local<Value> value, char *member, char *deflt)
-{
-	if (!value->IsObject())
-		return (new string(deflt));
-
-	Local<Object> o = Local<Object>::Cast(value);
-	Local<Value> v = o->Get(String::New(member));
-
-	if (!v->IsString())
-		return (new string(deflt));
-
-	String::AsciiValue val(v);
-	return (new string(*val));
-}
-
-int64_t
-KStatReader::intMember(Local<Value> value, char *member, int64_t deflt)
-{
-	int64_t rval = deflt;
-
-	if (!value->IsObject())
-		return (rval);
-
-	Local<Object> o = Local<Object>::Cast(value);
-	value = o->Get(String::New(member));
-
-	if (!value->IsNumber())
-		return (rval);
-
-	Local<Integer> i = Local<Integer>::Cast(value);
-
-	return (i->Value());
-}
-
-Handle<Value>
-KStatReader::New(const Arguments& args)
-{
-	HandleScope scope;
-
-	KStatReader *k = new KStatReader(stringMember(args[0], "module", ""),
-	    stringMember(args[0], "class", ""),
-	    stringMember(args[0], "name", ""),
-	    intMember(args[0], "instance", -1));
-
-	k->Wrap(args.Holder());
-
-	return (args.This());
-}
-
-Handle<Value>
-KStatReader::error(const char *fmt, ...)
-{
-	char buf[1024], buf2[1024];
-	char *err = buf;
-	va_list ap;
-
-	va_start(ap, fmt);
-	(void) vsnprintf(buf, sizeof (buf), fmt, ap);
-
-	if (buf[strlen(buf) - 1] != '\n') {
-		/*
-		 * If our error doesn't end in a new-line, we'll append the
-		 * strerror of errno.
-		 */
-		(void) snprintf(err = buf2, sizeof (buf2),
-		    "%s: %s", buf, strerror(errno));
-	} else {
-		buf[strlen(buf) - 1] = '\0';
-	}
-
-	return (ThrowException(Exception::Error(String::New(err))));
-}
-
-Handle<Object>
-KStatReader::data_raw_cpu_stat(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (cpu_stat_t));
-
-	cpu_stat_t	  *stat;
-	cpu_sysinfo_t	*sysinfo;
-	cpu_syswait_t	*syswait;
-	cpu_vminfo_t	*vminfo;
-
-	stat    = (cpu_stat_t *)(ksp->ks_data);
-	sysinfo = &stat->cpu_sysinfo;
-	syswait = &stat->cpu_syswait;
-	vminfo  = &stat->cpu_vminfo;
-
-	data->Set(String::New("idle"), Number::New(sysinfo->cpu[CPU_IDLE]));
-	data->Set(String::New("user"), Number::New(sysinfo->cpu[CPU_USER]));
-	data->Set(String::New("kernel"), Number::New(sysinfo->cpu[CPU_KERNEL]));
-	data->Set(String::New("wait"), Number::New(sysinfo->cpu[CPU_WAIT]));
-	data->Set(String::New("wait_io"), Number::New(sysinfo->wait[W_IO]));
-	data->Set(String::New("wait_swap"), Number::New(sysinfo->wait[W_SWAP]));
-	data->Set(String::New("wait_pio"), Number::New(sysinfo->wait[W_PIO]));
-	data->Set(String::New("bread"), Number::New(sysinfo->bread));
-	data->Set(String::New("bwrite"), Number::New(sysinfo->bwrite));
-	data->Set(String::New("lread"), Number::New(sysinfo->lread));
-	data->Set(String::New("lwrite"), Number::New(sysinfo->lwrite));
-	data->Set(String::New("phread"), Number::New(sysinfo->phread));
-	data->Set(String::New("phwrite"), Number::New(sysinfo->phwrite));
-	data->Set(String::New("pswitch"), Number::New(sysinfo->pswitch));
-	data->Set(String::New("trap"), Number::New(sysinfo->trap));
-	data->Set(String::New("intr"), Number::New(sysinfo->intr));
-	data->Set(String::New("syscall"), Number::New(sysinfo->syscall));
-	data->Set(String::New("sysread"), Number::New(sysinfo->sysread));
-	data->Set(String::New("syswrite"), Number::New(sysinfo->syswrite));
-	data->Set(String::New("sysfork"), Number::New(sysinfo->sysfork));
-	data->Set(String::New("sysvfork"), Number::New(sysinfo->sysvfork));
-	data->Set(String::New("sysexec"), Number::New(sysinfo->sysexec));
-	data->Set(String::New("readch"), Number::New(sysinfo->readch));
-	data->Set(String::New("writech"), Number::New(sysinfo->writech));
-	data->Set(String::New("rcvint"), Number::New(sysinfo->rcvint));
-	data->Set(String::New("xmtint"), Number::New(sysinfo->xmtint));
-	data->Set(String::New("mdmint"), Number::New(sysinfo->mdmint));
-	data->Set(String::New("rawch"), Number::New(sysinfo->rawch));
-	data->Set(String::New("canch"), Number::New(sysinfo->canch));
-	data->Set(String::New("outch"), Number::New(sysinfo->outch));
-	data->Set(String::New("msg"), Number::New(sysinfo->msg));
-	data->Set(String::New("sema"), Number::New(sysinfo->sema));
-	data->Set(String::New("namei"), Number::New(sysinfo->namei));
-	data->Set(String::New("ufsiget"), Number::New(sysinfo->ufsiget));
-	data->Set(String::New("ufsdirblk"), Number::New(sysinfo->ufsdirblk));
-	data->Set(String::New("ufsipage"), Number::New(sysinfo->ufsipage));
-	data->Set(String::New("ufsinopage"), Number::New(sysinfo->ufsinopage));
-	data->Set(String::New("inodeovf"), Number::New(sysinfo->inodeovf));
-	data->Set(String::New("fileovf"), Number::New(sysinfo->fileovf));
-	data->Set(String::New("procovf"), Number::New(sysinfo->procovf));
-	data->Set(String::New("intrthread"), Number::New(sysinfo->intrthread));
-	data->Set(String::New("intrblk"), Number::New(sysinfo->intrblk));
-	data->Set(String::New("idlethread"), Number::New(sysinfo->idlethread));
-	data->Set(String::New("inv_swtch"), Number::New(sysinfo->inv_swtch));
-	data->Set(String::New("nthreads"), Number::New(sysinfo->nthreads));
-	data->Set(String::New("cpumigrate"), Number::New(sysinfo->cpumigrate));
-	data->Set(String::New("xcalls"), Number::New(sysinfo->xcalls));
-	data->Set(String::New("mutex_adenters"),
-	    Number::New(sysinfo->mutex_adenters));
-	data->Set(String::New("rw_rdfails"), Number::New(sysinfo->rw_rdfails));
-	data->Set(String::New("rw_wrfails"), Number::New(sysinfo->rw_wrfails));
-	data->Set(String::New("modload"), Number::New(sysinfo->modload));
-	data->Set(String::New("modunload"), Number::New(sysinfo->modunload));
-	data->Set(String::New("bawrite"), Number::New(sysinfo->bawrite));
-#ifdef	STATISTICS	/* see header file */
-	data->Set(String::New("rw_enters"), Number::New(sysinfo->rw_enters));
-	data->Set(String::New("win_uo_cnt"), Number::New(sysinfo->win_uo_cnt));
-	data->Set(String::New("win_uu_cnt"), Number::New(sysinfo->win_uu_cnt));
-	data->Set(String::New("win_so_cnt"), Number::New(sysinfo->win_so_cnt));
-	data->Set(String::New("win_su_cnt"), Number::New(sysinfo->win_su_cnt));
-	data->Set(String::New("win_suo_cnt"),
-	    Number::New(sysinfo->win_suo_cnt));
-#endif
-
-	data->Set(String::New("iowait"), Number::New(syswait->iowait));
-	data->Set(String::New("swap"), Number::New(syswait->swap));
-	data->Set(String::New("physio"), Number::New(syswait->physio));
-
-	data->Set(String::New("pgrec"), Number::New(vminfo->pgrec));
-	data->Set(String::New("pgfrec"), Number::New(vminfo->pgfrec));
-	data->Set(String::New("pgin"), Number::New(vminfo->pgin));
-	data->Set(String::New("pgpgin"), Number::New(vminfo->pgpgin));
-	data->Set(String::New("pgout"), Number::New(vminfo->pgout));
-	data->Set(String::New("pgpgout"), Number::New(vminfo->pgpgout));
-	data->Set(String::New("swapin"), Number::New(vminfo->swapin));
-	data->Set(String::New("pgswapin"), Number::New(vminfo->pgswapin));
-	data->Set(String::New("swapout"), Number::New(vminfo->swapout));
-	data->Set(String::New("pgswapout"), Number::New(vminfo->pgswapout));
-	data->Set(String::New("zfod"), Number::New(vminfo->zfod));
-	data->Set(String::New("dfree"), Number::New(vminfo->dfree));
-	data->Set(String::New("scan"), Number::New(vminfo->scan));
-	data->Set(String::New("rev"), Number::New(vminfo->rev));
-	data->Set(String::New("hat_fault"), Number::New(vminfo->hat_fault));
-	data->Set(String::New("as_fault"), Number::New(vminfo->as_fault));
-	data->Set(String::New("maj_fault"), Number::New(vminfo->maj_fault));
-	data->Set(String::New("cow_fault"), Number::New(vminfo->cow_fault));
-	data->Set(String::New("prot_fault"), Number::New(vminfo->prot_fault));
-	data->Set(String::New("softlock"), Number::New(vminfo->softlock));
-	data->Set(String::New("kernel_asflt"),
-	    Number::New(vminfo->kernel_asflt));
-	data->Set(String::New("pgrrun"), Number::New(vminfo->pgrrun));
-	data->Set(String::New("execpgin"), Number::New(vminfo->execpgin));
-	data->Set(String::New("execpgout"), Number::New(vminfo->execpgout));
-	data->Set(String::New("execfree"), Number::New(vminfo->execfree));
-	data->Set(String::New("anonpgin"), Number::New(vminfo->anonpgin));
-	data->Set(String::New("anonpgout"), Number::New(vminfo->anonpgout));
-	data->Set(String::New("anonfree"), Number::New(vminfo->anonfree));
-	data->Set(String::New("fspgin"), Number::New(vminfo->fspgin));
-	data->Set(String::New("fspgout"), Number::New(vminfo->fspgout));
-	data->Set(String::New("fsfree"), Number::New(vminfo->fsfree));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw_var(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (struct var));
-
-	struct var	*var = (struct var *)(ksp->ks_data);
-
-	data->Set(String::New("v_buf"), Number::New(var->v_buf));
-	data->Set(String::New("v_call"), Number::New(var->v_call));
-	data->Set(String::New("v_proc"), Number::New(var->v_proc));
-	data->Set(String::New("v_maxupttl"), Number::New(var->v_maxupttl));
-	data->Set(String::New("v_nglobpris"), Number::New(var->v_nglobpris));
-	data->Set(String::New("v_maxsyspri"), Number::New(var->v_maxsyspri));
-	data->Set(String::New("v_clist"), Number::New(var->v_clist));
-	data->Set(String::New("v_maxup"), Number::New(var->v_maxup));
-	data->Set(String::New("v_hbuf"), Number::New(var->v_hbuf));
-	data->Set(String::New("v_hmask"), Number::New(var->v_hmask));
-	data->Set(String::New("v_pbuf"), Number::New(var->v_pbuf));
-	data->Set(String::New("v_sptmap"), Number::New(var->v_sptmap));
-	data->Set(String::New("v_maxpmem"), Number::New(var->v_maxpmem));
-	data->Set(String::New("v_autoup"), Number::New(var->v_autoup));
-	data->Set(String::New("v_bufhwm"), Number::New(var->v_bufhwm));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw_ncstats(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (struct ncstats));
-
-	struct ncstats	*ncstats = (struct ncstats *)(ksp->ks_data);
-
-	data->Set(String::New("hits"), Number::New(ncstats->hits));
-	data->Set(String::New("misses"), Number::New(ncstats->misses));
-	data->Set(String::New("enters"), Number::New(ncstats->enters));
-	data->Set(String::New("dbl_enters"), Number::New(ncstats->dbl_enters));
-	data->Set(String::New("long_enter"), Number::New(ncstats->long_enter));
-	data->Set(String::New("long_look"), Number::New(ncstats->long_look));
-	data->Set(String::New("move_to_front"),
-	    Number::New(ncstats->move_to_front));
-	data->Set(String::New("purges"), Number::New(ncstats->purges));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw_sysinfo(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (sysinfo_t));
-
-	sysinfo_t	*sysinfo = (sysinfo_t *)(ksp->ks_data);
-
-	data->Set(String::New("updates"), Number::New(sysinfo->updates));
-	data->Set(String::New("runque"), Number::New(sysinfo->runque));
-	data->Set(String::New("runocc"), Number::New(sysinfo->runocc));
-	data->Set(String::New("swpque"), Number::New(sysinfo->swpque));
-	data->Set(String::New("swpocc"), Number::New(sysinfo->swpocc));
-	data->Set(String::New("waiting"), Number::New(sysinfo->waiting));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw_vminfo(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (vminfo_t));
-
-	vminfo_t	*vminfo = (vminfo_t *)(ksp->ks_data);
-
-	data->Set(String::New("freemem"), Number::New(vminfo->freemem));
-	data->Set(String::New("swap_resv"), Number::New(vminfo->swap_resv));
-	data->Set(String::New("swap_alloc"), Number::New(vminfo->swap_alloc));
-	data->Set(String::New("swap_avail"), Number::New(vminfo->swap_avail));
-	data->Set(String::New("swap_free"), Number::New(vminfo->swap_free));
-	data->Set(String::New("updates"), Number::New(vminfo->updates));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw_mntinfo(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-
-	assert(ksp->ks_data_size == sizeof (struct mntinfo_kstat));
-
-	struct mntinfo_kstat *mntinfo = (struct mntinfo_kstat *)(ksp->ks_data);
-
-	data->Set(String::New("mntinfo"),
-	    String::New(mntinfo->mik_proto));
-	data->Set(String::New("mik_vers"),
-	    Number::New(mntinfo->mik_vers));
-	data->Set(String::New("mik_flags"),
-	    Number::New(mntinfo->mik_flags));
-	data->Set(String::New("mik_secmod"),
-	    Number::New(mntinfo->mik_secmod));
-	data->Set(String::New("mik_curread"),
-	    Number::New(mntinfo->mik_curread));
-	data->Set(String::New("mik_curwrite"),
-	    Number::New(mntinfo->mik_curwrite));
-	data->Set(String::New("mik_timeo"),
-	    Number::New(mntinfo->mik_timeo));
-	data->Set(String::New("mik_retrans"),
-	    Number::New(mntinfo->mik_retrans));
-	data->Set(String::New("mik_acregmin"),
-	    Number::New(mntinfo->mik_acregmin));
-	data->Set(String::New("mik_acregmax"),
-	    Number::New(mntinfo->mik_acregmax));
-	data->Set(String::New("mik_acdirmin"),
-	    Number::New(mntinfo->mik_acdirmin));
-	data->Set(String::New("mik_acdirmax"),
-	    Number::New(mntinfo->mik_acdirmax));
-	data->Set(String::New("lookup_srtt"),
-	    Number::New(mntinfo->mik_timers[0].srtt));
-	data->Set(String::New("lookup_deviate"),
-	    Number::New(mntinfo->mik_timers[0].deviate));
-	data->Set(String::New("lookup_rtxcur"),
-	    Number::New(mntinfo->mik_timers[0].rtxcur));
-	data->Set(String::New("read_srtt"),
-	    Number::New(mntinfo->mik_timers[1].srtt));
-	data->Set(String::New("read_deviate"),
-	    Number::New(mntinfo->mik_timers[1].deviate));
-	data->Set(String::New("read_rtxcur"),
-	    Number::New(mntinfo->mik_timers[1].rtxcur));
-	data->Set(String::New("write_srtt"),
-	    Number::New(mntinfo->mik_timers[2].srtt));
-	data->Set(String::New("write_deviate"),
-	    Number::New(mntinfo->mik_timers[2].deviate));
-	data->Set(String::New("write_rtxcur"),
-	    Number::New(mntinfo->mik_timers[2].rtxcur));
-	data->Set(String::New("mik_noresponse"),
-	    Number::New(mntinfo->mik_noresponse));
-	data->Set(String::New("mik_failover"),
-	    Number::New(mntinfo->mik_failover));
-	data->Set(String::New("mik_remap"),
-	    Number::New(mntinfo->mik_remap));
-	data->Set(String::New("mntinfo"),
-	    String::New(mntinfo->mik_curserver));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_raw(kstat_t *ksp)
-{
-	Handle<Object> data;
-
-	assert(ksp->ks_type == KSTAT_TYPE_RAW);
-
-	if (strcmp(ksp->ks_name, "cpu_stat") == 0) {
-		data = data_raw_cpu_stat(ksp);
-	} else if (strcmp(ksp->ks_name, "var") == 0) {
-		data = data_raw_var(ksp);
-	} else if (strcmp(ksp->ks_name, "ncstats") == 0) {
-		data = data_raw_ncstats(ksp);
-	} else if (strcmp(ksp->ks_name, "sysinfo") == 0) {
-		data = data_raw_sysinfo(ksp);
-	} else if (strcmp(ksp->ks_name, "vminfo") == 0) {
-		data = data_raw_vminfo(ksp);
-	} else if (strcmp(ksp->ks_name, "mntinfo") == 0) {
-		data = data_raw_mntinfo(ksp);
-	} else {
-		data = Object::New();
-	}
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_named(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-	kstat_named_t *nm = KSTAT_NAMED_PTR(ksp);
-	unsigned int i;
-
-	assert(ksp->ks_type == KSTAT_TYPE_NAMED);
-
-	for (i = 0; i < ksp->ks_ndata; i++, nm++) {
-		Handle<Value> val;
-
-		switch (nm->data_type) {
-		case KSTAT_DATA_CHAR:
-			val = Number::New(nm->value.c[0]);
-			break;
-
-		case KSTAT_DATA_INT32:
-			val = Number::New(nm->value.i32);
-			break;
-
-		case KSTAT_DATA_UINT32:
-			val = Number::New(nm->value.ui32);
-			break;
-
-		case KSTAT_DATA_INT64:
-			val = Number::New(nm->value.i64);
-			break;
-
-		case KSTAT_DATA_UINT64:
-			val = Number::New(nm->value.ui64);
-			break;
-
-		case KSTAT_DATA_STRING:
-			val = String::New(KSTAT_NAMED_STR_PTR(nm));
-			break;
-
-		default:
-			throw (error("unrecognized data type %d for member "
-			    "\"%s\" in instance %d of stat \"%s\" (module "
-			    "\"%s\", class \"%s\")\n", nm->data_type,
-			    nm->name, ksp->ks_instance, ksp->ks_name,
-			    ksp->ks_module, ksp->ks_class));
-		}
-
-		data->Set(String::New(nm->name), val);
-	}
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_intr(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-	kstat_intr_t *intr = KSTAT_INTR_PTR(ksp);
-
-	assert(ksp->ks_type == KSTAT_TYPE_INTR);
-
-	data->Set(String::New("KSTAT_INTR_HARD"),
-	    Number::New(intr->intrs[KSTAT_INTR_HARD]));
-	data->Set(String::New("KSTAT_INTR_SOFT"),
-	    Number::New(intr->intrs[KSTAT_INTR_SOFT]));
-	data->Set(String::New("KSTAT_INTR_WATCHDOG"),
-	    Number::New(intr->intrs[KSTAT_INTR_WATCHDOG]));
-	data->Set(String::New("KSTAT_INTR_SPURIOUS"),
-	    Number::New(intr->intrs[KSTAT_INTR_SPURIOUS]));
-	data->Set(String::New("KSTAT_INTR_MULTSVC"),
-	    Number::New(intr->intrs[KSTAT_INTR_MULTSVC]));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_io(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-	kstat_io_t *io = KSTAT_IO_PTR(ksp);
-
-	assert(ksp->ks_type == KSTAT_TYPE_IO);
-
-	data->Set(String::New("nread"), Number::New(io->nread));
-	data->Set(String::New("nwritten"), Number::New(io->nwritten));
-	data->Set(String::New("reads"), Integer::New(io->reads));
-	data->Set(String::New("writes"), Integer::New(io->writes));
-
-	data->Set(String::New("wtime"), Number::New(io->wtime));
-	data->Set(String::New("wlentime"), Number::New(io->wlentime));
-	data->Set(String::New("wlastupdate"), Number::New(io->wlastupdate));
-
-	data->Set(String::New("rtime"), Number::New(io->rtime));
-	data->Set(String::New("rlentime"), Number::New(io->rlentime));
-	data->Set(String::New("rlastupdate"), Number::New(io->rlastupdate));
-
-	data->Set(String::New("wcnt"), Integer::New(io->wcnt));
-	data->Set(String::New("rcnt"), Integer::New(io->rcnt));
-
-	return (data);
-}
-
-Handle<Object>
-KStatReader::data_timer(kstat_t *ksp)
-{
-	Handle<Object> data = Object::New();
-	kstat_timer_t *timer = KSTAT_TIMER_PTR(ksp);
-
-	assert(ksp->ks_type == KSTAT_TYPE_TIMER);
-
-	data->Set(String::New("name"), String::New(timer->name));
-	data->Set(String::New("num_events"), Number::New(timer->num_events));
-	data->Set(String::New("elapsed_time"),
-	    Number::New(timer->elapsed_time));
-	data->Set(String::New("min_time"), Number::New(timer->min_time));
-	data->Set(String::New("max_time"), Number::New(timer->max_time));
-	data->Set(String::New("start_time"), Number::New(timer->start_time));
-	data->Set(String::New("stop_time"), Number::New(timer->stop_time));
-
-	return (data);
-}
-
-Handle<Value>
-KStatReader::read(kstat_t *ksp)
-{
-	Handle<Object> rval = Object::New();
-	Handle<Object> data;
-
-	rval->Set(String::New("class"), String::New(ksp->ks_class));
-	rval->Set(String::New("module"), String::New(ksp->ks_module));
-	rval->Set(String::New("name"), String::New(ksp->ks_name));
-	rval->Set(String::New("instance"), Integer::New(ksp->ks_instance));
-
-	if (kstat_read(ksr_ctl, ksp, NULL) == -1) {
-		/*
-		 * It is deeply annoying, but some kstats can return errors
-		 * under otherwise routine conditions.  (ACPI is one
-		 * offender; there are surely others.)  To prevent these
-		 * fouled kstats from completely ruining our day, we assign
-		 * an "error" member to the return value that consists of
-		 * the strerror().
-		 */
-		rval->Set(String::New("error"), String::New(strerror(errno)));
-		return (rval);
-	}
-
-	rval->Set(String::New("instance"), Integer::New(ksp->ks_instance));
-	rval->Set(String::New("snaptime"), Number::New(ksp->ks_snaptime));
-	rval->Set(String::New("crtime"), Number::New(ksp->ks_crtime));
-
-	switch (ksp->ks_type) {
-		case KSTAT_TYPE_RAW:
-			data = data_raw(ksp);
-			break;
-
-		case KSTAT_TYPE_NAMED:
-			data = data_named(ksp);
-			break;
-
-		case KSTAT_TYPE_INTR:
-			data = data_intr(ksp);
-			break;
-
-		case KSTAT_TYPE_IO:
-			data = data_io(ksp);
-			break;
-
-		case KSTAT_TYPE_TIMER:
-			data = data_timer(ksp);
-			break;
-
-		default:
-			return (rval);
-	}
-
-	rval->Set(String::New("data"), data);
-
-	return (rval);
-}
-
-Handle<Value>
-KStatReader::Close(const Arguments& args)
-{
-	KStatReader *k = ObjectWrap::Unwrap<KStatReader>(args.Holder());
-	HandleScope scope;
-
-	if (k->ksr_ctl == NULL)
-		return (k->error("kstat reader has already been closed\n"));
-
-	k->close();
-	return (Undefined());
-}
-
-Handle<Value>
-KStatReader::Read(const Arguments& args)
-{
-	KStatReader *k = ObjectWrap::Unwrap<KStatReader>(args.Holder());
-	Handle<Array> rval;
-	HandleScope scope;
-	unsigned int i, j;
-
-	if (k->ksr_ctl == NULL)
-		return (k->error("kstat reader has already been closed\n"));
-
-	if (k->update() == -1)
-		return (k->error("failed to update kstat chain"));
-
-	string *rmodule = stringMember(args[0], "module", "");
-	string *rclass = stringMember(args[0], "class", "");
-	string *rname = stringMember(args[0], "name", "");
-	int64_t rinstance = intMember(args[0], "instance", -1);
-
-	rval = Array::New();
-
-	try {
-		for (i = 0, j = 0; i < k->ksr_kstats.size(); i++) {
-			if (!k->matches(k->ksr_kstats[i],
-			    rmodule, rclass, rname, rinstance))
-				continue;
-
-			rval->Set(j++, k->read(k->ksr_kstats[i]));
-		}
-	} catch (Handle<Value> err) {
-		delete rmodule;
-		delete rclass;
-		delete rname;
-		return (err);
-	}
-
-	delete rmodule;
-	delete rclass;
-	delete rname;
-	return (rval);
-}
-
-extern "C" void
-init(Handle<Object> target)
-{
-	KStatReader::Initialize(target);
-}
-
-NODE_MODULE(kstat, init);
diff --git a/package.json b/package.json
index e642bc5..a975901 100644
--- a/package.json
+++ b/package.json
@@ -1,9 +1,15 @@
 {
 	"name":		"kstat",
-	"version":	"0.5.0",
+	"version":	"1.0.0",
 	"description":	"illumos libkstat bindings",
-	"homepage":	"https://github.com/bcantrill/node-kstat",
+	"homepage":	"https://github.com/joyent/node-kstat",
 	"author":	"Joyent (joyent.com)",
-	"engines":	{ "node": ">=0.6" },
-	"main":		"build/Release/kstat"
+	"engines":	{ "node": ">=0.8" },
+	"main":		"kstat",
+	"dependencies": {
+		"v8plus":	"^1.0.2"
+	},
+	"devDependencies": {
+		"tape":		"4.6.2"
+	}
 }
diff --git a/test/basic.js b/test/basic.js
new file mode 100644
index 0000000..3e1171d
--- /dev/null
+++ b/test/basic.js
@@ -0,0 +1,133 @@
+var kstat = require('kstat');
+var test = require('tape');
+
+var check = function (t, results)
+{
+	var bymod = {};
+	var i;
+
+	t.assert(results instanceof Array);
+	t.assert(results.length > 1);
+
+	for (i = 0; i < results.length; i++) {
+		if (results[i].class == 'mib2')
+			bymod[results[i].module] = results[i];
+	}
+
+	t.assert(bymod.tcp);
+	t.assert(bymod.tcp.hasOwnProperty('class'));
+	t.assert(bymod.tcp.class == 'mib2');
+	t.assert(bymod.tcp.hasOwnProperty('instance'));
+	t.assert(bymod.tcp.hasOwnProperty('name'));
+	t.assert(bymod.tcp.name == 'tcp');
+
+	t.assert(bymod.tcp.hasOwnProperty('snaptime'));
+	t.assert(bymod.tcp.hasOwnProperty('crtime'));
+
+	t.assert(bymod.tcp.hasOwnProperty('data'));
+	t.assert(bymod.tcp.data.rtoMax > 0);
+	t.assert(bymod.tcp.data.hasOwnProperty('listenDrop'));
+
+	t.assert(bymod.udp);
+	t.assert(bymod.udp.hasOwnProperty('data'));
+	t.assert(bymod.udp.data.hasOwnProperty('inDatagrams'));
+	t.end();
+};
+
+test('basic open', function (t) {
+	var reader = new kstat.Reader();
+	var results = reader.read();
+
+	check(t, results);
+});
+
+test('unspecified open', function (t) {
+	var reader = new kstat.Reader({});
+	var results = reader.read();
+
+	check(t, results);
+});
+
+test('failed open', function (t) {
+	var f = function (arg) { if (arg) t.assert(false); };
+
+	t.throws(function () { f(new kstat.Reader(undefined)); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader('fooey')); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader({ 'class': 1234 })); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader({ 'module': -1 })); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader({ 'name': false })); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader({ 'instance': 'doogle' })); },
+	    /illegal kstat specifier/);
+	t.throws(function () { f(new kstat.Reader({ 'class': 'foo' }, 123)); },
+	    /illegal kstat specifier/);
+	t.end();
+});
+
+test('filtered open', function (t) {
+	var reader = new kstat.Reader({ 'class': 'mib2' });
+	var results = reader.read();
+
+	check(t, results);
+});
+
+test('overly filtered open', function (t) {
+	var checkempty = function (spec) {
+		var reader = new kstat.Reader(spec);
+		var results = reader.read();
+		t.assert(results instanceof Array);
+		t.assert(results.length === 0);
+	};
+
+	checkempty({ class: 'doogle' });
+	checkempty({ module: 'bagnoogle' });
+	checkempty({ name: 'thesack' });
+	checkempty({ instance: 123724800 });
+	t.end();
+});
+
+test('failed read', function (t) {
+	var reader = new kstat.Reader();
+
+	t.throws(function () { reader.read(undefined); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read('fooey'); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read({ 'class': 1234 }); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read({ 'module': -1 }); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read({ 'name': false }); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read({ 'instance': 'doogle' }); },
+	    /illegal kstat specifier/);
+	t.throws(function () { reader.read({ 'class': 'blech' }, 123); },
+	    /illegal kstat specifier/);
+	t.end();
+});
+
+test('filtered read', function (t) {
+	var reader = new kstat.Reader();
+	var results = reader.read({ 'class': 'mib2' });
+
+	check(t, results);
+});
+
+test('overly filtered read', function (t) {
+	var checkempty = function (spec) {
+		var reader = new kstat.Reader();
+		var results = reader.read(spec);
+		t.assert(results instanceof Array);
+		t.assert(results.length === 0);
+	};
+
+	checkempty({ class: 'doogle' });
+	checkempty({ module: 'bagnoogle' });
+	checkempty({ name: 'thesack' });
+	checkempty({ instance: 123724800 });
+	t.end();
+});
diff --git a/test/close.js b/test/close.js
new file mode 100644
index 0000000..9ca0b3a
--- /dev/null
+++ b/test/close.js
@@ -0,0 +1,26 @@
+var kstat = require('kstat');
+var test = require('tape');
+
+test('basic close', function (t) {
+	var reader = new kstat.Reader({ 'module': 'memory_cap' });
+	reader.read();
+	reader.close();
+	t.pass('called close successfully');
+	t.end();
+});
+
+test('spurious read', function (t) {
+	var reader = new kstat.Reader({ 'module': 'memory_cap' });
+	reader.close();
+
+	t.throws(function () { reader.read(); }, /already been closed/);
+	t.end();
+});
+
+test('spurious close', function (t) {
+	var reader = new kstat.Reader({ 'module': 'memory_cap' });
+	reader.close();
+
+	t.throws(function () { reader.close(); }, /already been closed/);
+	t.end();
+});
diff --git a/test/filter.js b/test/filter.js
new file mode 100644
index 0000000..7175cbf
--- /dev/null
+++ b/test/filter.js
@@ -0,0 +1,92 @@
+/*
+ * filter.js: tests filtering in both the Reader constructor and read().
+ */
+
+var kstat = require('kstat');
+var test = require('tape');
+
+function kstatToIdent(stat)
+{
+	return ({
+	    'module': stat['module'],
+	    'name': stat['name'],
+	    'class': stat['class'],
+	    'instance': stat['instance']
+	});
+}
+
+function identCompare(k1, k2)
+{
+	var key1 = k1['module'] + '.' + k1['name'] + '.' + k1['class'] + '.' +
+	    k1['instance'];
+	var key2 = k2['module'] + '.' + k2['name'] + '.' + k2['class'] + '.' +
+	    k2['instance'];
+	if (key1 < key2)
+		return (-1);
+	if (key1 > key2)
+		return (1);
+	return (0);
+}
+
+var all_reader = new kstat.Reader({});
+var cpu_reader = new kstat.Reader({ 'module': 'cpu' });
+var ncpustats = 0;
+var cpustats, allstats;
+
+test('constructor-based filtering', function (t) {
+	allstats = all_reader.read();
+	t.assert(allstats.length > 0);
+	t.comment(allstats.length + ' total stats');
+
+	cpustats = cpu_reader.read();
+	t.assert(cpustats.length > 0);
+	t.assert(allstats.length > cpustats.length);
+	t.comment(cpustats.length + ' cpu stats');
+
+	allstats.forEach(function (stat) {
+		if (stat['module'] == 'cpu')
+			ncpustats++;
+	});
+
+	t.assert(cpustats.length == ncpustats);
+	t.end();
+});
+
+test('read-based filtering', function (t) {
+	var filteredstats = all_reader.read({ 'module': 'cpu' });
+	t.equal(filteredstats.length, ncpustats);
+	t.deepEqual(filteredstats.map(kstatToIdent).sort(identCompare),
+	    cpustats.map(kstatToIdent).sort(identCompare));
+
+	filteredstats = all_reader.read({ 'instance': 1 });
+	t.assert(filteredstats.length < allstats.length);
+	t.assert(filteredstats.length > 0);
+	filteredstats.forEach(
+	    function (stat) { t.equal(stat['instance'], 1); });
+	t.comment(filteredstats.length + ' stats with instance == 1');
+
+	filteredstats = all_reader.read({ 'class': 'net' });
+	t.assert(filteredstats.length < allstats.length);
+	t.assert(filteredstats.length > 0);
+	filteredstats.forEach(
+	    function (stat) { t.equal(stat['class'], 'net'); });
+	t.comment(filteredstats.length + ' stats with class == "net"');
+
+	filteredstats = all_reader.read({ 'name': 'intrstat' });
+	t.assert(filteredstats.length < allstats.length);
+	t.assert(filteredstats.length > 0);
+	filteredstats.forEach(
+	    function (stat) { t.equal(stat['name'], 'intrstat'); });
+	t.comment(filteredstats.length + ' stats with name == "intrstat"');
+	t.end();
+});
+
+test('both kinds of filtering', function (t) {
+	var filteredstats = cpu_reader.read({ 'instance': 0 });
+	t.assert(filteredstats.length < cpustats.length);
+	t.assert(filteredstats.length > 0);
+	filteredstats.forEach(
+	    function (stat) { t.assert(stat['instance'] === 0); });
+	t.comment(filteredstats.length + ' cpu stats with instance === 0');
+	t.end();
+});
diff --git a/tools/bashstyle b/tools/bashstyle
new file mode 100755
index 0000000..3ea6622
--- /dev/null
+++ b/tools/bashstyle
@@ -0,0 +1,175 @@
+#!/usr/bin/env node
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+/*
+ * bashstyle: check bash scripts for adherence to style guidelines, including:
+ *
+ *    o no lines longer than 80 characters
+ *    o file does not end with a blank line
+ *    o Do not use 'local' and var initialization *using a subshell* in the
+ *      same statement. See
+ *      <http://www.tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01>
+ *      for why not. Arguably this belongs in a separate 'bashlint'.
+ *
+ * Future enhancements could include:
+ *    o indents consistent with respect to tabs, spaces
+ *    o indents consistently sized (all are some multiple of the smallest
+ *      indent, which must be a tab or 4 or 8 spaces)
+ */
+
+var VERSION = '2.0.0';
+
+var mod_assert = require('assert');
+var mod_fs = require('fs');
+
+var nerrors = 0;
+
+main();
+process.exit(0);
+
+function main()
+{
+	var files = process.argv.slice(2);
+
+	if (files.length === 0) {
+		console.error('usage: %s file1 [...]',
+		    process.argv.slice(0, 2).join(' '));
+		process.exit(2);
+	}
+
+	files.forEach(checkFile);
+
+	if (nerrors != 0)
+		process.exit(1);
+}
+
+function checkFile(filename)
+{
+	var text = mod_fs.readFileSync(filename, 'utf-8');
+	var lines = text.split('\n');
+	var i;
+	var styled = false;
+	var styleStart;
+
+	mod_assert.ok(lines.length > 0);
+
+	/*
+	 * Expand tabs in each line and check for long lines.
+	 */
+	for (i = 1; i <= lines.length; i++) {
+		var line = expandTabs(lines[i - 1]);
+
+		if (i > 1 && lines[i-2].match(/# BASHSTYLED/)) {
+			continue;
+		}
+
+		if (line.match(/# BEGIN BASHSTYLED/)) {
+			styleStart = i;
+			styled = true;
+		}
+
+		if (line.match(/# END BASHSTYLED/)) {
+			if (styled != true) {
+				nerrors++;
+				console.log('%s: %d: END BASHSTYLED ' +
+				    'w/o corresponding BEGIN', filename, i);
+			}
+			styled = false;
+		}
+
+		/*JSSTYLED*/
+		if (!styled && line.match(/^\s*local\s+(\w+)\s*=.*\$\(/)) {
+			nerrors++;
+			/*JSSTYLED*/
+			var m = line.match(/^\s*local\s+(\w+)\s*=/);
+			console.log('%s: %d: declaring and setting a "local" ' +
+				'var in the same statement ' +
+				'ignores a subshell return code ' +
+				'<http://www.tldp.org/LDP/abs/html/' +
+				'localvar.html#EXITVALANOMALY01>: ' +
+				'local %s=...',
+				filename, i, m[1]);
+		}
+
+		// Regexplanation: non-[, [, space (contents) space, ], non-]
+		// groups before and after brackets to ease search/replace.
+		if (!styled && line.match(/(^|[^\[])\[(\s.+\s)\]([^\]])/)) {
+			nerrors++;
+			console.log('%s: %d: prefer [[ to [ for tests.',
+			    filename, i);
+		}
+
+		if (!styled && line.length > 80) {
+			nerrors++;
+			console.log('%s: %d: line exceeds 80 columns',
+			    filename, i);
+		}
+
+		if (!styled && line.match(/\s+$/)) {
+			nerrors++;
+			console.log('%s: %d: line ends in whitespace',
+			    filename, i);
+		}
+	}
+
+	if (styled) {
+		nerrors++;
+		console.log('%s: %d: BEGIN BASHSTYLED that does not END',
+		            filename, styleStart);
+	}
+
+
+	/*
+	 * No sane editor lets you save a file without a newline at the
+	 * very end.
+	 */
+	if (lines[lines.length - 1].length !== 0) {
+		nerrors++;
+		console.log('%s: %d: file does not end with newline',
+			filename, lines.length);
+	}
+
+	/*
+	 * Since the file will always end with a newline, the last entry of
+	 * "lines" will actually be blank.
+	 */
+	if (lines.length > 1 && lines[lines.length - 2].length === 0) {
+		nerrors++;
+		console.log('%s: %d: file ends with a blank line',
+		    filename, lines.length - 1);
+	}
+}
+
+function expandTabs(text)
+{
+	var out = '';
+	var col = 0;
+	var j, k;
+
+	for (j = 0; j < text.length; j++) {
+		if (text[j] != '\t') {
+			out += text[j];
+			col++;
+			continue;
+		}
+
+		k = 8 - (col % 8);
+		col += k;
+
+		do {
+			out += ' ';
+		} while (--k > 0);
+
+		col += k;
+	}
+
+	return (out);
+}
diff --git a/tools/cstyle.pl b/tools/cstyle.pl
new file mode 100755
index 0000000..e5f8c0a
--- /dev/null
+++ b/tools/cstyle.pl
@@ -0,0 +1,1002 @@
+#!/usr/bin/perl -w
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+# Copyright 2015 Toomas Soome <tsoome@me.com>
+# Copyright 2016 Nexenta Systems, Inc.
+#
+# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+# Copyright (c) 2015 by Delphix. All rights reserved.
+#
+# @(#)cstyle 1.58 98/09/09 (from shannon)
+#
+# cstyle - check for some common stylistic errors.
+#
+#	cstyle is a sort of "lint" for C coding style.
+#	It attempts to check for the style used in the
+#	kernel, sometimes known as "Bill Joy Normal Form".
+#
+#	There's a lot this can't check for, like proper indentation
+#	of code blocks.  There's also a lot more this could check for.
+#
+#	A note to the non perl literate:
+#
+#		perl regular expressions are pretty much like egrep
+#		regular expressions, with the following special symbols
+#
+#		\s	any space character
+#		\S	any non-space character
+#		\w	any "word" character [a-zA-Z0-9_]
+#		\W	any non-word character
+#		\d	a digit [0-9]
+#		\D	a non-digit
+#		\b	word boundary (between \w and \W)
+#		\B	non-word boundary
+#
+
+require 5.0;
+use IO::File;
+use Getopt::Std;
+use strict;
+
+my $usage =
+"usage: cstyle [-chpvCP] [-o constructs] file ...
+	-c	check continuation indentation inside functions
+	-h	perform heuristic checks that are sometimes wrong
+	-p	perform some of the more picky checks
+	-v	verbose
+	-C	don't check anything in header block comments
+	-P	check for use of non-POSIX types
+	-o constructs
+		allow a comma-seperated list of optional constructs:
+		    doxygen	allow doxygen-style block comments (/** /*!)
+		    splint	allow splint-style lint comments (/*@ ... @*/)
+";
+
+my %opts;
+
+if (!getopts("cho:pvCP", \%opts)) {
+	print $usage;
+	exit 2;
+}
+
+my $check_continuation = $opts{'c'};
+my $heuristic = $opts{'h'};
+my $picky = $opts{'p'};
+my $verbose = $opts{'v'};
+my $ignore_hdr_comment = $opts{'C'};
+my $check_posix_types = $opts{'P'};
+
+my $doxygen_comments = 0;
+my $splint_comments = 0;
+
+if (defined($opts{'o'})) {
+	for my $x (split /,/, $opts{'o'}) {
+		if ($x eq "doxygen") {
+			$doxygen_comments = 1;
+		} elsif ($x eq "splint") {
+			$splint_comments = 1;
+		} else {
+			print "cstyle: unrecognized construct \"$x\"\n";
+			print $usage;
+			exit 2;
+		}
+	}
+}
+
+my ($filename, $line, $prev);		# shared globals
+
+my $fmt;
+my $hdr_comment_start;
+
+if ($verbose) {
+	$fmt = "%s: %d: %s\n%s\n";
+} else {
+	$fmt = "%s: %d: %s\n";
+}
+
+if ($doxygen_comments) {
+	# doxygen comments look like "/*!" or "/**"; allow them.
+	$hdr_comment_start = qr/^\s*\/\*[\!\*]?$/;
+} else {
+	$hdr_comment_start = qr/^\s*\/\*$/;
+}
+
+# Note, following must be in single quotes so that \s and \w work right.
+my $typename = '(int|char|short|long|unsigned|float|double' .
+    '|\w+_t|struct\s+\w+|union\s+\w+|FILE)';
+
+# mapping of old types to POSIX compatible types
+my %old2posix = (
+	'unchar' => 'uchar_t',
+	'ushort' => 'ushort_t',
+	'uint' => 'uint_t',
+	'ulong' => 'ulong_t',
+	'u_int' => 'uint_t',
+	'u_short' => 'ushort_t',
+	'u_long' => 'ulong_t',
+	'u_char' => 'uchar_t',
+	'quad' => 'quad_t'
+);
+
+my $lint_re = qr/\/\*(?:
+	ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*|
+	CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY|
+	FALLTHRU|FALLTHROUGH|LINTED.*?|PRINTFLIKE[0-9]*|
+	PROTOLIB[0-9]*|SCANFLIKE[0-9]*|CSTYLED.*?
+    )\*\//x;
+
+my $splint_re = qr/\/\*@.*?@\*\//x;
+
+my $warlock_re = qr/\/\*\s*(?:
+	VARIABLES\ PROTECTED\ BY|
+	MEMBERS\ PROTECTED\ BY|
+	ALL\ MEMBERS\ PROTECTED\ BY|
+	READ-ONLY\ VARIABLES:|
+	READ-ONLY\ MEMBERS:|
+	VARIABLES\ READABLE\ WITHOUT\ LOCK:|
+	MEMBERS\ READABLE\ WITHOUT\ LOCK:|
+	LOCKS\ COVERED\ BY|
+	LOCK\ UNNEEDED\ BECAUSE|
+	LOCK\ NEEDED:|
+	LOCK\ HELD\ ON\ ENTRY:|
+	READ\ LOCK\ HELD\ ON\ ENTRY:|
+	WRITE\ LOCK\ HELD\ ON\ ENTRY:|
+	LOCK\ ACQUIRED\ AS\ SIDE\ EFFECT:|
+	READ\ LOCK\ ACQUIRED\ AS\ SIDE\ EFFECT:|
+	WRITE\ LOCK\ ACQUIRED\ AS\ SIDE\ EFFECT:|
+	LOCK\ RELEASED\ AS\ SIDE\ EFFECT:|
+	LOCK\ UPGRADED\ AS\ SIDE\ EFFECT:|
+	LOCK\ DOWNGRADED\ AS\ SIDE\ EFFECT:|
+	FUNCTIONS\ CALLED\ THROUGH\ POINTER|
+	FUNCTIONS\ CALLED\ THROUGH\ MEMBER|
+	LOCK\ ORDER:
+    )/x;
+
+my $err_stat = 0;		# exit status
+
+if ($#ARGV >= 0) {
+	foreach my $arg (@ARGV) {
+		my $fh = new IO::File $arg, "r";
+		if (!defined($fh)) {
+			printf "%s: can not open\n", $arg;
+		} else {
+			&cstyle($arg, $fh);
+			close $fh;
+		}
+	}
+} else {
+	&cstyle("<stdin>", *STDIN);
+}
+exit $err_stat;
+
+my $no_errs = 0;		# set for CSTYLED-protected lines
+
+sub err($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		if ($verbose) {
+			printf $fmt, $filename, $., $error, $line;
+		} else {
+			printf $fmt, $filename, $., $error;
+		}
+		$err_stat = 1;
+	}
+}
+
+sub err_prefix($$) {
+	my ($prevline, $error) = @_;
+	my $out = $prevline."\n".$line;
+	unless ($no_errs) {
+		if ($verbose) {
+			printf $fmt, $filename, $., $error, $out;
+		} else {
+			printf $fmt, $filename, $., $error;
+		}
+		$err_stat = 1;
+	}
+}
+
+sub err_prev($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		if ($verbose) {
+			printf $fmt, $filename, $. - 1, $error, $prev;
+		} else {
+			printf $fmt, $filename, $. - 1, $error;
+		}
+		$err_stat = 1;
+	}
+}
+
+sub cstyle($$) {
+
+my ($fn, $filehandle) = @_;
+$filename = $fn;			# share it globally
+
+my $in_cpp = 0;
+my $next_in_cpp = 0;
+
+my $in_comment = 0;
+my $in_header_comment = 0;
+my $comment_done = 0;
+my $in_warlock_comment = 0;
+my $in_function = 0;
+my $in_function_header = 0;
+my $function_header_full_indent = 0;
+my $in_declaration = 0;
+my $note_level = 0;
+my $nextok = 0;
+my $nocheck = 0;
+
+my $in_string = 0;
+
+my ($okmsg, $comment_prefix);
+
+$line = '';
+$prev = '';
+reset_indent();
+
+line: while (<$filehandle>) {
+	s/\r?\n$//;	# strip return and newline
+
+	# save the original line, then remove all text from within
+	# double or single quotes, we do not want to check such text.
+
+	$line = $_;
+
+	#
+	# C allows strings to be continued with a backslash at the end of
+	# the line.  We translate that into a quoted string on the previous
+	# line followed by an initial quote on the next line.
+	#
+	# (we assume that no-one will use backslash-continuation with character
+	# constants)
+	#
+	$_ = '"' . $_		if ($in_string && !$nocheck && !$in_comment);
+
+	#
+	# normal strings and characters
+	#
+	s/'([^\\']|\\[^xX0]|\\0[0-9]*|\\[xX][0-9a-fA-F]*)'/''/g;
+	s/"([^\\"]|\\.)*"/\"\"/g;
+
+	#
+	# detect string continuation
+	#
+	if ($nocheck || $in_comment) {
+		$in_string = 0;
+	} else {
+		#
+		# Now that all full strings are replaced with "", we check
+		# for unfinished strings continuing onto the next line.
+		#
+		$in_string =
+		    (s/([^"](?:"")*)"([^\\"]|\\.)*\\$/$1""/ ||
+		    s/^("")*"([^\\"]|\\.)*\\$/""/);
+	}
+
+	#
+	# figure out if we are in a cpp directive
+	#
+	$in_cpp = $next_in_cpp || /^\s*#/;	# continued or started
+	$next_in_cpp = $in_cpp && /\\$/;	# only if continued
+
+	# strip off trailing backslashes, which appear in long macros
+	s/\s*\\$//;
+
+	# an /* END CSTYLED */ comment ends a no-check block.
+	if ($nocheck) {
+		if (/\/\* *END *CSTYLED *\*\//) {
+			$nocheck = 0;
+		} else {
+			reset_indent();
+			next line;
+		}
+	}
+
+	# a /*CSTYLED*/ comment indicates that the next line is ok.
+	if ($nextok) {
+		if ($okmsg) {
+			err($okmsg);
+		}
+		$nextok = 0;
+		$okmsg = 0;
+		if (/\/\* *CSTYLED.*\*\//) {
+			/^.*\/\* *CSTYLED *(.*) *\*\/.*$/;
+			$okmsg = $1;
+			$nextok = 1;
+		}
+		$no_errs = 1;
+	} elsif ($no_errs) {
+		$no_errs = 0;
+	}
+
+	# check length of line.
+	# first, a quick check to see if there is any chance of being too long.
+	if (($line =~ tr/\t/\t/) * 7 + length($line) > 80) {
+		# yes, there is a chance.
+		# replace tabs with spaces and check again.
+		my $eline = $line;
+		1 while $eline =~
+		    s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
+		if (length($eline) > 80) {
+			err("line > 80 characters");
+		}
+	}
+
+	# ignore NOTE(...) annotations (assumes NOTE is on lines by itself).
+	if ($note_level || /\b_?NOTE\s*\(/) { # if in NOTE or this is NOTE
+		s/[^()]//g;			  # eliminate all non-parens
+		$note_level += s/\(//g - length;  # update paren nest level
+		next;
+	}
+
+	# a /* BEGIN CSTYLED */ comment starts a no-check block.
+	if (/\/\* *BEGIN *CSTYLED *\*\//) {
+		$nocheck = 1;
+	}
+
+	# a /*CSTYLED*/ comment indicates that the next line is ok.
+	if (/\/\* *CSTYLED.*\*\//) {
+		/^.*\/\* *CSTYLED *(.*) *\*\/.*$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+	if (/\/\/ *CSTYLED/) {
+		/^.*\/\/ *CSTYLED *(.*)$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+
+	# universal checks; apply to everything
+	if (/\t +\t/) {
+		err("spaces between tabs");
+	}
+	if (/ \t+ /) {
+		err("tabs between spaces");
+	}
+	if (/\s$/) {
+		err("space or tab at end of line");
+	}
+	if (/[^ \t(]\/\*/ && !/\w\(\/\*.*\*\/\);/) {
+		err("comment preceded by non-blank");
+	}
+
+	# is this the beginning or ending of a function?
+	# (not if "struct foo\n{\n")
+	if (/^{$/ && $prev =~ /\)\s*(const\s*)?(\/\*.*\*\/\s*)?\\?$/) {
+		$in_function = 1;
+		$in_declaration = 1;
+		$in_function_header = 0;
+		$function_header_full_indent = 0;
+		$prev = $line;
+		next line;
+	}
+	if (/^}\s*(\/\*.*\*\/\s*)*$/) {
+		if ($prev =~ /^\s*return\s*;/) {
+			err_prev("unneeded return at end of function");
+		}
+		$in_function = 0;
+		reset_indent();		# we don't check between functions
+		$prev = $line;
+		next line;
+	}
+	if ($in_function_header && ! /^    (\w|\.)/ ) {
+		if (/^{}$/) {
+			$in_function_header = 0;
+			$function_header_full_indent = 0;
+		} elsif ($picky && ! (/^\t/ && $function_header_full_indent != 0)) {
+			err("continuation line should be indented by 4 spaces");
+		}
+	}
+
+	#
+	# If this matches something of form "foo(", it's probably a function
+	# definition, unless it ends with ") bar;", in which case it's a declaration
+	# that uses a macro to generate the type.
+	#
+	if (/^\w+\(/ && !/\) \w+;$/) {
+		$in_function_header = 1;
+		if (/\($/) {
+			$function_header_full_indent = 1;
+		}
+	}
+	if ($in_function_header && /^{$/) {
+		$in_function_header = 0;
+		$function_header_full_indent = 0;
+		$in_function = 1;
+	}
+	if ($in_function_header && /\);$/) {
+		$in_function_header = 0;
+		$function_header_full_indent = 0;
+	}
+	if ($in_function_header && /{$/ ) {
+		if ($picky) {
+			err("opening brace on same line as function header");
+		}
+		$in_function_header = 0;
+		$function_header_full_indent = 0;
+		$in_function = 1;
+		next line;
+	}
+
+	if ($in_warlock_comment && /\*\//) {
+		$in_warlock_comment = 0;
+		$prev = $line;
+		next line;
+	}
+
+	# a blank line terminates the declarations within a function.
+	# XXX - but still a problem in sub-blocks.
+	if ($in_declaration && /^$/) {
+		$in_declaration = 0;
+	}
+
+	if ($comment_done) {
+		$in_comment = 0;
+		$in_header_comment = 0;
+		$comment_done = 0;
+	}
+	# does this looks like the start of a block comment?
+	if (/$hdr_comment_start/) {
+		if (!/^\t*\/\*/) {
+			err("block comment not indented by tabs");
+		}
+		$in_comment = 1;
+		/^(\s*)\//;
+		$comment_prefix = $1;
+		if ($comment_prefix eq "") {
+			$in_header_comment = 1;
+		}
+		$prev = $line;
+		next line;
+	}
+	# are we still in the block comment?
+	if ($in_comment) {
+		if (/^$comment_prefix \*\/$/) {
+			$comment_done = 1;
+		} elsif (/\*\//) {
+			$comment_done = 1;
+			err("improper block comment close")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		} elsif (!/^$comment_prefix \*[ \t]/ &&
+		    !/^$comment_prefix \*$/) {
+			err("improper block comment")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		}
+	}
+
+	if ($in_header_comment && $ignore_hdr_comment) {
+		$prev = $line;
+		next line;
+	}
+
+	# check for errors that might occur in comments and in code.
+
+	# allow spaces to be used to draw pictures in header comments.
+	if (/[^ ]     / && !/".*     .*"/ && !$in_header_comment) {
+		err("spaces instead of tabs");
+	}
+	if (/^ / && !/^ \*[ \t\/]/ && !/^ \*$/ &&
+	    (!/^    (\w|\.)/ || $in_function != 0)) {
+		err("indent by spaces instead of tabs");
+	}
+	if (/^\t+ [^ \t\*]/ || /^\t+  \S/ || /^\t+   \S/) {
+		err("continuation line not indented by 4 spaces");
+	}
+	if (/$warlock_re/ && !/\*\//) {
+		$in_warlock_comment = 1;
+		$prev = $line;
+		next line;
+	}
+	if (/^\s*\/\*./ && !/^\s*\/\*.*\*\// && !/$hdr_comment_start/) {
+		err("improper first line of block comment");
+	}
+
+	if ($in_comment) {	# still in comment, don't do further checks
+		$prev = $line;
+		next line;
+	}
+
+	if ((/[^(]\/\*\S/ || /^\/\*\S/) &&
+	    !(/$lint_re/ || ($splint_comments && /$splint_re/))) {
+		err("missing blank after open comment");
+	}
+	if (/\S\*\/[^)]|\S\*\/$/ &&
+	    !(/$lint_re/ || ($splint_comments && /$splint_re/))) {
+		err("missing blank before close comment");
+	}
+	if (/\/\/\S/) {		# C++ comments
+		err("missing blank after start comment");
+	}
+	# check for unterminated single line comments, but allow them when
+	# they are used to comment out the argument list of a function
+	# declaration.
+	if (/\S.*\/\*/ && !/\S.*\/\*.*\*\// && !/\(\/\*/) {
+		err("unterminated single line comment");
+	}
+
+	if (/^(#else|#endif|#include)(.*)$/) {
+		$prev = $line;
+		if ($picky) {
+			my $directive = $1;
+			my $clause = $2;
+			# Enforce ANSI rules for #else and #endif: no noncomment
+			# identifiers are allowed after #endif or #else.  Allow
+			# C++ comments since they seem to be a fact of life.
+			if ((($1 eq "#endif") || ($1 eq "#else")) &&
+			    ($clause ne "") &&
+			    (!($clause =~ /^\s+\/\*.*\*\/$/)) &&
+			    (!($clause =~ /^\s+\/\/.*$/))) {
+				err("non-comment text following " .
+				    "$directive (or malformed $directive " .
+				    "directive)");
+			}
+		}
+		next line;
+	}
+
+	#
+	# delete any comments and check everything else.  Note that
+	# ".*?" is a non-greedy match, so that we don't get confused by
+	# multiple comments on the same line.
+	#
+	s/\/\*.*?\*\///g;
+	s/\/\/.*$//;		# C++ comments
+
+	# delete any trailing whitespace; we have already checked for that.
+	s/\s*$//;
+
+	# following checks do not apply to text in comments.
+
+	if (/[^<>\s][!<>=]=/ || /[^<>][!<>=]=[^\s,]/ ||
+	    (/[^->]>[^,=>\s]/ && !/[^->]>$/) ||
+	    (/[^<]<[^,=<\s]/ && !/[^<]<$/) ||
+	    /[^<\s]<[^<]/ || /[^->\s]>[^>]/) {
+		err("missing space around relational operator");
+	}
+	if (/\S>>=/ || /\S<<=/ || />>=\S/ || /<<=\S/ || /\S[-+*\/&|^%]=/ ||
+	    (/[^-+*\/&|^%!<>=\s]=[^=]/ && !/[^-+*\/&|^%!<>=\s]=$/) ||
+	    (/[^!<>=]=[^=\s]/ && !/[^!<>=]=$/)) {
+		# XXX - should only check this for C++ code
+		# XXX - there are probably other forms that should be allowed
+		if (!/\soperator=/) {
+			err("missing space around assignment operator");
+		}
+	}
+	if (/[,;]\S/ && !/\bfor \(;;\)/) {
+		err("comma or semicolon followed by non-blank");
+	}
+	# allow "for" statements to have empty "while" clauses
+	if (/\s[,;]/ && !/^[\t]+;$/ && !/^\s*for \([^;]*; ;[^;]*\)/) {
+		err("comma or semicolon preceded by blank");
+	}
+	if (/^\s*(&&|\|\|)/) {
+		err("improper boolean continuation");
+	}
+	if (/\S   *(&&|\|\|)/ || /(&&|\|\|)   *\S/) {
+		err("more than one space around boolean operator");
+	}
+	if (/\b(for|if|while|switch|sizeof|return|case)\(/) {
+		err("missing space between keyword and paren");
+	}
+	if (/(\b(for|if|while|switch|return)\b.*){2,}/ && !/^#define/) {
+		# multiple "case" and "sizeof" allowed
+		err("more than one keyword on line");
+	}
+	if (/\b(for|if|while|switch|sizeof|return|case)\s\s+\(/ &&
+	    !/^#if\s+\(/) {
+		err("extra space between keyword and paren");
+	}
+	# try to detect "func (x)" but not "if (x)" or
+	# "#define foo (x)" or "int (*func)();"
+	if (/\w\s\(/) {
+		my $s = $_;
+		# strip off all keywords on the line
+		s/\b(for|if|while|switch|return|case|sizeof)\s\(/XXX(/g;
+		s/#elif\s\(/XXX(/g;
+		s/^#define\s+\w+\s+\(/XXX(/;
+		# do not match things like "void (*f)();"
+		# or "typedef void (func_t)();"
+		s/\w\s\(+\*/XXX(*/g;
+		s/\b($typename|void)\s+\(+/XXX(/og;
+		if (/\w\s\(/) {
+			err("extra space between function name and left paren");
+		}
+		$_ = $s;
+	}
+	# try to detect "int foo(x)", but not "extern int foo(x);"
+	# XXX - this still trips over too many legitimate things,
+	# like "int foo(x,\n\ty);"
+#		if (/^(\w+(\s|\*)+)+\w+\(/ && !/\)[;,](\s|)*$/ &&
+#		    !/^(extern|static)\b/) {
+#			err("return type of function not on separate line");
+#		}
+	# this is a close approximation
+	if (/^(\w+(\s|\*)+)+\w+\(.*\)(\s|)*$/ &&
+	    !/^(extern|static)\b/) {
+		err("return type of function not on separate line");
+	}
+	if (/^#define /) {
+		err("#define followed by space instead of tab");
+	}
+	if (/^\s*return\W[^;]*;/ && !/^\s*return\s*\(.*\);/) {
+		err("unparenthesized return expression");
+	}
+	if (/\bsizeof\b/ && !/\bsizeof\s*\(.*\)/) {
+		err("unparenthesized sizeof expression");
+	}
+	if (/\(\s/) {
+		err("whitespace after left paren");
+	}
+	# allow "for" statements to have empty "continue" clauses
+	if (/\s\)/ && !/^\s*for \([^;]*;[^;]*; \)/) {
+		err("whitespace before right paren");
+	}
+	if (/^\s*\(void\)[^ ]/) {
+		err("missing space after (void) cast");
+	}
+	if (/\S\{/ && !/\{\{/) {
+		err("missing space before left brace");
+	}
+	if ($in_function && /^\s+{/ &&
+	    ($prev =~ /\)\s*$/ || $prev =~ /\bstruct\s+\w+$/)) {
+		err("left brace starting a line");
+	}
+	if (/}(else|while)/) {
+		err("missing space after right brace");
+	}
+	if (/}\s\s+(else|while)/) {
+		err("extra space after right brace");
+	}
+	if (/\b_VOID\b|\bVOID\b|\bSTATIC\b/) {
+		err("obsolete use of VOID or STATIC");
+	}
+	if (/\b$typename\*/o) {
+		err("missing space between type name and *");
+	}
+	if (/^\s+#/) {
+		err("preprocessor statement not in column 1");
+	}
+	if (/^#\s/) {
+		err("blank after preprocessor #");
+	}
+	if (/!\s*(strcmp|strncmp|bcmp)\s*\(/) {
+		err("don't use boolean ! with comparison functions");
+	}
+
+	#
+	# We completely ignore, for purposes of indentation:
+	#  * lines outside of functions
+	#  * preprocessor lines
+	#
+	if ($check_continuation && $in_function && !$in_cpp) {
+		process_indent($_);
+	}
+	if ($picky) {
+		# try to detect spaces after casts, but allow (e.g.)
+		# "sizeof (int) + 1", "void (*funcptr)(int) = foo;", and
+		# "int foo(int) __NORETURN;"
+		if ((/^\($typename( \*+)?\)\s/o ||
+		    /\W\($typename( \*+)?\)\s/o) &&
+		    !/sizeof\s*\($typename( \*)?\)\s/o &&
+		    !/\($typename( \*+)?\)\s+=[^=]/o) {
+			err("space after cast");
+		}
+		if (/\b$typename\s*\*\s/o &&
+		    !/\b$typename\s*\*\s+const\b/o) {
+			err("unary * followed by space");
+		}
+	}
+	if ($check_posix_types) {
+		# try to detect old non-POSIX types.
+		# POSIX requires all non-standard typedefs to end in _t,
+		# but historically these have been used.
+		if (/\b(unchar|ushort|uint|ulong|u_int|u_short|u_long|u_char|quad)\b/) {
+			err("non-POSIX typedef $1 used: use $old2posix{$1} instead");
+		}
+	}
+	if ($heuristic) {
+		# cannot check this everywhere due to "struct {\n...\n} foo;"
+		if ($in_function && !$in_declaration &&
+		    /}./ && !/}\s+=/ && !/{.*}[;,]$/ && !/}(\s|)*$/ &&
+		    !/} (else|while)/ && !/}}/) {
+			err("possible bad text following right brace");
+		}
+		# cannot check this because sub-blocks in
+		# the middle of code are ok
+		if ($in_function && /^\s+{/) {
+			err("possible left brace starting a line");
+		}
+	}
+	if (/^\s*else\W/) {
+		if ($prev =~ /^\s*}$/) {
+			err_prefix($prev,
+			    "else and right brace should be on same line");
+		}
+	}
+	$prev = $line;
+}
+
+if ($prev eq "") {
+	err("last line in file is blank");
+}
+
+}
+
+#
+# Continuation-line checking
+#
+# The rest of this file contains the code for the continuation checking
+# engine.  It's a pretty simple state machine which tracks the expression
+# depth (unmatched '('s and '['s).
+#
+# Keep in mind that the argument to process_indent() has already been heavily
+# processed; all comments have been replaced by control-A, and the contents of
+# strings and character constants have been elided.
+#
+
+my $cont_in;		# currently inside of a continuation
+my $cont_off;		# skipping an initializer or definition
+my $cont_noerr;		# suppress cascading errors
+my $cont_start;		# the line being continued
+my $cont_base;		# the base indentation
+my $cont_first;		# this is the first line of a statement
+my $cont_multiseg;	# this continuation has multiple segments
+
+my $cont_special;	# this is a C statement (if, for, etc.)
+my $cont_macro;		# this is a macro
+my $cont_case;		# this is a multi-line case
+
+my @cont_paren;		# the stack of unmatched ( and [s we've seen
+
+sub
+reset_indent()
+{
+	$cont_in = 0;
+	$cont_off = 0;
+}
+
+sub
+delabel($)
+{
+	#
+	# replace labels with tabs.  Note that there may be multiple
+	# labels on a line.
+	#
+	local $_ = $_[0];
+
+	while (/^(\t*)( *(?:(?:\w+\s*)|(?:case\b[^:]*)): *)(.*)$/) {
+		my ($pre_tabs, $label, $rest) = ($1, $2, $3);
+		$_ = $pre_tabs;
+		while ($label =~ s/^([^\t]*)(\t+)//) {
+			$_ .= "\t" x (length($2) + length($1) / 8);
+		}
+		$_ .= ("\t" x (length($label) / 8)).$rest;
+	}
+
+	return ($_);
+}
+
+sub
+process_indent($)
+{
+	require strict;
+	local $_ = $_[0];			# preserve the global $_
+
+	s///g;	# No comments
+	s/\s+$//;	# Strip trailing whitespace
+
+	return			if (/^$/);	# skip empty lines
+
+	# regexps used below; keywords taking (), macros, and continued cases
+	my $special = '(?:(?:\}\s*)?else\s+)?(?:if|for|while|switch)\b';
+	my $macro = '[A-Z_][A-Z_0-9]*\(';
+	my $case = 'case\b[^:]*$';
+
+	# skip over enumerations, array definitions, initializers, etc.
+	if ($cont_off <= 0 && !/^\s*$special/ &&
+	    (/(?:(?:\b(?:enum|struct|union)\s*[^\{]*)|(?:\s+=\s*)){/ ||
+	    (/^\s*{/ && $prev =~ /=\s*(?:\/\*.*\*\/\s*)*$/))) {
+		$cont_in = 0;
+		$cont_off = tr/{/{/ - tr/}/}/;
+		return;
+	}
+	if ($cont_off) {
+		$cont_off += tr/{/{/ - tr/}/}/;
+		return;
+	}
+
+	if (!$cont_in) {
+		$cont_start = $line;
+
+		if (/^\t* /) {
+			err("non-continuation indented 4 spaces");
+			$cont_noerr = 1;		# stop reporting
+		}
+		$_ = delabel($_);	# replace labels with tabs
+
+		# check if the statement is complete
+		return		if (/^\s*\}?$/);
+		return		if (/^\s*\}?\s*else\s*\{?$/);
+		return		if (/^\s*do\s*\{?$/);
+		return		if (/{$/);
+		return		if (/}[,;]?$/);
+
+		# Allow macros on their own lines
+		return		if (/^\s*[A-Z_][A-Z_0-9]*$/);
+
+		# cases we don't deal with, generally non-kosher
+		if (/{/) {
+			err("stuff after {");
+			return;
+		}
+
+		# Get the base line, and set up the state machine
+		/^(\t*)/;
+		$cont_base = $1;
+		$cont_in = 1;
+		@cont_paren = ();
+		$cont_first = 1;
+		$cont_multiseg = 0;
+
+		# certain things need special processing
+		$cont_special = /^\s*$special/? 1 : 0;
+		$cont_macro = /^\s*$macro/? 1 : 0;
+		$cont_case = /^\s*$case/? 1 : 0;
+	} else {
+		$cont_first = 0;
+
+		# Strings may be pulled back to an earlier (half-)tabstop
+		unless ($cont_noerr || /^$cont_base    / ||
+		    (/^\t*(?:    )?(?:gettext\()?\"/ && !/^$cont_base\t/)) {
+			err_prefix($cont_start,
+			    "continuation should be indented 4 spaces");
+		}
+	}
+
+	my $rest = $_;			# keeps the remainder of the line
+
+	#
+	# The split matches 0 characters, so that each 'special' character
+	# is processed separately.  Parens and brackets are pushed and
+	# popped off the @cont_paren stack.  For normal processing, we wait
+	# until a ; or { terminates the statement.  "special" processing
+	# (if/for/while/switch) is allowed to stop when the stack empties,
+	# as is macro processing.  Case statements are terminated with a :
+	# and an empty paren stack.
+	#
+	foreach $_ (split /[^\(\)\[\]\{\}\;\:]*/) {
+		next		if (length($_) == 0);
+
+		# rest contains the remainder of the line
+		my $rxp = "[^\Q$_\E]*\Q$_\E";
+		$rest =~ s/^$rxp//;
+
+		if (/\(/ || /\[/) {
+			push @cont_paren, $_;
+		} elsif (/\)/ || /\]/) {
+			my $cur = $_;
+			tr/\)\]/\(\[/;
+
+			my $old = (pop @cont_paren);
+			if (!defined($old)) {
+				err("unexpected '$cur'");
+				$cont_in = 0;
+				last;
+			} elsif ($old ne $_) {
+				err("'$cur' mismatched with '$old'");
+				$cont_in = 0;
+				last;
+			}
+
+			#
+			# If the stack is now empty, do special processing
+			# for if/for/while/switch and macro statements.
+			#
+			next		if (@cont_paren != 0);
+			if ($cont_special) {
+				if ($rest =~ /^\s*{?$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*;$/) {
+					err("empty if/for/while body ".
+					    "not on its own line");
+					$cont_in = 0;
+					last;
+				}
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				# We've finished this section, start
+				# processing the next.
+				goto section_ended;
+			}
+			if ($cont_macro) {
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+			}
+		} elsif (/\;/) {
+			if ($cont_case) {
+				err("unexpected ;");
+			} elsif (!$cont_special) {
+				err("unexpected ;")	if (@cont_paren != 0);
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*special/) {
+					err("if/for/while/switch not started ".
+					    "on its own line");
+				}
+				goto section_ended;
+			}
+		} elsif (/\{/) {
+			err("{ while in parens/brackets") if (@cont_paren != 0);
+			err("stuff after {")		if ($rest =~ /[^\s}]/);
+			$cont_in = 0;
+			last;
+		} elsif (/\}/) {
+			err("} while in parens/brackets") if (@cont_paren != 0);
+			if (!$cont_special && $rest !~ /^\s*(while|else)\b/) {
+				if ($rest =~ /^$/) {
+					err("unexpected }");
+				} else {
+					err("stuff after }");
+				}
+				$cont_in = 0;
+				last;
+			}
+		} elsif (/\:/ && $cont_case && @cont_paren == 0) {
+			err("stuff after multi-line case") if ($rest !~ /$^/);
+			$cont_in = 0;
+			last;
+		}
+		next;
+section_ended:
+		# End of a statement or if/while/for loop.  Reset
+		# cont_special and cont_macro based on the rest of the
+		# line.
+		$cont_special = ($rest =~ /^\s*$special/)? 1 : 0;
+		$cont_macro = ($rest =~ /^\s*$macro/)? 1 : 0;
+		$cont_case = 0;
+		next;
+	}
+	$cont_noerr = 0			if (!$cont_in);
+}
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
new file mode 100644
index 0000000..c44e8ee
--- /dev/null
+++ b/tools/jsl.node.conf
@@ -0,0 +1,139 @@
+#
+# Configuration File for JavaScript Lint 
+#
+# This configuration file can be used to lint a collection of scripts, or to enable
+# or disable warnings for scripts that are linted via the command line.
+#
+
+### Warnings
+# Enable or disable warnings based on requirements.
+# Use "+WarningName" to display or "-WarningName" to suppress.
+#
++ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
++ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
++ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
++anon_no_return_value         # anonymous function does not always return value
++assign_to_function_call      # assignment to a function call
+-block_without_braces         # block statement without curly braces
++comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
++comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
++default_not_at_end           # the default case is not at the end of the switch statement
++dup_option_explicit          # duplicate "option explicit" control comment
++duplicate_case_in_switch     # duplicate case in switch statement
++duplicate_formal             # duplicate formal argument {name}
++empty_statement              # empty statement or extra semicolon
++identifier_hides_another     # identifer {name} hides an identifier in a parent scope
+-inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
++incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
++invalid_fallthru             # unexpected "fallthru" control comment
++invalid_pass                 # unexpected "pass" control comment
++jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
++leading_decimal_point        # leading decimal point may indicate a number or an object member
++legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
++meaningless_block            # meaningless block; curly braces have no impact
++mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
++misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
++missing_break                # missing break statement
++missing_break_for_last_case  # missing break statement for last case in switch
++missing_default_case         # missing default case in switch statement
++missing_option_explicit      # the "option explicit" control comment is missing
++missing_semicolon            # missing semicolon
++missing_semicolon_for_lambda # missing semicolon for lambda assignment
++multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
++nested_comment               # nested comment
++no_return_value              # function {name} does not always return a value
++octal_number                 # leading zeros make an octal number
++parseint_missing_radix       # parseInt missing radix parameter
++partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
++redeclared_var               # redeclaration of {name}
++trailing_comma_in_array      # extra comma is not recommended in array initializers
++trailing_decimal_point       # trailing decimal point may indicate a number or an object member
++undeclared_identifier        # undeclared identifier: {name}
++unreachable_code             # unreachable code
+-unreferenced_argument        # argument declared but never referenced: {name}
+-unreferenced_function        # function is declared but never referenced: {name}
++unreferenced_variable        # variable is declared but never referenced: {name}
++unsupported_version          # JavaScript {version} is not supported
++use_of_label                 # use of label
++useless_assign               # useless assignment
++useless_comparison           # useless comparison; comparing identical expressions
+-useless_quotes               # the quotation marks are unnecessary
++useless_void                 # use of the void type may be unnecessary (void is always undefined)
++var_hides_arg                # variable {name} hides argument
++want_assign_or_call          # expected an assignment or function call
++with_statement               # with statement hides undeclared variables; use temporary variable instead
+
+
+### Output format
+# Customize the format of the error message.
+#    __FILE__ indicates current file path
+#    __FILENAME__ indicates current file name
+#    __LINE__ indicates current line
+#    __COL__ indicates current column
+#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
+#    __ERROR_NAME__ indicates error name (used in configuration file)
+#    __ERROR_PREFIX__ indicates error prefix
+#    __ERROR_MSG__ indicates error message
+#
+# For machine-friendly output, the output format can be prefixed with
+# "encode:". If specified, all items will be encoded with C-slashes.
+#
+# Visual Studio syntax (default):
++output-format __FILE__(__LINE__): __ERROR__
+# Alternative syntax:
+#+output-format __FILE__:__LINE__: __ERROR__
+
+
+### Context
+# Show the in-line position of the error.
+# Use "+context" to display or "-context" to suppress.
+#
++context
+
+
+### Control Comments
+# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
+# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
+# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
+# although legacy control comments are enabled by default for backward compatibility.
+#
+-legacy_control_comments
+
+
+### Defining identifiers
+# By default, "option explicit" is enabled on a per-file basis.
+# To enable this for all files, use "+always_use_option_explicit"
+-always_use_option_explicit
+
+# Define certain identifiers of which the lint is not aware.
+# (Use this in conjunction with the "undeclared identifier" warning.)
+#
+# Common uses for webpages might be:
++define __dirname
++define clearInterval
++define clearTimeout
++define console
++define exports
++define global
++define module
++define process
++define require
++define setInterval
++define setImmediate
++define setTimeout
++define Buffer
++define JSON
++define Math
+
+### JavaScript Version
+# To change the default JavaScript version:
+#+default-type text/javascript;version=1.5
+#+default-type text/javascript;e4x=1
+
+### Files
+# Specify which files to lint
+# Use "+recurse" to enable recursion (disabled by default).
+# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
+# or "+process Folder\Path\*.htm".
+#
+
diff --git a/tools/jsstyle b/tools/jsstyle
new file mode 100755
index 0000000..7f86ae7
--- /dev/null
+++ b/tools/jsstyle
@@ -0,0 +1,967 @@
+#!/usr/bin/env perl
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+#
+# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+# Copyright 2016 Joyent, Inc. All rights reserved.
+#
+# jsstyle - check for some common stylistic errors.
+#
+#	jsstyle is a sort of "lint" for Javascript coding style.  This tool is
+#	derived from the cstyle tool, used to check for the style used in the
+#	Solaris kernel, sometimes known as "Bill Joy Normal Form".
+#
+#	There's a lot this can't check for, like proper indentation of code
+#	blocks.  There's also a lot more this could check for.
+#
+#	A note to the non perl literate:
+#
+#		perl regular expressions are pretty much like egrep
+#		regular expressions, with the following special symbols
+#
+#		\s	any space character
+#		\S	any non-space character
+#		\w	any "word" character [a-zA-Z0-9_]
+#		\W	any non-word character
+#		\d	a digit [0-9]
+#		\D	a non-digit
+#		\b	word boundary (between \w and \W)
+#		\B	non-word boundary
+#
+
+require 5.0;
+use IO::File;
+use Getopt::Std;
+use strict;
+
+my $usage =
+"Usage: jsstyle [-h?vcC] [-t <num>] [-f <path>] [-o <config>] file ...
+
+Check your JavaScript file for style.
+See <https://github.com/davepacheco/jsstyle> for details on config options.
+Report bugs to <https://github.com/davepacheco/jsstyle/issues>.
+
+Options:
+	-h 	print this help and exit
+	-v	verbose
+
+	-c	check continuation indentation inside functions
+	-t	specify tab width for line length calculation
+	-C	don't check anything in header block comments
+
+	-f PATH
+		path to a jsstyle config file
+	-o OPTION1,OPTION2
+		set config options, e.g. '-o doxygen,indent=2'
+
+";
+
+my %opts;
+
+if (!getopts("ch?o:t:f:vC", \%opts)) {
+	print $usage;
+	exit 2;
+}
+
+if (defined($opts{'h'}) || defined($opts{'?'})) {
+	print $usage;
+	exit;
+}
+
+my $check_continuation = $opts{'c'};
+my $verbose = $opts{'v'};
+my $ignore_hdr_comment = $opts{'C'};
+my $tab_width = $opts{'t'};
+
+# By default, tabs are 8 characters wide
+if (! defined($opts{'t'})) {
+	$tab_width = 8;
+}
+
+
+# Load config
+my %config = (
+	indent => "tab",
+	"line-length" => 80,
+	doxygen => 0,  	# doxygen comments: /** ... */
+	splint => 0,    # splint comments. Needed?
+	"unparenthesized-return" => 1,
+	"literal-string-quote" => "single",  # 'single' or 'double'
+	"blank-after-start-comment" => 1,
+	"blank-after-open-comment" => 1,
+	"no-blank-for-anon-function" => 0,
+	"continuation-at-front" => 0,
+	"leading-right-paren-ok" => 0,
+	"strict-indent" => 0
+);
+sub add_config_var ($$) {
+	my ($scope, $str) = @_;
+
+	if ($str !~ /^([\w-]+)(?:\s*=\s*(.*?))?$/) {
+		die "$scope: invalid option: '$str'";
+	}
+	my $name = $1;
+	my $value = ($2 eq '' ? 1 : $2);
+	#print "scope: '$scope', str: '$str', name: '$name', value: '$value'\n";
+
+	# Validate config var.
+	if ($name eq "indent") {
+		# A number of spaces or "tab".
+		if ($value !~ /^\d+$/ && $value ne "tab") {
+			die "$scope: invalid '$name': must be a number (of ".
+				"spaces) or 'tab'";
+		}
+	} elsif ($name eq "line-length") { # numeric vars
+		if ($value !~ /^\d+$/) {
+			die "$scope: invalid '$name': must be a number";
+		}
+	} elsif ($name eq "doxygen" ||   # boolean vars
+		 $name eq "splint" ||
+		 $name eq "unparenthesized-return" ||
+		 $name eq "continuation-at-front" ||
+		 $name eq "leading-right-paren-ok" ||
+		 $name eq "leading-comma-ok" ||
+		 $name eq "uncuddled-else-ok" ||
+		 $name eq "whitespace-after-left-paren-ok" ||
+		 $name eq "strict-indent" ||
+		 $name eq "blank-after-open-comment" ||
+		 $name eq "blank-after-start-comment" ||
+		 $name eq "no-blank-for-anon-function") {
+
+		if ($value != 1 && $value != 0) {
+			die "$scope: invalid '$name': don't give a value";
+		}
+	} elsif ($name eq "literal-string-quote") {
+		if ($value !~ /single|double/) {
+			die "$scope: invalid '$name': must be 'single' ".
+				"or 'double'";
+		}
+	} else {
+		die "$scope: unknown config var: $name";
+	}
+	$config{$name} = $value;
+}
+
+if (defined($opts{'f'})) {
+	my $path = $opts{'f'};
+	my $fh = new IO::File $path, "r";
+	if (!defined($fh)) {
+		die "cannot open config path '$path'";
+	}
+	my $line = 0;
+	while (<$fh>) {
+		$line++;
+		s/^\s*//;  # drop leading space
+		s/\s*$//;  # drop trailing space
+		next if ! $_;  # skip empty line
+		next if /^#/;  # skip comments
+		add_config_var "$path:$line", $_;
+	}
+}
+
+if (defined($opts{'o'})) {
+	for my $x (split /,/, $opts{'o'}) {
+		add_config_var "'-o' option", $x;
+	}
+}
+
+
+my ($filename, $line, $prev);		# shared globals
+
+my $fmt;
+my $hdr_comment_start;
+
+if ($verbose) {
+	$fmt = "%s: %d: %s\n%s\n";
+} else {
+	$fmt = "%s: %d: %s\n";
+}
+
+if ($config{"doxygen"}) {
+	# doxygen comments look like "/*!" or "/**"; allow them.
+	$hdr_comment_start = qr/^\s*\/\*[\!\*]?$/;
+} else {
+	$hdr_comment_start = qr/^\s*\/\*$/;
+}
+
+# Note, following must be in single quotes so that \s and \w work right.
+my $lint_re = qr/\/\*(?:
+	jsl:\w+?|ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*|
+	CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY|
+	FALLTHRU|FALLTHROUGH|LINTED.*?|PRINTFLIKE[0-9]*|
+	PROTOLIB[0-9]*|SCANFLIKE[0-9]*|JSSTYLED.*?
+    )\*\//x;
+
+my $splint_re = qr/\/\*@.*?@\*\//x;
+
+my $err_stat = 0;		# exit status
+
+if ($#ARGV >= 0) {
+	foreach my $arg (@ARGV) {
+		open(my $fh, "<:encoding(UTF-8)", $arg);
+		if (!defined($fh)) {
+			printf "%s: cannot open\n", $arg;
+		} else {
+			&jsstyle($arg, $fh);
+			close $fh;
+		}
+	}
+} else {
+	&jsstyle("<stdin>", *STDIN);
+}
+exit $err_stat;
+
+my $no_errs = 0;		# set for JSSTYLED-protected lines
+
+sub err($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		printf $fmt, $filename, $., $error, $line;
+		$err_stat = 1;
+	}
+}
+
+sub err_prefix($$) {
+	my ($prevline, $error) = @_;
+	my $out = $prevline."\n".$line;
+	unless ($no_errs) {
+		printf $fmt, $filename, $., $error, $out;
+		$err_stat = 1;
+	}
+}
+
+sub err_prev($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		printf $fmt, $filename, $. - 1, $error, $prev;
+		$err_stat = 1;
+	}
+}
+
+sub jsstyle($$) {
+
+my ($fn, $filehandle) = @_;
+$filename = $fn;			# share it globally
+
+my $in_cpp = 0;
+my $next_in_cpp = 0;
+
+my $in_comment = 0;
+my $in_header_comment = 0;
+my $comment_done = 0;
+my $in_function = 0;
+my $in_function_header = 0;
+my $in_declaration = 0;
+my $note_level = 0;
+my $nextok = 0;
+my $nocheck = 0;
+
+my $in_string = 0;
+
+my ($okmsg, $comment_prefix);
+
+$line = '';
+$prev = '';
+reset_indent();
+
+line: while (<$filehandle>) {
+	s/\r?\n$//;	# strip return and newline
+
+	# save the original line, then remove all text from within
+	# double or single quotes, we do not want to check such text.
+
+	$line = $_;
+
+	#
+	# C allows strings to be continued with a backslash at the end of
+	# the line.  We translate that into a quoted string on the previous
+	# line followed by an initial quote on the next line.
+	#
+	# (we assume that no-one will use backslash-continuation with character
+	# constants)
+	#
+	$_ = '"' . $_		if ($in_string && !$nocheck && !$in_comment);
+
+	#
+	# normal strings and characters
+	#
+	s/'([^\\']|\\.)*'/\'\'/g;
+	s/"([^\\"]|\\.)*"/\"\"/g;
+
+	#
+	# detect string continuation
+	#
+	if ($nocheck || $in_comment) {
+		$in_string = 0;
+	} else {
+		#
+		# Now that all full strings are replaced with "", we check
+		# for unfinished strings continuing onto the next line.
+		#
+		$in_string =
+		    (s/([^"](?:"")*)"([^\\"]|\\.)*\\$/$1""/ ||
+		    s/^("")*"([^\\"]|\\.)*\\$/""/);
+	}
+
+	#
+	# figure out if we are in a cpp directive
+	#
+	$in_cpp = $next_in_cpp || /^\s*#/;	# continued or started
+	$next_in_cpp = $in_cpp && /\\$/;	# only if continued
+
+	# strip off trailing backslashes, which appear in long macros
+	s/\s*\\$//;
+
+	# an /* END JSSTYLED */ comment ends a no-check block.
+	if ($nocheck) {
+		if (/\/\* *END *JSSTYLED *\*\//) {
+			$nocheck = 0;
+		} else {
+			reset_indent();
+			next line;
+		}
+	}
+
+	# a /*JSSTYLED*/ comment indicates that the next line is ok.
+	if ($nextok) {
+		if ($okmsg) {
+			err($okmsg);
+		}
+		$nextok = 0;
+		$okmsg = 0;
+		if (/\/\* *JSSTYLED.*\*\//) {
+			/^.*\/\* *JSSTYLED *(.*) *\*\/.*$/;
+			$okmsg = $1;
+			$nextok = 1;
+		}
+		$no_errs = 1;
+	} elsif ($no_errs) {
+		$no_errs = 0;
+	}
+
+	# check length of line.
+	# first, a quick check to see if there is any chance of being too long.
+	if ((($line =~ tr/\t/\t/) * ($tab_width - 1)) + length($line) > $config{"line-length"}) {
+		# yes, there is a chance.
+		# replace tabs with spaces and check again.
+		my $eline = $line;
+		1 while $eline =~
+		    s/\t+/' ' x
+			(length($&) * $tab_width - length($`) % $tab_width)/e;
+		if (length($eline) > $config{"line-length"}) {
+			err("line > " . $config{"line-length"} . " characters");
+		}
+	}
+
+	# ignore NOTE(...) annotations (assumes NOTE is on lines by itself).
+	if ($note_level || /\b_?NOTE\s*\(/) { # if in NOTE or this is NOTE
+		s/[^()]//g;			  # eliminate all non-parens
+		$note_level += s/\(//g - length;  # update paren nest level
+		next;
+	}
+
+	# a /* BEGIN JSSTYLED */ comment starts a no-check block.
+	if (/\/\* *BEGIN *JSSTYLED *\*\//) {
+		$nocheck = 1;
+	}
+
+	# a /*JSSTYLED*/ comment indicates that the next line is ok.
+	if (/\/\* *JSSTYLED.*\*\//) {
+		/^.*\/\* *JSSTYLED *(.*) *\*\/.*$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+	if (/\/\/ *JSSTYLED/) {
+		/^.*\/\/ *JSSTYLED *(.*)$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+
+	# universal checks; apply to everything
+	if (/\t +\t/) {
+		err("spaces between tabs");
+	}
+	if (/ \t+ /) {
+		err("tabs between spaces");
+	}
+	if (/\s$/) {
+		err("space or tab at end of line");
+	}
+	if (/[^ \t(]\/\*/ && !/\w\(\/\*.*\*\/\);/) {
+		err("comment preceded by non-blank");
+	}
+
+	# is this the beginning or ending of a function?
+	# (not if "struct foo\n{\n")
+	if (/^{$/ && $prev =~ /\)\s*(const\s*)?(\/\*.*\*\/\s*)?\\?$/) {
+		$in_function = 1;
+		$in_declaration = 1;
+		$in_function_header = 0;
+		$prev = $line;
+		next line;
+	}
+	if (/^}\s*(\/\*.*\*\/\s*)*$/) {
+		if ($prev =~ /^\s*return\s*;/) {
+			err_prev("unneeded return at end of function");
+		}
+		$in_function = 0;
+		reset_indent();		# we don't check between functions
+		$prev = $line;
+		next line;
+	}
+	if (/^\w*\($/) {
+		$in_function_header = 1;
+	}
+
+	# a blank line terminates the declarations within a function.
+	# XXX - but still a problem in sub-blocks.
+	if ($in_declaration && /^$/) {
+		$in_declaration = 0;
+	}
+
+	if ($comment_done) {
+		$in_comment = 0;
+		$in_header_comment = 0;
+		$comment_done = 0;
+	}
+	# does this looks like the start of a block comment?
+	if (/$hdr_comment_start/) {
+		if ($config{"indent"} eq "tab") {
+			if (!/^\t*\/\*/) {
+				err("block comment not indented by tabs");
+			}
+		} elsif (!/^ *\/\*/) {
+			err("block comment not indented by spaces");
+		}
+		$in_comment = 1;
+		/^(\s*)\//;
+		$comment_prefix = $1;
+		if ($comment_prefix eq "") {
+			$in_header_comment = 1;
+		}
+		$prev = $line;
+		next line;
+	}
+	# are we still in the block comment?
+	if ($in_comment) {
+		if (/^$comment_prefix \*\/$/) {
+			$comment_done = 1;
+		} elsif (/\*\//) {
+			$comment_done = 1;
+			err("improper block comment close")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		} elsif (!/^$comment_prefix \*[ \t]/ &&
+		    !/^$comment_prefix \*$/) {
+			err("improper block comment")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		}
+	}
+
+	if ($in_header_comment && $ignore_hdr_comment) {
+		$prev = $line;
+		next line;
+	}
+
+	# check for errors that might occur in comments and in code.
+
+	# allow spaces to be used to draw pictures in header comments.
+	#if (/[^ ]     / && !/".*     .*"/ && !$in_header_comment) {
+	#	err("spaces instead of tabs");
+	#}
+	#if (/^ / && !/^ \*[ \t\/]/ && !/^ \*$/ &&
+	#    (!/^    \w/ || $in_function != 0)) {
+	#	err("indent by spaces instead of tabs");
+	#}
+	if ($config{"indent"} eq "tab") {
+		if (/^ {2,}/ && !/^    [^ ]/) {
+			err("indent by spaces instead of tabs");
+		}
+	} elsif (/^\t/) {
+		err("indent by tabs instead of spaces")
+	} elsif (/^( +)/ && !$in_comment) {
+		my $indent = $1;
+		if (length($indent) < $config{"indent"}) {
+			err("indent of " . length($indent) .
+				" space(s) instead of " . $config{"indent"});
+		} elsif ($config{"strict-indent"} &&
+			length($indent) % $config{"indent"} != 0) {
+			err("indent is " . length($indent) .
+				" not a multiple of " . $config{'indent'} . " spaces");
+		}
+	}
+	if (/^\t+ [^ \t\*]/ || /^\t+  \S/ || /^\t+   \S/) {
+		err("continuation line not indented by 4 spaces");
+	}
+
+	# A multi-line block comment must not have content on the first line.
+	if (/^\s*\/\*./ && !/^\s*\/\*.*\*\// && !/$hdr_comment_start/) {
+		err("improper first line of block comment");
+	}
+
+	if ($in_comment) {	# still in comment, don't do further checks
+		$prev = $line;
+		next line;
+	}
+
+	if ($config{"blank-after-open-comment"} && (/[^(]\/\*\S/ || /^\/\*\S/) &&
+	    !(/$lint_re/ || ($config{"splint"} && /$splint_re/))) {
+		err("missing blank after open comment");
+	}
+	if (/\S\*\/[^)]|\S\*\/$/ &&
+	    !(/$lint_re/ || ($config{"splint"} && /$splint_re/))) {
+		err("missing blank before close comment");
+	}
+	if ($config{"blank-after-start-comment"} && /(?<!\w:)\/\/\S/) {	# C++ comments
+		err("missing blank after start comment");
+	}
+	# check for unterminated single line comments, but allow them when
+	# they are used to comment out the argument list of a function
+	# declaration.
+	if (/\S.*\/\*/ && !/\S.*\/\*.*\*\// && !/\(\/\*/) {
+		err("unterminated single line comment");
+	}
+
+	if (/^(#else|#endif|#include)(.*)$/) {
+		$prev = $line;
+		next line;
+	}
+
+	#
+	# delete any comments and check everything else.  Note that
+	# ".*?" is a non-greedy match, so that we don't get confused by
+	# multiple comments on the same line.
+	#
+	s/\/\*.*?\*\///g;
+	s/\/\/.*$//;		# C++ comments
+
+	# delete any trailing whitespace; we have already checked for that.
+	s/\s*$//;
+
+	# following checks do not apply to text in comments.
+	my $quote = $config{"literal-string-quote"};
+	if ($quote eq "single") {
+		if (/"/) {
+			err("literal string using double-quote instead of single");
+		}
+	} elsif ($quote eq "double") {
+		if (/'/) {
+			err("literal string using single-quote instead of double");
+		}
+	}
+
+	if (/[^=!<>\s][!<>=]=/ || /[^<>!=][!<>=]==?[^\s,=]/ ||
+	    (/[^->]>[^,=>\s]/ && !/[^->]>$/) ||
+	    (/[^<]<[^,=<\s]/ && !/[^<]<$/) ||
+	    /[^<\s]<[^<]/ || /[^->\s]>[^>]/) {
+		err("missing space around relational operator");
+	}
+	if (/\S>>=/ || /\S<<=/ || />>=\S/ || /<<=\S/ || /\S[-+*\/&|^%]=/ ||
+	    (/[^-+*\/&|^%!<>=\s]=[^=]/ && !/[^-+*\/&|^%!<>=\s]=$/) ||
+	    (/[^!<>=]=[^=\s]/ && !/[^!<>=]=$/)) {
+		# XXX - should only check this for C++ code
+		# XXX - there are probably other forms that should be allowed
+		if (!/\soperator=/) {
+			err("missing space around assignment operator");
+		}
+	}
+	if (/[,;]\S/ && !/\bfor \(;;\)/ &&
+	    # Allow a comma in a regex quantifier.
+	    !/\/.*?\{\d+,?\d*\}.*?\//) {
+		err("comma or semicolon followed by non-blank");
+	}
+	# check for commas preceded by blanks
+	if ((!$config{"leading-comma-ok"} && /^\s*,/) || (!/^\s*,/ && /\s,/)) {
+		err("comma preceded by blank");
+	}
+	# check for semicolons preceded by blanks
+	# allow "for" statements to have empty "while" clauses
+	if (/\s;/ && !/^[\t]+;$/ && !/^\s*for \([^;]*; ;[^;]*\)/) {
+		err("semicolon preceded by blank");
+	}
+	if (!$config{"continuation-at-front"} && /^\s*(&&|\|\|)/) {
+		err("improper boolean continuation");
+	} elsif ($config{"continuation-at-front"} && /(&&|\|\||[^+]\+)$/) {
+		err("improper continuation");
+	}
+	if (/\S   *(&&|\|\|)/ || /(&&|\|\|)   *\S/) {
+		err("more than one space around boolean operator");
+	}
+	# We allow methods which look like obj.delete() but not keywords without
+	# spaces ala: delete(obj)
+	if (!$config{"no-blank-for-anon-function"} && /(?<!\.)\bfunction\(/) {
+		err("missing space between 'function' and paren");
+	} elsif ($config{"no-blank-for-anon-function"} && /(?<!\.)\bfunction\s+\(/) {
+		err("space between 'function' and paren");
+	}
+	if (/(?<!\.)\b(delete|typeof|instanceof|throw|with|catch|new|in|for|if|while|switch|return|case)\(/) {
+		err("missing space between keyword and paren");
+	}
+	if (/(\b(catch|for|if|with|while|switch|return)\b.*){2,}/) {
+		# multiple "case" and "sizeof" allowed
+		err("more than one keyword on line");
+	}
+	if (/\b(delete|typeof|instanceOf|with|throw|catch|new|function|in|for|if|while|switch|return|case)\s\s+\(/ &&
+	    !/^#if\s+\(/) {
+		err("extra space between keyword and paren");
+	}
+	# try to detect "func (x)" but not "if (x)" or
+	# "#define foo (x)" or "int (*func)();"
+	if (/\w\s\(/) {
+		my $s = $_;
+		# strip off all keywords on the line
+		s/\b(delete|typeof|instanceOf|throw|with|catch|new|function|in|for|if|while|switch|return|case)\s\(/XXX(/g;
+		s/#elif\s\(/XXX(/g;
+		s/^#define\s+\w+\s+\(/XXX(/;
+		# do not match things like "void (*f)();"
+		# or "typedef void (func_t)();"
+		s/\w\s\(+\*/XXX(*/g;
+		s/\b(void)\s+\(+/XXX(/og;
+		if (/\w\s\(/) {
+			err("extra space between function name and left paren");
+		}
+		$_ = $s;
+	}
+
+	if ($config{"unparenthesized-return"} &&
+	    /^\s*return\W[^;]*;/ && !/^\s*return\s*\(.*\);/) {
+		err("unparenthesized return expression");
+	}
+	if (/\btypeof\b/ && !/\btypeof\s*\(.*\)/) {
+		err("unparenthesized typeof expression");
+	}
+	if (!$config{"whitespace-after-left-paren-ok"} && /\(\s/) {
+		err("whitespace after left paren");
+	}
+	# allow "for" statements to have empty "continue" clauses
+	if (/\s\)/ && !/^\s*for \([^;]*;[^;]*; \)/) {
+		if ($config{"leading-right-paren-ok"} && /^\s+\)/) {
+			# this is allowed
+		} else {
+			err("whitespace before right paren");
+		}
+	}
+	if (/^\s*\(void\)[^ ]/) {
+		err("missing space after (void) cast");
+	}
+	if (/\S\{/ && !/({|\(){/ &&
+	    # Allow a brace in a regex quantifier.
+	    !/\/.*?\{\d+,?\d*\}.*?\//) {
+		err("missing space before left brace");
+	}
+	if ($in_function && /^\s+{/ &&
+	    ($prev =~ /\)\s*$/ || $prev =~ /\bstruct\s+\w+$/)) {
+		err("left brace starting a line");
+	}
+	if (/}(else|while)/) {
+		err("missing space after right brace");
+	}
+	if (/}\s\s+(else|while)/) {
+		err("extra space after right brace");
+	}
+	if (/^\s+#/) {
+		err("preprocessor statement not in column 1");
+	}
+	if (/^#\s/) {
+		err("blank after preprocessor #");
+	}
+
+	#
+	# We completely ignore, for purposes of indentation:
+	#  * lines outside of functions
+	#  * preprocessor lines
+	#
+	if ($check_continuation && $in_function && !$in_cpp) {
+		process_indent($_);
+	}
+
+	if (/^\s*else\W/) {
+		if (!$config{"uncuddled-else-ok"} && $prev =~ /^\s*}$/) {
+			err_prefix($prev,
+			    "else and right brace should be on same line");
+		}
+	}
+	$prev = $line;
+}
+
+if ($prev eq "") {
+	err("last line in file is blank");
+}
+
+}
+
+#
+# Continuation-line checking
+#
+# The rest of this file contains the code for the continuation checking
+# engine.  It's a pretty simple state machine which tracks the expression
+# depth (unmatched '('s and '['s).
+#
+# Keep in mind that the argument to process_indent() has already been heavily
+# processed; all comments have been replaced by control-A, and the contents of
+# strings and character constants have been elided.
+#
+
+my $cont_in;		# currently inside of a continuation
+my $cont_off;		# skipping an initializer or definition
+my $cont_noerr;		# suppress cascading errors
+my $cont_start;		# the line being continued
+my $cont_base;		# the base indentation
+my $cont_first;		# this is the first line of a statement
+my $cont_multiseg;	# this continuation has multiple segments
+
+my $cont_special;	# this is a C statement (if, for, etc.)
+my $cont_macro;		# this is a macro
+my $cont_case;		# this is a multi-line case
+
+my @cont_paren;		# the stack of unmatched ( and [s we've seen
+
+sub
+reset_indent()
+{
+	$cont_in = 0;
+	$cont_off = 0;
+}
+
+sub
+delabel($)
+{
+	#
+	# replace labels with tabs.  Note that there may be multiple
+	# labels on a line.
+	#
+	local $_ = $_[0];
+
+	while (/^(\t*)( *(?:(?:\w+\s*)|(?:case\b[^:]*)): *)(.*)$/) {
+		my ($pre_tabs, $label, $rest) = ($1, $2, $3);
+		$_ = $pre_tabs;
+		while ($label =~ s/^([^\t]*)(\t+)//) {
+			$_ .= "\t" x (length($2) + length($1) / 8);
+		}
+		$_ .= ("\t" x (length($label) / 8)).$rest;
+	}
+
+	return ($_);
+}
+
+sub
+process_indent($)
+{
+	require strict;
+	local $_ = $_[0];			# preserve the global $_
+
+	s///g;	# No comments
+	s/\s+$//;	# Strip trailing whitespace
+
+	return			if (/^$/);	# skip empty lines
+
+	# regexps used below; keywords taking (), macros, and continued cases
+	my $special = '(?:(?:\}\s*)?else\s+)?(?:if|for|while|switch)\b';
+	my $macro = '[A-Z_][A-Z_0-9]*\(';
+	my $case = 'case\b[^:]*$';
+
+	# skip over enumerations, array definitions, initializers, etc.
+	if ($cont_off <= 0 && !/^\s*$special/ &&
+	    (/(?:(?:\b(?:enum|struct|union)\s*[^\{]*)|(?:\s+=\s*)){/ ||
+	    (/^\s*{/ && $prev =~ /=\s*(?:\/\*.*\*\/\s*)*$/))) {
+		$cont_in = 0;
+		$cont_off = tr/{/{/ - tr/}/}/;
+		return;
+	}
+	if ($cont_off) {
+		$cont_off += tr/{/{/ - tr/}/}/;
+		return;
+	}
+
+	if (!$cont_in) {
+		$cont_start = $line;
+
+		if (/^\t* /) {
+			err("non-continuation indented 4 spaces");
+			$cont_noerr = 1;		# stop reporting
+		}
+		$_ = delabel($_);	# replace labels with tabs
+
+		# check if the statement is complete
+		return		if (/^\s*\}?$/);
+		return		if (/^\s*\}?\s*else\s*\{?$/);
+		return		if (/^\s*do\s*\{?$/);
+		return		if (/{$/);
+		return		if (/}[,;]?$/);
+
+		# Allow macros on their own lines
+		return		if (/^\s*[A-Z_][A-Z_0-9]*$/);
+
+		# cases we don't deal with, generally non-kosher
+		if (/{/) {
+			err("stuff after {");
+			return;
+		}
+
+		# Get the base line, and set up the state machine
+		/^(\t*)/;
+		$cont_base = $1;
+		$cont_in = 1;
+		@cont_paren = ();
+		$cont_first = 1;
+		$cont_multiseg = 0;
+
+		# certain things need special processing
+		$cont_special = /^\s*$special/? 1 : 0;
+		$cont_macro = /^\s*$macro/? 1 : 0;
+		$cont_case = /^\s*$case/? 1 : 0;
+	} else {
+		$cont_first = 0;
+
+		# Strings may be pulled back to an earlier (half-)tabstop
+		unless ($cont_noerr || /^$cont_base    / ||
+		    (/^\t*(?:    )?(?:gettext\()?\"/ && !/^$cont_base\t/)) {
+			err_prefix($cont_start,
+			    "continuation should be indented 4 spaces");
+		}
+	}
+
+	my $rest = $_;			# keeps the remainder of the line
+
+	#
+	# The split matches 0 characters, so that each 'special' character
+	# is processed separately.  Parens and brackets are pushed and
+	# popped off the @cont_paren stack.  For normal processing, we wait
+	# until a ; or { terminates the statement.  "special" processing
+	# (if/for/while/switch) is allowed to stop when the stack empties,
+	# as is macro processing.  Case statements are terminated with a :
+	# and an empty paren stack.
+	#
+	foreach $_ (split /[^\(\)\[\]\{\}\;\:]*/) {
+		next		if (length($_) == 0);
+
+		# rest contains the remainder of the line
+		my $rxp = "[^\Q$_\E]*\Q$_\E";
+		$rest =~ s/^$rxp//;
+
+		if (/\(/ || /\[/) {
+			push @cont_paren, $_;
+		} elsif (/\)/ || /\]/) {
+			my $cur = $_;
+			tr/\)\]/\(\[/;
+
+			my $old = (pop @cont_paren);
+			if (!defined($old)) {
+				err("unexpected '$cur'");
+				$cont_in = 0;
+				last;
+			} elsif ($old ne $_) {
+				err("'$cur' mismatched with '$old'");
+				$cont_in = 0;
+				last;
+			}
+
+			#
+			# If the stack is now empty, do special processing
+			# for if/for/while/switch and macro statements.
+			#
+			next		if (@cont_paren != 0);
+			if ($cont_special) {
+				if ($rest =~ /^\s*{?$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*;$/) {
+					err("empty if/for/while body ".
+					    "not on its own line");
+					$cont_in = 0;
+					last;
+				}
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				# We've finished this section, start
+				# processing the next.
+				goto section_ended;
+			}
+			if ($cont_macro) {
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+			}
+		} elsif (/\;/) {
+			if ($cont_case) {
+				err("unexpected ;");
+			} elsif (!$cont_special) {
+				err("unexpected ;")	if (@cont_paren != 0);
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*special/) {
+					err("if/for/while/switch not started ".
+					    "on its own line");
+				}
+				goto section_ended;
+			}
+		} elsif (/\{/) {
+			err("{ while in parens/brackets") if (@cont_paren != 0);
+			err("stuff after {")		if ($rest =~ /[^\s}]/);
+			$cont_in = 0;
+			last;
+		} elsif (/\}/) {
+			err("} while in parens/brackets") if (@cont_paren != 0);
+			if (!$cont_special && $rest !~ /^\s*(while|else)\b/) {
+				if ($rest =~ /^$/) {
+					err("unexpected }");
+				} else {
+					err("stuff after }");
+				}
+				$cont_in = 0;
+				last;
+			}
+		} elsif (/\:/ && $cont_case && @cont_paren == 0) {
+			err("stuff after multi-line case") if ($rest !~ /$^/);
+			$cont_in = 0;
+			last;
+		}
+		next;
+section_ended:
+		# End of a statement or if/while/for loop.  Reset
+		# cont_special and cont_macro based on the rest of the
+		# line.
+		$cont_special = ($rest =~ /^\s*$special/)? 1 : 0;
+		$cont_macro = ($rest =~ /^\s*$macro/)? 1 : 0;
+		$cont_case = 0;
+		next;
+	}
+	$cont_noerr = 0			if (!$cont_in);
+}
diff --git a/tools/multinode b/tools/multinode
new file mode 100755
index 0000000..802bb4f
--- /dev/null
+++ b/tools/multinode
@@ -0,0 +1,365 @@
+#!/bin/bash
+
+#
+# multinode: install several concurrent versions of node in a way that's
+# much lighter weight than nvm.  See usage() for usage details.
+#
+
+set -o pipefail
+
+#
+# Static configuration: Node versions to setup and test.
+#
+mn_versions="0.8.28 0.10.48 0.12.17 4.6.1 6.9.1"
+mn_platform="sunos"
+mn_arches="x64 x86"
+mn_nodebase="https://nodejs.org/dist"
+
+#
+# Runtime configuration
+#
+mn_arg0="$(basename ${BASH_SOURCE[0]})"
+mn_srcroot=`readlink -f $(dirname ${BASH_SOURCE[0]})/..`
+mn_subcmd=
+mn_target_dir=$mn_srcroot/node
+mn_results=
+mn_nerrors=0
+
+#
+# usage MESSAGE...: emit MESSAGE to stderr and exit non-zero.
+#
+function usage
+{
+	echo "$mn_arg0: $@" >&2
+	cat <<EOF >&2
+usage: $mn_arg0 setup
+       $mn_arg0 versions
+       $mn_arg0 env [ver] [[arch]]
+       $mn_arg0 test
+       $mn_arg0 clobber
+       $mn_arg0 build
+
+Subcommands:
+
+    setup        sets up directory TARGET_DIR with the configured Node
+                 versions by downloading official builds
+
+    versions     lists installed versions
+
+    env [ver]    runs bash with an environment that has \$PATH and \$NODE_PATH
+                 set to the specified version
+
+    test         runs the test suite with the configured Node versions.  You
+                 should have already run "setup" with TARGET_DIR first.
+
+    build        builds all artifacts for all versions
+
+    clobber      deletes all built artifacts
+EOF
+	exit 2
+}
+
+#
+# fail MESSAGE...: emit MESSAGE to stderr and exit 1
+#
+function fail
+{
+	echo "$mn_arg0: $@" >&2
+	exit 1
+}
+
+function main
+{
+	local func
+
+	if [[ $# -lt 1 ]]; then
+		usage "missing arguments"
+	fi
+
+	cd "$mn_srcroot" || fail "failed to fetch source root"
+	mn_srcroot="$(pwd)"
+	cd - > /dev/null || fail "failed to fetch source root"
+
+	mn_subcmd="$1"
+
+	shift
+
+	case "$mn_subcmd" in
+	setup|versions|build|test|env|clobber)	do_$mn_subcmd $* ;;
+	*)		usage "unknown command: \"$mn_subcmd\"" ;;
+	esac
+}
+
+#
+# do_setup: downloads and unpacks all configured Node versions into the target
+# directory.
+#
+function do_setup
+{
+	if ! mkdir -p "$mn_target_dir"; then
+		fail "failed to create \"$mn_target_dir\""
+	fi
+
+	if ! cd "$mn_target_dir"; then
+		fail "failed to chdir \"$mn_target_dir\""
+	fi
+
+	for version in $mn_versions; do
+		for arch in $mn_arches; do
+			if ! do_setup_one \
+			    "$version" "$mn_platform" "$arch"; then
+				fail "failed to setup Node $version ($arch)"
+			fi
+		done
+	done
+}
+
+#
+# do_setup_one VERSION PLATFORM ARCH: download and unpack a specific Node
+# version into the current directory.
+#
+function do_setup_one
+{
+	local version platform arch
+	local dir file url
+
+	version="$1"
+	platform="$2"
+	arch="$3"
+
+	dir="node-v$version-$platform-$arch"
+	file="$dir.tar.gz"
+	url="$mn_nodebase/v$version/$file"
+
+	if [[ -d "$dir" ]]; then
+		echo "Skipping Node version $version" \
+		    "($platform $arch) -- already found";
+		return 0
+	fi
+
+	echo -n "Setting up Node version $version ($platform $arch) ... "
+
+	if ! curl -fsS -o $file "$url"; then
+		echo "download failed."
+		return 1
+	fi
+
+	if ! tar xzf $file; then
+		echo "extract failed."
+		return 1
+	fi
+
+	rm -f $file
+	echo "done."
+}
+
+function do_test
+{
+	if ! cd "$mn_target_dir" 2>/dev/null; then
+		fail "failed to chdir \"$mn_target_dir\"" \
+		    "(have you run \"setup\"?)"
+	fi
+
+	mn_target_dir="$(pwd)"
+	cd - > /dev/null
+
+	cd "$mn_srcroot" || fail "failed to cd \"$mn_srcroot\""
+
+	for version in $mn_versions; do
+		for arch in $mn_arches; do
+			do_test_one "$version" "$mn_platform" "$arch"
+		done
+	done
+
+	echo
+	echo "Summary:"
+	echo -e "$mn_results"
+	exit "$mn_nerrors"
+}
+
+function do_test_one
+{
+	local version platform arch
+	local dir result
+
+	version="$1"
+	platform="$2"
+	arch="$3"
+
+	dir="$mn_target_dir/node-v$version-$platform-$arch"
+	if [[ ! -d "$dir" || ! -f "$dir/bin/node" ]]; then
+		fail "Did not find $dir/bin/node (have you run \"setup\"?)"
+	fi
+
+	gccpath=`gcc -v 2>&1 | grep Config | tr ' ' '\n' | \
+	    grep -- --prefix | cut -d= -f2`
+
+	if [[ -z $gccpath ]]; then
+		fail "gcc library location could not be determined (no gcc?)"
+	fi
+
+	echo "# $mn_arg0: === testing $version for $arch ==="
+
+	if (
+	    export PATH=$dir/bin:$PATH
+	    export NODE_PATH=$mn_srcroot:$dir/lib
+	    export LD_LIBRARY_PATH=$gccpath/lib
+	    export LD_LIBRARY_PATH_64=$gccpath/lib/amd64
+	    tape test/*.js ); then
+		result="$(printf "%-7s %5s %3s: success" \
+		    "$version" "$platform" "$arch")"
+	else
+		result="$(printf "%-7s %5s %3s: fail" \
+		    "$version" "$platform" "$arch")"
+		mn_nerrors=$(( mn_nerrors + 1 ))
+	fi
+
+	mn_results="$mn_results$result\n"
+}
+
+#
+# do_versions: list current known versions
+#
+function do_versions
+{
+	for version in $mn_versions; do
+		for arch in $mn_arches; do
+			echo $version $arch
+		done
+	done
+}
+
+function do_env
+{
+	if [[ $# -lt 1 ]]; then
+		usage "missing version and architecture"
+	fi
+
+	version=
+	arch=
+	platform=$mn_platform
+
+	for v in $mn_versions; do
+		if [[ "$v" == "$1" ]]; then
+			version=$v
+			break
+		fi
+	done
+
+	if [[ -z $version ]]; then
+		fail "$1 is not a known version (\"versions\" for all)"
+	fi
+
+	for a in $mn_arches; do
+		if [[ "$a" == "$2" || $# -eq 1 ]]; then
+			arch=$a
+			break
+		fi
+	done
+
+	if [[ -z $arch ]]; then
+		fail "$2 is not a known architecture (\"versions\" for all)"
+	fi
+
+	dir="$mn_target_dir/node-v$version-$platform-$arch"
+	if [[ ! -d "$dir" || ! -f "$dir/bin/node" ]]; then
+		fail "Did not find $dir/bin/node (have you run \"setup\"?)"
+	fi
+
+	gccpath=`gcc -v 2>&1 | grep Config | tr ' ' '\n' | \
+	    grep -- --prefix | cut -d= -f2`
+
+	if [[ -z $gccpath ]]; then
+		fail "gcc library location could not be determined (no gcc?)"
+	fi
+
+	export PS1=" "
+	. ~/.profile
+	. ~/.bashrc
+	export PS1="[$version-$arch] $PS1"
+	export PATH=$dir/bin:$PATH
+	export NODE_PATH=$mn_srcroot:$dir/lib
+	export LD_LIBRARY_PATH=$gccpath/lib
+	export LD_LIBRARY_PATH_64=$gccpath/lib/amd64
+
+        echo "Using bash as shell for $version environment... "
+        exec bash --noprofile --norc -i
+}
+
+function do_build
+{
+	mn_binary=$mn_srcroot/`cat $mn_srcroot/package.json | json main`.node
+
+	for version in $mn_versions; do
+		for arch in $mn_arches; do
+			do_build_one "$version" "$mn_platform" "$arch"
+		done
+	done
+}
+
+function do_build_one
+{
+	local version platform arch
+	local dir result
+
+	version="$1"
+	platform="$2"
+	arch="$3"
+	dir="$mn_target_dir/node-v$version-$platform-$arch"
+	if [[ ! -d "$dir" || ! -f "$dir/bin/node" ]]; then
+		fail "Did not find $dir/bin/node (have you run \"setup\"?)"
+	fi
+
+	dest=$dir/lib/`basename $mn_binary`
+
+	if [[ -f $dest ]]; then
+		binary=`basename $mn_binary`
+		echo "$mn_arg0: $version: $binary already exists for $arch"
+		return
+	fi
+
+	echo $mn_arg0: === building $version for $arch ===
+
+	export PATH=$dir/bin:$PATH
+
+	cd $mn_srcroot
+	make clobber
+
+	if [[ -f $mn_binary ]]; then
+		fail "$mn_binary exists after \"make clobber\""
+	fi
+
+	if ! make ; then
+		fail "could not build $version for $arch"
+	fi
+
+	if [[ ! -f $mn_binary ]]; then
+		fail "$mn_binary does not exist after \"make\""
+	fi
+
+	mv $mn_binary $dir/lib
+}
+
+function do_clobber
+{
+	mn_binary=$mn_srcroot/`cat $mn_srcroot/package.json | json main`.node
+
+	for version in $mn_versions; do
+		for arch in $mn_arches; do
+			dir="$mn_target_dir/node-v$version-$mn_platform-$arch"
+
+			if [[ ! -d "$dir" || ! -f "$dir/bin/node" ]]; then
+				fail "Did not find $dir/bin/node (\"setup\"?)"
+			fi
+
+			dest=$dir/lib/`basename $mn_binary`
+
+			if [[ -f $dest ]]; then
+				echo $mn_arg0: clobbering $version $arch ...
+				rm $dest
+			fi
+		done
+	done
+}
+
+main "$@"
diff --git a/wscript b/wscript
deleted file mode 100644
index 3ebbd4e..0000000
--- a/wscript
+++ /dev/null
@@ -1,17 +0,0 @@
-srcdir = '.'
-blddir = 'build'
-VERSION = '0.0.1'
-
-def set_options(opt):
-  opt.tool_options('compiler_cxx')
-
-def configure(conf):
-  conf.check_tool('compiler_cxx')
-  conf.check_tool('node_addon')
-
-def build(bld):
-  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
-  obj.cxxflags = '-Wno-write-strings'
-  obj.target = 'kstat'
-  obj.ldflags = '-lkstat'
-  obj.source = 'kstat.cc'
-- 
2.21.0

