commit 5a3fb8e8b7e1e08835c01e15852661491ec4166c (refs/changes/93/2893/3)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2017-11-10T23:03:40+13:00 (1 year, 11 months ago)
    
    DOCKER-1054: Provide provisioning limits plugin for sdc-docker similar to cloudapi functionality

diff --git a/Makefile b/Makefile
index 3e67c0b..049e2ea 100644
--- a/Makefile
+++ b/Makefile
@@ -16,7 +16,7 @@ RESTDOWN_FLAGS   = --brand-dir=deps/restdown-brand-remora
 
 TAPE	:= ./node_modules/.bin/tape
 
-JS_FILES	:= $(shell find lib test -name '*.js' | grep -v '/tmp/')
+JS_FILES	:= $(shell find lib plugins test -name '*.js' | grep -v '/tmp/')
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE	 = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index fa934ec..b9e4bb9 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -1253,10 +1253,10 @@ function getMemoryTarget(opts, container) {
  *
  * The callback is called:
  *
- *   callback(err, package_uuid)
+ *   callback(err, package)
  *
  * Where err is an Error object if no package was found that matches the
- * criteria, and package_uuid is passed if a package was found.
+ * criteria, and package is passed if a package was found.
  */
 function getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback) {
     assert.object(opts, 'opts');
@@ -1328,7 +1328,7 @@ function getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback) {
     }
 
     log.debug({pkg: candidate}, 'selected package for VM');
-    callback(null, candidate.uuid);
+    callback(null, candidate);
 }
 
 /*
@@ -1347,10 +1347,10 @@ function getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback) {
  *
  * The callback is called:
  *
- *   callback(err, package_uuid)
+ *   callback(err, package)
  *
  * Where err is an Error object if no package was found that matches the
- * criteria, and package_uuid is passed if a package was found.
+ * criteria, and package is passed if a package was found.
  */
 function getSpecifiedPackage(opts, pkgs, specifiedPackage, callback) {
     assert.object(opts, 'opts');
@@ -1360,7 +1360,7 @@ function getSpecifiedPackage(opts, pkgs, specifiedPackage, callback) {
     assert.func(callback, 'callback');
 
     var constraint = {};
-    var foundUuid;
+    var foundPkg;
     var log = opts.log;
     var nameMatches = [];
     var uuidMatches = [];
@@ -1372,30 +1372,30 @@ function getSpecifiedPackage(opts, pkgs, specifiedPackage, callback) {
         // use the one where the name matches.
         pkgs.forEach(function _onEachPkg(pkg) {
             if (pkg.name === specifiedPackage) {
-                nameMatches.push(pkg.uuid);
+                nameMatches.push(pkg);
             } else if (specifiedPackage.match(/^[0-9a-f]{8}$/)
                 && (pkg.uuid.substr(0, 8) === specifiedPackage)) {
 
-                uuidMatches.push(pkg.uuid);
+                uuidMatches.push(pkg);
             } else if (pkg.uuid === specifiedPackage) {
-                uuidMatches.push(pkg.uuid);
+                uuidMatches.push(pkg);
             }
         });
 
         // We're trying to uniquely identify a package, so only allow one match
         if (nameMatches.length === 1) {
-            foundUuid = nameMatches[0];
+            foundPkg = nameMatches[0];
         } else if (uuidMatches.length === 1) {
-            foundUuid = uuidMatches[0];
+            foundPkg = uuidMatches[0];
         }
 
         // If there are more than 1 match of either, or if there are no matches,
         // we can't determine the package to use and will fail.
     }
 
-    if (foundUuid) {
-        log.debug({foundPackage: foundUuid}, 'found package');
-        callback(null, foundUuid);
+    if (foundPkg) {
+        log.debug({foundPackage: foundPkg.uuid}, 'found package');
+        callback(null, foundPkg);
         return;
     }
 
@@ -1478,10 +1478,10 @@ function buildPackageFilter(opts) {
  *
  * Whether a package is found or not, the callback is called:
  *
- *   callback(err, package_uuid)
+ *   callback(err, package)
  *
- * with err being an Error object when a package was not found, and package_uuid
- * being the UUID of the correct package for this VM if this was able to be
+ * with err being an Error object when a package was not found, and package
+ * being the object for the correct package for this VM if this was able to be
  * determined.
  */
 function getPackage(opts, container, callback) {
@@ -1558,7 +1558,7 @@ function getPackage(opts, container, callback) {
         // memory value). So now we dispatch to the appropriate caller which
         // will call the callback with:
         //
-        //  callback(err, package_uuid)
+        //  callback(err, package)
         //
 
         if (specifiedPackage) {
@@ -2195,9 +2195,10 @@ function buildVmPayload(opts, container, callback) {
         },
 
         function selectPackage(_, cb) {
-            getPackage(opts, container, function (err, package_uuid) {
+            getPackage(opts, container, function (err, pkg) {
                 if (!err) {
-                    payload.billing_id = package_uuid;
+                    payload.pkg = pkg;
+                    payload.billing_id = pkg.uuid;
                 }
                 cb(err);
             });
@@ -2924,6 +2925,7 @@ function createContainer(opts, callback) {
 
     vasync.waterfall([
         _buildPayload,
+        _checkProvisionAllowed,
         _addLinks,
         _createVm,
         _saveLinks
@@ -2962,6 +2964,17 @@ function createContainer(opts, callback) {
         });
     }
 
+    function _checkProvisionAllowed(cb) {
+        var pkg = vm_payload.pkg;
+        delete vm_payload.pkg; // only used in this function; not needed further
+
+        opts.app.plugins.allowProvision({
+            account: opts.account,
+            image: opts.image,
+            pkg: pkg
+        }, cb);
+    }
+
     function _addLinks(cb) {
         var configLinks = container.HostConfig.Links;
         getLinkDetails(opts, configLinks, vm_payload, function (err, details) {
diff --git a/lib/plugin-manager.js b/lib/plugin-manager.js
index e52b260..a325a79 100644
--- a/lib/plugin-manager.js
+++ b/lib/plugin-manager.js
@@ -78,10 +78,41 @@ function init(app) {
     // the plugins it imports.
     var pluginApi = {
         log: app.log,
+        datacenterName: app.config.datacenterName,
+        service: 'docker',
         getNapiNetworksForAccount: function getNapiShim(obj, cb) {
+            assert.object(obj, 'obj');
+            assert.func(cb, 'cb');
+
             obj = jsprim.deepCopy(obj);
             obj.config = { napi: app.config.napi };
             app.backend.getNapiNetworksForAccount(obj, cb);
+        },
+        getActiveVmsForAccount: function getActiveVmsShim(opts, cb) {
+            assert.object(opts, 'opts');
+            assert.uuid(opts.owner_uuid, 'opts.owner_uuid');
+            assert.optionalString(opts.brand, 'opts.brand');
+            assert.optionalString(opts.fields, 'opts.fields');
+            assert.func(cb, 'cb');
+
+            app.vmapi.listVms({
+                owner_uuid: opts.owner_uuid,
+                brand: opts.brand,
+                fields: opts.fields,
+                state: 'active'
+            }, cb);
+        },
+        getImage: function getImageShim(imgUuid, cb) {
+            assert.uuid(imgUuid, 'imgUuid');
+            assert.func(cb, 'cb');
+
+            app.imgapi.getImage(imgUuid, cb);
+        },
+        listImages: function listImageShim(opts, cb) {
+            assert.object(opts, 'opts');
+            assert.func(cb, 'cb');
+
+            app.imgapi.listImages(opts, cb);
         }
     };
 
@@ -100,7 +131,14 @@ function init(app) {
         var plugin = require(pPath);
 
         Object.keys(plugin).forEach(function (apiName) {
-            assert.notEqual(supportedPluginHooks[apiName], -1,
+            // Allow a plugin to export names that are not a known plugin
+            // function by prefixing with an underscore. This is used for
+            // testing.
+            if (apiName[0] === '_') {
+                return;
+            }
+
+            assert.notEqual(supportedPluginHooks.indexOf(apiName), -1,
                 'supportedPluginFunctions[apiName]');
 
             var initedPlugin = plugin[apiName](pluginApi, pluginCfg);
@@ -165,3 +203,28 @@ function findOwnerExternalNetwork(opts, cb) {
         return p.bind(null, opts);
     }), cb);
 };
+
+
+/*
+ * This hook is run before the creation of a contain is initiated. It checks
+ * that various preconditions have been fulfilled before allowing the creation
+ * to proceed further.
+ */
+PluginManager.prototype.allowProvision =
+function allowProvision(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.func(cb, 'cb');
+
+    var hooks = this.hooks.allowProvision;
+    var funcs = hooks.map(function wrapFunc(func) {
+        return function (_, next) {
+            func(opts, next);
+        };
+    });
+
+    // Runs every plugin (if any) until a plugin fails. Any failure indicates
+    // that the provision should not be allowed.
+    vasync.pipeline({ funcs: funcs }, function (err, results) {
+        cb(err);
+    });
+};
diff --git a/plugins/filter_owner_networks.js b/plugins/filter_owner_networks.js
index dd1c2ec..f0e5cc3 100644
--- a/plugins/filter_owner_networks.js
+++ b/plugins/filter_owner_networks.js
@@ -129,16 +129,16 @@ function findOwnerExternalNetwork(api, cfg) {
             var owned = networks.filter(function filterOwner(network) {
                 var owners = network.owner_uuids;
                 return owners && owners.indexOf(accountUuid) !== -1;
-            })
+            });
 
             var external = owned.filter(function filterExternal(network) {
                 var tags = network.nic_tags_present;
-                return network.nic_tag === EXTERNAL_NIC_TAG ||
-                    (tags && tags.indexOf(EXTERNAL_NIC_TAG) !== -1);
+                return network.nic_tag === EXTERNAL_NIC_TAG
+                    || (tags && tags.indexOf(EXTERNAL_NIC_TAG) !== -1);
             });
 
             if (external.length === 0) {
-                var msg = 'Found no external network accessible to account'
+                var msg = 'Found no external network accessible to account';
                 return cb(new Error(msg));
             }
 
diff --git a/plugins/provision_limits.js b/plugins/provision_limits.js
new file mode 100644
index 0000000..10529d2
--- /dev/null
+++ b/plugins/provision_limits.js
@@ -0,0 +1,872 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * This applies provision limits specified by operators across a datacenter,
+ * either for all accounts or for a specific account. It is possible to limit an
+ * account based on three sums: total number of account VMs, total sum of those
+ * VMs' RAM, and/or the total sum of those VM's disk quota. Each of these three
+ * sums can be optionally constrainted by: VM brand, VM OS (specifically, the
+ * "os" attribute in the VM's image), and/or VM image name.
+ *
+ * Examples are worth a lot, so here are some examples of limits before going
+ * into the specifics:
+ *
+ * { "value": 200,  "by": "quota" }
+ * { "value": 1024, "by": "ram", "check": "os",    "os": "windows" }
+ * { "value": 25 }
+ * { "value": 100,               "check": "brand", "brand": "lx" }
+ * { "value": 8192, "by": "ram", "check": "image", "image": "base64-lts" }
+ * { "value": 50,                "check": "os",    "os": "any" }
+ *
+ * Now the specifics.
+ *
+ * Limit comes in the following JSON format:
+ * { "value": <number> }
+ *
+ * Where <number> is either a number, or a 10-base string encoding of a number.
+ * E.g. 10 or "10". 0 and -1 have special meanings: 0 means unlimited, and -1
+ * prevents all matching provisions.
+ *
+ * By default, a limit counts the number of VMs across a datacenter. So to set
+ * the maximum number of VMs for an account across a datacenter to 25, use:
+ * { "value": 25 }
+ *
+ * We can modify what the "value" counts by adding a "by" clause:
+ * { "value": <number>, "by": "<dimension>" }
+ *
+ * Where currently-supported dimensions are "ram" (in MiB) or "quota" (in GiB).
+ * It's possible to use something beyond "ram" and "quota" (e.g. "count"), but
+ * that will be ignored and treated as the default: counting the number of VMs
+ * across a datacenter; this is for compatibility with cloudapi's plugin.
+ *
+ * As an example, to limit the total amount of RAM an account can use across a
+ * datacenter to 10240MiB, use the following limit:
+ * { "value": 10240, "by": "ram" }
+ *
+ * It's possible to constrain a limit to specific VM brands, image names or
+ * operating systems, instead of the entire datacenter. This is done with the
+ * "check" attribute. It comes in three forms:
+ * { ..., "check": "brand", "brand": "<VM brand>" }
+ * { ..., "check": "image", "image": "<name of image>" }
+ * { ..., "check": "os", "os": "<name of image operating system>" }
+ *
+ * So to limit the total amount of RAM used by VMs running Windows images to
+ * 8192MiB:
+ * { "value": 8192, "by": "ram", "check": "os", "os": "windows" }
+ *
+ * You can use "any" in place of the image OS or name, or the VM brand. Like so:
+ * { "value" 25, "check": "image", "image": "any" }
+ *
+ * "any" flags in "image" or "os" are commonly added by adminui, yet while "any"
+ * is supported, its effect is the same as not using "check" in the first place.
+ * E.g. these two are equivalent, both limiting the amount of disk used across
+ * an entire datacenter to 900GiB:
+ * { "value": 900, "by": "quota", "check": "os", "os": "any" }
+ * { "value": 900, "by": "quota" }
+ *
+ * Several limits can apply to the same account at once. All the examples above
+ * were meant as one-liners, but adding several limits to an account will work
+ * as desired. Each limit is applied to a new provision, and if any of the
+ * limits, the provision is rejected.
+ *
+ * As an example, to allow an account to have up to 25 VMs, a maximum of
+ * 25600MiB RAM and 2.5TiB disk across the datacenter, and specifically only
+ * allow them to use 2048MiB RAM for the heretical penguin-loving Linux,
+ * add the following four limits to the account:
+ * { "value": 25 }
+ * { "value": 25600, "by": "ram" }
+ * { "value": 2560, "by": "quota" }
+ * { "value": 2048, "by": "ram", "check": "os", "os": "other" }
+ *
+ * There are two places that limits can be stored, and this is also reflected in
+ * their use case:
+ *
+ * 1. sapi, both for sdc-docker and cloudapi. This is where default limits and
+ *    categories of limits for large numbers of users are kept. These limits
+ *    typically rarely change.
+ * 2. ufds, which is for individual accounts. These are used to add exceptions
+ *    to the defaults and categories stored in sapi.
+ *
+ * A typical use-case is to prevent all accounts from using more than a limited
+ * amount of RAM of VMs across a datacenter, until their account has been vetted
+ * by support (e.g. credit card number isn't fraudulent). After vetting, the
+ * limit is bumped substantially. In this use-case, small limits would be set in
+ * sdc-docker's (and additionally cloudapi's) sapi configuration to serve as
+ * defaults. Once support has vetted the account, they can add a limit in ufds
+ * for that account to override the defaults, thus bumping the amount of RAM or
+ * VMs the account can provision.
+ *
+ * Limits are added to sdc-docker through sapi by adding a configuration for
+ * this sdc-docker plugin:
+ *
+ * DOCKER_UUID=$(sdc-sapi /services?name=docker | json -Ha uuid)
+ * sdc-sapi /services/$DOCKER_UUID -X PUT -d '{
+ *     "metadata": {
+ *         "DOCKER_PLUGINS": "[{\"name\":\"provision_limits\", \
+ *         \"enabled\": true,\"config\":{\"defaults\":[{\"value\":2 }]}}]"
+ *     }
+ * }'
+ *
+ * The above completely replaces DOCKER_PLUGINS, so make sure to check that
+ * you're not overwriting the configurations for other plugins in the process.
+ *
+ * Looking at this plugin's configuration:
+ * { "defaults": [<limits>] }
+ *
+ * Limits in "defaults" are applied to all provisions unless specifically
+ * overridden with a ufds limit. Additional categories can be added in the
+ * plugin's configuration, and their names are up to you. E.g.:
+ * {
+ *     "defaults": [
+ *         { "value": 2 },
+ *         { "value": 1024, "by": "ram" }
+ *     ]
+ *     "small": [
+ *         { "value": 20 },
+ *         { "value": 10, "check": "brand", "brand": "kvm" },
+ *         { "value": 327680, "by": "ram" },
+ *         { "value": 2000, "by": "quota" }
+ *     ]
+ *     "whale": [
+ *         { "value": 10000 },
+ *         { "value": 327680000, "by": "ram" },
+ *         { "value": 1000000, "by" :"quota" }
+ *     ]
+ * }
+ *
+ * The above configuration has defaults which are applied to all accounts that
+ * do not have a category set in "tenant" (see below). There are two added
+ * category of users: "small" and "whale". The "small" category allows accounts
+ * to have up to 20 VMs, up to 10 KVM instances, and a total of 320GiB RAM and
+ * 2000GiB disk across the datacenter. The "whale" category is much, much
+ * higher.
+ *
+ * Which category an account falls in is determined by the "tenant" attribute on
+ * that account in ufds. If the attribute is blank or absent (or a category
+ * that doesn't exist in the configuration), the account uses "defaults" limits.
+ * If the attribute is present and matches a category in the plugin
+ * those are the limits used. For example, this account is a whale:
+ *
+ * $ sdc-ufds search '(login=megacorp)' | json tenant
+ * whale
+ *
+ * To override any of these defaults or categories in ufds, add a capilimit
+ * entry. It takes the general form of:
+ *
+ * sdc-ufds add '
+ * {
+ *   "dn": "dclimit=$DATACENTER, uuid=$ACCOUNT_UUID, ou=users, o=smartdc",
+ *   "datacenter": "$DATACENTER",
+ *   "objectclass": "capilimit",
+ *   "limit": ["<JSON limit>", "<JSON limit>", ...]
+ * }'
+ *
+ * Or you could use adminui, which lets operators do the same with a
+ * friendly discoverable GUI.
+ *
+ * This plugin is compatible with cloudapi's provision_limits, with one minor
+ * difference: cloudapi's plugin only works correctly with lower-case image
+ * names, while this one works regardles of casing of image names (makes no
+ * attempt at case insensitivity). For now, to keep safe, only use lower-case
+ * image names.
+ */
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+
+// --- Globals
+
+var QUOTA_ERR = 'Quota exceeded; to have your limits raised please contact '
+    + 'Support';
+var BRAND = 'brand';
+var IMAGE = 'image';
+var OS = 'os';
+var RAM = 'ram';
+var QUOTA = 'quota';
+var ANY = 'any';
+
+
+/*
+ * DC limits come in two formats, as a result of how ufds (LDAP) works:
+ * a single JSON string, or an array of JSON strings. Each string represents
+ * a single limit. We deserialize these strings here.
+ *
+ * Returns an array of limit objects.
+ */
+function convertFromCapi(log, dcUserLimits) {
+    assert.object(log, 'log');
+    assert.optionalObject(dcUserLimits, 'dcUserLimits');
+
+    if (!dcUserLimits) {
+        return [];
+    }
+
+    var rawLimits = dcUserLimits.limit;
+    if (!rawLimits) {
+        return [];
+    }
+
+    if (typeof (rawLimits) === 'string') {
+        rawLimits = [rawLimits];
+    }
+
+    var parsedLimits = [];
+    rawLimits.forEach(function (raw) {
+        try {
+            parsedLimits.push(JSON.parse(raw));
+        } catch (e) {
+            log.warn({
+                failed_json_string: raw
+            }, 'Failed to deserialize DC provision limit!');
+        }
+    });
+
+    return parsedLimits;
+}
+
+
+/*
+ * Take an array of limit objects and convert their value attributes to numbers.
+ *
+ * Returns limits with all values as numbers.
+ */
+function atoiValues(limits) {
+    assert.arrayOfObject(limits, 'limits');
+
+    limits.forEach(function (limit) {
+        if (limit.value !== undefined) {
+            limit.value = parseInt(limit.value, 10) || 0;
+        }
+    });
+
+    return limits;
+}
+
+
+/*
+ * Given limits specified in sdc-docker's config file, and limits placed on an
+ * account in this DC, merge the two sets of limits into one. DC limits take
+ * priority over config limits, and if any of the DC limits has a image/os value
+ * of 'any' we skip config limits altogether (matching the cloudapi plugin's
+ * behaviour).
+ *
+ * We also do some cleaning/a few rudimentary optimizations here.
+ *
+ * Returns an array of limit objects.
+ */
+function filterLimits(log, service, cfgUserLimits, rawDcUserLimits) {
+    assert.object(log, 'log');
+    assert.string(service, 'service');
+    assert.arrayOfObject(cfgUserLimits, 'cfgUserLimits');
+    assert.optionalObject(rawDcUserLimits, 'dcUserLimits');
+
+    var dcUserLimits = convertFromCapi(log, rawDcUserLimits);
+
+    // Convert any value attributes to numbers
+    dcUserLimits  = atoiValues(dcUserLimits);
+    cfgUserLimits = atoiValues(cfgUserLimits);
+
+    // If the user has any DC-wide wildcard limits specified, we skip any limits
+    // specified in the sapi config.
+    var hasDcWildcards = dcUserLimits.some(function (limit) {
+        return !limit.check
+            || limit.brand === ANY
+            || limit.image === ANY
+            || limit.os === ANY;
+    });
+
+    // Union of the set of DC and config limits
+    var unionUserLimits = dcUserLimits.slice();
+
+    if (!hasDcWildcards) {
+        // Add any config limit which hasn't been overridden by a DC limit
+        cfgUserLimits.forEach(function (cfgLimit) {
+            var collision = dcUserLimits.some(function (dcLimit) {
+                return dcLimit.check && dcLimit.check === cfgLimit.check
+                    && dcLimit.by && dcLimit.by === cfgLimit.by;
+            });
+
+            if (!collision) {
+                unionUserLimits.push(cfgLimit);
+            }
+        });
+    }
+
+    // {image: 'any'} and {os: 'any'} are equivalent to {}: they're limits that
+    // apply to everything.
+    unionUserLimits.forEach(function simplifyAny(limit) {
+        if (limit.brand === ANY || limit.image === ANY || limit.os === ANY) {
+            limit.check = undefined;
+            limit.image = undefined;
+            limit.brand = undefined;
+            limit.os    = undefined;
+        }
+    });
+
+    // Remove and log invalid limits
+    unionUserLimits = unionUserLimits.filter(function validateLimit(limit) {
+        if ((limit.check === BRAND && !limit.brand)
+            || (limit.check === IMAGE && !limit.image)
+            || (limit.check === OS && !limit.os)) {
+
+            log.warn({ limit: limit }, 'Invalid limit; entry is incomplete');
+            return false;
+        }
+
+        return true;
+    });
+
+    // cloudapi currently supports filtering by image OS and name, but other
+    // services (i.e. Docker) don't need to. In the future image OS and name
+    // very likely be removed, albeit is not officially deprecated yet.
+    if (service !== 'cloudapi') {
+        unionUserLimits = unionUserLimits.filter(function stripImgAttr(limit) {
+            return limit.check !== IMAGE && limit.check !== OS;
+        });
+    }
+
+    // Any limit with a value of 0 means 'unlimited', so we remove such limits
+    // here since they're effectively a nop when filtering on them.
+    return unionUserLimits.filter(function filterZero(limit) {
+        return limit.value !== 0;
+    });
+}
+
+
+/*
+ * Determine what the VM's brand will be from an image.
+ *
+ * Returns a brand as string, or undefined if unrecognized image.
+ */
+function getBrand(image) {
+    assert.object(image, 'image');
+
+    var brand = image.requirements && image.requirements.brand;
+
+    if (!brand) {
+        var imgType = image.type;
+
+        if (imgType === 'lx-dataset' || imgType === 'docker') {
+            brand = 'lx';
+        } else if (imgType === 'zone-dataset') {
+            brand = 'joyent';
+        } else if (imgType === 'zvol') {
+            brand = 'kvm';
+        }
+    }
+
+    return brand;
+}
+
+
+function sum(a, b) {
+    return a + b;
+}
+
+
+/*
+ * Takes a look at all of a user's VMs, and determines whether this provision
+ * will shoot over any limits set. The three possible limits are for the sum of
+ * all RAM across the DC (in MiB), the sum of all disk across the DC (in GiB),
+ * and the total number of an account's VMs. Each of these limits can be
+ * optionally be restricted to VMs made using an image with the given name, or
+ * VMs that contain a certain OS.
+ *
+ * Some examples:
+ *
+ * - account limited to total 2GiB RAM across whole DC:
+ *   { "by": "ram", "value": 2048 }
+ *
+ * - account limited to total 1TiB disk across whole DC for VMs with "other"
+ *   OS; "other" is usually used for Docker:
+ *   { "check": "os", "os": "other", "by": "quota", "value": 1024 }
+ *
+ * - account limited to 1GiB RAM across DC, 25GiB disk across DC, and can have
+ *   no more than four VMs:
+ *   { "by": "ram", "value": 1024 }
+ *   { "by": "quota", "value": 25 }
+ *   { "value": 4 }
+ *
+ * Unknown checks (i.e. not "ram" or "quota") are treated as the default case:
+ * counting VMs. Not great, but this is to keep consistent with the cloudapi
+ * plugin's behaviour.
+ *
+ * Returns a boolean: true means provision is a go, false means provision should
+ * be rejected.
+ */
+function canProvision(log, pkg, vms, image, limits) {
+    assert.object(log, 'log');
+    assert.object(pkg, 'pkg');
+    assert.arrayOfObject(vms, 'vms');
+    assert.object(image, 'image');
+    assert.arrayOfObject(limits, 'limits');
+
+    // For the next three filter()s, it's possible that image.name, image.os or
+    // getBrand()'s results are undefined. This will only be the case if none of
+    // the limits require filtering by the associated image name, OS or VM
+    // brand. If they don't require it, then the results of imgVms, osVms,
+    // brandVms don't matter since they won't be used.
+
+    // All VMs matching new provision's image name
+    var imgVms = vms.filter(function imgFilter(vm) {
+        return vm.image_name === image.name;
+    });
+
+    // All VMs matching new provision's OS
+    var osVms = vms.filter(function osFilter(vm) {
+        return vm.os === image.os;
+    });
+
+    // All VMs with a particular brand
+    var brand = getBrand(image);
+    var brandVms = vms.filter(function brandFilter(vm) {
+        return vm.brand === brand;
+    });
+
+    // Loop through each limit and ensure that it passes. If any limit fails,
+    // this provision fails.
+    for (var i = 0; i < limits.length; i++) {
+        var limit = limits[i];
+
+        log.debug({ limit: limit }, 'Applying provision limit');
+
+        var machines = vms;
+        if (limit.check === BRAND) {
+            machines = brandVms;
+        } else if (limit.check === IMAGE) {
+            machines = imgVms;
+        } else if (limit.check === OS) {
+            machines = osVms;
+        }
+
+        // Default is this
+        var count = machines.length + 1;
+
+        if (limit.by === RAM) {
+            // RAM; in MiB
+            count = machines.map(function (vm) {
+                return vm.ram;
+            }).reduce(sum, pkg.max_physical_memory);
+
+        } else if (limit.by === QUOTA) {
+            // Disk; VMs and limits are in GiB, but packages in MiB
+            count = machines.map(function (vm) {
+                return vm.quota;
+            }).reduce(sum, pkg.quota / 1024);
+        }
+
+        if (count > limit.value) {
+            log.info({ limit: limit }, 'Provision limit applied');
+            return false;
+        }
+    }
+
+    return true;
+}
+
+
+/*
+ * Look at what the set of limits will be filtering on, and determine what
+ * are the minimal number of fields we need vmapi to populate each VM object
+ * with; this reduces serialization/deserialization time on both ends.
+ *
+ * One major limitation in vmapi is that it doesn't recognize "image_uuid" as
+ * a field, so if we need any information that can only be found in imgapi, we
+ * have no choice but to load complete vmapi objects.
+ *
+ * Returns a query string to use with vmapi's ListVms ?field=. Returns undefined
+ * if we'll use the default object layout instead.
+ */
+function findMinimalFields(limits) {
+    assert.arrayOfObject(limits, 'limits');
+
+    var needImageUuid = limits.some(function (limit) {
+        return limit.check === IMAGE || limit.check === OS;
+    });
+
+    if (needImageUuid) {
+        // Cannot use fields because vmapi doesn't understand
+        // ?fields=image_uuid, so we have to load everything :(
+        return undefined;
+    }
+
+    var needRam = limits.some(function (limit) {
+        return limit.by === RAM;
+    });
+
+    var needQuota = limits.some(function (limit) {
+        return limit.by === QUOTA;
+    });
+
+    if (needRam && needQuota) {
+        return 'ram,quota';
+    } else if (needQuota) {
+        return 'quota';
+    } else {
+        // vmapi won't return empty objects, so we need at least one attribute
+        // regardless of whether any limit applies to ram or not
+        return 'ram';
+    }
+}
+
+
+/*
+ * Fetch all the VMs from vmapi that we'll need to apply the given limits. If
+ * any of the limits require that VM objects are populated with details of their
+ * image's OS or name, we need to ensure we have an imgapi version of the image
+ * manifest.
+ *
+ * If we'll be filtering by image name or OS, we can throw away all image or OS
+ * limits that don't apply to this provision once we know the provision's image
+ * OS or name. After all, at that point the only limits that apply either match
+ * the provision's name and OS, or aren't matching on name or OS.
+ *
+ * Calls cb(err, vms, vmImage, limits), where vms is the list of VMs
+ * (populated with "image_name" and "os" if required by the limits), vmImage
+ * (also populated with "name" and "os" if required by the limits), and limits
+ * (a new set of limits once we've throw away now-irrelevant limits).
+ */
+function getVms(log, api, account, image, limits, cb) {
+    assert.object(log, 'log');
+    assert.object(api, 'api');
+    assert.object(account, 'account');
+    assert.object(image, 'image');
+    assert.arrayOfObject(limits, 'limits');
+    assert.func(cb, 'cb');
+
+    var imageLookup = {};
+    var vms = [];
+    var brand;
+
+    // Depending on the service using this plugin, we may get a Moray image
+    // manifest (i.e. from sdc-docker), or we may get an imgapi image manifest
+    // (i.e. from sdc-cloudapi). The image object that sdc-docker stores in
+    // Moray doesn't have the information we need if any of the limits will be
+    // checking by either image name or OS, thus we load it here.
+    function getVmImage(_, next) {
+        log.trace('Running getVmImage');
+
+        var needVmImage = limits.some(function (limit) {
+            var check = limit.check;
+            return check === BRAND || check === IMAGE || check === OS;
+        });
+
+        var isMorayImage = (image.constructor
+            && image.constructor.name === 'ImageV2');
+
+        if (!needVmImage || !isMorayImage) {
+            log.debug('Loading imgapi image unneeded for filtering; skipping');
+            return next();
+        }
+
+        var vmImgUuid = image.image_uuid;
+        log.debug('Loading imgapi image for limit filtering:', vmImgUuid);
+
+        api.getImage(vmImgUuid, function getImageCb(err, _image) {
+            if (err) {
+                return next(err);
+            }
+
+            image = _image;
+
+            log.debug({ vm_image: image }, 'Loaded VM\'s image');
+
+            return next();
+        });
+    }
+
+    function refineLimits(_, next) {
+        var needBrand = limits.some(function (limit) {
+            return limit.check === BRAND;
+        });
+
+        if (needBrand) {
+            // If any limits filter by brand, we'll have loaded an imgapi image
+            // in getVmImage().
+            brand = getBrand(image);
+            if (!brand) {
+                var errMsg = 'Unable to determine brand of image ' + image.uuid;
+                return next(new Error(errMsg));
+            }
+        }
+
+        // limits after filtering can contain at most one image name and one os
+        // name to query, so we will have at most two imgapi queries later.
+        // Brand doesn't cause an imgapi query since that information is already
+        // on vmapi objects.
+        limits = limits.filter(function filterRelevant(limit) {
+            if (limit.check === BRAND) {
+                return limit.brand === brand;
+            }
+
+            if (limit.check === IMAGE) {
+                return limit.image === image.name;
+            }
+
+            if (limit.check === OS) {
+                return limit.os === image.os;
+            }
+
+            return true;
+        });
+
+        log.debug({ limits: limits }, 'Found applicable limits');
+
+        return next();
+    }
+
+    // Helper function used by getOsImages() and getNameImages()
+    function getImages(opts, next) {
+        assert.object(opts, 'opts');
+        assert.func(next, 'next');
+
+        opts.state = 'all';
+
+        api.listImages(opts, function listImagesCb(err, images) {
+            if (err) {
+                return next(err);
+            }
+
+            log.debug({ opts: opts }, 'Loaded images');
+
+            images.forEach(function (img) {
+                imageLookup[img.uuid] = img;
+            });
+
+            return next();
+        });
+    }
+
+    // Search for images that match the VM image's OS, but only if needed
+    function getOsImages(_, next) {
+        log.trace('Running getOsImages');
+
+        var needOsDetails = limits.some(function (limit) {
+            return limit.check === OS;
+        });
+
+        if (needOsDetails) {
+            return getImages({ os: image.os }, next);
+        }
+
+        log.debug('VMs\' OS not needed for limit filtering; skipping');
+
+        return next();
+    }
+
+    // Search for images that match the VM image's name, but only if needed
+    function getNameImages(_, next) {
+        log.trace('Running getNameImages');
+
+        var needNameDetails = limits.some(function (limit) {
+            return limit.check === IMAGE;
+        });
+
+        if (needNameDetails) {
+            return getImages({ name: image.name }, next);
+        }
+
+        log.debug('Img names not needed needed for limit filtering; skipping');
+
+        return next();
+    }
+
+    // Unfortunately, vmapi VMs don't have an 'os' attribute, nor do they store
+    // image names. Therefore we're stuck always loading all of an account's
+    // active VMs. This is really Not Great.
+    //
+    // There are various convoluted optimizations we could try and pull (e.g.
+    // we can make individual vmapi queries for each ?image_uuid=, iff all
+    // applicable limits involve the image name), but if the current approach
+    // becomes too expensive it'd be simplest to have vmapi store the 'os' and
+    // 'image_name' attributes. '?fields=' needs to be extended to support
+    // image_uuid as well. And if vmapi grew a fast path for HEAD with an object
+    // count, that would be pretty handy...
+    //
+    // Calls cb(err, vms, image, limits), where vms is an array of VMs loaded
+    // from vmapi, image comes from imgapi (if needed later on, otherwise it
+    // might be a Moray image manifest) and matches the current provision, and
+    // limits are a new set of limits filtered to match the current provision
+    // given new information about the provision's OS and image name (if
+    // relevant).
+    function getAccountVms(_, next) {
+        log.trace('Running getAccountVms');
+
+        var brandLimits = limits.filter(function isBrandLimit(limit) {
+            return limit.check === BRAND;
+        });
+
+        var opts = {
+            owner_uuid: account.uuid,
+            fields: findMinimalFields(limits)
+        };
+
+        if (brandLimits.length > 0 && brandLimits.length === limits.length) {
+            // all limits are brand limits, so we only need to fetch VMs with
+            // our image's brand
+            opts.brand = brand;
+        }
+
+        api.getActiveVmsForAccount(opts, function getAccountVmsCb(err, _vms) {
+            if (err) {
+                return (err);
+            }
+
+            vms = _vms;
+
+            // Add 'os' and 'image_name' fields to vms when available. VMs which
+            // don't have a matching image are not under consideration for any
+            // "check":"image"/"os" (if applicable) in any case, which was why
+            // we didn't load those images earlier.
+            vms.forEach(function addVmAttr(vm) {
+                var img = imageLookup[vm.image_uuid];
+                if (img) {
+                    vm.image_name = img.name;
+                    vm.os = img.os;
+                }
+            });
+
+            log.debug('VMs loaded');
+
+            return next();
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [
+            getVmImage,
+            refineLimits,
+            getOsImages,
+            getNameImages,
+            getAccountVms
+        ]
+    }, function vasyncCb(err) {
+        cb(err, vms, image, limits);
+    });
+}
+
+
+/*
+ * Given a new provision, load all limits that apply to the current account
+ * both in sdc-docker's config and in ufds, determine which limits are relevant
+ * to this provision, and check that the provision won't violate any of those
+ * limits.
+ *
+ * Calls cb(err), where no error means that the provision can proceed. An error
+ * should halt the provision.
+ */
+function allowProvision(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.string(api.service, 'api.service');
+    assert.object(cfg, 'cfg');
+    assert.arrayOfObject(cfg.defaults, 'cfg.defaults');
+
+    var svcs = api.service;
+    var log = api.log;
+
+    return function checkProvisionLimits(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.object(opts.image, 'opts.image');
+        assert.object(opts.pkg, 'opts.pkg');
+        assert.func(cb, 'cb');
+
+        var account = opts.account;
+        var image = opts.image;
+        var pkg = opts.pkg;
+
+        log.debug('Running', checkProvisionLimits.name);
+
+        if (account.isAdmin()) {
+            log.debug('Account %s is an admin; skipping provision limits',
+                account.uuid);
+                return cb();
+        }
+
+        // fetch all of this account's DC limits from ufds
+        return account.listLimits(function listLimitsCb(err, globalUserLimits) {
+            if (err) {
+                return cb(err);
+            }
+
+            // Since ufds replicates between DCs, we're only interested in any
+            // limits that apply to this DC specifically.
+            var dcUserLimits = (globalUserLimits || []).find(function (limit) {
+                return limit.datacenter === api.datacenterName;
+            });
+
+            // We use a specific class of sapi-specified limits if the account
+            // has that class, otherwise fall back to defaults.
+            var cfgUserLimits = cfg[account.tenant] || cfg.defaults || [];
+
+            // Merge and optimize a bit the two sets of limits.
+            var limits = filterLimits(log, svcs, cfgUserLimits, dcUserLimits);
+
+            if (!limits.length) {
+                log.debug('No limits to be applied; skipping provision limits');
+                return cb();
+            }
+
+            log.debug({ provisioning_limits: limits }, 'Will apply limits');
+
+            var disallow = limits.some(function (limit) {
+                return limit.value <= -1;
+            });
+
+            if (disallow) {
+                log.info('Disallowing provision because -1 limit value found');
+                return cb(new Error(QUOTA_ERR));
+            }
+
+            // Load and populate any required VMs from imgapi to check against
+            // the given limits. Narrow the limits based on new information
+            // available from those queries.
+            getVms(log, api, account, image, limits,
+                function (err2, vms, image2, fittedLimits) {
+
+                if (err2) {
+                    return cb(err2);
+                }
+
+                log.info({
+                    vm_count: vms.length,
+                    limits: fittedLimits,
+                    img_os: image2.os,
+                    img_name: image2.name
+                }, 'VMs loaded and provision limits adjusted');
+
+                var allow = canProvision(log, pkg, vms, image2, fittedLimits);
+                if (!allow) {
+                    return cb(new Error(QUOTA_ERR));
+                }
+
+                return cb();
+            });
+        });
+    };
+}
+
+
+module.exports = {
+    // hook loaded by PluginManager
+    allowProvision: allowProvision,
+
+    // and these are additionally exported for tests
+    _convertFromCapi: convertFromCapi,
+    _atoiValues: atoiValues,
+    _filterLimits: filterLimits,
+    _getBrand: getBrand,
+    _canProvision: canProvision,
+    _findMinimalFields: findMinimalFields,
+    _getVms: getVms
+};
diff --git a/test/unit/plugin-provision-limits.test.js b/test/unit/plugin-provision-limits.test.js
new file mode 100644
index 0000000..27f82ee
--- /dev/null
+++ b/test/unit/plugin-provision-limits.test.js
@@ -0,0 +1,1115 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var clone = require('jsprim').deepCopy;
+var plugin = require('../../plugins/provision_limits');
+
+
+// --- Globals
+
+var ACCOUNT = {
+    uuid: 'd987aa8e-bfa3-11e7-b71c-28cfe91f7d53',
+    isAdmin: function () { return false; }
+};
+
+var API = {
+    getImage: function () {},
+    listImages: function () {},
+    getActiveVmsForAccount: function () {},
+    datacenterName: 'testdc',
+    service: 'cloudapi',
+    log: {
+        debug: function () {},
+        info: function () {},
+        trace: function () {},
+        warn: function () {}
+    }
+};
+
+var IMAGE = {
+    uuid: '4cae467a-bfa5-11e7-ae02-28cfe91f7d53',
+    name: 'testimage',
+    type: 'lx-dataset',
+    os: 'other'
+};
+
+
+// --- Helpers
+
+function check1(t, cfgLimits, ufdsLimits, tenant, vms, fields, shouldSucceed) {
+    var api = clone(API);
+    api.getImage = function () {
+        t.fail('No image should be needed');
+    };
+    api.listImages = function () {
+        t.fail('No images should be loaded');
+    };
+    api.getActiveVmsForAccount = function (args, cb) {
+        t.equal(args.owner_uuid, ACCOUNT.uuid, 'owner_uuid should match');
+        t.equal(args.fields, fields, 'fields should match');
+        return cb(null, vms);
+    };
+
+    var allowProvision = plugin.allowProvision(api, cfgLimits);
+
+    var account = clone(ACCOUNT);
+    account.tenant = tenant;
+    account.listLimits = function (cb) {
+        return cb(null, ufdsLimits);
+    };
+
+    var opts = {
+        account: account,
+        image: {
+            image_uuid: IMAGE.uuid
+        },
+        pkg: {
+            max_physical_memory: 256,
+            quota: 10
+        }
+    };
+
+    allowProvision(opts, function (err) {
+        if (shouldSucceed) {
+            t.ifError(err, 'Provision should succeeed');
+        } else {
+            t.ok(err, 'Provision should fail');
+        }
+
+        t.end();
+    });
+}
+
+
+function check2(t, limits, vms, listImages, shouldSucceed) {
+    var api = clone(API);
+    api.getImage = function (imgUuid, cb) {
+        t.equal(imgUuid, IMAGE.uuid, 'imgUuid is present');
+        t.ok(cb, 'cb is present');
+        return cb(null, IMAGE);
+    };
+    api.listImages = listImages;
+    api.getActiveVmsForAccount = function (args, cb) {
+        t.equal(args.owner_uuid, ACCOUNT.uuid, 'owner_uuid should match');
+        return cb(null, vms);
+    };
+
+    var allowProvision = plugin.allowProvision(api, { defaults: limits });
+
+    var account = clone(ACCOUNT);
+    account.listLimits = function (cb) {
+        return cb(null, []);
+    };
+
+    function ImageV2(imageUuid) {
+        this.image_uuid = imageUuid;
+        return this;
+    }
+
+    var opts = {
+        account: account,
+        image: new ImageV2(IMAGE.uuid),
+        pkg: {
+            max_physical_memory: 256,
+            quota: 10
+        }
+    };
+
+    allowProvision(opts, function (err) {
+        if (shouldSucceed) {
+            t.ifError(err, 'Provision should succeeed');
+        } else {
+            t.ok(err, 'Provision should fail');
+        }
+
+        t.end();
+    });
+}
+
+
+// --- Tests
+
+test('Setup allowProvision without api',
+function (t) {
+    try {
+        plugin.allowProvision();
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision without cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API);
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision with invalid cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API, { accounts: 'foo' });
+    } catch (e) {
+        t.equal(e.message, 'cfg.defaults ([object]) is required', 'err msg');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision with valid cfg',
+function (t) {
+    var allowProvision = plugin.allowProvision(API, { defaults: [] });
+    t.equal(typeof (allowProvision), 'function', 'func type');
+    t.equal(allowProvision.name, 'checkProvisionLimits', 'func name');
+    t.end();
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - unknown tenant/no ufdsLimits/one VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'supercalifragilisticexpialidocious';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - unknown tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'supercalifragilisticexpialidocious';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+
+test('allowProvision - tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/no VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/no VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/two large VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields,  true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/two large VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/ufdsLimits/four VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/different DC ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: 'lostinspaaace', limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - tenant/multiple ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/ufdsLimits/four VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/multiple ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/multiple ufdsLimits/two large VMs',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+    var fields = 'ram';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/os wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/os wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/image wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/image wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/brand wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'brand', brand: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/brand wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'brand', brand: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - count/os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/os/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'smartos' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/os/one VM same OS',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53' }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/os/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/image/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'definitelynotwhatyouwant' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/image/one VM same image',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53' }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/image/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/brand/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'joyent' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/brand/one VM same brand',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53',
+            brand: 'joyent' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/brand/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('_convertFromCapi',
+function (t) {
+    var convertFromCapi = plugin._convertFromCapi;
+
+    var result = convertFromCapi(API.log, undefined);
+    t.deepEqual(result, []);
+
+    result = convertFromCapi(API.log, { limit: '{ "value": 2 }' });
+    t.deepEqual(result, [ { value: 2 } ]);
+
+    result = convertFromCapi(API.log, {
+        limit: [
+            '{ "value": 2 }',
+            'badjson',
+            '{ "value": 25, "by": "quota" }'
+        ]
+    });
+    t.deepEqual(result, [
+        { value: 2 },
+        { value: 25, by: 'quota' }
+    ]);
+
+    t.end();
+});
+
+
+test('_atoiValues',
+function (t) {
+    var atoiValues = plugin._atoiValues;
+
+    var result = atoiValues([
+        { value: 25,     by: 'ram'   },
+        { value: 1,      by: 'ram'   },
+        { value: -1,     by: 'quota' },
+        { value: '25',   by: 'quota' },
+        { value: 'xxxx', by: 'count' },
+        { value: '-1' }
+    ]);
+
+    t.deepEqual(result, [
+        { value: 25, by: 'ram'   },
+        { value: 1,  by: 'ram'   },
+        { value: -1, by: 'quota' },
+        { value: 25, by: 'quota' },
+        { value: 0,  by: 'count' },
+        { value: -1 }
+    ], 'atoiValues limits');
+
+    t.end();
+});
+
+
+test('_getBrand',
+function (t) {
+    var getBrand = plugin._getBrand;
+
+    var result = getBrand({
+        requirements: { brand: 'foo' },
+        type: 'docker'
+    });
+    t.equal(result, 'foo', 'getBrand results');
+
+    result = getBrand({ type: 'docker' });
+    t.equal(result, 'lx', 'getBrand results');
+
+    result = getBrand({ type: 'lx-dataset' });
+    t.equal(result, 'lx', 'getBrand results');
+
+    result = getBrand({ type: 'zone-dataset' });
+    t.equal(result, 'joyent', 'getBrand results');
+
+    result = getBrand({ type: 'zvol' });
+    t.equal(result, 'kvm', 'getBrand results');
+
+    result = getBrand({ type: 'foo' });
+    t.equal(result, undefined, 'getBrand results');
+
+    t.end();
+});
+
+
+test('_findMinimalFields',
+function (t) {
+    var findMinimalFields = plugin._findMinimalFields;
+
+    var result = findMinimalFields([
+        { value: 256, by: 'ram' },
+        { value: 256, by: 'ram' }
+    ]);
+    t.deepEqual(result, 'ram', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 256, by: 'ram' },
+        { value: 256, by: 'ram' },
+        { value: 60,  by: 'quota' }
+    ]);
+    t.deepEqual(result, 'ram,quota', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 60,  by: 'quota' }
+    ]);
+    t.deepEqual(result, 'quota', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 5, check: 'os' }
+    ]);
+    t.deepEqual(result, undefined, 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 5, check: 'image' }
+    ]);
+    t.deepEqual(result, undefined, 'findMinimalFields results');
+
+    t.end();
+});
