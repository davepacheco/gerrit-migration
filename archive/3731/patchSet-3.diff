commit 8642d0b6d9b9452c931519034fbbce9f67dd9239 (refs/changes/31/3731/3)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-03-28T02:07:43+00:00 (1 year, 6 months ago)
    
    OS-6829 bhyve can miss PIR wake-ups

diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index f628e0b8ab..71f04df06f 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -3312,6 +3312,12 @@ do {									\
 	VCPU_CTR1(vm, vcpuid, msg " notify: %s", notify ? "yes" : "no");\
 } while (0)
 
+/*
+ * The least significant bit in the 'pending' field of the PIR descriptor
+ * indicates to the CPU that interrupts are pending in the 'pir' fields.
+ */
+#define	PIR_MASK_PENDING	0x1
+
 /*
  * vlapic->ops handlers that utilize the APICv hardware assist described in
  * Chapter 29 of the Intel SDM.
@@ -3321,8 +3327,14 @@ vmx_set_intr_ready(struct vlapic *vlapic, int vector, bool level)
 {
 	struct vlapic_vtx *vlapic_vtx;
 	struct pir_desc *pir_desc;
-	uint64_t mask;
+	uint64_t mask, old;
 	int idx, notify;
+	const uint_t prio = (vector & 0xf0) >> 4;
+	const uint64_t prio_mask = (1 << prio) | PIR_MASK_PENDING;
+
+#ifndef __FreeBSD__
+	ASSERT(vector >= 0x10 && vector <= 0xff);
+#endif
 
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
@@ -3335,7 +3347,42 @@ vmx_set_intr_ready(struct vlapic *vlapic, int vector, bool level)
 	idx = vector / 64;
 	mask = 1UL << (vector % 64);
 	atomic_set_long(&pir_desc->pir[idx], mask);
-	notify = atomic_cmpset_long(&pir_desc->pending, 0, 1);
+
+	/*
+	 * Deciding if vCPU notification is required when using PIR is
+	 * complicated by interrupt priorities.  It is not enough to simply
+	 * notify when 'pending' makes the 0->1 transition.  If an interrupt
+	 * with a higher priority class than those already present is queued,
+	 * its arrival necessitates a notification in case the vCPU is blocked
+	 * in HLT with a PPR higher than the existing interrupts.
+	 *
+	 * The priority classes of pending interrupts is cached as a bitfield
+	 * in the higher order bits of the 'pending' field of pir_desc.  The
+	 * Intel manual states those bits are reserved for software and we are
+	 * free to use them.
+	 */
+	old = atomic_load_acq_long(&pir_desc->pending);
+	if (atomic_cmpset_long(&pir_desc->pending, old, old|prio_mask) != 0) {
+		/*
+		 * If there was no race in updating the pending field
+		 * (including the priority bitfield), then a notification is
+		 * only needed if the incoming priority class is higher than
+		 * any existing ones.
+		 *
+		 * This will also cover the case where the 'pending' bit has
+		 * been cleared by the CPU as it delivered interrupts posted in
+		 * the structure.
+		 */
+		notify = ((old & PIR_MASK_PENDING) == 0 || prio_mask > old);
+	} else {
+		/*
+		 * In the case of racing updates to the pending field, the
+		 * priority and pending bit are atomically set and the
+		 * notification is unconditionally requested.
+		 */
+		atomic_set_long(&pir_desc->pending, prio_mask);
+		notify = 1;
+	}
 
 	VMX_CTR_PIR(vlapic->vm, vlapic->vcpuid, pir_desc, notify, vector,
 	    level, "vmx_set_intr_ready");
@@ -3362,7 +3409,7 @@ vmx_pending_intr(struct vlapic *vlapic, int *vecptr)
 	pir_desc = vlapic_vtx->pir_desc;
 
 	pending = atomic_load_acq_long(&pir_desc->pending);
-	if (!pending) {
+	if ((pending & PIR_MASK_PENDING) == 0) {
 		/*
 		 * While a virtual interrupt may have already been
 		 * processed the actual delivery maybe pending the
@@ -3503,13 +3550,15 @@ vmx_inject_pir(struct vlapic *vlapic)
 	struct vlapic_vtx *vlapic_vtx;
 	struct pir_desc *pir_desc;
 	struct LAPIC *lapic;
-	uint64_t val, pirval;
+	uint64_t val, pirval, pending;
 	int rvi, pirbase = -1;
 	uint16_t intr_status_old, intr_status_new;
 
 	vlapic_vtx = (struct vlapic_vtx *)vlapic;
 	pir_desc = vlapic_vtx->pir_desc;
-	if (atomic_cmpset_long(&pir_desc->pending, 1, 0) == 0) {
+
+	pending = atomic_swap_long(&pir_desc->pending, 0);
+	if ((pending & PIR_MASK_PENDING) == 0) {
 		VCPU_CTR0(vlapic->vm, vlapic->vcpuid, "vmx_inject_pir: "
 		    "no posted interrupt pending");
 		return;
