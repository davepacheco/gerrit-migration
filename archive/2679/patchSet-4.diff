commit f9ceb771b1fe88b9331349310e1367b4a740d70c (refs/changes/79/2679/4)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-10-02T12:06:46-04:00 (2 years ago)
    
    DOCKER-1112 waitContainer should wait for exit_status to become available

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 48912e3..d3e52c0 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -3508,23 +3508,67 @@ function waitContainer(opts, callback) {
     assert.optionalObject(opts.log, 'opts.log');
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.account, 'opts.account');
+    assert.object(opts.vm, 'opts.vm');
+    assert.uuid(opts.vm.uuid, 'opts.vm.uuid');
 
-    var log = opts.log || this.log;
+    var uuid = opts.vm.uuid;
     var vmapi = opts.app.vmapi;
+    var log = (opts.log || this.log).child({vm_uuid: uuid});
 
     var waitHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var waitOpts = { uuid: opts.vm.uuid };
+    var waitOpts = { uuid: uuid };
+
+    /*
+     * When a VM has transitioned to the "stopped" state, we also want to
+     * capture the "exit_status" before calling back.  It is possible however
+     * that a VM can transition to "stopped" but never have an exit_status.  To
+     * handle this sitution and ensure we don't wait indefinitely for a
+     * property that will never exist, we start counting down
+     * exitStatusIterations (15) when the VM has transitioned to the "stopped"
+     * state.  If we don't see the exit_status property when the countdown hits
+     * 0, we callback with `undefined` as the exit_status.
+     */
+    var stopped = false;
+    var exitStatusIterations = 15;
+
+    log.debug('waitContainer');
 
     function waitVm() {
         vmapi.getVm(waitOpts, waitHeaders, function (getErr, vm) {
             if (getErr) {
-                log.error(getErr, 'Error getting container.');
-                return callback(getErr);
-            } else if (vm.state === 'stopped') {
-                callback(null, vm.exit_status);
-            } else {
-                setTimeout(waitVm, 1000);
+                log.error({err: getErr}, 'Error getting container: %s',
+                    getErr.message);
+                callback(getErr);
+                return;
+            }
+
+            if (vm.state === 'stopped') {
+                stopped = true;
             }
+
+            // If this is set, we've already seen the VM transition to stopped.
+            if (stopped) {
+                if (vm.hasOwnProperty('exit_status')) {
+                    // We have the exit_status - return it.
+                    log.debug({exit_status: vm.exit_status},
+                        'VM stopped with exit_status');
+                    callback(null, vm.exit_status);
+                    return;
+                }
+
+                if (--exitStatusIterations === 0) {
+                    // We failed to find an exit_status - return undefined.
+                    log.debug('VM stopped without exit_status');
+                    callback(null, undefined);
+                    return;
+                }
+            }
+
+            /*
+             * The VM hasn't stopped or we are waiting on the exit_status, try
+             * again later.
+             */
+            setTimeout(waitVm, 1000);
         });
     }
 
