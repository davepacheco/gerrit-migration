From 0eb053fc2bc41335f8e3c564053451152e308336 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Tue, 23 Oct 2018 16:48:37 +0000
Subject: [PATCH] OS-7309 UEFI build_image should work in a NGZ

---
 .gitignore                         |   2 +
 Makefile                           |  14 +-
 overlay/generic/boot/forth/menu.rc | 144 +++++++++++
 tools/build_image                  | 360 ++++++++++++++++++++++++++
 tools/build_iso                    | 392 -----------------------------
 tools/build_usb                    |   1 -
 tools/format_image/Makefile        |  31 +++
 tools/format_image/format_image.c  | 379 ++++++++++++++++++++++++++++
 tools/images/make_image            | 263 -------------------
 9 files changed, 924 insertions(+), 662 deletions(-)
 create mode 100644 overlay/generic/boot/forth/menu.rc
 create mode 100755 tools/build_image
 delete mode 100755 tools/build_iso
 delete mode 120000 tools/build_usb
 create mode 100644 tools/format_image/Makefile
 create mode 100644 tools/format_image/format_image.c
 delete mode 100755 tools/images/make_image

diff --git a/.gitignore b/.gitignore
index ccb2a5ec..6d984593 100644
--- a/.gitignore
+++ b/.gitignore
@@ -43,6 +43,8 @@
 /tools/builder/users.c
 /tools/builder/users.c.tmp
 /tools/cryptpass
+/tools/format_image/*.o
+/tools/format_image/format_image
 /tools/pwgen
 /tools/pwgen-2.06/configure
 /tools/javascriptlint/build
diff --git a/Makefile b/Makefile
index a9b7e1a0..60cfe7f2 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 ROOT =		$(PWD)
@@ -153,11 +153,10 @@ $(BOOT_TARBALL): world manifest
 #
 images: $(IMAGES_SIZES_GB:%=$(IMAGES_PROTO)/%gb.img)
 
-$(IMAGES_PROTO)/%.img: boot tools/images/%.fdisk tools/images/make_image
+$(IMAGES_PROTO)/%.img: boot tools/images/%.fdisk 
 	rm -f $@
 	mkdir -p $(IMAGES_PROTO)
-	./tools/images/make_image -s $* -G $(ROOT)/proto \
-	    -F tools/images/$*.fdisk $@
+	./tools/build_image -p $* -r $(ROOT)
 
 images-tar: $(IMAGES_TARBALL)
 
@@ -321,6 +320,7 @@ update-base:
 
 0-tools-stamp: 0-pwgen-stamp
 	(cd $(ROOT)/tools/builder && gmake builder)
+	(cd $(ROOT)/tools/format_image && gmake)
 	touch $@
 
 0-pwgen-stamp:
@@ -386,6 +386,8 @@ clean:
 	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO) \
 	    $(IMAGES_PROTO))
 	rm -f tools/cryptpass
+	(cd tools/builder && gmake clean)
+	(cd tools/format_image && gmake clean)
 	(cd tools/mancheck && gmake clean)
 	(cd tools/mancf && gmake clean)
 	(cd tools/tzcheck && gmake clean)
@@ -396,10 +398,10 @@ clobber: clean
 	pfexec rm -rf output/* output-iso/* output-usb/*
  
 iso: live
-	./tools/build_iso
+	./tools/build_image -I -r $(ROOT)
 
 usb: live
-	./tools/build_usb
+	./tools/build_image -r $(ROOT)
 
 FRC:
 
diff --git a/overlay/generic/boot/forth/menu.rc b/overlay/generic/boot/forth/menu.rc
new file mode 100644
index 00000000..eb559a18
--- /dev/null
+++ b/overlay/generic/boot/forth/menu.rc
@@ -0,0 +1,144 @@
+\ Menu.rc
+\
+\ Load required Forth modules
+include /boot/forth/version.4th
+include /boot/forth/brand.4th
+include /boot/forth/menu.4th
+include /boot/forth/menu-commands.4th
+include /boot/forth/shortcuts.4th
+
+\ Screen prep
+clear         \ clear the screen (see `screen.4th')
+print_version \ print version string (bottom-right; see `version.4th')
+draw-beastie  \ draw freebsd mascot (on right; see `beastie.4th')
+draw-brand    \ draw the FreeBSD title (top-left; see `brand.4th')
+menu-init     \ initialize the menu area (see `menu.4th')
+
+\ Initialize main menu constructs (see `menu.4th')
+\ NOTE: To use `non-ansi' variants, add `loader_color=0' to loader.conf(5)
+\ NOTE: ANSI variants can use `^' in place of literal `Esc' (ASCII 27)
+
+\
+\ MAIN MENU
+\
+
+set menuset_name1="main"
+
+set mainmenu_init[1]="init_boot"
+
+set mainmenu_caption[1]="Boot SmartOS [Enter]"
+set maintoggled_text[1]="R[e]covery (root/root) [Enter]"
+set mainansi_caption[1]="^[1mB^[moot SmartOS ^[1m[Enter]^[m"
+set maintoggled_ansi[1]="R^[1me^[mcovery (root/root) ^[1m[Enter]^[m"
+set mainmenu_command[1]="boot"
+\ keycode set by init_boot
+
+set mainmenu_caption[2]="Boot [S]ingle User"
+set maintoggled_text[2]="Boot [M]ulti User"
+set mainansi_caption[2]="Boot ^[1mS^[mingle User"
+set maintoggled_ansi[2]="Boot ^[1mM^[multi User"
+set mainmenu_command[2]="altboot"
+\ keycode set by init_altboot
+
+set mainmenu_caption[3]="[Esc]ape to loader prompt"
+set mainmenu_command[3]="goto_prompt"
+set mainmenu_keycode[3]=27
+set mainansi_caption[3]="^[1mEsc^[mape to loader prompt"
+
+\ Enable built-in "Reboot" trailing menuitem
+\ NOTE: appears before menu_options if configured
+\
+set mainmenu_reboot
+
+\ Enable "Options:" separator. When set to a numerical value (1-8), a visual
+\ separator is inserted before that menuitem number.
+\
+set mainmenu_options=5
+
+\ illumos does not have multiple kernels
+\ set mainmenu_kernel=5
+\ set mainmenu_command[5]="cycle_kernel"
+\ set mainmenu_keycode[5]=107
+
+set mainmenu_caption[5]="Configure Boot [O]ptions..."
+set mainmenu_command[5]="2 goto_menu"
+set mainmenu_keycode[5]=111
+set mainansi_caption[5]="Configure Boot ^[1mO^[mptions..."
+
+\
+\ BOOT OPTIONS MENU
+\
+
+set menuset_name2="options"
+
+set optionsmenu_caption[1]="Back to Main Menu [Backspace]"
+set optionsmenu_command[1]="1 goto_menu"
+set optionsmenu_keycode[1]=8
+set optionsansi_caption[1]="Back to Main Menu ^[1m[Backspace]^[m"
+
+\ set optionsmenu_caption[2]="Load System [D]efaults"
+\ set optionsmenu_command[2]="set_default_boot_options"
+\ set optionsmenu_keycode[2]=100
+\ set optionsansi_caption[2]="Load System ^[1mD^[mefaults"
+
+set optionsmenu_options=2
+set optionsmenu_optionstext="Boot Options:"
+
+set optionsmenu_osconsole=2
+set optionsmenu_command[2]="cycle_osconsole"
+set optionsmenu_keycode[2]=99
+
+set optionsmenu_init[3]="init_singleuser"
+set optionsmenu_caption[3]="[S]ingle User. Off"
+set optionstoggled_text[3]="[S]ingle User. On"
+set optionsmenu_command[3]="toggle_singleuser"
+set optionsmenu_keycode[3]=115
+set optionsansi_caption[3]="^[1mS^[mingle User. ^[34;1mOff^[m"
+set optionstoggled_ansi[3]="^[1mS^[mingle User. ^[32;7mOn^[m"
+
+set optionsmenu_init[4]="init_verbose"
+set optionsmenu_caption[4]="[V]erbose..... Off"
+set optionstoggled_text[4]="[V]erbose..... On"
+set optionsmenu_command[4]="toggle_verbose"
+set optionsmenu_keycode[4]=118
+set optionsansi_caption[4]="^[1mV^[merbose..... ^[34;1mOff^[m"
+set optionstoggled_ansi[4]="^[1mV^[merbose..... ^[32;7mOn^[m"
+
+\ XXX - chnage this menu item to Rescue Mode
+set optionsmenu_init[5]="init_reconfigure"
+set optionsmenu_caption[5]="[R]econfigure. Off"
+set optionstoggled_text[5]="[R]econfigure. On"
+set optionsmenu_command[5]="toggle_reconfigure"
+set optionsmenu_keycode[5]=114
+set optionsansi_caption[5]="^[1mR^[meconfigure. ^[34;1mOff^[m"
+set optionstoggled_ansi[5]="^[1mR^[meconfigure. ^[32;7mOn^[m"
+
+set optionsmenu_init[6]="init_kmdb"
+set optionsmenu_caption[6]="k[m]db........ Off"
+set optionstoggled_text[6]="k[m]db........ On"
+set optionsmenu_command[6]="toggle_kmdb"
+set optionsmenu_keycode[6]=109
+set optionsansi_caption[6]="k^[1mm^[mdb........ ^[34;1mOff^[m"
+set optionstoggled_ansi[6]="k^[1mm^[mdb........ ^[32;7mOn^[m"
+
+set optionsmenu_init[7]="init_debug"
+set optionsmenu_caption[7]="[D]ebug....... Off"
+set optionstoggled_text[7]="[D]ebug....... On"
+set optionsmenu_command[7]="toggle_debug"
+set optionsmenu_keycode[7]=100
+set optionsansi_caption[7]="^[1mD^[mebug....... ^[34;1mOff^[m"
+set optionstoggled_ansi[7]="^[1mD^[mebug....... ^[32;7mOn^[m"
+
+\ Enable automatic booting (add ``autoboot_delay=N'' to loader.conf(5) to
+\ customize the timeout; default is 10-seconds)
+\
+set menu_timeout_command="boot"
+
+\ Include optional elements defined in a local file
+\
+try-include /boot/menu.rc.local
+
+\ Display the main menu (see `menu.4th')
+set menuset_initial=1
+menuset-loadinitial
+menu-display
diff --git a/tools/build_image b/tools/build_image
new file mode 100755
index 00000000..c2ceda40
--- /dev/null
+++ b/tools/build_image
@@ -0,0 +1,360 @@
+#!/usr/bin/bash
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+#
+# This script automates the process of building ISO and USB images of a SmartOS
+# build.  It can also be used to produce the proforma disk images used by the
+# tools in sdc-headnode.git to produce Triton USB and COAL images.  When
+# building SmartOS media, it uses the latest platform file that's been built.
+# This program can be invoked standalone via the "gmake iso", "gmake usb" and
+# "gmake images" targets of the top-level Makefile in "smartos-live.git".
+#
+# This script needs to be run either as root or as a user that is granted the
+# "Primary Administator" profile.  When run in a non-global zone, it must be
+# configured with "fs_allowed=ufs,pcfs"
+#
+# Things are complicated here by the fact that we would like to run inside a
+# non-global with older kernels.  Most of our partitioning tools such as format
+# do not run well inside a non-global zone, and non-labeled lofi doesn't have
+# sufficient support either.  So we delegate the tricky bits to format_image.
+#
+
+bi_make_iso=0
+bi_proforma_only=0
+bi_ufs_root=0
+bi_nocleanup=0
+bi_imgsz="512m"
+lofi_blkdev=
+lofi_rawdev=
+esp_blkdev=
+usb_image_name=
+platver=
+rootmnt=
+efimnt=
+tmpdir=
+
+function detach_lofi()
+{
+	local readonly dev=$1
+
+	if [[ -z "$dev" ]]; then
+		return
+	fi
+
+	if pfexec lofiadm $dev 2>/dev/null; then
+		print "Detaching LOFI device $dev ... \c"
+		pfexec lofiadm -d $dev
+		print "done"
+	fi
+}
+
+function cleanup()
+{
+	[[ $bi_nocleanup == 1 ]] && return
+
+	print "Cleaning up"
+
+	if mount | grep $efimnt >/dev/null; then
+		pfexec umount $efimnt
+	fi
+
+	if mount | grep $rootmnt >/dev/null; then
+		pfexec umount $rootmnt
+	fi
+
+	detach_lofi $lofi_blkdev
+	detach_lofi $esp_blkdev
+
+	pfexec rm -f $tmpdir/pmbr
+	pfexec rm -f $tmpdir/gptzfsboot
+	pfexec rm -f $tmpdir/esp.img
+	pfexec rm -f $tmpdir/rootfs.img
+	pfexec rm -f $tmpdir/smartos.usb
+	pfexec rm -f $tmpdir/partitions.out
+	pfexec rm -rf $tmpdir/mnt
+	pfexec rmdir $tmpdir
+}
+
+function fail()
+{
+        printf "%s\n" "$1" 1>&2
+        exit 1
+}
+
+function usage()
+{
+	[[ ! -z $1 ]] && printf "%s\n\n" "$1" 1>&2
+
+	print -u2 "Usage: build_image [-U] [-I] [-x] [-p <size>] -r <smartos-live repo>"
+	print -u2 "\n -U\tcreate UFS filesystem on root partition (default: PCFS)"
+	print -u2 " -I\tbuild SmartOS ISO image (default: USB image)"
+	print -u2 " -p\tbuild proforma USB image for Triton"
+	print -u2 " -x\tdon't cleanup on exit (for debugging use)\n"
+	exit 2
+}
+
+function pfrun()
+{
+	pfexec $*
+	local status=$?
+
+	if [[ $status != 0 ]]; then
+		print -u2 "\nCommand failed: $*\nExit status: $status"
+		exit 1
+	fi
+}
+
+#
+# Construct the EFI System Partition image: right now, this only contains
+# loader, so the 34Mb size is plenty.
+#
+function create_esp()
+{
+	local readonly tmpdir=$1
+	local readonly efimnt=$2
+	local readonly boot_tgz=$3
+	local readonly esp_size=34 # Mb
+	local readonly esp_sects=$(( $esp_size * 1024 * 1024 / 512 ))
+
+	pfrun mkfile -n ${esp_size}m $tmpdir/esp.img
+	esp_blkdev=$(pfexec lofiadm -a $tmpdir/esp.img)
+	[[ $? == 0 ]] || fail "Failed to create ESP lofi device"
+	readonly esp_rawdev=${esp_blkdev/lofi/rlofi}
+
+	pfrun mkfs -F pcfs -o b=system,size=$esp_sects,nofdisk,fat=32 \
+	    $esp_rawdev </dev/null
+
+	pfrun mkdir -p $efimnt
+	pfrun mount -F pcfs $esp_blkdev $efimnt
+	pfrun mkdir -p $efimnt/efi/boot
+	pfrun gtar Oxfz $boot_tgz \
+	    ./boot/loader64.efi >$efimnt/efi/boot/BOOTX64.efi
+	pfrun umount $efimnt
+	pfrun lofiadm -d $esp_blkdev
+}
+
+#
+# Assemble all our boot parts into the disk image.
+#
+function label_image()
+{
+	local readonly tmpdir=$1
+	local readonly boot_tgz=$2
+	local readonly dev=$3
+
+	pfrun gtar Oxfz $boot_tgz ./boot/pmbr >$tmpdir/pmbr
+	pfrun gtar Oxfz $boot_tgz ./boot/gptzfsboot >$tmpdir/gptzfsboot
+
+	args="-m $tmpdir/pmbr -b $tmpdir/gptzfsboot -e $tmpdir/esp.img -o $dev"
+	pfrun $bi_wsroot/tools/format_image/format_image $args >$tmpdir/partitions.out
+}
+
+#
+# Create the blank root filesystem.
+#
+function create_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+	local readonly sects=$(( $4 / 512 ))
+
+	if [[ $bi_ufs_root == 1 ]]; then
+		print "Creating UFS filesystem in root partition ... \c"
+		pfexec newfs $dev </dev/null
+	else
+		print "Creating PCFS filesystem in root partition ... \c"
+		pfrun mkfs -F pcfs -o b=SMARTOSBOOT,size=$sects,nofdisk,fat=32 \
+		    $dev </dev/null
+	fi
+
+	print "done"
+
+	if [[ $bi_proforma_only == 1 ]]; then
+		return
+	fi
+}
+
+#
+# Copy the root filesystem image into the correct place inside the image.
+#
+function copy_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+
+	print "Copying root filesystem at offset $offset ... \c"
+	pfrun /usr/bin/dd bs=512 conv=notrunc if=$dev of=$image \
+	    oseek=$(( $offset / 512 )) >/dev/null 2>&1
+	print "done"
+}
+
+#
+# Populate the root filesystem with all the SmartOS bits, as well as the loader
+# used in legacy boot mode.
+#
+function populate_root()
+{
+	local readonly dev=$1
+	local readonly rootmnt=$2
+	local mntopts="-F pcfs"
+
+	if [[ $bi_ufs_root == 1 ]]; then
+		mntopts="-o nologging"
+	fi
+
+	print "Mounting root partition at $rootmnt ... \c"
+	pfrun mkdir -p $rootmnt
+	pfrun mount $mntopts $dev $rootmnt 2>/dev/null
+	print "done"
+
+	print "Installing boot tarball onto root partition ... \c"
+
+	#
+	# This partially fails due to being unable to set permissions under a
+	# nodevices mount inside an NGZ.
+	#
+	(cd $rootmnt; pfexec tar xfz \
+	    $bi_wsroot/output/boot-${platver}.tgz 2>/dev/null || true)
+
+	pfrun cp -f $bi_wsroot/overlay/generic/boot/forth/menu.rc \
+	    $rootmnt/boot/forth/
+
+	print "done"
+
+	print "Customizing boot loader configuration ... \c"
+	readonly shadow='$5$2HOHRnK3$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'
+	pfrun touch $rootmnt/boot/loader.conf
+	pfrun chmod 666 $rootmnt/boot/loader.conf
+	pfrun echo "loader_logo=\"smartos\"" >> $rootmnt/boot/loader.conf
+	pfrun echo "loader_brand=\"smartos\"" >> $rootmnt/boot/loader.conf
+	pfrun echo "boot-args=\"-B root_shadow=${shadow},smartos=true\"" >> \
+	    $rootmnt/boot/loader.conf
+	print "done"
+
+	print "Copying platform image to root partition" \
+	    "(this will take a while) ... \c"
+
+	#
+	# Fails similarly to tar, and no, --no-preserve does not help.
+	#
+	pfexec cp -rp $bi_wsroot/output/platform-latest/ \
+	    $rootmnt/platform 2>/dev/null || true
+
+	print "done"
+
+	pfrun umount $rootmnt
+}
+
+
+while getopts "IUp:r:x" c $@; do
+	case "$c" in
+	I)	bi_make_iso=1 ;;
+	p)	bi_proforma_only=1
+		bi_imgsz=$OPTARG ;;
+	r)	bi_wsroot=$(readlink -f $OPTARG) ;;
+	U)	bi_ufs_root=1 ;;
+	x)	bi_nocleanup=1 ;;
+	:)	usage ;;
+	*)	usage ;;
+	esac
+done
+
+set -eou pipefail
+export SHELLOPTS
+
+[[ $bi_make_iso == 1 ]] && fail "ISO support not implemented, yet"
+
+[[ -z $bi_wsroot ]] && usage "-r is required"
+
+[[ $bi_proforma_only == 1 ]] && [[ $bi_ufs_root == 1 ]] && \
+    usage "-p and -U are mutually exclusive"
+
+[[ $bi_proforma_only == 1 ]] && [[ $bi_make_iso == 1 ]] && \
+    usage "-p and -I are mutually exclusive"
+
+[[ -e $bi_wsroot/output/platform-latest ]] || \
+    fail "No platform image found in $bi_wsroot/output"
+
+
+tmpdir=$(mktemp -d -p /var/tmp) || fail "mktemp failed!"
+
+trap cleanup EXIT
+
+efimnt=$tmpdir/mnt/efi
+rootmnt=$tmpdir/mnt/root
+usb_image_name=$(readlink -f $bi_wsroot/output/platform-latest)
+usb_image_name=$(basename $usb_image_name)
+platver=$(echo $usb_image_name | awk -F\- '{ print $2 }')
+usb_image_name="${usb_image_name}.usb"
+
+print "Creating empty $bi_imgsz image at $tmpdir/smartos.usb ... \c"
+pfrun mkfile -n $bi_imgsz $tmpdir/smartos.usb
+print "done"
+
+lofi_blkdev=$(pfexec lofiadm -a $tmpdir/smartos.usb)
+[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+lofi_rawdev=${lofi_blkdev/lofi/rlofi}
+
+print "Creating EFI System Partition image ... \c"
+create_esp $tmpdir $efimnt $bi_wsroot/output/boot-${platver}.tgz
+print "done"
+
+print "Labelling USB image ... \c"
+label_image $tmpdir $bi_wsroot/output/boot-${platver}.tgz $lofi_rawdev
+print "done"
+
+pfrun lofiadm -d $lofi_blkdev
+
+rootoff=$(nawk '$1 == "root" { print $3 }' <$tmpdir/partitions.out)
+rootsize=$(nawk '$1 == "root" { print $4 }' <$tmpdir/partitions.out)
+
+pfrun mkfile -n $rootsize $tmpdir/rootfs.img
+
+lofi_blkdev=$(pfexec lofiadm -a $tmpdir/rootfs.img)
+[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+lofi_rawdev=${lofi_blkdev/lofi/rlofi}
+
+create_root $lofi_rawdev $tmpdir/smartos.usb $rootoff $rootsize
+
+#
+# If we're only building a proforma image for Triton, then we're done.
+#
+if [[ $bi_proforma_only == 1 ]]; then
+	copy_root $lofi_rawdev $tmpdir/smartos.usb $rootoff
+	pfrun lofiadm -d $lofi_blkdev
+	pfrun mkdir -p $bi_wsroot/proto.images
+	pfrun mv $tmpdir/smartos.usb $bi_wsroot/proto.images/${bi_imgsz}b.img
+	pfrun chmod 444 $bi_wsroot/proto.images/${bi_imgsz}b.img
+	print "Successfully created proforma image:" \
+	    "$bi_wsroot/proto.images/${bi_imgsz}b.img"
+	exit 0
+fi
+
+populate_root $lofi_blkdev $rootmnt
+
+copy_root $lofi_rawdev $tmpdir/smartos.usb $rootoff
+pfrun lofiadm -d $lofi_blkdev
+pfrun mkdir -p $bi_wsroot/output-usb
+pfrun mv $tmpdir/smartos.usb $bi_wsroot/output-usb/$usb_image_name
+pfrun chmod 644 $bi_wsroot/output-usb/$usb_image_name
+
+print "Successfully created SmartOS USB image:" \
+    "$bi_wsroot/output-usb/$usb_image_name"
+exit 0
diff --git a/tools/build_iso b/tools/build_iso
deleted file mode 100755
index da8e5c56..00000000
--- a/tools/build_iso
+++ /dev/null
@@ -1,392 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright (c) 2017, Joyent, Inc.
-#
-
-#
-# Automates the process of building ISO and USB images of a SmartOS build.  It
-# uses the latest platform file that's been built.  This program should be
-# invoked via the "make iso" and "make usb" targets of the top-level Makefile
-# in "smartos-live.git".
-#
-
-shopt -s xpg_echo
-set -o pipefail
-export PATH=/usr/bin:/opt/local/bin:/usr/sbin
-
-bi_wsroot=$(cd $(dirname $0)/../; pwd)
-bi_arg0=$(basename $0)
-bi_type=${bi_arg0/build_/}
-
-. "${bi_wsroot}/tools/lib/build_common.sh"
-
-bi_grub_dir="proto/boot/grub"
-bi_output_grub_dir="$bi_tmpdir/boot/grub"
-bi_grub_files="stage1 stage2 stage2_eltorito"
-bi_archive_path="i86pc/amd64/boot_archive"
-bi_unix_path="i86pc/kernel/amd64/unix"
-bi_usb_size=2000000000
-bi_grub_optstr=
-bi_console=vga
-bi_grub_unit=
-bi_dont_clean=0
-bi_no_smartos=0
-bi_do_kmdb=
-bi_usbpath=
-bi_tmpusbpath=
-bi_lofidev=
-
-
-function usage
-{
-	local msg="$*"
-	[[ -z "$msg" ]] && echo "$msg"
-	cat <<USAGE >&2
-Usage: $bi_arg0 [ -o options ] [-c dev] [ -k ] [ -m ]
-
-Generate a bootable $bi_type image from the proto area and newest platform directory.
-
-	-o options	Append all the options to every GRUB menu.lst entry
-	-c dev		Set default console to be dev (tty{a,b,c,d} or vga)
-	-k		Don't delete temporary files
-	-m		Default to kmdb
-	-n		Don't build for SmartOS
-	-h		Display this message
-
-USAGE
-	exit 2
-}
-
-function fail_cleanup
-{
-	if [[ x"$bi_lofidev" != x ]]; then
-		#(unmount and) cleanup the lofi device
-		pfexec umount -f ${bi_lofidev}:c
-		pfexec lofiadm -d $bi_lofidev
-	fi
-	# an uncompressed usb file is probably incomplete.  remove it
-	[[ -f $bi_tmpusbpath ]] && rm -f $bi_tmpusbpath
-	[[ -f $bi_usbpath ]] && rm -f $bi_usbpath
-	local msg="$*"
-	[[ -z "$msg" ]] && msg="failed"
-	echo "$bi_arg0: $msg" >&2
-	exit 1
-}
-
-function bi_verif_mkisofs
-{
-	bi_emit_start 'Checking for mkisofs'
-	which mkisofs >/dev/null
-	[[ $? -eq 0 ]] || fail "missing mkisofs"
-	bi_emit_done
-}
-
-function bi_get_build
-{
-	#
-	# The build process updates a "platform-latest" symlink to the
-	# most recently built platform directory.  We use that symlink
-	# to decide which platform to bundle into the ISO or USB image.
-	#
-	bi_emit_start 'Determining platform'
-	if [[ ! -L "${bi_platform_dir}/platform-latest" ]]; then
-		fail '"platform-latest" symlink does not exist'
-	fi
-
-	if ! bi_platform_name=$(/usr/bin/readlink \
-	    "${bi_platform_dir}/platform-latest"); then
-		fail 'failed to read "platform-latest" symlink'
-	fi
-
-	bi_platform="${bi_platform_dir}${bi_platform_name}"
-	if [[ -z "${bi_platform_name}" || ! -d "${bi_platform}" ]]; then
-		fail '"platform-latest" symlink does not point to directory'
-	fi
-
-	bi_emit_done
-	bi_emit_info 'Using platform' "${bi_platform_name}"
-}
-
-#
-# Check to make sure the 64-bit kernel is actually there as a brief sanity check
-#
-function bi_verif_platform
-{
-	bi_emit_start 'Verifying platform'
-	[[ -d $bi_platform ]] || fail "invalid platform directory"
-	[[ -f $bi_platform/$bi_archive_path ]] || fail "missing boot archive"
-	[[ -f $bi_platform/$bi_unix_path ]] || fail "missing kernel image"
-	bi_emit_done
-}
-
-function bi_verif_grub
-{
-	bi_emit_start 'Verifying grub files'
-	if [[ ! -d $bi_grub_dir ]]; then
-		fail "missing /boot/grub from proto area"
-	fi
-	for file in $bi_grub_files; do
-		if [[ ! -f $bi_grub_dir/$file ]]; then
-			fail "file missing from grub proto area: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_verif_console
-{
-	bi_emit_start 'Verifying console selection'
-	case "$bi_console" in
-	text|graphics|vga)
-		bi_console=vga
-		bi_grub_unit=1,0,2,3
-		;;
-	ttya)
-		bi_grub_unit=0,1,2,3
-		;;
-	ttyb)
-		bi_grub_unit=1,0,2,3
-		;;
-	ttyc)
-		bi_grub_unit=2,1,0,3
-		;;
-	ttyd)
-		bi_grub_unit=3,1,0,2
-		;;
-	*)
-		fail "Invalid console device $bi_console"
-		;;
-	esac
-	bi_emit_done
-}
-
-function bi_generate_usb_file
-{
-	local tmp_free
-
-	if [[ ! -d $bi_output_dir ]]; then
-		mkdir -p $bi_output_dir > /dev/null
-		[[ $? -eq 0 ]] || fail "failed to make output directory"
-	fi
-
-	bi_emit_start 'Generating usb image file'
-	bi_usbpath="$bi_output_dir/$bi_platform_name.usb"
-	bi_tmpusbpath=$bi_usbpath
-
-	tmp_free=$(stat -f -c '%S * %f' $bi_tmpdir | xargs expr)
-	if ((tmp_free >= bi_usb_size + 10000)); then
-		bi_tmpusbpath="$bi_tmpdir/$bi_platform_name.usb"
-	fi
-
-	rm -f $bi_tmpusbpath
-	if ! mkfile -n $bi_usb_size $bi_tmpusbpath; then
-		fail "failed to generate usb file"
-	fi
-	if ! bi_lofidev=$(pfexec lofiadm -a $bi_tmpusbpath); then
-		fail "failed to create lofi device"
-	fi
-	if ! pfexec fdisk -F "$(dirname $0)/usb_fdisk_table" \
-	    "${bi_lofidev/lofi/rlofi}"; then
-		fail "failed to partition ${bi_lofidev/lofi/rlofi}"
-	fi
-	echo "y" | pfexec mkfs -F pcfs -o b=SMARTOSBOOT,fat=32 ${bi_lofidev/lofi/rlofi}:c
-	[[ $? -eq 0 ]] || fail "failed to format the usb image"
-	bi_emit_done
-
-	bi_emit_start 'Mounting usb image file'
-	if ! pfexec mount -F pcfs "${bi_lofidev}:c" "$bi_tmpdir"; then
-		fail "failed to mount usb image"
-	fi
-	bi_emit_done
-}
-
-function bi_copy_contents
-{
-	bi_emit_start 'Copying platform directory'
-	if ! cp -r $bi_platform $bi_tmpdir/platform >/dev/null; then
-		fail "failed to copy platform file"
-	fi
-	bi_emit_done
-
-	bi_emit_start 'Copying grub components'
-	if ! mkdir -p $bi_output_grub_dir; then
-		fail "failed to iso9960 grub output directory"
-	fi
-	for file in $bi_grub_files; do
-		if ! cp $bi_grub_dir/$file $bi_output_grub_dir >/dev/null; then
-			fail "failed to copy grub file: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_generate_grub_conf
-{
-	if [[ $bi_no_smartos != 1 ]]; then
-		bi_grub_optstr="${bi_grub_optstr},smartos=true"
-	fi
-	local console_settings='console=${os_console},${os_console}-mode="115200,8,n,1,-"'
-	# keep passord and shadow in sync, please
-	local password='root'
-	local shadow='$5$2HOHRnK3$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'
-	local default=0
-	[[ -n "$bi_do_kmdb" ]] && default=2
-	bi_emit_start 'Generating grub menu.lst'
-	cat > $bi_output_grub_dir/menu.lst <<EOF
-default=$default
-timeout=10
-min_mem64 1024
-serial --speed=115200 --unit=$bi_grub_unit --word=8 --parity=no --stop=1
-terminal composite
-variable os_console $bi_console
-
-title SmartOS
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS noinstall/recovery (login/pw: root/$password)
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow',standalone=true,noimport=true
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS +kmdb
-   kernel$ /platform/i86pc/kernel/amd64/unix -kd -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-EOF
-	[[ $? -eq 0 ]] || fail "failed to create menu.lst"
-	bi_emit_done
-}
-
-function bi_generate_iso
-{
-	local isopath
-
-	if [[ ! -d $bi_output_dir ]]; then
-		if ! mkdir $bi_output_dir > /dev/null; then
-			fail "failed to make output directory"
-		fi
-	fi
-	bi_emit_start 'Generating iso...'
-	isopath="$bi_output_dir/$bi_platform_name.iso"
-	LC_ALL=C mkisofs -R -b 		\
-	    boot/grub/stage2_eltorito	\
-	    -no-emul-boot 		\
-	    -boot-load-size 4		\
-	    -boot-info-table		\
-	    -quiet			\
-	    -o 	$isopath		\
-	    $bi_tmpdir/ >/dev/null
-	[[ $? -eq 0 ]] || fail "Failed to create iso"
-	bi_emit_done
-	bi_emit_info 'ISO output' "$(pwd)/$isopath"
-}
-
-
-function bi_generate_usb
-{
-	# The image file in $bi_tmpdir is hidden by the mounted image contents,
-	# so we have to make it visible again by umounting before grub can be
-	# installed.
-	if ! pfexec umount "${bi_lofidev}:c"; then
-		fail "failed to unmount ${bi_lofidev}:c"
-	fi
-	if ! pfexec lofiadm -d $bi_lofidev; then
-		fail "failed to remove lofi device $bi_lofidev"
-	fi
-	bi_lofidev= #unset that variable so fail won't try to clean it up again
-
-	bi_emit_start 'Installing grub'
-	bi_emit_newline
-	grub --batch <<____ENDOFGRUBCOMMANDS
-device (hd0) $bi_tmpusbpath
-root (hd0,0)
-setup (hd0)
-quit
-____ENDOFGRUBCOMMANDS
-	[[ $? -eq 0 ]] || fail "failed to install grub"
-	bi_emit_done
-
-	bi_emit_start 'Compressing usb image'
-	[[ -f ${bi_usbpath}.bz2 ]] && rm ${bi_usbpath}.bz2
-	if ! pbzip2 -c $bi_tmpusbpath > ${bi_usbpath}.bz2; then
-		fail "failed to compress $bi_usbpath"
-	fi
-	rm -f $bi_tmpusbpath
-	bi_emit_done
-	bi_emit_info 'USB Output' "$(pwd)/${bi_usbpath}.bz2"
-}
-
-while getopts "kmo:nhc:" c $@; do
-	case "$c" in
-	o)
-		bi_emit_info \
-		    "Building $bi_type image with additional options:" \
-		    "$OPTARG"
-		bi_grub_optstr=",$OPTARG"
-		;;
-	c)
-		bi_console="$OPTARG"
-		;;
-	k)
-		bi_dont_clean=1
-		;;
-	m)
-		bi_do_kmdb=1
-		;;
-	n)
-		bi_no_smartos=1
-		;;
-	h)
-		usage
-		;;
-	:)
-		usage "missing required argument -- $OPTARG"
-		;;
-	*)
-		usage "invalid option: $OPTARG"
-		;;
-	esac
-done
-
-bi_big_banner "Building \"$bi_type\" image"
-
-#
-# Get us to the root of the workspace
-#
-if ! cd ${bi_wsroot}; then
-	fail "could not chdir to workspace root \"${bi_wsroot}\""
-fi
-
-case "$bi_type" in
-	iso)
-		bi_verif_mkisofs
-		;;
-	usb)
-		;;
-esac
-bi_verif_grub
-bi_verif_console
-bi_get_build
-bi_verif_platform
-bi_setup_work_dir
-bi_copy_contents
-bi_generate_grub_conf
-case "$bi_type" in
-	iso)
-		bi_generate_iso
-		;;
-	usb)
-		bi_generate_usb
-		;;
-esac
-bi_cleanup_work_dir
diff --git a/tools/build_usb b/tools/build_usb
deleted file mode 120000
index a3116dfa..00000000
--- a/tools/build_usb
+++ /dev/null
@@ -1 +0,0 @@
-build_iso
\ No newline at end of file
diff --git a/tools/format_image/Makefile b/tools/format_image/Makefile
new file mode 100644
index 00000000..4f0e8d2a
--- /dev/null
+++ b/tools/format_image/Makefile
@@ -0,0 +1,31 @@
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+CC=gcc
+CFLAGS=-std=gnu99 -Wall -W -Werror -Wno-sign-compare
+SRC_ROOT=$(PWD)/../..
+
+TARGETS=format_image
+LIBS=-lsmbios -luuid
+
+#
+# Yes, we're directly pulling in a local copy of libefi source: see do_ioctl()
+# there for why. When our earliest platform has proper lofi support, we can stop
+# doing this, but for now, it's the simplest way of having less code.
+#
+OBJS=format_image.o rdwr_efi.o crc32_efi.o
+
+all: $(TARGETS)
+
+format_image: $(OBJS)
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS)
+
+%.o: %.c
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+%.o: $(SRC_ROOT)/projects/illumos/usr/src/lib/libefi/common/%.c
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+clean:
+	rm $(TARGETS) $(OBJS)
diff --git a/tools/format_image/format_image.c b/tools/format_image/format_image.c
new file mode 100644
index 00000000..96c5c1fa
--- /dev/null
+++ b/tools/format_image/format_image.c
@@ -0,0 +1,379 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * As the build runs in a non-global zone, we don't have the luxury of tools
+ * such as labeled lofi, format, etc. in order to create the USB image.  We are
+ * looking to create an image of the following form:
+ *
+ * Part Tag      First Sector Size     Type
+ * -    mbr/GPT  0            128KB    MBR+EFI GPT (-m option plus libefi)
+ * 0    system   256          34.00MB  EFI System Partition (-e option)
+ * 1    boot     69888        1.00MB   Legacy BIOS boot partition (-b option)
+ * 2    root     71936        468.86MB pcfs or ufs root
+ * 8    reserved 1032159      8.00MB   EFI backup GPT
+ *
+ * This boots under BIOS as follows:
+ *
+ * 1. BIOS loads the MBR, which jumps to stage2_sector (see pmbr.s)
+ * 2. stage2 is gptzfsboot, in partition 1 above
+ * 3. despite the name, this can also load pcfs/ufs - partition 2 above.
+ *    To find the partition, there is a weirdo fake multiboot header embedded
+ *    that we need to update with the starting LBA of partition 2.
+ * 4. This then boots into loader
+ * 5. which finally will load the kernel
+ *
+ * On a UEFI system:
+ *
+ * 1. BIOS finds the ESP at partition 0, and loads /EFI/BOOT/BOOTX64.EFI
+ * as defined by the EFI spec. This is "loader"
+ * 2. loader loads kernel from the pcfs/ufs root from partition 2
+ * 3. kernel takes control
+ *
+ * So this tool needs to fix up then write a modified MBR, populate the GPT
+ * header and partition tables, and write out the ESP and biosboot images.
+ * It is sort of an unholy merger of zpool_label_disk(ZPOOL_CREATE_BOOT_LABEL)
+ * and installboot(1m).
+ *
+ * It only currently supports 512 block size, and isn't endian-vetted.
+ *
+ * The "root" partition is populated later, not by this tool.
+ */
+
+#include <uuid/uuid.h>
+#include <strings.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <err.h>
+
+#include <sys/efi_partition.h>
+#include <sys/dktp/fdisk.h>
+#include <sys/types.h>
+#include <sys/vtoc.h>
+#include <sys/stat.h>
+
+#define	EXIT_USAGE (2)
+
+#define	LBSIZE (SECTOR_SIZE)
+#define	PART_ALIGN (SECTOR_SIZE)
+#define	LEGACY_BOOTPART_BLOCKS (2048) /* in LBSIZE */
+#define	LEGACY_BOOTPART_SIZE (LEGACY_BOOTPART_BLOCKS * LBSIZE)
+
+/*
+ * Space for MBR+GPT prior to first partition.  We use what zpool create does
+ * here, but not for any particular reason.
+ */
+#define	START_SECT (256)
+
+/*
+ * From installboot.h, these are a set of offsets into the MBR.
+ */
+#define	SECTOR_SIZE (512)
+#define	STAGE1_STAGE2_SIZE (0xfc)  /* 16bits */
+#define	STAGE1_STAGE2_LBA (0xfe)  /* 64bits */
+#define	STAGE1_STAGE2_UUID (0x106) /* 128bits */
+#define	STAGE1_BPB_OFFSET (0x3)   /* technically BPB starts at 0xb */
+#define	STAGE1_BPB_SIZE (0x3b)
+#define	STAGE1_MAGIC (0x1fe) /* 0xAA55 */
+
+/*
+ * From multiboot.h
+ */
+#define	MB_HEADER_MAGIC		 0x1BADB002	/* magic */
+
+typedef struct multiboot_header {
+	uint32_t	magic;
+	uint32_t	flags;
+	uint32_t	checksum;
+	caddr32_t	header_addr;
+	caddr32_t	load_addr;
+	caddr32_t	load_end_addr;
+	caddr32_t	bss_end_addr;
+	caddr32_t	entry_addr;
+} multiboot_header_t;
+
+static const char *progname;
+static size_t biosboot_start;
+static int outfile;
+
+static void
+usage(const char *fmt, ...)
+{
+	if (fmt != NULL) {
+		va_list ap;
+
+		(void) fprintf(stderr, "%s: ", progname);
+		va_start(ap, fmt);
+		(void) vfprintf(stderr, fmt, ap);
+		va_end(ap);
+		(void) fputs("\n", stderr);
+	}
+
+	(void) fprintf(stderr,
+	    "Usage: %s -o image.usb -m mbr -e efifs -b biosboot\n"
+	    "\n"
+	    "Format a USB/ISO image for booting SmartOS or Triton.\n"
+	    "\n"
+	    "\t-o  output file\n"
+	    "\t-m  MBR image\n"
+	    "\t-e  EFI system partition (ESP) pcfs image\n"
+	    "\t-b  Legacy BIOS stage2 boot program (gptzfsboot)\n",
+	    progname);
+
+	exit(fmt == NULL ? EXIT_SUCCESS : EXIT_USAGE);
+}
+
+static char *
+read_file(const char *path, size_t size, size_t *lenp)
+{
+	struct stat st;
+	ssize_t ret;
+	size_t left;
+	char *buf;
+	char *pos;
+	int fd;
+
+	if ((fd = open(path, O_RDONLY)) == -1)
+		err(EXIT_FAILURE, "couldn't open %s", path);
+
+	if (fstat(fd, &st) != 0)
+		err(EXIT_FAILURE, "couldn't state %s", path);
+
+	if (size != 0 && st.st_size > size) {
+		errx(EXIT_FAILURE, "file %s exceeds maximum %lu bytes",
+		    path, size);
+	}
+
+	if (size == 0)
+		size = st.st_size;
+
+	if ((buf = calloc(1, size)) == NULL)
+		err(EXIT_FAILURE, "couldn't alloc buf for %s", path);
+
+	for (left = st.st_size, pos = buf; left; pos += ret, left -=ret) {
+		ret = read(fd, pos, left);
+
+		if (ret < 0)
+			err(EXIT_FAILURE, "couldn't read from %s", path);
+	}
+
+	if (lenp != NULL)
+		*lenp = st.st_size;
+	return (buf);
+}
+
+static void
+write_mbr(char *mbr, size_t esplen, size_t biosbootlen)
+{
+	uint64_t *stage2_lbap = (uint64_t *)(mbr + STAGE1_STAGE2_LBA);
+	uint16_t *stage2_sizep = (uint16_t *)(mbr + STAGE1_STAGE2_SIZE);
+	uchar_t *uuidp = (uchar_t *)(mbr + STAGE1_STAGE2_UUID);
+
+	*stage2_lbap = START_SECT + esplen / LBSIZE;
+	*stage2_sizep = biosbootlen / LBSIZE;
+
+	/*
+	 * This is all "nops" in the MBR image: let's clear it out like
+	 * installboot(1M) does.
+	 */
+	bzero(mbr + STAGE1_BPB_OFFSET, STAGE1_BPB_SIZE);
+
+	uuid_generate(uuidp);
+
+	if (pwrite(outfile, mbr, SECTOR_SIZE, 0) != SECTOR_SIZE)
+		err(EXIT_FAILURE, "failed to write MBR");
+}
+
+static void
+set_part(struct dk_part *part, diskaddr_t start, diskaddr_t size,
+    const char *name, ushort_t tag)
+{
+	printf("%s %d %llu %llu\n", name, tag, start * LBSIZE, size * LBSIZE);
+	part->p_start = start;
+	part->p_size = size;
+	(void) strlcpy(part->p_name, name, sizeof (part->p_name));
+	part->p_tag = tag;
+}
+
+static void
+write_efi(size_t esplen)
+{
+	struct dk_gpt *vtoc;
+	diskaddr_t start = START_SECT;
+	diskaddr_t size;
+	int ret;
+
+	if (efi_alloc_and_init(outfile, EFI_NUMPAR, &vtoc) != 0)
+		err(EXIT_FAILURE, "failed to init EFI");
+
+	set_part(&vtoc->efi_parts[0], start, esplen / LBSIZE,
+	    "loader", V_SYSTEM);
+
+	start += esplen / LBSIZE;
+	biosboot_start = start;
+
+	set_part(&vtoc->efi_parts[1], start, LEGACY_BOOTPART_BLOCKS,
+	    "boot", V_BOOT);
+
+	start += LEGACY_BOOTPART_BLOCKS;
+	size = vtoc->efi_last_u_lba + 1 - (EFI_MIN_RESV_SIZE + start);
+	set_part(&vtoc->efi_parts[2], start, size, "root", V_ROOT);
+
+	start += size;
+	set_part(&vtoc->efi_parts[8], start, EFI_MIN_RESV_SIZE,
+	    "reserved", V_RESERVED);
+
+	/*
+	 * This also updates the PMBR for the protective partition.
+	 */
+	if ((ret = efi_write(outfile, vtoc)) != 0)
+		errx(EXIT_FAILURE, "failed to write EFI with %d", ret);
+
+	efi_free(vtoc);
+}
+
+static void
+write_esp(char *esp, size_t esplen)
+{
+	if (pwrite(outfile, esp, esplen, START_SECT * LBSIZE) != esplen)
+		err(EXIT_FAILURE, "failed to write ESP");
+}
+
+static multiboot_header_t *
+find_multiboot(char *biosboot, size_t biosbootlen)
+{
+	for (size_t off = 0; off < biosbootlen; off +=4) {
+		multiboot_header_t *mb = (multiboot_header_t *)(biosboot + off);
+
+		if (mb->magic != MB_HEADER_MAGIC)
+			continue;
+
+		if (-(mb->flags + mb->magic) != mb->checksum)
+			continue;
+
+		return (mb);
+	}
+
+	return (NULL);
+}
+
+/*
+ * Before we can write out gptzfsboot we need to update its embedded
+ * multiboot_header_t: the ->bss_end_addr offset is examined to figure out the
+ * root partition's start sector (see sys/boot/common/multiboot.S).  Whoever
+ * said booting was pleasant?
+ */
+static void
+write_biosboot(char *biosboot, size_t biosbootlen)
+{
+	/* in sectors */
+	multiboot_header_t *multiboot;
+	uint64_t *ptr;
+
+	if ((multiboot = find_multiboot(biosboot, biosbootlen)) == NULL)
+		errx(EXIT_FAILURE, "couldn't find fake multiboot header");
+
+	ptr = (uint64_t *)&multiboot->bss_end_addr;
+	*ptr = biosboot_start + LEGACY_BOOTPART_BLOCKS;
+
+	if (pwrite(outfile, biosboot, LEGACY_BOOTPART_SIZE,
+	    biosboot_start * LBSIZE) != LEGACY_BOOTPART_SIZE)
+		err(EXIT_FAILURE, "failed to write biosboot");
+}
+
+int
+main(int argc, char *argv[])
+{
+	const char *biosbootpath = NULL;
+	const char *esppath = NULL;
+	const char *mbrpath = NULL;
+	const char *outpath = NULL;
+	size_t biosbootlen;
+	char *biosboot;
+	size_t esplen;
+	char *esp;
+	char *mbr;
+	int c;
+
+	progname = basename(argv[0]);
+
+	while ((c = getopt(argc, argv, ":b:e:hm:o:")) != -1) {
+		switch (c) {
+		case 'b':
+			biosbootpath = optarg;
+			break;
+		case 'e':
+			esppath = optarg;
+			break;
+		case 'o':
+			outpath = optarg;
+			break;
+		case 'm':
+			mbrpath = optarg;
+			break;
+		case 'h':
+			usage(NULL);
+			break;
+		case ':':
+			usage("Option -%c requires an operand\n", optopt);
+			break;
+		case '?':
+			usage("Unrecognised option: -%c\n", optopt);
+			break;
+		}
+	}
+
+	if (biosbootpath == NULL || esppath == NULL || mbrpath == NULL ||
+	    outpath == NULL)
+		usage("missing argument\n");
+
+	if (optind != argc)
+		usage("too many arguments\n");
+
+	if ((outfile = open(outpath, O_RDWR)) == -1)
+		err(EXIT_FAILURE, "failed to open %s for writing", outpath);
+
+	mbr = read_file(mbrpath, SECTOR_SIZE, NULL);
+
+	if (((struct mboot *)mbr)->signature != MBB_MAGIC) {
+		errx(EXIT_FAILURE, "MBR has incorrect magic %hlx",
+		    ((struct mboot *)mbr)->signature);
+	}
+
+	esp = read_file(esppath, 0, &esplen);
+
+	if (esplen % PART_ALIGN) {
+		errx(EXIT_FAILURE, "ESP image is not %lu-byte aligned",
+		    PART_ALIGN);
+	}
+
+	if (esplen % LBSIZE) {
+		errx(EXIT_FAILURE, "ESP image is not %lu-byte aligned",
+		    LBSIZE);
+	}
+
+	biosboot = read_file(biosbootpath, LEGACY_BOOTPART_SIZE, &biosbootlen);
+
+	write_mbr(mbr, esplen, biosbootlen);
+	write_efi(esplen);
+	write_esp(esp, esplen);
+	write_biosboot(biosboot, biosbootlen);
+
+	return (EXIT_SUCCESS);
+}
diff --git a/tools/images/make_image b/tools/images/make_image
deleted file mode 100755
index 658fa484..00000000
--- a/tools/images/make_image
+++ /dev/null
@@ -1,263 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2016 Joyent, Inc.
-#
-
-#
-# This script has been written to be correct without either the "errexit" or
-# "pipefail" shell options.  The exit status of all operations is explicitly
-# checked, with appropriate handling of errors.
-#
-
-PFEXEC=/bin/pfexec
-GRUB_FILES=(
-	fat_stage1_5
-	iso9660_stage1_5
-	stage1
-	stage2
-	stage2_eltorito
-	ufs_stage1_5
-	zfs_stage1_5
-)
-
-g_size=
-g_fdisk_file=
-g_grub_dir=
-g_image_file=
-g_lofi_device=
-g_lofi_raw=
-g_mount_point=
-g_tmp_dir=
-
-function warn
-{
-	local msg="$0: WARNING: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-}
-
-function cleanup
-{
-	if [[ -n $g_mount_point ]]; then
-		if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-			warn 'could not unmount %s' "$g_mount_point"
-		fi
-	fi
-
-	if [[ -n $g_lofi_device ]]; then
-		if ! $PFEXEC /usr/sbin/lofiadm -d "$g_lofi_device"; then
-			warn 'could not remove lofi device %s' \
-			    "$g_lofi_device"
-		fi
-	fi
-
-	if [[ -n $g_tmp_dir ]]; then
-		rm -rf "$g_tmp_dir"
-	fi
-	if [[ -n $g_image_file ]]; then
-		rm -f "$g_image_file"
-	fi
-}
-
-function fatal
-{
-	local msg="$0: ERROR: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-
-	cleanup
-	exit 1
-}
-
-#
-# Option parsing:
-#
-while getopts 's:F:G:' a; do
-	case $a in
-	s)
-		case $OPTARG in
-		1gb|2gb|4gb|8gb)
-			g_size=${OPTARG%gb}
-			;;
-		*)
-			fatal 'unknown size (-s): %s' "$OPTARG"
-			;;
-		esac
-		;;
-	F)
-		if [[ ! -f $OPTARG ]]; then
-			fatal 'fdisk table file not found: %s' "$OPTARG"
-		fi
-		g_fdisk_file=$OPTARG
-		;;
-	G)
-		if [[ ! -d $OPTARG ]]; then
-			fatal 'grub directory not found: %s' "$OPTARG"
-		fi
-		g_grub_dir=$OPTARG
-		;;
-	*)
-		fatal 'usage error'
-		exit 1
-		;;
-	esac
-done
-
-shift $(( $OPTIND - 1 ))
-if (( $# != 1 )); then
-	fatal 'must specify an image file'
-	exit 1
-fi
-g_image_file=$1
-
-if [[ -z $g_image_file || -z $g_size || -z $g_fdisk_file ||
-    -z $g_grub_dir ]]; then
-	fatal 'usage error: must provide all of -s, -F, and -G'
-fi
-
-if [[ -f $g_image_file ]]; then
-	printf 'image file exists already\n' >&2
-	exit 1
-fi
-
-printf '== create proforma image ========================================\n\n'
-printf '  output file:     %s\n' "$g_image_file"
-printf '  image size:      %d GB\n' "$g_size"
-printf '  fdisk template:  %s\n' "$g_fdisk_file"
-printf '  grub directory:  %s\n' "$g_grub_dir"
-
-#
-# Create a sparse file of the appropriate size.  This size must match that
-# which was used to create the fdisk(1M) template, and must be the same size or
-# smaller than the target USB drive.
-#
-printf 'create sparse image file\n'
-if ! /usr/sbin/mkfile -n $(( g_size * 1000000000 )) "$g_image_file"; then
-	fatal 'could not mkfile'
-fi
-
-#
-# Attach the blank image file to the system as a lofi(7D) device.
-#
-printf 'attach image file as lofi(7D) device\n'
-if ! g_lofi_device=$($PFEXEC /usr/sbin/lofiadm -a "$g_image_file"); then
-	fatal 'could not attach image as lofi(7D) device'
-fi
-
-#
-# The lofi(7D) device path is for the emulated block device.  We also need the
-# path to the emulated character device.
-#
-g_lofi_raw=${g_lofi_device/#\/dev\/lofi\//\/dev\/rlofi\/}
-printf '  lofi device:     %s\n' "$g_lofi_device"
-printf '  lofi raw device: %s\n' "$g_lofi_raw"
-
-if [[ ! -b $g_lofi_device || ! -c $g_lofi_raw ]]; then
-	fatal 'could not locate lofi(7D) device paths'
-fi
-
-printf 'create partition table\n'
-if ! $PFEXEC /sbin/fdisk -F "$g_fdisk_file" "$g_lofi_raw"; then
-	fatal 'could not make partition table'
-fi
-
-#
-# Create a FAT32 file system on the first partition of the image.  The volume
-# label is set to "HEADNODE".
-#
-printf 'format FAT32 file system\n'
-if ! $PFEXEC /usr/sbin/mkfs -F pcfs -o 'b=HEADNODE,fat=32' "$g_lofi_raw:c" \
-    </dev/null; then
-	fatal 'could not format FAT32 file system'
-fi
-
-#
-# Create a temporary directory in which to mount the image to avoid conflicting
-# with any other processes.
-#
-if ! g_tmp_dir=$(mktemp -d); then
-	fatal 'could not create temporary directory'
-fi
-
-g_mount_point=$g_tmp_dir/mnt
-if ! mkdir "$g_mount_point"; then
-	fatal 'could not create mount point directory: %s' "$g_mount_point"
-fi
-
-#
-# Mount the FAT32 file system from the image with the appropriate mount options.
-#
-printf 'mount FAT32 file system\n'
-if ! $PFEXEC /sbin/mount -F pcfs -o 'foldcase,noatime,hidden,clamptime,rw' \
-    "$g_lofi_device:c" "$g_mount_point"; then
-	fatal 'could not mount file system'
-fi
-
-#
-# Create the grub directory within the image.
-#
-if ! mkdir -p "$g_mount_point/boot/grub"; then
-	fatal 'could not create grub directory within image'
-fi
-
-#
-# Copy each grub file from the build area to the image, and create an empty
-# grub menu file in the appropriate location.
-#
-printf 'copying files:\n'
-for grub_file in ${GRUB_FILES[@]}; do
-	p=boot/grub/$grub_file
-	printf '      copy: %s\n' "$p"
-	if ! /bin/cp "$g_grub_dir/$p" "$g_mount_point/$p"; then
-		fatal 'could not copy %s' "$p"
-	fi
-done
-touch "$g_mount_point/boot/grub/menu.lst"
-
-#
-# Unmount the image now, so that we can use the grub shell without upsetting
-# the kernel.  Unset the "g_mount_point" variable so that cleanup does not try
-# to unmount a second time.
-#
-printf 'unmounting image\n'
-if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-	fatal 'could not unmount image file system'
-fi
-unset g_mount_point
-
-#
-# Now that the file system is unmounted, use the grub command to install the
-# boot block within the MBR and embed the appropriate stage1_5.
-#
-printf 'installing grub\n'
-$PFEXEC "$g_grub_dir/boot/grub/bin/grub" --batch <<EOFGRUB
-device (hd0) $g_lofi_raw
-root (hd0,0)
-setup (hd0)
-quit
-EOFGRUB
-if [[ $? -ne 0 ]]; then
-	fatal 'failed to install grub'
-fi
-
-#
-# The image was successfully created.  Clean up all of our resources,
-# but make sure we do not delete the successfully created image file.
-#
-unset g_image_file
-cleanup
-printf '\n'
-exit 0
-- 
2.21.0

