From 0d7dd5fe9345549e5140a84549ca8d9bbc0e30ef Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Thu, 7 Dec 2017 23:17:55 +0000
Subject: [PATCH] MANTA-3232 Undeploy without disruption - electric-moray

---
 lib/fast_server.js |  27 ++++
 test/tst.server.js | 374 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 401 insertions(+)

diff --git a/lib/fast_server.js b/lib/fast_server.js
index 66e0485..19bd549 100644
--- a/lib/fast_server.js
+++ b/lib/fast_server.js
@@ -181,6 +181,7 @@ function FastServer(args)
 	this.fs_msghandler = new FastMessageHandler({
 	    'server': this
 	});
+	this.fs_notify_no_conns = false;
 	/*
 	 * See the comments below on use of setMaxListeners().
 	 */
@@ -224,6 +225,7 @@ function FastServer(args)
 	this.fs_dtid = fastNservers++;
 	this.fs_dtp = fastServerProvider;
 }
+mod_util.inherits(FastServer, mod_events.EventEmitter);
 
 /* public methods */
 
@@ -576,6 +578,31 @@ FastServer.prototype.connDrain = function (conn)
 		    conn.fc_server_error === null) {
 			conn.fc_socket.destroy();
 		}
+
+		if (this.fs_notify_no_conns &&
+		    mod_jsprim.isEmpty(this.fs_conns)) {
+			this.emit('noConnections');
+			this.fs_notify_no_conns = false;
+		}
+	}
+};
+
+
+/*
+ * Arranges for the 'noConnections' event to be emitted once by the FastServer
+ * the next time its last connection is destroyed. The event is emitted
+ * immediately form this function if the server already has no connections.
+ *
+ * Clients invoking this method must only call it once before receiving
+ * the 'noConnections' event.
+ */
+FastServer.prototype.notifyOnceOnEmptyConnectionSet = function notify() {
+    mod_assertplus.ok(!this.fs_notify_no_conns, '!this.fs_notify_no_conns');
+    this.fs_notify_no_conns = true;
+
+	if (mod_jsprim.isEmpty(this.fs_conns)) {
+		this.emit('noConnections');
+		this.fs_notify_no_conns = false;
 	}
 };
 
diff --git a/test/tst.server.js b/test/tst.server.js
index d80e6a6..f9a5f8d 100644
--- a/test/tst.server.js
+++ b/test/tst.server.js
@@ -15,6 +15,7 @@
 var mod_assertplus = require('assert-plus');
 var mod_artedi = require('artedi');
 var mod_bunyan = require('bunyan');
+var mod_jsprim = require('jsprim');
 var mod_net = require('net');
 var mod_path = require('path');
 var mod_vasync = require('vasync');
@@ -24,6 +25,7 @@ var mod_fastdemo = require('../lib/demo_server');
 var mod_protocol = require('../lib/fast_protocol');
 var mod_testcommon = require('./common');
 
+var EventEmitter = require('events');
 var VError = require('verror');
 
 var testLog;
@@ -357,6 +359,378 @@ function runConnFailureTest(tctx, injectFail, checkError, callback)
 }
 
 serverTestCases = [ {
+    'name': 'basic \'noConnections\' notify test',
+    'run': function (tctx, callback) {
+	/*
+	 * Check that 'noConnections' event is received once if we subscribe
+	 * to a notification before the client connections have been torn
+	 * down.
+	 */
+	var received = false;
+	var server = tctx.ts_server;
+
+	server.notifyOnceOnEmptyConnectionSet();
+
+	tctx.ts_clients.forEach(function (c) {
+	    c.tsc_client.detach();
+	    c.tsc_socket.destroy();
+	});
+
+	server.on('noConnections', function () {
+		if (received) {
+			callback(new VError('received \'noConnections\' ' +
+				'event more than once.'));
+			return;
+		}
+		if (!mod_jsprim.isEmpty(server.fs_conns)) {
+			callback(new VError('received \'noConnections\' ' +
+				'event when server still had active ' +
+				'connections'));
+			return;
+		}
+		received = true;
+	});
+
+	var WAIT_MS = 1000;
+	setTimeout(function () {
+	    var err;
+	    if (!received) {
+		err = new VError('did not receive \'noConnections\' event');
+	    }
+	    callback(err);
+	}, WAIT_MS);
+    }
+}, {
+    'name': '\'noConnections\' immediate response',
+    'run': function (tctx, callback) {
+	/*
+	 * Check that 'noConnections event is sent once if we've subscribed
+	 * to a notification after all client connections have been torn
+	 * down.
+	 */
+	var server = tctx.ts_server;
+	var received = false;
+
+	tctx.ts_clients.forEach(function (c) {
+		c.tsc_client.detach();
+		c.tsc_socket.destroy();
+	});
+
+	server.notifyOnceOnEmptyConnectionSet();
+
+	server.on('noConnections', function () {
+		if (received) {
+		    callback(new VError('received \'noConnections\' event' +
+			    'more than once.'));
+		    return;
+		}
+		if (!mod_jsprim.isEmpty(server.fs_conns)) {
+			callback(new VError('received \'noConnections\' ' +
+				'event when server still had active ' +
+				'connections'));
+			return;
+		}
+		received = true;
+	});
+
+	var WAIT_MS = 1000;
+	setTimeout(function () {
+		var err;
+		if (!received) {
+			err = new VError('did not receive \'noConnections\'' +
+			    ' event');
+		}
+		callback(err);
+	}, WAIT_MS);
+    }
+}, {
+    'name': '\'noConnections\' received after on successful rpc',
+    'run': function (tctx, callback) {
+	/*
+	 * Check that 'noConnections' event is sent once if we've subscribed
+	 * to the notification while server is working on an rpc that will
+	 * succeed. This verifies that the normal request termination path
+	 * followed by connection shutdown triggers the behavior we expect.
+	 */
+	var server = tctx.ts_server;
+	var server_socket = tctx.ts_socket;
+	var client;
+	var received = false;
+	var once = false;
+
+	/*
+	 * Fires when we connect the second client that is used to issue
+	 * the rpc.
+	 */
+	server_socket.on('connection', function () {
+	    if (once) {
+		return;
+	    }
+	    once = true;
+	    server.notifyOnceOnEmptyConnectionSet();
+	});
+
+	server.on('noConnections', function () {
+		received = true;
+	});
+
+	tctx.connectClient(function () {
+		client = tctx.ts_clients[1].tsc_client;
+
+		var req = client.rpc({
+			'rpcmethod': 'yes',
+			'rpcargs': [ {
+				value: 'yes',
+				count: 1
+			} ]
+		});
+		req.on('error', function (err) {
+			callback(new VError(err, 'received unexpected error ' +
+				'from dummy rpc'));
+		});
+
+		req.on('data', function () {});
+
+		req.on('end', function () {
+			var WAIT_MS = 1000;
+			tctx.ts_clients.forEach(function (c) {
+			    c.tsc_client.detach();
+			    c.tsc_socket.destroy();
+			});
+
+			setTimeout(function () {
+				if (!received) {
+					callback(new VError('did not ' +
+						'receive ' +
+						'\'noConnections\' callback'));
+					return;
+				}
+				callback();
+			}, WAIT_MS);
+		});
+	});
+    }
+}, {
+    'name': '\'noConnections\' received after protocol error',
+    'run': function (tctx, callback) {
+	/*
+	 * Check that if we subscribe for the 'noConnections' event during an
+	 * RPC that fails due to a protocol error, then we sitll receive the
+	 * event once when the client connections are torn down.
+	 */
+	var server = tctx.ts_server;
+	var server_socket = tctx.ts_socket;
+	var received = false;
+
+	var once = false;
+	server_socket.on('connection', function () {
+		if (once) {
+			return;
+		}
+		once = true;
+	    server.notifyOnceOnEmptyConnectionSet();
+	});
+
+	server.on('noConnections', function () {
+		if (received) {
+			callback(new VError('received \'noConnections\' ' +
+				'event more than once.'));
+			return;
+		}
+		if (!mod_jsprim.isEmpty(server.fs_conns)) {
+			callback(new VError('receved \'noConnections\' ' +
+				'event from a server with active ' +
+				'connections'));
+			return;
+		}
+		received = true;
+
+	});
+
+	tctx.connectClient(function () {
+		var client = tctx.ts_clients[1].tsc_client;
+		var req = client.rpc({
+		    'rpcmethod': '',
+		    'rpcargs': []
+		});
+		req.on('data', function () {
+			callback(new VError('received unexpected data from ' +
+				'nonexistent rpc'));
+		});
+
+		req.on('error', function (err) {
+			tctx.ts_clients.forEach(function (c) {
+				c.tsc_client.detach();
+				c.tsc_socket.destroy();
+			});
+
+			var WAIT_MS = 1000;
+			setTimeout(function () {
+				if (!received) {
+					callback(new VError('did not ' +
+						'receive ' +
+						'\'noConnections\' ' +
+						'event'));
+					return;
+				}
+				callback();
+			}, WAIT_MS);
+		});
+	});
+    }
+}, {
+    'name': 'advanced \'noConnections\' notify test',
+    'run': function (tctx, callback) {
+	/*
+	 *  Register a dummy rpc that alternates between returning
+	 *  errors and succeeding with no data. Connect an addition
+	 *  client and send 200 requests, 100 per client. After all
+	 *  request-sending work is queued up, register with the server
+	 *  to received a notification once all connections are closed.
+	 *  Check the that 'noConnections' event is sent once and only
+	 *  after the clients have been cleaned up. Also verifies that
+	 *  the 'noConnections' event is only received when there are in
+	 *  fact no connections.
+	 */
+	var which = 0;
+	var server = tctx.ts_server;
+	var server_socket = tctx.ts_socket;
+
+	var emit_ts = null;
+	var finish_ts = null;
+
+	server.registerRpcMethod({
+		'rpcmethod': 'alternate',
+		'rpchandler': function (rpc) {
+			var whichrpc = which++;
+			if (whichrpc % 2 === 0) {
+				rpc.end({'value': whichrpc});
+			} else {
+				rpc.fail(new VError('%d', whichrpc));
+			}
+		}
+    	});
+
+	var once = false;
+
+	/*
+	 * Subscribe to the empty connection set notification upon connecting
+	 * the second client.
+	 */
+	server_socket.on('connection', function () {
+		if (once) {
+		    	return;
+		}
+		once = true;
+		server.notifyOnceOnEmptyConnectionSet();
+	});
+
+	/*
+	 * We expect that this fires only after all the requests have been sent
+	 * and both clients have closed their conenctions to the server.
+	 */
+    	server.on('noConnections', function () {
+		if (emit_ts !== null) {
+			callback(new VError('received ' +
+				'\'noConnections\' event twice'));
+			return;
+		}
+		if (!mod_jsprim.isEmpty(
+		    tctx.ts_server.fs_conns)) {
+			callback(new VError('received ' +
+				'\'noConections\' event with active ' +
+				'server connections'));
+			return;
+		}
+		emit_ts = process.hrtime();
+	});
+
+
+	tctx.connectClient(function () {
+		var choice = 0;
+		var nrequests = 200;
+		var ncomplete = 0;
+		var e = new EventEmitter();
+
+		var queue = mod_vasync.queuev({
+			'concurrency': 100,
+			'worker': function makeRequest(_, qcallback) {
+				choice = 1 - choice;
+				var c = tctx.ts_clients[choice]
+							.tsc_client;
+				c.rpcBufferAndCallback({
+					'rpcmethod': 'alternate',
+					'rpcargs': [],
+					'maxObjectsToBuffer': 1
+				}, function () {
+					if (++ncomplete == nrequests) {
+						e.emit('complete');
+					}
+				});
+				qcallback();
+			}
+		});
+		for (var i = 0; i < nrequests; i++) {
+			queue.push(i);
+		}
+
+		/*
+		 * Detach and close the clients that sent the requests that just
+		 * finished sending requests. This should trigger the
+		 * noConnections event when the last client is closed.
+		 */
+		e.on('complete', function () {
+			var WAIT = 1000;
+			finish_ts = process.hrtime();
+			tctx.ts_clients.forEach(function (c) {
+				c.tsc_client.detach();
+				c.tsc_socket.destroy();
+			});
+			setTimeout(checkForNoConnectionsEvent, WAIT);
+		});
+
+		/*
+		 * Called after all the requests have been sent top verify that
+		 * the noConnections event was received after the stream of
+		 * requests completed.
+		 */
+		function checkForNoConnectionsEvent() {
+
+			function hrtimeToNanoseconds(hrtime) {
+				var NS_PER_SEC = 1e9;
+				return ((hrtime[0] * NS_PER_SEC) + hrtime[1]);
+			}
+
+			if (emit_ts === null) {
+				callback(new VError('did not ' +
+					'receive \'noConnections\' ' +
+					'event'));
+				return;
+			}
+
+			var emit = hrtimeToNanoseconds(emit_ts);
+			var finish = hrtimeToNanoseconds(finish_ts);
+
+			/*
+			 * Sanity check that the 'noConnections' event was
+			 * emitted after the client sockets were closed.
+			 */
+			if (finish > emit) {
+				callback(new VError('received' +
+					    'noConnections callback ' +
+					    'before all requests ' +
+					    'were sent.'));
+				return;
+			}
+
+			callback();
+		}
+
+		queue.close();
+	});
+    }
+}, {
+
     'name': 'basic RPC: no data',
     'run': function (tctx, callback) {
 	tctx.firstFastClient().rpcBufferAndCallback({
-- 
2.21.0

