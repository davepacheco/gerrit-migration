commit 562cae053aa4fdeeba26d418d8ca63421058329b (refs/changes/61/3061/9)
Author: Jan Wyszynski <jan.wyszynski@joyent.com>
Date:   2017-12-19T00:56:10+00:00 (1 year, 10 months ago)
    
    joyent/node-fast#14 want node-fast FastServer 'onConnsDestroyed' method

diff --git a/CHANGES.md b/CHANGES.md
index 024fd84..1c9bb82 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,9 @@
 
 ## Not yet released.
 
+## v2.4.0
+
+* #14 want node-fast FastServer 'onConnsDestroyed' method
 * #12 want support for node v6.12.0
 
 ## v2.3.1
diff --git a/README.md b/README.md
index b722575..5f331a3 100644
--- a/README.md
+++ b/README.md
@@ -371,6 +371,16 @@ handlers for outstanding requests continue as normal, and any data emitted is
 ignored.  As a result, though, these handlers may continue running even after
 this function has been called and client sockets are destroyed.
 
+#### onConnsDestroyed(callback): do work when all connections are destroyed
+
+This method pushes its `callback` argument on a queue of work to be done the
+next time the FastServer connection count goes to zero. If the connection count
+is already zero when `onConnsDestroyed` is called, the callback is invoked
+immediately.
+
+All callbacks pushed on the queue before the next time the connection count goes
+to zero are called in FIFO order the next time all connections are destroyed.
+Any callback pushed this way is called exactly once.
 
 ## Protocol overview
 
diff --git a/bin/fastcall b/bin/fastcall
index 122542e..34fd6ec 100755
--- a/bin/fastcall
+++ b/bin/fastcall
@@ -20,16 +20,29 @@ var mod_assertplus = require('assert-plus');
 var mod_bunyan = require('bunyan');
 var mod_cmdutil = require('cmdutil');
 var mod_fast = require('../lib/fast_client');
+var mod_getopt = require('posix-getopt');
 var mod_net = require('net');
 
+var OPTS = {
+	'a': 'abandon the RPC request after issuing it ' +
+		'via FastClientRequest#abandon',
+	'c': 'do not close the socket used to talk ' +
+		'to the FastServer until SIGINT'
+};
+
 function main()
 {
-	var argv, doabandon, host, port, rpcmethod, rpcargs;
+	var argv, host, port, rpcmethod, rpcargs;
+	var doabandon = false;
+	var leaveconnopen = false;
 	var timeout = null;
 
 	mod_cmdutil.configure({
-	    'synopses': [ '[--abandon-immediately] HOST PORT METHOD ARGS' ],
+	    'synopses': [ '[OPTIONS] HOST PORT METHOD ARGS' ],
 	    'usageMessage': [
+		'    OPTIONS',
+		'        -a,--abandon-immediately   ' + OPTS['a'],
+		'        -c,--leave-conn-open       ' + OPTS['c'],
 	        '    HOST     DNS name or IP address for remote server',
 		'    PORT     TCP port for remote server',
 		'    METHOD   Name of remote RPC method call',
@@ -38,14 +51,25 @@ function main()
 	});
 	mod_cmdutil.exitOnEpipe();
 
-	argv = process.argv.slice(2);
-	if (argv.length > 4 && argv[0] == '--abandon-immediately') {
-		doabandon = true;
-		argv.shift();
-	} else {
-		doabandon = false;
+	var option;
+	var parser = new mod_getopt.BasicParser('a(abandon-immediately)' +
+	    'c(leave-conn-open)', process.argv);
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+			case 'c':
+				leaveconnopen = true;
+				break;
+			case 'a':
+				doabandon = true;
+				break;
+			default:
+				mod_assertplus.equal('?', option.option);
+				mod_cmdutil.usage();
+				break;
+		}
 	}
 
+	argv = process.argv.slice(parser.optind());
 	if (argv.length != 4) {
 		mod_cmdutil.usage('expected four non-option arguments');
 	}
@@ -73,7 +97,8 @@ function main()
 	    'rpcmethod': rpcmethod,
 	    'rpcargs': rpcargs,
 	    'timeout': timeout,
-	    'abandonImmediately': doabandon
+	    'abandonImmediately': doabandon,
+	    'leaveConnOpen': leaveconnopen
 	}, function (err, result) {
 		if (err) {
 			mod_cmdutil.warn(err);
@@ -84,7 +109,7 @@ function main()
 function fastcall(args, callback)
 {
 	var log, conn;
-	var rpcmethod, rpcargs, timeout, doabandon;
+	var rpcmethod, rpcargs, timeout, doabandon, leaveconnopen;
 
 	mod_assertplus.object(args, 'args');
 	mod_assertplus.string(args.host, 'args.host');
@@ -93,11 +118,13 @@ function fastcall(args, callback)
 	mod_assertplus.string(args.rpcmethod, 'args.rpcmethod');
 	mod_assertplus.array(args.rpcargs, 'args.rpcargs');
 	mod_assertplus.bool(args.abandonImmediately, 'args.abandonImmediately');
+	mod_assertplus.bool(args.leaveConnOpen, 'args.leaveConnOpen');
 
 	rpcmethod = args.rpcmethod;
 	rpcargs = args.rpcargs;
 	timeout = args.timeout;
 	doabandon = args.abandonImmediately;
+	leaveconnopen = args.leaveConnOpen;
 
 	log = new mod_bunyan({
 	    'name': 'fastcall',
@@ -108,6 +135,19 @@ function fastcall(args, callback)
 	conn = mod_net.createConnection(args.port, args.host);
 
 	conn.on('connect', function onConnect() {
+		/*
+		 * If the '--leave-conn-open' option was specified, then we
+		 * leave the connection open until the user sends a SIGINT to
+		 * the process. The purpose of this option is to demonstrate the
+		 * function of FastServer#onConnsDestroyed. See documentation
+		 * on the '--quiesce' option to fastserve for more information.
+		 */
+		if (leaveconnopen) {
+			process.on('SIGINT', function () {
+				conn.destroy();
+			});
+		}
+
 		var fastconn, req;
 
 		fastconn = new mod_fast.FastClient({
@@ -117,7 +157,9 @@ function fastcall(args, callback)
 		});
 
 		fastconn.on('error', function (err) {
-			conn.destroy();
+			if (!leaveconnopen) {
+				conn.destroy();
+			}
 			callback(new VError(err, 'fast connection'));
 		});
 
@@ -132,7 +174,9 @@ function fastcall(args, callback)
 		}
 
 		req.on('error', function (err) {
-			conn.destroy();
+			if (!leaveconnopen) {
+				conn.destroy();
+			}
 			callback(new VError(err, 'fast request'));
 		});
 
@@ -141,7 +185,9 @@ function fastcall(args, callback)
 		});
 
 		req.on('end', function () {
-			conn.destroy();
+			if (!leaveconnopen) {
+				conn.destroy();
+			}
 			callback();
 		});
 	});
diff --git a/bin/fastserve b/bin/fastserve
index b61e91b..9195058 100755
--- a/bin/fastserve
+++ b/bin/fastserve
@@ -18,6 +18,7 @@ var mod_assertplus = require('assert-plus');
 var mod_artedi = require('artedi');
 var mod_bunyan = require('bunyan');
 var mod_cmdutil = require('cmdutil');
+var mod_getopt = require('posix-getopt');
 var mod_fastdemo = require('../lib/demo_server');
 var mod_fastserver = require('../lib/fast_server');
 var mod_kang = require('kang');
@@ -34,15 +35,32 @@ var usageMessage = [
 
 function main()
 {
-	var argv, port;
+	var argv, port, option;
+
+	var config = {
+		'quiesce': false
+	};
 
 	mod_cmdutil.configure({
-	    'synopses': [ 'PORT' ],
+	    'synopses': [ '[OPTIONS] PORT' ],
 	    'usageMessage': usageMessage
 	});
 	mod_cmdutil.exitOnEpipe();
 
-	argv = process.argv.slice(2);
+	var parser = new mod_getopt.BasicParser('q(quiesce)', process.argv);
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+			case 'q':
+				config.quiesce = true;
+				break;
+			default:
+				mod_assertplus.equal('?', option.option);
+				mod_cmdutil.usage();
+				break;
+		}
+	}
+
+	argv = process.argv.slice(parser.optind());
 	if (argv.length != 1) {
 		mod_cmdutil.usage('expected PORT');
 	}
@@ -53,8 +71,9 @@ function main()
 	}
 
 	fastDemoServer({
-	    'fastPort': port,
-	    'monitorPort': MONITOR_PORT
+		'fastPort': port,
+		'monitorPort': MONITOR_PORT,
+		'config': config
 	});
 }
 
@@ -66,6 +85,9 @@ function fastDemoServer(args)
 	mod_assertplus.object(args, 'args');
 	mod_assertplus.number(args.fastPort, 'args.fastPort');
 	mod_assertplus.number(args.monitorPort, 'args.monitorPort');
+	mod_assertplus.object(args.config, 'args.config');
+
+	var config = args.config;
 
 	collector = mod_artedi.createCollector({
 	    'labels': {
@@ -138,9 +160,19 @@ function fastDemoServer(args)
 
 		process.on('SIGINT', function () {
 			if (++nsigs == 1) {
-				monitor_server.close();
 				sock.close();
-				fastserver.close();
+
+				function shutdown() {
+					monitor_server.close();
+					fastserver.close();
+				}
+
+				if (config.quiesce) {
+					log.info('quiescing server');
+					fastserver.onConnsDestroyed(shutdown);
+				} else {
+					shutdown();
+				}
 			}
 		});
 	});
diff --git a/lib/fast_server.js b/lib/fast_server.js
index 66e0485..fbdc0d1 100644
--- a/lib/fast_server.js
+++ b/lib/fast_server.js
@@ -181,6 +181,7 @@ function FastServer(args)
 	this.fs_msghandler = new FastMessageHandler({
 	    'server': this
 	});
+	this.fs_conns_destroyed_callbacks = [];
 	/*
 	 * See the comments below on use of setMaxListeners().
 	 */
@@ -576,6 +577,30 @@ FastServer.prototype.connDrain = function (conn)
 		    conn.fc_server_error === null) {
 			conn.fc_socket.destroy();
 		}
+
+		if (mod_jsprim.isEmpty(this.fs_conns)) {
+			while (this.fs_conns_destroyed_callbacks.length > 0) {
+				setImmediate(this.fs_conns_destroyed_callbacks
+				    .shift());
+			}
+		}
+	}
+};
+
+
+/*
+ * Calls 'callback' when all the connections in 'fs_conns' have been destroyed.
+ * The callback is called immediately if the server already has no connections.
+ * Callbacks are queued and called in FIFO order the next time all client
+ * connections have been torn down.
+ */
+FastServer.prototype.onConnsDestroyed = function (callback)
+{
+	mod_assertplus.func(callback, 'callback');
+	if (mod_jsprim.isEmpty(this.fs_conns)) {
+		setImmediate(callback);
+	} else {
+		this.fs_conns_destroyed_callbacks.push(callback);
 	}
 };
 
diff --git a/package.json b/package.json
index 6065578..275a7ea 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
 	"name": "fast",
 	"description": "streaming JSON RPC over TCP",
-	"version": "2.3.1",
+	"version": "2.4.0",
 	"main": "./lib/fast.js",
 	"repository": {
 		"type": "git",
diff --git a/test/tst.server.js b/test/tst.server.js
index d80e6a6..c2300fd 100644
--- a/test/tst.server.js
+++ b/test/tst.server.js
@@ -15,6 +15,7 @@
 var mod_assertplus = require('assert-plus');
 var mod_artedi = require('artedi');
 var mod_bunyan = require('bunyan');
+var mod_jsprim = require('jsprim');
 var mod_net = require('net');
 var mod_path = require('path');
 var mod_vasync = require('vasync');
@@ -24,6 +25,7 @@ var mod_fastdemo = require('../lib/demo_server');
 var mod_protocol = require('../lib/fast_protocol');
 var mod_testcommon = require('./common');
 
+var EventEmitter = require('events');
 var VError = require('verror');
 
 var testLog;
@@ -356,6 +358,73 @@ function runConnFailureTest(tctx, injectFail, checkError, callback)
 	] }, callback);
 }
 
+/*
+ * Run a test that performs some client work and then checks for the receipt of
+ * an onConnsDestroyed callback after terminating the client connections.
+ *
+ * This test check verifies:
+ *	- The callback has been received within a reasonable timeout window
+ *	- The callback is received with the proper context: no active server
+ *	  connections.
+ *
+ * It does not verify that the callback is only received once. This is done in
+ * separate tests.
+ */
+function runOnConnsDestroyedCallbackTest(tctx, doClientWork, callback) {
+	mod_assertplus.ok(tctx, 'tctx');
+	mod_assertplus.func(doClientWork, 'doClientWork');
+	mod_assertplus.func(callback, 'callback');
+
+	var server = tctx.ts_server;
+	var server_socket = tctx.ts_socket;
+	var client;
+	var timedout = false;
+
+	/*
+	 * Timeout on the entire test. Any success path with invoke
+	 * clearTimeout on the handle returned by this call to
+	 * setTimeout.
+	 */
+	var WAIT_MS = 1000;
+	var timeout = setTimeout(function () {
+		timedout = true;
+		callback(new VError('did not receive' +
+		    '\'onConnsDestroyed\' callback'));
+	}, WAIT_MS);
+
+	server_socket.once('connection', function () {
+		server.onConnsDestroyed(function () {
+			if (timedout) {
+				return;
+			}
+			clearTimeout(timeout);
+
+			mod_assertplus.ok(server.fs_conns, 'server.fs_conns');
+			if (!mod_jsprim.isEmpty(server.fs_conns)) {
+				callback(new VError('received ' +
+				    '\'onConnsDestroyed\' callback when ' +
+				    'server still had active connections.'));
+				return;
+			}
+			callback();
+		});
+	});
+
+	tctx.connectClient(function () {
+		client = tctx.ts_clients[1].tsc_client;
+		doClientWork(client, function (err) {
+			tctx.ts_clients.forEach(function (c) {
+				c.tsc_client.detach();
+				c.tsc_socket.destroy();
+			});
+			if (!timedout && err) {
+				callback(err);
+			}
+		});
+	});
+}
+
+
 serverTestCases = [ {
     'name': 'basic RPC: no data',
     'run': function (tctx, callback) {
@@ -860,6 +929,265 @@ serverTestCases = [ {
 	csock.pause();
     }
 
+}, {
+    'name': '\'onConnsDestroyed\' callback test',
+    'run': function (tctx, callback) {
+	var received = false;
+	var server = tctx.ts_server;
+
+	var WAIT_MS = 1000;
+	var timeout = setTimeout(function () {
+		mod_assertplus.ok(false, 'did not receive ' +
+		    '\'onConnsDestroyed\' within timeout window');
+	}, WAIT_MS);
+
+	function verifyCallbackContext(cb) {
+		mod_assertplus.ok(!received, 'received \'onConnsDestroyed\' ' +
+		    'callback twice');
+		mod_assertplus.ok(server.fs_conns, 'server.fs_conns');
+		mod_assertplus.ok(mod_jsprim.isEmpty(server.fs_conns),
+		    'received \'onConnsDestroyed\' callback when server had ' +
+		    'active server connections');
+
+		received = true;
+		cb();
+	}
+
+	mod_vasync.waterfall([
+		function (qcb) {
+			/*
+			 * Check that connection count dropping to 0
+			 * triggers the callback
+			 */
+			server.onConnsDestroyed(function () {
+				setImmediate(verifyCallbackContext.bind(null,
+				    qcb));
+			});
+		},
+		function (qcb) {
+			received = false;
+			/*
+			 * Check that the callback is issued when the
+			 * connection count was already 0 prior to
+			 * calling onConnsDestroyed.
+			 */
+			server.onConnsDestroyed(function () {
+				setImmediate(verifyCallbackContext.bind(null,
+				    qcb));
+			});
+		}
+	], function (err) {
+		clearTimeout(timeout);
+		callback();
+	});
+
+	tctx.ts_clients.forEach(function (c) {
+		c.tsc_client.detach();
+		c.tsc_socket.destroy();
+	});
+    }
+}, {
+    'name': '\'onConnsDestroyed\' callback after successful rpc',
+    'run': function (tctx, callback) {
+	function doRpc(client, cb) {
+		client.rpcBufferAndCallback({
+			'rpcmethod': 'yes',
+			'rpcargs': [ {
+				value: 'yes',
+				count: 1
+			} ],
+			'maxObjectsToBuffer': 1
+		}, function (err, data, ndata) {
+			mod_assertplus.ok(!err, 'received unexpected error ' +
+				'from dummy rpc');
+			mod_assertplus.ok(ndata == 1, 'received more data ' +
+				'than expected');
+			cb();
+		});
+	}
+	runOnConnsDestroyedCallbackTest(tctx, doRpc, callback);
+    }
+}, {
+    'name': '\'onConnsDestroyed\' callback after protocol error',
+    'run': function (tctx, callback) {
+	function doBadRpc(client, cb) {
+		client.rpcBufferAndCallback({
+			'rpcmethod': '',
+			'rpcargs': [],
+			'maxObjectsToBuffer': 0
+		}, function (err, data, ndata) {
+			mod_assertplus.ok(err, 'did not receive error on ' +
+				'non-existent RPC');
+			mod_assertplus.ok(data.length === 0, 'received ' +
+				'unexpected data from non-existent RPC');
+			cb();
+		});
+	}
+	runOnConnsDestroyedCallbackTest(tctx, doBadRpc, callback);
+    }
+}, {
+    'name': '\'onConnsDestroyed\' multiple callbacks queued',
+    'run': function (tctx, callback) {
+	var server = tctx.ts_server;
+
+	var callback_one_ts = null;
+	var callback_two_ts = null;
+
+	var WAIT_MS = 1000;
+	var timeout = setTimeout(function () {
+		mod_assertplus.ok(false, 'did not complete callbacks in time');
+	}, WAIT_MS);
+
+	function verifyCallbackContext(hrtime) {
+		mod_assertplus.ok(hrtime === null, 'received ' +
+		    '\'onConnsDestroyed\' callback more than once');
+
+		mod_assertplus.ok(server.fs_conns, 'server.fs_conns');
+		mod_assertplus.ok(mod_jsprim.isEmpty(server.fs_conns),
+		    'received \'onConnsDestroyed\' callback from a server ' +
+		    'with active connections');
+	}
+
+	server.onConnsDestroyed(function () {
+		setImmediate(verifyCallbackContext.bind(null, callback_one_ts));
+		callback_one_ts = process.hrtime();
+	});
+
+	server.onConnsDestroyed(function () {
+		setImmediate(verifyCallbackContext.bind(null, callback_two_ts));
+		callback_two_ts = process.hrtime();
+
+		mod_assertplus.ok(callback_one_ts !== null, 'received ' +
+			'second callback without receiving the first');
+
+		var one_ts = mod_jsprim.hrtimeNanosec(callback_one_ts);
+		var two_ts = mod_jsprim.hrtimeNanosec(callback_two_ts);
+		mod_assertplus.ok(one_ts <= two_ts, 'callbacks received in ' +
+		    'wrong order');
+
+		clearTimeout(timeout);
+		callback();
+	});
+
+	tctx.ts_clients.forEach(function (c) {
+		c.tsc_client.detach();
+		c.tsc_socket.destroy();
+	});
+
+    }
+}, {
+    'name': '\'onConnsDestroyed\' callback after many requests',
+    'run': function (tctx, callback) {
+	var which = 0;
+	var server = tctx.ts_server;
+	var server_socket = tctx.ts_socket;
+
+	var callback_ts = null;
+	var finish_ts = null;
+
+	server.registerRpcMethod({
+		'rpcmethod': 'alternate',
+		'rpchandler': function (rpc) {
+			var whichrpc = which++;
+			if (whichrpc % 2 === 0) {
+				rpc.end({'value': whichrpc});
+			} else {
+				rpc.fail(new VError('%d', whichrpc));
+			}
+		}
+	});
+
+	/*
+	 * Subscribe to the empty connection set notification upon
+	 * connecting the second client.
+	 */
+	server_socket.once('connection', function () {
+		/*
+		 * We expect that the callback is called after both
+		 * clients have closed their connections to the server.
+		 */
+		server.onConnsDestroyed(function () {
+			mod_assertplus.ok(callback_ts === null, 'received ' +
+				'\'onConnsDestroyed\' callback twice');
+			mod_assertplus.ok(tctx.ts_server.fs_conns,
+			    'tctx.ts_server.fs_conns');
+			mod_assertplus.ok(mod_jsprim.isEmpty(server.fs_conns),
+				'received \'onConnsDestroyed\' callback with ' +
+				'active server connections');
+			callback_ts = process.hrtime();
+		});
+	});
+
+	tctx.connectClient(function () {
+		var choice = 0;
+		var nrequests = 200;
+		var ncomplete = 0;
+		var e = new EventEmitter();
+
+		var queue = mod_vasync.queuev({
+			'concurrency': 100,
+			'worker': function makeRequest(_, qcallback) {
+				choice = 1 - choice;
+				var c = tctx.ts_clients[choice]
+							.tsc_client;
+				c.rpcBufferAndCallback({
+					'rpcmethod': 'alternate',
+					'rpcargs': [],
+					'maxObjectsToBuffer': 1
+				}, function () {
+					if (++ncomplete == nrequests) {
+						e.emit('complete');
+					}
+				});
+				qcallback();
+			}
+		});
+		for (var i = 0; i < nrequests; i++) {
+			queue.push(i);
+		}
+
+		/*
+		 * Detach and close the clients that sent the requests
+		 * that just finished sending requests. This should
+		 * trigger the 'onConnsDestroyed' callback.
+		 */
+		e.on('complete', function () {
+			var WAIT = 1000;
+			finish_ts = process.hrtime();
+			tctx.ts_clients.forEach(function (c) {
+				c.tsc_client.detach();
+				c.tsc_socket.destroy();
+			});
+			setTimeout(checkForOnConnsDestroyedCallback, WAIT);
+		});
+
+		/*
+		 * Called after all the requests have been sent to
+		 * verify that the onConnsDestroyed callback was received
+		 * after the stream of requests completed.
+		 */
+		function checkForOnConnsDestroyedCallback() {
+			mod_assertplus.ok(callback_ts !== null, 'did not ' +
+			    'receive \'onConnsDestroyed\' callback');
+
+			var destroyed = mod_jsprim.hrtimeNanosec(
+			    callback_ts);
+			var finish = mod_jsprim.hrtimeNanosec(finish_ts);
+
+			/*
+			 * Sanity check that the 'onConnsDestroyed' callback
+			 * was emitted after the client sockets were
+			 * closed.
+			 */
+			mod_assertplus.ok(destroyed >= finish, 'received ' +
+			    '\'onConnsDestroyed\' callback before all ' +
+			    'requests were sent');
+
+			callback();
+		}
+		queue.close();
+	});
+    }
 } ];
 
 main();
