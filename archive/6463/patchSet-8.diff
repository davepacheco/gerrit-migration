commit 5e9814cc7ed118980849692248777b6dc4eff5c0
Author: Michael Zeller <mike@mikezeller.net>
Date:   2019-06-28T18:05:11+00:00 (3 months ago)
    
    TRITON-1318 need cfwlogd

diff --git a/.cargo/config b/.cargo/config
new file mode 100644
index 0000000..4ab32f9
--- /dev/null
+++ b/.cargo/config
@@ -0,0 +1 @@
+RUSTFLAGS = "-C force-frame-pointers"
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..5f07233
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,27 @@
+# Generated by Cargo
+# will have compiled files and executables
+/build/
+target
+
+# These are backup files generated by rustfmt
+**/*.rs.bk
+**/node_modules
+
+# The usual Joyent agent stuff
+/make_stamps
+/tmp
+/cache/
+bits
+bin
+/make_stamps
+docs/*.json
+docs/*.html
+cscope.in.out
+cscope.po.out
+cscope.out
+man
+smf/manifests/bapi.xml
+*.vim
+*.swp
+
+
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..6cbac63
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "deps/eng"]
+	path = deps/eng
+	url = https://github.com/joyent/eng.git
diff --git a/Cargo.lock b/Cargo.lock
new file mode 100644
index 0000000..b963b16
--- /dev/null
+++ b/Cargo.lock
@@ -0,0 +1,1299 @@
+[[package]]
+name = "aho-corasick"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "arc-swap"
+version = "0.3.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "arrayvec"
+version = "0.4.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "atty"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "termion 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "autocfg"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "bitflags"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "boxfnonce"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "byteorder"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "bytes"
+version = "0.4.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "cfg-if"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cfwlogd"
+version = "0.1.0"
+dependencies = [
+ "chrono 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "daemonize 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "illumos-priv 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nom 5.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "pretty_env_logger 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_json 1.0.39 (registry+https://github.com/rust-lang/crates.io-index)",
+ "signal-hook 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "testutils 0.1.0",
+ "uuid 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "vminfod-client 0.1.0",
+]
+
+[[package]]
+name = "chrono"
+version = "0.4.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "cloudabi"
+version = "0.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-deque 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-epoch 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-queue 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-channel"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-deque"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-epoch 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-queue"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "daemonize"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "boxfnonce 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "either"
+version = "1.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "env_logger"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "regex 1.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "termcolor 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "fnv"
+version = "1.0.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "fuchsia-cprng"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "fuchsia-zircon"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "fuchsia-zircon-sys"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "futures"
+version = "0.1.27"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "futures-cpupool"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "h2"
+version = "0.1.24"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "string 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "http"
+version = "0.1.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "http-body"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-buf 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "httparse"
+version = "1.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "humantime"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "hyper"
+version = "0.12.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures-cpupool 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "h2 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http-body 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "httparse 1.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-buf 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-tcp 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-threadpool 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-timer 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "want 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "illumos-priv"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "indexmap"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "iovec"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "itoa"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "kernel32-sys"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "lexical-core"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ryu 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "stackvector 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "static_assertions 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.58"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "lock_api"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "log"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "memchr"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "memoffset"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "mio"
+version = "0.6.19"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "mio-uds"
+version = "0.6.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "miow"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "net2"
+version = "0.2.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "nodrop"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "nom"
+version = "5.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "lexical-core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num_cpus"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "numtoa"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "owning_ref"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "parking_lot"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "parking_lot_core"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "pretty_env_logger"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "chrono 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "env_logger 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "0.4.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "quick-error"
+version = "1.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "quote"
+version = "0.6.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_jitter 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_os 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_pcg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "rand_hc"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_isaac"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_jitter"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_os"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_pcg"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rdrand"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.1.54"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "redox_termios"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "regex"
+version = "1.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "regex-syntax 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "utf8-ranges 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rustc_version"
+version = "0.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ryu"
+version = "0.2.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "scopeguard"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "semver"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "semver-parser"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "serde"
+version = "1.0.93"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "serde_derive 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.93"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 0.15.38 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.39"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ryu 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "signal-hook"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "signal-hook-registry 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "signal-hook-registry"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "arc-swap 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "slab"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "smallvec"
+version = "0.6.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "stable_deref_trait"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "stackvector"
+version = "1.0.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "static_assertions"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "string"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "syn"
+version = "0.15.38"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "wincolor 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "termion"
+version = "1.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "numtoa 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "testutils"
+version = "0.1.0"
+dependencies = [
+ "chrono 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "uuid 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "vminfod-client 0.1.0",
+]
+
+[[package]]
+name = "thread_local"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "time"
+version = "0.1.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio"
+version = "0.1.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-current-thread 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-fs 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-sync 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-tcp 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-threadpool 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-timer 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-trace-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-udp 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-uds 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-buf"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-codec"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-current-thread"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-executor"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-fs"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-threadpool 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-io"
+version = "0.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-reactor"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-sync 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-sync"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-tcp"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-threadpool"
+version = "0.1.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-deque 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-queue 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-timer"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-trace-core"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-udp"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-uds"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio-uds 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "try-lock"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "ucd-util"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "unicode-xid"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "unreachable"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "utf8-ranges"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "uuid"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "version_check"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "vminfod-client"
+version = "0.1.0"
+dependencies = [
+ "crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "hyper 0.12.31 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_json 1.0.39 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "void"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "want"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "try-lock 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi"
+version = "0.2.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi-build"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi-util"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "wincolor"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ws2_32-sys"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[metadata]
+"checksum aho-corasick 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)" = "e6f484ae0c99fec2e858eb6134949117399f222608d84cadb3f58c1f97c2364c"
+"checksum arc-swap 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)" = "bc4662175ead9cd84451d5c35070517777949a2ed84551764129cedb88384841"
+"checksum arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)" = "92c7fb76bc8826a8b33b4ee5bb07a247a81e76764ab4d55e8f73e3a4d8808c71"
+"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652"
+"checksum autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "0e49efa51329a5fd37e7c79db4621af617cd4e3e5bc224939808d076077077bf"
+"checksum bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "3d155346769a6855b86399e9bc3814ab343cd3d62c7e985113d46a0ec3c281fd"
+"checksum boxfnonce 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5988cb1d626264ac94100be357308f29ff7cbdd3b36bda27f450a4ee3f713426"
+"checksum byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5"
+"checksum bytes 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)" = "206fdffcfa2df7cbe15601ef46c813fce0965eb3286db6b56c583b814b51c81c"
+"checksum cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "b486ce3ccf7ffd79fdeb678eac06a9e6c09fc88d33836340becb8fffe87c5e33"
+"checksum chrono 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)" = "77d81f58b7301084de3b958691458a53c3f7e0b1d702f77e550b6a88e3a88abe"
+"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
+"checksum crossbeam 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "b14492071ca110999a20bf90e3833406d5d66bfd93b4e52ec9539025ff43fe0d"
+"checksum crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)" = "0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b"
+"checksum crossbeam-deque 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "b18cd2e169ad86297e6bc0ad9aa679aee9daa4f19e8163860faf7c164e4f5a71"
+"checksum crossbeam-epoch 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "04c9e3102cc2d69cd681412141b390abd55a362afc1540965dad0ad4d34280b4"
+"checksum crossbeam-queue 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7c979cd6cfe72335896575c6b5688da489e420d36a27a0b9eb0c73db574b4a4b"
+"checksum crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)" = "f8306fcef4a7b563b76b7dd949ca48f52bc1141aa067d2ea09565f3e2652aa5c"
+"checksum daemonize 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)" = "70c24513e34f53b640819f0ac9f705b673fcf4006d7aab8778bee72ebfc89815"
+"checksum either 1.5.2 (registry+https://github.com/rust-lang/crates.io-index)" = "5527cfe0d098f36e3f8839852688e63c8fff1c90b2b405aef730615f9a7bcf7b"
+"checksum env_logger 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)" = "b61fa891024a945da30a9581546e8cfaf5602c7b3f4c137a2805cf388f92075a"
+"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)" = "2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3"
+"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
+"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
+"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"
+"checksum futures 0.1.27 (registry+https://github.com/rust-lang/crates.io-index)" = "a2037ec1c6c1c4f79557762eab1f7eae1f64f6cb418ace90fae88f0942b60139"
+"checksum futures-cpupool 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "ab90cde24b3319636588d0c35fe03b1333857621051837ed769faefb4c2162e4"
+"checksum h2 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)" = "69b2a5a3092cbebbc951fe55408402e696ee2ed09019137d1800fc2c411265d2"
+"checksum http 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)" = "eed324f0f0daf6ec10c474f150505af2c143f251722bf9dbd1261bd1f2ee2c1a"
+"checksum http-body 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "6741c859c1b2463a423a1dbce98d418e6c3c3fc720fb0d45528657320920292d"
+"checksum httparse 1.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "e8734b0cfd3bc3e101ec59100e101c2eecd19282202e87808b3037b442777a83"
+"checksum humantime 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "3ca7e5f2e110db35f93b837c81797f3714500b81d517bf20c431b16d3ca4f114"
+"checksum hyper 0.12.31 (registry+https://github.com/rust-lang/crates.io-index)" = "6481fff8269772d4463253ca83c788104a7305cb3fb9136bc651a6211e46e03f"
+"checksum illumos-priv 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "653d3bde60e96063ce6965340946086cdd3a8e0ebda9b7e2f2cf794f1766370d"
+"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d"
+"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08"
+"checksum itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)" = "501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f"
+"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d"
+"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14"
+"checksum lexical-core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "3f8673fab7063c2cac37d299c8a1a7beb720e78f71500098e4a3c137fdf025bf"
+"checksum libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)" = "6281b86796ba5e4366000be6e9e18bf35580adf9e63fbe2294aadb587613a319"
+"checksum lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "62ebf1391f6acad60e5c8b43706dde4582df75c06698ab44511d15016bc2442c"
+"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)" = "c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6"
+"checksum memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39"
+"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3"
+"checksum mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)" = "83f51996a3ed004ef184e16818edc51fadffe8e7ca68be67f9dee67d84d0ff23"
+"checksum mio-uds 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)" = "966257a94e196b11bb43aca423754d87429960a768de9414f3691d6957abf125"
+"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919"
+"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)" = "42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88"
+"checksum nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)" = "2f9667ddcc6cc8a43afc9b7917599d7216aa09c463919ea32c59ed6cac8bc945"
+"checksum nom 5.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e9761d859320e381010a4f7f8ed425f2c924de33ad121ace447367c713ad561b"
+"checksum num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)" = "b85e541ef8255f6cf42bbfe4ef361305c6c135d10919ecc26126c4e5ae94bc09"
+"checksum num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "6ba9a427cfca2be13aa6f6403b0b7e7368fe982bfa16fccc450ce74c46cd9b32"
+"checksum num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)" = "bcef43580c035376c0705c42792c294b66974abbfd2789b511784023f71f3273"
+"checksum numtoa 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b8f8bdf33df195859076e54ab11ee78a1b208382d3a26ec40d142ffc1ecc49ef"
+"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13"
+"checksum parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337"
+"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9"
+"checksum pretty_env_logger 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61"
+"checksum proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)" = "cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759"
+"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0"
+"checksum quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)" = "faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db"
+"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)" = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
+"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef"
+"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
+"checksum rand_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d0e7a549d590831370895ab7ba4ea0c1b6b011d106b5ff2da6eee112615e6dc0"
+"checksum rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
+"checksum rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
+"checksum rand_jitter 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "1166d5c91dc97b88d1decc3285bb0a99ed84b05cfd0bc2341bdf2d43fc41e39b"
+"checksum rand_os 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
+"checksum rand_pcg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
+"checksum rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
+"checksum rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
+"checksum redox_syscall 0.1.54 (registry+https://github.com/rust-lang/crates.io-index)" = "12229c14a0f65c4f1cb046a3b52047cdd9da1f4b30f8a39c5063c8bae515e252"
+"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76"
+"checksum regex 1.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "0b2f0808e7d7e4fb1cb07feb6ff2f4bc827938f24f8c2e6a3beb7370af544bdd"
+"checksum regex-syntax 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)" = "9d76410686f9e3a17f06128962e0ecc5755870bb890c34820c7af7f1db2e1d48"
+"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)" = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
+"checksum ryu 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "b96a9549dc8d48f2c283938303c4b5a77aa29bfbc5b54b084fb1630408899a8f"
+"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27"
+"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)" = "1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"
+"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3"
+"checksum serde 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)" = "960e29cf7004b3b6e65fc5002981400eb3ccc017a08a2406940823e58e7179a9"
+"checksum serde_derive 1.0.93 (registry+https://github.com/rust-lang/crates.io-index)" = "c4cce6663696bd38272e90bf34a0267e1226156c33f52d3f3915a2dd5d802085"
+"checksum serde_json 1.0.39 (registry+https://github.com/rust-lang/crates.io-index)" = "5a23aa71d4a4d43fdbfaac00eff68ba8a06a51759a89ac3304323e800c4dd40d"
+"checksum signal-hook 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "72ab58f1fda436857e6337dcb6a5aaa34f16c5ddc87b3a8b6ef7a212f90b9c5a"
+"checksum signal-hook-registry 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cded4ffa32146722ec54ab1f16320568465aa922aa9ab4708129599740da85d7"
+"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8"
+"checksum smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)" = "ab606a9c5e214920bb66c458cd7be8ef094f813f20fe77a54cc7dbfff220d4b7"
+"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8"
+"checksum stackvector 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)" = "1c4725650978235083241fab0fdc8e694c3de37821524e7534a1a9061d1068af"
+"checksum static_assertions 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)" = "c19be23126415861cb3a23e501d34a708f7f9b2183c5252d690941c2e69199d5"
+"checksum string 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d0bbfb8937e38e34c3444ff00afb28b0811d9554f15c5ad64d12b0308d1d1995"
+"checksum syn 0.15.38 (registry+https://github.com/rust-lang/crates.io-index)" = "37ea458a750f59ab679b47fef9b6722c586c5742f4cfe18a120bbc807e5e01fd"
+"checksum termcolor 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)" = "96d6098003bde162e4277c70665bd87c326f5a0c3f3fbfb285787fa482d54e6e"
+"checksum termion 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)" = "6a8fb22f7cde82c8220e5aeacb3258ed7ce996142c77cba193f203515e26c330"
+"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)" = "c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b"
+"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f"
+"checksum tokio 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)" = "ec2ffcf4bcfc641413fa0f1427bf8f91dfc78f56a6559cbf50e04837ae442a87"
+"checksum tokio-buf 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "8fb220f46c53859a4b7ec083e41dec9778ff0b1851c0942b211edb89e0ccdc46"
+"checksum tokio-codec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5c501eceaf96f0e1793cf26beb63da3d11c738c4a943fdf3746d81d64684c39f"
+"checksum tokio-current-thread 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "d16217cad7f1b840c5a97dfb3c43b0c871fef423a6e8d2118c604e843662a443"
+"checksum tokio-executor 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "83ea44c6c0773cc034771693711c35c677b4b5a4b21b9e7071704c54de7d555e"
+"checksum tokio-fs 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "3fe6dc22b08d6993916647d108a1a7d15b9cd29c4f4496c62b92c45b5041b7af"
+"checksum tokio-io 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "5090db468dad16e1a7a54c8c67280c5e4b544f3d3e018f0b913b400261f85926"
+"checksum tokio-reactor 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "6af16bfac7e112bea8b0442542161bfc41cbfa4466b580bdda7d18cb88b911ce"
+"checksum tokio-sync 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "2162248ff317e2bc713b261f242b69dbb838b85248ed20bb21df56d60ea4cae7"
+"checksum tokio-tcp 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "1d14b10654be682ac43efee27401d792507e30fd8d26389e1da3b185de2e4119"
+"checksum tokio-threadpool 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)" = "72558af20be886ea124595ea0f806dd5703b8958e4705429dd58b3d8231f72f2"
+"checksum tokio-timer 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "f2106812d500ed25a4f38235b9cae8f78a09edf43203e16e59c3b769a342a60e"
+"checksum tokio-trace-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "a9c8a256d6956f7cb5e2bdfe8b1e8022f1a09206c6c2b1ba00f3b746b260c613"
+"checksum tokio-udp 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "66268575b80f4a4a710ef83d087fdfeeabdce9b74c797535fbac18a2cb906e92"
+"checksum tokio-uds 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)" = "037ffc3ba0e12a0ab4aca92e5234e0dedeb48fddf6ccd260f1f150a36a9f2445"
+"checksum try-lock 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "e604eb7b43c06650e854be16a2a03155743d3752dd1c943f6829e26b7a36e382"
+"checksum ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86"
+"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
+"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56"
+"checksum utf8-ranges 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "9d50aa7650df78abf942826607c62468ce18d9019673d4a2ebe1865dbb96ffde"
+"checksum uuid 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)" = "90dbc611eb48397705a6b0f6e917da23ae517e4d127123d2cf7674206627d32a"
+"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd"
+"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d"
+"checksum want 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b6395efa4784b027708f7451087e647ec73cc74f5d9bc2e418404248d679a230"
+"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
+"checksum winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)" = "f10e386af2b13e47c89e7236a7a14a086791a2b88ebad6df9bf42040195cf770"
+"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"
+"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+"checksum winapi-util 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9"
+"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+"checksum wincolor 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "561ed901ae465d6185fa7864d63fbd5720d0ef718366c9a4dc83cf6170d7e9ba"
+"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e"
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..3d869b1
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,15 @@
+[workspace]
+
+members = [
+	"cfwlogd",
+	"testutils",
+	"vminfod-client",
+]
+
+[profile.dev]
+panic = 'abort'
+
+[profile.release]
+panic = 'abort'
+lto = true
+debug = true
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..a612ad9
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,373 @@
+Mozilla Public License Version 2.0
+==================================
+
+1. Definitions
+--------------
+
+1.1. "Contributor"
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+1.2. "Contributor Version"
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+1.3. "Contribution"
+    means Covered Software of a particular Contributor.
+
+1.4. "Covered Software"
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+1.5. "Incompatible With Secondary Licenses"
+    means
+
+    (a) that the initial Contributor has attached the notice described
+        in Exhibit B to the Covered Software; or
+
+    (b) that the Covered Software was made available under the terms of
+        version 1.1 or earlier of the License, but not also under the
+        terms of a Secondary License.
+
+1.6. "Executable Form"
+    means any form of the work other than Source Code Form.
+
+1.7. "Larger Work"
+    means a work that combines Covered Software with other material, in
+    a separate file or files, that is not Covered Software.
+
+1.8. "License"
+    means this document.
+
+1.9. "Licensable"
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+1.10. "Modifications"
+    means any of the following:
+
+    (a) any file in Source Code Form that results from an addition to,
+        deletion from, or modification of the contents of Covered
+        Software; or
+
+    (b) any new file in Source Code Form that contains any Covered
+        Software.
+
+1.11. "Patent Claims" of a Contributor
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+1.12. "Secondary License"
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+1.13. "Source Code Form"
+    means the form of the work preferred for making modifications.
+
+1.14. "You" (or "Your")
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, "You" includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+2. License Grants and Conditions
+--------------------------------
+
+2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+(a) under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+
+(b) under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+(a) for any code that a Contributor has removed from Covered Software;
+    or
+
+(b) for infringements caused by: (i) Your and any other third party's
+    modifications of Covered Software, or (ii) the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+
+(c) under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+3. Responsibilities
+-------------------
+
+3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+(a) such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+(b) You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+4. Inability to Comply Due to Statute or Regulation
+---------------------------------------------------
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: (a) comply with
+the terms of this License to the maximum extent possible; and (b)
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+5. Termination
+--------------
+
+5.1. The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated (a) provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and (b) on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+5.2. If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+5.3. In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+************************************************************************
+*                                                                      *
+*  6. Disclaimer of Warranty                                           *
+*  -------------------------                                           *
+*                                                                      *
+*  Covered Software is provided under this License on an "as is"       *
+*  basis, without warranty of any kind, either expressed, implied, or  *
+*  statutory, including, without limitation, warranties that the       *
+*  Covered Software is free of defects, merchantable, fit for a        *
+*  particular purpose or non-infringing. The entire risk as to the     *
+*  quality and performance of the Covered Software is with You.        *
+*  Should any Covered Software prove defective in any respect, You     *
+*  (not any Contributor) assume the cost of any necessary servicing,   *
+*  repair, or correction. This disclaimer of warranty constitutes an   *
+*  essential part of this License. No use of any Covered Software is   *
+*  authorized under this License except under this disclaimer.         *
+*                                                                      *
+************************************************************************
+
+************************************************************************
+*                                                                      *
+*  7. Limitation of Liability                                          *
+*  --------------------------                                          *
+*                                                                      *
+*  Under no circumstances and under no legal theory, whether tort      *
+*  (including negligence), contract, or otherwise, shall any           *
+*  Contributor, or anyone who distributes Covered Software as          *
+*  permitted above, be liable to You for any direct, indirect,         *
+*  special, incidental, or consequential damages of any character      *
+*  including, without limitation, damages for lost profits, loss of    *
+*  goodwill, work stoppage, computer failure or malfunction, or any    *
+*  and all other commercial damages or losses, even if such party      *
+*  shall have been informed of the possibility of such damages. This   *
+*  limitation of liability shall not apply to liability for death or   *
+*  personal injury resulting from such party's negligence to the       *
+*  extent applicable law prohibits such limitation. Some               *
+*  jurisdictions do not allow the exclusion or limitation of           *
+*  incidental or consequential damages, so this exclusion and          *
+*  limitation may not apply to You.                                    *
+*                                                                      *
+************************************************************************
+
+8. Litigation
+-------------
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+9. Miscellaneous
+----------------
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+10. Versions of the License
+---------------------------
+
+10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+10.4. Distributing Source Code Form that is Incompatible With Secondary
+Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+Exhibit A - Source Code Form License Notice
+-------------------------------------------
+
+  This Source Code Form is subject to the terms of the Mozilla Public
+  License, v. 2.0. If a copy of the MPL was not distributed with this
+  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+Exhibit B - "Incompatible With Secondary Licenses" Notice
+---------------------------------------------------------
+
+  This Source Code Form is "Incompatible With Secondary Licenses", as
+  defined by the Mozilla Public License, v. 2.0.
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..2ca85e8
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,102 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+RUST_CODE = 1
+
+#
+# Files
+#
+DOC_FILES =		index.md
+JSON_FILES :=		package.json
+
+
+# While this component doesn't require a base image, we set this so
+# that validate-buildenv can determine whether we're building on
+# a recent enough image (including a reasonably recent version of rust)
+# triton-origin-x86_64-19.1.0
+BASE_IMAGE_UUID = cbf116a0-43a5-447c-ad8c-8fa57787351c
+
+#
+# Makefile.defs defines variables used as part of the build process.
+# Ensure we have the eng submodule before attempting to include it.
+#
+ENGBLD_REQUIRE := $(shell git submodule update --init deps/eng)
+include ./deps/eng/tools/mk/Makefile.defs
+TOP ?= $(error Unable to access eng.git submodule Makefiles.)
+
+NAME :=			firewall-logger-agent
+RELEASE_TARBALL :=	$(NAME)-$(STAMP).tgz
+RELEASE_MANIFEST :=	$(NAME)-$(STAMP).manifest
+RELSTAGEDIR :=		/tmp/$(NAME)-$(STAMP)
+
+DISTCLEAN_FILES += $(NAME)-*.manifest $(NAME)-*.tgz
+
+#
+# Repo-specific targets
+#
+.PHONY: all
+all: $(SMF_MANIFESTS) | $(REPO_DEPS)
+
+.PHONY: cargo
+cargo:
+	cargo build --release
+
+# Clean the target directory:
+TARGET_DIR ?= target
+DISTCLEAN_FILES += $(TARGET_DIR)
+
+.PHONY: release
+release: all cargo
+	echo "Building $(RELEASE_TARBALL)"
+	mkdir -p $(TOP)/bin
+	cp $(TOP)/target/release/cfwlogd \
+		$(TOP)/bin/cfwlogd
+	mkdir -p $(RELSTAGEDIR)/$(NAME)
+	cp -r \
+	    $(TOP)/bin \
+	    $(TOP)/npm \
+	    $(TOP)/package.json \
+	    $(TOP)/smf \
+	    $(TOP)/deps/eng/tools \
+	    $(RELSTAGEDIR)/$(NAME)
+	uuid -v4 >$(RELSTAGEDIR)/$(NAME)/image_uuid
+	cd $(RELSTAGEDIR) && $(TAR) -I pigz -cf $(TOP)/$(RELEASE_TARBALL) *
+	cat $(TOP)/manifest.tmpl | sed \
+	    -e "s/UUID/$$(cat $(RELSTAGEDIR)/$(NAME)/image_uuid)/" \
+	    -e "s/NAME/$$(json name < $(TOP)/package.json)/" \
+	    -e "s/VERSION/$$(json version < $(TOP)/package.json)/" \
+	    -e "s/DESCRIPTION/$$(json description < $(TOP)/package.json)/" \
+	    -e "s/BUILDSTAMP/$(STAMP)/" \
+	    -e "s/SIZE/$$(stat --printf="%s" $(TOP)/$(RELEASE_TARBALL))/" \
+	    -e "s/SHA/$$(openssl sha1 $(TOP)/$(RELEASE_TARBALL) \
+	    | cut -d ' ' -f2)/" \
+	    > $(TOP)/$(RELEASE_MANIFEST)
+	rm -rf $(RELSTAGEDIR)
+
+.PHONY: publish
+publish: release
+	mkdir -p $(ENGBLD_BITS_DIR)/$(NAME)
+	cp $(TOP)/$(RELEASE_TARBALL) $(ENGBLD_BITS_DIR)/$(NAME)/$(RELEASE_TARBALL)
+	cp $(TOP)/$(RELEASE_MANIFEST) $(ENGBLD_BITS_DIR)/$(NAME)/$(RELEASE_MANIFEST)
+
+# Here "cutting a release" is just tagging the current commit with
+# "v(package.json version)". We don't publish this to npm.
+.PHONY: cutarelease
+cutarelease:
+	echo "# Ensure working copy is clean."
+	[[ -z `git status --short` ]]  # If this fails, the working dir is dirty.
+	echo "# Ensure have 'json' tool."
+	which json 2>/dev/null 1>/dev/null
+	ver=$(shell cat package.json | json version) && \
+	    git tag "v$$ver" && \
+	    git push origin "v$$ver"
+
+include ./deps/eng/tools/mk/Makefile.deps
+include ./deps/eng/tools/mk/Makefile.targ
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..6fde4f3
--- /dev/null
+++ b/README.md
@@ -0,0 +1,50 @@
+<!--y
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+This repository is part of the Joyent Triton project. See the [contribution
+guidelines](https://github.com/joyent/triton/blob/master/CONTRIBUTING.md) --
+*Triton does not use GitHub PRs* -- and general documentation at the main
+[Triton project](https://github.com/joyent/triton) page.
+
+# Triton Firewall Logger Agent
+
+For more information see [rfd-163](https://github.com/joyent/rfd/tree/master/rfd/0163)
+
+## Development
+
+Describe steps necessary for development here.
+
+    make all
+
+
+## Test
+
+Describe steps necessary for testing here.
+
+    make test
+
+## Documentation
+
+[Main docs file is at docs/index.md](docs/index.md).
+
+To update, edit "docs/index.md" and run `make docs` to generate/update
+"docs/index.html". Works on either SmartOS or Mac OS X.
+
+## Your Other Sections Here
+
+Add other sections to your README as necessary. E.g. Running a demo, adding
+development data.
+
+
+## License
+
+"Triton Firewall Logger" is licensed under the
+[Mozilla Public License version 2.0](http://mozilla.org/MPL/2.0/).
+See the file LICENSE.
diff --git a/cfwlogd/Cargo.toml b/cfwlogd/Cargo.toml
new file mode 100644
index 0000000..8e5cf0c
--- /dev/null
+++ b/cfwlogd/Cargo.toml
@@ -0,0 +1,24 @@
+[package]
+name = "cfwlogd"
+version = "0.1.0"
+authors = ["Mike Zeller <mike@mikezeller.net>"]
+edition = "2018"
+
+[dependencies]
+crossbeam = "0.7"
+vminfod-client = { path = "../vminfod-client" }
+serde = { version = "1.0", features = ["derive"] }
+serde_json = "1.0"
+nom = "5.0"
+uuid = { version = "0.7", features = ["serde", "v4"] }
+chrono = { version = "0.4", features = ["serde"] }
+pretty_env_logger = "0.3"
+log = "0.4"
+signal-hook = "0.1"
+libc = "0.2"
+daemonize = "0.4.1"
+illumos-priv = "0.1.0"
+
+[dev-dependencies]
+testutils = { path = "../testutils" }
+rand = "0.6"
diff --git a/cfwlogd/src/events.rs b/cfwlogd/src/events.rs
new file mode 100644
index 0000000..d8e8105
--- /dev/null
+++ b/cfwlogd/src/events.rs
@@ -0,0 +1,427 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+//! Event processing pipeline implementation that is responsible for reading from an `EventSource`
+//! and parsing the returned events and passing them off to a `Logger`
+//!
+//!
+//!                        +---------------+        +--------------+ -----> zone1 Logger
+//!  +---------------+     | device reader |        | event fanout | -----> zone2 Logger
+//!  |  EventSource  |---> |    thread     |------->|    thread    | -----> zone3 Logger
+//!  +---------------+     +---------------+        +--------------+ -----> zone4 Logger
+//!
+//! The pipeline consists of a main device reading thread that sits in a tight loop.  This thread
+//! will read as many events as it can up to an upper bound via read(2) from the passed in
+//! `EventSource` such as "/dev/ipfev". This thread will parse the raw bytes into `CfwEvent`s and
+//! send them to the event fanout thread over a channel. This channel is bounded to some capacity
+//! based on the `EventSources`'s returned sizing but also features an upper and lower bound. This
+//! is to prevent endless memory growth if the userland daemon cannot keep up with its
+//! `EventSource`. Once the event fanout thread receives a parsed event it will attempt to wait a
+//! small amount of time in hopes of coalescing multiple events coming down the channel. After
+//! waiting the fanout thread will loop over each of the received events and attempt to send off
+//! the event to the appropriate `Logger` if one exists.  If the `Logger` does not exist it will
+//! spawn a new `Logger` thread for the zone and proceed to send it the `Logger` via an unbounded
+//! channel. These channels are unbounded because writing to disk is almost always slower than the
+//! `EventSource` producing events. The `Logger` then takes care of serializing the event into json
+//! and writing it out to the appropriate log file.
+//!
+
+use crate::logger::{self, Logger};
+use crate::parser::{self, CfwEvent};
+use crate::zones::{Vmobjs, Zonedid};
+use crossbeam::channel::{self, Receiver, Select, Sender, TrySendError};
+use std::collections::hash_map::Entry;
+use std::collections::HashMap;
+use std::sync::{Arc, Mutex};
+use std::thread;
+
+const RING_CAPACITY_MULTIPLIER: usize = 512;
+
+/// Holds a Mutex protected mapping of zonedid to Logging thread
+pub type Loggers = Arc<Mutex<HashMap<Zonedid, Logger>>>;
+
+/// Trait that represents a Firewall Event Source
+pub trait EventSource: Send {
+    /// Reads n events into the given buffer, returning how many bytes were read.
+    fn read_events(&mut self, buf: &mut [u8]) -> std::io::Result<usize>;
+    /// Returns a tuple that tells you the largest event size, and the max number of events that
+    /// may be returned in a single read.
+    fn event_sizing(&mut self) -> std::io::Result<(usize, usize)>;
+}
+
+/// Clamp the ringsize so that it falls somewhere between the min and max values.
+fn clamp_ring_size(min: usize, max: usize, value: usize) -> usize {
+    if value > max {
+        max
+    } else if value < min {
+        min
+    } else {
+        value
+    }
+}
+
+/// Start a thread that consumes events from an `EventSource`.
+/// The consumed events will be sent to the returned `Receiver`.
+pub fn start_event_reader<T: EventSource + 'static>(
+    mut device: T,
+) -> (Receiver<CfwEvent>, thread::JoinHandle<()>) {
+    let (max, ringsize) = device.event_sizing().unwrap_or_else(|e| {
+        error!("failed to get ring size from device: {}", e);
+        std::process::exit(e.raw_os_error().unwrap_or(-1));
+    });
+    debug!(
+        "device responded with max event size: {}, ring size: {}",
+        &max, &ringsize
+    );
+    // This value is kind of picked out of thin air based on initial testing during development.
+    // It's quite possible this will need to be tuned at some point in the future. We could make
+    // the channel unbounded at the cost of some performance, but it's probably a good idea to have
+    // some sort of backpressure control here so we don't endlessly grow in memory. Testing also
+    // showed that selecting a small ringsize provides the potential for cfwlogd to drop events
+    // so we set the ringsize lower bound to 1024. We also set an upper bound to 2048 so that we
+    // don't needlessly allocate a large chunk of memory at startup.
+    let rs = clamp_ring_size(1024, 2048, ringsize);
+    debug!(
+        "sizing the channel capacity to {} * {}",
+        rs, RING_CAPACITY_MULTIPLIER
+    );
+    let capacity = RING_CAPACITY_MULTIPLIER * rs;
+    let (tx, rx) = channel::bounded(capacity);
+    (
+        rx,
+        thread::Builder::new()
+            .name("EventReader".to_owned())
+            .spawn(move || {
+                // a buffer that can hold a full read of the ringbuffer
+                let mut buf = vec![0; max * ringsize];
+
+                loop {
+                    let size = match device.read_events(&mut buf) {
+                        Ok(size) => size,
+                        Err(e) => {
+                            match e.kind() {
+                                std::io::ErrorKind::Interrupted => continue,
+                                _ => {
+                                    // We failed to read from the EventSource so let's log the
+                                    // error and drop our `Sender` so that we can shutdown
+                                    // gracefully"
+                                    error!("failed to read from the EventSource: {:?}", e);
+                                    break;
+                                }
+                            }
+                        }
+                    };
+
+                    if parse_events(&buf[..size], &tx) {
+                        // The recv channel is closed so we can stop reading events
+                        break;
+                    }
+                }
+            })
+            .expect("failed to start event reader thread"),
+    )
+}
+
+/// Takes a buffer of bytes and slices them up into `CfwEvent`s that are then sent to the provided
+/// `Sender`.
+fn parse_events(bytes: &[u8], sender: &Sender<CfwEvent>) -> bool {
+    let mut bytes = bytes;
+    loop {
+        // Leaving this as an expect call because if we ever get out of sync or the device returns
+        // us not enough data we will be in a very bad place in terms of figuring out how to
+        // continue so it's best we just crash.
+        let (leftover, event) = parser::cfwevent_parse(&bytes).expect("event parsing failed");
+        if let Err(e) = sender.try_send(event) {
+            match e {
+                // Unfortunately we have to drop an event
+                // CMON TRITON-1755
+                TrySendError::Full(dropped_event) => warn!(
+                    "processing channel is full ({} queued) so we are dropping an event for \\
+                     zonedid: {}",
+                    sender.len(),
+                    dropped_event.zone()
+                ),
+                // We are in the process of shutting down
+                TrySendError::Disconnected(_) => {
+                    info!("the event processing channel has disconnected");
+                    return true;
+                }
+            }
+        }
+        bytes = leftover;
+        if bytes.is_empty() {
+            break;
+        };
+    }
+    false
+}
+
+/// Starts a thread that will receive `CfwEvent`s and fan them out to per zone logging threads.
+pub fn start_event_fanout(
+    events: Receiver<CfwEvent>,
+    shutdown: Receiver<()>,
+    vmobjs: Vmobjs,
+) -> (Loggers, thread::JoinHandle<()>) {
+    let loggers: Loggers = Arc::new(Mutex::new(HashMap::new()));
+    let loggers2 = Arc::clone(&loggers);
+    (
+        loggers,
+        thread::Builder::new()
+            .name("EventFanout".to_owned())
+            .spawn(move || fanout_events(events, shutdown, vmobjs, loggers2))
+            .expect("failed to start event fanout thread"),
+    )
+}
+
+/// Fanout events coming from the Receiver into the appropriate Logger, creating a new Logger if
+/// one does not yet exist.
+fn fanout_events(
+    events: Receiver<CfwEvent>,
+    shutdown: Receiver<()>,
+    vmobjs: Vmobjs,
+    mut loggers: Loggers,
+) {
+    let mut sel = Select::new();
+    let events_ready = sel.recv(&events);
+    let shutdown_ready = sel.recv(&shutdown);
+
+    loop {
+        match sel.ready() {
+            // This should never be a Disconnected message because the thread holding the tx end of
+            // the channel will never close it. There's also no way to currently check if the
+            // channel is disconnected given the current API.
+            i if i == events_ready => {
+                thread::sleep(std::time::Duration::from_nanos(500_000));
+                queue_zone_events(
+                    events.try_iter().take(1024).collect(),
+                    &vmobjs,
+                    &mut loggers,
+                )
+            }
+            i if i == shutdown_ready => {
+                shutdown
+                    .recv()
+                    .expect("the signal rx should never outlive the tx");
+                debug!("event fanout thread received shutdown signal");
+                break;
+            }
+            _ => unreachable!(),
+        }
+    }
+
+    // Attempt to grab all of the events that are currently in the queue so we can
+    // shutdown the receiver as quickly as possible. We use "take()" here so that we
+    // don't end up in a situation where this processing thread is being blasted with
+    // incoming events and we can't disconnect in a timely manner.
+    drop(sel);
+    let drain: Vec<_> = events.try_iter().take(events.len()).collect();
+    drop(events);
+    debug!(
+        "event processing thread drained {} remaining events before shutdown",
+        drain.len()
+    );
+    queue_zone_events(drain, &vmobjs, &mut loggers);
+
+    info!("event processing thread exiting");
+}
+
+/// For a given cfw event, find or create a `Logger` thats responsible for serializing the event to
+/// disk.
+fn queue_zone_events(events: Vec<CfwEvent>, vmobjs: &Vmobjs, loggers: &mut Loggers) {
+    let mut loggers = loggers.lock().unwrap();
+    for event in events {
+        if let CfwEvent::Unknown(_) = event {
+            continue;
+        };
+        let zonedid = event.zone();
+        let logger = match loggers.entry(zonedid) {
+            Entry::Occupied(entry) => entry.into_mut(),
+            Entry::Vacant(entry) => match logger::start_logger(zonedid, Arc::clone(&vmobjs)) {
+                Some(logger) => {
+                    info!("new logging thread started for zonedid {}", zonedid);
+                    entry.insert(logger)
+                }
+                None => {
+                    // CMON TRITON-1755
+                    error!(
+                        "unable to match zonedid {} to vm object; dropping event",
+                        zonedid
+                    );
+                    continue;
+                }
+            },
+        };
+        if logger.send(event).is_err() {
+            // Receive side of the log was disconnected somehow, so we drop the entry allowing it
+            // to be recreated on the next event.
+            // CMON TRITON-1755
+            error!(
+                "failed to log event for zone {} (logger channel disconnected)",
+                zonedid
+            );
+            loggers.remove(&zonedid);
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crossbeam::sync::ShardedLock;
+    use std::time::Duration;
+
+    struct MockEventSource {}
+
+    impl EventSource for MockEventSource {
+        fn read_events(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
+            let event = testutils::generate_event();
+            let bytes = event.as_bytes();
+            assert!(
+                buf.len() >= bytes.len(),
+                "the provided buffer must be able to hold at least one event"
+            );
+            buf[..bytes.len()].copy_from_slice(bytes);
+            Ok(bytes.len())
+        }
+        fn event_sizing(&mut self) -> std::io::Result<(usize, usize)> {
+            Ok((testutils::generate_event().as_bytes().len(), 1))
+        }
+    }
+
+    #[test]
+    fn parse_events_test() {
+        let num_events = 10;
+        let (tx, rx) = crossbeam::channel::unbounded();
+        let event = testutils::generate_event();
+
+        let mut bytes = vec![];
+        std::iter::repeat(event.as_bytes())
+            .take(num_events)
+            .for_each(|b| bytes.extend_from_slice(b));
+
+        let done = parse_events(&bytes, &tx);
+
+        // Parse_events returns false because the channel is still open
+        assert!(!done);
+        // There should be num_events in the rx half of the channel
+        assert_eq!(
+            rx.len(),
+            num_events,
+            "the rx channel contains the same number of events passed in"
+        );
+
+        // drop the sender so we can easily iterate over all the events in the channel
+        drop(tx);
+        let cfwevent = parser::cfwevent_parse(event.as_bytes()).unwrap().1;
+        for e in rx.iter() {
+            assert_eq!(cfwevent, e, "all events match the passed in events");
+        }
+    }
+
+    #[test]
+    fn start_event_reader_test() {
+        let device = MockEventSource {};
+        let (events, _handle) = start_event_reader(device);
+        let event = events.recv_timeout(Duration::from_secs(1));
+        assert!(
+            event.is_ok(),
+            "at least one event has made it through the returned rx channel"
+        );
+    }
+
+    #[test]
+    fn queue_zone_events_test() {
+        let mut loggers: Loggers = Arc::new(Mutex::new(HashMap::new()));
+        let vmobjs: Vmobjs = Arc::new(ShardedLock::new(HashMap::new()));
+
+        // Test that we don't create a logger for a zone we don't know about
+        let event = testutils::generate_event();
+        let cfwevent = parser::cfwevent_parse(event.as_bytes()).unwrap().1;
+        queue_zone_events(vec![cfwevent], &vmobjs, &mut loggers);
+
+        let logs = loggers.lock().unwrap();
+        assert!(logs.is_empty(), "there were no loggers created");
+        drop(logs);
+
+        // Make a fake zone for our test
+        let zone1 = testutils::create_zone();
+        let event = testutils::generate_event_for_zone(&zone1);
+        let customer_uuid = zone1.owner_uuid.clone();
+
+        let mut vms = vmobjs.write().unwrap();
+        vms.insert(zone1.zonedid, zone1);
+        drop(vms);
+
+        // Test that we create a logger for a zone found in vmobjs
+        let cfwevent = parser::cfwevent_parse(event.as_bytes()).unwrap().1;
+        queue_zone_events(vec![cfwevent], &vmobjs, &mut loggers);
+        let mut logs = loggers.lock().unwrap();
+        assert_eq!(logs.len(), 1, "there is exactly one logger created");
+        for (zonedid, logger) in logs.drain() {
+            assert_eq!(zonedid, event.zonedid, "zonedid's match");
+            // Shutdown the logger so the file flushes
+            logger.shutdown().expect("failed to shutdown logger");
+        }
+        drop(logs);
+
+        // make sure that the directory for the logs appeared and clean it up
+        assert_eq!(
+            true,
+            std::fs::remove_dir_all(format!("{}/{}", crate::logger::LOG_DIR, customer_uuid))
+                .is_ok(),
+            "successfully cleaned up test files"
+        );
+    }
+
+    #[test]
+    fn start_event_fanout_test() {
+        let vmobjs: Vmobjs = Arc::new(ShardedLock::new(HashMap::new()));
+
+        let zone1 = testutils::create_zone();
+        let event = testutils::generate_event_for_zone(&zone1);
+        let customer_uuid = zone1.owner_uuid.clone();
+
+        let mut vms = vmobjs.write().unwrap();
+        vms.insert(zone1.zonedid, zone1);
+        drop(vms);
+
+        let cfwevent = parser::cfwevent_parse(event.as_bytes()).unwrap().1;
+
+        let (tx, rx) = crossbeam::channel::unbounded();
+        let (stx, srx) = crossbeam::channel::unbounded();
+        let (loggers, handle) = start_event_fanout(rx, srx, Arc::clone(&vmobjs));
+
+        let logs = loggers.lock().unwrap();
+        assert!(logs.is_empty(), "no loggers exist yet");
+        drop(logs);
+
+        assert!(
+            tx.send(cfwevent).is_ok(),
+            "successfully sent CfwEvent to fanout thread"
+        );
+
+        assert!(stx.send(()).is_ok(), "shutdown signal sent");
+        // should be plenty of time for the thread to shutdown
+        thread::sleep(Duration::from_millis(500));
+        let cfwevent = parser::cfwevent_parse(event.as_bytes()).unwrap().1;
+        assert!(
+            tx.send(cfwevent).is_err(),
+            "thread should no longer be accepting CfwEvents"
+        );
+        // XXX not sure how to deal with this potentially hanging forever other than setting a
+        // timeout in a test runner like jenkins. Although if we made it this far in the test then
+        // it's looking like the thread has already actually shutdown.
+        assert!(handle.join().is_ok(), "thread shutdown");
+
+        // make sure that the directory for the logs appeared and clean it up
+        assert_eq!(
+            true,
+            std::fs::remove_dir_all(format!("{}/{}", crate::logger::LOG_DIR, customer_uuid))
+                .is_ok(),
+            "successfully cleaned up test files"
+        );
+    }
+}
diff --git a/cfwlogd/src/fileutils.rs b/cfwlogd/src/fileutils.rs
new file mode 100644
index 0000000..816767f
--- /dev/null
+++ b/cfwlogd/src/fileutils.rs
@@ -0,0 +1,155 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use std::io;
+use std::io::prelude::*;
+use std::io::{Seek, SeekFrom};
+
+/// Represents the total length of the Reader and position of the character of interest.
+pub struct ReaderSeekInfo {
+    /// Total Reader length
+    pub length: u64,
+    /// Location of specified character if any.
+    pub index: Option<u64>,
+}
+
+/// Iterates through the given bytes backwards looking for the provided char
+fn rev_locate_char(bytes: &[u8], c: u8) -> Option<usize> {
+    bytes.iter().rposition(|p| *p == c)
+}
+
+/// Seeks to the end of a given `Reader` and processes a chunk of bytes looking for a specific
+/// char. This process is repeated until the given char is found, otherwise returns None if it's
+/// not found. This function panics if the chunk size is 0.
+pub fn rseek_and_scan<R: Read + Seek>(r: &mut R, chunk: u64, c: u8) -> io::Result<ReaderSeekInfo> {
+    assert!(chunk > 0, "chunk size must be greater than 0");
+    let mut buf = String::with_capacity(chunk as usize);
+    // Track the overall seek offset
+    let mut ptr = r.seek(SeekFrom::End(0))?;
+    let file_len = ptr;
+    // Used to calculate the next seek offset when reading a chunk
+    let mut pos = ptr;
+
+    loop {
+        // Set the buffer len back to 0 leaving capacity alone.
+        buf.truncate(0);
+        pos = pos.saturating_sub(chunk);
+        // Seek to the next chunk of bytes.
+        r.seek(SeekFrom::Start(pos))?;
+        // Avoid overlapping chunks when there is less than a chunk's worth of data left
+        let max = if ptr < chunk { ptr } else { chunk };
+        // Read the max number of bytes into the buffer.
+        r.take(max).read_to_string(&mut buf)?;
+
+        // Attempt to locate the char.
+        if let Some(found) = rev_locate_char(buf.as_bytes(), c) {
+            return Ok(ReaderSeekInfo {
+                length: file_len,
+                index: Some(found as u64 + pos),
+            });
+        }
+
+        // If our pos is 0 there's nothing left to read. Using `saturating_sub` guarantees we
+        // will never dip below 0.
+        if pos == 0 {
+            break;
+        };
+
+        // Move our offset pointer to reflect how much was read and where we are in the Reader
+        ptr -= max;
+    }
+    Ok(ReaderSeekInfo {
+        length: file_len,
+        index: None,
+    })
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use std::io::Cursor;
+
+    #[test]
+    fn test_beginning() {
+        let mut data = Cursor::new(vec![b'\n', 2, 3, 4, 5]);
+        let pos = rseek_and_scan(&mut data, 100, b'\n').unwrap().index;
+        assert_eq!(Some(0), pos, "newline is in the first position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+
+    #[test]
+    fn test_middle() {
+        let mut data = Cursor::new(vec![1, 2, 3, b'\n', 5, 6, 7]);
+        let pos = rseek_and_scan(&mut data, 100, b'\n').unwrap().index;
+        assert_eq!(Some(3), pos, "newline is in the middle position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+
+    #[test]
+    fn test_end() {
+        let mut data = Cursor::new(vec![1, 2, 3, 4, 5, b'\n']);
+        let pos = rseek_and_scan(&mut data, 100, b'\n').unwrap().index;
+        assert_eq!(Some(5), pos, "newline is in the last position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+
+    #[test]
+    fn test_reading_single_byte() {
+        let mut data = Cursor::new(vec![b'\n', 2, 3, 4, 5]);
+        let pos = rseek_and_scan(&mut data, 1, b'\n').unwrap().index;
+        assert_eq!(Some(0), pos, "newline is in the first position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+
+    #[test]
+    fn test_overlapping_chunks() {
+        let mut data = Cursor::new(vec![b'\n', 2, 3, 4, 5]);
+        let pos = rseek_and_scan(&mut data, 2, b'\n').unwrap().index;
+        assert_eq!(Some(0), pos, "newline is in the first position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+
+    #[test]
+    fn test_multiple_newlines() {
+        let mut data = Cursor::new(vec![1, 2, b'\n', 4, b'\n', b'\n']);
+        let pos = rseek_and_scan(&mut data, 100, b'\n').unwrap().index;
+        assert_eq!(Some(5), pos, "newline is in the last position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+
+        data.get_mut().remove(pos.unwrap() as usize);
+        let pos = rseek_and_scan(&mut data, 50, b'\n').unwrap().index;
+        assert_eq!(Some(4), pos, "newline is in the last position");
+        assert_eq!(
+            b'\n',
+            data.get_ref()[pos.unwrap() as usize],
+            r#"byte should be \n"#
+        );
+    }
+}
diff --git a/cfwlogd/src/ipf.rs b/cfwlogd/src/ipf.rs
new file mode 100644
index 0000000..547849c
--- /dev/null
+++ b/cfwlogd/src/ipf.rs
@@ -0,0 +1,68 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+//! This is the implementation of an EventSource for ipfilter.
+
+use crate::events::EventSource;
+use libc::c_int;
+use std::fs::File;
+use std::io::Read;
+use std::os::unix::io::AsRawFd;
+use std::path::Path;
+
+/// SIOCIPFCFWCFG generated from:
+/// _IOR('r', 98, struct ipfcfwcfg)
+/// This _MUST_ be recomputed if any changes to `Ipfcfwcfg` are made.
+const SIOCIPFCFWCFG: c_int = 1_075_343_970;
+
+// C representation of a cfw event
+#[repr(C)]
+#[derive(Default)]
+pub struct Ipfcfwcfg {
+    pub max_event_size: u32,
+    pub ring_size: u32,
+    pub num_reports: u64,
+    pub num_drops: u64,
+}
+
+/// Wrapper around the ipfev device
+pub struct IpfevDevice {
+    file: File,
+}
+
+impl IpfevDevice {
+    /// Create a new `IpfevDevice`
+    pub fn new<P: AsRef<Path>>(device: P) -> std::io::Result<Self> {
+        let device = device.as_ref();
+        let file = File::open(device)?;
+        info!("connected to {}", device.display());
+        Ok(IpfevDevice { file })
+    }
+}
+
+impl EventSource for IpfevDevice {
+    /// Pull at least one event from the ipfev device into the provided buffer
+    fn read_events(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
+        let size = self.file.read(buf)?;
+        // The device should never return from a read with 0 bytes
+        assert!(size > 0);
+        Ok(size)
+    }
+
+    /// Dynamically read the largest known event size and the current sizing of the ring buffer
+    fn event_sizing(&mut self) -> std::io::Result<(usize, usize)> {
+        let mut cfg = Ipfcfwcfg::default();
+        // This is unsafe becuase we are calling out to the device via an ioctl, and because we are
+        // dealing with a raw pointer being passed into the C interface.
+        unsafe {
+            let cfg_ptr = &mut cfg as *mut Ipfcfwcfg;
+            match libc::ioctl(self.file.as_raw_fd(), SIOCIPFCFWCFG, cfg_ptr) {
+                -1 => Err(std::io::Error::last_os_error()),
+                _ => Ok((cfg.max_event_size as usize, cfg.ring_size as usize)),
+            }
+        }
+    }
+}
diff --git a/cfwlogd/src/logger.rs b/cfwlogd/src/logger.rs
new file mode 100644
index 0000000..e220f16
--- /dev/null
+++ b/cfwlogd/src/logger.rs
@@ -0,0 +1,323 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+//! A Logger is a thread that is responsible for receiving CfwEvents and logging them out to the
+//! appropriate directory in the current.log file. A Logger can also be told to perform a variety
+//! of tasks such as flushing its internal buffer to disk, flushing its buffer to disk and
+//! reopening current.log, or to simply flush its buffer to disk and shutdown.
+//!
+
+use crate::parser::CfwEvent;
+use crate::zones::{Vmobjs, Zonedid};
+use crossbeam::channel::{self, Select, SendError};
+use serde::Serialize;
+use std::fs::File;
+use std::fs::OpenOptions;
+use std::io::{BufWriter, Write};
+use std::path::PathBuf;
+use std::sync::Arc;
+use std::thread;
+
+/// Configure where log files will be created
+/// We are now chrooting into "/var/log/firewall" so the base dir should just be "/"
+#[cfg(not(test))]
+pub const LOG_DIR: &str = "/";
+#[cfg(test)]
+pub const LOG_DIR: &str = "/var/tmp/cfwlogd-tests";
+
+/// Capacity used for Logger's BufWriter.  This may need to be tuned later.
+const BUF_SIZE: usize = 1024 * 1024;
+
+#[derive(Debug, Serialize)]
+struct LogEvent<'a> {
+    #[serde(flatten)]
+    event: CfwEvent,
+    vm: &'a str,
+    alias: &'a str,
+}
+
+/// A signal that can be sent to the logger
+#[derive(PartialEq)]
+pub enum LoggerSignal {
+    /// Tell the thread to flush and continue
+    Flush,
+    /// Tell the thread to flush and shutdown
+    Shutdown,
+    /// Tell the thread to flush and rotate the log file
+    Rotate,
+}
+
+/// A Logger represents a thread tied to a specific zone that is responsible persisting CfwEvents
+/// to disk as newline separated json.
+pub struct Logger {
+    /// Zone UUID
+    pub uuid: String,
+    /// Threads handle
+    handle: thread::JoinHandle<()>,
+    /// Send half of a channel that's used to get CfwEvents into the Logger
+    sender: channel::Sender<CfwEvent>,
+    /// Send half of a channel that's used to signal the Logger to perform specific actions
+    signal: channel::Sender<LoggerSignal>,
+}
+
+impl Logger {
+    /// Send an event to the logger to be logged out to disk
+    pub fn send(&self, e: CfwEvent) -> Result<(), SendError<CfwEvent>> {
+        self.sender.send(e)
+    }
+
+    /// Flushes the logger's internal `BufWriter` to disk
+    pub fn flush(&self) -> Result<(), SendError<LoggerSignal>> {
+        self.signal.send(LoggerSignal::Flush)
+    }
+
+    /// Flushes the logger's internal `BufWriter` to disk, and reopens "current.log"
+    pub fn rotate(&self) -> Result<(), SendError<LoggerSignal>> {
+        self.signal.send(LoggerSignal::Rotate)
+    }
+
+    /// Flushes the logger's internal `BufWriter` to disk, and shutdowns the `Logger`, therefore
+    /// requiring ownership of self to be consumed.
+    pub fn shutdown(self) -> Result<(), SendError<LoggerSignal>> {
+        self.signal.send(LoggerSignal::Shutdown).and_then(|_| {
+            self.handle.join().unwrap();
+            Ok(())
+        })
+    }
+}
+
+/// Open "current.log" in "RW" for the given customer and zone.
+fn open_file(vm: &str, customer: &str) -> std::io::Result<File> {
+    let path: PathBuf = [LOG_DIR, customer, vm, "current.log"].iter().collect();
+    // we know the unwrap is safe because we just created the path above
+    std::fs::create_dir_all(path.parent().unwrap())?;
+    Ok(OpenOptions::new().append(true).create(true).open(path)?)
+}
+
+/// Given a collection of `CfwEvent`, serialize them out to disk as JSON formatted logs.
+fn log_events<W: Write>(events: Vec<CfwEvent>, mut writer: W, vmobjs: &Vmobjs) {
+    // force the event type for now
+    let vmobjs = vmobjs.read().unwrap();
+    for event in events {
+        let vmobj = vmobjs
+            .get(&event.zone())
+            .expect("we should have the zonedid:uuid mapping already");
+        // Check if the zone has an alias set, if not we provide a default one
+        // Note instead of String::as_ref we could also use "|s| &**s"
+        let alias = vmobj.alias.as_ref().map_or("", String::as_ref);
+        let event = LogEvent {
+            event,
+            vm: &vmobj.uuid,
+            alias: &alias,
+        };
+        // We decided that the only reason we would fail to write here would be due to something
+        // like ENOSPC/EDQUOT in which case none of the loggers are likely to make any forward
+        // progress so we will force unwrap the results and abort if we hit this scenario.
+        serde_json::to_writer(&mut writer, &event).expect("failed to CfwEvent to the BufWriter");
+        writer
+            .write_all(b"\n")
+            .expect("failed to write newline to the BufWriter");
+    }
+}
+
+// Process a signal sent to the Logger, and return true if the Logger was told to shutdown
+fn logger_handle_signal(
+    vm: &str,
+    customer: &str,
+    signal: LoggerSignal,
+    writer: &mut BufWriter<File>,
+) -> bool {
+    match signal {
+        LoggerSignal::Rotate => {
+            let _ = writer.flush();
+            let file = match open_file(vm, customer) {
+                Ok(file) => file,
+                Err(e) => {
+                    // CMON TRITON-1755
+                    error!("failed to open {}'s log file after rotation: {}", &vm, e);
+                    return true;
+                }
+            };
+            // Drop the old writer and create a new one
+            *writer = BufWriter::with_capacity(1024 * 1024, file);
+        }
+        LoggerSignal::Shutdown => return true,
+        LoggerSignal::Flush => {
+            info!("flushing log for {}", vm);
+            // If flushing fails, we are once again most likely hitting something like ENOSPC,
+            // which means we should just abort to let the operator know we are in a bad place.
+            writer
+                .flush()
+                .expect(&format!("failed to flush log for {}", vm));
+        }
+    }
+    false
+}
+
+/// Start the actual logging thread that receives events or signals on channels and loops forever
+/// until it is told to no longer do so.
+fn _start_logger(
+    vm: String,
+    customer: String,
+    vmobjs: Vmobjs,
+    events: channel::Receiver<CfwEvent>,
+    signal: channel::Receiver<LoggerSignal>,
+) -> thread::JoinHandle<()> {
+    thread::Builder::new()
+        .name(vm.clone())
+        .spawn(move || {
+            let file = match open_file(&vm, &customer) {
+                Ok(file) => file,
+                Err(e) => {
+                    // CMON TRITON-1755
+                    error!("failed to open log file: {}", e);
+                    return;
+                }
+            };
+
+            let mut writer = BufWriter::with_capacity(BUF_SIZE, file);
+            let mut sel = Select::new();
+            let events_ready = sel.recv(&events);
+            let signal_ready = sel.recv(&signal);
+            loop {
+                match sel.ready() {
+                    i if i == events_ready => {
+                        // Wait a small amount of time in hopes of coalescing events coming down
+                        // the channel, which helps reduce the number of calls to yield(2) and
+                        // reduces lock contention on the vmobjs rw lock.
+                        thread::sleep(std::time::Duration::from_nanos(500_000));
+                        log_events(events.try_iter().take(1024).collect(), &mut writer, &vmobjs)
+                    }
+                    i if i == signal_ready => match signal.recv() {
+                        Ok(signal) => {
+                            if logger_handle_signal(&vm, &customer, signal, &mut writer) {
+                                break;
+                            }
+                        }
+                        Err(_) => {
+                            warn!(
+                                "{}'s signal channel was disconnected which means the \\
+                                 Logger itself was dropped so we can safely shutdown as well",
+                                &vm
+                            );
+                        }
+                    },
+                    _ => unreachable!(),
+                }
+            }
+
+            // We are shutting down now so we drain the channel and then drop it
+            log_events(events.try_iter().collect(), &mut writer, &vmobjs);
+            drop(sel);
+            drop(events);
+            let _res = writer.flush();
+        })
+        .expect("failed to spawn Logger thread")
+}
+
+/// Return a Logger if we have information for the zone already otherwise return None
+pub fn start_logger(zonedid: Zonedid, vmobjs: Vmobjs) -> Option<Logger> {
+    let (event_tx, event_rx) = channel::unbounded();
+    let (signal_tx, signal_rx) = channel::bounded(1);
+    let vms = vmobjs.read().unwrap();
+    if let Some(vm) = vms.get(&zonedid) {
+        let handle = _start_logger(
+            vm.uuid.clone(),
+            vm.owner_uuid.clone(),
+            Arc::clone(&vmobjs),
+            event_rx,
+            signal_rx,
+        );
+        return Some(Logger {
+            uuid: vm.uuid.clone(),
+            handle,
+            sender: event_tx,
+            signal: signal_tx,
+        });
+    }
+    None
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::parser;
+    use crate::zones::Vmobjs;
+    use crossbeam::sync::ShardedLock;
+    use std::collections::HashMap;
+    use std::io::Read;
+    use std::path::PathBuf;
+
+    #[test]
+    fn open_file_test() {
+        let vm = "zone1";
+        let customer = "customer1";
+        let _f = open_file(vm, customer).expect("failed to open file");
+        let mut path: PathBuf = [LOG_DIR, customer, vm, "current.log"].iter().collect();
+        assert!(path.as_path().is_file(), "current.log file path is correct");
+        path.pop(); // current.log
+        path.pop(); // zone name
+        std::fs::remove_dir_all(path).expect("failed to cleanup log dir");
+    }
+
+    #[test]
+    fn log_events_test() {
+        let num_events = 4;
+        let vmobjs: Vmobjs = Arc::new(ShardedLock::new(HashMap::new()));
+
+        let zone1 = testutils::create_zone();
+
+        let events = std::iter::repeat_with(|| {
+            let event = testutils::generate_event_for_zone(&zone1);
+            parser::cfwevent_parse(event.as_bytes()).unwrap().1
+        })
+        .take(num_events)
+        .collect();
+
+        let mut vms = vmobjs.write().unwrap();
+        vms.insert(zone1.zonedid, zone1);
+        drop(vms);
+
+        let mut writer = vec![];
+        log_events(events, &mut writer, &vmobjs);
+
+        let mut buf = String::new();
+        writer
+            .as_slice()
+            .read_to_string(&mut buf)
+            .expect("failed to read all of the bytes from the writer");
+
+        let lines: Vec<&str> = buf.lines().collect();
+
+        assert_eq!(
+            num_events,
+            lines.len(),
+            "all events were written to the writer"
+        );
+    }
+
+    #[test]
+    fn start_logger_test() {
+        let vmobjs: Vmobjs = Arc::new(ShardedLock::new(HashMap::new()));
+        let logger = start_logger(10, Arc::clone(&vmobjs));
+        assert!(
+            logger.is_none(),
+            "no logger is created for an unknown zonedid",
+        );
+
+        let zone1 = testutils::create_zone();
+        let zonedid = zone1.zonedid;
+        let mut vms = vmobjs.write().unwrap();
+        vms.insert(zone1.zonedid, zone1);
+        drop(vms);
+
+        let logger = start_logger(zonedid, Arc::clone(&vmobjs));
+        assert!(
+            logger.is_some(),
+            "logger is created when we have the correct zone info",
+        );
+    }
+}
diff --git a/cfwlogd/src/main.rs b/cfwlogd/src/main.rs
new file mode 100644
index 0000000..ed4d8a2
--- /dev/null
+++ b/cfwlogd/src/main.rs
@@ -0,0 +1,376 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+//! cfwlogd is a userland daemon that is responsible for translating firewall events into newline
+//! separated json logs.  It does so by attaching to the kernel device found at `/dev/ipfev` and
+//! reading in a buffer of bytes.  Cfwlogd is then responsible for parsing the buffer into cloud
+//! firewall logs that will be serialized out to disk as json in
+//! `/var/log/firewall/<customer>/<vm>/<timestamp>.log`
+//!
+//!
+//!                      cfwlogd's current design
+//!
+//!
+//! gz process 127.0.0.1:9090
+//! +-------------------+
+//! |  vminfod process  |
+//! +-------------------+
+//!         |
+//!         |
+//!         v                Kernel Device
+//!   Vminfod Thread         +------------+
+//! +-----------------+      | /dev/ipfev |
+//! | vminfod watcher |      +------------+
+//! +-----------------+            |
+//!         |                      v
+//!         |                Userland Daemon
+//!         |                  +---------+
+//!         -----------------> | cfwlogd |
+//!                            +---------+
+//!                                |
+//!                                v
+//!                       Processing Threads
+//!                  -----------------------------
+//!                  |             |             |
+//!                +-----+      +-----+      +-----+
+//!                | vm1 |      | vm2 |      | vm3 |
+//!                +-----+      +-----+      +-----+
+//!                  |             |             |
+//!                  v             v             v
+//!              +--------+    +--------+    +--------+
+//!              |vm1.log |    |vm2.log |    |vm3.log |
+//!              +--------+    +--------+    +--------+
+//!
+//!
+//! In summary, cfwlogd must correlate the firewall log events it gets from the kernel with the
+//! appropriate zone information that contains the customer uuid, the vm uuid, and the vm alias.
+//! It does this by spawning a `vminfod` watcher thread that is responsible for tracking vminfod
+//! events as they arrive. Each binary payload from the kernel device contains a `zonedid` which is
+//! a unique id per vm until the box is rebooted; this allows cfwlogd to keep track of what event
+//! is for what vm (zone). Also, because cfwlogd gets vminfod events in real time it is able to
+//! track things like vm alias changes. As events are read from the kernel cfwlogd looks for an
+//! existing logging thread or creates one if it's the first event it has seen for a specific zone.
+//! Each logging thread serializes the internal data structure to json and writes the log to a
+//! `BufWriter` which has its own internal buffer that will flush to disk once full, this is to
+//! cut down on the number of write syscalls cfwlogd has to make.
+
+use crossbeam::channel;
+use crossbeam::sync::ShardedLock;
+use daemonize::Daemonize;
+use illumos_priv::{PrivOp, PrivPtype, PrivSet, Privilege};
+use libc::{c_int, dup};
+
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::fs::OpenOptions;
+use std::io;
+use std::os::unix::ffi::OsStringExt;
+use std::os::unix::io::{AsRawFd, FromRawFd};
+use std::path::PathBuf;
+use std::sync::Arc;
+
+#[macro_use]
+extern crate log;
+
+mod events;
+mod fileutils;
+mod ipf;
+mod logger;
+mod parser;
+mod signal;
+mod zones;
+use events::Loggers;
+use ipf::IpfevDevice;
+use zones::Vmobjs;
+
+const LOG_DIR: &str = "/var/log/firewall";
+
+/// As defined in smf_method(5): method successfully but purposefully leaves no processes remaining
+/// in the contract; it should be treated as if it had a transient service model.
+const SMF_EXIT_NODAEMON: i32 = 94;
+
+/// Dup a File's raw fd or log an error message and exit the process.
+macro_rules! dup_fd {
+    ($file:expr, $err:tt) => {{
+        match dup($file.as_raw_fd()) {
+            -1 => {
+                let e = io::Error::last_os_error();
+                error!("{}: {}", $err, e);
+                std::process::exit(1);
+            }
+            i => i,
+        }
+    }};
+}
+
+/// Dup a File by accessing the underlying raw fd. We dup the underlying fd to be sure that
+/// anything closing the original File doesn't result in EBADF when accessing the new File.
+macro_rules! dup_file {
+    ($file:expr, $err:tt) => {{
+        unsafe { std::fs::File::from_raw_fd(dup_fd!($file, $err)) }
+    }};
+}
+
+/// Set's the daemon's privileges to the basic set plus a few extras that allow us to open the
+/// /dev/ipfev device and chroot ourselves into LOG_DIR
+fn cfwlogd_set_privs() -> io::Result<()> {
+    let set = PrivSet::new_basic()?;
+    // Remove
+    set.delset(Privilege::ProcInfo)?;
+    set.delset(Privilege::ProcSession)?;
+    set.delset(Privilege::FileLinkAny)?;
+    set.delset(Privilege::ProcExec)?;
+    // Add
+    set.addset(Privilege::ProcChroot)?;
+    set.addset(Privilege::ProcSetid)?;
+    set.addset(Privilege::SysNetConfig)?;
+
+    illumos_priv::setppriv(PrivOp::Set, PrivPtype::Permitted, &set)?;
+    Ok(())
+}
+
+/// Drop all the privileges that we no longer need once we are running as a child aka daemon.
+fn cfwlogd_drop_privs() -> io::Result<()> {
+    let set = illumos_priv::getppriv(PrivPtype::Permitted)?;
+    set.delset(Privilege::ProcFork)?;
+    set.delset(Privilege::ProcChroot)?;
+    set.delset(Privilege::ProcSetid)?;
+    set.delset(Privilege::SysNetConfig)?;
+
+    illumos_priv::setppriv(PrivOp::Set, PrivPtype::Permitted, &set)?;
+    Ok(())
+}
+
+/// Fork cfwlogd as a daemon.
+fn cfwlogd_daemonize() {
+    // The "daemonize" crate unfortunately sets stdout/stderr to devnull if you don't specify a
+    // path, so for now we do this dance.
+    let stdout = dup_file!(io::stdout(), "failed to dup stdout");
+    let stderr = dup_file!(io::stderr(), "failed to dup stderr");
+
+    // Drop all groups
+    if unsafe { libc::setgroups(0, std::ptr::null()) } != 0 {
+        let e = io::Error::last_os_error();
+        error!("failed to drop all groups: {}", e);
+        std::process::exit(e.raw_os_error().unwrap_or(1));
+    }
+
+    if let Err(e) = Daemonize::new()
+        .stdout(stdout)
+        .stderr(stderr)
+        .group("daemon")
+        .working_directory(LOG_DIR)
+        .umask(0o022)
+        .start()
+    {
+        error!("failed to daemonize: {}", e);
+        std::process::exit(1);
+    };
+}
+
+/// Process incoming unix signals. Returns `true` if the signal indicates that
+/// we should shutdown the process.
+fn cfwlogd_handle_signals(s: c_int, loggers: &Loggers) -> bool {
+    let mut shutdown = false;
+    match s {
+        // CMON TRITON-1755 -- dump some cmon counters somewhere?
+        libc::SIGUSR1 => info!("SIGUSR1: caught sigusr1"),
+        // Tell the logger threads to flush to disk
+        libc::SIGUSR2 => {
+            info!("SIGUSR2: flushing logs");
+            let loggers = loggers.lock().unwrap();
+            loggers.values().for_each(|logger| {
+                if logger.flush().is_err() {
+                    error!(
+                        "Failed to flush logs for {} because the logger is no \
+                         longer listening on its signal handler",
+                        &logger.uuid
+                    );
+                }
+            });
+        }
+        // Tell logger threads to flush and reopen current.log
+        libc::SIGHUP => {
+            info!(
+                "SIGHUP: log rotation -- flushing currently opened files and \
+                 reopening current.log"
+            );
+            let loggers = loggers.lock().unwrap();
+            loggers.values().for_each(|logger| {
+                if logger.rotate().is_err() {
+                    error!(
+                        "Failed to rotate logs for {} because the logger is no \
+                         longer listening on its signal handler",
+                        &logger.uuid
+                    );
+                }
+            });
+        }
+        // Shutdown
+        libc::SIGINT => {
+            info!("SIGINT: shutting down");
+            shutdown = true;
+        }
+        // Shutdown
+        libc::SIGTERM => {
+            info!("SIGTERM: shutting down");
+            shutdown = true;
+        }
+        // Ignore all other signals in our set
+        val => debug!("ignoring signal: {}", val),
+    }
+    shutdown
+}
+
+/// Chroot into the provided path.
+fn cfwlogd_chroot<P: Into<PathBuf>>(p: P) -> io::Result<()> {
+    let path = p.into();
+    std::fs::create_dir_all(&path)?;
+    let cstring = CString::new(path.into_os_string().into_vec())
+        .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "path contained nuls"))?;
+    unsafe {
+        match libc::chroot(cstring.as_ptr()) {
+            -1 => Err(io::Error::last_os_error()),
+            _ => Ok(()),
+        }
+    }
+}
+
+/// Given a list of zones, iterate through them looking for log files that have incomplete newline
+/// separated json logs. Truncate logs to the first "\n" found from the end of the file seeking
+/// backwards.
+fn validate_log_files(vmobjs: &Vmobjs) {
+    let zones = vmobjs.read().unwrap();
+    for zone in zones.values() {
+        let path: PathBuf = ["/", &zone.owner_uuid, &zone.uuid, "current.log"]
+            .iter()
+            .collect();
+
+        // If the file doesn't yet exist on disk we can skip over it
+        if !path.is_file() {
+            continue;
+        };
+
+        match OpenOptions::new().read(true).write(true).open(&path) {
+            Ok(mut file) => match fileutils::rseek_and_scan(&mut file, 512, b'\n') {
+                Ok(info) => {
+                    // If we find the "\n" we add 1 to the index so that when we truncate the file
+                    // we keep the newline.
+                    let idx = info.index.and_then(|i| Some(i + 1)).unwrap_or(0);
+                    // If idx matches the length of the file we can skip the
+                    // truncation.
+                    if idx == info.length {
+                        continue;
+                    }
+                    if let Err(e) = file.set_len(idx) {
+                        error!("failed to truncate file ({}): {}", &path.display(), e);
+                    } else {
+                        info!(
+                            "truncated {} by {} bytes",
+                            &path.display(),
+                            info.length - idx
+                        );
+                    }
+                }
+                Err(e) => {
+                    error!(
+                        "failed to scan file ({}) for a newline: {}",
+                        &path.display(),
+                        e
+                    );
+                }
+            },
+            Err(e) => error!(
+                "failed to open file ({}) for cleanup: {}",
+                path.display(),
+                e
+            ),
+        }
+    }
+}
+
+fn main() {
+    pretty_env_logger::init();
+
+    // Since we are running as root limit our privileges as early as possible.
+    if let Err(e) = cfwlogd_set_privs() {
+        error!("failed to add extra privileges: {}", e);
+        std::process::exit(e.raw_os_error().unwrap_or(1));
+    }
+    debug!("successfully set new privileges");
+
+    let device = IpfevDevice::new("/dev/ipfev").unwrap_or_else(|e| match e.kind() {
+        // The device was not found but ipfilter is online because the smf dependency
+        // requires it to be up before starting, therefore we are on a platform that
+        // doesn't support ipfev. So we exit with SMF_EXIT_NODAEMON to indicate success
+        // leaving no process running.
+        io::ErrorKind::NotFound => {
+            info!(
+                "/dev/ipfev not present on this system -- \
+                 treating the daemon as a transient service"
+            );
+            std::process::exit(SMF_EXIT_NODAEMON);
+        }
+        // Anything other than NotFound should be treated as a hard error.
+        _ => {
+            error!("failed to open /dev/ipfev: {}", e);
+            std::process::exit(e.raw_os_error().unwrap_or(1));
+        }
+    });
+
+    cfwlogd_daemonize();
+
+    // The vminfod client and signal handler need access to /dev/{u}random so we handle these
+    // things before we chroot into "/var/log/firewall"
+    // TODO make sure the vminfod client is able to be restarted later once we drop privs
+    let vmobjs = Arc::new(ShardedLock::new(HashMap::new()));
+    let _vminfod_handle = zones::start_vminfod(Arc::clone(&vmobjs));
+
+    // This is unbounded so that we don't block in the signal handler
+    let (sig_tx, sig_rx) = channel::unbounded();
+    let _signal_handle = signal::start_signalhandler(sig_tx);
+
+    // Since we are running as root lock ourselves into the LOG_DIR, and then further limit our
+    // privileges.
+    if let Err(e) = cfwlogd_chroot(LOG_DIR) {
+        error!("failed to chroot into {}: {}", LOG_DIR, e);
+        std::process::exit(e.raw_os_error().unwrap_or(1));
+    }
+    if let Err(e) = cfwlogd_drop_privs() {
+        error!("failed to drop privileges: {}", e);
+        std::process::exit(e.raw_os_error().unwrap_or(1));
+    }
+    debug!("successfully dropped privileges");
+
+    validate_log_files(&vmobjs);
+
+    // Setup our processing pipeline
+    let (shutdown_tx, shutdown_rx) = channel::bounded(1);
+    let (ipf_events, _ipf_handle) = events::start_event_reader(device);
+    let (loggers, fanout_handle) =
+        events::start_event_fanout(ipf_events, shutdown_rx, Arc::clone(&vmobjs));
+
+    // Handle signals until we are told to exit
+    for sig in sig_rx.iter() {
+        if cfwlogd_handle_signals(sig, &loggers) {
+            break;
+        };
+    }
+
+    // Wait for the event processor to drain all queued events into its loggers
+    shutdown_tx.send(()).unwrap();
+    fanout_handle.join().unwrap();
+
+    // Wait for loggers to finish flushing to disk
+    let mut loggers = loggers.lock().unwrap();
+    for (zonedid, logger) in loggers.drain() {
+        info!(
+            "shutting down logging thread for {} ({})",
+            logger.uuid, zonedid
+        );
+        logger.shutdown().unwrap();
+    }
+}
diff --git a/cfwlogd/src/parser.rs b/cfwlogd/src/parser.rs
new file mode 100644
index 0000000..cb270e3
--- /dev/null
+++ b/cfwlogd/src/parser.rs
@@ -0,0 +1,328 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use std::net::Ipv6Addr;
+
+use chrono::{DateTime, TimeZone, Utc};
+use nom::bytes::complete::take;
+use nom::error::VerboseError;
+use nom::number::complete::{be_u128, be_u16, le_i64, le_u16, le_u32, le_u8};
+use nom::IResult;
+use serde::Serialize;
+use uuid::Uuid;
+
+#[derive(Debug, PartialEq, Serialize)]
+#[serde(rename_all = "lowercase")]
+pub enum CfwEvType {
+    Block,
+    Begin,
+    End,
+    Unknown, // Catch all (perhaps the kernel version is ahead of userland?)
+}
+
+impl From<u16> for CfwEvType {
+    fn from(val: u16) -> CfwEvType {
+        match val {
+            1 => CfwEvType::Block,
+            2 => CfwEvType::Begin,
+            3 => CfwEvType::End,
+            _ => CfwEvType::Unknown,
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Serialize)]
+#[serde(rename_all = "lowercase")]
+pub enum Direction {
+    In,
+    Out,
+}
+
+impl From<u8> for Direction {
+    fn from(val: u8) -> Direction {
+        match val {
+            1 => Direction::In,
+            2 => Direction::Out,
+            // This should never happen
+            _ => panic!("unknown direction: {}", val),
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Serialize)]
+pub enum Protocol {
+    AH,
+    ESP,
+    ICMP,
+    ICMPV6,
+    TCP,
+    UDP,
+    UNKNOWN,
+}
+
+impl From<u8> for Protocol {
+    fn from(val: u8) -> Protocol {
+        match val {
+            1 => Protocol::ICMP,
+            6 => Protocol::TCP,
+            17 => Protocol::UDP,
+            50 => Protocol::ESP,
+            51 => Protocol::AH,
+            58 => Protocol::ICMPV6,
+            // catch all in case fwadm ever supports additional protocols
+            _ => Protocol::UNKNOWN,
+        }
+    }
+}
+
+#[derive(Debug, Serialize, PartialEq)]
+#[serde(untagged)]
+pub enum CfwEvent {
+    Traffic(TrafficEvent),
+    Unknown(UnknownEvent),
+}
+
+impl CfwEvent {
+    pub fn zone(&self) -> u32 {
+        match &*self {
+            CfwEvent::Traffic(event) => event.zonedid,
+            CfwEvent::Unknown(event) => event.zonedid,
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Serialize)]
+pub struct UnknownEvent {
+    pub event: CfwEvType,
+    #[serde(skip)]
+    pub raw_event: u16,
+    #[serde(skip)]
+    pub length: u16,
+    #[serde(skip)]
+    pub zonedid: u32,
+}
+
+#[derive(Debug, PartialEq, Serialize)]
+pub struct TrafficEvent {
+    pub event: CfwEvType,
+    #[serde(skip)]
+    pub length: u16,
+    #[serde(skip)]
+    pub zonedid: u32,
+    #[serde(skip)]
+    pub rule_id: u32,
+    pub source_port: u16,
+    pub destination_port: u16,
+    pub protocol: Protocol,
+    pub direction: Direction,
+    pub source_ip: Ipv6Addr,
+    pub destination_ip: Ipv6Addr,
+    pub timestamp: DateTime<Utc>,
+    #[serde(rename = "rule")]
+    pub rule_uuid: Uuid,
+}
+
+type CfwEventHeader = (u16, u16, u32);
+
+/// Read the common bytes of all events, aka event type, length, and zonedid.
+fn cfwevent_parse_header<'a>(
+    bytes: &'a [u8],
+) -> IResult<&'a [u8], CfwEventHeader, VerboseError<&'a [u8]>> {
+    let (bytes, event) = le_u16(bytes)?;
+    let (bytes, length) = le_u16(bytes)?;
+    let (bytes, zonedid) = le_u32(bytes)?;
+    Ok((bytes, (event, length, zonedid)))
+}
+
+/// Parse an UnknownEvent type variant so that we can skip past the associated bytes.
+fn cfwevent_parse_unknown<'a>(
+    header: CfwEventHeader,
+    bytes: &'a [u8],
+) -> IResult<&'a [u8], CfwEvent, VerboseError<&'a [u8]>> {
+    // Take everything after the first 8 bytes (event + length + zonedid).
+    let (bytes, _skip) = take(header.1 - 8)(bytes)?;
+    Ok((
+        bytes,
+        CfwEvent::Unknown(UnknownEvent {
+            event: CfwEvType::Unknown,
+            raw_event: header.0,
+            length: header.1,
+            zonedid: header.2,
+        }),
+    ))
+}
+
+/// Parse an TrafficEvent type variant that was generated due to a firewall rule match.
+fn cfwevent_parse_traffic<'a>(
+    evtype: CfwEvType,
+    header: CfwEventHeader,
+    bytes: &'a [u8],
+) -> IResult<&'a [u8], CfwEvent, VerboseError<&'a [u8]>> {
+    let (bytes, rule_id) = le_u32(bytes)?;
+    let (bytes, source_port) = be_u16(bytes)?;
+    let (bytes, destination_port) = be_u16(bytes)?;
+    let (bytes, protocol) = le_u8(bytes)?;
+    let (bytes, direction) = le_u8(bytes)?;
+    let (bytes, _padding) = take(6usize)(bytes)?;
+    let (bytes, source_ip) = be_u128(bytes)?;
+    let (bytes, destination_ip) = be_u128(bytes)?;
+    let (bytes, time_sec) = le_i64(bytes)?;
+    let (bytes, time_usec) = le_i64(bytes)?;
+    let (bytes, rule_uuid) = take(16usize)(bytes)?;
+    Ok((
+        bytes,
+        CfwEvent::Traffic(TrafficEvent {
+            event: evtype,
+            length: header.1,
+            zonedid: header.2,
+            rule_id,
+            protocol: Protocol::from(protocol),
+            direction: Direction::from(direction),
+            source_port,
+            destination_port,
+            source_ip: Ipv6Addr::from(source_ip),
+            destination_ip: Ipv6Addr::from(destination_ip),
+            timestamp: Utc.timestamp(time_sec, (time_usec * 1000) as u32),
+            rule_uuid: Uuid::from_slice(rule_uuid).expect("we should have 16 bytes exactly"),
+        }),
+    ))
+}
+
+/// Parse a single CfwEvent out of the provided bytes returning a slice that points at the next
+/// event.
+pub fn cfwevent_parse<'a>(bytes: &'a [u8]) -> IResult<&'a [u8], CfwEvent, VerboseError<&'a [u8]>> {
+    let (bytes, header) = cfwevent_parse_header(bytes)?;
+    let event_type = CfwEvType::from(header.0);
+    match event_type {
+        CfwEvType::Unknown => cfwevent_parse_unknown(header, bytes),
+        _ => cfwevent_parse_traffic(event_type, header, bytes),
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn parse_traffic_event() {
+        let mut event = testutils::generate_event();
+        std::dbg!(&event);
+        let now = chrono::offset::Utc::now();
+        let ts = Utc.timestamp(now.timestamp(), now.timestamp_subsec_micros() * 1000);
+        let uuid = Uuid::parse_str("a7963143-14da-48d6-bef0-422f305d1556").unwrap();
+
+        // customize some values in the generated event
+        event.time_sec = ts.timestamp();
+        event.time_usec = ts.timestamp_subsec_micros() as i64;
+        event.rule_uuid = uuid.as_bytes().clone();
+
+        let bytes = event.as_bytes();
+        let cfw_event = cfwevent_parse(bytes);
+
+        // parsed successfully
+        assert!(cfw_event.is_ok());
+        let cfw_event = cfw_event.unwrap();
+
+        assert!(cfw_event.0.is_empty(), "no bytes left over");
+        match cfw_event.1 {
+            CfwEvent::Traffic(e) => {
+                assert_eq!(e.event, CfwEvType::from(event.event));
+                assert_eq!(e.length, event.length);
+                assert_eq!(e.zonedid, event.zonedid);
+                assert_eq!(e.rule_id, event.rule_id);
+                assert_eq!(e.protocol, Protocol::from(event.protocol));
+                assert_eq!(e.direction, Direction::from(event.direction));
+                assert_eq!(e.source_port, u16::from_be(event.source_port));
+                assert_eq!(e.destination_port, u16::from_be(event.destination_port));
+                assert_eq!(e.source_ip, Ipv6Addr::from(u128::from_be(event.source_ip)));
+                assert_eq!(
+                    e.destination_ip,
+                    Ipv6Addr::from(u128::from_be(event.destination_ip))
+                );
+                assert_eq!(e.timestamp, ts);
+                assert_eq!(e.rule_uuid, uuid);
+            }
+            _ => panic!("unexpected CfwEvType"),
+        }
+    }
+
+    #[test]
+    fn parse_unknown_event() {
+        let event = testutils::generate_unknown_event();
+        let bytes = event.as_bytes();
+        let cfw_event = cfwevent_parse(bytes);
+
+        // parsed successfully
+        assert!(cfw_event.is_ok());
+        let cfw_event = cfw_event.unwrap();
+
+        assert!(cfw_event.0.is_empty(), "no bytes left over");
+        match cfw_event.1 {
+            CfwEvent::Unknown(e) => {
+                assert_eq!(e.event, CfwEvType::from(event.event));
+                assert_eq!(e.length, event.length);
+                assert_eq!(e.zonedid, event.zonedid);
+            }
+            _ => panic!("unexpected CfwEvType"),
+        }
+    }
+
+    #[test]
+    fn parse_mixed_events() {
+        let event = testutils::generate_event();
+        let tbytes = event.as_bytes();
+
+        let uevent = testutils::generate_unknown_event();
+        let ubytes = uevent.as_bytes();
+
+        let mut mixed = vec![];
+        mixed.extend_from_slice(&tbytes);
+        mixed.extend_from_slice(&ubytes);
+        mixed.extend_from_slice(&ubytes);
+        mixed.extend_from_slice(&tbytes);
+        mixed.extend_from_slice(&tbytes);
+
+        let mut count = 0;
+        let mut traffic_count = 0;
+        let mut unknown_count = 0;
+        let mut bytes: &[u8] = &mixed;
+        loop {
+            let (leftover, event) = cfwevent_parse(bytes).expect("failed to parse CfwEvents");
+            match event {
+                CfwEvent::Traffic(_) => traffic_count += 1,
+                CfwEvent::Unknown(_) => unknown_count += 1,
+            };
+            bytes = leftover;
+            count += 1;
+            if bytes.is_empty() {
+                break;
+            };
+        }
+
+        assert_eq!(5, count, "saw exactly 5 events");
+        assert_eq!(3, traffic_count, "saw exactly 3 traffic events");
+        assert_eq!(2, unknown_count, "saw exactly 2 unknown events");
+    }
+
+    #[test]
+    #[should_panic]
+    fn garbage_data_fails_to_parse() {
+        // Try to pass in 100 bytes of random garbage to the parser
+        let random_bytes: Vec<u8> = std::iter::repeat_with(|| rand::random::<u8>())
+            .take(100)
+            .collect();
+        let (_leftover, _event) = cfwevent_parse(&random_bytes).unwrap();
+    }
+
+    #[test]
+    #[should_panic]
+    fn not_enough_bytes_fails_to_parse() {
+        let mut short = testutils::generate_unknown_event();
+        // Today the "sizeof (cfwev_t)" = 88 bytes, so pick something decently bigger
+        short.length = 1000;
+        let (_leftover, _event) = cfwevent_parse(short.as_bytes()).unwrap();
+    }
+}
diff --git a/cfwlogd/src/signal.rs b/cfwlogd/src/signal.rs
new file mode 100644
index 0000000..9c50e29
--- /dev/null
+++ b/cfwlogd/src/signal.rs
@@ -0,0 +1,44 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use crossbeam::channel::Sender;
+use libc::c_int;
+use std::sync::{Arc, Barrier};
+use std::thread;
+
+fn signal_handler(tx: Sender<c_int>, b: Arc<Barrier>) {
+    let signals = signal_hook::iterator::Signals::new(&[
+        libc::SIGHUP,
+        libc::SIGINT,
+        libc::SIGTERM,
+        libc::SIGUSR1,
+        libc::SIGUSR2,
+    ])
+    .expect("unable to create signal handler");
+
+    // signal handler has started
+    b.wait();
+
+    for signal in signals.forever() {
+        if tx.send(signal).is_err() {
+            trace!("receive half of signal handler channel is disconnected");
+            break;
+        }
+    }
+}
+
+pub fn start_signalhandler(tx: Sender<c_int>) -> thread::JoinHandle<()> {
+    let b = Arc::new(Barrier::new(2));
+    let b2 = Arc::clone(&b);
+    let handle = thread::Builder::new()
+        .name("signal_handler".to_owned())
+        .spawn(move || signal_handler(tx, b2))
+        .expect("failed to spawn signal watcher thread");
+
+    // Block until the signal handler is setup
+    b.wait();
+    handle
+}
diff --git a/cfwlogd/src/zones.rs b/cfwlogd/src/zones.rs
new file mode 100644
index 0000000..81211ee
--- /dev/null
+++ b/cfwlogd/src/zones.rs
@@ -0,0 +1,90 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use std::collections::HashMap;
+use std::sync::{Arc, Barrier};
+use std::thread;
+
+use crossbeam::sync::ShardedLock;
+use vminfod_client::{Changes, VminfodEvent, Zone};
+
+pub type Vmobjs = Arc<ShardedLock<HashMap<Zonedid, Zone>>>;
+pub type Zonedid = u32;
+
+/// Inserts or updates an existing vmobj into a given `Vmobjs`
+fn insert_vmobj(zone: Zone, vmobjs: &Vmobjs) {
+    let mut w = vmobjs.write().unwrap();
+    w.insert(zone.zonedid, zone);
+}
+
+/// Search through a vminfod changes payload and see if the alias was a part of the update
+fn alias_changed(changes: &[Changes]) -> bool {
+    changes.iter().any(|change| {
+        dbg!(change.path.first().map(|v| v.as_ref()));
+        change
+            .path
+            .first()
+            // double map_or because path is a `Vec<Option<String>>`
+            .map_or(false, |v| v.as_ref().map_or(false, |a| a == "alias"))
+    })
+}
+
+/// Start a vminfod watcher thread that will keep a `Vmobjs` object up-to-date.
+/// This function will block until the spawned thread has processed the `Ready` event from vminfod
+pub fn start_vminfod(vmobjs: Vmobjs) -> thread::JoinHandle<()> {
+    let version = env!("CARGO_PKG_VERSION");
+    let b = Arc::new(Barrier::new(2));
+    let b2 = Arc::clone(&b);
+    let handle = thread::Builder::new()
+        .name("vminfod_event_processor".to_owned())
+        .spawn(move || {
+            info!("starting vminfod thread");
+            let mut init = true;
+            let (r, _) = vminfod_client::start_vminfod_stream(version);
+            for event in r.iter() {
+                match event {
+                    VminfodEvent::Ready(event) => {
+                        let raw_vms = event.vms;
+                        let vms: Vec<Zone> = serde_json::from_str(&raw_vms)
+                            .expect("failed to parse vms payload from vminfod");
+                        let mut w = vmobjs.write().unwrap();
+                        for vm in vms {
+                            w.insert(vm.zonedid, vm);
+                        }
+                        debug!("vminfod ready event processed");
+                        // Barriers reset after wait is called n times. Since this thread won't be
+                        // spawned multiple times we should only call wait on the barrier during
+                        // initialization.
+                        if init {
+                            b2.wait();
+                            init = false;
+                        }
+                    }
+                    VminfodEvent::Create(event) => insert_vmobj(event.vm, &vmobjs),
+                    VminfodEvent::Modify(event) => {
+                        if alias_changed(&event.changes) {
+                            debug!(
+                                "alias changed for {} ({}), updating vmobj mapping",
+                                &event.vm.uuid, &event.vm.zonedid
+                            );
+                            insert_vmobj(event.vm, &vmobjs);
+                        }
+                    }
+                    // Nothing to be done with deletes currently. We don't modify `Vmobjs` since
+                    // cfw event logs in various processing queues may not have made it to disk
+                    // yet. We may eventually want to signal a logger that it's okay to shutdown.
+                    VminfodEvent::Delete(_) => (),
+                }
+            }
+            // TODO TRITON-1754: implement retry logic here, until then just panic
+            panic!("vminfod event stream closed");
+        })
+        .expect("vminfod client thread spawn failed.");
+
+    // Block until we process the very first "Ready" event from vminfod
+    b.wait();
+    handle
+}
diff --git a/deps/eng b/deps/eng
new file mode 160000
index 0000000..940d8fb
--- /dev/null
+++ b/deps/eng
@@ -0,0 +1 @@
+Subproject commit 940d8fbbef6f4d0e6a9e45409fc4646eda8255e8
diff --git a/manifest.tmpl b/manifest.tmpl
new file mode 100644
index 0000000..665d7b9
--- /dev/null
+++ b/manifest.tmpl
@@ -0,0 +1,27 @@
+{
+  "v": 2,
+  "uuid": "UUID",
+  "owner": "00000000-0000-0000-0000-000000000000",
+  "name": "NAME",
+  "version": "VERSION",
+  "state": "active",
+  "disabled": false,
+  "public": false,
+  "type": "other",
+  "os": "other",
+  "files": [
+    {
+      "sha1": "SHA",
+      "size": SIZE,
+      "compression": "gzip"
+    }
+  ],
+  "description": "DESCRIPTION",
+  "tags": {
+    "smartdc_service": "true",
+    "buildstamp": "BUILDSTAMP"
+  },
+  "channels": [
+    "dev"
+  ]
+}
diff --git a/npm/lib/error_handler.sh b/npm/lib/error_handler.sh
new file mode 100755
index 0000000..c7da4e8
--- /dev/null
+++ b/npm/lib/error_handler.sh
@@ -0,0 +1,73 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+function stack_trace
+{
+    set +o xtrace
+
+    (( cnt = ${#FUNCNAME[@]} ))
+    (( i = 0 ))
+    while (( i < cnt )); do
+        printf '  [%3d] %s\n' "${i}" "${FUNCNAME[i]}"
+        if (( i > 0 )); then
+            line="${BASH_LINENO[$((i - 1))]}"
+        else
+            line="${LINENO}"
+        fi
+        printf '        (file "%s" line %d)\n' "${BASH_SOURCE[i]}" "${line}"
+        (( i++ ))
+    done
+}
+
+function fatal
+{
+    # Disable error traps from here on:
+    set +o xtrace
+    set +o errexit
+    set +o errtrace
+    set +o nounset
+    trap '' ERR
+
+    local fmt="$1"
+    shift
+
+    printf "ERROR: $(basename $0): ${fmt}\n" "$@" >&2
+    stack_trace
+    exit 1
+}
+
+function trap_err
+{
+    st=$?
+    set +o nounset
+    fatal 'exit status %d at line %d' ${st} ${BASH_LINENO[0]}
+}
+
+#
+# We set errexit (a.k.a. "set -e") to force an exit on error conditions, but
+# there are many important error conditions that this does not capture --
+# first among them failures within a pipeline (only the exit status of the
+# final stage is propagated).  To exit on these failures, we also set
+# "pipefail" (a very useful option introduced to bash as of version 3 that
+# propagates any non-zero exit values in a pipeline).
+#
+set -o errexit
+set -o pipefail
+
+shopt -s extglob
+
+#
+# Install our error handling trap, so that we can have stack traces on
+# failures.  We set "errtrace" so that the ERR trap handler is inherited
+# by each function call.
+#
+trap trap_err ERR
+set -o errtrace
diff --git a/npm/lib/trace_logger.sh b/npm/lib/trace_logger.sh
new file mode 100755
index 0000000..8a8ad59
--- /dev/null
+++ b/npm/lib/trace_logger.sh
@@ -0,0 +1,36 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# If TRACE is set in the environment, enable xtrace.  Additionally,
+# assuming the current shell is bash version 4.1 or later, more advanced
+# tracing output will be emitted and some additional features may be used:
+#
+#   TRACE_LOG   Send xtrace output to this file instead of stderr.
+#   TRACE_FD    Send xtrace output to this fd instead of stderr.
+#               The file descriptor must be open before the shell
+#               script is started.
+#
+if [[ -n ${TRACE} ]]; then
+    if [[ ${BASH_VERSINFO[0]} -ge 4 && ${BASH_VERSINFO[1]} -ge 1 ]]; then
+        PS4=
+        PS4="${PS4}"'[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: '
+        PS4="${PS4}"'${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+        export PS4
+        if [[ -n ${TRACE_LOG} ]]; then
+            exec 4>>${TRACE_LOG}
+            export BASH_XTRACEFD=4
+        elif [[ -n ${TRACE_FD} ]]; then
+            export BASH_XTRACEFD=${TRACE_FD}
+        fi
+    fi
+    set -o xtrace
+fi
diff --git a/npm/postinstall.sh b/npm/postinstall.sh
new file mode 100755
index 0000000..f13a1c7
--- /dev/null
+++ b/npm/postinstall.sh
@@ -0,0 +1,273 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
+    printf 'Running during package build; skipping lifecycle script.\n' >&2
+    exit 0
+fi
+
+#
+# We must load the SDC configuration before setting any strict error handling
+# options.
+#
+. /lib/sdc/config.sh
+load_sdc_config
+
+ROOT="$(cd `dirname $0`/../ 2>/dev/null && pwd)"
+
+. "${ROOT}/npm/lib/error_handler.sh"
+. "${ROOT}/npm/lib/trace_logger.sh"
+
+set -o nounset
+
+export PREFIX="$npm_config_prefix"
+export ETC_DIR="$npm_config_etc"
+export SMF_DIR="$npm_config_smfdir"
+export VERSION="$npm_package_version"
+export ENABLED="true"
+
+AGENT="$npm_package_name"
+
+BOOTPARAMS=/usr/bin/bootparams
+AWK=/usr/bin/awk
+
+
+# ---- support functions
+
+#
+# Replace various substitution tokens in the input file, and write the result
+# into the output file.
+#
+function subfile
+{
+    local infile="$1"
+    local outfile="$2"
+
+    if [[ -z "${infile}" || -z "${outfile}" ]]; then
+        fatal 'subfile requires two arguments'
+    fi
+
+    if ! sed -e "s#@@PREFIX@@#$PREFIX#g" \
+      -e "s/@@VERSION@@/$VERSION/g" \
+      -e "s#@@ROOT@@#$ROOT#g" \
+      -e "s/@@ENABLED@@/$ENABLED/g" \
+      "${infile}" > "${outfile}"; then
+        fatal 'sed failure ("%s" -> "%s")' "${infile}" "${outfile}"
+    fi
+}
+
+#
+# Replace substitution tokens in the SMF manifest files, and then import the SMF
+# services.
+#
+function import_smf_manifest
+{
+    local agent_manifest_in="$ROOT/smf/manifests/$AGENT.xml.in"
+    local agent_manifest_out="$SMF_DIR/$AGENT.xml"
+    local agent_setup_manifest_in="$ROOT/smf/manifests/${AGENT}-setup.xml.in"
+    local agent_setup_manifest_out="$SMF_DIR/${AGENT}-setup.xml"
+
+    if [[ ! -f "${agent_manifest_in}" ]]; then
+        fatal 'could not find smf manifest input file: %s' \
+            "${agent_manifest_in}"
+    fi
+
+    if [[ ! -f "${agent_setup_manifest_in}" ]]; then
+        fatal 'could not find smf manifest input file: %s'
+        "${agent_setup_manifest_in}"
+    fi
+
+    if ! subfile "${agent_manifest_in}" "${agent_manifest_out}" ||
+      ! svccfg import "${agent_manifest_out}"; then
+        fatal 'could not process smf manifest (%s)' "${agent_manifest_in}"
+    fi
+
+    if ! subfile "${agent_setup_manifest_in}" "${agent_setup_manifest_out}" ||
+      ! svccfg import "${agent_setup_manifest_out}"; then
+        fatal 'could not process smf manifest (%s)' "${agent_setup_manifest_in}"
+    fi
+}
+
+#
+# Each installation of an agent is represented by a SAPI instance of the SAPI
+# service for that agent.  These UUIDs are persistent, so that upgrades do not
+# induce the generation of a new UUID.  If a UUID has not yet been written to
+# disk, we generate one now.  Otherwise, the existing UUID is read and
+# returned.
+#
+function get_or_create_instance_uuid
+{
+    local uuid_file="${ETC_DIR}/${AGENT}"
+    local uuid
+
+    if [[ -z "${ETC_DIR}" || -z "${AGENT}" ]]; then
+        fatal 'ETC_DIR and AGENT must be set'
+    fi
+
+    if [[ ! -f "${uuid_file}" ]]; then
+        #
+        # The instance UUID file does not exist.  Create one.
+        #
+        printf 'New agent instance.  Generating new UUID.\n' >&2
+        if ! /usr/bin/uuid -v4 >"${uuid_file}"; then
+            fatal 'could not write new UUID to "%s"' "${uuid_file}"
+        fi
+    fi
+
+    if ! uuid="$(<${uuid_file})" || [[ -z "${uuid}" ]]; then
+            fatal 'could not read UUID from "%s"' "${uuid_file}"
+    fi
+
+    printf 'Agent UUID: %s\n' "${uuid}" >&2
+    printf '%s' "${uuid}"
+    return 0
+}
+
+function adopt_instance
+{
+    local instance_uuid=$1
+    local service_uuid
+    local retry=10
+    local url
+    local data
+
+    if [[ -z "${instance_uuid}" ]]; then
+        fatal 'must pass instance_uuid'
+    fi
+
+    while (( retry-- > 0 )); do
+        #
+        # Fetch the UUID of the SAPI service for this agent.
+        #
+        url="${SAPI_URL}/services?type=agent&name=${AGENT}"
+        if ! service_uuid="$(curl -sSf -H 'Accept: application/json' "${url}" \
+          | json -Ha uuid)"; then
+            printf 'Could not retrieve SAPI service UUID for "%s"\n' \
+              "${AGENT}" >&2
+            sleep 5
+            continue
+        fi
+
+        #
+        # Attempt to register the SAPI instance for this agent installation.
+        # We need not be overly clever here; SAPI returns success for a
+        # duplicate agent adoption.
+        #
+        url="${SAPI_URL}/instances"
+        data="{
+            \"service_uuid\": \"${service_uuid}\",
+            \"uuid\": \"${instance_uuid}\"
+        }"
+        if ! curl -sSf -X POST -H 'Content-Type: application/json' \
+          -d "${data}" "${url}"; then
+            printf 'Could not register SAPI instance with UUID "%s"\n' \
+              "${instance_uuid}" >&2
+            sleep 5
+            continue
+        fi
+
+        printf 'Agent successfully adopted into SAPI.\n' >&2
+        return 0
+    done
+
+    fatal 'adopt_instance: failing after too many retries'
+}
+
+#
+# Check if we expect SAPI to be available.  Generally, registering with SAPI is
+# a hard requirement for the correct functioning of the system, but this
+# postinstall script can also be run during headnode setup; SAPI is not yet
+# available at that point.
+#
+function sapi_should_be_available
+{
+    local headnode
+    local script
+    local setup_complete
+
+    #
+    # In the event that SAPI is unavailable, we allow the operator to force us
+    # not to register with SAPI.  This behaviour should NOT be exercised
+    # programatically; it exists purely to allow operators to attempt
+    # (manually) to correct in the face of an abject failure of the system.
+    #
+    if [[ "${NO_SAPI:-false}" = true ]]; then
+        printf 'NO_SAPI=true in environment.\n' >&2
+        return 1
+    fi
+
+    script='
+        $1 == "headnode" {
+            print $2;
+            exit 0;
+        }
+    '
+    if ! headnode=$(${BOOTPARAMS} | ${AWK} -F= "${script}"); then
+        fatal 'could not read bootparams'
+    fi
+
+    if [[ "${headnode}" != 'true' ]]; then
+        #
+        # This is a compute node.  SAPI is expected to be available, and
+        # registration is expected to work.
+        #
+        printf 'This is not the headnode.\n' >&2
+        return 0
+    fi
+
+    #
+    # This is the headnode.  If setup has not yet been completed, then SAPI
+    # is not yet available.
+    #
+    if [[ ! -f '/var/lib/setup.json' ]]; then
+        fatal 'could not find setup state file: "/var/lib/setup.json"'
+    fi
+    if ! setup_complete=$(json -f '/var/lib/setup.json' 'complete'); then
+        fatal 'could not read "complete" from "/var/lib/setup.json"'
+    fi
+
+    if [[ "${setup_complete}" = true ]]; then
+        #
+        # Setup is complete.  SAPI is available.  Registration is expected
+        # to work.
+        #
+        printf 'This is the headnode, and setup is already complete.\n' >&2
+        return 0
+    fi
+
+    #
+    # Setup is not yet complete.  The headnode setup process will register
+    # this SAPI instance at the appropriate time.
+    #
+    printf 'This is the headnode, but setup is not yet complete.\n' >&2
+    return 1
+}
+
+
+# ---- mainline
+
+if [[ -z "${CONFIG_sapi_domain}" ]]; then
+    fatal '"sapi_domain" was not found in "node.config".'
+fi
+SAPI_URL="http://${CONFIG_sapi_domain}"
+
+import_smf_manifest
+
+INSTANCE_UUID="$(get_or_create_instance_uuid)"
+
+if sapi_should_be_available; then
+    printf 'SAPI expected to be available.  Adopting agent instance.\n' >&2
+    adopt_instance "${INSTANCE_UUID}"
+else
+    printf 'SAPI not yet available.  Skipping agent registration.\n' >&2
+fi
+
+exit 0
diff --git a/npm/postuninstall.sh b/npm/postuninstall.sh
new file mode 100755
index 0000000..dd8c3a3
--- /dev/null
+++ b/npm/postuninstall.sh
@@ -0,0 +1,33 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
+    printf 'Running during package build; skipping lifecycle script.\n' >&2
+    exit 0
+fi
+
+ROOT="$(cd `dirname $0`/../ 2>/dev/null && pwd)"
+
+. "${ROOT}/npm/lib/error_handler.sh"
+. "${ROOT}/npm/lib/trace_logger.sh"
+
+set -o nounset
+
+export SMF_DIR="${npm_config_smfdir}"
+
+AGENT="${npm_package_name}"
+
+if svcs "${AGENT}"; then
+    svcadm disable -s "${AGENT}"
+    svccfg delete "${AGENT}"
+fi
+
+rm -f "${SMF_DIR}/${AGENT}.xml"
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..e88de48
--- /dev/null
+++ b/package.json
@@ -0,0 +1,16 @@
+{
+  "name": "firewall-logger-agent",
+  "description": "Triton Firewall Logger Agent",
+  "version": "1.0.0",
+  "author": "Joyent (joyent.com)",
+  "private": true,
+  "dependencies": {
+  },
+  "devDependencies": {
+  },
+  "scripts": {
+    "postinstall": "./npm/postinstall.sh",
+    "postuninstall": "./npm/postuninstall.sh"
+  },
+  "license": "MPL-2.0"
+}
diff --git a/smf/manifests/firewall-logger-agent-setup.xml.in b/smf/manifests/firewall-logger-agent-setup.xml.in
new file mode 100644
index 0000000..880de7e
--- /dev/null
+++ b/smf/manifests/firewall-logger-agent-setup.xml.in
@@ -0,0 +1,55 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="firewall-logger-agent-setup">
+  <service name="smartdc/agent/firewall-logger-agent-setup" type="service" version="@@VERSION@@">
+
+    <create_default_instance enabled="@@ENABLED@@"/>
+    <single_instance/>
+
+    <dependency name="network" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/milestone/network:default"/>
+    </dependency>
+
+    <exec_method
+      type="method"
+      name="start"
+      exec="@@ROOT@@/smf/method/firewall-logger-agent-setup %m"
+      timeout_seconds="600">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+        <method_environment>
+          <envvar name="PATH" value="/usr/bin:/usr/sbin"/>
+        </method_environment>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="stop" exec=":true" timeout_seconds="60" />
+
+    <property_group name="startd" type="framework">
+      <propval name="duration" type="astring" value="transient" />
+      <propval name="ignore_error" type="astring" value="core,signal" />
+    </property_group>
+
+    <property_group name="application" type="application">
+    </property_group>
+
+    <stability value="Evolving"/>
+
+    <template>
+      <common_name>
+        <loctext xml:lang="C">Triton Firewall Logger Agent Setup</loctext>
+      </common_name>
+    </template>
+
+  </service>
+</service_bundle>
diff --git a/smf/manifests/firewall-logger-agent.xml.in b/smf/manifests/firewall-logger-agent.xml.in
new file mode 100644
index 0000000..19d90af
--- /dev/null
+++ b/smf/manifests/firewall-logger-agent.xml.in
@@ -0,0 +1,73 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="firewall-logger-agent">
+  <service name="smartdc/agent/firewall-logger-agent" type="service" version="@@VERSION@@">
+
+    <create_default_instance enabled="@@ENABLED@@"/>
+    <single_instance/>
+
+    <dependency name="network" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/milestone/network:default"/>
+    </dependency>
+
+    <dependency name="filesystem" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/system/filesystem/local"/>
+    </dependency>
+
+    <dependency name="ipfilter" grouping="require_all" restart_on="none" type="service">
+      <service_fmri value="svc:/network/ipfilter:default"/>
+    </dependency>
+
+    <dependency name="vminfod" grouping="require_all" restart_on="none" type="service">
+      <service_fmri value="svc:/system/smartdc/vminfod:default"/>
+    </dependency>
+
+    <exec_method
+      type="method"
+      name="start"
+      exec="@@ROOT@@/bin/cfwlogd"
+      timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+        <method_environment>
+          <envvar name="PATH" value="@@PREFIX@@/bin:/usr/bin:/usr/sbin"/>
+          <envvar name='UMEM_OPTIONS' value='perthread_cache=64M'/>
+          <envvar name='RUST_BACKTRACE' value='full'/>
+          <envvar name='RUST_LOG' value='cfwlogd=debug,vminfod=error'/>
+        </method_environment>
+      </method_context>
+    </exec_method>
+
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+
+    <property_group name="startd" type="framework">
+      <propval name="ignore_error" type="astring" value="core,signal"/>
+    </property_group>
+
+    <property_group name="application" type="application">
+    </property_group>
+
+    <stability value="Evolving"/>
+
+    <template>
+      <common_name>
+        <loctext xml:lang="C">Triton Firewall Logger Agent</loctext>
+      </common_name>
+    </template>
+
+  </service>
+</service_bundle>
diff --git a/smf/method/firewall-logger-agent-setup b/smf/method/firewall-logger-agent-setup
new file mode 100755
index 0000000..03bf37f
--- /dev/null
+++ b/smf/method/firewall-logger-agent-setup
@@ -0,0 +1,52 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Runs on node (CN + HN) boot to setup log rotation for firewall-logger agent logs.
+#
+
+set -o xtrace
+
+. /lib/svc/share/smf_include.sh
+. /lib/sdc/config.sh
+
+
+function setup_logadm {
+    # firewall-logger-agent logadm configuration:
+    logadm -v -w firewall_logger_logs -C 168 -S 1g -c -p 1h \
+        -t '/var/log/firewall-logger-agent/firewall-logger-agent_$nodename_%FT%H:%M:%S.log' \
+        /var/svc/log/*firewall-logger-agent*.log
+
+    # Move the smf_logs entry to run last (after the entries we just added) so
+    # that the default '-C' (from
+    # https://github.com/joyent/smartos-live/blob/master/overlay/generic/etc/logadm.conf)
+    # doesn't defeat our attempts to rotate out of "/var/svc/log".
+    /usr/sbin/logadm -v -r smf_logs
+    /usr/sbin/logadm -v -w smf_logs -C 8 -c -s 1m '/var/svc/log/*.log'
+}
+
+
+case "$1" in
+'start')
+    setup_logadm
+    ;;
+
+'stop')
+    echo "'stop' not yet supported" >&2
+    exit $SMF_EXIT_ERR_FATAL
+    ;;
+
+*)
+    echo "Usage: $0 { start | stop }"
+    exit $SMF_EXIT_ERR_FATAL
+    ;;
+esac
+exit $SMF_EXIT_OK
diff --git a/testutils/Cargo.toml b/testutils/Cargo.toml
new file mode 100644
index 0000000..56c2746
--- /dev/null
+++ b/testutils/Cargo.toml
@@ -0,0 +1,11 @@
+[package]
+name = "testutils"
+version = "0.1.0"
+authors = ["Mike Zeller <mike@mikezeller.net>"]
+edition = "2018"
+
+[dependencies]
+chrono = "0.4.6"
+uuid = { version = "0.7.4", features = ["v4"] }
+vminfod-client = { path = "../vminfod-client" }
+rand = "0.6.5"
diff --git a/testutils/src/lib.rs b/testutils/src/lib.rs
new file mode 100644
index 0000000..9ec313b
--- /dev/null
+++ b/testutils/src/lib.rs
@@ -0,0 +1,123 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use chrono::{TimeZone, Utc};
+use rand::{thread_rng, Rng};
+use std::net::Ipv6Addr;
+use uuid::Uuid;
+use vminfod_client::Zone;
+
+// C representation of a cfw event aka cfwev_t.
+#[derive(PartialEq, Debug)]
+#[repr(C)]
+pub struct Event {
+    pub event: u16,
+    pub length: u16,
+    pub zonedid: u32,
+    pub rule_id: u32,
+    pub source_port: u16,
+    pub destination_port: u16,
+    pub protocol: u8,
+    pub direction: u8,
+    pub reserved: [u8; 6],
+    pub source_ip: u128,
+    pub destination_ip: u128,
+    pub time_sec: i64,
+    pub time_usec: i64,
+    pub rule_uuid: [u8; 16],
+}
+
+impl Event {
+    pub fn as_bytes(&self) -> &[u8] {
+        unsafe {
+            ::std::slice::from_raw_parts(
+                (self as *const Self) as *const u8,
+                ::std::mem::size_of::<Self>(),
+            )
+        }
+    }
+}
+
+// C representation of a future event type
+#[derive(PartialEq, Debug)]
+#[repr(C)]
+pub struct UnknownEvent {
+    pub event: u16,
+    pub length: u16,
+    pub zonedid: u32,
+    _extra: [u8; 10],
+}
+
+impl UnknownEvent {
+    pub fn as_bytes(&self) -> &[u8] {
+        unsafe {
+            ::std::slice::from_raw_parts(
+                (self as *const Self) as *const u8,
+                ::std::mem::size_of::<Self>(),
+            )
+        }
+    }
+}
+
+pub fn generate_unknown_event() -> UnknownEvent {
+    UnknownEvent {
+        event: 200,
+        length: std::mem::size_of::<UnknownEvent>() as u16,
+        zonedid: 16,
+        _extra: [0; 10],
+    }
+}
+
+pub fn generate_event() -> Event {
+    let mut rng = thread_rng();
+
+    let ip_s: u128 = "::ffff:172.24.4.150".parse::<Ipv6Addr>().unwrap().into();
+    let ip_d: u128 = "::ffff:172.24.4.151".parse::<Ipv6Addr>().unwrap().into();
+    let port_s: u16 = rng.gen_range(1, 65535);
+    let port_d: u16 = rng.gen_range(1, 65535);
+    let now = chrono::offset::Utc::now();
+    // unix timeval only contains microseconds
+    let ts = Utc.timestamp(now.timestamp(), now.timestamp_subsec_micros() * 1000);
+    let uuid = Uuid::new_v4();
+
+    Event {
+        event: 1,
+        length: std::mem::size_of::<Event>() as u16,
+        zonedid: 16,
+        rule_id: rng.gen_range(0, u32::max_value()),
+        source_port: port_s.to_be(),
+        destination_port: port_d.to_be(),
+        protocol: 6,  // TCP
+        direction: 1, // In
+        reserved: [0; 6],
+        source_ip: ip_s.to_be(),
+        destination_ip: ip_d.to_be(),
+        time_sec: ts.timestamp(),
+        time_usec: i64::from(ts.timestamp_subsec_micros()),
+        rule_uuid: *uuid.as_bytes(),
+    }
+}
+
+pub fn generate_event_for_zone(z: &Zone) -> Event {
+    let mut e = generate_event();
+    e.zonedid = z.zonedid;
+    e
+}
+
+pub fn create_zone() -> Zone {
+    let mut rng = thread_rng();
+    Zone {
+        uuid: Uuid::new_v4().to_hyphenated().to_string(),
+        alias: Some("zone1".to_owned()),
+        owner_uuid: Uuid::new_v4().to_string(),
+        firewall_enabled: true,
+        zonedid: rng.gen_range(0, u32::max_value()),
+    }
+}
+
+pub fn generate_zones(n: usize) -> Vec<Zone> {
+    std::iter::repeat_with(create_zone).take(n).collect()
+}
diff --git a/vminfod-client/Cargo.toml b/vminfod-client/Cargo.toml
new file mode 100644
index 0000000..46326bd
--- /dev/null
+++ b/vminfod-client/Cargo.toml
@@ -0,0 +1,14 @@
+[package]
+name = "vminfod-client"
+version = "0.1.0"
+authors = ["Mike Zeller <mike@mikezeller.net>"]
+edition = "2018"
+
+[dependencies]
+hyper = "0.12.25"
+futures = "0.1.25"
+serde = { version = "1.0.89", features = ["derive"] }
+serde_json = "1.0.39"
+crossbeam-channel = "0.3.8"
+tokio = "0.1.17"
+log = "0.4.6"
diff --git a/vminfod-client/examples/print-events.rs b/vminfod-client/examples/print-events.rs
new file mode 100644
index 0000000..3bf17b3
--- /dev/null
+++ b/vminfod-client/examples/print-events.rs
@@ -0,0 +1,16 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// // License, v. 2.0. If a copy of the MPL was not distributed with this
+// // file, You can obtain one at http://mozilla.org/MPL/2.0/.
+//
+// // Copyright 2019 Joyent, Inc.
+
+fn main() {
+    // starts a new thread that sends events back over a channel
+    let version = env!("CARGO_PKG_VERSION");
+    let (rx, _vminfod_handle) = vminfod_client::start_vminfod_stream(version);
+
+    // do something with each event
+    for event in rx.iter() {
+        println!("{:#?}", event);
+    }
+}
diff --git a/vminfod-client/src/client.rs b/vminfod-client/src/client.rs
new file mode 100644
index 0000000..2f81a83
--- /dev/null
+++ b/vminfod-client/src/client.rs
@@ -0,0 +1,82 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use crate::linefeed::Lines;
+use crate::VminfodEvent;
+use crossbeam_channel::Sender;
+use futures::{Future, Stream};
+use hyper::{Body, Client as HyperClient, Request};
+use tokio::runtime::current_thread::Runtime;
+
+use std::string::FromUtf8Error;
+
+#[derive(Debug)]
+enum Error {
+    Hyper(hyper::Error),
+    Serde(serde_json::error::Error),
+    FromUtf8(FromUtf8Error),
+}
+
+impl From<serde_json::error::Error> for Error {
+    fn from(err: serde_json::error::Error) -> Error {
+        Error::Serde(err)
+    }
+}
+
+impl From<FromUtf8Error> for Error {
+    fn from(err: FromUtf8Error) -> Error {
+        Error::FromUtf8(err)
+    }
+}
+
+pub(crate) struct Client {
+    sender: Sender<VminfodEvent>,
+    version: String,
+}
+
+impl Client {
+    pub(crate) fn new(version: String, sender: Sender<VminfodEvent>) -> Self {
+        Client { version, sender }
+    }
+
+    pub(crate) fn run(&self) {
+        let req = Request::builder()
+            .method("GET")
+            .header(
+                "User-Agent",
+                format!(
+                    "cfwlogd v{} - VminfodWatcher (firewall-logger-agent)",
+                    self.version
+                ),
+            )
+            .uri("http://127.0.0.1:9090/events")
+            .body(Body::empty())
+            .expect("invalid hyper request params");
+
+        let tx = self.sender.clone();
+        let client = HyperClient::new();
+        let connection = client
+            .request(req)
+            .map_err(|e| {
+                error!("failed to connect to vminfod: {}", e);
+            })
+            .and_then(|res| {
+                Lines::new(res.into_body().map_err(Error::Hyper))
+                    .for_each(move |line| {
+                        let event: VminfodEvent = serde_json::from_str(&line)?;
+                        tx.send(event)
+                            .expect("vminfod receiving channel should always be listening");
+                        Ok(())
+                    })
+                    .map_err(|e| error!("vminfod event stream closed: {:#?}", e))
+            });
+
+        // The vminfod stream is processed by the current thread rather than a pool of threads
+        let mut rt = Runtime::new().expect("failed to create vminfod tokio runtime");
+        rt.spawn(connection);
+        rt.run().expect("failed to run vminfod tokio runtime");
+    }
+}
diff --git a/vminfod-client/src/lib.rs b/vminfod-client/src/lib.rs
new file mode 100644
index 0000000..65ca246
--- /dev/null
+++ b/vminfod-client/src/lib.rs
@@ -0,0 +1,92 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+pub mod client;
+pub mod linefeed;
+
+use std::thread;
+
+#[macro_use]
+extern crate log;
+
+// use fully qualified path (crate::*) here until jenkins is no longer on rust 1.31
+use crate::client::Client;
+use serde::Deserialize;
+
+#[derive(Deserialize, Debug)]
+#[serde(tag = "type")]
+pub enum VminfodEvent {
+    #[serde(rename = "ready")]
+    Ready(ReadyEvent),
+    #[serde(rename = "create")]
+    Create(CreateEvent),
+    #[serde(rename = "modify")]
+    Modify(ModifyEvent),
+    #[serde(rename = "delete")]
+    Delete(DeleteEvent),
+}
+
+#[derive(Deserialize, Debug)]
+pub struct ReadyEvent {
+    pub vms: String,
+}
+
+#[derive(Deserialize, Debug)]
+pub struct CreateEvent {
+    pub vm: Zone,
+}
+
+#[derive(Deserialize, Debug)]
+pub struct ModifyEvent {
+    pub vm: Zone,
+    pub changes: Vec<Changes>,
+}
+
+#[derive(Deserialize, Debug)]
+pub struct DeleteEvent {
+    pub zonename: String,
+    pub uuid: String,
+}
+
+#[derive(Deserialize, Debug)]
+pub struct Zone {
+    pub uuid: String,
+    pub alias: Option<String>,
+    pub owner_uuid: String,
+    pub firewall_enabled: bool,
+    pub zonedid: u32,
+}
+
+#[derive(Deserialize, Debug)]
+pub struct Changes {
+    pub path: Vec<Option<String>>,
+}
+
+/// Starts a new thread that runs a tokio executor/runtime responsible for watching a vminfod event
+/// stream and sending corresponding events back over the receive half of a channel
+pub fn start_vminfod_stream<S: Into<String>>(
+    version: S,
+) -> (
+    crossbeam_channel::Receiver<VminfodEvent>,
+    thread::JoinHandle<()>,
+) {
+    // We allow up to 10 events to be buffered
+    const NUM_EVENTS_BUFFERED: usize = 10;
+
+    let version = version.into();
+    let (tx, rx) = crossbeam_channel::bounded(NUM_EVENTS_BUFFERED);
+
+    (
+        rx,
+        thread::Builder::new()
+            .name("vminfod_client".to_string())
+            .spawn(move || {
+                let c = Client::new(version, tx);
+                c.run();
+            })
+            .expect("vminfod client thread spawn failed."),
+    )
+}
diff --git a/vminfod-client/src/linefeed.rs b/vminfod-client/src/linefeed.rs
new file mode 100644
index 0000000..d369105
--- /dev/null
+++ b/vminfod-client/src/linefeed.rs
@@ -0,0 +1,131 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+// Copyright 2019 Joyent, Inc.
+
+use std::mem::replace;
+use std::string::FromUtf8Error;
+
+use futures::stream::Fuse;
+use futures::{try_ready, Async, Poll, Stream};
+
+/// The following code is a modified version of:
+/// https://play.rust-lang.org/?gist=971e438cabd6f91efb76b7e45b15edf3&version=stable
+///
+/// The original author of that snippet is:
+/// https://github.com/hyperium/hyper/issues/1335#issuecomment-331682968
+
+#[derive(Debug)]
+pub struct Lines<S: Stream> {
+    buffered: Option<Vec<u8>>,
+    stream: Fuse<S>,
+}
+
+impl<S: Stream> Lines<S> {
+    pub fn new(stream: S) -> Lines<S> {
+        Lines {
+            buffered: None,
+            stream: stream.fuse(),
+        }
+    }
+
+    fn process(&mut self, flush: bool) -> Option<Result<String, FromUtf8Error>> {
+        let buffered = replace(&mut self.buffered, None);
+        if let Some(ref buffer) = buffered {
+            let mut split = buffer.splitn(2, |c| *c == b'\n');
+            if let Some(first) = split.next() {
+                if let Some(second) = split.next() {
+                    replace(&mut self.buffered, Some(second.to_vec()));
+                    return Some(String::from_utf8(first.to_vec()));
+                } else if flush {
+                    return Some(String::from_utf8(first.to_vec()));
+                }
+            }
+        }
+        replace(&mut self.buffered, buffered);
+        None
+    }
+}
+
+impl<S> Stream for Lines<S>
+where
+    S: Stream,
+    S::Item: AsRef<[u8]>,
+    S::Error: From<FromUtf8Error>,
+{
+    type Item = String;
+    type Error = S::Error;
+
+    fn poll(&mut self) -> Poll<Option<String>, S::Error> {
+        // It's important that we loop here so that we only return Async::NotReady when our inner
+        // Stream does.  Otherwise the current task will never be polled again and things will
+        // stall
+        loop {
+            match try_ready!(self.stream.poll()) {
+                // We got a chunk of data from the inner stream
+                Some(chunk) => {
+                    if let Some(ref mut buffer) = self.buffered {
+                        buffer.extend(chunk.as_ref());
+                    } else {
+                        self.buffered = Some(chunk.as_ref().to_vec());
+                    }
+                    match self.process(false) {
+                        Some(Ok(line)) => return Ok(Async::Ready(Some(line))),
+                        Some(Err(err)) => return Err(err.into()),
+                        None => (),
+                    }
+                }
+                // The inner stream has finished
+                None => match self.process(true) {
+                    Some(Ok(line)) => return Ok(Async::Ready(Some(line))),
+                    Some(Err(err)) => return Err(err.into()),
+                    None => return Ok(Async::Ready(None)),
+                },
+            }
+        }
+    }
+}
+
+#[cfg(test)]
+mod linefeed_tests {
+    use super::*;
+    use futures::stream::iter_ok;
+    use futures::Async;
+
+    #[test]
+    // test that `Lines` is able to buffer and split by new lines
+    fn test_lines() {
+        let chunks = vec![
+            "hello",
+            " world\n",
+            "good\nbye\n",
+            "world\n",
+            "escaped\\n\n",
+        ];
+        let stream = iter_ok::<_, FromUtf8Error>(chunks);
+        let mut lines = Lines::new(stream);
+
+        // iter_ok gives us an iterator that is always Ready
+        assert_eq!(
+            lines.poll().unwrap(),
+            Async::Ready(Some("hello world".to_string()))
+        );
+        assert_eq!(
+            lines.poll().unwrap(),
+            Async::Ready(Some("good".to_string()))
+        );
+        assert_eq!(lines.poll().unwrap(), Async::Ready(Some("bye".to_string())));
+        assert_eq!(
+            lines.poll().unwrap(),
+            Async::Ready(Some("world".to_string()))
+        );
+        assert_eq!(
+            lines.poll().unwrap(),
+            Async::Ready(Some("escaped\\n".to_string()))
+        );
+        assert_eq!(lines.poll().unwrap(), Async::Ready(Some("".to_string())));
+        assert_eq!(lines.poll().unwrap(), Async::Ready(None));
+    }
+
+}
