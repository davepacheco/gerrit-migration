From 8a824cab9e55af55672f41fedfc959d7eca13fdd Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Fri, 10 May 2019 13:22:41 -0600
Subject: [PATCH] MANTA-4263 Final sync up of RPC function names in boray

---
 src/bucket.rs         |  24 +++++-----
 src/lib.rs            |   4 +-
 src/object.rs         |  14 +++---
 tests/rpc_handlers.rs | 102 +++++++++++++++++++++---------------------
 4 files changed, 72 insertions(+), 72 deletions(-)

diff --git a/src/bucket.rs b/src/bucket.rs
index 1ccffaa..47e068a 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -38,7 +38,7 @@ pub struct BucketResponse {
 }
 
 #[derive(Serialize, Deserialize)]
-pub struct PutBucketPayload {
+pub struct CreateBucketPayload {
     pub owner : Uuid,
     pub name  : String,
     pub vnode : u64
@@ -205,12 +205,12 @@ pub fn list_handler(msg_id: u32,
     Ok(response)
 }
 
-pub fn put_handler(msg_id: u32,
+pub fn create_handler(msg_id: u32,
                    args: &[Value],
                    mut response: Vec<FastMessage>,
                    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                    log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling putbucket function request");
+    debug!(log, "handling createbucket function request");
 
     let arg0 = match &args[0] {
         Value::Object(_) => &args[0],
@@ -218,18 +218,18 @@ pub fn put_handler(msg_id: u32,
     };
 
     let data_clone = arg0.clone();
-    let payload_result: Result<PutBucketPayload, _> =
+    let payload_result: Result<CreateBucketPayload, _> =
         serde_json::from_value(data_clone);
 
     let payload = match payload_result {
         Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for putbucket function"))
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createbucket function"))
     };
 
     // Make db request and form response
-    put(payload, pool)
+    create(payload, pool)
         .and_then(|maybe_resp| {
-            let method = String::from("putbucket");
+            let method = String::from("createbucket");
             match maybe_resp {
                 Some(resp) => {
                     let value = array_wrap(serde_json::to_value(resp).unwrap());
@@ -253,7 +253,7 @@ pub fn delete_handler(msg_id: u32,
                       mut response: Vec<FastMessage>,
                       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                       log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling putbucket function request");
+    debug!(log, "handling deletebucket function request");
 
     let arg0 = match &args[0] {
         Value::Object(_) => &args[0],
@@ -338,7 +338,7 @@ fn get_sql(vnode: u64) -> String {
        AND name = $2"].concat()
 }
 
-fn put_sql(vnode: u64) -> String {
+fn create_sql(vnode: u64) -> String {
     ["INSERT INTO manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket \
@@ -374,16 +374,16 @@ fn get(payload: GetBucketPayload,
 }
 
 
-fn put(payload: PutBucketPayload,
+fn create(payload: CreateBucketPayload,
        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
        -> Result<Option<BucketResponse>, IOError>
 {
     let mut conn = pool.claim().unwrap();
     let mut txn = (*conn).transaction().unwrap();
-    let put_sql = put_sql(payload.vnode);
+    let create_sql = create_sql(payload.vnode);
 
     let insert_result =
-        txn.query(put_sql.as_str(), &[&Uuid::new_v4(),
+        txn.query(create_sql.as_str(), &[&Uuid::new_v4(),
                                       &payload.owner,
                                       &payload.name])
         .map_err(|e| {
diff --git a/src/lib.rs b/src/lib.rs
index 03f333e..44e6f03 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -43,11 +43,11 @@ pub mod util {
             Value::Array(ref args) => {
                 match msg.data.m.name.as_str() {
                     "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
-                    "putobject"    => object::put_handler(msg.id, &args, response, &pool, &log),
+                    "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
                     "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
                     "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
                     "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
-                    "putbucket"    => bucket::put_handler(msg.id, &args, response, &pool, &log),
+                    "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
                     "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
                     "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
                     _ => Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", msg.data.m.name)))
diff --git a/src/object.rs b/src/object.rs
index f2ac6fb..9f95322 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -113,7 +113,7 @@ pub struct ObjectResponse {
 }
 
 #[derive(Debug, Serialize, Deserialize)]
-pub struct PutObjectPayload {
+pub struct CreateObjectPayload {
     pub owner          : Uuid,
     pub bucket_id      : Uuid,
     pub name           : String,
@@ -269,7 +269,7 @@ pub fn list_handler(msg_id: u32,
     Ok(response)
 }
 
-pub fn put_handler(msg_id: u32,
+pub fn create_handler(msg_id: u32,
                    args: &[Value],
                    mut response: Vec<FastMessage>,
                    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
@@ -282,7 +282,7 @@ pub fn put_handler(msg_id: u32,
     };
 
     let data_clone = arg0.clone();
-    let payload_result: Result<PutObjectPayload, _> =
+    let payload_result: Result<CreateObjectPayload, _> =
         serde_json::from_value(data_clone);
 
     let payload = match payload_result {
@@ -434,20 +434,20 @@ fn list_sql(vnode: u64, limit: u64, offset: u64, order_by: &str) -> String {
         vnode, order_by, limit, offset)
 }
 
-fn put(payload: PutObjectPayload,
+fn put(payload: CreateObjectPayload,
        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
        -> Result<Option<ObjectResponse>, IOError>
 {
     let mut conn = pool.claim().unwrap();
     let mut txn = (*conn).transaction().unwrap();
-    let put_sql = put_sql(payload.vnode);
+    let create_sql = create_sql(payload.vnode);
     let move_sql = insert_delete_table_sql(payload.vnode);
     let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
     txn.execute(move_sql.as_str(), &[&payload.owner,
                                      &payload.bucket_id,
                                      &payload.name])
         .and_then(|_moved_rows| {
-            txn.query(put_sql.as_str(), &[&Uuid::new_v4(),
+            txn.query(create_sql.as_str(), &[&Uuid::new_v4(),
                                           &payload.owner,
                                           &payload.bucket_id,
                                           &payload.name,
@@ -488,7 +488,7 @@ fn insert_delete_table_sql(vnode: u64) -> String {
        AND name = $3"].concat()
 }
 
-fn put_sql(vnode: u64) -> String {
+fn create_sql(vnode: u64) -> String {
     ["INSERT INTO manta_bucket_",
      &vnode.to_string(),
      &".manta_bucket_object ( \
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 307005d..0ef359a 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -126,25 +126,25 @@ fn verify_rpc_handlers() {
 
 
     // Create a bucket
-    let put_bucket_payload = bucket::PutBucketPayload {
+    let create_bucket_payload = bucket::CreateBucketPayload {
         owner: owner_id,
         name: bucket.clone(),
         vnode: 0
     };
 
-    let put_bucket_json = serde_json::to_value(put_bucket_payload).unwrap();
-    let put_bucket_args = vec![put_bucket_json];
-    let mut put_bucket_result =
-        bucket::put_handler(msg_id, &put_bucket_args, vec![], &pool, &log);
+    let create_bucket_json = serde_json::to_value(create_bucket_payload).unwrap();
+    let create_bucket_args = vec![create_bucket_json];
+    let mut create_bucket_result =
+        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
-    assert!(put_bucket_result.is_ok());
-    let put_bucket_response = put_bucket_result.unwrap();
-    assert_eq!(put_bucket_response.len(), 1);
+    assert!(create_bucket_result.is_ok());
+    let create_bucket_response = create_bucket_result.unwrap();
+    assert_eq!(create_bucket_response.len(), 1);
 
-    let put_bucket_response_result: Result<bucket::BucketResponse, _> =
-        serde_json::from_value(put_bucket_response[0].data.d[0].clone());
-    assert!(put_bucket_response_result.is_ok());
-    assert_eq!(put_bucket_response_result.unwrap().name, bucket);
+    let create_bucket_response_result: Result<bucket::BucketResponse, _> =
+        serde_json::from_value(create_bucket_response[0].data.d[0].clone());
+    assert!(create_bucket_response_result.is_ok());
+    assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
 
     // Read bucket again and make sure the resonse is returned successfully
@@ -163,17 +163,17 @@ fn verify_rpc_handlers() {
 
     // Try to create same bucket again and verify a BucketAlreadyExists error is
     // returned
-    put_bucket_result =
-        bucket::put_handler(msg_id, &put_bucket_args, vec![], &pool, &log);
+    create_bucket_result =
+        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
-    assert!(put_bucket_result.is_ok());
-    let put_bucket_response = put_bucket_result.unwrap();
-    assert_eq!(put_bucket_response.len(), 1);
+    assert!(create_bucket_result.is_ok());
+    let create_bucket_response = create_bucket_result.unwrap();
+    assert_eq!(create_bucket_response.len(), 1);
 
-    let put_bucket_response_result: Result<bucket::BucketAlreadyExistsError, _> =
-        serde_json::from_value(put_bucket_response[0].data.d.clone());
-    assert!(put_bucket_response_result.is_ok());
-    assert_eq!(put_bucket_response_result.unwrap(),
+    let create_bucket_response_result: Result<bucket::BucketAlreadyExistsError, _> =
+        serde_json::from_value(create_bucket_response[0].data.d.clone());
+    assert!(create_bucket_response_result.is_ok());
+    assert_eq!(create_bucket_response_result.unwrap(),
                bucket::BucketAlreadyExistsError::new());
 
     // Delete bucket
@@ -255,7 +255,7 @@ fn verify_rpc_handlers() {
         manta_storage_id: "3.stor.us-east.joyent.com".into(),
     };
 
-    let put_object_payload = object::PutObjectPayload {
+    let create_object_payload = object::CreateObjectPayload {
         owner: owner_id,
         bucket_id,
         name: object.clone(),
@@ -268,19 +268,19 @@ fn verify_rpc_handlers() {
         properties: None,
     };
 
-    let put_object_json = serde_json::to_value(put_object_payload).unwrap();
-    let put_object_args = vec![put_object_json];
-    let mut put_object_result =
-        object::put_handler(msg_id, &put_object_args, vec![], &pool, &log);
+    let create_object_json = serde_json::to_value(create_object_payload).unwrap();
+    let create_object_args = vec![create_object_json];
+    let mut create_object_result =
+        object::create_handler(msg_id, &create_object_args, vec![], &pool, &log);
 
-    assert!(put_object_result.is_ok());
-    let put_object_response = put_object_result.unwrap();
-    assert_eq!(put_object_response.len(), 1);
+    assert!(create_object_result.is_ok());
+    let create_object_response = create_object_result.unwrap();
+    assert_eq!(create_object_response.len(), 1);
 
-    let put_object_response_result: Result<object::ObjectResponse, _> =
-        serde_json::from_value(put_object_response[0].data.d[0].clone());
-    assert!(put_object_response_result.is_ok());
-    assert_eq!(put_object_response_result.unwrap().name, object);
+    let create_object_response_result: Result<object::ObjectResponse, _> =
+        serde_json::from_value(create_object_response[0].data.d[0].clone());
+    assert!(create_object_response_result.is_ok());
+    assert_eq!(create_object_response_result.unwrap().name, object);
 
 
     // Read object again and verify a successful response is returned
@@ -361,17 +361,17 @@ fn verify_rpc_handlers() {
     assert_eq!(list_buckets_response.len(), 0);
 
     // Create a bucket and list buckets again
-    put_bucket_result =
-        bucket::put_handler(msg_id, &put_bucket_args, vec![], &pool, &log);
+    create_bucket_result =
+        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
-    assert!(put_bucket_result.is_ok());
-    let put_bucket_response = put_bucket_result.unwrap();
-    assert_eq!(put_bucket_response.len(), 1);
+    assert!(create_bucket_result.is_ok());
+    let create_bucket_response = create_bucket_result.unwrap();
+    assert_eq!(create_bucket_response.len(), 1);
 
-    let put_bucket_response_result: Result<bucket::BucketResponse, _> =
-        serde_json::from_value(put_bucket_response[0].data.d[0].clone());
-    assert!(put_bucket_response_result.is_ok());
-    assert_eq!(put_bucket_response_result.unwrap().name, bucket);
+    let create_bucket_response_result: Result<bucket::BucketResponse, _> =
+        serde_json::from_value(create_bucket_response[0].data.d[0].clone());
+    assert!(create_bucket_response_result.is_ok());
+    assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
     list_buckets_result =
         bucket::list_handler(msg_id, &list_buckets_args, vec![], &pool, &log);
@@ -403,17 +403,17 @@ fn verify_rpc_handlers() {
     assert_eq!(list_objects_response.len(), 0);
 
     // Create an object and list objects again
-    put_object_result =
-        object::put_handler(msg_id, &put_object_args, vec![], &pool, &log);
+    create_object_result =
+        object::create_handler(msg_id, &create_object_args, vec![], &pool, &log);
 
-    assert!(put_object_result.is_ok());
-    let put_object_response = put_object_result.unwrap();
-    assert_eq!(put_object_response.len(), 1);
+    assert!(create_object_result.is_ok());
+    let create_object_response = create_object_result.unwrap();
+    assert_eq!(create_object_response.len(), 1);
 
-    let put_object_response_result: Result<object::ObjectResponse, _> =
-        serde_json::from_value(put_object_response[0].data.d[0].clone());
-    assert!(put_object_response_result.is_ok());
-    assert_eq!(put_object_response_result.unwrap().name, object);
+    let create_object_response_result: Result<object::ObjectResponse, _> =
+        serde_json::from_value(create_object_response[0].data.d[0].clone());
+    assert!(create_object_response_result.is_ok());
+    assert_eq!(create_object_response_result.unwrap().name, object);
 
     list_objects_result =
         object::list_handler(msg_id, &list_objects_args, vec![], &pool, &log);
-- 
2.21.0

