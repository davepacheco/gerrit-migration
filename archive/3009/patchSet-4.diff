commit 93d6502321925b523bfafaacdc9d0e6ebc50cce9 (refs/changes/09/3009/4)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-11-30T21:31:00+00:00 (1 year, 10 months ago)
    
    joyent/v8plus#20 ACF_NOREPLY results in use after free
    joyent/v8plus#21 Write panic messages out into their own buffer
    Reviewed by: Tim Kordas <tim.kordas@joyent.com>

diff --git a/CHANGES.md b/CHANGES.md
index 5630edf..35617fe 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,10 @@
 # v8plus Change History
 
+## 1.0.3
+
+Fixes a use-after-free bug, which could, in the right circumstances, cause
+the program to crash.
+
 ## 1.0.2
 
 Fixes a bug whereby C constructors were silently forced into having one
diff --git a/package.json b/package.json
index ce6d62f..bfc40cc 100644
--- a/package.json
+++ b/package.json
@@ -2,7 +2,7 @@
 	"author": "Keith 'The Mayor' Wesolowski <keith.wesolowski@joyent.com>",
 	"name": "v8plus",
 	"description": "utility environment for writing addons in C",
-	"version": "1.0.2",
+	"version": "1.0.3",
 	"contributors": [
 		"Joshua M. Clulow <jmc@joyent.com>",
 		"Bryan Cantrill <bryan@joyent.com>"
diff --git a/v8plus_csup.c b/v8plus_csup.c
index 0c81417..3abcbf4 100644
--- a/v8plus_csup.c
+++ b/v8plus_csup.c
@@ -51,6 +51,7 @@ static STAILQ_HEAD(v8plus_callq_head, v8plus_async_call) _v8plus_callq =
 static pthread_mutex_t _v8plus_callq_mtx;
 static pthread_t _v8plus_uv_event_thread;
 static uv_async_t _v8plus_uv_async;
+static char _v8plus_panic_buf[1024];
 
 static int _v8plus_eventloop_refcount;
 
@@ -184,9 +185,9 @@ v8plus_async_callback(uv_async_t *async __UNUSED, int status __UNUSED)
 			 * on a reply.  Just free the call structure and move
 			 * on.
 			 */
-			free(vac);
 			if (vac->vac_lp != NULL)
 				nvlist_free((nvlist_t *)vac->vac_lp);
+			free(vac);
 			continue;
 		}
 
@@ -221,6 +222,7 @@ v8plus_async_callback(uv_async_t *async __UNUSED, int status __UNUSED)
 static nvlist_t *
 v8plus_cross_thread_call(v8plus_async_call_t *vac)
 {
+	boolean_t noreply = (vac->vac_flags & ACF_NOREPLY);
 	int err;
 
 	/*
@@ -254,7 +256,7 @@ v8plus_cross_thread_call(v8plus_async_call_t *vac)
 	}
 	uv_async_send(&_v8plus_uv_async);
 
-	if (vac->vac_flags & ACF_NOREPLY) {
+	if (noreply) {
 		/*
 		 * The caller does not care about the reply, and has allocated
 		 * the v8plus_async_call_t structure from the heap.  The
@@ -564,6 +566,8 @@ static void __NORETURN
 v8plus_vpanic(const char *fmt, va_list ap)
 {
 	(void) fprintf(stderr, "v8plus: ");
+	(void) vsnprintf(_v8plus_panic_buf, sizeof (_v8plus_panic_buf),
+	    fmt, ap);
 	(void) vfprintf(stderr, fmt, ap);
 	(void) fflush(stderr);
 	abort();
