commit 3e87c96cb8d6143b9d5d8d62e4f6ea1203b2ac3f (refs/changes/13/3713/1)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-03-23T17:39:32+00:00 (1 year, 7 months ago)
    
    OS-6811 viona must not spin on invalid descriptor count

diff --git a/usr/src/uts/i86pc/io/viona/viona.c b/usr/src/uts/i86pc/io/viona/viona.c
index 359f814265..df7f146baa 100644
--- a/usr/src/uts/i86pc/io/viona/viona.c
+++ b/usr/src/uts/i86pc/io/viona/viona.c
@@ -1067,8 +1067,6 @@ viona_vr_num_avail(viona_vring_t *ring)
 	 */
 	ndesc = (unsigned)*ring->vr_avail_idx - (unsigned)ring->vr_cur_aidx;
 
-	ASSERT(ndesc <= ring->vr_size);
-
 	return (ndesc);
 }
 
@@ -1124,7 +1122,14 @@ viona_worker_tx(viona_vring_t *ring, viona_link_t *link)
 		atomic_or_16(ring->vr_used_flags, VRING_USED_F_NO_NOTIFY);
 		while (viona_vr_num_avail(ring)) {
 			viona_tx(link, ring);
-			ntx++;
+
+			/*
+			 * It is adventageous for throughput to keep this
+			 * transmission loop tight, but periodic breaks to
+			 * check for other events are of value too.
+			 */
+			if (ntx++ >= ring->vr_size)
+				break;
 		}
 		atomic_and_16(ring->vr_used_flags, ~VRING_USED_F_NO_NOTIFY);
 
@@ -1289,10 +1294,15 @@ vq_popchain(viona_vring_t *ring, struct iovec *iov, int niov, uint16_t *cookie)
 		return (0);
 	}
 	if (ndesc > ring->vr_size) {
+		/*
+		 * Despite the fact that the guest has provided an 'avail_idx'
+		 * which indicates that an impossible number of descriptors are
+		 * available, continue on and attempt to process the next one.
+		 *
+		 * The transgression will not escape the probe or stats though.
+		 */
 		VIONA_PROBE2(ndesc_too_high, viona_vring_t *, ring,
 		    uint16_t, ndesc);
-		mutex_exit(&ring->vr_a_mutex);
-		return (-1);
 	}
 
 	head = ring->vr_avail_ring[idx & ring->vr_mask];
