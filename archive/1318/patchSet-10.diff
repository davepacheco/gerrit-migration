From eb49533328a452adf0eec55839b4ca3a2f1731a5 Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Tue, 6 Dec 2016 22:50:33 +0000
Subject: [PATCH] MANTA-2169 Support multipart upload of a single file to Manta

---
 bin/mmpu            | 649 ++++++++++++++++++++++++++++++++++++++++++++
 lib/client.js       | 617 +++++++++++++++++++++++++++++++++--------
 package.json        |   1 +
 test/client.test.js | 123 +++++++++
 test/mmpu.test.js   | 604 +++++++++++++++++++++++++++++++++++++++++
 5 files changed, 1878 insertions(+), 116 deletions(-)
 create mode 100755 bin/mmpu
 create mode 100644 test/mmpu.test.js

diff --git a/bin/mmpu b/bin/mmpu
new file mode 100755
index 0000000..63b44f6
--- /dev/null
+++ b/bin/mmpu
@@ -0,0 +1,649 @@
+#!/usr/bin/env node
+// -*- mode: js -*-
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert');
+var crypto = require('crypto');
+var EventEmitter = require('events').EventEmitter;
+var fs = require('fs');
+var path = require('path');
+var strsplit = require('strsplit');
+var util = require('util');
+
+var bunyan = require('bunyan');
+var cmdln = require('cmdln');
+
+var manta = require('../lib');
+
+
+///--- Globals
+
+var sprintf = util.format;
+
+var NAME = path.basename(process.argv[1]);
+var LOG = bunyan.createLogger({
+    name: NAME,
+    level: (process.env.LOG_LEVEL || 'info'),
+    stream: process.stderr
+});
+
+
+///-- Helpers
+
+function createClient(opts) {
+    return (manta.createBinClient(opts));
+}
+
+
+function assertOpts(thisp, subcmd, opts, cb) {
+    if (opts.help) {
+        setImmediate(function () {
+            thisp.do_help('help', {}, [subcmd], cb.bind(thisp));
+        });
+        return (false);
+    }
+
+    manta.cliVersionCheckPrintAndExit(opts);
+
+    try {
+        manta.checkBinEnv(opts);
+        manta.cli_logger(opts, LOG);
+    } catch (e) {
+        process.setImmediate(cb.bind(thisp, e));
+        return (false);
+    }
+
+    return (true);
+}
+
+
+function printEntry(obj) {
+    console.log(obj.parent + (obj.name ? ('/' + obj.name) : ''));
+}
+
+///--- CLI
+
+function MMpu() {
+    cmdln.Cmdln.call(this, {
+        name: 'mmpu',
+        desc: 'Manages Manta multipart uploads',
+        options: [
+            {
+                names: ['help', 'h'],
+                type: 'bool',
+                help: 'Show this help message and exit.'
+            },
+            {
+                names: ['version'],
+                type: 'bool',
+                help: 'Print version and exit.'
+            },
+            {
+                names: ['completion'],
+                type: 'bool',
+                help: 'Print bash completion code for this command and exit.',
+                hidden: true
+            }
+        ],
+        helpOpts: {
+            includeEnv: true
+        }
+    });
+}
+util.inherits(MMpu, cmdln.Cmdln);
+
+
+MMpu.prototype.init = function (opts, args, callback) {
+    manta.cliVersionCheckPrintAndExit(opts);
+
+    if (opts.completion) {
+        /*
+         * To ensure that all our stdout is written before 'process.exit()'
+         * terminates, we set stdout to blocking. This is an issue when
+         * (a) node v4 or later is used and (b) at least when exec'd by node
+         * as in test/completion.test.js. See
+         * https://gist.github.com/misterdjules/3aa4c77d8f881ffccba3b6e6f0050d03
+         * for some discussion. An alternative would be to exit the the node
+         * process without 'process.exit'.
+         */
+        if (process.stdout._handle &&
+            typeof (process.stdout._handle.setBlocking) === 'function')
+        {
+            process.stdout._handle.setBlocking(true);
+        }
+        console.log(this.bashCompletion());
+        process.exit(0);
+    }
+
+    cmdln.Cmdln.prototype.init.apply(this, arguments);
+};
+
+
+//-- CreateUpload
+
+MMpu.prototype.do_create = function do_create(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 1) {
+        cb(new Error('Object path must be specified'));
+        return;
+    } else if (args.length > 1) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var objectPath = args[0];
+    var client = createClient(opts);
+    var headers = {};
+
+    (opts.header || []).forEach(function (h) {
+        if (h.indexOf(':') === -1) {
+            cb(new Error('Header must be of the form "[header]: value"'));
+            return;
+        }
+        var tmp = strsplit(h, ':', 2);
+        headers[tmp[0]] = tmp[1].trim();
+    });
+
+    var createUploadOpts = {
+        headers: headers,
+        account: opts.account,
+        md5: opts.md5,
+        copies: opts.copies,
+        size: opts.size
+    };
+
+    client.createUpload(objectPath, createUploadOpts, function (err, obj) {
+        if (err) {
+            cb(err);
+        } else {
+            console.log(obj.id);
+            cb();
+        }
+
+        client.close();
+    });
+};
+
+
+MMpu.prototype.do_create.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu create options'
+    },
+    {
+        names: ['copies', 'c'],
+        type: 'positiveInteger',
+        default: 2,
+        help: 'number of copies to make',
+        helpArg: 'COPIES'
+    },
+    {
+        names: ['size', 's'],
+        type: 'positiveInteger',
+        help: 'object size',
+        helpArg: 'SIZE'
+    },
+    {
+        names: ['header', 'H'],
+        type: 'arrayOfString',
+        help: 'HTTP headers to include',
+        helpArg: 'HEADER'
+    },
+    {
+        names: ['md5', 'm'],
+        type: 'string',
+        help: 'Calculated md5 sum (as a base 64 digest) of the object to be ' +
+                'uploaded. The server will validate this md5 on commit, and ' +
+                'will reject the commit if it does not match the sum ' +
+                'provided on create.',
+        helpArg: 'MD5'
+    }
+]);
+
+
+//TODO: add some examples here.
+MMpu.prototype.do_create.help = [
+    'Initiate a Manta multipart upload for an object.',
+    '',
+    'You can specify several options here that will be transformed into user',
+    'headers. In particular, the "size" option is transformed into a',
+    '"content-length" header, the "copies" option is transformed into',
+    '"durability-level", and the "md5" option is added as a "content-md5"',
+    'header. These options will overwrite the headers specified in the',
+    '"headers" option, if one is specified. If you wish to add additional',
+    'headers, you should add them there.',
+    '',
+    'This tool prints the upload ID after the upload is created. You should',
+    'save this ID to use for future operations on the upload.',
+    '',
+    'Usage:',
+    '    mmpu create [OPTIONS] PATH',
+    '{{options}}',
+    ''
+].join('\n');
+
+
+//-- UploadPart
+
+MMpu.prototype.do_upload = function do_upload(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 2) {
+        cb(new Error('An upload ID and part number are required'));
+        return;
+    } else if (args.length > 2) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var regex = /^([0-9]|[1-9][0-9]{0,3})$/;
+    var partNum = args[1];
+    if (!regex.test(partNum)) {
+        cb(new Error('Part number must be in the range: [0, 9999]'));
+        return;
+    }
+
+    partNum = parseInt(partNum, 10);
+    var id = args[0];
+    var client = createClient(opts);
+    var filename = opts.file;
+
+    function createFileStream(file, size) {
+        var f_opts = {
+            start: 0,
+            end: size > 0 ? (size - 1) : 0
+         };
+
+        return (fs.createReadStream(file, f_opts));
+    }
+
+    function uploadPart(stream, uploadId, num, options, stats) {
+        stream.pause();
+        client.uploadPart(stream, uploadId, num, options, function (err, res) {
+            if (err) {
+                cb(err);
+            } else {
+                console.log(res.headers.etag);
+                cb();
+            }
+
+            client.close();
+        });
+    }
+
+    var uploadPartOpts = {
+        account: opts.account,
+        headers: opts.headers
+    };
+
+    if (filename) {
+        fs.stat(filename, function (err, stats) {
+            if (!stats.isFile()) {
+                client.close();
+                cb(new Error(filename + ' is not a file'));
+                return;
+            }
+
+            var fstream = createFileStream(filename, stats.size);
+            fstream.on('open', function () {
+                var drawProgBar = !opts.quiet && Boolean(process.stderr.isTTY);
+                if (opts.progress || drawProgBar) {
+                    var bar = new manta.ProgressBar({
+                        filename: opts.file,
+                        size: stats ? stats.size : undefined,
+                        nosize: stats ? false : true,
+                        devtty: opts.progress
+                    });
+                    fstream.on('data', function (data) {
+                        bar.advance(data.length);
+                    });
+                    fstream.once('end', function () {
+                        bar.end();
+                    });
+                }
+
+                uploadPart(fstream, id, partNum, uploadPartOpts, stats);
+            });
+       });
+    } else {
+        uploadPart(process.stdin, id, partNum, uploadPartOpts);
+    }
+};
+
+
+MMpu.prototype.do_upload.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu upload options'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'local file to upload',
+        helpArg: 'FILE',
+        completionType: 'file'
+    },
+    {
+        names: ['quiet', 'q'],
+        type: 'bool',
+        help: 'disable the progress bar'
+    },
+    {
+        names: ['progress'],
+        type: 'bool',
+        help: 'force the progress bar to draw, even when stderr redirected'
+    }
+]);
+
+MMpu.prototype.do_upload.help = [
+    'Upload a part to a multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu upload [OPTIONS] UPLOAD_ID PART_NUMBER',
+    '    mmpu upload [OPTIONS] UPLOAD_ID PART_NUMBER -f FILE',
+    '',
+    '{{options}}'
+].join('\n');
+
+
+
+//-- Abort
+
+MMpu.prototype.do_abort = function do_abort(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    } else if (args.length > 1) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var id = args[0];
+    var client = createClient(opts);
+
+    var abortUploadOpts = {
+        account: opts.account
+    };
+
+    client.abortUpload(id, abortUploadOpts, function (err) {
+        if (err) {
+            cb(err);
+        } else {
+            cb();
+        }
+
+        client.close();
+    });
+};
+
+MMpu.prototype.do_abort.options = manta.DEFAULT_CLI_OPTIONS;
+
+MMpu.prototype.do_abort.help = [
+    'Abort a multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu abort [OPTIONS] UPLOAD_ID',
+    '',
+    '{{options}}'
+].join('\n');
+
+
+//-- Commit
+
+MMpu.prototype.do_commit = function do_commit(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    var parts = [];
+    var id = args[0];
+    for (var i = 1; i < args.length; i++) {
+        parts[i - 1] = args[i];
+    }
+
+    var client = createClient(opts);
+
+    var commitUploadOpts = {
+        account: opts.account
+    };
+
+    client.commitUpload(id, parts, commitUploadOpts, function (err) {
+        if (err) {
+            cb(err);
+        } else {
+            cb();
+        }
+
+        client.close();
+    });
+};
+
+
+MMpu.prototype.do_commit.help = [
+    'Commit a multipart upload.',
+    '',
+    'The arguments to this command are first the upload ID, followed by all',
+    'of the etags of the parts you are committing for the upload, ordered by',
+    'part number.',
+    '',
+    'For example, suppose you have an upload with the id',
+    'be5f05d6-7daa-6869-d19b-c1f7fbcf6d8d and the following etags:',
+    '   part 0: f14a41dc-7d28-6fdb-e07c-d54c0adcdf35',
+    '   part 1: e2893e52-9ba3-64fe-eec9-b4663835ad01',
+    '   part 2: 73b44fa7-fbd3-efea-b7d0-cd8098e1d928',
+    '',
+    'To commit this upload, you would run:',
+    '   $ mmpu commit be5f05d6-7daa-6869-d19b-c1f7fbcf6d8d \\',
+    '        f14a41dc-7d28-6fdb-e07c-d54c0adcdf35 \\',
+    '        e2893e52-9ba3-64fe-eec9-b4663835ad01 \\',
+    '        73b44fa7-fbd3-efea-b7d0-cd8098e1d928',
+    '',
+    'Note that the multipart upload API does not require that you commit',
+    'all parts that have been uploaded, as long as you commit zero or more',
+    'consecutive parts and meet part size constraints. So the following',
+    'commands for the above upload are also valid but would create a different',
+    'object than the first example:',
+    '',
+    '   $ mmpu commit be5f05d6-7daa-6869-d19b-c1f7fbcf6d8d',
+    '',
+    '   $ mmpu commit be5f05d6-7daa-6869-d19b-c1f7fbcf6d8d \\',
+    '        f14a41dc-7d28-6fdb-e07c-d54c0adcdf35',
+    '        e2893e52-9ba3-64fe-eec9-b4663835ad01',
+    '',
+    '   $ mmpu commit be5f05d6-7daa-6869-d19b-c1f7fbcf6d8d \\',
+    '        f14a41dc-7d28-6fdb-e07c-d54c0adcdf35 \\',
+    '        e2893e52-9ba3-64fe-eec9-b4663835ad01',
+    '',
+    'Usage:',
+    '    mmpu commit [OPTIONS] UPLOAD_ID [ETAG_0] [ETAG_1] ...',
+    ''
+].join('\n');
+
+
+//-- GetMPU
+
+MMpu.prototype.do_get = function do_get(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    } else if (args.length > 1) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var id = args[0];
+    var client = createClient(opts);
+
+    var getUploadOpts = {
+        account: opts.account
+    };
+
+    client.getUpload(id, getUploadOpts, function (err, upload) {
+        if (err) {
+            cb(err);
+        } else {
+            console.log(JSON.stringify(upload, null, 2));
+            cb();
+        }
+
+        client.close();
+    });
+};
+
+
+MMpu.prototype.do_get.options = manta.DEFAULT_CLI_OPTIONS;
+
+
+MMpu.prototype.do_get.help = [
+    'Fetch information about a multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu get [OPTIONS] UPLOAD_ID',
+    '',
+    '{{options}}'
+].join('\n');
+
+
+//-- ListMPU
+
+MMpu.prototype.do_list = function do_list(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length > 0) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var url = '/' + opts.account + '/uploads';
+    var client = createClient(opts);
+
+    var ftwOpts = {
+        mindepth: 1,
+        maxdepth: 2
+    };
+
+    if (opts.includeParts) {
+        ftwOpts.maxdepth = 3;
+    }
+
+    client.ftw(url, ftwOpts, function (err, res) {
+        if (err) {
+            client.close();
+            cb(err);
+        } else {
+            res.on('entry', printEntry);
+            res.on('end', function () {
+                client.close();
+                cb();
+            });
+        }
+    });
+};
+
+
+MMpu.prototype.do_list.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu list options'
+    },
+    {
+        names: ['includeParts', 'p'],
+        type: 'bool',
+        default: false,
+        help: 'list uploaded parts in addition to uploads',
+        helpArg: 'INCLUDE_PARTS'
+    }
+]);
+
+
+MMpu.prototype.do_list.help = [
+    'Lists all uploads for $MANTA_USER.',
+    '',
+    'Usage:',
+    '    mmpu list [OPTIONS]',
+    '',
+    '{{options}}'
+].join('\n');
+
+
+
+//-- ListParts
+
+MMpu.prototype.do_parts = function do_parts(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb)) {
+        return;
+    }
+
+    if (args.length < 1 || args[0].length < 2) {
+        cb(new Error('A valid upload ID is required'));
+        return;
+    } else if (args.length > 2) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var id = args[0];
+    var prefix = id.charAt(0);
+    var url = '/' + opts.account + '/uploads/' + prefix + '/' + id;
+    var client = createClient(opts);
+
+    var ftwOpts = {
+        minDepth: 0,
+        maxDepth: 1
+    };
+
+    client.ftw(url, ftwOpts, function (err, res) {
+        if (err) {
+            client.close();
+            cb(err);
+        } else {
+            res.on('entry', printEntry);
+            res.on('end', function () {
+                client.close();
+                cb();
+            });
+        }
+    });
+};
+
+
+MMpu.prototype.do_parts.options = manta.DEFAULT_CLI_OPTIONS;
+
+
+MMpu.prototype.do_parts.help = [
+    'Lists all parts that have been uploaded to a multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu parts [OPTIONS] UPLOAD_ID',
+    ''
+].join('\n');
+
+
+///--- Mainline
+
+if (require.main === module) {
+    var cli = new MMpu();
+    cli.showErrStack = false;
+    cmdln.main(cli, {
+        showNoCommandErr: false
+    });
+}
diff --git a/lib/client.js b/lib/client.js
index fa1e730..5772c69 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var EventEmitter = require('events').EventEmitter;
@@ -10,8 +10,10 @@ var util = require('util');
 var assert = require('assert-plus');
 var bunyan = require('bunyan');
 var clone = require('clone');
+var jsprim = require('jsprim');
 var libuuid = require('uuid');
 var LineStream = require('lstream');
+var LOMStream = require('lomstream').LOMStream;
 var PassThrough = require('stream').PassThrough;
 if (!PassThrough)
     PassThrough = require('readable-stream/passthrough.js');
@@ -19,8 +21,8 @@ var mime = require('mime');
 var once = require('once');
 var restifyClients = require('restify-clients');
 var vasync = require('vasync');
+var Verror = require('verror');
 var Watershed = require('watershed').Watershed;
-var LOMStream = require('lomstream').LOMStream;
 
 var auth = require('smartdc-auth');
 var jobshare = require('./jobshare');
@@ -47,6 +49,14 @@ var TOKENS_RE = /^\/([a-zA-Z][a-zA-Z0-9_\.@]+)\/tokens/;
 
 var MAX_INT = Math.pow(2, 32) - 1;
 
+// Possible operations on a multipart upload
+var UPLOAD_OPS = {
+    CREATE: 'create',
+    UPLOAD: 'upload',
+    COMMIT: 'commit',
+    ABORT: 'abort',
+    GET: 'state'
+};
 
 
 ///--- Hacks
@@ -475,6 +485,58 @@ function resultToInfoCb(_path, cb) {
 }
 
 
+/*
+ * Given an account and multipart upload operation (plus an upload id and a
+ * part number, if relevant), this function returns the correct url to send
+ * a multipart upload related request to.
+ *
+ * In the current implementation of multipart uploads, parts of an upload are
+ * stored at /<account>/uploads/[0-f]/<upload uuid>, where the parent directory
+ * is the first character in the upload uuid. It is possible this may change in
+ * the future, in order to allow for more simultaneously ongoing multipart
+ * uploads.
+ *
+ * To allow clients an easier way to avoid knowing this exact path structure,
+ * Muskie supports a redirect mechanism in which a client can do a normal
+ * multipart upload request to the path /<account>/uploads/<upload uuid>,
+ * and muskie will redirect it to the correct path, which the client can then
+ * use for the request.
+ *
+ * We can implement this mechanism in the future, but for now, we just hardcode
+ * the prefix.
+ */
+function uploadURL(account, op, id, partNum) {
+    assert.string(account, 'account');
+    assert.string(op, 'op');
+
+    var ops = UPLOAD_OPS;
+    var baseURL = '/' + account + '/uploads';
+
+    if (op === ops.CREATE) {
+        return (baseURL);
+    } else {
+        assert.uuid(id, 'id');
+        assert.ok(id.length > 0);
+
+        var url = baseURL + '/' + id.charAt(0) + '/' + id;
+
+        switch (op) {
+            case ops.COMMIT:
+                return (url + '/commit');
+            case ops.ABORT:
+                return (url + '/abort');
+            case ops.GET:
+                return (url + '/state');
+            case ops.UPLOAD:
+                assert.number(partNum, 'partNum');
+                return (url + '/' + partNum);
+            default:
+                assert.fail('Invalid operation: ' + op);
+                return (undefined);
+        }
+    }
+}
+
 
 ///--- API
 
@@ -1006,7 +1068,6 @@ MantaClient.prototype.ftw = function ftw(p, opts, cb) {
 
                     ls_res.on('entry', function onEntry(obj) {
                         obj.depth = _opts.depth;
-
                         if (obj.type === 'directory' &&
                             (obj.depth + 1) < maxdepth) {
                             var name = obj.parent + '/' + obj.name;
@@ -1016,7 +1077,6 @@ MantaClient.prototype.ftw = function ftw(p, opts, cb) {
                                 path: name
                             });
                         }
-
                         filter(obj);
                     });
 
@@ -3082,131 +3142,129 @@ MantaClient.prototype.signUrl = function signUrl() {
 
 
 MantaClient.prototype.medusaAttach = function medusaAttach(j, opts, cb) {
-        var self = this;
-        var log = self.log.child({});
+    var self = this;
+    var log = self.log.child({});
 
-        var ws = new Watershed();
-        var wskey = ws.generateKey();
-        var res, socket, head, shed;
+    var ws = new Watershed();
+    var wskey = ws.generateKey();
+    var res, socket, head, shed;
 
-        assert.string(j, 'job');
-        if (typeof (opts) === 'function') {
-                cb = opts;
-                opts = {};
-        }
+    assert.string(j, 'job');
+    if (typeof (opts) === 'function') {
+        cb = opts;
+        opts = {};
+    }
 
-        var _path = '/' + self.user + '/medusa/attach/' + j + '/master';
-        var headers = {
-                connection: 'upgrade',
-                upgrade: 'websocket',
-                'sec-websocket-key': wskey
-        };
-        var options = createOptions({
-                headers: headers,
-                path: _path
-        }, {
-                headers: headers
-        });
-        log.debug({
-                job: j,
-                headers: headers
-        }, 'medusaAttach: entered');
+    var _path = '/' + self.user + '/medusa/attach/' + j + '/master';
+    var headers = {
+        connection: 'upgrade',
+        upgrade: 'websocket',
+        'sec-websocket-key': wskey
+    };
+    var options = createOptions({
+        headers: headers,
+        path: _path
+    }, {
+        headers: headers
+    });
+    log.debug({
+        job: j,
+        headers: headers
+    }, 'medusaAttach: entered');
 
-        log.debug({ options: options });
+    log.debug({ options: options });
 
-        /*
-         * Phase functions:
-         */
-        var do_sign_request = function (_, next) {
-                self.signRequest({
-                        headers: options.headers
-                }, next);
-        };
+    /*
+     * Phase functions:
+     */
+    var do_sign_request = function (_, next) {
+        self.signRequest({
+            headers: options.headers
+        }, next);
+    };
 
-        var do_websocket_get = function (_, next) {
-                self.client.get(options, function onRequest(err, req) {
-                        if (err) {
-                                next(err);
-                                return;
-                        }
+    var do_websocket_get = function (_, next) {
+        self.client.get(options, function onRequest(err, req) {
+            if (err) {
+                next(err);
+                return;
+            }
 
-                        var fired = false;
-                        req.once('result', function (_err, _res) {
-                                if (fired)
-                                        return;
-                                fired = true;
-
-                                /*
-                                 * We wanted an Upgrade, but didn't get one.
-                                 * This is an error condition.
-                                 */
-                                var outerr;
-                                if (_err) {
-                                        outerr = new Error('Server did not ' +
-                                            'Upgrade: ' + _err.name + ': ' +
-                                            _err.message);
-                                } else {
-                                        outerr = new Error('Server did not ' +
-                                            'Upgrade (HTTP ' + _res.statusCode +
-                                            ')');
-                                }
-                                next(outerr);
-                        });
-                        req.once('upgradeResult', function (_err, _r, _s, _h) {
-                                if (fired) {
-                                        if (_s)
-                                                _s.destroy();
-                                        return;
-                                }
-                                fired = true;
-
-                                if (_err) {
-                                        next(err);
-                                        return;
-                                }
-
-                                res = _r;
-                                socket = _s;
-                                head = _h;
-
-                                next();
-                        });
-                });
-        };
+            var fired = false;
+            req.once('result', function (_err, _res) {
+                if (fired)
+                        return;
+                fired = true;
 
-        var do_websocket_attach = function (_, next) {
                 /*
-                 * Attempt to attach to the websocket stream,
-                 * and return it to the caller:
+                 * We wanted an Upgrade, but didn't get one.
+                 * This is an error condition.
                  */
-                try {
-                        socket.setNoDelay(true);
-                        shed = ws.connect(res, socket, head, wskey);
-                        next();
-                        return;
-                } catch (ex) {
-                        next(ex);
-                        return;
+                var outerr;
+                if (_err) {
+                    outerr = new Error('Server did not ' +
+                        'Upgrade: ' + _err.name + ': ' + _err.message);
+                } else {
+                    outerr = new Error('Server did not ' +
+                        'Upgrade (HTTP ' + _res.statusCode + ')');
                 }
-        };
+                next(outerr);
+            });
+            req.once('upgradeResult', function (_err, _r, _s, _h) {
+                if (fired) {
+                    if (_s)
+                        _s.destroy();
+                    return;
+                }
+                fired = true;
 
-        /*
-         * Perform phases:
-         */
-        vasync.pipeline({
-                funcs: [
-                        do_sign_request,
-                        do_websocket_get,
-                        do_websocket_attach
-                ]
-        }, function final(err) {
-                if (err) {
-                        cb(err);
-                        return;
+                if (_err) {
+                    next(err);
+                    return;
                 }
 
-                cb(null, shed);
+                res = _r;
+                socket = _s;
+                head = _h;
+
+                next();
+            });
         });
+    };
+
+    var do_websocket_attach = function (_, next) {
+        /*
+         * Attempt to attach to the websocket stream,
+         * and return it to the caller:
+         */
+        try {
+            socket.setNoDelay(true);
+            shed = ws.connect(res, socket, head, wskey);
+            next();
+            return;
+        } catch (ex) {
+            next(ex);
+            return;
+        }
+    };
+
+    /*
+     * Perform phases:
+     */
+    vasync.pipeline({
+        funcs: [
+            do_sign_request,
+            do_websocket_get,
+            do_websocket_attach
+        ]
+    }, function final(err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        cb(null, shed);
+    });
 };
 
 
@@ -3216,6 +3274,334 @@ MantaClient.prototype.path = function _getPath(p, skipEncode) {
 
 
 
+///--- Multipart Uploads API
+
+
+/*
+ * Creates a multipart upload in Manta.
+ *
+ * Parameters:
+ *  - p: the path the object will be uploaded to on commit
+ *  - opts: optional object block
+ *  - cb: callback of the form f(err, uploadId)
+ *
+ *  The following option is required:
+ *    - account: the account associated with the upload
+ *
+ *  Other optional options are:
+ *    - size: the size of the object to be uploaded
+ *    - copies: the number of copies of the object to save
+ *    - md5: calculated md5 sum of the object
+ *    - headers: headers to define on the object
+ *
+ *  Note that if opts.headers conflicts with the values set in
+ *  opts.{size,copies,md5}, the values in the headers object will be
+ *  ovewritten with the explicitly set options values.
+ *
+ */
+MantaClient.prototype.createUpload = function createUpload(p, opts, cb) {
+    assert.string(p, 'path');
+    assert.object(opts, 'options');
+    assert.string(opts.account, 'opts.account');
+    assert.optionalObject(opts.headers, 'opts.headers');
+    assert.optionalNumber(opts.copies, 'opts.copies');
+    assert.optionalNumber(opts.size, 'opts.size');
+    assert.optionalString(opts.md5, 'opts.md5');
+    assert.func(cb, 'callback');
+
+    var url = uploadURL(opts.account, UPLOAD_OPS.CREATE);
+    var objectPath = this.path(p);
+
+    var options = createOptions({
+        accept: 'application/json',
+        contentType: 'application/json',
+        path: url
+    }, opts);
+
+    // Headers to store with the object (not sent as headers on the request)
+    var headers = {};
+    if (opts.headers) {
+        headers = jsprim.deepCopy(opts.headers);
+    }
+
+    if (opts.copies) {
+        headers['durability-level'] = opts.copies;
+    }
+
+    if (opts.size) {
+        headers['content-length'] = opts.size;
+    }
+
+    if (opts.md5) {
+        headers['content-md5'] = opts.md5;
+    }
+
+    var log = this.log.child({
+        path: url,
+        req_id: options.id
+    }, true);
+
+    var self = this;
+
+    log.debug('createUpload: entered');
+    self.signRequest({
+        headers: options.headers
+    }, function onSignRequest(err) {
+        if (err) {
+            err = new Verror(err, 'signing request');
+            log.debug(err);
+            cb(err);
+            return;
+        }
+
+        var body = {
+            objectPath: objectPath,
+            headers: headers
+        };
+
+        self.jsonClient.post(options, body, function (err2, req, res, obj) {
+            if (err2) {
+                err2 = new Verror(err2, 'jsonClient POST');
+                log.debug(err2);
+                cb(err2);
+            } else {
+                cb(null, obj);
+            }
+        });
+
+        return;
+    });
+};
+
+
+/*
+ * Uploads a part to a multipart upload.
+ *
+ * Parameters:
+ *  - stream: stream containing the part data
+ *  - id: upload uuid
+ *  - partNum: the part number
+ *  - opts: options object that must contain the following:
+ *      - account: the Manta account the upload belongs to
+ *  - cb: callback function of the form f(err, res, req)
+ */
+MantaClient.prototype.uploadPart =
+function uploadPart(stream, id, partNum, opts, cb) {
+    assert.stream(stream, 'stream');
+    assert.string(id, 'id');
+    assert.object(opts, 'opts');
+    assert.string(opts.account, 'opts.account');
+    assert.func(cb, 'callback');
+
+    var op = UPLOAD_OPS.UPLOAD;
+    var url = uploadURL(opts.account, op, id, partNum);
+
+    var options = createOptions({
+        accept: 'application/json',
+        expect: '100-continue',
+        path: url
+    }, opts);
+
+    var log = this.log.child({
+        path: url,
+            req_id: options.id
+    }, true);
+
+    var self = this;
+
+    log.debug('uploadPart: entered');
+    self.signRequest({
+        headers: options.headers
+    }, function onSignRequest(err) {
+        if (err) {
+            err = new Verror(err, 'signing request');
+            log.debug(err);
+            cb(err);
+            return;
+        }
+
+        function reqCb(req) {
+            req.once('continue', function onContinue() {
+                log.debug('uploadPart: continue received');
+                if (stream.readable) {
+                    stream.pipe(req);
+                    stream.resume();
+                } else {
+                    req.end();
+                }
+            });
+        }
+
+        self.client.put(options, onRequestCallback({
+            cb: cb,
+            log: log,
+            name: 'put',
+            onResult: onResultCallback({
+                cb: cb,
+                log: log,
+                name: 'put'
+            }),
+            reqCb: reqCb
+        }));
+    });
+};
+
+
+/*
+ * Aborts an upload.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ *  - opts: options object that must contain the following:
+ *      - account: the Manta account the upload belongs to
+ *  - cb: callback function of the form f(err)
+ */
+MantaClient.prototype.abortUpload = function abortUpload(id, opts, cb) {
+    assert.string(id, 'id');
+    assert.object(opts, 'options');
+    assert.string(opts.account, 'opts.account');
+    assert.func(cb, 'callback');
+
+    var url = uploadURL(opts.account, UPLOAD_OPS.ABORT, id);
+    var options = createOptions({
+        path: url
+    }, opts);
+
+    var log = this.log.child({
+        path: url,
+        req_id: options.id
+    }, true);
+
+    var self = this;
+    log.debug('abortUpload: entered');
+    self.signRequest({
+        headers: options.headers
+    }, function onSignRequest(err) {
+        if (err) {
+            err = new Verror(err, 'signing request');
+            log.debug(err);
+            cb(err);
+            return;
+        }
+
+        self.jsonClient.post(options, function (err2, req, res, obj) {
+            if (err2) {
+                err2 = new Verror(err2, 'jsonClient POST');
+                log.debug(err2);
+                cb(err2);
+            } else {
+                cb();
+            }
+        });
+    });
+};
+
+
+/*
+ * Gets information about an upload, including its state, the path the
+ * object will be uploaded to, headers for the object, and how many
+ * copies of it will be stored.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ *  - opts: options object that must contain the following:
+ *      - account: the Manta account the upload belongs to
+ *  - cb: callback function of the form f(err, upload)
+ */
+MantaClient.prototype.getUpload = function getUpload(id, opts, cb) {
+    assert.string(id, 'id');
+    assert.object(opts, 'options');
+    assert.string(opts.account, 'opts.account');
+    assert.func(cb, 'callback');
+
+    var url = uploadURL(opts.account, UPLOAD_OPS.GET, id);
+    var options = createOptions({
+        path: url
+    }, opts);
+
+    var log = this.log.child({
+        path: url,
+        req_id: options.id
+    }, true);
+
+    var self = this;
+
+    log.debug('getUpload: entered');
+    self.signRequest({
+        headers: options.headers
+    }, function onSignRequest(err) {
+        if (err) {
+            err = new Verror(err, 'signing request');
+            log.debug(err);
+            cb(err);
+            return;
+        }
+
+        self.jsonClient.get(options, function (err2, req, res, obj) {
+            if (err2) {
+                err2 = new Verror(err2, 'jsonClient GET');
+                log.debug(err2);
+                cb(err2);
+            } else {
+                cb(null, obj);
+            }
+        });
+    });
+};
+
+
+/*
+ * Commits an upload.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ *  - p: an array of part etags
+ *  - opts: options object that must contain the following:
+ *      - account: the Manta account the upload belongs to
+ *  - cb: callback function of the form f(err)
+ */
+MantaClient.prototype.commitUpload = function commitUpload(id, p, opts, cb) {
+    assert.string(id, 'id');
+    assert.object(opts, 'options');
+    assert.string(opts.account, 'opts.account');
+    assert.func(cb, 'callback');
+
+    var url = uploadURL(opts.account, UPLOAD_OPS.COMMIT, id);
+    var options = createOptions({
+        accept: 'application/json',
+        contentType: 'application/json',
+        path: url
+    }, opts);
+
+    var log = this.log.child({
+        path: url,
+        req_id: options.id
+    }, true);
+
+    var self = this;
+    log.debug('commitUpload: entered');
+    self.signRequest({
+        headers: options.headers
+    }, function onSignRequest(err) {
+        if (err) {
+            err = new Verror(err, 'signing request');
+            log.debug(err);
+            cb(err);
+            return;
+        }
+
+        var body = { parts:  p };
+        self.jsonClient.post(options, body, function (err2, req, res) {
+            if (err2) {
+                err2 = new Verror(err2, 'jsonClient POST');
+                log.debug(err2);
+                cb(err2);
+            } else {
+                cb(null);
+            }
+        });
+    });
+};
 
 
 ///--- Exports
@@ -3223,7 +3609,6 @@ MantaClient.prototype.path = function _getPath(p, skipEncode) {
 module.exports = {
     path: getPath, // useful for the CLI
     jobPath: getJobPath, // useful for mjob
+    createOptions: createOptions, // useful for testing
     MantaClient: MantaClient
 };
-
-/* vim: set ts=8 sts=8 sw=8 expandtab: */
diff --git a/package.json b/package.json
index ae4a006..e9c48bb 100644
--- a/package.json
+++ b/package.json
@@ -30,6 +30,7 @@
         "restify-clients": "~1.4.1",
         "showdown": "~1.4.2",
         "smartdc-auth": "^2.4.1",
+        "strsplit": "1.0.0",
         "tar": "~2.2.1",
         "uuid": "~2.0.2",
         "vasync": "^1.6.4",
diff --git a/test/client.test.js b/test/client.test.js
index ec2f459..3136dd1 100644
--- a/test/client.test.js
+++ b/test/client.test.js
@@ -3,6 +3,7 @@
  */
 
 var exec = require('child_process').exec;
+var crypto = require('crypto');
 var fs = require('fs');
 var path = require('path');
 
@@ -30,6 +31,11 @@ var CHILD2 = SUBDIR2 + '/child2-' + libuuid.v4().split('-')[0]; // link
 var NOENTSUB1 = SUBDIR1 + '/a/b/c';
 var NOENTSUB2 = SUBDIR1 + '/d/e/f';
 var SPECIALOBJ1 = SUBDIR1 + '/' + 'before-\r-after';
+var UPLOAD1; // committed upload
+var UPLOAD2; // aborted upload
+var PATH1 = ROOT + '/committed-obj';
+var PATH2 = ROOT + '/aborted-obj';
+var ETAGS1 = [];
 
 var SUBDIR1_NOBJECTS = 1;
 var SUBDIR1_NDIRECTORIES = 2;
@@ -720,6 +726,123 @@ test('mkdirp/rmr', function (t) {
     });
 });
 
+test('create upload', function (t) {
+    var opts = {
+        account: this.client.user
+    };
+
+    this.client.createUpload(PATH1, opts, function (err, obj) {
+        t.ifError(err);
+        t.ok(obj);
+        t.ok(obj.id);
+        UPLOAD1 = obj.id;
+        t.done();
+    });
+});
+
+test('upload part', function (t) {
+    var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var stream = new MemoryStream();
+    var opts = {
+        account: this.client.user,
+        md5: crypto.createHash('md5').update(text).digest('base64'),
+        size: Buffer.byteLength(text),
+        type: 'text/plain'
+    };
+
+    var pn = 0;
+    this.client.uploadPart(stream, UPLOAD1, pn, opts, function (err, res) {
+        t.ifError(err);
+        t.ok(res);
+        t.ok(res.headers && res.headers.etag);
+        ETAGS1[pn] = res.headers.etag;
+        t.done();
+    });
+
+    setImmediate(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
+test('get upload', function (t) {
+    var opts = {
+        account: this.client.user
+    };
+
+    this.client.getUpload(UPLOAD1, opts, function (err, upload) {
+        t.ifError(err);
+        t.ok(upload);
+        t.equal(upload.id, UPLOAD1);
+        t.equal(upload.state, 'created');
+        t.done();
+    });
+});
+
+test('commit upload', function (t) {
+    var opts = {
+        account: this.client.user
+    };
+
+    var self = this;
+    self.client.commitUpload(UPLOAD1, ETAGS1, opts, function (err) {
+        t.ifError(err);
+        self.client.getUpload(UPLOAD1, opts, function (err2, upload) {
+            t.ifError(err2);
+            t.ok(upload);
+            t.equal(upload.id, UPLOAD1);
+            t.equal(upload.state, 'finalizing');
+            t.equal(upload.type, 'commit');
+
+            self.client.get(PATH1, function (err3, stream) {
+                t.ifError(err3);
+
+                var text = 'The lazy brown fox \nsomething \nsomething foo';
+                var data = '';
+                stream.setEncoding('utf8');
+                stream.on('data', function (chunk) {
+                    data += chunk;
+                });
+                stream.on('end', function (chunk) {
+                    t.equal(data, text);
+
+                    self.client.unlink(PATH1, opts, function (err4) {
+                        t.ifError(err4);
+                        t.done();
+                    });
+                });
+            });
+        });
+    });
+});
+
+test('abort upload', function (t) {
+    var opts = {
+        account: this.client.user
+    };
+
+    var self = this;
+    this.client.createUpload(PATH2, opts, function (err, obj) {
+        t.ifError(err);
+        t.ok(obj);
+        t.ok(obj.id);
+        UPLOAD2 = obj.id;
+
+        self.client.abortUpload(UPLOAD2, opts, function (err2) {
+            t.ifError(err2);
+            self.client.getUpload(UPLOAD2, opts, function (err3, upload) {
+                t.ifError(err3);
+                t.ok(upload);
+                t.equal(upload.id, UPLOAD2);
+                t.equal(upload.state, 'finalizing');
+                t.equal(upload.type, 'abort');
+
+                t.done();
+            });
+        });
+    });
+});
+
 
 test('GH-196 getPath ~~/', function (t) {
     // confirm that evaluating ~~/ works with and without ENV variables
diff --git a/test/mmpu.test.js b/test/mmpu.test.js
new file mode 100644
index 0000000..2a69312
--- /dev/null
+++ b/test/mmpu.test.js
@@ -0,0 +1,604 @@
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+/*
+ * Test `mmpu` workflow: create an upload, upload a part, get the upload,
+ * and then commit it. Repeat the same process for abort.
+ *
+ * We also check that the `list` and `parts` subcommands output what we expect
+ * at various points in the process.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var exec = require('child_process').exec;
+var forkExecWait = require('forkexec').forkExecWait;
+var format = require('util').format;
+var fs = require('fs');
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+
+var logging = require('./lib/logging');
+var manta = require('../lib');
+
+
+// ---- globals
+
+var log = logging.createLogger();
+
+var MANTA_USER = process.env.MANTA_USER || 'admin';
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MGET = path.resolve(BINDIR, 'mget');
+var MMPU = path.resolve(BINDIR, 'mmpu');
+var MRM = path.resolve(BINDIR, 'mrm');
+
+// mmpu subcommands
+var CREATE = 'create';
+var UPLOAD = 'upload';
+var GET = 'get';
+var LIST = 'list';
+var PARTS = 'parts';
+var ABORT = 'abort';
+var COMMIT = 'commit';
+
+// object paths
+var C_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-commit',
+    MANTA_USER, MANTA_USER);
+var A_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-abort',
+    MANTA_USER, MANTA_USER);
+
+// upload ids
+var C_ID;
+var A_ID;
+
+// part etags
+var C_ETAG0;
+var A_ETAG0;
+
+// object to upload
+var TEXT = 'asdfghjk;';
+var TEXT_SIZE = TEXT.length.toString();
+var TEXT_MD5 = crypto.createHash('md5').update(TEXT).digest('base64');
+
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+function uploadPath(id) {
+    var prefix = id.charAt(0);
+    return ('/' + MANTA_USER + '/uploads/' + prefix + '/' + id);
+}
+
+
+// ---- tests
+
+// Exercise all possible create flags here.
+test('mmpu create C_OBJ_PATH -c 1 -H m-custom-header:foo -s TEXT_SIZE ' +
+'-m TEXT_MD5', function (t) {
+    var argv = [
+        MMPU, CREATE, C_OBJ_PATH,
+        '-c', '1',
+        '-H', 'm-custom-header:foo',
+        '-s', TEXT_SIZE,
+        '-m', TEXT_MD5
+    ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.ok(info);
+            t.ok(info.stdout);
+            C_ID = info.stdout.replace('\n', '');
+        }
+        t.done();
+    });
+});
+
+// Get the upload we are going to commit, and verify the attributes match
+// what was specified on create.
+test('mmpu get C_ID', function (t) {
+    var argv = [ MMPU, GET, C_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.ok(info);
+            var upload = JSON.parse(info.stdout);
+            t.ok(upload);
+            if (!upload) {
+                t.done();
+                return;
+            }
+
+            var headers = upload.headers;
+            if (!headers) {
+                t.done();
+                return;
+            }
+
+            t.ok(headers);
+            t.equal(headers['durability-level'], 1);
+            t.equal(headers['content-length'], TEXT_SIZE);
+            t.equal(headers['content-md5'], TEXT_MD5);
+            t.equal(headers['m-custom-header'], 'foo');
+            t.equal(upload.state, 'created');
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+
+// Check that the values specified as flags overwrite the header values.
+test('mmpu create A_OBJ_PATH -c 1 -s TEXT_SIZE -m TEXT_MD5' +
+'-H durability-level 3 -H content-length:10 -H content-md5:foo', function (t) {
+    var argv = [
+        MMPU, CREATE, A_OBJ_PATH,
+        '-c', '1',
+        '-s', TEXT_SIZE,
+        '-m', TEXT_MD5,
+        '-H', 'durability-level:3',
+        '-H', 'content-length:10',
+        '-H', 'content-md5:foo'
+    ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.ok(info);
+            t.ok(info.stdout);
+            A_ID = info.stdout.replace('\n', '');
+        }
+        t.done();
+    });
+});
+
+
+// Get the upload we are going to abort, and verify the attributes match
+// what was specified on create.
+test('mmpu get A_IDJ', function (t) {
+    var argv = [ MMPU, GET, A_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.ok(info);
+            var upload = JSON.parse(info.stdout);
+            t.ok(upload);
+            if (!upload) {
+                t.done();
+                return;
+            }
+
+            var headers = upload.headers;
+            if (!headers) {
+                t.done();
+                return;
+            }
+
+            t.ok(headers);
+            t.equal(headers['durability-level'], 1);
+            t.equal(headers['content-length'], TEXT_SIZE);
+            t.equal(headers['content-md5'], TEXT_MD5);
+
+            t.equal(upload.state, 'created');
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+
+});
+
+// Check that no parts have been uploaded for C_ID.
+test('mmpu parts C_ID: pre-upload', function (t) {
+    var argv = [ MMPU, PARTS, C_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.equal(info.stdout, '');
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+// Check that no parts have been uploaded for A_ID.
+test('mmpu parts A_ID: pre-upload', function (t) {
+    var argv = [ MMPU, PARTS, A_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            t.equal(info.stdout, '');
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+// Check that we see the new uploads in `mmpu list`.
+test('mmpu list', function (t) {
+    var argv = [ MMPU, LIST ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        var c = uploadPath(C_ID);
+        var a = uploadPath(A_ID);
+        var cFound, aFound = false;
+
+        if (!err) {
+            var split = info.stdout.split('\n');
+            split.forEach(function (line) {
+                if (line === c) {
+                    cFound = true;
+                } else if (line === a) {
+                    aFound = true;
+                }
+            });
+
+            t.ok(cFound);
+            t.ok(aFound);
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+
+// Upload a part from a file to the commit object.
+test('mmpu upload C_ID 0 -f tmpFile', function (t) {
+    var tmpFile = '/var/tmp/node-manta-mmpu-test-tmp-file-' + process.pid;
+
+    function mkTmpFile(_, cb) {
+        fs.writeFile(tmpFile, TEXT, cb);
+    }
+
+    function upload(_, cb) {
+        var argv = [ MMPU, UPLOAD, C_ID,
+            '0',
+            '-f', tmpFile
+        ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                 C_ETAG0 = info.stdout.replace('\n', '');
+                 cb();
+            }
+        });
+    }
+
+    function rmTmpFile(_, cb) {
+        fs.unlink(tmpFile, cb);
+    }
+
+    vasync.pipeline({
+        funcs: [
+            mkTmpFile,
+            upload,
+            rmTmpFile
+        ]
+    }, function (err, results) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+
+// Upload a part from a stream to the abort object.
+test('mmpu upload A_ID 0', function (t) {
+    var argv = [ MMPU, UPLOAD, A_ID,
+        '0'
+    ];
+
+    var child = forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            A_ETAG0 = info.stdout.replace('\n', '');
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+        t.done();
+    });
+
+    setImmediate(function () {
+        child.stdin.write(TEXT);
+        child.stdin.end();
+    });
+});
+
+// Check that one part has been uploaded for C_ID.
+test('mmpu parts C_ID: post-upload', function (t) {
+    var argv = [ MMPU, PARTS, C_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            var expectedStdout = uploadPath(C_ID) + '/0\n';
+            t.equal(info.stdout, expectedStdout);
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+// Check that one part has been uploaded for A_ID.
+test('mmpu parts A_ID: post-upload', function (t) {
+    var argv = [ MMPU, PARTS, A_ID ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+        if (!err) {
+            var expectedStdout = uploadPath(A_ID) + '/0\n';
+            t.equal(info.stdout, expectedStdout);
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+
+// Check that `mmpu list -p` now includes the parts that have been uploaded.
+test('mmpu list -p', function (t) {
+    var argv = [ MMPU, LIST, '-p' ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        var c = uploadPath(C_ID);
+        var a = uploadPath(A_ID);
+        var c0 = c + '/0';
+        var a0 = a + '/0';
+
+        var cFound, aFound, c0Found, a0Found = false;
+
+        if (!err) {
+            var split = info.stdout.split('\n');
+            split.forEach(function (line) {
+                if (line === c) {
+                    cFound = true;
+                } else if (line === a) {
+                    aFound = true;
+                } else if (line === c0) {
+                    c0Found = true;
+                } else if (line === a0) {
+                    a0Found = true;
+                }
+            });
+
+            t.ok(cFound);
+            t.ok(aFound);
+            t.ok(c0Found);
+            t.ok(a0Found);
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+
+// Check that `mmpu list` (without -p) does not show the parts that have been
+// uploaded.
+test('mmpu list: post part upload', function (t) {
+    var argv = [ MMPU, LIST ];
+
+    forkExecWait({
+        argv: argv
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        var c = uploadPath(C_ID);
+        var a = uploadPath(A_ID);
+        var c0 = c + '/0';
+        var a0 = a + '/0';
+
+        var cFound, aFound, c0Found, a0Found = false;
+
+        if (!err) {
+            var split = info.stdout.split('\n');
+            split.forEach(function (line) {
+                if (line === c) {
+                    cFound = true;
+                } else if (line === a) {
+                    aFound = true;
+                } else if (line === c0) {
+                    c0Found = true;
+                } else if (line === a0) {
+                    a0Found = true;
+                }
+            });
+
+            t.ok(cFound);
+            t.ok(aFound);
+            t.ok(!c0Found);
+            t.ok(!a0Found);
+        } else {
+            console.log(err);
+            console.log(info.stderr);
+        }
+
+        t.done();
+    });
+});
+
+
+
+// Commit the object, do an mget of it to verify it's the object we expect,
+// and remove it to clean up.
+test('mmpu commit C_ID C_ETAG0', function (t) {
+    function commit(_, cb) {
+        var argv = [ MMPU, COMMIT, C_ID, C_ETAG0 ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                cb();
+            }
+        });
+    }
+
+    function checkCommitState(_, cb) {
+        var argv = [ MMPU, GET, C_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                var upload = JSON.parse(info.stdout);
+                t.ok(upload.state, 'finalizing');
+                t.ok(upload.type, 'commit');
+                cb();
+            }
+        });
+    }
+
+    function getCommitObj(_, cb) {
+        var argv = [ MGET, C_OBJ_PATH ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                var output = info.stdout.replace('\n', '');
+                t.equal(TEXT, output);
+                cb();
+            }
+        });
+    }
+
+    function rmCommitObj(_, cb) {
+        var argv = [ MRM, C_OBJ_PATH ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                 cb();
+            }
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [
+            commit,
+            checkCommitState,
+            getCommitObj,
+            rmCommitObj
+        ]
+    }, function (err, results) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+
+// Abort the object being uploaded to A_OBJ_PATH.
+test('mmpu abort A_ID', function (t) {
+    function abort(_, cb) {
+        var argv = [ MMPU, ABORT, A_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                cb();
+            }
+        });
+    }
+
+    function checkAbortState(_, cb) {
+        var argv = [ MMPU, GET, A_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            if (err) {
+                cb(err);
+            } else {
+                var upload = JSON.parse(info.stdout);
+                t.ok(upload.state, 'finalizing');
+                t.ok(upload.type, 'abort');
+                cb();
+            }
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [
+            abort,
+            checkAbortState
+        ]
+    }, function (err, results) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
-- 
2.21.0

