From d6e3a32d12ac7a875e6cb06500034ab975be2efb Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Tue, 6 Dec 2016 22:50:33 +0000
Subject: [PATCH] MANTA-2169 Support multipart upload of a single file to Manta

---
 bin/mmpu      | 562 ++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/client.js | 370 ++++++++++++++++++++++++++++++++-
 2 files changed, 928 insertions(+), 4 deletions(-)
 create mode 100755 bin/mmpu

diff --git a/bin/mmpu b/bin/mmpu
new file mode 100755
index 0000000..086ec08
--- /dev/null
+++ b/bin/mmpu
@@ -0,0 +1,562 @@
+#!/usr/bin/env node
+// -*- mode: js -*-
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var fs = require('fs');
+var path = require('path');
+var util = require('util');
+
+var bunyan = require('bunyan');
+var cmdln = require('cmdln');
+
+var manta = require('../lib');
+
+
+///--- Globals
+
+var sprintf = util.format;
+
+var NAME = path.basename(process.argv[1]);
+var LOG = bunyan.createLogger({
+    name: NAME,
+    level: (process.env.LOG_LEVEL || 'info'),
+    stream: process.stderr
+});
+
+
+///-- Helpers
+
+function createClient(opts) {
+    return (manta.createBinClient(opts));
+}
+
+
+function assertOpts(thisp, subcmd, opts, cb) {
+    if (opts.help) {
+        process.nextTick(function () {
+            thisp.do_help('help', {}, [subcmd], cb.bind(thisp));
+        });
+        return (false);
+    }
+
+    manta.cliVersionCheckPrintAndExit(opts);
+
+    try {
+        manta.checkBinEnv(opts);
+        manta.cli_logger(opts, LOG);
+    } catch (e) {
+        process.nextTick(cb.bind(thisp, e));
+        return (false);
+    }
+
+    return (true);
+}
+
+
+///--- CLI
+
+function MMpu() {
+    cmdln.Cmdln.call(this, {
+        name: 'mmpu',
+        desc: 'Manages Manta multipart uploads',
+        options: [
+            {
+                names: ['help', 'h'],
+                type: 'bool',
+                help: 'Show this help message and exit.'
+            },
+            {
+                names: ['version'],
+                type: 'bool',
+                help: 'Print version and exit.'
+            },
+            {
+                names: ['completion'],
+                type: 'bool',
+                help: 'Print bash completion code for this command and exit.',
+                hidden: true
+            }
+        ],
+        helpOpts: {
+            includeEnv: true
+        }
+    });
+}
+util.inherits(MMpu, cmdln.Cmdln);
+
+
+//-- CreateUpload
+
+MMpu.prototype.do_create = function do_create(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('Object path must be specified'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    opts.headers = {};
+    (opts.header || []).forEach(function (h) {
+        if (h.indexOf(':') === -1) {
+            cb(new Error('Header must be of the form "[header]: value"'));
+            return;
+        }
+        var tmp = h.split(':');
+        opts.headers[tmp[0]] = tmp[1].trim();
+    });
+
+    var objectPath = args[0];
+    opts.log = LOG;
+    var client = createClient(opts);
+
+    client.createUpload(objectPath, opts, function (err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        console.log(obj.id);
+        cb();
+        client.close();
+        return;
+    });
+};
+
+
+MMpu.prototype.do_create.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu create options'
+    },
+    {
+        names: ['copies', 'c'],
+        type: 'positiveInteger',
+        default: 2,
+        help: 'number of copies to make',
+        helpArg: 'COPIES'
+    },
+    {
+        names: ['size', 's'],
+        type: 'positiveInteger',
+        help: 'object size',
+        helpArg: 'SIZE'
+    },
+    {
+        names: ['header', 'H'],
+        type: 'arrayOfString',
+        help: 'HTTP headers to include',
+        helpArg: 'HEADER'
+    },
+    {
+        names: ['md5', 'm'],
+        type: 'string',
+        help: 'Calculated md5 sum of the object to be uploaded',
+        helpArg: 'MD5'
+    }
+]);
+
+
+//TODO: add some examples here.
+MMpu.prototype.do_create.help = [
+    /* BEGIN JSSTYLED */
+    'Initiate a Manta multipart upload for an object.',
+    '',
+    'You can specify several options here that will be transformed into user',
+    'headers. In particular, the "size" option is transformed into a "content-length" header',
+    'the "copies" option is transformed into "x-durability-level", and the "md5" option is',
+    'added as a "content-md5" header. These options will overwrite the headers specified in',
+    'the "headers" option, if one is specified. If you wish to add additional headers, you should',
+    'add them there.',
+    '',
+    'This tool print the upload ID once the upload is created. You should save this ID to use for',
+    'future operations on the upload.',
+    '',
+    'Usage:',
+    '    mmpu create [OPTIONS] Path',
+    '{{options}}',
+    ''
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- UploadPart
+
+MMpu.prototype.do_upload = function do_upload(subcmd, opts, args, cb) {
+    if (args.length < 2) {
+        cb(new Error('An upload ID and part number are required'));
+        return;
+    }
+
+    // Accept part numbers in the range: [1, 10000].
+    var regex = /^([1-9][0-9]{0,3}|10000)$/;
+    var partNum = opts._args[1];
+    if (!regex.test(partNum)) {
+        cb(new Error('Part number must be between 1 and 10000'));
+        return;
+    }
+    partNum = parseInt(partNum, 10);
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = args[0];
+    var client = createClient(opts);
+    var filename = opts.file;
+
+    function uploadPart(stream, uploadId, num, options) {
+        stream.pause();
+        client.uploadPart(stream, uploadId, num, options, function (err, res) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            console.log(res.headers.etag);
+            cb();
+            client.close();
+            return;
+        });
+    }
+
+    function openFileStream(file, stats) {
+        var options = {
+                start: 0,
+                end: stats.size > 0 ? (stats.size - 1) : 0
+        };
+        var stream = fs.createReadStream(file, options);
+
+        return (stream);
+    }
+
+    if (filename) {
+        fs.stat(filename, function (err, stats) {
+            if (!stats.isFile()) {
+                console.err(filename + ' is not a file');
+                client.close();
+                //TODO: probably more cleanup I should do here
+                process.exit(1);
+            }
+
+            var stream = openFileStream(filename, stats);
+            opts.size = stats.size;
+            uploadPart(stream, id, partNum, opts);
+       });
+    } else {
+        uploadPart(process.stdin, id, partNum, opts);
+    }
+};
+
+
+MMpu.prototype.do_upload.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu upload options'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'Local file to upload as part',
+        helpArg: 'FILE',
+        completionType: 'file'
+    }
+]);
+
+MMpu.prototype.do_upload.help = [
+    /* BEGIN JSSTYLED */
+    'Upload a part for an existing Manta multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu upload [OPTIONS] UploadId',
+    '    mmpu upload [OPTIONS] UploadId -f [FILE]',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+
+//-- Abort
+
+MMpu.prototype.do_abort = function do_abort(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = args[0];
+    var client = createClient(opts);
+
+    client.abortUpload(id, opts, function (err) {
+        if (err) {
+            console.error('mmpu abort: error creating upload: ' + err);
+            cb(err);
+            return;
+        }
+
+        cb();
+        client.close();
+        return;
+    });
+};
+
+MMpu.prototype.do_abort.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu abort options'
+    }
+]);
+
+MMpu.prototype.do_abort.help = [
+    /* BEGIN JSSTYLED */
+    'Abort an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu abort [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- Commit
+
+// TODO: For now, this is used by just passing in the etags following the id
+// argument. It's probably better to have a more structured way of passing
+// the etags. Am open to suggestions on improving usability here.
+MMpu.prototype.do_commit = function do_commit(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var parts = [];
+    args.forEach(function parseEtag(ele, index, arr) {
+        // Skipping part 0.
+        if (index !== 0) {
+            parts[index] = ele;
+        }
+    });
+
+    var id = opts._args[0];
+    var client = createClient(opts);
+
+    client.commitUpload(id, parts, opts, function (err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        cb();
+        client.close();
+        return;
+    });
+};
+
+
+MMpu.prototype.do_commit.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu commit options'
+    }
+]);
+
+
+MMpu.prototype.do_commit.help = [
+    /* BEGIN JSSTYLED */
+    'Commit an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu commit [OPTIONS] UploadId [etag1] [etag2] ...',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- GetMPU
+
+MMpu.prototype.do_get = function do_get(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = opts._args[0];
+    var client = createClient(opts);
+
+    client.getUpload(id, opts, function (err, upload) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        console.log(upload);
+        cb();
+        client.close();
+        return;
+    });
+};
+
+
+MMpu.prototype.do_get.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu state options'
+    }
+]);
+
+
+MMpu.prototype.do_get.help = [
+    /* BEGIN JSSTYLED */
+    'Query the state of an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu state [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- ListMPU
+
+//TODO: copied from mfind. Abstract into common file?
+var TOTAL_ENTRIES = 0;
+function printEntry(opts, obj) {
+    if (opts.json) {
+        console.log(JSON.stringify(obj));
+    } else {
+        console.log(obj.parent + (obj.name ? ('/' + obj.name) : ''));
+    }
+    if (opts.limit && (++TOTAL_ENTRIES >= opts.limit)) {
+        process.exit(0);
+    }
+}
+
+
+MMpu.prototype.do_list = function do_list(subcmd, opts, args, cb) {
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var url = '/' + opts.account + '/uploads';
+    var client = createClient(opts);
+    var print = printEntry.bind(null, opts);
+
+    opts.mindepth = 1;
+    opts.maxdepth = 2;
+
+    if (opts.includeParts) {
+        opts.maxdepth = 3;
+    }
+
+    client.ftw(url, opts, function (err, res) {
+        if (err) {
+            cb(err);
+        } else {
+            res.on('entry', print);
+            res.on('end', function () {
+                client.close();
+                cb();
+            });
+        }
+    });
+};
+
+
+MMpu.prototype.do_list.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu list options'
+    },
+    {
+        names: ['includeParts', 'p'],
+        type: 'bool',
+        default: false,
+        help: 'list uploaded parts in addition to uploads',
+        helpArg: 'INCLUDE_PARTS'
+    }
+]);
+
+
+MMpu.prototype.do_list.help = [
+    /* BEGIN JSSTYLED */
+    'Lists all uploads.',
+    '',
+    'Usage:',
+    '    mmpu list [OPTIONS]',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+
+//-- GetMPU
+
+MMpu.prototype.do_parts = function do_parts(subcmd, opts, args, cb) {
+    if (args.length < 1 || args[0].length < 2) {
+        cb(new Error('A valid upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = args[0];
+    var prefix = id.charAt(0);
+    var url = '/' + opts.account + '/uploads/' + prefix + '/' + id;
+    var client = createClient(opts);
+    var print = printEntry.bind(null, opts);
+
+    opts.mindepth = 0;
+    opts.maxdepth = 1;
+
+    client.ftw(url, opts, function (err, res) {
+        if (err) {
+            cb(err);
+        } else {
+            res.on('entry', print);
+            res.on('end', function () {
+                client.close();
+                cb();
+            });
+        }
+    });
+};
+
+
+MMpu.prototype.do_parts.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu parts options'
+    }
+]);
+
+
+MMpu.prototype.do_parts.help = [
+    /* BEGIN JSSTYLED */
+    'Lists all parts for an upload.',
+    '',
+    'Usage:',
+    '    mmpu parts [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+///--- Mainline
+
+if (require.main === module) {
+    var cli = new MMpu();
+    cli.showErrStack = false;
+    cmdln.main(cli, {
+        showNoCommandErr: false
+    });
+}
diff --git a/lib/client.js b/lib/client.js
index 8de4b24..963f94d 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var EventEmitter = require('events').EventEmitter;
@@ -47,6 +47,14 @@ var TOKENS_RE = /^\/([a-zA-Z][a-zA-Z0-9_\.@]+)\/tokens/;
 
 var MAX_INT = Math.pow(2, 32) - 1;
 
+// Possible operations on a multipart upload
+var uploadOps = {
+        CREATE: 'create',
+        UPLOAD: 'upload',
+        COMMIT: 'commit',
+        ABORT: 'abort',
+        GET: 'state'
+};
 
 
 ///--- Hacks
@@ -260,6 +268,7 @@ function createRestifyClient(opts, type) {
         ca: opts.ca,
         ciphers: opts.ciphers,
         connectTimeout: opts.connectTimeout,
+        followRedirects: opts.followRedirects || false,
         headers: opts.headers,
         log: opts.log,
         pooling: opts.pooling,
@@ -475,6 +484,60 @@ function resultToInfoCb(_path, cb) {
 }
 
 
+/*
+ * Given an account and multipart upload operation (plus an upload id and a
+ * part number, if relevant), this function returns the correct url to send
+ * a multipart upload related request to.
+ *
+ * In the current implementation of multipart uploads, parts of an upload are
+ * stored at /<account>/uploads/[0-f]/<upload uuid>, where the parent directory
+ * is the first character in the upload uuid. It is possible this may change in
+ * the future, in order to allow for more simultaneoulsy ongoing multipart
+ * uploads.
+ *
+ * To allow clients an easier way to avoid knowing this exact path structure,
+ * Muskie supports a redirect mechanism in which a client can do a normal
+ * multipart upload request to the path /<account>/uploads/<upload uuid>,
+ * and muskie will redirect it to the correct path, which the client can then
+ * use for the request.
+ *
+ * Implementing this redirection for each type of upload request proved
+ * a bit more difficult than I had hoped, so for now, I am going to hardcode
+ * the prefix directory through this common function. It should be more
+ * straightforward to add redirect support later by modifying this function.
+ */
+function uploadURL(account, op, id, partNum) {
+        assert.string(account, 'account');
+        assert.string(op, 'op');
+
+        var ops = uploadOps;
+        var baseURL = '/' + account + '/uploads';
+
+        if (op === ops.CREATE) {
+                return (baseURL);
+        } else {
+                assert.string(id, 'id');
+                assert.ok(id.length > 0);
+
+                var url = baseURL + '/' + id.charAt(0) + '/' + id;
+
+                switch (op) {
+                        case ops.COMMIT:
+                                return (url + '/commit');
+                        case ops.ABORT:
+                                return (url + '/abort');
+                        case ops.GET:
+                                return (url + '/state');
+                        case ops.UPLOAD:
+                                assert.number(partNum, 'partNum');
+                                return (url + '/' + partNum);
+                        default:
+                                assert.fail('Invalid operation: ' + op);
+                                return (undefined);
+                }
+        }
+}
+
 
 ///--- API
 
@@ -1015,7 +1078,6 @@ MantaClient.prototype.ftw = function ftw(p, opts, cb) {
                                 path: name
                             });
                         }
-
                         filter(obj);
                     });
 
@@ -1852,7 +1914,6 @@ MantaClient.prototype.put = function put(p, input, opts, cb) {
     doPut(this, log, options, input, cb, opts.mkdirs);
 };
 
-
 function doPut(self, log, options, input, cb, allowretry) {
     self.signRequest({
         headers: options.headers
@@ -2433,7 +2494,7 @@ MantaClient.prototype.listJobs = function listJobs(opts, cb) {
                     try {
                         j = JSON.parse(line);
                     } catch (e) {
-                        log.warn({
+                    log.warn({
                             line: line,
                             err: e
                         }, 'ls: invalid JSON data');
@@ -3215,6 +3276,307 @@ MantaClient.prototype.path = function _getPath(p, skipEncode) {
 
 
 
+///--- Multipart Uploads API
+
+
+/*
+ * Creates a multipart upload in Manta.
+ *
+ * Parameters:
+ *  - p: the path the object will be uploaded to on commit
+ *  - opts: optional object block
+ *
+ *  Some options you might want to use are:
+ *    - size: the size of the object to be uploaded
+ *    - copies: the number of copies of the object to save
+ *    - md5: calculated md5 sum of the object
+ *    - headers: headers to define on the object
+ *
+ *  Note that if opts.headers conflicts with the values set in
+ *  opts.{size,copies,md5}, the values in the headers object will be
+ *  ovewritten with the explicitly set options values.
+ *
+ */
+MantaClient.prototype.createUpload = function createUpload(p, opts, cb) {
+        var url = uploadURL(opts.account, uploadOps.CREATE);
+        var objectPath = this.path(p);
+
+        var options = createOptions({
+                accept: 'application/json',
+                contentType: 'application/json',
+                path: url
+        }, opts);
+
+        // Headers to store with the object (not sent as headers on the request)
+        var headers = opts.headers || {};
+        if (opts.copies) {
+               headers['x-durability-level'] = parseInt(opts.copies, 10);
+        }
+
+        if (opts.size) {
+               headers['content-length'] = parseInt(opts.copies, 10);
+        }
+
+        if (opts.md5) {
+               headers['content-md5'] = parseInt(opts.copies, 10);
+        }
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+        var self = this;
+
+        log.debug('createUpload: entered');
+        self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                var body = {
+                        objectPath: objectPath,
+                        headers: headers
+                };
+                self.jsonClient.post(options, body,
+                function (err2, req, res, obj) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null, obj);
+                        }
+                });
+
+                return;
+        });
+};
+
+
+/*
+ * Uploads a part of an upload.
+ *
+ * Parameters:
+ *  - stream: stream containing the part data
+ *  - id: upload uuid
+ *  - partNum: the part number
+ */
+MantaClient.prototype.uploadPart =
+function uploadPart(stream, id, partNum, opts, cb) {
+        assert.stream(stream, 'stream');
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var op = uploadOps.UPLOAD;
+        var url = uploadURL(opts.account, op, id, partNum);
+
+        var options = createOptions({
+                accept: 'application/json',
+                expect: '100-continue',
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+
+       log.debug('uploadPart: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                function reqCb(req) {
+                        req.once('continue', function onContinue() {
+                        log.debug('uploadPart: continue received');
+                        if (stream.readable) {
+                                stream.pipe(req);
+                                stream.resume();
+                        } else {
+                                req.end();
+                        }
+                        });
+                }
+
+                function upload(uploadOptions) {
+                        self.client.put(uploadOptions, onRequestCallback({
+                                cb: cb,
+                                log: log,
+                                name: 'put',
+                                onResult: onResultCallback({
+                                        cb: cb,
+                                        log: log,
+                                        name: 'put'
+                                }),
+                                reqCb: reqCb
+                        }));
+                }
+
+                upload(options);
+        });
+};
+
+
+/*
+ * Aborts an upload.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ */
+MantaClient.prototype.abortUpload = function abortUpload(id, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.ABORT, id);
+        var options = createOptions({
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+       log.debug('abortUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                function abort(abortOptions) {
+                        self.jsonClient.post(abortOptions,
+                        function (err2, req, res, obj) {
+                                if (err2) {
+                                        cb(err2);
+                                } else {
+                                        cb();
+                                }
+                        });
+                }
+
+                abort(options);
+
+        });
+};
+
+
+/*
+ * Gets information about an upload, including its state, the path the
+ * object will be uploaded to, headers for the object, and how many
+ * copies of it will be stored.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ */
+MantaClient.prototype.getUpload = function getUpload(id, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.GET, id);
+        var options = createOptions({
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+
+       log.debug('getUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                self.jsonClient.get(options, function (err2, req, res, obj) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null, obj);
+                        }
+                });
+        });
+};
+
+
+/*
+ * Commits an upload.
+ *
+ * Parameters:
+ *  - id: upload uuid
+ *  - p: an array of part etags
+ */
+MantaClient.prototype.commitUpload = function commitUpload(id, p, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.COMMIT, id);
+        var options = createOptions({
+                accept: 'application/json',
+                contentType: 'application/json',
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+       log.debug('commitUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                var body = { parts:  p };
+                self.jsonClient.post(options, body, function (err2, req, res) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null);
+                        }
+                });
+        });
+};
 
 
 ///--- Exports
-- 
2.21.0

