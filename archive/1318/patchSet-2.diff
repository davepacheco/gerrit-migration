From a649b33d06c66bbcf2b2672e6ab346bf379655d1 Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Tue, 6 Dec 2016 22:50:33 +0000
Subject: [PATCH] MANTA-2169 Support multipart upload of a single file to Manta

---
 bin/mmpu      | 485 ++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/client.js | 334 +++++++++++++++++++++++++++++++++-
 2 files changed, 817 insertions(+), 2 deletions(-)
 create mode 100755 bin/mmpu

diff --git a/bin/mmpu b/bin/mmpu
new file mode 100755
index 0000000..28e7474
--- /dev/null
+++ b/bin/mmpu
@@ -0,0 +1,485 @@
+#!/usr/bin/env node
+// -*- mode: js -*-
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+var EventEmitter = require('events').EventEmitter;
+var fs = require('fs');
+var path = require('path');
+var util = require('util');
+
+var bunyan = require('bunyan');
+var cmdln = require('cmdln');
+
+var manta = require('../lib');
+
+
+
+///--- Globals
+
+var sprintf = util.format;
+
+var JOB_DATA_FMT = '/%s/jobs/%s/%s.txt';
+
+var NAME = path.basename(process.argv[1]);
+var LOG = bunyan.createLogger({
+    name: NAME,
+    level: (process.env.LOG_LEVEL || 'info'),
+    stream: process.stderr
+});
+
+
+
+///-- Helpers
+
+function createClient(opts) {
+    return (manta.createBinClient(opts));
+}
+
+function assertOpts(thisp, subcmd, opts, cb) {
+    if (opts.help) {
+        process.nextTick(function () {
+            thisp.do_help('help', {}, [subcmd], cb.bind(thisp));
+        });
+        return (false);
+    }
+
+    manta.cliVersionCheckPrintAndExit(opts);
+
+    try {
+        manta.checkBinEnv(opts);
+        manta.cli_logger(opts, LOG);
+    } catch (e) {
+        process.nextTick(cb.bind(thisp, e));
+        return (false);
+    }
+
+    return (true);
+}
+
+
+///--- CLI
+
+function MMpu() {
+    cmdln.Cmdln.call(this, {
+        name: 'mmpu',
+        desc: 'Manages Manta multipart uploads',
+        options: [
+            {
+                names: ['help', 'h'],
+                type: 'bool',
+                help: 'Show this help message and exit.'
+            },
+            {
+                names: ['version'],
+                type: 'bool',
+                help: 'Print version and exit.'
+            }
+        ],
+        helpOpts: {
+            includeEnv: true
+        }
+    });
+}
+util.inherits(MMpu, cmdln.Cmdln);
+
+//-- CreateUpload
+
+//TODO add headers support
+MMpu.prototype.do_create = function do_create(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('Object path must be specified'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var objectPath = args[0];
+    opts.log = LOG;
+    var client = createClient(opts);
+
+    client.createUpload(objectPath, opts, function (err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        console.log(obj.id);
+        cb();
+        return;
+    });
+};
+
+MMpu.prototype.do_create.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu create options'
+    },
+    {
+        names: ['copies', 'c'],
+        type: 'positiveInteger',
+        default: 2,
+        help: 'number of copies to make'
+    },
+    {
+        names: ['size', 's'],
+        type: 'positiveInteger',
+        help: 'size of the uploaded object'
+    }
+]);
+
+MMpu.prototype.do_create.help = [
+    /* BEGIN JSSTYLED */
+    'Initiate a Manta multipart upload for an object at Path.',
+    '',
+    'Usage:',
+    '    mmpu create [OPTIONS] Path',
+    ''
+    /* END JSSTYLED */
+].join('\n');
+
+//-- UploadPart
+
+// expected use: `mmpu upload -f file id partN`
+// OR `mmpu upload id partN` with stdin
+MMpu.prototype.do_upload = function do_upload(subcmd, opts, args, cb) {
+    if (args.length < 2) {
+        cb(new Error('An upload ID and part number are required'));
+        return;
+    }
+
+    var partNum = parseFloat(opts._args[1], 10);
+    if (!Number.isInteger(partNum)) {
+        cb(new Error('Part number must be an integer'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = args[0];
+    var client = createClient(opts);
+    var filename = opts.file;
+
+    function uploadPart(stream, uploadId, num, options) {
+        stream.pause();
+        client.uploadPart(stream, uploadId, num, options, function (err, res) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            console.log(res.headers.etag);
+            cb();
+            return;
+        });
+    }
+
+    function openFileStream(file, stats) {
+        var options = {
+                start: 0,
+                end: stats.size > 0 ? (stats.size - 1) : 0
+        };
+        var stream = fs.createReadStream(file, options);
+
+        return (stream);
+    }
+
+    if (filename) {
+        fs.stat(filename, function (err, stats) {
+            if (!stats.isFile()) {
+                console.err(filename + ' is not a file');
+                process.exit(1); //TODO proper cleanup here
+            }
+
+            var stream = openFileStream(filename, stats);
+            debugger;
+            opts.size = stats.size;
+            uploadPart(stream, id, partNum, opts);
+       });
+    } else {
+        uploadPart(process.stdin, id, partNum, opts);
+    }
+
+    //TODO close manta client?
+};
+
+MMpu.prototype.do_upload.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu upload options'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'Local file to upload as part',
+        helpArg: 'FILE',
+        completionType: 'file'
+    }
+]);
+
+MMpu.prototype.do_upload.help = [
+    /* BEGIN JSSTYLED */
+    'Upload a part of a Manta object.',
+    '',
+    'Usage:',
+    '    mmpu upload [OPTIONS] UploadId', //TODO file input option
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- Abort
+
+MMpu.prototype.do_abort = function do_abort(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = args[0];
+    var client = createClient(opts);
+
+    client.abortUpload(id, opts, function (err) {
+        if (err) {
+            console.error('mmpu abort: error creating upload: ' + err);
+            cb(err);
+            return;
+        }
+
+        cb();
+        return;
+    });
+};
+
+MMpu.prototype.do_abort.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu abort options'
+    }
+]);
+
+MMpu.prototype.do_abort.help = [
+    /* BEGIN JSSTYLED */
+    'Abort an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu abort [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- Commit
+
+// Expected use:
+// mmpu commit <id> 1=<etag> 2=<etag> ...
+// TODO: csv input
+// TODO: best format for this?
+MMpu.prototype.do_commit = function do_commit(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    //TODO: more validation here?
+    var parts = [];
+    args.forEach(function parseEtag(ele, index, arr) {
+        if (index !== 0) {
+            parts[index] = ele;
+        }
+    });
+
+    console.log(parts);
+    var id = opts._args[0];
+    var client = createClient(opts);
+
+    client.commitUpload(id, parts, opts, function (err) {
+        //console.log('commitUpload cb');
+        if (err) {
+            console.error('mmpu commit: error committing upload: ' + err);
+            cb(err);
+            return;
+        }
+
+        cb();
+        return;
+    });
+};
+
+MMpu.prototype.do_commit.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu commit options'
+    }
+]);
+
+MMpu.prototype.do_commit.help = [
+    /* BEGIN JSSTYLED */
+    'Commit an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu commit [OPTIONS] UploadId', //TODO list of parts and etags
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- GetMPU
+
+MMpu.prototype.do_get = function do_get(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = opts._args[0];
+    var client = createClient(opts);
+
+    client.getUpload(id, opts, function (err, upload) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        console.log(upload);
+        cb();
+        return;
+    });
+};
+
+MMpu.prototype.do_get.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu state options'
+    }
+]);
+
+MMpu.prototype.do_get.help = [
+    /* BEGIN JSSTYLED */
+    'Query the state of an existing multipart upload.',
+    '',
+    'Usage:',
+    '    mmpu state [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+//-- list
+
+//TODO: copied from mfind. Abstract into common file?
+var TOTAL_ENTRIES = 0;
+function printEntry(opts, obj) {
+    if (opts.json) {
+        console.log(JSON.stringify(obj));
+    } else {
+        console.log(obj.parent + (obj.name ? ('/' + obj.name) : ''));
+    }
+    if (opts.limit && (++TOTAL_ENTRIES >= opts.limit)) {
+        process.exit(0);
+    }
+}
+
+// List all uploads
+MMpu.prototype.do_list = function do_list(subcmd, opts, args, cb) {
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var url = '/' + opts.account + '/uploads';
+    var client = createClient(opts);
+    var print = printEntry.bind(null, opts);
+
+    opts.mindepth = 1; // only want full paths to parts directories
+    client.ftw(url, opts, function (err, res) {
+        if (err) {
+            cb(err);
+        } else {
+            res.on('entry', print);
+        }
+    });
+};
+
+MMpu.prototype.do_list.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu list options'
+    }
+]);
+
+MMpu.prototype.do_list.help = [
+    /* BEGIN JSSTYLED */
+    'Lists all uploads.',
+    '',
+    'Usage:',
+    '    mmpu list [OPTIONS]',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+
+//-- parts
+
+MMpu.prototype.do_parts = function do_parts(subcmd, opts, args, cb) {
+    if (args.length < 1) {
+        cb(new Error('An upload ID is required'));
+        return;
+    }
+
+    if (!assertOpts(this, subcmd, opts, cb))
+        return;
+
+    var id = opts._args[0];
+    var client = createClient(opts);
+
+    client.getUpload(id, opts, function (err, upload) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        console.log(upload);
+        cb();
+        return;
+    });
+};
+
+MMpu.prototype.do_parts.options = manta.DEFAULT_CLI_OPTIONS.concat([
+    {
+        group: 'mmpu parts options'
+    }
+]);
+
+MMpu.prototype.do_parts.help = [
+    /* BEGIN JSSTYLED */
+    'Lists all parts for an upload.',
+    '',
+    'Usage:',
+    '    mmpu parts [OPTIONS] UploadId',
+    '',
+    '{{options}}'
+    /* END JSSTYLED */
+].join('\n');
+
+
+///--- Mainline
+
+if (require.main === module) {
+    var cli = new MMpu();
+    cli.showErrStack = false;
+    cmdln.main(cli, {
+        showNoCommandErr: false
+    });
+}
diff --git a/lib/client.js b/lib/client.js
index 8de4b24..1bfdb09 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -260,6 +260,7 @@ function createRestifyClient(opts, type) {
         ca: opts.ca,
         ciphers: opts.ciphers,
         connectTimeout: opts.connectTimeout,
+        followRedirects: opts.followRedirects || false,
         headers: opts.headers,
         log: opts.log,
         pooling: opts.pooling,
@@ -308,6 +309,14 @@ function getJobPath(p, user) {
 }
 
 
+function getUploadsPath(p, user) {
+    if (user && !/^\/.*\/uploads/.test(p))
+        p = '/' + user + '/uploads/' + p;
+
+    return (path.posix.normalize(p).replace(/\/$/, ''));
+}
+
+
 function onRequestCallback(opts) {
     function onRequest(err, req) {
         if (err) {
@@ -535,6 +544,7 @@ function MantaClient(options) {
         ca: options.ca,
         ciphers: options.ciphers,
         connectTimeout: options.connectTimeout,
+        followRedirects: options.followRedirects,
         headers: normalizeHeaders(options.headers),
         log: self.log,
         rejectUnauthorized: options.rejectUnauthorized,
@@ -549,6 +559,7 @@ function MantaClient(options) {
         ca: options.ca,
         ciphers: options.ciphers,
         connectTimeout: options.connectTimeout,
+        followRedirects: options.followRedirects,
         headers: normalizeHeaders(options.headers),
         log: self.log,
         rejectUnauthorized: options.rejectUnauthorized,
@@ -903,6 +914,7 @@ MantaClient.prototype.get = function get(p, opts, cb) {
  *  - p: string path
  *  - opts: (optional) object block where you can set headers, et al.
  */
+//XXX: this is only for reading from manta, I think
 MantaClient.prototype.createReadStream = function createReadStream(p, opts) {
     assert.string(p, 'path');
     assert.optionalObject(opts, 'options');
@@ -1852,7 +1864,6 @@ MantaClient.prototype.put = function put(p, input, opts, cb) {
     doPut(this, log, options, input, cb, opts.mkdirs);
 };
 
-
 function doPut(self, log, options, input, cb, allowretry) {
     self.signRequest({
         headers: options.headers
@@ -2433,7 +2444,8 @@ MantaClient.prototype.listJobs = function listJobs(opts, cb) {
                     try {
                         j = JSON.parse(line);
                     } catch (e) {
-                        log.warn({
+
+                   log.warn({
                             line: line,
                             err: e
                         }, 'ls: invalid JSON data');
@@ -3213,8 +3225,326 @@ MantaClient.prototype.path = function _getPath(p, skipEncode) {
     return (getPath(p, this.user, skipEncode));
 };
 
+var uploadOps = {
+        CREATE: 'create',
+        UPLOAD: 'upload',
+        COMMIT: 'commit',
+        ABORT: 'abort',
+        GET: 'state'
+};
+
+
+function uploadURL(account, op, id, partNum) {
+        assert.string(account, 'account');
+        assert.string(op, 'op');
+
+        var ops = uploadOps;
+        var baseURL = '/' + account + '/uploads';
+
+        if (op === ops.CREATE) {
+                return (baseURL);
+        } else {
+                assert.string(id, 'id');
+                assert.ok(id.length > 0);
+
+                var url = baseURL + '/' + id.charAt(0) + '/' + id;
+
+                switch (op) {
+                        case ops.COMMIT:
+                                return (url + '/commit');
+                        case ops.ABORT:
+                                return (url + '/abort');
+                        case ops.GET:
+                                return (url + '/state');
+                        case ops.UPLOAD:
+                                assert.number(partNum, 'partNum');
+                                return (url + '/' + partNum);
+                        default:
+                                assert.fail('Invalid operation: ' + op);
+                                return (undefined);
+                }
+        }
+}
+
+
+// Multipart uploads API
+MantaClient.prototype.createUpload = function createUpload(p, opts, cb) {
+        var url = uploadURL(opts.account, uploadOps.CREATE);
+        var objectPath = this.path(p);
+
+        var options = createOptions({
+                accept: 'application/json',
+                contentType: 'application/json',
+                path: url
+        }, opts);
+
+        if (opts.copies) {
+                options.headers['x-durability-level'] =
+                        parseInt(opts.copies, 10);
+        }
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+        var self = this;
+
+        log.debug('createUpload: entered');
+        self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                var body = {
+                        objectPath: objectPath
+                };
+                self.jsonClient.post(options, body,
+                function (err2, req, res, obj) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null, obj);
+                        }
+                });
+
+                return;
+        });
+};
+
+function getUploadPath(mantaClient, options, op, cb) {
+        assert.object(mantaClient, 'mantaClient');
+        assert.object(options, 'options');
+        assert.string(op, 'op');
 
+        function redirectCb(err, req, res) {
+                if (err) {
+                        cb(err);
+                } else {
+                        if (res.headers.location) {
+                                cb(null, res.headers.location);
+                        } else {
+                                cb(new Error('Invalid upload ID'));
+                        }
+                }
+        }
 
+        var ops = uploadOps;
+        switch (op) {
+                case ops.CREATE:
+                case ops.COMMIT:
+                case ops.ABORT:
+                        mantaClient.jsonClient.post(options, redirectCb);
+                        break;
+                case ops.GET:
+                        mantaClient.client.get(options, redirectCb);
+                        break;
+                case ops.UPLOAD:
+                        mantaClient.client.put(options, redirectCb);
+                        break;
+                default:
+                        assert.fail('Invalid operation: ' + op);
+                        break;
+        }
+}
+
+
+MantaClient.prototype.uploadPart =
+function uploadPart(stream, id, partNum, opts, cb) {
+        assert.stream(stream, 'stream');
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var op = uploadOps.UPLOAD;
+        var url = uploadURL(opts.account, op, id, partNum);
+
+        var options = createOptions({
+                accept: 'application/json',
+                expect: '100-continue',
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+
+       log.debug('uploadPart: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                function reqCb(req) {
+                        req.once('continue', function onContinue() {
+                        log.debug('uploadPart: continue received');
+                        if (stream.readable) {
+                                stream.pipe(req);
+                                stream.resume();
+                        } else {
+                                req.end();
+                        }
+                        });
+                }
+
+                function upload(uploadOptions) {
+                        self.client.put(uploadOptions, onRequestCallback({
+                                cb: cb,
+                                log: log,
+                                name: 'put',
+                                onResult: onResultCallback({
+                                        cb: cb,
+                                        log: log,
+                                        name: 'put'
+                                }),
+                                reqCb: reqCb
+                        }));
+                }
+
+                upload(options);
+        });
+};
+
+
+MantaClient.prototype.abortUpload = function abortUpload(id, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.ABORT, id);
+        var options = createOptions({
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+       log.debug('abortUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                function abort(abortOptions) {
+                        self.jsonClient.post(abortOptions,
+                        function (err2, req, res, obj) {
+                                if (err2) {
+                                        cb(err2);
+                                } else {
+                                        cb();
+                                }
+                        });
+                }
+
+                abort(options);
+
+        });
+};
+
+
+MantaClient.prototype.getUpload = function getUpload(id, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.GET, id);
+        var options = createOptions({
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+
+       log.debug('getUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                self.jsonClient.get(options, function (err2, req, res, obj) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null, obj);
+                        }
+                });
+        });
+};
+
+
+MantaClient.prototype.commitUpload = function commitUpload(id, p, opts, cb) {
+        assert.string(id, 'id');
+        assert.object(opts, 'options');
+        assert.func(cb, 'callback');
+
+        var url = uploadURL(opts.account, uploadOps.COMMIT, id);
+        var options = createOptions({
+                accept: 'application/json',
+                contentType: 'application/json',
+                contentMD5: opts.md5,
+                contentLength: opts.size,
+                path: url
+        }, opts);
+
+        var log = this.log.child({
+                path: url,
+                req_id: options.id
+        }, true);
+
+       var self = this;
+       log.debug('commitUpload: entered');
+       self.signRequest({
+                headers: options.headers
+        }, function onSignRequest(err) {
+                if (err) {
+                        log.debug('onSignRequest error: ' + err);
+                        cb(err);
+                        return;
+                }
+
+                var body = { parts:  p };
+                self.jsonClient.post(options, body, function (err2, req, res) {
+                        if (err2) {
+                                log.debug('jsonClient error: ' + err2);
+                                cb(err2);
+                        } else {
+                                cb(null);
+                        }
+                });
+        });
+};
 
 
 ///--- Exports
-- 
2.21.0

