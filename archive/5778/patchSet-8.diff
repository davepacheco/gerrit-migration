From 5648492a6a1d4b980a39a6afe84bb7c8d165d3dc Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 12 Mar 2019 15:05:55 -0700
Subject: [PATCH] MANTA-4172 zk client ping timeouts not working Reviewed by:
 Robert Mustacchi <rm@joyent.com> Approved by: Joshua M. Clulow
 <jmc@joyent.com>

---
 CHANGELOG.md             |   7 +-
 lib/ConnectionManager.js | 149 +++++++++++++++++++++++++++++++++++++++
 package.json             |   2 +-
 3 files changed, 156 insertions(+), 2 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5615226..64dca30 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,13 @@
 # Change Log
 
+## 0.2.3
+
+1. MANTA-4172: zk client ping timeouts not working
+
 ## 0.2.2
 
-1. [Issue #31: WatcherManager leaks memory on un-rewatched nodes](https://github.com/alexguan/node-zookeeper-client/issues/31)
+1. MORAY-398: moray caught connecting to deposed peer
+2. [Issue #31: WatcherManager leaks memory on un-rewatched nodes](https://github.com/alexguan/node-zookeeper-client/issues/31)
 
 ## 0.2.1
 
diff --git a/lib/ConnectionManager.js b/lib/ConnectionManager.js
index 1c63046..ec1af5c 100644
--- a/lib/ConnectionManager.js
+++ b/lib/ConnectionManager.js
@@ -33,6 +33,16 @@ var STATES = { // Connection States.
     AUTHENTICATION_FAILED : -4
 };
 
+var STATES_REV = {}; // Reverse lookup for connection states
+
+Object.keys(STATES).forEach(function (k) {
+    STATES_REV[STATES[k]] = k;
+});
+
+// Keep ping history for this long (ms)
+var PING_HISTORY = 5 * 60 * 1000;
+// Keep this many state history entries
+var MAX_STATE_HISTORY = 16;
 
 /**
  * Construct a new ConnectionManager instance.
@@ -92,11 +102,55 @@ function ConnectionManager(connectionString, options, stateListener) {
     this.packetQueue.on('readable', this.onPacketQueueReadable.bind(this));
     this.pendingQueue = [];
 
+    this.pings = [];
+    this.counters = {};
+    this.stateHistory = [];
+
     this.on('state', stateListener);
+
+    this.register();
 }
 
 utils.inherits(ConnectionManager, events.EventEmitter);
 
+/*
+ * Keep a list of all the instances of ConnectionManager that are running
+ * in the process in a convenient place for the debugger to find.
+ *
+ * The thing we export from this module is ConnectionManager() the function, so
+ * we stash it on a property of that. Module exports are faster to find than
+ * file-scope variables (no heap scan needed).
+ */
+ConnectionManager.instances = [];
+
+ConnectionManager.prototype.register = function () {
+    ConnectionManager.instances.push(this);
+};
+
+ConnectionManager.prototype.unregister = function () {
+    var insts = ConnectionManager.instances;
+    var idx = insts.indexOf(this);
+
+    if (idx !== -1) {
+        insts.splice(idx, 1);
+    }
+};
+
+/*
+ * Similarly, there are a few global counters we would like to keep track of
+ * (as well as their per-instance values)
+ */
+ConnectionManager.counters = {};
+
+ConnectionManager.prototype.bumpCounter = function (ctr) {
+    if (this.counters[ctr] === undefined)
+        this.counters[ctr] = 0;
+    ++this.counters[ctr];
+    if (ConnectionManager.counters[ctr] === undefined)
+        ConnectionManager.counters[ctr] = 0;
+    ++ConnectionManager.counters[ctr];
+};
+
 /**
  * Update the session timeout and related timeout variables.
  *
@@ -163,10 +217,23 @@ ConnectionManager.prototype.setState = function (state) {
         throw new Error('state must be a valid number.');
     }
 
+    this.stateHistory.push({
+        state: STATES_REV[state],
+        time: new Date()
+    });
+    this.bumpCounter('state-' + STATES_REV[state]);
+    while (this.stateHistory.length > MAX_STATE_HISTORY) {
+        this.stateHistory.shift();
+    }
+
     if (this.state !== state) {
         this.state = state;
         this.emit('state', this.state);
     }
+
+    if (state === STATES.CLOSED) {
+        this.unregister();
+    }
 };
 
 ConnectionManager.prototype.registerDataWatcher = function (path, watcher) {
@@ -253,6 +320,18 @@ ConnectionManager.prototype.onSocketClosed = function (hasError) {
         errorCode,
         pendingPacket;
 
+    var now = new Date();
+
+    this.pings.forEach(function (ping) {
+        if (ping.timer) {
+            clearTimeout(ping.timer);
+            ping.timer = null;
+        }
+        if (!ping.received) {
+            ping.killed = now;
+        }
+    });
+
     switch (this.state) {
     case STATES.CLOSING:
         errorCode = Exception.CONNECTION_LOSS;
@@ -261,6 +340,7 @@ ConnectionManager.prototype.onSocketClosed = function (hasError) {
     case STATES.SESSION_EXPIRED:
         errorCode = Exception.SESSION_EXPIRED;
         retry = false;
+        this.bumpCounter('session-expired');
         break;
     case STATES.AUTHENTICATION_FAILED:
         errorCode = Exception.AUTH_FAILED;
@@ -269,6 +349,7 @@ ConnectionManager.prototype.onSocketClosed = function (hasError) {
     default:
         errorCode = Exception.CONNECTION_LOSS;
         retry = true;
+        this.bumpCounter('connection-lost');
     }
 
     this.cleanupPendingQueue(errorCode);
@@ -285,6 +366,8 @@ ConnectionManager.prototype.onSocketError = function (error) {
     if (this.connectTimeoutHandler) {
         clearTimeout(this.connectTimeoutHandler);
     }
+    this.lastSocketError = error;
+    this.bumpCounter('socket-error');
 
     // After socket error, the socket closed event will be triggered,
     // we will retry connect in that listener function.
@@ -293,6 +376,7 @@ ConnectionManager.prototype.onSocketError = function (error) {
 ConnectionManager.prototype.onSocketConnectTimeout = function () {
     // Destroy the current socket so the socket closed event
     // will be trigger.
+    this.bumpCounter('connect-timeout');
     this.socket.destroy();
 };
 
@@ -363,6 +447,20 @@ ConnectionManager.prototype.onSocketTimeout = function () {
             jute.XID_PING,
             jute.OP_CODES.PING
         );
+        var self = this;
+        var sent = new Date();
+        var socket = this.socket;
+        var ping = {};
+        var timer = setTimeout(function () {
+            ping.expired = new Date();
+            self.bumpCounter('ping-timeout');
+            socket.destroy();
+        }, this.pingTimeout);
+
+        ping.timer = timer;
+        ping.sent = sent;
+
+        this.pings.push(ping);
 
         request = new jute.Request(header, null);
         this.queue(request);
@@ -458,6 +556,53 @@ ConnectionManager.prototype.onSocketData = function (buffer) {
         // TODO BETTTER LOGGING
         switch (responseHeader.xid) {
         case jute.XID_PING:
+
+            /*
+             * Find the first ping on the self.pings array that hasn't been
+             * marked as received or killed.
+             *
+             * The array contains a bunch of "used" pings as well as ones that
+             * are still outstanding.
+             */
+            var outstanding = self.pings.filter(function (p) {
+                return (!p.received && !p.killed);
+            });
+            var next = outstanding.shift();
+
+            if (!next) {
+
+                /*
+                 * No outstanding ping. This is probably a bug, but we have no
+                 * logger here to log out, and it's probably not worthy of
+                 * being fatal.
+                 */
+                self.bumpCounter('spurious-ping');
+                break;
+            }
+            var now = new Date();
+
+            next.received = now;
+            if (next.timer) {
+                clearTimeout(next.timer);
+                next.timer = null;
+            }
+
+            /*
+             * Remove any pings older than PING_HISTORY so it doesn't grow
+             * without bound.
+             */
+            while (self.pings[0]) {
+                var ping = self.pings[0];
+                var delta = now.getTime() - ping.sent.getTime();
+
+                if (!ping.received && !ping.killed) {
+                    break;
+                }
+                if (delta < PING_HISTORY) {
+                    break;
+                }
+                self.pings.shift();
+            }
             break;
         case jute.XID_AUTHENTICATION:
             if (responseHeader.err === Exception.AUTH_FAILED) {
@@ -472,6 +617,7 @@ ConnectionManager.prototype.onSocketData = function (buffer) {
             }
 
             offset += event.deserialize(buffer, offset);
+            self.bumpCounter('notification');
             self.watcherManager.emit(event);
             break;
         default:
@@ -483,6 +629,7 @@ ConnectionManager.prototype.onSocketData = function (buffer) {
                 // throw new Error(
                 //    'Nothing in pending queue but got data from server.'
                 // );
+                self.bumpCounter('spurious-response');
                 self.socket.destroy(); // this will trigger reconnect
                 return;
             }
@@ -496,6 +643,7 @@ ConnectionManager.prototype.onSocketData = function (buffer) {
                         // responseHeader.err + ', expected xid: ' +
                         // pendingPacket.request.header.xid + '.'
                 // );
+                self.bumpCounter('cxid-mismatch');
                 self.socket.destroy(); // this will trigger reconnect
                 return;
             }
@@ -546,6 +694,7 @@ ConnectionManager.prototype.onSocketData = function (buffer) {
                 default:
                     // throw new Error('Unknown request OP_CODE: ' +
                         // pendingPacket.request.header.type);
+                    self.bumpCounter('bad-opcode');
                     self.socket.destroy(); // this will trigger reconnect
                     return;
                 }
diff --git a/package.json b/package.json
index e7dc5c7..7c814b2 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "joyent-zookeeper-client",
-  "version": "0.2.2",
+  "version": "0.2.3",
   "description": "A pure Javascript ZooKeeper client for Node.js.",
   "author": "Alex Guan <alex.guan@gmail.com>",
   "main": "index.js",
-- 
2.21.0

