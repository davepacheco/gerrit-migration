commit aacc1e2fd1cb82648742d4d291c23d263a242a9e
Author: John Levon <john.levon@joyent.com>
Date:   2019-03-20T21:34:44+00:00 (7 months ago)
    
    OS-7675 would like a way to set kmdb_on_nmi at boot time

diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
index 30644ad12a..b1a0b9c3d0 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
@@ -23,7 +23,7 @@
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  * Copyright (c) 2016, 2017 by Delphix. All rights reserved.
  */
 
@@ -808,6 +808,8 @@ gethrtime_again:
 void
 apic_nmi_intr(caddr_t arg, struct regs *rp)
 {
+	int action = nmi_action;
+
 	if (apic_shutdown_processors) {
 		apic_disable_local_apic();
 		return;
@@ -819,18 +821,41 @@ apic_nmi_intr(caddr_t arg, struct regs *rp)
 		return;
 	apic_num_nmis++;
 
-	if (apic_kmdb_on_nmi && psm_debugger()) {
-		debug_enter("NMI received: entering kmdb\n");
-	} else if (apic_panic_on_nmi) {
-		/* Keep panic from entering kmdb. */
-		nopanicdebug = 1;
-		panic("NMI received\n");
-	} else {
+	/*
+	 * "nmi_action" always over-rides the older way of doing this, unless we
+	 * can't actually drop into kmdb when requested.
+	 */
+	if (action == NMI_ACTION_KMDB && !psm_debugger())
+		action = NMI_ACTION_UNSET;
+
+	if (action == NMI_ACTION_UNSET) {
+		if (apic_kmdb_on_nmi && psm_debugger())
+			action = NMI_ACTION_KMDB;
+		else if (apic_panic_on_nmi)
+			action = NMI_ACTION_PANIC;
+		else
+			action = NMI_ACTION_IGNORE;
+	}
+
+	switch (action) {
+	case NMI_ACTION_IGNORE:
 		/*
 		 * prom_printf is the best shot we have of something which is
 		 * problem free from high level/NMI type of interrupts
 		 */
 		prom_printf("NMI received\n");
+		break;
+
+	case NMI_ACTION_PANIC:
+		/* Keep panic from entering kmdb. */
+		nopanicdebug = 1;
+		panic("NMI received\n");
+		break;
+
+	case NMI_ACTION_KMDB:
+	default:
+		debug_enter("NMI received: entering kmdb\n");
+		break;
 	}
 
 	lock_clear(&apic_nmi_lock);
diff --git a/usr/src/uts/i86pc/os/fakebop.c b/usr/src/uts/i86pc/os/fakebop.c
index 7bbd6b369f..44ef06ee48 100644
--- a/usr/src/uts/i86pc/os/fakebop.c
+++ b/usr/src/uts/i86pc/os/fakebop.c
@@ -2009,14 +2009,14 @@ bop_trap(ulong_t *tfp)
 	if (tf->code_seg != B64CODE_SEL)
 		tf = (struct trapframe *)(tfp - 1);
 	else
-		bop_printf(NULL, "error code           0x%lx\n",
+		bop_printf(NULL, "error code	   0x%lx\n",
 		    tf->error_code & 0xffffffff);
 
 	bop_printf(NULL, "instruction pointer  0x%lx\n", tf->inst_ptr);
-	bop_printf(NULL, "code segment         0x%lx\n", tf->code_seg & 0xffff);
+	bop_printf(NULL, "code segment	 0x%lx\n", tf->code_seg & 0xffff);
 	bop_printf(NULL, "flags register       0x%lx\n", tf->flags_reg);
-	bop_printf(NULL, "return %%rsp          0x%lx\n", tf->stk_ptr);
-	bop_printf(NULL, "return %%ss           0x%lx\n", tf->stk_seg & 0xffff);
+	bop_printf(NULL, "return %%rsp	  0x%lx\n", tf->stk_ptr);
+	bop_printf(NULL, "return %%ss	   0x%lx\n", tf->stk_seg & 0xffff);
 
 	/* grab %[er]bp pushed by our code from the stack */
 	fakeframe.old_frame = (bop_frame_t *)*(tfp - 3);
@@ -2915,10 +2915,8 @@ boot_compinfo(int fd, struct compinfo *cbp)
 	return (0);
 }
 
-#define	BP_MAX_STRLEN	32
-
 /*
- * Get value for given boot property
+ * Get an integer value for given boot property
  */
 int
 bootprop_getval(const char *prop_name, u_longlong_t *prop_value)
@@ -2938,3 +2936,15 @@ bootprop_getval(const char *prop_name, u_longlong_t *prop_value)
 
 	return (0);
 }
+
+int
+bootprop_getstr(const char *prop_name, char *buf, size_t buflen)
+{
+	int boot_prop_len = BOP_GETPROPLEN(bootops, prop_name);
+
+	if (boot_prop_len < 0 || boot_prop_len >= buflen ||
+	    BOP_GETPROP(bootops, prop_name, buf) < 0)
+		return (-1);
+
+	return (0);
+}
diff --git a/usr/src/uts/i86pc/os/intr.c b/usr/src/uts/i86pc/os/intr.c
index 0634df1a94..4e68f87893 100644
--- a/usr/src/uts/i86pc/os/intr.c
+++ b/usr/src/uts/i86pc/os/intr.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018 Joyent, Inc.  All rights reserverd.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -508,6 +508,8 @@ ulong_t lastcli[NCPU];
 
 #endif
 
+int nmi_action = NMI_ACTION_UNSET;
+
 void do_interrupt(struct regs *rp, trap_trace_rec_t *ttp);
 
 void (*do_interrupt_common)(struct regs *, trap_trace_rec_t *) = do_interrupt;
diff --git a/usr/src/uts/i86pc/os/mlsetup.c b/usr/src/uts/i86pc/os/mlsetup.c
index 7c17aab541..c712c9ea25 100644
--- a/usr/src/uts/i86pc/os/mlsetup.c
+++ b/usr/src/uts/i86pc/os/mlsetup.c
@@ -23,7 +23,7 @@
  *
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2011 by Delphix. All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -103,6 +103,7 @@ void
 mlsetup(struct regs *rp)
 {
 	u_longlong_t prop_value;
+	char prop_str[BP_MAX_STRLEN];
 	extern struct classfuncs sys_classfuncs;
 	extern disp_t cpu0_disp;
 	extern char t0stack[];
@@ -149,6 +150,19 @@ mlsetup(struct regs *rp)
 		cpuid_feature_edx_exclude = (uint32_t)prop_value;
 
 #if !defined(__xpv)
+	if (bootprop_getstr("nmi", prop_str, sizeof (prop_str)) == 0) {
+		if (strcmp(prop_str, "ignore") == 0) {
+			nmi_action = NMI_ACTION_IGNORE;
+		} else if (strcmp(prop_str, "panic") == 0) {
+			nmi_action = NMI_ACTION_PANIC;
+		} else if (strcmp(prop_str, "kmdb") == 0) {
+			nmi_action = NMI_ACTION_KMDB;
+		} else {
+			prom_printf("unix: ignoring unknown nmi=%s\n",
+			    prop_str);
+		}
+	}
+
 	/*
 	 * Check to see if KPTI has been explicitly enabled or disabled.
 	 * We have to check this before init_desctbls().
diff --git a/usr/src/uts/i86pc/sys/apic_common.h b/usr/src/uts/i86pc/sys/apic_common.h
index 03e851a4dc..f346a32fcc 100644
--- a/usr/src/uts/i86pc/sys/apic_common.h
+++ b/usr/src/uts/i86pc/sys/apic_common.h
@@ -23,7 +23,7 @@
  * Copyright (c) 2017 by Delphix. All rights reserved.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _SYS_APIC_COMMON_H
@@ -155,7 +155,6 @@ extern lock_t	apic_nmi_lock;
 extern lock_t	apic_error_lock;
 
 /* Patchable global variables. */
-extern int	apic_kmdb_on_nmi;	/* 0 - no, 1 - yes enter kmdb */
 extern uint32_t	apic_divide_reg_init;	/* 0 - divide by 2 */
 
 extern apic_intrmap_ops_t *apic_vt_ops;
diff --git a/usr/src/uts/intel/sys/archsystm.h b/usr/src/uts/intel/sys/archsystm.h
index 0c9ceac7be..06400455fe 100644
--- a/usr/src/uts/intel/sys/archsystm.h
+++ b/usr/src/uts/intel/sys/archsystm.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _SYS_ARCHSYSTM_H
@@ -152,6 +152,13 @@ extern int use_sse_pagecopy;
 extern int use_sse_pagezero;
 extern int use_sse_copy;
 
+#define	NMI_ACTION_UNSET (0)
+#define	NMI_ACTION_PANIC (1)
+#define	NMI_ACTION_IGNORE (2)
+#define	NMI_ACTION_KMDB (3)
+
+extern int nmi_action;
+
 extern caddr_t i86devmap(pfn_t, pgcnt_t, uint_t);
 extern page_t *page_numtopp_alloc(pfn_t pfnum);
 
diff --git a/usr/src/uts/intel/sys/bootconf.h b/usr/src/uts/intel/sys/bootconf.h
index 27a89206cf..f0ade9d94d 100644
--- a/usr/src/uts/intel/sys/bootconf.h
+++ b/usr/src/uts/intel/sys/bootconf.h
@@ -23,6 +23,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2016 Nexenta Systems, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef	_SYS_BOOTCONF_H
@@ -46,6 +47,8 @@
 extern "C" {
 #endif
 
+#define	BP_MAX_STRLEN	32
+
 /*
  * Boot property names
  */
@@ -243,6 +246,7 @@ extern void bop_panic(const char *, ...)
 extern void boot_prop_finish(void);
 
 extern int bootprop_getval(const char *, u_longlong_t *);
+extern int bootprop_getstr(const char *, char *, size_t);
 
 /*
  * Back door to fakebop.c to get physical memory allocated.
