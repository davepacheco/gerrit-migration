From 264076b68cfb0ef2e8f087a4c022e717b7e000f4 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 26 Jan 2017 14:17:58 -0800
Subject: [PATCH] joyent/node-mooremachine#13 want DTrace probe support

---
 README.md    | 40 +++++++++++++++++++++++++++++
 lib/fsm.js   | 71 +++++++++++++++++++++++++++++++++++++++++++++-------
 package.json |  5 +++-
 3 files changed, 106 insertions(+), 10 deletions(-)

diff --git a/README.md b/README.md
index 67321ca..cac6b29 100644
--- a/README.md
+++ b/README.md
@@ -286,3 +286,43 @@ for each sub-state entered.
 Once a handle is used to transition to an unrelated state (e.g. `'closed'` in
 the example), all handlers are torn down (from both the parent state and
 sub-state) as usual before entering the new state.
+
+DTrace support
+--------------
+
+Mooremachine has support for DTrace probes using `dtrace-provider` (and
+`libusdt`). The following probes are provided under the
+`moorefsm$pid` provider:
+
+ * `create-fsm(char *klass, char *id)` -- fired at the creation of a new FSM
+   instance. The `klass` argument contains the string name of the constructor
+   of the FSM sub-class. The `id` argument contains a short randomly generated
+   string that should be unique to this FSM as long as <~6M instances of this
+   class exist in the program (it consists of 64 random bits, base64-encoded,
+   so about a 1/1M chance of collision at 6M instances).
+ * `transition-start(char *klass, char *id, char *oldState, char *newState)` --
+   fired at the beginning of an FSM transitioning to a new state.
+ * `transition-end(char *klass, char *id, char *oldState, char *newState)` --
+   fired at the end of an FSM transitioning to a new state.
+
+For example:
+
+```
+dtrace -c 'node thingfsm.js' -n '
+    moorefsm$target:::transition-start
+    /copyinstr(arg0) == "ThingFSM"/
+    {
+        printf("%s => %s", copyinstr(arg2), copyinstr(arg3));
+    }'
+```
+
+When used on the `ThingFSM` above might output:
+
+```
+CPU     ID                    FUNCTION:NAME
+  4   8216 transition-start:transition-start undefined => stopped
+  4   8216 transition-start:transition-start stopped => connecting
+  4   8216 transition-start:transition-start connecting => error
+```
+
+This is will list all the transitions of `ThingFSM` instances.
diff --git a/lib/fsm.js b/lib/fsm.js
index 09ad2a0..7ab2696 100644
--- a/lib/fsm.js
+++ b/lib/fsm.js
@@ -10,10 +10,31 @@
 
 module.exports = FSM;
 
-var assert = require('assert-plus');
-var util = require('util');
+var mod_assert = require('assert-plus');
+var mod_util = require('util');
 var EventEmitter = require('events').EventEmitter;
 
+var mod_dtrace;
+
+try {
+	mod_dtrace = require('dtrace-provider');
+} catch (e) {
+	mod_dtrace = undefined;
+}
+
+var dt;
+if (mod_dtrace !== undefined) {
+	dt = {};
+
+	dt.provider = mod_dtrace.createDTraceProvider('moorefsm');
+	dt.create = dt.provider.addProbe('create-fsm', 'char *', 'char *');
+	dt.start = dt.provider.addProbe('transition-start', 'char *', 'char *',
+	    'char *', 'char *');
+	dt.end = dt.provider.addProbe('transition-end', 'char *', 'char *',
+	    'char *', 'char *');
+	dt.provider.enable();
+}
+
 function FSMStateHandle(fsm, state, link) {
 	this.fsh_fsm = fsm;
 	this.fsh_link = link;
@@ -30,7 +51,7 @@ function FSMStateHandle(fsm, state, link) {
 FSMStateHandle.prototype.validTransitions = function (states) {
 	if (this.fsh_validTransitions !== undefined)
 		throw (new Error('FSM validTransitions already set'));
-	assert.arrayOfString(states, 'states');
+	mod_assert.arrayOfString(states, 'states');
 	this.fsh_validTransitions = states;
 };
 
@@ -173,7 +194,11 @@ FSMStateHandle.prototype.callback = function (cb) {
  * used with "onState".
  */
 function FSM(defState) {
-	assert.string(defState, 'default state');
+	mod_assert.string(defState, 'default state');
+	this.fsm_id = FSM.genId();
+	this.fsm_clsname = this.constructor.name;
+	if (this.fsm_clsname.length === 0)
+		this.fsm_clsname = 'FSM';
 	this.fsm_history = [];
 	this.fsm_handle = undefined;
 	this.fsm_inTransition = false;
@@ -182,9 +207,22 @@ function FSM(defState) {
 	this.fsm_state = undefined;
 	this.fsm_toEmit = [];
 	EventEmitter.call(this);
+	if (dt !== undefined) {
+		var self = this;
+		dt.create.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id]);
+		});
+	}
 	this._gotoState(defState);
 }
-util.inherits(FSM, EventEmitter);
+mod_util.inherits(FSM, EventEmitter);
+
+FSM.genId = function () {
+	var b = new Buffer(8);
+	b.writeUInt32BE(Math.random() * 4294967296, 0);
+	b.writeUInt32BE(Math.random() * 4294967296, 4);
+	return (b.toString('base64').slice(0, 11));
+};
 
 FSM.prototype.getState = function () {
 	return (this.fsm_state);
@@ -196,7 +234,7 @@ FSM.prototype.isInState = function (state) {
 };
 
 FSM.prototype.allStateEvent = function (evt) {
-	assert.string(evt, 'event');
+	mod_assert.string(evt, 'event');
 	if (this.fsm_allStateEvents === undefined)
 		this.fsm_allStateEvents = [];
 	this.fsm_allStateEvents.push(evt);
@@ -204,14 +242,23 @@ FSM.prototype.allStateEvent = function (evt) {
 
 /* Transition the FSM to a new state. */
 FSM.prototype._gotoState = function (state) {
-	assert.string(state, 'state');
+	mod_assert.string(state, 'state');
 
 	if (this.fsm_inTransition) {
-		assert.ok(this.fsm_nextState === undefined);
+		mod_assert.ok(this.fsm_nextState === undefined);
 		this.fsm_nextState = state;
 		return;
 	}
 
+	var self = this;
+	var oldState = this.fsm_state;
+	if (dt !== undefined) {
+		dt.start.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id,
+			    oldState, state]);
+		});
+	}
+
 	/*
 	 * First, kill event handlers and timers from our previous state, as
 	 * needed.
@@ -273,7 +320,6 @@ FSM.prototype._gotoState = function (state) {
 	f.call(this, this.fsm_handle);
 	this.fsm_inTransition = false;
 
-	var self = this;
 	this.fsm_allStateEvents.forEach(function (evt) {
 		if (self.listeners(evt).length < 1) {
 			throw (new Error('FSM consistency error: ' +
@@ -294,6 +340,13 @@ FSM.prototype._gotoState = function (state) {
 		});
 	}
 
+	if (dt !== undefined) {
+		dt.end.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id,
+			    oldState, state]);
+		});
+	}
+
 	var next = this.fsm_nextState;
 	if (next !== undefined) {
 		this.fsm_nextState = undefined;
diff --git a/package.json b/package.json
index e19e41f..ce2b3b0 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "mooremachine",
-  "version": "2.0.1",
+  "version": "2.1.0",
   "description": "Moore finite state machines",
   "main": "lib/index.js",
   "scripts": {
@@ -31,6 +31,9 @@
   "dependencies": {
     "assert-plus": ">=0.2.0 <0.3.0"
   },
+  "optionalDependencies": {
+    "dtrace-provider": "~0.8"
+  },
   "devDependencies": {
     "tape": ">=3.5.0 <4.0.0"
   }
-- 
2.21.0

