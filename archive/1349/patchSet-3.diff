From 070f193219d12f258bdb14f453594eb3f3bec69e Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 26 Jan 2017 14:17:58 -0800
Subject: [PATCH] joyent/node-mooremachine#13 want DTrace probe support
 Reviewed by: Robert Mustacchi <rm@joyent.com>

---
 README.md    | 130 +++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/fsm.js   |  74 +++++++++++++++++++++++++----
 package.json |   5 +-
 3 files changed, 199 insertions(+), 10 deletions(-)

diff --git a/README.md b/README.md
index 67321ca..bac2f73 100644
--- a/README.md
+++ b/README.md
@@ -286,3 +286,133 @@ for each sub-state entered.
 Once a handle is used to transition to an unrelated state (e.g. `'closed'` in
 the example), all handlers are torn down (from both the parent state and
 sub-state) as usual before entering the new state.
+
+DTrace support
+--------------
+
+Mooremachine has support for DTrace probes using `dtrace-provider` (and
+`libusdt`). The following probes are provided under the
+`moorefsm$pid` provider:
+
+ * `create-fsm(char *klass, char *id)` -- fired at the creation of a new FSM
+   instance. The `klass` argument contains the string name of the constructor
+   of the FSM sub-class. The `id` argument contains a short randomly generated
+   string that should be unique to this FSM as long as <~6M instances of this
+   class exist in the program (it consists of 64 random bits, base64-encoded,
+   so about a 1/1M chance of collision at 6M instances).
+ * `transition-start(char *klass, char *id, char *oldState, char *newState)` --
+   fired at the beginning of an FSM transitioning to a new state.
+ * `transition-end(char *klass, char *id, char *oldState, char *newState)` --
+   fired at the end of an FSM transitioning to a new state.
+
+For example:
+
+```
+dtrace -Zc 'node thingfsm.js' -n '
+    moorefsm$target:::transition-start
+    /copyinstr(arg0) == "ThingFSM"/
+    {
+        printf("%s => %s", copyinstr(arg2), copyinstr(arg3));
+    }'
+```
+
+When used on the `ThingFSM` above might output:
+
+```
+CPU     ID                    FUNCTION:NAME
+  4   8216 transition-start:transition-start undefined => stopped
+  4   8216 transition-start:transition-start stopped => connecting
+  4   8216 transition-start:transition-start connecting => error
+```
+
+This is will list all the transitions of `ThingFSM` instances.
+
+Another example (as a d-script file):
+
+```
+uint64_t timeIn[string];
+
+moorefsm$target:::transition-start
+/copyinstr(arg0) == "SocketMgrFSM" && copyinstr(arg2) != "undefined"/
+{
+    this->id = copyinstr(arg1);
+    this->state = copyinstr(arg2);
+    this->entryTime = timeIn[this->id];
+    this->exitTime = timestamp;
+    this->time = (this->exitTime - this->entryTime) / 1000000;
+    @timeInState[this->state] = quantize(this->time);
+}
+
+moorefsm$target:::transition-end
+/copyinstr(arg0) == "SocketMgrFSM"/
+{
+    this->id = copyinstr(arg1);
+    timeIn[this->id] = timestamp;
+}
+```
+
+This reports on the number of milliseconds spent in each state by
+all SocketMgrFSM instances in the process.
+
+The output from this could look like:
+
+```
+$ dtrace -Zc 'node test.js' -s script.d
+...
+  error
+           value  ------------- Distribution ------------- count
+              -1 |                                         0
+               0 |@@@@@@@@@@@@@@@@@@@@                     1
+               1 |                                         0
+               2 |@@@@@@@@@@@@@@@@@@@@                     1
+               4 |                                         0
+
+  backoff
+           value  ------------- Distribution ------------- count
+              -1 |                                         0
+               0 |@@@@@@@@@@@@@@@@@@@@                     1
+               1 |                                         0
+               2 |                                         0
+               4 |                                         0
+               8 |                                         0
+              16 |                                         0
+              32 |                                         0
+              64 |@@@@@@@@@@@@@@@@@@@@                     1
+             128 |                                         0
+
+  connected
+           value  ------------- Distribution ------------- count
+               2 |                                         0
+               4 |@@@@@@@@@@@                              2
+               8 |@@@@@@                                   1
+              16 |                                         0
+              32 |                                         0
+              64 |                                         0
+             128 |                                         0
+             256 |@@@@@@                                   1
+             512 |@@@@@@@@@@@@@@@@@                        3
+            1024 |                                         0
+
+  connecting
+           value  ------------- Distribution ------------- count
+              -1 |                                         0
+               0 |@@@@@@@@@@@@@@@@@@                       4
+               1 |@@@@                                     1
+               2 |                                         0
+               4 |                                         0
+               8 |                                         0
+              16 |                                         0
+              32 |                                         0
+              64 |@@@@                                     1
+             128 |                                         0
+             256 |@@@@                                     1
+             512 |@@@@                                     1
+            1024 |@@@@                                     1
+            2048 |                                         0
+```
+
+It's generally safe enough to use only the `id` of the FSM as a key in an
+associative array or aggregation in DTrace, even when tracing multiple
+processes. This only becomes a problem if you expect to have more than a few
+million FSMs running at the same time on a system (in which case you can scope
+it by pid and class as well as key).
diff --git a/lib/fsm.js b/lib/fsm.js
index 09ad2a0..ea07260 100644
--- a/lib/fsm.js
+++ b/lib/fsm.js
@@ -10,10 +10,32 @@
 
 module.exports = FSM;
 
-var assert = require('assert-plus');
-var util = require('util');
+var mod_assert = require('assert-plus');
+var mod_crypto = require('crypto');
+var mod_util = require('util');
 var EventEmitter = require('events').EventEmitter;
 
+var mod_dtrace;
+
+try {
+	mod_dtrace = require('dtrace-provider');
+} catch (e) {
+	mod_dtrace = undefined;
+}
+
+var dt;
+if (mod_dtrace !== undefined) {
+	dt = {};
+
+	dt.provider = mod_dtrace.createDTraceProvider('moorefsm');
+	dt.create = dt.provider.addProbe('create-fsm', 'char *', 'char *');
+	dt.start = dt.provider.addProbe('transition-start', 'char *', 'char *',
+	    'char *', 'char *');
+	dt.end = dt.provider.addProbe('transition-end', 'char *', 'char *',
+	    'char *', 'char *');
+	dt.provider.enable();
+}
+
 function FSMStateHandle(fsm, state, link) {
 	this.fsh_fsm = fsm;
 	this.fsh_link = link;
@@ -30,7 +52,7 @@ function FSMStateHandle(fsm, state, link) {
 FSMStateHandle.prototype.validTransitions = function (states) {
 	if (this.fsh_validTransitions !== undefined)
 		throw (new Error('FSM validTransitions already set'));
-	assert.arrayOfString(states, 'states');
+	mod_assert.arrayOfString(states, 'states');
 	this.fsh_validTransitions = states;
 };
 
@@ -173,7 +195,11 @@ FSMStateHandle.prototype.callback = function (cb) {
  * used with "onState".
  */
 function FSM(defState) {
-	assert.string(defState, 'default state');
+	mod_assert.string(defState, 'default state');
+	this.fsm_id = FSM.genId();
+	this.fsm_clsname = this.constructor.name;
+	if (this.fsm_clsname.length === 0)
+		this.fsm_clsname = 'FSM';
 	this.fsm_history = [];
 	this.fsm_handle = undefined;
 	this.fsm_inTransition = false;
@@ -182,9 +208,24 @@ function FSM(defState) {
 	this.fsm_state = undefined;
 	this.fsm_toEmit = [];
 	EventEmitter.call(this);
+	if (dt !== undefined) {
+		var self = this;
+		dt.create.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id]);
+		});
+	}
 	this._gotoState(defState);
 }
-util.inherits(FSM, EventEmitter);
+mod_util.inherits(FSM, EventEmitter);
+
+FSM.genId = function () {
+	var b = mod_crypto.randomBytes(8);
+	/*
+	 * Use slice() to strip off the trailing "=" padding, as the last 2
+	 * chars are always the same and make for unnecessary noise.
+	 */
+	return (b.toString('base64').slice(0, 11));
+};
 
 FSM.prototype.getState = function () {
 	return (this.fsm_state);
@@ -196,7 +237,7 @@ FSM.prototype.isInState = function (state) {
 };
 
 FSM.prototype.allStateEvent = function (evt) {
-	assert.string(evt, 'event');
+	mod_assert.string(evt, 'event');
 	if (this.fsm_allStateEvents === undefined)
 		this.fsm_allStateEvents = [];
 	this.fsm_allStateEvents.push(evt);
@@ -204,14 +245,23 @@ FSM.prototype.allStateEvent = function (evt) {
 
 /* Transition the FSM to a new state. */
 FSM.prototype._gotoState = function (state) {
-	assert.string(state, 'state');
+	mod_assert.string(state, 'state');
 
 	if (this.fsm_inTransition) {
-		assert.ok(this.fsm_nextState === undefined);
+		mod_assert.ok(this.fsm_nextState === undefined);
 		this.fsm_nextState = state;
 		return;
 	}
 
+	var self = this;
+	var oldState = this.fsm_state;
+	if (dt !== undefined) {
+		dt.start.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id,
+			    oldState, state]);
+		});
+	}
+
 	/*
 	 * First, kill event handlers and timers from our previous state, as
 	 * needed.
@@ -273,7 +323,6 @@ FSM.prototype._gotoState = function (state) {
 	f.call(this, this.fsm_handle);
 	this.fsm_inTransition = false;
 
-	var self = this;
 	this.fsm_allStateEvents.forEach(function (evt) {
 		if (self.listeners(evt).length < 1) {
 			throw (new Error('FSM consistency error: ' +
@@ -294,6 +343,13 @@ FSM.prototype._gotoState = function (state) {
 		});
 	}
 
+	if (dt !== undefined) {
+		dt.end.fire(function () {
+			return ([self.fsm_clsname, self.fsm_id,
+			    oldState, state]);
+		});
+	}
+
 	var next = this.fsm_nextState;
 	if (next !== undefined) {
 		this.fsm_nextState = undefined;
diff --git a/package.json b/package.json
index e19e41f..ce2b3b0 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "mooremachine",
-  "version": "2.0.1",
+  "version": "2.1.0",
   "description": "Moore finite state machines",
   "main": "lib/index.js",
   "scripts": {
@@ -31,6 +31,9 @@
   "dependencies": {
     "assert-plus": ">=0.2.0 <0.3.0"
   },
+  "optionalDependencies": {
+    "dtrace-provider": "~0.8"
+  },
   "devDependencies": {
     "tape": ">=3.5.0 <4.0.0"
   }
-- 
2.21.0

