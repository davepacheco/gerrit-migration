From f8a8714b41aa14ec330f7748a66e680e2eae66d2 Mon Sep 17 00:00:00 2001
From: Isaac Davis <isaac.davis@joyent.com>
Date: Mon, 17 Jun 2019 22:14:16 +0000
Subject: [PATCH] TRITON-1696 sdcadm should verify that triton_cns_enabled is
 set for the admin user before deploying prometheus

---
 lib/post-setup/prometheus.js | 62 ++++++++++++++++++++++++++++++++----
 1 file changed, 55 insertions(+), 7 deletions(-)

diff --git a/lib/post-setup/prometheus.js b/lib/post-setup/prometheus.js
index a7ac93e..54adae4 100644
--- a/lib/post-setup/prometheus.js
+++ b/lib/post-setup/prometheus.js
@@ -12,6 +12,9 @@
  * The 'sdcadm post-setup prometheus' CLI subcommand.
  */
 
+var vasync = require('vasync');
+var verror = require('verror');
+
 var errors = require('../errors');
 var AddServiceProc = require('../procedures/add-service').AddServiceProcedure;
 var AddAllowTransferProc =
@@ -80,13 +83,58 @@ function do_prometheus(subcmd, opts, args, cb) {
     const addServiceProc = new AddServiceProc(addServiceOpts);
     const addAllowTransferProc = new AddAllowTransferProc(addAllowTransferOpts);
 
-    runProcs({
-        log: self.log,
-        procs: [addServiceProc, addAllowTransferProc],
-        sdcadm: self.sdcadm,
-        ui: self.ui,
-        dryRun: opts.dry_run,
-        skipConfirm: opts.yes
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function checkCnsEnabled(_, next) {
+                self.sdcadm.ufds.getUser('admin', function gotUfds(err, user) {
+                    var ufdsErr = null;
+                    if (err) {
+                        ufdsErr = err;
+                    } else if (user.triton_cns_enabled !== 'true') {
+                        ufdsErr = new verror.VError('The prometheus service ' +
+                            'requires the admin user to have ' +
+                            '\'triton_cns_enabled\' set to \'true\'');
+                    }
+                    /*
+                     * We have to report any UFDS request error from the block
+                     * of code above, as well as any error encountered when
+                     * attempting to close the UFDS connection. Thus, we return
+                     * a MultiError object, one error, or no errors as
+                     * appropriate. Eurgh!
+                     */
+                    self.sdcadm._ufds.close(function closedUfds(closeErr) {
+                        var errs = [ufdsErr, closeErr];
+                        errs = errs.filter(function checkErrDefined(e) {
+                            return e !== null && e !== undefined;
+                        });
+                        var errToReturn;
+                        switch (errs.length) {
+                        case 0:
+                            errToReturn = null;
+                            break;
+                        case 1:
+                            errToReturn = errs[0];
+                            break;
+                        default:
+                            errToReturn = new verror.MultiError(errs);
+                            break;
+                        }
+                        next(errToReturn);
+                    });
+                });
+            },
+            function addPrometheus(_, next) {
+                runProcs({
+                    log: self.log,
+                    procs: [addServiceProc, addAllowTransferProc],
+                    sdcadm: self.sdcadm,
+                    ui: self.ui,
+                    dryRun: opts.dry_run,
+                    skipConfirm: opts.yes
+                }, next);
+            }
+        ]
     }, cb);
 }
 
-- 
2.21.0

