commit cbfdd06dd13bb140ca0b2ebc867b26ff782cd0a8
Author: Isaac Davis <isaac.davis@joyent.com>
Date:   2019-06-17T22:17:50+00:00 (4 months ago)
    
    TRITON-1696 sdcadm should verify that triton_cns_enabled is set for the admin user before deploying prometheus

diff --git a/lib/post-setup/prometheus.js b/lib/post-setup/prometheus.js
index a7ac93e..c48c586 100644
--- a/lib/post-setup/prometheus.js
+++ b/lib/post-setup/prometheus.js
@@ -12,6 +12,9 @@
  * The 'sdcadm post-setup prometheus' CLI subcommand.
  */
 
+var vasync = require('vasync');
+var verror = require('verror');
+
 var errors = require('../errors');
 var AddServiceProc = require('../procedures/add-service').AddServiceProcedure;
 var AddAllowTransferProc =
@@ -80,13 +83,58 @@ function do_prometheus(subcmd, opts, args, cb) {
     const addServiceProc = new AddServiceProc(addServiceOpts);
     const addAllowTransferProc = new AddAllowTransferProc(addAllowTransferOpts);
 
-    runProcs({
-        log: self.log,
-        procs: [addServiceProc, addAllowTransferProc],
-        sdcadm: self.sdcadm,
-        ui: self.ui,
-        dryRun: opts.dry_run,
-        skipConfirm: opts.yes
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function checkCnsEnabled(_, next) {
+                self.sdcadm.ufds.getUser('admin', function gotUfds(err, user) {
+                    var ufdsErr = null;
+                    if (err) {
+                        ufdsErr = err;
+                    } else if (user.triton_cns_enabled !== 'true') {
+                        ufdsErr = new verror.VError('The prometheus service ' +
+                            'requires the admin user to have ' +
+                            '\'triton_cns_enabled\' set to \'true\'');
+                    }
+                    /*
+                     * We have to report any UFDS request error from the block
+                     * of code above, as well as any error encountered when
+                     * attempting to close the UFDS connection. Thus, we return
+                     * a MultiError object, one error, or no errors as
+                     * appropriate. Eurgh!
+                     */
+                    self.sdcadm.ufds.close(function closedUfds(closeErr) {
+                        var errs = [ufdsErr, closeErr];
+                        errs = errs.filter(function checkErrDefined(e) {
+                            return e !== null && e !== undefined;
+                        });
+                        var errToReturn;
+                        switch (errs.length) {
+                        case 0:
+                            errToReturn = null;
+                            break;
+                        case 1:
+                            errToReturn = errs[0];
+                            break;
+                        default:
+                            errToReturn = new verror.MultiError(errs);
+                            break;
+                        }
+                        next(errToReturn);
+                    });
+                });
+            },
+            function addPrometheus(_, next) {
+                runProcs({
+                    log: self.log,
+                    procs: [addServiceProc, addAllowTransferProc],
+                    sdcadm: self.sdcadm,
+                    ui: self.ui,
+                    dryRun: opts.dry_run,
+                    skipConfirm: opts.yes
+                }, next);
+            }
+        ]
     }, cb);
 }
 
