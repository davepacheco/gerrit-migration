From 998d9b99b54ae31cfa1746685a4a4d16858ed06a Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 31 Aug 2016 18:18:34 +0000
Subject: [PATCH] FWAPI-239 Firewall rules are not regenerated when machine tag
 changes are made FWAPI-249 firewaller doesn't fetch remote VMs with matching
 tags Reviewed by: Richard Kiene <richard.kiene@joyent.com>

---
 lib/cache.js                |  21 +++-
 lib/pred.js                 |   4 +-
 lib/tasks/vm-add.js         |  67 +---------
 lib/tasks/vm-common.js      |  84 +++++++++++++
 lib/tasks/vm-update.js      | 238 ++++++++++++++++++++++++------------
 lib/vmapi.js                | 102 ++++++++++++----
 package.json                |   4 +-
 test/lib/vm.js              |   2 +-
 test/unit/helpers.js        |   1 +
 test/unit/vm-update.test.js |   9 +-
 10 files changed, 350 insertions(+), 182 deletions(-)
 create mode 100644 lib/tasks/vm-common.js

diff --git a/lib/cache.js b/lib/cache.js
index c9a6d29..39641fe 100644
--- a/lib/cache.js
+++ b/lib/cache.js
@@ -22,6 +22,7 @@
  * - all vms, eg: "FROM all vms TO ..."
  */
 
+var assert = require('assert-plus');
 var prim = require('jsprim');
 var util = require('util');
 
@@ -61,12 +62,9 @@ function tagInOwnerCache(oCache, t, val) {
  * VMCache object constructor
  */
 function VMCache() {
-    var self = this;
-    this.clear();
+    this.cache = {};
 
-    this.__defineGetter__('state', function () {
-        return self.cache;
-    });
+    Object.seal(this);
 }
 
 
@@ -86,6 +84,11 @@ VMCache.prototype._addOwner = function addOwner(owner, overwrite) {
 };
 
 
+Object.defineProperty(VMCache.prototype, 'state', {
+    get: function () { return this.cache; }
+});
+
+
 /**
  * Set the allVMs attribute for an owner's cache - in other words, we have
  * data for all of their remote VMs.
@@ -134,6 +137,9 @@ VMCache.prototype.addResolveData = function addResolveData(resolved) {
  *   }
  */
 VMCache.prototype.addTags = function addTags(owner, tags) {
+    assert.optionalUuid(owner, 'owner');
+    assert.optionalObject(tags, 'tags');
+
     if (!tags || prim.isEmpty(tags)) {
         return;
     }
@@ -177,6 +183,9 @@ VMCache.prototype.addTags = function addTags(owner, tags) {
  *   }
  */
 VMCache.prototype.addVMs = function addVMs(owner, vms) {
+    assert.optionalUuid(owner, 'owner');
+    assert.optionalArrayOfUuid(vms, 'vms');
+
     if (!vms || vms.length === 0) {
         return;
     }
@@ -272,5 +281,5 @@ VMCache.prototype.missing = function _missing(owner, targets) {
 
 
 module.exports = {
-    VMCache : VMCache
+    VMCache: VMCache
 };
diff --git a/lib/pred.js b/lib/pred.js
index 7379bb2..10584d0 100644
--- a/lib/pred.js
+++ b/lib/pred.js
@@ -94,7 +94,7 @@ function createPred(params) {
                 orFilter.push(eqFilt('tag.' + t, vals[v]));
             }
         } else {
-            if (t === true) {
+            if (tags[t] === true) {
                 orFilter.push(eqFilt('tag.' + t, '*'));
             } else {
                 orFilter.push(eqFilt('tag.' + t, tags[t]));
@@ -110,7 +110,7 @@ function createPred(params) {
         return allFilt;
     }
 
-    if (orFilter.length == 1) {
+    if (orFilter.length === 1) {
         // OR filters require at least two sub-elements
         allFilt.and.push(orFilter[0]);
     } else {
diff --git a/lib/tasks/vm-add.js b/lib/tasks/vm-add.js
index 704c248..ce0b517 100644
--- a/lib/tasks/vm-add.js
+++ b/lib/tasks/vm-add.js
@@ -12,75 +12,10 @@
  * Add remote VM task
  */
 
-var fw = require('../fw');
 var mod_fwapi = require('../fwapi');
 var mod_vm = require('../vm');
 
-
-
-// --- Internal
-
-
-
-/**
- * The VM is not local: add it if there are any non-global rules that would
- * apply to it
- */
-function addRemoteVM(opts, vms, callback) {
-    var rulesPayload = {
-        log: opts.log,
-        req_id: opts.req_id,
-        payload: {
-            vms: vms,
-            remoteVM: opts.value
-        }
-    };
-
-    fw.rvmRules(rulesPayload, function (err2, rvmRules) {
-        if (err2) {
-            return callback(err2);
-        }
-
-        var globalRules = 0;
-        var nonGlobalRules = 0;
-
-        rvmRules.forEach(function (rvmRule) {
-            if (rvmRule.global) {
-                globalRules++;
-            } else {
-                nonGlobalRules++;
-            }
-        });
-
-        if (nonGlobalRules === 0) {
-            opts.log.info(
-                { rvm: opts.value, globalRules: globalRules },
-                'Remote VM "%s" is not the target of any ' +
-                'non-global rules: not adding', opts.value.uuid);
-            return callback();
-        }
-
-        var addPayload = {
-            log: opts.log,
-            req_id: opts.req_id,
-            payload: {
-                remoteVMs: [ opts.value ],
-                vms: vms
-            }
-        };
-
-        fw.add(addPayload, function (err3, res) {
-            if (!err3) {
-                opts.cache.addVMs(opts.value.owner_uuid, [opts.value]);
-            }
-
-            opts.log.info(opts.value,
-                'Added remote VM "%s"', opts.value.uuid);
-            return callback(err3, res);
-        });
-    });
-}
-
+var addRemoteVM = require('./vm-common').addRemoteVM;
 
 
 // --- Exports
diff --git a/lib/tasks/vm-common.js b/lib/tasks/vm-common.js
new file mode 100644
index 0000000..152b63c
--- /dev/null
+++ b/lib/tasks/vm-common.js
@@ -0,0 +1,84 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Common routines for managing VMs.
+ */
+
+var fw = require('../fw');
+
+
+// --- Exports
+
+/**
+ * Check if an array of rules contains any non-global rules
+ */
+function hasNonGlobalRules(rules) {
+    return rules.some(function (rule) {
+        return !rule.global;
+    });
+}
+
+
+/**
+ * The VM is not local: add it if there are any non-global rules that would
+ * apply to it
+ */
+function addRemoteVM(opts, vms, callback) {
+    var rulesPayload = {
+        log: opts.log,
+        req_id: opts.req_id,
+        payload: {
+            vms: vms,
+            remoteVM: opts.value
+        }
+    };
+
+    fw.rvmRules(rulesPayload, function (rvmErr, rvmRules) {
+        if (rvmErr) {
+            callback(rvmErr);
+            return;
+        }
+
+        if (!hasNonGlobalRules(rvmRules)) {
+            opts.log.info(
+                { rvm: opts.value },
+                'Remote VM "%s" is not the target of any ' +
+                'non-global rules: not adding', opts.value.uuid);
+            callback();
+            return;
+        }
+
+        var addPayload = {
+            log: opts.log,
+            req_id: opts.req_id,
+            payload: {
+                remoteVMs: [ opts.value ],
+                vms: vms
+            }
+        };
+
+        fw.add(addPayload, function (addErr, res) {
+            if (!addErr) {
+                opts.cache.addVMs(opts.value.owner_uuid, [opts.value.uuid]);
+                opts.log.info(opts.value,
+                    'Added remote VM "%s"', opts.value.uuid);
+            }
+
+            callback(addErr, res);
+        });
+    });
+}
+
+
+module.exports = {
+    addRemoteVM: addRemoteVM,
+    hasNonGlobalRules: hasNonGlobalRules
+};
diff --git a/lib/tasks/vm-update.js b/lib/tasks/vm-update.js
index 48267cf..6904e38 100644
--- a/lib/tasks/vm-update.js
+++ b/lib/tasks/vm-update.js
@@ -12,21 +12,70 @@
  * Update remote VM task
  */
 
+var clone = require('clone');
 var fw = require('../fw');
+var mod_common = require('./vm-common');
 var mod_fwapi = require('../fwapi');
 var mod_vm = require('../vm');
+var mod_vmapi = require('../vmapi');
 var prim = require('jsprim');
 
+var addRemoteVM = mod_common.addRemoteVM;
+var hasNonGlobalRules = mod_common.hasNonGlobalRules;
 
 
 // --- Internal
 
+function fillRVM(opts, rvm) {
+    var t;
+
+    if (opts.value.hasOwnProperty('add_nics')) {
+        rvm.nics = opts.value.add_nics;
+    }
+
+    if (!rvm.hasOwnProperty('ips')) {
+        rvm.ips = [];
+    }
+
+    if (opts.value.hasOwnProperty('remove_ips') && rvm.ips) {
+        rvm.ips = rvm.ips.filter(function (ip) {
+            return (opts.value.remove_ips.indexOf(ip) === -1);
+        });
+    }
+
+    if (!rvm.hasOwnProperty('tags')) {
+        rvm.tags = {};
+    }
+
+    if (opts.value.hasOwnProperty('set_tags')) {
+        for (t in opts.value.set_tags) {
+            rvm.tags[t] = opts.value.set_tags[t];
+        }
+    }
+
+    if (opts.value.hasOwnProperty('remove_tags')) {
+        for (t in opts.value.remove_tags) {
+            delete rvm.tags[opts.value.remove_tags[t]];
+        }
+    }
+
+    if (prim.isEmpty(rvm.tags)) {
+        delete rvm.tags;
+    }
+
+    return rvm;
+}
 
 
+/**
+ * If a local VM changes properties, new rules may become applicable. Check
+ * with FWAPI using its new properties, and then update its firewall.
+ */
 function updateLocalVM(opts, localVM, callback) {
-    mod_fwapi.resolveLocalVM(opts, localVM, function (err, res) {
-        if (err || res) {
-            return callback(err);
+    mod_fwapi.resolveLocalVM(opts, localVM, function (err) {
+        if (err) {
+            callback(err);
+            return;
         }
 
         opts.log.info({ localVM: localVM }, 'updating local VM');
@@ -38,14 +87,115 @@ function updateLocalVM(opts, localVM, callback) {
             }
         }, callback);
     });
-
 }
 
 
-
-// --- Exports
+/**
+ * When a remote VM changes, determine if it's relevant to any local VMs,
+ * and fetch its information if so.
+ */
+function updateRVM(opts, vms, callback) {
+    var rvm_uuid = opts.value.uuid;
+    var rvmPayload = {
+        log: opts.log,
+        req_id: opts.req_id,
+        payload: { remoteVM: rvm_uuid }
+    };
+
+    fw.getRVM(rvmPayload, function (getErr, rvm) {
+        if (getErr) {
+            if (getErr.code !== 'ENOENT') {
+                /* Unknown failure: abort  */
+                callback(getErr);
+            } else if (opts.value.owner_uuid === undefined) {
+                /*
+                 * RVM doesn't exist locally and an out-of-date VMAPI
+                 * hasn't sent us the owner UUID, so we can't determine
+                 * if the RVM needs to be saved locally: fetch the VM
+                 * object from VMAPI, and then check if we need to
+                 * save it.
+                 */
+                opts.log.warn('Update information for %s is missing '
+                    + 'an owner_uuid: update VMAPI', rvm_uuid);
+                mod_vmapi.get(opts, rvm_uuid, function (err3, nrvm) {
+                    if (err3) {
+                        callback(err3);
+                        return;
+                    }
+
+                    var nopts = clone(opts, false, 1);
+                    nopts.value = nrvm;
+                    addRemoteVM(nopts, vms, callback);
+                });
+            } else {
+                /*
+                 * Check if this VM update would make this RVM relevant to
+                 * any of the local VMs' rules. If so, fetch the VM object
+                 * and save it locally.
+                 */
+                fw.rvmRules({
+                    log: opts.log,
+                    req_id: opts.req_id,
+                    payload: {
+                        vms: vms,
+                        remoteVM: fillRVM(opts, {
+                            owner_uuid: opts.value.owner_uuid,
+                            uuid: rvm_uuid
+                        })
+                    }
+                }, function (err3, rvmRules) {
+                    if (err3 || !hasNonGlobalRules(rvmRules)) {
+                        callback(err3);
+                        return;
+                    }
+
+                    mod_vmapi.get(opts, rvm_uuid, function (err4, nrvm) {
+                        if (err4) {
+                            callback(err4);
+                            return;
+                        }
+
+                        fw.add({
+                            log: opts.log,
+                            req_id: opts.req_id,
+                            payload: {
+                                remoteVMs: [ nrvm ],
+                                vms: vms
+                            }
+                        }, function (err5, res) {
+                            if (!err5) {
+                                opts.cache.addVMs(opts.value.owner_uuid,
+                                    [opts.value.uuid]);
+                            }
+
+                            opts.log.info(opts.value,
+                                'Added remote VM "%s"', opts.value.uuid);
+                            callback(err5, res);
+                        });
+                    });
+                });
+            }
+        } else {
+            /*
+             * RVM already exists locally, so we'll just update it. It's
+             * okay if this update makes it no longer relevant locally,
+             * since we'll take care of garbage collecting it and any
+             * other irrelevant VMs during the periodic "sync" task.
+             */
+            fw.update({
+                log: opts.log,
+                req_id: opts.req_id,
+                payload: {
+                    remoteVMs: [ fillRVM(opts, rvm) ],
+                    vms: vms
+                }
+            }, callback);
+        }
+    });
+}
 
 
+// --- Exports
 
 /*
  * vm-update task entry point
@@ -61,88 +211,26 @@ function updateVM(opts, callback) {
 
     if (!opts.value.uuid) {
         opts.log.warn(opts.value, 'Remote VM missing UUID: not updating');
-        return callback();
+        callback();
+        return;
     }
 
     // XXX: validate other properties
 
     mod_vm.list(opts.log, filter, function (err, vms) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var localVM = mod_vm.isLocal(vms, opts.value);
         if (localVM) {
             opts.vms = vms;
-            return updateLocalVM(opts, localVM, callback);
+            updateLocalVM(opts, localVM, callback);
+            return;
         }
 
-        var rvmPayload = {
-            log: opts.log,
-            req_id: opts.req_id,
-            payload: { remoteVM: opts.value.uuid }
-        };
-
-        fw.getRVM(rvmPayload, function (err2, rvm) {
-            if (err2) {
-                if (err2.code === 'ENOENT') {
-                    opts.log.info(opts.value,
-                        'Remote VM "%s" does not exist on this server: ' +
-                        'not updating', opts.value.uuid);
-                    return callback();
-                }
-                return callback(err2);
-            }
-
-            var t;
-
-            if (opts.value.hasOwnProperty('add_nics')) {
-                rvm.nics = opts.value.add_nics;
-            }
-
-            if (opts.value.hasOwnProperty('remove_ips') && rvm.ips) {
-                rvm.ips = rvm.ips.filter(function (ip) {
-                    return opts.value.remove_ips.indexOf(ip) === -1;
-                });
-            }
-
-            if (opts.value.hasOwnProperty('remove_tags')) {
-                for (t in opts.value.remove_tags) {
-                    delete rvm.tags[t];
-                }
-            }
-
-            if (!rvm.hasOwnProperty('tags')) {
-                rvm.tags = {};
-            }
-
-            if (opts.value.hasOwnProperty('set_tags')) {
-                for (t in opts.value.set_tags) {
-                    rvm.tags[t] = opts.value.set_tags[t];
-                }
-            }
-
-            if (opts.value.hasOwnProperty('remove_tags')) {
-                for (t in opts.value.remove_tags) {
-                    delete rvm.tags[t];
-                }
-            }
-
-            if (prim.isEmpty(rvm.tags)) {
-                delete rvm.tags;
-            }
-
-            var updatePayload = {
-                log: opts.log,
-                req_id: opts.req_id,
-                payload: {
-                    remoteVMs: [ rvm ],
-                    vms: vms
-                }
-            };
-
-            fw.update(updatePayload, callback);
-        });
+        updateRVM(opts, vms, callback);
     });
 }
 
diff --git a/lib/vmapi.js b/lib/vmapi.js
index de11a9a..8d8c8df 100644
--- a/lib/vmapi.js
+++ b/lib/vmapi.js
@@ -17,11 +17,32 @@ var fw = require('./fw');
 var mod_vm = require('./vm');
 var pred = require('./pred');
 var prim = require('jsprim');
-var util = require('util');
 var VMAPI = require('sdc-clients').VMAPI;
 
 
 
+// --- Internal
+
+
+
+function buildRVM(vm) {
+    var rvm = {
+        enabled: !!vm.firewall_enabled,
+        ips: vm.nics.map(function (n) { return n.ip; }),
+        owner_uuid: vm.owner_uuid,
+        tags: {},
+        uuid: vm.uuid
+    };
+
+    for (var t in vm.tags) {
+        rvm.tags[t] = vm.tags[t];
+    }
+
+    return rvm;
+}
+
+
+
 // --- Exports
 
 
@@ -31,12 +52,55 @@ function createClient(opts) {
 }
 
 
+function getVM(opts, vm_uuid, callback) {
+    var clientCreated = false;
+
+    assert.object(opts, 'opts');
+    assert.string(vm_uuid, 'vm_uuid');
+    assert.func(callback, 'callback');
+
+    if (!opts.vmapi) {
+        opts.vmapi = createClient(opts);
+        clientCreated = true;
+    }
+
+    var getParams = {
+        path: '/vms/' + vm_uuid
+    };
+
+    if (opts.req_id) {
+        getParams.headers = { 'x-request-id': opts.req_id };
+    }
+
+    opts.log.debug('vmapi.get: Getting VM %s', vm_uuid);
+
+    opts.vmapi.get(getParams, function (err, vm) {
+        if (clientCreated) {
+            opts.vmapi.client.close();
+        }
+
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        if (!vm.hasOwnProperty('nics') || vm.nics.length === 0) {
+            opts.log.warn(vm, 'vmapi.get: Got VM from VMAPI with no nics');
+            callback();
+            return;
+        }
+
+        callback(null, buildRVM(vm));
+    });
+}
+
+
 function listVMs(opts, callback) {
     var filter = opts.filter;
     var clientCreated = false;
     var predicate;
 
-    if (!filter.tags && ! filter.vms && !filter.allVMs) {
+    if (!filter.tags && !filter.vms && !filter.allVMs) {
         opts.log.debug(
             'vmapi.list: No tags, vms or allVMs for owner "%s": not getting',
             opts.filter.owner_uuid);
@@ -48,7 +112,8 @@ function listVMs(opts, callback) {
     if (prim.isEmpty(tags) && vmsToFind.length === 0 && !filter.allVMs) {
         opts.log.debug('vmapi.list: No tags or VMs to get for owner "%s"',
             opts.filter.owner_uuid);
-        return callback();
+        callback();
+        return;
     }
 
     predicate = pred.create(opts.filter);
@@ -70,8 +135,13 @@ function listVMs(opts, callback) {
     opts.log.debug({ params: getParams, predicate: predicate }, 'listing VMs');
 
     opts.vmapi.get(getParams, function (err, vms) {
+        if (clientCreated) {
+            opts.vmapi.client.close();
+        }
+
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var rvms = [];
@@ -80,7 +150,7 @@ function listVMs(opts, callback) {
 
             // Skip VMs that are on this server
             if (vm.hasOwnProperty('server_uuid') &&
-                vm.server_uuid == opts.filter.serverUUID) {
+                vm.server_uuid === opts.filter.serverUUID) {
                 continue;
             }
 
@@ -89,27 +159,10 @@ function listVMs(opts, callback) {
                 continue;
             }
 
-            var rvm = {
-                enabled: vm.firewall_enabled ? true : false,
-                ips: vm.nics.map(function (n) { return n.ip; }),
-                owner_uuid: vm.owner_uuid,
-                tags: {},
-                uuid: vm.uuid
-            };
-
-            for (var t in vm.tags) {
-                rvm.tags[t] = vm.tags[t];
-            }
-
-            rvms.push(rvm);
-        }
-
-
-        if (clientCreated) {
-            opts.vmapi.client.close();
+            rvms.push(buildRVM(vm));
         }
 
-        return callback(null, rvms);
+        callback(null, rvms);
     });
 }
 
@@ -237,6 +290,7 @@ function populateRemoteVMs(opts, callback) {
 
 module.exports = {
     createClient: createClient,
+    get: getVM,
     list: listVMs,
     populateRemoteVMs: populateRemoteVMs
 };
diff --git a/package.json b/package.json
index d612af0..9144913 100644
--- a/package.json
+++ b/package.json
@@ -5,11 +5,11 @@
     "author": "Joyent (joyent.com)",
     "private": true,
     "dependencies": {
-        "assert-plus": "0.1.4",
+        "assert-plus": "1.0.0",
         "async": "0.2.9",
         "backoff": "2.3.0",
         "bunyan": "0.22.1",
-        "clone": "0.1.11",
+        "clone": "1.0.2",
         "fast-stream": "git+https://github.com/joyent/sdc-fast-stream.git#893d59d",
         "jsprim": "0.5.0",
         "lockfd": "1.0.1",
diff --git a/test/lib/vm.js b/test/lib/vm.js
index 51e5fef..6864cff 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -59,7 +59,7 @@ function ipfRule(t, opts) {
     assert.object(opts.vm, 'opts.vm');
     assert.string(opts.vm.uuid, 'opts.vm.uuid');
 
-    var ipfConfs = fwHelper.zoneIPFconfigs();
+    var ipfConfs = fwHelper.zoneIPFconfigs(4);
     var cur = ipfConfs;
     var curStr;
     // XXX: allow setting pass / block
diff --git a/test/unit/helpers.js b/test/unit/helpers.js
index 2f27d41..5fa89dd 100644
--- a/test/unit/helpers.js
+++ b/test/unit/helpers.js
@@ -175,6 +175,7 @@ function setupMocks() {
         './vmapi',
         './vms',
         './vm-add',
+        './vm-common',
         './vm-delete',
         './vm-update',
         '../fw',
diff --git a/test/unit/vm-update.test.js b/test/unit/vm-update.test.js
index e5e5c0d..20cdc0b 100644
--- a/test/unit/vm-update.test.js
+++ b/test/unit/vm-update.test.js
@@ -69,7 +69,7 @@ exports['update firewall_enabled'] = {
             h.rule({
                 created_by: 'fwapi',
                 owner_uuid: d.owners[0],
-                rule:'FROM tag web = true TO tag private = true '
+                rule: 'FROM tag web = true TO tag private = true '
                     + 'ALLOW tcp PORT 22'
             })
         ];
@@ -324,11 +324,8 @@ exports['update so rules no longer affect VM'] = {
                 port: 22,
                 proto: 'tcp',
                 target: 'any',
-                vm: d.vms[0]
-                // XXX: this is wrong - the VM's ipf rules should be
-                // rewritten. Uncomment the next line once FWAPI-200
-                // is fixed:
-                // doesNotExist: true
+                vm: d.vms[0],
+                doesNotExist: true
             });
 
             return t.done();
-- 
2.21.0

