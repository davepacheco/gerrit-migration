From fcbd66058d290fa8284a25bda854ff8743478b4f Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Mon, 15 Oct 2018 16:29:14 +0200
Subject: [PATCH] TRITON-769 wf-runner is crashing in metrics calc on jobs that
 fail with "workflow timeout" Reviewed by: Trent Mick <trentm@gmail.com>
 Approved by: Trent Mick <trentm@gmail.com>

---
 README.md           |   4 +-
 lib/job-runner.js   |   6 +-
 lib/runner.js       |  21 ++-
 test/runner.test.js | 413 +++++++++++++++++++++++++++-----------------
 4 files changed, 273 insertions(+), 171 deletions(-)

diff --git a/README.md b/README.md
index 427fc40..3bd8454 100644
--- a/README.md
+++ b/README.md
@@ -99,7 +99,7 @@ To run a Job Runner:
     ./bin/workflow-runner path/to/config.json
 
 Note that it's fine to run more than one Runner, either on the same or different
-machines, so long as they have access to the Redis Server.
+machines, so long as they have access to the same storage backend.
 
 # Testing
 
@@ -184,7 +184,7 @@ See https://github.com/joyent/node-workflow/issues.
 
 # LICENSE
 
-The MIT License (MIT) Copyright (c) 2017 Joyent, Inc.
+The MIT License (MIT) Copyright (c) 2018 Joyent, Inc.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
diff --git a/lib/job-runner.js b/lib/job-runner.js
index aa5b478..40abc88 100644
--- a/lib/job-runner.js
+++ b/lib/job-runner.js
@@ -449,7 +449,8 @@ var WorkflowJobRunner = module.exports = function (opts) {
                 if (!failed) {
                     job[chain_results].push({
                         error: 'workflow timeout',
-                        result: ''
+                        result: '',
+                        finished_at: new Date().toISOString()
                     });
                     _updateJobProperty(
                         job.uuid,
@@ -464,7 +465,8 @@ var WorkflowJobRunner = module.exports = function (opts) {
                 } else {
                     job.onerror_results.push({
                         error: 'workflow timeout',
-                        result: ''
+                        result: '',
+                        finished_at: new Date().toISOString()
                     });
                     _updateJobProperty(
                         job.uuid,
diff --git a/lib/runner.js b/lib/runner.js
index ae23c67..015ea0a 100644
--- a/lib/runner.js
+++ b/lib/runner.js
@@ -147,10 +147,14 @@ var WorkflowRunner = module.exports = function (opts) {
                 if (job.chain_results.length) {
                     var lastTask = job.
                         chain_results[job.chain_results.length - 1];
-                    var endMs = new Date(lastTask.finished_at).getTime();
-                    var startMs = new Date(job.created_at).getTime();
-                    durationSeconds = (endMs - startMs) / 1000;
-                } else {
+                    if (lastTask.finished_at) {
+                        var endMs = new Date(lastTask.finished_at).getTime();
+                        var startMs = new Date(job.created_at).getTime();
+                        durationSeconds = (endMs - startMs) / 1000;
+                    }
+                }
+
+                if (!durationSeconds) {
                     durationSeconds = job.elapsed;
                 }
 
@@ -161,13 +165,16 @@ var WorkflowRunner = module.exports = function (opts) {
             // between tasks
             function calculateOverhead(job) {
                 var jobCreated = new Date(job.created_at).getTime();
-                var firstJobStarted = new Date(job.chain_results[0].started_at)
-                    .getTime();
+                var firstJobStarted = (job.chain_results[0].started_at) ?
+                    new Date(job.chain_results[0].started_at).getTime():
+                    jobCreated;
                 var startOverhead = (firstJobStarted - jobCreated) / 1000;
                 var overheadSeconds = job.chain_results.reduce(
                     function sumOverhead(total, result, idx, chainResults) {
                     var nextTask = chainResults[idx + 1];
-                    if (nextTask) {
+                    if (nextTask &&
+                        nextTask.started_at &&
+                        result.finished_at) {
                         var nextTaskStartMs = new Date(nextTask.started_at)
                             .getTime();
                         var currentTaskEndMs = new Date(result.finished_at)
diff --git a/test/runner.test.js b/test/runner.test.js
index f3381f8..4c399d4 100644
--- a/test/runner.test.js
+++ b/test/runner.test.js
@@ -6,6 +6,7 @@ var path = require('path');
 var fs = require('fs');
 var test = require('tap').test;
 var uuid = require('uuid');
+var vasync = require('vasync');
 var WorkflowRunner = require('../lib/runner');
 var Factory = require('../lib/index').Factory;
 var exists = fs.exists || path.exists;
@@ -18,8 +19,8 @@ var config = {};
 var okTask = {
     name: 'OK Task',
     retry: 1,
-    body: function (job, cb) {
-        return cb(null);
+    body: function (_job, cb) {
+        cb(null);
     }
 };
 var failTask = {
@@ -27,7 +28,7 @@ var failTask = {
     name: 'Fail Task',
     body: function (job, cb) {
         job.log.info('recording some info');
-        return cb('Fail task error');
+        cb('Fail task error');
     }
 };
 var failTaskWithError = {
@@ -35,32 +36,33 @@ var failTaskWithError = {
     name: 'Fail Task with error',
     body: function (job, cb) {
         job.log.info('recording some info');
-        return cb(new Error('Fail task error'));
+        cb(new Error('Fail task error'));
     }
 
 };
 var failTaskWithJobRetry = {
     retry: 1,
     name: 'Fail Task with job retry',
-    body: function (job, cb) {
-        return cb('retry');
+    body: function (_job, cb) {
+        cb('retry');
     }
 };
 var failTaskWithJobWait = {
     retry: 1,
     name: 'Fail Task with job wait',
-    body: function (job, cb) {
-        return cb('wait');
+    body: function (_job, cb) {
+        cb('wait');
     }
 };
 var taskWithModules = {
     name: 'OK Task with modules',
     retry: 1,
-    body: function (job, cb) {
+    body: function (_job, cb) {
         if (typeof (uuid) !== 'function') {
-            return cb('uuid module is not defined');
+            cb('uuid module is not defined');
+            return;
         }
-        return cb(null);
+        cb(null);
     },
     modules: {
         uuid: 'uuid'
@@ -74,7 +76,7 @@ var DTRACE = createDTrace('workflow');
 
 test('throws on missing opts', function (t) {
     t.throws(function () {
-        return WorkflowRunner();
+        WorkflowRunner();
     }, 'The "opts" argument must be of type object');
     t.end();
 });
@@ -82,7 +84,7 @@ test('throws on missing opts', function (t) {
 
 test('throws on missing backend', function (t) {
     t.throws(function () {
-        return WorkflowRunner(config);
+        WorkflowRunner(config);
     }, 'The "opts.backend" argument must be of type object');
     t.end();
 });
@@ -91,7 +93,7 @@ test('throws on missing backend', function (t) {
 test('throws on missing dtrace', function (t) {
     config = helper.config();
     t.throws(function () {
-        return WorkflowRunner(config);
+        WorkflowRunner(config);
     }, 'The "opts.dtrace" argument must be of type object');
     t.end();
 });
@@ -113,8 +115,8 @@ test('setup', function (t) {
     t.ok(runner);
     t.ok(runner.backend, 'backend ok');
     backend = runner.backend;
-    runner.init(function (err) {
-        t.ifError(err, 'runner init error');
+    runner.init(function (err0) {
+        t.ifError(err0, 'runner init error');
         factory = Factory(backend);
         t.ok(factory);
 
@@ -123,38 +125,38 @@ test('setup', function (t) {
             name: 'OK wf',
             chain: [okTask, failTaskWithJobWait, taskWithModules],
             timeout: 60
-        }, function (err, wf) {
-            t.ifError(err, 'ok wf error');
-            t.ok(wf, 'OK wf OK');
-            okWf = wf;
+        }, function (err1, wf1) {
+            t.ifError(err1, 'ok wf error');
+            t.ok(wf1, 'OK wf OK');
+            okWf = wf1;
             // failWf:
             factory.workflow({
                 name: 'Fail wf',
                 chain: [failTask],
                 timeout: 60
-            }, function (err, wf) {
-                t.ifError(err, 'Fail wf error');
-                t.ok(wf, 'Fail wf OK');
-                failWf = wf;
+            }, function (err2, wf2) {
+                t.ifError(err2, 'Fail wf error');
+                t.ok(wf2, 'Fail wf OK');
+                failWf = wf2;
                 factory.workflow({
                     name: 'Fail wf with error',
                     chain: [failTaskWithError],
                     timeout: 60
-                }, function (err, wf) {
-                    t.ifError(err, 'Fail wf with error');
-                    t.ok(wf, 'Fail wf with error OK');
-                    failWfWithError = wf;
+                }, function (err3, wf3) {
+                    t.ifError(err3, 'Fail wf with error');
+                    t.ok(wf3, 'Fail wf with error OK');
+                    failWfWithError = wf3;
                     factory.workflow({
                         name: 'Fail wf with retry',
                         chain: [failTaskWithJobRetry],
                         timeout: 60,
                         max_attempts: 3
-                    }, function (err, wf) {
-                        t.ifError(err, 'Fail wf with retry');
-                        t.ok(wf, 'Fail wf with retry OK');
-                        failWfWithRetry = wf;
-                        backend.getRunners(function (err, runners) {
-                            t.ifError(err, 'get runners error');
+                    }, function (err4, wf4) {
+                        t.ifError(err4, 'Fail wf with retry');
+                        t.ok(wf4, 'Fail wf with retry OK');
+                        failWfWithRetry = wf4;
+                        backend.getRunners(function (err5, runners) {
+                            t.ifError(err5, 'get runners error');
                             t.ok(runners[identifier], 'runner id ok');
                             t.ok(new Date(runners[identifier]),
                                 'runner timestamp ok');
@@ -169,22 +171,23 @@ test('setup', function (t) {
 
 
 test('runner identifier', function (t) {
-    var cfg = {
+    const cfg = {
         backend: helper.config().backend,
         dtrace: DTRACE
-    }, aRunner = WorkflowRunner(cfg),
-    identifier;
+    };
+    const aRunner = WorkflowRunner(cfg);
+    var ident;
     // run getIdentifier twice, one to create the file,
     // another to just read it:
     aRunner.init(function (err) {
         t.ifError(err, 'runner init error');
-        aRunner.getIdentifier(function (err, id) {
-            t.ifError(err, 'get identifier error');
+        aRunner.getIdentifier(function (err1, id) {
+            t.ifError(err1, 'get identifier error');
             t.ok(id, 'get identifier id');
-            identifier = id;
-            aRunner.getIdentifier(function (err, id) {
-                t.ifError(err, 'get identifier error');
-                t.equal(id, identifier, 'correct id');
+            ident = id;
+            aRunner.getIdentifier(function (err2, id2) {
+                t.ifError(err2, 'get identifier error');
+                t.equal(id2, ident, 'correct id');
                 aRunner.backend.quit(function () {
                     t.end();
                 });
@@ -233,14 +236,14 @@ test('idle runner', function (t) {
         factory.job({
             workflow: okWf.uuid,
             exec_after: '2012-01-03T12:54:05.788Z'
-        }, function (err, job) {
-            t.ifError(err, 'job error');
-            t.ok(job, 'run job ok');
-            theJob = job;
+        }, function (err1, job1) {
+            t.ifError(err1, 'job error');
+            t.ok(job1, 'run job ok');
+            theJob = job1;
             // The job is queued. The runner is idle. Job should remain queued:
-            backend.getJob(theJob.uuid, function (err, j) {
-                t.ifError(err, 'run job get job error');
-                t.equal(j.execution, 'queued', 'job execution');
+            backend.getJob(theJob.uuid, function (err2, job2) {
+                t.ifError(err2, 'run job get job error');
+                t.equal(job2.execution, 'queued', 'job execution');
                 runner.quit(function () {
                     t.end();
                 });
@@ -257,12 +260,12 @@ test('run job', function (t) {
         runner.run();
         setTimeout(function () {
             runner.quit(function () {
-                backend.getJob(theJob.uuid, function (err, job) {
-                    t.ifError(err, 'run job get job error');
-                    t.equal(job.execution, 'waiting', 'job execution');
-                    t.equal(job.chain_results[0].result, 'OK');
-                    t.equal(job.chain_results[1].result, 'OK');
-                    theJob = job;
+                backend.getJob(theJob.uuid, function (err1, job1) {
+                    t.ifError(err1, 'run job get job error');
+                    t.equal(job1.execution, 'waiting', 'job execution');
+                    t.equal(job1.chain_results[0].result, 'OK');
+                    t.equal(job1.chain_results[1].result, 'OK');
+                    theJob = job1;
                     t.end();
                 });
             });
@@ -278,11 +281,11 @@ test('re-run waiting job', function (t) {
         runner.run();
         setTimeout(function () {
             runner.quit(function () {
-                backend.getJob(theJob.uuid, function (err, job) {
-                    t.ifError(err, 'run job get job error');
-                    t.equal(job.execution, 'succeeded', 'job execution');
-                    t.equal(job.chain_results[0].result, 'OK');
-                    t.equal(job.chain_results[1].result, 'OK');
+                backend.getJob(theJob.uuid, function (err1, job1) {
+                    t.ifError(err1, 'run job get job error');
+                    t.equal(job1.execution, 'succeeded', 'job execution');
+                    t.equal(job1.chain_results[0].result, 'OK');
+                    t.equal(job1.chain_results[1].result, 'OK');
                     t.end();
                 });
             });
@@ -303,10 +306,10 @@ test('run job which fails', function (t) {
         runner.run();
         setTimeout(function () {
             runner.quit(function () {
-                backend.getJob(aJob.uuid, function (err, job) {
-                    t.ifError(err, 'get job error');
-                    t.equal(job.execution, 'failed', 'job execution');
-                    t.equal(job.chain_results[0].error, 'Fail task error');
+                backend.getJob(aJob.uuid, function (err1, job1) {
+                    t.ifError(err1, 'get job error');
+                    t.equal(job1.execution, 'failed', 'job execution');
+                    t.equal(job1.chain_results[0].error, 'Fail task error');
                     t.end();
                 });
             });
@@ -327,12 +330,12 @@ test('run job which fails with error instance', function (t) {
         runner.run();
         setTimeout(function () {
             runner.quit(function () {
-                backend.getJob(aJob.uuid, function (err, job) {
-                    t.ifError(err, 'get job error');
-                    t.equal(job.execution, 'failed', 'job execution');
-                    t.ok(job.chain_results[0].error.name);
-                    t.ok(job.chain_results[0].error.message);
-                    t.equal(job.chain_results[0].error.message,
+                backend.getJob(aJob.uuid, function (err1, job1) {
+                    t.ifError(err1, 'get job error');
+                    t.equal(job1.execution, 'failed', 'job execution');
+                    t.ok(job1.chain_results[0].error.name);
+                    t.ok(job1.chain_results[0].error.message);
+                    t.equal(job1.chain_results[0].error.message,
                         'Fail task error');
                     t.end();
                 });
@@ -354,23 +357,24 @@ test('a job that is retried', function (t) {
         runner.run();
         setTimeout(function () {
             runner.quit(function () {
-                backend.getJob(aJob.uuid, function (err, job) {
-                    t.ifError(err, 'get job error');
-                    t.equal(job.execution, 'retried', 'job execution');
-                    t.equal(job.chain_results[0].error, 'retry', 'error');
-                    var prevJob = job;
-                    backend.getJob(job.next_attempt, function (err, job) {
-                        t.ifError(err, 'get job error');
-                        t.equal(job.execution, 'retried', 'job execution');
-                        t.equal(job.chain_results[0].error, 'retry', 'error');
-                        t.equal(prevJob.uuid, job.prev_attempt);
-                        var midJob = job;
-                        backend.getJob(job.next_attempt, function (err, job) {
-                            t.ifError(err, 'get job error');
-                            t.equal(job.execution, 'retried', 'job execution');
-                            t.equal(job.chain_results[0].error, 'retry');
-                            t.equal(midJob.uuid, job.prev_attempt);
-                            t.notOk(job.next_attempt);
+                backend.getJob(aJob.uuid, function (err1, job1) {
+                    t.ifError(err1, 'get job error');
+                    t.equal(job1.execution, 'retried', 'job execution');
+                    t.equal(job1.chain_results[0].error, 'retry', 'error');
+                    var prevJob = job1;
+                    backend.getJob(job1.next_attempt, function (err2, job2) {
+                        t.ifError(err2, 'get job error');
+                        t.equal(job2.execution, 'retried', 'job execution');
+                        t.equal(job2.chain_results[0].error, 'retry', 'error');
+                        t.equal(prevJob.uuid, job2.prev_attempt);
+                        var midJob = job2;
+                        backend.getJob(job2.next_attempt,
+                            function getJCb(err3, job3) {
+                            t.ifError(err3, 'get job error');
+                            t.equal(job3.execution, 'retried', 'job execution');
+                            t.equal(job3.chain_results[0].error, 'retry');
+                            t.equal(midJob.uuid, job3.prev_attempt);
+                            t.notOk(job3.next_attempt);
                             t.end();
                         });
                     });
@@ -400,20 +404,20 @@ test('inactive runners', function (t) {
         t.ifError(err, 'another runner init error');
         // Now we quit the new runner, and outdate it:
         anotherRunner.quit(function () {
-            runner.inactiveRunners(function (err, runners) {
-                t.ifError(err, 'inactive runners error');
-                t.ok(util.isArray(runners), 'runners is array');
-                t.equal(runners.length, 0, 'runners length');
+            runner.inactiveRunners(function (err1, runners1) {
+                t.ifError(err1, 'inactive runners error');
+                t.ok(util.isArray(runners1), 'runners is array');
+                t.equal(runners1.length, 0, 'runners length');
                 backend.runnerActive(
                     anotherRunner.identifier,
                     '2012-01-03T12:54:05.788Z',
-                    function (err) {
-                        t.ifError(err, 'set runner timestamp error');
-                        runner.inactiveRunners(function (err, runners) {
-                            t.ifError(err, 'inactive runners error');
-                            t.ok(util.isArray(runners), 'runners is array');
-                            t.equal(runners.length, 1, 'runners length');
-                            t.equal(runners[0], theUUID, 'runner uuid error');
+                    function (err2) {
+                        t.ifError(err2, 'set runner timestamp error');
+                        runner.inactiveRunners(function (err3, runners3) {
+                            t.ifError(err3, 'inactive runners error');
+                            t.ok(util.isArray(runners3), 'runners is array');
+                            t.equal(runners3.length, 1, 'runners length');
+                            t.equal(runners3[0], theUUID, 'runner uuid error');
                             anotherRunner.backend.quit(function () {
                                 t.end();
                             });
@@ -427,79 +431,168 @@ test('inactive runners', function (t) {
 
 test('stale jobs', function (t) {
     // Add another runner, which we'll set as inactive
-    var theUUID = uuid(),
-    cfg = {
+    var cfg = {
         backend: helper.config().backend,
         runner: {
-            identifier: theUUID,
+            identifier: uuid(),
             forks: 2,
             run_interval: 250
         },
         dtrace: DTRACE
-    },
-    anotherRunner = WorkflowRunner(cfg),
-    aJob;
-    t.ok(anotherRunner, 'another runner ok');
+    };
 
-    factory.job({
-        workflow: okWf.uuid,
-        exec_after: '2012-01-03T12:54:05.788Z'
-    }, function (err, job) {
-        t.ifError(err, 'job error');
-        t.ok(job, 'run job ok');
-        aJob = job;
-        // Init the new runner, then update it to make inactive
-        anotherRunner.init(function (err) {
-            t.ifError(err, 'another runner init error');
-            backend.runJob(aJob.uuid, anotherRunner.identifier,
-              function (err, job) {
-                t.ifError(err, 'backend run job error');
-                // The runner is not inactive; therefore, no stale jobs
+    vasync.pipeline({
+        arg: {
+            anotherRunner: WorkflowRunner(cfg)
+        },
+        funcs: [
+            // Create a job and store as `ctx.aJob`
+            function createJob(ctx, next) {
+                factory.job({
+                    workflow: okWf.uuid,
+                    exec_after: '2012-01-03T12:54:05.788Z'
+                }, function (err, job) {
+                    t.ifError(err, 'job error');
+                    t.ok(job, 'run job ok');
+                    ctx.aJob = job;
+                    backend.getJob(ctx.aJob.uuid, function (err1, job1) {
+                        t.ifError(err1, 'get job err');
+                        t.equal('queued', job1.execution, 'Job is queued');
+                        ctx.aJob = job1;
+                        next();
+                    });
+                });
+            },
+            function runJob(ctx, next) {
+                backend.runJob(
+                    ctx.aJob.uuid,
+                    ctx.anotherRunner.identifier,
+                    function runJobCb(err, job) {
+                        t.ifError(err, 'backend run job error');
+                        t.equal('running', job.execution, 'Job is running');
+                        ctx.aJob = job;
+                        ctx.anotherRunner.quit(next);
+                });
+            },
+            function checkStaleJobs(_, next) {
                 runner.staleJobs(function (err, jobs) {
                     t.ifError(err, 'stale jobs error');
                     t.equivalent(jobs, [], 'stale jobs empty');
-                    // Now we quit the new runner, and outdate it:
-                    anotherRunner.quit(function () {
-                        // The runner will be inactive so, any job flagged
-                        // as owned by this runner will be stale
-                        backend.runnerActive(
-                          anotherRunner.identifier,
-                          '2012-01-03T12:54:05.788Z',
-                          function (err) {
-                            t.ifError(err, 'set runner timestamp error');
-                            // Our job should be here now:
-                            runner.staleJobs(function (err, jobs) {
-                                t.ifError(err, 'stale jobs 2 error');
-                                t.equivalent([aJob.uuid], jobs);
-                                // Let's set the job canceled and finish it:
-                                backend.updateJobProperty(
-                                  aJob.uuid,
-                                  'execution',
-                                  'canceled',
-                                  function (err) {
-                                    t.ifError(err, 'update job prop err');
-                                    aJob.execution = 'canceled';
-                                    backend.finishJob(aJob,
-                                      function (err, job) {
-                                        t.ifError(err, 'finish job err');
-                                        t.ok(job, 'finish job ok');
-                                        runner.staleJobs(function (err, jobs) {
-                                            t.ifError(err,
-                                              'stale jobs 3 error');
-                                            t.equivalent(jobs, []);
-                                            anotherRunner.backend.quit(
-                                              function () {
-                                                t.end();
-                                            });
-                                        });
-                                    });
-                                });
-                            });
-                        });
+                    next();
+                });
+            },
+            function outdateRunner(ctx, next) {
+                // The runner will be inactive so, any job flagged
+                // as owned by this runner will be stale
+                backend.runnerActive(
+                    ctx.anotherRunner.identifier,
+                      '2012-01-03T12:54:05.788Z',
+                      function (err) {
+                          t.ifError(err, 'set runner timestamp error');
+                          next();
+                      });
+            },
+            function reCheckStaleJobs(ctx, next) {
+                runner.staleJobs(function (err, jobs) {
+                    t.ifError(err, 'stale jobs error');
+                    t.equivalent(jobs, [ctx.aJob.uuid], 'stale jobs not empty');
+                    next();
+                });
+            },
+            function finishJob(ctx, next) {
+                backend.finishJob(ctx.aJob, function finishJobCb(err, job) {
+                    t.ifError(err, 'finish job err');
+                    t.ok(job, 'finish job ok');
+                    next();
+                });
+            },
+            function triCheckStaleJobs(_, next) {
+                runner.staleJobs(function (err, jobs) {
+                    t.ifError(err, 'stale jobs error');
+                    t.equivalent(jobs, [],
+                        'Only not finished jobs can be stale');
+                    next();
+                });
+            }
+        ]
+    }, function pipeCb(pipeErr) {
+        t.end(pipeErr);
+    });
+
+});
+
+
+test('timeout job', function (t) {
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function createWorkflow(ctx, next) {
+                factory.workflow({
+                    name: 'Timeout wf',
+                    chain: [
+                        {
+                            name: 'Timeout Task',
+                            retry: 0,
+                            body: function (_job, cb) {
+                                setTimeout(function () {
+                                    cb(null);
+                                }, 10000);
+                            }
+                        }
+                    ],
+                    timeout: 1,
+                    max_attempts: 1
+                }, function (err, wf) {
+                    t.ifError(err, 'Timeout wf error');
+                    t.ok(wf, 'Timeout wf OK');
+                    ctx.wf = wf;
+                    next();
+                });
+            },
+            function createJob(ctx, next) {
+                factory.job({
+                    workflow: ctx.wf.uuid,
+                    exec_after: '2012-01-03T12:54:05.788Z'
+                }, function (err, job) {
+                    t.ifError(err, 'job error');
+                    t.ok(job, 'job ok');
+                    ctx.aJob = job;
+                    backend.getJob(ctx.aJob.uuid, function (err1, job1) {
+                        t.ifError(err1, 'get job err');
+                        t.equal('queued', job1.execution, 'Job is queued');
+                        ctx.aJob = job1;
+                        next();
                     });
                 });
-            });
-        });
+            },
+            function runJob(_, next) {
+                backend.wakeUpRunner(runner.identifier, function (err) {
+                    t.ifError(err, 'wake up runner error');
+                    runner.run();
+                    next();
+                });
+            },
+            function checkJob(ctx, next) {
+                // Give it room enough to timeout the job
+                setTimeout(function () {
+                    backend.getJob(ctx.aJob.uuid, function (err, job) {
+                        t.ifError(err, 'get job err');
+                        t.equal('failed', job.execution, 'Job is failed');
+                        t.ok(job.chain_results, 'chain_results');
+                        t.ok(job.chain_results[0].error, 'job error');
+                        t.ok(job.chain_results[0].finished_at,
+                            'job finished_at');
+                        next();
+                    });
+                }, 2000);
+
+            },
+            function quitRunner(_, next) {
+                runner.quit(next);
+            }
+        ]
+    }, function pipeCb(pipeErr) {
+        t.end(pipeErr);
     });
 });
 
-- 
2.21.0

