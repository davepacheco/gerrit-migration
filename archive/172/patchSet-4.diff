commit 10093c11e7f04848f1bd00c12b2e3357afad9740 (refs/changes/72/172/4)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-07-29T16:15:50-07:00 (3 years, 2 months ago)
    
    PUBAPI-1299 want nicer API for smartdc-auth

diff --git a/Makefile b/Makefile
index d4f4309..cc9737a 100644
--- a/Makefile
+++ b/Makefile
@@ -9,7 +9,6 @@ JS_FILES	:= $(shell find lib -name '*.js')
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
-JSSTYLE_FLAGS    = -o indent=4,doxygen,unparenthesized-return=0
 
 #
 # Tools
diff --git a/README.md b/README.md
index 368d114..62844ef 100644
--- a/README.md
+++ b/README.md
@@ -26,6 +26,136 @@ The `keyId` for SmartDC is always `/$your_joyent_login/keys/$ssh_fingerprint`,
 and the supported algorithms are: `rsa-sha1`, `rsa-sha256` and `dsa-sha1`.  You
 then just append the base64 encoded signature.
 
+## New API: KeyRing
+
+### `new mod_sdcauth.KeyRing([options])`
+
+Create a new SDC keyring. KeyRing instances use a list of plugins in order to
+locate keys on the local system - via the filesystem, via the SSH agent, or any
+other mechanism.
+
+Parameters
+
+- `options`: an Object containing properties:
+  - `plugins`: an Array of String, names of plugins to enable
+
+Any additional keys set in the `options` object will be passed through to
+plugins as options for their processing.
+
+Available plugins:
+- `agent`: Gets keys from the OpenSSH agent. Options:
+  - `sshAgentOpts`: an Object, options to be passed to `mod_sshpk_agent.Client`
+- `homedir`: Gets keys from a directory on the filesystem. Options:
+  - `keyDir`: a String, path to look in for keys, defaults to `$HOME/.ssh`
+
+### `KeyRing#list(cb)`
+
+Lists all available keys in all plugins, organised by their Key ID.
+
+Parameters
+
+- `cb`: a Function `(err, keypairs)` with parameters:
+  - `err`: an Error or `null`
+  - `keypairs`: an Object, keys: String key IDs, values: Array of instances of
+    `KeyPair`
+
+### `KeyRing#find(fingerprint, cb)`
+
+Searches active plugins for an SSH key matching the given fingerprint. Calls
+`cb` with an array of `KeyPair` instances that match, ordered arbitrarily.
+
+Parameters:
+ - `fingerprint`: an `sshpk.Fingerprint`
+ - `cb`: a Function `(err, keypairs)`, with parameters:
+   - `err`: an Error or `null`
+   - `keypairs`: an Array of `KeyPair` instances
+
+### `KeyRing#findSigningKeyPair(fingerprint, cb)`
+
+Searches active plugins for an SSH key matching the given fingerprint. Chooses
+the best available signing key of those available (preferably unlocked) and
+calls `cb` with this single `KeyPair` instance.
+
+Parameters:
+ - `fingerprint`: an `sshpk.Fingerprint`
+ - `cb`: a Function `(err, keypair)`, with parameters:
+   - `err`: an Error or `null`
+   - `keypair`: a `KeyPair` instance
+
+## KeyPair
+
+### `KeyPair.fromPrivateKey(privKey)`
+
+Constructs a KeyPair unrelated to any keychain, based directly on a given
+private key. This is mostly useful for compatibility purposes.
+
+Parameters:
+ - `privKey`: an `sshpk.PrivateKey`
+
+### `KeyPair#plugin`
+
+String, name of the plugin through which this KeyPair was found.
+
+### `KeyPair#source`
+
+String (may be `undefined`), human-readable name of the source that the KeyPair
+came from when discovered (e.g. for a plugin that searches the filesystem, this
+could be the path to the key file).
+
+### `KeyPair#comment`
+
+String, comment that was stored with the key, if any.
+
+### `KeyPair#canSign()`
+
+Returns Boolean `true` if this key pair is complete (has a private and public
+key) and can be used for signing. Note that this returns `true` for locked
+keys.
+
+### `KeyPair#isLocked()`
+
+Returns Boolean `true` if this key pair is locked and may be unlocked using
+the `unlock()` method.
+
+### `KeyPair#unlock(passphrase)`
+
+Unlocks an encrypted key pair, allowing it to be used for signing and the
+`getPrivateKey()` method to be called.
+
+Parameters:
+ - `passphrase`: a String, passphrase for decryption
+
+### `KeyPair#getKeyId()`
+
+Returns the String key ID for this key pair. This is specifically the key ID
+as used in HTTP signature auth for SDC and Manta. Currently this is a
+hex-format MD5 fingerprint of the key, but this may change in future.
+
+### `KeyPair#getPublicKey()`
+
+Returns the `sshpk.Key` object representing this pair's public key.
+
+### `KeyPair#getPrivateKey()`
+
+Returns the `sshpk.PrivateKey` object representing this pair's private key. If
+unavailable, this method will throw an `Error`.
+
+### `KeyPair#createRequestSigner(options)`
+
+Creates an `http-signature` `RequestSigner` object for signing an HTTP request
+using this key pair's private key.
+
+Parameters:
+ - `options`, an Object...
+
+### `KeyPair#createSign(options)`
+
+Creates a `sign()` function (matching the legacy `smartdc-auth` API) for
+signing arbitrary data with this key pair's private key.
+
+Parameters:
+ - `options`, an Object...
+
 ## Authenticating Requests
 
 When creating a smartdc client, you'll need to pass in a callback function for
diff --git a/lib/errors.js b/lib/errors.js
new file mode 100644
index 0000000..9ced009
--- /dev/null
+++ b/lib/errors.js
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = {
+	KeyNotFoundError: KeyNotFoundError
+};
+
+const mod_assert = require('assert-plus');
+const mod_util = require('util');
+
+function KeyNotFoundError(fp, srcs) {
+	mod_assert.object(fp, 'fingerprint');
+	mod_assert.arrayOfString(srcs, 'sources');
+	if (Error.captureStackTrace)
+		Error.captureStackTrace(this, KeyNotFoundError);
+	this.name = 'KeyNotFoundError';
+	this.fingerprint = fp;
+	this.sources = srcs;
+	this.message = 'SSH key with fingerprint "' + fp.toString() + '" ' +
+	    'could not be located in ' + srcs.join(' or ');
+}
+mod_util.inherits(KeyNotFoundError, Error);
+/*
+ * Used to condense multiple KeyNotFoundErrors into one, so that we can
+ * produce a single error that covers everything. Joins them together by
+ * concatenating their .sources lists.
+ */
+KeyNotFoundError.join = function (errs) {
+	mod_assert.arrayOfObject(errs, 'errors');
+	var fp = errs[0].fingerprint;
+	var srcs = errs[0].sources;
+	for (var i = 1; i < errs.length; ++i) {
+		mod_assert.ok(errs[i] instanceof KeyNotFoundError);
+		mod_assert.strictEqual(errs[i].fingerprint, fp);
+		srcs = srcs.concat(errs[i].sources);
+	}
+	return (new KeyNotFoundError(fp, srcs));
+};
diff --git a/lib/index.js b/lib/index.js
index fe339ea..ebd445b 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -1,832 +1,205 @@
-// Copyright (c) 2015, Joyent, Inc. All rights reserved.
-
-var crypto = require('crypto');
-var EventEmitter = require('events').EventEmitter;
-var fs = require('fs');
-var path = require('path');
-var util = require('util');
-
-var assert = require('assert-plus');
-var clone = require('clone');
-var SSHAgentClient = require('sshpk-agent').Client;
-var once = require('once');
-var vasync = require('vasync');
-var sshpk = require('sshpk');
-var httpSignature = require('http-signature');
-
-/*
- * These are max file sizes for pub/private keys, to avoid buffering in huge
- * files that clearly are not keys.
- */
-var MAX_PUBKEY_SIZE = 65536;
-var MAX_PRIVKEY_SIZE = 131072;
-
-function KeyNotFoundError(fp, srcs) {
-    assert.string(fp, 'fingerprint');
-    assert.arrayOfString(srcs, 'sources');
-    if (Error.captureStackTrace)
-        Error.captureStackTrace(this, KeyNotFoundError);
-    this.name = 'KeyNotFoundError';
-    this.fingerprint = fp;
-    this.sources = srcs;
-    this.message = 'SSH key with fingerprint "' + fp + '" could not be ' +
-        'located in ' + srcs.join(' or ');
-}
-util.inherits(KeyNotFoundError, Error);
 /*
- * Used to condense multiple KeyNotFoundErrors into one, so that we can
- * produce a single error that covers everything. Joins them together by
- * concatenating their .sources lists.
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
  */
-KeyNotFoundError.join = function (errs) {
-    assert.arrayOfObject(errs, 'errors');
-    var fp = errs[0].fingerprint;
-    var srcs = errs[0].sources;
-    for (var i = 1; i < errs.length; ++i) {
-        assert.ok(errs[i] instanceof KeyNotFoundError);
-        assert.strictEqual(errs[i].fingerprint, fp);
-        srcs = srcs.concat(errs[i].sources);
-    }
-    return (new KeyNotFoundError(fp, srcs));
-};
-
-function SignatureCache(opts) {
-    assert.optionalObject(opts, 'options');
-    opts = opts || {};
-    assert.optionalNumber(opts.expiry, 'options.expiry');
-
-    this.expiry = opts.expiry || 10000;
-    this.pending = new EventEmitter();
-    this.pending.table = {};
-    this.table = {};
-    this.list = [];
-}
-
-SignatureCache.prototype.get = function get(k, cb) {
-    assert.string(k, 'key');
-    assert.func(cb, 'callback');
-
-    cb = once(cb);
-
-    var found = false;
-    var self = this;
-
-    function cachedResponse() {
-        var val = self.table[k].value;
-        cb(val.err, val.value);
-    }
 
-    if (this.table[k]) {
-        found = true;
-        process.nextTick(cachedResponse);
-    } else if (this.pending.table[k]) {
-        found = true;
-        this.pending.once(k, cachedResponse);
-    }
-
-    return (found);
-};
-
-
-SignatureCache.prototype.put = function put(k, v) {
-    assert.string(k, 'key');
-    assert.ok(v, 'value');
-
-    this.table[k] = {
-        time: new Date().getTime(),
-        value: v
-    };
-
-    if (this.pending.table[k])
-        delete this.pending.table[k];
-
-    this.pending.emit(k, v);
-    this.purge();
-};
+const mod_assert = require('assert-plus');
+const mod_httpsig = require('http-signature');
+const mod_sshpk = require('sshpk');
+const mod_clone = require('clone');
 
+const KeyRing = require('./keyring');
 
-SignatureCache.prototype.purge = function purge() {
-    var list = [];
-    var now = new Date().getTime();
-    var self = this;
+const mod_keypair = require('./keypair');
+const KeyPair = mod_keypair.KeyPair;
+const LockedKeyPair = mod_keypair.LockedKeyPair;
 
-    Object.keys(this.table).forEach(function (k) {
-        if (self.table[k].time + self.expiry < now)
-            list.push(k);
-    });
+const mod_errors = require('./errors');
 
-    list.forEach(function (k) {
-        if (self.table[k])
-            delete self.table[k];
-    });
-};
+module.exports = {
+	KeyRing: KeyRing,
 
+	cliSigner: cliSigner,
+	privateKeySigner: privateKeySigner,
+	sshAgentSigner: sshAgentSigner,
+	loadSSHKey: loadSSHKey,
+	signUrl: signUrl,
+	requestSigner: requestSigner,
 
-SignatureCache.prototype.toString = function toString() {
-    var fmt = '[object SignatureCache<pending=%j, table=%j>]';
-    return (util.format(fmt, this.pending.table, this.table));
+	KeyNotFoundError: mod_errors.KeyNotFoundError
 };
 
-
-function createCacheKey(opts) {
-    assert.object(opts, 'options');
-    assert.object(opts.key, 'options.key');
-    assert.string(opts.data, 'options.data');
-
-    return (opts.key.comment + '|' + opts.data);
-}
-
-function canonicalKeyId(key) {
-    assert.object(key, 'key');
-    return (key.fingerprint('md5').toString('hex'));
-}
+/* This is the legacy API that we emulate for compatibility. */
 
 function loadSSHKey(fp, cb) {
-    if (typeof (fp) === 'string')
-        fp = sshpk.parseFingerprint(fp);
-    assert.object(fp, 'fingerprint');
-    assert.ok(fp instanceof sshpk.Fingerprint,
-        'fingerprint instanceof sshpk.Fingerprint');
-    assert.func(cb, 'callback'); // `function (err, key, keyPaths)`
-
-    cb = once(cb);
-
-    var p;
-
-    if (process.platform === 'win32') {
-        p = process.env.USERPROFILE;
-    } else {
-        p = process.env.HOME;
-    }
-
-    if (!p) {
-        cb(new Error('cannot find HOME dir (HOME/USERPROFILE is not set)'));
-        return;
-    }
-
-    p = path.join(p, '.ssh');
-
-    fs.readdir(p, function (err, files) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        var allKeyPaths = [];
-        (files || []).forEach(function (f) {
-            /*
-             * If we have a .pub file and a matching private key, consider
-             * them as a pair (see below).
-             */
-            var m = f.match(/(.+)\.pub$/);
-            if (m && files.indexOf(m[1]) !== -1) {
-                allKeyPaths.push({
-                    public: path.join(p, f),
-                    private: path.join(p, m[1])
-                });
-                return;
-            }
-            /*
-             * If the name contains id_ (but doesn't end with .pub) and there
-             * is no matching public key, use it as a solo private key.
-             */
-            var m2 = f.match(/(^|[^a-zA-Z])id_/);
-            if (!m && m2 && files.indexOf(f + '.pub') === -1) {
-                allKeyPaths.push({
-                    private: path.join(p, f)
-                });
-                return;
-            }
-        });
-
-        /*
-         * When we have both a public and private key file, read in the
-         * .pub file first to do the fingerprint match. If that succeeds,
-         * read in and validate that the private key file matches it.
-         *
-         * This also ensures we fail early and give a sensible error if,
-         * e.g. the specified key is password-protected.
-         */
-        function readPublicKey(keyPaths, kcb) {
-            fs.readFile(keyPaths.public, 'ascii', function (kerr, blob) {
-                if (kerr) {
-                    kcb(kerr);
-                    return;
-                }
-
-                try {
-                    var key = sshpk.parseKey(blob, 'ssh', keyPaths.public);
-                } catch (e) {
-                    kcb(e);
-                    return;
-                }
-
-                if (fp.matches(key)) {
-                    /*
-                     * At this point, readPrivateKey has to succeed. If it
-                     * doesn't, its error should go all the way to the user
-                     * rather than a KeyNotFoundError (we did find the key,
-                     * but something is wrong with it)
-                     */
-                    readPrivateKey(keyPaths, function (pkerr, pk) {
-                        cb(pkerr, pk, keyPaths);
-                        kcb(null, pk);
-                    });
-                } else {
-                    kcb(new KeyNotFoundError(fp.toString(), [keyPaths.public]));
-                }
-            });
-        }
-
-        function readPrivateKey(keyPaths, kcb) {
-            fs.readFile(keyPaths.private, 'ascii', function (kerr, blob) {
-                if (kerr) {
-                    kcb(kerr);
-                    return;
-                }
-
-                try {
-                    var key = sshpk.parsePrivateKey(blob, 'pem',
-                        keyPaths.private);
-                } catch (e) {
-                    kcb(e);
-                    return;
-                }
-
-                /*
-                 * NOTE: we call cb() here (which has been once()'d above)
-                 * directly if we find a match. The actual forEachParallel cb
-                 * only calls cb() in case nothing succeeds.
-                 */
-                if (fp.matches(key)) {
-                    cb(null, key, keyPaths);
-                    kcb(null, key);
-                } else {
-                    kcb(new KeyNotFoundError(fp.toString(),
-                        [keyPaths.private]));
-                }
-            });
-        }
-
-        function processKey(keyPaths, kcb) {
-            /*
-             * Stat the file first to ensure we don't read from any sockets
-             * or crazy huge files that ended up in $HOME/.ssh (it happens).
-             *
-             * It's possible that the file could change between our stat here
-             * and when we open it in readPublicKey/readPrivateKey. Doing
-             * something about it is more effort than it's worth.
-             */
-            if (keyPaths.public) {
-                fs.stat(keyPaths.public, function (serr, stats) {
-                    if (serr) {
-                        kcb(serr);
-                        return;
-                    }
-                    if (stats.isFile() && stats.size < MAX_PUBKEY_SIZE) {
-                        readPublicKey(keyPaths, kcb);
-                    } else {
-                        kcb(new Error(keyPaths.public +
-                            ' is not a regular file, or ' +
-                            'size is too big to be an SSH public key.'));
-                    }
-                });
-            } else {
-                fs.stat(keyPaths.private, function (serr, stats) {
-                    if (serr) {
-                        kcb(serr);
-                        return;
-                    }
-                    if (stats.isFile() && stats.size < MAX_PRIVKEY_SIZE) {
-                        readPrivateKey(keyPaths, kcb);
-                    } else {
-                        kcb(new Error(keyPaths.private +
-                            ' is not a regular file, or ' +
-                            'size is too big to be an SSH private key.'));
-                    }
-                });
-            }
-        }
-
-        var opts = {
-            inputs: allKeyPaths,
-            func: processKey
-        };
-        vasync.forEachParallel(opts, function (errs, res) {
-            /* Only handle the not found case, see above. */
-            if (res.successes.length === 0) {
-                var msg = 'dir ' + p;
-                if (errs) {
-                    var fatals = [];
-                    res.operations.forEach(function (op) {
-                        if (op.err && !(op.err instanceof KeyNotFoundError))
-                            fatals.push(op.err.name + ': ' +
-                                op.err.message);
-                    });
-                    if (fatals.length > 0)
-                        msg += ' [warnings: ' + fatals.join(' ; ') + ']';
-                }
-                cb(new KeyNotFoundError(fp.toString(), [msg]));
-                return;
-            }
-        });
-    });
+	if (typeof (fp) === 'string')
+		fp = mod_sshpk.parseFingerprint(fp);
+	mod_assert.object(fp, 'fingerprint');
+	mod_assert.func(cb, 'callback');
+
+	var kr = new KeyRing({ plugins: ['homedir'] });
+	kr.findSigningKeyPair(fp, function (err, kp) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		try {
+			var key = kp.getPrivateKey();
+		} catch (e) {
+			cb(e);
+			return;
+		}
+		cb(null, key);
+	});
 }
 
-
-function rfc3986(str) {
-    return (encodeURIComponent(str)
-            .replace(/[!'()]/g, escape)
-            /* JSSTYLED */
-            .replace(/\*/g, '%2A'));
+function privateKeySigner(options) {
+	mod_assert.object(options, 'options');
+	if (typeof (options.key) !== 'string' &&
+	    !Buffer.isBuffer(options.key)) {
+		throw (new Error('options.key (a String or Buffer) is ' +
+		    'required'));
+	}
+	mod_assert.string(options.key, 'options.key');
+	mod_assert.string(options.user, 'options.user');
+	mod_assert.optionalString(options.subuser, 'options.subuser');
+	mod_assert.optionalString(options.keyId, 'options.keyId');
+
+	var key = mod_sshpk.parsePrivateKey(options.key);
+	var kp = KeyPair.fromPrivateKey(key);
+	return (kp.createSign(options));
 }
 
+function sshAgentSigner(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.string(options.keyId, 'options.keyId');
+	mod_assert.string(options.user, 'options.user');
+	mod_assert.optionalString(options.subuser, 'options.subuser');
+	mod_assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
 
-function sshAgentGetKey(client, fp, cb) {
-    assert.object(client, 'sshAgentClient');
-    if (typeof (fp) === 'string')
-        fp = sshpk.parseFingerprint(fp);
-    assert.object(fp, 'fingerprint');
-    assert.ok(fp instanceof sshpk.Fingerprint,
-        'fingerprint instanceof sshpk.Fingerprint');
-    assert.func(cb, 'callback');
-
-    var cache = client._signCache;
-    var _key = 'requestIdentities ' + fp.toString();
-    if (cache.get(_key, cb))
-        return;
-
-    client.listKeys(function (err, keys) {
-        var _val = {
-            err: null,
-            value: null
-        };
-
-        if (err) {
-            _val.err = err;
-        } else {
-            var key;
-            for (var i = 0; i < keys.length; ++i) {
-                if (fp.matches(keys[i])) {
-                    key = keys[i];
-                    break;
-                }
-            }
-
-            if (!key) {
-                _val.err = new KeyNotFoundError(fp.toString(), ['ssh-agent (' +
-                    keys.length + ' keys)']);
-            } else {
-                _val.value = key;
-            }
-        }
-
-        cache.put(_key, _val);
-        cb(_val.err, _val.value);
-    });
-}
+	var fp = mod_sshpk.parseFingerprint(options.keyId);
+	var kr = new KeyRing({ plugins: ['agent'] });
 
-function createSSHAgent(agentOpts) {
-    assert.optionalObject(agentOpts, 'agentOpts');
-
-    /*
-     * Return an error rather than throwing, so if our caller wants to ignore
-     * an issue with agent setup (eg no socket to connect to), they can do that
-     * without also ignoring a programmer error in SignatureCache (like a
-     * failed assertion).
-     */
-    try {
-        var agent = new SSHAgentClient(agentOpts);
-    } catch (e) {
-        assert.ok(e instanceof Error);
-        return (e);
-    }
-
-    agent._signCache = new SignatureCache();
-    return (agent);
+	return (signerWrapper(fp, kr, options));
 }
 
-function sshAgentSign(client, key, data, cb) {
-    assert.object(client, 'sshAgentClient');
-    assert.object(client._signCache, 'sshAgentClient');
-    assert.object(key, 'key');
-    assert.buffer(data, 'data');
-    assert.func(cb, 'callback');
-
-    var cache = client._signCache;
-
-    var _key = createCacheKey({
-        key: key,
-        data: data.toString()
-    });
-
-    if (cache.get(_key, cb))
-        return;
-
-    client.sign(key, data, function (err, sig) {
-        var _val = {};
-
-        if (err) {
-            _val.err = err;
-            cb(err);
-        } else {
-            _val.err = null;
-
-            _val.value = {
-                algorithm: key.type + '-' + sig.hashAlgorithm,
-                signature: sig.toString('asn1')
-            };
+function cliSigner(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.string(options.keyId, 'options.keyId');
+	mod_assert.string(options.user, 'options.user');
+	mod_assert.optionalString(options.subuser, 'options.subuser');
+	mod_assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
 
-            cb(null, _val.value);
-        }
+	var fp = mod_sshpk.parseFingerprint(options.keyId);
+	var kr = new KeyRing();
 
-        cache.put(_key, _val);
-    });
+	return (signerWrapper(fp, kr, options));
 }
 
-// ---- API
-
-function privateKeySigner(options) {
-    assert.object(options, 'options');
-    assert.optionalString(options.algorithm, 'options.algorithm');
-    assert.optionalString(options.keyId, 'options.keyId');
-    assert.string(options.key, 'options.key');
-    assert.string(options.user, 'options.user');
-    assert.optionalString(options.subuser, 'options.subuser');
-
-    var key = sshpk.parsePrivateKey(options.key, 'pem');
-    if (options.keyId) {
-        var fp = sshpk.parseFingerprint(options.keyId);
-        assert.ok(fp.matches(key), 'keyId does not match the given key');
-    }
-    var keyId = canonicalKeyId(key);
-
-    var alg = options.algorithm;
-    var algParts = alg ? alg.toLowerCase().split('-') : [];
-
-    if (algParts[0] && algParts[0] !== key.type)
-        throw (new Error('Requested algorithm ' + alg + ' is ' +
-            'not supported with a key of type ' + key.type));
-
-    var opts = clone(options);
-
-    function sign(str, cb) {
-        assert.string(str, 'str');
-        assert.func(cb, 'callback');
-
-        /*
-         * We can throw in here if the hash algorithm we were told to use in
-         * 'algorithm' is invalid. Return it as a normal error.
-         */
-        try {
-            var signer = key.createSign(algParts[1]);
-            signer.update(str);
-            var sig = signer.sign();
-        } catch (e) {
-            cb(e);
-            return;
-        }
-        var res = {
-            algorithm: key.type + '-' + sig.hashAlgorithm,
-            keyId: keyId,
-            signature: sig.toString(),
-            user: opts.user,
-            subuser: opts.subuser
-        };
-        sign.algorithm = res.algorithm;
-
-        cb(null, res);
-    }
-
-    sign.keyId = keyId;
-    sign.user = options.user;
-    sign.subuser = options.subuser;
-    sign.getKey = function (cb) {
-        cb(null, key);
-    };
-
-    return (sign);
-}
-
-
-function sshAgentSigner(options) {
-    assert.object(options, 'options');
-    assert.string(options.keyId, 'options.keyId');
-    assert.string(options.user, 'options.user');
-    assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
-    assert.optionalString(options.subuser, 'options.subuser');
-
-    var agentOrErr = createSSHAgent(options.sshAgentOpts);
-    /* An agent signer is useless without an agent, so throw */
-    if (agentOrErr instanceof Error)
-        throw (agentOrErr);
-
-    var agent = agentOrErr;
-
-    var fp = sshpk.parseFingerprint(options.keyId);
-
-    function sign(str, cb) {
-        assert.string(str, 'string');
-        assert.func(cb, 'callback');
-
-        sshAgentGetKey(agent, fp, function (err, key) {
-            if (err) {
-                cb(err);
-                return;
-            }
-
-            var data = new Buffer(str);
-            sshAgentSign(agent, key, data, function (err2, res) {
-                if (err2) {
-                    cb(err2);
-                } else {
-                    res.keyId = canonicalKeyId(key);
-                    res.user = options.user;
-                    res.subuser = options.subuser;
-                    sign.algorithm = res.algorithm;
-                    sign.keyId = res.keyId;
-                    cb(null, res);
-                }
-            });
-        });
-    }
-
-    sign.keyId = options.keyId;
-    sign.user = options.user;
-    sign.subuser = options.subuser;
-    sign.getKey = function (cb) {
-        sshAgentGetKey(agent, fp, function (err, key) {
-            if (key)
-                sign.algorithm = key.type + '-sha1';
-            cb(err, key);
-        });
-    };
-
-    return (sign);
+function requestSigner(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.optionalString(options.keyId, 'options.keyId');
+	mod_assert.optionalFunc(options.sign, 'options.sign');
+	mod_assert.optionalString(options.user, 'options.user');
+	mod_assert.optionalString(options.subuser, 'options.subuser');
+	mod_assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
+	mod_assert.optionalBool(options.mantaSubUser, 'options.mantaSubUser');
+
+	var sign = options.sign || cliSigner(options);
+
+	function rsign(data, cb) {
+		sign(data, function (err, res) {
+			if (res) {
+				var user = options.user || sign.user ||
+				    res.user;
+				var subuser = options.subuser || sign.subuser ||
+				    res.subuser;
+				mod_assert.string(user, 'user');
+				if (subuser) {
+					if (options.mantaSubUser)
+						user += '/' + subuser;
+					else
+						user += '/users/' + subuser;
+				}
+				var keyId = '/' + user + '/keys/' + res.keyId;
+				res.keyId = keyId;
+			}
+			cb(err, res);
+		});
+	}
+
+	return (mod_httpsig.createSigner({ sign: rsign }));
 }
 
-function cliSigner(options) {
-    assert.object(options, 'options');
-
-    assert.string(options.keyId, 'options.keyId');
-    assert.string(options.user, 'options.user');
-    assert.optionalString(options.subuser, 'options.subuser');
-    assert.optionalString(options.algorithm, 'options.algorithm');
-    assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
-
-    var alg = options.algorithm;
-    var algParts = alg ? alg.toLowerCase().split('-') : [];
-
-    var initOpts = new EventEmitter();
-    initOpts.setMaxListeners(Infinity);
-    var fp = sshpk.parseFingerprint(options.keyId);
-    var user = options.user;
-
-    var agentOrErr = createSSHAgent(options.sshAgentOpts);
-    /* It's ok if we got an error, we can look at files instead */
-    if (!(agentOrErr instanceof Error))
-        initOpts.agent = agentOrErr;
-
-    // This pipeline is to perform setup ahead of time; we don't want to
-    // recheck the agent, or reload private keys, etc., if we're in a nested
-    // case, like mfind. We use 'initOpts' as a node hack, where we tack
-    // what we need on it, but use it as an "lock" if this function is
-    // invoked _before_ the setup work is done.
-    vasync.pipeline({
-        funcs: [
-            function checkAgentForKey(opts, cb) {
-                if (!opts.agent) {
-                    cb();
-                    return;
-                }
-
-                var a = opts.agent;
-                sshAgentGetKey(a, fp, function (err, key) {
-                    if (err && err instanceof KeyNotFoundError)
-                        opts.agentErr = err;
-
-                    if (!err) {
-                        opts.key = key;
-                        opts.alg = opts.algorithm = key.type + '-sha1';
-                    }
-
-                    cb();
-                });
-
-            },
-
-            function loadKey(opts, cb) {
-                if (opts.key) {
-                    cb();
-                    return;
-                }
-
-                loadSSHKey(fp, function (err, key) {
-                    if (err && err instanceof KeyNotFoundError && opts.agentErr)
-                        err = KeyNotFoundError.join([opts.agentErr, err]);
-
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-
-                    if (algParts[0] && algParts[0] !== key.type) {
-                        cb(new Error('Requested algorithm ' + alg + ' is ' +
-                            'not supported with a key of type ' + key.type));
-                        return;
-                    }
-
-                    opts.key = key;
-                    cb();
-                });
-            }
-        ],
-        arg: initOpts
-    }, function (err) {
-        if (err) {
-            initOpts.error = err;
-            initOpts.emit('error', err);
-            return;
-        }
-
-        initOpts.ready = true;
-        initOpts.emit('ready');
-    });
-
-    function waitForReady(opts, cb) {
-        cb = once(cb);
-
-        if (initOpts.ready) {
-            cb();
-            return;
-        } else if (initOpts.error) {
-            cb(initOpts.error);
-            return;
-        }
-
-        initOpts.once('ready', cb);
-        initOpts.once('error', cb);
-    }
-
-    function sign(str, callback) {
-        assert.string(str, 'string');
-        assert.func(callback, 'callback');
-
-        callback = once(callback);
-
-        var arg = {};
-        vasync.pipeline({
-            funcs: [
-                waitForReady,
-
-                function agentSign(opts, cb) {
-                    if (!initOpts.agent || !initOpts.key ||
-                        initOpts.key instanceof sshpk.PrivateKey)
-                    {
-                        cb();
-                        return;
-                    }
-
-                    var a = initOpts.agent;
-                    var d = new Buffer(str);
-                    var k = initOpts.key;
-                    sshAgentSign(a, k, d, function (e, s) {
-                        if (e) {
-                            cb(e);
-                            return;
-                        }
-
-                        s.keyId = canonicalKeyId(k);
-                        s.user = options.user;
-                        s.subuser = options.subuser;
-                        opts.res = s;
-                        cb();
-                    });
-                },
-
-                function signWithPrivateKey(opts, cb) {
-                    if (opts.res) {
-                        cb();
-                        return;
-                    }
-
-
-                    var k = initOpts.key;
-                    /*
-                     * We can throw in here if the hash algorithm we were
-                     * told to use in 'algorithm' is invalid. Return it as
-                     * a normal error.
-                     */
-                    try {
-                        var s = k.createSign(algParts[1]);
-                        s.update(str);
-                        var sig = s.sign();
-                    } catch (e) {
-                        cb(e);
-                        return;
-                    }
-
-                    opts.res = {
-                        algorithm: k.type + '-' + sig.hashAlgorithm,
-                        keyId: canonicalKeyId(k),
-                        signature: sig.toString(),
-                        user: user,
-                        subuser: options.subuser
-                    };
-
-                    cb();
-                }
-            ],
-            arg: arg
-        }, function (err) {
-            if (err) {
-                callback(err);
-            } else {
-                sign.algorithm = arg.res.algorithm.toLowerCase();
-                sign.keyId = arg.res.keyId;
-                sign.user = user;
-                sign.subuser = options.subuser;
-                callback(null, arg.res);
-            }
-        });
-    }
-
-    function getKey(cb) {
-        waitForReady({}, function (err) {
-            if (err)
-                return cb(err);
-            return cb(null, initOpts.key);
-        });
-    }
-
-    sign.getKey = getKey;
-    sign.user = options.user;
-    sign.subuser = options.subuser;
-
-    return (sign);
+function signerWrapper(fp, kr, options) {
+	var kpsign;
+
+	function sign(data, cb) {
+		if (kpsign === undefined) {
+			kr.findSigningKeyPair(fp, function (err, kp) {
+				if (err) {
+					cb(err);
+					return;
+				}
+				kpsign = kp.createSign(options);
+				sign.keypair = kp;
+				kpsign(data, cb);
+			});
+			return;
+		}
+		kpsign(data, cb);
+	}
+
+	Object.defineProperty(sign, 'keyId', {
+	    get: function () {
+		if (kpsign === undefined)
+			return (undefined);
+		return (kpsign.keyId);
+	    }
+	});
+	sign.user = options.user;
+	sign.subuser = options.subuser;
+	sign.getKey = function (cb) {
+		if (kpsign === undefined) {
+			kr.findSigningKeyPair(fp, function (err, kp) {
+				kpsign = kp.createSign(options);
+				kpsign.getKey(cb);
+			});
+			return;
+		}
+		kpsign.getKey(cb);
+	};
+	sign.keyring = kr;
+	sign.fp = fp;
+
+	return (sign);
 }
 
-function requestSigner(options) {
-    assert.object(options, 'options');
-
-    assert.optionalFunc(options.sign, 'options.sign');
-    if (options.user === undefined && options.subuser === undefined &&
-      options.sign !== undefined) {
-        options.user = options.sign.user;
-        options.subuser = options.sign.subuser;
-    }
-    if (options.sign === undefined) {
-        assert.string(options.keyId, 'options.keyId');
-    }
-    assert.optionalString(options.user, 'options.user');
-    assert.optionalString(options.subuser, 'options.subuser');
-    assert.optionalString(options.algorithm, 'options.algorithm');
-    assert.optionalObject(options.sshAgentOpts, 'options.sshAgentOpts');
-    assert.optionalBool(options.mantaSubUser, 'options.mantaSubUser');
-
-    var cliSign = options.sign || cliSigner(options);
-
-    function sign(data, cb) {
-        cliSign(data, function (err, inSig) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            var sig = {};
-            sig.signature = inSig.signature;
-            sig.algorithm = inSig.algorithm;
-
-            var user = options.user || inSig.user;
-            if (user === undefined) {
-                cb(new Error('A valid user must be supplied to sign a request' +
-                    ', either via arguments to requestSigner or in the object' +
-                    ' returned by the sign function.'));
-                return;
-            }
-            var subuser = options.subuser || inSig.subuser;
-
-            /* Manta separates user and subuser by a single /. */
-            if (options.mantaSubUser && subuser !== undefined)
-                user += '/' + subuser;
-            /*
-             * CloudAPI separates user and subuser by one path component. It
-             * only checks that there is *something* there, not what it
-             * actually is. Existing SDC clients are using "users", so we'll
-             * use that too.
-             */
-            else if (subuser !== undefined)
-                user += '/users/' + subuser;
-
-            sig.keyId = '/' + user + '/keys/' + inSig.keyId;
-            cb(null, sig);
-        });
-    }
-
-    return (httpSignature.createSigner({sign: sign}));
+function rfc3986(str) {
+	return (encodeURIComponent(str)
+	    .replace(/[!'()]/g, escape)
+	    /* JSSTYLED */
+	    .replace(/\*/g, '%2A'));
 }
 
-
-/**
+/*
  * Creates a presigned URL.
  *
  * Invoke with a signing callback (like other client APIs) and the keys/et al
@@ -842,117 +215,111 @@ function requestSigner(options) {
  * - mantaSubUser: set to true if using sub-users with Manta
  */
 function signUrl(opts, cb) {
-    assert.object(opts, 'options');
-    assert.optionalNumber(opts.expires, 'options.expires');
-    assert.string(opts.host, 'options.host,');
-    assert.string(opts.keyId, 'options.keyId');
-    assert.string(opts.user, 'options.user');
-    assert.string(opts.path, 'options.path');
-    assert.optionalObject(opts.query, 'options.query');
-    assert.optionalArrayOfString(opts.role, 'options.role');
-    assert.optionalArrayOfString(opts['role-tag'], 'options[\'role-tag\']');
-    assert.optionalString(opts.subuser, 'opts.subuser');
-    assert.func(opts.sign, 'options.sign');
-    assert.func(opts.sign.getKey, 'options.sign.getKey');
-    assert.func(cb, 'callback');
-    assert.optionalBool(opts.mantaSubUser, 'options.mantaSubUser');
-    assert.optionalString(opts.algorithm, 'options.algorithm');
-
-    if (opts.mantaSubUser && opts.subuser !== undefined)
-        opts.user = opts.user + '/' + opts.subuser;
-    else if (opts.subuser !== undefined)
-        opts.user = opts.user + '/user/' + opts.subuser;
-
-    if (opts.method !== undefined) {
-        if (Array.isArray(opts.method)) {
-            assert.ok(opts.method.length >= 1);
-            opts.method.forEach(function (m) {
-                assert.string(m, 'options.method');
-            });
-        } else {
-            assert.string(opts.method, 'options.method');
-            opts.method = [opts.method];
-        }
-    } else {
-        opts.method = ['GET', 'HEAD'];
-    }
-    opts.method.sort();
-    var method = opts.method.join(',');
-
-    var q = clone(opts.query || {});
-    q.expires = (opts.expires ||
-                 Math.floor(((Date.now() + (1000 * 300))/1000)));
-
-    if (opts.role)
-        q.role = opts.role.join(',');
-
-    if (opts['role-tag'])
-        q['role-tag'] = opts['role-tag'].join(',');
-
-    if (opts.method.length > 1)
-        q.method = method;
-
-    opts.sign.getKey(function (err, key) {
-        if (err) {
-            cb(err);
-            return;
-        }
-
-        var fp = canonicalKeyId(key);
-        q.keyId = '/' + opts.user + '/keys/' + fp;
-
-        q.algorithm = opts.algorithm || opts.sign.algorithm;
-        if (q.algorithm === undefined)
-            q.algorithm = key.type + '-' + key.defaultHashAlgorithm();
-        q.algorithm = q.algorithm.toUpperCase();
-
-        var line =
-            method + '\n' +
-            opts.host + '\n' +
-            opts.path + '\n';
-        var str = Object.keys(q).sort(function (a, b) {
-            return (a.localeCompare(b));
-        }).map(function (k) {
-            return (rfc3986(k) + '=' + rfc3986(q[k]));
-        }).join('&');
-        line += str;
-
-        if (opts.log)
-            opts.log.debug('signUrl: signing -->\n%s', line);
-
-        opts.sign(line, function onSignature(serr, obj) {
-            if (serr) {
-                cb(serr);
-            } else {
-                if (obj.algorithm.toUpperCase() !== q.algorithm) {
-                    if (opts.algorithm === undefined) {
-                        opts.algorithm = obj.algorithm;
-                        signUrl(opts, cb);
-                    } else {
-                        cb(new Error('The algorithm ' + q.algorithm +
-                            ' could not be used with this key (try ' +
-                            obj.algorithm.toUpperCase() + ')'));
-                    }
-                    return;
-                }
-                var u = opts.path + '?' +
-                    str +
-                    '&signature=' + rfc3986(obj.signature);
-                cb(null, u);
-            }
-        });
-    });
+	mod_assert.object(opts, 'options');
+	mod_assert.optionalNumber(opts.expires, 'options.expires');
+	mod_assert.string(opts.host, 'options.host,');
+	mod_assert.string(opts.keyId, 'options.keyId');
+	mod_assert.string(opts.user, 'options.user');
+	mod_assert.string(opts.path, 'options.path');
+	mod_assert.optionalObject(opts.query, 'options.query');
+	mod_assert.optionalArrayOfString(opts.role, 'options.role');
+	mod_assert.optionalArrayOfString(opts['role-tag'],
+	    'options[\'role-tag\']');
+	mod_assert.optionalString(opts.subuser, 'opts.subuser');
+	mod_assert.func(opts.sign, 'options.sign');
+	mod_assert.func(opts.sign.getKey, 'options.sign.getKey');
+	mod_assert.func(cb, 'callback');
+	mod_assert.optionalBool(opts.mantaSubUser, 'options.mantaSubUser');
+	mod_assert.optionalString(opts.algorithm, 'options.algorithm');
+
+	if (opts.mantaSubUser && opts.subuser !== undefined)
+		opts.user = opts.user + '/' + opts.subuser;
+	else if (opts.subuser !== undefined)
+		opts.user = opts.user + '/user/' + opts.subuser;
+
+	if (opts.method !== undefined) {
+		if (Array.isArray(opts.method)) {
+			mod_assert.ok(opts.method.length >= 1);
+			opts.method.forEach(function (m) {
+				mod_assert.string(m, 'options.method');
+			});
+		} else {
+			mod_assert.string(opts.method, 'options.method');
+			opts.method = [opts.method];
+		}
+	} else {
+		opts.method = ['GET', 'HEAD'];
+	}
+	opts.method.sort();
+	var method = opts.method.join(',');
+
+	var q = mod_clone(opts.query || {});
+	q.expires = (opts.expires ||
+	    Math.floor(((Date.now() + (1000 * 300))/1000)));
+
+	if (opts.role)
+		q.role = opts.role.join(',');
+
+	if (opts['role-tag'])
+		q['role-tag'] = opts['role-tag'].join(',');
+
+	if (opts.method.length > 1)
+		q.method = method;
+
+	opts.sign.getKey(function (err, key) {
+		if (err) {
+			cb(err);
+			return;
+		}
+
+		var fp = key.fingerprint('md5').toString('hex');
+		q.keyId = '/' + opts.user + '/keys/' + fp;
+
+		q.algorithm = opts.algorithm || opts.sign.algorithm;
+		if (q.algorithm === undefined) {
+			q.algorithm = key.type + '-' +
+			    key.defaultHashAlgorithm();
+		}
+		q.algorithm = q.algorithm.toUpperCase();
+
+		var line =
+		    method + '\n' +
+		    opts.host + '\n' +
+		    opts.path + '\n';
+
+		var str = Object.keys(q).sort(function (a, b) {
+			return (a.localeCompare(b));
+		}).map(function (k) {
+			return (rfc3986(k) + '=' + rfc3986(q[k]));
+		}).join('&');
+
+		line += str;
+
+		if (opts.log)
+			opts.log.debug('signUrl: signing -->\n%s', line);
+
+		opts.sign(line, function onSignature(serr, obj) {
+			if (serr) {
+				cb(serr);
+			} else {
+				if (obj.algorithm.toUpperCase() !==
+				    q.algorithm) {
+					if (opts.algorithm === undefined) {
+						opts.algorithm = obj.algorithm;
+						signUrl(opts, cb);
+					} else {
+						cb(new Error('The algorithm ' +
+						    q.algorithm + ' could not' +
+						    ' be used with this key ' +
+						    '(try ' + obj.algorithm.
+						    toUpperCase() + ')'));
+					}
+					return;
+				}
+				var u = opts.path + '?' + str + '&signature=' +
+				    rfc3986(obj.signature);
+				cb(null, u);
+			}
+		});
+	});
 }
-
-
-// ---- Exports
-
-module.exports = {
-    cliSigner: cliSigner,
-    privateKeySigner: privateKeySigner,
-    sshAgentSigner: sshAgentSigner,
-    loadSSHKey: loadSSHKey,
-    signUrl: signUrl,
-    requestSigner: requestSigner,
-    KeyNotFoundError: KeyNotFoundError
-};
diff --git a/lib/keypair.js b/lib/keypair.js
new file mode 100644
index 0000000..453cd0a
--- /dev/null
+++ b/lib/keypair.js
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = {
+	KeyPair: SDCKeyPair,
+	LockedKeyPair: SDCLockedKeyPair
+};
+
+const mod_assert = require('assert-plus');
+const mod_sshpk = require('sshpk');
+const mod_util = require('util');
+const mod_httpsig = require('http-signature');
+
+const KeyRing = require('./keyring');
+
+function SDCKeyPair(kr, opts) {
+	mod_assert.object(kr, 'keyring');
+	mod_assert.ok(kr instanceof KeyRing,
+	    'keyring instanceof KeyRing');
+	this.skp_kr = kr;
+
+	mod_assert.object(opts, 'options');
+	mod_assert.string(opts.plugin, 'options.plugin');
+	mod_assert.optionalString(opts.source, 'options.source');
+
+	this.plugin = opts.plugin;
+	this.source = opts.source;
+	this.comment = '';
+
+	if (opts.public !== undefined) {
+		mod_assert.ok(mod_sshpk.Key.isKey(opts.public));
+		this.comment = opts.public.comment;
+	}
+	this.skp_public = opts.public;
+	if (opts.private !== undefined)
+		mod_assert.ok(mod_sshpk.PrivateKey.isPrivateKey(opts.private));
+	this.skp_private = opts.private;
+}
+
+SDCKeyPair.fromPrivateKey = function (key) {
+	mod_assert.object(key, 'key');
+	mod_assert.ok(mod_sshpk.PrivateKey.isPrivateKey(key),
+	    'key is a PrivateKey');
+
+	var kr = new KeyRing({ plugins: [] });
+	var kp = new SDCKeyPair(kr, {
+		plugin: 'none',
+		private: key,
+		public: key.toPublic()
+	});
+	return (kp);
+};
+
+SDCKeyPair.prototype.canSign = function () {
+	return (this.skp_private !== undefined);
+};
+
+SDCKeyPair.prototype.createRequestSigner = function (opts) {
+	mod_assert.string(opts.user, 'options.user');
+	mod_assert.optionalString(opts.subuser, 'options.subuser');
+	mod_assert.optionalBool(opts.mantaSubUser, 'options.mantaSubUser');
+
+	var sign = this.createSign(opts);
+
+	var user = opts.user;
+	if (opts.subuser) {
+		if (opts.mantaSubUser)
+			user += '/' + opts.subuser;
+		else
+			user += '/users/' + opts.subuser;
+	}
+	var keyId = '/' + user + '/keys/' + this.getKeyId();
+
+	function rsign(data, cb) {
+		sign(data, function (err, res) {
+			if (res)
+				res.keyId = keyId;
+			cb(err, res);
+		});
+	}
+	return (mod_httpsig.createSigner({ sign: rsign }));
+};
+
+SDCKeyPair.prototype.createSign = function (opts) {
+	mod_assert.object(opts, 'options');
+	mod_assert.optionalString(opts.algorithm, 'options.algorithm');
+	mod_assert.optionalString(opts.keyId, 'options.keyId');
+	mod_assert.string(opts.user, 'options.user');
+	mod_assert.optionalString(opts.subuser, 'options.subuser');
+	mod_assert.optionalBool(opts.mantaSubUser, 'options.mantaSubUser');
+
+	if (this.skp_private === undefined) {
+		throw (new Error('Private key for this key pair is ' +
+		    'unavailable'));
+	}
+	var key = this.skp_private;
+	var keyId = this.getKeyId();
+	var alg = opts.algorithm;
+	var algParts = alg ? alg.toLowerCase().split('-') : [];
+
+	if (algParts[0] && algParts[0] !== key.type) {
+		throw (new Error('Requested algorithm ' + alg + ' is ' +
+		    'not supported with a key of type ' + key.type));
+	}
+
+	var self = this;
+	var cache = this.skp_kr.getSignatureCache();
+	function sign(data, cb) {
+		mod_assert.string(data, 'data');
+		mod_assert.func(cb, 'callback');
+
+		var ck = { key: key, data: data };
+		if (cache.get(ck, cb))
+			return;
+		cache.registerPending(ck);
+
+		/*
+		 * We can throw in here if the hash algorithm we were told to
+		 * use in 'algorithm' is invalid. Return it as a normal error.
+		 */
+		var signer, sig;
+		try {
+			signer = self.skp_private.createSign(algParts[1]);
+			signer.update(data);
+			sig = signer.sign();
+		} catch (e) {
+			cache.put(ck, e);
+			cb(e);
+			return;
+		}
+
+		var res = {
+		    algorithm: key.type + '-' + sig.hashAlgorithm,
+		    keyId: keyId,
+		    signature: sig.toString(),
+		    user: opts.user,
+		    subuser: opts.subuser
+		};
+		sign.algorithm = res.algorithm;
+
+		cache.put(ck, null, res);
+
+		cb(null, res);
+	}
+
+	sign.keyId = keyId;
+	sign.user = opts.user;
+	sign.subuser = opts.subuser;
+	sign.getKey = function (cb) {
+		cb(null, self.skp_private);
+	};
+	return (sign);
+};
+
+SDCKeyPair.prototype.getKeyId = function () {
+	return (this.skp_public.fingerprint('md5').toString('hex'));
+};
+
+SDCKeyPair.prototype.getPublicKey = function () {
+	return (this.skp_public);
+};
+
+SDCKeyPair.prototype.getPrivateKey = function () {
+	return (this.skp_private);
+};
+
+SDCKeyPair.prototype.isLocked = function () {
+	return (false);
+};
+
+SDCKeyPair.prototype.unlock = function (passphrase) {
+	throw (new Error('Keypair is not locked'));
+};
+
+
+function SDCLockedKeyPair(kr, opts) {
+	SDCKeyPair.call(this, kr, opts);
+
+	mod_assert.buffer(opts.privateData, 'options.privateData');
+	this.lkp_privateData = opts.privateData;
+	mod_assert.string(opts.privateFormat, 'options.privateFormat');
+	this.lkp_privateFormat = opts.privateFormat;
+	this.lkp_locked = true;
+}
+mod_util.inherits(SDCLockedKeyPair, SDCKeyPair);
+
+SDCLockedKeyPair.prototype.canSign = function () {
+	return (true);
+};
+
+SDCLockedKeyPair.prototype.getPrivateKey = function () {
+	if (this.lkp_locked) {
+		throw (new Error('SSH private key ' +
+		    this.getPublicKey().comment +
+		    ' is locked (encrypted/password-protected). It must be ' +
+		    'unlocked before use.'));
+	}
+	return (this.skp_private);
+};
+
+SDCLockedKeyPair.prototype.isLocked = function () {
+	return (this.lkp_locked);
+};
+
+SDCLockedKeyPair.prototype.unlock = function (passphrase) {
+	mod_assert.ok(this.lkp_locked);
+	this.skp_private = mod_sshpk.parsePrivateKey(this.lkp_privateData,
+	    this.lkp_privateFormat, { passphrase: passphrase });
+	mod_assert.ok(this.skp_public.fingerprint('sha512').matches(
+	    this.skp_private));
+	this.lkp_locked = false;
+};
diff --git a/lib/keyring.js b/lib/keyring.js
new file mode 100644
index 0000000..b06bb29
--- /dev/null
+++ b/lib/keyring.js
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = SDCKeyRing;
+
+const mod_assert = require('assert-plus');
+const mod_vasync = require('vasync');
+const mod_events = require('events');
+const EventEmitter = mod_events.EventEmitter;
+const mod_errors = require('./errors');
+const mod_util = require('util');
+
+/*
+ * Keep this in rough order of performance, to make the logic in
+ * findSigningKey() produce good results.
+ */
+const PLUGINS = ['homedir', 'agent'];
+
+function SDCKeyRing(opts) {
+	var self = this;
+	var pluginReq = true;
+	mod_assert.optionalObject(opts, 'options');
+	if (opts === undefined)
+		opts = {};
+	mod_assert.optionalArrayOfString(opts.plugins, 'options.plugins');
+	if (opts.plugins === undefined) {
+		opts.plugins = PLUGINS;
+		pluginReq = false;
+	}
+
+	this.skr_pluginNames = [];
+	this.skr_plugins = [];
+	opts.plugins.forEach(function (name) {
+		mod_assert.ok(PLUGINS.indexOf(name) !== -1);
+		var Plugin = require('./kr-' + name);
+		try {
+			var inst = new Plugin(self, opts);
+			self.skr_plugins.push(inst);
+			self.skr_pluginNames.push(name);
+		} catch (e) {
+			if (pluginReq)
+				throw (e);
+		}
+	});
+
+	this.skr_cache = new SignatureCache();
+}
+
+SDCKeyRing.prototype.getSignatureCache = function () {
+	return (this.skr_cache);
+};
+
+SDCKeyRing.prototype.list = function (cb) {
+	var keys = {};
+	mod_vasync.forEachParallel({
+		func: runPlugin,
+		inputs: this.skr_plugins
+	}, function (err) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		cb(null, keys);
+	});
+	function runPlugin(plugin, pcb) {
+		plugin.listKeys(function (err, pairs) {
+			if (err) {
+				pcb(err);
+				return;
+			}
+			pairs.forEach(function (pair) {
+				var keyId = pair.getKeyId();
+				if (keys[keyId] === undefined)
+					keys[keyId] = [];
+				keys[keyId].push(pair);
+			});
+			pcb();
+		});
+	}
+};
+
+SDCKeyRing.prototype.find = function (fp, cb) {
+	var keys = [];
+	mod_vasync.forEachParallel({
+		func: runPlugin,
+		inputs: this.skr_plugins
+	}, function (err) {
+		if (err && Array.isArray(err.ase_errors)) {
+			var knfs = err.ase_errors.filter(function (e) {
+				return (e.name === 'KeyNotFoundError');
+			});
+			if (knfs.length === err.ase_errors.length) {
+				if (keys.length > 0) {
+					cb(null, keys);
+					return;
+				}
+				err = mod_errors.KeyNotFoundError.join(knfs);
+			}
+			cb(err);
+			return;
+		} else if (err) {
+			cb(err);
+			return;
+		}
+		cb(null, keys);
+	});
+	function runPlugin(plugin, pcb) {
+		plugin.findKey(fp, function (err, pairs) {
+			if (err) {
+				pcb(err);
+				return;
+			}
+			pairs.forEach(function (pair) {
+				keys.push(pair);
+			});
+			pcb();
+		});
+	}
+};
+
+SDCKeyRing.prototype.findSigningKeyPair = function (fp, cb) {
+	var self = this;
+	this.find(fp, function (err, kps) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		kps = kps.filter(function (kp) {
+			return (kp.canSign());
+		}).sort(function (a, b) {
+			/* Always prefer already-unlocked keys. */
+			if (a.isLocked() && !b.isLocked())
+				return (1);
+			if (!a.isLocked() && b.isLocked())
+				return (-1);
+			/* Then preference in PLUGINS order. */
+			var idxa = PLUGINS.indexOf(a.plugin);
+			var idxb = PLUGINS.indexOf(b.plugin);
+			if (idxa < idxb)
+				return (-1);
+			if (idxa > idxb)
+				return (1);
+			return (0);
+		});
+		if (kps.length < 1) {
+			cb(new mod_errors.KeyNotFoundError(fp,
+			    self.skr_pluginNames));
+			return;
+		}
+		cb(null, kps[0]);
+	});
+};
+
+SDCKeyRing.getPlugins = function () {
+	return (PLUGINS.slice());
+};
+
+function SignatureCache(opts) {
+	mod_assert.optionalObject(opts, 'options');
+	opts = opts || {};
+	mod_assert.optionalNumber(opts.expiry, 'options.expiry');
+
+	this.expiry = opts.expiry || 10000;
+	this.pending = new EventEmitter();
+	this.pending.table = {};
+	this.table = {};
+	this.list = [];
+}
+
+function createCacheKey(opts) {
+	mod_assert.object(opts, 'options');
+	mod_assert.object(opts.key, 'options.key');
+	mod_assert.string(opts.data, 'options.data');
+	return (opts.key.fingerprint('sha256').toString() + '|' + opts.data);
+}
+
+SignatureCache.prototype.get = function get(opts, cb) {
+	mod_assert.func(cb, 'callback');
+
+	var k = createCacheKey(opts);
+
+	var found = false;
+	var self = this;
+
+	function cachedResponse() {
+		var val = self.table[k].value;
+		cb(val.err, val.value);
+	}
+
+	if (this.table[k]) {
+		found = true;
+		process.nextTick(cachedResponse);
+	} else if (this.pending.table[k]) {
+		found = true;
+		this.pending.once(k, cachedResponse);
+	}
+
+	return (found);
+};
+
+SignatureCache.prototype.registerPending = function (opts) {
+	var k = createCacheKey(opts);
+	this.pending.table[k] = true;
+};
+
+SignatureCache.prototype.put = function put(opts, err, v) {
+	mod_assert.ok(v, 'value');
+
+	var k = createCacheKey(opts);
+
+	this.table[k] = {
+	    time: new Date().getTime(),
+	    value: { err: err, value: v }
+	};
+
+	if (this.pending.table[k])
+		delete this.pending.table[k];
+
+	this.pending.emit(k, v);
+	this.purge();
+};
+
+
+SignatureCache.prototype.purge = function purge() {
+	var list = [];
+	var now = new Date().getTime();
+	var self = this;
+
+	Object.keys(this.table).forEach(function (k) {
+		if (self.table[k].time + self.expiry < now)
+			list.push(k);
+	});
+
+	list.forEach(function (k) {
+		if (self.table[k])
+			delete self.table[k];
+	});
+};
+
+
+SignatureCache.prototype.toString = function toString() {
+	var fmt = '[object SignatureCache<pending=%j, table=%j>]';
+	return (mod_util.format(fmt, this.pending.table, this.table));
+};
diff --git a/lib/kr-agent.js b/lib/kr-agent.js
new file mode 100644
index 0000000..2daede7
--- /dev/null
+++ b/lib/kr-agent.js
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = KeyRingAgentPlugin;
+
+const mod_util = require('util');
+const mod_assert = require('assert-plus');
+const mod_sshpk = require('sshpk');
+const mod_agent = require('sshpk-agent');
+const mod_vasync = require('vasync');
+const mod_errors = require('./errors');
+const KeyRingPlugin = require('./krplugin');
+
+const mod_keypair = require('./keypair');
+const KeyPair = mod_keypair.KeyPair;
+const LockedKeyPair = mod_keypair.LockedKeyPair;
+
+function KeyRingAgentPlugin(kr, opts) {
+	KeyRingPlugin.call(this, kr, opts);
+	mod_assert.optionalObject(opts.sshAgentOpts);
+
+	this.kra_error = undefined;
+	this.kra_agent = new mod_agent.Client(opts.sshAgentOpts);
+}
+mod_util.inherits(KeyRingAgentPlugin, KeyRingPlugin);
+
+KeyRingAgentPlugin.prototype.listKeys = function (cb) {
+	var self = this;
+	if (!this.kra_agent) {
+		cb(null, []);
+		return;
+	}
+	this.kra_agent.listKeys(function (err, keys) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		var kps = keys.map(function (k) {
+			return (new AgentKeyPair(self.krp_kr, self.kra_agent, {
+			    plugin: 'agent', public: k }));
+		});
+		cb(null, kps);
+	});
+};
+
+KeyRingAgentPlugin.prototype.findKey = function (fp, cb) {
+	mod_assert.ok(mod_sshpk.Fingerprint.isFingerprint(fp));
+	var self = this;
+	if (!this.kra_agent) {
+		cb(new mod_errors.KeyNotFoundError(fp, ['SSH agent']));
+		return;
+	}
+	this.kra_agent.listKeys(function (err, keys) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		for (var i = 0; i < keys.length; ++i) {
+			if (fp.matches(keys[i])) {
+				var kp = new AgentKeyPair(self.krp_kr,
+				    self.kra_agent, { plugin: 'agent',
+				    public: keys[i] });
+				cb(null, [kp]);
+				return;
+			}
+		}
+		cb(new mod_errors.KeyNotFoundError(fp, ['SSH agent']));
+	});
+};
+
+function AgentKeyPair(kr, agent, opts) {
+	KeyPair.call(this, kr, opts);
+	this.akp_agent = agent;
+}
+mod_util.inherits(AgentKeyPair, KeyPair);
+
+AgentKeyPair.prototype.getPrivateKey = function () {
+	throw (new Error('Agent private keys cannot be directly retrieved'));
+};
+
+AgentKeyPair.prototype.canSign = function () {
+	return (true);
+};
+
+AgentKeyPair.prototype.createSign = function (opts) {
+	mod_assert.object(opts, 'options');
+	mod_assert.optionalString(opts.algorithm, 'options.algorithm');
+	mod_assert.optionalString(opts.keyId, 'options.keyId');
+	mod_assert.string(opts.user, 'options.user');
+	mod_assert.optionalString(opts.subuser, 'options.subuser');
+	mod_assert.optionalBool(opts.mantaSubUser, 'options.mantaSubUser');
+
+	var pub = this.getPublicKey();
+	var keyId = this.getKeyId();
+	var alg = opts.algorithm;
+	var algParts = alg ? alg.toLowerCase().split('-') : [];
+
+	if (algParts[0] && algParts[0] !== pub.type) {
+		throw (new Error('Requested algorithm ' + alg + ' is ' +
+		    'not supported with a key of type ' + pub.type));
+	}
+
+	var self = this;
+	var cache = this.skp_kr.getSignatureCache();
+
+	function sign(data, cb) {
+		mod_assert.string(data, 'data');
+		mod_assert.func(cb, 'callback');
+
+		var ck = { key: pub, data: data };
+		if (cache.get(ck, cb))
+			return;
+		cache.registerPending(ck);
+
+		self.akp_agent.sign(pub, data, function (err, sig) {
+			if (err) {
+				cache.put(ck, err);
+				cb(err);
+				return;
+			}
+
+			var res = {
+			    algorithm: pub.type + '-' + sig.hashAlgorithm,
+			    keyId: keyId,
+			    signature: sig.toString(),
+			    user: opts.user,
+			    subuser: opts.subuser
+			};
+			sign.algorithm = res.algorithm;
+
+			cache.put(ck, null, res);
+			cb(null, res);
+		});
+	}
+
+	sign.keyId = keyId;
+	sign.user = opts.user;
+	sign.subuser = opts.subuser;
+	sign.getKey = function (cb) {
+		cb(null, self.skp_public);
+	};
+	return (sign);
+};
diff --git a/lib/kr-homedir.js b/lib/kr-homedir.js
new file mode 100644
index 0000000..23abee9
--- /dev/null
+++ b/lib/kr-homedir.js
@@ -0,0 +1,328 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = KeyRingHomeDirPlugin;
+
+const mod_util = require('util');
+const mod_assert = require('assert-plus');
+const mod_sshpk = require('sshpk');
+const mod_fs = require('fs');
+const mod_path = require('path');
+const mod_errors = require('./errors');
+const KeyRingPlugin = require('./krplugin');
+const mod_vasync = require('vasync');
+
+const mod_keypair = require('./keypair');
+const KeyPair = mod_keypair.KeyPair;
+const LockedKeyPair = mod_keypair.LockedKeyPair;
+
+/*
+ * These are max file sizes for pub/private keys, to avoid buffering in huge
+ * files that clearly are not keys.
+ */
+const MAX_PUBKEY_SIZE = 65536;
+const MAX_PRIVKEY_SIZE = 131072;
+
+function KeyRingHomeDirPlugin(kr, opts) {
+	KeyRingPlugin.call(this, kr, opts);
+	var path;
+
+	if (typeof (opts.keyDir) === 'string') {
+		this.hdp_path = opts.keyDir;
+
+	} else {
+		if (process.platform === 'win32') {
+			path = process.env.USERPROFILE;
+		} else {
+			path = process.env.HOME;
+		}
+
+		if (!path) {
+			throw (new Error('cannot find HOME dir ' +
+			    '(HOME/USERPROFILE is not set)'));
+		}
+
+		path = mod_path.join(path, '.ssh');
+
+		this.hdp_path = path;
+	}
+}
+mod_util.inherits(KeyRingHomeDirPlugin, KeyRingPlugin);
+
+KeyRingHomeDirPlugin.prototype.listKeys = function (cb) {
+	var keys = [];
+	this._iter(function (kp, next, finish) {
+		keys.push(kp);
+		next();
+	}, function (err) {
+		if (err && keys.length < 1) {
+			cb(err);
+		}
+		cb(null, keys);
+	});
+};
+
+KeyRingHomeDirPlugin.prototype.findKey = function (fp, cb) {
+	mod_assert.ok(mod_sshpk.Fingerprint.isFingerprint(fp));
+	var keys = [];
+	this._iter(function (kp, next, finish) {
+		if (fp.matches(kp.getPublicKey())) {
+			keys.push(kp);
+			finish();
+		} else {
+			next();
+		}
+	}, function (err) {
+		if (err && keys.length < 1) {
+			cb(err);
+			return;
+		}
+		if (keys.length < 1) {
+			cb(new mod_errors.KeyNotFoundError(fp, ['$HOME/.ssh']));
+			return;
+		}
+		cb(null, keys);
+	});
+};
+
+KeyRingHomeDirPlugin.prototype._iter = function (each, cb) {
+	mod_assert.func(each);
+	mod_assert.func(cb);
+
+	var self = this;
+	var skip = false;
+	var path = this.hdp_path;
+
+	mod_fs.readdir(path, function (err, files) {
+		if (err) {
+			cb(err);
+			return;
+		}
+
+		var allKeyPaths = [];
+		(files || []).forEach(function (f) {
+			/*
+			 * If we have a .pub file and a matching private key,
+			 * consider them as a pair (see below).
+			 */
+			var m = f.match(/(.+)\.pub$/);
+			if (m && files.indexOf(m[1]) !== -1) {
+				allKeyPaths.push({
+					public: mod_path.join(path, f),
+					private: mod_path.join(path, m[1])
+				});
+				return;
+			}
+			if (m) {
+				allKeyPaths.push({
+					public: mod_path.join(path, f)
+				});
+				return;
+			}
+			/*
+			 * If the name contains id_ (but doesn't end with .pub)
+			 * and there is no matching public key, use it as a
+			 * solo private key.
+			 */
+			var m2 = f.match(/(^|[^a-zA-Z])id_/);
+			if (!m && m2 && files.indexOf(f + '.pub') === -1) {
+				allKeyPaths.push({
+					private: mod_path.join(path, f)
+				});
+				return;
+			}
+		});
+
+		/*
+		 * When we have both a public and private key file, read in the
+		 * .pub file first to do the fingerprint match. If that
+		 * succeeds, read in and validate that the private key file
+		 * matches it.
+		 *
+		 * This also ensures we fail early and give a sensible error if,
+		 * e.g. the specified key is password-protected.
+		 */
+		function readPublicKey(keyPaths, kcb) {
+			mod_fs.readFile(keyPaths.public,
+			    function (kerr, blob) {
+				if (kerr) {
+					kcb(kerr);
+					return;
+				}
+
+				try {
+					var key = mod_sshpk.parseKey(blob,
+					    'ssh', keyPaths.public);
+				} catch (e) {
+					kcb(e);
+					return;
+				}
+
+				if (keyPaths.private === undefined) {
+					var pubSrc = keyPaths.public.replace(
+					    self.hdp_path + '/', '');
+					var kp = new KeyPair(self.krp_kr, {
+						plugin: 'homedir',
+						source: pubSrc,
+						public: key
+					    });
+					each(kp, kcb, function () {
+						skip = true;
+						kcb();
+					});
+					return;
+				}
+
+				readPrivateKey(keyPaths, function (pkerr, pk) {
+					var src = keyPaths.private.replace(
+					    self.hdp_path + '/', '');
+					if (pkerr && pkerr.name ===
+					    'KeyEncryptedError') {
+						var lkp = new LockedKeyPair(
+						    self.krp_kr, {
+							plugin: 'homedir',
+							source: src,
+							public: key,
+							privateData: pk,
+							privateFormat: 'pem'
+						    });
+						each(lkp, kcb, function () {
+							skip = true;
+							kcb();
+						});
+						return;
+					}
+					if (pkerr) {
+						kcb(pkerr);
+						return;
+					}
+
+					var kkp = new KeyPair(self.krp_kr, {
+						plugin: 'homedir',
+						source: src,
+						public: key,
+						private: pk
+					    });
+					each(kkp, kcb, function () {
+						skip = true;
+						kcb();
+					});
+				}, true);
+			});
+		}
+
+		function readPrivateKey(keyPaths, kcb, inPublic) {
+			mod_fs.readFile(keyPaths.private,
+			    function (kerr, blob) {
+				if (kerr) {
+					kcb(kerr);
+					return;
+				}
+
+				try {
+					var key = mod_sshpk.parsePrivateKey(
+					    blob, 'pem', keyPaths.private);
+				} catch (e) {
+					kcb(e, blob);
+					return;
+				}
+
+				if (!inPublic) {
+					var pub = key.toPublic();
+					var src = keyPaths.private.replace(
+					    self.hdp_path + '/', '');
+					pub.comment = src;
+					var kp = new KeyPair(self.krp_kr, {
+						plugin: 'homedir',
+						source: src,
+						public: pub,
+						private: key
+					    });
+					each(kp, kcb, function () {
+						skip = true;
+						kcb(null, key);
+					});
+				} else {
+					kcb(null, key);
+				}
+			});
+		}
+
+		function processKey(keyPaths, kcb) {
+			if (skip) {
+				kcb();
+				return;
+			}
+			/*
+			 * Stat the file first to ensure we don't read from any
+			 * sockets or crazy huge files that ended up in
+			 * $HOME/.ssh (it happens).
+			 *
+			 * It's possible that the file could change between our
+			 * stat here and when we open it in readPublicKey/
+			 * readPrivateKey. Doing something about it is more
+			 * effort than it's worth.
+			 */
+			if (keyPaths.public) {
+				mod_fs.stat(keyPaths.public,
+				    function (serr, stats) {
+					if (serr) {
+						kcb(serr);
+						return;
+					}
+					if (stats.isFile() &&
+					    stats.size < MAX_PUBKEY_SIZE) {
+						readPublicKey(keyPaths, kcb);
+					} else {
+						kcb(new Error(keyPaths.public +
+						    ' is not a regular file, ' +
+						    'or size is too big to be' +
+						    ' an SSH public key.'));
+					}
+				});
+			} else {
+				mod_fs.stat(keyPaths.private,
+				    function (serr, stats) {
+					if (serr) {
+						kcb(serr);
+						return;
+					}
+					if (stats.isFile() &&
+					    stats.size < MAX_PRIVKEY_SIZE) {
+						readPrivateKey(keyPaths, kcb);
+					} else {
+						kcb(new Error(keyPaths.private +
+						    ' is not a regular file, ' +
+						    'or size is too big to be' +
+						    ' an SSH private key.'));
+					}
+				});
+			}
+		}
+
+		var opts = {
+			inputs: allKeyPaths,
+			func: processKey
+		};
+		mod_vasync.forEachParallel(opts, cb);
+	});
+};
diff --git a/lib/krplugin.js b/lib/krplugin.js
new file mode 100644
index 0000000..73b4e9b
--- /dev/null
+++ b/lib/krplugin.js
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016 Joyent, Inc., All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE
+ */
+
+module.exports = SDCKeyRingPlugin;
+
+const mod_assert = require('assert-plus');
+const mod_sshpk = require('sshpk');
+const KeyRing = require('./keyring');
+
+function SDCKeyRingPlugin(kr, opts) {
+	mod_assert.object(kr, 'keyring');
+	mod_assert.ok(kr instanceof KeyRing);
+	this.krp_kr = kr;
+
+	mod_assert.object(opts, 'options');
+}
+
+SDCKeyRingPlugin.prototype.listKeys = function (cb) {
+	cb(new Error('This plugin does not implement listKeys'));
+};
+
+SDCKeyRingPlugin.prototype.findKey = function (fp, cb) {
+	mod_assert.ok(mod_sshpk.Fingerprint.isFingerprint(fp));
+	cb(new Error('This plugin does not implement findKey'));
+};
diff --git a/package.json b/package.json
index f391099..838d722 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "smartdc-auth",
     "description": "SmartDataCenter Authentication Library",
-    "version": "2.4.1",
+    "version": "2.5.0",
     "author": "Joyent (joyent.com)",
     "contributors": [
         "Mark Cavage",
@@ -24,17 +24,17 @@
         "lib": "./lib"
     },
     "engines": {
-        "node": ">=0.8"
+        "node": ">=0.10"
     },
     "dependencies": {
-        "assert-plus": "0.1.2",
+        "assert-plus": "^1.0.0",
         "bunyan": "1.5.1",
         "clone": "0.1.5",
         "dashdash": "1.10.1",
-        "http-signature": ">=1.0.2 <2.0.0",
+        "http-signature": "^1.0.2",
         "once": "1.3.0",
-        "sshpk-agent": "1.2.1",
-        "sshpk": "1.7.4",
+        "sshpk-agent": "^1.3.0",
+        "sshpk": "^1.8.3",
         "vasync": "1.4.3"
     },
     "devDependencies": {
diff --git a/test/fs-keys.test.js b/test/fs-keys.test.js
index 7862707..5b255c2 100644
--- a/test/fs-keys.test.js
+++ b/test/fs-keys.test.js
@@ -55,10 +55,7 @@ test('loadSSHKey full pair', function (t) {
         t.error(err);
         t.equal(key.type, 'rsa');
         t.equal(key.size, 1024);
-        t.equal(keyFiles.public, path.join(tmpDir, '.ssh', 'id_rsa.pub'),
-            'keyFiles.public');
-        t.equal(keyFiles.private, path.join(tmpDir, '.ssh', 'id_rsa'),
-            'keyFiles.private');
+        t.equal(key.comment, path.join(tmpDir, '.ssh', 'id_rsa'));
         t.end();
     });
 });
@@ -72,6 +69,20 @@ test('loadSSHKey public only', function (t) {
     });
 });
 
+test('keyring cannot sign', function (t) {
+    var kr = new auth.KeyRing({ plugins: ['homedir'] });
+    var fp = sshpk.parseFingerprint(ID_RSA_FP);
+    kr.findSigningKeyPair(fp, function (err, kp) {
+        t.ok(err);
+        kr.find(fp, function (err2, kps) {
+            t.error(err2);
+            t.strictEqual(kps.length, 1);
+            t.ok(!kps[0].canSign());
+            t.end();
+        });
+    });
+});
+
 test('loadSSHKey private only rsa', function (t) {
     fs.unlinkSync(path.join(tmpDir, '.ssh', 'id_rsa.pub'));
     copyAsset('id_rsa', path.join('.ssh', 'id_rsa'), function () {
@@ -91,6 +102,17 @@ test('loadSSHKey private only dsa', function (t) {
     });
 });
 
+test('keyring basic', function (t) {
+    var kr = new auth.KeyRing({ plugins: ['homedir'] });
+    var fp = sshpk.parseFingerprint(ID_DSA_FP);
+    kr.findSigningKeyPair(fp, function (err, kp) {
+        t.error(err);
+        t.ok(kp.canSign());
+        t.ok(!kp.isLocked());
+        t.end();
+    });
+});
+
 test('setup encrypted', function (t) {
     vasync.parallel({
         funcs: [
@@ -103,11 +125,23 @@ test('setup encrypted', function (t) {
     });
 });
 
+test('keyring unlock', function (t) {
+    var kr = new auth.KeyRing({ plugins: ['homedir'] });
+    var fp = sshpk.parseFingerprint(ID_RSA2_FP);
+    kr.findSigningKeyPair(fp, function (err, kp) {
+        t.error(err);
+        t.ok(kp.isLocked());
+        kp.unlock('asdfasdf');
+        t.ok(!kp.isLocked());
+        t.ok(fp.matches(kp.getPrivateKey()));
+        t.end();
+    });
+});
+
 test('loadSSHKey enc-private full pair', function (t) {
     auth.loadSSHKey(ID_RSA2_FP, function (err) {
         t.ok(err);
-        t.ok(err instanceof sshpk.KeyParseError);
-        t.notStrictEqual(err.message.indexOf('encrypted'), -1);
+        t.notStrictEqual(err.toString().indexOf('encrypted'), -1);
         t.end();
     });
 });
@@ -116,8 +150,6 @@ test('loadSSHKey enc-private private only', function (t) {
     fs.unlinkSync(path.join(tmpDir, '.ssh', 'id_rsa2.pub'));
     auth.loadSSHKey(ID_RSA2_FP, function (err) {
         t.ok(err);
-        t.ok(err instanceof auth.KeyNotFoundError);
-        t.notStrictEqual(err.message.indexOf('encrypted'), -1);
         t.end();
     });
 });
diff --git a/test/signers.test.js b/test/signers.test.js
index 51c7517..c44a943 100644
--- a/test/signers.test.js
+++ b/test/signers.test.js
@@ -81,6 +81,46 @@ test('basic cliSigner rsa', function (t) {
     });
 });
 
+test('KeyRing signer rsa', function (t) {
+    var kr = new auth.KeyRing();
+    var fp = sshpk.parseFingerprint(ID_RSA_FP);
+    kr.findSigningKeyPair(fp, function (err, kp) {
+        t.error(err);
+        var rs = kp.createRequestSigner({
+            user: 'foo'
+        });
+        rs.writeHeader('date', 'foo');
+        rs.sign(function (err2, authz) {
+            t.error(err2);
+            var req = {
+                headers: {
+                    authorization: authz,
+                    date: 'foo'
+                }
+            };
+            var sig = httpSignature.parseRequest(req, {});
+            t.strictEqual(sig.scheme, 'Signature');
+            t.strictEqual(sig.params.keyId, '/foo/keys/' + ID_RSA_MD5);
+            t.strictEqual(sig.params.algorithm, 'rsa-sha256');
+            t.ok(httpSignature.verifySignature(sig, ID_RSA));
+            t.end();
+        });
+    })
+});
+
+test('KeyRing list keys', function (t) {
+    var kr = new auth.KeyRing();
+    kr.list(function (err, kps) {
+        t.error(err);
+        t.strictEqual(Object.keys(kps).length, 2);
+        Object.keys(kps).forEach(function (kId) {
+            t.strictEqual(kps[kId].length, 1);
+            t.ok(kps[kId][0].canSign());
+        });
+        t.end();
+    });
+});
+
 test('requestSigner rsa', function (t) {
     var signer = auth.requestSigner({
         keyId: ID_RSA_FP,
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 0b8ae95..0388cde 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -120,10 +120,25 @@
 +define require
 +define setInterval
 +define setTimeout
++define setImmediate
++define clearImmediate
 +define Buffer
 +define JSON
 +define Math
 
+# ES6 Typed Arrays
++define ArrayBuffer
++define DataView
++define Int8Array
++define Uint8Array
++define Uint8ClampedArray
++define Int16Array
++define Uint16Array
++define Int32Array
++define Uint32Array
++define Float32Array
++define Float64Array
+
 ### JavaScript Version
 # To change the default JavaScript version:
 #+default-type text/javascript;version=1.5
diff --git a/tools/jsstyle.conf b/tools/jsstyle.conf
new file mode 100644
index 0000000..5e7999e
--- /dev/null
+++ b/tools/jsstyle.conf
@@ -0,0 +1,12 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+indent=tab
+blank-after-start-comment=0
