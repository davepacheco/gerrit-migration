From 626457219be78a3595ae6e2ba9f0d9bf0aa6095b Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Tue, 13 Nov 2018 03:32:51 +0000
Subject: [PATCH] OS-7336 lx_acl_getxattr leaks the ACL Reviewed by: Patrick
 Mooney <patrick.mooney@joyent.com> Reviewed by: Robert Mustacchi
 <rm@joyent.com> Approved by: Robert Mustacchi <rm@joyent.com>

---
 manifest                                      |   1 +
 usr/src/boot/lib/libstand/ip.c                |   1 -
 usr/src/boot/lib/libstand/net.c               |   1 -
 usr/src/boot/lib/libstand/udp.c               |   5 +-
 usr/src/boot/sys/boot/common/disk.c           |   4 +-
 usr/src/boot/sys/boot/common/part.c           |   3 +-
 usr/src/boot/sys/boot/efi/loader/comconsole.c |   2 +-
 usr/src/boot/sys/boot/i386/libi386/biosdisk.c |  56 +++--
 usr/src/boot/sys/boot/i386/loader/main.c      |   7 -
 usr/src/boot/sys/boot/zfs/zfs.c               |  12 +-
 usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h   |  19 +-
 .../cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c |   9 +-
 .../cmd/cmd-inet/usr.sbin/snoop/snoop_slp.c   |  14 +-
 .../cmd/cmd-inet/usr.sbin/snoop/snoop_tftp.c  | 232 ++++++++++++------
 .../mdb/common/modules/genunix/Makefile.files |   3 +-
 .../cmd/mdb/common/modules/genunix/genunix.c  |   5 +
 .../cmd/mdb/common/modules/genunix/refhash.c  |  61 +++++
 .../cmd/mdb/common/modules/genunix/refhash.h  |  35 +++
 .../cmd/sgs/elfedit/common/elfedit_machelf.c  |  12 +-
 .../lib/cfgadm_plugins/ib/common/cfga_ib.c    |   9 +-
 .../cfgadm_plugins/sata/common/cfga_sata.c    |   7 +-
 .../lib/cfgadm_plugins/usb/common/cfga_usb.c  |   9 +-
 usr/src/pkg/manifests/system-header.mf        |   2 +
 usr/src/tools/Makefile                        |   7 +-
 usr/src/uts/common/Makefile.files             |   1 +
 usr/src/uts/common/brand/lx/os/lx_acl.c       |   5 +-
 usr/src/uts/common/inet/ip/ip_if.c            |  39 ++-
 usr/src/uts/common/inet/ip/rts.c              |  14 +-
 usr/src/uts/common/io/hook.c                  |   2 +-
 usr/src/uts/common/io/mac/mac_soft_ring.c     |  16 +-
 usr/src/uts/common/os/cpu_uarray.c            |  79 ++++++
 usr/src/uts/common/os/msacct.c                |  54 ++--
 usr/src/uts/common/os/zone.c                  |  51 ++--
 usr/src/uts/common/sys/Makefile               |  13 +-
 usr/src/uts/common/sys/cpu_uarray.h           |  77 ++++++
 usr/src/uts/common/sys/mac.h                  |   4 +-
 usr/src/uts/common/sys/mac_soft_ring.h        |  16 +-
 usr/src/uts/common/sys/sysmacros.h            |  13 +
 usr/src/uts/common/sys/zone.h                 |  46 ++--
 39 files changed, 684 insertions(+), 262 deletions(-)
 create mode 100644 usr/src/cmd/mdb/common/modules/genunix/refhash.c
 create mode 100644 usr/src/cmd/mdb/common/modules/genunix/refhash.h
 create mode 100644 usr/src/uts/common/os/cpu_uarray.c
 create mode 100644 usr/src/uts/common/sys/cpu_uarray.h

diff --git a/manifest b/manifest
index 310b7878b3..5645ffbeb8 100644
--- a/manifest
+++ b/manifest
@@ -3783,6 +3783,7 @@ f usr/include/sys/corectl.h 0644 root bin
 f usr/include/sys/cpc_impl.h 0644 root bin
 f usr/include/sys/cpc_pcbe.h 0644 root bin
 f usr/include/sys/cpr.h 0644 root bin
+f usr/include/sys/cpu_uarray.h 0644 root bin
 f usr/include/sys/cpu.h 0644 root bin
 f usr/include/sys/cpucaps.h 0644 root bin
 f usr/include/sys/cpucaps_impl.h 0644 root bin
diff --git a/usr/src/boot/lib/libstand/ip.c b/usr/src/boot/lib/libstand/ip.c
index 789dcaab6f..ab3cd36591 100644
--- a/usr/src/boot/lib/libstand/ip.c
+++ b/usr/src/boot/lib/libstand/ip.c
@@ -50,7 +50,6 @@
 #include <netinet/if_ether.h>
 #include <netinet/in_systm.h>
 
-#include <netinet/in_pcb.h>
 #include <netinet/ip.h>
 #include <netinet/ip_var.h>
 #include <netinet/udp.h>
diff --git a/usr/src/boot/lib/libstand/net.c b/usr/src/boot/lib/libstand/net.c
index ae2590a327..640f8746e9 100644
--- a/usr/src/boot/lib/libstand/net.c
+++ b/usr/src/boot/lib/libstand/net.c
@@ -47,7 +47,6 @@
 #include <netinet/if_ether.h>
 #include <netinet/in_systm.h>
 
-#include <netinet/in_pcb.h>
 #include <netinet/ip.h>
 #include <netinet/ip_var.h>
 #include <netinet/udp.h>
diff --git a/usr/src/boot/lib/libstand/udp.c b/usr/src/boot/lib/libstand/udp.c
index 3875e12144..50809db294 100644
--- a/usr/src/boot/lib/libstand/udp.c
+++ b/usr/src/boot/lib/libstand/udp.c
@@ -47,7 +47,6 @@
 #include <netinet/if_ether.h>
 #include <netinet/in_systm.h>
 
-#include <netinet/in_pcb.h>
 #include <netinet/ip.h>
 #include <netinet/ip_var.h>
 #include <netinet/udp.h>
@@ -65,7 +64,7 @@ sendudp(struct iodesc *d, void *pkt, size_t len)
 	struct udphdr *uh;
 
 #ifdef NET_DEBUG
- 	if (debug) {
+	if (debug) {
 		printf("sendudp: d=%lx called.\n", (long)d);
 		if (d) {
 			printf("saddr: %s:%d",
@@ -171,7 +170,7 @@ readudp(struct iodesc *d, void **pkt, void **payload, time_t tleft)
 		return (-1);
 	}
 
-	n = (n > (ntohs(uh->uh_ulen) - sizeof(*uh))) ? 
+	n = (n > (ntohs(uh->uh_ulen) - sizeof(*uh))) ?
 	    ntohs(uh->uh_ulen) - sizeof(*uh) : n;
 	*pkt = ptr;
 	*payload = (void *)((uintptr_t)uh + sizeof(*uh));
diff --git a/usr/src/boot/sys/boot/common/disk.c b/usr/src/boot/sys/boot/common/disk.c
index 2b89274473..7d48e2842a 100644
--- a/usr/src/boot/sys/boot/common/disk.c
+++ b/usr/src/boot/sys/boot/common/disk.c
@@ -262,9 +262,7 @@ disk_open(struct disk_devdesc *dev, uint64_t mediasize, u_int sectorsize)
 		rc = ENXIO;
 		goto out;
 	}
-	if (mediasize > od->mediasize) {
-		od->mediasize = mediasize;
-	}
+	od->mediasize = mediasize;
 
 	if (ptable_gettype(od->table) == PTABLE_BSD &&
 	    partition >= 0) {
diff --git a/usr/src/boot/sys/boot/common/part.c b/usr/src/boot/sys/boot/common/part.c
index 1e3d8bf43a..25a9cf98a0 100644
--- a/usr/src/boot/sys/boot/common/part.c
+++ b/usr/src/boot/sys/boot/common/part.c
@@ -342,8 +342,7 @@ ptable_gptread(struct ptable *table, void *dev, diskread_t dread)
 	 * Note, this is still not a foolproof way to get disk's size. For
 	 * example, an image file can be truncated when copied to smaller media.
 	 */
-	if (hdr.hdr_lba_alt + 1 > table->sectors)
-		table->sectors = hdr.hdr_lba_alt + 1;
+	table->sectors = hdr.hdr_lba_alt + 1;
 
 	for (i = 0; i < size / hdr.hdr_entsz; i++) {
 		ent = (struct gpt_ent *)(tbl + i * hdr.hdr_entsz);
diff --git a/usr/src/boot/sys/boot/efi/loader/comconsole.c b/usr/src/boot/sys/boot/efi/loader/comconsole.c
index 7fb19b11f1..8bcce95e0b 100644
--- a/usr/src/boot/sys/boot/efi/loader/comconsole.c
+++ b/usr/src/boot/sys/boot/efi/loader/comconsole.c
@@ -304,7 +304,7 @@ comc_ischar(struct console *cp)
 	if (EFI_ERROR(status))
 		return (0);
 
-	return (!(status & EFI_SERIAL_INPUT_BUFFER_EMPTY));
+	return (!(control & EFI_SERIAL_INPUT_BUFFER_EMPTY));
 }
 
 static char *
diff --git a/usr/src/boot/sys/boot/i386/libi386/biosdisk.c b/usr/src/boot/sys/boot/i386/libi386/biosdisk.c
index 3db2144763..30af54ea53 100644
--- a/usr/src/boot/sys/boot/i386/libi386/biosdisk.c
+++ b/usr/src/boot/sys/boot/i386/libi386/biosdisk.c
@@ -439,6 +439,33 @@ bd_print(int verbose)
 	return (ret);
 }
 
+/*
+ * Read disk size from partition.
+ * This is needed to work around buggy BIOS systems returning
+ * wrong (truncated) disk media size.
+ * During bd_probe() we tested if the multiplication of bd_sectors
+ * would overflow so it should be safe to perform here.
+ */
+static uint64_t
+bd_disk_get_sectors(struct disk_devdesc *dev)
+{
+	struct disk_devdesc disk;
+	uint64_t size;
+
+	disk.dd.d_dev = dev->dd.d_dev;
+	disk.dd.d_unit = dev->dd.d_unit;
+	disk.d_slice = -1;
+	disk.d_partition = -1;
+	disk.d_offset = 0;
+
+	size = BD(dev).bd_sectors * BD(dev).bd_sectorsize;
+	if (disk_open(&disk, size, BD(dev).bd_sectorsize) == 0) {
+		(void) disk_ioctl(&disk, DIOCGMEDIASIZE, &size);
+		disk_close(&disk);
+	}
+	return (size / BD(dev).bd_sectorsize);
+}
+
 /*
  * Attempt to open the disk described by (dev) for use by (f).
  *
@@ -453,9 +480,7 @@ static int
 bd_open(struct open_file *f, ...)
 {
 	struct disk_devdesc *dev;
-	struct disk_devdesc disk;
 	va_list ap;
-	uint64_t size;
 	int rc;
 
 	va_start(ap, f);
@@ -471,33 +496,12 @@ bd_open(struct open_file *f, ...)
 		if ((BD(dev).bd_flags & BD_NO_MEDIA) == BD_NO_MEDIA)
 			return (EIO);
 	}
-	BD(dev).bd_open++;
 	if (BD(dev).bd_bcache == NULL)
 	    BD(dev).bd_bcache = bcache_allocate();
 
-	/*
-	 * Read disk size from partition.
-	 * This is needed to work around buggy BIOS systems returning
-	 * wrong (truncated) disk media size.
-	 * During bd_probe() we tested if the mulitplication of bd_sectors
-	 * would overflow so it should be safe to perform here.
-	 */
-	disk.dd.d_dev = dev->dd.d_dev;
-	disk.dd.d_unit = dev->dd.d_unit;
-	disk.d_slice = -1;
-	disk.d_partition = -1;
-	disk.d_offset = 0;
-
-	if (disk_open(&disk, BD(dev).bd_sectors * BD(dev).bd_sectorsize,
-	    BD(dev).bd_sectorsize) == 0) {
-
-		if (disk_ioctl(&disk, DIOCGMEDIASIZE, &size) == 0) {
-			size /= BD(dev).bd_sectorsize;
-			if (size > BD(dev).bd_sectors)
-				BD(dev).bd_sectors = size;
-		}
-		disk_close(&disk);
-	}
+	if (BD(dev).bd_open == 0)
+		BD(dev).bd_sectors = bd_disk_get_sectors(dev);
+	BD(dev).bd_open++;
 
 	rc = disk_open(dev, BD(dev).bd_sectors * BD(dev).bd_sectorsize,
 	    BD(dev).bd_sectorsize);
diff --git a/usr/src/boot/sys/boot/i386/loader/main.c b/usr/src/boot/sys/boot/i386/loader/main.c
index 443a523cfd..d6b50338d3 100644
--- a/usr/src/boot/sys/boot/i386/loader/main.c
+++ b/usr/src/boot/sys/boot/i386/loader/main.c
@@ -216,7 +216,6 @@ extract_currdev(void)
 {
     struct i386_devdesc		new_currdev;
 #ifdef LOADER_ZFS_SUPPORT
-    char			buf[20];
     struct zfs_boot_args	*zargs;
 #endif
     int				biosdev = -1;
@@ -252,12 +251,6 @@ extract_currdev(void)
 	    /* sufficient data is provided */
 	    new_currdev.d_kind.zfs.pool_guid = zargs->pool;
 	    new_currdev.d_kind.zfs.root_guid = zargs->root;
-	    if (zargs->size >= sizeof(*zargs) && zargs->primary_vdev != 0) {
-		sprintf(buf, "%llu", zargs->primary_pool);
-		setenv("vfs.zfs.boot.primary_pool", buf, 1);
-		sprintf(buf, "%llu", zargs->primary_vdev);
-		setenv("vfs.zfs.boot.primary_vdev", buf, 1);
-	    }
 	} else {
 	    /* old style zfsboot block */
 	    new_currdev.d_kind.zfs.pool_guid = kargs->zfspool;
diff --git a/usr/src/boot/sys/boot/zfs/zfs.c b/usr/src/boot/sys/boot/zfs/zfs.c
index 60da09a441..8139f8fa24 100644
--- a/usr/src/boot/sys/boot/zfs/zfs.c
+++ b/usr/src/boot/sys/boot/zfs/zfs.c
@@ -40,6 +40,7 @@
 #include <string.h>
 #include <stand.h>
 #include <bootstrap.h>
+#include <inttypes.h>
 
 #include "libzfs.h"
 
@@ -724,8 +725,11 @@ zfs_bootfs(void *zdev)
 	}
 
 	/* Set the environment. */
-	snprintf(buf, sizeof (buf), "%s/%llu", spa->spa_name,
-	    (unsigned long long)objnum);
+	snprintf(buf, sizeof (buf), "%" PRIu64, dev->pool_guid);
+	setenv("zfs-bootpool", buf, 1);
+	snprintf(buf, sizeof (buf), "%" PRIu64, spa->spa_boot_vdev->v_guid);
+	setenv("zfs-bootvdev", buf, 1);
+	snprintf(buf, sizeof (buf), "%s/%" PRIu64, spa->spa_name, objnum);
 	setenv("zfs-bootfs", buf, 1);
 	if (spa->spa_boot_vdev->v_phys_path != NULL)
 		setenv("bootpath", spa->spa_boot_vdev->v_phys_path, 1);
@@ -737,8 +741,8 @@ zfs_bootfs(void *zdev)
 	 * the environment and we can stop caring about old kernels,
 	 * we can remove this part.
 	 */
-	snprintf(buf, sizeof(buf), "zfs-bootfs=%s/%llu", spa->spa_name,
-	    (unsigned long long)objnum);
+	snprintf(buf, sizeof(buf), "zfs-bootfs=%s/%" PRIu64, spa->spa_name,
+	    objnum);
 	n = strlen(buf);
 	if (spa->spa_boot_vdev->v_phys_path != NULL) {
 		snprintf(buf+n, sizeof (buf) - n, ",bootpath=\"%s\"",
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
index 42095bcd34..991abae186 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
@@ -69,6 +69,19 @@ extern "C" {
 
 #define	MAXLINE		(1088)		/* max len of detail line */
 
+/*
+ * Transient port structure. See TFTP interpreter.
+ */
+struct ttable {
+	int t_port;
+	int blksize;
+	int (*t_proc)(int, void *, int);
+};
+
+extern int add_transient(int port, int (*proc)(int, void *, int));
+extern struct ttable *is_transient(int port);
+extern void del_transient(int port);
+
 /*
  * The RPC XID cache structure.
  * When analyzing RPC protocols we
@@ -244,14 +257,14 @@ struct dhcp;
 extern int interpret_dhcp(int, struct dhcp *, int);
 extern int interpret_dhcpv6(int, const uint8_t *, int);
 struct tftphdr;
-extern int interpret_tftp(int, struct tftphdr *, int);
+extern int interpret_tftp(int, void *, int);
 extern int interpret_http(int, char *, int);
 struct ntpdata;
 extern int interpret_ntp(int, struct ntpdata *, int);
 extern void interpret_netbios_ns(int, uchar_t *, int);
 extern void interpret_netbios_datagram(int, uchar_t *, int);
 extern void interpret_netbios_ses(int, uchar_t *, int);
-extern void interpret_slp(int, char *, int);
+extern void interpret_slp(int, void *, int);
 struct rip;
 extern int interpret_rip(int, struct rip *, int);
 struct rip6;
@@ -295,7 +308,7 @@ typedef uint_t (headerlen_fn_t)(char *, size_t);
 typedef struct interface {
 	uint_t		mac_type;
 	uint_t		mtu_size;
-	uint_t  	network_type_offset;
+	uint_t		network_type_offset;
 	size_t		network_type_len;
 	uint_t		network_type_ip;
 	uint_t		network_type_ipv6;
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
index c2fcfd7c72..76ab7f2da0 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
@@ -181,13 +181,10 @@ reservedport(int proto, int port)
  * See TFTP interpreter.
  */
 #define	MAXTRANS 64
-static struct ttable {
-	int t_port;
-	int (*t_proc)(int, char *, int);
-} transients [MAXTRANS];
+static struct ttable transients [MAXTRANS];
 
 int
-add_transient(int port, int (*proc)(int, char *, int))
+add_transient(int port, int (*proc)(int, void *, int))
 {
 	static struct ttable *next = transients;
 
@@ -200,7 +197,7 @@ add_transient(int port, int (*proc)(int, char *, int))
 	return (1);
 }
 
-static struct ttable *
+struct ttable *
 is_transient(int port)
 {
 	struct ttable *p;
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_slp.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_slp.c
index 9feb3e9b27..fc0cd87522 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_slp.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_slp.c
@@ -24,8 +24,6 @@
  * All rights reserved.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <arpa/inet.h>
 #include <stdlib.h>
@@ -64,9 +62,6 @@ static int v2_finish(struct slpv2_hdr *, int);
 /* V2 auth blocks */
 static int slpv2_authblock(int);
 
-/* From snoop_rport: */
-extern int add_transient(int, int (*)());
-
 /*
  * Functions for parsing each protocol message
  * Each function takes the interpreter's flags argument as its input
@@ -163,9 +158,10 @@ static char *slpv1_charset(unsigned short);
  * The only external entry point to the SLP interpreter. This function
  * simply dispatches the packet based on the version.
  */
-void interpret_slp(int flags, char *slp, int fraglen) {
+void interpret_slp(int flags, void *slp, int fraglen) {
 	extern int dst_port, curr_proto;
 	struct tcp_cont *tce = NULL;
+	char *s;
 
 	msglength = fraglen;
 	retlength = 0;
@@ -182,10 +178,10 @@ void interpret_slp(int flags, char *slp, int fraglen) {
 		}
 	    }
 	}
-	if (*slp == 2 || tce)
-	    interpret_slp_v2(flags, (void *)slp, fraglen);
+	if (*(char *)slp == 2 || tce)
+	    interpret_slp_v2(flags, slp, fraglen);
 	else
-	    interpret_slp_v1(flags, (void *)slp, fraglen);
+	    interpret_slp_v1(flags, slp, fraglen);
 
 	tcp_continuation = B_FALSE;
 }
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_tftp.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_tftp.c
index 21964540fd..0c7b95cbe9 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_tftp.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_tftp.c
@@ -24,22 +24,32 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <fcntl.h>
 #include <arpa/tftp.h>
 #include "snoop.h"
 
+struct tftp_options {
+	int blksize;
+	int tsize;
+};
+
 extern char *dlc_header;
-char *tftperror();
-char *show_type();
+static char *tftperror(unsigned short);
+static char *show_type(int);
+static char *tftp_parse_oack(char *, size_t, struct tftp_options *);
 
 int
-interpret_tftp(int flags, struct tftphdr *tftp, int fraglen)
+interpret_tftp(int flags, void *data, int fraglen)
 {
 	char *name, *mode;
 	extern int src_port, dst_port;
 	int blocksize = fraglen - 4;
+	struct tftp_options opts;
+	struct ttable *tt;
+	struct tftphdr *tftp = data;
+
+	opts.tsize = 0;
+	opts.blksize = 512;
 
 	switch (ntohs(tftp->th_opcode)) {
 	case RRQ:
@@ -49,6 +59,18 @@ interpret_tftp(int flags, struct tftphdr *tftp, int fraglen)
 	case ERROR:
 		del_transient(src_port);
 		break;
+	case OACK:
+		tt = is_transient(dst_port);
+		if (tt != NULL)
+			tt->blksize = opts.blksize;
+		break;
+	case DATA:
+		tt = is_transient(dst_port);
+		if (tt != NULL)
+			opts.blksize = tt->blksize;
+		break;
+	default:
+		break;
 	}
 
 	if (flags & F_SUM) {
@@ -57,94 +79,102 @@ interpret_tftp(int flags, struct tftphdr *tftp, int fraglen)
 			name = (char *)&tftp->th_stuff;
 			mode = name + (strlen(name) + 1);
 			(void) sprintf(get_sum_line(),
-				"TFTP Read \"%s\" (%s)", name, mode);
+			    "TFTP Read \"%s\" (%s)", name, mode);
 			break;
 		case WRQ:
 			name = (char *)&tftp->th_stuff;
 			mode = name + (strlen(name) + 1);
 			(void) sprintf(get_sum_line(),
-				"TFTP Write \"%s\" (%s)", name, mode);
+			    "TFTP Write \"%s\" (%s)", name, mode);
 			break;
 		case DATA:
 			(void) sprintf(get_sum_line(),
-				"TFTP Data block %d (%d bytes)%s",
-				ntohs(tftp->th_block),
-				blocksize,
-				blocksize < 512 ? " (last block)":"");
+			    "TFTP Data block %u (%d bytes)%s",
+			    ntohs(tftp->th_block), blocksize,
+			    blocksize < opts.blksize ? " (last block)":"");
 			break;
 		case ACK:
-			(void) sprintf(get_sum_line(),
-				"TFTP Ack  block %d",
-				ntohs(tftp->th_block));
+			(void) sprintf(get_sum_line(), "TFTP Ack block %d",
+			    ntohs(tftp->th_block));
 			break;
 		case ERROR:
-			(void) sprintf(get_sum_line(),
-				"TFTP Error: %s",
-				tftperror(ntohs(tftp->th_code)));
+			(void) sprintf(get_sum_line(), "TFTP Error: %s",
+			    tftperror(ntohs(tftp->th_code)));
+			break;
+		case OACK:
+			(void) sprintf(get_sum_line(), "TFTP OACK: %s",
+			    tftp_parse_oack((char *)&tftp->th_stuff,
+			    fraglen - sizeof (tftp->th_opcode), &opts));
+			if (tt != NULL)
+				tt->blksize = opts.blksize;
 			break;
 		}
 	}
 
 	if (flags & F_DTAIL) {
+		show_header("TFTP:  ", "Trivial File Transfer Protocol",
+		    fraglen);
+		show_space();
+		(void) sprintf(get_line((char *)(uintptr_t)tftp->th_opcode -
+		    dlc_header, 2), "Opcode = %d (%s)", ntohs(tftp->th_opcode),
+		    show_type(ntohs(tftp->th_opcode)));
 
-	show_header("TFTP:  ", "Trivial File Transfer Protocol", fraglen);
-	show_space();
-	(void) sprintf(get_line((char *)(uintptr_t)tftp->th_opcode -
-		dlc_header, 2),
-		"Opcode = %d (%s)",
-		ntohs(tftp->th_opcode),
-		show_type(ntohs(tftp->th_opcode)));
-
-	switch (ntohs(tftp->th_opcode)) {
-	case RRQ:
-	case WRQ:
-		name = (char *)&tftp->th_stuff;
-		mode = name + (strlen(name) + 1);
-		(void) sprintf(
-			get_line(name - dlc_header, strlen(name) + 1),
-			"File name = \"%s\"",
-			name);
-		(void) sprintf(
-			get_line(mode - dlc_header, strlen(mode) + 1),
-			"Transfer mode = %s",
-			mode);
-		break;
+		switch (ntohs(tftp->th_opcode)) {
+		case RRQ:
+		case WRQ:
+			name = (char *)&tftp->th_stuff;
+			mode = name + (strlen(name) + 1);
+			(void) sprintf(
+			    get_line(name - dlc_header, strlen(name) + 1),
+			    "File name = \"%s\"", name);
+			(void) sprintf(
+			    get_line(mode - dlc_header, strlen(mode) + 1),
+			    "Transfer mode = %s", mode);
+			break;
 
-	case DATA:
-		(void) sprintf(
-			get_line((char *)(uintptr_t)tftp->th_block -
-			dlc_header, 2),	"Data block = %d%s",
-			ntohs(tftp->th_block),
-			blocksize < 512 ? " (last block)":"");
-		(void) sprintf(get_line((char *)(uintptr_t)tftp->th_data -
-			dlc_header, blocksize),
-			"[ %d bytes of data ]",
-			blocksize);
-		break;
+		case DATA:
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_block - dlc_header, 2),
+			    "Data block = %d%s", ntohs(tftp->th_block),
+			    blocksize < opts.blksize ? " (last block)" : "");
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_data - dlc_header,
+			    blocksize), "[ %d bytes of data ]", blocksize);
+			break;
 
-	case ACK:
-		(void) sprintf(get_line((char *)(uintptr_t)tftp->th_block -
-			dlc_header, 2),	"Acknowledge block = %d",
-			ntohs(tftp->th_block));
-		break;
+		case ACK:
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_block - dlc_header, 2),
+			    "Acknowledge block = %d", ntohs(tftp->th_block));
+			break;
 
-	case ERROR:
-		(void) sprintf(get_line((char *)(uintptr_t)tftp->th_code -
-			dlc_header, 2),	"Error = %d (%s)",
-			ntohs(tftp->th_code),
-			tftperror(ntohs(tftp->th_code)));
-		(void) sprintf(get_line((char *)(uintptr_t)tftp->th_data -
-			dlc_header, strlen(tftp->th_data) + 1),
-			"Error string = \"%s\"", tftp->th_data);
-	}
+		case ERROR:
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_code - dlc_header, 2),
+			    "Error = %d (%s)", ntohs(tftp->th_code),
+			    tftperror(ntohs(tftp->th_code)));
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_data -
+			    dlc_header, strlen(tftp->th_data) + 1),
+			    "Error string = \"%s\"", tftp->th_data);
+			break;
+		case OACK:
+			(void) sprintf(get_line(
+			    (char *)(uintptr_t)tftp->th_code - dlc_header, 2),
+			    "TFTP OACK: %s",
+			    tftp_parse_oack((char *)&tftp->th_stuff,
+			    fraglen - sizeof (tftp->th_opcode), &opts));
+			if (tt != NULL)
+				tt->blksize = opts.blksize;
+			break;
+		}
 	}
 
 	return (fraglen);
 }
 
-char *
-show_type(t)
-	int t;
+static char *
+show_type(int t)
 {
 	switch (t) {
 	case RRQ:	return ("read request");
@@ -152,13 +182,13 @@ show_type(t)
 	case DATA:	return ("data packet");
 	case ACK:	return ("acknowledgement");
 	case ERROR:	return ("error");
+	case OACK:	return ("option acknowledgement");
 	}
 	return ("?");
 }
 
-char *
-tftperror(code)
-    unsigned short code;
+static char *
+tftperror(unsigned short code)
 {
 	static char buf[128];
 
@@ -176,3 +206,65 @@ tftperror(code)
 
 	return (buf);
 }
+
+static char *
+tftp_parse_oack(char *buf, size_t size, struct tftp_options *opts)
+{
+	static char tftp_options[128];
+	int i, idx;
+
+	tftp_options[0] = '\0';
+	idx = 0;
+
+	while (size > 0 && idx < sizeof (tftp_options)) {
+		if (idx > 0) {
+			tftp_options[idx++] = ' ';
+			tftp_options[idx] = '\0';
+		}
+
+		/* get name */
+		if (idx + strnlen(buf, size) + 1 > sizeof (tftp_options))
+			break;
+		for (i = 0; i < size; i++) {
+			tftp_options[idx] = buf[i];
+			if (tftp_options[idx] == '\0') {
+				i++;
+				break;
+			}
+			idx++;
+		}
+		size -= i;
+		/*
+		 * RFC 2348 requires this case in-sensitive.
+		 */
+		if (strcasecmp(buf, "blksize") == 0) {
+			int blksize = strtol(buf + i, NULL, 0);
+
+			if (blksize >= 8)
+				opts->blksize = blksize;
+		}
+		buf += i;
+
+		/* can we store separator? */
+		if (idx + 3 > sizeof (tftp_options))
+			break;
+		strcat(tftp_options, ": ");
+		idx += 2;
+
+		/* get value */
+		if (idx + strnlen(buf, size) + 1 > sizeof (tftp_options))
+			break;
+
+		for (i = 0; i < size; i++) {
+			tftp_options[idx] = buf[i];
+			if (tftp_options[idx] == '\0') {
+				i++;
+				break;
+			}
+			idx++;
+		}
+		size -= i;
+		buf += i;
+	}
+	return (tftp_options);
+}
diff --git a/usr/src/cmd/mdb/common/modules/genunix/Makefile.files b/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
index 5d9cf9bb8f..07e5c2fa14 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
+++ b/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
@@ -21,7 +21,7 @@
 #
 # Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
 # Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright 2016 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 # Copyright (c) 2013 by Delphix. All rights reserved.
 #
 
@@ -72,6 +72,7 @@ GENUNIX_SRCS =		\
 	nvpair.c	\
 	pg.c		\
 	rctl.c		\
+	refhash.c	\
 	sobj.c		\
 	streams.c	\
 	sysevent.c	\
diff --git a/usr/src/cmd/mdb/common/modules/genunix/genunix.c b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
index b3b8aea9bc..3fa1ad2e64 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/genunix.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
@@ -97,6 +97,7 @@
 #include "nvpair.h"
 #include "pg.h"
 #include "rctl.h"
+#include "refhash.h"
 #include "sobj.h"
 #include "streams.h"
 #include "sysevent.h"
@@ -4687,6 +4688,10 @@ static const mdb_walker_t walkers[] = {
 	{ "rctl_val", "given a rctl_t, walk all rctl_val entries associated",
 		rctl_val_walk_init, rctl_val_walk_step },
 
+	/* from refhash.c */
+	{ REFHASH_WALK_NAME, REFHASH_WALK_DESC,
+		refhash_walk_init, refhash_walk_step, NULL },
+
 	/* from sobj.c */
 	{ "blocked", "walk threads blocked on a given sobj",
 		blocked_walk_init, blocked_walk_step, NULL },
diff --git a/usr/src/cmd/mdb/common/modules/genunix/refhash.c b/usr/src/cmd/mdb/common/modules/genunix/refhash.c
new file mode 100644
index 0000000000..4b4c92dc14
--- /dev/null
+++ b/usr/src/cmd/mdb/common/modules/genunix/refhash.c
@@ -0,0 +1,61 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#include <mdb/mdb_modapi.h>
+#include <mdb/mdb_ctf.h>
+
+#include <inttypes.h>
+#include <sys/refhash.h>
+
+typedef struct refhash_walk_data {
+	size_t	rwd_offset;
+} refhash_walk_data_t;
+
+int
+refhash_walk_init(mdb_walk_state_t *wsp)
+{
+	refhash_t refh = { 0 };
+	refhash_walk_data_t *rwd;
+	int offset;
+
+	/*  mdb_ctf_offsetof_by_name() will print any errors */
+	if ((offset = mdb_ctf_offsetof_by_name("refhash_t", "rh_objs")) == -1)
+		return (WALK_ERR);
+
+	if (mdb_vread(&refh, sizeof (refhash_t), wsp->walk_addr) == -1) {
+		mdb_warn("failed to read refhash_t at %#lx", wsp->walk_addr);
+		return (WALK_ERR);
+	}
+
+	rwd = wsp->walk_data = mdb_zalloc(sizeof (*rwd), UM_SLEEP | UM_GC);
+	rwd->rwd_offset = refh.rh_link_off;
+
+	wsp->walk_addr += offset;
+	if (mdb_layered_walk("list", wsp) == -1) {
+		mdb_warn("can't walk refhash_t");
+		return (WALK_ERR);
+	}
+
+	return (WALK_NEXT);
+}
+
+int
+refhash_walk_step(mdb_walk_state_t *wsp)
+{
+	refhash_walk_data_t *rwd = wsp->walk_data;
+	uintptr_t addr = wsp->walk_addr - rwd->rwd_offset;
+
+	return (wsp->walk_callback(addr, wsp->walk_layer, wsp->walk_cbdata));
+}
diff --git a/usr/src/cmd/mdb/common/modules/genunix/refhash.h b/usr/src/cmd/mdb/common/modules/genunix/refhash.h
new file mode 100644
index 0000000000..1e91ced8d5
--- /dev/null
+++ b/usr/src/cmd/mdb/common/modules/genunix/refhash.h
@@ -0,0 +1,35 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#ifndef _REFHASH_H
+#define	_REFHASH_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	REFHASH_WALK_NAME "refhash"
+#define	REFHASH_WALK_DESC "walk a refhash"
+
+struct mdb_walk_state;
+
+extern int refhash_walk_init(struct mdb_walk_state *);
+extern int refhash_walk_step(struct mdb_walk_state *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _REFHASH_H */
diff --git a/usr/src/cmd/sgs/elfedit/common/elfedit_machelf.c b/usr/src/cmd/sgs/elfedit/common/elfedit_machelf.c
index 73653cd6e2..b5094e39c3 100644
--- a/usr/src/cmd/sgs/elfedit/common/elfedit_machelf.c
+++ b/usr/src/cmd/sgs/elfedit/common/elfedit_machelf.c
@@ -22,6 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
 
 /*
@@ -229,15 +230,16 @@ elfedit32_init_obj_state(const char *file, int fd, Elf *elf)
 	/*LINTED E_BAD_PTR_CAST_ALIGN*/
 	obj_state->os_secarr = (elfedit_section_t *)
 	    ((char *)obj_state + os_size);
-	if (obj_state->os_symtabnum == 0)
+	if (obj_state->os_symtabnum == 0) {
 		obj_state->os_symtab = NULL;
-	else
+	} else {
 		/*LINTED E_BAD_PTR_CAST_ALIGN*/
 		obj_state->os_symtab = (elfedit_symtab_t *)
 		    ((char *)obj_state->os_secarr + secarr_size);
-	obj_state->os_file =
-	    (char *)(obj_state->os_symtab + tstate.os_symtabnum);
-	(void) strncpy((char *)obj_state->os_file, tstate.os_file, len);
+		obj_state->os_file =
+		    (char *)(obj_state->os_symtab + tstate.os_symtabnum);
+		(void) strncpy((char *)obj_state->os_file, tstate.os_file, len);
+	}
 
 	/*
 	 * Fill in obj_state->os_secarr with information for each section.
diff --git a/usr/src/lib/cfgadm_plugins/ib/common/cfga_ib.c b/usr/src/lib/cfgadm_plugins/ib/common/cfga_ib.c
index 6186f187e0..e9585ef40a 100644
--- a/usr/src/lib/cfgadm_plugins/ib/common/cfga_ib.c
+++ b/usr/src/lib/cfgadm_plugins/ib/common/cfga_ib.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
 
 #include "cfga_ib.h"
@@ -73,7 +74,7 @@ void			cfga_msg(struct cfga_msg *, const char *);
 cfga_err_t		cfga_help(struct cfga_msg *, const char *,
 			    cfga_flags_t);
 static int		ib_confirm(struct cfga_confirm *, char *);
-static char 		*ib_get_devicepath(const char *);
+static char		*ib_get_devicepath(const char *);
 
 
 /* External function prototypes */
@@ -194,7 +195,7 @@ static char		*ib_service_subopts[] = {
 /* Communication Service name : "port" or "vppa" or "hca-svc" */
 static char		*comm_name = NULL;
 
-char 			*service_name = NULL;	/* service name */
+char			*service_name = NULL;	/* service name */
 ib_service_type_t	service_type = IB_NONE;	/* service type */
 
 
@@ -1654,14 +1655,12 @@ cfga_list_ext(const char *ap_id, cfga_list_data_t **ap_id_list, int *nlistp,
 	cfga_list_data_t	*clp = NULL;
 
 	if ((rv = ib_verify_params(ap_id, options, errstring)) != CFGA_IB_OK) {
-		(void) cfga_help(NULL, options, flags);
 		return (ib_err_msg(errstring, rv, ap_id, errno));
 	}
 
 	/* make sure we have a valid ap_id_list */
 	if (ap_id_list == NULL || nlistp == NULL) {
 		DPRINTF("cfga_list_ext: list = NULL or nlistp = NULL\n");
-		(void) cfga_help(NULL, options, flags);
 		return (ib_err_msg(errstring, CFGA_IB_INVAL_ARG_ERR,
 		    ap_id, errno));
 	}
@@ -1717,7 +1716,7 @@ cfga_list_ext(const char *ap_id, cfga_list_data_t **ap_id_list, int *nlistp,
 	/*
 	 * *nlistp contains to how many APIDs to show w/ cfgadm -l.
 	 * If ap_id is "fabric" then
-	 * 	*nlistp is all Dynamic Apids + One more for "fabric"
+	 *	*nlistp is all Dynamic Apids + One more for "fabric"
 	 * If ap_id is "HCA" ap_id then
 	 *	*nlistp is 1
 	 * Note that each HCA is a static APID, so nlistp will be 1 always
diff --git a/usr/src/lib/cfgadm_plugins/sata/common/cfga_sata.c b/usr/src/lib/cfgadm_plugins/sata/common/cfga_sata.c
index 29f059b2db..ad4dcd6dd3 100644
--- a/usr/src/lib/cfgadm_plugins/sata/common/cfga_sata.c
+++ b/usr/src/lib/cfgadm_plugins/sata/common/cfga_sata.c
@@ -22,6 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
 
 #include <sys/param.h>
@@ -570,7 +571,7 @@ cfga_change_state(
     cfga_flags_t flags)
 {
 	int		ret;
-	int 		len;
+	int		len;
 	char		*msg;
 	char		*devpath;
 	nvlist_t	*nvl = NULL;
@@ -922,7 +923,7 @@ cfga_private_func(
     cfga_flags_t flags)
 {
 	int			len;
-	char 			*msg;
+	char			*msg;
 	nvlist_t		*list = NULL;
 	ap_ostate_t		ostate;
 	ap_rstate_t		rstate;
@@ -1430,7 +1431,6 @@ cfga_list_ext(
 
 
 	if ((rv = verify_params(ap_id, options, errstring)) != CFGA_SATA_OK) {
-		(void) cfga_help(NULL, options, flags);
 		goto bailout;
 	}
 	/* We do not care here about dynamic AP name component */
@@ -1440,7 +1440,6 @@ cfga_list_ext(
 
 	if (ap_id_list == NULL || nlistp == NULL) {
 		rv = CFGA_SATA_DATA_ERROR;
-		(void) cfga_help(NULL, options, flags);
 		goto bailout;
 	}
 
diff --git a/usr/src/lib/cfgadm_plugins/usb/common/cfga_usb.c b/usr/src/lib/cfgadm_plugins/usb/common/cfga_usb.c
index e570daeeb3..cfb0b63232 100644
--- a/usr/src/lib/cfgadm_plugins/usb/common/cfga_usb.c
+++ b/usr/src/lib/cfgadm_plugins/usb/common/cfga_usb.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
 
 
@@ -36,7 +37,7 @@ extern cfga_usb_ret_t	usb_rcm_online(const char *, char **, char *,
 extern cfga_usb_ret_t	usb_rcm_remove(const char *, char **, char *,
 			    cfga_flags_t);
 static int		usb_confirm(struct cfga_confirm *, char *);
-static char 		*usb_get_devicepath(const char *);
+static char		*usb_get_devicepath(const char *);
 
 /*
  * This file contains the entry points to the plugin as defined in the
@@ -621,7 +622,7 @@ device_connected(devctl_hdl_t hdl, nvlist_t *list, ap_ostate_t *ostate)
  */
 cfga_usb_ret_t
 do_control_ioctl(const char *ap_id, uint_t subcommand, uint_t arg,
-	void **descrp, size_t *sizep)
+    void **descrp, size_t *sizep)
 {
 	int			fd = -1;
 	uint_t			port;
@@ -1224,7 +1225,7 @@ cfga_private_func(
 	char			*msg;
 	nvlist_t		*list = NULL;
 	ap_ostate_t		ostate;
-	devctl_hdl_t 		hdl = NULL;
+	devctl_hdl_t		hdl = NULL;
 	cfga_usb_ret_t		rv;
 	usb_dev_descr_t		*dev_descrp = NULL;
 	char			*driver = NULL;
@@ -1474,14 +1475,12 @@ cfga_list_ext(
 	DPRINTF("cfga_list_ext:\n");
 
 	if ((rv = verify_params(ap_id, options, errstring)) != CFGA_USB_OK) {
-		(void) cfga_help(NULL, options, flags);
 		goto bailout;
 	}
 
 	if (ap_id_list == NULL || nlistp == NULL) {
 		DPRINTF("cfga_list_ext: list = NULL or nlistp = NULL\n");
 		rv = CFGA_USB_INTERNAL_ERROR;
-		(void) cfga_help(NULL, options, flags);
 		goto bailout;
 	}
 
diff --git a/usr/src/pkg/manifests/system-header.mf b/usr/src/pkg/manifests/system-header.mf
index a65dbd02b9..5495835f8a 100644
--- a/usr/src/pkg/manifests/system-header.mf
+++ b/usr/src/pkg/manifests/system-header.mf
@@ -26,6 +26,7 @@
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 set name=pkg.fmri value=pkg:/system/header@$(PKGVERS)
@@ -854,6 +855,7 @@ file path=usr/include/sys/corectl.h
 file path=usr/include/sys/cpc_impl.h
 file path=usr/include/sys/cpc_pcbe.h
 file path=usr/include/sys/cpr.h
+file path=usr/include/sys/cpu_uarray.h
 file path=usr/include/sys/cpu.h
 file path=usr/include/sys/cpucaps.h
 file path=usr/include/sys/cpucaps_impl.h
diff --git a/usr/src/tools/Makefile b/usr/src/tools/Makefile
index d9796e6c05..81fbbaf30c 100644
--- a/usr/src/tools/Makefile
+++ b/usr/src/tools/Makefile
@@ -37,13 +37,14 @@ include ../Makefile.master
 BOOT_SUBDIRS= \
 	cw \
 	.WAIT \
-	install.bin
+	install.bin \
+	.WAIT \
+	ctf
 
 COMMON_SUBDIRS= \
 	codereview \
 	codesign \
 	cscope-fast \
-	ctf \
 	env \
 	findunref \
 	lintdump \
@@ -161,6 +162,4 @@ $(ROOTDIRS):
 $(ROOTONBLDLIBPY): $(ROOTDIRS)
 	$(RM) -r $@; $(SYMLINK) python$(PYTHON_VERSION) $@
 
-make: ctf
-
 FRC:
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 942a28069b..174141ea57 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -51,6 +51,7 @@ COMMON_CORE_OBJS +=		\
 		cmt.o		\
 		cmt_policy.o	\
 		cpu.o		\
+		cpu_uarray.o	\
 		cpu_event.o	\
 		cpu_intr.o	\
 		cpu_pm.o	\
diff --git a/usr/src/uts/common/brand/lx/os/lx_acl.c b/usr/src/uts/common/brand/lx/os/lx_acl.c
index 594671f401..184f05b6ed 100644
--- a/usr/src/uts/common/brand/lx/os/lx_acl.c
+++ b/usr/src/uts/common/brand/lx/os/lx_acl.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -192,6 +192,9 @@ lx_acl_getxattr(vnode_t *vp, enum lx_acl_type atype, void *data, size_t slen,
 		return (err);
 	}
 
+	if (vsattr.vsa_aclentp != NULL)
+		kmem_free(vsattr.vsa_aclentp, vsattr.vsa_aclentsz);
+
 	return (ENODATA);
 }
 
diff --git a/usr/src/uts/common/inet/ip/ip_if.c b/usr/src/uts/common/inet/ip/ip_if.c
index c4b60daa68..60a9035176 100644
--- a/usr/src/uts/common/inet/ip/ip_if.c
+++ b/usr/src/uts/common/inet/ip/ip_if.c
@@ -1380,16 +1380,33 @@ ill_capability_probe(ill_t *ill)
 	ill->ill_dlpi_capab_state = IDCS_PROBE_SENT;
 }
 
-static void
+static boolean_t
 ill_capability_wait(ill_t *ill)
 {
-	while (ill->ill_capab_pending_cnt != 0) {
+	/*
+	 * I'm in this ill's squeue, aka a writer.  The ILL_CONDEMNED flag can
+	 * only be set by someone who is the writer.  Since we
+	 * drop-and-reacquire the squeue in this loop, we need to check for
+	 * ILL_CONDEMNED, which if set means nothing can signal our capability
+	 * condition variable.
+	 */
+	ASSERT(IAM_WRITER_ILL(ill));
+
+	while (ill->ill_capab_pending_cnt != 0 &&
+	    (ill->ill_state_flags & ILL_CONDEMNED) == 0) {
 		mutex_enter(&ill->ill_dlpi_capab_lock);
 		ipsq_exit(ill->ill_phyint->phyint_ipsq);
 		cv_wait(&ill->ill_dlpi_capab_cv, &ill->ill_dlpi_capab_lock);
 		mutex_exit(&ill->ill_dlpi_capab_lock);
-		VERIFY(ipsq_enter(ill, B_FALSE, CUR_OP) == B_TRUE);
+		/*
+		 * If ipsq_enter() fails, someone set ILL_CONDEMNED
+		 * while we dropped the squeue. Indicate such to the caller.
+		 */
+		if (!ipsq_enter(ill, B_FALSE, CUR_OP))
+			return (B_FALSE);
 	}
+
+	return ((ill->ill_state_flags & ILL_CONDEMNED) == 0);
 }
 
 void
@@ -12790,8 +12807,11 @@ ill_dl_down(ill_t *ill)
 		ill_capability_reset(ill, B_FALSE);
 		ill_dlpi_send(ill, mp);
 
-		/* Wait for the capability reset to finish */
-		ill_capability_wait(ill);
+		/*
+		 * Wait for the capability reset to finish.
+		 * In this case, it doesn't matter WHY or HOW it finished.
+		 */
+		(void) ill_capability_wait(ill);
 	}
 }
 
@@ -14727,8 +14747,13 @@ ill_dl_up(ill_t *ill, ipif_t *ipif)
 	ill_dlpi_send(ill, bind_mp);
 	/* Send down link-layer capabilities probe if not already done. */
 	ill_capability_probe(ill);
-	/* Wait for DLPI to be bound and the capability probe to finish */
-	ill_capability_wait(ill);
+	/*
+	 * Wait for DLPI to be bound and the capability probe to finish.
+	 * The call drops-and-reacquires the squeue. If it couldn't because
+	 * ILL_CONDEMNED got set, bail.
+	 */
+	if (!ill_capability_wait(ill))
+		return (ENXIO);
 
 	/* DLPI failed to bind. Return the saved error */
 	if (!ill->ill_dl_up) {
diff --git a/usr/src/uts/common/inet/ip/rts.c b/usr/src/uts/common/inet/ip/rts.c
index f5ab423eb0..e265a994b2 100644
--- a/usr/src/uts/common/inet/ip/rts.c
+++ b/usr/src/uts/common/inet/ip/rts.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018 Toomas Soome <tsoome@me.com>
  */
 
 #include <sys/types.h>
@@ -110,7 +111,7 @@ static rtsparam_t	lcl_param_arr[] = {
 #define	rtss_recv_hiwat		rtss_params[2].rts_param_value
 #define	rtss_max_buf		rtss_params[3].rts_param_value
 
-static void 	rts_err_ack(queue_t *q, mblk_t *mp, t_scalar_t t_error,
+static void	rts_err_ack(queue_t *q, mblk_t *mp, t_scalar_t t_error,
     int sys_error);
 static void	rts_input(void *, mblk_t *, void *, ip_recv_attr_t *);
 static void	rts_icmp_input(void *, mblk_t *, void *, ip_recv_attr_t *);
@@ -124,7 +125,7 @@ static void	*rts_stack_init(netstackid_t stackid, netstack_t *ns);
 static void	rts_stack_fini(netstackid_t stackid, void *arg);
 static void	rts_wput(queue_t *q, mblk_t *mp);
 static void	rts_wput_iocdata(queue_t *q, mblk_t *mp);
-static void 	rts_wput_other(queue_t *q, mblk_t *mp);
+static void	rts_wput_other(queue_t *q, mblk_t *mp);
 static int	rts_wrw(queue_t *q, struiod_t *dp);
 
 static int	rts_stream_open(queue_t *q, dev_t *devp, int flag, int sflag,
@@ -667,7 +668,7 @@ rts_opt_set(conn_t *connp, uint_t optset_context, int level, int name,
     uint_t inlen, uchar_t *invalp, uint_t *outlenp, uchar_t *outvalp,
     void *thisdg_attrs, cred_t *cr)
 {
-	boolean_t 	checkonly = B_FALSE;
+	boolean_t	checkonly = B_FALSE;
 
 	if (optset_context) {
 		switch (optset_context) {
@@ -676,9 +677,9 @@ rts_opt_set(conn_t *connp, uint_t optset_context, int level, int name,
 			/*
 			 * Note: Implies T_CHECK semantics for T_OPTCOM_REQ
 			 * inlen != 0 implies value supplied and
-			 * 	we have to "pretend" to set it.
+			 *	we have to "pretend" to set it.
 			 * inlen == 0 implies that there is no value part
-			 * 	in T_CHECK request and just validation
+			 *	in T_CHECK request and just validation
 			 * done elsewhere should be enough, we just return here.
 			 */
 			if (inlen == 0) {
@@ -1063,6 +1064,7 @@ rts_wput_other(queue_t *q, mblk_t *mp)
 		default:
 			break;
 		}
+		break;
 	case M_IOCDATA:
 		rts_wput_iocdata(q, mp);
 		return;
@@ -1349,7 +1351,7 @@ static int
 rts_getsockopt(sock_lower_handle_t proto_handle, int level, int option_name,
     void *optvalp, socklen_t *optlen, cred_t *cr)
 {
-	conn_t  	*connp = (conn_t *)proto_handle;
+	conn_t		*connp = (conn_t *)proto_handle;
 	rts_t		*rts = connp->conn_rts;
 	int		error;
 	t_uscalar_t	max_optbuf_len;
diff --git a/usr/src/uts/common/io/hook.c b/usr/src/uts/common/io/hook.c
index cf075f27c9..6726f72147 100644
--- a/usr/src/uts/common/io/hook.c
+++ b/usr/src/uts/common/io/hook.c
@@ -754,7 +754,7 @@ hook_stack_notify_unregister(netstackid_t stackid, hook_notify_fn_t callback)
 		}
 	} else {
 		/*
-		 * hook_notify_register() should only fail if the callback has
+		 * hook_notify_unregister() should only fail if the callback has
 		 * already been deleted (ESRCH).
 		 */
 		VERIFY3S(error, ==, ESRCH);
diff --git a/usr/src/uts/common/io/mac/mac_soft_ring.c b/usr/src/uts/common/io/mac/mac_soft_ring.c
index c62bd997a8..4655631dc1 100644
--- a/usr/src/uts/common/io/mac/mac_soft_ring.c
+++ b/usr/src/uts/common/io/mac/mac_soft_ring.c
@@ -152,8 +152,8 @@ mac_soft_ring_create(int id, clock_t wait, uint16_t type,
     processorid_t cpuid, mac_direct_rx_t rx_func, void *x_arg1,
     mac_resource_handle_t x_arg2)
 {
-	mac_soft_ring_t 	*ringp;
-	char 			name[S_RING_NAMELEN];
+	mac_soft_ring_t		*ringp;
+	char			name[S_RING_NAMELEN];
 
 	bzero(name, 64);
 	ringp = kmem_cache_alloc(mac_soft_ring_cache, KM_SLEEP);
@@ -353,7 +353,7 @@ mac_rx_soft_ring_drain(mac_soft_ring_t *ringp)
 	mblk_t		*mp;
 	void		*arg1;
 	mac_resource_handle_t arg2;
-	timeout_id_t 	tid;
+	timeout_id_t	tid;
 	mac_direct_rx_t	proc;
 	size_t		sz;
 	int		cnt;
@@ -532,7 +532,7 @@ mac_soft_ring_intr_disable(void *arg)
  * setup.
  */
 mblk_t *
-mac_soft_ring_poll(mac_soft_ring_t *ringp, int bytes_to_pickup)
+mac_soft_ring_poll(mac_soft_ring_t *ringp, size_t bytes_to_pickup)
 {
 	mblk_t	*head, *tail;
 	mblk_t	*mp;
@@ -644,10 +644,10 @@ mac_soft_ring_signal(mac_soft_ring_t *softring, uint_t sr_flag)
 static void
 mac_tx_soft_ring_drain(mac_soft_ring_t *ringp)
 {
-	mblk_t 			*mp;
-	void 			*arg1;
-	void 			*arg2;
-	mblk_t 			*tail;
+	mblk_t			*mp;
+	void			*arg1;
+	void			*arg2;
+	mblk_t			*tail;
 	uint_t			saved_pkt_count, saved_size;
 	mac_tx_stats_t		stats;
 	mac_soft_ring_set_t	*mac_srs = ringp->s_ring_set;
diff --git a/usr/src/uts/common/os/cpu_uarray.c b/usr/src/uts/common/os/cpu_uarray.c
new file mode 100644
index 0000000000..b26b89e61a
--- /dev/null
+++ b/usr/src/uts/common/os/cpu_uarray.c
@@ -0,0 +1,79 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <sys/cpu_uarray.h>
+#include <sys/sysmacros.h>
+#include <sys/cpuvar.h>
+#include <sys/debug.h>
+#include <sys/kmem.h>
+
+static size_t
+cpu_uarray_size(size_t nr_items)
+{
+	size_t size = P2ROUNDUP(nr_items * sizeof (uint64_t), CUA_ALIGN);
+	size *= NCPU;
+	return (sizeof (cpu_uarray_t) + size);
+}
+
+cpu_uarray_t *
+cpu_uarray_zalloc(size_t nr_items, int kmflags)
+{
+	cpu_uarray_t *cua;
+
+	cua = kmem_zalloc(cpu_uarray_size(nr_items), kmflags);
+
+	if (cua != NULL) {
+		VERIFY(IS_P2ALIGNED(cua->cu_vals, CUA_ALIGN));
+		cua->cu_nr_items = nr_items;
+	}
+
+	return (cua);
+}
+
+void
+cpu_uarray_free(cpu_uarray_t *cua)
+{
+	kmem_free(cua, cpu_uarray_size(cua->cu_nr_items));
+}
+
+uint64_t
+cpu_uarray_sum(cpu_uarray_t *cua, size_t index)
+{
+	uint64_t sum = 0;
+
+	VERIFY3U(index, <, cua->cu_nr_items);
+
+	for (size_t c = 0; c < ncpus; c++) {
+		uint64_t addend = CPU_UARRAY_VAL(cua, c, index);
+		sum = UINT64_OVERFLOW_ADD(sum, addend);
+	}
+
+	return (sum);
+}
+
+uint64_t
+cpu_uarray_sum_all(cpu_uarray_t *cua)
+{
+	uint64_t sum = 0;
+
+	for (size_t c = 0; c < ncpus; c++) {
+		for (size_t i = 0; i < cua->cu_nr_items; i++) {
+			uint64_t addend = CPU_UARRAY_VAL(cua, c, i);
+			sum = UINT64_OVERFLOW_ADD(sum, addend);
+		}
+	}
+
+	return (sum);
+}
diff --git a/usr/src/uts/common/os/msacct.c b/usr/src/uts/common/os/msacct.c
index 66994321f7..db3ddd7fc8 100644
--- a/usr/src/uts/common/os/msacct.c
+++ b/usr/src/uts/common/os/msacct.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2012 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -416,16 +416,21 @@ syscall_mstate(int fromms, int toms)
 		newtime = curtime - ms->ms_state_start;
 	}
 	*mstimep += newtime;
-	if (fromms == LMS_USER)
-		atomic_add_64(&z->zone_utime, newtime);
-	else if (fromms == LMS_SYSTEM)
-		atomic_add_64(&z->zone_stime, newtime);
 	t->t_mstate = toms;
 	ms->ms_state_start = curtime;
 	ms->ms_prev = fromms;
 	kpreempt_disable(); /* don't change CPU while changing CPU's state */
 	cpu = CPU;
 	ASSERT(cpu == t->t_cpu);
+
+	if (fromms == LMS_USER) {
+		CPU_UARRAY_VAL(z->zone_ustate, cpu->cpu_id,
+		    ZONE_USTATE_UTIME) += newtime;
+	} else if (fromms == LMS_SYSTEM) {
+		CPU_UARRAY_VAL(z->zone_ustate, cpu->cpu_id,
+		    ZONE_USTATE_STIME) += newtime;
+	}
+
 	if ((toms != LMS_USER) && (cpu->cpu_mstate != CMS_SYSTEM)) {
 		NEW_CPU_MSTATE(CMS_SYSTEM);
 	} else if ((toms == LMS_USER) && (cpu->cpu_mstate != CMS_USER)) {
@@ -652,19 +657,6 @@ new_mstate(kthread_t *t, int new_state)
 	} while (atomic_cas_64((uint64_t *)mstimep, oldtime, newtime) !=
 	    oldtime);
 
-	/*
-	 * When the system boots the initial startup thread will have a
-	 * ms_state_start of 0 which would add a huge system time to the global
-	 * zone.  We want to skip aggregating that initial bit of work.
-	 */
-	if (origstart != 0) {
-		z = ttozone(t);
-		if (state == LMS_USER)
-			atomic_add_64(&z->zone_utime, ztime);
-		else if (state == LMS_SYSTEM)
-			atomic_add_64(&z->zone_stime, ztime);
-	}
-
 	/*
 	 * Remember the previous running microstate.
 	 */
@@ -676,7 +668,25 @@ new_mstate(kthread_t *t, int new_state)
 	 */
 
 	kpreempt_disable(); /* MUST disable kpreempt before touching t->cpu */
+
 	ASSERT(t->t_cpu == CPU);
+
+	/*
+	 * When the system boots the initial startup thread will have a
+	 * ms_state_start of 0 which would add a huge system time to the global
+	 * zone.  We want to skip aggregating that initial bit of work.
+	 */
+	if (origstart != 0) {
+		z = ttozone(t);
+		if (state == LMS_USER) {
+			CPU_UARRAY_VAL(z->zone_ustate, t->t_cpu->cpu_id,
+			    ZONE_USTATE_UTIME) += ztime;
+		} else if (state == LMS_SYSTEM) {
+			CPU_UARRAY_VAL(z->zone_ustate, t->t_cpu->cpu_id,
+			    ZONE_USTATE_STIME) += ztime;
+		}
+	}
+
 	if (!CPU_ON_INTR(t->t_cpu) && curthread->t_intr == NULL) {
 		if (new_state == LMS_USER && t->t_cpu->cpu_mstate != CMS_USER)
 			new_cpu_mstate(CMS_USER, curtime);
@@ -783,7 +793,13 @@ restore_mstate(kthread_t *t)
 	z = ttozone(t);
 	waittime = curtime - waitrq;
 	ms->ms_acct[LMS_WAIT_CPU] += waittime;
-	atomic_add_64(&z->zone_wtime, waittime);
+
+	/*
+	 * We are in a disp context where we're not going to migrate CPUs.
+	 */
+	CPU_UARRAY_VAL(z->zone_ustate, CPU->cpu_id,
+	    ZONE_USTATE_WTIME) += waittime;
+
 	CPU->cpu_waitrq += waittime;
 	ms->ms_state_start = curtime;
 }
diff --git a/usr/src/uts/common/os/zone.c b/usr/src/uts/common/os/zone.c
index 42eba20668..68832a2c75 100644
--- a/usr/src/uts/common/os/zone.c
+++ b/usr/src/uts/common/os/zone.c
@@ -2364,20 +2364,26 @@ zone_misc_kstat_update(kstat_t *ksp, int rw)
 {
 	zone_t *zone = ksp->ks_private;
 	zone_misc_kstat_t *zmp = ksp->ks_data;
-	hrtime_t tmp;
+	hrtime_t hrtime;
+	uint64_t tmp;
 
 	if (rw == KSTAT_WRITE)
 		return (EACCES);
 
-	tmp = zone->zone_utime;
-	scalehrtime(&tmp);
-	zmp->zm_utime.value.ui64 = tmp;
-	tmp = zone->zone_stime;
-	scalehrtime(&tmp);
-	zmp->zm_stime.value.ui64 = tmp;
-	tmp = zone->zone_wtime;
-	scalehrtime(&tmp);
-	zmp->zm_wtime.value.ui64 = tmp;
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_STIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_stime.value.ui64 = hrtime;
+
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_UTIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_utime.value.ui64 = hrtime;
+
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_WTIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_wtime.value.ui64 = hrtime;
 
 	zmp->zm_avenrun1.value.ui32 = zone->zone_avenrun[0];
 	zmp->zm_avenrun5.value.ui32 = zone->zone_avenrun[1];
@@ -2572,9 +2578,6 @@ zone_zsd_init(void)
 	zone0.zone_swapresv_kstat = NULL;
 	zone0.zone_physmem_kstat = NULL;
 	zone0.zone_nprocs_kstat = NULL;
-	zone0.zone_stime = 0;
-	zone0.zone_utime = 0;
-	zone0.zone_wtime = 0;
 
 	zone_pdata[0].zpers_zfsp = &zone0_zp_zfs;
 	zone_pdata[0].zpers_zfsp->zpers_zfs_io_pri = 1;
@@ -2819,6 +2822,8 @@ zone_init(void)
 	 */
 	rw_init(&zone0.zone_mntfs_db_lock, NULL, RW_DEFAULT, NULL);
 
+	zone0.zone_ustate = cpu_uarray_zalloc(ZONE_USTATE_MAX, KM_SLEEP);
+
 	mutex_enter(&zonehash_lock);
 	zone_uniqid(&zone0);
 	ASSERT(zone0.zone_uniqid == GLOBAL_ZONEUNIQID);
@@ -2930,6 +2935,8 @@ zone_free(zone_t *zone)
 	zone_status_set(zone, ZONE_IS_FREE);
 	mutex_exit(&zone_status_lock);
 
+	cpu_uarray_free(zone->zone_ustate);
+
 	if (zone->zone_rootvp != NULL)
 		VN_RELE(zone->zone_rootvp);
 	if (zone->zone_rootpath)
@@ -3750,12 +3757,13 @@ zone_find_by_path(const char *path)
  * Based on loadavg_update(), genloadavg() and calcloadavg() from clock.c.
  */
 void
-zone_loadavg_update()
+zone_loadavg_update(void)
 {
 	zone_t *zp;
 	zone_status_t status;
 	struct loadavg_s *lavg;
 	hrtime_t zone_total;
+	uint64_t tmp;
 	int i;
 	hrtime_t hr_avg;
 	int nrun;
@@ -3780,7 +3788,9 @@ zone_loadavg_update()
 		 */
 		lavg = &zp->zone_loadavg;
 
-		zone_total = zp->zone_utime + zp->zone_stime + zp->zone_wtime;
+		tmp = cpu_uarray_sum_all(zp->zone_ustate);
+		zone_total = UINT64_OVERFLOW_TO_INT64(tmp);
+
 		scalehrtime(&zone_total);
 
 		/* The zone_total should always be increasing. */
@@ -4835,8 +4845,8 @@ zone_set_privset(zone_t *zone, const priv_set_t *zone_privs,
  * Where each element of the nvpair_list_array is of the form:
  *
  * [(name = "privilege", value = RCPRIV_PRIVILEGED),
- * 	(name = "limit", value = uint64_t),
- * 	(name = "action", value = (RCTL_LOCAL_NOACTION || RCTL_LOCAL_DENY))]
+ *	(name = "limit", value = uint64_t),
+ *	(name = "action", value = (RCTL_LOCAL_NOACTION || RCTL_LOCAL_DENY))]
  */
 static int
 parse_rctls(caddr_t ubuf, size_t buflen, nvlist_t **nvlp)
@@ -5131,10 +5141,7 @@ zone_create(const char *zone_name, const char *zone_root,
 	zone->zone_bootargs = NULL;
 	zone->zone_fs_allowed = NULL;
 
-	secflags_zero(&zone0.zone_secflags.psf_lower);
-	secflags_zero(&zone0.zone_secflags.psf_effective);
-	secflags_zero(&zone0.zone_secflags.psf_inherit);
-	secflags_fullset(&zone0.zone_secflags.psf_upper);
+	psecflags_default(&zone->zone_secflags);
 
 	zone->zone_initname =
 	    kmem_alloc(strlen(zone_default_initname) + 1, KM_SLEEP);
@@ -5157,6 +5164,8 @@ zone_create(const char *zone_name, const char *zone_root,
 	    kmem_zalloc(sizeof (zone_zfs_io_t), KM_SLEEP);
 	zone_pdata[zoneid].zpers_zfsp->zpers_zfs_io_pri = 1;
 
+	zone->zone_ustate = cpu_uarray_zalloc(ZONE_USTATE_MAX, KM_SLEEP);
+
 	/*
 	 * Zsched initializes the rctls.
 	 */
diff --git a/usr/src/uts/common/sys/Makefile b/usr/src/uts/common/sys/Makefile
index 787774e03a..498e2ebab3 100644
--- a/usr/src/uts/common/sys/Makefile
+++ b/usr/src/uts/common/sys/Makefile
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright 2014, Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright 2013 Garrett D'Amore <garrett@damore.org>
 # Copyright 2015, Joyent, Inc. All rights reserved.
 # Copyright 2013 Saso Kiselkov. All rights reserved.
@@ -59,7 +59,7 @@ i386_HDRS=			\
 	nvme.h			\
 	ucode.h
 
-sparc_HDRS= 			\
+sparc_HDRS=			\
 	mouse.h			\
 	scsi/targets/ssddef.h	\
 	$(MDESCHDRS)
@@ -138,6 +138,7 @@ CHKHDRS=			\
 	cpc_impl.h		\
 	cpc_pcbe.h		\
 	cpr.h			\
+	cpu_uarray.h		\
 	cpupart.h		\
 	cpuvar.h		\
 	crc32.h			\
@@ -280,7 +281,7 @@ CHKHDRS=			\
 	iapriocntl.h		\
 	ibpart.h		\
 	id32.h			\
-	idmap.h 		\
+	idmap.h			\
 	ieeefp.h		\
 	id_space.h		\
 	inotify.h		\
@@ -714,7 +715,7 @@ BSCHDRS=			\
 
 MDESCHDRS=			\
 	mdesc.h			\
-	mdesc_impl.h		
+	mdesc_impl.h
 
 CPUDRVHDRS=			\
 	cpudrv.h
@@ -777,8 +778,8 @@ RDMAHDRS=		\
 	ib_user_mad.h	\
 	ib_user_sa.h	\
 	ib_user_verbs.h \
-	ib_verbs.h 	\
-	rdma_cm.h 	\
+	ib_verbs.h	\
+	rdma_cm.h	\
 	rdma_user_cm.h
 
 SOL_UVERBSHDRS=		\
diff --git a/usr/src/uts/common/sys/cpu_uarray.h b/usr/src/uts/common/sys/cpu_uarray.h
new file mode 100644
index 0000000000..797d8d8d1e
--- /dev/null
+++ b/usr/src/uts/common/sys/cpu_uarray.h
@@ -0,0 +1,77 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Use a cpu_uarray_t for an array of uint64_t values that are written on a
+ * per-CPU basis.  We align each CPU on a 128-byte boundary (so two cachelines).
+ * It's not clear why, but this can have a significant effect in multi-socket
+ * systems running certain benchmarks on a relatively current Intel system.
+ *
+ * So the layout is like this, for example:
+ *
+ * 0:	STAT1 for CPU 0
+ * 8:	STAT2 for CPU 0
+ * 16:	STAT3 for CPU 0
+ * 24:	padding
+ * 128: STAT1 for CPU 1
+ * 136: STAT2 for CPU 1
+ * ...
+ *
+ * At collection time, cpu_uarray_sum() can be used to sum the given value index
+ * across all CPUs, or cpu_uarray_sum_all() sums all stats across all CPUs.
+ * The summation is done such that it saturates at UINT64_MAX.
+ */
+
+#ifndef	_SYS_CPU_UARRAY_H
+#define	_SYS_CPU_UARRAY_H
+
+#include <sys/types.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifdef _KERNEL
+
+/*
+ * Trying to include sysmacros.h for P2ROUNDUP() here is just too painful.
+ */
+#define	CUA_ROUNDUP(x, align) (-(-(x) & -(align)))
+#define	CUA_ALIGN (128)
+#define	CUA_CPU_STRIDE(nr_items) \
+	CUA_ROUNDUP((nr_items), CUA_ALIGN / sizeof (uint64_t))
+#define	CUA_INDEX(nr_items, c, i) (((c) * CUA_CPU_STRIDE(nr_items)) + (i))
+
+#define	CPU_UARRAY_VAL(cua, cpu_index, stat_index) \
+	((cua)->cu_vals[CUA_INDEX((cua)->cu_nr_items, cpu_index, stat_index)])
+
+typedef struct {
+	uint64_t cu_nr_items;
+	char cu_pad[CUA_ALIGN - sizeof (uint64_t)];
+	volatile uint64_t cu_vals[];
+} cpu_uarray_t __aligned(CUA_ALIGN);
+
+extern cpu_uarray_t *cpu_uarray_zalloc(size_t, int);
+extern void cpu_uarray_free(cpu_uarray_t *);
+extern uint64_t cpu_uarray_sum(cpu_uarray_t *, size_t);
+extern uint64_t cpu_uarray_sum_all(cpu_uarray_t *);
+
+#endif /* _KERNEL */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SYS_CPU_UARRAY_H */
diff --git a/usr/src/uts/common/sys/mac.h b/usr/src/uts/common/sys/mac.h
index 6af2e0bccb..afe554ba03 100644
--- a/usr/src/uts/common/sys/mac.h
+++ b/usr/src/uts/common/sys/mac.h
@@ -406,7 +406,7 @@ typedef enum {
 typedef void		(*mac_notify_t)(void *, mac_notify_type_t);
 typedef void		(*mac_rx_t)(void *, mac_resource_handle_t, mblk_t *,
 			    boolean_t);
-typedef	mblk_t		*(*mac_receive_t)(void *, int);
+typedef	mblk_t		*(*mac_receive_t)(void *, size_t);
 
 /*
  * MAC resource types
@@ -673,7 +673,7 @@ extern uint_t			mac_addr_len(mac_handle_t);
 extern int			mac_type(mac_handle_t);
 extern int			mac_nativetype(mac_handle_t);
 
-extern void 			mac_unicst_update(mac_handle_t,
+extern void			mac_unicst_update(mac_handle_t,
 				    const uint8_t *);
 extern void			mac_capab_update(mac_handle_t);
 extern int			mac_pdata_update(mac_handle_t, void *,
diff --git a/usr/src/uts/common/sys/mac_soft_ring.h b/usr/src/uts/common/sys/mac_soft_ring.h
index e96c41ae91..581e18d06e 100644
--- a/usr/src/uts/common/sys/mac_soft_ring.h
+++ b/usr/src/uts/common/sys/mac_soft_ring.h
@@ -183,7 +183,7 @@ typedef struct mac_srs_rx_s {
 	 */
 	mac_direct_rx_t		sr_func;	/* srs_lock */
 	void			*sr_arg1;	/* srs_lock */
-	mac_resource_handle_t 	sr_arg2;	/* srs_lock */
+	mac_resource_handle_t	sr_arg2;	/* srs_lock */
 	mac_rx_func_t		sr_lower_proc;	/* Atomically changed */
 	uint32_t		sr_poll_pkt_cnt;
 	uint32_t		sr_poll_thres;
@@ -386,7 +386,7 @@ struct mac_soft_ring_set_s {
 /*
  * type flags - combination allowed to process and drain the queue
  */
-#define	ST_RING_WORKER_ONLY  	0x0001	/* Worker thread only */
+#define	ST_RING_WORKER_ONLY	0x0001	/* Worker thread only */
 #define	ST_RING_ANY		0x0002	/* Any thread can process the queue */
 #define	ST_RING_TCP		0x0004
 #define	ST_RING_UDP		0x0008
@@ -540,7 +540,7 @@ extern struct dls_kstats dls_kstat;
 }
 
 #define	MAC_COUNT_CHAIN(mac_srs, head, tail, cnt, sz)	{	\
-	mblk_t 		*tmp;		       			\
+	mblk_t		*tmp;					\
 	boolean_t	bw_ctl = B_FALSE;			\
 								\
 	ASSERT((head) != NULL);					\
@@ -579,12 +579,12 @@ extern struct dls_kstats dls_kstat;
 	ASSERT(MUTEX_HELD(&(mac_srs)->srs_lock));			\
 									\
 	srs_rx->sr_poll_pkt_cnt -= cnt;					\
-	if ((srs_rx->sr_poll_pkt_cnt <= srs_rx->sr_poll_thres) && 	\
-		(((mac_srs)->srs_state &				\
-		(SRS_POLLING|SRS_PROC|SRS_GET_PKTS)) == SRS_POLLING))	\
+	if ((srs_rx->sr_poll_pkt_cnt <= srs_rx->sr_poll_thres) &&	\
+	    (((mac_srs)->srs_state &					\
+	    (SRS_POLLING|SRS_PROC|SRS_GET_PKTS)) == SRS_POLLING))	\
 	{								\
 		(mac_srs)->srs_state |= (SRS_PROC|SRS_GET_PKTS);	\
-		cv_signal(&(mac_srs)->srs_cv); 				\
+		cv_signal(&(mac_srs)->srs_cv);				\
 		srs_rx->sr_below_hiwat++;				\
 	}								\
 }
@@ -639,7 +639,7 @@ extern void mac_fanout_setup(mac_client_impl_t *, flow_entry_t *,
 
 extern void mac_soft_ring_worker_wakeup(mac_soft_ring_t *);
 extern void mac_soft_ring_blank(void *, time_t, uint_t, int);
-extern mblk_t *mac_soft_ring_poll(mac_soft_ring_t *, int);
+extern mblk_t *mac_soft_ring_poll(mac_soft_ring_t *, size_t);
 extern void mac_soft_ring_destroy(mac_soft_ring_t *);
 extern void mac_soft_ring_dls_bypass(void *, mac_direct_rx_t, void *);
 
diff --git a/usr/src/uts/common/sys/sysmacros.h b/usr/src/uts/common/sys/sysmacros.h
index 6f5882b54b..5dc6eee0ec 100644
--- a/usr/src/uts/common/sys/sysmacros.h
+++ b/usr/src/uts/common/sys/sysmacros.h
@@ -373,6 +373,19 @@ extern unsigned char bcd_to_byte[256];
 #define	ARRAY_SIZE(x)	(sizeof (x) / sizeof (x[0]))
 #endif
 
+/*
+ * Add a value to a uint64_t that saturates at UINT64_MAX instead of wrapping
+ * around.
+ */
+#define	UINT64_OVERFLOW_ADD(val, add) \
+	((val) > ((val) + (add)) ? (UINT64_MAX) : ((val) + (add)))
+
+/*
+ * Convert to an int64, saturating at INT64_MAX.
+ */
+#define	UINT64_OVERFLOW_TO_INT64(uval) \
+	(((uval) > INT64_MAX) ? INT64_MAX : (int64_t)(uval))
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/uts/common/sys/zone.h b/usr/src/uts/common/sys/zone.h
index 678dd4e029..845f20a46f 100644
--- a/usr/src/uts/common/sys/zone.h
+++ b/usr/src/uts/common/sys/zone.h
@@ -42,6 +42,7 @@
 #include <sys/socket_impl.h>
 #include <sys/secflags.h>
 #include <netinet/in.h>
+#include <sys/cpu_uarray.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -353,6 +354,15 @@ typedef struct zone_net_data {
 
 #define	GLOBAL_ZONEUNIQID	0	/* uniqid of the global zone */
 
+/*
+ * Indexes into ->zone_ustate array, summing the micro state of all threads in a
+ * particular zone.
+ */
+#define	ZONE_USTATE_STIME (0)
+#define	ZONE_USTATE_UTIME (1)
+#define	ZONE_USTATE_WTIME (2)
+#define	ZONE_USTATE_MAX (3)
+
 struct pool;
 struct brand;
 
@@ -429,7 +439,7 @@ typedef struct {
 	kstat_named_t	zv_100ms_ops;
 	kstat_named_t	zv_1s_ops;
 	kstat_named_t	zv_10s_ops;
-	kstat_named_t 	zv_delay_cnt;
+	kstat_named_t	zv_delay_cnt;
 	kstat_named_t	zv_delay_time;
 } zone_vfs_kstat_t;
 
@@ -502,13 +512,13 @@ typedef struct zone {
 					/* if not emulated */
 	/*
 	 * zone_lock protects the following fields of a zone_t:
-	 * 	zone_ref
-	 * 	zone_cred_ref
-	 * 	zone_subsys_ref
-	 * 	zone_ref_list
-	 * 	zone_ntasks
-	 * 	zone_flags
-	 * 	zone_zsd
+	 *	zone_ref
+	 *	zone_cred_ref
+	 *	zone_subsys_ref
+	 *	zone_ref_list
+	 *	zone_ntasks
+	 *	zone_flags
+	 *	zone_zsd
 	 *	zone_pfexecd
 	 */
 	kmutex_t	zone_lock;
@@ -616,7 +626,7 @@ typedef struct zone {
 	boolean_t	zone_restart_init_0;	/* Restart only if it exits 0 */
 	boolean_t	zone_setup_app_contract; /* setup contract? */
 	struct brand	*zone_brand;		/* zone's brand */
-	void 		*zone_brand_data;	/* store brand specific data */
+	void		*zone_brand_data;	/* store brand specific data */
 	id_t		zone_defaultcid;	/* dflt scheduling class id */
 	boolean_t	zone_fixed_hipri;	/* fixed sched. hi prio */
 	kstat_t		*zone_swapresv_kstat;
@@ -678,22 +688,12 @@ typedef struct zone {
 
 	/*
 	 * Misc. kstats and counters for zone cpu-usage aggregation.
-	 * The zone_Xtime values are the sum of the micro-state accounting
-	 * values for all threads that are running or have run in the zone.
-	 * This is tracked in msacct.c as threads change state.
-	 * The zone_stime is the sum of the LMS_SYSTEM times.
-	 * The zone_utime is the sum of the LMS_USER times.
-	 * The zone_wtime is the sum of the LMS_WAIT_CPU times.
-	 * As with per-thread micro-state accounting values, these values are
-	 * not scaled to nanosecs.  The scaling is done by the
-	 * zone_misc_kstat_update function when kstats are requested.
 	 */
 	kmutex_t	zone_misc_lock;		/* protects misc statistics */
 	kstat_t		*zone_misc_ksp;
 	zone_misc_kstat_t *zone_misc_stats;
-	uint64_t	zone_stime;		/* total system time */
-	uint64_t	zone_utime;		/* total user time */
-	uint64_t	zone_wtime;		/* total time waiting in runq */
+	/* Accumulated microstate for all threads in this zone. */
+	cpu_uarray_t	*zone_ustate;
 	/* fork-fail kstat tracking */
 	uint32_t	zone_ffcap;		/* hit an rctl cap */
 	uint32_t	zone_ffnoproc;		/* get proc/lwp error */
@@ -825,7 +825,7 @@ typedef uint_t zone_key_t;
 
 extern void	zone_key_create(zone_key_t *, void *(*)(zoneid_t),
     void (*)(zoneid_t, void *), void (*)(zoneid_t, void *));
-extern int 	zone_key_delete(zone_key_t);
+extern int	zone_key_delete(zone_key_t);
 extern void	*zone_getspecific(zone_key_t, zone_t *);
 extern int	zone_setspecific(zone_key_t, zone_t *, const void *);
 
@@ -851,7 +851,7 @@ struct zsd_entry {
 	void			(*zsd_shutdown)(zoneid_t, void *);
 	void			(*zsd_destroy)(zoneid_t, void *);
 	list_node_t		zsd_linkage;
-	uint16_t 		zsd_flags;	/* See below */
+	uint16_t		zsd_flags;	/* See below */
 	kcondvar_t		zsd_cv;
 };
 
-- 
2.21.0

