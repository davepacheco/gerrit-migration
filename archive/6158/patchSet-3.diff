commit fbd7a47645c155f39010e7f19ebde9a26e3bafcd
Author: Robert Bogart <robert.bogart@joyent.com>
Date:   2019-04-24T22:19:47+00:00 (6 months ago)
    
    MANTA-4238 Implement low water level mark for GC flushing

diff --git a/README.md b/README.md
index 32d108d..e4f8126 100644
--- a/README.md
+++ b/README.md
@@ -170,8 +170,14 @@ accel-gc` attempts to help with these decisions -- see
 
 ### Instruction Upload
 
-* `GC_INSTR_UPLOAD_BATCH_SIZE` - The number of delete instructions (lines) to
-  include per instruction object.
+* `GC_INSTR_UPLOAD_MIN_BATCH_SIZE` - The minimum number of delete instructions
+  (lines) to include per instruction object.  This ensures that instruction
+  files can never have less than a pre-configured number of lines.  This is
+  important because performance on the mako side will deteriorate with
+  numerous, small instruction files to process.
+* `GC_INSTR_UPLOAD_BATCH_SIZE` - The maximum number of delete instructions
+  (lines) to include per instruction object.  Note that there is no guarantee
+  that all instruction files will reach this size.
 * `GC_INSTR_UPLOAD_FLUSH_DELAY` - The number of milliseconds to wait between
   attempt to upload an instruction object.
 * `GC_INSTR_UPLOAD_PATH_PREFIX` - The location in which to upload delete
@@ -194,6 +200,15 @@ accel-gc` attempts to help with these decisions -- see
 Each of these SAPI values can be overridden in the instance object of a single
 collector.
 
+### Example of how to set a tunable parameter
+
+The following example will set the instruction upload batch size to 300:
+
+```
+GCID=$(sdc-sapi /services?name=garbage-collector | json -Ha uuid)
+echo '{ "metadata": {"GC_INSTR_UPLOAD_BATCH_SIZE": 300 } }' | sapiadm update $GCID
+```
+
 # Metrics
 
 The garbage collector exposes a number of application-level metrics, in addition
diff --git a/lib/delete_record_transformer.js b/lib/delete_record_transformer.js
index 5379a60..04bef63 100644
--- a/lib/delete_record_transformer.js
+++ b/lib/delete_record_transformer.js
@@ -83,6 +83,13 @@ _get_collector()
 };
 
 
+DeleteRecordTransformer.prototype._get_min_batch_size = function
+_get_min_batch_size()
+{
+	return (this._get_tunables_ref().instr_upload_min_batch_size);
+};
+
+
 DeleteRecordTransformer.prototype._get_batch_size = function
 _get_batch_size()
 {
@@ -233,7 +240,12 @@ _process_record(record, done)
 				self._incr_cache_counts();
 			}
 
-
+			/*
+			 * If a given shark has reached (or exceeded) the
+			 * upload batch size, add it to the list of sharks
+			 * that will be flushed immediately (i.e. outside of
+			 * the periodic / regularly scheduled flush).
+			 */
 			if (Object.keys(cache[storage_id]).length >=
 			    self._get_batch_size()) {
 				sharks.push(storage_id);
@@ -245,7 +257,12 @@ _process_record(record, done)
 	});
 };
 
-
+/*
+ * Flush cached instructions from memory out to storage.  This function can be
+ * called either during a periodic flush or if  any given storage node
+ * accumulates a number of instructions greater than or equal to the upload
+ * batch size.
+ */
 DeleteRecordTransformer.prototype._flush = function
 _flush(storage_ids, done)
 {
@@ -279,7 +296,22 @@ _flush(storage_ids, done)
 				return (self.mt_cache[storage_id][key]);
 			});
 
-			if ((lines || []).length === 0) {
+			/*
+			 * In order to ensure that instruction files maintain
+			 * at least a minimum number of lines, we will not
+			 * perform a periodic flush unless the mako has
+			 * accumulated at least a certain amount of lines.
+			 * What exactly the floor is is dictated by the
+			 * configuration information passed to us, tunable
+			 * through SAPI.
+			 */
+			if ((lines || []).length < self._get_min_batch_size()) {
+				self.mt_log.info({
+					storage_id: storage_id,
+					lines: lines.length
+				}, 'Skipping flush.  Mako has less than the ' +
+				'minimum number of lines required.');
+
 				finished();
 				return;
 			}
@@ -403,10 +435,19 @@ _listen_for_records()
 				});
 				return;
 			}
-			if (sharks.length === 0) {
-				self.mt_log.info('Skipping no-op flush.');
+
+			/*
+			 * If the list of sharks that have reached their batch
+			 * size is empty, then return.
+			 */
+			if (sharks.length === 0)
 				return;
-			}
+
+			/*
+			 * Perform a flush on all sharks that have accumulated
+			 * a number of instructions greater than or equal to our
+			 * upload batch size.
+			 */
 			self._flush(sharks, function (ferr) {
 				if (ferr) {
 					self.mt_log.warn({
diff --git a/lib/schema.js b/lib/schema.js
index 20c9136..077705a 100644
--- a/lib/schema.js
+++ b/lib/schema.js
@@ -35,6 +35,10 @@ var SORT_ORDERS = [
 ];
 
 var tunables_cfg_properties = {
+	'instr_upload_min_batch_size': {
+		'type': 'integer',
+		'minimum': 1
+	},
 	'instr_upload_batch_size': {
 		'type': 'integer',
 		'minimum': 1
diff --git a/sapi_manifests/manta-garbage-collector/template b/sapi_manifests/manta-garbage-collector/template
index e666713..2aa89df 100644
--- a/sapi_manifests/manta-garbage-collector/template
+++ b/sapi_manifests/manta-garbage-collector/template
@@ -51,6 +51,7 @@
 		}{{^last}},{{/last}}{{/ACCOUNTS_SNAPLINKS_DISABLED}}
 	],
 	"tunables": {
+		"instr_upload_min_batch_size": {{GC_INSTR_UPLOAD_MIN_BATCH_SIZE}},
 		"instr_upload_batch_size": {{GC_INSTR_UPLOAD_BATCH_SIZE}},
 		"instr_upload_flush_delay": {{GC_INSTR_UPLOAD_FLUSH_DELAY}},
 		"instr_upload_path_prefix": "{{GC_INSTR_UPLOAD_PATH_PREFIX}}",
