commit 5b05ed0b1185bd3505307404943d6f836668c993 (refs/changes/09/2509/2)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-09-07T20:33:40+00:00 (2 years, 1 month ago)
    
    OS-6276 lx set TCP_KEEPINTVL fails

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_socket.c b/usr/src/uts/common/brand/lx/syscall/lx_socket.c
index 81e39199cf..2f162604e6 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_socket.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_socket.c
@@ -2866,6 +2866,8 @@ lx_setsockopt_tcp(sonode_t *so, int optname, void *optval, socklen_t optlen)
 {
 	int error;
 	lx_proto_opts_t sockopts_tbl = PROTO_SOCKOPTS(ltos_tcp_sockopts);
+	uint32_t rto_max, abrt_thresh;
+	boolean_t abrt_changed = B_FALSE, rto_max_changed = B_FALSE;
 
 	if (optname == LX_TCP_DEFER_ACCEPT) {
 		int *intval;
@@ -2909,8 +2911,77 @@ lx_setsockopt_tcp(sonode_t *so, int optname, void *optval, socklen_t optlen)
 		return (ENOPROTOOPT);
 	}
 
+	if (optname == TCP_KEEPINTVL) {
+		/*
+		 * When setting TCP_KEEPINTVL there is an unfortunate set of
+		 * dependencies. TCP_KEEPINTVL must be <= TCP_RTO_MAX and
+		 * TCP_RTO_MAX must be <= TCP_ABORT_THRESHOLD. Thus, we may
+		 * have to increase one or both of these in order to increase
+		 * TCP_KEEPINTVL. Note that TCP_KEEPINTVL is passed in seconds
+		 * but TCP_RTO_MAX and TCP_ABORT_THRESHOLD are in milliseconds.
+		 */
+		uint32_t new_val = *(uint_t *)optval * 1000;
+		uint32_t len;
+
+		/*
+		 * Linux limits this to 32k, so we do too. However, anything
+		 * over 2 hours (7200000 ms) will fail anyway due to the
+		 * system-wide default (see "_rexmit_interval_max" in
+		 * tcp_tunables.c). Our 2 hour default seems reasonable as a
+		 * practical limit for now.
+		 */
+		if (*(uint_t *)optval > 32768)
+			return (EINVAL);
+
+		len = sizeof (rto_max);
+		if ((error = socket_getsockopt(so, IPPROTO_TCP, TCP_RTO_MAX,
+		    &rto_max, &len, 0, CRED())) != 0)
+			return (error);
+		len = sizeof (abrt_thresh);
+		if ((error = socket_getsockopt(so, IPPROTO_TCP,
+		    TCP_ABORT_THRESHOLD, &abrt_thresh, &len, 0,
+		    CRED())) != 0)
+			return (error);
+
+		if (new_val > abrt_thresh) {
+			error = socket_setsockopt(so, IPPROTO_TCP,
+			    TCP_ABORT_THRESHOLD, &new_val, sizeof (new_val),
+			    CRED());
+			if (error != 0)
+				goto fail;
+			abrt_changed = B_TRUE;
+		}
+		if (new_val > rto_max) {
+			error = socket_setsockopt(so, IPPROTO_TCP,
+			    TCP_RTO_MAX, &new_val, sizeof (new_val), CRED());
+			if (error != 0)
+				goto fail;
+			rto_max_changed = B_TRUE;
+		}
+	}
+
 	error = socket_setsockopt(so, IPPROTO_TCP, optname, optval, optlen,
 	    CRED());
+
+fail:
+	if (error != 0 && optname == TCP_KEEPINTVL) {
+		/*
+		 * If changing TCP_KEEPINTVL failed then we may need to
+		 * restore the previous values for TCP_ABORT_THRESHOLD and
+		 * TCP_RTO_MAX.
+		 */
+		if (rto_max_changed) {
+			(void) socket_setsockopt(so, IPPROTO_TCP,
+			    TCP_RTO_MAX, &rto_max,
+			    sizeof (rto_max), CRED());
+		}
+		if (abrt_changed) {
+			(void) socket_setsockopt(so, IPPROTO_TCP,
+			    TCP_ABORT_THRESHOLD, &abrt_thresh,
+			    sizeof (abrt_thresh), CRED());
+		}
+	}
+
 	return (error);
 }
 
