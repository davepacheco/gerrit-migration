From ca6f568bc76d721f1ed8a29f2fafb48378794f6e Mon Sep 17 00:00:00 2001
From: Sam Gwydir <sam.gwydir@joyent.com>
Date: Fri, 14 Jul 2017 18:16:00 +0000
Subject: [PATCH] OS-6239 Work around smap_disable ROP exploit

---
 usr/src/uts/common/krtld/kobj.c            | 39 ++++++++++++++++++
 usr/src/uts/common/os/modctl.c             | 15 +++++--
 usr/src/uts/common/sys/kobj.h              |  8 ++++
 usr/src/uts/common/sys/sdt.h               |  6 +++
 usr/src/uts/i86pc/Makefile.rules           |  5 +++
 usr/src/uts/i86pc/os/startup.c             |  9 ++++-
 usr/src/uts/intel/amd64/krtld/kobj_reloc.c | 46 ++++++++++++++++++++++
 usr/src/uts/intel/ia32/ml/copy.s           | 31 ---------------
 usr/src/uts/intel/sys/archsystm.h          |  4 +-
 9 files changed, 124 insertions(+), 39 deletions(-)

diff --git a/usr/src/uts/common/krtld/kobj.c b/usr/src/uts/common/krtld/kobj.c
index 90303d496b..6b703727d8 100644
--- a/usr/src/uts/common/krtld/kobj.c
+++ b/usr/src/uts/common/krtld/kobj.c
@@ -3032,8 +3032,14 @@ do_symbols(struct module *mp, Elf64_Addr bss_base)
 		if (sp->st_shndx == SHN_UNDEF) {
 			resolved = 0;
 
+			/* skip over sdt probes and smap calls, 
+			 * they're relocated later 
+			 */
 			if (strncmp(name, sdt_prefix, strlen(sdt_prefix)) == 0)
 				continue;
+			if (strcmp(name, "smap_enable") == 0 || 
+					strcmp(name, "smap_disable") == 0)
+				continue;
 
 			/*
 			 * If it's not a weak reference and it's
@@ -4666,3 +4672,36 @@ kobj_is_compressed(intptr_t fd)
 
 	return (0);
 }
+
+#define	NOP_INSTR	0x90
+
+// Inline function call stubs stored inside module struct
+// Used to inline calls to smap_enable() and smap_disable() inside dtrace
+// Calls inside the "unix" module are relocated earlier inside startup.c
+// Currently b0-b3 are specified by inst, and the last nop cannot be changed
+//
+// |------+-------+-------+-----+-----|
+// | b0   | b1    | b2    | b3  | b4  |
+// |------+-------+-------+-----+-----|
+// |             inst           | nop |
+// |------+-------+-------+-----+-----|
+//
+void
+kobj_inline_stub(struct module *mp, char *symname, uint32_t inst)
+{
+	stubcall_desc_t *stubcall;
+	uint8_t nop = NOP_INSTR;
+
+	for(stubcall = mp->stubcalls; stubcall != NULL; stubcall = stubcall->stubcall_next) {
+		if (strcmp(stubcall->symname, symname) == 0) {
+			// Because we want to replace the call itself
+			// we must backup one instruction to write over the call
+			uint8_t *instp = ((uint8_t *)stubcall->instr_offset) - 1;
+
+			// Calls are 5 bytes wide
+			// 5 = 1 byte for call, 4 bytes for address
+			bcopy(&inst, instp, 4);
+			bcopy(&nop, instp+4, 1);
+		}
+	}
+}
diff --git a/usr/src/uts/common/os/modctl.c b/usr/src/uts/common/os/modctl.c
index 35162eb558..1575bfb682 100644
--- a/usr/src/uts/common/os/modctl.c
+++ b/usr/src/uts/common/os/modctl.c
@@ -76,6 +76,7 @@
 #include <sys/fs/dv_node.h>
 #include <sys/strsubr.h>
 #include <sys/fs/sdev_impl.h>
+#include <sys/x86_archext.h>
 
 static int		mod_circdep(struct modctl *);
 static int		modinfo(modid_t, struct modinfo *);
@@ -3469,16 +3470,22 @@ mod_load(struct modctl *mp, int usepath)
 		retval = install_stubs_by_name(mp, mp->mod_modname);
 
 		/*
-		 * Now that the module is loaded, we need to give DTrace
-		 * a chance to notify its providers.  This is done via
+		 * Now that the module is loaded, we can inline function
+		 * calls as requested. In addition, we need to give DTrace
+		 * a chance to notify its providers. This is done via
 		 * the dtrace_modload function pointer.
 		 */
 		if (strcmp(mp->mod_modname, "dtrace") != 0) {
 			struct modctl *dmp = mod_hold_by_name("dtrace");
 
-			if (dmp != NULL && dtrace_modload != NULL)
+			if (dmp != NULL && dtrace_modload != NULL) {
+				// On AMD64 this is where we inline calls to enable/disable smap
+				if (is_x86_feature(x86_featureset, X86FSET_SMAP) == B_TRUE) {
+					kobj_inline_stub(dmp->mod_mp, "smap_enable", SMAP_CLAC_INSTR);
+					kobj_inline_stub(dmp->mod_mp, "smap_disable", SMAP_STAC_INSTR);
+				}
 				(*dtrace_modload)(mp);
-
+			}
 			mod_release_mod(dmp);
 		}
 
diff --git a/usr/src/uts/common/sys/kobj.h b/usr/src/uts/common/sys/kobj.h
index 8537430ed0..cdf0a5572f 100644
--- a/usr/src/uts/common/sys/kobj.h
+++ b/usr/src/uts/common/sys/kobj.h
@@ -39,6 +39,11 @@
 extern "C" {
 #endif
 
+// TODO(SAM): these probably don't go here
+#define	NOP_INSTR	0x90
+#define	SMAP_CLAC_INSTR	0x90ca010f
+#define	SMAP_STAC_INSTR	0x90cb010f
+
 /*
  * List of modules maintained by kobj.c
  */
@@ -99,6 +104,8 @@ struct module {
 	caddr_t textwin;
 	caddr_t textwin_base;
 
+	stubcall_desc_t *stubcalls;
+
 	sdt_probedesc_t *sdt_probes;
 	size_t sdt_nprobes;
 	char *sdt_tab;
@@ -187,6 +194,7 @@ extern int kobj_read_file(struct _buf *, char *, unsigned, unsigned);
 extern int kobj_get_filesize(struct _buf *, uint64_t *size);
 extern uintptr_t kobj_getelfsym(char *, void *, int *);
 extern void kobj_set_ctf(struct module *, caddr_t data, size_t size);
+extern void kobj_inline_stub(struct module *, char *, uint32_t);
 
 extern int kobj_filbuf(struct _buf *);
 extern void kobj_sync(void);
diff --git a/usr/src/uts/common/sys/sdt.h b/usr/src/uts/common/sys/sdt.h
index 6cbbe856bb..315d70fd14 100644
--- a/usr/src/uts/common/sys/sdt.h
+++ b/usr/src/uts/common/sys/sdt.h
@@ -432,6 +432,12 @@ typedef struct sdt_probedesc {
 	struct sdt_probedesc	*sdpd_next;	/* next static probe */
 } sdt_probedesc_t;
 
+typedef struct stubcall_desc {
+	char			*symname;	/* symbol name */
+	unsigned long		instr_offset;	/* offset of call in text */
+	struct stubcall_desc	*stubcall_next;	/* next smap call */
+} stubcall_desc_t;
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/uts/i86pc/Makefile.rules b/usr/src/uts/i86pc/Makefile.rules
index a3bf823c69..2892573f05 100644
--- a/usr/src/uts/i86pc/Makefile.rules
+++ b/usr/src/uts/i86pc/Makefile.rules
@@ -329,6 +329,11 @@ $(OBJS_DIR)/dtracestubs.s:	$(UNIX_O) $(LIBS)
 	    $(UNIQ) | $(AWK) '{ \
 	    printf("\t.globl %s\n\t.type %s,@function\n%s:\n", \
 	    $$1, $$1, $$1); }' > $(OBJS_DIR)/dtracestubs.s
+# TODO(SAM): I'm not sure I like placing this here...it seems sort of surprising
+	$(NM) -u $(UNIX_O) $(LIBS) | $(EGREP) 'smap_(disable|enable)' | $(SORT) | \
+	    $(UNIQ) | $(AWK) '{ \
+	    printf("\t.globl %s\n\t.type %s,@function\n%s:\n", \
+	    $$1, $$1, $$1); }' >> $(OBJS_DIR)/dtracestubs.s
 
 $(DTRACESTUBS):	$(DTRACESTUBS_O)
 	$(BUILD.SO) $(DTRACESTUBS_O)
diff --git a/usr/src/uts/i86pc/os/startup.c b/usr/src/uts/i86pc/os/startup.c
index 16c683d993..cd032c5f21 100644
--- a/usr/src/uts/i86pc/os/startup.c
+++ b/usr/src/uts/i86pc/os/startup.c
@@ -727,8 +727,13 @@ startup_smap(void)
 		hot_patch_kernel_text((caddr_t)instp, inst, 4);
 	}
 
-	hot_patch_kernel_text((caddr_t)smap_enable, SMAP_CLAC_INSTR, 4);
-	hot_patch_kernel_text((caddr_t)smap_disable, SMAP_STAC_INSTR, 4);
+	// relocate calls to smap_enable and smap_disable within unix module
+	// relocations for dtrace are done later inside modctl.c
+	struct modctl *modp = mod_hold_by_name("unix");
+	kobj_inline_stub(modp->mod_mp, "smap_enable", SMAP_CLAC_INSTR);
+	kobj_inline_stub(modp->mod_mp, "smap_disable", SMAP_STAC_INSTR);
+	mod_release_mod(modp);
+
 	setcr4(getcr4() | CR4_SMAP);
 	smap_enable();
 }
diff --git a/usr/src/uts/intel/amd64/krtld/kobj_reloc.c b/usr/src/uts/intel/amd64/krtld/kobj_reloc.c
index 56c8087baa..a9e6ea6422 100644
--- a/usr/src/uts/intel/amd64/krtld/kobj_reloc.c
+++ b/usr/src/uts/intel/amd64/krtld/kobj_reloc.c
@@ -119,6 +119,47 @@ sdt_reloc_resolve(struct module *mp, char *symname, uint8_t *instr)
 	return (0);
 }
 
+#define	SMAP_NOPS	5 // 5 = 1 Byte Call + 4 Byte Address
+
+static int
+smap_replace(struct module *mp, char *symname, uint8_t *instr)
+{
+	int i;
+	uint8_t nop = NOP_INSTR;
+	stubcall_desc_t *sid;
+
+	/* Bail out early if our symbol doesn't begin with smap_ */
+	if (strncmp(symname, "smap_", 5) != 0)
+		return (1);
+
+	if (strcmp(symname, "smap_enable") == 0 || 
+			strcmp(symname, "smap_disable") == 0) {
+
+#ifdef	KOBJ_DEBUG
+		if (kobj_debug & D_RELOCATIONS) {
+			_kobj_printf(ops, "smap_replace: %s relocating " 
+					"enable/disable_smap\n",
+					mp->filename);
+		}
+#endif
+
+		sid = kobj_alloc(sizeof (stubcall_desc_t), KM_WAIT);
+		sid->symname = kobj_alloc(strlen(symname) + 1, KM_WAIT);
+		bcopy(symname, sid->symname, strlen(symname) + 1);
+
+		sid->instr_offset = (uintptr_t)instr;
+		sid->stubcall_next = mp->stubcalls;
+		mp->stubcalls = sid;
+
+		for (i = 0; i < SMAP_NOPS; i++) 
+			bcopy(&nop, (instr - 1)+i, 1);
+
+		return (0);
+	}
+
+	return (1);
+}
+
 int
 /* ARGSUSED2 */
 do_relocate(struct module *mp, char *reltbl, Word relshtype, int nreloc,
@@ -222,6 +263,11 @@ do_relocate(struct module *mp, char *reltbl, Word relshtype, int nreloc,
 				    symref->st_name, (uint8_t *)off) == 0)
 					continue;
 
+				if (symref->st_shndx == SHN_UNDEF &&
+				    smap_replace(mp, mp->strings + symref->st_name,
+				     (uint8_t *)off) == 0)
+					continue;
+
 				if (symref->st_shndx == SHN_UNDEF &&
 				    tnf_reloc_resolve(mp->strings +
 				    symref->st_name, &symref->st_value,
diff --git a/usr/src/uts/intel/ia32/ml/copy.s b/usr/src/uts/intel/ia32/ml/copy.s
index 7593de374e..fe820d3d09 100644
--- a/usr/src/uts/intel/ia32/ml/copy.s
+++ b/usr/src/uts/intel/ia32/ml/copy.s
@@ -3148,37 +3148,6 @@ ucopystr(const char *ufrom, char *uto, size_t umaxlength, size_t *lencopied)
  * out of paranoia, the kernel will likely call it at several points.
  */
 
-#if defined(__lint)
-
-void
-smap_enable(void)
-{}
-
-void
-smap_disable(void)
-{}
-
-#else
-
-#if defined (__amd64) || defined(__i386)
-	ENTRY(smap_disable)
-	nop
-	nop
-	nop
-	ret
-	SET_SIZE(smap_disable)
-
-	ENTRY(smap_enable)
-	nop
-	nop
-	nop
-	ret
-	SET_SIZE(smap_enable)
-
-#endif /* __amd64 || __i386 */
-
-#endif /* __lint */
-
 #ifndef __lint
 
 .data
diff --git a/usr/src/uts/intel/sys/archsystm.h b/usr/src/uts/intel/sys/archsystm.h
index 9cfd83a334..c113d09337 100644
--- a/usr/src/uts/intel/sys/archsystm.h
+++ b/usr/src/uts/intel/sys/archsystm.h
@@ -189,8 +189,8 @@ extern void *plat_traceback(void *);
  * up the valid instructions. For more information on SMAP, see
  * uts/intel/ia32/ml/copy.s.
  */
-#define	SMAP_CLAC_INSTR	0xc3ca010f
-#define	SMAP_STAC_INSTR	0xc3cb010f
+#define	SMAP_CLAC_INSTR	0x90ca010f
+#define	SMAP_STAC_INSTR	0x90cb010f
 extern void smap_disable(void);
 extern void smap_enable(void);
 
-- 
2.21.0

