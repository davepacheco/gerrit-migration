commit 6cfc0bdb2568beb76d2f5e1a018598ee5a5fcb9a (refs/changes/45/2545/18)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2017-09-20T21:49:44+00:00 (2 years, 1 month ago)
    
    DOCKER-1101 Cleanup containers.js

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 2f32825..68b8490 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -134,17 +134,23 @@ function getPapiClient(config) {
     return _papiClientCache;
 }
 
-
-/**
- * Return rules that expose each specified port individually for a given
- * account and protocol.
- */
-function generateExposeRules(account, vm, proto, ports, cb) {
+function generateExpose(account, what, vm, proto, ports, cb) {
     var protoRules = [];
-
+    var nport_err = 'publish port: only support exposing %d %s port';
+    var rule_fmt;
+    var rule_ports;
+
+    if (what === 'range') {
+        ports = utils.compressPorts(ports);
+        nport_err = nport_err + ' ranges';
+        rule_fmt = 'FROM any to vm %s ALLOW %s ports %s';
+    } else {
+        nport_err = nport_err + 's';
+        rule_fmt = 'FROM any to vm %s ALLOW %s (port %s)';
+    }
     if (ports.length > MAX_EXPOSED_PORTS) {
         return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s ports',
+            nport_err,
             MAX_EXPOSED_PORTS, proto.toUpperCase())));
     }
 
@@ -154,12 +160,16 @@ function generateExposeRules(account, vm, proto, ports, cb) {
         if (rulePorts.length === 0) {
             break;
         }
+        if (what === 'range') {
+            rule_ports = rulePorts.map(port2str).join(',');
+        } else {
+            rule_ports = rulePorts.sort().join(' AND port ');
+        }
 
         protoRules.push({
             enabled: true,
             owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s (port %s)',
-                vm, proto, rulePorts.sort().join(' AND port ')),
+            rule: util.format(rule_fmt, vm, proto, rule_ports),
             uuid: libuuid.create()
         });
     }
@@ -167,6 +177,14 @@ function generateExposeRules(account, vm, proto, ports, cb) {
     return cb(null, protoRules);
 }
 
+/**
+ * Return rules that expose each specified port individually for a given
+ * account and protocol.
+ */
+function generateExposeRules(account, vm, proto, ports, cb) {
+    generateExpose(account, 'rules', vm, proto, ports, cb);
+}
+
 function port2str(port) {
     if (port.hasOwnProperty('start')
         && port.hasOwnProperty('end')) {
@@ -180,32 +198,7 @@ function port2str(port) {
  * Return rules that expose port ranges for a given account and protocol
  */
 function generateExposeRange(account, vm, proto, ports, cb) {
-    var protoRules = [];
-
-    ports = utils.compressPorts(ports);
-    if (ports.length > MAX_EXPOSED_PORTS) {
-        return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s port ranges',
-            MAX_EXPOSED_PORTS, proto.toUpperCase())));
-    }
-
-    // Each FWAPI rule only supports 8 ports
-    for (var i = 0; i < MAX_EXPOSED_PORTS; i += MAX_PORTS_PER_RULE) {
-        var rulePorts = ports.slice(i, i + MAX_PORTS_PER_RULE);
-        if (rulePorts.length === 0) {
-            break;
-        }
-
-        protoRules.push({
-            enabled: true,
-            owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s ports %s',
-                vm, proto, rulePorts.map(port2str).join(',')),
-            uuid: libuuid.create()
-        });
-    }
-
-    return cb(null, protoRules);
+    generateExpose(account, 'range', vm, proto, ports, cb);
 }
 
 
@@ -2400,7 +2393,7 @@ function getContainersForVms(opts, callback) {
             owner_uuid: vmobj.owner_uuid
         }, function (err, fwrules) {
             if (err) {
-                callback(err);
+                cb(err);
                 return;
             }
 
@@ -4229,16 +4222,16 @@ function copyContainer(opts, callback) {
     var log = opts.log;
     var payload = opts.payload;
 
-    dockerCopy({
+    containerArchiveReadStream({
         log: log,
         payload: payload,
         req_id: opts.req_id,
         account: opts.account,
         cnapi: opts.app.cnapi,
         vm: opts.vm
-    }, function (copyErr, stream) {
-        if (copyErr) {
-            callback(copyErr);
+    }, function (err, stream) {
+        if (err) {
+            callback(err);
             return;
         }
 
@@ -4247,44 +4240,81 @@ function copyContainer(opts, callback) {
 }
 
 
-function dockerCopy(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.payload, 'opts.payload');
+function dockerVerbToMethod(verb) {
+    switch (verb) {
+    case 'stats':
+        return 'dockerStats';
+    case 'copy':
+        return 'dockerCopy';
+    default:
+        assert.ok(null);
+        break;
+    }
+}
+
+function containerArchiveRWStream(opts, verb, mode, callback) {
     assert.object(opts.log, 'opts.log');
+    assert.optionalObject(opts.account, 'opts.account');
     assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assert.string(mode, 'mode');
+    assert.string(verb, 'verb');
+    assert.optionalObject(opts.payload, 'opts.payload');
+    assert.optionalString(opts.path, 'opts.path');
+    assert.ok(opts.path || opts.payload);
+    assert.ok(verb === 'copy' || verb === 'stats');
+    if (verb === 'copy')
+        assert.ok(mode === 'read' || mode === 'write' || mode === 'stat');
+    assert.object(opts.vm, 'opts.vm');
     assert.object(opts.cnapi, 'opts.cnapi');
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var dockerCommand = dockerVerbToMethod(verb);
+    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var params;
+    if (opts.path) {
+        params = {
+            path: opts.path
+        };
+    } else {
+        params = {
+            payload: opts.payload
+        };
+    }
+    params.mode = (verb !== 'stats') ? mode : undefined;
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload,
-        mode: 'read'
-    }, copyHeaders, onCopy);
+    cnapi[dockerCommand](opts.vm.server_uuid, opts.vm.uuid, params,
+        headers, onCommand);
 
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
+    function onCommand(err, res) {
+        if (err) {
+            log.error(err, 'error calling docker-' + verb);
+            if (err.restCode === 'VmNotRunning') {
+                callback(new errors.NotImplementedError(
                     'copy on stopped container'));
+                return;
             }
-            log.error(copyErr, 'error calling docker-copy');
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            callback(errors.cnapiErrorWrap(
+                err, 'problem calling docker ' + verb));
+            return;
         }
 
         var host = res.host;
         var port = res.port;
 
-        var copySocket = net.createConnection({ host: host, port: port });
+        var socket = net.createConnection({ host: host, port: port });
 
-        callback(null, copySocket);
+        if (opts.path && verb === 'copy' && mode === 'read') {
+            callback(null, socket, {
+                containerPathStat: res.containerPathStat });
+        } else if (opts.path && verb === 'copy' && mode === 'stat') {
+            callback(null, {containerPathStat: res.containerPathStat });
+        } else {
+            callback(null, socket);
+        }
     }
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
@@ -4292,41 +4322,7 @@ function dockerCopy(opts, callback) {
  */
 
 function containerArchiveReadStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'read'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket, {
-            containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'copy', 'read', callback);
 }
 
 
@@ -4337,46 +4333,7 @@ function containerArchiveReadStream(opts, callback) {
  */
 
 function containerArchiveWriteStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.string(opts.path, 'opts.path');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    var copyOpts = {
-        path: opts.path,
-        mode: 'write'
-    };
-
-    if (opts.no_overwrite_dir) {
-        copyOpts.no_overwrite_dir = true;
-    }
-
-    cnapi.dockerCopy(
-        opts.vm.server_uuid, opts.vm.uuid, copyOpts, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket);
-    }
+    containerArchiveRWStream(opts, 'copy', 'write', callback);
 }
 
 
@@ -4386,67 +4343,12 @@ function containerArchiveWriteStream(opts, callback) {
  */
 
 function containerArchiveStat(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'stat'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        callback(null, { containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'copy', 'stat', callback);
 }
 
 
 function containerStats(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.payload, 'opts.payload');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.socket, 'opts.socket');
-
-    var log = opts.log;
-    var cnapi = opts.app.cnapi;
-    var headers = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerStats(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload
-    }, headers, function (err, res) {
-        if (err) {
-            log.error(err, 'error calling docker-stats');
-            return callback(errors.cnapiErrorWrap(
-                err, 'problem calling docker stats'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        log.debug('containerStats server on host: ', host, 'port: ', port);
-
-        var statsSocket = net.createConnection({ host: host, port: port });
-
-        callback(null, statsSocket);
-    });
+    containerArchiveRWStream(opts, 'stats', null, callback);
 }
 
 
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index 32b8318..c889bc7 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -893,7 +893,7 @@ function compressPorts(ports) {
     var sorted = [], ranges = [];
     var port, i;
     if (ports.length === 0) {
-        return;
+        return ranges;
     }
 
     for (i = 0; i < ports.length; i++) {
diff --git a/lib/endpoints/containers.js b/lib/endpoints/containers.js
index c1041d4..7916d92 100644
--- a/lib/endpoints/containers.js
+++ b/lib/endpoints/containers.js
@@ -307,11 +307,10 @@ function containerStats(req, res, next) {
 
     req.backend.containerStats({
         account: req.account,
-        app: req.app,
+        cnapi: req.app.cnapi,
         log: log,
         payload: payload,
         req_id: req.getId(),
-        socket: req.socket,
         vm: req.vm
     }, function (err, statsSocket) {
             if (err) {
