From fdbb7b1dd89603f15400986b208ded27b469aea3 Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Fri, 18 Aug 2017 00:31:12 +0000
Subject: [PATCH] DOCKER-1101 Cleanup containers.js

---
 lib/backends/sdc/containers.js      | 864 ++++++++++------------------
 lib/backends/sdc/index.js           |   3 +-
 lib/backends/sdc/networks.js        | 131 ++++-
 lib/endpoints/networks.js           |   2 +-
 package.json                        |   2 +-
 test/integration/api-create.test.js |  35 ++
 test/integration/helpers.js         |  23 +
 7 files changed, 484 insertions(+), 576 deletions(-)

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 516d192..044d9d7 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -83,7 +83,6 @@ var TRITON_PUBLIC_NETWORK_LABEL = 'triton.network.public';
 var BAD_PKG_NAME_RE = /[\_\-\.][\_\-\.]/;
 var PKG_NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9\_\-\.]+)?[a-zA-Z0-9]$/;
 
-
 //---- internal support routines
 
 function getCnapiClient(config) {
@@ -134,17 +133,32 @@ function getPapiClient(config) {
     return _papiClientCache;
 }
 
+function cropOpts(opts, names) {
+    var ret = {};
+    names.forEach(function (n) {
+        assert.string(n);
+        ret[n] = opts[n];
+    });
+}
 
-/**
- * Return rules that expose each specified port individually for a given
- * account and protocol.
- */
-function generateExposeRules(account, vm, proto, ports, cb) {
-    var protoRules = [];
 
+function generateExpose(account, what, vm, proto, ports, cb) {
+    var protoRules = [];
+    var nport_err = 'publish port: only support exposing %d %s port';
+    var rule_fmt;
+    var rule_ports;
+
+    if (what === 'range') {
+        ports = utils.compressPorts(ports);
+        nport_err = nport_err + ' ranges';
+        rule_fmt = 'FROM any to vm %s ALLOW %s ports %s';
+    } else {
+        nport_err = nport_err + 's';
+        rule_fmt = 'FROM any to vm %s ALLOW %s (port %s)';
+    }
     if (ports.length > MAX_EXPOSED_PORTS) {
         return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s ports',
+            nport_err,
             MAX_EXPOSED_PORTS, proto.toUpperCase())));
     }
 
@@ -154,12 +168,16 @@ function generateExposeRules(account, vm, proto, ports, cb) {
         if (rulePorts.length === 0) {
             break;
         }
+        if (what === 'range') {
+            rule_ports = rulePorts.map(port2str).join(',');
+        } else {
+            rule_ports = rulePorts.sort().join(' AND port ');
+        }
 
         protoRules.push({
             enabled: true,
             owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s (port %s)',
-                vm, proto, rulePorts.sort().join(' AND port ')),
+            rule: util.format(rule_fmt, vm, proto, rule_ports),
             uuid: libuuid.create()
         });
     }
@@ -167,6 +185,14 @@ function generateExposeRules(account, vm, proto, ports, cb) {
     return cb(null, protoRules);
 }
 
+/**
+ * Return rules that expose each specified port individually for a given
+ * account and protocol.
+ */
+function generateExposeRules(account, vm, proto, ports, cb) {
+    generateExpose(account, 'rules', vm, proto, ports, cb);
+}
+
 function port2str(port) {
     if (port.hasOwnProperty('start')
         && port.hasOwnProperty('end')) {
@@ -180,45 +206,10 @@ function port2str(port) {
  * Return rules that expose port ranges for a given account and protocol
  */
 function generateExposeRange(account, vm, proto, ports, cb) {
-    var protoRules = [];
-
-    ports = utils.compressPorts(ports);
-    if (ports.length > MAX_EXPOSED_PORTS) {
-        return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s port ranges',
-            MAX_EXPOSED_PORTS, proto.toUpperCase())));
-    }
-
-    // Each FWAPI rule only supports 8 ports
-    for (var i = 0; i < MAX_EXPOSED_PORTS; i += MAX_PORTS_PER_RULE) {
-        var rulePorts = ports.slice(i, i + MAX_PORTS_PER_RULE);
-        if (rulePorts.length === 0) {
-            break;
-        }
-
-        protoRules.push({
-            enabled: true,
-            owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s ports %s',
-                vm, proto, rulePorts.map(port2str).join(',')),
-            uuid: libuuid.create()
-        });
-    }
-
-    return cb(null, protoRules);
+    generateExpose(account, 'range', vm, proto, ports, cb);
 }
 
 
-/**
- * List networks in NAPI, filtering by params
- */
-function listNetworks(opts, params, callback) {
-    var napi = getNapiClient(opts.config.napi);
-
-    napi.listNetworks(params, {headers: {'x-request-id': opts.req_id}},
-        callback);
-}
-
 /**
  * Add the "EXPOSE" firewall rules to the payload.  Note that we open up all
  * ports between docker hosts right now, since this is what other inter-host
@@ -457,7 +448,8 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
             var ports = exposedPorts[portProto];
 
             if (ports.length === 0) {
-                return cb(null, []);
+                cb(null, []);
+                return;
             }
 
             // Generate firewall rules. If port ranges are available, use them
@@ -587,7 +579,7 @@ function addNetworksToPayload(opts, container, payload, callback) {
                     || networkMode === 'default') {
                 defaultFabricNetwork(opts, payload, next);
             } else {
-                mod_networks.findNetworkByNameOrId(networkMode, opts,
+                mod_networks.findNetworkOrPoolByNameOrId(networkMode, opts,
                     function (findErr, network)
                 {
                     if (findErr) {
@@ -672,7 +664,6 @@ function externalNetworkByName(opts, container, payload, callback) {
     // Find the external network using the given (or default) network name.
     var listParams = {
         name: externalNetworkName || opts.config.externalNetwork || 'external',
-        fabric: false,
         provisionable_by: opts.account.uuid
     };
 
@@ -680,9 +671,10 @@ function externalNetworkByName(opts, container, payload, callback) {
         format('Networks: fabrics not configured, using network %s',
         listParams.name));
 
-    listNetworks(opts, listParams, function (err, networks) {
+    mod_networks.getNetworksOrPools(listParams, opts, function (err, networks) {
         log.debug({ err: err, res: networks },
-            format('Networks: listNetworks result for %s', listParams.name));
+            format('Networks/Pools: getNetworksOrPools result for %s',
+                listParams.name));
 
         if (err) {
             callback(errors.napiErrorWrap(err,
@@ -717,12 +709,10 @@ function externalNetworkByName(opts, container, payload, callback) {
  * (typically the external/public pool).
  */
 function defaultFabricNetwork(opts, payload, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.object(opts.app.config, 'opts.app.config');
     assert.string(opts.app.config.datacenterName,
         'opts.app.config.datacenterName');
-    assert.object(opts.log, 'opt.log');
     assert.object(payload, 'payload');
     assert.func(callback, 'callback');
 
@@ -772,13 +762,10 @@ function addRulesToPayload(payload, rules) {
  * returns the link details via the callback.
  */
 function getLinkDetails(opts, configLinks, vm_payload, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.vmapi, 'opts.app.vmapi');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     if (!configLinks) {
         callback();
@@ -983,9 +970,7 @@ function applyLinksToMetadata(im, linkDetails) {
 }
 
 function storeLinks(opts, linkDetails, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
+    assertOptsAppLog(opts, true);
     assert.object(linkDetails, 'linkDetails');
     assert.func(callback, 'callback');
 
@@ -1009,11 +994,9 @@ function storeLinks(opts, linkDetails, callback) {
 }
 
 function deleteLinks(opts, cb) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
     assert.object(opts.vm, 'opts.vm');
-    assert.object(opts.app, 'opts.app');
     assert.object(opts.account, 'opts.account');
-    assert.object(opts.log, 'opts.log');
     assert.func(cb, 'cb');
 
     var log = opts.log;
@@ -1064,10 +1047,8 @@ function deleteLinks(opts, cb) {
 }
 
 function renameLinks(opts, newName, callback) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
     assert.object(opts.account, 'opts.account');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
 
     var log = opts.log;
 
@@ -1587,12 +1568,9 @@ function publishingPorts(container) {
  * to the user.
  */
 function buildVmPayload(opts, container, callback) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.config, 'opts.config');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.app, 'opts.app');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
     assert.object(opts.image, 'opts.image');
     assert.object(opts.vmapi, 'opts.vmapi'); // vmapi client
     assert.object(container, 'container');
@@ -1881,12 +1859,7 @@ function buildVmPayload(opts, container, callback) {
             // This must happen after we've added the owner_uuid to the payload.
             // ...and is where we add --volumes-from volumes.
 
-            var get_opts = {
-                account: opts.account,
-                log: log,
-                req_id: opts.req_id,
-                vmapi: opts.vmapi
-            };
+            var get_opts = cropOpts(opts, ['account', 'log', 'req_id', 'vmapi']);
             var vf_containers = [];
 
             function _addContainerVolumes(source, next) {
@@ -2289,10 +2262,7 @@ function findContainerIdMatch(id, objects) {
  * Find this container id from the list of all docker containers.
  */
 function getVmById(id, opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true);
     assert.object(opts.vmapi, 'opts.vmapi');
 
     var log = opts.log;
@@ -2351,11 +2321,7 @@ function loadPackages(opts, callback) {
 //---- exported SdcBackend methods
 
 function getContainerCount(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts);
 
     var vmapi = getVmapiClient(this.config.vmapi);
     var params = {
@@ -2392,10 +2358,8 @@ function getContainerCount(opts, callback) {
  * builds an array of docker container objects.
  */
 function getContainersForVms(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.pkgmapUtoN, 'opts.pkgmapUtoN');
     assert.array(opts.vmobjs, 'opts.vmobjs');
     assert.func(callback, 'callback');
@@ -2413,11 +2377,9 @@ function getContainersForVms(opts, callback) {
                 return;
             }
 
-            utils.vmobjToContainer({
-                clientApiVersion: opts.clientApiVersion,
-                app: opts.app,
-                log: opts.log
-            }, vmobj, fwrules, function _addPkgLabel(e, container) {
+            utils.vmobjToContainer(
+                cropOpts(opts, ['clientApiVersion', 'app', 'log']),
+                vmobj, fwrules, function _addPkgLabel(e, container) {
                 if (!e) {
                     if (pkgmapUtoN.hasOwnProperty(vmobj.billing_id)) {
                         // We've got the package available, so attach to the
@@ -2458,19 +2420,16 @@ function getContainersForVms(opts, callback) {
 }
 
 function getContainers(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.account, 'opts.account');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.uuid(opts.account.uuid, 'opts.account.uuid');
     assert.optionalBool(opts.all, 'opts.all');
-    assert.object(opts.app, 'opts.app');
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.config.fwapi, 'opts.app.config.fwapi');
     assert.object(opts.app.config.papi, 'opts.app.config.papi');
     assert.object(opts.app.vmapi, 'opts.app.vmapi');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalString(opts.filters, 'opts.filters');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
 
     var filters;
     var log = opts.log || this.log;
@@ -2837,11 +2796,8 @@ function getContainers(opts, callback) {
 }
 
 function createContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalBool(opts.requireExternalNetwork,
         'opts.requireExternalNetwork');
@@ -2876,7 +2832,8 @@ function createContainer(opts, callback) {
             clientApiVersion: opts.clientApiVersion
         }, container, function (err, _vm_payload) {
             if (err) {
-                return cb(err);
+                cb(err);
+                return;
             }
             vm_payload = _vm_payload;
             if (vm_payload.internal_metadata['docker:entrypoint'] === '[]'
@@ -2934,40 +2891,55 @@ function createContainer(opts, callback) {
     }
 }
 
-function stopContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+function stopOrKillContainer(opts, verb, callback) {
+    assertOptsReqIdAccount(opts);
+    assert.ok(verb === 'stop' || verb === 'kill');
 
     if (opts.timeout) {
         assert.ok(!isNaN(opts.timeout), 'opts.timeout');
     }
+    if (opts.signal) {
+        assert.ok((['string', 'number'].indexOf(typeof (opts.signal)) !== -1),
+                  'opts.signal');
+    }
+    if (verb === 'kill' && !opts.signal) {
+        opts.signal = 'SIGKILL';
+    }
 
     var log = opts.log || this.log;
     var timeout = opts.timeout;
     var vmapi = opts.app.vmapi;
 
-    var stopHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var stopParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        timeout: timeout,
-        uuid: opts.vm.uuid
-    };
+    var present_tense = (verb === 'stop') ? 'stopping' : 'killing';
+    var vmapiCommand = (verb === 'stop') ? vmapi.stopVm.bind(vmapi) :
+            vmapi.killVm.bind(vmapi);
+
+    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var params = initDoToContainerParams(opts);
+    params.timeout = timeout;
 
-    log.debug('stopParams: ' + JSON.stringify(stopParams));
-    stopParams.log = log;
+    if (verb === 'kill') {
+        if ((typeof (opts.signal) === 'string')
+            && (opts.signal.match(/^[0-9]+$/))) {
 
-    vmapi.stopVm(stopParams, stopHeaders, function (stop_err, job) {
-        if (stop_err) {
-            log.error(stop_err, 'Error stopping container.');
+            // An integer signal being sent as a string. Fix it.
+            params.signal = Number(opts.signal);
+        } else {
+            params.signal = opts.signal;
+        }
+    }
+
+    log.debug(verb + 'Params: ' + JSON.stringify(params));
+    params.log = log;
+
+    vmapiCommand(params, headers, function (err, job) {
+        if (err) {
+            if (verb === 'stop') {
+                // for some reason, the caller must log for kill cmds
+                log.error(err, 'Error ' + present_tense + ' container.');
+            }
             callback(errors.vmapiErrorWrap(
-                stop_err, 'problem stopping container'));
+                err, 'problem ' + present_tense + ' container'));
             return;
         }
 
@@ -2976,114 +2948,103 @@ function stopContainer(opts, callback) {
     });
 }
 
-function restartContainer(opts, callback) {
+function stopContainer(opts, callback) {
+    stopOrKillContainer(opts, 'stop', callback);
+}
+
+function initDoToContainerParams(opts) {
+    return {
+        context: opts.context,
+        creator_uuid: opts.creator_uuid,
+        idempotent: true,
+        origin: opts.origin,
+        owner_uuid: opts.account.uuid,
+        sync: true,
+        uuid: opts.vm.uuid
+    };
+}
+
+function assertOptsAppLog(opts, log_mandatory) {
     assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
+    assert.object(opts.app, 'opts.app');
+    if (log_mandatory) {
+        assert.object(opts.log, 'opts.log');
+    } else {
+        assert.optionalObject(opts.log, 'opts.log');
+    }
+}
+
+function assertOptsReqIdAccount(opts, log, optional) {
+    assertOptsAppLog(opts);
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.account, 'opts.account');
+    if (log && !optional) {
+        assert.object(opts.log, 'opts.log');
+    } else if (log && optional) {
+        assert.optionalObject(opts.log, 'opts.log');
+    }
+}
 
-    if (opts.timeout) {
+
+function doToContainer(opts, verb, callback) {
+    assertOptsReqIdAccount(opts);
+    assert.string(verb, 'verb');
+    assert.ok(verb === 'start' || verb === 'restart');
+
+    if (verb === 'restart' && opts.timeout) {
         assert.ok(!isNaN(opts.timeout), 'opts.timeout');
     }
 
     var log = opts.log || this.log;
     var timeout = opts.timeout;
     var vmapi = opts.app.vmapi;
+    var vmapiCommand;
 
-    var restartHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var restartParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        timeout: timeout,
-        uuid: opts.vm.uuid
-    };
+    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var params = initDoToContainerParams(opts);
+    if (verb === 'restart') {
+        params.timeout = timeout;
+        vmapiCommand = vmapi.rebootVm.bind(vmapi);
+    } else {
+        vmapiCommand = vmapi.startVm.bind(vmapi);
+    }
 
     // First, check if vm needs updating, if so pass an 'update' param.
     checkForContainerUpdate(opts, function (err, update) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (update) {
-            log.info('rebootVm with update');
-            restartParams['update'] = update;
+            log.info(verb + 'VM with update');
+            params['update'] = update;
         }
 
-        log.debug('restartParams: ' + JSON.stringify(restartParams));
-        restartParams.log = log;
+        log.debug(verb + 'Params: ' + JSON.stringify(params));
+        params.log = log;
 
-        vmapi.rebootVm(restartParams, restartHeaders,
-                        function (restart_err, job) {
-            if (restart_err) {
-                log.error(restart_err, 'Error restarting container.');
+        vmapiCommand(params, headers, function (err2, job) {
+            if (err2) {
+                log.error(err2, 'Error ' + verb + 'ing container.');
                 callback(errors.vmapiErrorWrap(
-                    restart_err, 'problem restarting container'));
+                    err2, 'problem ' + verb + 'ing container'));
                 return;
             }
 
             log.debug('job: ' + JSON.stringify(job));
+            //log.debug({job: job}, 'created ' + verb + ' job');
             callback();
         });
     });
 }
 
-function killContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    if (opts.signal) {
-        assert.ok((['string', 'number'].indexOf(typeof (opts.signal)) !== -1),
-            'opts.signal');
-    }
-
-    var log = opts.log || this.log;
-    var vmapi = opts.app.vmapi;
-
-    var killHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var killParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        uuid: opts.vm.uuid
-    };
-
-    if (!opts.signal) {
-        opts.signal = 'SIGKILL';
-    }
-
-    if ((typeof (opts.signal) === 'string')
-        && (opts.signal.match(/^[0-9]+$/))) {
-
-        // An integer signal being sent as a string. Fix it.
-        killParams.signal = Number(opts.signal);
-    } else {
-        killParams.signal = opts.signal;
-    }
-
-    log.debug('killParams: ' + JSON.stringify(killParams));
-    killParams.log = log;
-
-    vmapi.killVm(killParams, killHeaders, function (kill_err, job) {
-        if (kill_err) {
-            // caller must log
-            callback(errors.vmapiErrorWrap(
-                kill_err,
-                'problem sending signal to container'));
-            return;
-        }
+function restartContainer(opts, callback) {
+    doToContainer(opts, 'restart', callback);
+}
 
-        log.debug('job: ' + JSON.stringify(job));
-        callback();
-    });
+function killContainer(opts, callback) {
+    stopOrKillContainer(opts, 'kill', callback);
 }
 
 /**
@@ -3147,61 +3108,16 @@ function checkForContainerUpdate(opts, callback) {
 
 
 function startContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    var log = opts.log || this.log;
-    var vmapi = opts.app.vmapi;
-
-    var startHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var startParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        uuid: opts.vm.uuid
-    };
-
-    // First, check if vm needs updating, if so pass an 'update' param.
-    checkForContainerUpdate(opts, function (err, update) {
-        if (err) {
-            return callback(err);
-        }
-
-        if (update) {
-            log.info('startVm with update');
-            startParams['update'] = update;
-        }
-
-        log.debug('startParams: ' + JSON.stringify(startParams));
-        startParams.log = log;
-
-        vmapi.startVm(startParams, startHeaders, function (start_err, job) {
-            if (start_err) {
-                log.error(start_err, 'Error starting container.');
-                return callback(errors.vmapiErrorWrap(start_err,
-                    'problem starting container'));
-            }
-
-            log.debug({job: job}, 'created start job');
-            callback();
-        });
-    });
+    doToContainer(opts, 'start', callback);
 }
 
 
+
 function deleteContainer(opts, callback) {
-    assert.object(opts, 'opts');
+    assertOptsReqIdAccount(opts, true, true);
     assert.bool(opts.force, 'opts.force');
     assert.bool(opts.link, 'opts.link');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
     assert.string(opts.id, 'opts.id');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
@@ -3336,10 +3252,8 @@ function deleteContainer(opts, callback) {
 
 
 function deleteLink(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.string(opts.link, 'opts.link');
-    assert.optionalObject(opts.log, 'opts.log');
 
     var linkAlias = opts.link;
     var log = opts.log || this.log;
@@ -3391,13 +3305,11 @@ function deleteLink(opts, callback) {
 
 
 function inspectContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.config.fwapi, 'opts.app.config.fwapi');
     assert.object(opts.app.config.papi, 'opts.app.config.papi');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.optionalObject(opts.log, 'opts.log');
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.vm, 'opts.vm');
     assert.string(opts.vm.billing_id, 'opts.vm.billing_id');
@@ -3473,10 +3385,7 @@ function inspectContainer(opts, callback) {
 }
 
 function psContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true, true);
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
@@ -3524,10 +3433,7 @@ function psContainer(opts, callback) {
 }
 
 function waitContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true, true);
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
@@ -3572,13 +3478,9 @@ function waitContainer(opts, callback) {
 // execStart will send the same parameters along.
 //
 function execContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
     assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     _runCreateSocket(opts, function (err, cmdId, socketData) {
         if (err) {
@@ -3593,11 +3495,9 @@ function execContainer(opts, callback) {
 
 
 function execStart(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.string(opts.cmdId, 'opts.cmdId');
     assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.socketData, 'opts.socketData');
     assert.object(opts.account, 'opts.account');
     assert.object(opts.socket, 'opts.socket');
@@ -3615,12 +3515,9 @@ function execStart(opts, callback) {
 
 
 function _runCreateSocket(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log;
     var payload = opts.payload;
@@ -3736,15 +3633,14 @@ function _createLinestreamParser(opts, toSocket) {
     return lstream;
 }
 
-
-function _runExec(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.string(opts.cmdId, 'opts.cmdId');
+function _runAttachOrExec (opts, verb, callback) {
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
+    assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
     assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.socketData, 'opts.socketData');
     assert.object(opts.socket, 'opts.socket');
+    assert.ok(verb === 'attach' || verb === 'exec');
 
     // Make sure our callbacks get called only once
     var cb = once(callback);
@@ -3755,119 +3651,18 @@ function _runExec(opts, callback) {
     var clientSocket = opts.socket;
 
     var cmdString = socketData.command.Cmd.join(' ');
-    var serverSocket = net.createConnection({ host: host, port: port });
-
-    // Store a reference to the exec socket for future resizes
-    socketData.socket = serverSocket;
-
-    function writeData(stream, data, writeCb) {
-        data = JSON.stringify(data) + '\r\n';
-
-        if (writeCb) {
-            stream.write(data, writeCb);
-        } else {
-            stream.write(data);
-        }
-    }
-
-    function writeEnd(stream, writeCb) {
-        var data = JSON.stringify({
-            type: 'end'
-        }) + '\r\n';
-
-        stream.write(data, writeCb);
-    }
-
-    function _endSocket(error) {
-        if (error) {
-            opts.log.error('client socket %s threw an error %s',
-                cmdString, error.toString());
-        }
-        serverSocket.end();
-        cb(error, socketData);
-    }
-
-    var endSocket = once(_endSocket);
-
-    serverSocket.on('connect', setupListeners);
-
-    // error can happen before connect too (eg. ECONNREFUSED)
-    serverSocket.on('error', function _onServerSocketError(error) {
-        opts.log.error('serverSocket for %s threw an error %s',
-            cmdString, error.toString());
-
-        cb(error);
-    });
-
-    function setupListeners() {
-        if (socketData.command.AttachStdin) {
-            clientSocket.on('data', function (chunk) {
-                var type = socketData.command.Tty ? 'tty' : 'stdin';
-                writeData(serverSocket, {
-                    type: type,
-                    data: chunk.toString()
-                });
-            });
-        }
-
-        clientSocket.on('end', function () {
-            if (!serverSocket.destroyed) {
-                writeEnd(serverSocket, function () {
-                    opts.log.info('clientSocket has closed its stdin');
-                });
-            }
-        });
-
-        clientSocket.on('error', endSocket);
-        clientSocket.on('timeout', endSocket);
-
-        serverSocket.on('close', function (had_error) {
-            opts.log.debug('serverSocket %s closed, had_error=%s',
-                cmdString, had_error);
 
-            endSocket();
-        });
-
-        serverSocket.on('end', function () {
-            opts.log.debug('serverSocket %s end', cmdString);
-        });
-
-        var lstream = _createLinestreamParser({
-            log: opts.log,
-            socketData: socketData
-        }, clientSocket);
-        serverSocket.pipe(lstream);
+    var serverSocket;
+    if (verb === 'attach') {
+        serverSocket = socketData.socket;
     }
-}
-
-
-function _runAttach(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
-    assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.socketData, 'opts.socketData');
-    assert.object(opts.socket, 'opts.socket');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    // Make sure our callbacks get called only once
-    var cb = once(callback);
-
-    var socketData = opts.socketData;
-    var host = socketData.host;
-    var port = socketData.port;
-    var clientSocket = opts.socket;
-
-    var cmdString = socketData.command.Cmd.join(' ');
 
-    var serverSocket = socketData.socket;
     if (!serverSocket) {
         serverSocket = net.createConnection({ host: host, port: port });
         serverSocket.on('connect', setupListeners);
+        // error can happen before connect too (eg. ECONNREFUSED)
         serverSocket.on('error', function (error) {
-            opts.log.debug('attach for %s threw an error %',
+            opts.log.debug(verb + ' for %s threw an error %',
                 cmdString, error.toString());
 
             cb(error);
@@ -3876,9 +3671,14 @@ function _runAttach(opts, callback) {
         socketData.socket = serverSocket;
 
         // Store socket reference immediately
-        opts.app.sockets.setSocket('attach', opts.id, socketData);
+        // For 'exec' we already have it set via _runCreateSocket inside of
+        // execContainer
+        if (verb === 'attach') {
+            opts.app.sockets.setSocket('attach', opts.id, socketData);
+        }
     } else {
         // Reuse an existing attach session for a new client socket
+        assert.ok(verb === 'attach');
         setupListeners();
     }
 
@@ -3908,24 +3708,31 @@ function _runAttach(opts, callback) {
                 opts.log.error('client socket %s threw an error %s',
                     cmdString, error.toString());
                 serverSocket.end();
-                cb(error);
+                // Not sure why these differ in _runAttach and _runExec
+                if (verb === 'attach') {
+                    cb(error);
+                } else {
+                    cb(error, socketData);
+                }
                 return;
             }
-            waitContainer({
-                account: opts.account,
-                app: opts.app,
-                log: opts.log,
-                req_id: opts.req_id,
-                vm: opts.vm
-            }, function (err, statusCode) {
-                if (err) {
-                    opts.log.error(err, 'error waiting for container to stop');
-                    lstream.end();
-                    return;
-                }
-                serverSocket.end();
-                cb(error);
-            });
+            if (verb === 'attach') {
+                waitContainer({
+                    account: opts.account,
+                    app: opts.app,
+                    log: opts.log,
+                    req_id: opts.req_id,
+                    vm: opts.vm
+                }, function (err, statusCode) {
+                    if (err) {
+                        opts.log.error(err, 'error waiting for container to stop');
+                        lstream.end();
+                        return;
+                    }
+                    serverSocket.end();
+                    cb(error);
+                });
+            }
         }
 
         var endSocket = once(_endSocket);
@@ -3934,7 +3741,7 @@ function _runAttach(opts, callback) {
         // resizing the console so our socket supports resize and data message
         // types. Resize messages are queued by docker when calling
         // /containers/id/resize
-        function onData(chunk) {
+        function onDataAttach(chunk) {
             if (!socketData.command.Tty) {
                 writeData(serverSocket, {
                     type: 'stdin',
@@ -3963,45 +3770,71 @@ function _runAttach(opts, callback) {
             }
         }
 
+        function onDataExec(chunk) {
+            var type = socketData.command.Tty ? 'tty' : 'stdin';
+            writeData(serverSocket, {
+                type: type,
+                data: chunk.toString()
+            });
+        }
+
         if (socketData.command.AttachStdin) {
-            clientSocket.on('data', onData);
+            if (verb === 'attach') {
+                clientSocket.on('data', onDataAttach);
+            } else {
+                clientSocket.on('data', onDataExec);
+            }
         }
 
         clientSocket.on('end', function () {
-            writeEnd(serverSocket, function () {
-                opts.log.info('clientSocket has closed its stdin');
-            });
+            if ((verb === 'exec' && !serverSocket.destroyed) ||
+                verb === 'attach') {
+
+                writeEnd(serverSocket, function () {
+                    opts.log.info('clientSocket has closed its stdin');
+                });
+            }
         });
 
         clientSocket.on('error', endSocket);
         clientSocket.on('timeout', endSocket);
 
         serverSocket.on('close', function (had_error) {
-            opts.log.debug('attach %s closed, had_error=%s',
+            opts.log.debug(verb + ' %s closed, had_error=%s',
                 cmdString, had_error);
 
             endSocket();
         });
 
         serverSocket.on('end', function () {
-            opts.log.debug('attach %s end', cmdString);
+            opts.log.debug(verb + ' %s end', cmdString);
         });
 
-        var lstream = _createLinestreamParser({
-            doNotEncodeData: opts.doNotEncodeData,
-            noCloseOnSocketEnd: true,
+        var lstream_params = {
             log: opts.log,
             socketData: socketData
-        }, clientSocket);
+        };
+        if (verb === 'attach') {
+            lstream_params.doNotEncodeData = opts.doNotEncodeData;
+            lstream_params.noCloseOnSocketEnd = true;
+        }
+        var lstream = _createLinestreamParser(lstream_params, clientSocket);
         serverSocket.pipe(lstream);
     }
 }
 
+function _runExec(opts, callback) {
+    _runAttachOrExec(opts, 'exec', callback);
+}
+
+
+function _runAttach(opts, callback) {
+    _runAttachOrExec(opts, 'attach', callback);
+}
+
 
 function execResize(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
+    assertOptsAppLog(opts, true);
     assert.object(opts.account, 'opts.account');
     assert.object(opts.socketData, 'opts.socketData');
     assert.number(opts.w, 'opts.w');
@@ -4016,21 +3849,17 @@ function execResize(opts, callback) {
     socket.write(data, callback);
 }
 
-
 /*
  * attachContainer resuses _runAttach and _runCreateSocket
  */
 function attachContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
     assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
     assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
-    assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.socket, 'opts.socket');
     assert.object(opts.vm, 'opts.vm');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log;
     var socketData = opts.app.sockets.getSocket('attach', opts.id);
@@ -4135,10 +3964,8 @@ function renameContainer(opts, callback) {
  * should be resized
  */
 function resizeContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
     assert.number(opts.w, 'opts.w');
     assert.number(opts.h, 'opts.h');
 
@@ -4151,12 +3978,8 @@ function resizeContainer(opts, callback) {
  * containerLogs resuses _runExec and _runCreateSocket
  */
 function containerLogs(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
     assert.object(opts.vm, 'opts.vm');
 
     var log = opts.log;
@@ -4227,17 +4050,13 @@ function dockerExec(opts, callback) {
 
 
 function copyContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log;
     var payload = opts.payload;
 
-    dockerCopy({
+    containerArchiveReadStream({
         log: log,
         payload: payload,
         req_id: opts.req_id,
@@ -4255,32 +4074,46 @@ function copyContainer(opts, callback) {
 }
 
 
-function dockerCopy(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.payload, 'opts.payload');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+function containerArchiveRWStream(opts, mode, callback) {
+    assertOptsReqIdAccount(opts, true);
+    assert.string(mode, 'mode');
+    assert.optionalObject(opts.payload, 'opts.payload');
+    assert.optionalString(opts.path, 'opts.path');
+    assert.ok(opts.path || opts.payload);
+    assert.ok(mode === 'read' || mode === 'write' || mode === 'stat');
+    assert.object(opts.vm, 'opts.vm');
     assert.object(opts.cnapi, 'opts.cnapi');
 
     var log = opts.log;
     var cnapi = opts.cnapi;
     var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var copyOpts;
+    if (opts.path) {
+        copyOpts = {
+            path: opts.path,
+            mode: mode
+        };
+    } else {
+        copyOpts = {
+            payload: opts.payload,
+            mode: mode
+        };
+    }
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload,
-        mode: 'read'
-    }, copyHeaders, onCopy);
+    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, copyOpts,
+        copyHeaders, onCopy);
 
     function onCopy(copyErr, res) {
         if (copyErr) {
+            log.error(copyErr, 'error calling docker-copy');
             if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
+                callback(new errors.NotImplementedError(
                     'copy on stopped container'));
+                return;
             }
-            log.error(copyErr, 'error calling docker-copy');
-            return callback(errors.cnapiErrorWrap(
+            callback(errors.cnapiErrorWrap(
                 copyErr, 'problem calling docker copy'));
+            return;
         }
 
         var host = res.host;
@@ -4288,56 +4121,26 @@ function dockerCopy(opts, callback) {
 
         var copySocket = net.createConnection({ host: host, port: port });
 
-        callback(null, copySocket);
+        if (opts.path && mode === 'read') {
+            callback(null, copySocket, {
+                containerPathStat: res.containerPathStat });
+        } else if (opts.path && mode === 'stat') {
+            callback(null, {containerPathStat: res.containerPathStat });
+        } else {
+            callback(null, copySocket);
+        }
     }
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
  * then connect to that server and pipe it's stream to the our client.
  */
-
 function containerArchiveReadStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'read'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket, {
-            containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'read', callback);
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
@@ -4345,46 +4148,7 @@ function containerArchiveReadStream(opts, callback) {
  */
 
 function containerArchiveWriteStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.string(opts.path, 'opts.path');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    var copyOpts = {
-        path: opts.path,
-        mode: 'write'
-    };
-
-    if (opts.no_overwrite_dir) {
-        copyOpts.no_overwrite_dir = true;
-    }
-
-    cnapi.dockerCopy(
-        opts.vm.server_uuid, opts.vm.uuid, copyOpts, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket);
-    }
+    containerArchiveRWStream(opts, 'write', callback);
 }
 
 
@@ -4394,35 +4158,7 @@ function containerArchiveWriteStream(opts, callback) {
  */
 
 function containerArchiveStat(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'stat'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        callback(null, { containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'stat', callback);
 }
 
 
diff --git a/lib/backends/sdc/index.js b/lib/backends/sdc/index.js
index afb8fc7..841f1bd 100644
--- a/lib/backends/sdc/index.js
+++ b/lib/backends/sdc/index.js
@@ -80,7 +80,8 @@ SdcBackend.prototype.buildImage = build.buildImage;
 SdcBackend.prototype.commitImage = build.commitImage;
 
 // networks.js
-SdcBackend.prototype.findNetworkByNameOrId = networks.findNetworkByNameOrId;
+SdcBackend.prototype.findNetworkOrPoolByNameOrId =
+    networks.findNetworkOrPoolByNameOrId;
 SdcBackend.prototype.inspectNetwork = networks.inspectNetwork;
 SdcBackend.prototype.listNetworks = networks.listNetworks;
 
diff --git a/lib/backends/sdc/networks.js b/lib/backends/sdc/networks.js
index 409f59a..bad5e6b 100644
--- a/lib/backends/sdc/networks.js
+++ b/lib/backends/sdc/networks.js
@@ -271,6 +271,122 @@ function inspectNetwork(opts, callback) {
     napiNetworkToDockerNetwork(opts.req.network, {}, callback);
 }
 
+function getNetworksOrPools(params, opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(params, 'params');
+    assert.ok(params.name || params.uuid, 'params name or uuid');
+    assert.object(opts.config, 'opts.config');
+    var napi = getNapiClient(opts.config.napi);
+    var headers = {headers: {'x-request-id': opts.req_id}};
+
+    vasync.tryEach([
+        function listNets(cb) {
+            napi.listNetworks(params, headers, function (err, res) {
+                if (res && res.length === 0) {
+                    cb(new Error('Empty List'));
+                } else {
+                    if (err && err.statusCode !== 404) {
+                        cb(null, {err: err});
+                    } else {
+                        cb(err, {res: res});
+                    }
+                }
+            });
+        },
+        function listFiltNets(cb) {
+            /*
+             * This is our fallback in case we are talking to an older version
+             * of NAPI that does not support matching UUIDs by prefix.
+             */
+            if (params.name) {
+                /* Can't prefix search names */
+                cb(new Error('Net name not found'));
+                return;
+            }
+            var uuid = params.uuid;
+            var uuidPref = uuid.substring(0, (uuid.length - 1));
+            var sz = uuidPref.length;
+            if (uuid[(uuid.length - 1)] !== '*') {
+                cb(new Error('Must be prefix'));
+                return;
+            }
+            var newParams = {provisionable_by: params.provisionable_by};
+            napi.listNetworks(newParams, headers, function (err, res) {
+                if (res && res.length === 0) {
+                    cb(new Error('Empty List'));
+                } else {
+                    if (err && err.statusCode !== 404) {
+                        cb(null, {err: err});
+                        return;
+                    }
+                    var filtered = res.filter(function (p) {
+                        return (uuidPref === p.uuid.substring(0, sz));
+                    });
+                    if (filtered.length > 0) {
+                        cb(null, {res: filtered});
+                    } else {
+                        cb(new Error('Network not found'));
+                    }
+                }
+            });
+        },
+        function listNetPools(cb) {
+            napi.listNetworkPools(params, headers, function (err, res) {
+                if (res && res.length === 0) {
+                    cb(new Error('Empty List'));
+                } else {
+                    if (err && err.statusCode !== 404) {
+                        cb(null, {err: err});
+                    } else {
+                        cb(err, {res: res});
+                    }
+                }
+            });
+        },
+        function listFiltNetPools(cb) {
+            /*
+             * This is our fallback in case we are talking to an older version
+             * of NAPI that does not support matching UUIDs by prefix.
+             */
+            if (params.name) {
+                /* Can't prefix search names */
+                cb(new Error('Net name not found'));
+                return;
+            }
+            var uuid = params.uuid;
+            var uuidPref = uuid.substring(0, (uuid.length - 1));
+            var sz = uuidPref.length;
+            if (uuid[(uuid.length - 1)] !== '*') {
+                cb(new Error('Must be prefix'));
+                return;
+            }
+            var newParams = {provisionable_by: params.provisionable_by};
+            napi.listNetworkPools(newParams, headers, function (err, res) {
+                if (res && res.length === 0) {
+                    cb(new Error('Empty List'));
+                } else {
+                    if (err && err.statusCode !== 404) {
+                        cb(null, {err: err});
+                        return;
+                    }
+                    var filtered = res.filter(function (p) {
+                        return (uuidPref === p.uuid.substring(0, sz));
+                    });
+                    if (filtered.length > 0) {
+                        cb(null, {res: filtered});
+                    } else {
+                        cb(new Error('Network pool not found'));
+                    }
+                }
+            });
+        },
+        function final(cb) {
+            cb(null, {res: []});
+        }
+    ], function (err, res) {
+        callback(res.err, res.res);
+    });
+}
 
 /**
  * Find the NAPI network from the given name or id.
@@ -279,7 +395,7 @@ function inspectNetwork(opts, callback) {
  * @param {Object} opts Accont and config options.
  * @param {Function} callback (err, network) Called with the found network.
  */
-function findNetworkByNameOrId(name, opts, callback) {
+function findNetworkOrPoolByNameOrId(name, opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.account, 'opts.account');
     assert.string(opts.account.uuid, 'opts.account.uuid');
@@ -291,7 +407,6 @@ function findNetworkByNameOrId(name, opts, callback) {
 
     // need to search on networks by: name, fabric-true, owner_uuid
     var log = opts.log;
-    var napi = getNapiClient(opts.config.napi);
 
     // NOTE: the order of the functions in this parallel() call is significant;
     // they are ordered by how docker prefers to resolve IDs:
@@ -317,8 +432,7 @@ function findNetworkByNameOrId(name, opts, callback) {
                     provisionable_by: opts.account.uuid
                 };
 
-                napi.listNetworks(listParams,
-                    { headers: { 'x-request-id': opts.req_id }}, cb);
+                getNetworksOrPools(listParams, opts, cb);
             },
             function byName(cb) {
                 var listParams = {
@@ -330,8 +444,7 @@ function findNetworkByNameOrId(name, opts, callback) {
                     util.format('Networks: searching for network %s',
                         listParams.name));
 
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
+                getNetworksOrPools(listParams, opts, cb);
             },
             function byDockerId(cb) {
                 // we assume the 'double uuid' convention for networks here,
@@ -371,8 +484,7 @@ function findNetworkByNameOrId(name, opts, callback) {
                     util.format('Networks: searching for network %s',
                         listParams.uuid));
 
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
+                getNetworksOrPools(listParams, opts, cb);
             }
         ]
     }, function _listedNetworks(err, results) {
@@ -436,7 +548,8 @@ function findNetworkByNameOrId(name, opts, callback) {
 
 
 module.exports = {
-    findNetworkByNameOrId: findNetworkByNameOrId,
+    findNetworkOrPoolByNameOrId: findNetworkOrPoolByNameOrId,
     inspectNetwork: inspectNetwork,
+    getNetworksOrPools: getNetworksOrPools,
     listNetworks: listNetworks
 };
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
index cd71323..cc75abf 100644
--- a/lib/endpoints/networks.js
+++ b/lib/endpoints/networks.js
@@ -120,7 +120,7 @@ function register(http, before) {
             log: req.log,
             req_id: req.getId()
         };
-        req.backend.findNetworkByNameOrId(req.params.id, opts,
+        req.backend.findNetworkOrPoolByNameOrId(req.params.id, opts,
             function onFindNetwork(err, network)
         {
             if (err) {
diff --git a/package.json b/package.json
index aab7552..e9fdf92 100644
--- a/package.json
+++ b/package.json
@@ -29,7 +29,7 @@
     "trace-event": "1.2.0",
     "triton-tags": "1.1.4",
     "ufds": "1.2.0",
-    "vasync": "1.6.3",
+    "vasync": "git+https://cr.joyent.us/p/joyent/node-vasync.git#4932adf889e5c2fb5594e539da6a2d9bfcd21aa2",
     "verror": "1.9.0",
     "wf-client": "0.2.1",
     "xregexp": "3.1.0"
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index 6b40d75..60aeb45 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -488,6 +488,15 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
             fNetwork3 = results.operations[2].result;
             nonFabricNetwork = results.operations[3].result;
 
+            t.test('create pool', function (t2) {
+                h.getOrCreateNetworkPool(NAPI, 'sdcdockertest_apicreate_netp', {
+                    networks: [ nonFabricNetwork.uuid ]
+                }, function (err2) {
+                    t2.ifErr(err2, 'create pool failed');
+                    t2.end();
+                });
+            });
+
             t.end();
         });
     });
@@ -515,6 +524,30 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 
+    // create with networkPool name
+    tt.test('create with a networkPool name', function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { 'HostConfig.NetworkMode': 'sdcdockertest_apicreate_netp' },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            t.ifErr(err, 'create NetworkPool: networkName');
+            var nics = result.vm.nics;
+            t.equal(nics[0].network_uuid, nonFabricNetwork.uuid,
+                'correct network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete network testing container');
+            t.end();
+        }
+    });
+
     tt.test('create with a complete network id', function (t) {
         var fullId = (fNetwork1.uuid + fNetwork1.uuid).replace(/-/g, '');
 
@@ -527,6 +560,7 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }, oncreate);
 
         function oncreate(err, result) {
+            t.ifErr(err, 'create network testing container');
             var nics = result.vm.nics;
             t.equal(nics.length, 1, 'only one nic');
             t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
@@ -552,6 +586,7 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }, oncreate);
 
         function oncreate(err, result) {
+            t.ifErr(err, 'create network testing container');
             var nics = result.vm.nics;
             t.equal(nics.length, 1, 'only one nic');
             t.equal(nics[0].network_uuid, fNetwork1.uuid, 'correct network');
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index ff7faaa..7e4ab7e 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -1881,6 +1881,28 @@ function getOrCreateFabricNetwork(client, userUuid, vlan_id, params, callback) {
     );
 }
 
+/*
+ * Gets or creates a network pool for use in testing; based on the
+ * network *name*.
+ */
+function getOrCreateNetworkPool(client, name, params, callback) {
+    assert.object(client, 'napi client');
+    assert.object(params, 'network params');
+
+    var listParams = {
+        name: name
+    };
+    client.listNetworkPools(listParams, function (err, networks) {
+        if (err) {
+            return callback(err);
+        }
+        if (networks.length !== 0) {
+            return callback(null, networks[0]);
+        }
+        client.createNetworkPool(name, params, callback);
+    });
+}
+
 function getNetwork(client, params, callback) {
     assert.object(client, 'napi client');
     assert.object(params, 'network params');
@@ -2062,6 +2084,7 @@ module.exports = {
     getOrCreateExternalNetwork: getOrCreateExternalNetwork,
     getOrCreateFabricVLAN: getOrCreateFabricVLAN,
     getOrCreateFabricNetwork: getOrCreateFabricNetwork,
+    getOrCreateNetworkPool: getOrCreateNetworkPool,
     getNetwork: getNetwork,
     getNicsByVm: getNicsByVm,
     isFabricNetworkingEnabled: isFabricNetworkingEnabled,
-- 
2.21.0

