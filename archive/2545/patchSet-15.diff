From 18d2e980bb6c44be63e45fd3231c4123d7af666c Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Tue, 12 Sep 2017 18:56:04 +0000
Subject: [PATCH] DOCKER-1101 Cleanup containers.js

---
 lib/backends/sdc/containers.js | 1111 +++++++++++---------------------
 lib/backends/sdc/utils.js      |    2 +-
 lib/endpoints/containers.js    |    3 +-
 3 files changed, 392 insertions(+), 724 deletions(-)

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 516d192..e101b06 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -83,7 +83,6 @@ var TRITON_PUBLIC_NETWORK_LABEL = 'triton.network.public';
 var BAD_PKG_NAME_RE = /[\_\-\.][\_\-\.]/;
 var PKG_NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9\_\-\.]+)?[a-zA-Z0-9]$/;
 
-
 //---- internal support routines
 
 function getCnapiClient(config) {
@@ -134,17 +133,33 @@ function getPapiClient(config) {
     return _papiClientCache;
 }
 
+function cropOpts(opts, names) {
+    var ret = {};
+    names.forEach(function (n) {
+        assert.string(n);
+        ret[n] = opts[n];
+    });
+    return ret;
+}
 
-/**
- * Return rules that expose each specified port individually for a given
- * account and protocol.
- */
-function generateExposeRules(account, vm, proto, ports, cb) {
-    var protoRules = [];
 
+function generateExpose(account, what, vm, proto, ports, cb) {
+    var protoRules = [];
+    var nport_err = 'publish port: only support exposing %d %s port';
+    var rule_fmt;
+    var rule_ports;
+
+    if (what === 'range') {
+        ports = utils.compressPorts(ports);
+        nport_err = nport_err + ' ranges';
+        rule_fmt = 'FROM any to vm %s ALLOW %s ports %s';
+    } else {
+        nport_err = nport_err + 's';
+        rule_fmt = 'FROM any to vm %s ALLOW %s (port %s)';
+    }
     if (ports.length > MAX_EXPOSED_PORTS) {
         return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s ports',
+            nport_err,
             MAX_EXPOSED_PORTS, proto.toUpperCase())));
     }
 
@@ -154,12 +169,16 @@ function generateExposeRules(account, vm, proto, ports, cb) {
         if (rulePorts.length === 0) {
             break;
         }
+        if (what === 'range') {
+            rule_ports = rulePorts.map(port2str).join(',');
+        } else {
+            rule_ports = rulePorts.sort().join(' AND port ');
+        }
 
         protoRules.push({
             enabled: true,
             owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s (port %s)',
-                vm, proto, rulePorts.sort().join(' AND port ')),
+            rule: util.format(rule_fmt, vm, proto, rule_ports),
             uuid: libuuid.create()
         });
     }
@@ -167,6 +186,14 @@ function generateExposeRules(account, vm, proto, ports, cb) {
     return cb(null, protoRules);
 }
 
+/**
+ * Return rules that expose each specified port individually for a given
+ * account and protocol.
+ */
+function generateExposeRules(account, vm, proto, ports, cb) {
+    generateExpose(account, 'rules', vm, proto, ports, cb);
+}
+
 function port2str(port) {
     if (port.hasOwnProperty('start')
         && port.hasOwnProperty('end')) {
@@ -180,38 +207,9 @@ function port2str(port) {
  * Return rules that expose port ranges for a given account and protocol
  */
 function generateExposeRange(account, vm, proto, ports, cb) {
-    var protoRules = [];
-
-    ports = utils.compressPorts(ports);
-    if (ports.length > MAX_EXPOSED_PORTS) {
-        return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s port ranges',
-            MAX_EXPOSED_PORTS, proto.toUpperCase())));
-    }
-
-    // Each FWAPI rule only supports 8 ports
-    for (var i = 0; i < MAX_EXPOSED_PORTS; i += MAX_PORTS_PER_RULE) {
-        var rulePorts = ports.slice(i, i + MAX_PORTS_PER_RULE);
-        if (rulePorts.length === 0) {
-            break;
-        }
-
-        protoRules.push({
-            enabled: true,
-            owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s ports %s',
-                vm, proto, rulePorts.map(port2str).join(',')),
-            uuid: libuuid.create()
-        });
-    }
-
-    return cb(null, protoRules);
+    generateExpose(account, 'range', vm, proto, ports, cb);
 }
 
-
-/**
- * List networks in NAPI, filtering by params
- */
 function listNetworks(opts, params, callback) {
     var napi = getNapiClient(opts.config.napi);
 
@@ -457,7 +455,8 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
             var ports = exposedPorts[portProto];
 
             if (ports.length === 0) {
-                return cb(null, []);
+                cb(null, []);
+                return;
             }
 
             // Generate firewall rules. If port ranges are available, use them
@@ -672,7 +671,6 @@ function externalNetworkByName(opts, container, payload, callback) {
     // Find the external network using the given (or default) network name.
     var listParams = {
         name: externalNetworkName || opts.config.externalNetwork || 'external',
-        fabric: false,
         provisionable_by: opts.account.uuid
     };
 
@@ -717,12 +715,10 @@ function externalNetworkByName(opts, container, payload, callback) {
  * (typically the external/public pool).
  */
 function defaultFabricNetwork(opts, payload, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.object(opts.app.config, 'opts.app.config');
     assert.string(opts.app.config.datacenterName,
         'opts.app.config.datacenterName');
-    assert.object(opts.log, 'opt.log');
     assert.object(payload, 'payload');
     assert.func(callback, 'callback');
 
@@ -772,13 +768,10 @@ function addRulesToPayload(payload, rules) {
  * returns the link details via the callback.
  */
 function getLinkDetails(opts, configLinks, vm_payload, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.vmapi, 'opts.app.vmapi');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     if (!configLinks) {
         callback();
@@ -983,9 +976,7 @@ function applyLinksToMetadata(im, linkDetails) {
 }
 
 function storeLinks(opts, linkDetails, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
+    assertOptsAppLog(opts, true);
     assert.object(linkDetails, 'linkDetails');
     assert.func(callback, 'callback');
 
@@ -1009,11 +1000,9 @@ function storeLinks(opts, linkDetails, callback) {
 }
 
 function deleteLinks(opts, cb) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
     assert.object(opts.vm, 'opts.vm');
-    assert.object(opts.app, 'opts.app');
     assert.object(opts.account, 'opts.account');
-    assert.object(opts.log, 'opts.log');
     assert.func(cb, 'cb');
 
     var log = opts.log;
@@ -1064,10 +1053,8 @@ function deleteLinks(opts, cb) {
 }
 
 function renameLinks(opts, newName, callback) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
     assert.object(opts.account, 'opts.account');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
 
     var log = opts.log;
 
@@ -1510,19 +1497,20 @@ function getPackage(opts, container, callback) {
     });
 }
 
-function listDockerVms(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.account, 'opts.account');
-    assert.object(opts.vmapi, 'opts.vmapi'); // vmapi client
-    assert.object(opts.log, 'opts.log');
+function listOrCountDockerVms(opts, verb, callback) {
+    assertOptsReqIdAccount(opts, true);
+    var vmapi = opts.vmapi;
+    assert.object(vmapi);
     assert.optionalBool(opts.all, 'opts.all'); // docker ps -a
     assert.optionalBool(opts.one, 'opts.one'); // docker stop/start
+    assert.ok(verb === 'list' || verb === 'count');
     assert.func(callback, 'callback');
-
+    var vmapiCommand = verbToMethod(verb, 'vmapi');
+    var headers = {headers: {'x-request-id': opts.req_id}};
     var params = {};
 
     // query for one vm or all vms must include running/stopped
-    if (opts.one || opts.all) {
+    if (verb === 'count' || opts.one || opts.all) {
         params.predicate = JSON.stringify({
             and: [
                 { eq: [ 'docker', true ] },
@@ -1545,20 +1533,21 @@ function listDockerVms(opts, callback) {
         });
     }
 
-    opts.vmapi.listVms(params, {
-        headers: {'x-request-id': opts.req_id}
-    }, function _listVmsCb(err, vms, _req, _res) {
+    vmapi[vmapiCommand](params, headers, function (err, ret, _req, _res) {
         if (err) {
-            opts.log.error(err, 'Error retrieving Virtual Machines');
+            opts.log.error(err, 'Error retrieving Virtual Machine ' + verb);
             return callback(errors.vmapiErrorWrap(
-                err, 'problem retrieving virtual machines'));
+                err, 'problem retrieving virtual machine ' + verb));
         }
 
-        opts.log.debug('Found ' + vms.length + ' VMs');
-        callback(null, vms);
+        callback(null, ret);
     });
 }
 
+function listDockerVms(opts, callback) {
+    listOrCountDockerVms(opts, 'list', callback);
+}
+
 function ltrim(str, chars)
 {
     chars = chars || '\\s';
@@ -1587,12 +1576,9 @@ function publishingPorts(container) {
  * to the user.
  */
 function buildVmPayload(opts, container, callback) {
-    assert.object(opts, 'opts');
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.config, 'opts.config');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.app, 'opts.app');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
     assert.object(opts.image, 'opts.image');
     assert.object(opts.vmapi, 'opts.vmapi'); // vmapi client
     assert.object(container, 'container');
@@ -1881,12 +1867,8 @@ function buildVmPayload(opts, container, callback) {
             // This must happen after we've added the owner_uuid to the payload.
             // ...and is where we add --volumes-from volumes.
 
-            var get_opts = {
-                account: opts.account,
-                log: log,
-                req_id: opts.req_id,
-                vmapi: opts.vmapi
-            };
+            var get_opts = cropOpts(opts, ['account', 'log', 'req_id',
+                'vmapi']);
             var vf_containers = [];
 
             function _addContainerVolumes(source, next) {
@@ -2289,10 +2271,7 @@ function findContainerIdMatch(id, objects) {
  * Find this container id from the list of all docker containers.
  */
 function getVmById(id, opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true);
     assert.object(opts.vmapi, 'opts.vmapi');
 
     var log = opts.log;
@@ -2351,39 +2330,8 @@ function loadPackages(opts, callback) {
 //---- exported SdcBackend methods
 
 function getContainerCount(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    var vmapi = getVmapiClient(this.config.vmapi);
-    var params = {
-        predicate: JSON.stringify({
-            and: [
-                { eq: [ 'docker', true ] },
-                { and:
-                    [
-                        { ne: [ 'state', 'failed' ] },
-                        { ne: [ 'state', 'destroyed' ] }
-                    ]
-                },
-                { eq: [ 'owner_uuid', opts.account.uuid ] }
-            ]
-        })
-    };
-
-    vmapi.countVms(params, {
-        headers: {'x-request-id': opts.req_id}
-    }, function _countVmsCb(err, vmcount, _req, _res) {
-        if (err) {
-            opts.log.error(err, 'Error retrieving Virtual Machine count');
-            return callback(errors.vmapiErrorWrap(
-                err, 'problem retrieving virtual machine count'));
-        }
-
-        callback(null, vmcount);
-    });
+    opts.vmapi = getVmapiClient(this.config.vmapi);
+    listOrCountDockerVms(opts, 'count', callback);
 }
 
 /*
@@ -2392,10 +2340,8 @@ function getContainerCount(opts, callback) {
  * builds an array of docker container objects.
  */
 function getContainersForVms(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.pkgmapUtoN, 'opts.pkgmapUtoN');
     assert.array(opts.vmobjs, 'opts.vmobjs');
     assert.func(callback, 'callback');
@@ -2409,15 +2355,13 @@ function getContainersForVms(opts, callback) {
             owner_uuid: vmobj.owner_uuid
         }, function (err, fwrules) {
             if (err) {
-                callback(err);
+                cb(err);
                 return;
             }
 
-            utils.vmobjToContainer({
-                clientApiVersion: opts.clientApiVersion,
-                app: opts.app,
-                log: opts.log
-            }, vmobj, fwrules, function _addPkgLabel(e, container) {
+            utils.vmobjToContainer(
+                cropOpts(opts, ['clientApiVersion', 'app', 'log']),
+                vmobj, fwrules, function _addPkgLabel(e, container) {
                 if (!e) {
                     if (pkgmapUtoN.hasOwnProperty(vmobj.billing_id)) {
                         // We've got the package available, so attach to the
@@ -2458,19 +2402,16 @@ function getContainersForVms(opts, callback) {
 }
 
 function getContainers(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.account, 'opts.account');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.uuid(opts.account.uuid, 'opts.account.uuid');
     assert.optionalBool(opts.all, 'opts.all');
-    assert.object(opts.app, 'opts.app');
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.config.fwapi, 'opts.app.config.fwapi');
     assert.object(opts.app.config.papi, 'opts.app.config.papi');
     assert.object(opts.app.vmapi, 'opts.app.vmapi');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalString(opts.filters, 'opts.filters');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
 
     var filters;
     var log = opts.log || this.log;
@@ -2503,6 +2444,7 @@ function getContainers(opts, callback) {
             listDockerVms({
                 log: log,
                 req_id: opts.req_id,
+                app: opts.app,
                 account: opts.account,
                 vmapi: vmapi,
                 all: opts.all
@@ -2837,11 +2779,8 @@ function getContainers(opts, callback) {
 }
 
 function createContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalBool(opts.requireExternalNetwork,
         'opts.requireExternalNetwork');
@@ -2876,7 +2815,8 @@ function createContainer(opts, callback) {
             clientApiVersion: opts.clientApiVersion
         }, container, function (err, _vm_payload) {
             if (err) {
-                return cb(err);
+                cb(err);
+                return;
             }
             vm_payload = _vm_payload;
             if (vm_payload.internal_metadata['docker:entrypoint'] === '[]'
@@ -2935,93 +2875,148 @@ function createContainer(opts, callback) {
 }
 
 function stopContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    if (opts.timeout) {
-        assert.ok(!isNaN(opts.timeout), 'opts.timeout');
-    }
-
-    var log = opts.log || this.log;
-    var timeout = opts.timeout;
-    var vmapi = opts.app.vmapi;
+    doToContainer(opts, 'stop', callback);
+}
 
-    var stopHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var stopParams = {
+function initDoToContainerParams(opts, verb) {
+    var params = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
         idempotent: true,
         origin: opts.origin,
         owner_uuid: opts.account.uuid,
         sync: true,
-        timeout: timeout,
         uuid: opts.vm.uuid
     };
+    if (verb !== 'start') {
+        params.timeout = opts.timeout;
+    }
+    if (verb === 'kill') {
+        if ((typeof (opts.signal) === 'string')
+            && (opts.signal.match(/^[0-9]+$/))) {
 
-    log.debug('stopParams: ' + JSON.stringify(stopParams));
-    stopParams.log = log;
-
-    vmapi.stopVm(stopParams, stopHeaders, function (stop_err, job) {
-        if (stop_err) {
-            log.error(stop_err, 'Error stopping container.');
-            callback(errors.vmapiErrorWrap(
-                stop_err, 'problem stopping container'));
-            return;
+            // An integer signal being sent as a string. Fix it.
+            params.signal = Number(opts.signal);
+        } else {
+            params.signal = opts.signal;
         }
+    }
 
-        log.debug('job: ' + JSON.stringify(job));
-        callback();
-    });
+    return params;
 }
 
-function restartContainer(opts, callback) {
+function assertOptsAppLog(opts, log_mandatory) {
     assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
+    assert.object(opts.app, 'opts.app');
+    if (log_mandatory) {
+        assert.object(opts.log, 'opts.log');
+    } else {
+        assert.optionalObject(opts.log, 'opts.log');
+    }
+}
+
+function assertOptsReqIdAccount(opts, log, optional, no_account) {
+    assertOptsAppLog(opts);
     assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    if (!no_account) {
+        assert.object(opts.account, 'opts.account');
+    }
+    if (log && !optional) {
+        assert.object(opts.log, 'opts.log');
+    } else if (log && optional) {
+        assert.optionalObject(opts.log, 'opts.log');
+    }
+}
 
-    if (opts.timeout) {
+function verbToMethod(verb, svc) {
+    if (svc === 'vmapi') {
+        switch (verb) {
+        case 'start':
+            return 'startVm';
+        case 'restart':
+            return 'rebootVm';
+        case 'list':
+            return 'listVms';
+        case 'count':
+            return 'countVms';
+        case 'kill':
+            return 'killVm';
+        case 'stop':
+            return 'stopVm';
+        default:
+            assert.ok(null);
+            break;
+        }
+    } else if (svc === 'docker') {
+        switch (verb) {
+        case 'stats':
+            return 'dockerStats';
+        case 'copy':
+            return 'dockerCopy';
+        default:
+            assert.ok(null);
+            break;
+        }
+    }
+}
+
+
+function doToContainer(opts, verb, callback) {
+    assertOptsReqIdAccount(opts);
+    assert.string(verb, 'verb');
+    assert.ok(verb === 'start' || verb === 'restart'
+        || verb === 'kill' || verb === 'stop'
+        || verb === 'list' || verb === 'count');
+
+    if (verb === 'restart' && opts.timeout) {
         assert.ok(!isNaN(opts.timeout), 'opts.timeout');
     }
 
+    if (opts.signal) {
+        assert.ok((['string', 'number'].indexOf(typeof (opts.signal)) !== -1),
+            'opts.signal');
+    }
+    if (verb === 'kill' && !opts.signal) {
+        opts.signal = 'SIGKILL';
+    }
+
     var log = opts.log || this.log;
-    var timeout = opts.timeout;
     var vmapi = opts.app.vmapi;
+    var vmapiCommand = verbToMethod(verb, 'vmapi');
 
-    var restartHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var restartParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        timeout: timeout,
-        uuid: opts.vm.uuid
-    };
+    var present_tense = (verb === 'stop') ? 'stopping' : verb + 'ing';
+    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var params = initDoToContainerParams(opts, verb);
+
+    var firstFn;
+    if (verb === 'stop' || verb === 'kill') {
+        firstFn = function (_, cb) {
+            cb(null, null);
+        };
+    } else {
+        firstFn = checkForContainerUpdate;
+    }
 
     // First, check if vm needs updating, if so pass an 'update' param.
-    checkForContainerUpdate(opts, function (err, update) {
+    firstFn(opts, function (err, update) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (update) {
-            log.info('rebootVm with update');
-            restartParams['update'] = update;
+            log.info(verb + 'VM with update');
+            params['update'] = update;
         }
 
-        log.debug('restartParams: ' + JSON.stringify(restartParams));
-        restartParams.log = log;
+        log.debug(verb + 'Params: ' + JSON.stringify(params));
+        params.log = log;
 
-        vmapi.rebootVm(restartParams, restartHeaders,
-                        function (restart_err, job) {
-            if (restart_err) {
-                log.error(restart_err, 'Error restarting container.');
+        vmapi[vmapiCommand](params, headers, function (err2, job) {
+            if (err2) {
+                log.error(err2, 'Error ' + present_tense + 'ing container.');
                 callback(errors.vmapiErrorWrap(
-                    restart_err, 'problem restarting container'));
+                    err2, 'problem ' + present_tense + 'ing container'));
                 return;
             }
 
@@ -3031,59 +3026,12 @@ function restartContainer(opts, callback) {
     });
 }
 
-function killContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    if (opts.signal) {
-        assert.ok((['string', 'number'].indexOf(typeof (opts.signal)) !== -1),
-            'opts.signal');
-    }
-
-    var log = opts.log || this.log;
-    var vmapi = opts.app.vmapi;
-
-    var killHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var killParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        idempotent: true,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        uuid: opts.vm.uuid
-    };
-
-    if (!opts.signal) {
-        opts.signal = 'SIGKILL';
-    }
-
-    if ((typeof (opts.signal) === 'string')
-        && (opts.signal.match(/^[0-9]+$/))) {
-
-        // An integer signal being sent as a string. Fix it.
-        killParams.signal = Number(opts.signal);
-    } else {
-        killParams.signal = opts.signal;
-    }
-
-    log.debug('killParams: ' + JSON.stringify(killParams));
-    killParams.log = log;
-
-    vmapi.killVm(killParams, killHeaders, function (kill_err, job) {
-        if (kill_err) {
-            // caller must log
-            callback(errors.vmapiErrorWrap(
-                kill_err,
-                'problem sending signal to container'));
-            return;
-        }
+function restartContainer(opts, callback) {
+    doToContainer(opts, 'restart', callback);
+}
 
-        log.debug('job: ' + JSON.stringify(job));
-        callback();
-    });
+function killContainer(opts, callback) {
+    doToContainer(opts, 'kill', callback);
 }
 
 /**
@@ -3147,78 +3095,33 @@ function checkForContainerUpdate(opts, callback) {
 
 
 function startContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    doToContainer(opts, 'start', callback);
+}
+
+
+
+function deleteContainer(opts, callback) {
+    assertOptsReqIdAccount(opts, true, true);
+    assert.bool(opts.force, 'opts.force');
+    assert.bool(opts.link, 'opts.link');
+    assert.string(opts.id, 'opts.id');
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
 
-    var startHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var startParams = {
+    var deleteHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var deleteParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
-        idempotent: true,
         origin: opts.origin,
         owner_uuid: opts.account.uuid,
         sync: true,
         uuid: opts.vm.uuid
     };
 
-    // First, check if vm needs updating, if so pass an 'update' param.
-    checkForContainerUpdate(opts, function (err, update) {
-        if (err) {
-            return callback(err);
-        }
-
-        if (update) {
-            log.info('startVm with update');
-            startParams['update'] = update;
-        }
-
-        log.debug('startParams: ' + JSON.stringify(startParams));
-        startParams.log = log;
-
-        vmapi.startVm(startParams, startHeaders, function (start_err, job) {
-            if (start_err) {
-                log.error(start_err, 'Error starting container.');
-                return callback(errors.vmapiErrorWrap(start_err,
-                    'problem starting container'));
-            }
-
-            log.debug({job: job}, 'created start job');
-            callback();
-        });
-    });
-}
-
-
-function deleteContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.bool(opts.force, 'opts.force');
-    assert.bool(opts.link, 'opts.link');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.string(opts.id, 'opts.id');
-    assert.object(opts.account, 'opts.account');
-
-    var log = opts.log || this.log;
-    var vmapi = opts.app.vmapi;
-
-    var deleteHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var deleteParams = {
-        context: opts.context,
-        creator_uuid: opts.creator_uuid,
-        origin: opts.origin,
-        owner_uuid: opts.account.uuid,
-        sync: true,
-        uuid: opts.vm.uuid
-    };
-
-    var data_prefix;
-    var data_volumes = [];
-    var volume_users = [];
+    var data_prefix;
+    var data_volumes = [];
+    var volume_users = [];
 
     // Sanity check for accidently deleting a container via link.
     if (opts.link) {
@@ -3249,6 +3152,7 @@ function deleteContainer(opts, callback) {
     // Sanity check for deleting a container sharing its volumes.
     listDockerVms({
         log: log,
+        app: opts.app,
         req_id: opts.req_id,
         account: opts.account,
         vmapi: vmapi,
@@ -3336,10 +3240,8 @@ function deleteContainer(opts, callback) {
 
 
 function deleteLink(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.string(opts.link, 'opts.link');
-    assert.optionalObject(opts.log, 'opts.log');
 
     var linkAlias = opts.link;
     var log = opts.log || this.log;
@@ -3391,13 +3293,11 @@ function deleteLink(opts, callback) {
 
 
 function inspectContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.object(opts.app.config, 'opts.app.config');
     assert.object(opts.app.config.fwapi, 'opts.app.config.fwapi');
     assert.object(opts.app.config.papi, 'opts.app.config.papi');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.optionalObject(opts.log, 'opts.log');
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.vm, 'opts.vm');
     assert.string(opts.vm.billing_id, 'opts.vm.billing_id');
@@ -3473,10 +3373,7 @@ function inspectContainer(opts, callback) {
 }
 
 function psContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true, true);
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
@@ -3524,10 +3421,7 @@ function psContainer(opts, callback) {
 }
 
 function waitContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+    assertOptsReqIdAccount(opts, true, true);
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
@@ -3572,13 +3466,9 @@ function waitContainer(opts, callback) {
 // execStart will send the same parameters along.
 //
 function execContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
     assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     _runCreateSocket(opts, function (err, cmdId, socketData) {
         if (err) {
@@ -3593,11 +3483,9 @@ function execContainer(opts, callback) {
 
 
 function execStart(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts, true);
     assert.string(opts.cmdId, 'opts.cmdId');
     assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.socketData, 'opts.socketData');
     assert.object(opts.account, 'opts.account');
     assert.object(opts.socket, 'opts.socket');
@@ -3615,12 +3503,9 @@ function execStart(opts, callback) {
 
 
 function _runCreateSocket(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log;
     var payload = opts.payload;
@@ -3736,15 +3621,14 @@ function _createLinestreamParser(opts, toSocket) {
     return lstream;
 }
 
-
-function _runExec(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.string(opts.cmdId, 'opts.cmdId');
+function _runAttachOrExec(opts, verb, callback) {
+    assertOptsAppLog(opts, true);
+    assertOptsReqIdAccount(opts);
+    assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
     assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
     assert.object(opts.socketData, 'opts.socketData');
     assert.object(opts.socket, 'opts.socket');
+    assert.ok(verb === 'attach' || verb === 'exec');
 
     // Make sure our callbacks get called only once
     var cb = once(callback);
@@ -3755,119 +3639,18 @@ function _runExec(opts, callback) {
     var clientSocket = opts.socket;
 
     var cmdString = socketData.command.Cmd.join(' ');
-    var serverSocket = net.createConnection({ host: host, port: port });
-
-    // Store a reference to the exec socket for future resizes
-    socketData.socket = serverSocket;
-
-    function writeData(stream, data, writeCb) {
-        data = JSON.stringify(data) + '\r\n';
-
-        if (writeCb) {
-            stream.write(data, writeCb);
-        } else {
-            stream.write(data);
-        }
-    }
-
-    function writeEnd(stream, writeCb) {
-        var data = JSON.stringify({
-            type: 'end'
-        }) + '\r\n';
-
-        stream.write(data, writeCb);
-    }
-
-    function _endSocket(error) {
-        if (error) {
-            opts.log.error('client socket %s threw an error %s',
-                cmdString, error.toString());
-        }
-        serverSocket.end();
-        cb(error, socketData);
-    }
-
-    var endSocket = once(_endSocket);
-
-    serverSocket.on('connect', setupListeners);
-
-    // error can happen before connect too (eg. ECONNREFUSED)
-    serverSocket.on('error', function _onServerSocketError(error) {
-        opts.log.error('serverSocket for %s threw an error %s',
-            cmdString, error.toString());
-
-        cb(error);
-    });
-
-    function setupListeners() {
-        if (socketData.command.AttachStdin) {
-            clientSocket.on('data', function (chunk) {
-                var type = socketData.command.Tty ? 'tty' : 'stdin';
-                writeData(serverSocket, {
-                    type: type,
-                    data: chunk.toString()
-                });
-            });
-        }
-
-        clientSocket.on('end', function () {
-            if (!serverSocket.destroyed) {
-                writeEnd(serverSocket, function () {
-                    opts.log.info('clientSocket has closed its stdin');
-                });
-            }
-        });
-
-        clientSocket.on('error', endSocket);
-        clientSocket.on('timeout', endSocket);
-
-        serverSocket.on('close', function (had_error) {
-            opts.log.debug('serverSocket %s closed, had_error=%s',
-                cmdString, had_error);
 
-            endSocket();
-        });
-
-        serverSocket.on('end', function () {
-            opts.log.debug('serverSocket %s end', cmdString);
-        });
-
-        var lstream = _createLinestreamParser({
-            log: opts.log,
-            socketData: socketData
-        }, clientSocket);
-        serverSocket.pipe(lstream);
+    var serverSocket;
+    if (verb === 'attach') {
+        serverSocket = socketData.socket;
     }
-}
-
-
-function _runAttach(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
-    assert.optionalString(opts.id, 'opts.id');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.socketData, 'opts.socketData');
-    assert.object(opts.socket, 'opts.socket');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
-    // Make sure our callbacks get called only once
-    var cb = once(callback);
-
-    var socketData = opts.socketData;
-    var host = socketData.host;
-    var port = socketData.port;
-    var clientSocket = opts.socket;
-
-    var cmdString = socketData.command.Cmd.join(' ');
 
-    var serverSocket = socketData.socket;
     if (!serverSocket) {
         serverSocket = net.createConnection({ host: host, port: port });
         serverSocket.on('connect', setupListeners);
+        // error can happen before connect too (eg. ECONNREFUSED)
         serverSocket.on('error', function (error) {
-            opts.log.debug('attach for %s threw an error %',
+            opts.log.debug(verb + ' for %s threw an error %',
                 cmdString, error.toString());
 
             cb(error);
@@ -3876,9 +3659,14 @@ function _runAttach(opts, callback) {
         socketData.socket = serverSocket;
 
         // Store socket reference immediately
-        opts.app.sockets.setSocket('attach', opts.id, socketData);
+        // For 'exec' we already have it set via _runCreateSocket inside of
+        // execContainer
+        if (verb === 'attach') {
+            opts.app.sockets.setSocket('attach', opts.id, socketData);
+        }
     } else {
         // Reuse an existing attach session for a new client socket
+        assert.ok(verb === 'attach');
         setupListeners();
     }
 
@@ -3908,24 +3696,32 @@ function _runAttach(opts, callback) {
                 opts.log.error('client socket %s threw an error %s',
                     cmdString, error.toString());
                 serverSocket.end();
-                cb(error);
+                // Not sure why these differ in _runAttach and _runExec
+                if (verb === 'attach') {
+                    cb(error);
+                } else {
+                    cb(error, socketData);
+                }
                 return;
             }
-            waitContainer({
-                account: opts.account,
-                app: opts.app,
-                log: opts.log,
-                req_id: opts.req_id,
-                vm: opts.vm
-            }, function (err, statusCode) {
-                if (err) {
-                    opts.log.error(err, 'error waiting for container to stop');
-                    lstream.end();
-                    return;
-                }
-                serverSocket.end();
-                cb(error);
-            });
+            if (verb === 'attach') {
+                waitContainer({
+                    account: opts.account,
+                    app: opts.app,
+                    log: opts.log,
+                    req_id: opts.req_id,
+                    vm: opts.vm
+                }, function (err, statusCode) {
+                    if (err) {
+                        opts.log.error(err, 'error waiting for container'
+                            + ' to stop');
+                        lstream.end();
+                        return;
+                    }
+                    serverSocket.end();
+                    cb(error);
+                });
+            }
         }
 
         var endSocket = once(_endSocket);
@@ -3934,7 +3730,7 @@ function _runAttach(opts, callback) {
         // resizing the console so our socket supports resize and data message
         // types. Resize messages are queued by docker when calling
         // /containers/id/resize
-        function onData(chunk) {
+        function onDataAttach(chunk) {
             if (!socketData.command.Tty) {
                 writeData(serverSocket, {
                     type: 'stdin',
@@ -3963,45 +3759,71 @@ function _runAttach(opts, callback) {
             }
         }
 
+        function onDataExec(chunk) {
+            var type = socketData.command.Tty ? 'tty' : 'stdin';
+            writeData(serverSocket, {
+                type: type,
+                data: chunk.toString()
+            });
+        }
+
         if (socketData.command.AttachStdin) {
-            clientSocket.on('data', onData);
+            if (verb === 'attach') {
+                clientSocket.on('data', onDataAttach);
+            } else {
+                clientSocket.on('data', onDataExec);
+            }
         }
 
         clientSocket.on('end', function () {
-            writeEnd(serverSocket, function () {
-                opts.log.info('clientSocket has closed its stdin');
-            });
+            if ((verb === 'exec' && !serverSocket.destroyed)
+                || verb === 'attach') {
+
+                writeEnd(serverSocket, function () {
+                    opts.log.info('clientSocket has closed its stdin');
+                });
+            }
         });
 
         clientSocket.on('error', endSocket);
         clientSocket.on('timeout', endSocket);
 
         serverSocket.on('close', function (had_error) {
-            opts.log.debug('attach %s closed, had_error=%s',
+            opts.log.debug(verb + ' %s closed, had_error=%s',
                 cmdString, had_error);
 
             endSocket();
         });
 
         serverSocket.on('end', function () {
-            opts.log.debug('attach %s end', cmdString);
+            opts.log.debug(verb + ' %s end', cmdString);
         });
 
-        var lstream = _createLinestreamParser({
-            doNotEncodeData: opts.doNotEncodeData,
-            noCloseOnSocketEnd: true,
+        var lstream_params = {
             log: opts.log,
             socketData: socketData
-        }, clientSocket);
+        };
+        if (verb === 'attach') {
+            lstream_params.doNotEncodeData = opts.doNotEncodeData;
+            lstream_params.noCloseOnSocketEnd = true;
+        }
+        var lstream = _createLinestreamParser(lstream_params, clientSocket);
         serverSocket.pipe(lstream);
     }
 }
 
+function _runExec(opts, callback) {
+    _runAttachOrExec(opts, 'exec', callback);
+}
+
+
+function _runAttach(opts, callback) {
+    _runAttachOrExec(opts, 'attach', callback);
+}
+
 
 function execResize(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
+    assertOptsAppLog(opts, true);
     assert.object(opts.account, 'opts.account');
     assert.object(opts.socketData, 'opts.socketData');
     assert.number(opts.w, 'opts.w');
@@ -4016,67 +3838,11 @@ function execResize(opts, callback) {
     socket.write(data, callback);
 }
 
-
 /*
  * attachContainer resuses _runAttach and _runCreateSocket
  */
 function attachContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.payload, 'opts.payload');
-    assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.socket, 'opts.socket');
-    assert.object(opts.vm, 'opts.vm');
-    assert.object(opts.account, 'opts.account');
-
-    var log = opts.log;
-    var socketData = opts.app.sockets.getSocket('attach', opts.id);
-
-    vasync.pipeline({
-        funcs: [
-            createSocket,
-            attach
-        ]
-    }, callback);
-
-
-    function createSocket(_, next) {
-        if (socketData) {
-            opts.socketData = socketData;
-            next();
-            return;
-        }
-
-        _runCreateSocket(opts, function (err, cmdId, data) {
-            if (err) {
-                log.error({err: err}, 'backend.attachContainer error');
-                next(err);
-                return;
-            }
-
-            opts.socketData = data;
-            next();
-        });
-    }
-
-    function attach(_, next) {
-        _runAttach(opts, function (execErr) {
-            // Cleanup regardless of the error
-            opts.app.sockets.removeSocket('attach', opts.id);
-            opts.socket.end();
-
-            if (execErr) {
-                log.error({err: execErr}, 'backend._runAttach error');
-                next(execErr);
-                return;
-            }
-
-            next();
-        });
-    }
+    attachOrLogs(opts, 'attach', callback);
 }
 
 
@@ -4135,10 +3901,8 @@ function renameContainer(opts, callback) {
  * should be resized
  */
 function resizeContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsAppLog(opts);
     assert.string(opts.id, 'opts.id');
-    assert.optionalObject(opts.log, 'opts.log');
     assert.number(opts.w, 'opts.w');
     assert.number(opts.h, 'opts.h');
 
@@ -4146,37 +3910,48 @@ function resizeContainer(opts, callback) {
     callback();
 }
 
-
-/*
- * containerLogs resuses _runExec and _runCreateSocket
- */
-function containerLogs(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+function attachOrLogs(opts, verb, callback) {
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
     assert.object(opts.vm, 'opts.vm');
+    assert.ok(verb === 'logs' || verb === 'attach');
+    if (verb === 'attach') {
+        assertOptsAppLog(opts);
+        assert.string(opts.id, 'opts.id');
+        assert.optionalBool(opts.doNotEncodeData, 'doNotEncodeData');
+        assert.object(opts.socket, 'opts.socket');
+    }
 
     var log = opts.log;
+    var socketData = (verb === 'attach') ?
+            opts.app.sockets.getSocket('attach', opts.id) : null;
+    var firstFn = _runCreateSocket;
+    if (verb === 'attach' && socketData) {
+        firstFn = function (_, cb) {
+            cb(null, null, socketData);
+        };
+    }
 
-    _runCreateSocket(opts, function (err, cmdId, socketData) {
+    var nextFn = (verb === 'attach') ? _runAttach : _runExec;
+
+    firstFn(opts, function (err, cmdId, data) {
         if (err) {
             log.error({err: err}, 'backend.containerLogs error');
             callback(err);
             return;
         }
 
-        opts.cmdId = cmdId;
-        opts.socketData = socketData;
+        if (verb === 'logs') {
+            opts.cmdId = cmdId;
+        }
+        opts.socketData = data;
 
-        _runExec(opts, function (execErr) {
+        nextFn(opts, function (execAttachErr) {
             opts.socket.end();
 
-            if (execErr) {
-                log.error({err: execErr}, 'backend.containerLogs error');
-                callback(execErr);
+            if (execAttachErr) {
+                log.error({err: execAttachErr}, 'backend.containerLogs error');
+                callback(execAttachErr);
                 return;
             }
 
@@ -4185,12 +3960,17 @@ function containerLogs(opts, callback) {
     });
 }
 
+/*
+ * containerLogs resuses _runExec and _runCreateSocket
+ */
+function containerLogs(opts, callback) {
+    attachOrLogs(opts, 'logs', callback);
+}
+
 
 function dockerExec(opts, callback) {
-    assert.object(opts, 'opts');
+    assertOptsReqIdAccount(opts, true, false, true);
     assert.object(opts.payload, 'opts.payload');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.cnapi, 'opts.cnapi');
 
     var e;
@@ -4227,26 +4007,22 @@ function dockerExec(opts, callback) {
 
 
 function copyContainer(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.app, 'opts.app');
+    assertOptsReqIdAccount(opts);
     assert.object(opts.payload, 'opts.payload');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
 
     var log = opts.log;
     var payload = opts.payload;
 
-    dockerCopy({
+    containerArchiveReadStream({
         log: log,
         payload: payload,
         req_id: opts.req_id,
         account: opts.account,
         cnapi: opts.app.cnapi,
         vm: opts.vm
-    }, function (copyErr, stream) {
-        if (copyErr) {
-            callback(copyErr);
+    }, function (err, stream) {
+        if (err) {
+            callback(err);
             return;
         }
 
@@ -4255,89 +4031,76 @@ function copyContainer(opts, callback) {
 }
 
 
-function dockerCopy(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.payload, 'opts.payload');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
+function containerArchiveRWStream(opts, verb, mode, callback) {
+    assertOptsReqIdAccount(opts, true, false, true);
+    assert.string(mode, 'mode');
+    assert.string(verb, 'verb');
+    assert.optionalObject(opts.payload, 'opts.payload');
+    assert.optionalString(opts.path, 'opts.path');
+    assert.ok(opts.path || opts.payload);
+    assert.ok(verb === 'copy' || verb === 'stats');
+    if (verb === 'copy')
+        assert.ok(mode === 'read' || mode === 'write' || mode === 'stat');
+    assert.object(opts.vm, 'opts.vm');
     assert.object(opts.cnapi, 'opts.cnapi');
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var dockerCommand = verbToMethod(verb, 'docker');
+    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var params;
+    if (opts.path) {
+        params = {
+            path: opts.path
+        };
+    } else {
+        params = {
+            payload: opts.payload
+        };
+    }
+    params.mode = (verb !== 'stats') ? mode : undefined;
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload,
-        mode: 'read'
-    }, copyHeaders, onCopy);
+    cnapi[dockerCommand](opts.vm.server_uuid, opts.vm.uuid, params,
+        headers, onCommand);
 
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
+    function onCommand(err, res) {
+        if (err) {
+            log.error(err, 'error calling docker-' + verb);
+            if (err.restCode === 'VmNotRunning') {
+                callback(new errors.NotImplementedError(
                     'copy on stopped container'));
+                return;
             }
-            log.error(copyErr, 'error calling docker-copy');
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            callback(errors.cnapiErrorWrap(
+                err, 'problem calling docker ' + verb));
+            return;
         }
 
         var host = res.host;
         var port = res.port;
 
-        var copySocket = net.createConnection({ host: host, port: port });
+        var socket = net.createConnection({ host: host, port: port });
 
-        callback(null, copySocket);
+        if (opts.path && verb === 'copy' && mode === 'read') {
+            callback(null, socket, {
+                containerPathStat: res.containerPathStat });
+        } else if (opts.path && verb === 'copy' && mode === 'stat') {
+            callback(null, {containerPathStat: res.containerPathStat });
+        } else {
+            callback(null, socket);
+        }
     }
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
  * then connect to that server and pipe it's stream to the our client.
  */
-
 function containerArchiveReadStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'read'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket, {
-            containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'copy', 'read', callback);
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
@@ -4345,46 +4108,7 @@ function containerArchiveReadStream(opts, callback) {
  */
 
 function containerArchiveWriteStream(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.string(opts.path, 'opts.path');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    var copyOpts = {
-        path: opts.path,
-        mode: 'write'
-    };
-
-    if (opts.no_overwrite_dir) {
-        copyOpts.no_overwrite_dir = true;
-    }
-
-    cnapi.dockerCopy(
-        opts.vm.server_uuid, opts.vm.uuid, copyOpts, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        var copySocket = net.createConnection({ host: host, port: port });
-
-        callback(null, copySocket);
-    }
+    containerArchiveRWStream(opts, 'copy', 'write', callback);
 }
 
 
@@ -4394,67 +4118,12 @@ function containerArchiveWriteStream(opts, callback) {
  */
 
 function containerArchiveStat(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.vm, 'opts.vm');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.cnapi, 'opts.cnapi');
-    assert.string(opts.path, 'opts.path');
-
-    var log = opts.log;
-    var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'stat'
-    }, copyHeaders, onCopy);
-
-    function onCopy(copyErr, res) {
-        if (copyErr) {
-            log.error(copyErr, 'error calling docker-copy');
-            if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
-            }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
-        }
-
-        callback(null, { containerPathStat: res.containerPathStat });
-    }
+    containerArchiveRWStream(opts, 'copy', 'stat', callback);
 }
 
 
 function containerStats(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.payload, 'opts.payload');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.socket, 'opts.socket');
-
-    var log = opts.log;
-    var cnapi = opts.app.cnapi;
-    var headers = { headers: { 'x-request-id': opts.req_id } };
-
-    cnapi.dockerStats(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload
-    }, headers, function (err, res) {
-        if (err) {
-            log.error(err, 'error calling docker-stats');
-            return callback(errors.cnapiErrorWrap(
-                err, 'problem calling docker stats'));
-        }
-
-        var host = res.host;
-        var port = res.port;
-
-        log.debug('containerStats server on host: ', host, 'port: ', port);
-
-        var statsSocket = net.createConnection({ host: host, port: port });
-
-        callback(null, statsSocket);
-    });
+    containerArchiveRWStream(opts, 'stats', null, callback);
 }
 
 
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index 32b8318..c889bc7 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -893,7 +893,7 @@ function compressPorts(ports) {
     var sorted = [], ranges = [];
     var port, i;
     if (ports.length === 0) {
-        return;
+        return ranges;
     }
 
     for (i = 0; i < ports.length; i++) {
diff --git a/lib/endpoints/containers.js b/lib/endpoints/containers.js
index c1041d4..7916d92 100644
--- a/lib/endpoints/containers.js
+++ b/lib/endpoints/containers.js
@@ -307,11 +307,10 @@ function containerStats(req, res, next) {
 
     req.backend.containerStats({
         account: req.account,
-        app: req.app,
+        cnapi: req.app.cnapi,
         log: log,
         payload: payload,
         req_id: req.getId(),
-        socket: req.socket,
         vm: req.vm
     }, function (err, statsSocket) {
             if (err) {
-- 
2.21.0

