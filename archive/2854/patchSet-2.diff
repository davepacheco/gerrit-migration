commit 9a914e898daf7eb58af3ff380d9b67d80e1c1e07 (refs/changes/54/2854/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-10-24T22:08:15-07:00 (1 year, 11 months ago)
    
    CMON-74 Want RFD94 global zone metrics and discovery

diff --git a/lib/cn-filter.js b/lib/cn-filter.js
index 04da12a..efb48bb 100644
--- a/lib/cn-filter.js
+++ b/lib/cn-filter.js
@@ -60,7 +60,7 @@ util.inherits(CNFilter, stream.Transform);
 
 CNFilter.prototype.updateServers = function (cb) {
 	var self = this;
-	self.client.get('/servers?extras=status',
+	self.client.get('/servers?extras=status,sysinfo',
 	    function (err, req, res, objs) {
 		if (err) {
 			self.log.warn(err,
@@ -77,6 +77,7 @@ CNFilter.prototype.updateServers = function (cb) {
 			var newObj = cutServerObj(obj);
 
 			self.cache[obj.uuid] = newObj;
+			self.pushFakeVM(newObj);
 
 			if (oldObj && newObj.down !== oldObj.down) {
 				self.log.info({
@@ -95,6 +96,44 @@ CNFilter.prototype.updateServers = function (cb) {
 	});
 };
 
+CNFilter.prototype.pushFakeVM = function (server) {
+	/*
+	 * So, this is a somewhat awful hack. We want to generate CMON records
+	 * for each CN, at $uuid.cmon.suffix. To do this, we push onto the
+	 * pipeline here a "fake" VM for each CN.
+	 *
+	 * The fake VM is owned by admin and has to have a smartdc_role tag
+	 * set so that the admin force-listing kicks in. However, we don't want
+	 * to actually list any of its IP addresses in DNS or else some
+	 * operators who like their security by obscurity will have a fit.
+	 *
+	 * So we copy across only an admin NIC for the server. The code in
+	 * net-filter.js will cleave this NIC out for us, but set everything
+	 * else up properly, and we will generate only CMON records since we
+	 * have no listable IP addresses left. Winner.
+	 */
+	var vm = {
+		uuid: server.uuid,
+		state: 'running',
+		owner_uuid: 'admin',
+		server_uuid: server.uuid,
+		server: server,
+		customer_metadata: {},
+		tags: {
+			'smartdc_role': server.hostname
+		},
+		nics: server.nics.filter(function (nic) {
+			return (nic.mac && nic.ip && nic.nic_tag === 'admin');
+		}),
+		origin: 'fake-cn',
+		alias: server.hostname
+	};
+	vm.timers = vm.timers || [];
+	vm.timers.push({t: new Date(), n: 'cn-filter'});
+	this.log.trace({vm: vm}, 'pushing fake CN vm');
+	this.push(vm);
+};
+
 CNFilter.prototype._transform = function (vm, enc, cb) {
 	assert.object(vm, 'vm');
 	if (typeof (vm.server_uuid) !== 'string') {
@@ -134,6 +173,7 @@ function cutServerObj(obj) {
 	cutObj.uuid = obj.uuid;
 	assert.string(obj.status);
 	cutObj.status = obj.status;
+	cutObj.hostname = obj.hostname;
 
 	assert.string(obj.last_boot);
 	cutObj.last_boot = new Date(obj.last_boot);
@@ -152,6 +192,57 @@ function cutServerObj(obj) {
 	cutObj.last_heartbeat = new Date(obj.last_heartbeat);
 	cutObj.heartbeat_age = (new Date()) - cutObj.last_heartbeat;
 
+	cutObj.nics = {};
+	if (typeof (obj.sysinfo) === 'object' && obj.sysinfo !== null) {
+		var nics = obj.sysinfo['Network Interfaces'];
+		assert.object(nics);
+		assert.ok(nics);
+
+		cutObj.nics = [];
+
+		Object.keys(nics).forEach(function (k) {
+			var n = nics[k];
+			var o = {
+				mac: n['MAC Address'],
+				ip: n['ip4addr']
+			};
+			if (n['NIC Names'].length === 1)
+				o.nic_tag = n['NIC Names'][0];
+			else if (n['NIC Names'].indexOf('admin') !== -1)
+				o.nic_tag = 'admin';
+			else if (n['NIC Names'].indexOf('external') !== -1)
+				o.nic_tag = 'external';
+			else
+				o.nic_tag = n['NIC Names'][0];
+			n.nic_tag = o.nic_tag;
+			if (!o.mac || !o.nic_tag || !o.ip)
+				return;
+			cutObj.nics.push(o);
+		});
+
+		var vnics = obj.sysinfo['Virtual Network Interfaces'];
+		if (typeof (vnics) === 'object' && vnics !== null) {
+			Object.keys(vnics).forEach(function (k) {
+				var n = vnics[k];
+				var vlan = n['VLAN'];
+				if (typeof (vlan) === 'string')
+					vlan = parseInt(vlan, 10);
+				if (!isFinite(vlan))
+					vlan = undefined;
+				var o = {
+					mac: n['MAC Address'],
+					ip: n['ip4addr'],
+					vlan_id: vlan
+				};
+				var h = nics[n['Host Interface']];
+				o.nic_tag = h.nic_tag;
+				if (!o.mac || !o.nic_tag || !o.ip)
+					return;
+				cutObj.nics.push(o);
+			});
+		}
+	}
+
 	/*
 	 * "CN that is not running" includes CNs with a non-"running" status
 	 * and a last_heartbeat >1min ago, those that have not heartbeated in
diff --git a/lib/napi-legacy-filter.js b/lib/napi-legacy-filter.js
index 19764e5..37b5a70 100644
--- a/lib/napi-legacy-filter.js
+++ b/lib/napi-legacy-filter.js
@@ -76,7 +76,7 @@ NAPILegacyFilter.prototype._transform = function (vm, enc, cb) {
 	vasync.forEachParallel({
 		inputs: nicsToFix,
 		func: fixNic
-	}, function (err) {
+	}, function (err, res) {
 		if (err) {
 			self.log.warn({
 			    vm: vm.uuid,
@@ -97,7 +97,17 @@ NAPILegacyFilter.prototype._transform = function (vm, enc, cb) {
 
 	function fixNic(nic, ccb) {
 		self.getNic(nic.mac, function (err, napiObj) {
-			if (err) {
+			if (err && err.statusCode === 404) {
+				self.guessNetwork(nic, function (err2, uuid) {
+					if (err2) {
+						ccb(err2);
+						return;
+					}
+					nic.network_uuid = uuid;
+					ccb();
+				});
+				return;
+			} else if (err) {
 				ccb(err);
 				return;
 			}
@@ -114,6 +124,26 @@ NAPILegacyFilter.prototype._transform = function (vm, enc, cb) {
 	}
 };
 
+NAPILegacyFilter.prototype.guessNetwork = function (nic, cb) {
+	var q = {
+		nic_tag: nic.nic_tag,
+		vlan_id: nic.vlan_id
+	};
+	q = qs.stringify(q);
+	this.client.get('/networks?' + q, function (err, req, res, objs) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		assert.arrayOfObject(objs);
+		if (objs.length === 1) {
+			cb(null, objs[0].uuid);
+		} else {
+			cb(new Error('No matching single network'));
+		}
+	});
+};
+
 NAPILegacyFilter.prototype.getNic = function (mac, cb) {
 	var v = this.cache.get(mac);
 	if (v) {
diff --git a/lib/net-filter.js b/lib/net-filter.js
index df51975..c0afaca 100644
--- a/lib/net-filter.js
+++ b/lib/net-filter.js
@@ -47,6 +47,9 @@ NetFilter.prototype._transform = function (vm, enc, cb) {
 		/*
 		 * Never allow NICs on the admin network to be listed in
 		 * CNS. These should only be found via binder.
+		 *
+		 * If you change this, make sure to visit cn-filter.js and
+		 * think about what happens to the fake CN VMs.
 		 */
 		if (nic.nic_tag === 'admin' && (nic.vlan_id === 0 ||
 		    nic.vlan_id === undefined)) {
diff --git a/lib/ufds-filter.js b/lib/ufds-filter.js
index a8cff4c..6a55fba 100644
--- a/lib/ufds-filter.js
+++ b/lib/ufds-filter.js
@@ -81,12 +81,20 @@ UfdsFilter.prototype.getUser = function (uuid, cb) {
 		return;
 	}
 
+	var uuidEq = new ldap.filters.EqualityFilter({
+		attribute: 'uuid',
+		value: uuid
+	});
+	var loginEq = new ldap.filters.EqualityFilter({
+		attribute: 'login',
+		value: uuid
+	});
+
 	var base = 'ou=users, o=smartdc';
 	var opts = {
 		scope: 'one',
-		filter: new ldap.filters.EqualityFilter({
-			attribute: 'uuid',
-			value: uuid
+		filter: new ldap.filters.OrFilter({
+			filters: [ uuidEq, loginEq ]
 		})
 	};
 
