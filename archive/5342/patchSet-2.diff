From 247cbe248512417d0c0b9defe356cb00b9c59e38 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Wed, 13 Jun 2018 18:22:09 -0500
Subject: [PATCH] OS-7503 snoop(1m) should learn about SVP

---
 usr/src/cmd/cmd-inet/usr.sbin/snoop/Makefile  |   8 +-
 usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h   |   3 +-
 .../cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c |   9 +-
 .../cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c   | 526 ++++++++++++++++++
 usr/src/lib/varpd/svp/Makefile                |   7 +-
 5 files changed, 545 insertions(+), 8 deletions(-)
 create mode 100644 usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c

diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/Makefile b/usr/src/cmd/cmd-inet/usr.sbin/snoop/Makefile
index 5d9ef9e64d..ed2882cef9 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/Makefile
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/Makefile
@@ -22,7 +22,7 @@
 #
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 PROG=	snoop
@@ -40,8 +40,8 @@ OBJS=	nfs4_xdr.o snoop.o snoop_aarp.o snoop_adsp.o snoop_aecho.o \
 	snoop_pppoe.o snoop_rip.o snoop_rip6.o snoop_rpc.o snoop_rpcprint.o \
 	snoop_rpcsec.o snoop_rport.o snoop_rquota.o snoop_rstat.o snoop_rtmp.o \
 	snoop_sctp.o snoop_slp.o snoop_smb.o snoop_socks.o snoop_solarnet.o \
-	snoop_tcp.o snoop_tftp.o snoop_trill.o snoop_udp.o snoop_vxlan.o \
-	snoop_zip.o
+	snoop_svp.o snoop_tcp.o snoop_tftp.o snoop_trill.o snoop_udp.o \
+	snoop_vxlan.o snoop_zip.o
 
 SRCS=	$(OBJS:.o=.c)
 HDRS=	snoop.h snoop_mip.h at.h snoop_ospf.h snoop_ospf6.h
@@ -51,7 +51,7 @@ include ../../../Makefile.ctf
 
 CPPFLAGS += -I. -I$(SRC)/common/net/dhcp \
 	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
-LDLIBS += -ldhcputil -ldlpi -lsocket -lnsl -ltsol
+LDLIBS += -ldhcputil -ldlpi -lsocket -lnsl -ltsol -luuid
 LDFLAGS += $(MAPFILE.NGB:%=-M%)
 CERRWARN += -_gcc=-Wno-switch
 CERRWARN += -_gcc=-Wno-implicit-function-declaration
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
index 991abae186..fc63d3987f 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop.h
@@ -24,7 +24,7 @@
  * Use is subject to license terms.
  *
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_SNOOP_H
@@ -275,6 +275,7 @@ extern int interpret_trill(int, struct ether_header **, char *, int *);
 extern int interpret_isis(int, char *, int, boolean_t);
 extern int interpret_bpdu(int, char *, int);
 extern int interpret_vxlan(int, char *, int);
+extern int interpret_svp(int, char *, int);
 extern void init_ldap(void);
 extern boolean_t arp_for_ether(char *, struct ether_addr *);
 extern char *ether_ouiname(uint32_t);
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
index 76ab7f2da0..8e474fe470 100644
--- a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_rport.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <stdio.h>
@@ -130,6 +130,7 @@ static struct porttable pt_tcp[] = {
 	{ 540,			"UUCP" },
 	{ 600,			"PCSERVER" },
 	{ IPPORT_SOCKS,		"SOCKS" },
+	{ 1296,			"SVP" },
 	{ 1524,			"INGRESLOCK" },
 	{ 2904,			"M2UA" },
 	{ 2905,			"M3UA" },
@@ -430,6 +431,12 @@ interpret_reserved(int flags, int proto, in_port_t src, in_port_t dst,
 		case IPPORT_VXLAN:
 			(void) interpret_vxlan(flags, data, dlen);
 			return (1);
+		case 1296:
+			if (proto == IPPROTO_TCP) {
+				(void) interpret_svp(flags, data, dlen);
+				return (1);
+			}
+			break;
 		}
 	}
 
diff --git a/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c
new file mode 100644
index 0000000000..a6186df4e2
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop_svp.c
@@ -0,0 +1,526 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.  All rights reserved.
+ */
+
+/*
+ * Decode SVP (SmartDC VxLAN Protocol) packets
+ */
+
+#include <inttypes.h>
+#include <sys/crc32.h>
+#include <uuid/uuid.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <libvarpd_svp_prot.h>
+#include "snoop.h"
+
+static uint32_t svp_crc32_tab[] = { CRC32_TABLE };
+
+/*
+ * buf_print() is used to construct intermediate strings to ultimately print.
+ * As we might want to do this multiple times before (or as arguments) to
+ * show_printf(), we create NUM_BUFS number of buffers that are cycled through
+ * before a given buffer is repeated.  Four times is more than enough for
+ * all of our current usages.
+ */
+#define	NUM_BUFS 4
+
+/*
+ * The size of each temporary buffer -- the size is large enough that it
+ * should be able to hold the resulting output of any call to buf_printf()
+ * without truncation.  Currently this is the 'unknown' message in
+ * do_svp_lrm_req() (rounded up).
+ */
+#define	BUF_LEN 64
+
+static const char *
+buf_printf(const char *fmt, ...)
+{
+	static char buf[NUM_BUFS][BUF_LEN];
+	static size_t i = 0;
+	char *bufp = buf[i++];
+	va_list ap;
+
+	va_start(ap, fmt);
+	(void) vsnprintf(bufp, BUF_LEN, fmt, ap);
+	va_end(ap);
+
+	i %= NUM_BUFS;
+	return (bufp);
+}
+
+#define	STR(x) case x: return(#x)
+static const char *
+svp_op_str(uint16_t op)
+{
+	switch (op) {
+	STR(SVP_R_UNKNOWN);
+	STR(SVP_R_PING);
+	STR(SVP_R_PONG);
+	STR(SVP_R_VL2_REQ);
+	STR(SVP_R_VL2_ACK);
+	STR(SVP_R_VL3_REQ);
+	STR(SVP_R_VL3_ACK);
+	STR(SVP_R_BULK_REQ);
+	STR(SVP_R_BULK_ACK);
+	STR(SVP_R_LOG_REQ);
+	STR(SVP_R_LOG_ACK);
+	STR(SVP_R_LOG_RM);
+	STR(SVP_R_LOG_RM_ACK);
+	STR(SVP_R_SHOOTDOWN);
+	default:
+		return (buf_printf("0x%hx", op));
+	}
+}
+
+static const char *
+svp_status_str(uint16_t status)
+{
+	switch (status) {
+	STR(SVP_S_OK);
+	STR(SVP_S_FATAL);
+	STR(SVP_S_NOTFOUND);
+	STR(SVP_S_BADL3TYPE);
+	STR(SVP_S_BADBULK);
+	default:
+		return (buf_printf("0x%hx", status));
+	}
+}
+
+static const char *
+svp_vl3_type_str(uint32_t type)
+{
+	switch (type) {
+	STR(SVP_VL3_IP);
+	STR(SVP_VL3_IPV6);
+	default:
+		return (buf_printf("0x%x", type));
+	}
+}
+
+static const char *
+svp_bulk_type_str(uint32_t type)
+{
+	switch (type) {
+	STR(SVP_BULK_VL2);
+	STR(SVP_BULK_VL3);
+	default:
+		return (buf_printf("0x%x", type));
+	}
+}
+
+static const char *
+svp_log_type_str(uint32_t type)
+{
+	switch (type) {
+	STR(SVP_LOG_VL2);
+	STR(SVP_LOG_VL3);
+	default:
+		return (buf_printf("0x%x", type));
+	}
+}
+#undef STR
+
+static const char *
+svp_addr_str(void *addrp, uint8_t *prefixp)
+{
+	/* Include space for optional /ddd prefix length */
+	static char buf[INET6_ADDRSTRLEN + 5];
+	struct in_addr v4;
+	int af = AF_INET6;
+
+	if (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)addrp)) {
+		af = AF_INET;
+		IN6_V4MAPPED_TO_INADDR((struct in6_addr *)addrp, &v4);
+		addrp = &v4;
+	}
+
+	if (inet_ntop(af, addrp, buf, sizeof (buf)) == NULL) {
+		uint8_t *p = addrp;
+		size_t i;
+
+		(void) strlcpy(buf, "0x", sizeof (buf));
+		for (i = 0; i < 16; i++) {
+			(void) snprintf(buf + 2 + i * 2,
+			    sizeof (buf) - 2 - i * 2, "%02hhx", p[i]);
+		}
+	}
+
+	if (prefixp != NULL && *prefixp != 128) {
+		char buf2[5]; /* / + 3 digits + NUL */
+
+		if (af == AF_INET)
+			*prefixp -= 96;
+
+		(void) snprintf(buf2, sizeof (buf2), "/%hhu", *prefixp);
+		(void) strlcat(buf, buf2, sizeof (buf));
+	}
+
+	return (buf);
+}
+
+static const char *
+svp_uuid_str(uint8_t *uuid)
+{
+	/* Grab a the next available buf */
+	char *bufp = (char *)buf_printf("");
+
+	uuid_unparse(uuid, bufp);
+	return (bufp);
+}
+
+static boolean_t
+svp_check_crc(char *data, int len)
+{
+	svp_req_t *req = (svp_req_t *)data;
+	uint32_t save_crc = req->svp_crc32;
+	uint32_t crc = -1U;
+
+	req->svp_crc32 = 0;
+	CRC32(crc, (uint8_t *)data, len, -1U, svp_crc32_tab);
+	crc = ~crc;
+	req->svp_crc32 = save_crc;
+
+	return (ntohl(save_crc) == crc ? B_TRUE : B_FALSE);
+}
+
+static void
+do_svp_vl2_req(void *data, int len)
+{
+	svp_vl2_req_t *vl2 = data;
+
+	show_printf("MAC = %s", ether_ntoa((struct ether_addr *)vl2->sl2r_mac));
+	show_printf("Virtual network id = %u", ntohl(vl2->sl2r_vnetid));
+}
+
+static void
+do_svp_vl2_ack(void *data, int len)
+{
+	svp_vl2_ack_t *vl2a = data;
+
+	show_printf("Status = %s", svp_status_str(ntohs(vl2a->sl2a_status)));
+	show_printf("UL3 Address = %s", svp_addr_str(vl2a->sl2a_addr, NULL));
+	show_printf("UL3 Port = %hu", ntohs(vl2a->sl2a_port));
+}
+
+static void
+do_svp_vl3_req(void *data, int len)
+{
+	svp_vl3_req_t *req = data;
+
+	show_printf("Virtual network id = %u", ntohl(req->sl3r_vnetid));
+	show_printf("Type = %s", svp_vl3_type_str(ntohl(req->sl3r_type)));
+	show_printf("VL3 Address = %s", svp_addr_str(req->sl3r_ip, NULL));
+}
+
+static void
+do_svp_vl3_ack(void *data, int len)
+{
+	svp_vl3_ack_t *vl3a = data;
+
+	show_printf("Status = %s", svp_status_str(ntohl(vl3a->sl3a_status)));
+	show_printf("MAC = %s",
+	    ether_ntoa((struct ether_addr *)vl3a->sl3a_mac));
+	show_printf("UL3 Address = %s", svp_addr_str(vl3a->sl3a_uip, NULL));
+	show_printf("UL3 Port = %hu", ntohs(vl3a->sl3a_uport));
+}
+
+static void
+do_svp_bulk_req(void *data, int len)
+{
+	svp_bulk_req_t *req = data;
+
+	if (len < sizeof (svp_bulk_req_t)) {
+		show_printf("%s runt", svp_op_str(SVP_R_BULK_REQ));
+		return;
+	}
+
+	show_printf("Type = %s", svp_bulk_type_str(ntohl(req->svbr_type)));
+}
+
+static void
+do_svp_bulk_ack(void *data, int len)
+{
+	svp_bulk_ack_t *ack = data;
+	uint32_t status;
+	size_t i, n;
+
+	show_printf("Status = %s", svp_status_str(status));
+	show_printf("Type = %s", svp_bulk_type_str(ntohl(ack->svba_type)));
+
+}
+
+static void
+do_svp_log_req(void *data, int len)
+{
+	svp_log_req_t *svlr = data;
+
+	show_printf("Count = %u", ntohl(svlr->svlr_count));
+	show_printf("Address = %s", svp_addr_str(svlr->svlr_ip, NULL));
+}
+
+static void
+do_svp_log_ack(void *data, int len)
+{
+	svp_log_ack_t *ack = data;
+	union {
+		svp_log_vl2_t *vl2;
+		svp_log_vl3_t *vl3;
+		uint32_t	*vtype;
+		void		*vd;
+	} u;
+	uint32_t type;
+	size_t total = 0, rlen = 0;
+	uint8_t prefixlen;
+	boolean_t is_host;
+
+	u.vd = (ack + 1);
+
+	show_printf("Status = %s", svp_status_str(ntohl(ack->svla_status)));
+	len -= sizeof (*ack);
+
+	while (len > 0) {
+		if (len < sizeof (uint32_t)) {
+			show_printf("    Trailing runt");
+			break;
+		}
+
+		type = ntohl(*u.vtype);
+
+		switch (type) {
+		case SVP_LOG_VL2:
+			rlen = sizeof (svp_log_vl2_t);
+			break;
+		case SVP_LOG_VL3:
+			rlen = sizeof (svp_log_vl3_t);
+			break;
+		default:
+			/*
+			 * If we don't know the type of log record we have,
+			 * we cannot determine the size of the record, so we
+			 * cannot continue past this.
+			 */
+			show_printf("Log %-4s: Log type = 0x%x (unknown)",
+			    buf_printf("%zu", ++total), type);
+			return;
+		}
+
+		if (len < rlen) {
+			show_printf("Log %-4s %s runt",
+			    buf_printf("%zu", ++total), svp_log_type_str(type));
+			return;
+		}
+
+		/* These are the same in both records */
+		show_printf("Log %-4s Log type = %s",
+		    buf_printf("%zu", ++total), svp_log_type_str(type));
+		show_printf("%8s UUID = %s", "", svp_uuid_str(u.vl2->svl2_id));
+
+		switch (type) {
+		case SVP_LOG_VL2:
+			show_printf("%8s MAC = %s", "",
+			    ether_ntoa((struct ether_addr *)u.vl2->svl2_mac));
+			show_printf("%8s Vnet = %u", "",
+			    ntohl(u.vl2->svl2_vnetid));
+			u.vl2++;
+			break;
+		case SVP_LOG_VL3:
+			show_printf("%8s VLAN = %hu", "",
+			    ntohs(u.vl3->svl3_vlan));
+			show_printf("%8s Address = %s", "",
+			    svp_addr_str(u.vl3->svl3_ip, NULL));
+			show_printf("%8s Vnet = %u", "",
+			    ntohl(u.vl3->svl3_vnetid));
+			u.vl3++;
+			break;
+		}
+
+		len -= rlen;
+		show_space();
+	}
+	show_printf("Total log records = %zu", total);
+}
+
+static void
+do_svp_lrm_req(void *data, int len)
+{
+	const char *mismatch_str = "";
+	svp_lrm_req_t *req = data;
+	size_t expected_sz = sizeof (*req);
+	size_t i, n;
+
+	n = ntohl(req->svrr_count);
+
+	/* IDs are 16-byte UUIDs */
+	expected_sz += n * UUID_LEN;
+	if (len != expected_sz) {
+		mismatch_str = buf_printf(" (expected %zu bytes,"
+		    " actual size is %d bytes)",
+		    expected_sz, len);
+	}
+	show_printf("ID Count = %u%s", n, mismatch_str);
+	if (len != expected_sz)
+		return;
+
+	for (i = 0; i < n; i++) {
+		show_printf("%-4s %s", (i == 0) ? "IDs:" : "",
+		    svp_uuid_str(&req->svrr_ids[UUID_LEN * i]));
+	}
+}
+
+static void
+do_svp_lrm_ack(void *data, int len)
+{
+	svp_lrm_ack_t *ack = data;
+
+	show_printf("Status = %s", svp_status_str(ntohl(ack->svra_status)));
+}
+
+static void
+do_svp_shootdown(void *data, int len)
+{
+	svp_shootdown_t *sd = data;
+
+	show_printf("Vnet = %u", ntohl(sd->svsd_vnetid));
+	show_printf("MAC Address = %s",
+	    ether_ntoa((struct ether_addr *)sd->svsd_mac));
+}
+
+static struct svp_len_tbl {
+	uint16_t slt_op;
+	size_t	slt_len;
+} svp_len_tbl[] = {
+	{ SVP_R_UNKNOWN,	0 },
+	{ SVP_R_PING,		0 },
+	{ SVP_R_PONG,		0 },
+	{ SVP_R_VL2_REQ,	sizeof (svp_vl2_req_t) },
+	{ SVP_R_VL2_ACK,	sizeof (svp_vl2_ack_t) },
+	{ SVP_R_VL3_REQ,	sizeof (svp_vl3_req_t) },
+	{ SVP_R_VL3_ACK,	sizeof (svp_vl3_ack_t) },
+	{ SVP_R_BULK_REQ,	sizeof (svp_bulk_req_t) },
+	{ SVP_R_BULK_ACK,	sizeof (svp_bulk_ack_t) },
+	{ SVP_R_LOG_REQ,	sizeof (svp_log_req_t) },
+	{ SVP_R_LOG_ACK,	0 },
+	{ SVP_R_LOG_RM,		sizeof (svp_lrm_req_t) },
+	{ SVP_R_LOG_RM_ACK,	sizeof (svp_lrm_ack_t) },
+	{ SVP_R_SHOOTDOWN,	sizeof (svp_shootdown_t) },
+};
+
+static boolean_t
+svp_check_runt(uint16_t op, int len)
+{
+	if (op > SVP_R_SHOOTDOWN)
+		return (B_FALSE);
+
+	if (len < svp_len_tbl[op].slt_len) {
+		show_printf("%s Runt", svp_op_str(op));
+		show_space();
+		return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+int
+interpret_svp(int flags, char *data, int fraglen)
+{
+	svp_req_t *req = (svp_req_t *)data;
+	boolean_t crc_ok;
+
+	if (fraglen < sizeof (svp_req_t)) {
+		if (flags & F_SUM)
+			(void) snprintf(get_sum_line(), MAXLINE,
+			    "SVP RUNT");
+		if (flags & F_DTAIL)
+			show_header("SVP RUNT:  ", "Short packet", fraglen);
+
+		return (fraglen);
+	}
+
+	crc_ok = svp_check_crc(data, fraglen);
+
+	if (flags & F_SUM) {
+		(void) snprintf(get_sum_line(), MAXLINE,
+		    "SVP V=%hu OP=%s ID=%u%s", ntohs(req->svp_ver),
+		    svp_op_str(ntohs(req->svp_op)),
+		    ntohl(req->svp_id), crc_ok ? "" : " (BAD CRC)");
+	}
+
+	if (flags & F_DTAIL) {
+		uint16_t op = ntohs(req->svp_op);
+
+		show_header("SVP:    ", "SVP Header", sizeof (svp_req_t));
+		show_space();
+		show_printf("Version = %hu", ntohs(req->svp_ver));
+		show_printf("Op = %s", svp_op_str(op));
+		show_printf("Packet length = %u bytes%s", ntohl(req->svp_size),
+		    (ntohl(req->svp_size) == fraglen - sizeof (*req)) ?
+		    "" : " (mismatch)");
+		show_printf("Id = %u", ntohl(req->svp_id));
+		show_printf("CRC = %x%s", ntohl(req->svp_crc32),
+		    crc_ok ? "" : " (bad)");
+		show_space();
+
+		req++;
+		fraglen -= sizeof (*req);
+
+		/*
+		 * Since we cannot know the length of an unknown op,
+		 * svp_check_runt() returns B_TRUE for both truncated packets
+		 * and unknown packets -- we have nothing meaningful besides
+		 * the header we could print anyway.
+		 */
+		if (svp_check_runt(op, fraglen))
+			return (fraglen);
+
+		switch (op) {
+		case SVP_R_VL2_REQ:
+			do_svp_vl2_req(req, fraglen);
+			break;
+		case SVP_R_VL2_ACK:
+			do_svp_vl2_ack(req, fraglen);
+			break;
+		case SVP_R_VL3_REQ:
+			do_svp_vl3_req(req, fraglen);
+			break;
+		case SVP_R_VL3_ACK:
+			do_svp_vl3_ack(req, fraglen);
+			break;
+		case SVP_R_BULK_REQ:
+			do_svp_bulk_req(req, fraglen);
+			break;
+		case SVP_R_BULK_ACK:
+			do_svp_bulk_ack(req, fraglen);
+			break;
+		case SVP_R_LOG_REQ:
+			do_svp_log_req(req, fraglen);
+			break;
+		case SVP_R_LOG_ACK:
+			do_svp_log_ack(req, fraglen);
+			break;
+		case SVP_R_LOG_RM:
+			do_svp_lrm_req(req, fraglen);
+			break;
+		case SVP_R_LOG_RM_ACK:
+			do_svp_lrm_ack(req, fraglen);
+			break;
+		case SVP_R_SHOOTDOWN:
+			do_svp_shootdown(req, fraglen);
+			break;
+		}
+
+		show_space();
+	}
+
+	return (0);
+}
diff --git a/usr/src/lib/varpd/svp/Makefile b/usr/src/lib/varpd/svp/Makefile
index 275f07bf8b..b4dbf8f017 100644
--- a/usr/src/lib/varpd/svp/Makefile
+++ b/usr/src/lib/varpd/svp/Makefile
@@ -10,11 +10,13 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 include		../../Makefile.lib
 
+HDRS =		libvarpd_svp_prot.h	# For snoop
+HDRDIR =	common
 SUBDIRS =	$(MACH)
 $(BUILD64)SUBDIRS +=	$(MACH64)
 
@@ -28,7 +30,8 @@ lint :=		TARGET = lint
 
 all clean clobber install lint: $(SUBDIRS)
 
-install_h:
+install:	install_h
+install_h:	$(ROOTHDRS)
 
 check:
 
-- 
2.21.0

