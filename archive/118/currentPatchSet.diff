From 1b275fb87e8de96e9eaa2a1f186004bc12cad9f4 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 21 Jul 2016 22:10:53 +0000
Subject: [PATCH] OS-5521 lxbrand epoll_ctl not allowed to emit EINTR Reviewed
 by: Ryan Zezeski <rpz@joyent.com> Reviewed by: Jerry Jelinek
 <jerry.jelinek@joyent.com> Approved by: Jerry Jelinek
 <jerry.jelinek@joyent.com>

---
 .../uts/common/brand/lx/syscall/lx_epoll.c    | 31 ++++++++++++++++---
 usr/src/uts/common/io/devpoll.c               | 27 ++++++++++++++++
 2 files changed, 54 insertions(+), 4 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_epoll.c b/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
index 8eead951f4..f23c1c96a1 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
@@ -191,16 +191,39 @@ lx_epoll_ctl(int fd, int op, int pfd, void *event)
 	error = VOP_WRITE(fp->f_vnode, &auio, 1, fp->f_cred, NULL);
 
 	releasef(fd);
-	if (error == ELOOP) {
+
+	switch (error) {
+	case 0:
+		return (0);
+
+	case EBADF:
+	case EEXIST:
+	case EINVAL:
+	case ENOENT:
+	case ENOMEM:
+	case ENOSPC:
+	case EPERM:
+		/*
+		 * Legal errors should pass straight through.
+		 */
+		return (set_errno(error));
+
+	case ELOOP:
 		/*
 		 * In the case of descriptor loops, /dev/poll emits a more
 		 * descriptive error than Linux epoll consumers would expect.
 		 */
 		return (set_errno(EINVAL));
-	} else if (error != 0) {
-		return (set_errno(error));
+
+	default:
+		/*
+		 * While devpoll itself should not emit unexpected errors, it
+		 * is possible that a VOP_POLL handler might.  There is little
+		 * choice but to map these unexpected errors to something which
+		 * is valid for epoll_ctl.
+		 */
+		return (set_errno(ENOMEM));
 	}
-	return (0);
 }
 
 long
diff --git a/usr/src/uts/common/io/devpoll.c b/usr/src/uts/common/io/devpoll.c
index 4fce431e00..aad192189e 100644
--- a/usr/src/uts/common/io/devpoll.c
+++ b/usr/src/uts/common/io/devpoll.c
@@ -674,6 +674,18 @@ dpwrite(dev_t dev, struct uio *uiop, cred_t *credp)
 	uiosize = uiop->uio_resid;
 	pollfdnum = uiosize / size;
 
+	/*
+	 * For epoll-enabled handles, restrict the allowed write size to 2.
+	 * This corresponds to an epoll_ctl(3C) performing an EPOLL_CTL_MOD
+	 * operation which is expanded into two operations (DEL and ADD).
+	 *
+	 * All other operations performed through epoll_ctl(3C) will consist of
+	 * a single entry.
+	 */
+	if (is_epoll && pollfdnum > 2) {
+		return (EINVAL);
+	}
+
 	/*
 	 * We want to make sure that pollfdnum isn't large enough to DoS us,
 	 * but we also don't want to grab p_lock unnecessarily -- so we
@@ -733,6 +745,21 @@ dpwrite(dev_t dev, struct uio *uiop, cred_t *credp)
 	while ((dpep->dpe_flag & DP_WRITER_PRESENT) != 0) {
 		ASSERT(dpep->dpe_refcnt != 0);
 
+		/*
+		 * The epoll API does not allow EINTR as a result when making
+		 * modifications to the set of polled fds.  Given that write
+		 * activity is relatively quick and the size of accepted writes
+		 * is limited above to two entries, a signal-ignorant wait is
+		 * used here to avoid the EINTR.
+		 */
+		if (is_epoll) {
+			cv_wait(&dpep->dpe_cv, &dpep->dpe_lock);
+			continue;
+		}
+
+		/*
+		 * Non-epoll writers to /dev/poll handles can tolerate EINTR.
+		 */
 		if (!cv_wait_sig_swap(&dpep->dpe_cv, &dpep->dpe_lock)) {
 			dpep->dpe_writerwait--;
 			mutex_exit(&dpep->dpe_lock);
-- 
2.21.0

