From fcec55520e535ac6ba8ca4d133a00488aabd7eb5 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Mon, 18 Jul 2016 21:28:07 +0000
Subject: [PATCH] OS-5521 lxbrand epoll_ctl not allowed to emit EINTR

---
 usr/src/uts/common/brand/lx/syscall/lx_epoll.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_epoll.c b/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
index 8eead951f4..5d853aabd5 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_epoll.c
@@ -125,6 +125,8 @@ lx_epoll_ctl(int fd, int op, int pfd, void *event)
 	uio_t auio;
 	uint32_t events, ev = 0;
 	int error = 0, i = 0;
+	kthread_t *t = curthread;
+	proc_t *p = ttoproc(t);
 
 	dpevent[i].dpep_pollfd.fd = pfd;
 	switch (op) {
@@ -188,8 +190,24 @@ lx_epoll_ctl(int fd, int op, int pfd, void *event)
 	auio.uio_loffset = 0;
 	auio.uio_fmode = fp->f_flag;
 
+	/*
+	 * It is possible for writes to /dev/poll to fail with EINTR.  This
+	 * occurs when a signal arrives while writers are contending for access
+	 * to the pollcache.  Since EINTR is not allowed for epoll_ctl, all
+	 * signals must be blocked prior to attempting the write.
+	 */
+	mutex_enter(&p->p_lock);
+	ttolwp(t)->lwp_sigoldmask = t->t_hold;
+	sigfillset(&t->t_hold);
+	sigdiffset(&t->t_hold, &cantmask);
+	mutex_exit(&p->p_lock);
+
 	error = VOP_WRITE(fp->f_vnode, &auio, 1, fp->f_cred, NULL);
 
+	mutex_enter(&p->p_lock);
+	t->t_hold = ttolwp(t)->lwp_sigoldmask;
+	mutex_exit(&p->p_lock);
+
 	releasef(fd);
 	if (error == ELOOP) {
 		/*
-- 
2.21.0

