commit c50f0c906f8b7489ab881f5703bc264e0309ce69 (refs/changes/75/3275/4)
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2018-05-11T11:37:28-06:00 (1 year, 5 months ago)
    
    TRITON-85 log-scan probe plugin does not work for SMF services that run multiple instances per zone

diff --git a/plugins/lib/bunyan-log-scan.js b/plugins/lib/bunyan-log-scan.js
index 4df68f4..0e5bab3 100644
--- a/plugins/lib/bunyan-log-scan.js
+++ b/plugins/lib/bunyan-log-scan.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -158,8 +158,8 @@ BunyanLogScanProbe.prototype.validateConfig = function (config) {
 /**
  * Get an appropriate message for a log-scan event.
  *
- * Note: We cheat and use `this._pathCache`. The assumption is that
- * this method is only ever called after `_getPath()` success.
+ * Note: We cheat and use `this._pathsCache`. The assumption is that
+ * this method is only ever called after `_getPaths()` success.
  */
 BunyanLogScanProbe.prototype._getMessage = function () {
     if (! this._messageCache) {
@@ -182,11 +182,16 @@ BunyanLogScanProbe.prototype._getMessage = function () {
         conds = (conds.length ? format(' (%s)', conds.join(', ')) : '');
 
         var msg;
+        if (this._pathsCache.length > 1) {
+            msg = 'Logs "' + this._pathsCache.join('", "') + '" matched';
+        } else {
+            msg = 'Log "' + this._pathsCache[0] + '" matched';
+        }
         if (this.threshold > 1) {
-            msg = format('Log "%s" matched >=%d times in %d seconds%s.',
-                this._pathCache, this.threshold, this.period, conds);
+            msg += format(' >=%d times in %d seconds%s.',
+                this.threshold, this.period, conds);
         } else {
-            msg = format('Log "%s" matched%s.', this._pathCache, conds);
+            msg += conds + '.';
         }
         this._messageCache = msg;
     }
diff --git a/plugins/lib/log-scan.js b/plugins/lib/log-scan.js
index db880c0..62d8727 100644
--- a/plugins/lib/log-scan.js
+++ b/plugins/lib/log-scan.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -83,14 +83,14 @@ LogScanProbe.prototype.validateConfig = function (config) {
 };
 
 
-LogScanProbe.prototype._getPath = function (callback) {
+LogScanProbe.prototype._getPaths = function (callback) {
     var self = this;
-    if (this._pathCache) {
-        return callback(null, this._pathCache);
+    if (this._pathsCache) {
+        return callback(null, this._pathsCache);
     }
     if (this.path) {
-        this._pathCache = this.path;
-        callback(null, this._pathCache);
+        this._pathsCache = [this.path];
+        callback(null, this._pathsCache);
     } else if (this.smfServiceName) {
         execFile('/usr/bin/svcs', ['-L', this.smfServiceName],
             function (sErr, stdout, stderr) {
@@ -101,8 +101,8 @@ LogScanProbe.prototype._getPath = function (callback) {
                         'error getting SMF service path: `svcs -L %s`: %s',
                         self.smfServiceName, stderr)));
                 } else {
-                    self._pathCache = stdout.trim();
-                    callback(null, self._pathCache);
+                    self._pathsCache = stdout.trim().split('\n');
+                    callback(null, self._pathsCache);
                 }
             }
         );
@@ -115,17 +115,22 @@ LogScanProbe.prototype._getPath = function (callback) {
 /**
  * Get an appropriate message for a log-scan event.
  *
- * Note: We cheat and use `this._pathCache`. The assumption is that
- * this method is only ever called after `_getPath()` success.
+ * Note: We cheat and use `this._pathsCache`. The assumption is that
+ * this method is only ever called after `_getPaths()` success.
  */
 LogScanProbe.prototype._getMessage = function () {
     if (! this._messageCache) {
         var msg;
+        if (this._pathsCache.length > 1) {
+            msg = 'Logs "' + this._pathsCache.join('", "') + '" matched';
+        } else {
+            msg = 'Log "' + this._pathsCache[0] + '" matched';
+        }
         if (this.threshold > 1) {
-            msg = format('Log "%s" matched %s >=%d times in %d seconds.',
-                this._pathCache, this.matcher, this.threshold, this.period);
+            msg += format(' >=%d times in %d seconds.',
+                this.threshold, this.period);
         } else {
-            msg = format('Log "%s" matched %s.', this._pathCache, this.matcher);
+            msg += '.';
         }
         this._messageCache = msg;
     }
@@ -154,16 +159,16 @@ LogScanProbe.prototype.start = function (callback) {
 
     var GET_PATH_RETRY = 5 * 60 * 1000; // Every 5 minutes.
 
-    function getPathAndStart(cb) {
-        log.info('get path');
-        self._getPath(function (err, path) {
+    function getPathsAndStart(cb) {
+        log.info('get paths');
+        self._getPaths(function (err, paths) {
             if (err) {
-                log.info(err, 'could not get path to scan, recheck in %dms',
+                log.info(err, 'could not get paths to scan, recheck in %dms',
                     GET_PATH_RETRY);
-                self.pathRetrier = setTimeout(getPathAndStart, GET_PATH_RETRY);
+                self.pathRetrier = setTimeout(getPathsAndStart, GET_PATH_RETRY);
                 return;
             }
-            log.info({path: path}, 'got path');
+            log.info({paths: paths}, 'got paths');
 
             self.timer = setInterval(function () {
                 if (!self._running)
@@ -173,7 +178,8 @@ LogScanProbe.prototype.start = function (callback) {
             }, self.period * SECONDS);
 
             self._running = true;
-            self.tail = spawn('/usr/bin/tail', ['-1cF', path]);
+            var args = ['-1cF', '-q'].concat(paths);
+            self.tail = spawn('/usr/bin/tail', args);
             self.tail.stdout.on('data', function (chunk) {
                 if (!self._running) {
                     return;
@@ -207,7 +213,7 @@ LogScanProbe.prototype.start = function (callback) {
         });
     }
 
-    process.nextTick(getPathAndStart);
+    process.nextTick(getPathsAndStart);
     if (callback && (callback instanceof Function)) {
         return callback();
     }
