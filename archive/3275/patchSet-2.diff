From 2d11f5d93269bced59650753daa5dbdb96d6394d Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Tue, 27 Feb 2018 09:40:09 -0700
Subject: [PATCH] TRITON-85 log-scan probe plugin does not work for SMF
 services that run multiple instances per zone

---
 plugins/lib/bunyan-log-scan.js |  8 +++----
 plugins/lib/log-scan.js        | 39 +++++++++++++++++-----------------
 2 files changed, 24 insertions(+), 23 deletions(-)

diff --git a/plugins/lib/bunyan-log-scan.js b/plugins/lib/bunyan-log-scan.js
index 4df68f4..08240b8 100644
--- a/plugins/lib/bunyan-log-scan.js
+++ b/plugins/lib/bunyan-log-scan.js
@@ -158,8 +158,8 @@ BunyanLogScanProbe.prototype.validateConfig = function (config) {
 /**
  * Get an appropriate message for a log-scan event.
  *
- * Note: We cheat and use `this._pathCache`. The assumption is that
- * this method is only ever called after `_getPath()` success.
+ * Note: We cheat and use `this._pathsCache`. The assumption is that
+ * this method is only ever called after `_getPaths()` success.
  */
 BunyanLogScanProbe.prototype._getMessage = function () {
     if (! this._messageCache) {
@@ -184,9 +184,9 @@ BunyanLogScanProbe.prototype._getMessage = function () {
         var msg;
         if (this.threshold > 1) {
             msg = format('Log "%s" matched >=%d times in %d seconds%s.',
-                this._pathCache, this.threshold, this.period, conds);
+                this._pathsCache.join(' '), this.threshold, this.period, conds);
         } else {
-            msg = format('Log "%s" matched%s.', this._pathCache, conds);
+            msg = format('Log "%s" matched%s.', this._pathsCache.join(' '), conds);
         }
         this._messageCache = msg;
     }
diff --git a/plugins/lib/log-scan.js b/plugins/lib/log-scan.js
index db880c0..3c4636e 100644
--- a/plugins/lib/log-scan.js
+++ b/plugins/lib/log-scan.js
@@ -83,14 +83,14 @@ LogScanProbe.prototype.validateConfig = function (config) {
 };
 
 
-LogScanProbe.prototype._getPath = function (callback) {
+LogScanProbe.prototype._getPaths = function (callback) {
     var self = this;
-    if (this._pathCache) {
-        return callback(null, this._pathCache);
+    if (this._pathsCache) {
+        return callback(null, this._pathsCache);
     }
     if (this.path) {
-        this._pathCache = this.path;
-        callback(null, this._pathCache);
+        this._pathsCache = [this.path];
+        callback(null, this._pathsCache);
     } else if (this.smfServiceName) {
         execFile('/usr/bin/svcs', ['-L', this.smfServiceName],
             function (sErr, stdout, stderr) {
@@ -101,8 +101,8 @@ LogScanProbe.prototype._getPath = function (callback) {
                         'error getting SMF service path: `svcs -L %s`: %s',
                         self.smfServiceName, stderr)));
                 } else {
-                    self._pathCache = stdout.trim();
-                    callback(null, self._pathCache);
+                    self._pathsCache = stdout.trim().split('\n');
+                    callback(null, self._pathsCache);
                 }
             }
         );
@@ -115,17 +115,17 @@ LogScanProbe.prototype._getPath = function (callback) {
 /**
  * Get an appropriate message for a log-scan event.
  *
- * Note: We cheat and use `this._pathCache`. The assumption is that
- * this method is only ever called after `_getPath()` success.
+ * Note: We cheat and use `this._pathsCache`. The assumption is that
+ * this method is only ever called after `_getPaths()` success.
  */
 LogScanProbe.prototype._getMessage = function () {
     if (! this._messageCache) {
         var msg;
         if (this.threshold > 1) {
             msg = format('Log "%s" matched %s >=%d times in %d seconds.',
-                this._pathCache, this.matcher, this.threshold, this.period);
+                      this._pathsCache.join(' '), this.matcher, this.threshold, this.period);
         } else {
-            msg = format('Log "%s" matched %s.', this._pathCache, this.matcher);
+            msg = format('Log "%s" matched %s.', this._pathsCache.join(' '), this.matcher);
         }
         this._messageCache = msg;
     }
@@ -154,16 +154,16 @@ LogScanProbe.prototype.start = function (callback) {
 
     var GET_PATH_RETRY = 5 * 60 * 1000; // Every 5 minutes.
 
-    function getPathAndStart(cb) {
-        log.info('get path');
-        self._getPath(function (err, path) {
+    function getPathsAndStart(cb) {
+        log.info('get paths');
+        self._getPaths(function (err, paths) {
             if (err) {
-                log.info(err, 'could not get path to scan, recheck in %dms',
+                log.info(err, 'could not get paths to scan, recheck in %dms',
                     GET_PATH_RETRY);
-                self.pathRetrier = setTimeout(getPathAndStart, GET_PATH_RETRY);
+                self.pathRetrier = setTimeout(getPathsAndStart, GET_PATH_RETRY);
                 return;
             }
-            log.info({path: path}, 'got path');
+            log.info({paths: paths}, 'got paths');
 
             self.timer = setInterval(function () {
                 if (!self._running)
@@ -173,7 +173,8 @@ LogScanProbe.prototype.start = function (callback) {
             }, self.period * SECONDS);
 
             self._running = true;
-            self.tail = spawn('/usr/bin/tail', ['-1cF', path]);
+            var args = ['-1cF', '-q'].concat(paths);
+            self.tail = spawn('/usr/bin/tail', args);
             self.tail.stdout.on('data', function (chunk) {
                 if (!self._running) {
                     return;
@@ -207,7 +208,7 @@ LogScanProbe.prototype.start = function (callback) {
         });
     }
 
-    process.nextTick(getPathAndStart);
+    process.nextTick(getPathsAndStart);
     if (callback && (callback instanceof Function)) {
         return callback();
     }
-- 
2.21.0

