commit 229ec05bc13b5a7413125a8afa8d657ccde84d85 (refs/changes/65/3965/6)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-05-29T21:03:08+00:00 (1 year, 4 months ago)
    
    TRITON-387 net-agent should update VMs based on changes within NAPI
    TRITON-444 Use ESLint in sdc-net-agent

diff --git a/.eslintrc b/.eslintrc
new file mode 100644
index 0000000..afa37ca
--- /dev/null
+++ b/.eslintrc
@@ -0,0 +1,26 @@
+{
+    "plugins": [ "joyent" ],
+    "extends": [
+        "eslint:recommended",
+        "plugin:joyent/style",
+        "plugin:joyent/lint"
+    ],
+    "parserOptions": {
+        "ecmaVersion": 5,
+        "sourceType": "script",
+        "ecmaFeatures": {
+        }
+    },
+    "env": {
+        "node": true
+    },
+    "rules": {
+        // Lint:
+        "strict": [ "error", "global" ],
+
+        // Style:
+        "func-style": [ "error", "declaration" ],
+
+        "multiline-comment-style": [ "error", "starred-block" ]
+    }
+}
diff --git a/.gitignore b/.gitignore
index 1193dbb..eef0354 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,3 +10,4 @@ smf/manifests/bapi.xml
 describe
 net-agent-*.tgz
 net-agent-*.manifest
+*.s[a-w][a-z]
diff --git a/.gitmodules b/.gitmodules
index 1d72cc4..bdab6db 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -3,7 +3,7 @@
 	url = https://github.com/trentm/restdown.git
 [submodule "deps/javascriptlint"]
 	path = deps/javascriptlint
-	url = https://github.com/davepacheco/javascriptlint.git
+	url = https://github.com/joyent/javascriptlint.git
 [submodule "deps/jsstyle"]
 	path = deps/jsstyle
-	url = https://github.com/davepacheco/jsstyle.git
+	url = https://github.com/joyent/jsstyle.git
diff --git a/Makefile b/Makefile
index f695090..00b2941 100644
--- a/Makefile
+++ b/Makefile
@@ -31,8 +31,9 @@ JSL_CONF_NODE =		tools/jsl.node.conf
 JSL_FILES_NODE =	$(JS_FILES)
 JSSTYLE_FILES =		$(JS_FILES)
 JSSTYLE_FLAGS =		-o indent=4,doxygen,unparenthesized-return=0
+ESLINT_FILES =		$(JS_FILES)
 
-NODE_PREBUILT_VERSION =	v0.10.48
+NODE_PREBUILT_VERSION =	v4.6.1
 
 ifeq ($(shell uname -s),SunOS)
 NODE_PREBUILT_TAG =	gz
diff --git a/bin/net-agent.js b/bin/net-agent.js
index aa0bb69..ee1714d 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -5,19 +5,18 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 /*
  * net-agent.js
  */
 
-var path = require('path');
+'use strict';
+
 var fs = require('fs');
 var bunyan = require('bunyan');
 var bunyanSerializers = require('sdc-bunyan-serializers');
-var async = require('async');
-var execFile = require('child_process').execFile;
 
 var logLevel = (process.env.LOG_LEVEL || 'debug');
 var logger = bunyan.createLogger({
@@ -28,107 +27,53 @@ var logger = bunyan.createLogger({
 
 var NetAgent = require('../lib');
 
-var config = { log: logger };
-var sdcConfig;
-var agentConfig;
-var sysinfo;
+var NET_AGENT_CONFIG_PATH = '/opt/smartdc/agents/etc/net-agent.config.json';
+var NET_AGENT_CONFIG_SLEEP = 10000;
 
+/**
+ * Wait until our configuration file appears, and then try to parse it.
+ */
 function loadConfig(callback) {
-    var configPath = '/opt/smartdc/agents/etc/net-agent.config.json';
+    var txt, config;
 
     try {
-        agentConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
+        txt = fs.readFileSync(NET_AGENT_CONFIG_PATH, 'utf-8');
     } catch (e) {
-        logger.error(e, 'Could not parse agent config: "%s", '
-            + 'attempting to load from /lib/sdc/config.sh now', e.message);
+        logger.error(e,
+            'Could not read agent configuration at %s', NET_AGENT_CONFIG_PATH);
+        setTimeout(loadConfig, NET_AGENT_CONFIG_SLEEP, callback);
+        return;
     }
 
-    return callback(null);
-}
-
-// If we are unable to read a config-agent managed configuration, then we
-// have to rely on sdc/config.sh and turn off no_rabbit
-function loadSdcConfig(callback) {
-    if (agentConfig !== undefined) {
-        callback();
+    try {
+        config = JSON.parse(txt);
+    } catch (e) {
+        callback(e);
         return;
     }
 
-    execFile('/bin/bash', ['/lib/sdc/config.sh', '-json'],
-        function _loadConfig(err, stdout, stderr) {
-            if (err) {
-                logger.fatal(err, 'Could not load sdc config: ' + stderr);
-                return callback(err);
-            }
-
-            try {
-                sdcConfig = JSON.parse(stdout);
-                agentConfig = {
-                    napi: { url: 'http://' + sdcConfig.napi_domain },
-                    no_rabbit: false
-                };
-            } catch (e) {
-                logger.fatal(e, 'Could not parse sdc config: ' + e.message);
-                return callback(e);
-            }
-
-            return callback(null);
-    });
-}
-
-
-// Run the sysinfo script and return the captured stdout, stderr, and exit
-// status code.
-function loadSysinfo(callback) {
-    execFile('/usr/bin/sysinfo', [], function (err, stdout, stderr) {
-        if (err) {
-            logger.fatal('Could not load sysinfo: ' + stderr.toString());
-            return callback(err);
-        }
-
-        try {
-            sysinfo = JSON.parse(stdout);
-        } catch (e) {
-            logger.fatal(e, 'Could not parse sysinfo: ' + e.message);
-            return callback(e);
-        }
-
-        return callback(null);
-    });
+    callback(null, config);
 }
 
-
-async.waterfall([
-    loadConfig,
-    loadSdcConfig,
-    loadSysinfo
-], function (err) {
+loadConfig(function afterLoadConfig(err, config) {
     if (err) {
         logger.fatal('Failed to initialize net-agent configuration');
         process.exit(1);
     }
 
-    if (!sysinfo.UUID) {
-        logger.fatal('Could not find "UUID" in `sysinfo` output.');
-        process.exit(1);
+    if (!config.no_rabbit) {
+        logger.warn('"no_rabbit" flag is not true, net-agent will now sleep');
+        /*
+         * http://nodejs.org/docs/latest/api/all.html#all_settimeout_cb_ms
+         * The timeout must be in the range of 1 to 2,147,483,647 inclusive...
+         */
+        setInterval(function () {}, 2000000000);
+        return;
     }
 
-    config.uuid = sysinfo.UUID;
-    config.url = agentConfig.napi.url;
+    config.log = logger;
 
-    if (!config.url) {
-        logger.fatal('config.url is required');
-        process.exit(1);
-    }
+    var netagent = new NetAgent(config);
 
-    var netagent;
-    if (agentConfig.no_rabbit) {
-        netagent = new NetAgent(config);
-        netagent.start();
-    } else {
-        logger.warn('"no_rabbit" flag is not true, net-agent will now sleep');
-        // http://nodejs.org/docs/latest/api/all.html#all_settimeout_cb_ms
-        // ...The timeout must be in the range of 1-2,147,483,647 inclusive...
-        setInterval(function () {}, 2000000000);
-    }
+    netagent.start();
 });
diff --git a/deps/javascriptlint b/deps/javascriptlint
index e1bd0ab..ad52812 160000
--- a/deps/javascriptlint
+++ b/deps/javascriptlint
@@ -1 +1 @@
-Subproject commit e1bd0abfd424811af469d1ece3af131d95443924
+Subproject commit ad52812e77bdfb1e90fb71a1201adb2b665a27e6
diff --git a/deps/jsstyle b/deps/jsstyle
index ab8f1fc..52dc973 160000
--- a/deps/jsstyle
+++ b/deps/jsstyle
@@ -1 +1 @@
-Subproject commit ab8f1fc8d90db8484bbed8a526ff40add5aa1c15
+Subproject commit 52dc973cf64da11834eca7cf46ebce8518e3ee88
diff --git a/lib/aggr-fsm.js b/lib/aggr-fsm.js
new file mode 100644
index 0000000..ea703d5
--- /dev/null
+++ b/lib/aggr-fsm.js
@@ -0,0 +1,531 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_common = require('./common');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+
+// --- Globals
+
+var LOCAL_FIELDS = [
+];
+
+var REMOTE_FIELDS = [
+];
+
+// --- Internal helpers
+
+function getDifferences(fields, cur, old) {
+    var update = {};
+
+    fields.forEach(function (field) {
+        if (cur[field] !== old[field]) {
+            update[field] = cur[field];
+        }
+    });
+
+    return update;
+}
+
+
+// --- Exports
+
+/**
+ * The AggrFSM is responsible for tracking changes related to a single
+ * aggregation located in a CN's global zone.
+ *
+ * The state machine looks like the following (note that retries aren't
+ * depicted here, but are loops back into the same state usually).
+ *
+ *                       +---------+
+ *                       | create  | -------------------------+
+ *                       +---------+                          |
+ *                 404 on 1st ^                               |
+ *                    refresh |    setLocal()                 |
+ *       +------+        +---------+ -----> +--------+        |
+ *       | init | -----> | refresh |        | update |        |
+ *       +------+        +---------+   +--- +--------+        |
+ *                        |   ^        |         |            |
+ *           NAPI 404 for |   |        |         |            |
+ *           existing NIC |   |        |         |            |
+ *       +---------+      |   |        |         |            |
+ *       | remove  | <----+   |        |         |            |
+ *       +---------+          |        |         |            |
+ *            |               |        |         |            |
+ *            v               |        |         v            |
+ *       +---------+     +---------+   |    +--------------+  |
+ *       | stopped |     | waiting | <-+--- | update.local | -+
+ *       +---------+     +---------+   |    +--------------+  |
+ *            ^                        |                      |
+ *            |          +---------+   +--- +--------------+  |
+ *            +--------- | release |        | update.napi  | -+
+ *            |          +---------+        +--------------+  |
+ *            |               ^                  |            |
+ *            |               |     NAPI 404     |            |
+ *            +-------------- | -----------------+            |
+ *                            |        releaseFrom()          |
+ *                            +-------------------------------+
+ */
+function AggrFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.string(opts.name, 'opts.name');
+    assert.object(opts.app, 'opts.app');
+
+    this.name = opts.name;
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'aggr',
+        name: this.name
+    }, true);
+
+    this.pending = {
+        refresh: false,
+        update: false
+    };
+    this.released = null;
+
+    this.local = null;
+    this.remote = null;
+
+    /*
+     * We track the "Etag" header so that we can be careful
+     * about our DELETEs.
+     */
+    this.etag = undefined;
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(AggrFSM, mod_mooremachine.FSM);
+
+AggrFSM.prototype.state_init = function (S) {
+    S.immediate(function () {
+        S.gotoState('refresh');
+    });
+};
+
+/**
+ * Wait for external events to force us to recompare.
+ */
+AggrFSM.prototype.state_waiting = function (S) {
+    S.on(this, 'setAsserted', function () {
+        S.gotoState('update');
+    });
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    /*
+     * Refresh periodically.
+     */
+    S.timeout(60 * 60 * 1000, function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(this, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+};
+
+AggrFSM.prototype.state_refresh = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'create',
+        'refresh',
+        'remove',
+        'update'
+    ]);
+
+    S.on(self, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(self, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+
+    function afterGet(err, aggr, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                if (self.remote === null) {
+                    S.gotoState('create');
+                } else {
+                    S.gotoState('remove');
+                }
+                return;
+            }
+
+            self.log.warn(err,
+                'Failed to refresh aggregation information; ' +
+                'retrying in 5 seconds');
+            S.timeout(5000, function () {
+                S.gotoState('refresh');
+            });
+            return;
+        }
+
+        self.setRemote(aggr, res.headers['etag']);
+
+        self.log.info('Refreshed aggregation information');
+
+        S.gotoState('update');
+    }
+
+    self.log.info('Refreshing aggregation information');
+
+    self.app.napi.getAggr(self.getId(), S.callback(afterGet));
+};
+
+AggrFSM.prototype.state_create = function (S) {
+    var self = this;
+    var deleted = false;
+
+    S.validTransitions([
+        'refresh',
+        'release',
+        'waiting'
+    ]);
+
+    if (self.local === null) {
+        S.gotoState('waiting');
+        return;
+    }
+
+    S.on(this, 'releaseAsserted', function () {
+        /*
+         * We wait to move to the "release" state to ensure that our
+         * POST always comes entirely before the DELETE.
+         */
+        deleted = true;
+    });
+
+    function afterCreate(err, aggr, _, res) {
+        if (deleted) {
+            S.gotoState('release');
+            return;
+        }
+
+        if (err) {
+            self.log.warn(err,
+                'Failed to create aggregation in NAPI; ' +
+                'scheduling state refresh');
+            S.timeout(5000, function () {
+                S.gotoState('refresh');
+            });
+            return;
+        }
+
+        self.setRemote(aggr, res.headers['etag']);
+
+        S.gotoState('waiting');
+    }
+
+    self.log.info({ aggr: self.local }, 'Syncing local aggregation to NAPI');
+
+    self.app.napi.createAggr(self.local, S.callback(afterCreate));
+};
+
+AggrFSM.prototype.state_update = function (S) {
+    /*
+     * We haven't seen a local aggr yet. Go to state "waiting" until
+     * we're assigned one.
+     */
+    if (this.local === null) {
+        this.log.debug('No local aggregation information yet');
+        S.gotoState('waiting');
+        return;
+    }
+
+    /*
+     * If the belongs_to_uuid has changed, then we need to move the aggr.
+     */
+    if (this.local.belongs_to_uuid !== this.remote.belongs_to_uuid) {
+        S.gotoState('remove');
+        return;
+    }
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    S.gotoState('update.local');
+};
+
+AggrFSM.prototype.state_update.local = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'release',
+        'update.local',
+        'update.napi',
+        'waiting'
+    ]);
+
+    var locupdate = getDifferences(REMOTE_FIELDS, self.remote, self.local);
+    if (mod_jsprim.isEmpty(locupdate)) {
+        self.log.trace('No local changes needed');
+        S.gotoState('update.napi');
+        return;
+    }
+
+    S.on(this, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+
+    function afterUpdate(err) {
+        if (err) {
+            self.log.error(err, 'Failed to update aggregation %s',
+                self.name);
+            S.gotoState('update.local');
+            return;
+        }
+
+        S.gotoState('update.napi');
+    }
+
+    self.app.server.updateAggr(self.getId(), locupdate,
+        S.callback(afterUpdate));
+};
+
+AggrFSM.prototype.state_update.napi = function (S) {
+    var self = this;
+    var updated = false;
+
+    S.validTransitions([
+        'release',
+        'update',
+        'update.napi',
+        'stopped',
+        'waiting'
+    ]);
+
+    var remupdate = getDifferences(LOCAL_FIELDS, self.local, self.remote);
+    if (mod_jsprim.isEmpty(remupdate)) {
+        self.log.trace('No remote changes needed');
+        S.gotoState('waiting');
+        return;
+    }
+
+    S.on(this, 'setAsserted', function () {
+        /*
+         * We wait to move to the "update" state again to ensure that our
+         * PUTs are always correctly ordered.
+         */
+        updated = true;
+    });
+
+    S.on(this, 'releaseAsserted', function () {
+        /*
+         * It's okay for our DELETE to race with the PUT:
+         *
+         * - If the PUT wins, the DELETE will fail due to the "If-Match" header,
+         *   and will retry after refreshing.
+         * - If the DELETE wins, the PUT will fail, and we ignore the response.
+         */
+        S.gotoState('release');
+    });
+
+    function afterPut(err, aggr, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                self.log.warn('Aggregation no longer in NAPI, stopping');
+                S.gotoState('stopped');
+                return;
+            }
+
+            self.log.error(err, 'Failed to update aggregation in NAPI');
+            S.gotoState('update.napi');
+            return;
+        }
+
+        self.setRemote(aggr, res.headers['etag']);
+
+        if (updated) {
+            S.gotoState('update');
+        } else {
+            S.gotoState('waiting');
+        }
+    }
+
+    self.log.info({ payload: remupdate }, 'Updating aggregation in NAPI');
+
+    self.app.napi.updateAggr(self.getId(), remupdate, S.callback(afterPut));
+};
+
+AggrFSM.prototype.state_remove = function (S) {
+    S.validTransitions([
+        'stopped'
+    ]);
+
+    S.gotoState('stopped');
+};
+
+AggrFSM.prototype.state_release = function (S) {
+    S.validTransitions([
+        'release.delete',
+        'release.refresh',
+        'stopped'
+    ]);
+
+    S.gotoState('release.delete');
+};
+
+AggrFSM.prototype.state_release.delete = function (S) {
+    var self = this;
+
+    if (self.remote === null) {
+        S.gotoState('release.refresh');
+        return;
+    }
+
+    if (self.released !== self.remote.belongs_to_uuid) {
+        self.log.info('Skipping aggregation deletion, ' +
+            'since upstream belongs_to_uuid has changed');
+        S.gotoState('stopped');
+        return;
+    }
+
+    if (typeof (self.etag) !== 'string') {
+        self.log.warn('No "Etag" set, skipping deletion');
+        S.gotoState('stopped');
+        return;
+    }
+
+    function afterDelete(err) {
+        if (err) {
+            if (err.statusCode === 404) {
+                self.log.info('Aggregation already deleted from NAPI');
+                S.gotoState('stopped');
+                return;
+            }
+
+            if (err.statusCode === 412) {
+                self.log.info('Aggregation "Etag" changed in NAPI, refreshing');
+                S.gotoState('release.refresh');
+                return;
+            }
+
+            S.timeout(5000, function () {
+                S.gotoState('release.delete');
+            });
+            return;
+        }
+
+        S.gotoState('stopped');
+    }
+
+    self.app.napi.deleteAggr(self.getId(), {}, {
+        headers: {
+            'If-Match': self.etag
+        }
+    }, S.callback(afterDelete));
+};
+
+AggrFSM.prototype.state_release.refresh = function (S) {
+    var self = this;
+
+    function afterGet(err, aggr, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                S.gotoState('stopped');
+                return;
+            }
+
+            self.log.warn(err,
+                'Failed to refresh aggregation information for release; ' +
+                'retrying in 5 seconds');
+            S.timeout(5000, function () {
+                S.gotoState('release.refresh');
+            });
+            return;
+        }
+
+        self.setRemote(aggr, res.headers['etag']);
+
+        self.log.info('Refreshed aggregation release information');
+
+        S.gotoState('release.delete');
+    }
+
+    self.log.info('Refreshing aggregation release information');
+
+    self.app.napi.getAggr(self.getId(), S.callback(afterGet));
+};
+
+AggrFSM.prototype.state_stopped = function (S) {
+    S.validTransitions([ ]);
+
+    this.local = null;
+    this.remote = null;
+    this.etag = undefined;
+};
+
+AggrFSM.prototype.getId = function () {
+    return mod_common.formatAggrId(this.app.cn_uuid, this.name);
+};
+
+AggrFSM.prototype.setLocal = function (aggr) {
+    assert.object(aggr, 'aggr');
+    var self = this;
+
+    self.local = aggr;
+
+    if (self.pending.update) {
+        return;
+    }
+
+    self.pending.update = true;
+    setImmediate(function () {
+        self.pending.update = false;
+        self.emit('setAsserted');
+    });
+};
+
+/**
+ * Update our copy of the aggregation in NAPI (as well as it's etag if the
+ * NAPI instance is new enough to report it).
+ */
+AggrFSM.prototype.setRemote = function (aggr, etag) {
+    assert.object(aggr, 'aggr');
+    assert.optionalString(etag, 'etag');
+    this.remote = aggr;
+    this.etag = etag;
+};
+
+AggrFSM.prototype.refresh = function (etag) {
+    var self = this;
+
+    if (etag && etag === self.etag) {
+        return;
+    }
+
+    if (self.pending.refresh) {
+        return;
+    }
+
+    self.pending.refresh = true;
+    setImmediate(function () {
+        self.pending.refresh = false;
+        self.emit('refreshAsserted');
+    });
+};
+
+AggrFSM.prototype.releaseFrom = function (belongs_to_uuid) {
+    assert.string(belongs_to_uuid, 'belongs_to_uuid');
+    this.released = belongs_to_uuid;
+    this.emit('releaseAsserted', belongs_to_uuid);
+};
+
+module.exports = AggrFSM;
diff --git a/lib/common.js b/lib/common.js
new file mode 100644
index 0000000..a4b9abc
--- /dev/null
+++ b/lib/common.js
@@ -0,0 +1,41 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var mod_jsprim = require('jsprim');
+var mod_util = require('util');
+
+// --- Exports
+
+function formatAggrId(cn_uuid, name) {
+    return mod_util.format('%s-%s', cn_uuid, name);
+}
+
+
+function hasChanged(fields, cur, old) {
+    if (cur === old) {
+        return false;
+    }
+
+    if (old === null) {
+        return true;
+    }
+
+    return fields.some(function (field) {
+        return mod_jsprim.deepEqual(cur[field], old[field]);
+    });
+}
+
+
+module.exports = {
+    formatAggrId: formatAggrId,
+    hasChanged: hasChanged
+};
diff --git a/lib/index.js b/lib/index.js
index e67010b..e652022 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,13 +5,15 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
  * index.js
  */
 
+'use strict';
+
 var NetAgent = require('./net-agent');
 
 module.exports = NetAgent;
diff --git a/lib/inst-fsm.js b/lib/inst-fsm.js
new file mode 100644
index 0000000..e94885f
--- /dev/null
+++ b/lib/inst-fsm.js
@@ -0,0 +1,427 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+var vmadm = require('vmadm');
+
+// --- Globals
+
+var FIELDS = [
+    'uuid',
+    'owner_uuid',
+    'state',
+    'zone_state',
+    'nics',
+    'resolvers',
+    'routes'
+];
+
+var NAPI_FIELDS = [
+    'allow_dhcp_spoofing',
+    'allow_ip_spoofing',
+    'allow_mac_spoofing',
+    'allow_restricted_traffic',
+    'allow_unfiltered_promisc',
+    'gateway',
+    'model',
+    'mtu',
+    'netmask',
+    'network_uuid',
+    'nic_tag',
+    'primary',
+    'ip',
+    'vlan_id'
+];
+
+var STATE_WATCHER_TIMEOUT = 5 * 60 * 1000;
+
+
+// --- Exports
+
+/**
+ * The InstanceFSM is responsible for tracking changes related to a single VM
+ * and its NICs. When a VM's state changes we push any relevant info up to NAPI.
+ * Alternatively, when NAPI state changes (new routes, for example), then we
+ * need to take care of updating the VM to match.
+ */
+function InstanceFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+    assert.object(opts.app, 'opts.app');
+    assert.optionalObject(opts.vm, 'opts.vm');
+
+    this.uuid = opts.uuid;
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'instance',
+        uuid: this.uuid
+    }, true);
+
+    this.pending = {
+        refresh: false
+    };
+
+    this.nics = {};
+    this.vm = null;
+
+    if (opts.vm) {
+        this._update(opts.vm);
+    }
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(InstanceFSM, mod_mooremachine.FSM);
+
+InstanceFSM.prototype.state_init = function (S) {
+    S.validTransitions([
+        'refresh',
+        'update'
+    ]);
+
+    if (this.vm === null) {
+        S.gotoState('refresh');
+    } else {
+        S.gotoState('update');
+    }
+};
+
+InstanceFSM.prototype.state_waiting = function (S) {
+    S.validTransitions([ 'refresh' ]);
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    /*
+     * Due to historical unreliable behavior of our two watchers and since they
+     * don't alert on all relevant property changes (such as "owner_uuid"), we
+     * periodically check the configuration of the instance for any changes.
+     */
+    S.timeout(STATE_WATCHER_TIMEOUT, function () {
+        S.gotoState('refresh');
+    });
+};
+
+InstanceFSM.prototype.state_refresh = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'refresh',
+        'remove',
+        'update',
+        'waiting'
+    ]);
+
+    S.on(self, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    function afterLoad(err, vm) {
+        if (err) {
+            if (err.restCode === 'VmNotFound') {
+                if (self.vm === null) {
+                    S.gotoState('waiting');
+                } else {
+                    S.gotoState('remove');
+                }
+                return;
+            }
+
+            self.log.error(err, 'failed to refresh vm information');
+            S.immediate(function () {
+                S.gotoState('refresh');
+            });
+            return;
+        }
+
+        if (vm.state === 'failed') {
+            S.gotoState('remove');
+            return;
+        }
+
+        self._update(vm);
+
+        S.gotoState('update');
+    }
+
+    vmadm.load({
+        log: self.log,
+        uuid: self.uuid,
+        fields: FIELDS,
+        include_dni: false
+    }, S.callback(afterLoad));
+};
+
+InstanceFSM.prototype.state_update = function (S) {
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(this, 'removeAsserted', function () {
+        S.gotoState('remove');
+    });
+
+    S.gotoState('update.wait');
+};
+
+/**
+ * Check that all of this instance's NICs have completed their first refresh.
+ * If they have, we can go ahead and compare target routes with the current
+ * set. Otherwise, wait until the NIC moves into state "update", and then
+ * try again.
+ */
+InstanceFSM.prototype.state_update.wait = function (S) {
+    var pending = null;
+
+    for (var mac in this.nics) {
+        if (!mod_jsprim.hasKey(this.nics, mac)) {
+            continue;
+        }
+
+        if (this.nics[mac].remote === null) {
+            pending = this.nics[mac];
+            break;
+        }
+    }
+
+    if (pending === null) {
+        S.gotoState('update.vm');
+        return;
+    }
+
+    S.on(pending, 'stateChanged', function onStateChange() {
+        if (pending.remote === null) {
+            return;
+        }
+
+        S.gotoState('update.wait');
+    });
+};
+
+InstanceFSM.prototype.state_update.vm = function (S) {
+    var self = this;
+
+    var current = Object.assign({}, this.vm.routes);
+    var resolvers = [];
+    var target = {};
+
+    function addResolver(resolver) {
+        if (resolvers.indexOf(resolver) === -1) {
+            resolvers.push(resolver);
+        }
+    }
+
+    mod_jsprim.forEachKey(this.nics, function (_, nfsm) {
+        if (nfsm.remote.routes) {
+            Object.assign(target, nfsm.remote.routes);
+        }
+
+        if (Array.isArray(nfsm.remote.resolvers)) {
+            nfsm.remote.resolvers.forEach(addResolver);
+        }
+    });
+
+    mod_jsprim.forEachKey(target, function (dst, gw) {
+        if (current[dst] === gw) {
+            delete target[dst];
+        }
+
+        delete current[dst];
+    });
+
+    var remove = Object.keys(current);
+
+    if (remove.length === 0 &&
+        mod_jsprim.isEmpty(target) &&
+        mod_jsprim.deepEqual(resolvers, this.vm.resolvers)) {
+        S.gotoState('waiting');
+        return;
+    }
+
+    function afterUpdate(err) {
+        if (err) {
+            self.log.error(err, 'Failed to update networking info for VM');
+        }
+
+        /*
+         * Refresh to verify the current state of the VM.
+         */
+        S.gotoState('refresh');
+    }
+
+    var payload = {
+        uuid: self.uuid,
+        resolvers: resolvers,
+        set_routes: target,
+        remove_routes: remove
+    };
+
+    self.log.info({ payload: payload },
+        'Updating networking information for VM');
+
+    payload.log = self.log;
+
+    vmadm.update(payload, S.callback(afterUpdate));
+};
+
+
+InstanceFSM.prototype.state_remove = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'refresh'
+    ]);
+
+    mod_jsprim.forEachKey(self.nics, function (mac, _) {
+        self.app.releaseNic(mac, self.uuid);
+    });
+
+    self.nics = {};
+    self.vm = null;
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+};
+
+
+InstanceFSM.prototype._update = function (vm) {
+    var self = this;
+    var prev = self.nics;
+
+    self.vm = {
+        state: vm.state,
+        owner_uuid: vm.owner_uuid,
+        resolvers: vm.resolvers,
+        routes: vm.routes,
+        zone_state: vm.zone_state
+    };
+    self.nics = {};
+
+    vm.nics.forEach(function (nic) {
+        var mac = nic.mac;
+        var nfsm;
+
+        if (mod_jsprim.hasKey(prev, mac)) {
+            nfsm = prev[mac];
+            delete prev[mac];
+        } else {
+            self.log.info('NIC %s added to VM %s', mac, self.uuid);
+            nfsm = self.app.watchNic(mac);
+        }
+
+        nfsm.setLocal(self._fmtnic(nic));
+
+        self.nics[mac] = nfsm;
+    });
+
+    mod_jsprim.forEachKey(prev, function (mac, _) {
+        self.log.info('NIC %s removed from VM %s', mac, self.uuid);
+        self.app.releaseNic(mac, self.uuid);
+    });
+};
+
+InstanceFSM.prototype._fmtstate = function (state) {
+    return (state === 'running' ? 'running' : 'stopped');
+};
+
+InstanceFSM.prototype._fmtnic = function (nic) {
+    var o = {
+        cn_uuid: this.app.cn_uuid,
+        belongs_to_uuid: this.uuid,
+        belongs_to_type: 'zone',
+        owner_uuid: this.vm.owner_uuid,
+        state: this._fmtstate(this.vm.state)
+    };
+
+    NAPI_FIELDS.forEach(function (field) {
+        if (mod_jsprim.hasKey(nic, field)) {
+            o[field] = nic[field];
+        }
+    });
+
+    return o;
+};
+
+InstanceFSM.prototype.refresh = function () {
+    var self = this;
+
+    if (self.pending.refresh) {
+        return;
+    }
+
+    self.pending.refresh = true;
+    setImmediate(function () {
+        self.pending.refresh = false;
+        self.emit('refreshAsserted');
+    });
+};
+
+InstanceFSM.prototype.remove = function () {
+    this.emit('removeAsserted');
+};
+
+InstanceFSM.prototype.addNIC = function (mac, nic, callback) {
+    var self = this;
+
+    nic.mac = mac;
+
+    vmadm.update({
+        uuid: self.uuid,
+        add_nics: [ nic ],
+        log: self.log
+    }, function (err) {
+        self.refresh();
+        callback(err);
+    });
+};
+
+InstanceFSM.prototype.updateNIC = function (mac, update, callback) {
+    var self = this;
+
+    self.log.info({ payload: update },
+        'Updating NIC %s on VM %s', mac, self.uuid);
+
+    update.mac = mac;
+
+    vmadm.update({
+        uuid: self.uuid,
+        update_nics: [ update ],
+        log: self.log
+    }, function (err) {
+        self.refresh();
+        callback(err);
+    });
+};
+
+InstanceFSM.prototype.removeNIC = function (mac, callback) {
+    var self = this;
+
+    self.log.info('Removing NIC %s on VM %s', mac, self.uuid);
+
+    vmadm.update({
+        uuid: self.uuid,
+        remove_nics: [ mac ],
+        log: self.log
+    }, function (err) {
+        self.refresh();
+        callback(err);
+    });
+};
+
+module.exports = {
+    InstanceFSM: InstanceFSM,
+    FIELDS: FIELDS
+};
diff --git a/lib/napi-client.js b/lib/napi-client.js
deleted file mode 100644
index 37faaac..0000000
--- a/lib/napi-client.js
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright 2016 Joyent, Inc.
- */
-
-/*
- * net-agent.js
- */
-
-var async = require('async');
-var NAPI = require('sdc-clients').NAPI;
-
-var ANTI_SPOOF_FIELDS = ['allow_dhcp_spoofing', 'allow_ip_spoofing',
-    'allow_mac_spoofing', 'allow_restricted_traffic',
-    'allow_unfiltered_promisc'];
-
-
-function NapiClient(options) {
-    this.options = options;
-    this.log = options.log;
-    this.uuid = options.uuid;
-
-    this.client = new NAPI({
-        url: options.url,
-        log: options.log,
-        userAgent: options.userAgent
-    });
-}
-
-
-/*
- * Updates each of the VM NICs
- *
- * - vm: VM object
- * - nics: the NICs that need to be updated
- *
- * Calls out to NAPI to verify the current NIC data and for each NIC it can do
- * one of the following things:
- *
- * 1. NIC was removed from the VM or VM provision has failed (destroy)
- * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be updated (update)
- * 4. NIC exists and but has not changed, no need to do anything (noop)
- */
-NapiClient.prototype.updateNics = function (vm, nics, callback) {
-    var self = this;
-    var log = this.log;
-
-    async.forEachSeries(nics, eachNic, callback);
-
-    function eachNic(nic, cb) {
-        // cn_uuid is a field that exists in NAPI but not in vmadm, so add
-        // it here:
-        nic.cn_uuid = self.uuid;
-
-        self.getNic(nic.mac, onGetNic);
-
-        function onGetNic(err, napiNic) {
-            if (err) {
-                if (err.name === 'ResourceNotFoundError') {
-                    napiNic = undefined;
-                } else {
-                    cb(err);
-                    return;
-                }
-            }
-
-            if (nic.destroyed) {
-                self.deleteNic(vm, nic, cb);
-                return;
-            }
-
-            nic.state = (vm.state === 'running' ? 'running' : 'stopped');
-
-            if (!napiNic) {
-                self.createNic(vm, nic, cb);
-            } else if (_nicChanged(nic, napiNic)) {
-                self.updateNic(vm, nic, napiNic, cb);
-            } else {
-                log.info('NIC (mac=%s, ip=%s, state=%s) unchanged for VM %s',
-                    nic.mac, nic.ip, nic.state, vm.uuid);
-                cb();
-            }
-        }
-    }
-};
-
-
-NapiClient.prototype.getNic = function (mac, callback) {
-    return this.client.getNic(mac, callback);
-};
-
-
-NapiClient.prototype.createNic = function (vm, newNic, callback) {
-    var log = this.log;
-    var nic = _createNicPayload(vm, newNic);
-
-    this.client.createNic(nic.mac, nic, function (err) {
-        if (err) {
-            log.error(err, 'Could not add NIC %s for VM %s',
-                nic.mac, vm.uuid);
-            return callback(err);
-        }
-
-        log.info('NIC (mac=%s, ip=%s, state=%s) added for VM %s',
-            nic.mac, nic.ip, nic.state, vm.uuid);
-        return callback();
-    });
-};
-
-
-NapiClient.prototype.updateNic = function (vm, newNic, napiNic, callback) {
-    var log = this.log;
-    var nic = _createNicPayload(vm, newNic);
-
-    for (var i = 0; i < ANTI_SPOOF_FIELDS.length; i++) {
-        var field = ANTI_SPOOF_FIELDS[i];
-        if (napiNic.hasOwnProperty(field) && !newNic.hasOwnProperty(field)) {
-            nic[field] = false;
-        }
-    }
-
-    this.client.updateNic(nic.mac, nic, function (err) {
-        if (err) {
-            log.error(err, 'Could not update NIC %s for VM %s',
-                nic.mac, vm.uuid);
-            return callback(err);
-        }
-
-        log.info('NIC (mac=%s, ip=%s, state=%s) updated for VM %s',
-            nic.mac, nic.ip, nic.state, vm.uuid);
-        return callback();
-    });
-};
-
-
-NapiClient.prototype.deleteNic = function (vm, nic, callback) {
-    var log = this.log;
-
-    this.client.deleteNic(nic.mac, function (err) {
-        if (err) {
-            if (err.name === 'ResourceNotFoundError') {
-                log.info('NIC (mac=%s, ip=%s) already gone for VM %s',
-                    nic.mac, nic.ip, vm.uuid);
-                return callback();
-            } else {
-                log.error(err, 'Could not delete NIC %s for VM %s',
-                    nic.mac, vm.uuid);
-                return callback(err);
-            }
-        }
-
-        log.info('NIC (mac=%s, ip=%s) deleted for VM %s',
-            nic.mac, nic.ip, vm.uuid);
-        return callback();
-    });
-};
-
-
-
-/*
- * Some helper functions for NapiClient
- */
-
-function _nicChanged(cur, old) {
-    var fields = [ 'cn_uuid', 'vlan_id', 'nic_tag', 'primary', 'ip', 'netmask',
-        'state' ].concat(ANTI_SPOOF_FIELDS);
-    var field;
-
-    for (var i = 0; i < fields.length; i++) {
-        field = fields[i];
-        if (cur[field] !== old[field]) {
-            return true;
-        }
-    }
-
-    return false;
-}
-
-
-function _clone(obj) {
-    if (null === obj || 'object' != typeof (obj)) {
-        return obj;
-    }
-
-    var copy = obj.constructor();
-
-    for (var attr in obj) {
-        if (obj.hasOwnProperty(attr)) {
-            copy[attr] = obj[attr];
-        }
-    }
-    return copy;
-}
-
-
-function _sanitizeBooleanAntiSpoof(nic) {
-    function booleanFromValue(value) {
-        if (value === 'false' || value === '0') {
-            return false;
-        } else if (value === 'true' || value === '1') {
-            return true;
-        } else {
-            // else should be boolean
-            return value;
-        }
-    }
-
-    ANTI_SPOOF_FIELDS.forEach(function (field) {
-        if (nic[field] !== undefined) {
-            nic[field] = booleanFromValue(nic[field]);
-        }
-    });
-}
-
-
-function _createNicPayload(vm, currentNic) {
-    var newNic = _clone(currentNic);
-
-    newNic.check_owner = false;
-    newNic.owner_uuid = vm.owner_uuid;
-    newNic.belongs_to_uuid = vm.uuid;
-    newNic.belongs_to_type = 'zone';
-
-    if (newNic.vlan_id === undefined) {
-        newNic.vlan_id = 0;
-    }
-    newNic.vlan = newNic.vlan_id;
-    _sanitizeBooleanAntiSpoof(newNic);
-
-    return newNic;
-}
-
-
-module.exports = NapiClient;
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 58dcb02..67a611d 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,61 +5,80 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018 Joyent, Inc.
  */
 
 /*
- * Net-Agent and NAPI
- * ==================
  *
- * VM Change Events
- * ----------------
+ * net-agent
+ * =========
  *
- * Net-agent's job is to inform NAPI of any changes to any NICs that result
- * from VM-related events. For instance, if a VM gets destroyed (either by
- * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
- * for telling NAPI that the NIC that used to belong to that VM should be
- * destroyed.
+ * The networking agent is responsible for syncing information between NAPI
+ * and Compute Nodes. Unlike other aspects of Triton, such as disk space
+ * availability, memory usage, and so on, the Compute Node is not the source
+ * of truth for networking configuration. Changes to properties like a network's
+ * gateway or resolvers need to be rolled out to VMs as soon as they happen.
+ * As NAPI's boots on the ground, net-agent takes care of updating VMs as it
+ * becomes aware of changes to networks and NICs.
  *
- * Net-agent responds to 4 kinds of changes to a VM:
+ * Unfortunately, some networking changes require a reboot in order for them
+ * to take effect (this is especially true of many hardware VM images), so we
+ * leave the timing of the reboot up to the VM owner. The notable exception to
+ * this is when we detect that a VM has a NIC that belongs to someone else, in
+ * which case we need to remove the NIC and reboot it to avoid hitting
+ * Duplicate Address Detection issues.
  *
- *  - The VM's zone_state has changed
- *  - The VM's zone configurations XML file has changed
- *  - The VM's state has changed
- *  - The VM has been destroyed
+ * Monitor FSMs
+ * ------------
+ *
+ * net-agent has several finite state machines that it uses for tracking local
+ * and remote state. From a high level, they do the following:
+ *
+ *  - Waiting
+ *  - Refreshing
+ *  - Update
  *
- * Whenever a change is detected, net-agent walks its internal list of VM
- * objects (which also contains the NIC info) and pushes the NIC objects to
- * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
- * address.
+ * Each FSM is solely responsible for tracking the state of its object. This is
+ * to ensure that the updates for an object are correctly ordered, and to
+ * simplify the logic for performing retries. (As an example, net-agent used to
+ * exponentially back off on retries, and the backed off request would
+ * eventually overwrite an update that came later.)
  *
- * Net-Agent and VMs
- * =================
+ * Tracking VM changes
+ * -------------------
  *
- * Net-Agent loads all of VMs that are located on the same CN as it is, by
- * executing `vmadm lookup`, and storing the VM objects in memory. This set of
- * VM objects is known as the sample.
+ * net-agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory, each one
+ * tracked by a separate InstanceFSM.
  *
- * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * net-agent listens for VM events by executing a child `zoneevent` command,
  * and processing the JSON that it produces on stdout. `zoneevent` emits output
  * whenever a property of the zone has changed. Note that it does not report
- * higher-level VM properties (that are used by vmadm and vmapi).
- *
- * As Net-Agent receives these change events, it updates the changed properties
- * of the VM objects in the sample. However, it is possible that one of the
- * change-events does not make it to net-agent. In order to mitigate the drift
- * between net-agent's picture of reality, and reality itself, net-agent also
- * does a full `vmadm lookup` every minute, and emits state-change events if it
- * detects a difference.
+ * higher-level VM properties (that are used by vmadm and vmapi). As net-agent
+ * receives these change events, it tells the InstanceFSM to refresh its state.
  */
 
+'use strict';
+
 var assert = require('assert-plus');
-var async = require('async');
-var backoff = require('backoff');
+var mod_clients = require('sdc-clients');
+var mod_cueball = require('cueball');
+var mod_inst = require('./inst-fsm');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
 var vmadm = require('vmadm');
 
 var VM = require('./vm');
-var NAPI = require('./napi-client');
+var NAPI = mod_clients.NAPI;
+
+var AggrFSM = require('./aggr-fsm');
+var NetworkFSM = require('./net-fsm');
+var NicFSM = require('./nic-fsm');
+var InstanceFSM = mod_inst.InstanceFSM;
+var ServerFSM = require('./server-fsm');
+
+// --- Internal helpers
 
 var _versionCache = null;
 function getNetAgentVersion() {
@@ -69,23 +88,44 @@ function getNetAgentVersion() {
     return _versionCache;
 }
 
+
+// --- Exports
+
 function NetAgent(options) {
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.uuid(options.cn_uuid, 'options.cn_uuid');
+    assert.uuid(options.agent_uuid, 'options.agent_uuid');
+    assert.uuid(options.admin_uuid, 'options.admin_uuid');
+    assert.object(options.napi, 'options.napi');
+    assert.string(options.napi.url, 'options.napi.url');
+    assert.object(options.cueballAgent, 'options.cueballAgent');
+
     this.options = options;
     this.log = options.log;
     this.sample = null;
     this.lastFullSample = null;
-    this.uuid = options.uuid;
+    this.cn_uuid = options.cn_uuid;
+    this.agent_uuid = options.agent_uuid;
+    this.admin_uuid = options.admin_uuid;
     this.version = getNetAgentVersion();
 
-    var userAgent = 'net-agent/' + this.version +
-        ' (' + 'node/' + process.versions.node + ')' +
-        ' server/' + this.uuid;
+    var userAgent = mod_util.format(
+        'net-agent/%s (node/%s) server/%s',
+        this.version, process.versions.node, this.cn_uuid);
+
+    var cbopts = mod_jsprim.mergeObjects(options.cueballAgent, {
+        log: this.log.child({ component: 'cueball' })
+    });
+
+    this.cueballAgent = new mod_cueball.HttpAgent(cbopts);
 
-    this.napiClient = new NAPI({
-        url: options.url,
+    this.napi = new NAPI({
+        url: options.napi.url,
         log: options.log,
-        userAgent: userAgent,
-        uuid: options.uuid
+        agent: this.cueballAgent,
+        retry: false,
+        userAgent: userAgent
     });
 
     this.eventWatcher = VM.createEventWatcher({
@@ -96,475 +136,254 @@ function NetAgent(options) {
     this.sample = {};
     // Serial queues for sending VM updates serially
     this.queues = {};
-}
-
-
-NetAgent.prototype.start = function () {
-    var self = this;
-    var log = this.log;
-
-    this.initializeEventWatcher();
-
-    // Wrap our initial full sample in a retry-backoff
-    var opts = { uuid: this.uuid };
-    var fn = this.sendFullSample.bind(this, opts);
-    this.retryUpdate(fn, opts, onRetry);
-
-    function onRetry(err) {
-        if (err) {
-            log.error(err, 'Failed retry-backoff for initial sendFullSample');
-            return;
-        }
 
-        log.info('Initial NICs state was successfully sent. Good to go');
-        self.eventWatcher.updateState(self.sample);
-        self.eventWatcher.lastCfgEvent = self.lastFullSample;
-        self.eventWatcher.start();
-    }
-};
-
-
-/*
- * Initializes the EventWatcher event listeners
- */
-NetAgent.prototype.initializeEventWatcher = function () {
-    var self = this;
-    var log = this.log;
-    var eventWatcher = this.eventWatcher;
-
-    eventWatcher.on('state', function vm_state_event(uuid, state) {
-        log.debug('state event for %s state: %s', uuid, state);
-        self.pushSample({
-            uuid: uuid,
-            cachedVm: self.sample[uuid]
-        });
+    this.server = new ServerFSM({
+        uuid: this.cn_uuid,
+        app: this
     });
+    this.aggrs = {};
+    this.insts = {};
+    this.nics = {};
+    this.nets = {};
 
-    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
-        log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
-        self.pushSample({
-            uuid: uuid,
-            cachedVm: self.sample[uuid]
-        });
-    });
-
-    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
-        log.debug('fs.watch event on /etc/zones for %s', uuid);
-        self.pushSample({
-            uuid: uuid,
-            cachedVm: self.sample[uuid]
-        });
-    });
-
-    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
-        var vm = self.sample[uuid];
-        if (!vm) {
-            log.warn('VM %s appears to have gone away but ' +
-                'self.sample doesn\'t have it', uuid);
-            return;
-        }
-
-        log.info('Found a destroyed VM %s', uuid);
-        vm.state = 'destroyed';
-        self.pushSample({
-            uuid: uuid,
-            cachedVm: vm
-        });
-    });
+    mod_mooremachine.FSM.call(this, 'waiting');
+}
+mod_util.inherits(NetAgent, mod_mooremachine.FSM);
 
-    eventWatcher.on('err', function zone_err_event(err) {
-        log.error(err, 'eventWatcher saw en error');
-    });
+NetAgent.prototype.start = function () {
+    this.emit('startAsserted');
 };
 
+NetAgent.prototype.stop = function () {
+    this.emit('stopAsserted');
+};
 
-NetAgent.prototype.setSample = function (sample) {
-    var self = this;
+NetAgent.prototype.addVM = function (vm) {
+    if (mod_jsprim.hasKey(this.insts, vm.uuid)) {
+        this.insts[vm.uuid].refresh();
+        return;
+    }
 
-    Object.keys(sample).forEach(function (key) {
-        self.sample[key] = sample[key];
+    this.insts[vm.uuid] = new InstanceFSM({
+        uuid: vm.uuid,
+        vm: vm,
+        app: this
     });
 };
 
-/*
- * On startup, sendFullSample updates all NICs for all VMs on the server. This
- * will be a blocking call before we turn on the event listeners so we allow
- * net-agent to report the full state of the server first
- */
-NetAgent.prototype.sendFullSample = function (opts, callback) {
-    var self = this;
-    var log = this.log;
-
-    this.updateSample({}, function (err, sample) {
-        if (err) {
-            log.error(err, 'updateSample failed, cannot sendFullSample');
-            callback(err);
-            return;
-
-        } else if (Object.keys(sample).length === 0) {
-            log.warn('empty sample returned by vmadm lookup');
-            callback();
-            return;
-        }
-
-        self.setSample(sample);
-
-        async.forEachSeries(Object.keys(sample), function (uuid, cb) {
-            var options = {
-                uuid: uuid,
-                vm: sample[uuid]
-            };
-
-            self._updateVmNics(options, cb);
-        },
-        function (asyncErr) {
-            if (asyncErr) {
-                log.error(asyncErr, 'Could not sendFullSample');
-                return callback(asyncErr);
-            }
+NetAgent.prototype.refreshVM = function (uuid) {
+    if (mod_jsprim.hasKey(this.insts, uuid)) {
+        this.insts[uuid].refresh();
+        return;
+    }
 
-            return callback();
-        });
+    this.insts[uuid] = new InstanceFSM({
+        uuid: uuid,
+        app: this
     });
 };
 
+NetAgent.prototype.removeVM = function (uuid) {
+    if (!mod_jsprim.hasKey(this.insts, uuid)) {
+        this.log.warn('VM %s appears to have gone away but ' +
+            'the agent isn\'t tracking it', uuid);
+        return;
+    }
 
-/*
- * sendSample accepts options.server to indicate this is a full server sample
- */
-NetAgent.prototype.sendSample = function (options, callback) {
-    var self = this;
-    var log = this.log;
+    this.log.info('Found a destroyed VM %s', uuid);
+    this.insts[uuid].remove();
+    delete this.insts[uuid];
+};
 
-    // if vm was destroyed else vmadm lookup
-    if (options.cachedVm && options.cachedVm.state === 'destroyed') {
-        var destSample = {};
-        destSample[options.uuid] = options.cachedVm;
-        this.setSample(destSample);
-        this.eventWatcher.removeState(options.uuid);
-
-        self._updateVmNics(options, callback);
-    } else {
-        this.updateSample(options, function (err, sample) {
-            if (err) {
-                log.error(err, 'updateSample failed, cannot sendSample');
-                callback(err);
-            } else if (Object.keys(sample).length === 0) {
-                log.warn('empty sample returned by vmadm lookup');
-                callback();
-            } else {
-                self.eventWatcher.updateState(sample);
-                self.setSample(sample);
-                options.vm = sample[options.uuid];
-                self._updateVmNics(options, callback);
-            }
+NetAgent.prototype.watchNet = function (uuid) {
+    if (!mod_jsprim.hasKey(this.nets, uuid)) {
+        this.nets[uuid] = new NetworkFSM({
+            uuid: uuid,
+            app: this
         });
     }
+
+    return this.nets[uuid];
 };
 
+NetAgent.prototype.releaseNet = function (network_uuid) {
+    if (mod_jsprim.hasKey(this.nets, network_uuid)) {
+        this.nets[network_uuid].stop();
+        delete this.nets[network_uuid];
+    }
+};
 
-/*
- * Updates each of the VM NICs
- *
- * - options.cachedVm: what net-agent currently knows about the VM
- * - options.vm: what net-agent has loaded from vmadm
- *
- * When options.vm is undefined, it means that the VM has been destroyed because
- * options.vm gets populated from the vmadm lookup results. We always store the
- * last VM object known to net-agent as options.cachedVm
- *
- * When options.cachedVm is undefined, then this is the first time we see that
- * VM (or our net-agent has just started)
- */
-NetAgent.prototype._updateVmNics = function (options, callback) {
-    var log = this.log;
-    var allNics = [];
-
-    if (options.vm) {
-        options.vm.nics.forEach(function (nic) {
-            // When VM is failed just mark all NICs are destroyed
-            if (options.vm.state === 'failed') {
-                nic.destroyed = true;
-            }
-            allNics.push(nic);
+NetAgent.prototype.watchNic = function (mac) {
+    if (!mod_jsprim.hasKey(this.nics, mac)) {
+        this.nics[mac] = new NicFSM({
+            app: this,
+            mac: mac
         });
     }
 
-    // First time net-agent runs its cache will be empty
-    if (options.cachedVm) {
-        options.cachedVm.nics.forEach(function (cachedNic) {
-            // When VM is destroyed just mark all NICs are destroyed
-            if (options.cachedVm.state === 'destroyed') {
-                cachedNic.destroyed = true;
-                allNics.push(cachedNic);
-                return;
-            }
-
-            // If a cached NIC cannot be found on the sampled VM object then
-            // we can assume it has been deleted from the VM
-            var filtered = options.vm && options.vm.nics.filter(function (nic) {
-                return nic.mac === cachedNic.mac;
-            });
+    return this.nics[mac];
+};
 
-            if (!filtered.length) {
-                cachedNic.destroyed = true;
-                allNics.push(cachedNic);
-            }
-        });
+NetAgent.prototype.releaseNic = function (mac, belongs_to_uuid) {
+    if (mod_jsprim.hasKey(this.nics, mac)) {
+        this.nics[mac].releaseFrom(belongs_to_uuid);
+        delete this.nics[mac];
     }
+};
 
-    if (!allNics.length) {
-        log.info('VM %s has no NICs to update', options.uuid);
-        callback();
-        return;
+NetAgent.prototype.watchAggr = function (name) {
+    if (!mod_jsprim.hasKey(this.aggrs, name)) {
+        this.aggrs[name] = new AggrFSM({
+            app: this,
+            name: name
+        });
     }
 
-    var vm = options.vm || options.cachedVm;
+    return this.aggrs[name];
+};
 
-    this.napiClient.updateNics(vm, allNics, callback);
+NetAgent.prototype.releaseAggr = function (name, belongs_to_uuid) {
+    if (mod_jsprim.hasKey(this.aggrs, name)) {
+        this.aggrs[name].releaseFrom(belongs_to_uuid);
+        delete this.aggrs[name];
+    }
 };
 
+NetAgent.prototype.state_waiting = function (S) {
+    S.on(this, 'startAsserted', function () {
+        S.gotoState('init');
+    });
+};
 
-/*
- * Initializes the serial queue for a single uuid and pushes the item to be
- * processed.
- */
-NetAgent.prototype.pushSample = function (options) {
-    var uuid = options.uuid || this.uuid;
+NetAgent.prototype.state_init = function (S) {
+    S.on(this, 'stopAsserted', function () {
+        S.gotoState('stopping');
+    });
 
-    if (this.queues[uuid] === undefined) {
-        this.queues[uuid] = this.createQueue(uuid);
-    }
-    this.queues[uuid].push(options);
+    S.gotoState('init.watchzones');
 };
 
+NetAgent.prototype.state_init.watchzones = function (S) {
+    S.validTransitions([ 'init.fetchzones' ]);
 
-/*
- * Retries an update operation.
- */
-NetAgent.prototype.retryUpdate = function (fn, options, callback) {
-    assert.object(options);
-    assert.uuid(options.uuid);
-    var log = this.log;
-    var retryOpts = { initialDelay: 2000, maxDelay: 64000 };
-
-    function logAttempt(aLog, host) {
-        function _log(number, delay, err) {
-            var level;
-            if (number === 0) {
-                level = 'info';
-            } else if (number < 5) {
-                level = 'warn';
-            } else {
-                level = 'error';
-            }
-
-            aLog.error(err, 'retry error for %s', options.uuid);
-            aLog[level]({
-                ip: host,
-                attempt: number,
-                delay: delay
-            }, 'retry attempt for %s', options.uuid);
-        }
+    /*
+     * TODO: At some point, we should refactor the zoneevent watcher to be an
+     * FSM that handles restarting failed/exited processes correctly.
+     *
+     * Ideally when we do so, it'll have a .start() method, and emit an event
+     * that indicates we can continue here.
+     */
+    this.initializeEventWatcher();
+    this.eventWatcher.start();
 
-        return (_log);
-    }
+    S.gotoState('init.fetchzones');
+};
 
-    var retry = backoff.call(fn, function backoffCallCb(err) {
-        retry.removeAllListeners('backoff');
+NetAgent.prototype.state_init.fetchzones = function (S) {
+    var self = this;
 
-        var attempts = retry.getNumRetries();
+    S.validTransitions([ 'init.fetchzones', 'running', 'stopping' ]);
 
+    function afterLookup(err, vms) {
         if (err) {
-            log.error({ uuid: options.uuid },
-                'Could not retry operation after %d attempts', attempts);
-            return callback(err);
+            self.log.error(err, 'unable to fetch initial VM list; retrying');
+            S.timeout(1000, function () {
+                S.gotoState('init.fetchzones');
+            });
+            return;
         }
-        return callback();
-    });
 
-    retry.setStrategy(new backoff.ExponentialStrategy({
-        initialDelay: retryOpts.initialDelay,
-        maxDelay: retryOpts.maxDelay
-    }));
+        vms.forEach(function (vm) {
+            self.addVM(vm);
+        });
 
-    retry.failAfter(retryOpts.retries || Infinity);
-    retry.on('backoff', logAttempt(log));
+        self.log.info('found %d instances for tracking', vms.length);
 
-    retry.start();
-};
+        S.gotoState('running');
+    }
 
+    self.log.info('querying local cn for instances...');
 
-/*
- * Initializes a serial queue for a uuid
- */
-NetAgent.prototype.createQueue = function (uuid) {
+    vmadm.lookup({}, {
+        log: self.log,
+        include_dni: false,
+        fields: mod_inst.FIELDS
+    }, S.callback(afterLookup));
+};
+
+NetAgent.prototype.state_running = function (S) {
     var self = this;
-    var log = this.log;
 
-    var queue = async.queue(function qcb(opts, callback) {
-        var fn = self.sendSample.bind(self, opts);
-        self.retryUpdate(fn, opts, function retryUpdateCb(err) {
-            if (err) {
-                log.error(err, 'Error updating NICs %', uuid);
-                return callback(err);
-            }
+    S.validTransitions([ 'stopping' ]);
 
-            return callback();
-        });
-    }, 1);
+    S.on(self, 'stopAsserted', function () {
+        S.gotoState('stopping');
+    });
+};
+
+NetAgent.prototype.state_stopping = function (S) {
+    var self = this;
 
-    queue.drain = function () {
-        log.trace('serial queue for %s has been drained', uuid);
-    };
+    S.validTransitions([ 'stopped' ]);
 
-    queue.saturated = function () {
-        log.trace('serial queue for % has been saturated', uuid);
-    };
+    self.cueballAgent.stop();
 
-    return queue;
+    S.gotoState('stopped');
 };
 
+NetAgent.prototype.state_stopped = function (S) {
+    S.validTransitions([ ]);
+};
 
 /*
+ * Initializes the EventWatcher event listeners, which allow us to track any
+ * NIC changes that occur due to VM-related events. For instance, if a VM gets
+ * destroyed (either by VMAPI or an operator tool like vmadm or zoneadm), then
+ * net-agent is responsible for telling NAPI that the NIC that used to belong
+ * to that VM should be destroyed. (The VMAPI "destroy" workflow will also make
+ * an effort to do this -- and could perhaps beat us to the punch -- but we do
+ * it here too in case someone is using vmadm(1M) to remove a VM.)
+ *
+ * net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone configurations XML file has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever an update is detected, net-agent refreshes the corresponding
+ * InstanceFSM, which calculates the changes between the old and new states, to
+ * determine whether NICs have been added or removed.
  *
- *  Sample format that gets loaded from vmadm.lookup:
+ * Note that changes _within_ the zone are not reflected here, since they are
+ * not part of the VM configuration; this includes changes made with route(1M),
+ * updates to /etc/resolv.conf to change nameservers, etc.
  *
- *    {
- *    '70ac24a6-962a-4711-92f6-6dc6a53ea59e':
- *    { uuid: '70ac24a6-962a-4711-92f6-6dc6a53ea59e',
- *       owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
- *       quota: 25,
- *       max_physical_memory: 128,
- *       zone_state: 'running',
- *       state: 'running',
- *       brand: 'joyent-minimal',
- *       cpu_cap: 100,
- *       last_modified: '2014-04-29T23:30:17.000Z' },
- *    '9181f298-a867-49c6-9f34-d57584e7047e':
- *     { uuid: '9181f298-a867-49c6-9f34-d57584e7047e',
- *       owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
- *       quota: 25,
- *       max_physical_memory: 1024,
- *       zone_state: 'running',
- *       state: 'running',
- *       brand: 'joyent-minimal',
- *       cpu_cap: 300,
- *       last_modified: '2014-04-29T23:36:33.000Z' } },
- *       ...
- *       ...
- *   }
+ * In the case that a VM is destroyed, we remove the VM, which then releases the
+ * NICs.
  */
-
-NetAgent.prototype.updateSample = function (options, callback) {
-    if (!this._sampleQueue)
-        this._sampleQueue = async.queue(updateSample.bind(this), 8);
-
-    this._sampleQueue.push(options, callback);
-};
-
-function updateSample(options, callback) {
+NetAgent.prototype.initializeEventWatcher = function () {
     var self = this;
     var log = this.log;
-    var uuid = options.uuid;
-
-    var newSample;
-
-    function lookup(cb) {
-        // If we fail a lookup, newSample gets reset on every retry
-        newSample = {};
-        var searchOpts = {};
-        var query;
-
-        if (uuid) {
-            searchOpts.uuid = uuid;
-            query = 'uuid=' + uuid;
-        } else {
-            query = 'uuid=*';
-        }
-
-        log.debug('Starting updateSample ' + query);
-
-        vmadm.lookup(searchOpts, { log: log }, function (err, vmobjs) {
-            var vmobj;
-            var running = 0;
-            var notRunning = 0;
-            var nonInventory = 0;
-
-            if (err) {
-                log.error(err, 'ERROR: unable update VM list');
-                return cb(err);
-            } else {
-                for (vmobj in vmobjs) {
-                    vmobj = vmobjs[vmobj];
-                    if (!vmobj.do_not_inventory) {
-                        newSample[vmobj.uuid] = vmobj;
-                        if (vmobj.zone_state === 'running') {
-                            running++;
-                        } else {
-                            notRunning++;
-                        }
-                    } else {
-                        nonInventory++;
-                    }
-                }
-
-                var lookupResults = {
-                    running: running,
-                    notRunning: notRunning,
-                    nonInventory: nonInventory
-                };
-                log.info(lookupResults, 'Lookup query results');
-
-                return cb(null);
-            }
-        });
-    }
-
-    function logAttempt(aLog, host) {
-        function _log(number, delay) {
-            var level;
-            if (number === 0) {
-                level = 'info';
-            } else if (number < 5) {
-                level = 'warn';
-            } else {
-                level = 'error';
-            }
-            aLog[level]({
-                ip: host,
-                attempt: number,
-                delay: delay
-            }, 'updateSample retry attempt');
-        }
-
-        return (_log);
-    }
-
-    var retry = backoff.call(lookup, function (err) {
-        retry.removeAllListeners('backoff');
-
-        var attempts = retry.getNumRetries();
-        if (err) {
-            log.error('Could not updateSample after %d attempts', attempts);
-            return callback(err);
-        }
-
-        self.lastFullSample = (new Date()).getTime() / 1000;
+    var eventWatcher = this.eventWatcher;
 
-        return callback(null, newSample);
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
+        log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
+        self.refreshVM(uuid);
     });
 
-    var retryOpts = { initialDelay: 200, maxDelay: 2000 };
-    retry.setStrategy(new backoff.ExponentialStrategy({
-        initialDelay: retryOpts.initialDelay,
-        maxDelay: retryOpts.maxDelay
-    }));
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
+        log.debug('fs.watch event on /etc/zones for %s', uuid);
+        self.refreshVM(uuid);
+    });
 
-    retry.failAfter(5);
-    retry.on('backoff', logAttempt(log));
-    retry.start();
-}
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
+        self.removeVM(uuid);
+    });
 
+    eventWatcher.on('err', function zone_err_event(err) {
+        log.error(err, 'eventWatcher saw an error');
+    });
+};
 
 module.exports = NetAgent;
diff --git a/lib/net-fsm.js b/lib/net-fsm.js
new file mode 100644
index 0000000..c896ff7
--- /dev/null
+++ b/lib/net-fsm.js
@@ -0,0 +1,145 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_common = require('./common');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+
+// --- Globals
+
+var DIFF_FIELDS = [
+    'gateway',
+    'mtu',
+    'netmask',
+    'nic_tag',
+    'resolvers',
+    'routes',
+    'vlan_id'
+];
+
+/*
+ * EventEmitters emit a warning to stderr when many listeners are added to
+ * an event. Since the default is to warn after 10, and every NIC on a network
+ * will be listening, we bump the limit here to make it less likely to warn.
+ */
+var MAX_NIC_LISTENERS = 512;
+
+
+// --- Exports
+
+/**
+ * The NetFSM is responsible for tracking changes related to a single network.
+ */
+function NetworkFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+    assert.object(opts.app, 'opts.app');
+
+    this.uuid = opts.uuid;
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'network',
+        network_uuid: this.uuid
+    }, true);
+
+    this.old = null;
+    this.cur = null;
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(NetworkFSM, mod_mooremachine.FSM);
+
+NetworkFSM.prototype.state_init = function (S) {
+    this.setMaxListeners(MAX_NIC_LISTENERS);
+
+    S.immediate(function () {
+        S.gotoState('refresh');
+    });
+};
+
+NetworkFSM.prototype.state_waiting = function (S) {
+    S.validTransitions([ 'refresh' ]);
+
+    if (!mod_jsprim.deepEqual(this.old, this.cur)) {
+        this.emit('updated', this.cur);
+    }
+
+    /*
+     * Refresh periodically.
+     */
+    S.timeout(60 * 60 * 1000, function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+};
+
+NetworkFSM.prototype.state_refresh = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'refresh',
+        'waiting'
+    ]);
+
+    self.old = self.cur;
+
+    function afterGet(err, net) {
+        if (err) {
+            if (err.statusCode === 404) {
+                self.log.error(err, 'Network disappeared from NAPI; stopping');
+                S.gotoState('stopped');
+                return;
+            }
+
+            S.gotoState('refresh');
+            return;
+        }
+
+        self.cur = net;
+
+        if (mod_common.hasChanged(DIFF_FIELDS, self.cur, self.old)) {
+            self.emit('changed');
+        }
+
+        S.gotoState('waiting');
+    }
+
+    S.on(self, 'stopAsserted', function () {
+        S.gotoState('stopped');
+    });
+
+    self.log.info('Refreshing network information');
+    self.app.napi.getNetwork(self.uuid, S.callback(afterGet));
+};
+
+NetworkFSM.prototype.state_stopped = function (S) {
+    S.validTransitions([ 'refresh' ]);
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+};
+
+NetworkFSM.prototype.refresh = function () {
+    this.emit('refreshAsserted');
+};
+
+NetworkFSM.prototype.stop = function () {
+    this.emit('stopAsserted');
+};
+
+module.exports = NetworkFSM;
diff --git a/lib/nic-fsm.js b/lib/nic-fsm.js
new file mode 100644
index 0000000..611c9da
--- /dev/null
+++ b/lib/nic-fsm.js
@@ -0,0 +1,678 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_common = require('./common');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+
+// --- Globals
+
+var ANTI_SPOOF_FIELDS = [
+    'allow_dhcp_spoofing',
+    'allow_ip_spoofing',
+    'allow_mac_spoofing',
+    'allow_restricted_traffic',
+    'allow_unfiltered_promisc'
+];
+
+var LOCAL_FIELDS = [
+    'belongs_to_type',
+    'cn_uuid',
+    'owner_uuid',
+    'primary',
+    'state'
+];
+
+var REMOTE_FIELDS = [
+    'allow_dhcp_spoofing',
+    'allow_ip_spoofing',
+    'allow_mac_spoofing',
+    'allow_restricted_traffic',
+    'allow_unfiltered_promisc',
+    'gateway',
+    'ip',
+    'model',
+    'mtu',
+    'netmask',
+    'network_uuid',
+    'nic_tag',
+    'vlan_id'
+];
+
+var VM_FIELDS = [
+    'resolvers',
+    'routes'
+];
+
+
+// --- Internal helpers
+
+function boolFromVal(value) {
+    if (value === 'false' || value === '0') {
+        return false;
+    } else if (value === undefined || value === null) {
+        return false;
+    } else if (value === 'true' || value === '1') {
+        return true;
+    } else {
+        // else should be boolean
+        return value;
+    }
+}
+
+function getDifferences(fields, cur, old) {
+    var update = {};
+
+    fields.forEach(function (field) {
+        if (ANTI_SPOOF_FIELDS.indexOf(field) !== -1) {
+            if (boolFromVal(cur[field]) !== boolFromVal(old[field])) {
+                update[field] = boolFromVal(cur[field]);
+            }
+            return;
+        }
+
+        if (cur[field] !== old[field]) {
+            update[field] = cur[field];
+        }
+    });
+
+    /*
+     * We only ever update "primary" to true. Updating it to "false" isn't
+     * necessary since setting a new primary NIC removes the flag from the
+     * old one.
+     */
+    if (update.primary !== true) {
+        delete update.primary;
+    }
+
+    return update;
+}
+
+
+// --- Exports
+
+/**
+ * The NicFSM is responsible for tracking changes related to a single NIC,
+ * located either on a VM or the CN's global zone.
+ *
+ * The state machine looks like the following (note that retries aren't
+ * depicted here, but are loops back into the same state usually).
+ *
+ *                       +---------+
+ *                       | create  | -------------------------+
+ *                       +---------+                          |
+ *                 404 on 1st ^                               |
+ *                    refresh |    setLocal()                 |
+ *       +------+        +---------+ -----> +--------+        |
+ *       | init | -----> | refresh |        | update |        |
+ *       +------+        +---------+   +--- +--------+        |
+ *                        |   ^        |         |            |
+ *           NAPI 404 for |   |        |         |            |
+ *           existing NIC |   |        |         |            |
+ *       +---------+      |   |        |         |            |
+ *       | remove  | <----+   |        |         |            |
+ *       +---------+          |        |         |            |
+ *            |               |        |         |            |
+ *            v               |        |         v            |
+ *       +---------+     +---------+   |    +--------------+  |
+ *       | stopped |     | waiting | <-+--- | update.local | -+
+ *       +---------+     +---------+   |    +--------------+  |
+ *            ^                        |                      |
+ *            |          +---------+   +--- +--------------+  |
+ *            +--------- | release |        | update.napi  | -+
+ *            |          +---------+        +--------------+  |
+ *            |               ^                  |            |
+ *            |               |     NAPI 404     |            |
+ *            +-------------- | -----------------+            |
+ *                            |        releaseFrom()          |
+ *                            +-------------------------------+
+ */
+function NicFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.string(opts.mac, 'opts.mac');
+    assert.object(opts.app, 'opts.app');
+
+    this.mac = opts.mac;
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'nic',
+        mac: this.mac
+    }, true);
+
+    this.pending = {
+        refresh: false,
+        update: false
+    };
+    this.released = null;
+
+    this.local = null;
+    this.remote = null;
+
+    /*
+     * We track the "Etag" header so that we can be careful
+     * about our DELETEs.
+     */
+    this.etag = undefined;
+
+    this.network = null;
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(NicFSM, mod_mooremachine.FSM);
+
+NicFSM.prototype.state_init = function (S) {
+    S.immediate(function () {
+        S.gotoState('refresh');
+    });
+};
+
+/**
+ * Wait for external events to force us to recompare.
+ */
+NicFSM.prototype.state_waiting = function (S) {
+    S.on(this, 'setAsserted', function () {
+        S.gotoState('update');
+    });
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    /*
+     * Refresh periodically.
+     */
+    S.timeout(60 * 60 * 1000, function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(this, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+
+    if (this.network !== null) {
+        S.on(this.network, 'changed', function () {
+            S.gotoState('refresh');
+        });
+    }
+};
+
+NicFSM.prototype.state_refresh = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'create',
+        'refresh',
+        'remove',
+        'update'
+    ]);
+
+    S.on(self, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    S.on(self, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+
+    function afterGet(err, nic, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                if (self.remote === null) {
+                    S.gotoState('create');
+                } else {
+                    S.gotoState('remove');
+                }
+                return;
+            }
+
+            self.log.warn(err,
+                'Failed to refresh NIC information; ' +
+                'retrying in 5 seconds');
+            S.timeout(5000, function () {
+                S.gotoState('refresh');
+            });
+            return;
+        }
+
+        self.setRemote(nic, res.headers['etag']);
+
+        self.log.info('Refreshed NIC information');
+
+        S.gotoState('update');
+    }
+
+    self.log.info('Refreshing NIC information');
+
+    self.app.napi.getNic(self.mac, S.callback(afterGet));
+};
+
+NicFSM.prototype.state_create = function (S) {
+    var self = this;
+    var deleted = false;
+
+    S.validTransitions([
+        'refresh',
+        'release',
+        'waiting'
+    ]);
+
+    if (self.local === null) {
+        S.gotoState('waiting');
+        return;
+    }
+
+    S.on(this, 'releaseAsserted', function () {
+        /*
+         * We wait to move to the "release" state to ensure that our
+         * POST always comes entirely before the DELETE.
+         */
+        deleted = true;
+    });
+
+    function afterCreate(err, nic, _, res) {
+        if (deleted) {
+            S.gotoState('release');
+            return;
+        }
+
+        if (err) {
+            self.log.warn(err,
+                'Failed to create NIC in NAPI; ' +
+                'scheduling state refresh');
+            S.timeout(5000, function () {
+                S.gotoState('refresh');
+            });
+            return;
+        }
+
+        self.setRemote(nic, res.headers['etag']);
+
+        S.gotoState('waiting');
+    }
+
+    self.log.info({ nic: self.local }, 'Syncing local NIC to NAPI');
+
+    self.app.napi.createNic(self.mac, self.local, S.callback(afterCreate));
+};
+
+NicFSM.prototype.state_update = function (S) {
+    S.validTransitions([
+        'refresh',
+        'remove',
+        'update.local',
+        'waiting'
+    ]);
+
+    /*
+     * We haven't seen a local NIC yet. Go to state "waiting" until
+     * we're assigned one.
+     */
+    if (this.local === null) {
+        this.log.debug('No local NIC information yet');
+        S.gotoState('waiting');
+        return;
+    }
+
+    /*
+     * If the belongs_to_uuid has changed, then we need to move the NIC.
+     */
+    if (this.local.belongs_to_uuid !== this.remote.belongs_to_uuid) {
+        S.gotoState('remove');
+        return;
+    }
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+
+    S.gotoState('update.local');
+};
+
+NicFSM.prototype.state_update.local = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'release',
+        'update.local',
+        'update.napi',
+        'waiting'
+    ]);
+
+    var locupdate = getDifferences(REMOTE_FIELDS, self.remote, self.local);
+    var needUpdate = !mod_jsprim.isEmpty(locupdate);
+    var needRefresh = mod_common.hasChanged(VM_FIELDS, self.remote, self.local);
+    if (!needUpdate && !needRefresh) {
+        self.log.trace('No local changes needed');
+        S.gotoState('update.napi');
+        return;
+    }
+
+    S.on(this, 'releaseAsserted', function () {
+        S.gotoState('release');
+    });
+
+    function afterUpdate(err) {
+        if (err) {
+            self.log.error(err, 'Failed to update NIC on %s %s',
+                self.local.belongs_to_type, self.local.belongs_to_uuid);
+            S.gotoState('update.local');
+            return;
+        }
+
+        S.gotoState('update.napi');
+    }
+
+    locupdate.mac = self.mac;
+
+    var owner;
+    switch (self.local.belongs_to_type) {
+    case 'zone':
+        if (!mod_jsprim.hasKey(self.app.insts, self.local.belongs_to_uuid)) {
+            self.log.warn('Cannot update NIC %s for nonexistent VM %s',
+                self.local.belongs_to_uuid);
+            S.gotoState('waiting');
+            return;
+        }
+
+        owner = self.app.insts[self.local.belongs_to_uuid];
+        break;
+    case 'server':
+        if (self.local.belongs_to_uuid !== self.app.cn_uuid) {
+            self.log.warn('Server NIC is for CN %s, not the local CN (%s)',
+                self.local.belongs_to_uuid, self.app.cn_uuid);
+            S.gotoState('waiting');
+            return;
+        }
+
+        owner = self.app.server;
+        break;
+    case 'other':
+        self.log.warn('Ignoring NIC with belongs_to_type=other');
+        S.gotoState('waiting');
+        return;
+    default:
+        self.log.warn('Ignoring unknown "belongs_to_type" value: %j',
+            self.local.belongs_to_type);
+        S.gotoState('waiting');
+        return;
+    }
+
+    if (needUpdate) {
+        owner.updateNIC(self.mac, locupdate, S.callback(afterUpdate));
+    } else {
+        owner.refresh();
+        S.gotoState('update.napi');
+    }
+};
+
+NicFSM.prototype.state_update.napi = function (S) {
+    var self = this;
+    var updated = false;
+
+    S.validTransitions([
+        'release',
+        'update',
+        'update.napi',
+        'stopped',
+        'waiting'
+    ]);
+
+    var remupdate = getDifferences(LOCAL_FIELDS, self.local, self.remote);
+    if (mod_jsprim.isEmpty(remupdate)) {
+        self.log.trace('No remote changes needed');
+        S.gotoState('waiting');
+        return;
+    }
+
+    S.on(this, 'setAsserted', function () {
+        /*
+         * We wait to move to the "update" state again to ensure that our
+         * PUTs are always correctly ordered.
+         */
+        updated = true;
+    });
+
+    S.on(this, 'releaseAsserted', function () {
+        /*
+         * It's okay for our DELETE to race with the PUT:
+         *
+         * - If the PUT wins, the DELETE will fail due to the "If-Match" header,
+         *   and will retry after refreshing.
+         * - If the DELETE wins, the PUT will fail, and we ignore the response.
+         */
+        S.gotoState('release');
+    });
+
+    function afterPut(err, nic, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                self.log.warn('NIC no longer in NAPI, stopping');
+                S.gotoState('stopped');
+                return;
+            }
+
+            self.log.error(err, 'Failed to update NIC in NAPI');
+            S.gotoState('update.napi');
+            return;
+        }
+
+        self.setRemote(nic, res.headers['etag']);
+
+        if (updated) {
+            S.gotoState('update');
+        } else {
+            S.gotoState('waiting');
+        }
+    }
+
+    remupdate.check_owner = false;
+
+    self.log.info({ payload: remupdate }, 'Updating NIC in NAPI');
+
+    self.app.napi.updateNic(self.mac, remupdate, S.callback(afterPut));
+};
+
+NicFSM.prototype.state_remove = function (S) {
+    var self = this;
+
+    S.validTransitions([
+        'remove',
+        'stopped'
+    ]);
+
+    if (!mod_jsprim.hasKey(self.app.insts, self.local.belongs_to_uuid)) {
+        S.gotoState('stopped');
+        return;
+    }
+
+    function afterRemove(err) {
+        if (err) {
+            self.log.error(err, 'Failed to update NIC on VM %s',
+                self.local.belongs_to_uuid);
+            S.timeout(5000, function () {
+                S.gotoState('remove');
+            });
+            return;
+        }
+
+        S.gotoState('stopped');
+    }
+
+    self.app.insts[self.local.belongs_to_uuid].removeNIC(
+        self.mac, S.callback(afterRemove));
+};
+
+NicFSM.prototype.state_release = function (S) {
+    S.validTransitions([
+        'release.delete',
+        'release.refresh',
+        'stopped'
+    ]);
+
+    S.gotoState('release.delete');
+};
+
+NicFSM.prototype.state_release.delete = function (S) {
+    var self = this;
+
+    if (self.remote === null) {
+        S.gotoState('release.refresh');
+        return;
+    }
+
+    if (self.released !== self.remote.belongs_to_uuid) {
+        self.log.info('Skipping NIC deletion, ' +
+            'since upstream belongs_to_uuid has changed');
+        S.gotoState('stopped');
+        return;
+    }
+
+    if (self.remote.state !== 'running' && self.remote.state !== 'stopped') {
+        self.log.info('Skipping NIC deletion, ' +
+            'since upstream state isn\'t running or stopped');
+        S.gotoState('stopped');
+        return;
+    }
+
+    if (typeof (self.etag) !== 'string') {
+        self.log.warn('No "Etag" set, skipping deletion');
+        S.gotoState('stopped');
+        return;
+    }
+
+    function afterDelete(err) {
+        if (err) {
+            if (err.statusCode === 404) {
+                self.log.info('NIC already deleted from NAPI');
+                S.gotoState('stopped');
+                return;
+            }
+
+            if (err.statusCode === 412) {
+                self.log.info('NIC "Etag" changed in NAPI, refreshing');
+                S.gotoState('release.refresh');
+                return;
+            }
+
+            S.timeout(5000, function () {
+                S.gotoState('release.delete');
+            });
+            return;
+        }
+
+        S.gotoState('stopped');
+    }
+
+    self.app.napi.deleteNic(self.mac, {}, {
+        headers: {
+            'If-Match': self.etag
+        }
+    }, S.callback(afterDelete));
+};
+
+NicFSM.prototype.state_release.refresh = function (S) {
+    var self = this;
+
+    function afterGet(err, nic, _, res) {
+        if (err) {
+            if (err.statusCode === 404) {
+                S.gotoState('stopped');
+                return;
+            }
+
+            self.log.warn(err,
+                'Failed to refresh NIC information for release; ' +
+                'retrying in 5 seconds');
+            S.timeout(5000, function () {
+                S.gotoState('release.refresh');
+            });
+            return;
+        }
+
+        self.setRemote(nic, res.headers['etag']);
+
+        self.log.info('Refreshed NIC release information');
+
+        S.gotoState('release.delete');
+    }
+
+    self.log.info('Refreshing NIC release information');
+
+    self.app.napi.getNic(self.mac, S.callback(afterGet));
+};
+
+NicFSM.prototype.state_stopped = function (S) {
+    S.validTransitions([ ]);
+
+    this.local = null;
+    this.remote = null;
+    this.etag = undefined;
+};
+
+NicFSM.prototype.setLocal = function (nic) {
+    assert.object(nic, 'nic');
+    var self = this;
+
+    self.local = nic;
+
+    if (self.pending.update) {
+        return;
+    }
+
+    self.pending.update = true;
+    setImmediate(function () {
+        self.pending.update = false;
+        self.emit('setAsserted');
+    });
+};
+
+/**
+ * Update our copy of the NIC in NAPI (as well as it's etag if the
+ * NAPI instance is new enough to report it).
+ */
+NicFSM.prototype.setRemote = function (nic, etag) {
+    assert.object(nic, 'nic');
+    assert.optionalString(etag, 'etag');
+    this.remote = nic;
+    this.etag = etag;
+    this.network = mod_jsprim.hasKey(nic, 'network_uuid')
+        ? this.app.watchNet(nic.network_uuid)
+        : null;
+};
+
+NicFSM.prototype.refresh = function (etag) {
+    var self = this;
+
+    if (etag && etag === self.etag) {
+        return;
+    }
+
+    if (self.pending.refresh) {
+        return;
+    }
+
+    self.pending.refresh = true;
+    setImmediate(function () {
+        self.pending.refresh = false;
+        self.emit('refreshAsserted');
+    });
+};
+
+NicFSM.prototype.releaseFrom = function (belongs_to_uuid) {
+    assert.string(belongs_to_uuid, 'belongs_to_uuid');
+    this.released = belongs_to_uuid;
+    this.emit('releaseAsserted', belongs_to_uuid);
+};
+
+module.exports = NicFSM;
diff --git a/lib/server-fsm.js b/lib/server-fsm.js
new file mode 100644
index 0000000..aa9e4c0
--- /dev/null
+++ b/lib/server-fsm.js
@@ -0,0 +1,293 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018 Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_common = require('./common');
+var mod_forkexec = require('forkexec');
+var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
+var mod_util = require('util');
+
+// --- Globals
+
+var VNIC_NAME_RE = /^([a-zA-Z0-9_]{0,31})[0-9]+$/;
+var ADMIN_TAG_RE = /^admin(_[a-zA-Z0-9_]+)?$/;
+
+// --- Internal helpers
+
+function isAdminLike(tag) {
+    return ADMIN_TAG_RE.test(tag);
+}
+
+// --- Exports
+
+function ServerFSM(opts) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+    assert.object(opts.app, 'opts.app');
+
+    this.uuid = opts.uuid;
+    this.app = opts.app;
+    this.log = opts.app.log.child({
+        component: 'server',
+        cn_uuid: this.uuid
+    }, true);
+
+    this.nics = {};
+    this.nictags = {};
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(ServerFSM, mod_mooremachine.FSM);
+
+ServerFSM.prototype.state_init = function (S) {
+    S.validTransitions([ 'refresh' ]);
+
+    S.gotoState('refresh');
+};
+
+ServerFSM.prototype.state_waiting = function (S) {
+    S.validTransitions([ 'refresh' ]);
+
+    S.on(this, 'refreshAsserted', function () {
+        S.gotoState('refresh');
+    });
+};
+
+ServerFSM.prototype.state_refresh = function (S) {
+    var self = this;
+
+    S.validTransitions([ 'refresh', 'waiting' ]);
+
+    function retry(err) {
+        self.log.error(err, 'failed to fetch new sysinfo');
+        S.timeout(5000, function () {
+            S.gotoState('refresh');
+        });
+    }
+
+    mod_forkexec.forkExecWait({
+        argv: [ '/usr/bin/sysinfo' ],
+        includeStderr: true,
+        timeout: 0
+    }, function (err, info) {
+        if (err) {
+            retry(err);
+            return;
+        }
+
+        var sysinfo;
+
+        try {
+            sysinfo = JSON.parse(info.stdout.trim());
+        } catch (e) {
+            retry(e);
+            return;
+        }
+
+        self._update(sysinfo);
+
+        S.gotoState('waiting');
+    });
+};
+
+ServerFSM.prototype._update = function (sysinfo) {
+    var self = this;
+    var prev = self.nics;
+
+    self.nics = {};
+    self.nictags = {};
+
+    var pnics = sysinfo['Network Interfaces'];
+    var vnics = sysinfo['Virtual Network Interfaces'];
+    var aggrs = sysinfo['Link Aggregations'];
+
+    function watchNic(mac, nic) {
+        var nfsm;
+
+        if (mod_jsprim.hasKey(prev, mac)) {
+            nfsm = prev[mac];
+            delete prev[mac];
+        } else {
+            self.log.info('NIC %s added to CN %s', mac, self.uuid);
+            nfsm = self.app.watchNic(mac);
+        }
+
+        nfsm.setLocal(nic);
+
+        self.nics[mac] = nfsm;
+    }
+
+    mod_jsprim.forEachKey(pnics, function (name, pnic) {
+        if (mod_jsprim.hasKey(aggrs, name)) {
+            return;
+        }
+
+        var mac = pnic['MAC Address'];
+
+        pnic['NIC Names'].forEach(function (tag) {
+            self.nictags[tag] = name;
+        });
+
+        watchNic(mac, self._fmtpnic(pnic));
+    });
+
+    mod_jsprim.forEachKey(vnics, function (name, vnic) {
+        var mac = vnic['MAC Address'];
+
+        watchNic(mac, self._fmtvnic(name, vnic));
+    });
+
+    mod_jsprim.forEachKey(aggrs, function (name, aggr) {
+        var afsm = self.app.watchAggr(name);
+
+        afsm.setLocal(self._fmtaggr(name, aggr, pnics));
+
+        self.aggrs[name] = afsm;
+    });
+
+    mod_jsprim.forEachKey(prev, function (mac, nfsm) {
+        self.log.info('NIC %s removed from CN %s', mac, self.uuid);
+
+        nfsm.releaseFrom(self.uuid);
+    });
+};
+
+ServerFSM.prototype._fmtstate = function (state) {
+    return (state === 'up' ? 'running' : 'stopped');
+};
+
+ServerFSM.prototype._fmtpnic = function (nic) {
+    var o = {
+        belongs_to_uuid: this.uuid,
+        belongs_to_type: 'server',
+        owner_uuid: this.app.admin_uuid,
+        state: this._fmtstate(nic['Link Status']),
+        nic_tags_provided: nic['NIC Names']
+    };
+
+    if (nic.ip4addr) {
+        o.ip = nic.ip4addr;
+    }
+
+    /* If this smells like an admin NIC, try to set "nic_tag" */
+    var atags = nic['NIC Names'].filter(isAdminLike);
+    if (atags.length > 0) {
+        if (atags.length > 1) {
+            this.log.warn({
+                nic: nic, matching: atags
+            }, 'multiple candidate tags found for admin-like interface');
+        }
+
+        o.nic_tag = atags[0];
+        o.vlan_id = 0;
+    }
+
+    return o;
+};
+
+ServerFSM.prototype._findtag = function (name, host) {
+    var m = VNIC_NAME_RE.exec(name);
+    if (m !== null) {
+        return undefined;
+    }
+
+    if (this.nictags[m[1]] !== host) {
+        /*
+         * Under normal Triton operation this shouldn't happen, but if an
+         * operator is modifying state in the GZ themselves with dladm(1M)
+         * we could arrive here.
+         */
+        return undefined;
+    }
+
+    return m[1];
+};
+
+ServerFSM.prototype._fmtvnic = function (name, nic) {
+    var o = {
+        belongs_to_uuid: this.uuid,
+        belongs_to_type: 'server',
+        owner_uuid: this.app.admin_uuid,
+        state: this._fmtstate(nic['Link Status'])
+    };
+
+    if (nic.ip4addr) {
+        o.ip = nic.ip4addr;
+    }
+
+    if (mod_jsprim.hasKey(nic, 'VLAN')) {
+        o.vlan_id = nic['VLAN'];
+    } else {
+        o.vlan_id = 0;
+    }
+
+    /* Extract the nic_tag for VNICs */
+    o.nic_tag = this._findtag(name, nic['Host Interface']);
+
+    return o;
+};
+
+ServerFSM.prototype._fmtaggr = function (name, aggr, pnics) {
+    assert.string(name, 'name');
+    assert.object(aggr, 'aggr');
+    assert.object(pnics, 'pnics');
+
+    var nic_tags_provided = pnics[name]['NIC Names'];
+
+    var macs = aggr['Interfaces'].map(function (pname) {
+        return pnics[pname]['MAC Address'];
+    });
+
+    return {
+        id: mod_common.formatAggrId(this.app.cn_uuid, name),
+        name: name,
+        belongs_to_uuid: this.app.cn_uuid,
+        lacp_mode: aggr['LACP mode'],
+        nic_tags_provided: nic_tags_provided,
+        macs: macs
+    };
+};
+
+ServerFSM.prototype.refresh = function () {
+    this.emit('refreshAsserted');
+};
+
+ServerFSM.prototype.addNIC = function (mac, payload, callback) {
+    this.log.warn({ mac: mac, payload: payload },
+        'Server NIC adds are currently unsupported');
+
+    setImmediate(callback);
+};
+
+ServerFSM.prototype.updateNIC = function (mac, payload, callback) {
+    this.log.warn({ mac: mac, payload: payload },
+        'Server NIC updates are currently unsupported');
+
+    setImmediate(callback);
+};
+
+ServerFSM.prototype.removeNIC = function (mac, payload, callback) {
+    this.log.warn({ mac: mac, payload: payload },
+        'Server NIC removals are currently unsupported');
+
+    setImmediate(callback);
+};
+
+ServerFSM.prototype.updateAggr = function (name, payload, callback) {
+    this.log.warn({ name: name, payload: payload },
+        'Server aggregation updates are currently unsupported');
+
+    setImmediate(callback);
+};
+
+module.exports = ServerFSM;
diff --git a/lib/vm.js b/lib/vm.js
index 6b0bc48..5bc643c 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -12,44 +12,35 @@
  * Functions for interacting with vmadm
  */
 
-var cp = require('child_process');
-var execFile = cp.execFile;
-var exec = cp.exec;
-var spawn = cp.spawn;
+'use strict';
+
 var assert = require('assert');
-var util = require('util');
-var fs = require('fs');
-var path = require('path');
+var cp = require('child_process');
 var EventEmitter = require('events').EventEmitter;
-var vmadm = require('vmadm');
+var forkexec = require('forkexec');
+var fs = require('fs');
 var LineStream = require('lstream');
+var path = require('path');
+var spawn = cp.spawn;
+var util = require('util');
+var vasync = require('vasync');
 var VError = require('verror');
-var forkexec = require('forkexec');
 
-var async = require('async');
 
 
+var XML_FILE_RE =
+    /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\.xml$/;
 
 
-function isLocal(vms, vm) {
-    for (var v in vms) {
-        if (vms[v].uuid == vm.uuid) {
-            return vms[v];
-        }
-    }
-
-    return null;
-}
-
-// These are the events being watched by the zoneevent watcher. When zones
-// don't switch to these zone_states we ignore them
+/*
+ * These are the events being watched by the zoneevent watcher. When zones
+ * don't switch to these zone_states we ignore them
+ */
 var watchEvents = {
     uninitialized: true,
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 60 * 1000;
-
 /*
  * The EventWatcher will emit these events:
  *
@@ -65,8 +56,6 @@ function EventWatcher(options) {
 
     // Array of uuids that the watcher knows about
     this.vms = [];
-    // Hash of vm states used by the state watcher
-    this.vmStates = {};
 
     // Watches changes on /etc/zones
     this.lastCfgEvent = null;
@@ -82,94 +71,9 @@ util.inherits(EventWatcher, EventEmitter);
 EventWatcher.prototype.start = function () {
     this.startZoneConfigWatcher();
     this.startZoneWatcher();
-    this.startStateWatcher();
-};
-
-
-/*
- * Accepts an object with a uuid:vmobj format. The vmobj format only needs to
- * to have the state and zone_state as keys
- */
-EventWatcher.prototype.updateState = function (objs) {
-    var self = this;
-
-    Object.keys(objs).forEach(function foreachobjs(uuid) {
-        self.vmStates[uuid] = {
-            state: objs[uuid].state,
-            zone_state: objs[uuid].zone_state
-        };
-    });
 };
 
 
-EventWatcher.prototype.getState = function (uuid) {
-    return this.vmStates[uuid];
-};
-
-
-EventWatcher.prototype.removeState = function (uuid) {
-    delete this.vmStates[uuid];
-};
-
-
-/*
- * State watcher will fix incorrect states due to improper behavior of our
- * other two watchers. All these watchers are not reliable for many reasons
- * and this entire code base will be replaced with vminfod in the near future.
- * By having a state watcher that fix states every X seconds we can guarantee
- * that VMs have an incorrect state for at most X seconds.
- */
-EventWatcher.prototype.startStateWatcher = function () {
-    var self = this;
-    var log = this.log;
-
-    function onLookup(err, vmobjs) {
-        if (err) {
-            log.error(err, 'Unable to run stateWatcher lookup');
-            setTimeout(lookup, STATE_WATCHER_TIMEOUT);
-            return;
-        }
-
-        vmobjs.forEach(function (vm) {
-
-            // Don't emit when states stay the same
-            var current = self.getState(vm.uuid);
-            if (current && current.state === vm.state &&
-                current.zone_state === vm.zone_state) {
-                return;
-            }
-
-            self.emit('state', vm.uuid, vm.state, vm.zone_state);
-
-            var newState = {};
-            newState[vm.uuid] = {
-                state: vm.state,
-                zone_state: vm.zone_state
-            };
-            self.updateState(newState);
-        });
-
-        setTimeout(lookup, STATE_WATCHER_TIMEOUT);
-    }
-
-    /*
-     * We get a list of all VMs that don't have the do_not_inventory flag set.
-     * This flag is used by tests and ops to get some things done. For example
-     * it is used by the migrator script to signal to SDC that events for the
-     * target VM should be ignored.
-     */
-    var lookup = vmadm.lookup.bind(null, {}, {
-        fields: [
-            'uuid',
-            'state',
-            'zone_state'],
-         log: log,
-         include_dni: false
-    }, onLookup);
-
-    lookup();
-};
-
 EventWatcher.prototype.startZoneWatcher = function () {
     /*
      * sendFullSample is called in an infinite retry loop. We don't want to
@@ -222,7 +126,7 @@ EventWatcher.prototype.startZoneWatcher = function () {
     });
     watcher.on('exit', function (code) {
         if (stdout_ended) {
-            log.warn('zoneevent watcher exited.');
+            log.warn({ code: code }, 'zoneevent watcher exited.');
             watcher = null;
             self.zoneeventWatcher = null;
         } else {
@@ -237,10 +141,12 @@ EventWatcher.prototype.startZoneConfigWatcher = function () {
     var self = this;
 
     this.cfgWatcher = fs.watch('/etc/zones', function (evt, file) {
-        // When we get here something changed in /etc/zones and if that happens
-        // it means that something has changed about one of the zones and in
-        // turn it means that we need to recheck.
-        log.trace('fs.watch event on /etc/zones');
+        /*
+         * When we get here something changed in /etc/zones and if that happens
+         * it means that something has changed about one of the zones and in
+         * turn it means that we need to recheck.
+         */
+        log.trace({ evt: evt, file: file }, 'fs.watch event on /etc/zones');
 
         self.checkZoneConfigChanges();
     });
@@ -251,10 +157,8 @@ EventWatcher.prototype.startZoneConfigWatcher = function () {
 
 EventWatcher.prototype.checkZoneConfigChanges = function () {
     var log = this.log;
-    var self  = this;
+    var self = this;
 
-    /*JSSTYLED*/
-    var XML_FILE_RE = /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\.xml$/;
     var changed = [];
     var newVms = [];
 
@@ -267,7 +171,10 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
             return;
         }
 
-        async.forEachSeries(files, eachFile, asyncCallback);
+        vasync.forEachPipeline({
+            inputs: files,
+            func: eachFile
+        }, asyncCallback);
     }
 
     function eachFile(file, next) {
@@ -288,8 +195,10 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
                 return next(statErr);
             }
 
-            // Only push to newVms array when fs.stat confirms that the file is
-            // there. This avoids a race condition on destroy/reprovision
+            /*
+             * Only push to newVms array when fs.stat confirms that the file is
+             * there. This avoids a race condition on destroy/reprovision.
+             */
             newVms.push(uuid);
 
             var mtime = stats.mtime.getTime() / 1000;
@@ -307,9 +216,11 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
             return;
         }
 
-        // Check if any of the existing VMs is no longer in the server. In
-        // this case we just send the full sample so VMAPI can check which
-        // VMs have been destroyed
+        /*
+         * Check if any of the existing VMs is no longer in the server. In
+         * this case we just send the full sample so VMAPI can check which
+         * VMs have been destroyed.
+         */
         var destroyed = [];
         for (var i = 0; i < self.vms.length; i++) {
             if (newVms.indexOf(self.vms[i]) === -1) {
@@ -336,8 +247,10 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
             self.emit('zone_xml', uuid);
         });
 
-        // Update this timestamp so next time we check if files have changed
-        // since the last time
+        /*
+         * Update this timestamp so next time we check if files have changed
+         * since the last time.
+         */
         self.lastCfgEvent = (new Date()).getTime() / 1000;
     }
 };
@@ -382,6 +295,5 @@ function createEventWatcher(options) {
 
 
 module.exports = {
-    isLocal: isLocal,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index 033c298..0d5c8b3 100644
--- a/package.json
+++ b/package.json
@@ -1,27 +1,33 @@
 {
     "name": "net-agent",
-    "description": "SmartDataCenter Network Agent",
-    "version": "1.4.0",
+    "description": "Triton Network Agent",
+    "version": "2.0.0",
     "author": "Joyent (joyent.com)",
     "private": true,
     "dependencies": {
-        "async": "0.1.18",
-        "vasync": "^1.6.4",
         "assert-plus": "^1.0.0",
-        "backoff": "2.5.0",
-        "bunyan": "1.3.2",
-        "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#aefc119",
-        "restify": "2.7.0",
-        "sdc-clients": "^9.5.0",
-        "vmadm": "1.0.0",
+        "bunyan": "1.8.12",
+        "cueball": "2.5.1",
+        "forkexec": "1.1.0",
+        "jsprim": "1.4.1",
+        "kang": "1.2.0",
         "lstream": "0.0.4",
+        "mooremachine": "2.2.0",
+        "restify": "4.3.0",
+        "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#aefc119",
+        "sdc-clients": "^10.5.0",
+        "uuid": "3.2.1",
+        "vasync": "^1.6.4",
         "verror": "^1.6.1",
-        "jsprim": "^1.3.0",
-        "forkexec": "^1.1.0"
+        "vmadm": "1.0.0"
     },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
     },
+    "devDependencies": {
+        "eslint": "^4.13.1",
+        "eslint-plugin-joyent": "~2.0.0"
+    },
     "scripts": {
         "postinstall": "npm/postinstall.sh",
         "postuninstall": "npm/postuninstall.sh"
diff --git a/sapi_manifests/net-agent/template b/sapi_manifests/net-agent/template
index b51034d..9fd1992 100644
--- a/sapi_manifests/net-agent/template
+++ b/sapi_manifests/net-agent/template
@@ -1,4 +1,25 @@
 {
 	"napi": { "url": "http://{{{NAPI_SERVICE}}}" },
-	"no_rabbit": {{#no_rabbit}}true{{/no_rabbit}}{{^no_rabbit}}false{{/no_rabbit}}
-}
\ No newline at end of file
+	"no_rabbit": {{#no_rabbit}}true{{/no_rabbit}}{{^no_rabbit}}false{{/no_rabbit}},
+	"agent_uuid": "{{{auto.INSTANCE_UUID}}}",
+	"cn_uuid": "{{{auto.SERVER_UUID}}}",
+	"bindip": "{{{auto.ADMIN_IP}}}",
+	"admin_uuid": "{{{ufds_admin_uuid}}}",
+	"cueballAgent": {
+		"resolvers": [ "{{{BINDER_SERVICE}}}" ],
+		"initialDomains": [
+			"{{{NAPI_SERVICE}}}"
+		],
+		"spares": 3,
+		"maximum": 10,
+		"recovery": {
+			"default": {
+				"timeout": 2000,
+				"maxTimeout": 8000,
+				"retries": 3,
+				"delay": 0,
+				"maxDelay": 1000
+			}
+		}
+	}
+}
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 0b8ae95..6845b5e 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -60,7 +60,7 @@
 -useless_quotes               # the quotation marks are unnecessary
 +useless_void                 # use of the void type may be unnecessary (void is always undefined)
 +var_hides_arg                # variable {name} hides argument
-+want_assign_or_call          # expected an assignment or function call
+-want_assign_or_call          # expected an assignment or function call
 +with_statement               # with statement hides undeclared variables; use temporary variable instead
 
 
@@ -118,6 +118,7 @@
 +define module
 +define process
 +define require
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
diff --git a/tools/mk/Makefile.defs b/tools/mk/Makefile.defs
index 85139d7..73dd612 100644
--- a/tools/mk/Makefile.defs
+++ b/tools/mk/Makefile.defs
@@ -1,4 +1,3 @@
-# -*- mode: makefile -*-
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -6,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -28,6 +27,14 @@
 #			the TIMESTAMP envvar (used by MG-based builds).
 #	STAMP		A build stamp to use in built package names.
 #
+#	MAKE_STAMPS_DIR	The directory in which make stamp files are to be
+#			created.  See comments below on expensive targets.
+#
+#	CACHE_DIR	A directory tree in which temporary files may be
+#			collected by download, tarball extraction, etc.  This
+#			directory is completely removed by "make distclean".
+#			Files in this directory are not intended to be shipped.
+#
 
 TOP := $(shell pwd)
 
@@ -49,3 +56,50 @@ STAMP := $(BRANCH)-$(TIMESTAMP)-$(_GITDESCRIBE)
 
 # node-gyp will print build info useful for debugging with V=1
 export V=1
+
+CACHE_DIR ?=		cache
+DISTCLEAN_FILES +=	$(CACHE_DIR)
+
+#
+# EXPENSIVE TARGETS AND MAKE STAMP FILES
+#
+# Targets which are expensive to run and lack a single file that marks
+# completion are difficult to track with make; e.g., "npm install".  One
+# solution to this problem is to create "stamp" files with symbolic names which
+# are created as the final step in a complex make rule in order to mark
+# completion.
+#
+# In order to make these more uniform, and easier to target with "make clean",
+# we will attempt to store them under a single directory.  Note that these
+# files are never targets for shipping in build artefacts.
+#
+# Stamp-backed targets come in several parts.  First, a macro should be defined
+# which names a file in the MAKE_STAMPS_DIR directory.  Then, a target which
+# creates this stamp file must be provided.  The recipe for this target should
+# use MAKE_STAMP_REMOVE and MAKE_STAMP_CREATE to perform the appropriate stamp
+# management.
+#
+# For example:
+#
+# --- Makefile.*.defs:
+#
+#	$(STAMP_EXPENSIVE_RESULT) := $(MAKE_STAMPS_DIR)/expensive-result
+#
+# --- Makefile.*.targ:
+#
+#	$(STAMP_EXPENSIVE_RESULT): input/file another/input/file
+#		$(MAKE_STAMP_REMOVE)
+#		rm -rf output_tree/  # <--- ensure a clean slate
+#		expensive_program -o output_tree/ $^
+#		$(MAKE_STAMP_CREATE)
+#
+# NOTE: Every stamp file is exposed as an implicit "stamp-$STAMP_NAME" target.
+# The example above could be built manually by invoking:
+#
+#	make stamp-expensive-result
+#
+MAKE_STAMPS_DIR ?=	make_stamps
+CLEAN_FILES +=		$(MAKE_STAMPS_DIR)
+
+MAKE_STAMP_REMOVE =	mkdir -p $(@D); rm -f $(@)
+MAKE_STAMP_CREATE =	mkdir -p $(@D); touch $(@)
diff --git a/tools/mk/Makefile.deps b/tools/mk/Makefile.deps
index 2d92ec3..91f8346 100644
--- a/tools/mk/Makefile.deps
+++ b/tools/mk/Makefile.deps
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -44,9 +44,44 @@ JSSTYLE		?= $(JSSTYLE_EXEC)
 
 $(JSSTYLE_EXEC): | deps/jsstyle/.git
 
+#
+# eslint
+#
+ESLINT_EXEC	?= node_modules/.bin/eslint
+ifdef NODE
+    ESLINT	:= $(NODE) $(ESLINT_EXEC)
+else
+    ESLINT	?= $(ESLINT_EXEC)
+endif
+
+# Install eslint.
+#
+# The install of specific modules is to allow running "make check"
+# without having to do a complete install of all npm dependencies.
+#
+# NPM_EXEC will be defined if either of "Makefile.{node,node_prebuilt}.defs"
+# is included.
+ifdef NPM
+$(ESLINT_EXEC): package.json | $(NPM_EXEC)
+	ESLINT_VER=$$($(NODE) -e 'console.log(require("./package.json").devDependencies["eslint"] || "")') && \
+	    ESLINT_JOY_VER=$$($(NODE) -e 'console.log(require("./package.json").devDependencies["eslint-plugin-joyent"] || "")') && \
+	    [[ -n $$ESLINT_VER && -n $$ESLINT_JOY_VER ]] && \
+	    $(NPM) install --no-save eslint@$$ESLINT_VER eslint-plugin-joyent@$$ESLINT_JOY_VER && \
+	    touch $(ESLINT_EXEC)
+else
+$(ESLINT_EXEC): package.json
+	ESLINT_VER=$$(node -e 'console.log(require("./package.json").devDependencies["eslint"] || "")') && \
+	    ESLINT_JOY_VER=$$(node -e 'console.log(require("./package.json").devDependencies["eslint-plugin-joyent"] || "")') && \
+	    [[ -n $$ESLINT_VER && -n $$ESLINT_JOY_VER ]] && \
+	    npm install --no-save eslint@$$ESLINT_VER eslint-plugin-joyent@$$ESLINT_JOY_VER && \
+	    touch $(ESLINT_EXEC)
+endif
+
 #
 # restdown
 #
 RESTDOWN_EXEC	?= deps/restdown/bin/restdown
 RESTDOWN	?= python $(RESTDOWN_EXEC)
 $(RESTDOWN_EXEC): | deps/restdown/.git
+
+EXTRA_DOC_DEPS	?=
diff --git a/tools/mk/Makefile.node.defs b/tools/mk/Makefile.node.defs
index 9376841..487824d 100644
--- a/tools/mk/Makefile.node.defs
+++ b/tools/mk/Makefile.node.defs
@@ -1,4 +1,3 @@
-# -*- mode: makefile -*-
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -6,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -97,8 +96,15 @@ NODE_EXEC	= $(NODE_INSTALL)/bin/node
 NODE_WAF_EXEC	= $(NODE_INSTALL)/bin/node-waf
 NPM_EXEC	= $(NODE_INSTALL)/bin/npm
 
-# Ensure these use absolute paths to the executables to allow running
-# from a dir other than the project top.
+#
+# These paths should be used during the build process to invoke Node and
+# Node-related build tools like NPM.  All paths are fully qualified so that
+# they work regardless of the current working directory at the point of
+# invocation.
+#
+# Note that where PATH is overridden, the value chosen must cause execution of
+# "node" to find the same binary to which the NODE macro refers.
+#
 NODE		:= $(TOP)/$(NODE_EXEC)
 NODE_WAF	:= $(TOP)/$(NODE_WAF_EXEC)
-NPM		:= PATH=$(TOP)/$(NODE_INSTALL)/bin:$(PATH) node $(TOP)/$(NPM_EXEC)
+NPM		:= PATH=$(TOP)/$(NODE_INSTALL)/bin:$(PATH) $(NODE) $(TOP)/$(NPM_EXEC)
diff --git a/tools/mk/Makefile.node.targ b/tools/mk/Makefile.node.targ
index abdc616..bf53f78 100644
--- a/tools/mk/Makefile.node.targ
+++ b/tools/mk/Makefile.node.targ
@@ -29,7 +29,7 @@ else
 $(NODE_EXEC) $(NPM_EXEC) $(NODE_WAF_EXEC):
 	(mkdir -p $(BUILD) \
 		&& cd $(BUILD) \
-		&& [[ -d src-node ]] && (cd src-node && git checkout master && git pull) || git clone git://github.com/joyent/node.git src-node \
+		&& [[ -d src-node ]] && (cd src-node && git checkout master && git pull) || git clone https://github.com/joyent/node.git src-node \
 		&& cd src-node \
 		&& git checkout $(NODE_PREBUILT_VERSION) \
 		&& ./configure $(NODE_CONFIG_FLAGS) \
diff --git a/tools/mk/Makefile.node_prebuilt.defs b/tools/mk/Makefile.node_prebuilt.defs
index 5744489..2129742 100644
--- a/tools/mk/Makefile.node_prebuilt.defs
+++ b/tools/mk/Makefile.node_prebuilt.defs
@@ -1,4 +1,3 @@
-# -*- mode: makefile -*-
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -6,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -146,8 +145,15 @@ NODE_EXEC	:= $(BUILD)/prebuilt-node-$(NODE_PREBUILT_NAME)
 NODE_WAF_EXEC	:= $(BUILD)/prebuilt-node-waf-$(NODE_PREBUILT_NAME)
 NPM_EXEC	:= $(BUILD)/prebuilt-npm-$(NODE_PREBUILT_NAME)
 
-# Ensure these use absolute paths to the executables to allow running
-# from a dir other than the project top.
+#
+# These paths should be used during the build process to invoke Node and
+# Node-related build tools like NPM.  All paths are fully qualified so that
+# they work regardless of the current working directory at the point of
+# invocation.
+#
+# Note that where PATH is overridden, the value chosen must cause execution of
+# "node" to find the same binary to which the NODE macro refers.
+#
 NODE		:= $(TOP)/$(NODE_INSTALL)/bin/node
 NODE_WAF	:= $(TOP)/$(NODE_INSTALL)/bin/node-waf
-NPM		:= PATH=$(TOP)/$(NODE_INSTALL)/bin:$(PATH) node $(TOP)/$(NODE_INSTALL)/bin/npm
+NPM		:= PATH=$(TOP)/$(NODE_INSTALL)/bin:$(PATH) $(NODE) $(TOP)/$(NODE_INSTALL)/bin/npm
diff --git a/tools/mk/Makefile.smf.targ b/tools/mk/Makefile.smf.targ
index 0fa03ce..f78de96 100644
--- a/tools/mk/Makefile.smf.targ
+++ b/tools/mk/Makefile.smf.targ
@@ -23,7 +23,7 @@ check-manifests: $(SMF_MANIFESTS:%=%.smfchk)
 %.smfchk: %
 	$(XMLLINT) --path $(dir $(SMF_DTD)) --dtdvalid $(SMF_DTD) $^
 
-check: check-manifests
+check:: check-manifests
 
 $(SMF_MANIFESTS): %: %.in
 	$(SED) -e 's#@@NODE@@#@@PREFIX@@/$(NODE_INSTALL)/bin/node#' $< > $@
diff --git a/tools/mk/Makefile.targ b/tools/mk/Makefile.targ
index ea19000..cc5ae95 100644
--- a/tools/mk/Makefile.targ
+++ b/tools/mk/Makefile.targ
@@ -1,4 +1,3 @@
-# -*- mode: makefile -*-
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -6,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -77,6 +76,10 @@
 #	CSCOPE_DIRS	Directories to search for source files for the cscope
 #			index. (default: ".")
 #
+#	ESLINT		Path to eslint (default: "eslint")
+#
+#	ESLINT_FLAGS	Additional flags to pass through to eslint
+#
 #	JSL		Path to JavaScriptLint (default: "jsl")
 #
 #	JSL_FLAGS_NODE	Additional flags to pass through to JSL
@@ -89,9 +92,9 @@
 #
 #	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
 #
-#	RESTDOWN_EXT	By default '.restdown' is required for DOC_FILES
-#			(see above). If you want to use, say, '.md' instead, then
-#			set 'RESTDOWN_EXT=.md' in your Makefile.
+#	RESTDOWN_EXT	By default '.md' is required for DOC_FILES (see above).
+#			If you want to use, say, '.restdown' instead, then set
+#			'RESTDOWN_EXT=.restdown' in your Makefile.
 #
 
 #
@@ -102,13 +105,14 @@ BASHSTYLE	?= tools/bashstyle
 CP		?= cp
 CSCOPE		?= cscope
 CSCOPE_DIRS	?= .
+ESLINT		?= eslint
 JSL		?= jsl
 JSON		?= json
 JSSTYLE		?= jsstyle
 MKDIR		?= mkdir -p
 MV		?= mv
 RESTDOWN_FLAGS	?=
-RESTDOWN_EXT	?= .restdown
+RESTDOWN_EXT	?= .md
 RMTREE		?= rm -rf
 JSL_FLAGS  	?= --nologo --nosummary
 
@@ -190,6 +194,12 @@ check-json: $(JSON_FILES:%=%.jsonchk)
 # a variable for the target itself *only if* the list of input files is
 # non-empty.  This avoids invoking the tool if there are no files to check.
 #
+
+ESLINT_TARGET = $(if $(ESLINT_FILES), check-eslint)
+.PHONY: check-eslint
+check-eslint: $(ESLINT_EXEC)
+	$(ESLINT) $(ESLINT_FLAGS) $(ESLINT_FILES)
+
 JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
 .PHONY: check-jsl-node
 check-jsl-node: $(JSL_EXEC)
@@ -209,7 +219,7 @@ check-jsstyle:  $(JSSTYLE_EXEC)
 	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
 
 .PHONY: check
-check: check-jsl check-json $(JSSTYLE_TARGET) check-bash
+check:: $(ESLINT_TARGET) check-jsl check-json $(JSSTYLE_TARGET) check-bash
 	@echo check ok
 
 .PHONY: clean
@@ -264,7 +274,7 @@ DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
 # to get there.
 #
 .PHONY: docs
-docs:							\
+docs::							\
 	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.html)		\
 	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.json)		\
 	$(DOC_MEDIA_FILES_BUILD)
@@ -294,9 +304,11 @@ CLEAN_FILES +=					\
 $(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
 
 $(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
+	$(MKDIR) $(shell dirname $@)
 	$(CP) $< $@
 
-docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC)
+docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC) \
+    $(EXTRA_DOC_DEPS)
 	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
 
 $(DOC_BUILD):
@@ -315,3 +327,19 @@ test:
 
 .PHONY: prepush
 prepush: check test
+
+#
+# This rule automatically exposes every "stamp" file as a target that can be
+# invoked manually as "stamp-$STAMP_NAME".  For example, if a stamp has been
+# defined thus:
+#
+#	STAMP_EXPENSIVE_RESULT := $(MAKE_STAMPS_DIR)/expensive-result
+#
+# ... this can be invoked manually as "make stamp-expensive-result".  Note that
+# these phony targets are essentially just for interactive usage.  Targets
+# should be specified to depend on the macro containing the stamp file name.
+#
+# See also the comments in "Makefile.defs".
+#
+stamp-%: $(MAKE_STAMPS_DIR)/%
+	@:
