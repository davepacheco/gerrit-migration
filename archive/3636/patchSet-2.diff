From 19ceab3a17c753fe786c7141cea4a47b82f359c6 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Wed, 14 Mar 2018 16:53:30 -0700
Subject: [PATCH] OS-6753 HVM disk quotas insufficient on larger zvols

---
 src/vm/node_modules/VM.js           | 132 +++++++++++++++-------------
 src/vm/node_modules/proptable.js    |   6 +-
 src/vm/node_modules/vmload/index.js |  16 +++-
 3 files changed, 88 insertions(+), 66 deletions(-)

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index d5e4f00e..faa1197d 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -1246,8 +1246,19 @@ exports.validate = function (brand, action, payload, options, callback)
     });
 };
 
-function setQuota(dataset, quota, log, callback)
+function setQuota(opts, callback)
 {
+    assert.object(opts, 'opts');
+    assert.string(opts.brand, 'opts.brand');
+    assert.string(opts.dataset, 'opts.dataset');
+    assert.object(opts.log, 'opts.log');
+    assert(opts.quota, 'opts.quota');
+
+    var brand = opts.brand;
+    var dataset = opts.dataset;
+    var log = opts.log;
+    var quota = opts.quota;
+    var quotaKey = 'quota';
     var newval;
 
     assert(log, 'no logger passed to setQuota()');
@@ -1263,7 +1274,14 @@ function setQuota(dataset, quota, log, callback)
         newval = quota.toString() + 'g';
     }
 
-    zfs(['set', 'quota=' + newval, dataset], log, function (err, fds) {
+    if (brand === 'bhyve') {
+        // For bhyve we want to use refquota so that the quota only applies to
+        // the zonepath dataset, and not the zvol 'disks' that are underneath as
+        // zones/<uuid>/diskX
+        quotaKey = 'refquota';
+    }
+
+    zfs(['set', quotaKey + '=' + newval, dataset], log, function (err, fds) {
         if (err) {
             log.error('setQuota() cmd failed: ' + fds.stderr);
             callback(new Error(rtrim(fds.stderr)));
@@ -1959,15 +1977,19 @@ function destroyVolume(volume, log, callback)
 }
 
 // create a new zvol for a VM
-function createVolume(volume, log, callback)
+function createVolume(volume, opts, callback)
 {
+    assert.object(opts, 'opts');
+    assert.string(opts.brand, 'opts.brand');
+    assert.object(opts.log, 'opts.log');
+
+    var brand = opts.brand;
+    var log = opts.log;
     var refreserv;
     var size;
     var snapshot;
     var tracers_obj;
 
-    assert(log, 'no logger passed for createVolume()');
-
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('create-volume', log, callback);
         callback = tracers_obj.callback;
@@ -1988,9 +2010,25 @@ function createVolume(volume, log, callback)
 
     if (volume.hasOwnProperty('refreservation')) {
         refreserv = volume.refreservation;
-    } else {
-        log.debug('defaulting to refreservation = ' + size);
+    } else if (volume.hasOwnProperty('image_uuid')) {
+        // We can't set refreserv > volsize when making a clone, so set it
+        // to volsize instead.
+        refreserv = size;
+        log.debug({
+            size: size
+        }, 'refreservation unset, setting refreserv=size for cloned disk');
+    } else if (brand === 'kvm') {
+        // For KVM we keep the pre-OS-6753 for now to not break compatibility
+        // but could change this to match bhyve (default case below) in the
+        // future.
         refreserv = size;
+        log.debug({
+            size: size
+        }, 'refreservation unset for kvm, setting refreserv=size for new disk');
+    } else {
+        // We default to letting SmartOS set refreservation for bhyve: OS-6753
+        log.debug('refreservation unset, letting system determine');
+        refreserv = 'auto';
     }
 
     async.series([
@@ -2042,7 +2080,9 @@ function createVolume(volume, log, callback)
                     args.push('-o', 'volblocksize='
                         + volume.block_size);
                 }
-                args.push('-o', 'refreservation=' + refreserv + 'M');
+                if (refreserv !== 'auto') {
+                    args.push('-o', 'refreservation=' + refreserv + 'M');
+                }
                 args.push(snapshot, target);
                 zfs(args, log, function (e) {
                     if (e) {
@@ -2064,8 +2104,10 @@ function createVolume(volume, log, callback)
                     args.push('-o', 'volblocksize='
                         + volume.block_size);
                 }
-                args.push('-o', 'refreservation=' + refreserv + 'M', '-V',
-                    size + 'M', target);
+                if (refreserv !== 'auto') {
+                    args.push('-o', 'refreservation=' + refreserv + 'M');
+                }
+                args.push('-V', size + 'M', target);
                 zfs(args, log, function (err, fds) {
                     if (err) {
                         cb(err);
@@ -2646,7 +2688,10 @@ function createVolumes(payload, log, callback)
     }
 
     function _loggedCreateVolume(volume, cb) {
-        return createVolume(volume, log, cb);
+        return createVolume(volume, {
+            brand: payload.brand,
+            log: log
+        }, cb);
     }
 
     function _loggedDeleteVolume(volume, cb) {
@@ -3037,7 +3082,7 @@ function createVM(payload, log, callback)
             //
             //  zones/<uuid>/disk0
             //
-            args = ['create', '-o', 'quota=' + payload.quota + 'G',
+            args = ['create', '-o', 'refquota=' + payload.quota + 'G',
                 payload.zpool + '/' + payload.uuid];
 
             zfs(args, log, function _onZfsCreate(err) {
@@ -4549,6 +4594,14 @@ function checkPayloadProperties(payload, vmobj, log, callback)
             if (payload.update_disks.hasOwnProperty(disk)) {
                 zvol = payload.update_disks[disk];
 
+                // Disks cannot have refreservation=auto on update.
+                // Only create.
+                if (zvol.refreservation === 'auto') {
+                    callback(new Error('cannot change refreservation to '
+                        + 'auto on existing disk'));
+                    return;
+                }
+
                 if (zvol.hasOwnProperty('compression')) {
                     if (VM.COMPRESSION_TYPES.indexOf(zvol.compression) === -1) {
                         callback(new Error('invalid compression type for '
@@ -9860,50 +9913,6 @@ exports.create = function (payload, options, callback)
                 }
                 cb(err);
             });
-        }, function _fixByveQuota(cb) {
-            var disk;
-            var disks;
-            var idx;
-            var oldQuota;
-
-            // For bhyve, we set quota to quota + the sum of the disk sizes.
-            // This is because here (unlike KVM) the volumes are sub-datasets.
-            // It has to happen after normalizePayload since that will have set
-            // the image_size if the original payload failed to include one.
-            if (payload.brand !== 'bhyve') {
-                cb();
-                return;
-            }
-
-            if (payload.add_disks) {
-                disks = payload.add_disks;
-            } else if (payload.disks) {
-                disks = payload.disks;
-            }
-
-            // These should already have been "normalized"/validated above, and
-            // for bhyve a VM doesn't make sense without disks.
-            assert.number(payload.quota, 'payload.quota');
-            assert.arrayOfObject(disks, 'disks');
-
-            oldQuota = payload.quota;
-            for (idx = 0; idx < disks.length; idx++) {
-                disk = disks[idx];
-
-                if (disk.image_size) {
-                    // image_size is MiB, quota is GiB
-                    payload.quota += Math.ceil(Number(disk.image_size) / 1024);
-                } else if (disk.size) {
-                    payload.quota += Math.ceil(Number(disk.size) / 1024);
-                }
-            }
-
-            log.debug({
-                newQuota: payload.quota,
-                oldQuota: oldQuota
-            }, 'Updated bhyve VM quota to include disks');
-
-            cb();
         }, function (cb) {
             checkDatasetProvisionable(payload, log, function (provisionable) {
                 if (!provisionable) {
@@ -12929,9 +12938,12 @@ function applyUpdates(oldobj, newobj, payload, log, callback)
             if (payload.hasOwnProperty('quota')
                 && (Number(payload.quota) !== Number(oldobj.quota))) {
 
-                setQuota(newobj.zfs_filesystem, payload.quota, log,
-                    function (err) {
-
+                setQuota({
+                    brand: oldobj.brand,
+                    dataset: newobj.zfs_filesystem,
+                    log: log,
+                    quota: payload.quota
+                }, function _onSetQuota(err) {
                     if (!err) {
                         changed = true;
                     }
@@ -13449,7 +13461,7 @@ exports.update = function (uuid, payload, options, callback)
             }
 
             // add the bits of payload createVolumes() needs.
-            p = {'add_disks': disks};
+            p = {add_disks: disks, brand: vmobj.brand};
             p.uuid = uuid;
             if (vmobj.hasOwnProperty('zpool')) {
                 p.zpool = vmobj.zpool;
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index 7b3b134c..4092fcd0 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -35,11 +35,13 @@
  *
  */
 
-// values used in feature table for bhyve
 // This can likely be lowered once we use large pages.
 var BHYVE_MEM_OVERHEAD = 1024 + 256;
 var BHYVE_MIN_MEM_OVERHEAD = 256;
 
+exports.BHYVE_MEM_OVERHEAD = BHYVE_MEM_OVERHEAD;
+exports.BHYVE_MIN_MEM_OVERHEAD = BHYVE_MIN_MEM_OVERHEAD;
+
 // values used in feature table for KVM
 var KVM_MEM_OVERHEAD = 1024;
 var KVM_MIN_MEM_OVERHEAD = 256;
@@ -1493,7 +1495,7 @@ exports.properties = {
             min: 0
         },
         zfs: {
-            fields: ['quota'],
+            fields: ['refquota', 'quota'],
             types: ['filesystem']
         }
     }, ram: {
diff --git a/src/vm/node_modules/vmload/index.js b/src/vm/node_modules/vmload/index.js
index b5647728..fe2daeeb 100644
--- a/src/vm/node_modules/vmload/index.js
+++ b/src/vm/node_modules/vmload/index.js
@@ -309,10 +309,18 @@ function addRootDatasetProperties(vmobj, dataset_objects, options)
     }
 
     // dsobj.quota is in bytes, we want GiB for vmobj.quota
-    if (wantField(options, 'quota') && dsobj.hasOwnProperty('quota')) {
-        vmobj.quota = (dsobj.quota / (1024 * 1024 * 1024));
-        log.trace('found quota "' + vmobj.quota + '" for '
-            + vmobj.uuid);
+    if (vmobj.brand === 'bhyve') {
+        if (wantField(options, 'quota') && dsobj.hasOwnProperty('refquota')) {
+            vmobj.quota = (dsobj.refquota / (1024 * 1024 * 1024));
+            log.trace('found quota "' + vmobj.quota + '" for '
+                + vmobj.uuid);
+        }
+    } else {
+        if (wantField(options, 'quota') && dsobj.hasOwnProperty('quota')) {
+            vmobj.quota = (dsobj.quota / (1024 * 1024 * 1024));
+            log.trace('found quota "' + vmobj.quota + '" for '
+                + vmobj.uuid);
+        }
     }
 
     if (wantField(options, 'create_timestamp')
-- 
2.21.0

