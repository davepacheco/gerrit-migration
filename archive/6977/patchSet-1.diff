From 47fe5fcb946e17e4b9938f9e9ab0373fc34635ca Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Fri, 23 Aug 2019 16:09:21 +0000
Subject: [PATCH] sysinfo.js error handling and code organization improvements

---
 lib/backends/linux/sysinfo.js | 178 ++++++++++++++++------------------
 1 file changed, 83 insertions(+), 95 deletions(-)

diff --git a/lib/backends/linux/sysinfo.js b/lib/backends/linux/sysinfo.js
index 065f78f..05fe822 100644
--- a/lib/backends/linux/sysinfo.js
+++ b/lib/backends/linux/sysinfo.js
@@ -11,21 +11,13 @@
 // This file gathers all the data required for the sysinfo command.
 
 var cp = require('child_process');
-var EventEmitter = require('events').EventEmitter;
-var exec = cp.exec;
 var execFile = cp.execFile;
 var fs = require('fs');
 var os = require('os');
-var spawn = cp.spawn;
-var util = require('util');
 
 var assert = require('assert-plus');
-var async = require('async');
-var sprintf = require('sprintf').sprintf;
 var vasync = require('vasync');
-var verror = require('verror');
-var zfs = require('zfs').zfs;
-var zpool = require('zfs').zpool;
+var VError = require('verror');
 
 var smartdc_config = require('./smartdc-config');
 
@@ -153,6 +145,8 @@ function getMemInfo(log, callback)
                 return;
             }
         }
+        callback(new VError(
+            'getMemInfo: could not find MemTotal in /proc/meminfo'));
     });
 }
 
@@ -207,6 +201,8 @@ function getDiskInfo(log, callback)
 function getZpoolInfo(log, callback)
 {
     var sysinfo = {};
+    // If we can't find a system pool, these will be returned.
+    var errors = [];
 
     /*
      * There can be many pools on the system.  sysinfo is only concerned with
@@ -254,30 +250,23 @@ function getZpoolInfo(log, callback)
                     var props = dsprops[pool];
 
                     if (props.mounted !== 'yes') {
-                        if (LOG) {
-                            LOG.info({props: props},
-                                'getZpoolInfo: top level dataset of pool ' +
-                                pool + ' not mounted: not a system pool');
-                            done();
-                            return;
-                        }
+                        errors.push(new VError({props: props},
+                            'top level dataset of pool ' + pool +
+                            ' is not mounted: not a system pool'));
+                        done();
+                        return;
                     }
                     fs.access(props.mountpoint + '/.system_pool',
                         function dotSystemPoolExists(err) {
 
                         if (err) {
-                            if (LOG) {
-                                LOG.debug({props: props},
-                                    'getZpoolInfo: not a system pool: ' + err);
-                            }
+                            errors.push(new VError({props: props},
+                                'top level dataset of pool ' + pool +
+                                ' does not contain "/.system_pool"'));
                             done();
-                        } else {
-                            if (LOG) {
-                                LOG.debug({props: props},
-                                    'getZpoolInfo: found a system pool');
-                            }
-                            done(null, props);
+                            return;
                         }
+                        done(null, props);
                     });
                 }
             },
@@ -296,12 +285,12 @@ function getZpoolInfo(log, callback)
                 }
 
                 if (syspools.length == 0) {
-                    next(new Error('no system zfs pools'));
+                    next(new VError('no system zfs pools'));
                     return;
                 }
                 if (syspools.length != 1) {
-                    next(new Error('multiple system zfs pools: ' +
-                        syspools.join(', ')));
+                    next(new VError({results: results, syspools: syspools},
+                        'multiple system zfs pools'));
                     return;
                 }
 
@@ -312,7 +301,6 @@ function getZpoolInfo(log, callback)
                     (1024 * 1024 * 1024));
                 sysinfo['Zpool Creation'] = Number(selected.creation);
 
-
                 next(null, selected.name);
             });
         }, function getSystemPoolProfile(pool, next) {
@@ -359,6 +347,13 @@ function getZpoolInfo(log, callback)
             });
         }],
         function getZpoolInfoDone(err) {
+            // The errors array contains errors that may be helpful when no
+            // system pool is found.  If a system pool was found, the oddities
+            // found along the way do not matter.
+            if (err && errors) {
+                err = new MultiError([err].concat(errors));
+            }
+
             callback(err, sysinfo);
         });
 }
@@ -440,83 +435,76 @@ function getNetInfo(log, callback)
             return;
         }
         var nets = JSON.parse(stdout);
-        var netinfo = ipAddrToNetInfo(JSON.parse(stdout))
-
-        var sysinfo = {
-            'Network Interfaces': netinfo.nics,
-            'Virtual Network Interfaces': netinfo.vnics,
-            'Link Aggregations': netinfo.aggrs
-        };
-
-        callback(null, sysinfo);
-    });
-}
-
-function ipAddrToNetInfo(nets)
-{
-    var nics = {};
-    var vnics = {};
-    var aggrs = {};
-    var aggr_ifs = {};
-
-    // XXX-mg does not handle vlan, vxlan.  vnic and aggr are questionable.
-    for (var net of nets) {
-        if (net.link_type !== 'ether') {
-            continue;
-        }
-
-        var nic = {
-            'MAC Address': net.address,
-            'Link Status': net.operstate == 'UP' ? 'up' : 'down',
-            'ip4addr': '',
-            'NIC Names': []
-        };
-        nics[net.ifname] = nic;
-
-        for (var addr of net.addr_info) {
-            // XXX-mg what about inet6?
-            if (addr.family !== 'inet') {
-                continue;
-            }
-            if (addr.label === net.ifname) {
-                nic.ip4addr = addr.local;
+        var nics = {};
+        var vnics = {};
+        var aggrs = {};
+        var aggr_ifs = {};
+
+        // XXX-mg does not handle vlan, vxlan.  vnic and aggr are questionable.
+        for (var net of nets) {
+            if (net.link_type !== 'ether') {
                 continue;
             }
 
-            // XXX-mg virtual IP as a vnic?  Is there something better?
-            vnics[addr.label] = {
+            var nic = {
                 'MAC Address': net.address,
-                'ip4addr': addr.local,
-                'Link Status': 'up',
-                'Host Interface': net.ifname
+                'Link Status': net.operstate == 'UP' ? 'up' : 'down',
+                'ip4addr': '',
+                'NIC Names': []
             };
-        }
+            nics[net.ifname] = nic;
+
+            for (var addr of net.addr_info) {
+                // XXX-mg what about inet6?
+                if (addr.family !== 'inet') {
+                    continue;
+                }
+                if (addr.label === net.ifname) {
+                    nic.ip4addr = addr.local;
+                    continue;
+                }
+
+                // XXX-mg virtual IP as a vnic?  Is there something better?
+                vnics[addr.label] = {
+                    'MAC Address': net.address,
+                    'ip4addr': addr.local,
+                    'Link Status': 'up',
+                    'Host Interface': net.ifname
+                };
+            }
 
-        // Handle "link aggregation" (bond) lower links.  Order of keys in
-        // 'ip a' output is not documented to have bond slave (lower link)
-        // interfaces before master (bond, aggr) interfaces so stash the
-        // mapping in a separate object for now.
-        if (net.hasOwnProperty('master') && net.master != '') {
-            if (!aggr_ifs.hasOwnProperty(net.master)) {
-                aggr_ifs[net.master] = [];
+            // Handle "link aggregation" (bond) lower links.  Order of keys in
+            // 'ip a' output is not documented to have bond slave (lower link)
+            // interfaces before master (bond, aggr) interfaces so stash the
+            // mapping in a separate object for now.
+            if (net.hasOwnProperty('master') && net.master != '') {
+                if (!aggr_ifs.hasOwnProperty(net.master)) {
+                    aggr_ifs[net.master] = [];
+                }
+                aggr_ifs[net.master].push(net.ifname);
+            }
+
+            // Handle bond master links.
+            if (net.flags.indexOf('MASTER') !== -1) {
+                aggrs[net.ifname] = {
+                    'LACP mode': 'Unknown', // XXX-mg fix this
+                };
             }
-            aggr_ifs[net.master].push(net.ifname);
         }
 
-        // Handle bond master links.
-        if (net.flags.indexOf('MASTER') !== -1) {
-            aggrs[net.ifname] = {
-                'LACP mode': 'Unknown', // XXX-mg fix this
-            };
+        // Add slave links to master
+        for (var aggr in aggrs) {
+            aggrs[aggr]['Interfaces'] = aggr_ifs[aggr] || [];
         }
-    }
 
-    // Add slave links to master
-    for (var aggr in aggrs) {
-        aggrs[aggr]['Interfaces'] = aggr_ifs[aggr] || [];
-    }
+        var sysinfo = {
+            'Network Interfaces': nics,
+            'Virtual Network Interfaces': vnics,
+            'Link Aggregations': aggrs
+        };
 
-    return ({ nics: nics, vnics: vnics, aggrs: aggrs });
+        callback(null, sysinfo);
+    });
 }
 
 function getSmbiosInfo(log, callback)
-- 
2.17.2 (Apple Git-113)

