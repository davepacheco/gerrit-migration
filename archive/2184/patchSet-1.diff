From 43e908f172a2f91266fe300fa61db9ac4f882833 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Tue, 4 Jul 2017 15:29:53 -0700
Subject: [PATCH] DOCKER-1056 support `docker network inspect`

---
 lib/backends/sdc/containers.js       | 201 ++++-----------------------
 lib/backends/sdc/index.js            |   2 +
 lib/backends/sdc/networks.js         | 185 ++++++++++++++++++++++++
 lib/endpoints/networks.js            |  44 +++++-
 test/integration/api-network.test.js |  15 ++
 5 files changed, 267 insertions(+), 180 deletions(-)

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index b0ac7b5..f14d81b 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -34,6 +34,7 @@ var common = require('../../../lib/common');
 var errors = require('../../../lib/errors');
 var images = require('./images');
 var Link = require('../../models/link');
+var mod_networks = require('./networks');
 var utils = require('./utils');
 var validate = require('../../validate');
 
@@ -570,18 +571,35 @@ function addNetworksToPayload(opts, container, payload, callback) {
         'opts.requireExternalNetwork');
     assert.func(callback, 'callback');
 
+    var log = opts.log;
+    var networkMode;
+
     vasync.pipeline({ funcs: [
         function addFabricNetworks(_, next) {
             if (!opts.config.overlay.enabled) {
                 next();
                 return;
             }
-            if (container.HostConfig.NetworkMode === 'bridge'
-                || container.HostConfig.NetworkMode === 'default'
-                || common.objEmpty(container.HostConfig.NetworkMode)) {
+            assert.string(container.HostConfig.NetworkMode,
+                'container.HostConfig.NetworkMode');
+            assert.notEqual(container.HostConfig.NetworkMode, '',
+                'NetworkMode is empty');
+            networkMode = container.HostConfig.NetworkMode;
+            if (networkMode === 'bridge'
+                || networkMode === 'default'
+                || common.objEmpty(networkMode)) {
                 defaultFabricNetwork(opts, payload, next);
             } else {
-                namedNetwork(opts, container, payload, next);
+                mod_networks.findNetworkByNameOrId(networkMode, opts,
+                    function (findErr, network)
+                {
+                    if (findErr) {
+                        next(findErr);
+                        return;
+                    }
+                    payload.networks = [ {uuid: network.uuid, primary: true} ];
+                    next();
+                });
             }
         },
 
@@ -604,7 +622,12 @@ function addNetworksToPayload(opts, container, payload, callback) {
             }
             externalNetworkByName(opts, container, payload, next);
         }
-    ]}, callback);
+    ]}, function (err) {
+        if (!err) {
+            log.debug({ networks: payload.networks }, 'payload.networks');
+        }
+        callback(err);
+    });
 }
 
 /*
@@ -728,174 +751,6 @@ function defaultFabricNetwork(opts, payload, callback) {
     });
 }
 
-/*
- * When fabrics are configured and a specific network name is supplied,
- * we will find and use the specified network.
- */
-function namedNetwork(opts, container, payload, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.account, 'opts.account');
-    assert.string(opts.account.uuid, 'opts.account.uuid');
-    assert.object(opts.config, 'opts.config');
-    assert.object(opts.config.napi, 'opts.config.napi');
-    assert.object(opts.log, 'opts.log');
-    assert.object(container, 'container');
-    assert.object(container.HostConfig, 'container.HostConfig');
-    assert.string(container.HostConfig.NetworkMode,
-        'container.HostConfig.NetworkMode');
-    assert.notEqual(container.HostConfig.NetworkMode, '',
-        'NetworkMode is empty');
-    assert.func(callback, 'callback');
-
-    // need to search on networks by: name, fabric-true, owner_uuid
-    var log = opts.log;
-    var query = container.HostConfig.NetworkMode;
-    var napi = getNapiClient(opts.config.napi);
-
-    // NOTE: the order of the functions in this parallel() call is significant;
-    // they are ordered by how docker prefers to resolve IDs:
-    // 1. exact id match
-    // 2. exact name match
-    // 3. partial id match
-    vasync.parallel({
-        funcs: [
-            function byExactId(cb) {
-                // length === 64, and 0..31 === 32..63, or it's an 'impossible'
-                // id under our double-uuid convention, and we can skip it.
-                if (query.substr(0, 32) !== query.substr(32)) {
-                    log.debug({ query: query },
-                        'Networks: impossible exactId: %s, skipping', query);
-                    setImmediate(cb, null, []);
-                    return;
-                }
-                var uuid = utils.shortNetworkIdToUuidPrefix(query);
-
-                // XXX - ldapEscape required to work around NAPI-367
-                var listParams = {
-                    uuid: utils.ldapEscape(uuid),
-                    provisionable_by: opts.account.uuid
-                };
-
-                napi.listNetworks(listParams,
-                    { headers: { 'x-request-id': opts.req_id }}, cb);
-            },
-            function byName(cb) {
-                var listParams = {
-                    name: query,
-                    provisionable_by: opts.account.uuid
-                };
-
-                log.debug({ listParams: listParams },
-                    format('Networks: searching for network %s',
-                        listParams.name));
-
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
-            },
-            function byDockerId(cb) {
-                // we assume the 'double uuid' convention for networks here,
-                // that is, dockerId = (uuid + uuid).replace(/-/g, '').
-                // So if we have a query.length > 31, 32... must be a prefix of
-                // 0..31. If not, the id supplied is impossible in our system.
-                if (query.length >= 32) {
-                    // this must be a prefix of the first half of the input
-                    var secondHalf = query.substr(32);
-                    var firstHalf = query.substr(0, 31);
-
-                    if (secondHalf.length >= firstHalf.length
-                        || secondHalf !==
-                        firstHalf.substr(0, secondHalf.length)) {
-
-                        log.info({ query: query },
-                            'Networks: impossible network id %s, skipping',
-                            query);
-                        setImmediate(cb, null, []);
-                        return;
-                    }
-                }
-
-                // To perform the search, we transform the provided query to
-                // a (potentially partial) UUID, and perform a wildcard search
-                // on it.
-                // XXX - ldapEscape required to work around NAPI-367
-                var uuidSearchStr = utils.ldapEscape(
-                    utils.shortNetworkIdToUuidPrefix(query)) + '*';
-
-                var listParams = {
-                    uuid: uuidSearchStr,
-                    provisionable_by: opts.account.uuid
-                };
-
-                log.debug({ listParams: listParams },
-                    format('Networks: searching for network %s',
-                        listParams.uuid));
-
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
-            }
-        ]
-    }, function _listedNetworks(err, results) {
-        // results.operations is ordered per the funcs array provided
-        // to vasync.parallel (see vasync docs). We can tolerate partial
-        // errors as long as they are lower in the preference chain.
-        // IOW, we callback with the err/result of the most-preferred
-        // search, and log any additional errors.
-        var bestMatch = results.operations.reduce(function (acc, op) {
-            if (acc.err || acc.result) {
-                return acc;
-            }
-            if (op.err) {
-                acc.err = op.err;
-                return acc;
-            }
-            // all match funcs are listNetworks, contract is to return an
-            // err (handled above) or array.
-            switch (op.result.length) {
-            case 0:
-                break;
-            case 1:
-                acc.result = op.result[0];
-                break;
-            default:
-                acc.err = new errors.AmbiguousDockerNetworkIdPrefixError(query);
-                break;
-            }
-            return acc;
-        }, { err: null, result: null });
-
-        if (bestMatch.err) {
-            // found an error before a result.
-            log.error({ err: bestMatch.err, query: query },
-                format('Networks: Error finding network to match %s', query));
-            callback(bestMatch.err);
-            return;
-        }
-
-        if (!bestMatch.err && !bestMatch.result) {
-            log.info({ query: query, user: opts.account.uuid },
-                format('Networks: no results for query %s', query));
-            callback(new errors.NetworkNotFoundError(query));
-            return;
-        }
-
-        if (!bestMatch.err && err) {
-            // found result before an error, but did have errs.
-            log.warn({ err: err },
-                'Networks: non-critical error searching NAPI');
-        }
-
-        log.debug({ network: bestMatch.result }, 'Networks: chose %s/%s',
-            bestMatch.result.name, bestMatch.result.uuid);
-
-        payload.networks = [ { uuid: bestMatch.result.uuid, primary: true } ];
-        log.debug({ payload: payload }, format('Networks: built payload'));
-
-        callback();
-        return;
-    });
-}
-
-
 /**
  * Add a rule or rules to payload.firewall_rules
  */
diff --git a/lib/backends/sdc/index.js b/lib/backends/sdc/index.js
index 12efd46..d20d3a3 100644
--- a/lib/backends/sdc/index.js
+++ b/lib/backends/sdc/index.js
@@ -82,6 +82,8 @@ SdcBackend.prototype.buildImage = build.buildImage;
 SdcBackend.prototype.commitImage = build.commitImage;
 
 // networks.js
+SdcBackend.prototype.findNetworkByNameOrId = networks.findNetworkByNameOrId;
+SdcBackend.prototype.inspectNetwork = networks.inspectNetwork;
 SdcBackend.prototype.listNetworks = networks.listNetworks;
 
 
diff --git a/lib/backends/sdc/networks.js b/lib/backends/sdc/networks.js
index 244c9e8..409f59a 100644
--- a/lib/backends/sdc/networks.js
+++ b/lib/backends/sdc/networks.js
@@ -16,8 +16,10 @@
 
 var assert = require('assert-plus');
 var NAPI = require('sdc-clients').NAPI;
+var util = require('util');
 var vasync = require('vasync');
 
+var errors = require('../../errors');
 var utils = require('./utils');
 
 //---- globals
@@ -252,6 +254,189 @@ function listNetworks(opts, callback) {
 }
 
 
+/**
+ * List networks available to the req account holder.
+ *
+ * @param {Object} opts Options.
+ * @param {Function} callback (err, networks) Array of docker network objects.
+ */
+function inspectNetwork(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.req, 'opts.req');
+    assert.object(opts.req.network, 'opts.req.network');
+    assert.object(opts.req.app, 'opts.req.app');
+    assert.object(opts.req.app.config, 'opts.req.app.config');
+    assert.object(opts.req.log, 'opts.req.log');
+
+    napiNetworkToDockerNetwork(opts.req.network, {}, callback);
+}
+
+
+/**
+ * Find the NAPI network from the given name or id.
+ *
+ * @param {String} name The name or id of the network to look for.
+ * @param {Object} opts Accont and config options.
+ * @param {Function} callback (err, network) Called with the found network.
+ */
+function findNetworkByNameOrId(name, opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.string(opts.account.uuid, 'opts.account.uuid');
+    assert.object(opts.config, 'opts.config');
+    assert.object(opts.config.napi, 'opts.config.napi');
+    assert.object(opts.log, 'opts.log');
+    assert.uuid(opts.req_id, 'opts.req_id');
+    assert.func(callback, 'callback');
+
+    // need to search on networks by: name, fabric-true, owner_uuid
+    var log = opts.log;
+    var napi = getNapiClient(opts.config.napi);
+
+    // NOTE: the order of the functions in this parallel() call is significant;
+    // they are ordered by how docker prefers to resolve IDs:
+    // 1. exact id match
+    // 2. exact name match
+    // 3. partial id match
+    vasync.parallel({
+        funcs: [
+            function byExactId(cb) {
+                // length === 64, and 0..31 === 32..63, or it's an 'impossible'
+                // id under our double-uuid convention, and we can skip it.
+                if (name.substr(0, 32) !== name.substr(32)) {
+                    log.debug({ name: name },
+                        'Networks: impossible exactId: %s, skipping', name);
+                    setImmediate(cb, null, []);
+                    return;
+                }
+                var uuid = utils.shortNetworkIdToUuidPrefix(name);
+
+                // XXX - ldapEscape required to work around NAPI-367
+                var listParams = {
+                    uuid: utils.ldapEscape(uuid),
+                    provisionable_by: opts.account.uuid
+                };
+
+                napi.listNetworks(listParams,
+                    { headers: { 'x-request-id': opts.req_id }}, cb);
+            },
+            function byName(cb) {
+                var listParams = {
+                    name: name,
+                    provisionable_by: opts.account.uuid
+                };
+
+                log.debug({ listParams: listParams },
+                    util.format('Networks: searching for network %s',
+                        listParams.name));
+
+                napi.listNetworks(listParams,
+                    { headers: {'x-request-id': opts.req_id }}, cb);
+            },
+            function byDockerId(cb) {
+                // we assume the 'double uuid' convention for networks here,
+                // that is, dockerId = (uuid + uuid).replace(/-/g, '').
+                // So if we have a name.length > 31, 32... must be a prefix of
+                // 0..31. If not, the id supplied is impossible in our system.
+                if (name.length >= 32) {
+                    // this must be a prefix of the first half of the input
+                    var secondHalf = name.substr(32);
+                    var firstHalf = name.substr(0, 31);
+
+                    if (secondHalf.length >= firstHalf.length
+                        || secondHalf !==
+                        firstHalf.substr(0, secondHalf.length)) {
+
+                        log.info({ name: name },
+                            'Networks: impossible network id %s, skipping',
+                            name);
+                        setImmediate(cb, null, []);
+                        return;
+                    }
+                }
+
+                // To perform the search, we transform the provided name to
+                // a (potentially partial) UUID, and perform a wildcard search
+                // on it.
+                // XXX - ldapEscape required to work around NAPI-367
+                var uuidSearchStr = utils.ldapEscape(
+                    utils.shortNetworkIdToUuidPrefix(name)) + '*';
+
+                var listParams = {
+                    uuid: uuidSearchStr,
+                    provisionable_by: opts.account.uuid
+                };
+
+                log.debug({ listParams: listParams },
+                    util.format('Networks: searching for network %s',
+                        listParams.uuid));
+
+                napi.listNetworks(listParams,
+                    { headers: {'x-request-id': opts.req_id }}, cb);
+            }
+        ]
+    }, function _listedNetworks(err, results) {
+        // results.operations is ordered per the funcs array provided
+        // to vasync.parallel (see vasync docs). We can tolerate partial
+        // errors as long as they are lower in the preference chain.
+        // IOW, we callback with the err/result of the most-preferred
+        // search, and log any additional errors.
+        var bestMatch = results.operations.reduce(function (acc, op) {
+            if (acc.err || acc.result) {
+                return acc;
+            }
+            if (op.err) {
+                acc.err = op.err;
+                return acc;
+            }
+            // all match funcs are listNetworks, contract is to return an
+            // err (handled above) or array.
+            switch (op.result.length) {
+                case 0:
+                    break;
+                case 1:
+                    acc.result = op.result[0];
+                    break;
+                default:
+                    acc.err = new errors.AmbiguousDockerNetworkIdPrefixError(
+                        name);
+                    break;
+            }
+            return acc;
+        }, { err: null, result: null });
+
+        if (bestMatch.err) {
+            // found an error before a result.
+            log.error({ err: bestMatch.err, name: name },
+                util.format('Networks: Error finding network to match %s',
+                    name));
+            callback(bestMatch.err);
+            return;
+        }
+
+        if (!bestMatch.err && !bestMatch.result) {
+            log.info({ name: name, user: opts.account.uuid },
+                util.format('Networks: no results for name %s', name));
+            callback(new errors.NetworkNotFoundError(name));
+            return;
+        }
+
+        if (!bestMatch.err && err) {
+            // found result before an error, but did have errs.
+            log.warn({ err: err },
+                'Networks: non-critical error searching NAPI');
+        }
+
+        log.debug({ network: bestMatch.result }, 'Networks: chose %s/%s',
+            bestMatch.result.name, bestMatch.result.uuid);
+
+        callback(null, bestMatch.result);
+    });
+}
+
+
 module.exports = {
+    findNetworkByNameOrId: findNetworkByNameOrId,
+    inspectNetwork: inspectNetwork,
     listNetworks: listNetworks
 };
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
index 9a9e19c..cd71323 100644
--- a/lib/endpoints/networks.js
+++ b/lib/endpoints/networks.js
@@ -59,7 +59,22 @@ function networkDelete(req, res, next) {
  * GET /networks/:id
  */
 function networkInspect(req, res, next) {
-    return next(new errors.NotImplementedError('network inspect'));
+    var log = req.log;
+    var opts = {req: req};
+
+    req.backend.inspectNetwork(opts, function (err, network) {
+        if (err) {
+            if (!(err instanceof errors.DockerError)) {
+                log.error({err: err}, 'Problem inspecting network');
+                err = new errors.DockerError(err, 'problem inspecting network');
+            }
+            next(err);
+            return;
+        }
+
+        res.send(network);
+        next();
+    });
 }
 
 
@@ -98,8 +113,23 @@ function register(http, before) {
         next();
     }
 
-    function getNetwork(req, res, next) {
-        next();
+    function reqNetwork(req, res, next) {
+        var opts = {
+            account: req.account,
+            config: req.app.config,
+            log: req.log,
+            req_id: req.getId()
+        };
+        req.backend.findNetworkByNameOrId(req.params.id, opts,
+            function onFindNetwork(err, network)
+        {
+            if (err) {
+                next(err);
+                return;
+            }
+            req.network = network;
+            next();
+        });
     }
 
     var queryParserOpts = {
@@ -124,22 +154,22 @@ function register(http, before) {
 
     // DELETE '/:apiversion/networks/:id'
     http.del({ path: /^(\/v[^\/]+)?\/networks\/([^\/]+)$/,
-        name: 'NetworkDelete' }, before, reqParamsId, getNetwork,
+        name: 'NetworkDelete' }, before, reqParamsId, reqNetwork,
         networkDelete);
 
     // GET '/:apiversion/networks/:id'
     http.get({ path: /^(\/v[^\/]+)?\/networks\/([^\/]+)$/,
-        name: 'NetworkInspect' }, before, reqParamsId, getNetwork,
+        name: 'NetworkInspect' }, before, reqParamsId, reqNetwork,
         networkInspect);
 
     // POST '/:apiversion/networks/:id/connect'
     http.post({ path: /^(\/v[^\/]+)?\/networks\/([^\/]+)\/connect$/,
-        name: 'NetworkConnect' }, before, reqParamsId, getNetwork,
+        name: 'NetworkConnect' }, before, reqParamsId, reqNetwork,
         networkConnect);
 
     // POST '/:apiversion/networks/:id/disconnect'
     http.post({ path: /^(\/v[^\/]+)?\/networks\/([^\/]+)\/disconnect$/,
-        name: 'NetworkDisconnect' }, before, reqParamsId, getNetwork,
+        name: 'NetworkDisconnect' }, before, reqParamsId, reqNetwork,
         networkDisconnect);
 
     // POST '/:apiversion/networks/prune'
diff --git a/test/integration/api-network.test.js b/test/integration/api-network.test.js
index 4151493..475ec41 100644
--- a/test/integration/api-network.test.js
+++ b/test/integration/api-network.test.js
@@ -116,3 +116,18 @@ test('docker network ls', function (tt) {
         });
     });
 });
+
+test('docker network inspect', function (tt) {
+    tt.test('inspect external network', function (t) {
+        DOCKER_ALICE.get('/networks/external',
+            function (err, res, req, net)
+        {
+            t.ifErr(err, 'check /networks/external err');
+            t.equal(net.Driver, 'Triton', 'checking net.Driver');
+            t.ok(net.IPAM, 'checking net.IPAM existance');
+            t.ok(net.Options, 'checking net.Options existance');
+            t.equal(net.Scope, 'external', 'checking net.Scope is external');
+            t.end();
+        });
+    });
+});
-- 
2.21.0

