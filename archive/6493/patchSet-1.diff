commit 9d5c1e73058718d22bcd995fbe897477d8405401
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2019-06-24T17:07:20-07:00 (4 months ago)
    
    TRITON-1720 migration needs a rollback feature

diff --git a/docs/index.md b/docs/index.md
index 3d54d9c..77f38a2 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -2267,6 +2267,14 @@ For any migration action (e.g. begin, sync, switch or abort) you can use the
 migration watch endpoint to show progress information for the running migration
 action.
 
+After performing a migration switch (or full automatic migration), if everything
+is working in the newly migrated instance you can then use the migration
+*finalize* action, which will remove the original (now hidden) source instance
+and complete the migration process, else if the new instance is not working
+correctly, you can perform a migration *rollback* action, which will reinstate
+the original source instance and delete the migration target instance, reverting
+to the state of the instance before the migration switch action.
+
 User migrations are disabled by default, but that can be changed globally by
 setting the VMAPI/SAPI user_migration_allowed setting to true, or
 changed on a per-instance basis by updating
@@ -2361,7 +2369,7 @@ Starts the specified migration action.
 
 Param            | Type     | Description
 ---------------- | -------- | -----------
-migration_action | String   | One of "begin", "sync", "switch", "pause", "abort" or "finalize".
+migration_action | String   | One of "begin", "sync", "switch", "pause", "abort", "finalize" or "rollback".
 
 ### Optional Inputs
 
@@ -2410,6 +2418,14 @@ This action is only actionable when the migration is paused or failed. It is
 used to abort the migration, removing the target placeholder vm and ensuring the
 source vm is returned to it's original state.
 
+### Migrate Rollback
+
+The "rollback" action will remove (decommission) the newly migrated target
+instance and restore the original source instance back as the primary (and
+visible) instance. Any filesystem changes made to the target instance since it
+was primary (i.e. since the migration switch) will be lost. After a successful
+migration rollback, the migration record will have been removed.
+
 ### Migrate Finalize
 
 The "finalize" action will remove (decommission) the original source vm (which
diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index 2c5c39e..b6cae46 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -1602,8 +1602,10 @@ Moray.prototype.getVmMigrations = function (params, cb) {
             filter += '(|(state=running)(state=paused)(state=failed))';
         } else if (param === 'source_server_uuid') {
             // Match to the current source_server_uuid or in the case of a
-            // finished migration, match the target_server_uuid.
-            filter += sprintf('(|%s(&%s(state=successful)))',
+            // finished (or failed rollback) migration, alternatively match
+            // to the target_server_uuid.
+            filter += sprintf('(|%s(&%s(|(state=successful)' +
+                '(&(phase=rollback)(state=failed)))))',
                 sprintf(PARAM_FILTER, param, params[param]),
                 sprintf(PARAM_FILTER, 'target_server_uuid', params[param]));
         } else {
diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
index 3e6f9ef..06caae1 100644
--- a/lib/vm-migration/migrate.js
+++ b/lib/vm-migration/migrate.js
@@ -35,6 +35,7 @@ var VALID_MIGRATION_ACTIONS = [
     'estimate',
     'finalize',
     'pause',
+    'rollback',
     'switch',
     'sync'
 ];
@@ -448,6 +449,13 @@ function migrateVm(req, res, next) {
                         return;
                     }
                     break;
+                case 'rollback':
+                    if (state !== 'successful' && phase !== 'rollback') {
+                        cb(new restify.errors.PreconditionFailedError(
+                            'Rollback only works on a successful migration'));
+                        return;
+                    }
+                    break;
                 case 'switch':
                     if (phase !== 'begin' && phase !== 'sync') {
                         cb(new restify.errors.PreconditionFailedError(
@@ -741,7 +749,8 @@ function migrateVm(req, res, next) {
 
         // Keep a record of the running (or soon to be running) phase.
         if (actionIsRunning && (action === 'begin' || action === 'sync' ||
-                action === 'switch' || action === 'abort')) {
+                action === 'switch' || action === 'abort' ||
+                action === 'rollback')) {
             req.migrationTask.record.state = 'running';
             MIGRATION_RECORD_FOR_VM_UUID[vm.uuid] = req.migrationTask.record;
             // Clear old progress events.
@@ -937,6 +946,25 @@ function storeMigrationRecord(req, res, next) {
     // TODO: Check etag?
     var record = req.body;
 
+    // For rollback - at the end of a successful rollback we want to delete
+    // the migration record.
+    if (record.state === 'successful' && record.phase === 'rollback') {
+        req.app.moray.delVmMigration(record.id,
+                function _delMigrationCb(err, etag) {
+            if (err) {
+                next(err);
+                return;
+            }
+
+            MIGRATION_RECORD_FOR_VM_UUID[record.vm_uuid] = record;
+
+            res.send(200);
+            next();
+        });
+
+        return;
+    }
+
     req.app.moray.putVmMigration(record, function _putMigrationCb(err, etag) {
         if (err) {
             next(err);
diff --git a/lib/workflows/migrate-rollback.js b/lib/workflows/migrate-rollback.js
new file mode 100644
index 0000000..ca86a72
--- /dev/null
+++ b/lib/workflows/migrate-rollback.js
@@ -0,0 +1,101 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to rollback a successful migration.
+ *
+ * Preconditions:
+ *  - migration state can only be 'successful'
+ *  - the target instance must still exist
+ *  - the source instance must still exist and have DNI set
+ */
+
+var common = require('./job-common');
+var migrationCommon = require('./vm-migration/common');
+var modSwitch = require('./vm-migration/switch');
+var rollback = require('./vm-migration/rollback');
+
+var VERSION = '1.0.0';
+
+var workflow = module.exports = {
+    name: 'migrate-rollback-' + VERSION,
+    version: VERSION,
+    timeout: 15 * 60, // 15 minutes
+
+    chain: [
+        common.tasks.validateForZoneAction,
+        migrationCommon.tasks.validate,
+
+        rollback.tasks.ensureSourceVmHasDni,
+
+        /* Stop the target vm */
+        rollback.tasks.stopTargetVm,
+        common.tasks.waitForWorkflowJob,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        rollback.tasks.ensureTargetVmStopped,
+
+        migrationCommon.tasks.storeInitialRecord,
+
+        modSwitch.tasks.reserveNetworkIps,
+        modSwitch.tasks.storeReservedNetworkIps,
+
+        common.tasks.setupForWaitTask,
+        rollback.tasks.disableTargetVmAutoboot,
+        common.tasks.waitTask,
+
+        common.tasks.setupForWaitTask,
+        rollback.tasks.setTargetDoNotInventory,
+        common.tasks.waitTask,
+
+        // Dev note: brief window here where the vm could appear to have
+        // been destroyed (i.e. both have 'do_not_inventory' set).
+
+        modSwitch.tasks.updateVmServerUuid,
+
+        common.tasks.setupForWaitTask,
+        migrationCommon.tasks.setSourceVmAutoboot,
+        common.tasks.waitTask,
+
+        common.tasks.setupForWaitTask,
+        rollback.tasks.removeSourceDoNotInventory,
+        common.tasks.waitTask,
+
+        /* Destroy the target vm. */
+        common.tasks.setupForWaitTask,
+        rollback.tasks.deleteTargetDniVm,
+        common.tasks.waitTask,
+
+        /* All done - record final details and store as successful */
+        migrationCommon.tasks.storeSuccess,
+
+        common.tasks.releaseVMTicket,
+
+        /* Restart the source vm. */
+        modSwitch.tasks.startSourceVm,
+        common.tasks.waitForWorkflowJob
+    ],
+
+    onerror: [
+        // TODO: Mark target vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        common.tasks.releaseVMTicketIgnoringErr
+    ],
+
+    oncancel: [
+        // TODO: Mark target vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        common.tasks.releaseVMTicketIgnoringErr
+    ]
+};
diff --git a/lib/workflows/migrate-switch.js b/lib/workflows/migrate-switch.js
index be08525..64d43da 100644
--- a/lib/workflows/migrate-switch.js
+++ b/lib/workflows/migrate-switch.js
@@ -16,7 +16,7 @@ var common = require('./job-common');
 var migrationCommon = require('./vm-migration/common');
 var modSwitch = require('./vm-migration/switch');
 
-var VERSION = '1.0.0';
+var VERSION = '1.0.1';
 
 var workflow = module.exports = {
     name: 'migrate-switch-' + VERSION,
@@ -34,7 +34,7 @@ var workflow = module.exports = {
         common.tasks.releaseVMTicket,
 
         /* Stop the vm */
-        modSwitch.tasks.stopVm,
+        modSwitch.tasks.stopSourceVm,
         common.tasks.waitForWorkflowJob,
 
         /* Run the final sync */
@@ -48,7 +48,7 @@ var workflow = module.exports = {
         modSwitch.tasks.getRecord,
         migrationCommon.tasks.storeInitialRecord,
 
-        modSwitch.tasks.ensureVmStopped,
+        modSwitch.tasks.ensureSourceVmStopped,
 
         /* Switch over instances. */
         modSwitch.tasks.reserveNetworkIps,
@@ -58,6 +58,10 @@ var workflow = module.exports = {
         modSwitch.tasks.setupTargetFilesystem,
         common.tasks.waitTask,
 
+        common.tasks.setupForWaitTask,
+        modSwitch.tasks.disableSourceVmAutoboot,
+        common.tasks.waitTask,
+
         common.tasks.setupForWaitTask,
         modSwitch.tasks.setTargetVmAutoboot,
         common.tasks.waitTask,
diff --git a/lib/workflows/vm-migration/begin.js b/lib/workflows/vm-migration/begin.js
index 744b271..249d60c 100644
--- a/lib/workflows/vm-migration/begin.js
+++ b/lib/workflows/vm-migration/begin.js
@@ -191,6 +191,13 @@ function createProvisionPayload(job, cb) {
     // Mark as a migrating instance.
     vmPayload.do_not_inventory = true;
     vmPayload.vm_migration_target = true;
+    // We will later change the create timestamp, so remember when this
+    // instance was first created.
+    if (!vmPayload.internal_metadata) {
+        vmPayload.internal_metadata = {};
+    }
+    vmPayload.internal_metadata.vm_migration_create_timestamp =
+        (new Date()).toISOString();
 
     // Allow overriding the UUID and alias (which would be maintained
     // otherwise) for testing.
diff --git a/lib/workflows/vm-migration/common.js b/lib/workflows/vm-migration/common.js
index 11ca62b..e581ccf 100644
--- a/lib/workflows/vm-migration/common.js
+++ b/lib/workflows/vm-migration/common.js
@@ -40,8 +40,9 @@ function validate(job, cb) {
 
     var VALID_MIGRATION_ACTIONS = [
         'abort',
-        'pause',
         'begin',
+        'pause',
+        'rollback',
         'switch',
         'sync'
     ];
@@ -365,6 +366,40 @@ function setupCnapiTarget(job, cb) {
 }
 
 
+function setSourceVmAutoboot(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.object(job.params.vm, 'job.params.vm');
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var url = '/servers/' +
+        record.source_server_uuid + '/vms/' +
+        record.vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-autoboot',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: record.vm_uuid,
+        value: (job.params.vm.autoboot ? 'true' : 'false')
+    };
+
+    cnapi.post(url, payload, function _setAutobootCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
 /**
  * Set the record state to 'running'.
  */
@@ -448,6 +483,9 @@ function storeInitialRecord(job, cb) {
         case 'pause':
             message = 'pausing migration';
             break;
+        case 'rollback':
+            message = 'reverting migration';
+            break;
         case 'sync':
             message = 'syncing data';
             break;
@@ -625,7 +663,7 @@ function storeSuccess(job, cb) {
 
     if (action === 'abort') {
         record.state = 'aborted';
-    } else if (action === 'switch') {
+    } else if (action === 'switch' || action === 'rollback') {
         record.state = 'successful';
     } else if (record.automatic && (action === 'begin' || action === 'sync')) {
         record.state = 'running';
@@ -839,6 +877,16 @@ module.exports = {
                 restify: 'restify'
             }
         },
+        setSourceVmAutoboot: {
+            name: 'migration.rollback.setSourceVmAutoboot',
+            timeout: 300,
+            // retry: 1,
+            body: setSourceVmAutoboot,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
         storeFailure: {
             name: 'migration.storeFailure',
             timeout: 180,
diff --git a/lib/workflows/vm-migration/rollback.js b/lib/workflows/vm-migration/rollback.js
new file mode 100644
index 0000000..1b55390
--- /dev/null
+++ b/lib/workflows/vm-migration/rollback.js
@@ -0,0 +1,501 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var vasync = require('vasync');
+
+
+function ensureSourceVmHasDni(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    var url = '/servers/' +
+        record.source_server_uuid + '/vms/' +
+        record.vm_uuid + '?include_dni=true';
+
+    cnapi.get(url, function _cnapiGetSourceDniVmCb(err, req, res, vm) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!vm.do_not_inventory) {
+            cb('Source instance does not have the do_not_inventory flag');
+            return;
+        }
+
+        cb(null, 'OK - source instance exists and has do_not_inventory flag');
+    });
+}
+
+
+function stopTargetVm(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.equal(job.params.vm_uuid, record.target_vm_uuid,
+        'job.params.vm_uuid should be the same as record.target_vm_uuid');
+
+    job.workflow_job_uuid = null;
+
+    if (job.params.vm.state === 'stopped') {
+        cb(null, 'OK - target vm is stopped already');
+        return;
+    }
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 3,
+        message: 'stopping the instance',
+        phase: 'rollback',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    vasync.pipeline({funcs: [
+        function checkTargetVm(ctx, next) {
+            var cnapi = restify.createJsonClient({
+                url: cnapiUrl,
+                headers: {'x-request-id': job.params['x-request-id']}
+            });
+
+            var url = '/servers/' +
+                record.target_server_uuid + '/vms/' +
+                record.target_vm_uuid + '?include_dni=true';
+
+            cnapi.get(url, function _cnapiGetSourceDniVmCb(err, req, res, vm) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (vm.do_not_inventory) {
+                    // Target already has DNI set, remember that.
+                    job.params.migrationTask.targetAlreadyHasDNI = true;
+                    if (vm.state !== 'stopped') {
+                        next('Target has DNI, yet state is not stopped: ' +
+                            vm.state);
+                        return;
+                    }
+                }
+                next();
+            });
+        },
+
+        function stopVm(ctx, next) {
+            if (job.params.migrationTask.targetAlreadyHasDNI) {
+                next();
+                return;
+            }
+
+            var vmapi = new sdcClients.VMAPI({
+                log: job.log,
+                headers: {'x-request-id': job.params['x-request-id']},
+                url: vmapiUrl
+            });
+            vmapi.stopVm({uuid: job.params.vm_uuid}, function (err, body) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                // Set the workflow job uuid for the waitForWorkflowJob step.
+                job.workflow_job_uuid = body.job_uuid;
+                assert.uuid(job.workflow_job_uuid, 'job.workflow_job_uuid');
+
+                next(null, 'OK - target vm stop called, job uuid: ' +
+                    body.job_uuid);
+            });
+        }
+    ]}, cb);
+}
+
+
+function ensureTargetVmStopped(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    if (job.params.migrationTask.targetAlreadyHasDNI) {
+        cb(null, 'OK - target VM already has DNI set');
+        return;
+    }
+
+    var vmapi = new sdcClients.VMAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    vmapi.getVm({uuid: record.target_vm_uuid}, function (err, vm) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (vm.state !== 'stopped') {
+            cb(new Error('Vm is no longer stopped - state: ' + vm.state));
+            return;
+        }
+
+        // job.vmStooped is required by the reserveNetworkIps task.
+        job.vmStopped = vm;
+
+        cb(null, 'OK - target vm is stopped');
+    });
+}
+
+
+function setTargetDoNotInventory(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    if (job.params.migrationTask.targetAlreadyHasDNI) {
+        job.params.skip_zone_action = true;
+        cb(null, 'OK - target VM already has DNI set');
+        return;
+    }
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.target_vm_uuid + '/progress';
+    var event = {
+        current_progress: 25,
+        message: 'hiding the target instance',
+        phase: 'rollback',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Set DNI flag on the target instance.
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-do-not-inventory',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: record.target_vm_uuid,
+        value: 'true'
+    };
+
+    cnapi.post(url, payload, function _setDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function removeSourceDoNotInventory(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 85,
+        message: 'promoting the original instance',
+        phase: 'rollback',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Remove do-not-inventory status.
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var vmUuid = record.vm_uuid;
+
+    var url = '/servers/' + record.source_server_uuid + '/vms/' + vmUuid +
+        '/migrate';
+    var payload = {
+        action: 'set-do-not-inventory',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: vmUuid,
+        value: 'false'
+    };
+
+    cnapi.post(url, payload, function _remDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function updateVmServerUuid(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    // Don't need to do this if the vm uuid is different.
+    if (record.vm_uuid !== record.target_vm_uuid) {
+        cb(null, 'OK - vm_uuid is different on target server - skip');
+        return;
+    }
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/updateVmServerUuid';
+    var data = {
+        server_uuid: record.source_server_uuid
+    };
+
+    rawVmapi.post(url, data, function _updateVmServerUuidCb(err) {
+        if (err) {
+            job.log.error({err: err},
+                'Unable to rollback vm server_uuid: ' + err);
+            cb(err);
+            return;
+        }
+
+        cb(null, 'OK - updated vm server uuid');
+    });
+}
+
+
+function disableTargetVmAutoboot(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    if (job.params.vm.autoboot === false) {
+        job.params.skip_zone_action = true;
+        cb(null, 'OK - autoboot is already disabled');
+        return;
+    }
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-autoboot',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: record.target_vm_uuid,
+        value: 'false'
+    };
+
+    cnapi.post(url, payload, function _disableAutobootCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function deleteTargetDniVm(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 90,
+        message: 'removing the migrated instance',
+        phase: 'rollback',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Remove the target vm.
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '?include_dni=true';
+
+    cnapi.del(url, function _cnapiDelTargetDniVmCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        deleteTargetDniVm: {
+            name: 'migration.rollback.deleteTargetDniVm',
+            timeout: 180,
+            // retry: 1,
+            body: deleteTargetDniVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        disableTargetVmAutoboot: {
+            name: 'migration.rollback.disableTargetVmAutoboot',
+            timeout: 300,
+            // retry: 1,
+            body: disableTargetVmAutoboot,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        ensureSourceVmHasDni: {
+            name: 'migration.rollback.ensureSourceVmHasDni',
+            timeout: 180,
+            // retry: 1,
+            body: ensureSourceVmHasDni,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        ensureTargetVmStopped: {
+            name: 'migration.rollback.ensureTargetVmStopped',
+            timeout: 180,
+            // retry: 1,
+            body: ensureTargetVmStopped,
+            modules: {
+                assert: 'assert-plus',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        removeSourceDoNotInventory: {
+            name: 'migration.rollback.removeSourceDoNotInventory',
+            timeout: 300,
+            // retry: 1,
+            body: removeSourceDoNotInventory,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        setTargetDoNotInventory: {
+            name: 'migration.rollback.setTargetDoNotInventory',
+            timeout: 300,
+            // retry: 1,
+            body: setTargetDoNotInventory,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        stopTargetVm: {
+            name: 'migration.rollback.stopTargetVm',
+            timeout: 300,
+            // retry: 1,
+            body: stopTargetVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify',
+                sdcClients: 'sdc-clients',
+                vasync: 'vasync'
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/switch.js b/lib/workflows/vm-migration/switch.js
index 084285f..a62e1fd 100644
--- a/lib/workflows/vm-migration/switch.js
+++ b/lib/workflows/vm-migration/switch.js
@@ -15,7 +15,7 @@ var sdcClients = require('sdc-clients');
 var vasync = require('vasync');
 
 
-function stopVm(job, cb) {
+function stopSourceVm(job, cb) {
     if (job.params.vm.state === 'stopped') {
         job.workflow_job_uuid = null;
         cb(null, 'OK - vm is stopped already');
@@ -67,7 +67,7 @@ function stopVm(job, cb) {
 }
 
 
-function ensureVmStopped(job, cb) {
+function ensureSourceVmStopped(job, cb) {
     var vmapi = new sdcClients.VMAPI({
         headers: {'x-request-id': job.params['x-request-id']},
         url: vmapiUrl
@@ -85,7 +85,7 @@ function ensureVmStopped(job, cb) {
         }
 
         job.vmStopped = vm;
-        cb(null, 'OK - vm is stopped');
+        cb(null, 'OK - source vm is stopped');
     });
 }
 
@@ -163,6 +163,11 @@ function getRecord(job, cb) {
 
 
 function reserveNetworkIps(job, cb) {
+    if (job.params.migrationTask.targetAlreadyHasDNI) {
+        cb(null, 'OK - target VM already has DNI set');
+        return;
+    }
+
     // Send a progress event.
     var rawVmapi = restify.createJsonClient({
         log: job.log,
@@ -269,7 +274,8 @@ function reserveNetworkIps(job, cb) {
 
 
 function storeReservedNetworkIps(job, cb) {
-    if (job.migration_reserved_nics.length === 0) {
+    if (!Array.isArray(job.migration_reserved_nics) ||
+            job.migration_reserved_nics.length === 0) {
         cb(null, 'OK - no reserved IPS');
         return;
     }
@@ -396,6 +402,44 @@ function setupTargetFilesystem(job, cb) {
 }
 
 
+function disableSourceVmAutoboot(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    if (job.params.vm.autoboot === false) {
+        cb(null, 'OK - autoboot is already disabled');
+        return;
+    }
+
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var url = '/servers/' +
+        record.source_server_uuid + '/vms/' +
+        record.vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-autoboot',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: record.vm_uuid,
+        value: 'false'
+    };
+
+    cnapi.post(url, payload, function _disableAutobootCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
 function setTargetVmAutoboot(job, cb) {
     var record = job.params.migrationTask.record;
 
@@ -516,7 +560,7 @@ function updateVmServerUuid(job, cb) {
             return;
         }
 
-        cb(null, 'OK - sent reserverd network IP progress event');
+        cb(null, 'OK - updated vm server uuid');
     });
 }
 
@@ -791,11 +835,21 @@ function startSourceVm(job, cb) {
 
 module.exports = {
     tasks: {
-        ensureVmStopped: {
-            name: 'migration.switch.ensureVmStopped',
+        disableSourceVmAutoboot: {
+            name: 'migration.rollback.disableSourceVmAutoboot',
+            timeout: 300,
+            // retry: 1,
+            body: disableSourceVmAutoboot,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        ensureSourceVmStopped: {
+            name: 'migration.switch.ensureSourceVmStopped',
             timeout: 180,
             // retry: 1,
-            body: ensureVmStopped,
+            body: ensureSourceVmStopped,
             modules: {
                 sdcClients: 'sdc-clients'
             }
@@ -919,11 +973,11 @@ module.exports = {
                 sdcClients: 'sdc-clients'
             }
         },
-        stopVm: {
-            name: 'migration.switch.stopVm',
+        stopSourceVm: {
+            name: 'migration.switch.stopSourceVm',
             timeout: 300,
             // retry: 1,
-            body: stopVm,
+            body: stopSourceVm,
             modules: {
                 assert: 'assert-plus',
                 restify: 'restify',
diff --git a/package.json b/package.json
index ccaa4c6..2bfc24b 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "vmapi",
   "description": "VMs API",
-  "version": "9.8.12",
+  "version": "9.8.13",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/sapi_manifests/vmapi/template b/sapi_manifests/vmapi/template
index b8b3372..518028f 100644
--- a/sapi_manifests/vmapi/template
+++ b/sapi_manifests/vmapi/template
@@ -53,6 +53,7 @@
             "migrate-abort",
             "migrate-begin",
             "migrate-pause",
+            "migrate-rollback",
             "migrate-sync",
             "migrate-switch"
         ],
diff --git a/test/lib/migration.js b/test/lib/migration.js
index ec62c2d..f91e363 100644
--- a/test/lib/migration.js
+++ b/test/lib/migration.js
@@ -100,6 +100,7 @@ MigrationWatcher.prototype.start = function _migWatchStart() {
 
 function TestMigrationCfg(test, cfg) {
     var client;
+    var migrationRolledBack = false;
     var migrationStarted = false;
     var migrationSynced = false;
     var migrationSwitched = false;
@@ -1548,7 +1549,7 @@ function TestMigrationCfg(test, cfg) {
         }
     };
 
-    test.migration_full_finalize = function test_migration_full_finalize(t) {
+    test.migration_rollback = function test_migration_rollback(t) {
         if (!targetVm) {
             t.ok(false, 'Target VM was not migrated successfully');
             t.done();
@@ -1556,25 +1557,100 @@ function TestMigrationCfg(test, cfg) {
         }
 
         client.post({
-            path: format('/vms/%s?action=migrate&migration_action=finalize',
+            path: format('/vms/%s?action=migrate&migration_action=rollback',
                 targetVm.uuid)
-        }, function onMigrateFinalizeCb(err, req, res) {
-            common.ifError(t, err, 'no error from migration finalize call');
+        }, function onMigrateRollbackCb(err, req, res, body) {
+            common.ifError(t, err, 'no error from migration rollback call');
             if (!err) {
                 t.ok(res, 'should get a restify response object');
                 if (res) {
-                    t.equal(res.statusCode, 200,
-                        format('err.statusCode === 200, got %s',
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
                             res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'rollback',
+                            'phase should be rollback');
+                        t.equal(body.migration.state, 'running',
+                            'state should be running');
+                    }
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 20 * 60 // 20 minutes
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state,
+                            job) {
+                        common.ifError(t, jerr,
+                            'rollback should be successful');
+                        if (!jerr) {
+                            t.equal(state, 'succeeded',
+                                'Migration rollback job should succeed - ' +
+                                (state === 'succeeded' ? 'ok' :
+                                    getJobError(job)));
+                        }
+                        migrationRolledBack = (state === 'succeeded');
+                        t.done();
+                    });
+                    return;
                 }
             }
             t.done();
         });
     };
 
+    test.check_vmapi_state_after_rollback =
+            function test_check_vmapi_state_after_rollback(t) {
+        if (!migrationRolledBack) {
+            t.ok(false, 'Vm did not rollback successfully');
+            t.done();
+            return;
+        }
+
+        // The target vm should no longer be visible in vmapi. We use
+        // 'sync=true' to ensure vmapi (via cnapi) will use the most up-to-date
+        // information.
+        client.get({path: format('/vms/%s?sync=true', targetVm.uuid)},
+            onGetTargetVm);
+
+        function onGetTargetVm(err, req, res, vm) {
+            common.ifError(t, err, 'should not error fetching target vm');
+            if (res) {
+                t.equal(res.statusCode, 200,
+                    format('err.statusCode === 200, got %s', res.statusCode));
+            }
+            t.ok(vm, 'should get a vm object');
+            if (vm) {
+                // In the case of an override the vm should now be seen as
+                // destroyed, else the vm will be active, but the server_uuid
+                // will have changed.
+                if (migrationUuidOverride) {
+                    t.equal(vm.state, 'destroyed',
+                        'original vm should have state destroyed');
+                    t.equal(targetVm.server_uuid, vm.server_uuid,
+                        'vm server_uuid should be the same');
+                } else {
+                    t.equal(sourceVm.server_uuid, vm.server_uuid,
+                        'vm server_uuid should be the source server uuid');
+                    t.notEqual(targetVm.server_uuid, vm.server_uuid,
+                        'vm target server_uuid should be different');
+                }
+            }
+
+            t.done();
+        }
+    };
+
     test.cleanup = function test_cleanup(t) {
-        if (!targetVm) {
-            t.ok(false, 'target vm not found, cannot delete VM');
+        if (!sourceVm) {
+            t.ok(false, 'source vm not found, cannot delete VM');
             t.done();
             return;
         }
