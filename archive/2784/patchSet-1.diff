From 87245d4ff7c198f1454b343fe2c2acc615f08c50 Mon Sep 17 00:00:00 2001
From: Tim Kordas <tim.kordas@joyent.com>
Date: Fri, 13 Oct 2017 17:10:52 -0700
Subject: [PATCH] OS-6363 system went to dark side of moon for ~467 seconds

---
 usr/src/uts/common/fs/zfs/arc.c | 16 ++++++++++++++--
 usr/src/uts/common/os/kmem.c    | 12 ++++++++++--
 usr/src/uts/common/os/taskq.c   | 17 +++++++++++++++++
 usr/src/uts/common/os/vmem.c    |  2 +-
 usr/src/uts/common/sys/kmem.h   |  2 ++
 usr/src/uts/common/sys/taskq.h  |  2 ++
 6 files changed, 46 insertions(+), 5 deletions(-)

diff --git a/usr/src/uts/common/fs/zfs/arc.c b/usr/src/uts/common/fs/zfs/arc.c
index fe60c09daa..ab57f129b6 100644
--- a/usr/src/uts/common/fs/zfs/arc.c
+++ b/usr/src/uts/common/fs/zfs/arc.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2012, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc. All rights reserved.
  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
  * Copyright (c) 2014 by Saso Kiselkov. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
@@ -302,6 +302,9 @@ int zfs_arc_evict_batch_limit = 10;
 /* number of seconds before growing cache again */
 static int		arc_grow_retry = 60;
 
+/* number of seconds before attempting a kmem-cache-reap */
+static int		arc_kmem_cache_reap_retry = 1;
+
 /* shift of arc_c for calculating overflow limit in arc_get_data_impl */
 int		zfs_arc_overflow_shift = 3;
 
@@ -4047,6 +4050,10 @@ arc_kmem_reap_now(void)
 #endif
 #endif
 
+	// If a cache-reap is already active, don't schedule more.
+	if (kmem_cache_reap_active())
+		return;
+
 	for (i = 0; i < SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT; i++) {
 		if (zio_buf_cache[i] != prev_cache) {
 			prev_cache = zio_buf_cache[i];
@@ -4093,6 +4100,7 @@ static void
 arc_reclaim_thread(void *unused)
 {
 	hrtime_t		growtime = 0;
+	hrtime_t		kmem_reap_time = 0;
 	callb_cpr_t		cpr;
 
 	CALLB_CPR_INIT(&cpr, &arc_reclaim_lock, callb_generic_cpr, FTAG);
@@ -4136,7 +4144,11 @@ arc_reclaim_thread(void *unused)
 			 */
 			growtime = gethrtime() + SEC2NSEC(arc_grow_retry);
 
-			arc_kmem_reap_now();
+			if (gethrtime() >= kmem_reap_time) {
+				arc_kmem_reap_now();
+				kmem_reap_time = gethrtime() +
+				    SEC2NSEC(arc_kmem_cache_reap_retry);
+			}
 
 			/*
 			 * If we are still low on memory, shrink the ARC
diff --git a/usr/src/uts/common/os/kmem.c b/usr/src/uts/common/os/kmem.c
index 1243d0fbbf..ccb8936b1c 100644
--- a/usr/src/uts/common/os/kmem.c
+++ b/usr/src/uts/common/os/kmem.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2015 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2017 Joyent, Inc.  All rights reserved.
  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  */
@@ -3286,6 +3286,15 @@ kmem_cache_magazine_enable(kmem_cache_t *cp)
 
 }
 
+/*
+ * Allow our caller to determine if there are running reaps.
+ */
+boolean_t
+kmem_cache_reap_active(kmem_cache_t *cp)
+{
+	return (!taskq_empty(kmem_taskq));
+}
+
 /*
  * Reap (almost) everything right now.
  */
@@ -3298,7 +3307,6 @@ kmem_cache_reap_now(kmem_cache_t *cp)
 
 	(void) taskq_dispatch(kmem_taskq,
 	    (task_func_t *)kmem_depot_ws_reap, cp, TQ_SLEEP);
-	taskq_wait(kmem_taskq);
 }
 
 /*
diff --git a/usr/src/uts/common/os/taskq.c b/usr/src/uts/common/os/taskq.c
index 814b738581..0f0da13f59 100644
--- a/usr/src/uts/common/os/taskq.c
+++ b/usr/src/uts/common/os/taskq.c
@@ -26,6 +26,7 @@
 /*
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc. All rights reserved.
  */
 
 /*
@@ -1319,6 +1320,22 @@ taskq_dispatch_ent(taskq_t *tq, task_func_t func, void *arg, uint_t flags,
 	mutex_exit(&tq->tq_lock);
 }
 
+/*
+ * Allow our caller to ask if there are tasks pending on the queue.
+ */
+boolean_t
+taskq_empty(taskq_t *tq)
+{
+	boolean_t rv ;
+
+	ASSERT(tq != curthread->t_taskq);
+	mutex_enter(&tq->tq_lock);
+	rv = tq->tq_task.tqent_next == &tq->tq_task && tq->tq_active == 0;
+	mutex_exit(&tq->tq_lock);
+
+	return (rv);
+}
+
 /*
  * Wait for all pending tasks to complete.
  * Calling taskq_wait from a task will cause deadlock.
diff --git a/usr/src/uts/common/os/vmem.c b/usr/src/uts/common/os/vmem.c
index e3da4df247..15b4326edd 100644
--- a/usr/src/uts/common/os/vmem.c
+++ b/usr/src/uts/common/os/vmem.c
@@ -25,7 +25,7 @@
 
 /*
  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.
- * Copyright (c) 2012, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc. All rights reserved.
  */
 
 /*
diff --git a/usr/src/uts/common/sys/kmem.h b/usr/src/uts/common/sys/kmem.h
index e54d83e499..6a30b37bdb 100644
--- a/usr/src/uts/common/sys/kmem.h
+++ b/usr/src/uts/common/sys/kmem.h
@@ -23,6 +23,7 @@
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc. All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
@@ -128,6 +129,7 @@ extern void kmem_cache_destroy(kmem_cache_t *);
 extern void *kmem_cache_alloc(kmem_cache_t *, int);
 extern void kmem_cache_free(kmem_cache_t *, void *);
 extern uint64_t kmem_cache_stat(kmem_cache_t *, char *);
+extern boolean_t kmem_cache_reap_active(kmem_cache_t *);
 extern void kmem_cache_reap_now(kmem_cache_t *);
 extern void kmem_cache_move_notify(kmem_cache_t *, void *);
 
diff --git a/usr/src/uts/common/sys/taskq.h b/usr/src/uts/common/sys/taskq.h
index 7548149ef6..b7a3c53e0d 100644
--- a/usr/src/uts/common/sys/taskq.h
+++ b/usr/src/uts/common/sys/taskq.h
@@ -23,6 +23,7 @@
  * Use is subject to license terms.
  *
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc. All rights reserved.
  */
 
 #ifndef	_SYS_TASKQ_H
@@ -80,6 +81,7 @@ extern taskqid_t taskq_dispatch(taskq_t *, task_func_t, void *, uint_t);
 extern void	nulltask(void *);
 extern void	taskq_destroy(taskq_t *);
 extern void	taskq_wait(taskq_t *);
+extern boolean_t taskq_empty(taskq_t *);
 extern void	taskq_suspend(taskq_t *);
 extern int	taskq_suspended(taskq_t *);
 extern void	taskq_resume(taskq_t *);
-- 
2.21.0

