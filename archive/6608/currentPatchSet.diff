commit d3506a18a402a438bd40194ee0c9e2fa73dcc9e9
Author: Peter Marton <pmarton@netflix.com>
Date:   2019-07-16T12:03:57-07:00 (3 months ago)
    
    joyent/node-verror#63 Do not call sprintf with one argument
    Portions contributed by: David Pacheco <dap@joyent.com>

diff --git a/README.md b/README.md
index f1896df..338d4ce 100644
--- a/README.md
+++ b/README.md
@@ -22,6 +22,8 @@ The classes here are:
   top-level error.  This is useful for API endpoints where you don't want to
   expose internal error messages, but you still want to preserve the error chain
   for logging and debugging.
+* **PError**, which is just like VError but does not interpret printf-style
+  arguments at all.
 * **SError**, which is just like VError but interprets printf-style arguments
   more strictly.
 * **MultiError**, which is just an Error that encapsulates one or more other
@@ -207,11 +209,11 @@ supporting the complex case above, you can still just do:
 for the simple cases.
 
 
-# Reference: VError, WError, SError
+# Reference: VError, WError, PError, SError
 
-VError, WError, and SError are convenient drop-in replacements for `Error` that
-support printf-style arguments, first-class causes, informational properties,
-and other useful features.
+VError, WError, PError, and SError are convenient drop-in replacements for
+`Error` that support printf-style arguments, first-class causes, informational
+properties, and other useful features.
 
 
 ## Constructors
@@ -249,6 +251,7 @@ Option name      | Type             | Meaning
 `strict`         | boolean          | If true, then `null` and `undefined` values in `sprintf_args` are passed through to `sprintf()`.  Otherwise, these are replaced with the strings `'null'`, and '`undefined`', respectively.
 `constructorOpt` | function         | If specified, then the stack trace for this error ends at function `constructorOpt`.  Functions called by `constructorOpt` will not show up in the stack.  This is useful when this class is subclassed.
 `info`           | object           | Specifies arbitrary informational properties that are available through the `VError.info(err)` static class method.  See that method for details.
+`skipPrintf`     | boolean          | If true, then `sprintf()` is not called on the `sprintf_args` arguments.  Instead, the first argument is taken as a plain string to be used as this error's message.
 
 The second form is equivalent to using the first form with the specified `cause`
 as the error's cause.  This form is distinguished from the first form because
@@ -261,13 +264,15 @@ argument is not an object or an Error.
 The `WError` constructor is used exactly the same way as the `VError`
 constructor.  The `SError` constructor is also used the same way as the
 `VError` constructor except that in all cases, the `strict` property is
-overriden to `true.
+overridden to `true`.  Likewise, the `PError` constructor is used the same way
+as the `VError` constructor except that in all cases, the `skipPrintf`
+property is overridden to `true`.
 
 
 ## Public properties
 
-`VError`, `WError`, and `SError` all provide the same public properties as
-JavaScript's built-in Error objects.
+`VError`, `WError`, `PError`, and `SError` all provide the same public
+properties as JavaScript's built-in Error objects.
 
 Property name | Type   | Meaning
 ------------- | ------ | -------
@@ -275,11 +280,11 @@ Property name | Type   | Meaning
 `message`     | string | Human-readable summary of the failure.  Programmatically-accessible details are provided through `VError.info(err)` class method.
 `stack`       | string | Human-readable stack trace where the Error was constructed.
 
-For all of these classes, the printf-style arguments passed to the constructor
-are processed with `sprintf()` to form a message.  For `WError`, this becomes
-the complete `message` property.  For `SError` and `VError`, this message is
-prepended to the message of the cause, if any (with a suitable separator), and
-the result becomes the `message` property.
+For all of these classes except `PError`, the printf-style arguments passed to
+the constructor are processed with `sprintf()` to form a message.
+For `WError`, this becomes the complete `message` property.  For `SError` and
+`VError`, this message is prepended to the message of the cause, if any
+(with a suitable separator), and the result becomes the `message` property.
 
 The `stack` property is managed entirely by the underlying JavaScript
 implementation.  It's generally implemented using a getter function because
diff --git a/lib/verror.js b/lib/verror.js
index 8663dde..cb7da60 100644
--- a/lib/verror.js
+++ b/lib/verror.js
@@ -18,6 +18,7 @@ module.exports = VError;
 /* For compatibility */
 VError.VError = VError;
 /* Other exported classes */
+VError.PError = PError;
 VError.SError = SError;
 VError.WError = WError;
 VError.MultiError = MultiError;
@@ -27,7 +28,11 @@ VError.MultiError = MultiError;
  * SError.  Named arguments to this function:
  *
  *     strict		force strict interpretation of sprintf arguments, even
- *     			if the options in "argv" don't say so
+ *     			if the options in "argv" don't say so.  This cannot
+ *     			be specified with "skipPrintf".
+ *
+ *     skipPrintf	do not apply sprintf-style formatting to the arguments.
+ *     			This cannot be specified with "strict".
  *
  *     argv		error's constructor arguments, which are to be
  *     			interpreted as described in README.md.  For quick
@@ -55,6 +60,9 @@ function parseConstructorArguments(args)
 	mod_assertplus.object(args, 'args');
 	mod_assertplus.bool(args.strict, 'args.strict');
 	mod_assertplus.array(args.argv, 'args.argv');
+	mod_assertplus.bool(args.skipPrintf, 'args.skipPrintf');
+	mod_assertplus.ok(!(args.strict && args.skipPrintf),
+	    'cannot specify both "strict" and "skipPrintf"');
 	argv = args.argv;
 
 	/*
@@ -74,7 +82,7 @@ function parseConstructorArguments(args)
 		sprintf_args = argv.slice(1);
 	} else {
 		mod_assertplus.string(argv[0],
-		    'first argument to VError, SError, or WError ' +
+		    'first argument to VError, PError, SError, or WError ' +
 		    'constructor must be a string, object, or Error');
 		options = {};
 		sprintf_args = argv;
@@ -107,7 +115,7 @@ function parseConstructorArguments(args)
 	 * "strict" option to the VError constructor.
 	 */
 	mod_assertplus.object(options);
-	if (!options.strict && !args.strict) {
+	if (!options.skipPrintf && !options.strict && !args.strict) {
 		sprintf_args = sprintf_args.map(function (a) {
 			return (a === null ? 'null' :
 			    a === undefined ? 'undefined' : a);
@@ -116,10 +124,20 @@ function parseConstructorArguments(args)
 
 	if (sprintf_args.length === 0) {
 		shortmessage = '';
+	} else if (args.skipPrintf || options.skipPrintf) {
+		mod_assertplus.equal(sprintf_args.length, 1,
+			'only one argument is allowed with options.skipPrintf');
+		shortmessage = sprintf_args[0];
 	} else {
 		shortmessage = sprintf.apply(null, sprintf_args);
 	}
 
+	/*
+	 * Always set "skipPrintf" at this point so that callers within this
+	 * library can invoke the VError constructor directly with the short
+	 * message we've given them.
+	 */
+	options['skipPrintf'] = true;
 	return ({
 	    'options': options,
 	    'shortmessage': shortmessage
@@ -152,7 +170,8 @@ function VError()
 	 */
 	parsed = parseConstructorArguments({
 	    'argv': args,
-	    'strict': false
+	    'strict': false,
+	    'skipPrintf': false
 	});
 
 	/*
@@ -338,13 +357,47 @@ VError.errorForEach = function (err, func)
 };
 
 
+/*
+ * PError is like VError, but the message is not run through printf-style
+ * templating.
+ */
+function PError() {
+	var args, obj, parsed;
+
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof PError)) {
+		obj = Object.create(PError.prototype);
+		PError.apply(obj, args);
+		return (obj);
+	}
+
+	parsed = parseConstructorArguments({
+		'argv': args,
+		'strict': false,
+		'skipPrintf': true
+	});
+
+	/*
+	 * parseConstructorArguments sets skipPrintf precisely so we can invoke
+	 * the VError constructor as we do below.
+	 */
+	mod_assertplus.ok(parsed.options.skipPrintf);
+	VError.call(this, parsed.options, parsed.shortmessage);
+
+	return (this);
+}
+
+mod_util.inherits(PError, VError);
+PError.prototype.name = 'PError';
+
+
 /*
  * SError is like VError, but stricter about types.  You cannot pass "null" or
  * "undefined" as string arguments to the formatter.
  */
 function SError()
 {
-	var args, obj, parsed, options;
+	var args, obj, parsed;
 
 	args = Array.prototype.slice.call(arguments, 0);
 	if (!(this instanceof SError)) {
@@ -355,11 +408,15 @@ function SError()
 
 	parsed = parseConstructorArguments({
 	    'argv': args,
-	    'strict': true
+	    'strict': true,
+	    'skipPrintf': false
 	});
 
-	options = parsed.options;
-	VError.call(this, options, '%s', parsed.shortmessage);
+	/*
+	 * See PError().
+	 */
+	mod_assertplus.ok(parsed.options.skipPrintf);
+	VError.call(this, parsed.options, parsed.shortmessage);
 
 	return (this);
 }
@@ -402,7 +459,7 @@ MultiError.prototype.errors = function me_errors()
  */
 function WError()
 {
-	var args, obj, parsed, options;
+	var args, obj, parsed;
 
 	args = Array.prototype.slice.call(arguments, 0);
 	if (!(this instanceof WError)) {
@@ -413,12 +470,16 @@ function WError()
 
 	parsed = parseConstructorArguments({
 	    'argv': args,
-	    'strict': false
+	    'strict': false,
+	    'skipPrintf': false
 	});
 
-	options = parsed.options;
-	options['skipCauseMessage'] = true;
-	VError.call(this, options, '%s', parsed.shortmessage);
+	/*
+	 * See PError().
+	 */
+	mod_assertplus.ok(parsed.options.skipPrintf);
+	parsed.options['skipCauseMessage'] = true;
+	VError.call(this, parsed.options, parsed.shortmessage);
 
 	return (this);
 }
diff --git a/test/tst.common.js b/test/tst.common.js
index e0355d6..05f951a 100644
--- a/test/tst.common.js
+++ b/test/tst.common.js
@@ -7,6 +7,7 @@ var mod_assert = require('assert');
 var mod_verror = require('../lib/verror');
 var mod_testcommon = require('./common');
 
+var PError = mod_verror.PError;
 var SError = mod_verror.SError;
 var VError = mod_verror.VError;
 var WError = mod_verror.WError;
@@ -177,8 +178,24 @@ function runTests(cons, label)
 	    '    at runTests (dummy filename)',
 	    '    at Object.<anonymous> (dummy filename)'
 	].join('\n') + '\n' + nodestack);
+
+	/* disabling printf */
+	err = new cons({ 'skipPrintf': true }, '%s');
+	mod_assert.equal(err.message, '%s');
+	err = new cons({ 'skipPrintf': true });
+	mod_assert.equal(err.message, '');
+	mod_assert.throws(function () {
+		console.error(new cons({ 'skipPrintf': true }, '%s', 'foo'));
+	}, /only one argument is allowed with options.skipPrintf/);
+	err = new cons({ 'skipPrintf': false }, '%s', 'foo');
+	mod_assert.equal(err.message, 'foo');
+	err = new cons({ 'skipPrintf': null }, '%s', 'foo');
+	mod_assert.equal(err.message, 'foo');
+	err = new cons({ 'skipPrintf': undefined }, '%s', 'foo');
+	mod_assert.equal(err.message, 'foo');
 }
 
 runTests(VError, 'VError');
 runTests(WError, 'WError');
 runTests(SError, 'VError');
+runTests(PError, 'PError');
