commit 500f1fad15b9b0c101aa321744d375aef994faeb
Author: Jason King <jason.king@joyent.com>
Date:   2019-07-17T19:34:14+00:00 (3 months ago)
    
    OS-7839 pkcs11_softtoken C_DecryptFinal can fail with CKM_AES_CBC_PAD

diff --git a/usr/src/common/crypto/modes/modes.h b/usr/src/common/crypto/modes/modes.h
index 0ad18b0c25..b7d247cec1 100644
--- a/usr/src/common/crypto/modes/modes.h
+++ b/usr/src/common/crypto/modes/modes.h
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  *
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef	_COMMON_CRYPTO_MODES_H
@@ -51,6 +51,9 @@ extern "C" {
 #define	GMAC_MODE			0x00000040
 #define	CMAC_MODE			0x00000080
 
+/* Private flag for pkcs11_softtoken */
+#define	P11_DECRYPTED			0x80000000
+
 /*
  * cc_keysched:		Pointer to key schedule.
  *
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
index 7d27cdcddc..4aff7660c5 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright 2017 Jason King.
  */
 
@@ -349,7 +349,7 @@ soft_aes_encrypt(soft_session_t *session_p, CK_BYTE_PTR pData,
 		return (CKR_ARGUMENTS_BAD);
 	}
 
-	remainder = ulDataLen & (AES_BLOCK_LEN - 1);
+	remainder = ulDataLen % AES_BLOCK_LEN;
 
 	/*
 	 * CTR, CCM, CMAC, and GCM modes do not require the plaintext
@@ -372,23 +372,24 @@ soft_aes_encrypt(soft_session_t *session_p, CK_BYTE_PTR pData,
 		}
 	}
 
-	switch (aes_ctx->ac_flags & (CMAC_MODE|CCM_MODE|GCM_MODE)) {
-	case CCM_MODE:
+	switch (mech) {
+	case CKM_AES_CCM:
 		length_needed = ulDataLen + aes_ctx->ac_mac_len;
 		break;
-	case GCM_MODE:
+	case CKM_AES_GCM:
 		length_needed = ulDataLen + aes_ctx->ac_tag_len;
 		break;
-	case CMAC_MODE:
+	case CKM_AES_CMAC:
+	case CKM_AES_CMAC_GENERAL:
 		length_needed = AES_BLOCK_LEN;
 		break;
+	case CKM_AES_CBC_PAD:
+		/* CKM_AES_CBC_PAD always adds 1..AES_BLOCK_LEN of padding */
+		length_needed = ulDataLen + AES_BLOCK_LEN - remainder;
+		break;
 	default:
 		length_needed = ulDataLen;
-
-		/* CKM_AES_CBC_PAD out pads to a multiple of AES_BLOCK_LEN */
-		if (mech == CKM_AES_CBC_PAD) {
-			length_needed += AES_BLOCK_LEN - remainder;
-		}
+		break;
 	}
 
 	if (pEncryptedData == NULL) {
@@ -424,58 +425,82 @@ soft_aes_encrypt(soft_session_t *session_p, CK_BYTE_PTR pData,
 		out.cd_offset = *pulEncryptedDataLen;
 	}
 
-	/*
-	 * As CKM_AES_CTR is a stream cipher, ctr_mode_final is always
-	 * invoked in the _update() functions, so we do not need to call it
-	 * here.
-	 */
-	if (mech == CKM_AES_CBC_PAD) {
+	switch (mech) {
+	case CKM_AES_CBC_PAD: {
 		/*
 		 * aes_encrypt_contiguous_blocks() accumulates plaintext
-		 * in aes_ctx and then encrypts once it has accumulated
-		 * a multiple of AES_BLOCK_LEN bytes of plaintext (through one
-		 * or more calls).  Any leftover plaintext is left in aes_ctx
-		 * for subsequent calls.  If there is any remaining plaintext
-		 * at the end, we pad it out to to AES_BLOCK_LEN using the
-		 * amount of padding to add as the value of the pad bytes
-		 * (i.e. PKCS#7 padding) and call
-		 * aes_encrypt_contiguous_blocks() one last time.
+		 * in aes_ctx until it has at least one full block of
+		 * plaintext.  Any partial blocks of data remaining after
+		 * encrypting are left for subsequent calls to
+		 * aes_encrypt_contiguous_blocks().  If the input happened
+		 * to be an exact multiple of AES_BLOCK_LEN, we must still
+		 * append a block of padding (a full block in that case) so
+		 * that the correct amount of padding to remove is known
+		 * during decryption.
 		 *
-		 * Even when the input is already a multiple of AES_BLOCK_LEN,
-		 * we must add an additional full block so that we can determine
-		 * the amount of padding to remove during decryption (by
-		 * examining the last byte of the decrypted ciphertext).
+		 * soft_add_pkcs7_padding() is a bit overkill -- we just
+		 * create a block filled with the pad amount using memset(),
+		 * and encrypt 'amt' bytes of the block to pad out the input.
 		 */
-		size_t amt = AES_BLOCK_LEN - remainder;
 		char block[AES_BLOCK_LEN];
+		size_t amt = AES_BLOCK_LEN - remainder;
 
-		ASSERT3U(remainder, ==, aes_ctx->ac_remainder_len);
-		ASSERT3U(amt + remainder, ==, AES_BLOCK_LEN);
+		VERIFY3U(remainder, ==, aes_ctx->ac_remainder_len);
 
-		/*
-		 * The existing soft_add_pkcs7_padding() interface is
-		 * overkill for what is effectively a memset().  A better
-		 * RFE would be to create a CBC_PAD mode.
-		 */
 		(void) memset(block, amt & 0xff, sizeof (block));
 		rc = aes_encrypt_contiguous_blocks(aes_ctx, block, amt, &out);
-	} else if (aes_ctx->ac_flags & CCM_MODE) {
+		rv = crypto2pkcs11_error_number(rc);
+		explicit_bzero(block, sizeof (block));
+		break;
+	}
+	case CKM_AES_CCM:
 		rc = ccm_encrypt_final((ccm_ctx_t *)aes_ctx, &out,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);
-	} else if (aes_ctx->ac_flags & GCM_MODE) {
+		rv = crypto2pkcs11_error_number(rc);
+		break;
+	case CKM_AES_GCM:
 		rc = gcm_encrypt_final((gcm_ctx_t *)aes_ctx, &out,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,
 		    aes_xor_block);
-	} else if (aes_ctx->ac_flags & CMAC_MODE) {
+		rv = crypto2pkcs11_error_number(rc);
+		break;
+	case CKM_AES_CMAC:
+	case CKM_AES_CMAC_GENERAL:
 		rc = cmac_mode_final((cbc_ctx_t *)aes_ctx, &out,
 		    aes_encrypt_block, aes_xor_block);
+		rv = crypto2pkcs11_error_number(rc);
 		aes_ctx->ac_remainder_len = 0;
+		break;
+	case CKM_AES_CTR:
+		/*
+		 * As CKM_AES_CTR is a stream cipher, ctr_mode_final is always
+		 * invoked in the xx_update() functions, so we do not need to
+		 * call it again here.
+		 */
+		break;
+	case CKM_AES_ECB:
+	case CKM_AES_CBC:
+		/*
+		 * These mechanisms do not have nor require a xx_final function.
+		 */
+		break;
+	default:
+		rv = CKR_MECHANISM_INVALID;
+		break;
 	}
 
 cleanup:
-	if (rc != CRYPTO_SUCCESS && rv == CKR_OK) {
+	switch (rv) {
+	case CKR_OK:
+		*pulEncryptedDataLen = out.cd_offset;
+		break;
+	case CKR_BUFFER_TOO_SMALL:
+		/* *pulEncryptedDataLen was set earlier */
+		break;
+	default:
+		/* something else failed */
 		*pulEncryptedDataLen = 0;
-		rv = crypto2pkcs11_error_number(rc);
+		break;
 	}
 
 	(void) pthread_mutex_lock(&session_p->session_mutex);
@@ -483,8 +508,124 @@ cleanup:
 	session_p->encrypt.context = NULL;
 	(void) pthread_mutex_unlock(&session_p->session_mutex);
 
-	if (rv == CKR_OK) {
-		*pulEncryptedDataLen = out.cd_offset;
+	return (rv);
+}
+
+static CK_RV
+soft_aes_cbc_pad_decrypt(aes_ctx_t *aes_ctx, CK_BYTE_PTR pEncryptedData,
+    CK_ULONG ulEncryptedDataLen, crypto_data_t *out_orig)
+{
+	aes_ctx_t *ctx = aes_ctx;
+	uint8_t *buf = NULL;
+	uint8_t *outbuf = (uint8_t *)out_orig->cd_raw.iov_base;
+	crypto_data_t out = *out_orig;
+	size_t i;
+	int rc;
+	CK_RV rv = CKR_OK;
+	uint8_t pad_len;
+	boolean_t speculate = B_FALSE;
+
+	/*
+	 * Just a query for the output size.  When the output buffer is
+	 * NULL, we are allowed to return a size slightly larger than
+	 * necessary.  We know the output will never be larger than the
+	 * input ciphertext, so we use that as an estimate.
+	 */
+	if (out_orig->cd_raw.iov_base == NULL) {
+		out_orig->cd_length = ulEncryptedDataLen;
+		return (CKR_OK);
+	}
+
+	/*
+	 * The output plaintext size will be 1..AES_BLOCK_LEN bytes
+	 * smaller than the input ciphertext.  However we cannot know
+	 * exactly how much smaller until we decrypt the entire
+	 * input ciphertext.  If we are unsure we have enough output buffer
+	 * space, we have to allocate our own memory to hold the output,
+	 * then see if we have enough room to hold the result.
+	 *
+	 * Unfortunately, having an output buffer that's too small does
+	 * not terminate the operation, nor are we allowed to return
+	 * partial results.  Therefore we must also duplicate the initial
+	 * aes_ctx so that this can potentially be run again.
+	 */
+	if (out_orig->cd_length < ulEncryptedDataLen) {
+		void *ks = malloc(aes_ctx->ac_keysched_len);
+
+		ctx = malloc(sizeof (*aes_ctx));
+		buf = malloc(ulEncryptedDataLen);
+		if (ks == NULL || ctx == NULL || buf == NULL) {
+			free(ks);
+			free(ctx);
+			free(buf);
+			return (CKR_HOST_MEMORY);
+		}
+
+		bcopy(aes_ctx, ctx, sizeof (*ctx));
+		bcopy(aes_ctx->ac_keysched, ks, aes_ctx->ac_keysched_len);
+		ctx->ac_keysched = ks;
+
+		out.cd_length = ulEncryptedDataLen;
+		out.cd_raw.iov_base = (char *)buf;
+		out.cd_raw.iov_len = ulEncryptedDataLen;
+		outbuf = buf;
+
+		speculate = B_TRUE;
+	}
+
+	rc = aes_decrypt_contiguous_blocks(ctx, (char *)pEncryptedData,
+	    ulEncryptedDataLen, &out);
+	if (rc != CRYPTO_SUCCESS) {
+		out_orig->cd_offset = 0;
+		rv = CKR_FUNCTION_FAILED;
+		goto done;
+	}
+
+	/*
+	 * RFC5652 6.3 The amount of padding must be
+	 * block_sz - (len mod block_size).  This means
+	 * the amount of padding must always be in the
+	 * range [1..block_size].
+	 */
+	pad_len = outbuf[ulEncryptedDataLen - 1];
+	if (pad_len == 0 || pad_len > AES_BLOCK_LEN) {
+		rv = CKR_ENCRYPTED_DATA_INVALID;
+		goto done;
+	}
+	out.cd_offset -= pad_len;
+
+	/*
+	 * Verify pad values, trying to do so in as close to constant
+	 * time as possible.
+	 */
+	for (i = ulEncryptedDataLen - pad_len; i < ulEncryptedDataLen; i++) {
+		if (outbuf[i] != pad_len) {
+			rv = CKR_ENCRYPTED_DATA_INVALID;
+		}
+	}
+	if (rv != CKR_OK) {
+		goto done;
+	}
+
+	if (speculate) {
+		if (out.cd_offset <= out_orig->cd_length) {
+			bcopy(out.cd_raw.iov_base, out_orig->cd_raw.iov_base,
+			    out.cd_offset);
+		} else {
+			rv = CKR_BUFFER_TOO_SMALL;
+		}
+	}
+
+	/*
+	 * No matter what, we report the exact size required.
+	 */
+	out_orig->cd_offset = out.cd_offset;
+
+done:
+	freezero(buf, ulEncryptedDataLen);
+	if (ctx != aes_ctx) {
+		VERIFY(speculate);
+		soft_aes_free_ctx(ctx);
 	}
 
 	return (rv);
@@ -518,7 +659,7 @@ soft_aes_decrypt(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 		return (CKR_ARGUMENTS_BAD);
 	}
 
-	remainder = ulEncryptedDataLen & (AES_BLOCK_LEN - 1);
+	remainder = ulEncryptedDataLen % AES_BLOCK_LEN;
 
 	/*
 	 * CTR, CCM, CMAC, and GCM modes do not require the ciphertext
@@ -540,6 +681,16 @@ soft_aes_decrypt(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 		}
 	}
 
+	if (mech == CKM_AES_CBC_PAD) {
+		rv = soft_aes_cbc_pad_decrypt(aes_ctx, pEncryptedData,
+		    ulEncryptedDataLen, &out);
+		if (pData == NULL || rv == CKR_BUFFER_TOO_SMALL) {
+			*pulDataLen = out.cd_offset;
+			return (rv);
+		}
+		goto cleanup;
+	}
+
 	switch (aes_ctx->ac_flags & (CCM_MODE|GCM_MODE)) {
 	case CCM_MODE:
 		length_needed = aes_ctx->ac_processed_data_len;
@@ -614,9 +765,7 @@ soft_aes_decrypt(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 	 * invoked in the _update() functions, so we do not need to call it
 	 * here.
 	 */
-	if (mech == CKM_AES_CBC_PAD) {
-		rv = soft_remove_pkcs7_padding(pData, *pulDataLen, pulDataLen);
-	} else if (aes_ctx->ac_flags & CCM_MODE) {
+	if (aes_ctx->ac_flags & CCM_MODE) {
 		ASSERT3U(aes_ctx->ac_processed_data_len, ==,
 		    aes_ctx->ac_data_len);
 		ASSERT3U(aes_ctx->ac_processed_mac_len, ==,
@@ -625,19 +774,18 @@ soft_aes_decrypt(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 		rc = ccm_decrypt_final((ccm_ctx_t *)aes_ctx, &out,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,
 		    aes_xor_block);
+		rv = crypto2pkcs11_error_number(rc);
 	} else if (aes_ctx->ac_flags & GCM_MODE) {
 		rc = gcm_decrypt_final((gcm_ctx_t *)aes_ctx, &out,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);
-	}
-
-cleanup:
-	if (rc != CRYPTO_SUCCESS && rv == CKR_OK) {
 		rv = crypto2pkcs11_error_number(rc);
-		*pulDataLen = 0;
 	}
 
+cleanup:
 	if (rv == CKR_OK) {
 		*pulDataLen = out.cd_offset;
+	} else {
+		*pulDataLen = 0;
 	}
 
 	(void) pthread_mutex_lock(&session_p->session_mutex);
@@ -667,24 +815,7 @@ soft_aes_encrypt_update(soft_session_t *session_p, CK_BYTE_PTR pData,
 	int rc;
 
 	/* Check size of the output buffer */
-	if (mech == CKM_AES_CBC_PAD && (out_len <= AES_BLOCK_LEN)) {
-		/*
-		 * Since there is currently no CBC_PAD mode, we must stash any
-		 * remainder ourselves.  For all other modes,
-		 * aes_encrypt_contiguous_blocks() will call the mode specific
-		 * encrypt function and will stash any reminder if required.
-		 */
-		if (pData != NULL) {
-			uint8_t *dest = (uint8_t *)aes_ctx->ac_remainder +
-			    aes_ctx->ac_remainder_len;
-
-			bcopy(pData, dest, ulDataLen);
-			aes_ctx->ac_remainder_len += ulDataLen;
-		}
-
-		*pulEncryptedDataLen = 0;
-		return (CKR_OK);
-	} else if (aes_ctx->ac_flags & CMAC_MODE) {
+	if (aes_ctx->ac_flags & CMAC_MODE) {
 		/*
 		 * The underlying CMAC implementation handles the storing of
 		 * extra bytes and does not output any data until *_final,
@@ -725,8 +856,7 @@ soft_aes_encrypt_update(soft_session_t *session_p, CK_BYTE_PTR pData,
 	*pulEncryptedDataLen = out.cd_offset;
 
 	if (rc != CRYPTO_SUCCESS) {
-		rv = CKR_FUNCTION_FAILED;
-		goto done;
+		return (CKR_FUNCTION_FAILED);
 	}
 
 	/*
@@ -738,11 +868,7 @@ soft_aes_encrypt_update(soft_session_t *session_p, CK_BYTE_PTR pData,
 		rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &out,
 		    aes_encrypt_block);
 	}
-
-done:
-	if (rc != CRYPTO_SUCCESS && rv == CKR_OK) {
-		rv = crypto2pkcs11_error_number(rc);
-	}
+	rv = crypto2pkcs11_error_number(rc);
 
 	return (rv);
 }
@@ -761,21 +887,39 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 	};
 	CK_MECHANISM_TYPE mech = session_p->decrypt.mech.mechanism;
 	CK_RV rv = CKR_OK;
-	size_t out_len = 0;
+	size_t out_len;
 	int rc = CRYPTO_SUCCESS;
 
-	if ((aes_ctx->ac_flags & (CCM_MODE|GCM_MODE)) == 0) {
+	switch (mech) {
+	case CKM_AES_CCM:
+	case CKM_AES_GCM:
+		out_len = 0;
+		break;
+	case CKM_AES_CBC_PAD:
 		out_len = aes_ctx->ac_remainder_len + ulEncryptedDataLen;
-
-		if (mech == CKM_AES_CBC_PAD && out_len <= AES_BLOCK_LEN) {
+		/*
+		 * Since we cannot know which data is the final block
+		 * of data until C_DecryptFinal() is called, we must
+		 * always buffer the most recent full block of
+		 * ciphertext.  Once C_DecryptFinal() is called, we should
+		 * have a full block of ciphertext buffered that we can
+		 * decrypt and remove the padding.
+		 */
+		if (out_len <= AES_BLOCK_LEN) {
 			uint8_t *dest = (uint8_t *)aes_ctx->ac_remainder +
 			    aes_ctx->ac_remainder_len;
 
 			bcopy(pEncryptedData, dest, ulEncryptedDataLen);
 			aes_ctx->ac_remainder_len += ulEncryptedDataLen;
+			*pulDataLen = 0;
 			return (CKR_OK);
 		}
 		out_len &= ~(AES_BLOCK_LEN - 1);
+		break;
+	default:
+		out_len = aes_ctx->ac_remainder_len + ulEncryptedDataLen;
+		out_len &= ~(AES_BLOCK_LEN - 1);
+		break;
 	}
 
 	if (pData == NULL) {
@@ -801,13 +945,10 @@ soft_aes_decrypt_update(soft_session_t *session_p, CK_BYTE_PTR pEncryptedData,
 	if ((aes_ctx->ac_flags & CTR_MODE) && (aes_ctx->ac_remainder_len > 0)) {
 		rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &out,
 		    aes_encrypt_block);
-	}
-
-done:
-	if (rc != CRYPTO_SUCCESS && rv == CKR_OK) {
 		rv = crypto2pkcs11_error_number(rc);
 	}
 
+done:
 	return (rv);
 }
 
@@ -823,60 +964,104 @@ soft_aes_encrypt_final(soft_session_t *session_p,
 		.cd_raw.iov_base = (char *)pLastEncryptedPart,
 		.cd_raw.iov_len = *pulLastEncryptedPartLen
 	};
-	int rc = CRYPTO_SUCCESS;
+	CK_MECHANISM_TYPE mech = session_p->encrypt.mech.mechanism;
 	CK_RV rv = CKR_OK;
+	size_t out_len;
+	int rc = CRYPTO_SUCCESS;
+
+	switch (mech) {
+	case CKM_AES_CBC_PAD:
+		/*
+		 * We always add 1..AES_BLOCK_LEN of padding to the input
+		 * plaintext to round up to a multiple of AES_BLOCK_LEN.
+		 * During encryption, we never output a partially encrypted
+		 * block (that is the amount encrypted by each call of
+		 * C_EncryptUpdate() is always either 0 or n * AES_BLOCK_LEN).
+		 * As a result, at the end of the encryption operation, we
+		 * output AES_BLOCK_LEN bytes of data -- this could be a full
+		 * block of padding, or a combination of data + padding.
+		 */
+		out_len = AES_BLOCK_LEN;
+		break;
+	case CKM_AES_CTR:
+		out_len = aes_ctx->ac_remainder_len;
+		break;
+	case CKM_AES_CCM:
+		out_len = aes_ctx->ac_remainder_len +
+		    aes_ctx->acu.acu_ccm.ccm_mac_len;
+		break;
+	case CKM_AES_GCM:
+		out_len = aes_ctx->ac_remainder_len +
+		    aes_ctx->acu.acu_gcm.gcm_tag_len;
+		break;
+	case CKM_AES_CMAC:
+	case CKM_AES_CMAC_GENERAL:
+		out_len = AES_BLOCK_LEN;
+		break;
+	default:
+		/*
+		 * Everything other AES mechansism requires full blocks of
+		 * input.  If the input was not an exact multiple of
+		 * AES_BLOCK_LEN, it is a fatal error.
+		 */
+		if (aes_ctx->ac_remainder_len > 0) {
+			rv = CKR_DATA_LEN_RANGE;
+			goto done;
+		}
+		out_len = 0;
+	}
 
-	if (session_p->encrypt.mech.mechanism == CKM_AES_CBC_PAD) {
+	if (*pulLastEncryptedPartLen < out_len || pLastEncryptedPart == NULL) {
+		*pulLastEncryptedPartLen = out_len;
+		return ((pLastEncryptedPart == NULL) ?
+		    CKR_OK : CKR_BUFFER_TOO_SMALL);
+	}
+
+	switch (mech) {
+	case CKM_AES_CBC_PAD: {
 		char block[AES_BLOCK_LEN] = { 0 };
 		size_t padlen = AES_BLOCK_LEN - aes_ctx->ac_remainder_len;
 
-		(void) memset(block, padlen & 0xff, sizeof (block));
-		if (padlen > 0) {
-			rc = aes_encrypt_contiguous_blocks(aes_ctx, block,
-			    padlen, &data);
-		}
-	} else if (aes_ctx->ac_flags & CTR_MODE) {
-		if (pLastEncryptedPart == NULL) {
-			*pulLastEncryptedPartLen = aes_ctx->ac_remainder_len;
-			return (CKR_OK);
+		if (padlen == 0) {
+			padlen = AES_BLOCK_LEN;
 		}
 
-		if (aes_ctx->ac_remainder_len > 0) {
-			rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &data,
-			    aes_encrypt_block);
-			if (rc == CRYPTO_BUFFER_TOO_SMALL) {
-				rv = CKR_BUFFER_TOO_SMALL;
-			}
+		(void) memset(block, padlen & 0xff, sizeof (block));
+		rc = aes_encrypt_contiguous_blocks(aes_ctx, block,
+		    padlen, &data);
+		explicit_bzero(block, sizeof (block));
+		break;
+	}
+	case CKM_AES_CTR:
+		if (aes_ctx->ac_remainder_len == 0) {
+			break;
 		}
-	} else if (aes_ctx->ac_flags & CCM_MODE) {
+
+		rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &data,
+		    aes_encrypt_block);
+		break;
+	case CKM_AES_CCM:
 		rc = ccm_encrypt_final((ccm_ctx_t *)aes_ctx, &data,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);
-	} else if (aes_ctx->ac_flags & GCM_MODE) {
+		break;
+	case CKM_AES_GCM:
 		rc = gcm_encrypt_final((gcm_ctx_t *)aes_ctx, &data,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,
 		    aes_xor_block);
-	} else if (aes_ctx->ac_flags & CMAC_MODE) {
-		if (pLastEncryptedPart == NULL) {
-			*pulLastEncryptedPartLen = AES_BLOCK_LEN;
-			return (CKR_OK);
-		}
-
+		break;
+	case CKM_AES_CMAC:
+	case CKM_AES_CMAC_GENERAL:
 		rc = cmac_mode_final((cbc_ctx_t *)aes_ctx, &data,
 		    aes_encrypt_block, aes_xor_block);
-	} else {
-		/*
-		 * There must be no unprocessed plaintext.
-		 * This happens if the length of the last data is not a
-		 * multiple of the AES block length.
-		 */
-		*pulLastEncryptedPartLen = 0;
-		if (aes_ctx->ac_remainder_len > 0) {
-			rv = CKR_DATA_LEN_RANGE;
-		}
+		break;
+	default:
+		break;
 	}
+	rv = crypto2pkcs11_error_number(rc);
 
-	if (rc != CRYPTO_SUCCESS && rv == CKR_OK) {
-		rv = crypto2pkcs11_error_number(rc);
+done:
+	if (rv == CKR_OK) {
+		*pulLastEncryptedPartLen = data.cd_offset;
 	}
 
 	soft_aes_free_ctx(aes_ctx);
@@ -892,6 +1077,7 @@ soft_aes_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 	CK_MECHANISM_TYPE mech = session_p->decrypt.mech.mechanism;
 	CK_RV rv = CKR_OK;
 	int rc = CRYPTO_SUCCESS;
+	size_t out_len;
 	crypto_data_t out = {
 		.cd_format = CRYPTO_DATA_RAW,
 		.cd_offset = 0,
@@ -900,93 +1086,154 @@ soft_aes_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 		.cd_raw.iov_len = *pulLastPartLen
 	};
 
-	if (aes_ctx->ac_remainder_len > 0) {
-		switch (mech) {
-		case CKM_AES_CBC_PAD:
-			/*
-			 * Since we cannot know the amount of padding present
-			 * until after we decrypt the final block, and since
-			 * we don't know which block is the last block until
-			 * C_DecryptFinal() is called, we must always defer
-			 * decrypting the most recent block of ciphertext
-			 * until C_DecryptFinal() is called.  As a consequence,
-			 * we should always have a remainder, and it should
-			 * always be equal to AES_BLOCK_LEN.
-			 */
+	switch (mech) {
+	case CKM_AES_CBC_PAD:
+		/*
+		 * PKCS#11 requires that a caller can discover the size of
+		 * the output buffer required by calling
+		 * C_DecryptFinal(hSession, NULL, &len) which sets
+		 * *pulLastPartLen to the size required.  However, it also
+		 * allows if one calls C_DecryptFinal with a buffer (i.e.
+		 * pLastPart != NULL) that is too small, to return
+		 * CKR_BUFFER_TOO_SMALL with *pulLastPartLen set to the
+		 * _exact_ size required (when pLastPart is NULL, the
+		 * implementation is allowed to set a 'sightly' larger
+		 * value than is strictly necessary.  In either case, the
+		 * caller is allowed to retry the operation (the operation
+		 * is not terminated).
+		 *
+		 * With PKCS#7 padding, we cannot determine the exact size of
+		 * the output until we decrypt the final block.  As such, the
+		 * first time for a given decrypt operation we are called,
+		 * we decrypt the final block and stash it in the aes_ctx
+		 * remainder block.  On any subsequent calls in the
+		 * current decrypt operation, we then can use the decrypted
+		 * block as necessary to provide the correct semantics.
+		 *
+		 * The cleanup of aes_ctx when the operation terminates
+		 * will take care of clearing out aes_ctx->ac_remainder_len.
+		 */
+		if ((aes_ctx->ac_flags & P11_DECRYPTED) == 0) {
+			uint8_t block[AES_BLOCK_LEN] = { 0 };
+			crypto_data_t block_out = {
+				.cd_format = CRYPTO_DATA_RAW,
+				.cd_offset = 0,
+				.cd_length = sizeof (block),
+				.cd_raw.iov_base = (char *)block,
+				.cd_raw.iov_len = sizeof (block)
+			};
+			size_t amt, i;
+			uint8_t pad_len;
+
 			if (aes_ctx->ac_remainder_len != AES_BLOCK_LEN) {
-				return (CKR_ENCRYPTED_DATA_LEN_RANGE);
+				return (CKR_DATA_LEN_RANGE);
 			}
 
-			if (*pulLastPartLen < AES_BLOCK_LEN) {
-				*pulLastPartLen = AES_BLOCK_LEN;
-				return (CKR_BUFFER_TOO_SMALL);
+			rc = aes_decrypt_contiguous_blocks(aes_ctx,
+			    (char *)block, 0, &block_out);
+			if (rc != CRYPTO_SUCCESS) {
+				explicit_bzero(block, sizeof (block));
+				return (CKR_FUNCTION_FAILED);
 			}
 
-			rc = aes_decrypt_contiguous_blocks(aes_ctx,
-			    (char *)pLastPart, AES_BLOCK_LEN, &out);
+			pad_len = block[AES_BLOCK_LEN - 1];
 
-			if (rc != CRYPTO_SUCCESS) {
-				break;
+			/*
+			 * RFC5652 6.3 The amount of padding must be
+			 * block_sz - (len mod block_size).  This means
+			 * the amount of padding must always be in the
+			 * range [1..block_size].
+			 */
+			if (pad_len == 0 || pad_len > AES_BLOCK_LEN) {
+				rv = CKR_ENCRYPTED_DATA_INVALID;
+				explicit_bzero(block, sizeof (block));
+				goto done;
 			}
+			amt = AES_BLOCK_LEN - pad_len;
 
-			rv = soft_remove_pkcs7_padding(pLastPart, AES_BLOCK_LEN,
-			    pulLastPartLen);
-			break;
-		case CKM_AES_CTR:
-			rc = ctr_mode_final((ctr_ctx_t *)aes_ctx, &out,
-			    aes_encrypt_block);
-			break;
-		default:
-			/* There must be no unprocessed ciphertext */
-			return (CKR_ENCRYPTED_DATA_LEN_RANGE);
+			/*
+			 * Verify the padding is correct.  Try to do so
+			 * in as constant a time as possible.
+			 */
+			for (i = amt; i < AES_BLOCK_LEN; i++) {
+				if (block[i] != pad_len) {
+					rv = CKR_ENCRYPTED_DATA_INVALID;
+				}
+			}
+			if (rv != CKR_OK) {
+				explicit_bzero(block, sizeof (block));
+				goto done;
+			}
+
+			bcopy(block, aes_ctx->ac_remainder, amt);
+			explicit_bzero(block, sizeof (block));
+
+			aes_ctx->ac_flags |= P11_DECRYPTED;
+			aes_ctx->ac_remainder_len = amt;
 		}
-	} else {
+
+		out_len = aes_ctx->ac_remainder_len;
+		break;
+	case CKM_AES_CTR:
+		out_len = aes_ctx->ac_remainder_len;
+		break;
+	case CKM_AES_CCM:
+		out_len = aes_ctx->ac_data_len;
+		break;
+	case CKM_AES_GCM:
+		out_len = aes_ctx->acu.acu_gcm.gcm_processed_data_len -
+		    aes_ctx->acu.acu_gcm.gcm_tag_len;
+		break;
+	default:
 		/*
-		 * We should never have no remainder for AES_CBC_PAD -- see
-		 * above.
+		 * The remaining mechanims require an exact multiple of
+		 * AES_BLOCK_LEN of ciphertext.  Any other value is an error.
 		 */
-		ASSERT3U(mech, !=, CKM_AES_CBC_PAD);
+		if (aes_ctx->ac_remainder_len > 0) {
+			rv = CKR_DATA_LEN_RANGE;
+			goto done;
+		}
+		out_len = 0;
+		break;
 	}
 
-	if (aes_ctx->ac_flags & CCM_MODE) {
-		size_t pt_len = aes_ctx->ac_data_len;
+	if (*pulLastPartLen < out_len || pLastPart == NULL) {
+		*pulLastPartLen = out_len;
+		return ((pLastPart == NULL) ? CKR_OK : CKR_BUFFER_TOO_SMALL);
+	}
 
-		if (*pulLastPartLen < pt_len) {
-			*pulLastPartLen = pt_len;
-			return (CKR_BUFFER_TOO_SMALL);
+	switch (mech) {
+	case CKM_AES_CBC_PAD:
+		*pulLastPartLen = out_len;
+		if (out_len == 0) {
+			break;
 		}
-
-		ASSERT3U(aes_ctx->ac_processed_data_len, ==, pt_len);
+		bcopy(aes_ctx->ac_remainder, pLastPart, out_len);
+		out.cd_offset += out_len;
+		break;
+	case CKM_AES_CCM:
+		ASSERT3U(aes_ctx->ac_processed_data_len, ==, out_len);
 		ASSERT3U(aes_ctx->ac_processed_mac_len, ==,
 		    aes_ctx->ac_mac_len);
 
 		rc = ccm_decrypt_final((ccm_ctx_t *)aes_ctx, &out,
 		    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,
 		    aes_xor_block);
-
-		if (rc != CRYPTO_SUCCESS) {
-			*pulLastPartLen = out.cd_offset;
-		}
-	} else if (aes_ctx->ac_flags & GCM_MODE) {
-		gcm_ctx_t *gcm_ctx = (gcm_ctx_t *)aes_ctx;
-		size_t pt_len = gcm_ctx->gcm_processed_data_len -
-		    gcm_ctx->gcm_tag_len;
-
-		if (*pulLastPartLen < pt_len) {
-			*pulLastPartLen = pt_len;
-			return (CKR_BUFFER_TOO_SMALL);
-		}
-
-		rc = gcm_decrypt_final(gcm_ctx, &out, AES_BLOCK_LEN,
-		    aes_encrypt_block, aes_xor_block);
-
-		if (rc != CRYPTO_SUCCESS) {
-			*pulLastPartLen = out.cd_offset;
-		}
+		break;
+	case CKM_AES_GCM:
+		rc = gcm_decrypt_final((gcm_ctx_t *)aes_ctx, &out,
+		    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);
+		break;
+	default:
+		break;
 	}
 
-	if (rv == CKR_OK && rc != CRYPTO_SUCCESS) {
-		rv = crypto2pkcs11_error_number(rc);
+	VERIFY3U(out.cd_offset, ==, out_len);
+	rv = crypto2pkcs11_error_number(rc);
+
+done:
+	if (rv == CKR_OK) {
+		*pulLastPartLen = out.cd_offset;
 	}
 
 	soft_aes_free_ctx(aes_ctx);
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/Makefile
index a58f77eb94..cd1e6a9b66 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/Makefile
@@ -12,10 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 .PARALLEL: $(SUBDIRS)
 
-SUBDIRS = cbc ccm cmac ctr ecb gcm
+SUBDIRS = cbc cbc_pad ccm cmac ctr ecb gcm
 
 include $(SRC)/test/Makefile.com
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/Makefile.subdirs b/usr/src/test/crypto-tests/tests/modes/aes/Makefile.subdirs
index 4678b6c7f8..f94bee509d 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/Makefile.subdirs
+++ b/usr/src/test/crypto-tests/tests/modes/aes/Makefile.subdirs
@@ -12,48 +12,44 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 include $(SRC)/cmd/Makefile.cmd
 include $(SRC)/test/Makefile.com
 include $(SRC)/cmd/Makefile.ctf
 
-CRYPTO = pkcs kcf
 PROGS_32 = $(CRYPTO:%=$(BASEPROG)_32_%)
 PROGS_64 = $(CRYPTO:%=$(BASEPROG)_64_%)
 PROGS = $(PROGS_32) $(PROGS_64)
-PROGS_pkcs = $(BASEPROG:%=%_32_pkcs) $(BASEPROG:%=%_64_pkcs)
-PROGS_kcf = $(BASEPROG:%=%_32_kcf) $(BASEPROG:%=%_64_kcf)
+$(CRYPTO_pkcs)PROGS_pkcs = $(BASEPROG:%=%_32_pkcs) $(BASEPROG:%=%_64_pkcs)
+$(CRYPTO_kcf)PROGS_kcf = $(BASEPROG:%=%_32_kcf) $(BASEPROG:%=%_64_kcf)
 
 ROOTOPTPKG = $(ROOT)/opt/crypto-tests
 TESTROOT = $(ROOTOPTPKG)/tests/aes
-TESTDIR_pkcs = $(TESTROOT)/pkcs
-TESTDIR_kcf = $(TESTROOT)/kcf
+$(CRYPTO_pkcs)TESTDIR_pkcs = $(TESTROOT)/pkcs
+$(CRYPTO_kcf)TESTDIR_kcf = $(TESTROOT)/kcf
 
 COMMONDIR = ../../../common
 $(PROGS_32)	:= OBJS += $(COMMONDIR)/testfuncs.32.o
 $(PROGS_64)	:= OBJS += $(COMMONDIR)/testfuncs.64.o
 $(PROGS_32)	:= OBJS += $(BASEPROG:%=%.32.o)
 $(PROGS_64)	:= OBJS += $(BASEPROG:%=%.64.o)
-$(BASEPROG)_32_pkcs	:= OBJS += $(COMMONDIR)/cryptotest_pkcs.32.o
-$(BASEPROG)_64_pkcs	:= OBJS += $(COMMONDIR)/cryptotest_pkcs.64.o
-$(BASEPROG)_32_kcf	:= OBJS += $(COMMONDIR)/cryptotest_kcf.32.o
-$(BASEPROG)_64_kcf	:= OBJS += $(COMMONDIR)/cryptotest_kcf.64.o
+$(CRYPTO_pkcs)$(BASEPROG)_32_pkcs	:= OBJS += $(COMMONDIR)/cryptotest_pkcs.32.o
+$(CRYPTO_pkcs)$(BASEPROG)_64_pkcs	:= OBJS += $(COMMONDIR)/cryptotest_pkcs.64.o
+$(CRYPTO_kcf)$(BASEPROG)_32_kcf	:= OBJS += $(COMMONDIR)/cryptotest_kcf.32.o
+$(CRYPTO_kcf)$(BASEPROG)_64_kcf	:= OBJS += $(COMMONDIR)/cryptotest_kcf.64.o
 
-$(PROGS_pkcs)	:= LDLIBS += -lpkcs11 -lcryptoutil
+$(CRYPTO_pkcs)$(PROGS_pkcs)	:= LDLIBS += -lpkcs11 -lcryptoutil
 
 CSTD = $(CSTD_GNU99)
 
-CMDS_pkcs = $(PROGS_pkcs:%_pkcs=$(TESTDIR_pkcs)/%)
-CMDS_kcf = $(PROGS_kcf:%_kcf=$(TESTDIR_kcf)/%)
+$(CRYPTO_pkcs)CMDS_pkcs = $(PROGS_pkcs:%_pkcs=$(TESTDIR_pkcs)/%)
+$(CRYPTO_kcf)CMDS_kcf = $(PROGS_kcf:%_kcf=$(TESTDIR_kcf)/%)
 CMDS = $(CMDS_pkcs) $(CMDS_kcf)
 
 $(CMDS) := FILEMODE = 0555
 
-LINTFLAGS += -xerroff=E_NAME_USED_NOT_DEF2
-LINTFLAGS += -xerroff=E_NAME_DEF_NOT_USED2
-
 CPPFLAGS += -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
 CPPFLAGS += -I$(COMMONDIR) -I$(SRC)/common/crypto/
 
@@ -83,17 +79,8 @@ all: $(PROGS)
 	$(COMPILE64.c) -o $@ $<
 	$(POST_PROCESS_O)
 
-	echo $(CMDS_kcf)
-
 install: all $(CMDS)
 
-lint: $(CRYPTO:%=lint_%)
-
-lint_pkcs:
-	$(LINT.c) $(OBJS_PKCS_23:%.o=%.c) $(LDLIBS) $(PKCSLIBS)
-
-lint_kcf:
-	$(LINT.c) $(OBJS_KCF_32:%.o=%.c) $(LDLIBS)
 clobber: clean
 	-$(RM) $(PROGS)
 
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/cbc/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/cbc/Makefile
index e7e36b988c..a0ac134243 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/cbc/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/cbc/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_cbc
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/Makefile
new file mode 100644
index 0000000000..feb36928a3
--- /dev/null
+++ b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/Makefile
@@ -0,0 +1,26 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2012 by Delphix. All rights reserved.
+# Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
+#
+
+BASEPROG = aes_cbc_pad
+
+# Currently, the cbc_pad mechanism is only present in PKCS#11 and
+# not KCF, so we do not create _kcf test binaries.
+CRYPTO = pkcs
+CRYPTO_kcf = $(POUND_SIGN)
+
+include $(SRC)/cmd/Makefile.cmd
+include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.c b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.c
new file mode 100644
index 0000000000..1cdcafedf2
--- /dev/null
+++ b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.c
@@ -0,0 +1,77 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2016 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * The illumos KCF does not currently support CKM_AES_CBC_PAD (it
+ * requires the consumer to explicitly add/remove padding), so there is
+ * no SUN_CKM_xxx symbol.
+ */
+#define	CBC_PAD	"CKM_AES_CBC_PAD"
+
+#include <aes/aes_impl.h>
+#include <stdio.h>
+
+#include "cryptotest.h"
+#include "aes_cbc_pad.h"
+
+int
+main(void)
+{
+	int errs = 0;
+	int i;
+	uint8_t N[1024];
+	cryptotest_t args;
+
+	args.out = N;
+
+	args.outlen = sizeof (N);
+	args.plen = AES_BLOCK_LEN;
+
+	args.mechname = CBC_PAD;
+	args.updatelen = 1;
+
+
+	for (i = 0; i < sizeof (RES) / sizeof (RES[0]); i++) {
+		args.in = DATA[i];
+		args.key = KEY[i];
+		args.param = IV[i];
+
+		args.inlen = DATALEN[i];
+		args.keylen = KEYLEN[i];
+
+		errs += run_test(&args, RES[i], RESLEN[i], ENCR_FG);
+		(void) fprintf(stderr, "----------\n");
+	}
+
+	(void) fprintf(stderr, "\t\t\t=== decrypt ===\n----------\n\n");
+
+	for (i = 0; i < sizeof (RES) / sizeof (RES[0]); i++) {
+		args.in = RES[i];
+		args.key = KEY[i];
+		args.param = IV[i];
+
+		args.inlen = RESLEN[i];
+		args.keylen = KEYLEN[i];
+
+		errs += run_test(&args, DATA[i], DATALEN[i], DECR_FG);
+		(void) fprintf(stderr, "----------\n");
+	}
+
+	if (errs != 0)
+		(void) fprintf(stderr, "%d tests failed\n", errs);
+
+	return (errs);
+}
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.h b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.h
new file mode 100644
index 0000000000..bbf33857e2
--- /dev/null
+++ b/usr/src/test/crypto-tests/tests/modes/aes/cbc_pad/aes_cbc_pad.h
@@ -0,0 +1,260 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#ifndef _AES_CBC_PAD_H
+#define	_AES_CBC_PAD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A search for test vectors that included PKCS7 padding has proven
+ * unsuccessful.  Instead, a few of the test aes_cbc test vectors
+ * were used as a starting point, adding extra data to the xx_DATA[]
+ * arrays to test padding.
+ *
+ * To compute the xx_RES[] (encrypted) values, openssl on an machine
+ * running macOS Mojave was used.
+ */
+
+static uint8_t CBC_PAD1_KEY[16] = {
+	0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
+	0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06,
+};
+static uint8_t CBC_PAD1_IV[16] = {
+	0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
+	0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41,
+};
+static uint8_t CBC_PAD1_DATA[] = {
+	'S', 'i', 'n', 'g', 'l', 'e', ' ', 'b',
+	'l', 'o', 'c', 'k', ' ', 'm', 's', 'g',
+};
+
+static uint8_t CBC_PAD1_RES[] = {
+	0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
+	0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a,
+
+	0xb9, 0x7c, 0x82, 0x5e, 0x1c, 0x78, 0x51, 0x46,
+	0x54, 0x2d, 0x39, 0x69, 0x41, 0xbc, 0xe5, 0x5d
+};
+
+
+static uint8_t CBC_PAD2_KEY[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a,
+};
+static uint8_t CBC_PAD2_IV[] = {
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+	0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58,
+};
+static uint8_t CBC_PAD2_DATA[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+};
+
+static uint8_t CBC_PAD2_RES[] = {
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1,
+
+	0xbc, 0xfd, 0x81, 0x02, 0x22, 0x02, 0x36, 0x6b,
+	0xde, 0x6d, 0xd2, 0x60, 0xa1, 0x58, 0x41, 0xa1
+};
+
+
+static uint8_t CBC_PAD3_KEY[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a,
+};
+static uint8_t CBC_PAD3_IV[] = {
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+	0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58,
+};
+
+static uint8_t CBC_PAD3_DATA[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+
+	0x00,
+};
+
+static uint8_t CBC_PAD3_RES[] = {
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1,
+
+	0xde, 0xf6, 0x23, 0xa9, 0xc6, 0xf5, 0xc6, 0xb9,
+	0x56, 0x14, 0x49, 0x60, 0xb2, 0x3d, 0x2f, 0x7f
+};
+
+
+static uint8_t CBC_PAD4_KEY[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a,
+};
+
+static uint8_t CBC_PAD4_IV[] = {
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+	0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58,
+};
+
+static uint8_t CBC_PAD4_DATA[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+
+	0x00, 0x01,
+};
+
+static uint8_t CBC_PAD4_RES[] = {
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1,
+
+	0x30, 0xce, 0x1d, 0xd5, 0xd1, 0xb3, 0x0e, 0xde,
+	0x59, 0x9c, 0x3b, 0x31, 0x1b, 0x62, 0xf0, 0x23
+};
+
+
+static uint8_t CBC_PAD5_KEY[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a,
+};
+
+static uint8_t CBC_PAD5_IV[] = {
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+	0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58,
+};
+
+static uint8_t CBC_PAD5_DATA[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
+};
+
+static uint8_t CBC_PAD5_RES[] = {
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1,
+
+	0xd3, 0x1c, 0x5a, 0x9d, 0xc4, 0x37, 0xa7, 0x7a,
+	0x74, 0xca, 0xb3, 0x69, 0x2b, 0x7b, 0x1f, 0xad
+};
+
+
+static uint8_t CBC_PAD6_KEY[] = {
+	0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
+	0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a,
+};
+
+static uint8_t CBC_PAD6_IV[] = {
+	0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
+	0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58,
+};
+
+static uint8_t CBC_PAD6_DATA[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+};
+
+static uint8_t CBC_PAD6_RES[] = {
+	0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
+	0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
+
+	0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
+	0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1,
+
+	0x79, 0x33, 0x83, 0xff, 0x4a, 0x64, 0x9d, 0xe3,
+	0x4d, 0x6f, 0x19, 0x94, 0x28, 0x7d, 0x65, 0x67
+};
+
+uint8_t *DATA[] = {
+	CBC_PAD1_DATA, CBC_PAD2_DATA, CBC_PAD3_DATA,
+	CBC_PAD4_DATA, CBC_PAD5_DATA, CBC_PAD6_DATA,
+};
+
+size_t DATALEN[] = {
+	sizeof (CBC_PAD1_DATA), sizeof (CBC_PAD2_DATA),
+	sizeof (CBC_PAD3_DATA), sizeof (CBC_PAD4_DATA),
+	sizeof (CBC_PAD5_DATA), sizeof (CBC_PAD6_DATA),
+};
+
+uint8_t *KEY[] = {
+	CBC_PAD1_KEY, CBC_PAD2_KEY, CBC_PAD3_KEY,
+	CBC_PAD4_KEY, CBC_PAD5_KEY, CBC_PAD6_KEY,
+};
+
+size_t KEYLEN[] = {
+	sizeof (CBC_PAD1_KEY), sizeof (CBC_PAD2_KEY),
+	sizeof (CBC_PAD3_KEY), sizeof (CBC_PAD4_KEY),
+	sizeof (CBC_PAD5_KEY), sizeof (CBC_PAD6_KEY),
+};
+
+uint8_t *IV[] = {
+	CBC_PAD1_IV, CBC_PAD2_IV, CBC_PAD3_IV,
+	CBC_PAD4_IV, CBC_PAD5_IV, CBC_PAD6_IV,
+};
+
+size_t IVLEN[] = {
+	sizeof (CBC_PAD1_IV), sizeof (CBC_PAD2_IV),
+	sizeof (CBC_PAD3_IV), sizeof (CBC_PAD4_IV),
+	sizeof (CBC_PAD5_IV), sizeof (CBC_PAD6_IV),
+};
+
+uint8_t *RES[] = {
+	CBC_PAD1_RES, CBC_PAD2_RES, CBC_PAD3_RES,
+	CBC_PAD4_RES, CBC_PAD5_RES, CBC_PAD6_RES,
+};
+
+size_t RESLEN[] = {
+	sizeof (CBC_PAD1_RES), sizeof (CBC_PAD2_RES),
+	sizeof (CBC_PAD3_RES), sizeof (CBC_PAD4_RES),
+	sizeof (CBC_PAD5_RES), sizeof (CBC_PAD6_RES),
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _AES_CBC_PAD_H */
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/ccm/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/ccm/Makefile
index ab91c27fda..204deed70c 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/ccm/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/ccm/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_ccm
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/cmac/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/cmac/Makefile
index 4c99aad1b6..c989c9068c 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/cmac/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/cmac/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_cmac
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/ctr/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/ctr/Makefile
index adc2a9cb52..e19dfe4215 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/ctr/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/ctr/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_ctr
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/ecb/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/ecb/Makefile
index d413f18329..ce4b90115b 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/ecb/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/ecb/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_ecb
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
diff --git a/usr/src/test/crypto-tests/tests/modes/aes/gcm/Makefile b/usr/src/test/crypto-tests/tests/modes/aes/gcm/Makefile
index 2cef165155..bd33defb96 100644
--- a/usr/src/test/crypto-tests/tests/modes/aes/gcm/Makefile
+++ b/usr/src/test/crypto-tests/tests/modes/aes/gcm/Makefile
@@ -12,9 +12,11 @@
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 
 BASEPROG = aes_gcm
+CRYPTO = pkcs kcf
 
 include $(SRC)/cmd/Makefile.cmd
 include ../Makefile.subdirs
