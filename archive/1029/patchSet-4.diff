From 91be5d19077c75600357a2d2998ec72ba6948029 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <jwilsdon@joyent.com>
Date: Wed, 1 Feb 2017 15:05:19 -0800
Subject: [PATCH] AGENT-1049 vm-agent blows up when VM is deleted while loading

---
 lib/vm-agent.js | 81 +++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 65 insertions(+), 16 deletions(-)

diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index ee5dd4c..6c507bd 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -262,21 +262,66 @@ VmAgent.prototype.updateVmapiVm = function updateVmapiVm(vmUuid, callback) {
                         loadErr.restCode = 'VmNotInventoriable';
                         self.log.warn({vmUuid: _vmUuid},
                             'ignoring deleted VM with do_not_inventory');
-                        next(loadErr);
-                        return;
-                    }
-
-                    // We need the VM to have been seen either when it was
-                    // created, or when we initially started up. Otherwise, we
-                    // don't have the VM object to post to VMAPI.
-                    assert.ok(self.lastSeenVms.hasOwnProperty(_vmUuid),
-                        'VM ' + _vmUuid + ' not seen before');
+                    } else if (self.lastSeenVms.hasOwnProperty(_vmUuid)) {
+                        //
+                        // We need the VM to have been seen either when it was
+                        // created, or when we initially started up. Otherwise,
+                        // we don't have the VM object to post to VMAPI. If we
+                        // don't have a VM object we can't tell VMAPI anything
+                        // about this VM.
+                        //
+                        // There are two known cases where we can get into this
+                        // situation. Both involve the VM being deleted soon
+                        // after creation, while we're still trying to load it.
+                        //
+                        // Case 1) Destroy job through the APIs
+                        //
+                        // In this case, a Destroy was sent soon after a Create
+                        // and somehow we were unable to load the new VM
+                        // (possibly missed sysevent delayed our noticing the
+                        // VM) before it had been destroyed. In this scenario,
+                        // the Destroy job if it succeeded should have marked
+                        // the VM as destroyed in VMAPI. So the fact that we
+                        // can't do that will only matter in the case the
+                        // destroy job had a bug.
+                        //
+                        // Case 2) Destroy happened locally via vmadm or similar
+                        //
+                        // In this case a VM was destroyed manually by an
+                        // operator without using the APIs and we could not load
+                        // the VM after creation but before the VM was
+                        // destroyed.
+                        //
+                        // If this VM was created through the APIs, the Operator
+                        // is working outside the system by deleting it and is
+                        // therefore also responsible for ensuring VMAPI data
+                        // makes sense. If we hit this case, the operator can do
+                        // a:
+                        //
+                        //  GET /vms?sync=true
+                        //
+                        // on VMAPI to fix the inconsistency they caused.
+                        //
+                        // Alternatively, if the VM was created manually by the
+                        // operator without the APIs (e.g. vmadm create) and
+                        // disappeared before we were able to load it, it should
+                        // never have been in VMAPI anyway, so there's no point
+                        // in trying to update VMAPI about it. The only way
+                        // manually created VMs get to VMAPI is if we notice
+                        // them and notify VMAPI.
+                        //
+                        self.lastSeenVms[_vmUuid].state = 'destroyed';
+                        self.lastSeenVms[_vmUuid].zone_state = 'destroyed';
+                        stash.vmobj = self.lastSeenVms[_vmUuid];
+                    } else {
+                        self.log.warn({vmUuid: _vmUuid}, 'no VM object for VM '
+                            + _vmUuid + ' and no longer exists.');
 
-                    self.lastSeenVms[_vmUuid].state = 'destroyed';
-                    self.lastSeenVms[_vmUuid].zone_state = 'destroyed';
-                    stash.vmobj = self.lastSeenVms[_vmUuid];
+                        loadErr = new Error('VM no longer exists');
+                        loadErr.restCode = 'VmMissed';
+                    }
 
-                    next();
+                    next(loadErr);
                     return;
                 }
 
@@ -351,8 +396,12 @@ VmAgent.prototype.updateVmapiVm = function updateVmapiVm(vmUuid, callback) {
     ]}, function _updateVmComplete(err) {
         var ignore = false;
 
-        // We don't sent updates for VMs that have do_not_inventory set
-        if (err && err.restCode === 'VmNotInventoriable') {
+        // We don't sent updates for VMs that have do_not_inventory set or which
+        // disappeared while loading.
+        if (err && [
+            'VmMissed',
+            'VmNotInventoriable'
+        ].indexOf(err.restCode) !== -1) {
             ignore = true;
         }
 
-- 
2.21.0

