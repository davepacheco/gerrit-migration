commit 59616277cb6796289d8e391a0a086472be6d31b2 (refs/changes/29/1029/6)
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2017-02-01T15:26:09-08:00 (2 years, 8 months ago)
    
    AGENT-1049 vm-agent blows up when VM is deleted while loading

diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index ee5dd4c..4aa4c4a 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -262,21 +262,91 @@ VmAgent.prototype.updateVmapiVm = function updateVmapiVm(vmUuid, callback) {
                         loadErr.restCode = 'VmNotInventoriable';
                         self.log.warn({vmUuid: _vmUuid},
                             'ignoring deleted VM with do_not_inventory');
-                        next(loadErr);
-                        return;
-                    }
-
-                    // We need the VM to have been seen either when it was
-                    // created, or when we initially started up. Otherwise, we
-                    // don't have the VM object to post to VMAPI.
-                    assert.ok(self.lastSeenVms.hasOwnProperty(_vmUuid),
-                        'VM ' + _vmUuid + ' not seen before');
+                    } else if (self.lastSeenVms.hasOwnProperty(_vmUuid)) {
+                        //
+                        // We need the VM to have been seen either when it was
+                        // created, or when we initially started up. Otherwise,
+                        // we don't have the VM object to post to VMAPI. If we
+                        // don't have a VM object we can't tell VMAPI anything
+                        // about this VM.
+                        //
+                        // There are two known cases where we can get into this
+                        // situation. Both involve the VM being deleted soon
+                        // after creation, while we're still trying to load it.
+                        //
+                        // If we hit either of these cases, an operator can do
+                        // a:
+                        //
+                        //  GET /vms?sync=true
+                        //
+                        // on VMAPI to fix any inconsistency.
+                        //
+                        //
+                        // Case 1) Destroy job through the APIs
+                        //
+                        // In this case, a Destroy was sent soon after a Create
+                        // and somehow we were unable to load the new VM
+                        // (possibly missed sysevent delayed our noticing the
+                        // VM) before it had been destroyed. In this scenario,
+                        // the Destroy job if it succeeded should have marked
+                        // the VM as destroyed in VMAPI. So the fact that we
+                        // can't do that will only matter in the case the
+                        // destroy job had a bug.
+                        //
+                        //
+                        // Case 2) Destroy happened locally via vmadm or similar
+                        //
+                        // In this case a VM was destroyed manually by an
+                        // operator without using the APIs and we could not load
+                        // the VM after creation but before the VM was
+                        // destroyed.
+                        //
+                        // If this VM was created through the APIs, the Operator
+                        // is working outside the system by deleting it and is
+                        // therefore also responsible for ensuring VMAPI data
+                        // makes sense.
+                        //
+                        // Alternatively, if the VM was created manually by the
+                        // operator without the APIs (e.g. vmadm create) and
+                        // disappeared before we were able to load it, it should
+                        // never have been in VMAPI anyway, so there's no point
+                        // in trying to update VMAPI about it. The only way
+                        // manually created VMs get to VMAPI is if we notice
+                        // them and notify VMAPI.
+                        //
+                        //
+                        // The reason we won't update VMAPI in either of these
+                        // cases is that the way we update VMAPI is by doing a
+                        // PUT on the VM which replaces all existing fields.
+                        // Since our load failed, the only information we have
+                        // about the VM is:
+                        //
+                        //  * the uuid
+                        //  * the server_uuid
+                        //  * the fact that it was destroyed
+                        //
+                        // If VMAPI has any more information than we do
+                        // (importantly owner_uuid, billing_id, etc) we don't
+                        // want to wipe that information out (since we don't
+                        // have it to include in our PUT). The most benefit we
+                        // would get from the PUT in this case is setting the
+                        // state to destroyed, but that should already happen
+                        // unless there are bugs or manual intervention as
+                        // outlined above. As such, we ignore the VM here and
+                        // leave the state update to other processes.
+                        //
+                        self.lastSeenVms[_vmUuid].state = 'destroyed';
+                        self.lastSeenVms[_vmUuid].zone_state = 'destroyed';
+                        stash.vmobj = self.lastSeenVms[_vmUuid];
+                    } else {
+                        self.log.warn({vmUuid: _vmUuid}, 'no VM object for VM '
+                            + _vmUuid + ' and no longer exists.');
 
-                    self.lastSeenVms[_vmUuid].state = 'destroyed';
-                    self.lastSeenVms[_vmUuid].zone_state = 'destroyed';
-                    stash.vmobj = self.lastSeenVms[_vmUuid];
+                        loadErr = new Error('VM no longer exists');
+                        loadErr.restCode = 'VmCreationMissed';
+                    }
 
-                    next();
+                    next(loadErr);
                     return;
                 }
 
@@ -351,8 +421,12 @@ VmAgent.prototype.updateVmapiVm = function updateVmapiVm(vmUuid, callback) {
     ]}, function _updateVmComplete(err) {
         var ignore = false;
 
-        // We don't sent updates for VMs that have do_not_inventory set
-        if (err && err.restCode === 'VmNotInventoriable') {
+        // We don't sent updates for VMs that have do_not_inventory set or which
+        // disappeared while loading.
+        if (err && [
+            'VmCreationMissed',
+            'VmNotInventoriable'
+        ].indexOf(err.restCode) !== -1) {
             ignore = true;
         }
 
