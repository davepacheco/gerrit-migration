commit b14c6a858b0781717d651beb7a4d6e2a6fa332e1 (refs/changes/01/3801/4)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-04-10T21:07:54-07:00 (1 year, 6 months ago)
    
    joyent/node-sshpk-agent#12 Simplify protocol parser code
    joyent/node-sshpk-agent#13 Add support for "extension" messages from draft-miller-ssh-agent

diff --git a/lib/protocol-streams.js b/lib/protocol-streams.js
index d1f33d4..b42a67c 100644
--- a/lib/protocol-streams.js
+++ b/lib/protocol-streams.js
@@ -10,6 +10,7 @@ if (process.version.match(/^v0[.]1[0-1][.]/))
 var protocol = require('./protocol');
 var errs = require('./errors');
 var AgentProtocolError = errs.AgentProtocolError;
+var SSHBuffer = require('./ssh-buffer');
 
 function AgentEncodeStream(opts) {
 	assert.object(opts, 'options');
@@ -17,16 +18,16 @@ function AgentEncodeStream(opts) {
 	this.role = opts.role.toLowerCase();
 	switch (this.role) {
 	case 'agent':
-		this.frameDefs = protocol.clientFrames;
+		this.convert = protocol.writeAgentFrame;
 		break;
 	case 'client':
-		this.frameDefs = protocol.agentFrames;
+		this.convert = protocol.writeClientFrame;
 		break;
 	default:
 		/* assert below will fail */
 		break;
 	}
-	assert.object(this.frameDefs, 'frame defs for role ' + this.role);
+	assert.func(this.convert, 'convert func for role ' + this.role);
 
 	opts.readableObjectMode = false;
 	opts.writableObjectMode = true;
@@ -36,71 +37,16 @@ util.inherits(AgentEncodeStream, stream.Transform);
 
 AgentEncodeStream.prototype._transform = function (obj, enc, cb) {
 	assert.object(obj);
-	var err, i;
 
-	var def = this.frameDefs[obj.type.toLowerCase()];
-	if (def === undefined) {
-		err = new AgentProtocolError(obj, 'unknown frame type: ' +
-		    obj.type);
-		cb(err);
-		return;
-	}
-
-	/* length prefix + frame id */
-	var len = 4 + 1;
-	var argdef, v;
-	for (i = 0; i < def.args.length; ++i) {
-		argdef = def.args[i];
-		v = obj[argdef.name];
-		if (v === undefined) {
-			err = new AgentProtocolError(obj, 'missing ' +
-			    'argument to ' + def.name + ': ' + argdef.name);
-			cb(err);
-			return;
-		}
-
-		try {
-			len += argdef.type.encodeSize(v);
-		} catch (e) {
-			err = new AgentProtocolError(obj, 'argument ' +
-			    argdef.name + ' to ' + def.name + ' is invalid: ' +
-			    e.message);
-			cb(err);
-			return;
-		}
-	}
-
-	var frame = new Buffer(len);
-	var offset = 0;
-
-	frame.writeUInt32BE(len - 4, 0);
-	offset += 4;
-	frame[offset++] = def.id;
-
-	for (i = 0; i < def.args.length; ++i) {
-		argdef = def.args[i];
-		v = obj[argdef.name];
-
-		try {
-			offset = argdef.type.encode(v, frame, offset);
-		} catch (e) {
-			err = new AgentProtocolError(obj, 'argument ' +
-			    argdef.name + ' to ' + def.name + ' is invalid: ' +
-			    e.message);
-			cb(err);
-			return;
-		}
-	}
+	var buf = new SSHBuffer({});
+	try {
+		var kbuf = this.convert(obj);
+		buf.writeb(kbuf);
 
-	if (offset !== frame.length) {
-		err = new AgentProtocolError(obj, 'arguments to ' +
-		    def.name + ' smaller than expected: ' + offset + ' bytes ' +
-		    ' vs ' + frame.length + ' bytes');
-		cb(err);
-		return;
+		this.push(buf.toBuffer());
+	} catch (e) {
+		this.emit('error', e);
 	}
-
-	this.push(frame);
 	cb();
 };
 
@@ -113,8 +59,18 @@ function AgentDecodeStream(opts) {
 	assert.object(opts, 'options');
 	assert.string(opts.role, 'options.role');
 	this.role = opts.role.toLowerCase();
-	this.frameDefs = protocol[this.role + 'Frames'];
-	assert.object(this.frameDefs, 'frame defs for role ' + this.role);
+	switch (this.role) {
+	case 'agent':
+		this.convert = protocol.readClientFrame;
+		break;
+	case 'client':
+		this.convert = protocol.readAgentFrame;
+		break;
+	default:
+		/* assert below will fail */
+		break;
+	}
+	assert.func(this.convert, 'convert func for role ' + this.role);
 
 	opts.readableObjectMode = true;
 	opts.writableObjectMode = false;
@@ -129,7 +85,6 @@ AgentDecodeStream.prototype._transform = function (chunk, enc, cb) {
 
 	while (this.frame.length >= 4) {
 		var len = this.frame.readUInt32BE(0);
-		var err;
 
 		if (this.frame.length < (len + 4)) {
 			/*
@@ -142,82 +97,14 @@ AgentDecodeStream.prototype._transform = function (chunk, enc, cb) {
 			/* We have an entire frame, let's process it */
 			var frame = this.frame.slice(4, len + 4);
 			this.frame = this.frame.slice(len + 4);
+			var buf = new SSHBuffer({ buffer: frame });
 
-			var offset = 0;
-			var id = frame[offset++];
-			var def = this.frameDefs[id];
-			var argdef;
-
-			if (def === undefined) {
-				err = new AgentProtocolError(frame,
-				    'unknown frame type: ' + id);
-				this.emit('error', err);
-				cb();
-				return;
+			try {
+				var obj = this.convert(buf);
+				this.push(obj);
+			} catch (e) {
+				this.emit('error', e);
 			}
-
-			var obj = {};
-			obj.type = def.name;
-
-			/*
-			 * First compute the lengths of arguments and verify
-			 * that they are all present in the buffer
-			 */
-			var argStart = offset;
-			for (var i = 0; i < def.args.length; ++i) {
-				argdef = def.args[i];
-				try {
-					var sz = argdef.type.decodeSize(
-					    frame, offset);
-				} catch (e) {
-					err = new AgentProtocolError(frame,
-					    'bad argument ' + argdef.name +
-					    ' in ' + def.name + ' @' + offset);
-					this.emit('error', err);
-					cb();
-					return;
-				}
-				if ((offset + sz) > frame.length) {
-					err = new AgentProtocolError(frame,
-					    'bad length of argument ' +
-					    argdef.name + ' in ' + def.name +
-					    ': ' + sz);
-					this.emit('error', err);
-					cb();
-					return;
-				}
-				offset += sz;
-			}
-			if (offset !== frame.length) {
-				err = new AgentProtocolError(frame,
-				    'unconsumed bytes after final argument: ' +
-				    'offset = ' + offset + ' in ' + def.name);
-				this.emit('error', err);
-				cb();
-				return;
-			}
-
-			/* Now parse the actual argument data */
-			offset = argStart;
-			for (i = 0; i < def.args.length; ++i) {
-				argdef = def.args[i];
-				try {
-					var r = argdef.type.decode(
-					    frame, offset);
-				} catch (e) {
-					err = new AgentProtocolError(frame,
-					    'bad argument ' + argdef.name +
-					    ' in ' + def.name + ' @' + offset);
-					this.emit('error', err);
-					cb();
-					return;
-				}
-				offset = r.offset;
-				obj[argdef.name] = r.value;
-			}
-
-			this.push(obj);
-
 		}
 	}
 	cb();
diff --git a/lib/protocol.js b/lib/protocol.js
index 4cf902d..15a2250 100644
--- a/lib/protocol.js
+++ b/lib/protocol.js
@@ -3,362 +3,269 @@
 var assert = require('assert-plus');
 var util = require('util');
 var sshpk = require('sshpk');
+var SSHBuffer = require('./ssh-buffer');
+var errs = require('./errors');
+var AgentProtocolError = errs.AgentProtocolError;
 
-var LenPrefixBuf = {
-	encodeSize: function (v) {
-		assert.buffer(v);
-		return (4 + v.length);
-	},
-	encode: function (v, buf, offset) {
-		assert.buffer(v);
-		buf.writeUInt32BE(v.length, offset);
-		offset += 4;
-		v.copy(buf, offset);
-		offset += v.length;
-		return (offset);
-	},
-	decodeSize: function (buf, offset) {
-		return (4 + buf.readUInt32BE(offset));
-	},
-	decode: function (buf, offset) {
-		var len = buf.readUInt32BE(offset);
-		offset += 4;
-		var v = buf.slice(offset, offset + len);
-		offset += len;
-		return ({value: v, offset: offset});
-	}
-};
-
-var SSHString = {
-	encodeSize: function (v) {
-		assert.string(v);
-		return (4 + v.length);
-	},
-	encode: function (v, buf, offset) {
-		return (LenPrefixBuf.encode(new Buffer(v), buf, offset));
-	},
-	decodeSize: LenPrefixBuf.decodeSize,
-	decode: function (buf, offset) {
-		var r = LenPrefixBuf.decode(buf, offset);
-		r.value = r.value.toString('utf-8');
-		return (r);
-	}
-};
-
-var U32 = {
-	encodeSize: function (v) { return (4); },
-	encode: function (v, buf, offset) {
-		assert.number(v);
-		buf.writeUInt32BE(v, offset);
-		return (offset + 4);
-	},
-	decodeSize: function (buf, offset) { return (4); },
-	decode: function (buf, offset) {
-		var v = buf.readUInt32BE(offset);
-		return ({value: v, offset: offset + 4});
-	}
-};
-
-var SignReqFlags = {
-	encodeSize: U32.encodeSize,
-	encode: function (v, buf, offset) {
-		assert.arrayOfString(v, 'flags');
-		var x = 0x0;
-		if (v.indexOf('old-signature') !== -1)
-			x |= 0x01;
-		if (v.indexOf('rsa-sha2-256') !== -1)
-			x |= 0x02;
-		if (v.indexOf('rsa-sha2-512') !== -1)
-			x |= 0x04;
-		return (U32.encode(x, buf, offset));
-	},
-	decodeSize: U32.decodeSize,
-	decode: function (buf, offset) {
-		var r = U32.decode(buf, offset);
-		var v = [];
-		if ((r.value & 0x01) === 0x01)
-			v.push('old-signature');
-		if ((r.value & 0x02) === 0x02)
-			v.push('rsa-sha2-256');
-		if ((r.value & 0x04) === 0x04)
-			v.push('rsa-sha2-512');
-		r.value = v;
-		return (r);
-	}
-};
-
-var PublicKey = {
-	encodeSize: function (v) {
-		assert.object(v);
-		assert.buffer(v.key, 'key');
-		assert.string(v.comment, 'comment');
-		return (4 + v.key.length + 4 + v.comment.length);
-	},
-	encode: function (v, buf, offset) {
-		assert.object(v);
-		assert.buffer(v.key, 'key');
-		assert.string(v.comment, 'comment');
-
-		offset = LenPrefixBuf.encode(v.key, buf, offset);
-		offset = SSHString.encode(v.comment, buf, offset);
-		return (offset);
-	},
-	decodeSize: function (buf, offset) {
-		var start = offset;
-		var keyLen = buf.readUInt32BE(offset);
-		offset += 4 + keyLen;
-		var commentLen = buf.readUInt32BE(offset);
-		offset += 4 + commentLen;
-		return (offset - start);
-	},
-	decode: function (buf, offset) {
-		var v = {};
-		var r = LenPrefixBuf.decode(buf, offset);
-		v.key = r.value;
-		r = SSHString.decode(buf, r.offset);
-		v.comment = r.value;
-		r.value = v;
-		return (r);
-	}
-};
+function readClientFrame(buf) {
+	var id = buf.readUInt8();
+	var obj = {};
+	switch (id) {
+	case 11:
+		obj.type = 'request-identities';
+		break;
+	case 19:
+		obj.type = 'remove-all-identities';
+		break;
+	case 13:
+		obj.type = 'sign-request';
+		obj.publicKey = buf.readBuffer();
+		obj.data = buf.readBuffer();
+		obj.flags = [];
 
-var Identities = {
-	encodeSize: function (v) {
-		assert.arrayOfObject(v);
-		var len = 4;
-		v.forEach(function (key) {
-			len += PublicKey.encodeSize(key);
-		});
-		return (len);
-	},
-	encode: function (v, buf, offset) {
-		assert.arrayOfObject(v);
-		buf.writeUInt32BE(v.length, offset);
-		offset += 4;
-		for (var i = 0; i < v.length; ++i)
-			offset = PublicKey.encode(v[i], buf, offset);
-		return (offset);
-	},
-	decodeSize: function (buf, offset) {
-		var start = offset;
-		var count = buf.readUInt32BE(offset);
-		offset += 4;
-		for (var i = 0; i < count; ++i)
-			offset += PublicKey.decodeSize(buf, offset);
-		return (offset - start);
-	},
-	decode: function (buf, offset) {
-		var v = [];
-		var count = buf.readUInt32BE(offset);
-		offset += 4;
-		for (var i = 0; i < count; ++i) {
-			var r = PublicKey.decode(buf, offset);
-			v.push(r.value);
-			offset = r.offset;
-		}
-		return ({value: v, offset: offset});
-	}
-};
-
-var PrivateKey = {
-	encodeSize: function (v) {
-		assert.buffer(v);
-		return (v.length);
-	},
-	encode: function (v, buf, offset) {
-		assert.buffer(v);
-		v.copy(buf, offset);
-		return (offset + v.length);
-	},
-	decodeSize: function (buf, offset) {
-		var keyBuf = buf.slice(offset);
-		var ret = {};
-		try {
-			sshpk.PrivateKey.formats.rfc4253.
-			    readInternal(ret, 'private', keyBuf);
-			return (ret.consumed);
-		} catch (e) {
-			sshpk.Certificate.formats.openssh.fromBuffer(
-			    keyBuf, undefined, ret);
-			return (ret.consumed);
-		}
-	},
-	decode: function (buf, offset) {
-		var size = PrivateKey.decodeSize(buf, offset);
-		var v = buf.slice(offset, offset + size);
-		return ({value: v, offset: offset + size});
-	}
-};
-
-var KeyConstraints = {
-	encodeSize: function (v) {
-		assert.arrayOfObject(v);
-		var sz = 0;
-		v.forEach(function (c) {
-			switch (c.type) {
-			case 'lifetime':
-				sz += 1 + U32.encodeSize();
+		var flagint = buf.readUInt();
+		if ((flagint & 0x01) != 0)
+			obj.flags.push('old-signature');
+		if ((flagint & 0x02) != 0)
+			obj.flags.push('rsa-sha2-256');
+		if ((flagint & 0x04) != 0)
+			obj.flags.push('rsa-sha2-512');
+		break;
+	case 17:
+		obj.type = 'add-identity';
+		obj.privateKey = buf.readPrivateKeyBuf();
+		obj.comment = buf.readString();
+		break;
+	case 18:
+		obj.type = 'remove-identity';
+		obj.publicKey = buf.readBuffer();
+		break;
+	case 22:
+		obj.type = 'lock';
+		obj.password = buf.readString();
+		break;
+	case 23:
+		obj.type = 'unlock';
+		obj.password = buf.readString();
+		break;
+	case 25:
+		obj.type = 'add-identity-constrained';
+		obj.privateKey = buf.readPrivateKeyBuf();
+		obj.comment = buf.readString();
+		obj.constraints = [];
+		while (!buf.atEnd()) {
+			var consType = buf.readUInt8();
+			var cons = {};
+			switch (consType) {
+			case 1:
+				cons.type = 'lifetime';
+				cons.seconds = buf.readUInt();
 				break;
-			case 'confirm':
-				sz += 1;
+			case 2:
+				cons.type = 'confirm';
 				break;
 			default:
-				assert.fail('unknown constraint type: ' +
-				    c.type);
-				break;
+				throw (new AgentProtocolError(util.format(
+				    'Unsupported key constraint type: 0x%02x',
+				    consType)));
 			}
-		});
-		return (sz);
-	},
-	encode: function (v, buf, offset) {
-		assert.arrayOfObject(v);
-		v.forEach(function (c) {
-			switch (c.type) {
+			obj.constraints.push(cons);
+		}
+		break;
+	case 27:
+		obj.type = 'extension';
+		obj.extension = buf.readString();
+		obj.data = buf.readBuffer();
+		break;
+	default:
+		throw (new AgentProtocolError(util.format(
+		    'Unsupported message type ID: 0x%02x', id)));
+	}
+	if (!buf.atEnd()) {
+		throw (new AgentProtocolError(util.format(
+		    'Message of type "%s" was too long (%d bytes unused)',
+		    obj.type, buf.remainder().length)));
+	}
+	return (obj);
+}
+
+function writeClientFrame(obj) {
+	var buf = new SSHBuffer({});
+	switch (obj.type) {
+	case 'request-identities':
+		buf.writeUInt8(11);
+		break;
+	case 'remove-all-identities':
+		buf.writeUInt8(19);
+		break;
+	case 'sign-request':
+		buf.writeUInt8(13);
+		assert.buffer(obj.publicKey, 'publicKey');
+		assert.buffer(obj.data, 'data');
+		assert.arrayOfString(obj.flags, 'flags');
+		buf.writeBuffer(obj.publicKey);
+		buf.writeBuffer(obj.data);
+		var flagint = 0;
+		if (obj.flags.indexOf('old-signature') !== -1)
+			flagint |= 0x01;
+		if (obj.flags.indexOf('rsa-sha2-256') !== -1)
+			flagint |= 0x02;
+		if (obj.flags.indexOf('rsa-sha2-512') !== -1)
+			flagint |= 0x04;
+		buf.writeUInt(flagint);
+		break;
+	case 'add-identity':
+		buf.writeUInt8(17);
+		assert.buffer(obj.privateKey, 'privateKey');
+		assert.string(obj.comment, 'comment');
+		buf.write(obj.privateKey);
+		buf.writeString(obj.comment);
+		break;
+	case 'remove-identity':
+		buf.writeUInt8(18);
+		assert.buffer(obj.publicKey, 'publicKey');
+		buf.writeBuffer(obj.publicKey);
+		break;
+	case 'lock':
+		buf.writeUInt8(22);
+		assert.string(obj.password, 'password');
+		buf.writeString(obj.password);
+		break;
+	case 'unlock':
+		buf.writeUInt8(23);
+		assert.string(obj.password, 'password');
+		buf.writeString(obj.password);
+		break;
+	case 'add-identity-constrained':
+		buf.writeUInt8(25);
+		assert.buffer(obj.privateKey, 'privateKey');
+		assert.string(obj.comment, 'comment');
+		assert.arrayOfObject(obj.constraints, 'constraints');
+		buf.write(obj.privateKey);
+		buf.writeString(obj.comment);
+		obj.constraints.forEach(function (cons) {
+			switch (cons.type) {
 			case 'lifetime':
-				buf[offset++] = 1;
-				offset = U32.encode(c.seconds, buf, offset);
+				assert.number(cons.seconds, 'cons.seconds');
+				buf.writeUInt8(1);
+				buf.writeUInt(cons.seconds);
 				break;
 			case 'confirm':
-				buf[offset++] = 2;
+				buf.writeUInt8(2);
 				break;
 			default:
-				assert.fail('unknown constraint type: ' +
-				    c.type);
-				break;
+				throw (new AgentProtocolError(util.format(
+				    'Invalid outgoing key constraint type: ' +
+				    '"%s"', cons.type)));
 			}
 		});
-		return (offset);
-	},
-	decodeSize: function (buf, offset) {
-		var start = offset;
-		while (offset < buf.length) {
-			var type = buf[offset];
-			switch (type) {
-			case 1:
-				offset += 5;
-				break;
-			case 2:
-				offset++;
-				break;
-			default:
-				return (offset - start);
-			}
+		break;
+	case 'extension':
+		buf.writeUInt8(27);
+		assert.string(obj.extension, 'extension');
+		assert.buffer(obj.data, 'data');
+		buf.writeString(obj.extension);
+		buf.writeBuffer(obj.data);
+		break;
+	default:
+		throw (new AgentProtocolError(util.format('Invalid outgoing ' +
+		    'frame type: "%s"', obj.type)));
+	}
+	return (buf);
+}
+
+function readAgentFrame(buf) {
+	var id = buf.readUInt8();
+	var obj = {};
+	switch (id) {
+	case 6:
+		obj.type = 'success';
+		var rem = buf.remainder();
+		/* Extensions can overload the "success" message */
+		if (rem.length > 0) {
+			obj.remainder = rem;
+			return (obj);
 		}
-		return (offset - start);
-	},
-	decode: function (buf, offset) {
-		var v = [];
-		while (offset < buf.length) {
-			var type = buf[offset];
-			switch (type) {
-			case 1:
-				offset++;
-				var r = U32.decode(buf, offset);
-				v.push({type: 'lifetime', seconds: r.value});
-				offset = r.offset;
-				break;
-			case 2:
-				offset++;
-				v.push({type: 'confirm'});
-				break;
-			default:
-				return ({value: v, offset: offset});
-			}
+		break;
+	case 5:
+		obj.type = 'failure';
+		break;
+	case 28:
+		obj.type = 'ext-failure';
+		break;
+	case 12:
+		obj.type = 'identities-answer';
+		obj.identities = [];
+		var n = buf.readUInt();
+		for (var i = 0; i < n; ++i) {
+			obj.identities.push({
+				key: buf.readBuffer(),
+				comment: buf.readString()
+			});
 		}
-		return ({value: v, offset: offset});
+		break;
+	case 14:
+		obj.type = 'sign-response';
+		obj.signature = buf.readBuffer();
+		break;
+	default:
+		throw (new AgentProtocolError(util.format(
+		    'Unsupported message type ID: 0x%02x', id)));
 	}
-};
-
-var agentFrames = {
-	'request-identities': {
-		id: 11,
-		args: []
-	},
-	'sign-request': {
-		id: 13,
-		args: [
-			{type: LenPrefixBuf, name: 'publicKey'},
-			{type: LenPrefixBuf, name: 'data'},
-			{type: SignReqFlags, name: 'flags'}
-		]
-	},
-	'add-identity': {
-		id: 17,
-		args: [
-			{type: PrivateKey, name: 'privateKey'},
-			{type: SSHString, name: 'comment'}
-		]
-	},
-	'remove-identity': {
-		id: 18,
-		args: [
-			{type: LenPrefixBuf, name: 'publicKey'}
-		]
-	},
-	'remove-all-identities': {
-		id: 19,
-		args: []
-	},
-	'lock': {
-		id: 22,
-		args: [
-			{type: SSHString, name: 'password'}
-		]
-	},
-	'unlock': {
-		id: 23,
-		args: [
-			{type: SSHString, name: 'password'}
-		]
-	},
-	'add-identity-constrained': {
-		id: 25,
-		args: [
-			{type: PrivateKey, name: 'privateKey'},
-			{type: SSHString, name: 'comment'},
-			{type: KeyConstraints, name: 'constraints'}
-		]
+	if (!buf.atEnd()) {
+		throw (new AgentProtocolError(util.format(
+		    'Message of type "%s" was too long (%d bytes unused)',
+		    obj.type, buf.remainder().length)));
 	}
-};
+	return (obj);
+}
 
-/* Add lookup by ID */
-Object.keys(agentFrames).forEach(function (k) {
-	var f = agentFrames[k];
-	f.name = k;
-	agentFrames[f.id] = f;
-});
-
-var clientFrames = {
-	'success': {
-		id: 6,
-		args: []
-	},
-	'failure': {
-		id: 5,
-		args: []
-	},
-	'identities-answer': {
-		id: 12,
-		args: [
-			{type: Identities, name: 'identities'}
-		]
-	},
-	'sign-response': {
-		id: 14,
-		args: [
-			{type: LenPrefixBuf, name: 'signature'}
-		]
+function writeAgentFrame(obj) {
+	var buf = new SSHBuffer({});
+	switch (obj.type) {
+	case 'success':
+		buf.writeUInt8(6);
+		if (obj.remainder !== undefined) {
+			assert.buffer(obj.remainder, 'remainder');
+			buf.write(obj.remainder);
+		}
+		break;
+	case 'failure':
+		buf.writeUInt8(5);
+		break;
+	case 'ext-failure':
+		buf.writeUInt8(28);
+		break;
+	case 'identities-answer':
+		buf.writeUInt8(12);
+		assert.optionalArrayOfObject(obj.identities, 'identities');
+		if (!obj.identities) {
+			buf.writeUInt(0);
+		} else {
+			buf.writeUInt(obj.identities.length);
+			obj.identities.forEach(function (id) {
+				assert.buffer(id.key, 'key');
+				assert.string(id.comment, 'comment');
+				buf.writeBuffer(id.key);
+				buf.writeString(id.comment);
+			});
+		}
+		break;
+	case 'sign-response':
+		buf.writeUInt8(14);
+		assert.buffer(obj.signature, 'signature');
+		buf.writeBuffer(obj.signature);
+		break;
+	default:
+		throw (new AgentProtocolError(util.format('Invalid outgoing ' +
+		    'frame type: "%s"', obj.type)));
 	}
-};
-
-/* Add lookup by ID */
-Object.keys(clientFrames).forEach(function (k) {
-	var f = clientFrames[k];
-	f.name = k;
-	clientFrames[f.id] = f;
-});
+	return (buf);
+}
 
 module.exports = {
-	agentFrames: agentFrames,
-	clientFrames: clientFrames
+	readClientFrame: readClientFrame,
+	readAgentFrame: readAgentFrame,
+	writeClientFrame: writeClientFrame,
+	writeAgentFrame: writeAgentFrame
 };
diff --git a/lib/ssh-buffer.js b/lib/ssh-buffer.js
new file mode 100644
index 0000000..b49c4e0
--- /dev/null
+++ b/lib/ssh-buffer.js
@@ -0,0 +1,174 @@
+// Copyright 2018 Joyent, Inc.
+
+module.exports = SSHBuffer;
+
+var assert = require('assert-plus');
+var sshpk = require('sshpk');
+
+function SSHBuffer(opts) {
+	assert.object(opts, 'options');
+	if (opts.buffer !== undefined)
+		assert.buffer(opts.buffer, 'options.buffer');
+
+	this._size = opts.buffer ? opts.buffer.length : 1024;
+	this._buffer = opts.buffer || (new Buffer(this._size));
+	this._offset = 0;
+}
+
+SSHBuffer.prototype.toBuffer = function () {
+	return (this._buffer.slice(0, this._offset));
+};
+
+SSHBuffer.prototype.atEnd = function () {
+	return (this._offset >= this._buffer.length);
+};
+
+SSHBuffer.prototype.remainder = function () {
+	return (this._buffer.slice(this._offset));
+};
+
+SSHBuffer.prototype.skip = function (n) {
+	this._offset += n;
+};
+
+SSHBuffer.prototype.expand = function () {
+	this._size *= 2;
+	var buf = new Buffer(this._size);
+	this._buffer.copy(buf, 0);
+	this._buffer = buf;
+};
+
+SSHBuffer.prototype.readb = function () {
+	return (new SSHBuffer({ buffer: this.readBuffer() }));
+};
+
+SSHBuffer.prototype.writeb = function (kid) {
+	return (this.writeBuffer(kid.toBuffer()));
+};
+
+SSHBuffer.prototype.readPrivateKeyBuf = function () {
+	var buf = this.remainder();
+	var ret = {};
+	var len;
+	try {
+		sshpk.PrivateKey.formats.rfc4253.
+		    readInternal(ret, 'private', buf);
+		len = ret.consumed;
+	} catch (e) {
+		sshpk.Certificate.formats.openssh.fromBuffer(
+		    buf, undefined, ret);
+		len = ret.consumed;
+	}
+	assert.number(len);
+	buf = buf.slice(0, len);
+	this._offset += len;
+	return (buf);
+};
+
+SSHBuffer.prototype.readBuffer = function () {
+	var len = this._buffer.readUInt32BE(this._offset);
+	this._offset += 4;
+	assert.ok(this._offset + len <= this._buffer.length,
+	    'length out of bounds at +0x' + this._offset.toString(16) +
+	    ' (data truncated?)');
+	var buf = this._buffer.slice(this._offset, this._offset + len);
+	this._offset += len;
+	return (buf);
+};
+
+SSHBuffer.prototype.readString = function () {
+	return (this.readBuffer().toString('utf-8'));
+};
+
+SSHBuffer.prototype.readCString = function () {
+	var offset = this._offset;
+	while (offset < this._buffer.length &&
+	    this._buffer[offset] !== 0x00)
+		offset++;
+	assert.ok(offset < this._buffer.length, 'c string does not terminate');
+	var str = this._buffer.slice(this._offset, offset).toString();
+	this._offset = offset + 1;
+	return (str);
+};
+
+SSHBuffer.prototype.readUInt = function () {
+	var v = this._buffer.readUInt32BE(this._offset);
+	this._offset += 4;
+	return (v);
+};
+
+SSHBuffer.prototype.readUInt64 = function () {
+	assert.ok(this._offset + 8 < this._buffer.length,
+	    'buffer not long enough to read Int64');
+	var v = this._buffer.slice(this._offset, this._offset + 8);
+	this._offset += 8;
+	return (v);
+};
+
+SSHBuffer.prototype.readUInt8 = function () {
+	var v = this._buffer.readUInt8(this._offset++);
+	return (v);
+};
+
+SSHBuffer.prototype.writeBuffer = function (buf) {
+	while (this._offset + 4 + buf.length > this._size)
+		this.expand();
+	this._buffer.writeUInt32BE(buf.length, this._offset);
+	this._offset += 4;
+	buf.copy(this._buffer, this._offset);
+	this._offset += buf.length;
+};
+
+SSHBuffer.prototype.writeString = function (str) {
+	this.writeBuffer(new Buffer(str, 'utf-8'));
+};
+
+SSHBuffer.prototype.writeCString = function (str) {
+	while (this._offset + 1 + str.length > this._size)
+		this.expand();
+	this._buffer.write(str, this._offset);
+	this._offset += str.length;
+	this._buffer[this._offset++] = 0;
+};
+
+SSHBuffer.prototype.writeUInt = function (v) {
+	while (this._offset + 4 > this._size)
+		this.expand();
+	this._buffer.writeUInt32BE(v, this._offset);
+	this._offset += 4;
+};
+
+SSHBuffer.prototype.writeUInt64 = function (v) {
+	assert.buffer(v, 'value');
+	if (v.length > 8) {
+		var lead = v.slice(0, v.length - 8);
+		for (var i = 0; i < lead.length; ++i) {
+			assert.strictEqual(lead[i], 0,
+			    'must fit in 64 bits of precision');
+		}
+		v = v.slice(v.length - 8, v.length);
+	}
+	while (this._offset + 8 > this._size)
+		this.expand();
+	v.copy(this._buffer, this._offset);
+	this._offset += 8;
+};
+
+SSHBuffer.prototype.writeUInt8 = function (v) {
+	while (this._offset + 1 > this._size)
+		this.expand();
+	this._buffer.writeUInt8(v, this._offset++);
+};
+
+SSHBuffer.prototype.writeChar = function (v) {
+	while (this._offset + 1 > this._size)
+		this.expand();
+	this._buffer[this._offset++] = v;
+};
+
+SSHBuffer.prototype.write = function (buf) {
+	while (this._offset + buf.length > this._size)
+		this.expand();
+	buf.copy(this._buffer, this._offset);
+	this._offset += buf.length;
+};
diff --git a/package.json b/package.json
index ecded1f..73d0d7a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "sshpk-agent",
-  "version": "1.6.1",
+  "version": "1.6.2",
   "description": "ssh-agent client for use with sshpk",
   "main": "lib/index.js",
   "scripts": {
@@ -29,7 +29,7 @@
     "assert-plus": "^1.0.0",
     "mooremachine": "^2.0.1",
     "readable-stream": "^2.1.4",
-    "sshpk": ">=1.13.0 < 1.14.0",
+    "sshpk": ">=1.13.0 < 1.13.2",
     "verror": "^1.10.0"
   },
   "devDependencies": {
