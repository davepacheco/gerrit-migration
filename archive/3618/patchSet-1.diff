commit 2233e3ca5e21d811b59218abee8440f76af79b89 (refs/changes/18/3618/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2018-03-13T15:20:10-07:00 (1 year, 7 months ago)
    
    TRITON-171 Ambiguous error message when creating a triton volume

diff --git a/lib/errors.js b/lib/errors.js
index 58ab4b0..201db88 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -5,13 +5,52 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var restify = require('restify');
 var util = require('util');
 
+function InvalidNetworksError(options) {
+    assert.object(options, 'options');
+    assert.optionalArrayOfUuid(options.missing, 'options.missing');
+    assert.optionalArrayOfUuid(options.nonOwned, 'options.nonOwned');
+    assert.optionalArrayOfUuid(options.nonFabric, 'options.nonFabric');
+
+    assert.ok((options.missing && options.missing.length > 0) ||
+        (options.nonOwned && options.nonOwned.length > 0) ||
+        (options.nonFabric && options.nonFabric.length > 0),
+        'at least one network needs to be missing, non-owned or non-fabric');
+
+    var detailsMsgs = [];
+    var errMsg;
+    var invalidNetsMsg = 'Invalid networks';
+
+    if (options.missing && options.missing.length > 0) {
+        detailsMsgs.push('missing: ' + options.missing.join(', '));
+    }
+
+    if (options.nonOwned && options.nonOwned.length > 0) {
+        detailsMsgs.push('not owned by user: ' + options.nonOwned.join(', '));
+    }
+
+    if (options.nonFabric && options.nonFabric.length > 0) {
+        detailsMsgs.push('non-fabric: ' + options.nonFabric.join(', '));
+    }
+
+    errMsg = invalidNetsMsg + ': ' + detailsMsgs.join(', ');
+
+    restify.RestError.call(this, {
+        restCode: 'InvalidNetworks',
+        statusCode: 409,
+        message: errMsg,
+        constructorOpt: InvalidNetworksError
+    });
+    this.name = 'InvalidNetworksError';
+}
+util.inherits(InvalidNetworksError, restify.RestError);
+
 function VolumeNotFoundError(volumeUuid) {
     restify.RestError.call(this, {
         restCode: 'VolumeNotFound',
@@ -55,6 +94,7 @@ function VolumeInUseError(volumeName) {
     });
     this.name = 'VolumeInUseError';
 }
+
 util.inherits(VolumeInUseError, restify.RestError);
 
 function ValidationError(causes) {
@@ -101,6 +141,7 @@ util.inherits(VolumeSizeNotAvailableError, restify.RestError);
 
 module.exports = {
     InternalError: restify.InternalError,
+    InvalidNetworksError: InvalidNetworksError,
     ValidationError: ValidationError,
     VolumeAlreadyExistsError: VolumeAlreadyExistsError,
     VolumeInUseError: VolumeInUseError,
diff --git a/lib/validation/networks.js b/lib/validation/networks.js
index d80d78f..9d17d87 100644
--- a/lib/validation/networks.js
+++ b/lib/validation/networks.js
@@ -5,12 +5,14 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var vasync = require('vasync');
 
+var errors = require('../errors');
+
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
 function validateNetwork(networkUuid) {
@@ -35,6 +37,7 @@ function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
     var missing = [];
     var nonFabric = [];
     var nonOwned = [];
+    var ownerUuid = volumeParams.owner_uuid;
 
     vasync.forEachParallel({
         func: function validateOneNetwork(networkUuid, cb) {
@@ -42,13 +45,14 @@ function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
                 if (!err && net) {
                     assert.object(net, 'net');
                     assert.optionalBool(net.fabric, 'net.fabric');
-                    assert.arrayOfUuid(net.owner_uuids, 'net.owner_uuids');
+                    assert.optionalArrayOfUuid(net.owner_uuids,
+                        'net.owner_uuids');
 
                     if (net.fabric !== true) {
                         nonFabric.push(networkUuid);
                     }
-                    if (net.owner_uuids
-                        .indexOf(volumeParams.owner_uuid) === -1) {
+                    if (!net.owner_uuids ||
+                        net.owner_uuids.indexOf(ownerUuid) === -1) {
                         nonOwned.push(networkUuid);
                     }
                 }
@@ -61,31 +65,19 @@ function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
                 cb(err);
             });
         }, inputs: volumeParams.networks
-    }, function onValidated(err) {
-        var newErr = err;
-        var newErrMsgs = [];
-
-        if (!err) {
-            if (missing.length > 0) {
-                newErrMsgs.push('missing networks: ' + JSON.stringify(missing));
-            }
-            if (nonOwned.length > 0) {
-                newErrMsgs.push('non-owned networks: ' +
-                    JSON.stringify(nonOwned));
-            }
-            if (nonFabric.length > 0) {
-                newErrMsgs.push('non-fabric networks: ' +
-                    JSON.stringify(nonFabric));
-            }
+    }, function onValidated(getNetworkErr) {
+        var err = getNetworkErr;
 
-            if (newErrMsgs.length > 0) {
-                // use .trim() to remove trailing space
-                newErr = new Error('invalid network(s) specified: ' +
-                    newErrMsgs.join(' '));
-            }
-       }
+        if (!getNetworkErr && (missing.length > 0 || nonFabric.length > 0 ||
+            nonOwned.length > 0)) {
+            err = new errors.InvalidNetworksError({
+                missing: missing,
+                nonOwned: nonOwned,
+                nonFabric: nonFabric
+            });
+        }
 
-       callback(newErr);
+       callback(err);
     });
 }
 
