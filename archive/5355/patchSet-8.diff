commit 838dbdd02b49a522d7eaef68e7c543c67753cd8b (refs/changes/55/5355/8)
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2019-01-28T15:29:00+00:00 (8 months ago)
    
    OS-7497 bhyve disks need uuids
    Reviewed by: Jorge Schrauwen <sjorge@blackdot.be>
    Reviewed by: Dylan Yep <dylan.yep@joyent.com>
    Reviewed by: Marsell Kukuljevic <marsell@joyent.com>
    Approved by: Marsell Kukuljevic <marsell@joyent.com>

diff --git a/src/Makefile b/src/Makefile
index 6ba8fab4..0961e82f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -111,6 +111,7 @@ JS_CHECK_TARGETS=\
 	vm/tests/test-create-filesystems.js \
 	vm/tests/test-create.js \
 	vm/tests/test-defaults.js \
+	vm/tests/test-disk-uuid.js \
 	vm/tests/test-docker.js \
 	vm/tests/test-firewall.js \
 	vm/tests/test-fswatcher.js \
diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index e065fe65..47de1896 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -1019,6 +1019,18 @@ tab-complete UUIDs rather than having to type them out for every command.
 
         NOTE: SDC does not support any pool name other than the default 'zones'.
 
+    disks.*.uuid:
+
+        A UUID that may be used to uniquely identify this disk.  It must be
+        unique across all disks associated with this VM.
+
+        type: uuid
+        vmtype: bhyve
+        listable: yes (see above)
+        create: yes
+        update: yes
+        default: Assigned while adding the disk or at next `vmadm start`.
+
     disk_driver:
 
         This specifies the default values for disks.*.model for disks attached
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 5d17060b..7758ace9 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -58,7 +58,7 @@
  * logger - you can set this to a node-bunyan log stream to capture the logs
  * SYSRQ_TYPES - list of supported requests for sysrq
  *
- * IMPORTANT: Per OS-2427, this file is for the exlusive use of vmadmd and
+ * IMPORTANT: Per OS-2427, this file is for the exclusive use of vmadmd and
  *            vmadm. If you are using this and you are not one of those two,
  *            please switch to calling vmadm instead.
  *
@@ -558,9 +558,7 @@ function validateProperty(brand, prop, value, action, data, errors, log)
     if (PAYLOAD_PROPERTIES.hasOwnProperty(prop)) {
         switch (PAYLOAD_PROPERTIES[prop].pr_type) {
         case 'uuid':
-            if (typeof (value) === 'string' && !isUUID(value)
-                && errors.bad_values.indexOf(prop) === -1) {
-
+            if (!isUUID(value) && errors.bad_values.indexOf(prop) === -1) {
                 errors.bad_values.push(prop);
             }
             break;
@@ -1437,7 +1435,7 @@ function setQuota(opts, callback)
  *   - Set quota on zone root dataset, based on whether flexible_disk_size is
  *     set. If flexible_disk_size is set, quota becomes the root dataset's
  *     refquota + sum(auto_refres - volsize) + flexible_disk_size. Otherwise,
- *     quota becomes the root dataset's refquota + sum(auto_frefres).
+ *     quota becomes the root dataset's refquota + sum(auto_refres).
  */
 
 function setQuotaBhyve(opts, callback) {
@@ -2425,7 +2423,7 @@ function createVolume(volume, opts, callback)
                 var args;
 
                 // This volume is from a template/dataset/image so we create it
-                // as a clone of a the @final snapshot on the original.  We
+                // as a clone of the @final snapshot on the original.  We
                 // already set 'snapshot' to the correct location above.
                 args = ['clone', '-F'];
                 if (volume.hasOwnProperty('compression')) {
@@ -4413,7 +4411,7 @@ exports.waitForZoneState = function (payload, state, options, callback)
             cb();
         }, function (_, cb) {
             if (!vs) {
-                // alreday in the correct state; we're done
+                // already in the correct state; we're done
                 cb();
                 return;
             }
@@ -4642,7 +4640,7 @@ function fixPayloadMemory(payload, vmobj, log)
     }
 
     // now that we've possibly adjusted target values, lower/raise values to
-    // satisify max/min.
+    // satisfy max/min.
 
     min_overhead = BRAND_OPTIONS[brand].features.min_memory_overhead;
     if (min_overhead) {
@@ -6028,6 +6026,11 @@ function buildDiskZonecfg(vmobj, payload)
                 + disk.pci_slot + '")\n';
         }
 
+        if (disk.hasOwnProperty('uuid')) {
+            zcfg = zcfg + 'add property (name=uuid, value="'
+                + disk.uuid + '")\n';
+        }
+
         zcfg = zcfg + 'end\n';
     }
 
@@ -6425,7 +6428,7 @@ function buildFilesystemZonecfg(vmobj, payload, options)
  *   -t-             n      y       n
  *   ---             n      n       n
  *
- * There are 6 cases here we deail with:
+ * There are 6 cases here we deal with:
  *
  *   - tty and json-file
  *       - write to the log in the GZ, zlog-mode=gt-
@@ -6932,7 +6935,7 @@ function buildZonecfgUpdate(vmobj, payload, log)
     }
 
     // We only get here with a 'datasets' member on payload if we're doing a
-    // recive. So in that case we always want to add to zonecfg input.
+    // receive. So in that case we always want to add to zonecfg input.
     if (payload.hasOwnProperty('datasets')) {
         zcfg = zcfg + buildDatasetZonecfg(vmobj, payload);
     }
@@ -9462,13 +9465,22 @@ function normalizeNics(payload, vmobj)
     }
 }
 
+/*
+ * Called during create and update to fix up various disk properties for the
+ * disks that are being added.  If conflicts are found, an Error will be raised.
+ */
+function normalizeDisks(payload, vmobj, log) {
+    normalizeDiskSlots(payload, vmobj, log);
+    normalizeDiskUuids(payload, vmobj, log);
+}
+
 /*
  * Ensure all disks being added have pci_slot set. This is called during create
  * and update.  During create, vmobj is null.
  *
  * This may throw an Error that was originally thrown by assignBhyvePCIslots.
  */
-function normalizeDisks(payload, vmobj, log)
+function normalizeDiskSlots(payload, vmobj, log)
 {
     var brand = (vmobj && vmobj.brand) ? vmobj.brand : payload.brand;
     if (brand !== 'bhyve' || !payload.hasOwnProperty('add_disks')) {
@@ -9485,7 +9497,7 @@ function normalizeDisks(payload, vmobj, log)
     // created instance may lack static assignments, but those will get fixed
     // the next time that VM.start() is called. legacy_compat is used in this
     // pass so that the right slots are set aside for use by the bhyve brand
-    // boot hook. See block comment above assignBhyvePCISlots().
+    // boot hook. See block comment above assignBhyvePCIslots().
     if (vmobj) {
         opts.disks = vmobj.disks;
         opts.legacy_compat = true;
@@ -9494,17 +9506,64 @@ function normalizeDisks(payload, vmobj, log)
 
     // Now see what needs to be fixed in the add_disks array.
     log.debug({add_disks: payload.add_disks},
-        'normalizeDisks start payload.add_disks');
+        'normalizeDiskSlots start payload.add_disks');
     opts.disks = payload.add_disks;
     opts.legacy_compat = false;
     var assignments = assignBhyvePCIslots(opts);
     assignments.forEach(function _eachAssignment(assignment) {
-        log.debug({assignment: assignment}, 'normalizeDisks updating payload');
+        log.debug({assignment: assignment},
+            'normalizeDiskSlots updating payload');
         assignment.disk.pci_slot = assignment.pci_slot;
     });
 
     log.debug({add_disks: payload.add_disks},
-        'normalizeDisks end payload.add_disks');
+        'normalizeDiskSlots end payload.add_disks');
+}
+
+/*
+ * Ensures each bhyve disk has a unique UUID.  Assigns UUIDs to
+ * payload.add_disks.* if they are missing and raises an Error if a duplicate is
+ * found.
+ */
+function normalizeDiskUuids(payload, vmobj, log)
+{
+    var uuids = [];
+    var disk, i;
+    var brand = (vmobj && vmobj.brand) ? vmobj.brand : payload.brand;
+    if (brand !== 'bhyve' || !payload.hasOwnProperty('add_disks')) {
+        return;
+    }
+
+    // Find uuids in use by existing disks
+    if (vmobj && vmobj.hasOwnProperty('disks')) {
+        uuids = vmobj.disks.reduce(function diskUuid(_uuids, _disk) {
+            if (_disk.hasOwnProperty('uuid')) {
+                _uuids.push(_disk.uuid);
+            }
+            return _uuids;
+        }, []);
+    }
+
+    // Ensure presence and uniqueness of new disk uuids.
+    for (i = 0; i < payload.add_disks.length; i++) {
+        disk = payload.add_disks[i];
+        if (disk.hasOwnProperty('uuid')) {
+            if (uuids.indexOf(disk.uuid) !== -1) {
+                log.error({
+                    'payload.add_disks': payload.add_disks,
+                    i: i,
+                    uuids: uuids
+                }, 'normalizeDiskUuids: duplicate disk uuid');
+
+                throw new Error('duplicate disk uuid ' + disk.uuid);
+            }
+        } else {
+            disk.uuid = libuuid.create();
+            assert(uuids.indexOf(disk.uuid) === -1,
+                'automatically assigned uuid must be unique');
+        }
+        uuids.push(disk.uuid);
+    }
 }
 
 /*
@@ -9858,7 +9917,7 @@ function normalizePayload(payload, vmobj, log, callback)
         // this will ensure we've got a MAC, etc.
         normalizeNics(payload, vmobj);
 
-        // ensure that pci slots are assigned for bhyve disks
+        // ensure that optional properties (pci_slot, uuid) are set on disks
         try {
             normalizeDisks(payload, vmobj, log);
         }
@@ -10225,7 +10284,7 @@ function receiveVM(json, log, callback)
     payload.transition =
         {'transition': 'receiving', 'target': 'stopped', 'timeout': 86400};
 
-    // We delete tags and metadata here becasue this exists in the root
+    // We delete tags and metadata here because this exists in the root
     // dataset which we will be copying, so it would be duplicated here.
     delete payload.customer_metadata;
     delete payload.internal_metadata;
@@ -10924,7 +10983,7 @@ exports.reprovision = function (uuid, payload, options, callback)
                 }
 
                 if (fds.stderr.match(/dataset does not exist/)) {
-                    // we'll use a different one. (falls throught to next func)
+                    // we'll use a different one. (falls through to next func)
                     cb();
                 } else {
                     cb(err);
@@ -12116,7 +12175,7 @@ function deleteZone(uuid, log, callback)
             // delete the incoming payload if it exists
             fs.unlink('/etc/zones/' + vmobj.uuid + '-receiving.json',
                 function (e) {
-                    // we can't do anyhing if this fails other than log
+                    // we can't do anything if this fails other than log
                     if (e && e.code !== 'ENOENT') {
                         log.warn(e, 'Failed to delete ' + vmobj.uuid
                             + '-receiving.json (' + e.code + '): ' + e.message);
@@ -12761,7 +12820,7 @@ function startVM(vmobj, extra, log, callback)
                 && nic.gateway == defaultgw) {
 
                 /*
-                 * XXX this exists here for backward compatibilty.  New VMs
+                 * XXX this exists here for backward compatibility.  New VMs
                  *     and old VMs that are upgraded should not use
                  *     default_gateway.  When we've implemented autoupgrade
                  *     this block (and all reference to default_gateway)
@@ -13717,7 +13776,7 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
                     log.error({err: e}, 'unable to mount snapshot: '
                         + e.message);
                 }
-                // not fatal becase snapshot was already created.
+                // not fatal because snapshot was already created.
                 cb();
             });
         }, function (cb) {
@@ -14117,11 +14176,11 @@ function setDockerRestartOpts(uuid, options, callback) {
  * The allocation algorithm varies on whether opts.legacy_compat is true. The
  * legacy compat mode is used by VM.start() to persist disks that were allocated
  * prior to the static PCI slot assignment feature's availability. The legacy
- * algorithm here matches the algorithm used by the the bhyve brand boot hook
+ * algorithm here matches the algorithm used by the bhyve brand boot hook
  * (/usr/lib/brand/bhyve/boot) when disks don't have pci_slot specified. Because
  * bhyve instances start at global zone boot by `zoneadm boot` issued by
  * svc:/system/zones:default, an instance that was provisioned prior to the
- * introduction of static slot assignments will not get static assignements
+ * introduction of static slot assignments will not get static assignments
  * until such a time as it is stopped then started.
  *
  * The modern allocation scheme puts the boot disk at 0:4:0 and data disks at
@@ -14132,8 +14191,8 @@ function setDockerRestartOpts(uuid, options, callback) {
  * of the first data device would render any remaining data devices unusable.
  *
  * In the case where new devices are added to an instance that has a disk at
- * 0:5:0, VM.update() will use legacy compatibilty while figuring out which
- * slots are currently in use and will not use legacy compatibilty while
+ * 0:5:0, VM.update() will use legacy compatibility while figuring out which
+ * slots are currently in use and will not use legacy compatibility while
  * assigning new disks.  This will make it so that the original boot disk will
  * stay at 0:4:0, the original data disk will stay at 0:5:0, and the new data
  * disk will be found at 0:4:1.  VM.update() can only add disks while the
@@ -14299,7 +14358,7 @@ function assignBhyvePCIslots(opts)
 }
 
 /*
- * Updates disks.*.pci_slot for each disk that has no static assignement.
+ * Updates disks.*.pci_slot for each disk that has no static assignment.
  * Expected to be called during VM.start(). If this called during a provisioning
  * boot, it is expected that normalizeDisks() will have already been called
  * during VM.create().
@@ -14337,6 +14396,36 @@ function updateBhyvePCIslots(opts, cb)
     VM.update(vmobj.uuid, {update_disks: updates}, {log: log}, cb);
 }
 
+function updateBhyveDiskUuids(opts, cb)
+{
+    assert.object(opts);
+    assert.object(opts.vmobj);
+    assert.object(opts.log);
+
+    var vmobj = opts.vmobj;
+    var log = opts.log;
+
+    if (vmobj.brand !== 'bhyve') {
+        cb();
+        return;
+    }
+
+    var ud = [];
+    var disk, i;
+    for (i = 0; i < vmobj.disks.length; i++) {
+        disk = vmobj.disks[i];
+        if (!disk.hasOwnProperty('uuid')) {
+            ud.push({path: disk.path, uuid: libuuid.create()});
+        }
+    }
+    if (ud.length === 0) {
+        cb();
+        return;
+    }
+    log.debug({update_disks: ud}, 'updateBhyveDiskUuids assigning uuids');
+    VM.update(vmobj.uuid, {update_disks: ud}, {log: log}, cb);
+}
+
 exports.start = function (uuid, extra, options, callback)
 {
     var load_fields;
@@ -14543,6 +14632,8 @@ exports.start = function (uuid, extra, options, callback)
         }, function _persistBhyveDevs(cb) {
             updateBhyvePCIslots({vmobj: vmobj, log: log, legacy_compat: true},
                 cb);
+        }, function _persistBhyveDiskUuids(cb) {
+            updateBhyveDiskUuids({vmobj: vmobj, log: log}, cb);
         }, function _start(cb) {
             var err;
             var vm_type = BRAND_OPTIONS[vmobj.brand].features.type;
@@ -14752,7 +14843,7 @@ function resizeDisks(vmobj, updates, log, callback)
          *
          * Gets the size of the refreservation change that will happen as a
          * result of resizing a volume. This is used to determine how much the
-         * quota and/or refereservation on the zone's dataset (zonepath dataset)
+         * quota and/or refreservation on the zone's dataset (zonepath dataset)
          * will need to change to allow the resize.
          *
          * opts.volname The name of the zfs volume that is being resized.
@@ -16291,7 +16382,7 @@ exports.update = function (uuid, payload, options, callback)
                 re = /^(set_|remove_)?(customer_metadata|internal_metadata|tags|routes)$/;
                 if (key.match(re)) {
                     /*
-                     * Metadata blocking logic is handleded in updateRoutes and
+                     * Metadata blocking logic is handled in updateRoutes and
                      * updateMetadata - so just short-circuit here.
                      */
                     return;
@@ -17479,7 +17570,7 @@ exports.stop = function (uuid, options, callback)
     async.series([
         function (cb) {
             /*
-             * Create the vminfod event stream here that wil be used below to
+             * Create the vminfod event stream here that will be used below to
              * block on the VM transitioning into the "stopped" state.  Also,
              * use the "ready" event to get the vmobj for the VM uuid given
              */
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index 0c6bcf36..d9b7fdec 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -697,6 +697,15 @@ exports.properties = {
             fields: ['volsize'],
             types: ['volume']
         }
+    }, 'disks.*.uuid': {
+        payload: {
+            allowed: {
+                'bhyve': ['add', 'update']
+            },
+            type: 'uuid'
+        },
+        updatable: true,
+        zonexml: 'zone.device.net-attr.uuid'
     }, 'disks.*.zfs_filesystem': {
         payload: {
             allowed: {
diff --git a/src/vm/node_modules/utils.js b/src/vm/node_modules/utils.js
index 08dc9291..c47326b1 100644
--- a/src/vm/node_modules/utils.js
+++ b/src/vm/node_modules/utils.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2019, Joyent, Inc. All rights reserved.
  *
  */
 
@@ -207,11 +207,7 @@ function isPrivateIP(str)
 function isUUID(str)
 {
     var re = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-    if (str && str.length === 36 && str.match(re)) {
-        return true;
-    } else {
-        return false;
-    }
+    return typeof (str) === 'string' && re.test(str);
 }
 
 function validAttrValue(str)
diff --git a/src/vm/tests/test-disk-uuid.js b/src/vm/tests/test-disk-uuid.js
new file mode 100644
index 00000000..3199b68f
--- /dev/null
+++ b/src/vm/tests/test-disk-uuid.js
@@ -0,0 +1,562 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2019, Joyent, Inc.
+ *
+ */
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var common = require('./common');
+var jsprim = require('/usr/vm/node_modules/jsprim');
+var libuuid = require('/usr/node/node_modules/uuid');
+var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
+var utils = require('/usr/vm/node_modules/utils');
+var vasync = require('/usr/vm/node_modules/vasync');
+var VM = require('/usr/vm/node_modules/VM');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+var vmtest = require('../common/vmtest.js');
+var zonecfg = require('/usr/vm/node_modules/zonecfg');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+VM.loglevel = 'DEBUG';
+
+var log = createLogger();
+
+/*
+ * nodeunit-plus executes the callback specified by before() before each test
+ * is run and executes the callback specified by after() after each test is run.
+ * These callbacks ensure that vmobj is initialized to undefined prior to each
+ * test and that any VM that was created by the test is deleted after the test
+ * completes.
+ *
+ * Tests that create a VM should be setting vmobj so that the after() hook can
+ * clean up the VM when the test finishes or gives up.  If a test uses vmobj
+ * then deletes the VM on its own, it should set vmobj to undefined.
+ */
+var vmobj;
+
+before(function _before(cb) {
+    assert.func(cb, 'cb');
+    vmobj = undefined;
+    cb();
+});
+
+after(function _after(cb) {
+    assert.func(cb, 'cb');
+    if (!vmobj) {
+        cb();
+        return;
+    }
+    VM.delete(vmobj.uuid, {}, function _delete_cb(err) {
+        if (err) {
+            console.log(sprintf('Could not delete vm %s: %s', vmobj.uuid,
+                err.message));
+        }
+        vmobj = undefined;
+        cb();
+    });
+});
+
+/*
+ * For use at the beginning of vasync.waterfall.  The next task (and presumably
+ * remaining tasks) is expected to take args (t, next).
+ *
+ * Creates a VM with the specified payload and stores a skeleton vmobj that
+ * contains at least vmobj.uuid.
+ */
+function createVM(t, payload, next)
+{
+    VM.create(payload, function _create_cb(err, obj) {
+        if (err) {
+            t.ok(false, 'error creating VM: ' + err);
+        } else {
+            t.ok(true, 'VM created with uuid ' + obj.uuid);
+        }
+        vmobj = obj;
+        next(err, t);
+    });
+}
+
+/*
+ * For use in vasync.waterfall.
+ *
+ * Call VM.start() and wait for the zone_state to go to 'running'.  If it does
+ * not go to running, the remaining tasks will be skipped.
+ */
+function startVM(t, next)
+{
+    VM.start(vmobj.uuid, {}, function _start_cb(err) {
+        if (err) {
+            t.ok(false, 'error starting VM: ' + err);
+            next(err);
+            return;
+        }
+        VM.waitForZoneState(vmobj, 'running', function waitRunning(_err) {
+            common.ifError(t, _err, 'zone start');
+            next(_err, t);
+        });
+    });
+}
+
+/*
+ * For use in vasync.waterfall.
+ *
+ * Call VM.stop() and wait for the zone_state to be 'installed'.  If it does not
+ * go to installed, the remaining tasks will be skipped.
+ */
+function stopVM(t, next)
+{
+    VM.stop(vmobj.uuid, {force: true}, function _stop_cb(err) {
+        if (err) {
+            t.ok(false, 'error stoping VM: ' + err);
+            next(err);
+            return;
+        }
+        VM.waitForZoneState(vmobj, 'installed', function waitInstalled(_err) {
+            common.ifError(t, _err, 'zone stop');
+            next(_err, t);
+        });
+    });
+}
+
+/*
+ * For use in vasync.waterfall.
+ *
+ * Reload vmobj from vminfod.
+ */
+function loadVM(t, next)
+{
+    VM.load(vmobj.uuid, function _load_cb(err, obj) {
+        if (err) {
+            t.ok(false, 'error loading VM: ' + err);
+        } else {
+            t.ok(true, sprintf('VM loaded uuid %s state %s zone_state %s',
+                obj.uuid, obj.state, obj.zone_state));
+            vmobj = obj;
+        }
+        next(err, t);
+    });
+}
+
+/*
+ * For use in vasync.waterfall.
+ */
+function checkRunning(t, next)
+{
+    t.equal(vmobj.state, 'running', 'VM is running');
+    next(null, t);
+}
+
+/*
+ * For use in vasync.waterfall.
+ */
+function checkStopped(t, next)
+{
+    t.equal(vmobj.state, 'stopped', 'VM is stopped');
+    next(null, t);
+}
+
+/*
+ * For use in vasync.waterfall.
+ *
+ * Check that each disk has a uuid.  This also useful for times where a list of
+ * the disks' uuids in test output would be nice - such as after adding or
+ * removing disks so that you can have comfort that the test is really doing
+ * what it says.
+ */
+function verifyDisksHaveUuids(t, next)
+{
+    var i, disk;
+    for (i = 0; i < vmobj.disks.length; i++) {
+        disk = vmobj.disks[i];
+        if (!disk.hasOwnProperty('uuid')) {
+            t.ok(false, 'disk missing uuid: ' + JSON.stringify(disk));
+        } else {
+            t.ok(utils.isUUID(disk.uuid), 'disk has valid uuid: ' + disk.uuid);
+        }
+    }
+    next(null, t);
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Verify that disk.*.uuid is not set.
+ */
+function verifyDisksHaveNoUuids(t, next)
+{
+    var i, disk;
+    for (i = 0; i < vmobj.disks.length; i++) {
+        disk = vmobj.disks[i];
+        t.equal(disk.uuid, undefined,
+            'disk ' + disk.path + ' should not have uuid');
+    }
+    next(null, t);
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Use zonecfg to remove disk.*.uuid.
+ */
+function removeDiskUuids(t, next)
+{
+    var vs = new vminfod.VminfodEventStream({
+        name: 'test-disk-uuid',
+        log: log
+    });
+    var cancelFn;
+    var zcfg = '';
+    var changes = [];
+    var i;
+
+    assert.notEqual(vmobj.disks.length, 0, 'must have disks');
+    for (i = 0; i < vmobj.disks.length; i++) {
+        var disk = vmobj.disks[i];
+        assert.uuid(disk.uuid, 'disk.uuid for ' + disk.path);
+        zcfg += sprintf('select device match=%s;'
+            + 'remove property (name=uuid,value="%s"); end;\n',
+            disk.path, disk.uuid);
+        changes.push({
+            path: ['disks', null, 'uuid'],
+            action: 'removed',
+            oldValue: disk.uuid
+        });
+    }
+
+    vs.once('ready', function () {
+        vasync.parallel({funcs: [
+            function _watcher(cb) {
+                var obj = {
+                    uuid: vmobj.uuid
+                };
+                var _opts = {
+                    timeout: 5000,
+                    catchErrors: true,
+                    teardown: true
+                };
+                cancelFn = vs.watchForChanges(obj, changes, _opts, cb);
+            },
+            function _zonecfg(cb) {
+                zonecfg(vmobj.uuid, [], {log: log, stdin: zcfg},
+                    function (err, fds) {
+
+                    common.ifError(t, err, 'remmove disk uuids');
+                    if (err) {
+                        cancelFn();
+                        cb(err);
+                        return;
+                    }
+                    cb();
+                });
+            }
+        ]}, function _done(err, results) {
+            vs.stop();
+            next(null, t);
+        });
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Before addDisk* is successful vmobj.disks should have two items.  This is
+ * called frequently to ensure that expected failures really failed.
+ *
+ * vmobj is reloaded on success.
+ */
+function haveTwoDisks(t, next)
+{
+    t.equal(vmobj.disks.length, 2, 'should have two disks');
+    next(null, t);
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Add a disk with the expectation that VM.js will automatically assign a uuid.
+ *
+ * vmobj is reloaded on success.
+ */
+function addDiskWithoutUuid(t, next)
+{
+    addDisks(t, [null], function _addDiskWithoutUuid(err) {
+        t.equal(err, null, 'added one disk without uuid');
+        next(null, t);
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Add a disk with a random uuid.
+ *
+ * vmobj is reloaded on success.
+ */
+function addDiskWithUuid(t, next)
+{
+    addDisks(t, [libuuid.create()], function _addDiskWithoutUuid(err) {
+        t.equal(err, null, 'added one disk with uuid');
+        next(null, t);
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Verify that adding disks with various bogus uuids fails.
+ */
+function addDisksWithBogusUuid(t, next)
+{
+    vasync.forEachPipeline({
+        inputs: ['', 'not-a-uuid', 0, ['also', 'not', 'a', 'uuid']],
+        func: function eachBogusUuid(uuid, callback) {
+            addDisks(t, [uuid], function _addDisksWithBogusUuid(err) {
+                checkError(t, err, 'Invalid value(s) for: disks.*.uuid',
+                    'bogus uuid ' + JSON.stringify(uuid) + ' not allowed');
+                callback();
+            });
+        }
+    }, function done() {
+        next(null, t);
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Add two disks at once, each with a unique uuid.
+ *
+ * vmobj is reloaded on success.
+ */
+function addTwoDisksWithUniqueUuids(t, next)
+{
+    var uuids = [libuuid.create(), libuuid.create()];
+
+    addDisks(t, uuids, function _addTwoDisksWithUniqueUuids(err) {
+        t.equal(err, null, 'add two disks with unique uuids');
+        next(null, t);
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Verify that when duplicate uuids in the payload are detected.
+ */
+function addTwoDisksWithDuplicateUuids(t, next)
+{
+    var uuids = [libuuid.create()];
+    uuids.push(uuids[0]);
+
+    addDisks(t, uuids, function _addTwoDisksWithDuplicateUuids(err) {
+        checkError(t, err, 'duplicate disk uuid',
+            'error expected when adding multiple disks with same uuid');
+        next(null, t);
+    });
+}
+
+/*
+ * For use with vasync.waterfall.
+ *
+ * Verify failure to add a new disk that has the same uuid as an existing disk.
+ */
+function addDiskWithExistingUuid(t, next)
+{
+    var uuids = [vmobj.disks[0].uuid];
+
+    addDisks(t, uuids, function _addDiskWithExistingUuid(err) {
+        checkError(t, err, 'duplicate disk uuid',
+            'error expected when adding disks with in-use uuid');
+        next(null, t);
+    });
+}
+
+/*
+ * Verify that err looks like an Error with err.message starting with err.  msg
+ * is the message logged by assertplus.
+ */
+function checkError(t, err, errmsg, msg) {
+    if (!err || !err.hasOwnProperty('message')) {
+        t.ok(false, msg + ': expected an Error with message "' + errmsg
+            + '", got ' + err);
+
+        return;
+    }
+    t.equal(err.message.slice(0, errmsg.length), errmsg, msg);
+}
+
+/*
+ * Adds a small disk for each uuid passed in uuids.  If an element of the uuids
+ * array is null, the corresponding disk has no uuid.
+ *
+ * On successful add, vmobj is reloaded and the presence of disks with the new
+ * uuids is verified.
+ */
+function addDisks(t, uuids, callback)
+{
+    var disks = uuids.map(function uuidToDisk(uuid) {
+        var disk = {
+            size: 10,
+            model: 'virtio'
+        };
+        if (uuid !== null) {
+            disk.uuid = uuid;
+        }
+        return disk;
+    });
+
+    vasync.waterfall([
+        function doUpdate(next) {
+            VM.update(vmobj.uuid, {add_disks: disks}, next);
+        },
+        function doLoad(next) {
+            VM.load(vmobj.uuid, next);
+        },
+        function checkUuids(obj, next) {
+            assert.object(obj);
+            assert.object(obj.disks);
+            vmobj = obj;
+
+            var newuuids = obj.disks.map(function mapDisk(disk) {
+                return disk.uuid;
+            });
+            var i, uuid;
+            for (i = 0; i < uuids.length; i++) {
+                uuid = uuids[i];
+                if (uuid != null) {
+                    t.ok(newuuids.indexOf(uuid) !== -1,
+                        'new disk with uuid ' + uuid + ' found in config');
+                }
+            }
+            next();
+        }],
+        function _done(err) {
+            callback(err);
+        });
+}
+
+var base_payload = {
+    alias: 'test-disk-uuid-' + process.pid,
+    brand: 'bhyve',
+    do_not_inventory: true,
+    autoboot: false,
+    ram: 256,
+    vcpus: 1,
+    disks: [
+        {
+            image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+            boot: true,
+            model: 'virtio'
+        },
+        {
+            size: 100,
+            model: 'virtio'
+        }
+    ],
+    flexible_disk_size: 15 * 1024
+};
+
+function diskUuidTest(name, steps)
+{
+    var payload = jsprim.deepCopy(base_payload);
+
+    test(name, function doTest(t) {
+        vasync.waterfall([
+            function _create(next) {
+                createVM(t, payload, next);
+            },
+            loadVM,
+            checkStopped,
+            verifyDisksHaveUuids,
+            haveTwoDisks
+        ].concat(steps),
+        function _done() {
+            t.end();
+        });
+    });
+}
+
+diskUuidTest(
+    'uuid is optional in the add_disk payload and uuids are assigned', [
+
+    addDiskWithoutUuid,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('add one disk with a uuid', [
+    addDiskWithUuid,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('add multiple disks with uuids', [
+    addTwoDisksWithUniqueUuids,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('duplicate disks.*.uuids in payload are detected', [
+    addTwoDisksWithDuplicateUuids,
+    loadVM,
+    haveTwoDisks,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('collision with existing disks are detected', [
+    addDiskWithExistingUuid,
+    loadVM,
+    haveTwoDisks,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('bogus uuids are not allowed', [
+    addDisksWithBogusUuid,
+    loadVM,
+    haveTwoDisks,
+    verifyDisksHaveUuids
+]);
+
+diskUuidTest('starting and stopping the VM does not lose uuids', [
+    startVM,
+    loadVM,
+    checkRunning,
+    verifyDisksHaveUuids,
+    haveTwoDisks,
+    stopVM,
+    loadVM,
+    checkStopped,
+    verifyDisksHaveUuids,
+    haveTwoDisks
+]);
+
+diskUuidTest('disks without uuids have uuids assigned at next boot', [
+    removeDiskUuids,
+    loadVM,
+    verifyDisksHaveNoUuids,
+    haveTwoDisks,
+    startVM,
+    loadVM,
+    verifyDisksHaveUuids,
+    haveTwoDisks
+]);
