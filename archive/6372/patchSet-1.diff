From ff8d69e0eabd81670702f03844d6192886898f75 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Thu, 30 May 2019 16:51:16 +0200
Subject: [PATCH] TRITON-1320 firewaller-agent needs to rewrite ipf rules on
 boot

---
 config-migration.js                           | 193 ++++++++++++++++++
 deps/fw/lib/fw.js                             |  48 ++++-
 npm/postinstall.sh                            |   7 +
 npm/postuninstall.sh                          |   6 +
 .../firewaller-config-migration.xml.in        |  69 +++++++
 5 files changed, 315 insertions(+), 8 deletions(-)
 create mode 100644 config-migration.js
 create mode 100644 smf/manifests/firewaller-config-migration.xml.in

diff --git a/config-migration.js b/config-migration.js
new file mode 100644
index 0000000..4d89759
--- /dev/null
+++ b/config-migration.js
@@ -0,0 +1,193 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Firewaller agent config migration from/to pre/post cfwlogging
+ * See https://github.com/joyent/rfd/blob/master/rfd/0163/README.md
+ */
+
+'use strict';
+
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+
+var vm = require('./lib/vm');
+var fw = require('./lib/fw');
+
+var fs = require('fs');
+var util = require('util');
+
+var LOG = bunyan.createLogger({
+    name: 'firewaller',
+    level: 'debug'
+});
+
+var DEV_IPFEV = '/dev/ipfev';
+var IPF_CONF = '%s/config/ipf.conf';
+var IPF6_CONF = '%s/config/ipf6.conf';
+
+vasync.pipeline({
+    funcs: [
+        // Get all the local VMs with firewall_enabled=true
+        function loadFwEnabledVms(ctx, next) {
+            vm.list(LOG, {
+                firewall_enabled: true
+            }, function listVmsCb(err, vms) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.vms = vms;
+                next();
+            });
+        },
+        // Load all the firewall rules for those vms
+        function loadFwEnabledRules(ctx, next) {
+            if (!ctx.vms.length) {
+                next();
+                return;
+            }
+            fw.list({
+                log: LOG,
+                payload: {
+                    localVMs: ctx.vms,
+                    vms: ctx.vms
+                }
+            }, function listRulesCb(err, rules) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.rules = rules;
+                next();
+            });
+        },
+        // We're interested only into firewall rules which have `rule.log` set
+        function filterRulesWithSetTags(ctx, next) {
+            if (!ctx.rules.length) {
+                next();
+                return;
+            }
+            ctx.rules = ctx.rules.filter(function ruleHasTags(rule) {
+                return (rule.log && rule.uuid);
+            });
+            next();
+        },
+        // Since firewall rules doesn't keep a reference to the VM they belong
+        // to, we need to figure out which VM UUIDs we're gonna need to check
+        // based into the firewall rules
+        function getVmsForRulesWithSetTags(ctx, next) {
+            if (!ctx.rules.length) {
+                next();
+                return;
+            }
+            ctx.rulesByVmUUID = {};
+            ctx.vmsByVmUUID = {};
+            vasync.forEachParallel({
+                inputs: ctx.rules,
+                func: function getRuleVm(rule, nextRule) {
+                    fw.vms({
+                        log: LOG,
+                        payload: {
+                            rule: rule,
+                            vms: ctx.vms
+                        }
+                    }, function getRuleVmCb(getErr, vmUuids) {
+                        if (getErr) {
+                            nextRule(getErr);
+                            return;
+                        }
+                        vmUuids.forEach(function addToCtx(vmUuid) {
+                            if (!ctx.vmsByVmUUID[vmUuid]) {
+                                ctx.vmsByVmUUID[vmUuid] = ctx.vms.filter(
+                                    function getVmByUUID(aVm) {
+                                        return (aVm.uuid === vmUuid);
+                                    })[0];
+                            }
+                            if (!ctx.rulesByVmUUID[vmUuid]) {
+                                ctx.rulesByVmUUID[vmUuid] = [];
+                            }
+                            ctx.rulesByVmUUID[vmUuid].push(rule);
+                        });
+                        nextRule();
+                    });
+                }
+            }, next);
+        },
+        // Once we know which vms to check, we need to review the contents of
+        // the IPF files
+        function checkIPFVersions(ctx, next) {
+            if (!ctx.rulesByVmUUID) {
+                next();
+                return;
+            }
+            ctx.vmsToRewriteIPF = [];
+            var vmsToCheck = Object.keys(ctx.rulesByVmUUID);
+            LOG.debug({vmsToCheck: vmsToCheck}, 'VMs to check');
+            if (!vmsToCheck.length) {
+                next();
+                return;
+            }
+            vasync.forEachParallel({
+                inputs: Object.keys(ctx.rulesByVmUUID),
+                func: function testIPFFiles(aVm, nextVm) {
+                    var ipfv4 = util.format(IPF_CONF,
+                        ctx.vmsByVmUUID[aVm].zonepath);
+                    var ipfv6 = util.format(IPF6_CONF,
+                        ctx.vmsByVmUUID[aVm].zonepath);
+                    var ipfv4Data = fs.readFileSync(ipfv4, 'utf8');
+                    var ipfv6Data = fs.readFileSync(ipfv6, 'utf8');
+                    var re = /^# smartos_ipf_version 2$/m;
+                    // If we already are at SmartOS IPF v2:
+                    if (re.test(ipfv4Data) || re.test(ipfv6Data)) {
+                        // We need to rewrite rules to v1 version if the system
+                        // doesn't yet have /dev/ipfev
+                        if (!ctx.haveDefIpfEv) {
+                            ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[aVm]);
+                        }
+                    } else if (ctx.haveDefIpfEv) {
+                        // If we're at SmartOS IPF v1 and teh system has
+                        // /dev/ipfev we need to rewrite the rules to v2 version
+                            ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[aVm]);
+                    }
+                    LOG.debug({
+                        smartos_ipf_version: (re.test(ipfv4Data) ||
+                            re.test(ipfv6Data)) ? 2 : 1,
+                        have_dev_ifev: ctx.have_dev_ifev,
+                        vm_uuid: aVm
+                    }, 'SmartOS IPF version check');
+                    nextVm();
+                }
+            }, next);
+        },
+        function updateIpfFiles(ctx, next) {
+            if (!ctx.vmsToRewriteIPF || !ctx.vmsToRewriteIPF.length) {
+                next();
+                return;
+            }
+            fw.update({
+                log: LOG,
+                payload: {
+                    localVms: ctx.vmsToRewriteIPF
+                }
+            }, next);
+        }
+    ],
+    arg: {
+        haveDefIpfEv: fs.existsSync(DEV_IPFEV)
+    }
+}, function pipeCb(pipeErr) {
+    if (pipeErr) {
+        console.error(pipeErr);
+    }
+});
+
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/deps/fw/lib/fw.js b/deps/fw/lib/fw.js
index 1ee415f..14d76c8 100644
--- a/deps/fw/lib/fw.js
+++ b/deps/fw/lib/fw.js
@@ -21,7 +21,7 @@
  * CDDL HEADER END
  *
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  *
  * fwadm: Main entry points
@@ -105,6 +105,9 @@ var v6fallbacks = fallbacks.concat([
     'pass out quick proto ipv6-icmp from any to any keep state',
     'pass out proto ipv6-icmp from any to any']);
 
+// Do not use directly - use haveIpfEventLogger() instead.
+var haveDevIpfEv = undefined;
+var DEV_IPFEV = '/dev/ipfev';
 
 // --- Internal helper functions
 
@@ -120,6 +123,17 @@ function assertStringOrObject(obj, name) {
 }
 
 
+/**
+ * Determine if /dev/ipfev exists, caching the result for future calls in the
+ * global variable haveDevIpfEv.
+ */
+function haveIpfEventLogger() {
+    if (haveDevIpfEv === undefined) {
+        haveDevIpfEv = fs.existsSync(DEV_IPFEV);
+    }
+    return haveDevIpfEv;
+}
+
 /**
  * For a rule and a direction, return whether or not we actually need to
  * write ipf rules. FROM+ALLOW and TO+BLOCK are essentially no-ops, as
@@ -1083,6 +1097,16 @@ function ipfRuleObj(opts) {
     // ipfilter uses /etc/protocols which calls ICMPv6 'ipv6-icmp'
     var ipfProto = (rule.protocol === 'icmp6') ? 'ipv6-icmp' : rule.protocol;
 
+    var readtags = [];
+    if (haveIpfEventLogger()) {
+        if (rule.uuid) {
+            readtags.push(util.format('uuid=%s', rule.uuid));
+        }
+        if (rule.log) {
+            readtags.push('cfwlog');
+        }
+    }
+
     var sortObj = {
         action: rule.action,
         direction: dir,
@@ -1097,7 +1121,9 @@ function ipfRuleObj(opts) {
         type: opts.type,
         uuid: rule.uuid,
         value: opts.value,
-        version: rule.version
+        version: rule.version,
+        allTags: readtags.length !== 0 ?
+            util.format(' set-tag(%s)', readtags.join(', ')) : ''
     };
 
     if (opts.type === 'wildcard' && opts.value === 'any') {
@@ -1252,16 +1278,22 @@ function prepareIPFdata(opts, log, callback) {
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
-            '#',
-            ''];
+            '#'
+        ];
+        if (haveIpfEventLogger()) {
+            ipf4Conf.push('# smartos_ipf_version 2');
+        }
+        ipf4Conf.push('#', '');
         var ipf6Conf = ipf4Conf.slice();
         var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
         conf[vm].sort(compareRules).forEach(function (sortObj) {
+            assert.string(sortObj.allTags, 'sortObj.allTags');
             var ktxt = KEEP_FRAGS;
-            if ((sortObj.direction === 'from' && sortObj.action === 'allow')
+            if (sortObj.allTags !== ''
+                || (sortObj.direction === 'from' && sortObj.action === 'allow')
                 || (sortObj.direction === 'to' && iks[sortObj.protocol])) {
-                ktxt += KEEP_STATE;
+                ktxt += KEEP_STATE + sortObj.allTags;
             }
 
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
@@ -2183,7 +2215,7 @@ function listRemoteVMs(opts, callback) {
 
             // XXX: support sorting by other fields, filtering
             var sortFn = function _sort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
 
             log.debug('listRemoteVMs: finish');
@@ -2238,7 +2270,7 @@ function listRules(opts, callback) {
             // XXX: support sorting by other fields, filtering
             // (eg: enabled=true vm=<uuid>)
             var sortFn = function _defaultSort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
             var mapFn = function _defaultMap(r) {
                 return r.serialize();
diff --git a/npm/postinstall.sh b/npm/postinstall.sh
index 645f079..2032c5a 100755
--- a/npm/postinstall.sh
+++ b/npm/postinstall.sh
@@ -65,6 +65,13 @@ function import_smf_manifest()
     if [[ $(uname -s) == "SunOS" ]]; then
         svccfg import $SMF_DIR/${AGENT}-setup.xml
     fi
+
+
+    subfile "$ROOT/smf/manifests/${AGENT}-config-migration.xml.in" \
+        "$SMF_DIR/${AGENT}-config-migration.xml"
+    if [[ $(uname -s) == "SunOS" ]]; then
+        svccfg import $SMF_DIR/${AGENT}-config-migration.xml
+    fi
 }
 
 function instance_exists()
diff --git a/npm/postuninstall.sh b/npm/postuninstall.sh
index e3ea84c..76a8cb4 100755
--- a/npm/postuninstall.sh
+++ b/npm/postuninstall.sh
@@ -20,6 +20,12 @@ NAME=firewaller
 if [[ $(uname -s) == "SunOS" ]]; then
     svcadm disable -s $NAME
     svccfg delete $NAME
+    svcadm disable -s $NAME-agent-setup
+    svccfg delete $NAME-agent-setup
+    svcadm disable -s $NAME-config-migration
+    svccfg delete $NAME-config-migration
 fi
 
 rm -f "$SMFDIR/$NAME.xml"
+rm -f "$SMFDIR/$NAME-agent-setup.xml"
+rm -f "$SMFDIR/$NAME-config-migration.xml"
diff --git a/smf/manifests/firewaller-config-migration.xml.in b/smf/manifests/firewaller-config-migration.xml.in
new file mode 100644
index 0000000..4ecaec4
--- /dev/null
+++ b/smf/manifests/firewaller-config-migration.xml.in
@@ -0,0 +1,69 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+<!--
+    Firewaller agent SMF manifest
+ -->
+
+<service_bundle type="manifest" name="firewaller">
+<service name="smartdc/agent/firewaller-config-migration" type="service" version="@@VERSION@@">
+
+<dependency name="network" grouping="require_all" restart_on="error" type="service">
+        <service_fmri value="svc:/network/physical" />
+</dependency>
+<dependency name="filesystem" grouping="require_all" restart_on="error" type="service">
+        <service_fmri value="svc:/system/filesystem/local" />
+</dependency>
+
+<dependent name="smartdc_vmadmd" grouping="optional_all" restart_on="none">
+        <service_fmri value='svc:/system/smartdc/vmadmd:default' />
+</dependent>
+<dependent name="system_zones" grouping="optional_all" restart_on="none">
+        <service_fmri value='svc:/system/zones:default' />
+</dependent>
+
+<exec_method
+  type="method"
+  name="start"
+  exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js &amp;"
+  timeout_seconds="60">
+  <method_context>
+    <method_credential user="root" group="staff"/>
+    <method_environment>
+      <envvar name="PATH" value="@@PREFIX@@/bin:/usr/bin:/usr/sbin"/>
+    </method_environment>
+  </method_context>
+</exec_method>
+
+<exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
+  <method_context>
+    <method_credential user="root" group="staff"/>
+  </method_context>
+</exec_method>
+
+<exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+  <method_context>
+    <method_credential user="root" group="staff"/>
+  </method_context>
+</exec_method>
+
+
+<instance name="default" enabled="true" />
+
+<stability value='Unstable' />
+
+<template>
+        <common_name><loctext xml:lang="C">Firewaller Agent</loctext></common_name>
+</template>
+
+</service>
+</service_bundle>
-- 
2.21.0

