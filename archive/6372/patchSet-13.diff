From 409fa94f1af97e46483779e0843844c216ae1f7c Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Mon, 10 Jun 2019 19:30:08 +0200
Subject: [PATCH] TRITON-1320 firewaller-agent needs to rewrite ipf rules on
 boot Reviewed by: Cody Peter Mello <melloc@writev.io>

---
 config-migration.js                           | 192 +++++++++++
 deps/fw/lib/fw.js                             |  58 +++-
 deps/fw/node_modules/fwrule/rule.js           |  16 +-
 deps/fw/test/lib/mocks.js                     |  23 +-
 deps/fw/test/unit/add.test.js                 |  13 +-
 deps/fw/test/unit/fw.test.js                  | 203 ++++++------
 deps/fw/test/unit/global.test.js              |  12 +-
 deps/fw/test/unit/icmp.test.js                |  12 +-
 deps/fw/test/unit/log.test.js                 | 298 ++++++++++++++++++
 deps/fw/test/unit/owner.test.js               |   9 +-
 deps/fw/test/unit/tags.test.js                |   8 +-
 deps/fw/test/unit/update.test.js              |  13 +-
 deps/fw/test/unit/wildcards.test.js           |  14 +-
 npm/postinstall.sh                            |   8 +-
 npm/postuninstall.sh                          |   8 +-
 .../firewaller-config-migration.xml.in        |  57 ++++
 16 files changed, 756 insertions(+), 188 deletions(-)
 create mode 100644 config-migration.js
 create mode 100644 deps/fw/test/unit/log.test.js
 create mode 100644 smf/manifests/firewaller-config-migration.xml.in

diff --git a/config-migration.js b/config-migration.js
new file mode 100644
index 0000000..3c6ee11
--- /dev/null
+++ b/config-migration.js
@@ -0,0 +1,192 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Firewaller agent config migration from/to pre/post cfwlogging
+ * See https://github.com/joyent/rfd/blob/master/rfd/0163/README.md
+ */
+
+'use strict';
+
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+
+var mod_vm = require('./lib/vm');
+var fw = require('./lib/fw');
+
+var fs = require('fs');
+var util = require('util');
+
+var LOG = bunyan.createLogger({
+    name: 'firewaller-config-migration',
+    level: 'debug'
+});
+
+var DEV_IPFEV = '/dev/ipfev';
+var IPF_CONF = '%s/config/ipf.conf';
+
+vasync.pipeline({
+    funcs: [
+        // Get all the local VMs with firewall_enabled=true
+        function loadFwEnabledVms(ctx, next) {
+            mod_vm.list(LOG, {
+                firewall_enabled: true
+            }, function listVmsCb(err, vms) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.vms = vms;
+                ctx.vmsByVmUUID = {};
+                ctx.vms.forEach(function (vm) {
+                    ctx.vmsByVmUUID[vm.uuid] = vm;
+                });
+                next();
+            });
+        },
+        // Load all the firewall rules for those vms
+        function loadFwEnabledRules(ctx, next) {
+            if (!ctx.vms.length) {
+                next();
+                return;
+            }
+            fw.list({
+                log: LOG,
+                payload: {
+                    localVMs: ctx.vms,
+                    vms: ctx.vms
+                }
+            }, function listRulesCb(err, rules) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.rules = rules;
+                next();
+            });
+        },
+        // We're interested only in firewall rules which have `rule.log` set
+        function filterRulesWithSetTags(ctx, next) {
+            if (!ctx.rules.length) {
+                next();
+                return;
+            }
+            ctx.rules = ctx.rules.filter(function ruleHasTags(rule) {
+                return rule.log;
+            });
+            next();
+        },
+        // Since firewall rules don't keep a reference to the VM they belong
+        // to, we need to figure out which VM UUIDs we're gonna need to check
+        // based into the firewall rules
+        function getVmsForRulesWithSetTags(ctx, next) {
+            if (ctx.rules.length === 0) {
+                next();
+                return;
+            }
+            ctx.rulesByVmUUID = {};
+            vasync.forEachParallel({
+                inputs: ctx.rules,
+                func: function getRuleVm(rule, nextRule) {
+                    fw.vms({
+                        log: LOG,
+                        payload: {
+                            rule: rule,
+                            vms: ctx.vms
+                        }
+                    }, function getRuleVmCb(getErr, vmUuids) {
+                        if (getErr) {
+                            nextRule(getErr);
+                            return;
+                        }
+                        vmUuids.forEach(function addToCtx(vmUuid) {
+                            if (!ctx.rulesByVmUUID[vmUuid]) {
+                                ctx.rulesByVmUUID[vmUuid] = [];
+                            }
+                            ctx.rulesByVmUUID[vmUuid].push(rule);
+                        });
+                        nextRule();
+                    });
+                }
+            }, next);
+        },
+        function getPlatformIPFVersion(ctx, next) {
+            var vFile = '/etc/ipf/smartos_version';
+            if (fs.existsSync(vFile)) {
+                ctx.ipfSmartosVersion = Number(fs.readFileSync(vFile, 'utf8'));
+            } else {
+                ctx.ipfSmartosVersion = (ctx.haveDevIpfEv) ? 2 : 1;
+            }
+            next();
+        },
+        // Once we know which vms to check, we need to review the contents of
+        // the IPF files
+        function checkIPFVersions(ctx, next) {
+            if (!ctx.rulesByVmUUID) {
+                next();
+                return;
+            }
+            ctx.vmsToRewriteIPF = [];
+            var vmsToCheck = Object.keys(ctx.rulesByVmUUID);
+            LOG.debug({vmsToCheck: vmsToCheck}, 'VMs to check');
+            if (!vmsToCheck.length) {
+                next();
+                return;
+            }
+            vasync.forEachParallel({
+                inputs: vmsToCheck,
+                func: function testIPFFiles(aVm, nextVm) {
+                    var ipfv4 = util.format(IPF_CONF,
+                        ctx.vmsByVmUUID[aVm].zonepath);
+                    var ipfv4Data = fs.readFileSync(ipfv4, 'utf8');
+                    var re = /^# smartos_ipf_version (\d+)$/m;
+                    var ipfv4Res = re.exec(ipfv4Data);
+                    // If we cannot find a version written on the rules file,
+                    // let's assume it's version 1 (pre RFD 163):
+                    var rulesVersion = (ipfv4Res !== null) ?
+                            Number(ipfv4Res[1]) : 1;
+                    if (rulesVersion !== ctx.ipfSmartosVersion) {
+                        ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[aVm]);
+                    }
+
+                    LOG.debug({
+                        smartos_ipf_version: ctx.ipfSmartosVersion,
+                        rules_ipf_version: rulesVersion,
+                        vm_uuid: aVm
+                    }, 'SmartOS IPF version check');
+                    nextVm();
+                }
+            }, next);
+        },
+        function updateIpfFiles(ctx, next) {
+            if (!Array.isArray(ctx.vmsToRewriteIPF) ||
+                ctx.vmsToRewriteIPF.length === 0) {
+                next();
+                return;
+            }
+            fw.update({
+                log: LOG,
+                payload: {
+                    localVms: ctx.vmsToRewriteIPF
+                }
+            }, next);
+        }
+    ],
+    arg: {
+        haveDevIpfEv: fs.existsSync(DEV_IPFEV)
+    }
+}, function pipeCb(pipeErr) {
+    if (pipeErr) {
+        console.error(pipeErr);
+    }
+});
+
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/deps/fw/lib/fw.js b/deps/fw/lib/fw.js
index 1ee415f..0b81260 100644
--- a/deps/fw/lib/fw.js
+++ b/deps/fw/lib/fw.js
@@ -21,7 +21,7 @@
  * CDDL HEADER END
  *
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  *
  * fwadm: Main entry points
@@ -105,6 +105,9 @@ var v6fallbacks = fallbacks.concat([
     'pass out quick proto ipv6-icmp from any to any keep state',
     'pass out proto ipv6-icmp from any to any']);
 
+// Do not use directly - use haveIpfEventLogger() instead.
+var haveDevIpfEv = undefined;
+var DEV_IPFEV = '/dev/ipfev';
 
 // --- Internal helper functions
 
@@ -120,6 +123,17 @@ function assertStringOrObject(obj, name) {
 }
 
 
+/**
+ * Determine if /dev/ipfev exists, caching the result for future calls in the
+ * global variable haveDevIpfEv.
+ */
+function haveIpfEventLogger() {
+    if (haveDevIpfEv === undefined) {
+        haveDevIpfEv = fs.existsSync(DEV_IPFEV);
+    }
+    return haveDevIpfEv;
+}
+
 /**
  * For a rule and a direction, return whether or not we actually need to
  * write ipf rules. FROM+ALLOW and TO+BLOCK are essentially no-ops, as
@@ -841,10 +855,8 @@ function validateRules(vms, rvms, rules, log, callback) {
                 sideData[rule.uuid][dir].vms[vm] = 1;
             }
             delete rulesLeft[rule.uuid];
-
         } else if (hasKey(rvms[type], t)) {
             delete rulesLeft[rule.uuid];
-
         } else {
             sideData[rule.uuid][dir].missing[type][t] = 1;
         }
@@ -901,7 +913,6 @@ function protoTarget(rule, target) {
     } else {
         if (hasKey(target, 'start')
             && hasKey(target, 'end')) {
-
             return 'port ' + target.start + ' : ' + target.end;
         } else {
             return 'port = ' + target;
@@ -1083,6 +1094,16 @@ function ipfRuleObj(opts) {
     // ipfilter uses /etc/protocols which calls ICMPv6 'ipv6-icmp'
     var ipfProto = (rule.protocol === 'icmp6') ? 'ipv6-icmp' : rule.protocol;
 
+    var readtags = [];
+    if (haveIpfEventLogger()) {
+        if (rule.uuid) {
+            readtags.push(util.format('uuid=%s', rule.uuid));
+        }
+        if (rule.log) {
+            readtags.push('cfwlog');
+        }
+    }
+
     var sortObj = {
         action: rule.action,
         direction: dir,
@@ -1097,7 +1118,9 @@ function ipfRuleObj(opts) {
         type: opts.type,
         uuid: rule.uuid,
         value: opts.value,
-        version: rule.version
+        version: rule.version,
+        allTags: readtags.length !== 0 ?
+            util.format(' set-tag(%s)', readtags.join(', ')) : ''
     };
 
     if (opts.type === 'wildcard' && opts.value === 'any') {
@@ -1107,10 +1130,8 @@ function ipfRuleObj(opts) {
                 dir === 'from' ? 'out' : 'in',
                 ipfProto,
                 protoTarget(rule, t));
-            if (rule.protocol !== 'icmp6')
-                sortObj.v4text.push(wild);
-            if (rule.protocol !== 'icmp')
-                sortObj.v6text.push(wild);
+            if (rule.protocol !== 'icmp6') { sortObj.v4text.push(wild); }
+            if (rule.protocol !== 'icmp') { sortObj.v6text.push(wild); }
         });
 
         return sortObj;
@@ -1252,16 +1273,21 @@ function prepareIPFdata(opts, log, callback) {
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
-            '#',
-            ''];
+            '#'
+        ];
+        if (haveIpfEventLogger()) {
+            ipf4Conf.push('# smartos_ipf_version 2');
+        }
+        ipf4Conf.push('#', '');
         var ipf6Conf = ipf4Conf.slice();
         var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
         conf[vm].sort(compareRules).forEach(function (sortObj) {
             var ktxt = KEEP_FRAGS;
-            if ((sortObj.direction === 'from' && sortObj.action === 'allow')
+            if (sortObj.allTags !== ''
+                || (sortObj.direction === 'from' && sortObj.action === 'allow')
                 || (sortObj.direction === 'to' && iks[sortObj.protocol])) {
-                ktxt += KEEP_STATE;
+                ktxt += KEEP_STATE + sortObj.allTags;
             }
 
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
@@ -1981,7 +2007,6 @@ function del(opts, callback) {
             throw new Error(
                 'Payload must contain one of: rvmUUIDs, uuids');
         }
-
     } catch (err) {
         return callback(err);
     }
@@ -2183,7 +2208,7 @@ function listRemoteVMs(opts, callback) {
 
             // XXX: support sorting by other fields, filtering
             var sortFn = function _sort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
 
             log.debug('listRemoteVMs: finish');
@@ -2238,7 +2263,7 @@ function listRules(opts, callback) {
             // XXX: support sorting by other fields, filtering
             // (eg: enabled=true vm=<uuid>)
             var sortFn = function _defaultSort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
             var mapFn = function _defaultMap(r) {
                 return r.serialize();
@@ -2709,7 +2734,6 @@ function getRemoteTargets(opts, callback) {
         if (opts.rules.length === 0) {
             throw new Error('Must specify rules');
         }
-
     } catch (err) {
         return callback(err);
     }
diff --git a/deps/fw/node_modules/fwrule/rule.js b/deps/fw/node_modules/fwrule/rule.js
index 8032a3f..6904fe0 100644
--- a/deps/fw/node_modules/fwrule/rule.js
+++ b/deps/fw/node_modules/fwrule/rule.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2019, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: firewall rule model
@@ -48,6 +48,7 @@ var FIELDS = [
     'description',
     'enabled',
     'global',
+    'log',
     'owner_uuid',
     'rule',
     'uuid',
@@ -379,6 +380,18 @@ function FwRule(data, opts) {
         this.enabled = false;
     }
 
+    if (hasOwnProperty(data, 'log')) {
+        if (!validators.bool(data.log)) {
+            errs.push(new validators.InvalidParamError('log',
+                'log must be true or false'));
+        }
+
+        this.log = data.log;
+    } else {
+        this.log = false;
+    }
+
+
     for (var s in STRING_PROPS) {
         var str = STRING_PROPS[s];
         if (hasOwnProperty(data, str)) {
@@ -591,6 +604,7 @@ FwRule.prototype.raw = function () {
     var raw = {
         action: this.action,
         enabled: this.enabled,
+        log: this.log,
         from: this.from,
         priority: this.priority,
         protocol: this.protocol,
diff --git a/deps/fw/test/lib/mocks.js b/deps/fw/test/lib/mocks.js
index d2fb122..30f6030 100644
--- a/deps/fw/test/lib/mocks.js
+++ b/deps/fw/test/lib/mocks.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * mocks for tests
  */
@@ -43,7 +43,8 @@ var MOCKS = {
         rename: rename,
         link: link,
         unlink: unlink,
-        writeFile: writeFile
+        writeFile: writeFile,
+        existsSync: existsSync
     },
     './locker': {
         acquireSharedLock: acquireLock,
@@ -52,8 +53,6 @@ var MOCKS = {
     },
     mkdirp: mkdirp
 };
-var ORIG_PROCESS;
-var PID;
 
 
 
@@ -238,6 +237,12 @@ function execFile(path, args, opts, cb) {
 
 // --- fs
 
+function existsSync(file) {
+    var p = _splitFile(file);
+    var root = VALUES.fs;
+
+    return hasKey(root, p.dir) && hasKey(root[p.dir], p.file);
+}
 
 function stat(file, cb) {
     var p = _splitFile(file);
@@ -360,16 +365,6 @@ mkdirp.sync = function mkdirpSync(dir) {
 
 
 
-// --- path
-
-
-
-function basename(file) {
-    return file;
-}
-
-
-
 // --- Setup / Teardown
 
 
diff --git a/deps/fw/test/unit/add.test.js b/deps/fw/test/unit/add.test.js
index 1dd634b..111a53f 100644
--- a/deps/fw/test/unit/add.test.js
+++ b/deps/fw/test/unit/add.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm add unit tests
  */
@@ -9,13 +9,8 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
 var mod_uuid = require('uuid');
 var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var createSubObjects = mod_obj.createSubObjects;
-var mergeObjects = mod_obj.mergeObjects;
 
 
 
@@ -26,7 +21,6 @@ var mergeObjects = mod_obj.mergeObjects;
 // Set this to any of the exports in this file to only run that test,
 // plus setup and teardown
 var runOne;
-var printVMs = false;
 
 
 
@@ -84,6 +78,8 @@ exports['created_by'] = function (t) {
 
     var expRules = clone(payload.rules);
     expRules[0].created_by = payload.createdBy;
+    expRules[0].log = false;
+    expRules[1].log = false;
 
     var expRulesOnDisk = {};
 
@@ -139,6 +135,7 @@ exports['created_by'] = function (t) {
         changing.version = '2383205215597.167882';
         expRules = clone(payload.rules);
         expRules[0].created_by = payload.createdBy;
+        expRules[0].log = false;
         expRulesOnDisk[changing.uuid].version = changing.version;
 
         fw.add(payload, function (err, res) {
@@ -167,6 +164,8 @@ exports['created_by'] = function (t) {
         payload.rules[1].uuid = mod_uuid.v4();
         expRules = clone(payload.rules);
         expRules[0].created_by = payload.createdBy;
+        expRules[0].log = false;
+        expRules[1].log = false;
 
         fw.update(payload, function (err, res) {
             t.ifError(err);
diff --git a/deps/fw/test/unit/fw.test.js b/deps/fw/test/unit/fw.test.js
index cee1515..2a46efb 100644
--- a/deps/fw/test/unit/fw.test.js
+++ b/deps/fw/test/unit/fw.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm tests
  */
@@ -30,13 +30,7 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('uuid');
 var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var mergeObjects = mod_obj.mergeObjects;
-
 
 
 // --- Globals
@@ -78,7 +72,8 @@ exports['add: no rules or VMs'] = function (t) {
     fw.add({}, function (err, res) {
         t.ok(err, 'error returned');
         if (!err) {
-            return t.done();
+            t.done();
+            return;
         }
 
         t.equal(err.message, 'opts.vms ([object]) required', 'VMs required');
@@ -124,7 +119,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             t.ok(res.rules[0].uuid, 'rule has a uuid');
@@ -133,6 +129,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
             t.ok(res.rules[0].version, 'rule has a version');
             expRule.version = res.rules[0].version;
 
+            expRule.log = false;
+
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
                 rules: [ expRule ]
@@ -157,22 +155,22 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwGetEquals(t, expRule, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwListEquals(t, [expRule], cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.vmsAffected({
             t: t,
             allVMs: [vm],
             rule: expRule,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         var updatePayload = {
             rules: [
                 {
@@ -188,7 +186,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
         fw.update(updatePayload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             t.equal(res.rules[0].uuid, expRule.uuid, 'uuid is the same');
@@ -219,30 +218,30 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwGetEquals(t, expRule, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwListEquals(t, [expRule], cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwRulesEqual({
             t: t,
             rules: [ expRule ],
             vm: vm,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.vmsAffected({
             t: t,
             allVMs: [vm],
             rule: expRule,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         // Disabling and re-enabling the firewall should have no effect on the
         // zone rules
         helpers.testEnableDisable({
@@ -250,7 +249,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
             vm: vm,
             vms: [vm]
         }, cb);
-    }, function (cb) {
+    },
+    function (cb) {
         // Delete the rule - the firewall should remain running, but only the
         // default rules should remain
 
@@ -262,7 +262,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
         fw.del(delPayload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             t.deepEqual(res, {
@@ -284,8 +285,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwRulesEqual({
             t: t,
             rules: [ ],
@@ -294,7 +295,8 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
         }, cb);
     }
 
-    ], function () {
+    ],
+    function () {
         t.done();
     });
 };
@@ -321,7 +323,8 @@ exports['add / update: vm to IP: ALLOW'] = function (t) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             helpers.fillInRuleBlanks(res.rules, expRule);
@@ -347,13 +350,10 @@ exports['add / update: vm to IP: ALLOW'] = function (t) {
 
             cb();
         });
-
     }, function (cb) {
         helpers.fwGetEquals(t, expRule, cb);
-
     }, function (cb) {
         helpers.fwListEquals(t, [expRule], cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -361,7 +361,6 @@ exports['add / update: vm to IP: ALLOW'] = function (t) {
             rule: expRule,
             vms: [vm]
         }, cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -378,8 +377,8 @@ exports['add / update: vm to IP: ALLOW'] = function (t) {
 
 
 exports['add: tag to IP'] = function (t) {
-    var vm1 = helpers.generateVM({ tags: { foo : true } });
-    var vm2 = helpers.generateVM({ tags: { foo : true } });
+    var vm1 = helpers.generateVM({ tags: { foo: true } });
+    var vm2 = helpers.generateVM({ tags: { foo: true } });
     var payload = {
         rules: [
             {
@@ -398,7 +397,8 @@ exports['add: tag to IP'] = function (t) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             t.ok(res.rules[0].uuid, 'rule has a uuid');
@@ -409,6 +409,9 @@ exports['add: tag to IP'] = function (t) {
             expRule.version = res.rules[0].version;
             delete res.rules[0].version;
 
+            expRule.log = false;
+            payload.rules[0].log = false;
+
             t.deepEqual(res, {
                 vms: [ vm1.uuid, vm2.uuid ],
                 rules: [ payload.rules[0] ]
@@ -437,17 +440,14 @@ exports['add: tag to IP'] = function (t) {
 
             cb();
         });
-
     }, function (cb) {
         fw.get({ uuid: expRule.uuid }, function (err, res) {
             t.ifError(err);
             t.deepEqual(res, expRule, 'get returns same rule');
             cb();
         });
-
     }, function (cb) {
         helpers.fwListEquals(t, [expRule], cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -455,7 +455,6 @@ exports['add: tag to IP'] = function (t) {
             rule: expRule,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -463,7 +462,6 @@ exports['add: tag to IP'] = function (t) {
             vm: vm1,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -479,8 +477,8 @@ exports['add: tag to IP'] = function (t) {
 
 
 exports['add: tag to subnet'] = function (t) {
-    var vm1 = helpers.generateVM({ tags: { foo : true } });
-    var vm2 = helpers.generateVM({ tags: { foo : true } });
+    var vm1 = helpers.generateVM({ tags: { foo: true } });
+    var vm2 = helpers.generateVM({ tags: { foo: true } });
     var payload = {
         rules: [
             {
@@ -506,14 +504,14 @@ exports['add: tag to subnet'] = function (t) {
     function (cb) {
         fw.validatePayload(payload, function (err, res) {
             t.ifError(err);
-            return cb();
+            cb();
         });
-
     }, function (cb) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb(err);
+                cb(err);
+                return;
             }
 
             helpers.fillInRuleBlanks(res.rules, [rule1, rule2]);
@@ -554,17 +552,14 @@ exports['add: tag to subnet'] = function (t) {
 
             cb();
         });
-
     }, function (cb) {
         fw.get({ uuid: rule1.uuid }, function (err, res) {
             t.ifError(err);
             t.deepEqual(res, rule1, 'get returns same rule');
             cb();
         });
-
     }, function (cb) {
         helpers.fwListEquals(t, [rule1, rule2].sort(helpers.uuidSort), cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -572,7 +567,6 @@ exports['add: tag to subnet'] = function (t) {
             vm: vm1,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -580,7 +574,6 @@ exports['add: tag to subnet'] = function (t) {
             vm: vm2,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -588,7 +581,6 @@ exports['add: tag to subnet'] = function (t) {
             rule: rule1,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -596,7 +588,6 @@ exports['add: tag to subnet'] = function (t) {
             rule: rule2,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.testEnableDisable({
             t: t,
@@ -611,9 +602,9 @@ exports['add: tag to subnet'] = function (t) {
 
 
 exports['add: vm to subnet'] = function (t) {
-    var vm1 = helpers.generateVM({ tags: { foo : true } });
+    var vm1 = helpers.generateVM({ tags: { foo: true } });
     // Not the target of the rule:
-    var vm2 = helpers.generateVM({ tags: { foo : true } });
+    var vm2 = helpers.generateVM({ tags: { foo: true } });
     var payload = {
         rules: [
             {
@@ -641,14 +632,14 @@ exports['add: vm to subnet'] = function (t) {
     function (cb) {
         fw.validatePayload(payload, function (err, res) {
             t.ifError(err);
-            return cb();
+            cb();
         });
-
     }, function (cb) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb(err);
+                cb(err);
+                return;
             }
 
             helpers.fillInRuleBlanks(res.rules, [rule1, rule2]);
@@ -682,17 +673,14 @@ exports['add: vm to subnet'] = function (t) {
 
             cb();
         });
-
     }, function (cb) {
         fw.get({ uuid: rule1.uuid }, function (err, res) {
             t.ifError(err);
             t.deepEqual(res, rule1, 'get returns same rule');
             cb();
         });
-
     }, function (cb) {
         helpers.fwListEquals(t, [rule1, rule2].sort(helpers.uuidSort), cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -700,7 +688,6 @@ exports['add: vm to subnet'] = function (t) {
             vm: vm1,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.fwRulesEqual({
             t: t,
@@ -708,7 +695,6 @@ exports['add: vm to subnet'] = function (t) {
             vm: vm2,
             vms: [vm1, vm2]
         }, cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -716,7 +702,6 @@ exports['add: vm to subnet'] = function (t) {
             rule: rule1,
             vms: [vm1]
         }, cb);
-
     }, function (cb) {
         // Ensure we can use the rule UUID to check
         helpers.vmsAffected({
@@ -725,7 +710,6 @@ exports['add: vm to subnet'] = function (t) {
             rule: rule1.uuid,
             vms: [vm1]
         }, cb);
-
     }, function (cb) {
         helpers.vmsAffected({
             t: t,
@@ -733,7 +717,6 @@ exports['add: vm to subnet'] = function (t) {
             rule: rule2,
             vms: [vm1]
         }, cb);
-
     }, function (cb) {
         // Ensure we can use the rule UUID to check
         helpers.vmsAffected({
@@ -806,8 +789,8 @@ exports['sorting: multiple ip and subnet rules'] = function (t) {
             t.ifError(err);
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
@@ -853,18 +836,17 @@ exports['sorting: multiple ip and subnet rules'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwListEquals(t, rules.sort(helpers.uuidSort), cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwRulesEqual({
             t: t,
             rules: rules,
             vm: vm,
             vms: [vm]
         }, cb);
-
     }
     ], function () {
         t.done();
@@ -929,8 +911,8 @@ exports['sorting: multiple icmp types'] = function (t) {
             t.ifError(err);
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
@@ -976,18 +958,17 @@ exports['sorting: multiple icmp types'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwListEquals(t, rules.sort(helpers.uuidSort), cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwRulesEqual({
             t: t,
             rules: rules,
             vm: vm,
             vms: [vm]
         }, cb);
-
     }
     ], function () {
         t.done();
@@ -1003,7 +984,8 @@ exports['enable / disable rule'] = function (t) {
                 owner_uuid: vm.owner_uuid,
                 rule: util.format('FROM vm %s TO ip 192.168.5.2 BLOCK tcp '
                                 + 'PORT 25', vm.uuid),
-                enabled: false
+                enabled: false,
+                log: true
             }
         ],
         vms: [vm]
@@ -1019,7 +1001,8 @@ exports['enable / disable rule'] = function (t) {
         fw.add(payload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             helpers.fillInRuleBlanks(res.rules, expRule);
@@ -1042,22 +1025,22 @@ exports['enable / disable rule'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwGetEquals(t, expRule, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwListEquals(t, [expRule], cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.fwRulesEqual({
             t: t,
             rules: [expRule],
             vm: vm,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         // Even though the rule is disabled, it should still show up as
         // affected
         helpers.vmsAffected({
@@ -1066,8 +1049,8 @@ exports['enable / disable rule'] = function (t) {
             rule: expRule,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         // Update the rule - it should still not affect the VM
         var updatePayload = {
             rules: [
@@ -1084,7 +1067,8 @@ exports['enable / disable rule'] = function (t) {
         fw.update(updatePayload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             expRule.version = res.rules[0].version;
@@ -1103,15 +1087,16 @@ exports['enable / disable rule'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         // Add an enabled rule - disabled rule should still not affect the vm
         var addPayload = {
             rules: [
                 {
                     owner_uuid: vm.owner_uuid,
                     rule: 'FROM any TO all vms ALLOW tcp PORT 33',
-                    enabled: true
+                    enabled: true,
+                    log: true
                 }
             ],
             vms: [vm]
@@ -1121,7 +1106,8 @@ exports['enable / disable rule'] = function (t) {
         fw.add(addPayload, function (err, res) {
             t.ifError(err);
             if (err) {
-                return cb();
+                cb();
+                return;
             }
 
             helpers.fillInRuleBlanks(res.rules, expRule2);
@@ -1134,7 +1120,6 @@ exports['enable / disable rule'] = function (t) {
                 [ helpers.allowPortInTCP('any', 33) ];
             v6rules[vm.uuid].in.tcp =
                 [ helpers.allowPortInTCP('any', 33) ];
-
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files still the same');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -1145,16 +1130,16 @@ exports['enable / disable rule'] = function (t) {
 
             cb();
         });
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.vmsAffected({
             t: t,
             allVMs: [vm],
             rule: expRule,
             vms: [vm]
         }, cb);
-
-    }, function (cb) {
+    },
+    function (cb) {
         helpers.vmsAffected({
             t: t,
             allVMs: [vm],
@@ -1169,11 +1154,13 @@ exports['enable / disable rule'] = function (t) {
 };
 
 
+
 exports['del: no uuids or rvmUUIDs'] = function (t) {
     fw.del({ vms: [ helpers.generateVM() ] }, function (err, res) {
         t.ok(err, 'error returned');
         if (!err) {
-            return t.done();
+            t.done();
+            return;
         }
 
         t.equal(err.message, 'Payload must contain one of: rvmUUIDs, uuids',
diff --git a/deps/fw/test/unit/global.test.js b/deps/fw/test/unit/global.test.js
index dfbea8f..f86685f 100644
--- a/deps/fw/test/unit/global.test.js
+++ b/deps/fw/test/unit/global.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm add unit tests
  */
@@ -9,14 +9,6 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('uuid');
-var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var createSubObjects = mod_obj.createSubObjects;
-var mergeObjects = mod_obj.mergeObjects;
-
 
 
 // --- Globals
@@ -26,7 +18,6 @@ var mergeObjects = mod_obj.mergeObjects;
 // Set this to any of the exports in this file to only run that test,
 // plus setup and teardown
 var runOne;
-var printVMs = false;
 
 
 
@@ -73,6 +64,7 @@ exports['global'] = function (t) {
 
     var expRules = clone(payload.rules);
     expRules[0].created_by = payload.createdBy;
+    expRules[0].log = false;
 
     var expRulesOnDisk = {};
 
diff --git a/deps/fw/test/unit/icmp.test.js b/deps/fw/test/unit/icmp.test.js
index 53deb35..89ca2d0 100644
--- a/deps/fw/test/unit/icmp.test.js
+++ b/deps/fw/test/unit/icmp.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm tests : ICMP
  */
@@ -30,14 +30,7 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('uuid');
 var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var createSubObjects = mod_obj.createSubObjects;
-var mergeObjects = mod_obj.mergeObjects;
-
 
 
 // --- Globals
@@ -106,6 +99,7 @@ exports['add / update ICMPv4'] = function (t) {
             expRule.uuid = res.rules[0].uuid;
             t.ok(res.rules[0].version, 'rule has a version');
             expRule.version = res.rules[0].version;
+            expRule.log = false;
 
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
@@ -155,6 +149,7 @@ exports['add / update ICMPv4'] = function (t) {
             t.ok(res.rules[0].version, 'rule has a version');
             expRule.version = res.rules[0].version;
             expRule.rule = res.rules[0].rule;
+            expRule.log = false;
 
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
@@ -327,6 +322,7 @@ exports['add / update ICMPv6'] = function (t) {
             expRule.uuid = res.rules[0].uuid;
             t.ok(res.rules[0].version, 'rule has a version');
             expRule.version = res.rules[0].version;
+            expRule.log = false;
 
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
diff --git a/deps/fw/test/unit/log.test.js b/deps/fw/test/unit/log.test.js
new file mode 100644
index 0000000..cd268bc
--- /dev/null
+++ b/deps/fw/test/unit/log.test.js
@@ -0,0 +1,298 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * fwadm unit tests related to cfwlogging
+ *
+ * fw checks for existence of the /dev/ipfev file in order to add or not
+ * the 'set-tag(uuid=$UUID, cfwlog)' tag to the IPF rules. The existence of
+ * such file is checked only once and, therefore, we would need to do a lot
+ * of reloading of mocks and cached node modules in order to test when it's
+ * present and when it is not. Instead, we do all the tests w/o such file and
+ * run current file with /dev/ipfev.
+ */
+
+var async = require('async');
+var clone = require('clone');
+var fw;
+var helpers = require('../lib/helpers');
+var mocks = require('../lib/mocks');
+var util = require('util');
+
+var fs = mocks.mocks.fs;
+
+
+// --- Globals
+
+
+
+// Set this to any of the exports in this file to only run that test,
+// plus setup and teardown
+var runOne;
+
+
+
+// --- Setup
+
+
+
+exports['setup'] = function (t) {
+    fw = mocks.setup();
+    t.ok(fw, 'fw loaded');
+    t.done();
+};
+
+
+// run before every test
+exports.setUp = function (cb) {
+    if (fw) {
+        mocks.reset();
+    }
+    cb();
+};
+
+
+
+// --- Tests
+
+
+
+exports['add / update: vm to IP: BLOCK'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO ip 10.99.99.254 BLOCK tcp '
+                                + 'PORT 8080', vm.uuid),
+                enabled: true,
+                log: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var expRule = clone(payload.rules[0]);
+
+    async.series([
+    function addDevIpfEv(cb) {
+        fs.writeFile('/dev/ipfev', '2', cb);
+    },
+    function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            t.ok(res.rules[0].uuid, 'rule has a uuid');
+            expRule.uuid = res.rules[0].uuid;
+
+            t.ok(res.rules[0].version, 'rule has a version');
+            expRule.version = res.rules[0].version;
+
+            expRule.log = true;
+
+            t.deepEqual(res, {
+                vms: [ vm.uuid ],
+                rules: [ expRule ]
+            }, 'rules returned');
+
+            var v4rules = helpers.defaultZoneRules(vm.uuid);
+            var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+            v4rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 8080,
+                    'keep state set-tag(uuid=' + expRule.uuid + ', cfwlog)')
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            var vmsEnabled = {};
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                    'ipf enabled in VMs');
+
+            cb();
+        });
+    },
+    function (cb) {
+        helpers.fwGetEquals(t, expRule, cb);
+    },
+    function (cb) {
+        helpers.fwListEquals(t, [expRule], cb);
+    },
+    function (cb) {
+        helpers.vmsAffected({
+            t: t,
+            allVMs: [vm],
+            rule: expRule,
+            vms: [vm]
+        }, cb);
+    },
+    function (cb) {
+        var updatePayload = {
+            rules: [
+                {
+                    rule: util.format(
+                        'FROM vm %s TO (ip 10.88.88.2 OR ip 10.99.99.254) '
+                        + 'BLOCK tcp PORT 8080', vm.uuid),
+                    uuid: expRule.uuid
+                }
+            ],
+            vms: [vm]
+        };
+
+        fw.update(updatePayload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            t.equal(res.rules[0].uuid, expRule.uuid, 'uuid is the same');
+            t.ok(res.rules[0].version, 'rule has a version');
+            t.notEqual(res.rules[0].version, expRule.version,
+                'rule version changed');
+
+            expRule.version = res.rules[0].version;
+            expRule.rule = updatePayload.rules[0].rule;
+
+            t.deepEqual(res, {
+                vms: [ vm.uuid ],
+                rules: [ expRule ]
+            }, 'rules returned');
+
+            var v4rules = helpers.defaultZoneRules(vm.uuid);
+            var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+            v4rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.88.88.2', 8080,
+                    'keep state set-tag(uuid=' + expRule.uuid + ', cfwlog)'),
+                helpers.blockPortOutTCP('10.99.99.254', 8080,
+                    'keep state set-tag(uuid=' + expRule.uuid + ', cfwlog)')
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            cb();
+        });
+    },
+    function (cb) {
+        helpers.fwGetEquals(t, expRule, cb);
+    },
+    function (cb) {
+        helpers.fwListEquals(t, [expRule], cb);
+    },
+    function (cb) {
+        helpers.fwRulesEqual({
+            t: t,
+            rules: [ expRule ],
+            vm: vm,
+            vms: [vm]
+        }, cb);
+    },
+    function (cb) {
+        helpers.vmsAffected({
+            t: t,
+            allVMs: [vm],
+            rule: expRule,
+            vms: [vm]
+        }, cb);
+    },
+    function (cb) {
+        // Disabling and re-enabling the firewall should have no effect on the
+        // zone rules
+        helpers.testEnableDisable({
+            t: t,
+            vm: vm,
+            vms: [vm]
+        }, cb);
+    },
+    function (cb) {
+        // Delete the rule - the firewall should remain running, but only the
+        // default rules should remain
+
+        var delPayload = {
+            uuids: [ expRule.uuid ],
+            vms: [vm]
+        };
+
+        fw.del(delPayload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            t.deepEqual(res, {
+                vms: [ vm.uuid ],
+                rules: [ expRule ]
+            }, 'results returned');
+
+            var defaultRules = helpers.defaultZoneRules(vm.uuid);
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), defaultRules,
+                'only default IPv4 firewall rules left in zone');
+            t.deepEqual(helpers.zoneIPFconfigs(6), defaultRules,
+                'only default IPv6 firewall rules left in zone');
+
+            var vmsEnabled = {};
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf still enabled in VM');
+
+            cb();
+        });
+    },
+    function (cb) {
+        helpers.fwRulesEqual({
+            t: t,
+            rules: [ ],
+            vm: vm,
+            vms: [vm]
+        }, cb);
+    },
+    function removeDevIpfEv(cb) {
+        fs.unlink('/dev/ipfev', function () {
+            // fw uses a global variable to store existence or not of the
+            // /dev/ipfev file. If we want to change the value of such var
+            // we need to reload the module.
+            delete require.cache[require.resolve('../../lib/fw')];
+            delete require.cache[require.resolve('../lib/mocks')];
+            cb();
+        });
+    }
+    ],
+    function () {
+        t.done();
+    });
+};
+
+
+
+// --- Teardown
+
+
+
+exports['teardown'] = function (t) {
+    mocks.teardown();
+    t.done();
+};
+
+
+// Use to run only one test in this file:
+if (runOne) {
+    module.exports = {
+        setup: exports.setup,
+        setUp: exports.setUp,
+        oneTest: runOne,
+        teardown: exports.teardown
+    };
+}
diff --git a/deps/fw/test/unit/owner.test.js b/deps/fw/test/unit/owner.test.js
index 9e229b9..88d3a94 100644
--- a/deps/fw/test/unit/owner.test.js
+++ b/deps/fw/test/unit/owner.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * test rules with owner_uuid set
  */
@@ -30,12 +30,9 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
 var mod_uuid = require('uuid');
 var util = require('util');
 
-var createSubObjects = mod_obj.createSubObjects;
-
 
 
 // --- Globals
@@ -106,6 +103,8 @@ exports['tag to IP'] = function (t) {
             expRule.version = res.rules[0].version;
             delete res.rules[0].version;
 
+            payload.rules[0].log = expRule.log = false;
+
             t.deepEqual(res, {
                 vms: [ vm2.uuid ],
                 rules: [ payload.rules[0] ]
@@ -174,6 +173,8 @@ exports['tag to IP'] = function (t) {
             t.ok(res.rules[0].version, 'rule has a version');
             delete res.rules[0].version;
 
+            expRule2.log = payload2.rules[0].log = false;
+
             t.deepEqual(res, {
                 vms: [ vm1.uuid, vm2.uuid ],
                 rules: [ payload2.rules[0] ]
diff --git a/deps/fw/test/unit/tags.test.js b/deps/fw/test/unit/tags.test.js
index 27dbc24..5ebbe82 100644
--- a/deps/fw/test/unit/tags.test.js
+++ b/deps/fw/test/unit/tags.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm test: tags
  */
@@ -30,9 +30,7 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_addr = require('ip6addr');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('uuid');
 var net = require('net');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
@@ -181,6 +179,7 @@ exports['add / update: tag to tag'] = function (t) {
 
             rule1.uuid = res.rules[0].uuid;
             rule1.version = res.rules[0].version;
+            rule1.log = false;
             t.deepEqual(helpers.sortRes(res), {
                 vms: tagOneVMs.map(getUUID).sort(),
                 rules: [ rule1 ]
@@ -1011,6 +1010,7 @@ exports['tags with values'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[0].version = res.rules[0].version;
+            expRules[0].log = false;
 
             t.deepEqual(helpers.sortRes(res), {
                 remoteVMs: helpers.sortedUUIDs([rvm1, rvm2, rvm3]),
@@ -1077,6 +1077,8 @@ exports['tags with values'] = function (t) {
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[1].version = res.rules[0].version;
 
+            expRules[1].log = false;
+
             t.deepEqual(helpers.sortRes(res), {
                 vms: [ vm2.uuid, vm4.uuid, vm5.uuid ].sort(),
                 rules: [ expRules[1] ]
diff --git a/deps/fw/test/unit/update.test.js b/deps/fw/test/unit/update.test.js
index 7193120..c36ac96 100644
--- a/deps/fw/test/unit/update.test.js
+++ b/deps/fw/test/unit/update.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm update unit tests
  */
@@ -30,12 +30,8 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
 var mod_uuid = require('uuid');
 var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var mergeObjects = mod_obj.mergeObjects;
 
 
 
@@ -46,7 +42,6 @@ var mergeObjects = mod_obj.mergeObjects;
 // Set this to any of the exports in this file to only run that test,
 // plus setup and teardown
 var runOne;
-var printVMs = false;
 
 
 
@@ -115,6 +110,7 @@ exports['update non-existent rule'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[0].version = res.rules[0].version;
+            expRules[0].log = false;
 
             t.deepEqual(res, {
                 rules: expRules,
@@ -191,6 +187,7 @@ exports['description and created_by'] = function (t) {
                 return cb();
             }
 
+            expRules[0].log = false;
             t.deepEqual(res, {
                 rules: expRules,
                 vms: [ payload.vms[0].uuid ]
@@ -212,6 +209,7 @@ exports['description and created_by'] = function (t) {
         payload.rules[0].description = 'two';
 
         expRules = [clone(payload.rules[0])];
+        expRules[0].log = false;
         fw.update(payload, function (err, res) {
             t.ifError(err);
             if (err) {
@@ -298,6 +296,7 @@ exports['FWAPI-237: Ignore rules that don\'t change'] = function (t) {
 
                 t.ok(res.rules[i].version, 'rule has a version');
                 expRules[i].version = res.rules[i].version;
+                expRules[i].log = false;
             }
 
             t.deepEqual(helpers.sortRes(res), helpers.sortRes({
@@ -363,6 +362,7 @@ exports['FWAPI-237: Ignore rules that don\'t change'] = function (t) {
                 return cb();
             }
 
+            updatePayload.rules[0].log = false;
             // This rule should only affect the VM that it mentions.
             t.deepEqual(helpers.sortRes(res), {
                 vms: [ vm1.uuid ],
@@ -430,6 +430,7 @@ exports['FWAPI-237: Ignore rules that don\'t change'] = function (t) {
             if (err) {
                 return cb();
             }
+            addPayload.rules[0].log = false;
 
             t.deepEqual(helpers.sortRes(res), {
                 vms: [ vm1.uuid, vm2.uuid, vm3.uuid ],
diff --git a/deps/fw/test/unit/wildcards.test.js b/deps/fw/test/unit/wildcards.test.js
index af8d267..0b3dfe1 100644
--- a/deps/fw/test/unit/wildcards.test.js
+++ b/deps/fw/test/unit/wildcards.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * fwadm tests: all and any targets
  */
@@ -30,14 +30,7 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('uuid');
 var util = require('util');
-var util_vm = require('../../lib/util/vm');
-
-var createSubObjects = mod_obj.createSubObjects;
-var mergeObjects = mod_obj.mergeObjects;
-
 
 
 // --- Globals
@@ -109,6 +102,7 @@ exports['any <-> vm: add / update'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[0].version = res.rules[0].version;
+            expRules[0].log = false;
 
             t.deepEqual(res, {
                 rules: expRules,
@@ -169,6 +163,7 @@ exports['any <-> vm: add / update'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[1].version = res.rules[0].version;
+            expRules[1].log = false;
 
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
@@ -636,6 +631,7 @@ exports['add / update: all ports'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[0].version = res.rules[0].version;
+            expRules[0].log = false;
 
             t.deepEqual(res, {
                 rules: expRules,
@@ -691,6 +687,7 @@ exports['add / update: all ports'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[1].version = res.rules[0].version;
+            expRules[1].log = false;
 
             t.deepEqual(res, {
                 vms: [ vm.uuid ],
@@ -749,6 +746,7 @@ exports['add / update: all ports'] = function (t) {
 
             t.ok(res.rules[0].version, 'rule has a version');
             expRules[1].version = res.rules[0].version;
+            expRules[1].log = false;
 
             t.deepEqual(helpers.sortRes(res), {
                 vms: [ vm.uuid, vm2.uuid ].sort(),
diff --git a/npm/postinstall.sh b/npm/postinstall.sh
index 645f079..7cd0010 100755
--- a/npm/postinstall.sh
+++ b/npm/postinstall.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2019, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
@@ -65,6 +65,12 @@ function import_smf_manifest()
     if [[ $(uname -s) == "SunOS" ]]; then
         svccfg import $SMF_DIR/${AGENT}-setup.xml
     fi
+
+    subfile "$ROOT/smf/manifests/${AGENT}-config-migration.xml.in" \
+        "$SMF_DIR/${AGENT}-config-migration.xml"
+    if [[ $(uname -s) == "SunOS" ]]; then
+        svccfg import $SMF_DIR/${AGENT}-config-migration.xml
+    fi
 }
 
 function instance_exists()
diff --git a/npm/postuninstall.sh b/npm/postuninstall.sh
index e3ea84c..31ed946 100755
--- a/npm/postuninstall.sh
+++ b/npm/postuninstall.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2019, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
@@ -20,6 +20,12 @@ NAME=firewaller
 if [[ $(uname -s) == "SunOS" ]]; then
     svcadm disable -s $NAME
     svccfg delete $NAME
+    svcadm disable -s $NAME-agent-setup
+    svccfg delete $NAME-agent-setup
+    svcadm disable -s $NAME-config-migration
+    svccfg delete $NAME-config-migration
 fi
 
 rm -f "$SMFDIR/$NAME.xml"
+rm -f "$SMFDIR/$NAME-agent-setup.xml"
+rm -f "$SMFDIR/$NAME-config-migration.xml"
diff --git a/smf/manifests/firewaller-config-migration.xml.in b/smf/manifests/firewaller-config-migration.xml.in
new file mode 100644
index 0000000..a7f5982
--- /dev/null
+++ b/smf/manifests/firewaller-config-migration.xml.in
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+<!--
+  Firewaller agent config migration SMF manifest.
+  When per-zone ipf.conf and ipf6.conf files change in a way that it's not backward compatible,
+  we need a service which will ensure that each zone's ipf configuration files are a version that
+  is compatible with the running system.
+ -->
+<service_bundle type="manifest" name="firewaller">
+  <service name="smartdc/agent/firewaller-config-migration" type="service" version="@@VERSION@@">
+    <dependency name="network_and_local_filesystem" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/network/physical"/>
+      <service_fmri value="svc:/system/filesystem/local"/>
+    </dependency>
+    <!--
+        Make vmadmd and zones services depend on this service so that firewall
+        rules are correct before those services cause them to be read.
+    -->
+    <dependent name="smartdc_vmadmd_and_system_zones" grouping="optional_all" restart_on="none">
+      <service_fmri value="svc:/system/smartdc/vmadmd:default"/>
+      <service_fmri value="svc:/system/zones:default"/>
+    </dependent>
+    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js &amp;" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+        <method_environment>
+          <envvar name="PATH" value="@@PREFIX@@/bin:/usr/bin:/usr/sbin"/>
+        </method_environment>
+      </method_context>
+    </exec_method>
+    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+    <instance name="default" enabled="true"/>
+    <stability value="Unstable"/>
+    <template>
+      <common_name>
+        <loctext xml:lang="C">Firewaller Agent Config Migration</loctext>
+      </common_name>
+    </template>
+  </service>
+</service_bundle>
-- 
2.21.0

