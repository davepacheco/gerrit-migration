From f1425729e4bfef1ffd17639b8517fe2b1a94e845 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Mon, 3 Jun 2019 19:35:43 +0200
Subject: [PATCH] TRITON-1320 firewaller-agent needs to rewrite ipf rules on
 boot

---
 config-migration.js                           | 192 ++++++++++++++++++
 deps/fw/lib/fw.js                             | 148 ++++++++------
 npm/postinstall.sh                            |   8 +-
 npm/postuninstall.sh                          |   8 +-
 .../firewaller-config-migration.xml.in        |  57 ++++++
 5 files changed, 349 insertions(+), 64 deletions(-)
 create mode 100644 config-migration.js
 create mode 100644 smf/manifests/firewaller-config-migration.xml.in

diff --git a/config-migration.js b/config-migration.js
new file mode 100644
index 0000000..3c6ee11
--- /dev/null
+++ b/config-migration.js
@@ -0,0 +1,192 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Firewaller agent config migration from/to pre/post cfwlogging
+ * See https://github.com/joyent/rfd/blob/master/rfd/0163/README.md
+ */
+
+'use strict';
+
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+
+var mod_vm = require('./lib/vm');
+var fw = require('./lib/fw');
+
+var fs = require('fs');
+var util = require('util');
+
+var LOG = bunyan.createLogger({
+    name: 'firewaller-config-migration',
+    level: 'debug'
+});
+
+var DEV_IPFEV = '/dev/ipfev';
+var IPF_CONF = '%s/config/ipf.conf';
+
+vasync.pipeline({
+    funcs: [
+        // Get all the local VMs with firewall_enabled=true
+        function loadFwEnabledVms(ctx, next) {
+            mod_vm.list(LOG, {
+                firewall_enabled: true
+            }, function listVmsCb(err, vms) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.vms = vms;
+                ctx.vmsByVmUUID = {};
+                ctx.vms.forEach(function (vm) {
+                    ctx.vmsByVmUUID[vm.uuid] = vm;
+                });
+                next();
+            });
+        },
+        // Load all the firewall rules for those vms
+        function loadFwEnabledRules(ctx, next) {
+            if (!ctx.vms.length) {
+                next();
+                return;
+            }
+            fw.list({
+                log: LOG,
+                payload: {
+                    localVMs: ctx.vms,
+                    vms: ctx.vms
+                }
+            }, function listRulesCb(err, rules) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.rules = rules;
+                next();
+            });
+        },
+        // We're interested only in firewall rules which have `rule.log` set
+        function filterRulesWithSetTags(ctx, next) {
+            if (!ctx.rules.length) {
+                next();
+                return;
+            }
+            ctx.rules = ctx.rules.filter(function ruleHasTags(rule) {
+                return rule.log;
+            });
+            next();
+        },
+        // Since firewall rules don't keep a reference to the VM they belong
+        // to, we need to figure out which VM UUIDs we're gonna need to check
+        // based into the firewall rules
+        function getVmsForRulesWithSetTags(ctx, next) {
+            if (ctx.rules.length === 0) {
+                next();
+                return;
+            }
+            ctx.rulesByVmUUID = {};
+            vasync.forEachParallel({
+                inputs: ctx.rules,
+                func: function getRuleVm(rule, nextRule) {
+                    fw.vms({
+                        log: LOG,
+                        payload: {
+                            rule: rule,
+                            vms: ctx.vms
+                        }
+                    }, function getRuleVmCb(getErr, vmUuids) {
+                        if (getErr) {
+                            nextRule(getErr);
+                            return;
+                        }
+                        vmUuids.forEach(function addToCtx(vmUuid) {
+                            if (!ctx.rulesByVmUUID[vmUuid]) {
+                                ctx.rulesByVmUUID[vmUuid] = [];
+                            }
+                            ctx.rulesByVmUUID[vmUuid].push(rule);
+                        });
+                        nextRule();
+                    });
+                }
+            }, next);
+        },
+        function getPlatformIPFVersion(ctx, next) {
+            var vFile = '/etc/ipf/smartos_version';
+            if (fs.existsSync(vFile)) {
+                ctx.ipfSmartosVersion = Number(fs.readFileSync(vFile, 'utf8'));
+            } else {
+                ctx.ipfSmartosVersion = (ctx.haveDevIpfEv) ? 2 : 1;
+            }
+            next();
+        },
+        // Once we know which vms to check, we need to review the contents of
+        // the IPF files
+        function checkIPFVersions(ctx, next) {
+            if (!ctx.rulesByVmUUID) {
+                next();
+                return;
+            }
+            ctx.vmsToRewriteIPF = [];
+            var vmsToCheck = Object.keys(ctx.rulesByVmUUID);
+            LOG.debug({vmsToCheck: vmsToCheck}, 'VMs to check');
+            if (!vmsToCheck.length) {
+                next();
+                return;
+            }
+            vasync.forEachParallel({
+                inputs: vmsToCheck,
+                func: function testIPFFiles(aVm, nextVm) {
+                    var ipfv4 = util.format(IPF_CONF,
+                        ctx.vmsByVmUUID[aVm].zonepath);
+                    var ipfv4Data = fs.readFileSync(ipfv4, 'utf8');
+                    var re = /^# smartos_ipf_version (\d+)$/m;
+                    var ipfv4Res = re.exec(ipfv4Data);
+                    // If we cannot find a version written on the rules file,
+                    // let's assume it's version 1 (pre RFD 163):
+                    var rulesVersion = (ipfv4Res !== null) ?
+                            Number(ipfv4Res[1]) : 1;
+                    if (rulesVersion !== ctx.ipfSmartosVersion) {
+                        ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[aVm]);
+                    }
+
+                    LOG.debug({
+                        smartos_ipf_version: ctx.ipfSmartosVersion,
+                        rules_ipf_version: rulesVersion,
+                        vm_uuid: aVm
+                    }, 'SmartOS IPF version check');
+                    nextVm();
+                }
+            }, next);
+        },
+        function updateIpfFiles(ctx, next) {
+            if (!Array.isArray(ctx.vmsToRewriteIPF) ||
+                ctx.vmsToRewriteIPF.length === 0) {
+                next();
+                return;
+            }
+            fw.update({
+                log: LOG,
+                payload: {
+                    localVms: ctx.vmsToRewriteIPF
+                }
+            }, next);
+        }
+    ],
+    arg: {
+        haveDevIpfEv: fs.existsSync(DEV_IPFEV)
+    }
+}, function pipeCb(pipeErr) {
+    if (pipeErr) {
+        console.error(pipeErr);
+    }
+});
+
+
+// vim: set softtabstop=4 shiftwidth=4:
diff --git a/deps/fw/lib/fw.js b/deps/fw/lib/fw.js
index 1ee415f..3bb3494 100644
--- a/deps/fw/lib/fw.js
+++ b/deps/fw/lib/fw.js
@@ -21,7 +21,7 @@
  * CDDL HEADER END
  *
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  *
  * fwadm: Main entry points
@@ -105,6 +105,9 @@ var v6fallbacks = fallbacks.concat([
     'pass out quick proto ipv6-icmp from any to any keep state',
     'pass out proto ipv6-icmp from any to any']);
 
+// Do not use directly - use haveIpfEventLogger() instead.
+var haveDevIpfEv = undefined;
+var DEV_IPFEV = '/dev/ipfev';
 
 // --- Internal helper functions
 
@@ -120,6 +123,17 @@ function assertStringOrObject(obj, name) {
 }
 
 
+/**
+ * Determine if /dev/ipfev exists, caching the result for future calls in the
+ * global variable haveDevIpfEv.
+ */
+function haveIpfEventLogger() {
+    if (haveDevIpfEv === undefined) {
+        haveDevIpfEv = fs.existsSync(DEV_IPFEV);
+    }
+    return haveDevIpfEv;
+}
+
 /**
  * For a rule and a direction, return whether or not we actually need to
  * write ipf rules. FROM+ALLOW and TO+BLOCK are essentially no-ops, as
@@ -133,8 +147,8 @@ function noRulesNeeded(dir, rule) {
         return false;
     }
 
-    if ((dir === 'from' && rule.action === 'allow')
-        || (dir === 'to' && rule.action === 'block')) {
+    if ((dir === 'from' && rule.action === 'allow') ||
+        (dir === 'to' && rule.action === 'block')) {
         return true;
     }
     return false;
@@ -226,16 +240,16 @@ function getChangingRules(rules, existingRules, cb) {
  */
 function getAffectedRules(new_vms, log) {
     return function _isAffectedRule(rule) {
-        if (rule.action === 'allow'
-            && vmsOnSide(new_vms, rule, 'from', log).length > 0) {
-            return rule.to.wildcards.indexOf('vmall') !== -1
-                || rule.to.tags.length > 0
-                || rule.to.vms.length > 0;
-        } else if (rule.action === 'block'
-            && vmsOnSide(new_vms, rule, 'to', log).length > 0) {
-            return rule.from.wildcards.indexOf('vmall') !== -1
-                || rule.from.tags.length > 0
-                || rule.from.vms.length > 0;
+        if (rule.action === 'allow' &&
+            vmsOnSide(new_vms, rule, 'from', log).length > 0) {
+            return rule.to.wildcards.indexOf('vmall') !== -1 ||
+                rule.to.tags.length > 0 ||
+                rule.to.vms.length > 0;
+        } else if (rule.action === 'block' &&
+            vmsOnSide(new_vms, rule, 'to', log).length > 0) {
+            return rule.from.wildcards.indexOf('vmall') !== -1 ||
+                rule.from.tags.length > 0 ||
+                rule.from.vms.length > 0;
         }
         return false;
     };
@@ -354,19 +368,19 @@ function createUpdatedRules(opts, log, callback) {
             origRule = originals[rule.uuid].serialize();
             mergedRule = mergeObjects(rule, origRule);
 
-            if (!(hasKey(rule, 'owner_uuid')
-                && hasKey(rule, 'global'))) {
+            if (!(hasKey(rule, 'owner_uuid') &&
+                hasKey(rule, 'global'))) {
                 // If both owner_uuid and global are set - let
                 // this bubble up the appropriate error in createRules()
 
-                if (hasKey(rule, 'owner_uuid')
-                    && hasKey(origRule, 'global')) {
+                if (hasKey(rule, 'owner_uuid') &&
+                    hasKey(origRule, 'global')) {
                     // Updating from global -> owner_uuid rule
                     delete mergedRule.global;
                 }
 
-                if (hasKey(rule, 'global')
-                    && hasKey(origRule, 'owner_uuid')) {
+                if (hasKey(rule, 'global') &&
+                    hasKey(origRule, 'owner_uuid')) {
                     // Updating from owner_uuid -> global rule
                     delete mergedRule.owner_uuid;
                 }
@@ -841,10 +855,8 @@ function validateRules(vms, rvms, rules, log, callback) {
                 sideData[rule.uuid][dir].vms[vm] = 1;
             }
             delete rulesLeft[rule.uuid];
-
         } else if (hasKey(rvms[type], t)) {
             delete rulesLeft[rule.uuid];
-
         } else {
             sideData[rule.uuid][dir].missing[type][t] = 1;
         }
@@ -865,8 +877,8 @@ function validateRules(vms, rvms, rules, log, callback) {
         DIRECTIONS.forEach(function (dir) {
             var otherSide = (dir == 'to' ? 'from' : 'to');
 
-            if (!hasKey(missing, dir) || objEmpty(missing[dir].vms)
-                || !hasKey(missing, otherSide)) {
+            if (!hasKey(missing, dir) || objEmpty(missing[dir].vms) ||
+                !hasKey(missing, otherSide)) {
                 return;
             }
 
@@ -899,9 +911,8 @@ function protoTarget(rule, target) {
         return 'icmp-type ' + typeArr[0]
             + (typeArr.length === 1 ? '' : ' code ' + typeArr[1]);
     } else {
-        if (hasKey(target, 'start')
-            && hasKey(target, 'end')) {
-
+        if (hasKey(target, 'start') &&
+            hasKey(target, 'end')) {
             return 'port ' + target.start + ' : ' + target.end;
         } else {
             return 'port = ' + target;
@@ -1083,6 +1094,16 @@ function ipfRuleObj(opts) {
     // ipfilter uses /etc/protocols which calls ICMPv6 'ipv6-icmp'
     var ipfProto = (rule.protocol === 'icmp6') ? 'ipv6-icmp' : rule.protocol;
 
+    var readtags = [];
+    if (haveIpfEventLogger()) {
+        if (rule.uuid) {
+            readtags.push(util.format('uuid=%s', rule.uuid));
+        }
+        if (rule.log) {
+            readtags.push('cfwlog');
+        }
+    }
+
     var sortObj = {
         action: rule.action,
         direction: dir,
@@ -1097,7 +1118,9 @@ function ipfRuleObj(opts) {
         type: opts.type,
         uuid: rule.uuid,
         value: opts.value,
-        version: rule.version
+        version: rule.version,
+        allTags: readtags.length !== 0 ?
+            util.format(' set-tag(%s)', readtags.join(', ')) : ''
     };
 
     if (opts.type === 'wildcard' && opts.value === 'any') {
@@ -1107,10 +1130,8 @@ function ipfRuleObj(opts) {
                 dir === 'from' ? 'out' : 'in',
                 ipfProto,
                 protoTarget(rule, t));
-            if (rule.protocol !== 'icmp6')
-                sortObj.v4text.push(wild);
-            if (rule.protocol !== 'icmp')
-                sortObj.v6text.push(wild);
+            if (rule.protocol !== 'icmp6') { sortObj.v4text.push(wild); }
+            if (rule.protocol !== 'icmp') { sortObj.v6text.push(wild); }
         });
 
         return sortObj;
@@ -1120,8 +1141,8 @@ function ipfRuleObj(opts) {
         var isv6 = target.indexOf(':') !== -1;
 
         // Don't generate rules for ICMPv4/IPv6 or ICMPv6/IPv4
-        if ((isv6 && rule.protocol === 'icmp')
-            || (!isv6 && rule.protocol === 'icmp6')) {
+        if ((isv6 && rule.protocol === 'icmp') ||
+            (!isv6 && rule.protocol === 'icmp6')) {
             return;
         }
 
@@ -1252,16 +1273,21 @@ function prepareIPFdata(opts, log, callback) {
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
-            '#',
-            ''];
+            '#'
+        ];
+        if (haveIpfEventLogger()) {
+            ipf4Conf.push('# smartos_ipf_version 2');
+        }
+        ipf4Conf.push('#', '');
         var ipf6Conf = ipf4Conf.slice();
         var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
         conf[vm].sort(compareRules).forEach(function (sortObj) {
             var ktxt = KEEP_FRAGS;
-            if ((sortObj.direction === 'from' && sortObj.action === 'allow')
-                || (sortObj.direction === 'to' && iks[sortObj.protocol])) {
-                ktxt += KEEP_STATE;
+            if (sortObj.allTags !== '' ||
+                (sortObj.direction === 'from' && sortObj.action === 'allow') ||
+                (sortObj.direction === 'to' && iks[sortObj.protocol])) {
+                ktxt += KEEP_STATE + sortObj.allTags;
             }
 
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
@@ -1331,8 +1357,8 @@ function vmsOnSide(allVMs, rule, dir, log) {
             }
 
             Object.keys(vmList).forEach(function (uuid) {
-                if (hasKey(rule, 'owner_uuid')
-                    && (rule.owner_uuid != vmList[uuid].owner_uuid)) {
+                if (hasKey(rule, 'owner_uuid') &&
+                    (rule.owner_uuid != vmList[uuid].owner_uuid)) {
                     return;
                 }
 
@@ -1399,8 +1425,8 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
             }
 
             [localVMs, remoteVMs].forEach(function (lookup) {
-                if (!hasKey(lookup, lookupTypePlural)
-                    || !hasKey(lookup[lookupTypePlural], value)) {
+                if (!hasKey(lookup, lookupTypePlural) ||
+                    !hasKey(lookup[lookupTypePlural], value)) {
                     return;
                 }
 
@@ -1413,8 +1439,8 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
                 }
 
                 forEachKey(vmList, function (uuid, vm) {
-                    if (rule.owner_uuid && vm.owner_uuid
-                        && vm.owner_uuid != rule.owner_uuid) {
+                    if (rule.owner_uuid && vm.owner_uuid &&
+                        vm.owner_uuid != rule.owner_uuid) {
                         return;
                     }
 
@@ -1700,8 +1726,8 @@ function applyChanges(opts, log, callback) {
 
         // Save the remote VMs
         function saveVMs(res, cb) {
-            if (opts.dryrun || !opts.save || !opts.save.remoteVMs
-                || objEmpty(opts.save.remoteVMs)) {
+            if (opts.dryrun || !opts.save || !opts.save.remoteVMs ||
+                objEmpty(opts.save.remoteVMs)) {
                 return cb(null);
             }
             mod_rvm.save(opts.save.remoteVMs, log, cb);
@@ -1709,8 +1735,8 @@ function applyChanges(opts, log, callback) {
 
         // Save rule files (if specified)
         function save(res, cb) {
-            if (opts.dryrun || !opts.save || !opts.save.rules
-                || opts.save.rules.length === 0) {
+            if (opts.dryrun || !opts.save || !opts.save.rules ||
+                opts.save.rules.length === 0) {
                 return cb(null);
             }
             saveRules(opts.save.rules, log, cb);
@@ -1718,8 +1744,8 @@ function applyChanges(opts, log, callback) {
 
         // Delete rule files (if specified)
         function delRules(res, cb) {
-            if (opts.dryrun || !opts.del || !opts.del.rules
-                || opts.del.rules.length === 0) {
+            if (opts.dryrun || !opts.del || !opts.del.rules ||
+                opts.del.rules.length === 0) {
                 return cb(null);
             }
             deleteRules(opts.del.rules, log, cb);
@@ -1727,8 +1753,8 @@ function applyChanges(opts, log, callback) {
 
         // Delete remote VMs (if specified)
         function delRVMs(res, cb) {
-            if (opts.dryrun || !opts.del || !opts.del.rvms
-                || opts.del.rvms.length === 0) {
+            if (opts.dryrun || !opts.del || !opts.del.rvms ||
+                opts.del.rvms.length === 0) {
                 return cb(null);
             }
             mod_rvm.del(opts.del.rvms, log, cb);
@@ -1827,8 +1853,8 @@ function add(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
@@ -1981,7 +2007,6 @@ function del(opts, callback) {
             throw new Error(
                 'Payload must contain one of: rvmUUIDs, uuids');
         }
-
     } catch (err) {
         return callback(err);
     }
@@ -2183,7 +2208,7 @@ function listRemoteVMs(opts, callback) {
 
             // XXX: support sorting by other fields, filtering
             var sortFn = function _sort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
 
             log.debug('listRemoteVMs: finish');
@@ -2238,7 +2263,7 @@ function listRules(opts, callback) {
             // XXX: support sorting by other fields, filtering
             // (eg: enabled=true vm=<uuid>)
             var sortFn = function _defaultSort(a, b) {
-                return (a.uuid > b.uuid) ? 1: -1;
+                return (a.uuid > b.uuid) ? 1 : -1;
             };
             var mapFn = function _defaultMap(r) {
                 return r.serialize();
@@ -2524,8 +2549,8 @@ function update(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
@@ -2709,7 +2734,6 @@ function getRemoteTargets(opts, callback) {
         if (opts.rules.length === 0) {
             throw new Error('Must specify rules');
         }
-
     } catch (err) {
         return callback(err);
     }
@@ -2958,8 +2982,8 @@ function validatePayload(opts, callback) {
         var optRules = opts.rules || [];
         var optLocalVMs = opts.localVMs || [];
         var optRemoteVMs = opts.remoteVMs || [];
-        if (optRules.length === 0 && optLocalVMs.length === 0
-            && optRemoteVMs.length === 0) {
+        if (optRules.length === 0 && optLocalVMs.length === 0 &&
+            optRemoteVMs.length === 0) {
             throw new Error(
                 'Payload must contain one of: rules, localVMs, remoteVMs');
         }
diff --git a/npm/postinstall.sh b/npm/postinstall.sh
index 645f079..7cd0010 100755
--- a/npm/postinstall.sh
+++ b/npm/postinstall.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2019, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
@@ -65,6 +65,12 @@ function import_smf_manifest()
     if [[ $(uname -s) == "SunOS" ]]; then
         svccfg import $SMF_DIR/${AGENT}-setup.xml
     fi
+
+    subfile "$ROOT/smf/manifests/${AGENT}-config-migration.xml.in" \
+        "$SMF_DIR/${AGENT}-config-migration.xml"
+    if [[ $(uname -s) == "SunOS" ]]; then
+        svccfg import $SMF_DIR/${AGENT}-config-migration.xml
+    fi
 }
 
 function instance_exists()
diff --git a/npm/postuninstall.sh b/npm/postuninstall.sh
index e3ea84c..31ed946 100755
--- a/npm/postuninstall.sh
+++ b/npm/postuninstall.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2019, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 if [[ "${SDC_AGENT_SKIP_LIFECYCLE:-no}" = "yes" ]]; then
@@ -20,6 +20,12 @@ NAME=firewaller
 if [[ $(uname -s) == "SunOS" ]]; then
     svcadm disable -s $NAME
     svccfg delete $NAME
+    svcadm disable -s $NAME-agent-setup
+    svccfg delete $NAME-agent-setup
+    svcadm disable -s $NAME-config-migration
+    svccfg delete $NAME-config-migration
 fi
 
 rm -f "$SMFDIR/$NAME.xml"
+rm -f "$SMFDIR/$NAME-agent-setup.xml"
+rm -f "$SMFDIR/$NAME-config-migration.xml"
diff --git a/smf/manifests/firewaller-config-migration.xml.in b/smf/manifests/firewaller-config-migration.xml.in
new file mode 100644
index 0000000..a7f5982
--- /dev/null
+++ b/smf/manifests/firewaller-config-migration.xml.in
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+<!--
+  Firewaller agent config migration SMF manifest.
+  When per-zone ipf.conf and ipf6.conf files change in a way that it's not backward compatible,
+  we need a service which will ensure that each zone's ipf configuration files are a version that
+  is compatible with the running system.
+ -->
+<service_bundle type="manifest" name="firewaller">
+  <service name="smartdc/agent/firewaller-config-migration" type="service" version="@@VERSION@@">
+    <dependency name="network_and_local_filesystem" grouping="require_all" restart_on="error" type="service">
+      <service_fmri value="svc:/network/physical"/>
+      <service_fmri value="svc:/system/filesystem/local"/>
+    </dependency>
+    <!--
+        Make vmadmd and zones services depend on this service so that firewall
+        rules are correct before those services cause them to be read.
+    -->
+    <dependent name="smartdc_vmadmd_and_system_zones" grouping="optional_all" restart_on="none">
+      <service_fmri value="svc:/system/smartdc/vmadmd:default"/>
+      <service_fmri value="svc:/system/zones:default"/>
+    </dependent>
+    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js &amp;" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+        <method_environment>
+          <envvar name="PATH" value="@@PREFIX@@/bin:/usr/bin:/usr/sbin"/>
+        </method_environment>
+      </method_context>
+    </exec_method>
+    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+      <method_context>
+        <method_credential user="root" group="staff"/>
+      </method_context>
+    </exec_method>
+    <instance name="default" enabled="true"/>
+    <stability value="Unstable"/>
+    <template>
+      <common_name>
+        <loctext xml:lang="C">Firewaller Agent Config Migration</loctext>
+      </common_name>
+    </template>
+  </service>
+</service_bundle>
-- 
2.21.0

