From b439908c344d5da6cbc9b980c62e94014596f5fe Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody.kantor@gmail.com>
Date: Mon, 8 Jan 2018 19:49:34 +0000
Subject: [PATCH] joyent/pgstatsmon#3 need a test suite

---
 CONTRIBUTING.md          |   4 +-
 Makefile                 |   8 +-
 README.md                |  58 +++++++--
 jsl.node.conf            |   2 +
 lib/pgstatsmon.js        | 166 ++++++++++++++++++++-----
 package.json             |  24 ++--
 test/badquery.tst.js     | 149 ++++++++++++++++++++++
 test/basic.tst.js        | 262 +++++++++++++++++++++++++++++++++++++++
 test/etc/testconfig.json |  12 ++
 test/helper.js           | 158 +++++++++++++++++++++++
 10 files changed, 793 insertions(+), 50 deletions(-)
 create mode 100644 test/badquery.tst.js
 create mode 100644 test/basic.tst.js
 create mode 100644 test/etc/testconfig.json
 create mode 100644 test/helper.js

diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 33def05..4dcd80e 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -5,6 +5,8 @@ changes.  Anyone can submit changes.  To get started, see the [cr.joyent.us user
 guide](https://github.com/joyent/joyent-gerrit/blob/master/docs/user/README.md).
 This repo does not use GitHub pull requests.
 
+You must submit a GitHub issue before submitting a change for code review.
+
 See the [Joyent Engineering
 Guidelines](https://github.com/joyent/eng/blob/master/docs/index.md) for general
 best practices expected in this repository.
@@ -14,5 +16,3 @@ Contributions should be "make prepush" clean.  The "prepush" target runs the
 
 * https://github.com/davepacheco/jsstyle
 * https://github.com/davepacheco/javascriptlint
-
-You must submit a GitHub issue before submitting a change for code review.
diff --git a/Makefile b/Makefile
index 1b8ce2f..cbe477c 100644
--- a/Makefile
+++ b/Makefile
@@ -17,13 +17,17 @@ JSSTYLE		 = jsstyle
 #
 # Files
 #
-JS_FILES	:= $(shell find bin etc lib -name '*.js')
-JSON_FILES      := package.json $(shell find etc -name '*.json')
+JS_FILES	:= $(shell find bin etc lib test -name '*.js')
+JSON_FILES      := package.json $(shell find etc test -name '*.json')
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSL_CONF_NODE	 = jsl.node.conf
+CLEAN_FILES	+= node_modules
 
 all:
 	npm install
 
+test: all
+	catest test/*.tst.js
+
 include ./Makefile.targ
diff --git a/README.md b/README.md
index d93c89d..71aea53 100644
--- a/README.md
+++ b/README.md
@@ -17,14 +17,6 @@ Then run the monitor with:
 
 It logs to stdout using bunyan.
 
-An SMF manifest is provided in order to run pgstatsmon as an SMF service.
-
-    svccfg import ./smf/manifests/pgstatsmon.xml
-
-If run as an SMF service, stdout is redirected to the service's log directory,
-which can be found by using the `svcs` tool:
-    svcs -L pgstatsmon
-
 ## Example
 ```
 $ cat etc/myconfig.json
@@ -77,6 +69,56 @@ every Postgres instance being monitored.
 The listening IP address and port numbers are specified in the pgstatsmon
 configuration file.
 
+## Testing
+Automated tests can be run using the `make test` target. The tests require the
+'catest' tool, which can be found here:
+
+* https://github.com/joyent/catest
+
+pgstatsmon requires a standalone Postgres instance to run functional
+tests.  The testing suite uses a configuration file that has the same format as
+the usual pgstatsmon configuration file.  There is a template configuration file
+at `./test/etc/testconfig.json`.  Each test optionally allows specifying a
+configuration file path as the first argument.  The 'make test' target will
+only use the default configuration file ('./test/etc/testconfig.json').
+
+A few things to note:
+* Do not point the tests at a production Postgres instance.  The tests will
+  create and drop tables in the given test database as they see fit.
+* The tests assume that the user and database listed in the test configuration
+  file are created before the tests are run.
+* Tests will generally ignore the 'interval' configuration field.  The tests
+  will instead manually kick off metric collection from the specified Postgres
+  instances when they find it necessary.  Modifying the 'interval' field won't
+  make the tests run shorter or longer.
+
+It's easy to create a test user and database once you have a Postgres instance
+running:
+
+    psql -U postgres -c 'CREATE ROLE pgstatsmon WITH LOGIN;'
+    psql -U postgres -c 'CREATE DATABASE pgstatsmon;'
+
+It may be useful to give the user additional privileges depending on what you
+will be testing.  Allowing the test user to log in to Postgres may be helpful
+for debugging failed tests.
+
+Assuming you're running your Postgres instance on the same machine you'll use
+to run the tests, your configuration file may look like this:
+```
+{
+    "interval": 2000,
+    "dbs": [ {
+        "name": "test",
+        "url": "postgres://pgstatsmon@localhost:5432/pgstatsmon"
+    } ],
+    "target": {
+        "ip": "0.0.0.0",
+        "port": 9187,
+        "route": "/metrics"
+    }
+}
+```
+
 ## License
 MPL-v2. See the LICENSE file.
 
diff --git a/jsl.node.conf b/jsl.node.conf
index a93184d..927f1d9 100644
--- a/jsl.node.conf
+++ b/jsl.node.conf
@@ -110,6 +110,7 @@
 #
 # Common uses for webpages might be:
 +define __dirname
++define __filename
 +define clearInterval
 +define clearTimeout
 +define console
@@ -118,6 +119,7 @@
 +define process
 +define require
 +define module
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
diff --git a/lib/pgstatsmon.js b/lib/pgstatsmon.js
index a8c1438..0550866 100644
--- a/lib/pgstatsmon.js
+++ b/lib/pgstatsmon.js
@@ -3,7 +3,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -19,7 +19,7 @@ var mod_restify = require('restify');
 var mod_util = require('util');
 var mod_vasync = require('vasync');
 
-var queries = require('./queries').getQueries();
+var queries = require('./queries');
 
 /* Public interface */
 module.exports = pgstatsmon;
@@ -70,6 +70,7 @@ function pgstatsmon(config)
 	mod_assertplus.number(target['port'], 'config.target.port');
 	mod_assertplus.string(target['route'], 'config.target.route');
 
+	mod_pg.defaults.parseInt8 = true; /* parse int8 into a numeric value */
 	var mon = new PgMon(config);
 	mon.start();
 	return (mon);
@@ -82,7 +83,6 @@ function pgstatsmon(config)
  */
 function PgMon(config)
 {
-	var mon = this;
 	var log = config['log'];
 
 	/* Save log and configuration */
@@ -91,37 +91,82 @@ function PgMon(config)
 	this.pm_targetconf = mod_jsprim.deepCopy(config['target']);
 	this.pm_interval = config['interval'];
 	this.pm_targets = [];
+	this.pm_prometheus_target = null;
+
+	/* interval returned from setInterval */
+	this.pm_intervalObj = -1;
 
 	/* queries to run */
-	this.pm_queries = queries.map(
-	    function (q) { return (new Query(q, log)); });
+	this.pm_queries = [];
+	/* current state of each instance's request */
+	this.pm_state =	[];
+	/* last-seen datapoints for each instance */
+	this.pm_data = [];
+
 	/* postgres client objects */
 	this.pm_pgs = new Array(this.pm_dbs.length);
-	/* current state of each instance's request */
+	this.initializeMetrics(queries.getQueries());
+}
+
+/*
+ * [private] Create a backend target.  Only Prometheus targets are currently
+ * supported, which is validated by the caller.
+ */
+PgMon.prototype.createTarget = function (targetconf)
+{
+	this.pm_prom_target = new PrometheusTarget(targetconf, this.pm_log);
+	return (this.pm_prom_target);
+};
+
+/*
+ * [private] Returns the backend target.  Only Prometheus targets are currently
+ * supported.
+ */
+PgMon.prototype.getTarget = function ()
+{
+	return (this.pm_prom_target);
+};
+
+/*
+ * [private] Set the queries to be used by pgstatsmon.  This is useful to
+ * initially set the list of queries to execute.  It could also be useful for
+ * testing to swap out queries.
+ *
+ * This currently blows away all existing query information (state and data)
+ * that the PgMon class tracks.  This isn't an issue unless this is used after
+ * pgstatsmon has already collected some metrics.
+ */
+PgMon.prototype.initializeMetrics = function (query_list)
+{
+	var mon = this;
+
+	/* make sure old targets (if any) are stopped before we drop them */
+	if (this.pm_targets) {
+		this.pm_targets.forEach(function (target) {
+			target.stop();
+		});
+	}
+
+	this.pm_targets = [];
+
+	this.pm_queries = query_list.map(
+	    function (q) { return (new Query(q, mon.pm_log)); });
+
 	this.pm_state = this.pm_dbs.map(function () {
 		/* JSSTYLED */
 		return (mon.pm_queries.map(function () { return (null); }));
 	});
-	/* last-seen datapoints for each instance */
+
 	this.pm_data = this.pm_dbs.map(function () {
 		/* JSSTYLED */
 		return (mon.pm_queries.map(function () { return ({}); }));
 	});
+
 	/* Prometheus target */
 	this.pm_targets.push(mon.createTarget(this.pm_targetconf));
 
 	/* always add a "log" target */
-	this.pm_targets.push(new LogTarget(log));
-
-}
-
-/*
- * [private] Create a backend target.  Only Prometheus targets are currently
- * supported, which is validated by the caller.
- */
-PgMon.prototype.createTarget = function (targetconf)
-{
-	return (new PrometheusTarget(targetconf, this.pm_log));
+	this.pm_targets.push(new LogTarget(this.pm_log));
 };
 
 PgMon.prototype.start = function ()
@@ -151,27 +196,78 @@ PgMon.prototype.start = function ()
 
 	barrier.on('drain', function () {
 		log.info('all clients connected');
+
 		mon.tick();
-		setInterval(function () { mon.tick(); }, mon.pm_interval);
+		mon.pm_intervalObj = setInterval(function () {
+			mon.tick();
+		}, mon.pm_interval);
+
 		mon.pm_targets.forEach(function (target) {
 			target.start();
 		});
 	});
 };
 
+PgMon.prototype.stop = function ()
+{
+	clearInterval(this.pm_intervalObj);
+	this.pm_targets.forEach(function (target) {
+		target.stop();
+	});
+	this.pm_pgs.forEach(function (db) {
+		db.end(); /* close the db connections */
+	});
+};
+
 /*
- * [private] Invoked once per INTERVAL to run checks..
+ * [private] Invoked once per INTERVAL to run checks.
+ * The caller may optionally provide a callback to be notified when all queries
+ * have been completed.
+ *
+ * The implementation of this uses both a vasync queue and barriers. The queue
+ * is used to ensure that we limit the number of Postgres instances being
+ * concurrently queried. The barriers are used to coordinate kicking off all of
+ * the queries for a given Postgres instance.
  */
-PgMon.prototype.tick = function ()
+PgMon.prototype.tick = function (callback)
 {
-	var pi, qi;
-	for (pi = 0; pi < this.pm_pgs.length; pi++) {
-		for (qi = 0; qi < this.pm_queries.length; qi++)
-			this.tickPgQuery(pi, qi);
-	}
+	var mon = this;
+	var queue;
+
+	queue = mod_vasync.queue(function (pi, cb) {
+		/* kick off the Postgres queries for this instance */
+		var barrier = mod_vasync.barrier();
+		barrier.start('enqueue queries');
+		mon.pm_queries.forEach(function (query, qi) {
+			/*
+			 * barrier string looks like:
+			 *  'url [pg_index, query_index]'
+			 */
+			var query_id = mod_util.format('%s [%d, %d]',
+			    mon.pm_dbs[pi], pi, qi);
+			barrier.start(query_id);
+			mon.tickPgQuery(pi, qi, function () {
+				barrier.done(query_id);
+			});
+		});
+		barrier.done('enqueue queries');
+		barrier.on('drain', cb);
+	}, 10); /* 10 Postgres instances outstanding */
+
+	/* enqueue all of the Postgres instances */
+	this.pm_pgs.forEach(function (pg, pi) {
+		queue.push(pi);
+	});
+
+	queue.close();
+	queue.on('end', function () {
+		if (callback) {
+			setImmediate(callback);
+		}
+	});
 };
 
-PgMon.prototype.tickPgQuery = function (pi, qi)
+PgMon.prototype.tickPgQuery = function (pi, qi, cb)
 {
 	var mon = this;
 	var log = this.pm_log;
@@ -196,6 +292,7 @@ PgMon.prototype.tickPgQuery = function (pi, qi)
 		    'query': query.q_name,
 		    'last': state
 		}, 'skipping check (still pending)');
+		setImmediate(cb);
 		return;
 	}
 
@@ -230,6 +327,7 @@ PgMon.prototype.tickPgQuery = function (pi, qi)
 			    'query': query.q_name
 			}, 'query failed');
 			mon.emitCounter(errmetric, 1);
+			setImmediate(cb);
 			return;
 		}
 
@@ -246,6 +344,7 @@ PgMon.prototype.tickPgQuery = function (pi, qi)
 		};
 		mon.emitTimer(mon.qstatname(pi, qi, null, timer),
 		    mod_jsprim.hrtimeMillisec(time));
+		setImmediate(cb);
 	});
 };
 
@@ -436,6 +535,10 @@ LogTarget.prototype.start = function ()
 {
 };
 
+LogTarget.prototype.stop = function ()
+{
+};
+
 /*
  * Exposes metrics in the Prometheus format via a Restify web server.
  */
@@ -447,7 +550,8 @@ function PrometheusTarget(conf, log)
 	this.pe_route = conf.route;
 	this.pe_collector = mod_artedi.createCollector();
 	this.pe_server = mod_restify.createServer({
-		name: 'Monitor'
+		'log': this.pe_log.child({ 'component': 'prometheus_server' }),
+		'name': 'Monitor'
 	});
 
 	var prom = this;
@@ -487,7 +591,6 @@ PrometheusTarget.prototype.emitGauge = function (metric, value)
 		name: metric.name,
 		help: metric.help
 	}).set(value, metric.metadata);
-
 };
 
 PrometheusTarget.prototype.emitTimer = function (metric, duration)
@@ -506,3 +609,8 @@ PrometheusTarget.prototype.start = function ()
 		    prom.pe_port);
 	});
 };
+
+PrometheusTarget.prototype.stop = function ()
+{
+	this.pe_server.close();
+};
diff --git a/package.json b/package.json
index 0a24a4d..21b69d2 100644
--- a/package.json
+++ b/package.json
@@ -1,17 +1,23 @@
 {
-        "name": "pgstatsmon",
-        "description": "Monitor Postgres databases",
+	"name": "pgstatsmon",
+	"description": "Monitor Postgres databases",
 	"repository": {
 		"type": "git",
 		"url": "https://github.com/joyent/pgstatsmon.git"
 	},
-        "dependencies": {
-		"assert-plus": "1.0.0",
+	"dependencies": {
 		"ajv": "5.5.1",
-		"artedi": "1.1.1",
-		"bunyan": "0.22.1",
+		"artedi": "1.2.0",
+		"assert-plus": "1.0.0",
 		"jsprim": "2.0.0",
-                "pg": "0.7.0",
-		"vasync": "1.4.0"
-        }
+		"pg": "6.4.2",
+		"restify": "6.3.4",
+		"vasync": "2.2.0"
+	},
+	"devDependencies": {
+		"bunyan": "1.8.10",
+		"verror": "1.10.0"
+	},
+	"author": "Joyent, Inc",
+	"license": "MPL-2.0"
 }
diff --git a/test/badquery.tst.js b/test/badquery.tst.js
new file mode 100644
index 0000000..6b78c23
--- /dev/null
+++ b/test/badquery.tst.js
@@ -0,0 +1,149 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var helper = require('./helper');
+
+var mod_assert = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+
+var VError = require('verror').VError;
+
+/*
+ * badquery.tst.js: run some invalid queries and see how pgstatsmon handles it.
+ */
+
+function main()
+{
+	var badQuery;
+
+	/* spin up the dependent pgstatsmon and run the test cases */
+	mod_vasync.pipeline({
+		'funcs': [
+			function (_, cb) {
+				badQuery = new BadQuery(cb);
+			},
+			function (_, cb) {
+				badQuery.run_invalid_query(cb);
+			}
+		]
+	}, function (err, res) {
+		mod_assert.ifError(err);
+		badQuery.shutDown(function (err2) {
+			mod_assert.ifError(err2);
+		});
+	});
+}
+
+function BadQuery(callback)
+{
+	var self = this;
+
+	/* allow user to provide an alternate configuration file path */
+	var mon_args = {};
+	if (process.argv.length === 3) {
+		mon_args.config_file = process.argv[2];
+	}
+
+	this.log = new mod_bunyan({
+		'name': mod_path.basename(__filename),
+		'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+	mon_args.log = this.log;
+
+	this.mon = helper.getMon(mon_args);
+	this.prom_target = this.mon.getTarget();
+	this.client = helper.createClient();
+
+	this.mon.tick(function () {
+		clearInterval(self.mon.pm_intervalObj);
+		callback();
+	});
+}
+
+BadQuery.prototype.shutDown = function (callback) {
+	this.mon.stop();
+	this.client.end(callback);
+};
+
+/* Tests */
+
+/*
+ * Make pgstatsmon run a query that results in an error being returned from
+ * Postgres.
+ */
+BadQuery.prototype.run_invalid_query = function (callback)
+{
+	var self = this;
+	var queries;
+	var counter;
+	var initial_value;
+
+	/* bogus query that causes Postgres to return an error */
+	queries = [ {
+		'name': 'test_bad_query',
+		'sql': 'SELECT *',
+		'statkey': 'non_existent',
+		'metadata': [ 'no_metadata' ],
+		'counters': [],
+		'gauges': []
+	} ];
+
+	var labels = {
+		'query': queries[0].name
+	};
+
+
+	this.mon.initializeMetrics(queries);
+	/*
+	 * since mon.initializeMetrics() drops all of the data, we need to get
+	 * a pointer to the new PrometheusTarget
+	 */
+	self.prom_target = this.mon.getTarget();
+
+	mod_vasync.pipeline({
+		'funcs': [
+			/* make sure counters are created */
+			function (_, cb) {
+				self.mon.tick(cb);
+			},
+			/* get the initial query error count */
+			function (_, cb) {
+				counter =
+				    self.prom_target.pe_collector.getCollector(
+					'pg_query_error');
+				initial_value = counter.getValue(labels);
+				self.log.debug({ 'iv': initial_value });
+				cb();
+			},
+			/*
+			 * kick off another round of stat updates
+			 *
+			 * In this case only one query is executed, and it
+			 * should result in an error counter being incremented.
+			 */
+			function (_, cb) {
+				self.mon.tick(cb);
+			}
+		]
+	/* make sure pgstatsmon incremented the error counter */
+	}, function (err, results) {
+		if (err) {
+			callback(new VError(err, 'error running invalid' +
+			    ' query'));
+			return;
+		}
+		mod_assert.equal(counter.getValue(labels),
+		    initial_value + 1, 'one query error');
+
+		callback();
+	});
+};
+
+main();
diff --git a/test/basic.tst.js b/test/basic.tst.js
new file mode 100644
index 0000000..b0b180f
--- /dev/null
+++ b/test/basic.tst.js
@@ -0,0 +1,262 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var helper = require('./helper');
+
+var mod_assert = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+
+var VError = require('verror').VError;
+
+/*
+ * basic.tst.js: basic tests to ensure pgstatsmon is operating properly.
+ *
+ * According to the PG docs, the backend Postgres process will only send stats
+ * to the main Postgres process on 500ms intervals when idle (the
+ * PGSTAT_STAT_INTERVAL constant), so we have to wait in various places after
+ * ensuring sessions aren't in use to update counters. Unfortunately this is
+ * only tunable before Postgres is compiled.
+ */
+var WAIT_PERIOD = 500; /* milliseconds to wait for stat updates */
+
+function main()
+{
+	var basicTest;
+
+	/* spin up the dependent pgstatsmon and run the test cases */
+	mod_vasync.pipeline({
+		'funcs': [
+			function (_, cb) {
+				basicTest = new BasicTest(cb);
+			},
+			function (_, cb) {
+				basicTest.check_connections(cb);
+			},
+			function (_, cb) {
+				basicTest.check_tuple_count(cb);
+			}
+		]
+	}, function (err, results) {
+		mod_assert.ifError(err);
+		basicTest.shutDown(function (err2) {
+			mod_assert.ifError(err2);
+		});
+	});
+}
+
+function BasicTest(callback)
+{
+	var self = this;
+
+	/* allow user to provide an alternate configuration file path */
+	var mon_args = {};
+	if (process.argv.length === 3) {
+		mon_args.config_file = process.argv[2];
+	}
+
+	this.log = new mod_bunyan({
+		'name': mod_path.basename(__filename),
+		'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+	mon_args.log = this.log;
+
+	this.table_name = 'pgstatsmon_basic';
+	this.mon = helper.getMon(mon_args);
+	this.prom_target = this.mon.getTarget();
+	this.client = helper.createClient();
+
+	mod_vasync.pipeline({
+		'funcs': [
+			function (_, cb) {
+				helper.dropTable(self.table_name, self.client,
+				    cb);
+			},
+			function (_, cb) {
+				helper.createTable(self.table_name, self.client,
+				    cb);
+			},
+			function (_, cb) {
+				self.mon.tick(cb);
+			}
+		]
+	}, function (err, results) {
+		if (err) {
+			callback(new VError(err, 'error preparing tests'));
+			return;
+		}
+		clearInterval(self.mon.pm_intervalObj);
+		callback();
+	});
+}
+
+BasicTest.prototype.shutDown = function (callback)
+{
+	var self = this;
+	mod_vasync.pipeline({
+		'funcs': [
+			function (_, cb) {
+				helper.dropTable(self.table_name, self.client,
+				    cb);
+			},
+			function (_, cb) {
+				self.mon.stop();
+				cb();
+			},
+			function (_, cb) {
+				self.client.end(cb);
+			}
+		]
+	}, function (err, results) {
+		if (err) {
+			callback(new VError(err, 'error during shutdown'));
+			return;
+		}
+		callback(err);
+	});
+};
+
+/* Tests */
+
+/*
+ * Get the tuple count, add a tuple, get the count again and make sure
+ * pgstatsmon recognizes the added tuple.
+ */
+BasicTest.prototype.check_tuple_count = function (callback)
+{
+	var self = this;
+	var mclient;
+	var gauge, counter;
+	var initial_value;
+	var q;
+	var labels = {
+		'name': this.mon.pm_dbs[0].name,
+		'relname': this.table_name
+	};
+
+	mod_vasync.pipeline({
+		'funcs': [
+			/* collect initial metrics */
+			function (_, cb) {
+				self.mon.tick(cb);
+			},
+			/*
+			 * Make sure we have a fresh start - counters and gauges
+			 * set to zero.
+			 */
+			function (_, cb) {
+				gauge =
+				    self.prom_target.pe_collector.getCollector(
+					'pg_stat_user_tables_n_live_tup');
+				counter =
+				    self.prom_target.pe_collector.getCollector(
+					'pg_stat_user_tables_n_tup_ins');
+
+				self.log.debug({ 'iv': initial_value });
+				mod_assert.equal(gauge.getValue(labels),
+				    counter.getValue(labels),
+				    'live tuples === tuples inserted');
+				initial_value = gauge.getValue(labels);
+
+				cb();
+			},
+			/* insert a single tuple */
+			function (_, cb) {
+				mclient = helper.createClient();
+				q = 'INSERT INTO ' + self.table_name +
+				    ' VALUES (\'dog\', \'woof\');';
+				mclient.query(q, function (err, res) {
+					mod_assert.ifError(err);
+					setTimeout(cb, WAIT_PERIOD);
+				});
+			},
+			function (_, cb) {
+				mclient.end(cb);
+			},
+			/* collect metrics again */
+			function (_, cb) {
+				self.mon.tick(cb);
+			}
+		]
+	/*
+	 * verify that we didn't have errors and the tuple counters were updated
+	 * properly
+	 */
+	}, function (err, results) {
+		if (err) {
+			callback(new VError(err, 'error checking tuple count'));
+			return;
+		}
+
+		mod_assert.equal(gauge.getValue(labels), initial_value + 1,
+		    'one live tuple');
+		mod_assert.equal(counter.getValue(labels), initial_value + 1,
+		    'one tuple inserted');
+		callback();
+	});
+};
+
+/*
+ * Get the idle connection count, create an idle connection, and make sure
+ * pgstatsmon recognized an added idle connection.
+ */
+BasicTest.prototype.check_connections = function (callback)
+{
+	var self = this;
+	var gauge;
+	var initial_value;
+	var mclient;
+	var labels = {
+		'name': this.mon.pm_dbs[0].name,
+		'datname': this.client.database,
+		'state': 'idle'
+	};
+
+	mod_vasync.pipeline({
+		'funcs': [
+			/* make sure we have gauges initialized */
+			function (_, cb) {
+				self.mon.tick(cb);
+			},
+			/*
+			 * discover initial idle connection count, then
+			 * create a new idle connection
+			 */
+			function (_, cb) {
+				gauge =
+				    self.prom_target.pe_collector.getCollector(
+					'pg_stat_activity_connections');
+				initial_value = gauge.getValue(labels);
+				self.log.debug({ 'iv': initial_value });
+
+				mclient = helper.createClient();
+				setTimeout(cb, WAIT_PERIOD);
+			},
+			/* kick off another round of stat updates */
+			function (_, cb) {
+				self.mon.tick(cb);
+			},
+			/* close the idle client connection */
+			function (_, cb) {
+				mclient.end(cb);
+			}
+		]
+	/* make sure pgstatsmon set the idle connection gauge properly */
+	}, function (err, results) {
+		if (err) {
+			callback(new VError(err, 'error checking connections'));
+		}
+
+		mod_assert.equal(gauge.getValue(labels), initial_value + 1,
+		    'one connection added');
+		callback();
+	});
+};
+
+main();
diff --git a/test/etc/testconfig.json b/test/etc/testconfig.json
new file mode 100644
index 0000000..661498d
--- /dev/null
+++ b/test/etc/testconfig.json
@@ -0,0 +1,12 @@
+{
+    "interval": 2000,
+    "dbs": [ {
+	"name": "test",
+	"url": "postgres://pgstatsmon@localhost:5432/pgstatsmon"
+    } ],
+    "target": {
+	"ip": "0.0.0.0",
+	"port": 9187,
+	"route": "/metrics"
+    }
+}
diff --git a/test/helper.js b/test/helper.js
new file mode 100644
index 0000000..b233dcb
--- /dev/null
+++ b/test/helper.js
@@ -0,0 +1,158 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_fs = require('fs');
+var mod_pg = require('pg');
+var mod_vasync = require('vasync');
+var pgstatsmon = require('../lib/pgstatsmon');
+
+var VError = require('verror').VError;
+
+/* Globals */
+var config;
+
+/* allow table names with alphanumeric characters, _, and - */
+var table_name_regex = new RegExp('^[a-zA-Z0-9_-]*$');
+
+/* helper.js: helper functions to make writing tests easier. */
+
+/*
+ * This is the testing analog to the main() method in bin/pgstatsmon.js. This
+ * function will read the provided configuration file and start a new instance
+ * of pgstatsmon in this process using the provided configuration values. An
+ * instance of the PgMon class is returned to the caller.
+ *
+ * The args object can have the following fields:
+ *
+ *    log		bunyan-style logger
+ *
+ *    config_file	(optional) path to the testing configuration file.
+ *    			The default value is 'test/etc/testconfig.json'.
+ *
+ */
+function getMon(args)
+{
+	mod_assert.object(args.log, 'args.log');
+	mod_assert.optionalString(args.config_file, 'args.config_file');
+
+	var filename;
+	if (args.config_file) {
+		filename = args.config_file;
+	} else {
+		filename = './etc/testconfig.json';
+	}
+
+	var data;
+	var mon;
+	var log;
+
+	try {
+		data = mod_fs.readFileSync(filename).toString('utf8');
+	} catch (ex) {
+		console.error('%s: failed to read file: %s',
+		    filename, ex.message);
+		process.exit(1);
+	}
+
+	try {
+		config = JSON.parse(data);
+	} catch (ex) {
+		console.error('%s: failed to parse config: %s',
+		    filename, ex.message);
+		process.exit(1);
+	}
+
+	log = args.log;
+	log.info('config', config);
+
+	config['log'] = log;
+
+	mon = pgstatsmon(config);
+
+	return (mon);
+}
+
+/*
+ * Get a connection to the Postgres database
+ */
+function createClient()
+{
+	var client = new mod_pg.Client(config.dbs[0].url);
+	client.connect(function (err) {
+		if (err) {
+			config.log.error(err, config.dbs[0], 'failed to' +
+				' create connection to backend Postgres');
+		}
+	});
+	return (client);
+}
+
+/*
+ * Create a table for testing
+ */
+function createTable(table_name, client, cb)
+{
+	if (table_name_regex.test(table_name) === false) {
+		cb(new VError('invalid table name: "%s"', table_name));
+		return;
+	}
+
+	var query = 'CREATE TABLE ' + table_name + ' (animal text, sound text)';
+	doSql(query, client, function (err) {
+		cb(err);
+	});
+}
+
+/*
+ * Destroy the table used for testing
+ */
+function dropTable(table_name, client, cb)
+{
+	if (table_name_regex.test(table_name) === false) {
+		cb(new VError('invalid table name: "%s"', table_name));
+		return;
+	}
+
+	var query = 'DROP TABLE IF EXISTS ' + table_name;
+	doSql(query, client, function (err) {
+		cb(err);
+	});
+}
+
+/*
+ * Sql transaction wrapper
+ */
+function doSql(sql, client, callback)
+{
+	mod_vasync.pipeline({
+		'funcs': [
+			function (_, cb) {
+				client.query('BEGIN', cb);
+			},
+			function (_, cb) {
+				client.query(sql, cb);
+			},
+			function (_, cb) {
+				client.query('COMMIT', cb);
+			}
+		]
+	}, function (err, results) {
+		/* return any error and the results from the query */
+		callback(err, results[1]);
+	});
+}
+
+module.exports = {
+	getMon: getMon,
+	createClient: createClient,
+	createTable: createTable,
+	dropTable: dropTable,
+	doSql: doSql
+};
-- 
2.21.0

