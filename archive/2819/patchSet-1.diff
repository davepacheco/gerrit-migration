From 797a25a44d0fb15715c40a2b75693d39a547c37c Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 19 Oct 2017 14:37:53 +0000
Subject: [PATCH] 8634 epoll fails to wake on certain edge-triggered conditions
 [fix regressions]

---
 usr/src/uts/common/fs/fs_subr.c       | 27 +++++---------------
 usr/src/uts/common/fs/ufs/ufs_vnops.c |  4 +--
 usr/src/uts/common/io/devpoll.c       | 36 +++++++++++++++++----------
 usr/src/uts/common/io/rsm/rsm.c       |  1 -
 4 files changed, 31 insertions(+), 37 deletions(-)

diff --git a/usr/src/uts/common/fs/fs_subr.c b/usr/src/uts/common/fs/fs_subr.c
index 7de9563bb6..e3d07b595d 100644
--- a/usr/src/uts/common/fs/fs_subr.c
+++ b/usr/src/uts/common/fs/fs_subr.c
@@ -424,25 +424,18 @@ fs_reject_epoll()
 	    (curthread->t_pollcache->pc_flag & PC_EPOLL) != 0);
 }
 
-/*
- * Return the answer requested to poll() for non-device files.
- * Only POLLIN, POLLRDNORM, and POLLOUT are recognized.
- */
-struct pollhead fs_pollhd;
-
 /* ARGSUSED */
 int
 fs_poll(vnode_t *vp, short events, int anyyet, short *reventsp,
     struct pollhead **phpp, caller_context_t *ct)
 {
 	/*
-	 * Reject all attempts for edge-triggered polling.  These should only
-	 * occur when regular files are added to a /dev/poll handle which is in
-	 * epoll mode.  The Linux epoll does not allow epoll-ing on regular
-	 * files at all, so rejecting EPOLLET requests is congruent with those
-	 * expectations.
+	 * Regular filesystems should reject epollers.  On the off chance that
+	 * a non-epoll consumer expresses the desire for edge-triggered
+	 * polling, we reject them too.  Yes, the expected error for this
+	 * really is EPERM.
 	 */
-	if (events & POLLET) {
+	if (fs_reject_epoll() || (events & POLLET) != 0) {
 		return (EPERM);
 	}
 
@@ -457,15 +450,7 @@ fs_poll(vnode_t *vp, short events, int anyyet, short *reventsp,
 		*reventsp |= POLLOUT;
 	if (events & POLLWRBAND)
 		*reventsp |= POLLWRBAND;
-	/*
-	 * Emitting a pollhead without the intention of issuing pollwakeup()
-	 * calls against it is a recipe for trouble.  It's only acceptable in
-	 * this case since the above logic matches practically all useful
-	 * events.
-	 */
-	if (*reventsp == 0 && !anyyet) {
-		*phpp = &fs_pollhd;
-	}
+
 	return (0);
 }
 
diff --git a/usr/src/uts/common/fs/ufs/ufs_vnops.c b/usr/src/uts/common/fs/ufs/ufs_vnops.c
index 5a2c9c8021..48ad30d3db 100644
--- a/usr/src/uts/common/fs/ufs/ufs_vnops.c
+++ b/usr/src/uts/common/fs/ufs/ufs_vnops.c
@@ -5741,10 +5741,10 @@ ufs_poll(vnode_t *vp, short ev, int any, short *revp, struct pollhead **phpp,
 	struct ufsvfs	*ufsvfsp;
 
 	/*
-	 * Regular files reject edge-triggered pollers.
+	 * Regular files reject epollers (and edge-triggered pollers).
 	 * See the comment in fs_poll() for a more detailed explanation.
 	 */
-	if (ev & POLLET) {
+	if (fs_reject_epoll() || (ev & POLLET) != 0) {
 		return (EPERM);
 	}
 
diff --git a/usr/src/uts/common/io/devpoll.c b/usr/src/uts/common/io/devpoll.c
index 32d2f4c238..040a1f9190 100644
--- a/usr/src/uts/common/io/devpoll.c
+++ b/usr/src/uts/common/io/devpoll.c
@@ -371,19 +371,6 @@ repoll:
 				 * is no good way to communicate this fact to
 				 * the consumer.
 				 *
-				 * If the file struct is also reused, we may
-				 * not be able to detect the fd reuse at all.
-				 * As long as this does not cause system
-				 * failure and/or memory leaks, we will play
-				 * along.  The man page states that if the user
-				 * does not clean up closed fds, polling
-				 * results will be indeterministic.
-				 *
-				 * XXX: perhaps log the detection of fd reuse?
-				 */
-				pdp->pd_fp = fp;
-
-				/*
 				 * When this situation has been detected, it's
 				 * likely that any existing pollhead is
 				 * ill-suited to perform proper wake-ups.
@@ -396,6 +383,29 @@ repoll:
 					pollhead_delete(pdp->pd_php, pdp);
 					pdp->pd_php = NULL;
 				}
+
+				/*
+				 * Since epoll is expected to act on the
+				 * underlying 'struct file' (in Linux terms,
+				 * our vnode_t would be a closer analog) rather
+				 * than the fd itself, an implicit remove
+				 * is necessary under these circumstances to
+				 * suppress any results (or errors) from the
+				 * new resource occupying the fd.
+				 */
+				if (is_epoll) {
+					pdp->pd_fp = NULL;
+					pdp->pd_events = 0;
+					BT_CLEAR(pcp->pc_bitmap, fd);
+					releasef(fd);
+					continue;
+				} else {
+					/*
+					 * Regular /dev/poll is unbothered
+					 * about the fd reassignment.
+					 */
+					pdp->pd_fp = fp;
+				}
 			}
 			/*
 			 * XXX - pollrelock() logic needs to know which
diff --git a/usr/src/uts/common/io/rsm/rsm.c b/usr/src/uts/common/io/rsm/rsm.c
index d9cca67414..4c5489b039 100644
--- a/usr/src/uts/common/io/rsm/rsm.c
+++ b/usr/src/uts/common/io/rsm/rsm.c
@@ -24,7 +24,6 @@
  * Copyright 2012 Milan Jurik. All rights reserved.
  * Copyright 2017 Joyent, Inc.
  * Copyright (c) 2016 by Delphix. All rights reserved.
- * Copyright 2017 Joyent, Inc.
  */
 
 
-- 
2.21.0

