commit 33f9a7266f969507bd6d1c2d40e436502e0778ad
Author: David Pacheco <dap@joyent.com>
Date:   2016-10-14T16:37:42-07:00 (3 years ago)
    
    MORAY-346 moray client needs work
    MORAY-309 error events should be emitted with prudence
    MORAY-257 MorayClient should emit errors properly
    MORAY-334 minnow clients reporting no active connections when moray seems to be up
    MORAY-361 moray client tools hang forever while moray is down
    MORAY-238 node-moray retry policy does not match what's configured
    MORAY-357 moray errors indict client for server-side problem
    MORAY-356 moray client continuing to periodically check DNS after close
    MORAY-325 node-moray client emits 'close' event even if some connections are still open
    MORAY-300 node-moray requires log parameter unnecessarily for version and ping
    MORAY-362 reindexobjects always fails on missing vasync dependency
    MORAY-365 command-line tools are not checked for style or lint
    MORAY-366 want command-line tool for "gettokens" RPC call

diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..6dbd88e
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,73 @@
+# Changelog
+
+## v2.0.0
+
+This is a major rewrite of the guts of this module, primarily to improve
+scalability with large numbers of servers and robustness in the face of
+networking failures.
+
+**Breaking changes**:
+
+* The `version()` method has been removed.  See [RFD
+  33](https://github.com/joyent/rfd/blob/master/rfd/0033/README.md#compatibility-and-upgrade-impact)
+  for details.  This was generally not used correctly.
+* Errors emitted by RPC calls have different names, because
+  server-side errors are now wrapped with errors that reflect the RPC context.
+  For example, instead of SomeServerSideError, you'll have a FastRequestError
+  that wraps a FastServerError that wraps a SomeServerSideError.  You can
+  restore the old behavior by supplying the `unwrapErrors` constructor
+  argument, which will cause the client to emit the same errors it emitted
+  before (without the Fast-level wrappers).  **Callers should generally be
+  updated to use
+  [VError.findCauseByName](https://github.com/joyent/node-verror#verrorfindcausebynameerr-name)
+  instead of checking the `name` property directly.**
+
+**Other changes:**
+
+* The constructor now accepts a more precise set of arguments related to
+  timeouts, delays, and retry policies.  See the constructor's comments for
+  usage information.  The constructor is backwards-compatible, so you can still
+  supply the same arguments that were used by the old client version (though you
+  cannot mix old and new styles).
+* This version replaced much of the implementation to use
+  [node-cueball](https://github.com/joyent/node-cueball) for service discovery
+  and connection health management.  Previously, this module did its own
+  service discovery that did not support eDNS or TCP-based DNS, so it did not
+  scale well with large numbers of servers.  Previously, the node-fast module
+  was responsible for connection health management.  However, node-fast didn't
+  actually handle explicit network errors; it simply attempted to avoid reading
+  and writing on sockets that were no longer readable or writable.  This worked
+  surprisingly well in the face of servers simply restarting, but it failed
+  badly when the socket experienced a true network failure (like ETIMEDOUT or
+  ECONNRESET).  Since both of these problems are both hard and need to be solved
+  for other components (e.g., HTTP-based components), they were separated into
+  the new "cueball" module.
+* Related to that, this version replaced the Fast protocol implementation with
+  [node-fast version 2](https://github.com/joyent/node-fast).  node-fast v2 is
+  substantially simpler than the previous implementation of fast (because it
+  does not deal with service discovery or connection health management) and much
+  more robust to protocol errors than the previous implementation was.
+
+Specific issues fixed:
+
+* [MORAY-362](http://smartos.org/bugview/MORAY-362) reindexobjects always fails on missing vasync dependency
+* [MORAY-361](http://smartos.org/bugview/MORAY-361) moray client tools hang forever while moray is down
+* [MORAY-346](http://smartos.org/bugview/MORAY-346) moray client needs work
+* [MORAY-309](http://smartos.org/bugview/MORAY-309) error events should be emitted with prudence
+* [MORAY-257](http://smartos.org/bugview/MORAY-257) MorayClient should emit errors properly
+* [MORAY-300](http://smartos.org/bugview/MORAY-300) node-moray requires log parameter unnecessarily for version and ping
+* [MORAY-334](http://smartos.org/bugview/MORAY-334) minnow clients reporting no active connections when moray seems to be up
+* [MORAY-356](http://smartos.org/bugview/MORAY-356) moray client continuing to periodically check DNS after close
+* [MORAY-325](http://smartos.org/bugview/MORAY-325) node-moray client emits 'close' event even if some connections are still open
+* [MORAY-365](http://smartos.org/bugview/MORAY-365) command-line tools are not checked for style or lint
+* [MORAY-366](http://smartos.org/bugview/MORAY-366) want command-line tool for "gettokens" RPC call
+* [MORAY-238](http://smartos.org/bugview/MORAY-238) node-moray retry policy does not match what's configured
+* [MORAY-357](http://smartos.org/bugview/MORAY-357) moray errors indict client for server-side problem
+
+
+## v1 and earlier
+
+Major version 1 and earlier (including v1.0.1 and everything before that) were
+distributed using git URLs, not npm.  As a result, they didn't really support
+semver.  These may be retroactively published to npm to aid the transition to
+v2.
diff --git a/Makefile b/Makefile
index 4011839..dd30cd3 100644
--- a/Makefile
+++ b/Makefile
@@ -25,12 +25,14 @@
 #
 # Tools
 #
+NODE			:= node
 NPM			:= npm
 
 #
 # Files
 #
 JS_FILES	:= $(shell find lib -name '*.js')
+JS_FILES	+= $(wildcard bin/*)
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
diff --git a/README.md b/README.md
index 6d00831..4407252 100644
--- a/README.md
+++ b/README.md
@@ -20,7 +20,7 @@ project pages. *Do not use GitHub PRs*.
 
 ## Overview
 
-This is the (node.js) client SDK for [Moray](https://mo.joyent.com/docs/moray).
+This is the (node.js) client SDK for [Moray](https://github.com/joyent/moray).
 For usage information, visit the Moray docs.
 
 
diff --git a/bin/backfill b/bin/backfill
index 1f6d8b4..3983499 100755
--- a/bin/backfill
+++ b/bin/backfill
@@ -30,6 +30,7 @@ var p = console.log;
 var path = require('path');
 var util = require('util');
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 var ProgressBar = require('progbar').ProgressBar;
 
@@ -43,7 +44,7 @@ var format = util.format;
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -65,7 +66,8 @@ function usage(msg) {
 
     var str = 'usage: ' + path.basename(process.argv[1]);
     // "limit" here is really batch size.
-    str += ' [-v] [-h host] [-p port] [-i index] [-l batch-size] [-P predicate] bucket';
+    str += ' [-v] [-h host] [-p port] [-i index] [-l batch-size] ' +
+        '[-P predicate] bucket';
     console.error(str);
     process.exit(1);
 }
@@ -144,33 +146,39 @@ var options = parseOptions();
 
 function backfillBucket() {
     var client = moray.createClient({
+        mustCloseBeforeNormalProcessExit: true,
+        failFast: true,
         host: options.host,
         log: LOG,
         port: options.port
     });
-    var cfg = options.config || {
-        options: options.options
-    };
     var bar;
 
+    client.on('error', cmdutil.fail);
     client.on('connect', function onConnect() {
         var pred;
         function getPredicate(cb) {
             client.getBucket(options.name, function (err, bucket) {
-                if (err) return cb(err);
+                if (err) {
+                    cb(err);
+                    return;
+                }
                 var ary = [];
                 options.indexes.forEach(function (i) {
                     ary.push('\'%' + i + '%\'');
                 });
-                pred = 'from ' + options.name + ' where _value like any (array[' +
-                    ary.join(',') + '])';
+                pred = 'from ' + options.name +
+                    ' where _value like any (array[' + ary.join(',') + '])';
                 Object.keys(options.predicates).forEach(function (field) {
-                    var isArray = bucket.index[field] && bucket.index[field].type[0] == '[';
+                    var isArray = bucket.index[field] &&
+                        bucket.index[field].type[0] == '[';
                     var values = options.predicates[field];
                     if (isArray) {
-                        pred += format(' and %s in (array[\'%s\'])', field, values.join("'], array['"));
+                        pred += format(' and %s in (array[\'%s\'])', field,
+                            values.join('\'], array[\''));
                     } else {
-                        pred += format(' and %s in (\'%s\')', field, values.join("', '"));
+                        pred += format(' and %s in (\'%s\')', field,
+                            values.join('\', \''));
                     }
                 });
                 cb(null, pred);
@@ -186,7 +194,7 @@ function backfillBucket() {
 
                 countReq.once('error', function (err) {
                     console.error(err.message);
-                    return cb(err);
+                    return (cb(err));
                 });
 
                 countReq.on('record', function (obj) {
@@ -201,11 +209,9 @@ function backfillBucket() {
                     }
                 });
 
-                countReq.once('end', function () {
-                    return cb();
-                });
+                countReq.once('end', cb);
             } else {
-                return cb();
+                cb();
             }
         }
 
@@ -215,9 +221,9 @@ function backfillBucket() {
 
             function wait() {
                 if (done === limit || TOTAL === PROCESSED) {
-                    return cb();
+                    return (cb());
                 } else {
-                    return setTimeout(wait, 1000);
+                    return (setTimeout(wait, 1000));
                 }
             }
 
@@ -228,7 +234,7 @@ function backfillBucket() {
 
             req.once('error', function (err) {
                 console.error(err.message);
-                return cb(err);
+                return (cb(err));
             });
 
             req.on('record', function (obj) {
@@ -244,8 +250,8 @@ function backfillBucket() {
                     for (var i = 0; i < options.indexes.length; i++) {
                         // XXX Not sure about a UFDS field with multiple values.
                         var idx = options.indexes[i];
-                        if (data.hasOwnProperty(idx)
-                            && String(data[idx]) !== _2update[key][idx]) {
+                        if (data.hasOwnProperty(idx) &&
+                            String(data[idx]) !== _2update[key][idx]) {
                             skip = false;
                             break;
                         }
@@ -268,7 +274,7 @@ function backfillBucket() {
                         }
                     });
                 });
-                return wait();
+                return (wait());
             });
 
         }
@@ -283,15 +289,13 @@ function backfillBucket() {
                         backfillObjects(PROCESSED, options.limit, processCb);
                     });
                 }
-                return (false);
             } else if (PROCESSED < TOTAL) {
-                return backfillObjects(PROCESSED, options.limit, processCb);
+                backfillObjects(PROCESSED, options.limit, processCb);
             } else {
                 bar.end();
                 client.close();
                 console.log('Backfill of %d objects done (in %d seconds)',
                             TOTAL, (Date.now() - START) / 1000);
-                process.exit(0);
             }
         }
 
diff --git a/bin/delbucket b/bin/delbucket
index 64ad79d..1440ddb 100755
--- a/bin/delbucket
+++ b/bin/delbucket
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,11 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vh:p:',
-                                        process.argv);
-    var tmp;
+    var parser = new getopt.BasicParser('vh:p:', process.argv);
 
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
@@ -99,6 +98,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -110,6 +111,8 @@ client.on('connect', function onConnect() {
             console.error(err.toString());
             process.exit(1);
         }
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/delmany b/bin/delmany
index c3433ba..6a66ba7 100755
--- a/bin/delmany
+++ b/bin/delmany
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var prettyPrint = true;
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -51,8 +52,7 @@ function parseOptions() {
         port: 2020,
         sort: {}
     };
-    var parser = new getopt.BasicParser('vh:l:o:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vh:l:o:p:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -98,7 +98,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "filter"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.filter = tmp[1];
 
@@ -113,6 +113,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -134,6 +136,8 @@ client.on('connect', function onConnect() {
         }
 
         console.log(meta.count + ' records deleted');
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/delobject b/bin/delobject
index 3838e5f..f304fa9 100755
--- a/bin/delobject
+++ b/bin/delobject
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,10 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vsh:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vsh:p:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -93,7 +93,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "key"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.key = tmp[1];
 
@@ -108,20 +108,22 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
 });
 
 client.on('connect', function onConnect() {
-    client.delObject(options.bucket,
-                     options.key,
-                     function callback(err, obj) {
-                         if (err) {
-                             console.error(err.message);
-                             process.exit(1);
-                         }
-
-                         process.exit(0);
-                     });
+    client.delObject(options.bucket, options.key, function callback(err, obj) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        client.close();
+    });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/findobjects b/bin/findobjects
index 850f265..975a538 100755
--- a/bin/findobjects
+++ b/bin/findobjects
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var prettyPrint = true;
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -52,8 +53,7 @@ function parseOptions() {
         port: 2020,
         sort: {}
     };
-    var parser = new getopt.BasicParser('nsva:d:Hh:l:o:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('nsva:d:Hh:l:o:p:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -121,7 +121,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "filter"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.filter = tmp[1];
 
@@ -136,6 +136,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -163,6 +165,8 @@ client.on('connect', function onConnect() {
     });
 
     req.on('end', function () {
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/getbucket b/bin/getbucket
index e48fee8..c762133 100755
--- a/bin/getbucket
+++ b/bin/getbucket
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,11 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vh:p:',
-                                        process.argv);
-    var tmp;
+    var parser = new getopt.BasicParser('vh:p:', process.argv);
 
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
@@ -99,6 +98,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -118,7 +119,9 @@ client.on('connect', function onConnect() {
             return (f.toString());
         });
 
-		console.log(JSON.stringify(b, null, 2));
-        process.exit(0);
+        console.log(JSON.stringify(b, null, 2));
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/getobject b/bin/getobject
index b995dc8..4462cce 100755
--- a/bin/getobject
+++ b/bin/getobject
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -25,7 +26,7 @@ var prettyPrint = true;
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -49,10 +50,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vsHh:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vsHh:p:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -98,7 +98,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "key"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.key = tmp[1];
 
@@ -113,26 +113,28 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
 });
 
 client.on('connect', function onConnect() {
-    client.getObject(options.bucket,
-                     options.key,
-                     { noCache: options.noCache },
-                     function callback(err, obj) {
-                         if (err) {
-                             console.error(err.message);
-                             process.exit(1);
-                         }
-
-                         if (prettyPrint)
-                             console.log(
-                                 JSON.stringify(obj, null, 2));
-                         else
-                             console.log(JSON.stringify(obj));
-                         process.exit(0);
-                     });
+    client.getObject(options.bucket, options.key, { noCache: options.noCache },
+        function callback(err, obj) {
+            if (err) {
+                console.error(err.message);
+                process.exit(1);
+            }
+
+            if (prettyPrint) {
+                console.log(JSON.stringify(obj, null, 2));
+            } else {
+                console.log(JSON.stringify(obj));
+            }
+            client.close();
+        });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/gettokens b/bin/gettokens
new file mode 100755
index 0000000..508be20
--- /dev/null
+++ b/bin/gettokens
@@ -0,0 +1,116 @@
+#!/usr/bin/env node
+// -*- mode: js -*-
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var path = require('path');
+var url = require('url');
+
+var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
+var getopt = require('posix-getopt');
+
+var moray = require('../lib');
+
+
+
+///--- Globals
+
+var LOG = bunyan.createLogger({
+    name: path.basename(process.argv[1]),
+    level: (process.env.LOG_LEVEL || 'fatal'),
+    stream: process.stderr,
+    serializers: bunyan.stdSerializers
+});
+
+
+
+///--- Functions
+
+function usage(msg) {
+    if (msg)
+        console.error(msg);
+
+    var str = 'usage: ' + path.basename(process.argv[1]);
+    str += '[-v] [-h host] [-p port]';
+    console.error(str);
+    process.exit(1);
+}
+
+
+function parseOptions() {
+    var option;
+    var opts = {
+        host: '127.0.0.1',
+        port: 2020
+    };
+    var parser = new getopt.BasicParser('vh:p:', process.argv);
+
+    if (process.env['MORAY_URL']) {
+        var u = url.parse(process.env['MORAY_URL']);
+        opts.host = u['hostname'] || opts.host;
+        opts.port = parseInt(u['port'], 10) || opts.port;
+    }
+
+    while ((option = parser.getopt()) !== undefined && !option.error) {
+        switch (option.option) {
+        case 'h':
+            opts.host = option.optarg;
+            break;
+
+        case 'p':
+            opts.port = parseInt(option.optarg, 10);
+            break;
+
+        case 'v':
+            // Allows us to set -vvv -> this little hackery
+            // just ensures that we're never < TRACE
+            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
+            if (LOG.level() <= bunyan.DEBUG)
+                LOG = LOG.child({src: true});
+            break;
+
+        default:
+            process.exit(1);
+            break;
+        }
+    }
+
+    return (opts);
+}
+
+
+
+///--- Mainline
+
+var client;
+var options = parseOptions();
+
+client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
+    host: options.host,
+    log: LOG,
+    port: options.port
+});
+
+client.on('connect', function onConnect() {
+    client.getTokens(function callback(err, b) {
+        if (err) {
+            console.error(err.message);
+            process.exit(1);
+        }
+
+        console.log(JSON.stringify(b, null, 2));
+        client.close();
+    });
+});
+
+client.on('error', cmdutil.fail);
diff --git a/bin/listbuckets b/bin/listbuckets
index c7a3a4f..fee34c8 100755
--- a/bin/listbuckets
+++ b/bin/listbuckets
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,11 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vh:p:',
-                                        process.argv);
-    var tmp;
+    var parser = new getopt.BasicParser('vh:p:', process.argv);
 
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
@@ -95,6 +94,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -114,7 +115,9 @@ client.on('connect', function onConnect() {
             return (f.toString());
         });
 
-	    console.log(JSON.stringify(b, null, 2));
-        process.exit(0);
+        console.log(JSON.stringify(b, null, 2));
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/morayping b/bin/morayping
index 449b39d..3e9bee2 100755
--- a/bin/morayping
+++ b/bin/morayping
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -49,10 +50,9 @@ function parseOptions() {
     var opts = {
         host: '127.0.0.1',
         port: 2020,
+        failFast: true
     };
-    var parser = new getopt.BasicParser('vdh:p:',
-                                        process.argv);
-    var tmp;
+    var parser = new getopt.BasicParser('vdFh:p:', process.argv);
 
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
@@ -65,6 +65,11 @@ function parseOptions() {
         case 'd':
             opts.deep = true;
             break;
+
+        case 'F':
+            opts.failFast = false;
+            break;
+
         case 'h':
             opts.host = option.optarg;
             break;
@@ -98,6 +103,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: options.failFast,
     host: options.host,
     log: LOG,
     port: options.port
@@ -109,6 +116,8 @@ client.on('connect', function onConnect() {
             console.error(err.toString());
             process.exit(1);
         }
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/morayversion b/bin/morayversion
index f03b576..86e2194 100755
--- a/bin/morayversion
+++ b/bin/morayversion
@@ -13,6 +13,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -23,7 +24,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -47,11 +48,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vdh:p:',
-                                        process.argv);
-    var tmp;
+    var parser = new getopt.BasicParser('vdh:p:', process.argv);
 
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
@@ -97,18 +96,23 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
 });
 
 client.on('connect', function onConnect() {
-    client.version({deep: options.deep, log: LOG}, function callback(err, data) {
+    var rqoptions = {deep: options.deep, log: LOG};
+    client.versionInternal(rqoptions, function callback(err, data) {
         if (err) {
             console.error(err.toString());
             process.exit(1);
         }
         console.log(data);
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/putbucket b/bin/putbucket
index b263752..23e8222 100755
--- a/bin/putbucket
+++ b/bin/putbucket
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -53,8 +54,7 @@ function parseOptions() {
         index: {},
         options: {}
     };
-    var parser = new getopt.BasicParser('svti:h:p:u:x:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('svti:h:p:u:x:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -121,7 +121,7 @@ function parseOptions() {
 
     if (parser.optind() >= process.argv.length)
         usage('missing required argument: "name"');
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.name = tmp[0];
 
     if (opts.stdin) {
@@ -151,6 +151,8 @@ function parseOptions() {
 
 function putBucket() {
     var client = moray.createClient({
+        mustCloseBeforeNormalProcessExit: true,
+        failFast: true,
         host: options.host,
         log: LOG,
         port: options.port
@@ -165,9 +167,11 @@ function putBucket() {
                 console.error(err.message);
                 process.exit(1);
             }
-            process.exit(0);
+            client.close();
         });
     });
+
+    client.on('error', cmdutil.fail);
 }
 
 
diff --git a/bin/putobject b/bin/putobject
index abcc0a3..b0ad553 100755
--- a/bin/putobject
+++ b/bin/putobject
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,11 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
-        index: {}
+        port: 2020
     };
-    var parser = new getopt.BasicParser('ve:h:p:d:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('ve:h:p:d:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -98,7 +97,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "key"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.key = tmp[1];
 
@@ -113,24 +112,23 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
 });
 
 client.on('connect', function onConnect() {
-    var cfg = {
-        index: options.index
-    };
-    client.putObject(options.bucket,
-                     options.key,
-                     options.data || {},
-                     options.etag ? { 'etag': options.etag } : {},
-                     function callback(err) {
-                         if (err) {
-                             console.error(err.message);
-                             process.exit(1);
-                         }
-                         process.exit(0);
-                     });
+    client.putObject(options.bucket, options.key, options.data || {},
+        options.etag ? { 'etag': options.etag } : {}, function callback(err) {
+            if (err) {
+                console.error(err.message);
+                process.exit(1);
+            }
+
+            client.close();
+        });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/reindexobjects b/bin/reindexobjects
index 8943d67..a607997 100755
--- a/bin/reindexobjects
+++ b/bin/reindexobjects
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 var vasync = require('vasync');
 
@@ -26,7 +27,7 @@ var prettyPrint = true;
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -50,10 +51,10 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vsHh:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vsHh:p:', process.argv);
+
     if (process.env['MORAY_URL']) {
         var u = url.parse(process.env['MORAY_URL']);
         opts.host = u['hostname'] || opts.host;
@@ -102,6 +103,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -117,6 +120,7 @@ client.on('connect', function onConnect() {
             if (!bucket.reindex_active ||
                 Object.keys(bucket.reindex_active).length === 0) {
                 // reindexing not require (or already complete)
+                client.close();
                 process.exit(0);
             }
             cb();
@@ -143,9 +147,9 @@ client.on('connect', function onConnect() {
             console.error(err.message);
             process.exit(1);
         }
-        reindexLoop(function (err) {
-            if (err) {
-                console.error(err.message);
+        reindexLoop(function (err2) {
+            if (err2) {
+                console.error(err2.message);
                 process.exit(1);
             }
             client.once('close', process.exit.bind(process, 0));
@@ -153,3 +157,5 @@ client.on('connect', function onConnect() {
         });
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/sql b/bin/sql
index fabf36e..1396d48 100755
--- a/bin/sql
+++ b/bin/sql
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -48,10 +49,9 @@ function parseOptions() {
     var option;
     var opts = {
         host: '127.0.0.1',
-        port: 2020,
+        port: 2020
     };
-    var parser = new getopt.BasicParser('vh:p:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vh:p:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -87,7 +87,7 @@ function parseOptions() {
     if (parser.optind() >= process.argv.length)
         usage('missing required arguments: "statement"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.statement = tmp[0];
 
     return (opts);
@@ -101,6 +101,8 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
@@ -116,10 +118,12 @@ client.on('connect', function onConnect() {
 
     req.on('record', function (obj) {
         if (typeof (obj) === 'object' && obj !== null)
-		    console.log(JSON.stringify(obj, null, 2));
+            console.log(JSON.stringify(obj, null, 2));
     });
 
     req.once('end', function () {
-        process.exit(0);
+        client.close();
     });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/bin/updatemany b/bin/updatemany
index e408638..f13eaa9 100755
--- a/bin/updatemany
+++ b/bin/updatemany
@@ -14,6 +14,7 @@ var path = require('path');
 var url = require('url');
 
 var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
 var getopt = require('posix-getopt');
 
 var moray = require('../lib');
@@ -24,7 +25,7 @@ var moray = require('../lib');
 
 var LOG = bunyan.createLogger({
     name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'info'),
+    level: (process.env.LOG_LEVEL || 'fatal'),
     stream: process.stderr,
     serializers: bunyan.stdSerializers
 });
@@ -51,8 +52,7 @@ function parseOptions() {
         port: 2020,
         options: {}
     };
-    var parser = new getopt.BasicParser('vh:l:p:d:',
-                                        process.argv);
+    var parser = new getopt.BasicParser('vh:l:p:d:', process.argv);
     var tmp;
 
     if (process.env['MORAY_URL']) {
@@ -98,7 +98,7 @@ function parseOptions() {
     if ((parser.optind() + 1) >= process.argv.length)
         usage('missing required arguments: "filter"');
 
-    var tmp = process.argv.slice(parser.optind());
+    tmp = process.argv.slice(parser.optind());
     opts.bucket = tmp[0];
     opts.filter = tmp[1];
 
@@ -113,22 +113,23 @@ var client;
 var options = parseOptions();
 
 client = moray.createClient({
+    mustCloseBeforeNormalProcessExit: true,
+    failFast: true,
     host: options.host,
     log: LOG,
     port: options.port
 });
 
 client.on('connect', function onConnect() {
-    client.updateObjects(options.bucket,
-                         options.data || {},
-                         options.filter,
-                         options.options,
-                         function callback(err, meta) {
-                             if (err) {
-                                 console.error(err.message);
-                                 process.exit(1);
-                             }
-                             console.log(meta);
-                             process.exit(0);
-                         });
+    client.updateObjects(options.bucket, options.data || {}, options.filter,
+        options.options, function callback(err, meta) {
+            if (err) {
+                console.error(err.message);
+                process.exit(1);
+            }
+            console.log(meta);
+            client.close();
+        });
 });
+
+client.on('error', cmdutil.fail);
diff --git a/lib/buckets.js b/lib/buckets.js
index a0ac767..9ced0bb 100644
--- a/lib/buckets.js
+++ b/lib/buckets.js
@@ -5,264 +5,185 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/buckets.js: bucket-related client API functions.  These functions are
+ * invoked by same-named methods in lib/client.js to do the bulk of the work
+ * associated with making RPC requests.  The arguments and semantics of these
+ * functions are documented in the Moray API.
  */
 
 var assert = require('assert-plus');
 var libuuid = require('libuuid');
-var once = require('once');
-var clone = require('clone');
-
-var utils = require('./utils');
-
-
-
-///--- Helpers
-
-function copyConfig(config) {
-    var cfg = utils.clone(config);
-
-    cfg.pre = (config.pre || []).map(function (f) {
-        return (f.toString());
-    });
-    cfg.post = (config.post || []).map(function (f) {
-        return (f.toString());
-    });
-
-    return (cfg);
-}
+var jsprim = require('jsprim');
+var VError = require('verror');
 
-
-function copyOptions(options) {
-    var opts = clone(options);
-    opts.req_id = options.req_id || libuuid.create();
-
-    return (opts);
-}
-
-
-function formatBucket(obj) {
-    function parseFunctor(f) {
-        var fn;
-        /* jsl:ignore */
-        eval('fn = ' + f);
-        /* jsl:end */
-        return (fn);
-    }
-    var res = {
-        name: obj.name,
-        index: JSON.parse(obj.index),
-        pre: JSON.parse(obj.pre).map(parseFunctor),
-        post: JSON.parse(obj.post).map(parseFunctor),
-        options: JSON.parse(obj.options),
-        mtime: new Date(obj.mtime)
-    };
-    if (obj.reindex_active) {
-        res.reindex_active = JSON.parse(obj.reindex_active);
-    }
-    return (res);
-}
+var rpc = require('./rpc');
 
 
 ///--- API
-// All of the functions here are scoped to the file as they require an
-// underlying 'fast' connection to be given to them.  The functions on
-// the moray prototype are just passthroughs to all these
 
-function createBucket(client, bucket, config, options, callback) {
-    assert.object(client, 'client');
+function createBucket(rpcctx, bucket, config, options, callback) {
+    var cfg, opts, log;
+
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.object(config, 'config');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var cfg = copyConfig(config);
-    var opts = copyOptions(options);
-    var req = client.rpc('createBucket', bucket, cfg, opts);
-    var log = utils.childLogger(client, opts);
-
-    log.debug({
-        bucket: bucket,
-        config: cfg
-    }, 'createBucket: entered');
-
-    var cb = utils.simpleCallback({
-        callback: callback,
-        log: log,
-        name: 'createBucket',
-        request: req
-    });
-
-    req.once('end', cb);
-    req.once('error', cb);
+    cfg = serializeBucketConfig(config);
+    opts = makeBucketOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+
+    /*
+     * electric-moray sends trailing null values with this response.  These are
+     * not normally allowed unless we specify ignoreNullValues.
+     */
+    rpc.rpcCommonNoData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'createBucket',
+        'rpcargs': [ bucket, cfg, opts ],
+        'ignoreNullValues': true,
+        'log': log
+    }, callback);
 }
 
+function getBucket(rpcctx, bucket, options, callback) {
+    var opts, log;
 
-function getBucket(client, bucket, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var req;
-    var res;
-    var log = utils.childLogger(client, opts);
-
-    log.debug({
-        bucket: bucket
-    }, 'getBucket: entered');
-
-    req = client.rpc('getBucket', opts, bucket);
-
-    req.once('message', function (obj) {
-        res = formatBucket(obj);
-        log.debug({
-            message: obj
-        }, 'getBucket: bucket found');
-    });
-
-    req.once('end', function () {
-        log.debug('getBucket: done');
-        callback(null, res);
-    });
+    opts = makeBucketOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'getBucket',
+        'rpcargs': [ opts, bucket ],
+        'log': log
+    }, function (err, buckets) {
+        if (!err && buckets.length != 1) {
+            err = new VError('bad server response: expected 1 bucket, found %d',
+                buckets.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'getBucket: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, parseBucketConfig(buckets[0]));
+        }
     });
 }
 
+function listBuckets(rpcctx, options, callback) {
+    var opts, log;
 
-function listBuckets(client, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var req;
-    var res = [];
-    var log = utils.childLogger(client, opts);
-
-    log.debug('listBuckets: entered');
-
-    req = client.rpc('listBuckets', opts);
-
-    req.on('message', function (obj) {
-        res.push(formatBucket(obj));
-        log.debug({
-            message: obj
-        }, 'listBuckets: bucket found');
-    });
-
-    req.once('end', function () {
-        log.debug('listBuckets: done');
-        callback(null, res);
-    });
-
-    req.once('error', function (err) {
-        log.debug(err, 'listBuckets: failed');
-        callback(err);
+    opts = makeBucketOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'listBuckets',
+        'rpcargs': [ opts ],
+        'log': log
+    }, function (err, buckets) {
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, buckets.map(parseBucketConfig));
+        }
     });
 }
 
+function updateBucket(rpcctx, bucket, config, options, callback) {
+    var cfg, opts, log;
 
-function updateBucket(client, bucket, config, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.object(config, 'config');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var cfg = copyConfig(config);
-    var opts = copyOptions(options);
-    var req = client.rpc('updateBucket', bucket, cfg, opts);
-    var log = utils.childLogger(client, opts);
-
-    log.debug({
-        bucket: bucket,
-        config: cfg
-    }, 'updateBucket: entered');
-
-    var cb = utils.simpleCallback({
-        callback: callback,
-        log: log,
-        name: 'updateBucket',
-        request: req
-    });
-
-    req.once('end', cb);
-    req.once('error', cb);
+    cfg = serializeBucketConfig(config);
+    opts = makeBucketOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+
+    /*
+     * electric-moray sends trailing null values with this response.  These are
+     * not normally allowed unless we specify ignoreNullValues.
+     */
+    rpc.rpcCommonNoData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'updateBucket',
+        'rpcargs': [ bucket, cfg, opts ],
+        'ignoreNullValues': true,
+        'log': log
+    }, callback);
 }
 
+function deleteBucket(rpcctx, bucket, options, callback) {
+    var opts, log;
 
-function deleteBucket(client, bucket, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var req;
-    var log = utils.childLogger(client, opts);
-
-    log.debug({
-        bucket: bucket
-    }, 'delBucket: entered');
-
-    req = client.rpc('delBucket', bucket, options);
-
-    req.once('end', function () {
-        log.debug('delBucket: done');
-        callback();
-    });
-
-    req.once('error', function (err) {
-        log.debug(err, 'delBucket: failed');
-        callback(err);
-    });
+    opts = makeBucketOptions(options);
+    opts.bucket = bucket;
+    log = rpc.childLogger(rpcctx, opts);
+
+    /*
+     * electric-moray sends trailing null values with this response.  These are
+     * not normally allowed unless we specify ignoreNullValues.
+     */
+    rpc.rpcCommonNoData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'delBucket',
+        'rpcargs': [ bucket, opts ],
+        'ignoreNullValues': true,
+        'log': log
+    }, callback);
 }
 
-
-function putBucket(client, b, cfg, options, cb) {
-    assert.object(client, 'client');
+function putBucket(rpcctx, b, cfg, options, cb) {
+    assert.object(rpcctx, 'rpcctx');
     assert.string(b, 'bucket');
     assert.object(cfg, 'config');
     assert.object(options, 'options');
     assert.func(cb, 'callback');
 
-    var opts = copyOptions(options);
+    var opts = makeBucketOptions(options);
 
-    var _cb = once(function put_callback(err) {
+    function putCallback(err) {
         // MANTA-1342: multiple racers doing putBucket
         // get this back b/c there's no way to be idempotent
         // with tables in postgres.  So we just check for that
         // error code and eat it -- this is somewhat dangerous
         // if two callers weren't doing the same putBucket, but
         // that's not really ever what we see in practice.
-        if (err && err.name !== 'BucketConflictError') {
+        if (err &&
+            VError.findCauseByName(err, 'BucketConflictError') === null) {
             cb(err);
         } else {
             cb();
         }
-    });
+    }
 
-    getBucket(client, b, opts, function (err, bucket) {
+    getBucket(rpcctx, b, opts, function (err, bucket) {
         if (err) {
-            if (err.name === 'BucketNotFoundError') {
-                createBucket(client, b, cfg, opts, _cb);
+            if (VError.findCauseByName(err, 'BucketNotFoundError') !== null) {
+                createBucket(rpcctx, b, cfg, opts, putCallback);
             } else {
-                _cb(err);
+                putCallback(err);
             }
         } else {
             // MANTA-897 - short circuit client side if
@@ -270,15 +191,75 @@ function putBucket(client, b, cfg, options, cb) {
             var v = bucket.options.version;
             var v2 = (cfg.options || {}).version || 0;
             if (v !== 0 && v === v2) {
-                _cb();
+                putCallback();
             } else {
-                updateBucket(client, b, cfg, opts, _cb);
+                updateBucket(rpcctx, b, cfg, opts, putCallback);
             }
         }
     });
 }
 
 
+///--- Helpers
+
+/*
+ * Create a shallow copy of the given configuration, but serialize functions
+ * in the "pre" and "post" arrays.
+ */
+function serializeBucketConfig(config) {
+    var cfg, k;
+
+    cfg = {};
+    if (typeof (config) == 'object' && config !== null) {
+        for (k in config) {
+            cfg[k] = config[k];
+        }
+    }
+
+    cfg.pre = (config.pre || []).map(function (f) {
+        return (f.toString());
+    });
+    cfg.post = (config.post || []).map(function (f) {
+        return (f.toString());
+    });
+
+    return (cfg);
+}
+
+/*
+ * Create options suitable for a bucket-related RPC call by creating a deep copy
+ * of the options passed in by the caller.  If the caller did not specify a
+ * req_id, create one and add it to the returned options.
+ */
+function makeBucketOptions(options) {
+    var opts = jsprim.deepCopy(options);
+    opts.req_id = options.req_id || libuuid.create();
+    return (opts);
+}
+
+/* XXX will a bad bucket here will crash the client? */
+function parseBucketConfig(obj) {
+    function parseFunctor(f) {
+        var fn;
+        /* jsl:ignore */
+        eval('fn = ' + f);
+        /* jsl:end */
+        return (fn);
+    }
+    var res = {
+        name: obj.name,
+        index: JSON.parse(obj.index),
+        pre: JSON.parse(obj.pre).map(parseFunctor),
+        post: JSON.parse(obj.post).map(parseFunctor),
+        options: JSON.parse(obj.options),
+        mtime: new Date(obj.mtime)
+    };
+    if (obj.reindex_active) {
+        res.reindex_active = JSON.parse(obj.reindex_active);
+    }
+    return (res);
+}
+
 
 ///--- Exports
 
diff --git a/lib/client.js b/lib/client.js
index 76c26d0..80702a6 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -5,340 +5,878 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/client.js: Moray client implementation.  The MorayClient object is the
+ * handle through which consumers make RPC requests to a remote Moray server.
  */
 
 var EventEmitter = require('events').EventEmitter;
 var net = require('net');
+var url = require('url');
 var util = require('util');
 
 var assert = require('assert-plus');
-var fast = require('fast');
+var cueball = require('cueball');
+var jsprim = require('jsprim');
 var libuuid = require('libuuid');
-var once = require('once');
+var VError = require('verror');
 
+var MorayConnectionPool = require('./pool');
+var FastConnection = require('./fast_connection');
 var buckets = require('./buckets');
-var dns = require('./dns');
-var ConnectionPool = require('./connection_pool');
+var meta = require('./meta');
 var objects = require('./objects');
 var tokens = require('./tokens');
-var utils = require('./utils');
 
 
+///--- Default values for function arguments
 
-///--- Globals
+var dflClientTargetConnections = 6;
+var dflClientMaxConnections = 15;
+var dflClientMaxDnsConcurrency = 3;
+var dflClientConnectRetries = 5;
+var dflClientConnectTimeout = 2000;     /* milliseconds */
+var dflClientDnsTimeout = 1000;         /* milliseconds */
+var dflClientDnsDelayMin = 10;          /* milliseconds */
+var dflClientDnsDelayMax = 10000;       /* milliseconds */
+var dflClientDelayMin = 1000;           /* milliseconds */
+var dflClientDelayMax = 60000;          /* milliseconds */
 
-var sprintf = util.format;
-var clone = utils.clone;
+var fastNRecentRequests = 30;
+var dflClientTcpKeepAliveIdle = 10000;  /* milliseconds */
 
+/*
+ * See MorayClient() constructor.
+ */
+var MORAY_CS_OPEN    = 'open';
+var MORAY_CS_CLOSING = 'closing';
+var MORAY_CS_CLOSED  = 'closed';
 
 
 ///--- Helpers
 
-// Super fugly way to return symmetric difference of two arrays
-function diffArray(a, b) {
-    var arr = [];
-
-    Object.keys(a).forEach(function (k) {
-        if (b.indexOf(a[k]) === -1 && arr.indexOf(a[k]) === -1)
-            arr.push(a[k]);
-    });
-
-    Object.keys(b).forEach(function (k) {
-        if (a.indexOf(b[k]) === -1 && arr.indexOf(b[k]) === -1)
-            arr.push(b[k]);
-    });
-
-    return (arr);
-}
-
 function emitUnavailable() {
     var emitter = new EventEmitter();
-    process.nextTick(function () {
+    setImmediate(function () {
         emitter.emit('error', new Error('no active connections'));
     });
     return (emitter);
 }
 
+/*
+ * This function constructs a set of node-cueball arguments based on legacy
+ * properties accepted by the MorayClient constructor.  Those properties
+ * included the following required properties:
+ *
+ *     url               string describing the URL (host and port) to connect to
+ *
+ * or:
+ *
+ *     host              string IP address or DNS name for remote Moray service.
+ *                       If this is an IP address, then DNS is not used.
+ *                       Otherwise, the string is used as a DNS name to find the
+ *                       actual IP addresses, and this list of IPs is maintained
+ *                       via periodic re-resolution of the DNS name.
+ *
+ *     port              positive integer: TCP port for remote Moray service
+ *
+ * and the following optional properties that, if not specified, have defaults
+ * that are assumed to be reasonable:
+ *
+ *     connectTimeout    non-negative, integer number of milliseconds
+ *                       to wait for TCP connections to be established
+ *
+ *     dns (object)      describes DNS behavior
+ *
+ *     dns.checkInterval non-negative, integer number of milliseconds
+ *                       between periodic resolution of DNS names used to keep
+ *                       the set of connected IPs up to date.  This is not used
+ *                       by cueball any more.
+ *
+ *     dns.resolvers     array of string IP addresses to use for DNS resolvers
+ *
+ *     dns.timeout       non-negative, integer number of milliseconds to wait
+ *                       for DNS query responses
+ *
+ *     maxConnections    non-negative, integer number of TCP connections that
+ *                       may ever be opened to each IP address used.  If "host"
+ *                       is an IP address, then this is the maximum number of
+ *                       connections, but if "host" is a DNS name, then there
+ *                       may be up to "maxConnections" per remote IP found in
+ *                       DNS.
+ *
+ *     retry (object)    describes a retry policy used for establishing
+ *                       connections.  Historically, the behavior with respect
+ *                       to this policy was confusing at best: this policy was
+ *                       used for establishing TCP connections to remote
+ *                       servers, but a second, hardcoded policy was used when
+ *                       this first policy was exhausted.  This policy appears
+ *                       to have been intended to cover DNS operations as well,
+ *                       but was not actually used.  In the current
+ *                       implementation, this policy is the one used for TCP
+ *                       connection establishment, and callers wanting to
+ *                       specify a DNS policy must specify cueball options
+ *                       directly rather than using these legacy options.
+ *
+ *     retry.retries     non-negative, integer number of retry attempts.  It's
+ *                       unspecified whether this is the number of attempts or
+ *                       the number of retries (i.e., one fewer than the number
+ *                       of attempts).  Today, this is interpreted by
+ *                       node-cueball.  Historically, this was interpreted by
+ *                       the node-backoff module.
+ *
+ *     retry.minTimeout  non-negative, integer number of milliseconds to wait
+ *                       after the first operation failure before retrying
+ *
+ *     retry.maxTimeout  non-negative, integer representing the maximum number
+ *                       of milliseconds between retries.  Some form of backoff
+ *                       (likely exponential) is used to determine the delay,
+ *                       but it will always be between retry.minTimeout and
+ *                       retry.maxTimeout.
+ *
+ * Additional properties were at one time documented, but never used:
+ * maxIdleTime and pingTimeout.
+ */
+function translateLegacyOptions(options) {
+    var cueballOptions, r, u;
+    var host, port;
+
+    /*
+     * This logic mirrors the legacy behavior of createClient, however
+     * unnecessarily complicated.  Specifically:
+     *
+     *     host     comes from "options.host" if present, and otherwise from
+     *              parsing "options.url"
+     *
+     *     port     comes from "options.port" (as a string or number) if
+     *              present.  If "host" was not present and "url" is, then
+     *              "port" MAY come from the parsed URL.  Otherwise, the port is
+     *              2020.
+     */
+    if (typeof (options.url) == 'string' && !options.hasOwnProperty('host')) {
+        u = url.parse(options.url);
+        host = u.hostname;
+
+        if (options.port) {
+            port = options.port;
+        } else if (u.port) {
+            port = u.port;
+        } else {
+            port = 2020;
+        }
 
-///--- API
-
-function ping(client, options, callback) {
-    assert.object(client, 'client');
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.optionalNumber(options.timeout, 'options.timeout');
-    assert.func(callback, 'callback');
-
-    callback = once(callback);
+        port = parseInt(port, 10);
+        assert.ok(!isNaN(port), 'port must be a number');
+    } else {
+        host = options.host;
+        port = options.port;
+    }
 
-    var opts = {
-        deep: options.deep || false,
-        req_id: options.req_id || libuuid.create()
-    };
-    var log = utils.childLogger(client, opts);
-    var req;
-    var t;
+    assert.string(host, 'options.host');
+    assert.number(port, 'options.port');
+    assert.optionalNumber(options.maxConnections, 'options.maxConnections');
+    assert.optionalNumber(options.connectTimeout, 'options.connectTimeout');
+    assert.optionalObject(options.retry, 'options.retry');
+    assert.optionalObject(options.dns, 'options.dns');
 
-    log.debug(opts, 'ping: entered');
+    cueballOptions = {
+        /* Resolver parameters */
+        'domain': host,
+        'maxDNSConcurrency': dflClientMaxDnsConcurrency,
+        'defaultPort': port,
 
-    function done(err) {
-        clearTimeout(t);
-        // 'error' and 'end' listeners aren't removed here since *this* function
-        // is timing out the requests and the fast client can still emit events.
-        // See: MANTA-1977
+        /* ConnectionSet parameters */
+        'target': dflClientTargetConnections,
+        'maximum': options.maxConnections || dflClientMaxConnections,
 
-        log.debug({
-            err: err,
-            req_id: opts.req_id
-        }, 'ping: %s', err ? 'failed' : 'done');
+        /* Shared parameters */
+        'recovery': {}
+    };
 
-        callback(err || null);
+    if (cueballOptions.maximum < cueballOptions.target) {
+        cueballOptions.target = cueballOptions.maximum;
     }
-    done = once(done);
-
-    req = client.rpc('ping', opts);
-    req.once('end', done);
-    req.once('error', done);
-    t = setTimeout(function onTimeout() {
-        done(new Error('ping: timeout'));
-    }, (options.timeout || 1000));
-}
 
-function version(client, options, callback) {
-    assert.object(client, 'client');
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.optionalNumber(options.timeout, 'options.timeout');
-    assert.func(callback, 'callback');
-
-    var opts = {
-        deep: options.deep || false,
-        req_id: options.req_id || libuuid.create()
+    /*
+     * DNS configuration: The delay and maxDelay values used in the previous
+     * implementation were historically hardcoded to the same values that we use
+     * use as defaults now.
+     */
+    r = cueballOptions.recovery.dns = {
+        'retries': dflClientConnectRetries,
+        'timeout': dflClientDnsTimeout,
+        'delay': dflClientDnsDelayMin,
+        'maxDelay': dflClientDnsDelayMax
     };
-    var log = utils.childLogger(client, opts);
-    var req;
-    var t;
-
-    log.debug(opts, 'version: entered');
-
-    var done = once(function (err, data) {
-        clearTimeout(t);
-        // 'error' and 'end' listeners aren't removed here since *this* function
-        // is timing out the requests and the fast client can still emit events.
-        // See: MANTA-1977
-
-        log.debug({
-            err: err,
-            req_id: opts.req_id
-        }, 'ping: %s', err ? 'failed' : 'done');
-
-        // For this specific endpoint, errors are not propagated.  Instead the
-        // minimum version (1) is returned to the caller.  This is because
-        // older versions of node-fast lacked a mechanism for communicating the
-        // lack of an RPC binding to clients.  When communicating with such an
-        // instance, this call will timeout, despite proper connectivity.
-        // This call is not to be used for verifying connectivity.
-        var ver = 0;
-        if (typeof (data) === 'object' && data.version !== undefined) {
-            ver = parseInt(data.version, 10);
+
+    if (options.dns) {
+        if (Array.isArray(options.dns.resolvers)) {
+            assert.arrayOfString(options.dns.resolvers,
+                'options.dns.resolvers');
+            cueballOptions.resolvers = options.dns.resolvers.slice(0);
         }
-        if (ver <= 0) {
-            ver = 1; // Minimum moray API version
+
+        if (options.dns.timeout) {
+            assert.number(options.dns.timeout, 'options.dns.timeout');
+            assert.ok(options.dns.timeout >= 0,
+                'dns timeout must be non-negative');
+            r.timeout = options.dns.timeout;
         }
+    }
 
+    /*
+     * Right or wrong, the legacy behavior was that the timeout for each
+     * request never increased.
+     */
+    r.maxTimeout = r.timeout;
+
+    /*
+     * DNS SRV configuration: SRV should fail fast, since it's not widely
+     * deployed yet.
+     */
+    cueballOptions.recovery.dns_srv = jsprim.deepCopy(
+        cueballOptions.recovery.dns);
+    cueballOptions.recovery.dns_srv.retries = 0;
+
+    /*
+     * Default recovery configuration: we specify a 'default' recovery in
+     * the cueball options that will cover both the initial connect attempt
+     * and subsequent connect attempts.
+     */
+    r = cueballOptions.recovery.default = {};
+    if (typeof (options.connectTimeout) == 'number') {
+        assert.ok(options.connectTimeout >= 0,
+            'connect timeout must be non-negative');
+        r.timeout = options.connectTimeout;
+    } else {
+        r.timeout = dflClientConnectTimeout;
+    }
 
-        callback(ver);
-    });
+    /*
+     * As with DNS requests, connection operations historically used a fixed
+     * timeout value.
+     */
+    r.maxTimeout = r.timeout;
 
-    req = client.rpc('version', opts);
-    req.on('message', function (msg) {
-        if (msg !== null) {
-            log.debug('version: msg: %j', msg);
-            done(null, msg);
+    if (options.retry) {
+        assert.optionalNumber(options.retry.retries, 'options.retry.retries');
+        if (typeof (options.retry.retries) == 'number') {
+            r.retries = options.retry.retries;
+        } else {
+            r.retries = dflClientConnectRetries;
         }
-    });
-    req.once('error', done);
-    t = setTimeout(function onTimeout() {
-        done(new Error('version: timeout'));
-    }, (options.timeout || 1000));
-}
-
-function sql(client, statement, values, options) {
-    assert.object(client, 'client');
-    assert.string(statement, 'statement');
-    assert.ok(Array.isArray(values));
-    assert.object(options, 'options');
 
-    var opts = {
-        req_id: options.req_id || libuuid.create()
-    };
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('sql', statement, values, opts);
-    var res = new EventEmitter();
-
-    log.debug({
-        statement: statement,
-        values: values
-    }, 'sql: entered');
-
-    req.on('message', function (msg) {
-        if (msg !== null) {
-            log.debug('sql: msg: %j', msg);
-            res.emit('record', msg);
+        /*
+         * It's confusing, but the "timeout" for a retry policy is
+         * really a delay.
+         */
+        assert.optionalNumber(options.retry.minTimeout,
+            'options.retry.minTimeout');
+        if (typeof (options.retry.minTimeout) == 'number') {
+            r.delay = options.retry.minTimeout;
+
+            if (typeof (options.retry.maxTimeout) == 'number') {
+                assert.ok(options.retry.maxTimeout >=
+                    options.retry.minTimeout,
+                    'retry.maxTimeout must not be smaller ' +
+                    'than retry.minTimeout');
+                r.maxDelay = options.retry.maxTimeout;
+            } else {
+                r.delay = options.retry.minTimeout;
+                r.maxDelay = Math.max(r.delay, dflClientDelayMax);
+            }
+        } else if (typeof (options.retry.maxTimeout) == 'number') {
+            r.maxDelay = options.retry.maxTimeout;
+            r.delay = Math.min(dflClientDelayMin, r.maxDelay);
+        } else {
+            r.delay = dflClientDelayMin;
+            r.maxDelay = dflClientDelayMax;
         }
-    });
 
-    req.once('end', function () {
-        log.debug('sql: done');
-        res.removeAllListeners('res');
-        res.removeAllListeners('error');
-        res.emit('end');
-    });
-
-    req.once('error', function (err) {
-        log.debug({
-            err: err,
-            req_id: opts.req_id
-        }, 'sql: failed');
-        res.removeAllListeners('data');
-        res.removeAllListeners('end');
-        res.emit('error', err);
-    });
+        assert.number(r.delay);
+        assert.number(r.maxDelay);
+        assert.ok(r.delay <= r.maxDelay);
+    } else {
+        r.retries = 0;
+        r.delay = 0;
+        r.maxDelay = r.delay;
+    }
 
-    return (res);
+    return (cueballOptions);
 }
 
 
 ///--- API
 
-/**
+/*
  * Constructor for the moray client.
  *
- * This client, when given a DNS name will create a ring of TCP connections to
- * each IP in the DNS record (RR).  Each operation will then be round-robined
- * across both remote hosts and local connections, ensuring that any given
- * agent talking to moray is driving load equally across all available moray
- * CPUs.
+ * This client uses the cueball module to maintain a pool of TCP connections to
+ * the IP addresses associated with a DNS name.  cueball is responsible for
+ * DNS resolution (periodically, in the background) and maintaining the
+ * appropriate TCP connections, while we maintain a small abstraction for
+ * balancing requests across connections.
  *
- * In addition, this client will periodically poll DNS looking for "dropped" or
- * added servers, and adjust the pools as apporpriate.  Note that right now this
- * is highly invasive, as the client just blatantly closes all old connections
- * and replaces with new ones, as it's assumed this is an infrequent event.
+ * The following named arguments must be specified:
  *
- * A sample invocation:
+ *     log             bunyan-style logger
+ *
+ * You must also specify either:
+ *
+ *     cueballOptions  An object containing node-cueball configuration
+ *                     parameters.  See the node-cueball documentation for
+ *                     details on what these mean.  The MorayClient supports the
+ *                     following properties:
+ *
+ *                         node-cueball Resolver properties: "domain",
+ *                         "service", "defaultPort", "resolvers",
+ *                         "maxDNSConcurrency"
+ *
+ *                         node-cueball ConnectionSet properties: "target",
+ *                         "maximum"
  *
- *         var client = moray.createClient({
- *               connectTimeout: 1000,  // default 2s
- *               dns: {
- *                       checkInterval: 2000,  // default 30s
- *                       resolvers: ['10.99.99.201'], //def  /etc/resolv.conf
- *                       timeout: 500 // default 1s
- *               },
- *               log: bunyan.createLogger({
- *                       name: 'moray_client',
- *                       level: process.env.LOG_LEVEL || 'debug',
- *                       stream: process.stdout
- *               }),
- *               maxConnections: 4, // default 10
- *               retry: {retries: 2}, // defaults 3
- *               url: process.env.MORAY_URL || 'tcp://127.0.0.1:2020'
- *       });
+ *                         properties used by both Resolver and ConnectionSet:
+ *                         "recovery"
  *
+ *                     Other cueball parameters (like "log", "resolver",
+ *                     "constructor") are supplied by the Moray client and may
+ *                     not be specified here.
+ *
+ * or some combination of legacy options documented with
+ * translateLegacyOptions() above.  It's strongly recommended that new consumers
+ * use the "cueballOptions" approach because it's much less confusing and allows
+ * specifying additional important parameters.
+ *
+ * You may also specify:
+ *
+ *     failFast         If true, this client emits "error" when the underlying
+ *                      Cueball set reaches state "failed".  This is intended
+ *                      for use by command-line tools to abort when it looks
+ *                      like dependent servers are down.  Servers should
+ *                      generally wait indefinitely for dependent services to
+ *                      come up.
+ *
+ *     unwrapErrors     If false (the default), Errors emitted by this client
+ *                      and RPC requests will contain a cause chain that
+ *                      explains precisely what happened.  For example, if an
+ *                      RPC fails with SomeError, you'll get back a
+ *                      FastRequestError (indicating a request failure) caused
+ *                      by a FastServerError (indicating that the failure was on
+ *                      the remote server, as opposed to a local or
+ *                      transport-level failure) caused by a SomeError.  In this
+ *                      mode, you should use VError.findCause(err, 'SomeError')
+ *                      to determine whether the root cause was a SomeError.
+ *
+ *                      If the "unwrapErrors" option is true, then Fast-level
+ *                      errors are unwrapped and the first non-Fast error in the
+ *                      cause chain is returned.  This is provided primarily for
+ *                      compatibility with legacy code that uses err.name to
+ *                      determine what kind of Error was returned.  New code
+ *                      should prefer VError.findCause() instead.
+ *
+ *    mustCloseBeforeNormalProcessExit
+ *
+ *                      If true, then cause the program to crash if it would
+ *                      otherwise exit 0 and this client has not been closed.
+ *                      This is useful for making sure that client consumers
+ *                      clean up after themselves.
+ *
+ * A sample invocation:
+ *
+ *     var client = moray.createClient({
+ *         'log': bunyan.createLogger({
+ *             'name': 'MorayClient',
+ *             'level': process.env.LOG_LEVEL || 'debug',
+ *             'stream': process.stdout
+ *         }),
+ *         'cueballOptions': {
+ *             'domain': 'moray.mydatacenter.joyent.us',
+ *             'maxDNSConcurrency': 3,
+ *             'defaultPort': 2020,
+ *             'target': 6,
+ *             'maximum': 15,
+ *             'recovery': {
+ *                 'default': {
+ *                     'retries': 5,
+ *                     'timeout': 2000,
+ *                     'maxTimeout': 10000,
+ *                     'delay': 1000,
+ *                     'maxDelay': 60000
+ *                 }
+ *             }
+ *         }
+ *     });
  */
 function MorayClient(options) {
+    var self = this;
+    var cueballOptions;
+    var resolver;
+
+    EventEmitter.call(this);
+
     assert.object(options, 'options');
-    assert.optionalNumber(options.checkInterval, 'options.checkInterval');
-    assert.optionalNumber(options.connectTimeout, 'options.connectTimeout');
-    assert.optionalObject(options.dns, 'options.dns');
-    options.dns = options.dns || {};
-    assert.optionalArrayOfString(options.dns.resolvers,
-                                 'options.dns.resolvers');
-    assert.optionalNumber(options.dns.timeout, 'options.dns.timeout');
-    assert.string(options.host, 'options.host');
     assert.object(options.log, 'options.log');
-    assert.optionalNumber(options.maxConnections, 'options.maxConnections');
-    assert.optionalNumber(options.maxIdleTime, 'options.maxIdleTime');
-    assert.optionalNumber(options.pingTimeout, 'options.pingTimeout');
-    assert.number(options.port, 'options.port');
-    assert.optionalObject(options.retry, 'options.retry');
+    assert.optionalBool(options.unwrapErrors, 'options.unwrapErrors');
+    assert.optionalBool(options.failFast, 'options.failFast');
+
+    /*
+     * Many of the client options determine how we configure the cueball module.
+     * For compatibility with pre-cueball clients, we accept the old options and
+     * translate them into arguments for cueball.  Modern clients may specify
+     * cueball options directly, in which case we demand that they have not
+     * specified any of these legacy options.
+     */
+    if (options.hasOwnProperty('cueballOptions')) {
+        assert.ok(!options.hasOwnProperty('host'),
+            'cannot combine "cueballOptions" with "host"');
+        assert.ok(!options.hasOwnProperty('port'),
+            'cannot combine "cueballOptions" with "port"');
+        assert.ok(!options.hasOwnProperty('connectTimeout'),
+            'cannot combine "cueballOptions" with "connectTimeout"');
+        assert.ok(!options.hasOwnProperty('dns'),
+            'cannot combine "cueballOptions" with "dns"');
+        assert.ok(!options.hasOwnProperty('maxConnections'),
+            'cannot combine "cueballOptions" with "maxConnections"');
+        assert.ok(!options.hasOwnProperty('retry'),
+            'cannot combine "cueballOptions" with "retry"');
+        assert.string(options.cueballOptions.domain,
+            'options.cueballOptions.domain');
+        cueballOptions = jsprim.deepCopy(options.cueballOptions);
+    } else {
+        cueballOptions = translateLegacyOptions(options);
+    }
 
-    var self = this;
-    EventEmitter.call(this);
+    assert.string(cueballOptions.domain, 'cueballOptions.domain');
 
-    this.connectTimeout = options.connectTimeout || 2000;
-    this.host = options.host;
+    /* Read-only metadata used for toString() and the like. */
+    this.hostLabel = cueballOptions.domain;
+    this.unwrapErrors = options.unwrapErrors ? true : false;
+    this.failFast = options.failFast ? true : false;
+
+    /* Helper objects. */
     this.log = options.log.child({
         component: 'MorayClient',
-        host: options.host,
-        port: options.port
+        domain: cueballOptions.domain
     }, true);
-    this.maxConnections = options.maxConnections || 10;
-    this.noCache = options.noCache || false;
-    this.port = options.port;
-
-    // Initialize the connection pool
-    var log = this.log;
-    var dns_opts = {
-        domain: options.host,
-        log: options.log,
-        resolvers: options.dns.resolvers,
-        retry: options.retry || {retries: 3},
-        timeout: options.dns.timeout || 1000
-    };
-    var dnsFreq = options.dns.checkInterval || 60000;
-
-    this.pool = new ConnectionPool({
-        port: this.port,
-        max: this.maxConnections,
-        connectTimeout: this.connectTimeout,
-        log: this.log,
-        retries: options.retry || {
-            maxTimeout: 10000,
-            retries: Infinity
+
+    this.log.debug(cueballOptions, 'init');
+
+    resolver = cueball.resolverForIpOrDomain({
+        'input': cueballOptions.domain + ':' + cueballOptions.defaultPort,
+        'resolverConfig': {
+            'resolvers': cueballOptions.resolvers,
+            'recovery': cueballOptions.recovery,
+            'service': cueballOptions.service,
+            'defaultPort': cueballOptions.defaultPort,
+            'maxDNSConcurrency': cueballOptions.maxDNSConcurrency,
+            'log': this.log.child({ 'component': 'CueballResolver' }, true)
         }
     });
-    this.pool.once('online', this.emit.bind(this, 'connect'));
-    this.pool.on('error', function (err) {
-        // MORAY-257: Pass errors through.  At some point, there might be
-        // certain classes of event which should be filterered out here.
-        self.emit('error', err);
-    });
-
-    this.__defineGetter__('connected', function () {
-        return (self.pool.connected);
+    if (resolver instanceof Error) {
+        throw new VError(resolver, 'invalid moray client configuration');
+    }
+    resolver.start();
+    this.cueballResolver = resolver;
+
+    this.cueball = new cueball.ConnectionSet({
+        'constructor': function cueballConstructor(backend) {
+            return (self.createFastConnection(backend));
+        },
+        'log': this.log.child({ 'component': 'CueballSet' }, true),
+        'resolver': resolver,
+        'recovery': cueballOptions.recovery,
+        'target': cueballOptions.target,
+        'maximum': cueballOptions.maximum
     });
 
-    function dnsCheck() {
-        log.debug('checking %s in DNS', dns_opts.domain);
-        dns.resolve(dns_opts, function (dns_err, ips) {
-            if (dns_err) {
-                log.error(dns_err, 'DNS lookup failed');
-            } else {
-                self.pool.setHosts(ips);
+    /* Internal state. */
+    this.nactive = 0;           /* count of outstanding RPCs */
+    this.timeConnected = null;  /* time when first cueball conn established */
+    this.ncontexts = 0;         /* counter of contexts ever created */
+    this.activeContexts = {};   /* active RPC contexts (requests) */
+    this.timeCueballInitFailed = null;   /* cueball entered "failed" */
+
+    /*
+     * State recorded when close() is invoked.  The closeState is one of:
+     *
+     *     MORAY_CS_OPEN        close() has never been invoked
+     *
+     *     MORAY_CS_CLOSING     close() has been invoked, but we have not
+     *                          finished closing (presumably because outstanding
+     *                          requests have not yet aborted)
+     *
+     *     MORAY_CS_CLOSED      close process has completed and there are no
+     *                          connections in use any more.
+     */
+    this.closeState = MORAY_CS_OPEN;    /* see above */
+    this.nactiveAtClose = null;         /* value of "nactive" at close() */
+
+    /*
+     * If requested, add a handler to ensure that the process does not exit
+     * without this client being closed.
+     */
+    if (options.mustCloseBeforeNormalProcessExit) {
+        this.onprocexit = function processExitCheck(code) {
+            if (code === 0) {
+                throw (new Error('process exiting before moray client closed'));
             }
-            self.timer = setTimeout(dnsCheck, dnsFreq);
-        });
-    }
-
-    if (!net.isIP(this.host)) {
-        dnsCheck();
+        };
+        process.on('exit', this.onprocexit);
     } else {
-        this.pool.addHost(this.host);
+        this.onprocexit = null;
     }
+
+    this.pool = new MorayConnectionPool({
+        'log': this.log,
+        'cueballResolver': this.cueballResolver,
+        'cueballSet': this.cueball
+    });
+
+    this.cueballOnStateChange = function (st) {
+        self.onCueballStateChange(st);
+    };
+
+    this.cueball.on('stateChanged', this.cueballOnStateChange);
 }
+
 util.inherits(MorayClient, EventEmitter);
 
+/*
+ * This getter is provided for historical reasons.  It's not a great interface.
+ * It's intrinsically racy (i.e., the state may change as soon as the caller has
+ * checked it), and it doesn't reflect much about the likelihood of a request
+ * succeeding.  It's tempting to simply always report "true" so that clients
+ * that might be tempted to avoid making a request when disconnected would just
+ * go ahead and try it (which will fail quickly if we are disconnected anyway).
+ * But we settle on the compromise position of reporting only whether we've
+ * _ever_ had a connection.  This accurately reflects what many clients seem
+ * interested in, which is whether we've set up yet.
+ */
+Object.defineProperty(MorayClient.prototype, 'connected', {
+    'get': function () {
+        return (this.timeConnected !== null &&
+            this.closeState == MORAY_CS_OPEN);
+    }
+});
+
+/*
+ * During startup, we wait for the state of the Cueball ConnectionSet to reach
+ * "running", at which point we emit "connect" so that callers know that they
+ * can start using this client.
+ *
+ * If "failFast" was specified in the constructor, then if the ConnectionSet
+ * reaches "failed" before "connected", then we emit an error and close the
+ * client.  See the "failFast" documentation above for details.
+ */
+MorayClient.prototype.onCueballStateChange = function onCueballStateChange(st) {
+    var err;
+
+    assert.strictEqual(this.timeConnected, null);
+    assert.strictEqual(this.timeCueballInitFailed, null);
+
+    this.log.trace({ 'newState': st }, 'cueball state change');
+
+    if (st == 'running') {
+        this.timeConnected = new Date();
+        this.cueball.removeListener('stateChanged', this.cueballOnStateChange);
+        this.log.debug('client ready');
+        this.emit('connect');
+    } else if (this.failFast && st == 'failed') {
+        this.timeCueballInitFailed = new Date();
+        this.cueball.removeListener('stateChanged', this.cueballOnStateChange);
+        err = new VError('moray client "%s": failed to establish connection',
+            this.hostLabel);
+        this.log.warn(err);
+        this.emit('error', err);
+        this.close();
+    }
+};
 
 /**
- * Shuts down all connections and closes this client down.
+ * Aborts outstanding requests, shuts down all connections, and closes this
+ * client down.
  */
 MorayClient.prototype.close = function close() {
-    clearTimeout(this.timer);
-    this.pool.once('close', this.emit.bind(this, 'close'));
-    this.pool.close();
+    var self = this;
+
+    if (this.closeState != MORAY_CS_OPEN) {
+        this.log.warn({
+            'closeState': this.closeState,
+            'nactiveAtClose': this.nactiveAtClose
+        }, 'ignoring close() after previous close()');
+        return;
+    }
+
+    if (this.onprocexit !== null) {
+        process.removeListener('exit', this.onprocexit);
+        this.onprocexit = null;
+    }
+
+    this.closeState = MORAY_CS_CLOSING;
+    this.nactiveAtClose = this.nactive;
+    this.log.info({ 'nactiveAtClose': this.nactive }, 'closing');
+
+    if (this.nactive === 0) {
+        setImmediate(function closeImmediate() { self.closeFini(); });
+        return;
+    }
+
+    /*
+     * Although we would handle sockets destroyed underneath us, the most
+     * straightforward way to clean up is to proactively terminate outstanding
+     * requests, wait for them to finish, and then stop the set.  We do this by
+     * detaching each underlying Fast client from its socket.  This should cause
+     * Fast to fail any oustanding requests, causing the RPC contexts to be
+     * released, and allowing us to proceed with closing.
+     */
+    jsprim.forEachKey(this.activeContexts, function (_, rpcctx) {
+        rpcctx.fastClient().detach();
+    });
+};
+
+MorayClient.prototype.closeFini = function closeFini() {
+    assert.equal(this.closeState, MORAY_CS_CLOSING);
+    assert.equal(this.nactive, 0);
+    assert.ok(jsprim.isEmpty(this.activeContexts));
+
+    this.cueball.stop();
+    this.cueballResolver.stop();
+    this.log.info('closed');
+    this.emit('close');
+};
+
+
+MorayClient.prototype.toString = function toString() {
+    var str = util.format('[object MorayClient<host=%s>]', this.hostLabel);
+    return (str);
+};
+
+/*
+ * Given a cueball "backend", return a Cueball-compatible Connection object.
+ * This is implemented by the separate FastConnection class.
+ */
+MorayClient.prototype.createFastConnection =
+    function createFastConnection(backend) {
+    assert.string(backend.key, 'backend.key');
+    assert.string(backend.name, 'backend.name');
+    assert.string(backend.address, 'backend.address');
+    assert.number(backend.port, 'backend.port');
+
+    return (new FastConnection({
+        'address': backend.address,
+        'port': backend.port,
+        'nRecentRequests': fastNRecentRequests,
+        'tcpKeepAliveInitialDelay': dflClientTcpKeepAliveIdle,
+        'log': this.log.child({
+            'component': 'FastClient',
+            'backendName': backend.name
+        })
+    }));
+};
+
+/*
+ * Internal functions for RPC contexts and context management
+ *
+ * Each RPC function receives as its first argument a MorayRpcContext, which is
+ * a per-request handle for accessing configuration (like "unwrapErrors") and
+ * the underlying Fast client.  When the RPC completes, the implementing
+ * function must release the MorayRpcContext.  This mechanism enables us to
+ * ensure that connections are never released twice from the same RPC, and it
+ * also affords some debuggability if connections become leaked.  Additionally,
+ * if future RPC function implementors need additional information from the
+ * Moray client (e.g., a way to tell whether the caller has tried to cancel the
+ * request), we can add additional functions to the MorayRpcContext.
+ *
+ * RPC functions use one of two patterns for obtaining and releasing RPC
+ * contexts, depending on whether they're callback-based or event-emitter-based.
+ * It's always possible for an RPC to fail because no RPC connections are
+ * available, and these two mechanisms differ in how they handle that:
+ *
+ *    (1) Callback-based RPCs (e.g., getBucket) use this pattern:
+ *
+ *          rpcctx = this.ctxCreateForCallback(usercallback);
+ *          if (rpcctx !== null) {
+ *              callback = this.makeReleaseCb(rpcctx, usercallback);
+ *              // Make the RPC call and invoke callback() upon completion.
+ *          }
+ *
+ *        If a backend connection is available, a MorayRpcContext will be
+ *        returned from ctxCreateForCallback().  These functions typically use
+ *        makeReleaseCb() to wrap the user callback they were given with one
+ *        that releases the RPC context before invoking the user callback.
+ *
+ *        If no backend connection is available, then callback() will be invoked
+ *        asynchronously with an appropriate error, and the caller should not do
+ *        anything else.
+ *
+ *    (2) Event-emitter-based RPCs (e.g., findObjects) use this pattern:
+ *
+ *          rpcctx = this.ctxCreateForEmitter();
+ *          if (rpcctx !== null) {
+ *              ee = new EventEmitter();
+ *              this.releaseWhenDone(rpcctx, ee);
+ *              // Make the RPC call and emit 'end' or 'error' upon completion.
+ *          } else {
+ *              ee = emitUnavailable();
+ *          }
+ *
+ *          return (ee);
+ *
+ *        If a backend connection is available, a MorayRpcContext will be
+ *        returned from ctxCreateForEmitter().  These functions typically use
+ *        releaseWhenDone() to release the RPC context when the event emitter
+ *        emits 'end' or 'error'.
+ *
+ *        If no backend connection is available, then the caller is responsible
+ *        for allocating and returning a new EventEmitter that will emit the
+ *        appropriate Error.
+ */
+
+/*
+ * Internal function that returns a context used for RPC operations for a
+ * callback-based RPC call.  If no backend connection is available, this
+ * function returns null and schedules an asynchronous invocation of the given
+ * callback with a suitable error.
+ *
+ * See "Internal functions for RPC contexts and context management" above.
+ */
+MorayClient.prototype.ctxCreateForCallback =
+    function ctxCreateForCallback(callback) {
+    var conn;
+
+    assert.func(callback, 'callback');
+    if (this.closeState != MORAY_CS_OPEN) {
+        setImmediate(callback, new Error('moray client has been closed'));
+        return (null);
+    }
+
+    conn = this.pool.connAlloc();
+    if (conn instanceof Error) {
+        setImmediate(callback, conn);
+        return (null);
+    }
+
+    return (this.ctxCreateCommon(conn));
+};
+
+/*
+ * Internal function that returns a context used for RPC operations for an
+ * event-emitter-based RPC call.  If no backend connection is available, this
+ * function returns null and the caller is responsible for propagating the error
+ * to its caller.
+ *
+ * See "Internal functions for RPC contexts and context management" above.
+ */
+MorayClient.prototype.ctxCreateForEmitter = function ctxCreateForEmitter() {
+    var conn;
+
+    if (this.closeState != MORAY_CS_OPEN) {
+        return (null);
+    }
+
+    conn = this.pool.connAlloc();
+    if (conn instanceof Error) {
+        /* The caller knows that this means there are no connections. */
+        return (null);
+    }
+
+    return (this.ctxCreateCommon(conn));
 };
 
+/*
+ * Internal function that creates an RPC context wrapping the given connection.
+ * We keep track of outstanding RPC contexts to provide a clean close()
+ * implementation and to aid debuggability in the event of leaks.
+ */
+MorayClient.prototype.ctxCreateCommon = function (conn) {
+    var rpcctx;
+
+    assert.object(conn);
+    assert.ok(!(conn instanceof Error));
+    assert.equal(this.closeState, MORAY_CS_OPEN);
+
+    this.nactive++;
+
+    rpcctx = new MorayRpcContext({
+        'id': this.ncontexts++,
+        'morayClient': this,
+        'connection': conn
+    });
+
+    assert.ok(!this.activeContexts.hasOwnProperty(rpcctx.mc_id));
+    this.activeContexts[rpcctx.mc_id] = rpcctx;
+    return (rpcctx);
+};
+
+/*
+ * Internal function for releasing an RPC context (that is, releasing the
+ * underlying connection).
+ */
+MorayClient.prototype.ctxRelease = function ctxRelease(rpcctx) {
+    assert.ok(this.nactive > 0);
+    this.nactive--;
+
+    assert.equal(this.activeContexts[rpcctx.mc_id], rpcctx);
+    delete (this.activeContexts[rpcctx.mc_id]);
+    this.pool.connRelease(rpcctx.mc_conn);
+
+    if (this.nactive === 0 && this.closeState == MORAY_CS_CLOSING) {
+        this.closeFini();
+    }
+};
+
+/*
+ * Given an RPC context and a user callback, return a callback that will
+ * release the underlying RPC context and then invoke the user callback with the
+ * same arguments.
+ *
+ * See "Internal functions for RPC contexts and context management" above.
+ */
+MorayClient.prototype.makeReleaseCb = function makeReleaseCb(rpcctx, cb) {
+    var self = this;
+    return (function onCallbackRpcComplete() {
+        self.ctxRelease(rpcctx);
+        cb.apply(null, arguments);
+    });
+};
+
+/*
+ * Given an RPC context and an event emitter, return a callback that will
+ * release the underlying RPC context when the event emitter emits "end" or
+ * "error".  This is the EventEmitter analog of makeReleaseCb.
+ *
+ * See "Internal functions for RPC contexts and context management" above.
+ */
+MorayClient.prototype.releaseWhenDone = function releaseOnEnd(rpcctx, emitter) {
+    var self = this;
+    var done = false;
+
+    assert.object(rpcctx);
+    assert.object(emitter);
+    assert.ok(emitter instanceof EventEmitter);
+
+    function onEmitterRpcComplete() {
+        assert.ok(!done);
+        done = true;
+        self.ctxRelease(rpcctx);
+    }
+
+    emitter.on('error', onEmitterRpcComplete);
+    emitter.on('end', onEmitterRpcComplete);
+};
+
+/*
+ * RPC implementation functions
+ *
+ * These are the primary public methods on the Moray client.  Typically, these
+ * functions normalize and validate their arguments and then delegate to an
+ * implementation in one of the nearby files.  They use one of the patterns
+ * described above under "Internal functions for RPC contexts and context
+ * management" to manage the RPC context.
+ */
 
 /**
  * Creates a Bucket
@@ -356,9 +894,10 @@ MorayClient.prototype.createBucket = function createBucket(b, cfg, opts, cb) {
         cb = opts;
         opts = {};
     }
-    var client = this.getClient(cb);
-    if (client)
-        buckets.createBucket(client, b, cfg, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        buckets.createBucket(rpcctx, b, cfg, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -376,9 +915,9 @@ MorayClient.prototype.getBucket = function getBucket(b, opts, cb) {
         cb = opts;
         opts = {};
     }
-    var client = this.getClient(cb);
-    if (client)
-        buckets.getBucket(client, b, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        buckets.getBucket(rpcctx, b, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -396,10 +935,10 @@ MorayClient.prototype.listBuckets = function listBuckets(opts, cb) {
         opts = {};
     }
 
-    var client = this.getClient(cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
 
-    if (client)
-        buckets.listBuckets(client, opts, cb);
+    if (rpcctx)
+        buckets.listBuckets(rpcctx, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -419,9 +958,10 @@ MorayClient.prototype.updateBucket = function updateBucket(b, cfg, opts, cb) {
         cb = opts;
         opts = {};
     }
-    var client = this.getClient(cb);
-    if (client)
-        buckets.updateBucket(client, b, cfg, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        buckets.updateBucket(rpcctx, b, cfg, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -443,9 +983,9 @@ MorayClient.prototype.deleteBucket = function deleteBucket(b, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        buckets.deleteBucket(client, b, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        buckets.deleteBucket(rpcctx, b, opts, this.makeReleaseCb(rpcctx, cb));
 };
 MorayClient.prototype.delBucket = MorayClient.prototype.deleteBucket;
 
@@ -472,12 +1012,11 @@ MorayClient.prototype.putBucket = function putBucket(b, cfg, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        buckets.putBucket(client, b, cfg, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        buckets.putBucket(rpcctx, b, cfg, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
-
 /**
  * Idempotently Creates or Replaces an Object.
  *
@@ -500,9 +1039,10 @@ MorayClient.prototype.putObject = function putObject(b, k, v, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.putObject(client, b, k, v, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.putObject(rpcctx, b, k, v, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -526,9 +1066,9 @@ MorayClient.prototype.getObject = function getObject(b, k, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.getObject(client, b, k, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.getObject(rpcctx, b, k, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -552,9 +1092,10 @@ MorayClient.prototype.deleteObject = function deleteObject(b, k, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.deleteObject(client, b, k, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.deleteObject(rpcctx, b, k, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 MorayClient.prototype.delObject = MorayClient.prototype.deleteObject;
 
@@ -574,9 +1115,11 @@ MorayClient.prototype.findObjects = function findObjects(b, f, opts) {
     assert.string(f, 'filter');
     assert.optionalObject(opts, 'options');
 
-    var client = this.getClient();
-    if (client) {
-        return (objects.findObjects(client, b, f, (opts || {})));
+    var rpcctx = this.ctxCreateForEmitter();
+    if (rpcctx) {
+        var rv = objects.findObjects(rpcctx, b, f, (opts || {}));
+        this.releaseWhenDone(rpcctx, rv);
+        return (rv);
     }
     return (emitUnavailable());
 };
@@ -601,9 +1144,9 @@ MorayClient.prototype.batch = function batch(requests, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.batch(client, requests, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.batch(rpcctx, requests, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -629,9 +1172,10 @@ MorayClient.prototype.updateObjects = function update(b, f, f2, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.updateObjects(client, b, f, f2, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.updateObjects(rpcctx, b, f, f2, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -655,9 +1199,9 @@ MorayClient.prototype.deleteMany = function deleteMany(b, f, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.deleteMany(client, b, f, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.deleteMany(rpcctx, b, f, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -682,9 +1226,10 @@ MorayClient.prototype.reindexObjects = function reindexObjects(b, c, opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        objects.reindexObjects(client, b, c, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        objects.reindexObjects(rpcctx, b, c, opts,
+            this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -704,9 +1249,9 @@ MorayClient.prototype.getTokens = function getTokens(opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        tokens.getTokens(client, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        tokens.getTokens(rpcctx, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 
@@ -731,26 +1276,21 @@ MorayClient.prototype.ping = function _ping(opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        ping(client, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        meta.ping(rpcctx, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
 /**
  * Query the API version of the server.
  *
- * As the Moray server develops features, it may be necessary to differentiate
- * between instance which do or do not possess updated functionality.  This
- * queries the version, if present, from the server.  If the version is not
- * present, or an error occurs, MorayClient defaults to the minimum possible
- * version of 1.
- *
- * The callback is invoked with the version as the first and  only parameter.
+ * Do not use this function except for reporting version numbers to humans.  See
+ * the comment in meta.versionInternal().
  *
  * @param {Object} opts   - request parameters
  * @param {Function} cb   - callback
  */
-MorayClient.prototype.version = function _version(opts, cb) {
+MorayClient.prototype.versionInternal = function _version(opts, cb) {
     if (typeof (opts) === 'function') {
         cb = opts;
         opts = {};
@@ -758,16 +1298,15 @@ MorayClient.prototype.version = function _version(opts, cb) {
     assert.object(opts, 'options');
     assert.func(cb, 'callback');
 
-    var client = this.getClient(cb);
-    if (client)
-        version(client, opts, cb);
+    var rpcctx = this.ctxCreateForCallback(cb);
+    if (rpcctx)
+        meta.versionInternal(rpcctx, opts, this.makeReleaseCb(rpcctx, cb));
 };
 
-
 /**
  * Performs a raw SQL operation against the server.
  *
- * For the love of all this good in this earth, please only use this method
+ * For the love of all that is good in this earth, please only use this method
  * at the utmost of need.  In almost every case this is used, it's used for
  * nefarious reasons.
  *
@@ -781,6 +1320,8 @@ MorayClient.prototype.version = function _version(opts, cb) {
  * @return {EventEmitter} - listen for 'record', 'end' and 'error'
  */
 MorayClient.prototype.sql = function _sql(stmt, vals, opts) {
+    var rv;
+
     switch (arguments.length) {
     case 0:
         throw new TypeError('statement (String) required');
@@ -808,95 +1349,79 @@ MorayClient.prototype.sql = function _sql(stmt, vals, opts) {
         throw new Error('too many arguments');
     }
 
-    var client = this.getClient();
-    if (client) {
-        return (sql(client, stmt, vals, opts));
+    var rpcctx = this.ctxCreateForEmitter();
+    if (rpcctx) {
+        rv = meta.sql(rpcctx, stmt, vals, opts);
+        this.releaseWhenDone(rpcctx, rv);
+        return (rv);
     }
     return (emitUnavailable());
 };
 
 
-MorayClient.prototype.toString = function toString() {
-    var str = sprintf('[object MorayClient<host=%s>]', this.host);
-    return (str);
-};
+/*
+ * A MorayRpcContext is a per-request handle that refers back to the Moray
+ * client and the underlying connection.  This object is provided to RPC
+ * implementors, and allows them to access the underlying Fast client (in order
+ * to make RPC requests), configuration (like "unwrapErrors"), and to release
+ * the RPC context when the RPC completes.
+ *
+ * This class should be thought of as part of the implementation of the Moray
+ * client itself, having internal implementation knowledge of the client.
+ */
+function MorayRpcContext(args) {
+    assert.object(args, 'args');
+    assert.number(args.id, 'args.id');
+    assert.object(args.connection, 'args.connection');
+    assert.object(args.morayClient, 'args.morayClient');
+
+    /*
+     * There's no mechanism in place to stop us from reaching this limit, but
+     * even at one million requests per second, we won't hit it until the client
+     * has been running for over 142 years.
+     */
+    assert.ok(args.id >= 0 && args.id < Math.pow(2, 53));
+
+    this.mc_id = args.id;
+    this.mc_conn = args.connection;
+    this.mc_moray = args.morayClient;
+}
 
+MorayRpcContext.prototype.fastClient = function fastClient() {
+    return (this.mc_conn.connection().fastClient());
+};
 
-// A little bit goofy, as this takes an optional callback which will
-// automatically return from callers (this is really an internal)
-// function - if the API takes no callback then the behavior is to
-// emit an error
-MorayClient.prototype.getClient = function getClient(callback) {
-    assert.optionalFunc(callback, 'callback');
+MorayRpcContext.prototype.socketAddrs = function socketAddrs() {
+    return (this.mc_conn.connection().socketAddrs());
+};
 
-    var cb = once(function _cb(err) {
-        if (callback) {
-            callback(err);
-        }
-    });
+MorayRpcContext.prototype.unwrapErrors = function unwrapErrors() {
+    assert.bool(this.mc_moray.unwrapErrors);
+    return (this.mc_moray.unwrapErrors);
+};
 
-    var client = this.pool.next();
+MorayRpcContext.prototype.createLog = function createLog(options) {
+    var reqid;
+    assert.optionalObject(options, 'options');
 
-    if (!client) {
-        cb(new Error('no active connections'));
+    if (options && options.req_id) {
+        reqid = options.req_id;
+    } else {
+        reqid = libuuid.create();
     }
 
-    // If we're here, we'll just return a dead client and let the top
-    // emit error
-    return (client);
+    return (this.mc_moray.log.child({ 'req_id': reqid }, true));
 };
 
 
-
 ///--- Exports
 
+/*
+ * Expose translateLegacyOptions privately for testing, not for the outside
+ * world.
+ */
+MorayClient.privateTranslateLegacyOptions = translateLegacyOptions;
+
 module.exports = {
     Client: MorayClient
 };
-
-
-
-
-
-
-// ///--- Tests
-
-// (function runTest() {
-//         var bunyan = require('bunyan');
-
-//         var log = bunyan.createLogger({
-//                 name: 'moray_test',
-//                 stream: process.stdout,
-//                 level: process.env.LOG_LEVEL || 'debug',
-//                 serializers: bunyan.stdSerializers
-//         });
-
-//         var client = new MorayClient({
-//                 checkInterval: 10 * 1000,
-//                 connectTimeout: 4000,
-//                 host: '1.moray.bh1.joyent.us',
-//                 port: 2020,
-//                 log: log,
-//                 maxConnections: 10,
-//                 maxIdleTime: 600 * 1000,
-//                 pingTimeout: 4000
-//         });
-
-//         function onConnect() {
-//                 client.once('close', function () {
-//                         log.info('runTest: client closed');
-//                 });
-
-//                 client.once('error', function (err) {
-//                         log.error(err, 'runTest: error encountered');
-//                 });
-
-//                 client.once('connect', function () {
-//                         log.info('runTest: reconnected');
-//                 });
-
-//                 console.log('go stop haproxy in the moray zone...');
-//         }
-
-//         client.once('connect', onConnect);
-// })();
diff --git a/lib/connection_pool.js b/lib/connection_pool.js
deleted file mode 100644
index bfcd814..0000000
--- a/lib/connection_pool.js
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-var assert = require('assert-plus');
-var once = require('once');
-var fast = require('fast');
-
-
-var Ring = require('./ring');
-
-///--- Helpers
-
-function leastRequestsPriority(conn) {
-    return (conn.countPending);
-}
-
-///--- API
-
-function ConnectionPool(opts) {
-    EventEmitter.call(this);
-    assert.object(opts, 'opts');
-    assert.number(opts.connectTimeout, 'opts.connectTimeout');
-    assert.number(opts.max);
-    assert.object(opts.log);
-
-    this.log = opts.log;
-    this.port = opts.port;
-    this.max = opts.max;
-    this.connectTimeout = opts.connectTimeout;
-    if (typeof (opts.retries) === 'number') {
-        this.retry = {
-            minTimeout: 1000,
-            maxTimeout: 10000,
-            retries: opts.retries
-        };
-    } else {
-        this.retry = opts.retries || { retries: Infinity };
-    }
-
-    this.ring = new Ring();
-    var self = this;
-    var forwardEvents = ['online', 'offline', 'activate', 'deactivate'];
-    forwardEvents.forEach(function (event) {
-        self.ring.on(event, self.emit.bind(self, event));
-    });
-
-    this.__defineGetter__('connected', function () {
-        return (self.ring.active.length !== 0);
-    });
-}
-util.inherits(ConnectionPool, EventEmitter);
-module.exports = ConnectionPool;
-
-ConnectionPool.prototype.setHosts = function setHosts(ipAddrs) {
-    assert.arrayOfString(ipAddrs);
-
-    var self = this;
-    var current = this.ring.members;
-    var remove = current.filter(function (addr) {
-        return (ipAddrs.indexOf(addr) === -1);
-    });
-    var add = ipAddrs.filter(function (addr) {
-        return (current.indexOf(addr) === -1);
-    });
-
-    remove.forEach(function (addr) {
-        self.removeHost(addr);
-    });
-    add.forEach(function (addr) {
-        self.addHost(addr);
-    });
-};
-
-ConnectionPool.prototype.addHost = function addHost(host) {
-    if (this.closed) {
-        return;
-    }
-
-    var self = this;
-    var cRing = new Ring({
-        priorityFunc: leastRequestsPriority
-    });
-    this.ring.add(host, cRing);
-    cRing.on('online', function () {
-        self.log.debug({host: host}, 'host online');
-        self.ring.activate(host);
-    });
-    cRing.on('offline', function () {
-        self.log.debug({host: host}, 'host offline');
-        self.ring.deactivate(host);
-    });
-
-    // setup ring of connections
-    for (var i = 0; i < this.max; i++) {
-        var key = '' + i;
-        // FIXME: tune defaults
-        var client = fast.createClient({
-            host: host,
-            port: this.port,
-            connectTimeout: this.connectTimeout,
-            retry: this.retry,
-            reconnect: true
-        });
-        client.log = this.log.child({
-            fastClient: host + '-' + i
-        });
-
-        cRing.add(key, client);
-        client.on('connect', cRing.activate.bind(cRing, key));
-        client.on('close', cRing.deactivate.bind(cRing, key));
-        client.on('error', this.emit.bind(this, 'error'));
-    }
-};
-
-ConnectionPool.prototype.removeHost = function removeHost(host) {
-    var cRing = this.ring.get(host);
-
-    // silence events during teardown
-    this.ring.deactivate(host, true);
-    cRing.removeAllListeners();
-
-    this.ring.remove(host);
-    cRing.members.forEach(function (key) {
-        var client = cRing.get(key);
-        client.close();
-    });
-};
-
-ConnectionPool.prototype.next = function next() {
-    var client = null;
-    var cRing = this.ring.next();
-    if (cRing) {
-        client = cRing.next();
-    }
-    return (client);
-};
-
-ConnectionPool.prototype.close = function close() {
-    var self = this;
-    if (!this.closed) {
-        this.closed = true;
-        this.ring.members.forEach(function (host) {
-            self.removeHost(host);
-        });
-        this.emit('close');
-    }
-};
diff --git a/lib/dns.js b/lib/dns.js
deleted file mode 100644
index 031e768..0000000
--- a/lib/dns.js
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var backoff = require('backoff');
-var dns = require('dns');
-var _dns = require('native-dns');
-var once = require('once');
-
-
-
-///--- API
-
-function resolve(opts, callback) {
-    assert.object(opts, 'options');
-    assert.string(opts.domain, 'options.domain');
-    assert.object(opts.log, 'options.log');
-    assert.optionalArrayOfString(opts.resolvers, 'options.resolvers');
-    assert.number(opts.timeout, 'options.timeout');
-    assert.func(callback, 'callback');
-
-    callback = once(callback);
-
-    var custom = false;
-    var log = opts.log.child({domain: opts.domain}, true);
-    var resolvers;
-
-    if (opts.resolvers) {
-        custom = true;
-        resolvers = opts.resolvers.map(function (r) {
-            return ({
-                address: r,
-                port: 53,
-                type: 'udp'
-            });
-        });
-    } else {
-        resolvers = _dns.platform.name_servers;
-    }
-
-    var _r = -1;
-
-    resolvers.next = function () {
-        if (++_r >= resolvers.length)
-            _r = 0;
-
-        return (resolvers[_r]);
-    };
-
-    function _resolve(_, cb) {
-        cb = once(cb);
-
-
-        if (custom) {
-            var answers = [];
-            var req = _dns.Request({
-                question: _dns.Question({
-                    name: opts.domain,
-                    type: 'A'
-                }),
-                server: resolvers.next(),
-                timeout: opts.timeout,
-                cache: false
-            });
-
-            req.on('end', function onDNSDone() {
-                if (answers.length === 0) {
-                    log.debug({
-                        server: req.server.address
-                    }, 'dns: empty result set');
-                    cb(new Error(opts.domain + ' not in DNS'));
-                    return;
-                }
-                cb(null, answers);
-            });
-
-            req.on('message', function onDNSMessage(err, answer) {
-                if (err) {
-                    log.debug({
-                        err: err,
-                        server: req.server.address,
-                        timeout: req.timeout
-                    }, 'dns message error');
-                    cb(err);
-                    return;
-                }
-                answer.answer.forEach(function (a) {
-                    answers.push(a.address);
-                });
-            });
-
-            req.once('error', function (err) {
-                log.debug({
-                    err: err,
-                    server: req.server.address,
-                    timeout: req.timeout
-                }, 'dns request error');
-                cb(err);
-            });
-
-            req.once('timeout', function () {
-                log.debug({
-                    server: req.server.address,
-                    timeout: req.timeout
-                }, 'dns resolution timeout');
-                cb(new Error('DNS Timeout'));
-            });
-
-            req.send();
-        } else {
-            dns.resolve(opts.domain, 'A', cb);
-        }
-    }
-
-    function run() {
-        var retry = backoff.call(_resolve, {}, function (err, answers) {
-            retry.removeAllListeners('backoff');
-            log.debug('resolve %s done after %d attempts',
-                      opts.domain, retry.getNumRetries() + 1);
-            callback(err, answers);
-        });
-        retry.setStrategy(new backoff.ExponentialStrategy({
-            initialDelay: 10,
-            maxDelay: 10000
-        }));
-        retry.failAfter(opts.retries || Infinity);
-        retry.on('backoff', function onBackoff(number, delay) {
-            var level;
-            if (number === 0) {
-                level = 'info';
-            } else if (number < 5) {
-                level = 'warn';
-            } else {
-                level = 'error';
-            }
-            log[level]({
-                attempt: number,
-                delay: delay
-            }, 'dns: resolve attempted');
-        });
-        retry.start();
-    }
-
-    if (resolvers.length > 0) {
-        run();
-    } else {
-        _dns.platform.once('ready', run);
-    }
-}
-
-
-
-///--- Exports
-
-module.exports = {
-    resolve: resolve
-};
diff --git a/lib/fast_connection.js b/lib/fast_connection.js
new file mode 100644
index 0000000..55f2068
--- /dev/null
+++ b/lib/fast_connection.js
@@ -0,0 +1,215 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_connection.js: implementation of the Cueball's "Connection"
+ * interface backed by a Fast client.
+ */
+
+var assert = require('assert-plus');
+var events = require('events');
+var fast = require('fast');
+var net = require('net');
+var util = require('util');
+var VError = require('verror');
+
+module.exports = FastConnection;
+
+/*
+ * Named arguments:
+ *
+ *     address                  IPv4 or IPv6 address, interpreted by
+ *     (string)                 net.createConnection().
+ *
+ *     port                     TCP port, used for net.createConnection().
+ *     (number)
+ *
+ *     log                      bunyan-style logger
+ *     (object)
+ *
+ *     nRecentRequests          see FastClient constructor
+ *     (number)
+ *
+ *     tcpKeepAliveInitialDelay initial TCP keep-alive delay (in milliseconds)
+ *     (number)
+ */
+function FastConnection(args) {
+    assert.object(args, 'args');
+    assert.string(args.address, 'args.address');
+    assert.number(args.port, 'args.port');
+    assert.object(args.log, 'args.log');
+    assert.number(args.nRecentRequests, 'args.nRecentRequests');
+    assert.number(args.tcpKeepAliveInitialDelay,
+        'args.tcpKeepAliveInitialDelay');
+
+    events.EventEmitter.call(this);
+
+    /* Arguments */
+    this.fc_connect_address = args.address;
+    this.fc_connect_port = args.port;
+    this.fc_tcpka_delay = args.tcpKeepAliveInitialDelay;
+
+    /* Socket and client state */
+    this.fc_sock = net.createConnection(args.port, args.address);
+    this.fc_destroyed = false;
+    this.fc_fast = new fast.FastClient({
+        'nRecentRequests': args.nRecentRequests,
+        'transport': this.fc_sock,
+        'log': args.log
+    });
+
+    /* List of all errors observed. */
+    this.fc_all_errors = [];
+
+    /*
+     * Socket addresses, populated after "connect".  These are only for logging
+     * and debugging.
+     */
+    this.fc_sockaddr_remote = null;
+    this.fc_sockaddr_remote_label = null;
+    this.fc_sockaddr_local = null;
+    this.fc_sockaddr_local_label = null;
+
+    this.fc_sock.on('close', this.emit.bind(this, 'close'));
+    this.fc_sock.on('connect', this.onSocketConnect.bind(this));
+    this.fc_sock.on('error', this.onSocketError.bind(this));
+    this.fc_fast.on('error', this.onFastError.bind(this));
+}
+
+util.inherits(FastConnection, events.EventEmitter);
+
+/* [private] */
+FastConnection.prototype.onSocketConnect = function onSocketConnect() {
+    /*
+     * It's important to enable TCP KeepAlive on connections to the Moray server
+     * so that we can identify connections that have failed as a result of a
+     * remote system panic, power cycle, power off, or a network partition.
+     * This will not address requests that have hung as a result of a server
+     * problem; callers are expected to deal with that on their own.  This
+     * client can't necessarily know what timeouts are reasonable, nor the scope
+     * of such a problem, nor how to deal with a request that's taking too long.
+     *
+     * Node provides an API for enabling TCP KeepAlive and setting the initial
+     * interval, but it has two major issues: first, on at least Node v0.10 and
+     * likely v0.12, it only works once the socket has been connected.  Before
+     * that, the request to enable KeepAlive is silently ignored.  For details,
+     * see nodejs/node-v0.x-archive issue 8572.  That's why we don't call
+     * setKeepAlive() until we get here.
+     *
+     * Second, the interface only allows us to configure the initial interval of
+     * idle time before TCP starts sending KeepAlive probes (equivalent to
+     * TCP_KEEPIDLE), not how long to keep sending probes before terminating the
+     * connection (TCP_KEEPCNT and TCP_KEEPINTVL or
+     * TCP_KEEPALIVE_ABORT_THRESHOLD).  Since Moray is only used inside
+     * environments expected to have good network connectivity, an aggressive
+     * configuration would be appropriate here, but for now we're left with the
+     * system defaults (which are pretty conservative).  We'll eventually learn
+     * if this connection fails, but not all that quickly.
+     */
+    this.fc_sock.setKeepAlive(true, this.fc_tcpka_delay);
+
+    /*
+     * Record the local and remote addresses, primarily for debugging, but also
+     * so we can incorporate these into error messages.
+     */
+    this.fc_sockaddr_remote = {
+        'address': this.fc_sock.remoteAddress,
+        'port': this.fc_sock.remotePort
+    };
+    this.fc_sockaddr_local = {
+        'address': this.fc_sock.localAddress,
+        'port': this.fc_sock.localPort
+    };
+    this.fc_sockaddr_remote_label =
+        this.fc_sock.remoteAddress + ':' + this.fc_sock.remotePort;
+    this.fc_sockaddr_local_label =
+        this.fc_sock.localAddress + ':' + this.fc_sock.localPort;
+
+    /* Cueball requires that we pass this event through. */
+    this.emit('connect');
+};
+
+/* [private] */
+FastConnection.prototype.onSocketError = function onSocketError(err) {
+    assert.ok(err instanceof Error);
+    this.onError(new VError({
+        'cause': err,
+        'info': {
+            'ipAddr': this.fc_connect_address,
+            'tcpPort': this.fc_connect_port
+        }
+    }, 'socket to %s:%d', this.fc_connect_address, this.fc_connect_port));
+};
+
+/* [private] */
+FastConnection.prototype.onFastError = function onFastError(err) {
+    assert.ok(err instanceof Error);
+    this.onError(new VError({
+        'cause': err,
+        'info': {
+            'ipAddr': this.fc_connect_address,
+            'tcpPort': this.fc_connect_port
+        }
+    }, 'fast client for %s:%d', this.fc_connect_address, this.fc_connect_port));
+};
+
+/* [private] */
+FastConnection.prototype.onError = function onError(err) {
+    assert.ok(err instanceof Error);
+
+    /*
+     * It's possible for either or both of the socket and the Fast client to
+     * emit an error.  We only pass through the first one, but we record all of
+     * them for debugging.
+     *
+     * It's not that clear, but Node seems to ensure that 'error' is not emitted
+     * after destroy().  Cueball appears to assume this, so we avoid it, too.
+     */
+    this.fc_all_errors.push(err);
+    if (!this.fc_destroyed && this.fc_all_errors.length == 1) {
+        this.emit('error', err);
+    }
+};
+
+/*
+ * Used by the rest of the Moray client
+ */
+FastConnection.prototype.fastClient = function () {
+    return (this.fc_fast);
+};
+
+/*
+ * Implementation of the Cueball "Connection" interface
+ */
+
+FastConnection.prototype.destroy = function () {
+    this.fc_destroyed = true;
+    this.fc_sock.destroy();
+};
+
+/*
+ * Cueball requires that we implement ref() and unref(), but they don't need to
+ * do anything.  These interfaces are usually used to allow callers to avoid
+ * having to explicit close client connections or connection pools (allowing a
+ * Node program to exit if that's all that's left).  We don't allow that here.
+ */
+FastConnection.prototype.ref = function ref() {};
+FastConnection.prototype.unref = function unref() {};
+
+/*
+ * Returns an object describing the local and remote IP address and port.  This
+ * is intended only for reporting, not to be parsed or interpreted.
+ */
+FastConnection.prototype.socketAddrs = function socketAddrs() {
+    return ({
+        'local': this.fc_sockaddr_local_label,
+        'remote': this.fc_sockaddr_remote_label
+    });
+};
diff --git a/lib/index.js b/lib/index.js
index 132da46..c31aa5c 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,35 +5,21 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
-var url = require('url');
-
-var assert = require('assert-plus');
+/*
+ * lib/index.js: public exports from the node-moray module.
+ */
 
 var Client = require('./client').Client;
-var clone = require('./utils').clone;
-
 
 
 ///-- API
 
 module.exports = {
     Client: Client,
-
     createClient: function createClient(options) {
-        assert.object(options, 'options');
-
-        var opts = clone(options);
-        opts.log = options.log;
-        if (opts.url && !opts.host) {
-            var _u = url.parse(opts.url);
-            opts.host = _u.hostname;
-            opts.port = parseInt(opts.port || _u.port || 2020, 10);
-            delete opts.url;
-        }
-
-        return (new Client(opts));
+        return (new Client(options));
     }
 };
diff --git a/lib/meta.js b/lib/meta.js
new file mode 100644
index 0000000..a6c887d
--- /dev/null
+++ b/lib/meta.js
@@ -0,0 +1,187 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/meta.js: non-data-related client API functions.  These functions are
+ * invoked by same-named methods in lib/client.js to do the bulk of the work
+ * associated with making RPC requests.  The arguments and semantics of these
+ * functions are documented in the Moray API.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var jsprim = require('jsprim');
+var events = require('events');
+var VError = require('verror');
+
+var rpc = require('./rpc');
+
+
+///--- API
+
+function ping(rpcctx, options, callback) {
+    var opts, log;
+
+    assert.object(rpcctx, 'rpcctx');
+    assert.object(options, 'options');
+    assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.func(callback, 'callback');
+
+    opts = {
+        deep: options.deep || false,
+        req_id: options.req_id || libuuid.create()
+    };
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonNoData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'ping',
+        'rpcargs': [ opts ],
+        'log': log,
+        'timeout': options.hasOwnProperty('timeout') ? options.timeout : 1000
+    }, callback);
+}
+
+/*
+ * This function invokes the "version" RPC on the remote server.  This should
+ * not be used for any purpose except reporting the version to a human.
+ *
+ * It's tempting to use the reported version to determine whether the remote
+ * server has some capabilities you need, but you MUST NOT do this.  First of
+ * all, this client is backed by a pool of sockets, and the servers at the
+ * remote ends of those sockets may be at different versions.  You could get
+ * back "version 2" from this RPC, make another request that assumes version 2,
+ * and have that fail because it contacted a version 1 server.  Note that this
+ * is true even if this client is only connected to version 2 servers.
+ * Operators may rollback Moray instances to earlier versions, so even in a
+ * single-Moray deployment, you cannot assume that just because you got back
+ * version N from this RPC that a subsequent request will not be serviced by a
+ * version M server where M < N.
+ *
+ * By this point, it should be clear that the result of this RPC cannot be used
+ * to make programmatic decisions.  It would be tempting to remove it
+ * altogether so that people don't accidentally build dependencies on it (which
+ * has happened in the past).  Instead, we give it a different name so that
+ * people won't stumble upon it accidentally, but we can still build
+ * command-line tools that report it.
+ *
+ * You might reasonably wonder: what do I do if I *do* depend on a newer Moray
+ * version?  In that case, we'll need to rework the MorayClient abstraction so
+ * that you can specify that all requests for this client should be made to
+ * version-N servers.  The client will have to determine server version and keep
+ * track of it.  None of this work has been done yet.  The minimum server
+ * version supported by this client is 2, which is the current version.
+ */
+function versionInternal(rpcctx, options, callback) {
+    var timeout, opts, log;
+
+    assert.object(rpcctx, 'rpcctx');
+    assert.object(options, 'options');
+    assert.func(callback, 'callback');
+
+    /*
+     * As mentioned above, servers that do not support this RPC will never
+     * respond to it.  To provide behavior that's at least remotely sane, we
+     * apply a generous timeout for this RPC.  However, in the event of timeout,
+     * we will not conclude that the remote server is old.  We'll leave that for
+     * callers to deal with.  See the notes above for details.
+     */
+    timeout = typeof (options.timeout) == 'number' ?
+        options.timeout : 20000;
+    opts = { req_id: options.req_id || libuuid.create() };
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'version',
+        'rpcargs': [ opts ],
+        'timeout': timeout,
+        'log': log
+    }, function (err, versions) {
+        if (err) {
+            /*
+             * As described in detail above, there's a decent chance that a
+             * timeout actually means the remote server is old.  This is
+             * decidedly not obvious, so it's useful if we can augment the error
+             * with a note about this possibility -- without actually concluding
+             * that that's what happened, since we don't really know.
+             */
+            if (VError.findCauseByName(err, 'TimeoutError')) {
+                err.message += ' (note: very old Moray versions do not ' +
+                    'respond to this RPC)';
+            }
+        } else {
+            if (versions.length != 1) {
+                err = new VError('bad server response: expected 1 version, ' +
+                    'but found %d', versions.length);
+            } else if ((typeof (versions[0]) != 'object' ||
+                versions[0] === null ||
+                typeof (versions[0].version) != 'number')) {
+                err = new VError(
+                    'bad server response: unable to parse version');
+            }
+        }
+
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, versions[0].version);
+        }
+    });
+}
+
+function sql(rpcctx, statement, values, options) {
+    var opts, log, req, res;
+
+    assert.object(rpcctx, 'rpcctx');
+    assert.string(statement, 'statement');
+    assert.ok(Array.isArray(values));
+    assert.object(options, 'options');
+
+    opts = { req_id: options.req_id || libuuid.create() };
+    log = rpc.childLogger(rpcctx, opts);
+    res = new events.EventEmitter();
+
+    /*
+     * We specify ignoreNullValues because electric-moray sends spurious
+     * trailing null values from successful sql() commands.  These are not
+     * generally allowed, but we have to maintain compatibility with broken
+     * servers.
+     */
+    req = rpc.rpcCommon({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'sql',
+        'rpcargs': [ statement, values, opts ],
+        'ignoreNullValues': true,
+        'log': log
+    }, function (err) {
+        if (err) {
+            res.emit('error', err);
+        } else {
+            res.emit('end');
+        }
+    });
+
+    req.on('data', function (msg) {
+        if (msg !== null) {
+            log.debug('sql: msg: %j', msg);
+            res.emit('record', msg);
+        }
+    });
+
+    return (res);
+}
+
+
+///--- Exports
+
+module.exports = {
+    ping: ping,
+    sql: sql,
+    versionInternal: versionInternal
+};
diff --git a/lib/objects.js b/lib/objects.js
index de892b5..f4029c4 100644
--- a/lib/objects.js
+++ b/lib/objects.js
@@ -5,214 +5,154 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/objects.js: object-related client API functions.  These functions are
+ * invoked by same-named methods in lib/client.js to do the bulk of the work
+ * associated with making RPC requests.  The arguments and semantics of these
+ * functions are documented in the Moray API.
  */
 
 var EventEmitter = require('events').EventEmitter;
 
 var assert = require('assert-plus');
+var jsprim = require('jsprim');
 var libuuid = require('libuuid');
-var once = require('once');
-var clone = require('clone');
-
-var utils = require('./utils');
-
-
-
-///--- Helpers
-
-function copyConfig(config) {
-    var cfg = utils.clone(config);
-
-    cfg.pre = (config.pre || []).map(function (f) {
-        return (f.toString());
-    });
-    cfg.post = (config.post || []).map(function (f) {
-        return (f.toString());
-    });
-
-    return (cfg);
-}
-
-
-function copyOptions(options, value) {
-    var opts = clone(options);
-
-    // Defaults handlers
-    opts.req_id = options.req_id || libuuid.create();
-    opts.etag = (options.etag !== undefined) ? options.etag : options._etag;
-    opts.headers = options.headers || {};
-    opts.no_count = options.no_count || false;
-    opts.sql_only = options.sql_only || false;
-    opts.noCache = true;
-
-    // Including the stringified value is redundant, but older versions of
-    // moray depend upon the _value field being populated in this way.
-    if (value)
-        opts._value = JSON.stringify(value);
-
-    if (typeof (options.noCache) !== 'undefined')
-        opts.noCache = options.noCache;
-
-    return (opts);
-}
+var VError = require('verror');
 
+var rpc = require('./rpc');
 
 
 ///--- API
-// All of the functions here are scoped to the file as they require an
-// underlying 'fast' connection to be given to them.  The functions on
-// the moray prototype are just passthroughs to all these
 
-function putObject(client, bucket, key, value, options, callback) {
-    assert.object(client, 'client');
+function putObject(rpcctx, bucket, key, value, options, callback) {
+    var opts, log;
+
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.string(key, 'key');
     assert.object(value, 'value');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options, value);
-    var log = utils.childLogger(client, opts);
-    var meta;
-    var req = client.rpc('putObject', bucket, key, value, opts);
-
-    log.debug({
-        bucket: bucket,
-        key: key,
-        value: value,
-        etag: opts.etag
-    }, 'putObject: entered');
-
-    req.once('message', function (msg) {
-        meta = msg;
-    });
-
-    req.once('end', function () {
-        log.debug('putObject: done');
-        callback(null, meta || {});
-    });
+    opts = makeOptions(options, value);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'putObject',
+        'rpcargs': [ bucket, key, value, opts ]
+    }, function (err, data) {
+        if (!err && data.length > 1) {
+            err = new VError('expected at most 1 data message, found %d',
+                data.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'putObject: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data.length === 0 ? {} : data[0]);
+        }
     });
 }
 
+function getObject(rpcctx, bucket, key, options, callback) {
+    var opts, log;
 
-function getObject(client, bucket, key, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.string(key, 'key');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var obj;
-    var req = client.rpc('getObject', bucket, key, opts);
-
-    log.debug({
-        bucket: bucket,
-        key: key
-    }, 'getObject: entered');
-
-    req.once('message', function (msg) {
-        obj = msg;
-    });
-
-    req.once('end', function () {
-        log.debug({
-            object: obj
-        }, 'getObject: done');
-        callback(null, obj);
-    });
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'getObject',
+        'rpcargs': [ bucket, key, opts ]
+    }, function (err, data) {
+        if (!err && data.length != 1) {
+            err = new VError('expected exactly 1 data message, found %d',
+                data.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'getObject: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data[0]);
+        }
     });
 }
 
+function deleteObject(rpcctx, bucket, key, options, callback) {
+    var opts, log;
 
-function deleteObject(client, bucket, key, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.string(key, 'key');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('delObject', bucket, key, opts);
-
-    log.debug({
-        bucket: bucket,
-        key: key,
-        etag: opts.etag
-    }, 'deleteObject: entered');
-
-    var cb = utils.simpleCallback({
-        callback: callback,
-        log: log,
-        name: 'deleteObject',
-        request: req
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+
+    /*
+     * electric-moray sends trailing null values with this response.  These are
+     * not normally allowed unless we specify ignoreNullValues.
+     */
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'ignoreNullValues': true,
+        'rpcmethod': 'delObject',
+        'rpcargs': [ bucket, key, opts ]
+    }, function (err, data) {
+        /*
+         * The server provides data in a response, but historically this client
+         * ignores it.
+         */
+        callback(err);
     });
-
-    req.once('end', cb);
-    req.once('error', cb);
 }
 
+function findObjects(rpcctx, bucket, filter, options) {
+    var opts, log, req, res;
 
-function findObjects(client, bucket, filter, options) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.string(filter, 'filter');
     assert.object(options, 'options');
 
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('findObjects', bucket, filter, opts);
-    var res = new EventEmitter();
-
-    log.debug({
-        bucket: bucket,
-        filter: filter,
-        options: opts
-    }, 'findObjects: entered');
-    req.on('message', function onObject(msg) {
-        log.debug({
-            object: msg
-        }, 'findObjects: record found');
-        res.emit('record', msg);
-    });
-
-    req.once('end', function () {
-        log.debug('findObjects: done');
-        res.removeAllListeners('record');
-        res.removeAllListeners('error');
-        res.emit('end');
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    res = new EventEmitter();
+    req = rpc.rpcCommon({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'findObjects',
+        'rpcargs': [ bucket, filter, opts ]
+    }, function (err) {
+        if (err) {
+            res.emit('error', err);
+        } else {
+            res.emit('end');
+        }
     });
 
-    req.once('error', function (err) {
-        log.debug(err, 'findObjects: failed');
-        res.removeAllListeners('record');
-        res.removeAllListeners('end');
-        res.emit('error', err);
+    req.on('data', function onObject(msg) {
+        log.debug({ object: msg }, 'findObjects: record found');
+        res.emit('record', msg);
     });
 
     return (res);
 }
 
-
-function batch(client, requests, options, callback) {
-    assert.object(client, 'client');
+function batch(rpcctx, requests, options, callback) {
+    assert.object(rpcctx, 'rpcctx');
     assert.arrayOfObject(requests, 'requests');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
@@ -250,145 +190,150 @@ function batch(client, requests, options, callback) {
 
             r = (r.options || {}).headers;
             assert.optionalObject(r, _s + '.options.headers');
-
         }
-
     }
 
-    callback = once(callback);
-
-    var meta;
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('batch', requests, opts);
-
-    log.debug({
-        requests: requests
-    }, 'batch: entered');
-
-    req.once('message', function (msg) {
-        meta = msg;
-    });
-
-    req.once('end', function () {
-        log.debug('batch: done');
-        callback(null, meta || {});
-    });
+    var opts, log;
+
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'batch',
+        'rpcargs': [ requests, opts ]
+    }, function (err, data) {
+        if (!err && data.length > 1) {
+            err = new VError('expected at most 1 data message, found %d',
+                data.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'batch: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data.length === 0 ? {} : data[0]);
+        }
     });
 }
 
+function updateObjects(rpcctx, bucket, fields, filter, options, callback) {
+    var opts, log;
 
-function updateObjects(client, bucket, fields, filter, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.object(fields, 'fields');
     assert.string(filter, 'filter');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var meta;
-    var req = client.rpc('updateObjects', bucket, fields, filter, opts);
-
-    log.debug({
-        bucket: bucket,
-        fields: fields,
-        filter: filter
-    }, 'updateObjects: entered');
-
-    req.once('message', function (obj) {
-        meta = obj;
-    });
-
-    req.once('end', function () {
-        log.debug({meta: meta}, 'updateObjects: done');
-        callback(null, meta || {});
-    });
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'updateObjects',
+        'rpcargs': [ bucket, fields, filter, opts ]
+    }, function (err, data) {
+        if (!err && data.length > 1) {
+            err = new VError('expected at most 1 data message, found %d',
+                data.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'updateObjects: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data.length === 0 ? {} : data[0]);
+        }
     });
 }
 
+function deleteMany(rpcctx, bucket, filter, options, callback) {
+    var opts, log;
 
-function deleteMany(client, bucket, filter, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.string(filter, 'filter');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('deleteMany', bucket, filter, opts);
-    log.debug({
-
-        bucket: bucket,
-        filter: filter
-    }, 'deleteMany: entered');
-
-    var meta;
-    req.once('message', function (obj) {
-        meta = obj;
-    });
-
-    req.once('end', function () {
-        log.debug('deleteMany: done');
-        callback(null, meta || {});
-    });
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'deleteMany',
+        'rpcargs': [ bucket, filter, opts ]
+    }, function (err, data) {
+        if (!err && data.length > 1) {
+            err = new VError('expected at most 1 data message, found %d',
+                data.length);
+        }
 
-    req.once('error', function (err) {
-        log.debug(err, 'deleteMany: failed');
-        callback(err);
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data.length === 0 ? {} : data[0]);
+        }
     });
 }
 
+function reindexObjects(rpcctx, bucket, count, options, callback) {
+    var opts, log;
 
-function reindexObjects(client, bucket, count, options, callback) {
-    assert.object(client, 'client');
+    assert.object(rpcctx, 'rpcctx');
     assert.string(bucket, 'bucket');
     assert.number(count, 'count');
     assert.ok(count > 0, 'count > 0');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
+    opts = makeOptions(options);
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'log': log,
+        'rpcmethod': 'reindexObjects',
+        'rpcargs': [ bucket, count, opts ]
+    }, function (err, data) {
+        if (!err && data.length != 1) {
+            err = new VError('expected exactly 1 data message, found %d',
+                data.length);
+        }
 
-    var opts = copyOptions(options);
-    var log = utils.childLogger(client, opts);
-    var req = client.rpc('reindexObjects', bucket, count, opts);
+        if (err) {
+            callback(err);
+        } else {
+            var result = data[0];
+            log.debug({ 'processed': result.processed },
+                'reindexObjects: processed');
+            callback(null, result);
+        }
+    });
+}
 
-    log.debug({
-        bucket: bucket,
-        count: count
-    }, 'reindexObjects: entered');
-    var result = {};
 
-    req.on('message', function (msg) {
-        result = msg;
-    });
+///--- Helpers
 
-    req.once('end', function () {
-        log.debug({
-            processed: result.processed
-        }, 'reindexObjects: done');
-        callback(null, result);
-    });
+function makeOptions(options, value) {
+    var opts = jsprim.deepCopy(options);
 
-    req.once('error', function (err) {
-        log.debug(err, 'reindexObjects: failed');
-        callback(err);
-    });
+    // Defaults handlers
+    opts.req_id = options.req_id || libuuid.create();
+    opts.etag = (options.etag !== undefined) ? options.etag : options._etag;
+    opts.headers = options.headers || {};
+    opts.no_count = options.no_count || false;
+    opts.sql_only = options.sql_only || false;
+    opts.noCache = true;
+
+    // Including the stringified value is redundant, but older versions of
+    // moray depend upon the _value field being populated in this way.
+    if (value)
+        opts._value = JSON.stringify(value);
+
+    if (typeof (options.noCache) !== 'undefined')
+        opts.noCache = options.noCache;
+
+    return (opts);
 }
 
 
diff --git a/lib/pool.js b/lib/pool.js
new file mode 100644
index 0000000..31d33e9
--- /dev/null
+++ b/lib/pool.js
@@ -0,0 +1,230 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/pool.js: Moray connection pool implementation
+ *
+ * The Moray client leverages the Cueball module for service discovery (via DNS)
+ * and for managing TCP connections to a set of backends found via service
+ * discovery.  Cueball is responsible for establishing connections (using
+ * connection timeouts and backoff as appropriate) and gracefully cleaning up
+ * after them when they fail.
+ *
+ * Cueball also provides a connection pool interface that's oriented around
+ * protocols that only support one consumer at a time (like HTTP).  Our use-case
+ * is quite different because we can multiplex a large number of requests over
+ * the same TCP connection.  As a result, our policy for how many connections to
+ * maintain to each instance, the way we allocate and track connections for each
+ * request, and the way we react to failures is pretty different than what the
+ * connection pool expects.  To accommodate that, we use the simpler
+ * ConnectionSet interface, which just maintains a set of connections for us.
+ * Here, we implement allocation and connection tracking appropriately.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var VError = require('verror');
+
+module.exports = MorayConnectionPool;
+
+/*
+ * This is a struct-like class that represents a single logical connection.  The
+ * lifecycle and logic are managed by the MorayConnectionPool class.
+ */
+function MorayConnection(key, conn, log) {
+    assert.string(key, 'key');
+    assert.object(conn, 'conn');
+    assert.object(log, 'log');
+    this.mc_key = key;      /* cueball identifier for this connection */
+    this.mc_conn = conn;    /* object implementing Cueball "Connection" */
+    this.mc_log = log;      /* bunyan-style logger */
+    this.mc_nreqs = 0;      /* number of outstanding requests */
+}
+
+/*
+ * This is a struct-like class representing a single allocation of a
+ * MorayConnection.  This primarily exists to allow us to ensure that consumers
+ * release each connection exactly once.  Double-releases will result in a
+ * thrown exception, and leaks will be at least somewhat debuggable.
+ */
+function MorayConnectionAllocation(mconn) {
+    this.mca_mconn = mconn;
+    this.mca_released = false;
+}
+
+MorayConnectionAllocation.prototype.connection = function () {
+    return (this.mca_mconn.mc_conn);
+};
+
+/*
+ * Given a Cueball ConnectionSet, implements a simple allocate/release interface
+ * using the connections in that set.
+ */
+function MorayConnectionPool(args) {
+    var self = this;
+
+    assert.object(args, 'args');
+    assert.object(args.log, 'args.log');
+    assert.object(args.cueballResolver, 'args.cueballResolver');
+    assert.object(args.cueballSet, 'args.cueballSet');
+
+    this.mcp_log = args.log;
+    this.mcp_cueball_resolver = args.cueballResolver;
+    this.mcp_cueball_set = args.cueballSet;
+
+    /*
+     * We keep track of all connections that we know about, as well as the set
+     * of connections that are available for new work to be assigned.  These
+     * aren't the same, as there may be some connections that are being drained
+     * because they've disappeared from service discovery or because cueball is
+     * rebalancing the set.  Both of these sets are indexed by the
+     * cueball-provided key for each connection.
+     */
+    this.mcp_conns = {};    /* all connections */
+    this.mcp_avail = {};    /* connections in service for new requests */
+
+    /* Counters for debugging */
+    this.mcp_nalloc_ok = 0;     /* successful allocations */
+    this.mcp_nalloc_fail = 0;   /* failed allocations */
+    this.mcp_nreleased = 0;     /* releases */
+
+    this.mcp_cueball_set.on('added', function onConnectionAdd(key, conn) {
+        self.connAdd(key, conn);
+    });
+
+    this.mcp_cueball_set.on('removed', function onConnectionRemoved(key) {
+        self.connDrain(key);
+    });
+}
+
+/*
+ * [public] Pick an available connection to use for a new request.  On success,
+ * returns an object that the caller can use to make requests.  On failure,
+ * returns an Error describing the problem.
+ *
+ * The caller must invoke connRelease() when the request is finished.
+ */
+MorayConnectionPool.prototype.connAlloc = function () {
+    var availkeys, key, mconn, aconn;
+
+    /*
+     * There are more sophisticated ways to pick a connection (e.g., store
+     * connections in a priority queue by number of outstanding requests).  But
+     * our expectation is that Moray servers are pretty uniform, Moray requests
+     * are pretty uniform in their cost on the server, and so a random
+     * distribution is likely to be reasonable.
+     */
+    availkeys = Object.keys(this.mcp_avail);
+    if (availkeys.length === 0) {
+        this.mcp_nalloc_fail++;
+        this.mcp_log.trace('failed to allocate connection');
+        return (new VError({
+            'name': 'NoBackendsError'
+        }, 'no connections available'));
+    }
+
+    key = jsprim.randElt(availkeys);
+    mconn = this.mcp_conns[key];
+    assert.ok(mconn instanceof MorayConnection);
+    assert.ok(mconn.mc_nreqs >= 0);
+    mconn.mc_nreqs++;
+    aconn = new MorayConnectionAllocation(mconn);
+    mconn.mc_log.trace('allocated connection');
+    this.mcp_nalloc_ok++;
+    return (aconn);
+};
+
+/*
+ * [public] Release a connection allocated from connAlloc().  The caller should
+ * not do anything else with the connection.
+ */
+MorayConnectionPool.prototype.connRelease = function (aconn) {
+    var mconn, key;
+
+    assert.ok(aconn instanceof MorayConnectionAllocation);
+    assert.ok(!aconn.mca_released, 'double-release of Moray connection');
+
+    mconn = aconn.mca_mconn;
+    assert.ok(mconn.mc_nreqs > 0);
+
+    aconn.mca_released = true;
+    mconn.mc_nreqs--;
+    mconn.mc_log.trace({ 'nreqs': mconn.mc_nreqs }, 'released connection');
+    this.mcp_nreleased++;
+
+    key = mconn.mc_key;
+    if (!this.mcp_avail.hasOwnProperty(key) && mconn.mc_nreqs === 0) {
+        this.connDelete(key);
+    }
+};
+
+/*
+ * [private] Invoked by cueball when a new connection has been established and
+ * is ready for use.  Just add it to our set of available connections.
+ */
+MorayConnectionPool.prototype.connAdd = function connAdd(key, conn) {
+    var mconn;
+
+    assert.ok(!this.mcp_conns.hasOwnProperty(key));
+    assert.ok(!this.mcp_avail.hasOwnProperty(key));
+
+    mconn = new MorayConnection(key, conn,
+        this.mcp_log.child({ 'key': key }, true));
+    this.mcp_conns[key] = mconn;
+    this.mcp_avail[key] = true;
+    mconn.mc_log.info('new connection');
+};
+
+/*
+ * [private] Invoked by cueball when a connection should be removed from
+ * service.  This connection may well still be in use by any number of requests.
+ * It's our responsibility to stop assigning new work to it, wait for existing
+ * requests to complete, and close the connection.
+ */
+MorayConnectionPool.prototype.connDrain = function connDrain(key) {
+    var mconn;
+
+    assert.ok(this.mcp_conns.hasOwnProperty(key));
+    assert.ok(this.mcp_avail.hasOwnProperty(key));
+
+    /*
+     * Remove the connection from service for new requests.
+     */
+    delete (this.mcp_avail[key]);
+
+    /*
+     * If there are no requests using this connection, clean it up now.  If
+     * there are, wait for those to finish and clean up when they're done.
+     */
+    mconn = this.mcp_conns[key];
+    if (mconn.mc_nreqs === 0) {
+        this.connDelete(key);
+    } else {
+        mconn.mc_log.info({ 'nreqs': mconn.mc_nreqs }, 'waiting for drain');
+    }
+};
+
+/*
+ * [private] Invoked when we know that a connection is fully quiesced (there are
+ * no requests associated with it) to remove it from service and destroy it.
+ */
+MorayConnectionPool.prototype.connDelete = function (key) {
+    var mconn;
+
+    assert.ok(!this.mcp_avail.hasOwnProperty(key));
+    assert.ok(this.mcp_conns.hasOwnProperty(key));
+
+    mconn = this.mcp_conns[key];
+    assert.strictEqual(mconn.mc_nreqs, 0);
+    delete (this.mcp_conns[key]);
+
+    mconn.mc_log.info('removed connection');
+    mconn.mc_conn.destroy();
+};
diff --git a/lib/ring.js b/lib/ring.js
deleted file mode 100644
index 9f6cd27..0000000
--- a/lib/ring.js
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-var assert = require('assert-plus');
-
-
-
-///--API
-function Ring(opts) {
-    opts = opts || {};
-    assert.object(opts);
-
-    EventEmitter.call(this);
-
-    var self = this;
-    this._members = {};
-    this._active = [];
-    this._next = 0;
-    this.priorityFunc = opts.priorityFunc;
-
-    this.__defineGetter__('members', function () {
-        return (Object.keys(self._members));
-    });
-    this.__defineGetter__('active', function () {
-        return (this._active.slice(0));
-    });
-}
-util.inherits(Ring, EventEmitter);
-module.exports = Ring;
-
-Ring.prototype.add = function add(key, obj) {
-    assert.string(key);
-    if (this.contains(key)) {
-        throw new Error(util.format('key already exists: %s', key));
-    }
-    this._members[key] = obj;
-};
-
-Ring.prototype.remove = function remove(key) {
-    this.contains(key, true);
-    this.deactivate(key);
-    delete this._members[key];
-};
-
-Ring.prototype.get = function get(key) {
-    this.contains(key, true);
-    return (this._members[key]);
-};
-
-Ring.prototype.contains = function contains(key, throwOnAbsent) {
-    var present = (this._members[key] !== undefined);
-    if (!present && throwOnAbsent) {
-        throw new Error(util.format('invalid key: %s', key));
-    }
-
-    return (present);
-};
-
-Ring.prototype.activate = function activate(key, suppress) {
-    if (this.isActive(key)) {
-        return;
-    }
-    this.contains(key, true);
-    this._active.push(key);
-    this._active.sort();
-    if (this._active.length === 1) {
-        this.emit('online');
-    }
-    if (!suppress) {
-        this.emit('deactivate', key);
-    }
-};
-
-Ring.prototype.deactivate = function deactivate(key, suppress) {
-    this.contains(key, true);
-    var idx = this._active.indexOf(key);
-    if (idx === -1) {
-        return;
-    }
-    delete this._active[idx];
-    // pull the null value off the array
-    this._active.sort().pop();
-    if (this._active.length === 0) {
-        this.emit('offline');
-    }
-    if (!suppress) {
-        this.emit('deactivate', key);
-    }
-};
-
-Ring.prototype.next = function next() {
-    if (this._active.length === 0) {
-        return (null);
-    }
-    if (this._next >= this._active.length) {
-        this._next = 0;
-    }
-    var key = this._active[this._next++];
-    if (this.priorityFunc) {
-        // Potentially override round-robin if priority function is present.
-        // The entry with the _lowest_ score will be chosen.
-        var self = this;
-        var base = this.priorityFunc(this._members[key]);
-        this._active.forEach(function (k) {
-            var score = self.priorityFunc(self._members[k]);
-            if (score < base) {
-                base = score;
-                key = k;
-            }
-        });
-    }
-    return (this._members[key]);
-};
-
-Ring.prototype.isActive = function isActive(key) {
-    return (this._active.indexOf(key) !== -1);
-};
-
-Ring.prototype.isOnline = function isOnline() {
-    return (this._active.length !== 0);
-};
diff --git a/lib/rpc.js b/lib/rpc.js
new file mode 100644
index 0000000..ccb6f98
--- /dev/null
+++ b/lib/rpc.js
@@ -0,0 +1,180 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/rpc.js: RPC-related utility functions
+ */
+
+var assert = require('assert-plus');
+var VError = require('verror');
+
+
+///--- API
+
+function childLogger(rpcctx, options) {
+    return (rpcctx.createLog(options));
+}
+
+/*
+ * We provide a few helper methods for making RPC calls using a FastClient:
+ *
+ *     rpcCommonNoData(args, callback)
+ *
+ *           Makes an RPC using the arguments specified by "args", reads and
+ *           buffers data returned by the RPC, waits for the RPC to complete,
+ *           and then invokes "callback" as:
+ *
+ *               callback(err)
+ *
+ *           where "err" is an error if the RPC fails or if it succeeds but
+ *           returns any data (which is not expected for users of this
+ *           function).
+ *
+ *     rpcCommonBufferData(args, callback)
+ *
+ *           Makes an RPC using the arguments specified by "args", reads and
+ *           buffers data returned by the RPC, waits for the RPC to complete,
+ *           and then invokes "callback" as:
+ *
+ *               callback(err, data)
+ *
+ *           where "err" is an error only if the RPC fails.  If the RPC
+ *           succeeds, "data" is an array of data emitted by the RPC call.
+ *
+ *     rpcCommon(args, callback)
+ *
+ *           Makes an RPC using the arguments specified by "args", waits for the
+ *           RPC to complete, and then invokes "callback" as:
+ *
+ *               callback(err)
+ *
+ *           where "err" is an error only if the RPC fails.  Unlike the
+ *           interfaces above, this one does NOT read data from the RPC, which
+ *           means the caller is responsible for doing that.  Since the RPC
+ *           response is a stream, if the caller does not start reading data,
+ *           the RPC will never complete.
+ *
+ *           This is the building block for the other methods, but it's only
+ *           useful if you want to handle data emitted by the RPC in a streaming
+ *           way.
+ *
+ * All of these functions take care of unwrapping errors if the Moray client was
+ * configured that way.  Named arguments are:
+ *
+ *     rpcmethod, rpcargs, log,     See FastClient.rpc() method.
+ *     ignoreNullValues
+ *
+ *     rpcctx                       Moray's "rpcctx" handle, a wrapper around
+ *                                  a FastClient that includes context related
+ *                                  to this Moray client.
+ */
+function rpcCommon(args, callback) {
+    var rpcctx, req, addrs;
+
+    assert.object(args, 'args');
+    assert.object(args.rpcctx, 'args.rpcctx');
+    assert.string(args.rpcmethod, 'args.rpcmethod');
+    assert.array(args.rpcargs, 'args.rpcargs');
+    assert.object(args.log, 'args.log');
+    assert.optionalNumber(args.timeout, 'args.timeout');
+    assert.optionalBool(args.ignoreNullValues, 'args.ignoreNullValues');
+    assert.func(callback);
+
+    rpcctx = args.rpcctx;
+    req = rpcctx.fastClient().rpc({
+        'rpcmethod': args.rpcmethod,
+        'rpcargs': args.rpcargs,
+        'timeout': args.timeout,
+        'ignoreNullValues': args.ignoreNullValues,
+        'log': args.log
+    });
+
+    req.once('end', callback);
+    req.once('error', function (err) {
+        if (rpcctx.unwrapErrors()) {
+            err = unwrapError(err);
+        } else {
+            addrs = rpcctx.socketAddrs();
+            err = new VError({
+                'cause': err,
+                'info': addrs
+            }, 'moray client ("%s" to "%s")', addrs.local, addrs.remote);
+        }
+        callback(err);
+    });
+
+    return (req);
+}
+
+/*
+ * See above.
+ */
+function rpcCommonNoData(args, callback) {
+    assert.func(callback);
+    rpcCommonBufferData(args, function (err, data) {
+        if (!err && data.length > 0) {
+            err = new VError('bad server response: expected 0 data messages, ' +
+                'found %d\n', data.length);
+        }
+
+        callback(err);
+    });
+}
+
+/*
+ * See above.
+ */
+function rpcCommonBufferData(args, callback) {
+    var req, rpcmethod, log, data;
+
+    assert.func(callback, 'callback');
+    req = rpcCommon(args, function (err) {
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, data);
+        }
+    });
+
+    rpcmethod = args.rpcmethod;
+    log = args.log;
+    data = [];
+    req.on('data', function (obj) {
+        log.debug({ 'message': obj }, 'rpc ' + rpcmethod + ': received object');
+        data.push(obj);
+    });
+
+    return (req);
+}
+
+/*
+ * See the "unwrapErrors" constructor argument for the MorayClient.
+ */
+function unwrapError(err) {
+    if (err.name == 'FastRequestError') {
+        err = VError.cause(err);
+    }
+
+    if (err.name == 'FastServerError') {
+        err = VError.cause(err);
+    }
+
+    return (err);
+}
+
+
+///--- Exports
+
+module.exports = {
+    childLogger: childLogger,
+    rpcCommon: rpcCommon,
+    rpcCommonNoData: rpcCommonNoData,
+    rpcCommonBufferData: rpcCommonBufferData
+};
diff --git a/lib/tokens.js b/lib/tokens.js
index c648555..49b538c 100644
--- a/lib/tokens.js
+++ b/lib/tokens.js
@@ -5,84 +5,55 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/tokens.js: token-related client API functions.  These functions are
+ * invoked by same-named methods in lib/client.js to do the bulk of the work
+ * associated with making RPC requests.  The arguments and semantics of these
+ * functions are documented in the Moray API.
  */
 
 var assert = require('assert-plus');
 var libuuid = require('libuuid');
-var once = require('once');
-
-var utils = require('./utils');
-
-
-
-///--- Helpers
-
-function copyOptions(options, value) {
-    var opts = {
-        etag: options.etag !== undefined ? options.etag : options._etag,
-        headers: options.headers || {},
-        limit: options.limit,
-        noCache: true,
-        offset: options.offset,
-        req_id: options.req_id || libuuid.create(),
-        sort: options.sort,
-        vnode: options.vnode
-    };
-
-    if (value)
-        opts._value = JSON.stringify(value);
-    if (typeof (options.noCache) !== 'undefined')
-        opts.noCache = options.noCache;
-
-    return (opts);
-}
+var VError = require('verror');
 
+var rpc = require('./rpc');
 
 
 ///--- API
-// All of the functions here are scoped to the file as they require an
-// underlying 'fast' connection to be given to them.  The functions on
-// the moray prototype are just passthroughs to all these
 
-function getTokens(client, options, callback) {
-    assert.object(client, 'client');
+function getTokens(rpcctx, options, callback) {
+    var opts, log;
+
+    assert.object(rpcctx, 'rpcctx');
     assert.object(options, 'options');
     assert.func(callback, 'callback');
 
-    callback = once(callback);
-
-    var req;
-    var res;
-    var log = utils.childLogger(client);
-    var opts = copyOptions(options);
-
-    req = client.rpc('getTokens', opts);
-
-    log.debug('getTokens: entered');
-
-    req.once('message', function (obj) {
-        res = {
-            tokens: obj
-        };
-        log.debug({
-            tokens: obj
-        }, 'getTokens: got tokens');
-    });
-
-    req.once('end', function () {
-        log.debug('getTokens: done');
-        callback(null, res);
-    });
-
-    req.once('error', function (err) {
-        log.debug(err, 'getTokens: failed');
-        callback(err);
+    opts = { req_id: options.req_id || libuuid.create() };
+    log = rpc.childLogger(rpcctx, opts);
+    rpc.rpcCommonBufferData({
+        'rpcctx': rpcctx,
+        'rpcmethod': 'getTokens',
+        'rpcargs': [ opts ],
+        'log': log
+    }, function (err, tokens) {
+        if (!err && tokens.length != 1) {
+            err = new VError('bad server response: expected 1 token, found %d',
+                tokens.length);
+        }
+
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        callback(null, { 'tokens': tokens[0] });
     });
 }
 
 
-
 ///--- Exports
 
 module.exports = {
diff --git a/lib/utils.js b/lib/utils.js
deleted file mode 100644
index 8ea6080..0000000
--- a/lib/utils.js
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var libuuid = require('libuuid');
-var once = require('once');
-
-
-
-///--- API
-
-function childLogger(client, options) {
-    var log = client.log.child({
-        req_id: (options || {}).req_id || libuuid.create()
-    }, true);
-
-    return (log);
-}
-
-
-function clone(obj) {
-    if (!obj) {
-        return (obj);
-    }
-    var copy = {};
-    Object.keys(obj).forEach(function (k) {
-        copy[k] = obj[k];
-    });
-    return (copy);
-}
-
-
-function simpleCallback(opts) {
-    assert.object(opts, 'options');
-    assert.func(opts.callback, 'options.callback');
-    assert.object(opts.log, 'options.log');
-    assert.string(opts.name, 'options.name');
-    assert.object(opts.request, 'options.request');
-
-    function callback(err) {
-        if (err) {
-            opts.log.debug(err, '%s failed', opts.name);
-            opts.callback(err);
-            return;
-        }
-
-        opts.log.debug('%s done', opts.name);
-        opts.request.removeAllListeners('end');
-        opts.request.removeAllListeners('error');
-        opts.callback();
-    }
-
-    return (callback);
-}
-
-
-
-///--- Exports
-
-module.exports = {
-    childLogger: childLogger,
-    clone: clone,
-    simpleCallback: simpleCallback
-};
\ No newline at end of file
diff --git a/package.json b/package.json
index ae045bc..89577af 100644
--- a/package.json
+++ b/package.json
@@ -1,25 +1,26 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "1.0.1",
+    "version": "2.0.0",
     "author": "Joyent (joyent.com)",
-    "private": true,
     "main": "./lib/index.js",
     "repository": {
         "type": "git",
         "url": "git+ssh://git@github.com:joyent/node-moray.git"
     },
     "dependencies": {
-        "assert-plus": "0.1.5",
+        "assert-plus": "^1.0.0",
         "backoff": "^2.4.1",
         "bunyan": "^1.3.2",
-        "fast": "^0.5.0",
-        "native-dns": "0.4.1",
+        "cmdutil": "^1.1.0",
+        "cueball": "^1.0.3",
+        "fast": "^2.1.0",
         "libuuid": "0.2.1",
-        "once": "1.3.0",
-        "posix-getopt": "1.0.0",
+        "jsprim": "^1.2.2",
+        "posix-getopt": "^1.0.0",
         "progbar": "0.1.0",
-        "clone": "0.1.18"
+        "vasync": "^1.6.4",
+        "verror": "^1.7.0"
     },
     "directories": {
         "bin": "./bin",
