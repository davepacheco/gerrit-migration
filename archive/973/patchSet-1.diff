From a245f80584dd8088418e060a20034c54370e419a Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Tue, 29 Nov 2016 20:41:35 +0000
Subject: [PATCH] OS-5817 lxbrand lint error in lx_brk

---
 usr/src/uts/common/brand/lx/syscall/lx_brk.c | 28 +++++++++-----------
 1 file changed, 13 insertions(+), 15 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_brk.c b/usr/src/uts/common/brand/lx/syscall/lx_brk.c
index 19a7577ac0..ab44bcf79f 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_brk.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_brk.c
@@ -21,29 +21,20 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2016 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/types.h>
 #include <sys/systm.h>
+#include <sys/thread.h>
 #include <sys/errno.h>
 
-/*
- * The brk() system call needs to be in-kernel because Linux expects a call to
- * brk(0) to return the current breakpoint.  In Solaris, the process breakpoint
- * is setup and managed by libc.  Due to the way we link our libraries and the
- * need for Linux to manage its own breakpoint, this has to remain in the
- * kernel.
- */
-extern int brk(caddr_t);
+/* From usr/src/uts/common/os/grow.c */
+extern intptr_t brk(caddr_t);
 
 long
 lx_brk(caddr_t nva)
 {
-	proc_t *p = curproc;
-	klwp_t *lwp = ttolwp(curthread);
-
 	if (nva != 0) {
 		(void) brk(nva);
 
@@ -51,7 +42,14 @@ lx_brk(caddr_t nva)
 		 * Despite claims to the contrary in the manpage, when Linux
 		 * brk() fails, errno is left unchanged.
 		 */
-		lwp->lwp_errno = 0;
+		ttolwp(curthread)->lwp_errno = 0;
 	}
-	return ((long)(p->p_brkbase + p->p_brksize));
+
+	/*
+	 * After the ASLR changes, interal brk(2) was updated to emit the
+	 * current brk when arg0 == 0.  It's functionally equivalent to
+	 * manually calculating the brk, but it also serializes with changes to
+	 * the process AS.
+	 */
+	return ((long)brk((caddr_t)0));
 }
-- 
2.21.0

