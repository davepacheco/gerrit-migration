commit c8fbe597bed6ef4d2f6abf7ec09b15a6e279dcd6 (refs/changes/87/487/3)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2016-09-16T22:48:29+00:00 (3 years, 1 month ago)
    
    FWAPI-239 Firewall rules are not regenerated when machine tag changes are made

diff --git a/lib/endpoints/updates.js b/lib/endpoints/updates.js
index c67e3d3..d16f896 100644
--- a/lib/endpoints/updates.js
+++ b/lib/endpoints/updates.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -22,6 +22,7 @@ var util = require('util');
 
 
 var UPDATES = {
+    'sync': validateSync,
     'vm.add': validateAdd,
     'vm.update': validateUpdate,
     'vm.delete': validateDel
@@ -33,6 +34,13 @@ var UPDATES = {
 
 
 
+function validateSync(params) {
+    return {
+        type: params.type,
+        req_id: params.req_id
+    };
+}
+
 function validateAdd(params) {
     return params;
 }
diff --git a/package.json b/package.json
index b3d0598..a0d5281 100644
--- a/package.json
+++ b/package.json
@@ -9,7 +9,7 @@
     "mockery": "1.4.0"
   },
   "dependencies": {
-    "assert-plus": "0.1",
+    "assert-plus": "1.0.0",
     "async": "0.1",
     "bunyan": "1.2.3",
     "clone": "0.1",
diff --git a/test/integration/vm-update.multi-test.js b/test/integration/vm-update.multi-test.js
index f6af96f..1dad37a 100644
--- a/test/integration/vm-update.multi-test.js
+++ b/test/integration/vm-update.multi-test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -13,12 +13,9 @@
  */
 
 var test = require('tape');
-var async = require('async');
 var config = require('../lib/config');
-var fmt = require('util').format;
 var mod_cn = require('../lib/cn');
 var mod_rule = require('../lib/rule');
-var mod_uuid = require('node-uuid');
 var mod_vm = require('../lib/vm');
 var util = require('util');
 
@@ -32,6 +29,8 @@ var OWNERS = [ config.test.owner_uuid ];
 var RULES = {};
 var TAGS = {
     // add process.pid to ensure the tags are unique
+    web: 'web_' + process.pid,
+    db: 'db_' + process.pid,
     role: 'role_' + process.pid
 };
 var VMS = [];
@@ -70,7 +69,7 @@ function checkVMsProvisioned(t2) {
 
 test('pre_test', pre_test);
 test('Add rules', function (t) {
-    t.test('VM 0 to VM 1', function (t2) {
+    t.test('VM 0 to VM 1: SSH', function (t2) {
         RULES.ssh1 = {
             description: 'allow SSH',
             enabled: true,
@@ -85,6 +84,22 @@ test('Add rules', function (t) {
             exp: RULES.ssh1
         });
     });
+
+    t.test('VM 2 to VM 1: DB', function (t2) {
+        RULES.web1 = {
+            description: 'allow DB access',
+            enabled: true,
+            owner_uuid: OWNERS[0],
+            rule: util.format(
+                'FROM tag %s TO tag %s ALLOW tcp PORT 5432',
+                TAGS.web, TAGS.db)
+        };
+
+        mod_rule.create(t2, {
+            rule: RULES.web1,
+            exp: RULES.web1
+        });
+    });
     t.end();
 });
 
@@ -109,10 +124,19 @@ test('Provision VMs', function (t) {
             owner_uuid: OWNERS[0],
             server_uuid: config.test.server2_uuid,
             tags: { }
+        },
+        {
+            alias: mod_vm.alias(),
+            firewall_enabled: false,
+            owner_uuid: OWNERS[0],
+            server_uuid: config.test.server1_uuid,
+            tags: { }
         }
     ];
     vms[0].tags[TAGS.role] = 'one';
     vms[1].tags[TAGS.role] = 'two';
+    vms[1].tags[TAGS.db] = '2';
+    vms[2].tags[TAGS.web] = '3';
 
     mod_vm.provision(t, {
         vms: vms
@@ -121,7 +145,8 @@ test('Provision VMs', function (t) {
             VMS = res;
         }
 
-        return t.end();
+        t.ifError(err, 'Provisioning VMs should succeed');
+        t.end();
     });
 });
 
@@ -152,6 +177,15 @@ test('After provision: rules', function (t) {
         });
     });
 
+    t.test('CN 0: web1 rule not present', function (t2) {
+        mod_cn.getRule(t2, {
+            server_uuid: VMS[0].server_uuid,
+            uuid: RULES.web1.uuid,
+            expCode: 404,
+            expErr: mod_cn.notFoundErr
+        });
+    });
+
     t.test('CN 1: RVM 0 not present', function (t2) {
         mod_cn.getRVM(t2, {
             server_uuid: VMS[1].server_uuid,
@@ -161,6 +195,15 @@ test('After provision: rules', function (t) {
         });
     });
 
+    t.test('CN 1: RVM 2 not present', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[2].uuid,
+            expCode: 404,
+            expErr: mod_cn.rvmNotFoundErr
+        });
+    });
+
     t.test('CN 1: ssh1 rule not present', function (t2) {
         mod_cn.getRule(t2, {
             server_uuid: VMS[1].server_uuid,
@@ -169,6 +212,16 @@ test('After provision: rules', function (t) {
             expErr: mod_cn.notFoundErr
         });
     });
+
+    t.test('CN 1: web1 rule not present', function (t2) {
+        mod_cn.getRule(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: RULES.web1.uuid,
+            expCode: 404,
+            expErr: mod_cn.notFoundErr
+        });
+    });
+
     t.end();
 });
 
@@ -211,6 +264,14 @@ test('Enable firewall', function (t) {
         });
     });
 
+    t.test('CN 1: web1 rule present', function (t2) {
+        mod_cn.getRule(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: RULES.web1.uuid,
+            exp: RULES.web1
+        });
+    });
+
     t.test('CN 1: RVM 0 present', function (t2) {
         mod_cn.getRVM(t2, {
             server_uuid: VMS[1].server_uuid,
@@ -218,22 +279,119 @@ test('Enable firewall', function (t) {
             exp: VMS[0]
         });
     });
+
+    t.test('CN 1: RVM 2 present', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[2].uuid,
+            exp: VMS[2]
+        });
+    });
+
     t.end();
 });
 
 
+test('Remove "web" tag from VM 2', function (t) {
 
-// --- Teardown
+    t.test('update VM', function (t2) {
+        mod_vm.removeTag(t2, {
+            uuid: VMS[2].uuid,
+            tag: TAGS.web
+        });
+    });
+
+    t.test('CN 1: RVM 2 present and missing "web" tag', function (t2) {
+        delete VMS[2].tags[TAGS.web];
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[2].uuid,
+            exp: VMS[2]
+        });
+    });
 
+    t.test('Syncing all CNs', function (t2) {
+        mod_cn.syncAll(t2, [ VMS[1].server_uuid ]);
+    });
 
+    t.test('CN 1: RVM 2 not present', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[2].uuid,
+            expCode: 404,
+            expErr: mod_cn.rvmNotFoundErr
+        });
+    });
 
-test('teardown', function (t) {
-    t.test('delete rules', function (t2) {
-        mod_rule.delAllCreated(t2);
+    t.end();
+});
+
+
+test('Add back "web" tag to VM 2', function (t) {
+
+    t.test('update VM', function (t2) {
+        VMS[2].tags[TAGS.web] = '4';
+        mod_vm.addTags(t2, {
+            uuid: VMS[2].uuid,
+            tags: VMS[2].tags
+        });
+    });
+
+    t.test('CN 1: RVM 2 present', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[2].uuid,
+            exp: VMS[2]
+        });
+    });
+
+    t.end();
+});
+
+
+test('Change value of "role" tag on VM 0', function (t) {
+
+    t.test('update VM', function (t2) {
+        VMS[0].tags[TAGS.role] = 'three';
+        mod_vm.updateTags(t2, {
+            uuid: VMS[0].uuid,
+            tags: VMS[0].tags
+        });
+    });
+
+    t.test('CN 1: RVM 0 updated', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[0].uuid,
+            exp: VMS[0]
+        });
     });
 
-    t.test('delete VMs', function (t2) {
-        mod_vm.delAllCreated(t2);
+    t.test('Syncing all CNs', function (t2) {
+        mod_cn.syncAll(t2, [ VMS[1].server_uuid ]);
     });
+
+    t.test('CN 1: RVM 0 not present', function (t2) {
+        mod_cn.getRVM(t2, {
+            server_uuid: VMS[1].server_uuid,
+            uuid: VMS[0].uuid,
+            expCode: 404,
+            expErr: mod_cn.rvmNotFoundErr
+        });
+    });
+
+    t.end();
+});
+
+
+
+
+// --- Teardown
+
+
+
+test('teardown', function (t) {
+    t.test('delete rules', mod_rule.delAllCreated);
+    t.test('delete VMs', mod_vm.delAllCreated);
     t.end();
 });
diff --git a/test/lib/cn.js b/test/lib/cn.js
index eb43ec0..4ad7091 100644
--- a/test/lib/cn.js
+++ b/test/lib/cn.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -21,7 +21,9 @@ var ifErr = common.ifErr;
 var fmt = require('util').format;
 var mod_client = require('./client');
 var mod_log = require('./log');
+var mod_obj = require('../../lib/util/obj.js');
 var restify = require('restify');
+var vasync = require('vasync');
 var VError = require('verror').VError;
 
 
@@ -130,7 +132,7 @@ function createRemoteVM(vm) {
         });
     }
 
-    if (objEmpty(ips)) {
+    if (mod_obj.isEmpty(ips)) {
         err = new VError(
             'Remote VM "%s": missing IPs', uuid);
         err.details = vm;
@@ -139,7 +141,7 @@ function createRemoteVM(vm) {
 
     rvm.ips = Object.keys(ips).sort();
 
-    if (vm.hasOwnProperty('tags') && !objEmpty(vm.tags)) {
+    if (vm.hasOwnProperty('tags') && !mod_obj.isEmpty(vm.tags)) {
         rvm.tags = {};
         for (var t in vm.tags) {
             rvm.tags[t] = vm.tags[t];
@@ -195,27 +197,83 @@ function getClient(t, server, callback) {
 }
 
 
-/**
- * Returns true if the object has no keys
- * (stolen from fw/lib/util/vm.js)
- */
-function objEmpty(obj) {
-    /* JSSTYLED */
-    /*jsl:ignore*/
-    for (var k in obj) {
-        return false;
-    }
-    /* JSSTYLED */
-    /*jsl:end*/
+function checkTask(t, server, updateUUID, callback) {
+    getClient(t, server, function (err, client) {
+        if (err) {
+            callback(err);
+            return;
+        }
 
-    return true;
-}
+        var start = Date.now();
 
+        function checkIt() {
+            client.get('/status', function (err2, req, res, obj) {
+                var elapsed = Date.now() - start;
+
+                if (err2 || obj.recent.indexOf(updateUUID) !== -1) {
+                    callback(err2);
+                    return;
+                }
+
+                /*
+                 * The 'sync' task does a lot more work than the other
+                 * endpoints, so we wait thrice as long before timing
+                 * out.
+                 */
+                if (elapsed < (POLL_TIMEOUT * 3)) {
+                    // We haven't hit our timeout yet, so keep trying
+                    LOG.trace({ start: start.toString(), elapsed: elapsed },
+                        'task poll timeout not hit: retrying');
+                    setTimeout(checkIt, POLL_INTERVAL);
+                    return;
+                }
+
+                LOG.debug({ start: start.toString(), elapsed: elapsed },
+                    'task poll timeout exceeded');
+
+                callback(new VError(
+                    'Task %s not executed within expected period', updateUUID));
+            });
+        }
+
+        setTimeout(checkIt, POLL_INTERVAL);
+    });
+}
 
 
 // --- Exports
 
 
+/**
+ * Run the 'sync' task on all CNs' firewallers, and make sure it finishes
+ * successfully on all CNs listed in the cns array.
+ */
+function syncAllCNs(t, cns, callback) {
+    assert.object(t, 't');
+    assert.arrayOfUuid(cns, 'cns');
+    assert.optionalFunc(callback, 'callback');
+
+    var fwapi = mod_client.get('fwapi');
+    fwapi.createUpdate({ type: 'sync' }, function (err, res) {
+        if (ifErr(t, err, 'sent sync message to FWAPI')) {
+            done(err, null, t, callback);
+            return;
+        }
+
+        var updateUUID = res.update_uuid;
+
+        vasync.forEachParallel({
+            inputs: cns,
+            func: function checkCN(cn, cb) {
+                checkTask(t, cn, updateUUID, cb);
+            }
+        }, function (err2) {
+            t.ifError(err2, 'all CNs should sync successfully');
+            done(err2, null, t, callback);
+        });
+    });
+}
+
 
 /**
  * Get a VM's firewall status from firewaller on a CN
@@ -395,6 +453,7 @@ module.exports = {
     getFwStatus: getFwStatus,
     getRule: getRule,
     getRVM: getRVM,
+    syncAll: syncAllCNs,
     get notFoundErr() {
         return clone(NOT_FOUND_ERR);
     },
diff --git a/test/lib/vm.js b/test/lib/vm.js
index c52a5a6..122d355 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
@@ -310,6 +310,84 @@ function provision(t, opts, callback) {
 }
 
 
+/**
+ * Add tags to a VM
+ */
+function addTags(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalFunc(callback, 'callback');
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.object(opts.tags, 'opts.tags');
+
+    var client = opts.client || mod_client.get('vmapi');
+    client.addMetadata('tags', { uuid: opts.uuid, metadata: opts.tags }, {},
+        function (err, job) {
+        if (ifErr(t, err, 'add tags to VM')) {
+            t.deepEqual(opts.tags, {}, 'VM add tags');
+            done(err, null, t, callback);
+            return;
+        }
+
+        waitForJob(t, job.job_uuid, function (err2, res) {
+            done(err2, null, t, callback);
+        });
+    });
+}
+
+
+/**
+ * Add tags to a VM
+ */
+function removeTag(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalFunc(callback, 'callback');
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.string(opts.tag, 'opts.tag');
+
+    var client = opts.client || mod_client.get('vmapi');
+    client.deleteMetadata('tags', { uuid: opts.uuid }, opts.tag, {},
+        function (err, job) {
+        if (ifErr(t, err, 'remove tag from VM')) {
+            t.deepEqual(opts.tag, '', 'VM remove tag');
+            done(err, null, t, callback);
+            return;
+        }
+
+        waitForJob(t, job.job_uuid, function (err2, res) {
+            done(err2, null, t, callback);
+        });
+    });
+}
+
+
+/**
+ * Add tags to a VM
+ */
+function updateTags(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalFunc(callback, 'callback');
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.object(opts.tags, 'opts.tags');
+
+    var client = opts.client || mod_client.get('vmapi');
+    client.setMetadata('tags', { uuid: opts.uuid, metadata: opts.tags }, {},
+        function (err, job) {
+        if (ifErr(t, err, 'update tags to VM')) {
+            t.deepEqual(opts.tags, {}, 'VM update tags');
+            done(err, null, t, callback);
+            return;
+        }
+
+        waitForJob(t, job.job_uuid, function (err2, res) {
+            done(err2, null, t, callback);
+        });
+    });
+}
+
+
 /**
  * Update a VM
  */
@@ -375,6 +453,9 @@ function update(t, opts, callback) {
 
 
 module.exports = {
+    addTags: addTags,
+    removeTag: removeTag,
+    updateTags: updateTags,
     alias: alias,
     del: del,
     delAllCreated: delAllCreated,
