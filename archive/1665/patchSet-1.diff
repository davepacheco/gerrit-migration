commit 8419e56968ce6b6b90fa671b6527b72d0cb1e483 (refs/changes/65/1665/1)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-03-15T16:35:30+01:00 (2 years, 7 months ago)
    
    TOOLS-1715 sdcadm: reprovisionRemote can timeout too easily

diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index e4c34d0..5ed0000 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -783,7 +783,80 @@ function disableVMRegistrarRemote(arg, callback) {
     });
 }
 
-// Reprovision through sdc-oneachnode
+/*
+ * Exec the given command into the provided server UUID.
+ *
+ * This is a replacement for running commands into servers using
+ * sdc-oneachnode.
+ *
+ *
+ * @param opts {Object}:
+ *      -sdcadm {Obkect} SdcAdm instance
+ *      - cmd {String} The command to be executed
+ *      - server {String} UUID of the server where the command will be executed
+ *      - timeout {Integer} Optional. Timeout for command execution in seconds.
+ *          (default to 60 seconds if nothing is given)
+ *      - env {Object} Optional. Execution environment for the command.
+ * @param callback {Function} of the form `f(execErr, execResult)`, where
+ *      `execResult` is an object with stderr, stdout and exit_status
+ *      properties.
+ */
+function execRemote(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.uuid(opts.server, 'opts.server');
+    assert.string(opts.cmd, 'opts.cmd');
+    assert.optionalNumber(opts.timeout, 'opts.timeout');
+    assert.optionalObject(opts.env, 'opts.env');
+    assert.func(callback, 'callback');
+
+    var arg = {};
+    vasync.pipeline({arg: arg, funcs: [
+        function getUrConnection(ctx, next) {
+            opts.sdcadm.getUrConnection(function (err, urconn) {
+                if (err) {
+                    next(new errors.InternalError({
+                        cause: err,
+                        message: 'ur failure'
+                    }));
+                    return;
+                }
+                assert.object(urconn);
+                ctx.urconn = urconn;
+                next();
+            });
+        },
+
+        function execCommand(ctx, next) {
+            var execOpts = {
+                script: opts.cmd,
+                server_uuid: opts.server,
+                timeout: (60 || opts.timeout) * 1000
+            };
+            if (opts.env) {
+                execOpts.env = opts.env;
+            }
+            ctx.urconn.exec(execOpts, function (cmdErr, cmdResult) {
+                if (cmdErr) {
+                    next(new errors.InternalError({
+                        cause: cmdErr,
+                        message: 'ur exec_command failure'
+                    }));
+                    return;
+                }
+
+                arg.result = cmdResult;
+                next();
+            });
+        }
+    ]}, function (pipeErr) {
+        callback(pipeErr, arg.result);
+    });
+}
+
+/*
+ * Reprovision into any server via Ur command
+ */
 function reprovisionRemote(opts, callback) {
     common.assertStrictOptions('reprovisionRemote', opts, {
         server: 'uuid',
@@ -802,7 +875,10 @@ function reprovisionRemote(opts, callback) {
         server: opts.server
     });
 
-    opts.progress('Reprovisioning %s VM %s', opts.zonename, opts.server);
+    var sdcadm = opts.sdcadm;
+    var progress = opts.progress;
+
+    progress('Reprovisioning %s VM %s', opts.zonename, opts.server);
     log.trace('reprovision VM inst');
 
     /*
@@ -813,58 +889,41 @@ function reprovisionRemote(opts, callback) {
         image_uuid: opts.img.uuid
     }).replace(/'/g, '\'"\'"\'');
 
-    var child = spawn('/opt/smartdc/bin/sdc-oneachnode', [
-        '-n',
-        opts.server,
-        format('/usr/sbin/vmadm reprovision %s <<< \'%s\'', opts.zonename,
-            reproJSON)
-    ]);
-
-    /*
-     * Collect stdout and stderr from the child process.
-     */
-    var stdout = '';
-    var stderr = '';
-    child.stdout.setEncoding('utf8');
-    child.stdout.on('data', function (so) {
-        stdout += so;
-    });
-    child.stderr.setEncoding('utf8');
-    child.stderr.on('data', function (se) {
-        stderr += se;
-    });
+    execRemote({
+        sdcadm: sdcadm,
+        server: opts.server,
+        timeout: 120,
+        cmd: format('/usr/sbin/vmadm reprovision %s <<< \'%s\'',
+                opts.zonename, reproJSON)
+    }, function (execErr, result) {
+        if (execErr) {
+            callback(execErr);
+            return;
+        }
 
-    child.on('close', function vmadmDone(code, signal) {
         log.debug({
             execResult: {
-                code: code,
-                signal: signal,
-                stdout: stdout,
-                stderr: stderr
+                code: result.exit_status,
+                stdout: result.stdout,
+                stderr: result.stderr
             }
         }, 'reprovisioned VM inst');
 
-        if (code === 0 && signal === null) {
-            /*
-             * Execution was successful.
-             */
+        if (result.exit_status === 0) {
             callback();
             return;
         }
 
-        /*
-         * Report the execution failure to our caller and take the
-         * reprovision failure lock.
-         */
         var msg = [
-            format('error reprovisioning VM %s: exit code %s, signal %s',
-                opts.zonename, code, signal),
+            format('error reprovisioning VM %s: exit code %s',
+                opts.zonename, result.exit_status),
             common.indent('stdout:', 4),
-            common.indent(stdout, 8),
+            common.indent(result.stdout.trim(), 8),
             common.indent('stderr:', 4),
-            common.indent(stderr, 8)
+            common.indent(result.stderr.trim(), 8)
         ].join('\n');
-        opts.sdcadm.reprovFailLock_Lock(msg, function (err) {
+
+        sdcadm.reprovFailLock_Lock(msg, function (err) {
             if (err) {
                 log.error(err, 'reprovFailLock_Lock failure');
             }
