commit fa7079b658db872844b912cc686a7ffc66f1107e
Author: Isaac Davis <isaac.davis@joyent.com>
Date:   2019-03-14T22:39:02+00:00 (7 months ago)
    
    MANTA-4122 Muskie could have a cheaper directory listing API

diff --git a/lib/common.js b/lib/common.js
index b65e6f6..4ed00cb 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -632,25 +632,59 @@ function addCustomHeaders(req, res) {
 
 
 function readdir(dir, req) {
+    /*
+     * We check for operator-only options:
+     *   - sort === 'none'
+     *   - skip_owner_check === 'true'
+     *
+     * These two options constitute a short-term approach to a faster ls, to be
+     * used in mako garbage collection. They remove the ability to paginate, and
+     * thus should not be used under normal circumstances. See MANTA-4122 for
+     * more information.
+     */
+    var nosort = req.params.sort === 'none';
+    var ownerCheck = !(req.params.skip_owner_check === 'true');
+    var isOperator = req.caller.account.isOperator;
+
+    var ee;
+    if (!isOperator) {
+        var badParams = [];
+        if (nosort) {
+            badParams.push('sort=none');
+        }
+        if (!ownerCheck) {
+            badParams.push('skip_owner_check=true');
+        }
+        if (badParams.length != 0) {
+            ee = new EventEmitter();
+            process.nextTick(function () {
+                ee.emit('error', new QueryParameterForbiddenError(badParams));
+            });
+            return (ee);
+        }
+    }
+
     var l = parseInt(req.params.limit || 256, 10);
     if (l <= 0 || l > 1024) {
-        var ee = new EventEmitter();
+        ee = new EventEmitter();
         process.nextTick(function () {
             ee.emit('error', new InvalidLimitError(l));
         });
         return (ee);
     }
 
-    var account = req.owner.account.uuid;
     // We want the really low-level API here, as we want to go hit the place
     // where all the keys are, not where the dirent itself is.
     var client = req.moray;
     var filter = new morayFilter.AndFilter();
 
-    filter.addFilter(new morayFilter.EqualityFilter({
-        attribute: 'owner',
-        value: account
-    }));
+    if (ownerCheck) {
+        var account = req.owner.account.uuid;
+        filter.addFilter(new morayFilter.EqualityFilter({
+            attribute: 'owner',
+            value: account
+        }));
+    }
     filter.addFilter(new morayFilter.EqualityFilter({
         attribute: 'dirname',
         value: dir
@@ -690,7 +724,10 @@ function readdir(dir, req) {
         } else {
             opts.sort.order = 'DESC';
         }
+    } else if (nosort) {
+        delete opts.sort;
     } else {
+        // If we do not specify tsort or nosort, we sort by name.
         opts.sort.attribute = 'name';
         if (reverse) {
             opts.sort.order = 'DESC';
@@ -699,7 +736,15 @@ function readdir(dir, req) {
         }
     }
 
-    if (marker) {
+    /*
+     * If a marker was provided with the request, add an appropriate filter so
+     * that this page of results begins at the appropriate position in the full
+     * result set.  If this is a request for unsorted results, as used
+     * internally to check if a directory is empty and for mako garbage
+     * collection, it doesn't make sense to use a marker as there is no
+     * consistent total order of the result set.
+     */
+    if (marker && !nosort) {
         if (tsort) {
             var mtime = Date.parse(marker);
             if (Number.isFinite(mtime)) {
@@ -730,7 +775,7 @@ function readdir(dir, req) {
 
     log.debug({
         dir: dir,
-        filter: opts.filter
+        opts: opts
     }, 'readdir: entered');
     var mreq = client.search(opts);
 
diff --git a/lib/errors.js b/lib/errors.js
index f963f60..ac42afb 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -541,6 +541,19 @@ function PreSignedRequestError(msg) {
 util.inherits(PreSignedRequestError, MuskieError);
 
 
+// We expect an array of the offending parameters.
+function QueryParameterForbiddenError(params) {
+    MuskieError.call(this, {
+        restCode: 'QueryParameterForbidden',
+        statusCode: 403,
+        message: sprintf(
+            'Use of these query parameters is restricted to operators: %s',
+            params.join(', '))
+    });
+}
+util.inherits(QueryParameterForbiddenError, MuskieError);
+
+
 function RequestedRangeNotSatisfiableError(req, err) {
     if (err && err._result && err._result.headers) {
         this.headers = {
diff --git a/package.json b/package.json
index a1189c7..3e07661 100644
--- a/package.json
+++ b/package.json
@@ -51,7 +51,8 @@
         "manta": "5.1.0",
         "nodeunit": "0.9.1",
         "node-uuid": "1.4.1",
-        "forkexec": "^1.0.0"
+        "forkexec": "^1.0.0",
+        "smartdc-auth": "^2.5.7"
     },
     "scripts": {
         "start": "./build/node/bin/node ./main.js",
diff --git a/test/dir.test.js b/test/dir.test.js
index 1545716..4e98a4b 100644
--- a/test/dir.test.js
+++ b/test/dir.test.js
@@ -53,10 +53,177 @@ function writeStreamingObject(client, key, cb) {
     });
 }
 
+/*
+ * Tests whether (or not) we are allowed to list the contents of a dir, given
+ * these input arguments:
+ *   - t: the test object - to be passed in from a wrapper function
+ *   - isOperator: whether we want to perform the request as an operator or not
+ *   - expectOk: whether we want the request to succeed or fail
+ *   - path: the directory to list
+ *   - params: an object containing the desired query parameters, of the form:
+ *     {
+ *        key1: "value1"
+ *        key2: "value2"
+ *        ...
+ *     }
+ *
+ * This function does not verify that the request returns well-formed results.
+ * See testListWithParams for that.
+ *
+ * Because some query parameters are not exposed through the node-manta client,
+ * we use a lower-level JSON client to perform the request.
+ */
+function testParamsAllowed(t, isOperator, expectOk, path, params) {
+    var queryParams = params || {};
+    var client = helper.createJsonClient();
+
+    var key;
+    var user;
+    if (isOperator) {
+        key = helper.getOperatorPrivkey();
+        user = helper.TEST_OPERATOR;
+    } else {
+        key = helper.getRegularPrivkey();
+        user = process.env.MANTA_USER;
+    }
+    var keyId = helper.getKeyFingerprint(key);
+    var signOpts = {
+        key: key,
+        keyId: keyId,
+        user: user
+    };
+
+    // Perform the ls request, and check the response according to expectOk
+    helper.signRequest(signOpts, function gotSignature(err, authz, date) {
+        var opts = {
+            headers: {
+                authorization: authz,
+                date: date
+            },
+            path: path,
+            query: queryParams
+        };
+        client.get(opts, function (get_err, get_req, get_res) {
+            if (expectOk) {
+                t.ifError(get_err);
+            } else {
+                t.ok(get_err);
+                t.equal(get_err.statusCode, 403);
+                t.equal(get_err.restCode, 'QueryParameterForbidden');
+            }
+            t.end();
+        });
+    });
+}
+
+/*
+ * Verifies that we get well-formed results back when listing the contents of a
+ * dir with the given query parameters. Arguments:
+ *   - t: the test object - to be passed in from a wrapper function
+ *   - params: an object containing the desired query parameters, of the form:
+ *     {
+ *        key1: "value1"
+ *        key2: "value2"
+ *        ...
+ *     }
+ *
+ * This function ensures that the request will be permitted by always performing
+ * the request as an operator, and thus does not test access control. See
+ * testParamsAllowed for that.
+ *
+ * Because some query parameters are not exposed through the node-manta client,
+ * we use a lower-level JSON client to perform the request.
+ */
+function testListWithParams(t, params) {
+    var self = this;
+    var queryParams = params || {};
+    var client = helper.createJsonClient();
+
+    var key = helper.getOperatorPrivkey();
+    var keyId = helper.getKeyFingerprint(key);
+    var user = helper.TEST_OPERATOR;
+    var signOpts = {
+        key: key,
+        keyId: keyId,
+        user: user
+    };
+
+    // Generate some subdirectory names we can read back
+    var subdirs = [];
+    var count = 5;
+    var i;
+    for (i = 0; i < count; i++) {
+        subdirs.push(self.dir + '/' + uuid.v4());
+    }
+    subdirs = subdirs.sort();
+
+
+    // Make the subdirectories
+    vasync.forEachParallel({
+        func: mkdir,
+        inputs: subdirs
+    }, function subdirsCreated(mkdir_err, results) {
+        t.ifError(mkdir_err);
+
+        // Read the subdirectories back with the specified query params
+        helper.signRequest(signOpts, function gotSig(sig_err, authz, date) {
+            t.ifError(sig_err);
+            var opts = {
+                headers: {
+                    authorization: authz,
+                    date: date
+                },
+                path: self.dir,
+                query: queryParams
+            };
+            client.get(opts, function (get_err, get_req, get_res) {
+                t.ifError(get_err);
+
+                // Parse the response body into a list of directory names
+                var jsonStrings = get_res.body.split('\n').filter(isNotEmpty);
+                var names = [];
+                jsonStrings.forEach(function appendName(s) {
+                    t.doesNotThrow(parseAndAppend.bind(null, s, names));
+                });
+                names = names.sort();
+
+                // Verify that we got back all of the directories we created
+                t.deepEqual(subdirs, names.map(prependDir));
+                t.end();
+            });
+        });
+    });
+
+    // helper functions
+
+    function mkdir(path, cb) {
+        self.operatorClient.mkdir(path, function madeDir(err, res) {
+            t.ifError(err);
+            t.ok(res);
+            t.checkResponse(res, 204);
+            cb(err);
+        });
+    }
+
+    function isNotEmpty(str) {
+        return (str !== '');
+    }
+
+    function parseAndAppend(str, list) {
+        list.push(JSON.parse(str).name);
+    }
+
+    function prependDir(name) {
+        return (self.dir + '/' + name);
+    }
+}
+
+
 ///--- Tests
 
 before(function (cb) {
     this.client = helper.createClient();
+    this.operatorClient = helper.createOperatorClient();
     this.top = '/' + this.client.user;
     this.root = this.top + '/stor';
     this.mpuRoot = this.top + '/uploads';
@@ -610,6 +777,69 @@ test('ls 404', function (t) {
 });
 
 
+test('operator can ls with no sort', function (t) {
+    testParamsAllowed(t, true, true, this.root, {
+        sort: 'none'
+    });
+});
+
+
+test('operator can ls with no owner check', function (t) {
+    testParamsAllowed(t, true, true, this.root, {
+        skip_owner_check: 'true'
+    });
+});
+
+
+test('operator can ls with sort and no owner check', function (t) {
+    testParamsAllowed(t, true, true, this.root, {
+        sort: 'none',
+        skip_owner_check: 'true'
+    });
+});
+
+
+test('regular user cannot ls with no sort', function (t) {
+    testParamsAllowed(t, false, false, this.root, {
+        sort: 'none'
+    });
+});
+
+
+test('regular user cannot ls with no owner check', function (t) {
+    testParamsAllowed(t, false, false, this.root, {
+        skip_owner_check: 'true'
+    });
+});
+
+
+test('regular user cannot ls with no sort and no owner check', function (t) {
+    testParamsAllowed(t, false, false, this.root, {
+        sort: 'none',
+        skip_owner_check: 'true'
+    });
+});
+
+test('ls with no sort returns accurate list of results', function (t) {
+    testListWithParams.bind(this)(t, {
+        sort: 'none'
+    });
+});
+
+test('ls with no owner check returns accurate list of results', function (t) {
+    testListWithParams.bind(this)(t, {
+        skip_owner_check: 'true'
+    });
+});
+
+test('ls with no sort and no owner check returns accurate list of results',
+    function (t) {
+    testListWithParams.bind(this)(t, {
+        sort: 'none',
+        skip_owner_check: 'true'
+    });
+});
+
 test('rmdir', function (t) {
     this.client.unlink(this.dir, function (err, res) {
         t.ifError(err);
diff --git a/test/helper.js b/test/helper.js
index 6d2416d..1f183ee 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -20,6 +20,7 @@ var manta = require('manta');
 var once = require('once');
 var restify = require('restify');
 var smartdc = require('smartdc');
+var smartdc_auth = require('smartdc-auth');
 var sshpk = require('sshpk');
 var VError = require('verror').VError;
 
@@ -83,6 +84,10 @@ function getOperatorPrivkey() {
     return (fs.readFileSync(TEST_OPERATOR_KEY, 'utf8'));
 }
 
+function getKeyFingerprint(key) {
+    return (sshpk.parseKey(key, 'auto').fingerprint('md5').toString());
+}
+
 function createLogger(name, stream) {
     var log = bunyan.createLogger({
         level: (process.env.LOG_LEVEL || 'warn'),
@@ -195,7 +200,7 @@ function createSDCClient() {
 
 function createOperatorSDCClient() {
     var key = getOperatorPrivkey();
-    var keyId = sshpk.parseKey(key, 'auto').fingerprint('md5').toString();
+    var keyId = getKeyFingerprint(key);
 
     var log = createLogger();
     var client = smartdc.createClient({
@@ -217,7 +222,7 @@ function createOperatorSDCClient() {
 
 function createOperatorClient() {
     var key = getOperatorPrivkey();
-    var keyId = sshpk.parseKey(key, 'auto').fingerprint('md5').toString();
+    var keyId = getKeyFingerprint(key);
 
     var log = createLogger();
     var client = manta.createClient({
@@ -290,6 +295,30 @@ function createAuthToken(opts, cb) {
 }
 
 
+function signRequest(opts, cb) {
+    var key = opts.key || getRegularPrivkey();
+
+    var sign = manta.privateKeySigner({
+        key: key,
+        keyId: opts.keyId || process.env.MANTA_KEY_ID,
+        user: opts.user || process.env.MANTA_USER
+    });
+
+    var rs = smartdc_auth.requestSigner({
+        sign: sign,
+        mantaSubUser: true
+    });
+
+    var date = rs.writeDateHeader();
+
+    rs.sign(function gotSignature(err, authz) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        cb(null, authz, date);
+    });
+}
 
 function signUrl(opts, expires, cb) {
     if (typeof (opts) === 'string') {
@@ -318,6 +347,7 @@ function signUrl(opts, expires, cb) {
         method: opts.method || 'GET',
         path: opts.path,
         role: opts.role,
+        query: opts.query,
         'role-tag': opts['role-tag'],
         sign: manta.privateKeySigner({
             algorithm: 'rsa-sha256',
@@ -444,6 +474,7 @@ module.exports = {
     },
 
     POSEIDON_ID: POSEIDON_ID,
+    TEST_OPERATOR: TEST_OPERATOR,
     createClient: createClient,
     createJsonClient: createJsonClient,
     createRawClient: createRawClient,
@@ -453,7 +484,11 @@ module.exports = {
     createAuthToken: createAuthToken,
     createOperatorSDCClient: createOperatorSDCClient,
     createOperatorClient: createOperatorClient,
+    signRequest: signRequest,
     signUrl: signUrl,
     getRegularPubkey: getRegularPubkey,
-    getRegularPrivkey: getRegularPrivkey
+    getRegularPrivkey: getRegularPrivkey,
+    getOperatorPubkey: getOperatorPubkey,
+    getOperatorPrivkey: getOperatorPrivkey,
+    getKeyFingerprint: getKeyFingerprint
 };
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index eac7168..6b349fa 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -179,6 +179,7 @@
 +define NotImplementedError
 +define ParentNotDirectoryError
 +define PreSignedRequestError
++define QueryParameterForbiddenError
 +define RequestEntityTooLargeError
 +define ResourceNotFoundError
 +define RootDirectoryError
