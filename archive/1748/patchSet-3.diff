From 0a60379f19841c3203db50186d54aa18f9fffbb7 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 4 Apr 2017 13:36:36 -0700
Subject: [PATCH] joyent/node-sshpk-agent#9 want to sign certificates using
 agent keys

---
 README.md             |  46 +++++++++++
 lib/client.js         | 173 +++++++++++++++++++++++++++++++++++++++++-
 package.json          |   2 +-
 test/basic.test.js    |  71 +++++++++++++++++
 test/key-mgmt.test.js |  54 ++++++++-----
 5 files changed, 323 insertions(+), 23 deletions(-)

diff --git a/README.md b/README.md
index a43b490..e569452 100644
--- a/README.md
+++ b/README.md
@@ -107,6 +107,52 @@ Parameters
   - `error` -- null if no error, otherwise instance of `Error`
   - `signature` -- an Object, instance of `sshpk.Signature`
 
+### `Client#createSelfSignedCertificate(subject, key, options, cb)`
+
+Uses a key stored in the agent to create a self-signed certificate for that
+key. The certificate can be read back in both OpenSSH and X.509 formats.
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `key` -- an Object, instance of `sshpk.Key`, key to sign with and the
+   subject key
+ - `options` -- an Object, additional options, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+     seconds
+   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
+     certificate validity period. If given, `lifetime` will be ignored.
+   - `serial` -- optional Buffer, the serial number of the certificate
+   - `purposes` -- optional Array of String, X.509 key usage restrictions
+ - `callback` -- function `(error, certificate)`, with arguments:
+   - `error` -- null if no error, otherwise instance of `Error`
+   - `certificate` -- an Object, instance of `sshpk.Certificate`
+
+### `Client#createCertificate(subject, subjectKey, issuer, key, options, cb)`
+
+Uses a key stored in the agent to create and sign a certificate for some other
+key (not necessarily in the agent). The certificate can be read back in both
+OpenSSH and X.509 formats.
+
+Parameters
+
+ - `subject` -- an Identity, the subject of the certificate
+ - `subjectKey` -- an Object, instance of `sshpk.Key`, key of the subject
+   entity (does not have to reside in the agent)
+ - `issuer` -- an Identity, the issuer of the certificate
+ - `key` -- an Object, instance of `sshpk.Key`, key to sign with (must be in
+   the agent, and match up with the `issuer` identity)
+ - `options` -- an Object, additional options, with keys:
+   - `lifetime` -- optional Number, lifetime of the certificate from now in
+     seconds
+   - `validFrom`, `validUntil` -- optional Dates, beginning and end of
+     certificate validity period. If given, `lifetime` will be ignored.
+   - `serial` -- optional Buffer, the serial number of the certificate
+   - `purposes` -- optional Array of String, X.509 key usage restrictions
+ - `callback` -- function `(error, certificate)`, with arguments:
+   - `error` -- null if no error, otherwise instance of `Error`
+   - `certificate` -- an Object, instance of `sshpk.Certificate`
+
 ### `Client#addKey(privkey[, options], callback);`
 
 Adds a new private key to the agent.
diff --git a/lib/client.js b/lib/client.js
index dda77c7..3941960 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -4,9 +4,9 @@ var assert = require('assert-plus');
 var sshpk = require('sshpk');
 var sshpkUtils = require('sshpk/lib/utils');
 var util = require('util');
-var errs = require('./errors');
+var errors = require('./errors');
 var SSHBuffer = require('sshpk/lib/ssh-buffer');
-var AgentProtocolError = errs.AgentProtocolError;
+var AgentProtocolError = errors.AgentProtocolError;
 
 var ClientFSM = require('./client-fsm');
 
@@ -180,6 +180,175 @@ Client.prototype.sign = function (key, data, opts, cb) {
 	});
 };
 
+var SIGFORMATS = {
+	'x509': require('sshpk/lib/formats/x509'),
+	'openssh': require('sshpk/lib/formats/openssh-cert')
+};
+
+Client.prototype.signCertificate = function (cert, key, cb) {
+	var signer = this.sign.bind(this, key);
+	var hashAlgo;
+	var done = 0;
+	var errs = [];
+	var fmts = Object.keys(SIGFORMATS);
+
+	/*
+	 * When we ask the agent to sign the certificate, we're going to send
+	 * the RSA-SHA256 flag. The agent may not support this flag, however,
+	 * and so could either give us a SHA1 or a SHA256 signature. We can't
+	 * know until after we ask it to sign something.
+	 *
+	 * Since we have to know which of these is being used in advance for
+	 * x509 certificates (the algorithm in use is part of the signed data),
+	 * ask the agent to sign a dummy value ('test') so we can see whether
+	 * it's going to use SHA1 or SHA256.
+	 */
+	this.sign(key, new Buffer('test', 'ascii'), {}, function (err, sig) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		hashAlgo = sig.hashAlgorithm;
+		doSignatures();
+	});
+
+	function doSignatures() {
+		fmts.forEach(function (fmt) {
+			cert.signatures[fmt] = {};
+			cert.signatures[fmt].algo = key.type + '-' + hashAlgo;
+			SIGFORMATS[fmt].signAsync(cert, signer, function (err) {
+				if (err) {
+					errs.push(err);
+					delete (cert.signatures[fmt]);
+				}
+				if (++done >= fmts.length) {
+					finish();
+				}
+			});
+		});
+	}
+
+	function finish() {
+		if (errs.length >= done) {
+			cb(new Error('Failed to sign the certificate for any ' +
+			    'available certificate formats'));
+			return;
+		}
+		cb();
+	}
+};
+
+function arrayOrArrayOfOne(thingOrThings) {
+	if (Array.isArray(thingOrThings))
+		return (thingOrThings);
+	else
+		return ([thingOrThings]);
+}
+
+Client.prototype.createSelfSignedCertificate =
+    function (subjectOrSubjects, key, options, cb) {
+	var subjects = arrayOrArrayOfOne(subjectOrSubjects);
+	if (options === undefined)
+		options = {};
+	options.ca = true;
+	this.createCertificate(subjects, key, subjects[0], key, options, cb);
+};
+
+Client.prototype.createCertificate =
+    function (subjectOrSubjects, key, issuer, issuerKey, options, cb) {
+	var subjects = arrayOrArrayOfOne(subjectOrSubjects);
+
+	assert.arrayOfObject(subjects);
+	subjects.forEach(function (subject) {
+		sshpkUtils.assertCompatible(subject, sshpk.Identity, [1, 0],
+		    'subject');
+	});
+
+	sshpkUtils.assertCompatible(key, sshpk.Key, [1, 0], 'key');
+	if (sshpk.PrivateKey.isPrivateKey(key))
+		key = key.toPublic();
+	sshpkUtils.assertCompatible(issuer, sshpk.Identity, [1, 0], 'issuer');
+	sshpkUtils.assertCompatible(issuerKey, sshpk.Key, [1, 0], 'issuer key');
+
+	assert.optionalObject(options, 'options');
+	if (options === undefined)
+		options = {};
+	assert.optionalObject(options.validFrom, 'options.validFrom');
+	assert.optionalObject(options.validUntil, 'options.validUntil');
+	var validFrom = options.validFrom;
+	var validUntil = options.validUntil;
+	if (validFrom === undefined)
+		validFrom = new Date();
+	if (validUntil === undefined) {
+		assert.optionalNumber(options.lifetime, 'options.lifetime');
+		var lifetime = options.lifetime;
+		if (lifetime === undefined)
+			lifetime = 10*365*24*3600;
+		validUntil = new Date();
+		validUntil.setTime(validUntil.getTime() + lifetime*1000);
+	}
+	assert.optionalBuffer(options.serial, 'options.serial');
+	var serial = options.serial;
+	if (serial === undefined)
+		serial = new Buffer('0000000000000001', 'hex');
+
+	var purposes = options.purposes;
+	if (purposes === undefined)
+		purposes = [];
+
+	if (purposes.indexOf('signature') === -1)
+		purposes.push('signature');
+
+	if (options.ca === true) {
+		if (purposes.indexOf('ca') === -1)
+			purposes.push('ca');
+		if (purposes.indexOf('crl') === -1)
+			purposes.push('crl');
+	}
+
+	var hostSubjects = subjects.filter(function (subject) {
+		return (subject.type === 'host');
+	});
+	var userSubjects = subjects.filter(function (subject) {
+		return (subject.type === 'user');
+	});
+	if (hostSubjects.length > 0) {
+		if (purposes.indexOf('serverAuth') === -1)
+			purposes.push('serverAuth');
+	}
+	if (userSubjects.length > 0) {
+		if (purposes.indexOf('clientAuth') === -1)
+			purposes.push('clientAuth');
+	}
+	if (userSubjects.length > 0 || hostSubjects.length > 0) {
+		if (purposes.indexOf('keyAgreement') === -1)
+			purposes.push('keyAgreement');
+		if (key.type === 'rsa' &&
+		    purposes.indexOf('encryption') === -1)
+			purposes.push('encryption');
+	}
+
+	var cert = new sshpk.Certificate({
+		subjects: subjects,
+		issuer: issuer,
+		subjectKey: key,
+		issuerKey: issuerKey,
+		signatures: {},
+		serial: serial,
+		validFrom: validFrom,
+		validUntil: validUntil,
+		purposes: purposes
+	});
+
+	this.signCertificate(cert, issuerKey, function (err) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		cb(null, cert);
+	});
+};
+
 /*
  * The agent protocol encodes the private keys that go with a given certificate
  * as simply the private-only parts of the key appended to the certificate
diff --git a/package.json b/package.json
index eca42bc..4e17c1c 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "sshpk-agent",
-  "version": "1.5.0",
+  "version": "1.6.0",
   "description": "ssh-agent client for use with sshpk",
   "main": "lib/index.js",
   "scripts": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 84d4f9e..82986d7 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -268,6 +268,77 @@ test('Client can sign data with an ecdsa key', function (t) {
 	});
 });
 
+test('Client can create rsa certificates', function (t) {
+	var c = new sshpkAgent.Client();
+	c.listKeys(function (err, keys) {
+		t.error(err);
+
+		var key = keys[0];
+		t.strictEqual(key.type, 'rsa');
+		t.ok(ID_RSA_FP.matches(key));
+
+		var id = sshpk.identityForHost('foo.com');
+		var opts = {};
+		c.createSelfSignedCertificate(id, key, opts,
+		    function (err, cert) {
+			t.error(err);
+			t.ok(cert);
+			t.ok(cert instanceof sshpk.Certificate);
+
+			t.strictEqual(cert.subjects[0].hostname, 'foo.com');
+			t.ok(cert.isSignedByKey(key));
+
+			if (ver >= [7, 0, 1]) {
+				var sig = cert.signatures.x509.signature;
+				t.strictEqual(sig.hashAlgorithm, 'sha256');
+			}
+
+			var ssh = cert.toBuffer('openssh');
+			var cert2 = sshpk.parseCertificate(ssh, 'openssh');
+			t.ok(cert2.isSignedByKey(key));
+
+			var pem = cert.toBuffer('pem');
+			var cert3 = sshpk.parseCertificate(pem, 'pem');
+			t.ok(cert3.isSignedByKey(key));
+
+			t.end();
+		});
+	});
+});
+
+test('Client can create ecdsa certificates', function (t) {
+	var c = new sshpkAgent.Client();
+	c.listKeys(function (err, keys) {
+		t.error(err);
+
+		var key = keys[1];
+		t.strictEqual(key.type, 'ecdsa');
+		t.ok(ID_ECDSA_FP.matches(key));
+
+		var id = sshpk.identityForHost('foobar.com');
+		var opts = {};
+		c.createSelfSignedCertificate(id, key, opts,
+		    function (err, cert) {
+			t.error(err);
+			t.ok(cert);
+			t.ok(cert instanceof sshpk.Certificate);
+
+			t.strictEqual(cert.subjects[0].hostname, 'foobar.com');
+			t.ok(cert.isSignedByKey(key));
+
+			var ssh = cert.toBuffer('openssh');
+			var cert2 = sshpk.parseCertificate(ssh, 'openssh');
+			t.ok(cert2.isSignedByKey(key));
+
+			var pem = cert.toBuffer('pem');
+			var cert3 = sshpk.parseCertificate(pem, 'pem');
+			t.ok(cert3.isSignedByKey(key));
+
+			t.end();
+		});
+	});
+});
+
 var usedEd = false;
 
 if (ver >= [6, 5, 1]) {
diff --git a/test/key-mgmt.test.js b/test/key-mgmt.test.js
index e9ef52b..8ab5af8 100644
--- a/test/key-mgmt.test.js
+++ b/test/key-mgmt.test.js
@@ -98,39 +98,53 @@ test('Client can add an ECDSA key', function (t) {
 	});
 });
 
+var ver = Agent.getVersion();
+if (ver === undefined)
+	ver = [0, 0, 0];
+else
+	console.log('using OpenSSH version %d.%dp%d', ver[0], ver[1], ver[2]);
+
 test('Client can add an RSA certificate', function (t) {
 	var pem = fs.readFileSync(path.join(testDir, 'id_rsa'));
 	var pk = sshpk.parsePrivateKey(pem, 'pem', 'test/id_rsa');
+	var pubk = pk.toPublic();
 	var id = sshpk.identityForHost('testing.rsa');
-	var cert = sshpk.createSelfSignedCertificate(id, pk);
-	client.addCertificate(cert, pk, function (err) {
+	var opts = {};
+
+	client.createSelfSignedCertificate(id, pubk, opts,
+	    function (err, cert) {
 		t.error(err);
+		t.ok(cert);
 
-		client.listKeys(function (err, keys) {
+		if (ver >= [7, 0, 1]) {
+			var sig = cert.signatures.x509.signature;
+			t.strictEqual(sig.hashAlgorithm, 'sha256');
+		}
+
+		client.addCertificate(cert, pk, function (err) {
 			t.error(err);
-			t.equal(keys.length, 3);
 
-			client.listCertificates(function (err2, certs) {
-				t.error(err2);
-				t.equal(certs.length, 1);
-				t.strictEqual(certs[0].subjects[0].type,
-				    'host');
-				t.strictEqual(certs[0].subjects[0].hostname,
-				    'testing.rsa');
-				t.ok(ID_RSA_FP.matches(certs[0].subjectKey),
-				    'fingerprint matches cert key');
-				t.end();
+			client.listKeys(function (err, keys) {
+				t.error(err);
+				t.equal(keys.length, 3);
+
+				client.listCertificates(function (err2, certs) {
+					t.error(err2);
+					t.equal(certs.length, 1);
+					t.strictEqual(
+					    certs[0].subjects[0].type, 'host');
+					t.strictEqual(
+					    certs[0].subjects[0].hostname,
+					    'testing.rsa');
+					t.ok(certs[0].isSignedByKey(pubk),
+					    'valid signature');
+					t.end();
+				});
 			});
 		});
 	});
 });
 
-var ver = Agent.getVersion();
-if (ver === undefined)
-	ver = [0, 0, 0];
-else
-	console.log('using OpenSSH version %d.%dp%d', ver[0], ver[1], ver[2]);
-
 test('Client can add an ECDSA certificate', function (t) {
 	var pem = fs.readFileSync(path.join(testDir, 'id_ecdsa'));
 	var pk = sshpk.parsePrivateKey(pem, 'pem', 'test/id_ecdsa');
-- 
2.21.0

