commit 57f16536342519e1ba74a8df45106a9ad5731849
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2019-05-08T14:52:24+00:00 (5 months ago)
    
    OS-7777 simplify bhyve vlapic ESR logic

diff --git a/usr/src/uts/i86pc/io/vmm/io/vlapic.c b/usr/src/uts/i86pc/io/vmm/io/vlapic.c
index 64e34b7532..4c38672b73 100644
--- a/usr/src/uts/i86pc/io/vmm/io/vlapic.c
+++ b/usr/src/uts/i86pc/io/vmm/io/vlapic.c
@@ -91,6 +91,9 @@ __FBSDID("$FreeBSD$");
  */
 #define VLAPIC_BUS_FREQ		(128 * 1024 * 1024)
 
+static void vlapic_set_error(struct vlapic *vlapic, uint32_t mask);
+
+
 static __inline uint32_t
 vlapic_get_id(struct vlapic *vlapic)
 {
@@ -455,7 +458,7 @@ vlapic_mask_lvts(struct vlapic *vlapic)
 }
 
 static int
-vlapic_fire_lvt(struct vlapic *vlapic, uint32_t lvt)
+vlapic_fire_lvt(struct vlapic *vlapic, uint32_t lvt, bool is_error)
 {
 	uint32_t vec, mode;
 
@@ -468,7 +471,14 @@ vlapic_fire_lvt(struct vlapic *vlapic, uint32_t lvt)
 	switch (mode) {
 	case APIC_LVT_DM_FIXED:
 		if (vec < 16) {
-			vlapic_set_error(vlapic, APIC_ESR_SEND_ILLEGAL_VECTOR);
+			/*
+			 * Do not (infinitely) recurse if the error LVT itself
+			 * is configured with an invalid vector.
+			 */
+			if (!is_error) {
+				vlapic_set_error(vlapic,
+				    APIC_ESR_SEND_ILLEGAL_VECTOR);
+			}
 			return (0);
 		}
 		if (vlapic_set_intr_ready(vlapic, vec, false))
@@ -629,22 +639,18 @@ vlapic_periodic_timer(struct vlapic *vlapic)
 
 static VMM_STAT(VLAPIC_INTR_ERROR, "error interrupts generated by vlapic");
 
-void
+static void
 vlapic_set_error(struct vlapic *vlapic, uint32_t mask)
 {
 	uint32_t lvt;
 
 	vlapic->esr_pending |= mask;
-	if (vlapic->esr_firing)
-		return;
-	vlapic->esr_firing = 1;
 
 	// The error LVT always uses the fixed delivery mode.
 	lvt = vlapic_get_lvt(vlapic, APIC_OFFSET_ERROR_LVT);
-	if (vlapic_fire_lvt(vlapic, lvt | APIC_LVT_DM_FIXED)) {
+	if (vlapic_fire_lvt(vlapic, lvt | APIC_LVT_DM_FIXED, true)) {
 		vmm_stat_incr(vlapic->vm, vlapic->vcpuid, VLAPIC_INTR_ERROR, 1);
 	}
-	vlapic->esr_firing = 0;
 }
 
 static VMM_STAT(VLAPIC_INTR_TIMER, "timer interrupts generated by vlapic");
@@ -655,10 +661,10 @@ vlapic_fire_timer(struct vlapic *vlapic)
 	uint32_t lvt;
 
 	KASSERT(VLAPIC_TIMER_LOCKED(vlapic), ("vlapic_fire_timer not locked"));
-	
+
 	// The timer LVT always uses the fixed delivery mode.
 	lvt = vlapic_get_lvt(vlapic, APIC_OFFSET_TIMER_LVT);
-	if (vlapic_fire_lvt(vlapic, lvt | APIC_LVT_DM_FIXED)) {
+	if (vlapic_fire_lvt(vlapic, lvt | APIC_LVT_DM_FIXED, false)) {
 		VLAPIC_CTR0(vlapic, "vlapic timer fired");
 		vmm_stat_incr(vlapic->vm, vlapic->vcpuid, VLAPIC_INTR_TIMER, 1);
 	}
@@ -673,7 +679,7 @@ vlapic_fire_cmci(struct vlapic *vlapic)
 	uint32_t lvt;
 
 	lvt = vlapic_get_lvt(vlapic, APIC_OFFSET_CMCI_LVT);
-	if (vlapic_fire_lvt(vlapic, lvt)) {
+	if (vlapic_fire_lvt(vlapic, lvt, false)) {
 		vmm_stat_incr(vlapic->vm, vlapic->vcpuid, VLAPIC_INTR_CMC, 1);
 	}
 }
@@ -732,7 +738,7 @@ vlapic_trigger_lvt(struct vlapic *vlapic, int vector)
 	default:
 		return (EINVAL);
 	}
-	if (vlapic_fire_lvt(vlapic, lvt)) {
+	if (vlapic_fire_lvt(vlapic, lvt, false)) {
 		vmm_stat_array_incr(vlapic->vm, vlapic->vcpuid,
 		    LVTS_TRIGGERRED, vector, 1);
 	}
diff --git a/usr/src/uts/i86pc/io/vmm/io/vlapic.h b/usr/src/uts/i86pc/io/vmm/io/vlapic.h
index a177b984ce..b7fb918b0f 100644
--- a/usr/src/uts/i86pc/io/vmm/io/vlapic.h
+++ b/usr/src/uts/i86pc/io/vmm/io/vlapic.h
@@ -75,7 +75,6 @@ int vlapic_set_intr_ready(struct vlapic *vlapic, int vector, bool level);
  */
 void vlapic_post_intr(struct vlapic *vlapic, int hostcpu, int ipinum);
 
-void vlapic_set_error(struct vlapic *vlapic, uint32_t mask);
 void vlapic_fire_cmci(struct vlapic *vlapic);
 int vlapic_trigger_lvt(struct vlapic *vlapic, int vector);
 
diff --git a/usr/src/uts/i86pc/io/vmm/io/vlapic_priv.h b/usr/src/uts/i86pc/io/vmm/io/vlapic_priv.h
index 43abd20a0a..fe7965cb65 100644
--- a/usr/src/uts/i86pc/io/vmm/io/vlapic_priv.h
+++ b/usr/src/uts/i86pc/io/vmm/io/vlapic_priv.h
@@ -156,7 +156,6 @@ struct vlapic {
 	struct vlapic_ops	ops;
 
 	uint32_t		esr_pending;
-	int			esr_firing;
 
 	struct callout	callout;	/* vlapic timer */
 	struct bintime	timer_fire_bt;	/* callout expiry time */
