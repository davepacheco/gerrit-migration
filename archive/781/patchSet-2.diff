From 2419ebf63f989d0701cc5ee9108899f6d11b803a Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 25 Oct 2016 16:34:14 -0700
Subject: [PATCH] joyent/node-cueball#14 leaked event handler warning on node
 >=4.x Reviewed by: Robert Mustacchi <rm@joyent.com>

---
 lib/connection-fsm.js | 48 ++++++++++++++++++++++++++++++++++---------
 1 file changed, 38 insertions(+), 10 deletions(-)

diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 8cdacb9..5f778e9 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -363,15 +363,28 @@ ConnectionFSM.prototype.state_idle = function (S) {
 	}
 
 	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var newCount = self.cf_conn.listeners(evt).filter(
-		    function (h) { return (typeof (h) === 'function'); }).
-		    length;
+		var newCount = countListeners(self.cf_conn, evt);
 		var oldCount = self.cf_oldListeners[evt];
 		if (oldCount !== undefined && newCount > oldCount) {
 			var info = {};
 			info.stack = self.cf_releaseStack;
+			info.countBeforeClaim = oldCount;
+			info.countAfterRelease = newCount;
 			info.handlers = self.cf_conn.listeners(evt).map(
-			    function (f) { return (f.toString()); });
+			    function (f) {
+				/*
+				 * node's EventEmitter#once function is actually
+				 * equivalent to calling #on() with a wrapper
+				 * function named 'g'. #once() sets up a
+				 * property 'listener' on these wrappers, which
+				 * points at the original handler. It's much
+				 * more useful for the user to see the original
+				 * function than the 'g'.
+				 */
+				if (f.name === 'g' && f.listener)
+					return (f.listener.toString());
+				return (f.toString());
+			});
 			info.event = evt;
 			self.cf_log.warn(info, 'connection claimer looks ' +
 			    'like it leaked event handlers');
@@ -462,9 +475,7 @@ ConnectionFSM.prototype.state_ping = function (S) {
 	 */
 	this.cf_oldListeners = {};
 	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var count = self.cf_conn.listeners(evt).filter(
-		    function (h) { return (typeof (h) === 'function'); }).
-		    length;
+		var count = countListeners(self.cf_conn, evt);
 		self.cf_oldListeners[evt] = count;
 	});
 
@@ -517,6 +528,25 @@ ConnectionFSM.prototype.state_ping = function (S) {
 	});
 };
 
+function countListeners(eve, event) {
+	var ls = eve.listeners(event);
+	ls = ls.filter(function (h) {
+		if (typeof (h) !== 'function')
+			return (false);
+		/*
+		 * Ignore a #once() called freeSocketErrorListener -- in node
+		 * v4 and later this is always present as a debugging aide, set
+		 * up by the http client framework.
+		 */
+		if (h.name === 'g' && h.listener &&
+		    h.listener.name === 'freeSocketErrorListener') {
+			return (false);
+		}
+		return (true);
+	});
+	return (ls.length);
+}
+
 ConnectionFSM.prototype.state_busy = function (S) {
 	S.validTransitions(['error', 'closed', 'idle']);
 	var self = this;
@@ -533,9 +563,7 @@ ConnectionFSM.prototype.state_busy = function (S) {
 	 */
 	this.cf_oldListeners = {};
 	['close', 'error', 'readable', 'data'].forEach(function (evt) {
-		var count = self.cf_conn.listeners(evt).filter(
-		    function (h) { return (typeof (h) === 'function'); }).
-		    length;
+		var count = countListeners(self.cf_conn, evt);
 		self.cf_oldListeners[evt] = count;
 	});
 
-- 
2.21.0

