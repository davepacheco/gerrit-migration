From 3c004342688abc98ede2eeb97b04cb6e1bc0f0ff Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Mon, 31 Jul 2017 14:45:49 -0700
Subject: [PATCH] joyent/node-cueball#116 timeout on SRV should avoid
 triggering fallback to A/AAAA joyent/node-cueball#115 handle REFUSED
 responses as name not known

---
 lib/resolver.js | 134 ++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 119 insertions(+), 15 deletions(-)

diff --git a/lib/resolver.js b/lib/resolver.js
index c19e59a..59bd68c 100644
--- a/lib/resolver.js
+++ b/lib/resolver.js
@@ -259,10 +259,18 @@ function CueBallDNSResolver(options) {
 		this.r_isBootstrap = true;
 
 	if (this.r_isBootstrap) {
+		/*
+		 * If we're a bootstrap resolver, then we want to look up
+		 * the DNS service itself, and try all possible resolvers.
+		 */
 		this.r_service = '_dns._udp';
 		this.r_defport = 53;
 		this.r_maxres = 10;
 		this.r_refCount = 0;
+		/*
+		 * We might have lots of downstream resolvers, so we do this to
+		 * stop node warning about "leaked" event handlers.
+		 */
 		this.setMaxListeners(500);
 	}
 
@@ -289,6 +297,10 @@ function CueBallDNSResolver(options) {
 	mod_utils.assertRecovery(dnsSrvRecov, 'recovery.dns_srv');
 	mod_utils.assertRecovery(dnsRecov, 'recovery.dns');
 
+	/*
+	 * These are used to stash our actual current retry timeout etc.
+	 * for SRV versus all other operations
+	 */
 	this.r_srvRetry = {
 		max: dnsSrvRecov.retries,
 		count: dnsSrvRecov.retries,
@@ -307,16 +319,56 @@ function CueBallDNSResolver(options) {
 		maxDelay: dnsRecov.maxDelay || Infinity
 	};
 
+	/*
+	 * nextService, nextV6 and nextV4 are used to stash Date objects
+	 * representing the time at which we should next try to resolve SRV,
+	 * AAAA and A records for our target name, respectively.
+	 *
+	 * Normally these will end up reflecting the TTL expiry of the last
+	 * records we saw, but in error cases they can represent our next
+	 * attempt time instead.
+	 */
 	this.r_nextService = new Date();
 	this.r_nextV6 = new Date();
 	this.r_nextV4 = new Date();
 
+	/*
+	 * Keep track of the last SRV TTL we saw -- we'll use this in the case
+	 * where we already know we have SRV records but all our resolvers are
+	 * down, as our retry timeout.
+	 */
+	this.r_lastSrvTtl = 60;
+
 	this.r_lastError = undefined;
 
+	/*
+	 * List of "srv" objects (our prototypes for the backends we'll
+	 * eventually emit). We use these as a common interface between the SRV
+	 * and AAAA/A resolution steps. If SRV fails, we generate a single "srv"
+	 * object with just the root name on it. If SRV succeeds, this is the
+	 * full set of backends we got from the results. The SRV lookup may not
+	 * necessarily have additional records giving us the IP addresses for
+	 * each backend, and we might need to do further AAAA/A lookups to
+	 * determine these after our SRV.
+	 */
 	this.r_srvs = [];
+
+	/*
+	 * Used by A/AAAA lookups: remaining "srv" objects we haven't
+	 * finished resolving yet.
+	 */
 	this.r_srvRem = [];
+
+	/* Used by A/AAAA: current srv object */
 	this.r_srv = undefined;
+
+	/* Index of backends we've emitted */
 	this.r_backends = {};
+
+	/*
+	 * Our bootstrap, if any -- an upstream Resolver instance that's
+	 * emitting updates to the set of DNS servers we should be using.
+	 */
 	this.r_bootstrap = undefined;
 	this.r_bootstrapRes = {};
 
@@ -468,6 +520,7 @@ CueBallDNSResolver.prototype.state_srv_try = function (S) {
 		var d = new Date();
 		d.setTime(d.getTime() + 1000*ttl);
 		self.r_nextService = d;
+		self.r_lastSrvTtl = ttl;
 
 		var oldLookup = {};
 		self.r_srvs.forEach(function (srv) {
@@ -508,19 +561,42 @@ CueBallDNSResolver.prototype.state_srv_try = function (S) {
 				port: self.r_defport
 			} ];
 
-			/*
-			 * Don't bother retrying SRV lookups for at least 60
-			 * minutes -- there probably aren't any available.
-			 */
 			var d = new Date();
-			d.setTime(d.getTime() + 1000*60*60);
+			if (err.code === 'NOTIMP') {
+				/*
+				 * Don't bother retrying SRV lookups for at
+				 * least 60 minutes -- our nameserver said it
+				 * doesn't support SRV at all and this isn't
+				 * likely to change quickly.
+				 */
+				self.r_log.trace('nameserver returned NOTIMP ' +
+				    'to SRV lookup on %s, will not retry SRV ' +
+				    'for 60 min', self.r_service);
+				d.setTime(d.getTime() + 1000*60*60);
+			} else {
+				/*
+				 * TODO: rework the client code so this can
+				 * respect a timeout in a SOA record in
+				 * NXDOMAIN responses (binder doesn't send
+				 * these)
+				 */
+				d.setTime(d.getTime() + 1000*60);
+			}
 			self.r_nextService = d;
 
 			self.r_log.trace('no SRV records found for service ' +
-			    '%s, treating as a plain name for next 60min',
-			    self.r_service);
+			    '%s, trying as a plain name', self.r_service);
 
 			S.gotoState('aaaa');
+
+		} else if (err.code === 'REFUSED') {
+			/*
+			 * Usually sent by an authoritative nameserver to a
+			 * recursive query about a name that is not in its
+			 * area of authority. Retrying this is pointless.
+			 */
+			self.r_srvRetry.count = 0;
+			S.gotoState('srv_error');
 		} else {
 			S.gotoState('srv_error');
 		}
@@ -543,7 +619,7 @@ CueBallDNSResolver.prototype.state_srv_error = function (S) {
 	} else {
 		self.r_log.trace({ err: self.r_lastError },
 		    'repeated error during SRV resolution for service %s, ' +
-		    'will retry in 5min', self.r_service);
+		    'will retry in %d sec', self.r_service, self.r_lastSrvTtl);
 
 		self.r_srvs = [ {
 			name: self.r_domain,
@@ -551,15 +627,24 @@ CueBallDNSResolver.prototype.state_srv_error = function (S) {
 		} ];
 
 		/*
-		 * Retry in 5 mins, but proceed on through -- just in case
-		 * our resolvers are giving us some error on SRV lookups
-		 * (e.g. because they don't implement the record type).
+		 * Retry in one TTL. Don't proceed to try A/AAAA lookups, to
+		 * avoid flapping back and forth between SRV and A/AAAA mode
+		 * on a service.
 		 */
 		var d = new Date();
-		d.setTime(d.getTime() + 1000*60*5);
+		d.setTime(d.getTime() + 1000*self.r_lastSrvTtl);
 		self.r_nextService = d;
 
-		S.gotoState('aaaa');
+		/*
+		 * Make sure the next time we wake up is for SRV still, not
+		 * A or AAAA.
+		 */
+		if (self.r_nextV6.getTime() < d.getTime())
+			self.r_nextV6 = d;
+		if (self.r_nextV4.getTime() < d.getTime())
+			self.r_nextV4 = d;
+
+		S.gotoState('sleep');
 	}
 };
 
@@ -655,8 +740,7 @@ CueBallDNSResolver.prototype.state_aaaa_try = function (S) {
 		S.gotoState('aaaa_next');
 	});
 	S.on(req, 'error', function (err) {
-		if (NoRecordsError.isInstance(err) ||
-		    err.code === 'NOTIMP') {
+		if (NoRecordsError.isInstance(err) || err.code === 'NOTIMP') {
 			/*
 			 * If we got NoRecordsError (NODATA), we probably have
 			 * a name that has no AAAA but has A records, so we
@@ -673,6 +757,14 @@ CueBallDNSResolver.prototype.state_aaaa_try = function (S) {
 			srv.expiry_v6 = d;
 			S.gotoState('aaaa_next');
 			return;
+
+		} else if (err.code === 'REFUSED') {
+			/*
+			 * Usually sent by an authoritative nameserver to a
+			 * recursive query about a name that is not in its
+			 * area of authority. Retrying this is pointless.
+			 */
+			self.r_retry.count = 0;
 		}
 		self.r_lastError = err;
 		S.gotoState('aaaa_error');
@@ -787,6 +879,13 @@ CueBallDNSResolver.prototype.state_a_try = function (S) {
 			 * any record type. This isn't a retryable error.
 			 */
 			self.r_retry.count = 0;
+		} else if (err.code === 'REFUSED') {
+			/*
+			 * Usually sent by an authoritative nameserver to a
+			 * recursive query about a name that is not in its
+			 * area of authority. Retrying this is pointless.
+			 */
+			self.r_retry.count = 0;
 		}
 		self.r_lastError = err;
 		S.gotoState('a_error');
@@ -812,6 +911,11 @@ CueBallDNSResolver.prototype.state_a_error = function (S) {
 		    'proceeding', self.r_srv.name);
 
 		var d = new Date();
+		/*
+		 * TODO: rework the client code so this can respect a timeout in
+		 * a SOA record in NXDOMAIN responses (not urgent, binder
+		 * doesn't send these)
+		 */
 		d.setTime(d.getTime() + 1000*60);
 		if (self.r_nextV4 === undefined || d <= self.r_nextV4)
 			self.r_nextV4 = d;
-- 
2.21.0

