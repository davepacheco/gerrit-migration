commit b610d838f296e5b5680c20b43d374b60828e458e (refs/changes/14/5314/5)
Author: Kody A Kantor <kody@kkantor.com>
Date:   2019-01-11T21:42:49+00:00 (9 months ago)
    
    OS-6602 ZFS not detecting faulty spares in a timely manner
    OS-7499 ZFS retire agent cannot fault inactive spares

diff --git a/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c b/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
index d1206a34d3..2b0c0d48e5 100644
--- a/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
+++ b/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
@@ -22,6 +22,7 @@
 /*
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <assert.h>
@@ -627,7 +628,8 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			pool_found = B_TRUE;
 			pool_load = zcp->zc_when;
 		}
-		if (zcp->zc_data.zc_vdev_guid == vdev_guid)
+		if (zcp->zc_data.zc_vdev_guid == vdev_guid &&
+		    zcp->zc_data.zc_pool_guid == pool_guid)
 			break;
 	}
 
diff --git a/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c b/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
index 4856676d7d..e2d1a6831a 100644
--- a/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
+++ b/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -121,13 +122,21 @@ find_vdev(libzfs_handle_t *zhdl, nvlist_t *nv, const char *search_fru,
 	}
 
 	if (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,
-	    &child, &children) != 0)
-		return (NULL);
+	    &child, &children) == 0) {
+		for (c = 0; c < children; c++) {
+			if ((ret = find_vdev(zhdl, child[c], search_fru,
+			    search_guid)) != NULL)
+				return (ret);
+		}
+	}
 
-	for (c = 0; c < children; c++) {
-		if ((ret = find_vdev(zhdl, child[c], search_fru,
-		    search_guid)) != NULL)
-			return (ret);
+	if (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,
+	    &child, &children) == 0) {
+		for (c = 0; c < children; c++) {
+			if ((ret = find_vdev(zhdl, child[c], search_fru,
+			    search_guid)) != NULL)
+				return (ret);
+		}
 	}
 
 	return (NULL);
diff --git a/usr/src/lib/libzfs/common/libzfs_pool.c b/usr/src/lib/libzfs/common/libzfs_pool.c
index 56e1d7032e..6cce9e22aa 100644
--- a/usr/src/lib/libzfs/common/libzfs_pool.c
+++ b/usr/src/lib/libzfs/common/libzfs_pool.c
@@ -2798,7 +2798,7 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 	zfs_cmd_t zc = { 0 };
 	char msg[1024];
 	int ret;
-	nvlist_t *tgt;
+	nvlist_t *tgt, *newvd;
 	boolean_t avail_spare, l2cache, islog;
 	uint64_t val;
 	char *newname;
@@ -2842,14 +2842,14 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 	if ((newname = zpool_vdev_name(NULL, NULL, child[0], B_FALSE)) == NULL)
 		return (-1);
 
+	newvd = zpool_find_vdev(zhp, newname, &avail_spare, &l2cache, NULL);
 	/*
 	 * If the target is a hot spare that has been swapped in, we can only
 	 * replace it with another hot spare.
 	 */
 	if (replacing &&
 	    nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_IS_SPARE, &val) == 0 &&
-	    (zpool_find_vdev(zhp, newname, &avail_spare, &l2cache,
-	    NULL) == NULL || !avail_spare) &&
+	    (newvd == NULL || !avail_spare) &&
 	    is_replacing_spare(config_root, tgt, 1)) {
 		zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
 		    "can only be replaced by another hot spare"));
@@ -2859,6 +2859,11 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 
 	free(newname);
 
+	if (replacing && avail_spare && !vdev_online(newvd)) {
+		(void) zpool_standard_error(hdl, ENXIO, msg);
+		return (-1);
+	}
+
 	if (zcmd_write_conf_nvlist(hdl, &zc, nvroot) != 0)
 		return (-1);
 
diff --git a/usr/src/test/zfs-tests/include/libtest.shlib b/usr/src/test/zfs-tests/include/libtest.shlib
index 6e7f5210a1..3456992370 100644
--- a/usr/src/test/zfs-tests/include/libtest.shlib
+++ b/usr/src/test/zfs-tests/include/libtest.shlib
@@ -322,7 +322,7 @@ function default_mirror_setup_noexit
 	[[ -z $secondary ]] && \
 		log_fail "$func: No secondary partition passed"
 	[[ -d /$TESTPOOL ]] && rm -rf /$TESTPOOL
-	log_must zpool create -f $TESTPOOL mirror $@
+	log_must zpool create -f $TESTPOOL mirror $primary $secondary
 	log_must zfs create $TESTPOOL/$TESTFS
 	log_must zfs set mountpoint=$TESTDIR $TESTPOOL/$TESTFS
 }
diff --git a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
index 51dfd8107b..f558254a90 100644
--- a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
@@ -28,7 +28,7 @@
 . $STF_SUITE/include/libtest.shlib
 
 verify_runnable "global"
-verify_disk_count "$DISKS" 2
+verify_disk_count "$DISKS" 3
 
 DISK=${DISKS%% *}
 
diff --git a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh
new file mode 100644
index 0000000000..fde508254c
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh
@@ -0,0 +1,51 @@
+#!/usr/bin/ksh -p
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+
+#
+# DESCRIPTION:
+#
+# zpool replace returns an error when spare device is faulted.
+#
+# STRATEGY:
+# 1. Add hot spare to pool
+# 2. Fault the hot spare device
+# 3. Attempt to replace a device in a pool with the faulted spare
+# 4. Verify the 'zpool replace' command fails
+#
+
+SPARE=${DISKS##* }
+DISK=${DISKS%% *}
+
+verify_runnable "global"
+log_must zpool add $TESTPOOL spare $SPARE
+log_assert "zpool replace returns an error when the hot spare is faulted"
+
+log_must zinject -d $SPARE -A fault $TESTPOOL
+log_mustnot zpool replace $TESTPOOL $DISK $SPARE
+
+log_pass "zpool replace returns an error when the hot spare is faulted"
diff --git a/usr/src/uts/common/fs/zfs/spa_misc.c b/usr/src/uts/common/fs/zfs/spa_misc.c
index 8ba49fed41..65e698b0fc 100644
--- a/usr/src/uts/common/fs/zfs/spa_misc.c
+++ b/usr/src/uts/common/fs/zfs/spa_misc.c
@@ -26,6 +26,7 @@
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  * Copyright (c) 2017 Datto Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/zfs_context.h>
@@ -238,6 +239,8 @@ static avl_tree_t spa_l2cache_avl;
 kmem_cache_t *spa_buffer_pool;
 int spa_mode_global;
 
+uint_t spa_spare_poll_interval_seconds = 60 * 60 * 24; /* One day */
+
 #ifdef ZFS_DEBUG
 /*
  * Everything except dprintf, spa, and indirect_remap is on by default
@@ -1009,6 +1012,101 @@ spa_aux_activate(vdev_t *vd, avl_tree_t *avl)
  * be completely consistent with respect to other vdev configuration changes.
  */
 
+static kthread_t *spare_poll_thread;
+static kmutex_t spare_poll_lock;
+static kcondvar_t spare_poll_cv;
+static boolean_t spare_poll_cancel;
+
+
+/*
+ * Poll the spare vdevs to make sure they are not faulty.
+ *
+ * vdev_probe will raise an ENXIO error and create an FM ereport if the probe
+ * fails.
+ */
+static void
+spa_spare_poll_thread(void *arg)
+{
+	spa_aux_t *aux;
+	spa_t *spa = NULL;
+	vdev_t *vd;
+	int zio_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_DONT_RETRY;
+
+	while (!spare_poll_cancel) {
+		zio_t *pio = NULL;
+		mutex_enter(&spa_spare_lock);
+		for (aux = avl_first(&spa_spare_avl); aux != NULL;
+		    aux = AVL_NEXT(&spa_spare_avl, aux)) {
+			/* This spare is in use by a pool. */
+			if (aux->aux_pool != NULL)
+			    continue;
+
+			/*
+			 * Probe all occurrences of each spare vdev to ensure
+			 * all pools fault their spares properly if they are
+			 * inaccessible.
+			 */
+			while ((spa = spa_next(spa)) != NULL) {
+				if ((vd = spa_lookup_by_guid(spa, aux->aux_guid,
+				    B_TRUE)) != NULL) {
+					if (pio == NULL) {
+						pio = zio_root(spa, NULL, NULL,
+						    zio_flags);
+					}
+					vdev_probe(vd, pio);
+				}
+			}
+		}
+		mutex_exit(&spa_spare_lock);
+
+		/* Wait for all probes to complete. */
+		if (pio != NULL)
+			zio_wait(pio);
+
+		mutex_enter(&spare_poll_lock);
+		(void) cv_timedwait_hires(&spare_poll_cv, &spare_poll_lock,
+		    SEC2NSEC(spa_spare_poll_interval_seconds), SEC2NSEC(1), 0);
+		mutex_exit(&spare_poll_lock);
+	}
+
+	mutex_enter(&spare_poll_lock);
+	spare_poll_thread = NULL;
+	cv_broadcast(&spare_poll_cv);
+	mutex_exit(&spare_poll_lock);
+	thread_exit();
+}
+
+static void
+spa_spare_poll_thread_destroy()
+{
+	mutex_enter(&spare_poll_lock);
+	spare_poll_cancel = B_TRUE;
+	cv_signal(&spare_poll_cv);
+	while (spare_poll_thread != NULL) {
+		cv_wait(&spare_poll_cv, &spare_poll_lock);
+	}
+	mutex_exit(&spare_poll_lock);
+
+	mutex_destroy(&spare_poll_lock);
+	cv_destroy(&spare_poll_cv);
+}
+
+/*
+ * Start a thread that will poll unused spare vdevs in the background.
+ * This is used to detect when spare devices are faulty before they are used to
+ * replace another vdev.
+ */
+static void
+spa_spare_poll_thread_create()
+{
+	mutex_init(&spare_poll_lock, NULL, MUTEX_DEFAULT,
+	    NULL);
+	cv_init(&spare_poll_cv, NULL, CV_DEFAULT, NULL);
+	spare_poll_cancel = B_FALSE;
+	spare_poll_thread = thread_create(NULL, 0, spa_spare_poll_thread, NULL,
+	    0, &p0, TS_RUN, minclsyspri);
+}
+
 static int
 spa_spare_compare(const void *a, const void *b)
 {
@@ -1942,11 +2040,13 @@ spa_init(int mode)
 	zpool_feature_init();
 	spa_config_load();
 	l2arc_start();
+	spa_spare_poll_thread_create();
 }
 
 void
 spa_fini(void)
 {
+	spa_spare_poll_thread_destroy();
 	l2arc_stop();
 
 	spa_evict_all();
