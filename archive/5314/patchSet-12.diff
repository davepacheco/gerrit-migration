commit a83d673d74d34fa985a18b3cae53d6f4e3e38397 (refs/changes/14/5314/12)
Author: Kody A Kantor <kody@kkantor.com>
Date:   2019-01-29T21:32:50+00:00 (8 months ago)
    
    OS-6602 ZFS not detecting faulty spares in a timely manner
    OS-7499 ZFS retire agent cannot fault inactive spares

diff --git a/manifest b/manifest
index 355dce2eaf..61881531e3 100644
--- a/manifest
+++ b/manifest
@@ -10512,6 +10512,7 @@ f usr/sbin/amd64/ippool 0555 root bin
 f usr/sbin/amd64/lockstat 0555 root bin
 f usr/sbin/amd64/plockstat 0555 root bin
 f usr/sbin/amd64/zdb 0555 root bin
+f usr/sbin/amd64/zinject 0555 root bin
 f usr/sbin/arp 0555 root bin
 f usr/sbin/audit 0555 root bin
 f usr/sbin/auditconfig 0555 root bin
@@ -10790,6 +10791,7 @@ h usr/sbin/zdb=usr/lib/isaexec
 f usr/sbin/zdump 0555 root bin
 s usr/sbin/zfs=../../sbin/zfs
 f usr/sbin/zic 0555 root bin
+h usr/sbin/zinject=usr/lib/isaexec
 f usr/sbin/zlogin 0555 root bin
 f usr/sbin/zoneadm 0555 root bin
 f usr/sbin/zonecfg 0555 root bin
diff --git a/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c b/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
index d1206a34d3..5295c012bc 100644
--- a/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
+++ b/usr/src/cmd/fm/modules/common/zfs-diagnosis/zfs_de.c
@@ -22,6 +22,7 @@
 /*
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <assert.h>
@@ -38,9 +39,9 @@
 #include <sys/fm/fs/zfs.h>
 
 /*
- * Our serd engines are named 'zfs_<pool_guid>_<vdev_guid>_{checksum,io}'.  This
- * #define reserves enough space for two 64-bit hex values plus the length of
- * the longest string.
+ * Our serd engines are named 'zfs_<pool_guid>_<vdev_guid>_{checksum,io,probe}'.
+ * This #define reserves enough space for two 64-bit hex values plus the length
+ * of the longest string.
  */
 #define	MAX_SERDLEN	(16 * 2 + sizeof ("zfs___checksum"))
 
@@ -58,6 +59,7 @@ typedef struct zfs_case_data {
 	int		zc_pool_state;
 	char		zc_serd_checksum[MAX_SERDLEN];
 	char		zc_serd_io[MAX_SERDLEN];
+	char		zc_serd_probe[MAX_SERDLEN];
 	int		zc_has_remove_timer;
 } zfs_case_data_t;
 
@@ -370,8 +372,8 @@ zfs_purge_cases(fmd_hdl_t *hdl)
 }
 
 /*
- * Construct the name of a serd engine given the pool/vdev GUID and type (io or
- * checksum).
+ * Construct the name of a serd engine given the pool/vdev GUID and type (io,
+ * checksum, or probe).
  */
 static void
 zfs_serd_name(char *buf, uint64_t pool_guid, uint64_t vdev_guid,
@@ -627,7 +629,8 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			pool_found = B_TRUE;
 			pool_load = zcp->zc_when;
 		}
-		if (zcp->zc_data.zc_vdev_guid == vdev_guid)
+		if (zcp->zc_data.zc_vdev_guid == vdev_guid &&
+		    zcp->zc_data.zc_pool_guid == pool_guid)
 			break;
 	}
 
@@ -775,6 +778,8 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			if (zcp->zc_data.zc_serd_checksum[0] != '\0')
 				fmd_serd_reset(hdl,
 				    zcp->zc_data.zc_serd_checksum);
+			if (zcp->zc_data.zc_serd_probe[0] != '\0')
+				fmd_serd_reset(hdl, zcp->zc_data.zc_serd_probe);
 		}
 		zfs_stats.resource_drops.fmds_value.ui64++;
 		return;
@@ -843,8 +848,8 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 		boolean_t checkremove = B_FALSE;
 
 		/*
-		 * If this is a checksum or I/O error, then toss it into the
-		 * appropriate SERD engine and check to see if it has fired.
+		 * If this is a checksum, I/O, or probe error, then toss it into
+		 * the appropriate SERD engine and check to see if it has fired.
 		 * Ideally, we want to do something more sophisticated,
 		 * (persistent errors for a single data block, etc).  For now,
 		 * a single SERD engine is sufficient.
@@ -894,7 +899,18 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			}
 		} else if (fmd_nvl_class_match(hdl, nvl,
 		    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_PROBE_FAILURE))) {
-			checkremove = B_TRUE;
+			if (zcp->zc_data.zc_serd_probe[0] == '\0') {
+				zfs_serd_name(zcp->zc_data.zc_serd_probe,
+				    pool_guid, vdev_guid, "probe");
+				fmd_serd_create(hdl, zcp->zc_data.zc_serd_probe,
+				    fmd_prop_get_int32(hdl, "probe_N"),
+				    fmd_prop_get_int64(hdl, "probe_T"));
+				zfs_case_serialize(hdl, zcp);
+			}
+			if (fmd_serd_record(hdl,
+			    zcp->zc_data.zc_serd_probe, ep)) {
+				checkremove = B_TRUE;
+			}
 		}
 
 		/*
@@ -938,6 +954,8 @@ zfs_fm_close(fmd_hdl_t *hdl, fmd_case_t *cs)
 		fmd_serd_destroy(hdl, zcp->zc_data.zc_serd_checksum);
 	if (zcp->zc_data.zc_serd_io[0] != '\0')
 		fmd_serd_destroy(hdl, zcp->zc_data.zc_serd_io);
+	if (zcp->zc_data.zc_serd_probe[0] != '\0')
+		fmd_serd_destroy(hdl, zcp->zc_data.zc_serd_probe);
 	if (zcp->zc_data.zc_has_remove_timer)
 		fmd_timer_remove(hdl, zcp->zc_remove_timer);
 	uu_list_remove(zfs_cases, zcp);
@@ -967,6 +985,8 @@ static const fmd_prop_t fmd_props[] = {
 	{ "checksum_T", FMD_TYPE_TIME, "10min" },
 	{ "io_N", FMD_TYPE_UINT32, "10" },
 	{ "io_T", FMD_TYPE_TIME, "10min" },
+	{ "probe_N", FMD_TYPE_UINT32, "5" },
+	{ "probe_T", FMD_TYPE_TIME, "24hour" },
 	{ "remove_timeout", FMD_TYPE_TIME, "15sec" },
 	{ NULL, 0, NULL }
 };
diff --git a/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c b/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
index 4856676d7d..e2d1a6831a 100644
--- a/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
+++ b/usr/src/cmd/fm/modules/common/zfs-retire/zfs_retire.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -121,13 +122,21 @@ find_vdev(libzfs_handle_t *zhdl, nvlist_t *nv, const char *search_fru,
 	}
 
 	if (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,
-	    &child, &children) != 0)
-		return (NULL);
+	    &child, &children) == 0) {
+		for (c = 0; c < children; c++) {
+			if ((ret = find_vdev(zhdl, child[c], search_fru,
+			    search_guid)) != NULL)
+				return (ret);
+		}
+	}
 
-	for (c = 0; c < children; c++) {
-		if ((ret = find_vdev(zhdl, child[c], search_fru,
-		    search_guid)) != NULL)
-			return (ret);
+	if (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,
+	    &child, &children) == 0) {
+		for (c = 0; c < children; c++) {
+			if ((ret = find_vdev(zhdl, child[c], search_fru,
+			    search_guid)) != NULL)
+				return (ret);
+		}
 	}
 
 	return (NULL);
diff --git a/usr/src/lib/libzfs/common/libzfs_pool.c b/usr/src/lib/libzfs/common/libzfs_pool.c
index 56e1d7032e..6cce9e22aa 100644
--- a/usr/src/lib/libzfs/common/libzfs_pool.c
+++ b/usr/src/lib/libzfs/common/libzfs_pool.c
@@ -2798,7 +2798,7 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 	zfs_cmd_t zc = { 0 };
 	char msg[1024];
 	int ret;
-	nvlist_t *tgt;
+	nvlist_t *tgt, *newvd;
 	boolean_t avail_spare, l2cache, islog;
 	uint64_t val;
 	char *newname;
@@ -2842,14 +2842,14 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 	if ((newname = zpool_vdev_name(NULL, NULL, child[0], B_FALSE)) == NULL)
 		return (-1);
 
+	newvd = zpool_find_vdev(zhp, newname, &avail_spare, &l2cache, NULL);
 	/*
 	 * If the target is a hot spare that has been swapped in, we can only
 	 * replace it with another hot spare.
 	 */
 	if (replacing &&
 	    nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_IS_SPARE, &val) == 0 &&
-	    (zpool_find_vdev(zhp, newname, &avail_spare, &l2cache,
-	    NULL) == NULL || !avail_spare) &&
+	    (newvd == NULL || !avail_spare) &&
 	    is_replacing_spare(config_root, tgt, 1)) {
 		zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
 		    "can only be replaced by another hot spare"));
@@ -2859,6 +2859,11 @@ zpool_vdev_attach(zpool_handle_t *zhp,
 
 	free(newname);
 
+	if (replacing && avail_spare && !vdev_online(newvd)) {
+		(void) zpool_standard_error(hdl, ENXIO, msg);
+		return (-1);
+	}
+
 	if (zcmd_write_conf_nvlist(hdl, &zc, nvroot) != 0)
 		return (-1);
 
diff --git a/usr/src/test/zfs-tests/include/libtest.shlib b/usr/src/test/zfs-tests/include/libtest.shlib
index 6e7f5210a1..66db2c9501 100644
--- a/usr/src/test/zfs-tests/include/libtest.shlib
+++ b/usr/src/test/zfs-tests/include/libtest.shlib
@@ -25,6 +25,7 @@
 # Copyright (c) 2012, 2017 by Delphix. All rights reserved.
 # Copyright 2016 Nexenta Systems, Inc.
 # Copyright (c) 2017 Datto Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 . ${STF_TOOLS}/contrib/include/logapi.shlib
@@ -322,7 +323,7 @@ function default_mirror_setup_noexit
 	[[ -z $secondary ]] && \
 		log_fail "$func: No secondary partition passed"
 	[[ -d /$TESTPOOL ]] && rm -rf /$TESTPOOL
-	log_must zpool create -f $TESTPOOL mirror $@
+	log_must zpool create -f $TESTPOOL mirror $primary $secondary
 	log_must zfs create $TESTPOOL/$TESTFS
 	log_must zfs set mountpoint=$TESTDIR $TESTPOOL/$TESTFS
 }
diff --git a/usr/src/test/zfs-tests/runfiles/smartos.run b/usr/src/test/zfs-tests/runfiles/smartos.run
index 5eac753cde..c0a2dbce9e 100644
--- a/usr/src/test/zfs-tests/runfiles/smartos.run
+++ b/usr/src/test/zfs-tests/runfiles/smartos.run
@@ -49,7 +49,7 @@ tests = ['zpool_remove_001_neg', 'zpool_remove_002_pos',
     'zpool_remove_003_pos']
 
 [/opt/zfs-tests/tests/functional/cli_root/zpool_replace]
-tests = ['zpool_replace_001_neg']
+tests = ['zpool_replace_001_neg', 'zpool_replace_002_neg']
 
 [/opt/zfs-tests/tests/functional/cli_root/zpool_scrub]
 tests = ['zpool_scrub_001_neg', 'zpool_scrub_004_pos', 'zpool_scrub_005_pos']
diff --git a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
index 51dfd8107b..83337a8949 100644
--- a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/setup.ksh
@@ -25,10 +25,14 @@
 # Use is subject to license terms.
 #
 
+#
+# Copyright 2019 Joyent, Inc.
+#
+
 . $STF_SUITE/include/libtest.shlib
 
 verify_runnable "global"
-verify_disk_count "$DISKS" 2
+verify_disk_count "$DISKS" 3
 
 DISK=${DISKS%% *}
 
diff --git a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh
new file mode 100644
index 0000000000..fde508254c
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_replace/zpool_replace_002_neg.ksh
@@ -0,0 +1,51 @@
+#!/usr/bin/ksh -p
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+
+#
+# DESCRIPTION:
+#
+# zpool replace returns an error when spare device is faulted.
+#
+# STRATEGY:
+# 1. Add hot spare to pool
+# 2. Fault the hot spare device
+# 3. Attempt to replace a device in a pool with the faulted spare
+# 4. Verify the 'zpool replace' command fails
+#
+
+SPARE=${DISKS##* }
+DISK=${DISKS%% *}
+
+verify_runnable "global"
+log_must zpool add $TESTPOOL spare $SPARE
+log_assert "zpool replace returns an error when the hot spare is faulted"
+
+log_must zinject -d $SPARE -A fault $TESTPOOL
+log_mustnot zpool replace $TESTPOOL $DISK $SPARE
+
+log_pass "zpool replace returns an error when the hot spare is faulted"
diff --git a/usr/src/uts/common/fs/zfs/spa.c b/usr/src/uts/common/fs/zfs/spa.c
index 92ec682e29..b93973f9c5 100644
--- a/usr/src/uts/common/fs/zfs/spa.c
+++ b/usr/src/uts/common/fs/zfs/spa.c
@@ -27,7 +27,7 @@
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  * Copyright 2016 Toomas Soome <tsoome@me.com>
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2017 Datto Inc.
  * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
@@ -224,6 +224,13 @@ uint64_t	zfs_max_missing_tvds_cachefile = SPA_DVAS_PER_BP - 1;
  */
 uint64_t	zfs_max_missing_tvds_scan = 0;
 
+/*
+ * Interval in seconds at which to poll spare vdevs for health.
+ * Setting this to zero disables spare polling.
+ * Set to three hours by default.
+ */
+uint_t		spa_spare_poll_interval_seconds = 60 * 60 * 3;
+
 /*
  * Debugging aid that pauses spa_sync() towards the end.
  */
@@ -6888,6 +6895,8 @@ spa_async_thread(void *arg)
 	if (tasks & SPA_ASYNC_PROBE) {
 		spa_vdev_state_enter(spa, SCL_NONE);
 		spa_async_probe(spa, spa->spa_root_vdev);
+		for (int i = 0; i < spa->spa_spares.sav_count; i++)
+			spa_async_probe(spa, spa->spa_spares.sav_vdevs[i]);
 		(void) spa_vdev_state_exit(spa, NULL, 0);
 	}
 
@@ -7877,6 +7886,14 @@ spa_sync(spa_t *spa, uint64_t txg)
 
 	spa_handle_ignored_writes(spa);
 
+	/* Mark unused spares as needing a health check. */
+	if (spa_spare_poll_interval_seconds != 0 &&
+	    NSEC2SEC(gethrtime() - spa->spa_spares_last_polled) >
+	    spa_spare_poll_interval_seconds) {
+		spa_spare_poll(spa);
+		spa->spa_spares_last_polled = gethrtime();
+	}
+
 	/*
 	 * If any async tasks have been requested, kick them off.
 	 */
diff --git a/usr/src/uts/common/fs/zfs/spa_misc.c b/usr/src/uts/common/fs/zfs/spa_misc.c
index 8ba49fed41..bb637eb92e 100644
--- a/usr/src/uts/common/fs/zfs/spa_misc.c
+++ b/usr/src/uts/common/fs/zfs/spa_misc.c
@@ -26,6 +26,7 @@
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  * Copyright (c) 2017 Datto Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/zfs_context.h>
@@ -1009,6 +1010,41 @@ spa_aux_activate(vdev_t *vd, avl_tree_t *avl)
  * be completely consistent with respect to other vdev configuration changes.
  */
 
+/*
+ * Poll the spare vdevs to make sure they are not faulty.
+ *
+ * The probe operation will raise an ENXIO error and create an FM ereport if the
+ * probe fails.
+ */
+void
+spa_spare_poll(spa_t *spa)
+{
+	boolean_t async_request = B_FALSE;
+	spa_config_enter(spa, SCL_STATE, FTAG, RW_READER);
+	for (int i = 0; i < spa->spa_spares.sav_count; i++) {
+		spa_aux_t search, *found;
+		vdev_t *vd = spa->spa_spares.sav_vdevs[i];
+
+		search.aux_guid = vd->vdev_guid;
+
+		mutex_enter(&spa_spare_lock);
+		found = avl_find(&spa_spare_avl, &search, NULL);
+		/* This spare is in use by a pool. */
+		if (found != NULL && found->aux_pool != NULL) {
+			mutex_exit(&spa_spare_lock);
+			continue;
+		}
+		mutex_exit(&spa_spare_lock);
+
+		vd->vdev_probe_wanted = B_TRUE;
+		async_request = B_TRUE;
+	}
+	if (async_request)
+		spa_async_request(spa, SPA_ASYNC_PROBE);
+
+	spa_config_exit(spa, SCL_STATE, FTAG);
+}
+
 static int
 spa_spare_compare(const void *a, const void *b)
 {
diff --git a/usr/src/uts/common/fs/zfs/sys/spa.h b/usr/src/uts/common/fs/zfs/sys/spa.h
index dc5da8fd77..79d4d84dca 100644
--- a/usr/src/uts/common/fs/zfs/sys/spa.h
+++ b/usr/src/uts/common/fs/zfs/sys/spa.h
@@ -25,7 +25,7 @@
  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2017 Datto Inc.
  */
 
@@ -678,6 +678,9 @@ extern void spa_spare_remove(vdev_t *vd);
 extern boolean_t spa_spare_exists(uint64_t guid, uint64_t *pool, int *refcnt);
 extern void spa_spare_activate(vdev_t *vd);
 
+/* spare polling */
+extern void spa_spare_poll(spa_t *spa);
+
 /* L2ARC state (which is global across all pools) */
 extern void spa_l2cache_add(vdev_t *vd);
 extern void spa_l2cache_remove(vdev_t *vd);
diff --git a/usr/src/uts/common/fs/zfs/sys/spa_impl.h b/usr/src/uts/common/fs/zfs/sys/spa_impl.h
index ea251cf0c6..9835947a1e 100644
--- a/usr/src/uts/common/fs/zfs/sys/spa_impl.h
+++ b/usr/src/uts/common/fs/zfs/sys/spa_impl.h
@@ -25,6 +25,7 @@
  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2017 Datto Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef _SYS_SPA_IMPL_H
@@ -249,6 +250,7 @@ struct spa {
 
 	spa_aux_vdev_t	spa_spares;		/* hot spares */
 	spa_aux_vdev_t	spa_l2cache;		/* L2ARC cache devices */
+	hrtime_t	spa_spares_last_polled;	/* time spares last polled */
 	nvlist_t	*spa_label_features;	/* Features for reading MOS */
 	uint64_t	spa_config_object;	/* MOS object for pool config */
 	uint64_t	spa_config_generation;	/* config generation number */
