From 6500eaea0f049e65dc5702ac166901fdddb762ac Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Thu, 27 Dec 2018 06:35:58 +0000
Subject: [PATCH] OS-7293 Kernel attempts to apply old erratum to AMD
 Threadripper 1950X Reviewed by: Hans Rosenfeld <hans.rosenfeld@joyent.com>
 Reviewed by: Mike Zeller <mike.zeller@joyent.com> Approved by: Mike Zeller
 <mike.zeller@joyent.com>

---
 usr/src/uts/i86pc/os/cpuid.c      | 26 ++++++++++++++++++++++----
 usr/src/uts/i86pc/os/mp_startup.c |  9 +++++++--
 2 files changed, 29 insertions(+), 6 deletions(-)

diff --git a/usr/src/uts/i86pc/os/cpuid.c b/usr/src/uts/i86pc/os/cpuid.c
index 4af3f4c470..140100e671 100644
--- a/usr/src/uts/i86pc/os/cpuid.c
+++ b/usr/src/uts/i86pc/os/cpuid.c
@@ -32,7 +32,7 @@
  * Portions Copyright 2009 Advanced Micro Devices, Inc.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 /*
  * Various routines to handle identification
@@ -2034,6 +2034,7 @@ cpuid_pass1(cpu_t *cpu, uchar_t *featureset)
 		 */
 		switch (cpi->cpi_vendor) {
 		case X86_VENDOR_Intel:
+		case X86_VENDOR_AMD:
 			if (cpi->cpi_maxeax >= 7) {
 				cp = &cpi->cpi_extd[7];
 				cp->cp_eax = 0x80000007;
@@ -3939,9 +3940,9 @@ cpuid_opteron_erratum(cpu_t *cpu, uint_t erratum)
 	 */
 	if (cpi->cpi_vendor != X86_VENDOR_AMD ||
 	    cpi->cpi_family == 4 || cpi->cpi_family == 5 ||
-	    cpi->cpi_family == 6)
-
+	    cpi->cpi_family == 6) {
 		return (0);
+	}
 
 	eax = cpi->cpi_std[1].cp_eax;
 
@@ -4102,10 +4103,21 @@ cpuid_opteron_erratum(cpu_t *cpu, uint_t erratum)
 	case 131:
 		return (cpi->cpi_family < 0x10);
 	case 6336786:
+
 		/*
 		 * Test for AdvPowerMgmtInfo.TscPStateInvariant
-		 * if this is a K8 family or newer processor
+		 * if this is a K8 family or newer processor. We're testing for
+		 * this 'erratum' to determine whether or not we have a constant
+		 * TSC.
+		 *
+		 * Our current fix for this is to disable the C1-Clock ramping.
+		 * However, this doesn't work on newer processor families nor
+		 * does it work when virtualized as those devices don't exist.
 		 */
+		if (cpi->cpi_family >= 0x12 || get_hwenv() != HW_NATIVE) {
+			return (0);
+		}
+
 		if (CPI_FAMILY(cpi) == 0xf) {
 			struct cpuid_regs regs;
 			regs.cp_eax = 0x80000007;
@@ -4114,6 +4126,12 @@ cpuid_opteron_erratum(cpu_t *cpu, uint_t erratum)
 		}
 		return (0);
 	case 6323525:
+		/*
+		 * This erratum (K8 #147) is not present on family 10 and newer.
+		 */
+		if (cpi->cpi_family >= 0x10) {
+			return (0);
+		}
 		return (((((eax >> 12) & 0xff00) + (eax & 0xf00)) |
 		    (((eax >> 4) & 0xf) | ((eax >> 12) & 0xf0))) < 0xf40);
 
diff --git a/usr/src/uts/i86pc/os/mp_startup.c b/usr/src/uts/i86pc/os/mp_startup.c
index f292b52fbe..da629d02c2 100644
--- a/usr/src/uts/i86pc/os/mp_startup.c
+++ b/usr/src/uts/i86pc/os/mp_startup.c
@@ -27,7 +27,7 @@
  * All rights reserved.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
@@ -1123,6 +1123,9 @@ workaround_errata(struct cpu *cpu)
 	/*
 	 * This isn't really an erratum, but for convenience the
 	 * detection/workaround code lives here and in cpuid_opteron_erratum.
+	 * Note, the technique only is valid on families before 12h and
+	 * certainly doesn't work when we're virtualized. This is checked for in
+	 * the erratum workaround.
 	 */
 	if (cpuid_opteron_erratum(cpu, 6336786) > 0) {
 #if defined(OPTERON_WORKAROUND_6336786)
@@ -1173,7 +1176,9 @@ workaround_errata(struct cpu *cpu)
 
 	/*LINTED*/
 	/*
-	 * Mutex primitives don't work as expected.
+	 * Mutex primitives don't work as expected. This is erratum #147 from
+	 * 'Revision Guide for AMD Athlon 64 and AMD Opteron Processors'
+	 * document 25759.
 	 */
 	if (cpuid_opteron_erratum(cpu, 6323525) > 0) {
 #if defined(OPTERON_WORKAROUND_6323525)
-- 
2.21.0

