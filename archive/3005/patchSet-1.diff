From 3190ce7c252749e6e837301b7125d98d868dbbe2 Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Tue, 28 Nov 2017 21:05:03 -0800
Subject: [PATCH] VOLAPI-97 tools/setup/setup.sh should not use experimental
 images

---
 README.md            |  59 +++-----
 tools/setup/setup.sh | 324 -------------------------------------------
 2 files changed, 22 insertions(+), 361 deletions(-)
 delete mode 100644 tools/setup/setup.sh

diff --git a/README.md b/README.md
index 547275c..a432105 100644
--- a/README.md
+++ b/README.md
@@ -50,22 +50,32 @@ use volumes, just not through Docker APIs/clients.
 
 ### Installation
 
-1. Checkout VOLAPI's source code:
+1. Install and enable the VOLAPI service by running the following command on
+   your DC's headnode:
 
-  ```
-  $ git clone git@github.com:joyent/sdc-volapi.git
-  $ cd sdc-volapi
-  ```
+   ```
+   $ sdcadm post-setup volapi
+   ```
+
+2. Enable NFS volumes feature flags by running the following commands on your
+   DC's headnode:
 
-2. Install and enable the VOLAPI service:
+   ```
+   # Enables support for creating/managing NFS volumes with the docker API and
+   # the docker volume commands
+   $ sdcadm experimental nfs-volumes docker
+
+   # Enables support for docker containers to automatically mount NFS volumes
+   # at startup time
+   $ sdcadm experimental nfs-volumes docker-automount
 
-  ```
-  $ sh tools/setup/setup.sh $DC_NAME
-  ```
+   # Enables support for creating/managing NFS volumes with CloudAPI
+   $ sdcadm experimental nfs-volumes cloudapi
 
-  where `$DC_NAME` is the name of the datacenter in which the VOLAPI service
-  should be installed. By default, the installation process will use `coal` as
-  the datacenter name.
+   # Enables support for non-Docker VMs (except KVM VMs) to automatically mount
+   # NFS volumes at startup time
+   $ sdcadm experimental nfs-volumes cloudapi-automount
+   ```
 
 3. Install the latest version of node-triton to get NFS shared volumes support:
 
@@ -73,31 +83,6 @@ use volumes, just not through Docker APIs/clients.
    $ npm install -g triton
    ```
 
-#### Disclaimer
-
-Running `tools/setup/setup.sh` goes through all the steps necessary to enable
-support for NFS shared volumes in any datacenter (including COAL). It updates
-other core Triton services, such as sdc-docker, to different versions from
-feature branches that include changes needed to support shared volumes
-management. It also adds packages into PAPI and services into SAPI, among other
-things.
-
-As a result, when enabling this new service in COAL, it is no longer possible to
-update services that play a role in supporting NFS shared volumes as usual. For
-instance, updating the Docker API to the latest development version from the
-master branch would break support for `tritonnfs` volumes.
-
-The feature branches of all the repositories that are used to support the
-Volumes API are regularly rebased on top of the current development (master)
-branch, but not immediately. Thus, running this script is not recommended when
-the ability to use latest development features of Triton is needed at all times.
-
-There is also not automated procedure for uninstalling support for the Volumes
-API, and going back to using the latest development branch (master) for all
-Triton repositories.
-
-In other words, __use at your own risk__.
-
 ## Contributing changes
 
 Before commiting/pushing run `make prepush` and, if possible, get a code
diff --git a/tools/setup/setup.sh b/tools/setup/setup.sh
deleted file mode 100644
index 24c53f9..0000000
--- a/tools/setup/setup.sh
+++ /dev/null
@@ -1,324 +0,0 @@
-#!/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2017, Joyent, Inc.
-#
-
-# This is the first platform build that integrates the fix for DOCKER-754 that
-# brings supports for mounting NFS volumes with dockerinit when Docker zones
-# boot.
-MINIMUM_SUPPORTED_PLATFORM_VERSION="20160613T123039Z"
-
-if [[ -n "$TRACE" ]]; then
-    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: '\
-        '${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-    set -o xtrace
-fi
-set -o errexit
-set -o pipefail
-
-TOP=$(cd $(dirname $0)/../../; pwd)
-
-function fatal
-{
-    echo "$0: fatal error: $*"
-    exit 1
-}
-
-function errexit
-{
-    [[ $1 -ne 0 ]] || exit 0
-    fatal "error exit status $1"
-}
-
-function usage
-{
-    echo "Usage:"
-    echo "setup [ssh-datacenter-name]"
-    echo ""
-    echo "ssh-datacenter-name is a name that can be used to connect via ssh"
-    echo "to the datacenter on which to setup VOLAPI. It defaults to \"coal\"."
-    exit 1
-}
-
-function cns_need_platform_upgrade
-{
-    local datacenter_name=$1
-    local cns_platform_versions=$(ssh root@$datacenter_name \
-        "/opt/smartdc/bin/sdc-oneachnode -j -N -c 'uname -v'" | \
-        json -a result.stdout | \
-        cut -d '_' -f 2)
-
-    for CN_PLATFORM_VERSION in $cns_platform_versions; do
-        if [[ "$CN_PLATFORM_VERSION" < \
-            "$MINIMUM_SUPPORTED_PLATFORM_VERSION" ]]; then
-            return 0
-        fi
-    done
-
-    return 1
-}
-
-function coal_needs_platform_upgrade
-{
-    local coal_headnode_platform_version=$(ssh root@$datacenter_name uname -v | \
-        cut -d '_' -f 2)
-
-    if [[ "$coal_headnode_platform_version" < \
-            "$MINIMUM_SUPPORTED_PLATFORM_VERSION" ]]; then
-        return 0
-    else
-        return 1
-    fi
-}
-
-function upgrade_platform_to_latest_master
-{
-    local datacenter_name=$1
-    local latest_master_platform_uuid_and_version
-    local latest_master_platform_uuid
-    local latest_master_platform_version
-
-    echo "Upgrading platform to latest master on all CNs..."
-
-    latest_master_platform_uuid_and_version=$(ssh root@$datacenter_name \
-        /opt/smartdc/bin/updates-imgadm list -H -o uuid,version name=platform \
-        version=~master | tail -1)
-    latest_master_platform_uuid=$(echo $latest_master_platform_uuid_and_version\
-        | cut -d ' ' -f 1)
-    latest_master_platform_version=$(echo $latest_master_platform_uuid_and_version\
-        | cut -d ' ' -f 2 | cut -d '-' -f 2)
-
-    echo "Installing latest master platform..."
-    ssh root@$datacenter_name /opt/smartdc/bin/sdcadm platform install \
-        "$latest_master_platform_uuid"
-
-    echo "Assigning latest master platform to all CNs..."
-    ssh root@$datacenter_name /opt/smartdc/bin/sdcadm platform assign --all \
-        $latest_master_platform_version
-
-    echo "Platform upgrade done, please reboot all CNs in order for " \
-        "them to boot with the new installed platform."
-}
-
-function check_platform_supports_nfs_volumes
-{
-    local datacenter_name=$1
-    local proceed_with_upgrade=""
-    local need_platform_upgrade=0
-
-    if [[ "$datacenter_name" == "coal" ]]; then
-        if coal_needs_platform_upgrade; then
-            need_platform_upgrade=1
-        fi
-    elif cns_need_platform_upgrade "$datacenter_name"; then
-        need_platform_upgrade=1
-    fi
-
-    if [[ $need_platform_upgrade -eq 1 ]]; then
-        echo "Current installed platform is older than minimum supported" \
-            "platform on at least 1 CN."
-        printf "Do you want to upgrade to latest master platform on all CNs" \
-            "[y/N]"
-
-        read proceed_with_upgrade
-        echo ""
-
-        if [[ "$proceed_with_upgrade" == "y" || \
-            "$proceed_with_upgrade" == "Y" ]]; then
-            upgrade_platform_to_latest_master "$datacenter_name"
-        else
-            echo "A platform that supports NFS volumes is needed to use "\
-                "VOLAPI, exiting."
-            exit 0
-        fi
-    else
-        echo "Current installed platform supports NFS volumes, not upgrading."
-    fi
-}
-
-trap 'errexit $?' EXIT
-
-if [ "$#" -gt 1 ]; then
-    usage
-fi
-
-datacenter_name="coal"
-if [ "x$1" != "x" ]; then
-    datacenter_name="$1"
-fi
-
-echo "Setting up VOLAPI in $datacenter_name..."
-
-check_platform_supports_nfs_volumes "$datacenter_name"
-
-ssh root@"$datacenter_name" TRACE="$TRACE" /bin/bash -l << "EOS"
-if [[ -n "$TRACE" ]]; then
-    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: '\
-        '${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-    set -o xtrace
-fi
-
-set -o errexit
-set -o pipefail
-
-function fatal
-{
-    echo "$0: fatal error: $*"
-    exit 1
-}
-
-# This function achieves the same goal as get_latest_img_uuid, but is used when
-# the images for which we want to get the latest build from a given branch don't
-# have the branch name outputted by "updates-imgadm list". In this case, we need
-# to get the branch information from IMGAPI by performing a GetImage request,
-# which is a lot more time consuming. As a result, this function should be used
-# only when needed, e.g for images such as sdcadm and gz-tools. It seems core
-# service images (e.g docker, volapi, etc.) don't have that limitation, and for
-# them using the "get_latest_img_uuid" function is highly recommended.
-function get_latest_img_uuid_using_imgapi_version
-{
-    local image_name=$1
-    local branch_pattern=$2
-    local images
-    local branch_img_uuid
-    local latest_branch_img_uuid
-
-    images=($(/opt/smartdc/bin/updates-imgadm -H -C experimental \
-        list name=$image_name | cut -d ' ' -f 1 | tr '\n' ' '))
-    # Find latest image with a name that matches $image_name created from a
-    # branch whose name matches $branch_pattern. It is currently assumed that
-    # the output of updates-imgadm list is sorted by publishing date, so we can
-    # process the list of images from the last (most recent) to the first
-    # (oldest) and stop at the first one that was generated from a branch that
-    # matches $branch_pattern.
-    for ((i = ${#images[@]} - 1; i >= 0; i--)); \
-    do
-        branch_img_uuid=$(updates-imgadm -C experimental get "${images[i]}" | \
-            json -c "(version != null && \
-            version.match(/"${branch_pattern}"-\d{8}T\d{6}Z-g[a-z0-9]+/)) || \
-            (tags != null && tags.buildstamp != null && \
-            tags.buildstamp.match(/"${branch_pattern}"-\d{8}T\d{6}Z-g[a-z0-9]+/))" uuid)
-        if [[ "$branch_img_uuid" != "" ]]; then
-            latest_branch_img_uuid=$branch_img_uuid
-            break
-        fi
-    done
-    echo "$latest_branch_img_uuid"
-}
-
-function get_latest_img_uuid
-{
-    local image_name=$1
-    local branch_pattern=$2
-    local update_channel_name="dev"
-    local latest_branch_img_uuid
-
-    if [ "$branch_pattern" != "master" ]; then
-        update_channel_name="experimental"
-    fi
-
-    # The "${branch_pattern}-([0-9])+T([0-9)+Z-g([a-z0-9])+" regexp could be
-    # stricter, but since it seems "egrep" lacks support for quantifiers
-    # ("{n,m}") I couldn't come up with a way to make it stricter without
-    # repeating several parts of it to a point where it would become a lot less
-    # readable.
-    latest_branch_img_uuid=$(/opt/smartdc/bin/updates-imgadm -H -C \
-        "$update_channel_name" list name=$image_name | \
-        egrep "${branch_pattern}-([0-9])+T([0-9)+Z-g([a-z0-9])+" | \
-        tail -1 | cut -d ' ' -f 1)
-
-    echo "$latest_branch_img_uuid"
-}
-
-function upgrade_core_service_to_latest_branch_image
-{
-    local core_service_name=$1
-    local branch_name=$2
-    local update_channel_name="dev"
-    local latest_img_uuid
-
-    echo "Making sure $core_service_name core zone is up to date..."
-
-    if [ "$branch_name" != "master" ]; then
-        update_channel_name="experimental"
-    fi
-
-    latest_img_uuid=$(get_latest_img_uuid "$core_service_name" "$branch_name")
-    if [ "x$latest_img_uuid" != "x" ]; then
-        echo "Updating $core_service_name to image ${latest_img_uuid}"
-        sdcadm up -y -C "$update_channel_name" \
-            "$core_service_name@$latest_img_uuid"
-    else
-        fatal "Could not find latest $core_service_name version built from"\
-            "branch $branch_name"
-    fi
-}
-
-function upgrade_gz_tools_to_latest_branch_image
-{
-    local branch_name=$1
-
-    local latest_img_uuid
-
-    latest_img_uuid=$(get_latest_img_uuid_using_imgapi_version gz-tools \
-        "$branch_name")
-    if [ "x$latest_img_uuid" != "x" ]; then
-        echo "Updating gz-tools to image ${latest_img_uuid}"
-        sdcadm experimental update-gz-tools -C experimental "$latest_img_uuid"
-    else
-        fatal "Could not find latest gz-tools version built from"\
-            "branch $branch_name"
-    fi
-}
-
-echo "Making sure sdcadm is up to date..."
-sdcadm_installed_version=$(sdcadm --version | cut -d ' ' -f 3 | tr -d '()')
-echo "Current sdcadm version: $sdcadm_installed_version"
-latest_sdcadm_tritonnfs_img=$(get_latest_img_uuid_using_imgapi_version \
-    "sdcadm" "tritonnfs")
-if [ "x$latest_sdcadm_tritonnfs_img" != "x" ]; then
-    latest_sdcadm_tritonnfs_img_buildstamp=$(updates-imgadm  -C experimental \
-        get "$latest_sdcadm_tritonnfs_img" | json tags.buildstamp)
-    if [ "$latest_sdcadm_tritonnfs_img_buildstamp" != \
-        "$sdcadm_installed_version" ]; then
-        echo "Updating sdcadm to image ${latest_sdcadm_tritonnfs_img}"
-        sdcadm self-update -C experimental "$latest_sdcadm_tritonnfs_img"
-    else
-        echo "sdcadm is up to date on latest tritonnfs version"
-    fi
-else
-    fatal "Could not find latest sdcadm version with tritonnfs support"
-fi
-
-echo "Setting up VOLAPI service"
-sdcadm post-setup volapi
-
-upgrade_core_service_to_latest_branch_image "sdc" "tritonnfs"
-upgrade_core_service_to_latest_branch_image "workflow" "tritonnfs"
-upgrade_core_service_to_latest_branch_image "cnapi" "tritonnfs"
-upgrade_core_service_to_latest_branch_image "vmapi" "tritonnfs"
-upgrade_core_service_to_latest_branch_image "docker" "tritonnfs"
-upgrade_core_service_to_latest_branch_image "cloudapi" "tritonnfs"
-
-# The VOLAPI service may have been already enabled by "sdcadm experimental
-# volapi" but the VOLAPI zone may need to be updated to the latest version.
-upgrade_core_service_to_latest_branch_image "volapi" "master"
-
-# Needed to add additional programs in the HN's GZ, such as sdc-volapi
-upgrade_gz_tools_to_latest_branch_image tritonnfs
-
-# Now enable the flags in SAPI to enable NFS volumes support for docker and
-# CloudAPI, as well as the ability to automount NFS volumes
-sdcadm experimental nfs-volumes docker
-sdcadm experimental nfs-volumes docker-automount
-sdcadm experimental nfs-volumes cloudapi
-sdcadm experimental nfs-volumes cloudapi-automount
-EOS
-
-echo "VOLAPI setup done, reboot of all CNs is needed before it can be used"
-- 
2.21.0

