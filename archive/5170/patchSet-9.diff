From 5bbd31725fc1d57535b0b605a3ca657bde1333e1 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Mon, 26 Nov 2018 19:55:36 +0000
Subject: [PATCH] =?UTF-8?q?OS-7352=20VM.update=20should=20allow=20disk=20r?=
 =?UTF-8?q?esize=20with=20update=5Fdisks=20Reviewed=20by:=20Pedro=20Palaz?=
 =?UTF-8?q?=C3=B3n=20Candel=20<pedro@joyent.com>=20Reviewed=20by:=20Orland?=
 =?UTF-8?q?o=20Vazquez=20<orlando@joyent.com>=20Reviewed=20by:=20Dylan=20Y?=
 =?UTF-8?q?ep=20<dylan.yep@joyent.com>=20Approved=20by:=20Pedro=20Palaz?=
 =?UTF-8?q?=C3=B3n=20Candel=20<pedro@joyent.com>?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 src/vm/man/vmadm.1m.md                 |  17 +
 src/vm/node_modules/VM.js              | 659 ++++++++++++++++++++-----
 src/vm/node_modules/proptable.js       |   9 +-
 src/vm/tests/test-bhyve-disk-resize.js | 387 ++++++++++++---
 4 files changed, 884 insertions(+), 188 deletions(-)

diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index 049318f8..ecac3e4d 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -440,6 +440,23 @@ tab-complete UUIDs rather than having to type them out for every command.
         except that the options are add_disks, remove_disks and update_disks
         and instead of "mac" these will be keyed on "path".
 
+        When updating disks.*.size, the system protects against accidental
+        shrinkage and associated data loss. If the size of a disk is reduced,
+        the end of the disk is removed. If that space contains data, it is
+        permanently lost. Snapshots do not provide protection. To allow a disk
+        to shrink, set the dangerous_allow_shrink property to true. This
+        property is used only for the update - it is not stored. For example,
+        the following will resize a disk to 10 MiB, even if it had previously
+        been larger.
+
+         {
+           "update_disks": {
+             "path": "/dev/zvol/rdsk/zones/.../disk1",
+             "size": 10,
+             "dangerous_allow_shrink": true
+           }
+         }
+
         Those fields marked in the PROPERTIES section below as updatable and
         modified with '(live update)' mean that when you update the property
         the change takes effect immediately for the VM without the VM being
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index b68a4593..6c0efe71 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -143,6 +143,7 @@ var DEFAULT_MAX_MSG_IDS = 4096;
 var DEFAULT_MAX_SEM_IDS = 4096;
 var DEFAULT_MAX_SHM_IDS = 4096;
 var DEFAULT_MDATA_TIMEOUT = 300;
+var DEFAULT_VOLBLOCKSIZE = 8192;
 var DISABLED = 0;
 var MAX_HOSTVOL_FILE_BYTES = (10 * 1024 * 1024);
 var MAX_SNAPNAME_LENGTH = 64;
@@ -1462,7 +1463,6 @@ function setQuotaBhyve(opts, callback) {
     assert.number(opts.quota, 'opts.quota');
     assert.optionalNumber(opts.flexible_disk_size, 'opts.flexible_disk_size');
 
-
     var cancelFn = opts.cancelFn ? opts.cancelFn : noop;
 
     var log = opts.log;
@@ -2297,15 +2297,26 @@ function destroyVolume(volume, log, callback)
 // create a new zvol for a VM
 function createVolume(volume, opts, callback)
 {
+    assert.object(volume, 'volume');
+    assert.string(volume.zfs_filesystem, 'volume.zfs_filesystem');
+    assert.optionalNumber(volume.size, 'volume.size');              // MiB
+    // volume.block_size may be a number (bytes) or string (e.g. 64k)
+    assert(!volume.hasOwnProperty('block_size')
+        || ['string', 'number'].indexOf(typeof (volume.block_size)) !== -1,
+        'volume.block_size');
+    assert.optionalNumber(volume.image_size, 'volume.image_size');  // MiB
+    assert.optionalUuid(volume.image_uuid, 'volume.image_uuid');
     assert.object(opts, 'opts');
-    assert.string(opts.brand, 'opts.brand');
+    assert.string(opts.zpds, 'opts.zpds');
     assert.object(opts.log, 'opts.log');
+    assert.func(callback, 'callback');
 
     var log = opts.log;
-    var refreserv;
-    var size;
+    var refreserv;          // MiB or 'auto'
+    var size;               // MiB
     var snapshot;
     var tracers_obj;
+    var cloning = volume.hasOwnProperty('image_uuid');
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
         tracers_obj = traceUntilCallback('create-volume', log, callback);
@@ -2313,12 +2324,13 @@ function createVolume(volume, opts, callback)
         log = tracers_obj.log;
     }
 
-    log.debug('creating volume ' + JSON.stringify(volume));
+    log.debug({volume: volume}, 'creating volume');
 
-    if (volume.hasOwnProperty('image_size')) {
-        size = volume.image_size;
-    } else if (volume.hasOwnProperty('size')) {
+    if (volume.hasOwnProperty('size')) {
         size = volume.size;
+    } else if (volume.hasOwnProperty('image_size')) {
+        assert(cloning, 'image_size only valid with image_uuid');
+        size = volume.image_size;
     } else {
         callback(new Error('FATAL: createVolume(' + JSON.stringify(volume)
             + '): ' + 'has no size or image_size'));
@@ -2332,48 +2344,104 @@ function createVolume(volume, opts, callback)
         refreserv = 'auto';
     }
 
-    async.series([
-        function (cb) {
-            // Ensure we've got a snapshot if we're going to make a clone
-            if (!volume.hasOwnProperty('image_uuid')) {
-                cb();
+    createResizeDeleteVolume({
+        log: log,
+        zpds: opts.zpds,
+        volname: volume.zfs_filesystem,
+        newsize: size * 1024 * 1024,
+        getSpaceDeltaFunc: cloning ? getCloneMdSize : getNewMdSize,
+        volChangeFunc: cloning ? cloneVolumeFunc :  createVolumeFunc
+    }, callback);
+
+    // A getSpaceDeltaFunc for createResizeDeleteVolume()
+    function getCloneMdSize(_opts, _cb) {
+        assert.object(_opts, '_opts');
+        assert.number(_opts.newsize, '_opts.newsize');
+        assert.func(_cb, '_cb');
+        var newsize = _opts.newsize;
+        var image = volume.zpool + '/' + volume.image_uuid;
+
+        if (refreserv !== 'auto') {
+            _cb(null, 0);
+            return;
+        }
+
+        zfsGet(image, ['volblocksize'], log,
+            function getCloneVbs(err, props) {
+
+            if (err) {
+                log.error({err: err}, 'unable to calculate refreservation');
+                _cb(err);
                 return;
             }
 
-            snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
-            zfs(['get', '-Ho', 'value', 'name', snapshot], log,
-                function (err, fds) {
+            var res = volsizeToRefreservation({
+                volsize: newsize,
+                volblocksize: props.volblocksize,
+                copies: 1
+            });
+            _cb(null, res - newsize);
+        });
+    }
 
-                if (err) {
-                    if (fds.stderr.match('dataset does not exist')) {
-                        // no @final, so we'll make a new snapshot @<uuid>
-                        snapshot = volume.zpool + '/' + volume.image_uuid
-                            + '@' + volume.uuid;
+    // A getSpaceDeltaFunc for createResizeDeleteVolume()
+    function getNewMdSize(_opts, _cb) {
+        assert.object(_opts, '_opts');
+        assert.number(_opts.newsize, '_opts.newsize');
+        assert.func(_cb, '_cb');
+        var newsize = _opts.newsize;
+        var vbs = volume.block_size || DEFAULT_VOLBLOCKSIZE;
 
-                        zfs(['snapshot', snapshot], log, function (e) {
-                            cb(e);
-                        });
-                    } else {
-                        cb(err);
+        if (refreserv !== 'auto') {
+            log.debug({volume: volume, refreserv: refreserv},
+                'getNewMdSize not altering metadata reservation');
+            _cb(null, 0);
+            return;
+        }
+
+        var res = volsizeToRefreservation({
+            volsize: newsize,
+            volblocksize: vbs,
+            copies: 1
+        });
+        _cb(null, res - newsize);
+    }
+
+    // A volChangeFunc for createResizeDeleteVolume()
+    function cloneVolumeFunc(_opts, cvfcb) {
+        assert.object(_opts, '_opts');
+        assert.string(_opts.volname, '_opts.volname');
+        assert.func(cvfcb, 'cvfcb');
+        var target = _opts.volname;
+
+        async.series([
+            function cvfFinalSnapshot(cb) {
+                snapshot = volume.zpool + '/' + volume.image_uuid + '@final';
+                zfs(['get', '-Ho', 'value', 'name', snapshot], log,
+                    function findSnap(err, fds) {
+
+                    if (err) {
+                        if (fds.stderr.match('dataset does not exist')) {
+                            // no @final, so we'll make a new snapshot @<uuid>
+                            snapshot = volume.zpool + '/' + volume.image_uuid
+                                + '@' + volume.uuid;
+
+                            zfs(['snapshot', snapshot], log, cb);
+                        } else {
+                            cb(err);
+                        }
+                        return;
                     }
-                    return;
-                }
 
-                // @final is here!
-                cb();
-            });
-        }, function (cb) {
-            var args;
-            var target;
-
-            // We write to volume.zfs_filesystem here so that the caller knows
-            // what name we gave the newly-created volume.
-            volume.zfs_filesystem = volume.zpool + '/' + volume.uuid;
-            target = volume.zfs_filesystem;
-            if (volume.hasOwnProperty('image_uuid')) {
-                // This volume is from a template/dataset/image so we create
-                // it as a clone of a the @final snapshot on the original.
-                // we already set 'snapshot' to the correct location above.
+                    // @final is here!
+                    cb();
+                });
+            }, function cvfClone(cb) {
+                var args;
+
+                // This volume is from a template/dataset/image so we create it
+                // as a clone of a the @final snapshot on the original.  We
+                // already set 'snapshot' to the correct location above.
                 args = ['clone', '-F'];
                 if (volume.hasOwnProperty('compression')) {
                     args.push('-o', 'compression='
@@ -2401,41 +2469,50 @@ function createVolume(volume, opts, callback)
                     volume.path = '/dev/zvol/rdsk/' + target;
                     cb();
                 });
+            }
+        ], function cvfDone(err, results) {
+            if (err) {
+                log.error({err: err, volume: volume},
+                    'failed to clone volume');
             } else {
-                // This volume is not from a template/dataset/image so we create
-                // a blank new zvol for it.
-                args = ['create'];
-                if (volume.hasOwnProperty('compression')) {
-                    args.push('-o', 'compression='
-                        + volume.compression);
-                }
-                if (volume.hasOwnProperty('block_size')) {
-                    args.push('-o', 'volblocksize='
-                        + volume.block_size);
-                }
-                if (refreserv !== 'auto') {
-                    args.push('-o', 'refreservation=' + refreserv + 'M');
-                }
-                args.push('-V', size + 'M', target);
-                zfs(args, log, function (err, fds) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-
-                    volume.path = '/dev/zvol/rdsk/' + target;
-                    cb();
-                });
+                log.debug({volume: volume}, 'successfully cloned volume');
             }
+            cvfcb(err);
+        });
+    }
+
+    // A volChangeFunc for createResizeDeleteVolume()
+    function createVolumeFunc(_opts, cvfcb) {
+        assert.object(_opts, '_opts');
+        assert.string(_opts.volname, '_opts.volname');
+        assert.func(cvfcb, 'cvfcb');
+        var target = _opts.volname;
+
+        // This volume is not from a template/dataset/image so we
+        // create a blank new zvol for it.
+        var args = ['create'];
+        if (volume.hasOwnProperty('compression')) {
+            args.push('-o', 'compression='
+                + volume.compression);
         }
-    ], function (err, results) {
-        if (err) {
-            log.error({err: err, volume: volume}, 'failed to create volume');
-        } else {
-            log.debug({volume: volume}, 'successfully created volume');
+        if (volume.hasOwnProperty('block_size')) {
+            args.push('-o', 'volblocksize='
+                + volume.block_size);
         }
-        callback(err);
-    });
+        if (refreserv !== 'auto') {
+            args.push('-o', 'refreservation=' + refreserv + 'M');
+        }
+        args.push('-V', size + 'M', target);
+        zfs(args, log, function (err, fds) {
+            if (err) {
+                cvfcb(err);
+                return;
+            }
+
+            volume.path = '/dev/zvol/rdsk/' + target;
+            cvfcb();
+        });
+    }
 }
 
 /*
@@ -2978,15 +3055,20 @@ function createFilesystems(payload, filesystems, log, callback)
     });
 }
 
-// Create all the KVM volumes for a given VM property set
+// Create all the disk volumes for a given VM
 function createVolumes(payload, log, callback)
 {
+    assert.object(payload, 'payload');
+    assert.string(payload.zfs_filesystem, 'payload.zfs_filesystem');
+    assert.optionalArrayOfObject(payload.add_disks, 'payload.add_disks');
+    assert.func(callback, 'callback');
     var createme = [];
     var d;
     var disk;
     var disk_idx = 0;
     var tracers_obj;
     var used_disk_indexes = [];
+    var zvolfmt = payload.brand === 'bhyve' ? '%s/%s/disk%d' : '%s/%s-disk%d';
 
     assert(log, 'no logger passed to createVolumes()');
 
@@ -3014,16 +3096,12 @@ function createVolumes(payload, log, callback)
                     disk_idx++;
                 }
 
-                d.index = disk_idx;
-                if (payload.brand === 'bhyve') {
-                    d.uuid = payload.uuid + '/disk' + disk_idx;
-                } else {
-                    d.uuid = payload.uuid + '-disk' + disk_idx;
-                }
                 used_disk_indexes.push(Number(disk_idx));
                 if (!d.hasOwnProperty('zpool')) {
                     d.zpool = payload.zpool;
                 }
+                d.zfs_filesystem =
+                    sprintf(zvolfmt, d.zpool, payload.uuid, disk_idx);
                 createme.push(d);
             }
         }
@@ -3031,7 +3109,7 @@ function createVolumes(payload, log, callback)
 
     function _loggedCreateVolume(volume, cb) {
         return createVolume(volume, {
-            brand: payload.brand,
+            zpds: payload.zfs_filesystem,
             log: log
         }, cb);
     }
@@ -3618,7 +3696,8 @@ function createVM(payload, log, callback)
 
     var created_zoneroot = false;
     var tracers_obj;
-    var zoneroot = payload.zpool + '/' + payload.uuid;
+    var zonepath_ds = payload.zpool + '/' + payload.uuid;
+    payload.zfs_filesystem = zonepath_ds;
 
     assert(log, 'no logger passed to createVM()');
 
@@ -3650,7 +3729,7 @@ function createVM(payload, log, callback)
             //
             //  zones/<uuid>/disk0
             //
-            args = ['create', zoneroot];
+            args = ['create', zonepath_ds];
 
             zfs(args, log, function _onZfsCreate(err) {
                 if (!err) {
@@ -3658,19 +3737,19 @@ function createVM(payload, log, callback)
                 }
                 cb(err);
             });
-        }, function (cb) {
+        }, function _createVolumes(cb) {
             if (payload.create_only) {
                 cb();
                 return;
             }
             createVolumes(payload, log, cb);
-        }, function (cb) {
+        }, function _setQuotaBhyve(cb) {
             if (payload.brand !== 'bhyve') {
                 cb();
                 return;
             }
             setQuotaBhyve({
-                dataset: zoneroot,
+                dataset: zonepath_ds,
                 log: log,
                 flexible_disk_size: payload.flexible_disk_size,
                 quota: payload.quota
@@ -3678,9 +3757,8 @@ function createVM(payload, log, callback)
         }, function (cb) {
             createZone(payload, log, cb);
         }
-    ], function (err, results) {
+    ], function _createVMdone(err, results) {
         var zonecfg_file = zoneXMLPath(payload.uuid);
-        var zonepath_ds = payload.zpool + '/' + payload.uuid;
 
         if (!err) {
             callback(null, results);
@@ -4126,6 +4204,110 @@ function zfs(args, log, callback)
     });
 }
 
+/*
+ * For the one dataset, get the values of the properties in the props array.
+ * On success, callback(null, props) is called, where props is an object that
+ * has properties as the keys. Properties that are typically integers are
+ * returned as integers. However, if 'zfs get' returns a string that doesn't
+ * look like an integer (e.g. 'none' instead of '0'), the string is stored in
+ * the props object.
+ */
+function zfsGet(dataset, props, log, callback)
+{
+    assert.string(dataset, 'dataset');
+    assert.arrayOfString(props, 'properties');
+    assert.object(log, 'no logger passed to zfsGet()');
+    assert.func(callback, 'callback');
+    var ret = {};
+    var args = [ 'get', '-Hpo', 'property,value' ];
+
+    args.push(props.join(','));
+    args.push(dataset);
+
+    // Properties in this list will be returned as an integer if they look like
+    // integers.
+    var returnInt = [
+        // read-write properties first, as they are most likely to be used
+        'copies', 'filesystem_limit', 'quota', 'snapshot_limit', 'recordsize',
+        'refquota', 'refreservation', 'reservation', 'volsize',
+        // read-only properties
+        'available', 'createtxg', 'guid', 'logicalreferenced', 'logicalused',
+        'referenced', 'snapshot_count', 'used', 'usedbychildren',
+        'usedbydataset', 'usedbyrefreservation', 'usedbysnapshots', 'userrefs',
+        'volblocksize', 'written' ];
+
+    zfs(args, log, function _zfsGet(err, out) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        out.stdout.trim().split('\n').forEach(function zfsGetLine(line) {
+            var pv = line.split('\t');
+            var prop = pv[0];
+            var val = pv[1];
+            if (returnInt.indexOf(prop) !== -1) {
+                // val may be an integer, 'none', or perhaps other strings.
+                var num = jsprim.parseInteger(val);
+                if (!util.isError(num)) {
+                    val = num;
+                }
+            }
+            ret[prop] = val;
+        });
+        log.debug({dataset: dataset, props: props, ret: ret}, 'zfsGet');
+        callback(null, ret);
+    });
+}
+
+/*
+ * Calculate the zfs refreservation based on the volsize, volblocksize, and
+ * copies.  All values are in bytes.
+ *
+ * Example:
+ *
+ *  var refres;
+ *  ...
+ *  zfsGet(volname, [ 'copies', 'volblocksize', 'volsize' ],
+ *      function getCb(err, props) {
+ *
+ *      if (!err) {
+ *          refres = volSizeToRefReservation(props);
+ *      }
+ *  });
+ *
+ * Adapted from usr/src/lib/libzfs/common/libzfs_dataset.c and related headers.
+ */
+function volsizeToRefreservation(props)
+{
+    assert.object(props, 'props');
+    assert.number(props.copies, 'props.copies');
+    assert.number(props.volblocksize, 'props.volblocksize');
+    assert.number(props.volsize, 'props.volsize');
+    var copies = props.copies;
+    var volblocksize = props.volblocksize;
+    var volsize = props.volsize;
+
+    var SPA_BLKPTRSHIFT = 7;        /* blkptr_t is 128 bytes */
+    var SPA_DVAS_PER_BP = 3;        /* Number of DVAs in a bp */
+    var DN_MAX_INDBLKSHIFT = 17;    /* 128k */
+    var DNODES_PER_LEVEL_SHIFT = DN_MAX_INDBLKSHIFT - SPA_BLKPTRSHIFT;
+    var DNODES_PER_LEVEL = 1 << DNODES_PER_LEVEL_SHIFT;
+    var blocks = volsize / volblocksize;
+    var numdb = 7;
+
+    while (blocks > 1) {
+        blocks = Math.floor((blocks + DNODES_PER_LEVEL - 1) / DNODES_PER_LEVEL);
+        numdb += blocks;
+    }
+
+    numdb *= Math.min(SPA_DVAS_PER_BP, copies + 1);
+    volsize *= copies;
+
+    numdb *= 1 << DN_MAX_INDBLKSHIFT;
+    return volsize + numdb;
+}
+
 exports.getSysinfo = function (args, options, callback)
 {
     var cmd = '/usr/bin/sysinfo';
@@ -14425,10 +14607,14 @@ function resizeTmp(zonename, newsize, log, callback)
     });
 }
 
-function resizeDisks(disks, updates, log, callback)
+function resizeDisks(vmobj, updates, log, callback)
 {
-    var d;
-    var disk;
+    assert.object(vmobj, 'vmobj');
+    assert.arrayOfObject(vmobj.disks, 'vmobj.disks');
+    assert.string(vmobj.zfs_filesystem, 'vmobj.zfs_filesystem');
+    assert.arrayOfObject(updates, 'updates (array of disks)');
+    assert.func(callback, 'callback');
+    var vmDisks = vmobj.disks;
     var resized = 0;
     var tracers_obj;
     var vols = [];
@@ -14441,55 +14627,269 @@ function resizeDisks(disks, updates, log, callback)
         log = tracers_obj.log;
     }
 
-    for (disk in updates) {
-        disk = updates[disk];
-        for (d in disks) {
-            d = disks[d];
-            if (d.path === disk.path && disk.hasOwnProperty('size')) {
-                vols.push({'disk': d, 'new_size': disk.size});
+    updates.forEach(function eachUpdate(update) {
+        vmDisks.forEach(function eachDisk(vmDisk) {
+            if (vmDisk.path === update.path && update.hasOwnProperty('size')) {
+                vols.push({disk: vmDisk,
+                    new_size: update.size,
+                    allow_shrink: !!update.dangerous_allow_shrink
+                });
             }
+        });
+    });
+
+    async.forEachSeries(vols, resize, function (err) {
+        if (err) {
+            log.error(err, 'Unable to resize disks');
+            callback(err);
+            return;
         }
-    }
+
+        callback(null, resized);
+    });
 
     function resize(vol, cb) {
-        var args;
-        var dsk = vol.disk;
-        var size = vol.new_size;
+        var disk = vol.disk;
+        var newsize = vol.new_size;
 
-        if (!dsk.hasOwnProperty('zfs_filesystem')) {
-            cb(new Error('could not find zfs_filesystem in '
-                + JSON.stringify(dsk)));
+        if (!disk.hasOwnProperty('zfs_filesystem')) {
+            log.error({disk: disk}, 'resize: disk has no zfs_filesystem');
+            cb(new Error('failed to identify device to resize'));
             return;
         }
 
-        if (dsk.size > size) {
-            cb(new Error('cannot resize ' + dsk.zfs_filesystem
-                + ' new size must be greater than current size. ('
-                + dsk.size + ' > ' + dsk.size + ')'));
-            return;
+        if (disk.size > newsize) {
+            if (vol.allow_shrink) {
+                log.info({vol: vol}, 'resizeDisk shrinking disk');
+            } else {
+                log.debug({vol: vol}, 'refusing to shrink disk');
+                cb(new Error('cannot resize disk: new size must be greater '
+                    + 'than current size. ('
+                    + disk.size + ' > ' + newsize + ')'));
+                return;
+            }
         }
 
-        if (dsk.size === size) {
+        if (disk.size === newsize) {
             // no point resizing if the old+new are the same
             cb();
             return;
         }
 
-        args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
-        zfs(args, log, function (err, fds) {
-            resized++;
-            cb(err);
-        });
+        createResizeDeleteVolume({
+            log: log,
+            zpds: vmobj.zfs_filesystem,
+            volname: disk.zfs_filesystem,
+            newsize: newsize * 1024 * 1024,
+            getSpaceDeltaFunc: getRefresDelta,
+            volChangeFunc: setNewVolSize
+            }, cb);
+
+        /*
+         * A getSpaceDeltaFunc for createResizeDeleteVolume()
+         *
+         * Gets the size of the refreservation change that will happen as a
+         * result of resizing a volume. This is used to determine how much the
+         * quota and/or refereservation on the zone's dataset (zonepath dataset)
+         * will need to change to allow the resize.
+         *
+         * opts.volname The name of the zfs volume that is being resized.
+         * opts.newsize The new size of the volume in bytes.
+         *
+         * This is designed to be called as part of a vasync.pipeline. Upon
+         * completion, it will execute _cb(null, delta) or _cb(err).
+         */
+        function getRefresDelta(opts, _cb) {
+            assert.string(opts.volname, 'volname');
+            assert.number(opts.newsize, 'newsize');
+
+            zfsGet(opts.volname,
+                ['volsize', 'volblocksize', 'copies', 'refreservation'],
+                log, function _get_refres_cb(err, props) {
+
+                if (err) {
+                    _cb(err);
+                    return;
+                }
+
+                // Get the current size for 'auto'
+                var curRefres = props.refreservation;
+                var curAuto = volsizeToRefreservation(props);
+                var curMd = curAuto - props.volsize;
+
+                log.debug({
+                    props: props,
+                    curAuto: curAuto,
+                    curMd: curMd,
+                    volname: opts.volname
+                    }, 'getRefresDelta: before changes');
+
+                // Bail out if 'zfs set volsize' will not adjust refreservation.
+                if (curRefres !== curAuto) {
+                    _cb(null, 0);
+                    return;
+                }
+
+                // Calculate the new size for 'auto'.
+                props.volsize = opts.newsize;
+                var newAuto = volsizeToRefreservation(props);
+                var newMd = newAuto - props.volsize;
+
+                var delta = newMd - curMd;
+                log.debug({volname: opts.volname, delta: delta},
+                    'getRefresDelta: quota requires adjustment');
+
+                _cb(null, delta);
+            });
+        }
+
+        // A volChangeFunc for createResizeDeleteVolume()
+        function setNewVolSize(opts, _cb) {
+            assert.string(opts.volname, 'opts.volname');
+            assert.number(opts.newsize, 'opts.newsize');
+            zfs(['set', 'volsize=' + opts.newsize, opts.volname], log,
+                function _setNewVolSizeCb(err) {
+
+                if (err) {
+                    _cb(err);
+                    return;
+                }
+                resized++;
+                _cb();
+            });
+        }
     }
+}
 
-    async.forEachSeries(vols, resize, function (err) {
-        if (err) {
-            log.error(err, 'Unable to resize disks');
+/*
+ * Used when creating, resizing, or deleting a volume. When refreservation=auto,
+ * any change to volsize also requires changes to the parent filesystem's
+ * properties if that filesystem has quota and/or reservation set. This is
+ * because changing the volume's size will also change the amount of space
+ * required for the volume's metadata.
+ *
+ * opts.zpds                zonepath dataset (typically vmobj.zfs_filesystem)
+ * opts.volname             volume name (typical disks.*.zfs_filesystem)
+ * opts.newsize             target size of the volume, in bytes
+ * opts.getSpaceDeltaFunc   A function that will be called to determine how much
+ *                          more or less space will be required once
+ *                          opts.volChangeFunc() completes with success. This
+ *                          function must call its callback as cb(null, delta)
+ *                          or cb(err). The delta must only be the difference in
+ *                          metadata size.
+ * opts.volChangeFunc       A function that will perform whatever change is
+ *                          needed (create, delete, resize).
+ */
+function createResizeDeleteVolume(opts, callback)
+{
+    assert.string(opts.zpds, 'opts.zpds');
+    assert.string(opts.volname, 'opts.volname');
+    assert.number(opts.newsize, 'opts.newsize');
+    assert.equal(opts.newsize % (1024 * 1024), 0,
+        'newsize must be a whole number of MiB, specified in bytes');
+    assert.func(opts.getSpaceDeltaFunc, 'opts.getSpaceDeltaFunc');
+    assert.func(opts.volChangeFunc, 'opts.volChangeFunc');
+    assert.func(callback);
+
+    var log = opts.log;
+    var zpds = opts.zpds;
+    var volname = opts.volname;
+    var zpdsDelta;
+    var quota;
+    var resetQuotaOnError = false;
+
+    function bumpSpaceTo(_newsize, cb) {
+        zfs([ 'set', 'quota=' + _newsize, 'reservation=' + _newsize, zpds ],
+            log, cb);
+    }
+
+    vasync.waterfall([
+        function getDelta(next) {
+            // Quota adjustment needed only if disk is under zonepath dataset.
+            var prefix = zpds + '/';
+            if (volname.slice(0, prefix.length) !== prefix) {
+                log.debug({zpds: zpds, volname: volname},
+                    'createResizeDeleteVolume: no space adjustment required');
+                next(null, 0);
+                return;
+            }
+            opts.getSpaceDeltaFunc(opts, next);
+        }, function storeDelta(delta, next) {
+            log.debug('createResizeDeleteVolume: delta for ' + volname + ' is '
+                + delta);
+            zpdsDelta = delta;
+            assert.number(zpdsDelta, 'zpdsDelta');
+            next();
+        }, function getQuota(next) {
+            if (zpdsDelta === 0) {
+                next();
+                return;
+            }
+            zfsGet(zpds, ['quota'], log, function get_cb(err, props) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                if (props.quota === 0) {
+                    log.debug('createResizeDeleteVolume: no quota on '
+                        + volname);
+                    zpdsDelta = 0;
+                    next();
+                    return;
+                }
+                quota = props.quota;
+                next();
+            });
+        }, function raiseQuotaIfNecessary(next) {
+            if (zpdsDelta <= 0) {
+                next();
+                return;
+            }
+            log.debug('createResizeDeleteVolume: raising quota on ' + volname
+                + ' by ' + zpdsDelta);
+            bumpSpaceTo(quota + zpdsDelta, function _raise(err) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                resetQuotaOnError = true;
+                next();
+            });
+        }, function callvolChangeFunc(next) {
+            opts.volChangeFunc(opts, next);
+        }, function lowerQuotaIfNecessary(next) {
+            if (zpdsDelta >= 0) {
+                next();
+                return;
+            }
+            log.debug('createResizeDeleteVolume: reducing quota on ' + volname
+                + ' by ' + zpdsDelta);
+            bumpSpaceTo(quota + zpdsDelta, function _lower(err) {
+                next(err);
+            });
+        }
+    ], function _done(err) {
+        if (!err) {
+            callback();
+            return;
+        }
+        log.debug('createResizeDeleteVolume: failed to resize ' + volname + ': '
+            + err.message);
+        if (!resetQuotaOnError) {
             callback(err);
             return;
         }
 
-        callback(null, resized);
+        log.debug('createResizeDeleteVolume: attempting to reset quota on '
+            + zpds + ' to ' + quota);
+        bumpSpaceTo(quota, function _restore(_err) {
+            if (_err) {
+                log.debug('createResizeDeleteVolume: failed to restore quota: '
+                    + _err.message);
+            }
+            // Propagate original error, not the cleanup error.
+            callback(err);
+        });
     });
 }
 
@@ -15205,7 +15605,7 @@ function applyUpdates(oldobj, newobj, payload, log, cancelFn, callback)
             if (payload.hasOwnProperty('update_disks')
                 && oldobj.hasOwnProperty('disks')) {
 
-                resizeDisks(oldobj.disks, payload.update_disks, log,
+                resizeDisks(oldobj, payload.update_disks, log,
                     function (err, resized) {
                         // If any were resized, mark that we changed something
                         if (!err && resized > 0) {
@@ -15893,9 +16293,15 @@ exports.update = function (uuid, payload, options, callback)
                     }
                     assert.arrayOfObject(value, 'value');
 
+                    // Some properties (i.e. dangerous_allow_shrink) are
+                    // present to influence how the change is made and are not
+                    // persisted. Such properties are added to ignoreProps and
+                    // we don't watch for changes to them in vmobj.
+                    var ignoreProps = [];
                     switch (label) {
                     case 'disks':
                         identifierKey = 'path';
+                        ignoreProps.push('dangerous_allow_shrink');
                         break;
                     case 'nics':
                         identifierKey = 'mac';
@@ -15904,6 +16310,7 @@ exports.update = function (uuid, payload, options, callback)
                         log.warn({key: key}, 'skipping unknown key "%s"', key);
                         return;
                     }
+                    ignoreProps.push(identifierKey);
 
                     // build a map of identifier key => object
                     assert.arrayOfObject(vmobj[label], 'vmobj.' + label);
@@ -15928,7 +16335,7 @@ exports.update = function (uuid, payload, options, callback)
                         assert.object(orig, 'orig');
 
                         Object.keys(thing).forEach(function (_key) {
-                            if (_key === identifierKey)
+                            if (ignoreProps.indexOf(_key) !== -1)
                                 return;
 
                             var defaultPath = util.format('%s.*.%s',
@@ -16302,8 +16709,12 @@ exports.update = function (uuid, payload, options, callback)
                 }
 
                 // add the bits of payload createVolumes() needs.
-                p = {add_disks: disks, brand: vmobj.brand};
-                p.uuid = uuid;
+                p = {
+                    add_disks: disks,
+                    brand: vmobj.brand,
+                    zfs_filesystem: vmobj.zfs_filesystem,
+                    uuid: uuid
+                };
                 if (vmobj.hasOwnProperty('zpool')) {
                     p.zpool = vmobj.zpool;
                 }
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index 0edeb0c5..b4d191d1 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -589,6 +589,13 @@ exports.properties = {
             fields: ['compression'],
             types: ['volume']
         }
+    }, 'disks.*.dangerous_allow_shrink': {
+        payload: {
+            allowed: {
+                'bhyve': ['update']
+            },
+            type: 'boolean'
+        }
     }, 'disks.*.image_name': {
         deprecated: true,
         ignore: true,
@@ -680,7 +687,7 @@ exports.properties = {
     }, 'disks.*.size': {
         payload: {
             allowed: {
-                'bhyve': ['add'],
+                'bhyve': ['add', 'update'],
                 'kvm': ['add']
             },
             type: 'integer',
diff --git a/src/vm/tests/test-bhyve-disk-resize.js b/src/vm/tests/test-bhyve-disk-resize.js
index 4e0406a6..86f2d5f1 100644
--- a/src/vm/tests/test-bhyve-disk-resize.js
+++ b/src/vm/tests/test-bhyve-disk-resize.js
@@ -25,6 +25,7 @@
  */
 
 var assert = require('/usr/node/node_modules/assert-plus');
+var jsprim = require('/usr/vm/node_modules/jsprim');
 var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
 var vasync = require('/usr/vm/node_modules/vasync');
 var VM = require('/usr/vm/node_modules/VM');
@@ -55,18 +56,18 @@ before(function (cb) {
 });
 
 after(function (cb) {
-    if (vmobj) {
-        VM.delete(vmobj.uuid, {}, function _delete_cb(err) {
-            if (err) {
-                console.log(sprintf('Could not delete vm %s: %s', vmobj.uuid,
-                    err.message));
-            }
-            vmobj = undefined;
-            cb();
-        });
-    } else {
+    if (!vmobj) {
         cb();
+        return;
     }
+    VM.delete(vmobj.uuid, {}, function _delete_cb(err) {
+        if (err) {
+            console.log(sprintf('Could not delete vm %s: %s', vmobj.uuid,
+                err.message));
+        }
+        vmobj = undefined;
+        cb();
+    });
 });
 
 /*
@@ -89,8 +90,8 @@ after(function (cb) {
 function testCreateAndCheckDisks(opts) {
     var t = opts.t;
     var payload = opts.payload;
-    var disks = opts.disks;
     var update = opts.update;
+    var disks = opts.disks;
 
     vasync.waterfall([
         function _create(next) {
@@ -110,6 +111,7 @@ function testCreateAndCheckDisks(opts) {
                 next();
                 return;
             }
+            update = expandDiskPaths(update);
             VM.update(vmobj.uuid, update, function _update_cb(err) {
                 if (err) {
                     t.ok(false, 'error updating VM: ' + err);
@@ -138,61 +140,24 @@ function testCreateAndCheckDisks(opts) {
                 uuid: vmobj.uuid
             }));
         }
-    ], function _done(err) {
-        t.end(err);
-    });
-}
-
-function dup(thing) {
-    return JSON.parse(JSON.stringify(thing));
-}
-
-function checkDisks(opts) {
-    var t = opts.t;
-    var haves = opts.haves;
-    var uuid = opts.uuid;
-    var wants = opts.wants;
-    var errors = 0;
-
-    wants.forEach(function _check_disk(want) {
-        var found = false;
-        var path = sprintf(want.path, uuid);
-
-        t.ok(true, 'Checking disk ' + path);
-
-        haves.filter(function filter_disks(have) {
-            return path == have.path;
-        }).forEach(function _select_disk(have) {
-            found = true;
-            Object.keys(want).forEach(function _check_prop(prop) {
-                if (prop === 'path') {
-                    return;
-                }
-                var haveval = have[prop];
-                var wantval = want[prop];
-                t.equal(haveval, wantval,
-                    'matching prop: ' + prop + '=' + haveval);
-                if (haveval !== wantval) {
-                    errors++;
-                }
-            });
+        ], function (err) {
+            t.end();
         });
-        t.ok(found, 'disk ' + path + ' found');
-        if (!found) {
-            errors++;
-        }
-    });
-    if (errors !== 0) {
-        return new Error('checkDisks encountered ' + errors + ' error(s)');
-    }
-    return null;
 }
 
 /*
- * VM.create() is expected to fail with an Error message that starts with
- * opts.expect.
+ * This is the main driver for tests that will fail during VM.create().
+ *
+ * opts.t           test object
+ * opts.payload     VM.create payload. Most likely should have autoboot set to
+ *                  false.
+ * opts.expect      A string containing the beginning of Error.message that is
+ *                  expected.  Up to one '%s' will be replaced by the instance
+ *                  uuid via sprintf().  Any other percent symbols should be
+ *                  escaped with %, as is common with strings passed to sprintf.
  */
 function testFailCreate(opts) {
+    assert.object(opts, 'opts');
     assert.object(opts.t, 't must be test object');
     assert.object(opts.payload, 'payload must be an object');
     assert.string(opts.expect, 'expect must be a string');
@@ -231,10 +196,118 @@ function testFailCreate(opts) {
             });
         }
         ], function _done(err) {
-            t.end(err);
+            t.end();
         });
 }
 
+/*
+ * This is the main driver for tests that will fail during VM.update().
+ *
+ * opts.t           test object
+ * opts.payload     VM.create payload. Most likely should have autoboot set to
+ *                  false.
+ * opts.update      VM.update payload
+ * opts.expect      A string containing the beginning of Error.message that is
+ *                  expected.  Up to one '%s' will be replaced by the instance
+ *                  uuid via sprintf().  Any other percent symbols should be
+ *                  escaped with %, as is common with strings passed to sprintf.
+ */
+function testCreateAndFailUpdate(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.t, 't must be test object');
+    assert.object(opts.payload, 'payload must be an object');
+    assert.object(opts.update, 'update must be an object');
+    assert.string(opts.expect, 'expect must be a string');
+    assert.notEqual(opts.expect.length, 0, 'expect must not be empty');
+
+    var t = opts.t;
+    var payload = opts.payload;
+    var update = opts.update;
+    var expect = opts.expect;
+
+    vasync.waterfall([
+        function _create(next) {
+            VM.create(payload, function _create_cb(err, obj) {
+                vmobj = obj;
+                expect = sprintf(expect, vmobj.uuid);
+
+                next(err);
+            });
+        },
+        function _update(next) {
+            update = expandDiskPaths(update);
+            VM.update(vmobj.uuid, update, function _update_cb(err) {
+                if (err) {
+                    t.equal(err.message.substring(0, expect.length), expect,
+                        'error detected');
+                } else {
+                    t.ok(false, 'No error detected');
+                }
+                next();
+            });
+        }
+        ], function (err) {
+            t.end();
+        });
+}
+
+function expandDiskPaths(payload) {
+    assert.uuid(vmobj.uuid);
+    if (!payload || !payload.hasOwnProperty('update_disks')) {
+        return (payload);
+    }
+
+    payload = jsprim.deepCopy(payload);
+    payload.update_disks.forEach(function expandDisk(disk) {
+        if (disk.hasOwnProperty('path')) {
+            disk.path = sprintf(disk.path, vmobj.uuid);
+        }
+    });
+
+    return payload;
+}
+
+function checkDisks(opts) {
+    var t = opts.t;
+    var haves = opts.haves;
+    var uuid = opts.uuid;
+    var wants = opts.wants;
+    var errors = 0;
+
+    wants.forEach(function _check_disk(want) {
+        var found = false;
+        var path = sprintf(want.path, uuid);
+
+        t.ok(true, 'Checking disk ' + path);
+
+        haves.filter(function filter_disks(have) {
+            return path == have.path;
+        }).forEach(function _select_disk(have) {
+            found = true;
+            Object.keys(want).forEach(function _check_prop(prop) {
+                if (prop === 'path') {
+                    return;
+                }
+                var haveval = have[prop];
+                var wantval = want[prop];
+                t.equal(haveval, wantval,
+                    'matching prop: ' + prop + '=' + haveval);
+                if (haveval !== wantval) {
+                    errors++;
+                }
+            });
+        });
+        t.ok(found, 'disk ' + path + ' found');
+        if (!found) {
+            errors++;
+        }
+    });
+    if (errors !== 0) {
+        return new Error('checkDisks encountered ' + errors + ' error(s)');
+    }
+    return null;
+}
+
 /*
  * Common payload elements
  */
@@ -266,7 +339,7 @@ var base_payload = {
 
 test('boot disk is grown when size > image_size',
     function _verify_grow_boot_disk(t) {
-        var payload = dup(base_payload);
+        var payload = jsprim.deepCopy(base_payload);
         var newsize = image_size + 1024;
         var check_disks = [
             {
@@ -287,7 +360,7 @@ test('boot disk is grown when size > image_size',
 
 test('create fails when size < image_size',
     function _conflict_no_shrink_boot_disk(t) {
-        var payload = dup(base_payload);
+        var payload = jsprim.deepCopy(base_payload);
         payload.disks[0].size = image_size - 1024;
 
         testFailCreate({
@@ -296,3 +369,191 @@ test('create fails when size < image_size',
             expect: 'Invalid value(s) for: size'
         });
     });
+
+test('boot disk can be grown with update_disk',
+    function _verify_disk0_grow_with_update_disk(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var newsize = image_size + 1024;
+        var update = {
+            update_disks: [
+                {
+                    path: '/dev/zvol/rdsk/zones/%s/disk0',
+                    size: newsize
+                }
+            ]
+        };
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                size: newsize
+            }
+        ];
+
+        payload.flexible_disk_size = newsize;
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            update: update,
+            disks: check_disks
+        });
+    });
+
+test('data disk can be grown with update_disk',
+    function _verify_disk1_grow_with_update_disk(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var datasize = 2048;
+        payload.disks.push({model: 'virtio', size: datasize});
+        var newsize =  datasize + 1024;
+        var update = {
+            update_disks: [
+                {
+                    path: '/dev/zvol/rdsk/zones/%s/disk1',
+                    size: newsize
+                }
+            ]
+        };
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                size: image_size
+            }, {
+                path: '/dev/zvol/rdsk/zones/%s/disk1',
+                image_uuid: undefined,
+                size: newsize
+            }
+        ];
+
+        payload.flexible_disk_size = image_size + newsize;
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            update: update,
+            disks: check_disks
+        });
+    });
+
+test('disk can be shrunk with update_disk',
+    function _verify_disk1_shrink_with_update_disk(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var datasize = 2048;
+        payload.disks.push({model: 'virtio', size: datasize});
+        var newsize =  datasize - 1024;
+        var update = {
+            update_disks: [
+                {
+                    path: '/dev/zvol/rdsk/zones/%s/disk1',
+                    size: newsize,
+                    dangerous_allow_shrink: true
+                }
+            ]
+        };
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                size: image_size
+            }, {
+                path: '/dev/zvol/rdsk/zones/%s/disk1',
+                image_uuid: undefined,
+                size: newsize
+            }
+        ];
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            update: update,
+            disks: check_disks
+        });
+    });
+
+test('disk shrink protection works',
+    function _verify_disk1_shrink_fail(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var datasize = 2048;
+        payload.disks.push({model: 'virtio', size: datasize});
+        var newsize =  datasize - 1024;
+        var update = {
+            update_disks: [
+                {
+                    path: '/dev/zvol/rdsk/zones/%s/disk1',
+                    size: newsize
+                }
+            ]
+        };
+
+        payload.flexible_disk_size = image_size + datasize;
+
+        testCreateAndFailUpdate({
+            t: t,
+            payload: payload,
+            update: update,
+            expect: 'first of 1 error: cannot resize '
+        });
+    });
+
+test('grow fails without flexible_disk_size',
+    function _grow_fails_enospc(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var datasize = 2048;
+        payload.disks.push({model: 'virtio', size: datasize});
+        var newsize =  datasize + 1;
+        var update = {
+            update_disks: [
+                {
+                    path: '/dev/zvol/rdsk/zones/%s/disk1',
+                    size: newsize
+                }
+            ]
+        };
+        var expect = 'first of 1 error: Command failed: cannot set property '
+            + 'for \'zones/%s/disk1\': size is greater than available space';
+
+        testCreateAndFailUpdate({
+            t: t,
+            payload: payload,
+            update: update,
+            expect: expect
+        });
+    });
+
+test('add a disk works up to flexible_disk_size',
+    function _add_disk_use_all_flexible_space(t) {
+        var payload = jsprim.deepCopy(base_payload);
+        var newsize = 1024;
+        var update = {
+            add_disks: [
+                {
+                    model: 'virtio',
+                    size: newsize
+                }
+            ]
+        };
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                size: image_size
+            }, {
+                path: '/dev/zvol/rdsk/zones/%s/disk1',
+                size: newsize
+            }
+        ];
+
+        payload.flexible_disk_size = image_size + newsize;
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            update: update,
+            disks: check_disks
+        });
+    });
-- 
2.21.0

