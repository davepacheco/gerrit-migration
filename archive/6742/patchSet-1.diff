commit fcaeecded1bcce8507dc916b40431bcfc50ee72b
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-08-02T10:29:56-06:00 (9 weeks ago)
    
    MANTA-4392 Format code with rustfmt

diff --git a/.cargo/config b/.cargo/config
new file mode 100644
index 0000000..63d14d9
--- /dev/null
+++ b/.cargo/config
@@ -0,0 +1,2 @@
+[target.release]
+rustflags = ["-C force-frame-pointers=yes"]
\ No newline at end of file
diff --git a/src/bucket.rs b/src/bucket.rs
index def2e12..509cca8 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -17,20 +17,20 @@ type Timestamptz = chrono::DateTime<chrono::Utc>;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct GetBucketPayload {
-    pub owner      : Uuid,
-    pub name       : String,
-    pub vnode      : u64,
-    pub request_id : Uuid
+    pub owner: Uuid,
+    pub name: String,
+    pub vnode: u64,
+    pub request_id: Uuid,
 }
 
 pub type DeleteBucketPayload = GetBucketPayload;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct BucketResponse {
-    pub id         : Uuid,
-    pub owner      : Uuid,
-    pub name       : String ,
-    pub created    : Timestamptz
+    pub id: Uuid,
+    pub owner: Uuid,
+    pub name: String,
+    pub created: Timestamptz,
 }
 
 pub(self) fn to_json(br: BucketResponse) -> Value {
@@ -56,11 +56,7 @@ pub(self) fn bucket_already_exists() -> Value {
         .expect("failed to encode a BucketAlreadyExists error")
 }
 
-pub(self) fn response(
-    method: &str,
-    rows: Rows
-) -> Result<Option<BucketResponse>, String>
-{
+pub(self) fn response(method: &str, rows: Rows) -> Result<Option<BucketResponse>, String> {
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
@@ -69,26 +65,31 @@ pub(self) fn response(
 
         if cols >= 4 {
             let resp = BucketResponse {
-                id             : row.get("id"),
-                owner          : row.get("owner"),
-                name           : row.get("name"),
-                created        : row.get("created")
+                id: row.get("id"),
+                owner: row.get("owner"),
+                name: row.get("name"),
+                created: row.get("created"),
             };
             Ok(Some(resp))
         } else {
-            let err = format!("{} query returned a row with only {} columns, \
-                               but 4 were expected .", method, cols);
+            let err = format!(
+                "{} query returned a row with only {} columns, \
+                 but 4 were expected .",
+                method, cols
+            );
             Err(err.to_string())
         }
     } else {
         // The schema should prevent there ever being multiple rows in the query result
-        let err = format!("{} query found {} results, but expected only 1.",
-                          method, rows.len());
+        let err = format!(
+            "{} query found {} results, but expected only 1.",
+            method,
+            rows.len()
+        );
         Err(err.to_string())
     }
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -135,7 +136,7 @@ mod test {
                 owner,
                 name,
                 vnode,
-                request_id
+                request_id,
             }
         }
     }
@@ -151,7 +152,7 @@ mod test {
                 id,
                 owner,
                 name,
-                created
+                created,
             }
         }
     }
diff --git a/src/bucket/create.rs b/src/bucket/create.rs
index 55ecafe..e89446c 100644
--- a/src/bucket/create.rs
+++ b/src/bucket/create.rs
@@ -1,44 +1,33 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::bucket::{
-    BucketResponse,
-    bucket_already_exists,
-    response,
-    to_json
-};
+use crate::bucket::{bucket_already_exists, response, to_json, BucketResponse};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "createbucket";
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateBucketPayload {
-    pub owner      : Uuid,
-    pub name       : String,
-    pub vnode      : u64,
-    pub request_id : Uuid
+    pub owner: Uuid,
+    pub name: String,
+    pub vnode: u64,
+    pub request_id: Uuid,
 }
 
 pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger)
-    -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<CreateBucketPayload>>(data.clone())
@@ -62,21 +51,24 @@ pub(crate) fn handler(
             create(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
-                    let value =
-                        match maybe_resp {
-                            Some(resp) => to_json(resp),
-                            None => bucket_already_exists()
-                        };
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    debug!(
+                        log,
+                        "{} operation was successful, req_id: {}", &METHOD, &req_id
+                    );
+                    let value = match maybe_resp {
+                        Some(resp) => to_json(resp),
+                        None => bucket_already_exists(),
+                    };
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -86,8 +78,7 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
@@ -96,40 +87,38 @@ pub(crate) fn handler(
 
 fn create(
     payload: CreateBucketPayload,
-    conn: &mut PostgresConnection
-) -> Result<Option<BucketResponse>, String>
-{
+    conn: &mut PostgresConnection,
+) -> Result<Option<BucketResponse>, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let create_sql = create_sql(payload.vnode);
 
-    sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
-                   &[&Uuid::new_v4(),
-                     &payload.owner,
-                     &payload.name])
-        .and_then(|rows| {
-            txn.commit()?;
-            Ok(rows)
-        })
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            response(METHOD, rows)
-        })
+    sql::txn_query(
+        sql::Method::BucketCreate,
+        &mut txn,
+        create_sql.as_str(),
+        &[&Uuid::new_v4(), &payload.owner, &payload.name],
+    )
+    .and_then(|rows| {
+        txn.commit()?;
+        Ok(rows)
+    })
+    .map_err(|e| e.to_string())
+    .and_then(|rows| response(METHOD, rows))
 }
 
-fn create_sql(
-    vnode: u64
-) -> String
-{
-    ["INSERT INTO manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket \
-       (id, owner, name) \
-       VALUES ($1, $2, $3) \
-       ON CONFLICT DO NOTHING \
-       RETURNING id, owner, name, created"].concat()
+fn create_sql(vnode: u64) -> String {
+    [
+        "INSERT INTO manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket \
+          (id, owner, name) \
+          VALUES ($1, $2, $3) \
+          ON CONFLICT DO NOTHING \
+          RETURNING id, owner, name, created",
+    ]
+    .concat()
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -173,7 +162,7 @@ mod test {
                 owner,
                 name,
                 vnode,
-                request_id
+                request_id,
             }
         }
     }
diff --git a/src/bucket/delete.rs b/src/bucket/delete.rs
index 44ae04d..311f021 100644
--- a/src/bucket/delete.rs
+++ b/src/bucket/delete.rs
@@ -1,22 +1,14 @@
 // Copyright 2019 Joyent, Inc.
 
-use slog::{Logger, debug, error, warn};
 use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::bucket::{
-    DeleteBucketPayload,
-    bucket_not_found
-};
+use crate::bucket::{bucket_not_found, DeleteBucketPayload};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "deletebucket";
 
@@ -24,16 +16,15 @@ pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<DeleteBucketPayload>>(data.clone())
         .map_err(|e| e.to_string())
         .and_then(|mut arr| {
             // Remove outer JSON array required by Fast
-            if !arr.is_empty(){
+            if !arr.is_empty() {
                 Ok(arr.remove(0))
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
@@ -50,29 +41,32 @@ pub(crate) fn handler(
             delete(payload, &mut conn)
                 .and_then(|affected_rows| {
                     // Handle the successful database response
-                    debug!(log, "deletebucket operation was successful, req_id: {}", &req_id);
-                    let value =
-                        if affected_rows > 0 {
-                            // This conversion can fail if the implementation of
-                            // Serialize decides to fail, or if the type
-                            // contains a map with non-string keys. There is no
-                            // reason for the former to occur and the latter
-                            // reason for failure is not a concern here since
-                            // the type of `affected_rows` is u64.
-                            serde_json::to_value(affected_rows).unwrap()
-                        } else {
-                            bucket_not_found()
-                        };
+                    debug!(
+                        log,
+                        "deletebucket operation was successful, req_id: {}", &req_id
+                    );
+                    let value = if affected_rows > 0 {
+                        // This conversion can fail if the implementation of
+                        // Serialize decides to fail, or if the type
+                        // contains a map with non-string keys. There is no
+                        // reason for the former to occur and the latter
+                        // reason for failure is not a concern here since
+                        // the type of `affected_rows` is u64.
+                        serde_json::to_value(affected_rows).unwrap()
+                    } else {
+                        bucket_not_found()
+                    };
 
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -82,62 +76,63 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
         .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(
-    payload: DeleteBucketPayload,
-    conn: &mut PostgresConnection
-) -> Result<u64, String>
-{
+fn delete(payload: DeleteBucketPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
 
-    sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                       &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
-                             &[&payload.owner,
-                               &payload.name])
-        })
-        .and_then(|row_count| {
-            txn.commit()?;
-            Ok(row_count)
-        })
-        .map_err(|e| e.to_string())
+    sql::txn_execute(
+        sql::Method::BucketDeleteMove,
+        &mut txn,
+        move_sql.as_str(),
+        &[&payload.owner, &payload.name],
+    )
+    .and_then(|_moved_rows| {
+        sql::txn_execute(
+            sql::Method::BucketDelete,
+            &mut txn,
+            delete_sql.as_str(),
+            &[&payload.owner, &payload.name],
+        )
+    })
+    .and_then(|row_count| {
+        txn.commit()?;
+        Ok(row_count)
+    })
+    .map_err(|e| e.to_string())
 }
 
-fn insert_delete_table_sql(
-    vnode: u64
-) -> String
-{
+fn insert_delete_table_sql(vnode: u64) -> String {
     let vnode_str = vnode.to_string();
-    ["INSERT INTO manta_bucket_",
-     &vnode_str,
-     &".manta_bucket_deleted_bucket \
-      (id, owner, name, created) \
-      SELECT id, owner, name, created \
-      FROM manta_bucket_",
-     &vnode_str,
-     &".manta_bucket \
-       WHERE owner = $1 \
-       AND name = $2"].concat()
+    [
+        "INSERT INTO manta_bucket_",
+        &vnode_str,
+        &".manta_bucket_deleted_bucket \
+          (id, owner, name, created) \
+          SELECT id, owner, name, created \
+          FROM manta_bucket_",
+        &vnode_str,
+        &".manta_bucket \
+          WHERE owner = $1 \
+          AND name = $2",
+    ]
+    .concat()
 }
 
-fn delete_sql(
-    vnode: u64
-) -> String
-{
-    ["DELETE FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket \
-       WHERE owner = $1 \
-       AND name = $2"].concat()
+fn delete_sql(vnode: u64) -> String {
+    [
+        "DELETE FROM manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket \
+          WHERE owner = $1 \
+          AND name = $2",
+    ]
+    .concat()
 }
diff --git a/src/bucket/get.rs b/src/bucket/get.rs
index b280182..334856a 100644
--- a/src/bucket/get.rs
+++ b/src/bucket/get.rs
@@ -1,25 +1,14 @@
 // Copyright 2019 Joyent, Inc.
 
-use slog::{Logger, debug, error, warn};
-use serde_json::{Value, json};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::bucket::{
-    GetBucketPayload,
-    BucketResponse,
-    bucket_not_found,
-    response,
-    to_json
-};
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::bucket::{bucket_not_found, response, to_json, BucketResponse, GetBucketPayload};
 use crate::sql;
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "getbucket";
 
@@ -27,9 +16,8 @@ pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<GetBucketPayload>>(data.clone())
@@ -53,21 +41,24 @@ pub(crate) fn handler(
             get(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
-                    let value =
-                        match maybe_resp {
-                            Some(resp) => to_json(resp),
-                            None => bucket_not_found()
-                        };
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    debug!(
+                        log,
+                        "{} operation was successful, req_id: {}", &METHOD, &req_id
+                    );
+                    let value = match maybe_resp {
+                        Some(resp) => to_json(resp),
+                        None => bucket_not_found(),
+                    };
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -77,8 +68,7 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
@@ -87,27 +77,27 @@ pub(crate) fn handler(
 
 fn get(
     payload: GetBucketPayload,
-    mut conn: &mut PostgresConnection
-) -> Result<Option<BucketResponse>, String>
-{
+    mut conn: &mut PostgresConnection,
+) -> Result<Option<BucketResponse>, String> {
     let sql = get_sql(payload.vnode);
 
-    sql::query(sql::Method::BucketGet, &mut conn, sql.as_str(),
-               &[&payload.owner,
-                 &payload.name])
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            response(METHOD, rows)
-        })
+    sql::query(
+        sql::Method::BucketGet,
+        &mut conn,
+        sql.as_str(),
+        &[&payload.owner, &payload.name],
+    )
+    .map_err(|e| e.to_string())
+    .and_then(|rows| response(METHOD, rows))
 }
 
-fn get_sql(
-    vnode: u64
-) -> String
-{
-    ["SELECT id, owner, name, created \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket WHERE owner = $1 \
-       AND name = $2"].concat()
+fn get_sql(vnode: u64) -> String {
+    [
+        "SELECT id, owner, name, created \
+         FROM manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket WHERE owner = $1 \
+          AND name = $2",
+    ]
+    .concat()
 }
diff --git a/src/bucket/list.rs b/src/bucket/list.rs
index b79f4ef..2b4dc69 100644
--- a/src/bucket/list.rs
+++ b/src/bucket/list.rs
@@ -1,44 +1,35 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::bucket::{
-    BucketResponse,
-    to_json
-};
+use crate::bucket::{to_json, BucketResponse};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "listbuckets";
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListBucketsPayload {
-    pub owner      : Uuid,
-    pub vnode      : u64,
-    pub prefix     : Option<String>,
-    pub limit      : u64,
-    pub marker     : Option<String>,
-    pub request_id : Uuid
+    pub owner: Uuid,
+    pub vnode: u64,
+    pub prefix: Option<String>,
+    pub limit: u64,
+    pub marker: Option<String>,
+    pub request_id: Uuid,
 }
 
 pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<ListBucketsPayload>>(data.clone())
@@ -63,12 +54,18 @@ pub(crate) fn handler(
                 list(msg_id, payload, &mut conn)
                     .and_then(|resp| {
                         // Handle the successful database response
-                        debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                        debug!(
+                            log,
+                            "{} operation was successful, req_id: {}", &METHOD, &req_id
+                        );
                         Ok(HandlerResponse::from(resp))
                     })
                     .or_else(|e| {
                         // Handle database error response
-                        error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                        error!(
+                            log,
+                            "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                        );
 
                         // Database errors are returned to as regular Fast messages
                         // to be handled by the calling application
@@ -77,23 +74,24 @@ pub(crate) fn handler(
                             "message": e
                         }));
                         let msg_data = FastMessageData::new(METHOD.into(), value);
-                        let msg: HandlerResponse =
-                            FastMessage::data(msg_id, msg_data).into();
+                        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                         Ok(msg)
                     })
             } else {
                 // Limit constraint violations are returned to as regular
                 // Fast messages to be handled by the calling application
-                let e = format!("the {} limit option must be a value between 1 \
-                                 and 1024. the requested limit was {}, req_id: \
-                                 {}", &METHOD, &payload.limit, &req_id);
+                let e = format!(
+                    "the {} limit option must be a value between 1 \
+                     and 1024. the requested limit was {}, req_id: \
+                     {}",
+                    &METHOD, &payload.limit, &req_id
+                );
                 let value = array_wrap(json!({
                     "name": "LimitConstraintError",
                     "message": e
                 }));
                 let msg_data = FastMessageData::new(METHOD.into(), value);
-                let msg: HandlerResponse =
-                    FastMessage::data(msg_id, msg_data).into();
+                let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                 Ok(msg)
             }
         })
@@ -103,95 +101,113 @@ pub(crate) fn handler(
 fn list(
     msg_id: u32,
     payload: ListBucketsPayload,
-    mut conn: &mut PostgresConnection
-) -> Result<Vec<FastMessage>, String>
-{
-    let query_result =
-        match (payload.marker, payload.prefix) {
-            (Some(marker), Some(prefix)) => {
-                let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
-                let prefix = format!("{}%", prefix);
-                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &prefix, &marker])
-            }
-            (Some(marker), None) => {
-                let sql = list_sql_marker(payload.vnode, payload.limit);
-                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &marker])
-            }
-            (None, Some(prefix)) => {
-                let sql = list_sql_prefix(payload.vnode, payload.limit);
-                let prefix = format!("{}%", prefix);
-                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &prefix])
-            }
-            (None, None) => {
-                let sql = list_sql(payload.vnode, payload.limit);
-                sql::query(sql::Method::BucketList, &mut conn, sql.as_str(),
-                           &[&payload.owner])
-            }
-        };
+    mut conn: &mut PostgresConnection,
+) -> Result<Vec<FastMessage>, String> {
+    let query_result = match (payload.marker, payload.prefix) {
+        (Some(marker), Some(prefix)) => {
+            let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
+            let prefix = format!("{}%", prefix);
+            sql::query(
+                sql::Method::BucketList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &prefix, &marker],
+            )
+        }
+        (Some(marker), None) => {
+            let sql = list_sql_marker(payload.vnode, payload.limit);
+            sql::query(
+                sql::Method::BucketList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &marker],
+            )
+        }
+        (None, Some(prefix)) => {
+            let sql = list_sql_prefix(payload.vnode, payload.limit);
+            let prefix = format!("{}%", prefix);
+            sql::query(
+                sql::Method::BucketList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &prefix],
+            )
+        }
+        (None, None) => {
+            let sql = list_sql(payload.vnode, payload.limit);
+            sql::query(
+                sql::Method::BucketList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner],
+            )
+        }
+    };
 
     let mut msgs: Vec<FastMessage> = Vec::with_capacity(1024);
 
-    query_result
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            for row in rows.iter() {
-                let resp = BucketResponse {
-                    id: row.get("id"),
-                    owner: row.get("owner"),
-                    name: row.get("name"),
-                    created: row.get("created")
-                };
+    query_result.map_err(|e| e.to_string()).and_then(|rows| {
+        for row in rows.iter() {
+            let resp = BucketResponse {
+                id: row.get("id"),
+                owner: row.get("owner"),
+                name: row.get("name"),
+                created: row.get("created"),
+            };
 
-                let value = to_json(resp);
-                let msg_data =
-                    FastMessageData::new(METHOD.into(), array_wrap(value));
-                let msg = FastMessage::data(msg_id, msg_data);
+            let value = to_json(resp);
+            let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+            let msg = FastMessage::data(msg_id, msg_data);
 
-                msgs.push(msg);
-            }
-            Ok(msgs)
-        })
+            msgs.push(msg);
+        }
+        Ok(msgs)
+    })
 }
 
 fn list_sql_prefix_marker(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, name, created
+    format!(
+        "SELECT id, owner, name, created
         FROM manta_bucket_{}.manta_bucket
         WHERE owner = $1 AND name like $2 AND name > $3
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
 fn list_sql_prefix(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, name, created
+    format!(
+        "SELECT id, owner, name, created
         FROM manta_bucket_{}.manta_bucket
         WHERE owner = $1 AND name like $2
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 fn list_sql_marker(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, name, created
+    format!(
+        "SELECT id, owner, name, created
         FROM manta_bucket_{}.manta_bucket
         WHERE owner = $1 AND name > $2
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
 fn list_sql(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, name, created
+    format!(
+        "SELECT id, owner, name, created
         FROM manta_bucket_{}.manta_bucket
         WHERE owner = $1
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -245,7 +261,7 @@ mod test {
                 prefix,
                 limit,
                 marker,
-                request_id
+                request_id,
             }
         }
     }
diff --git a/src/config.rs b/src/config.rs
index 9037a70..7bad29b 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -8,14 +8,13 @@
 /// implementations in this module.  These can first be overridden by a config
 /// file specified with `-c <config>`, and then overridden again by specific
 /// command line arguments.
-
 use std::convert::Into;
 use std::ffi::OsStr;
 use std::fs;
 use std::path::{Path, PathBuf};
 use std::str::FromStr;
 
-use clap::{ArgMatches, value_t};
+use clap::{value_t, ArgMatches};
 use serde_derive::Deserialize;
 use slog::Level;
 
@@ -44,7 +43,7 @@ pub enum LogLevel {
     Debug,
     /// Log everything
     #[serde(alias = "trace")]
-    Trace
+    Trace,
 }
 
 impl FromStr for LogLevel {
@@ -53,12 +52,12 @@ impl FromStr for LogLevel {
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         match s {
             "critical" => Ok(LogLevel::Critical),
-            "error"    => Ok(LogLevel::Error),
-            "warning"  => Ok(LogLevel::Warning),
-            "info"     => Ok(LogLevel::Info),
-            "debug"    => Ok(LogLevel::Debug),
-            "trace"    => Ok(LogLevel::Trace),
-            _          => Err("invalid log level")
+            "error" => Ok(LogLevel::Error),
+            "warning" => Ok(LogLevel::Warning),
+            "info" => Ok(LogLevel::Info),
+            "debug" => Ok(LogLevel::Debug),
+            "trace" => Ok(LogLevel::Trace),
+            _ => Err("invalid log level"),
         }
     }
 }
@@ -73,11 +72,11 @@ impl ToString for LogLevel {
     fn to_string(&self) -> String {
         match self {
             LogLevel::Critical => "critical".into(),
-            LogLevel::Error    => "error".into(),
-            LogLevel::Warning  => "warning".into(),
-            LogLevel::Info     => "info".into(),
-            LogLevel::Debug    => "debug".into(),
-            LogLevel::Trace    => "trace".into()
+            LogLevel::Error => "error".into(),
+            LogLevel::Warning => "warning".into(),
+            LogLevel::Info => "info".into(),
+            LogLevel::Debug => "debug".into(),
+            LogLevel::Trace => "trace".into(),
         }
     }
 }
@@ -86,11 +85,11 @@ impl From<LogLevel> for slog::Level {
     fn from(lvl: LogLevel) -> Self {
         match lvl {
             LogLevel::Critical => Level::Critical,
-            LogLevel::Error    => Level::Error,
-            LogLevel::Warning  => Level::Warning,
-            LogLevel::Info     => Level::Info,
-            LogLevel::Debug    => Level::Debug,
-            LogLevel::Trace    => Level::Trace
+            LogLevel::Error => Level::Error,
+            LogLevel::Warning => Level::Warning,
+            LogLevel::Info => Level::Info,
+            LogLevel::Debug => Level::Debug,
+            LogLevel::Trace => Level::Trace,
         }
     }
 }
@@ -102,18 +101,18 @@ pub struct Config {
     pub metrics: ConfigMetrics,
     pub database: ConfigDatabase,
     pub cueball: ConfigCueball,
-    pub tokio: ConfigTokio
+    pub tokio: ConfigTokio,
 }
 
 #[derive(Clone, Deserialize)]
 pub struct ConfigLog {
-    pub level: LogLevel
+    pub level: LogLevel,
 }
 
 impl Default for ConfigLog {
     fn default() -> Self {
         ConfigLog {
-            level: LogLevel::Debug
+            level: LogLevel::Debug,
         }
     }
 }
@@ -121,14 +120,14 @@ impl Default for ConfigLog {
 #[derive(Clone, Deserialize)]
 pub struct ConfigServer {
     pub host: String,
-    pub port: u16
+    pub port: u16,
 }
 
 impl Default for ConfigServer {
     fn default() -> Self {
         ConfigServer {
             host: "127.0.0.1".into(),
-            port: 2030
+            port: 2030,
         }
     }
 }
@@ -136,14 +135,14 @@ impl Default for ConfigServer {
 #[derive(Clone, Deserialize)]
 pub struct ConfigMetrics {
     pub host: String,
-    pub port: u16
+    pub port: u16,
 }
 
 impl Default for ConfigMetrics {
     fn default() -> Self {
         ConfigMetrics {
             host: "127.0.0.1".into(),
-            port: 3020
+            port: 3020,
         }
     }
 }
@@ -156,7 +155,7 @@ pub struct ConfigDatabase {
     pub database: String,
     pub application_name: String,
     pub tls_mode: TlsConnectMode,
-    pub certificate: Option<PathBuf>
+    pub certificate: Option<PathBuf>,
 }
 
 impl Default for ConfigDatabase {
@@ -168,7 +167,7 @@ impl Default for ConfigDatabase {
             database: "boray".to_owned(),
             application_name: "boray".into(),
             tls_mode: TlsConnectMode::Disable,
-            certificate: None
+            certificate: None,
         }
     }
 }
@@ -177,7 +176,7 @@ impl Default for ConfigDatabase {
 pub struct ConfigCueball {
     pub max_connections: u32,
     pub claim_timeout: Option<u64>,
-    pub rebalancer_action_delay: Option<u64>
+    pub rebalancer_action_delay: Option<u64>,
 }
 
 impl Default for ConfigCueball {
@@ -185,19 +184,18 @@ impl Default for ConfigCueball {
         ConfigCueball {
             max_connections: 10,
             claim_timeout: Some(500),
-            rebalancer_action_delay: Some(100)
+            rebalancer_action_delay: Some(100),
         }
     }
 }
 
-
 #[derive(Clone, Deserialize)]
 pub struct ConfigTokio {
     pub core_threads: usize,
     pub blocking_threads: usize,
     pub thread_keep_alive: u64,
     pub thread_stack_size: usize,
-    pub thread_name_prefix: String
+    pub thread_name_prefix: String,
 }
 
 impl Default for ConfigTokio {
@@ -207,13 +205,12 @@ impl Default for ConfigTokio {
             blocking_threads: 200,
             thread_keep_alive: 60,
             thread_stack_size: 2 * 1024 * 1024,
-            thread_name_prefix: "boray-worker-".into()
+            thread_name_prefix: "boray-worker-".into(),
         }
     }
 }
 
-pub fn read_file<F: AsRef<OsStr> + ?Sized>(f: &F) -> Config
-{
+pub fn read_file<F: AsRef<OsStr> + ?Sized>(f: &F) -> Config {
     let s = match fs::read(Path::new(&f)) {
         Ok(s) => s,
         Err(e) => {
@@ -222,11 +219,10 @@ pub fn read_file<F: AsRef<OsStr> + ?Sized>(f: &F) -> Config
         }
     };
 
-    toml::from_slice(&s)
-        .unwrap_or_else(|e| {
-            eprintln!("Failed to parse config file: {}", e);
-            std::process::exit(1);
-        })
+    toml::from_slice(&s).unwrap_or_else(|e| {
+        eprintln!("Failed to parse config file: {}", e);
+        std::process::exit(1);
+    })
 }
 
 pub fn read_cli_args(matches: &ArgMatches, config: &mut Config) {
@@ -277,7 +273,7 @@ pub mod tls {
     pub(crate) enum TlsError {
         NoCertificate,
         CertError(CertificateError),
-        IOError(io::Error)
+        IOError(io::Error),
     }
 
     impl From<io::Error> for TlsError {
@@ -295,18 +291,17 @@ pub mod tls {
     impl fmt::Display for TlsError {
         fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
             match self {
-                TlsError::NoCertificate => {
-                    write!(fmt, "no TLS certificate file given")
-                },
+                TlsError::NoCertificate => write!(fmt, "no TLS certificate file given"),
                 TlsError::CertError(ref e) => e.fmt(fmt),
-                TlsError::IOError(ref e) => e.fmt(fmt)
+                TlsError::IOError(ref e) => e.fmt(fmt),
             }
         }
     }
 
-    pub(crate) fn tls_config(mode: TlsConnectMode, o_p: Option<PathBuf>) ->
-        Result<TlsConfig, TlsError>
-    {
+    pub(crate) fn tls_config(
+        mode: TlsConnectMode,
+        o_p: Option<PathBuf>,
+    ) -> Result<TlsConfig, TlsError> {
         let cert_result = maybe_read_certificate(o_p);
         let cert_ok = cert_result.is_ok();
 
@@ -315,26 +310,26 @@ pub mod tls {
             TlsConnectMode::Allow => {
                 let cert_option = cert_result.ok();
                 Ok(TlsConfig::allow(cert_option))
-            },
+            }
             TlsConnectMode::Prefer => {
                 let cert_option = cert_result.ok();
                 Ok(TlsConfig::prefer(cert_option))
-            },
+            }
             TlsConnectMode::Require if cert_ok => {
                 // Unwrapping the result since we've verifed the Result is Ok in
                 // the guard
                 Ok(TlsConfig::require(cert_result.unwrap()))
-            },
+            }
             TlsConnectMode::VerifyCa if cert_ok => {
                 // Unwrapping the result since we've verifed the Result is Ok in
                 // the guard
                 Ok(TlsConfig::verify_ca(cert_result.unwrap()))
-            },
-            TlsConnectMode::VerifyFull if cert_ok  => {
+            }
+            TlsConnectMode::VerifyFull if cert_ok => {
                 // Unwrapping the result since we've verifed the Result is Ok in
                 // the guard
                 Ok(TlsConfig::verify_full(cert_result.unwrap()))
-            },
+            }
             _ => {
                 // If we arrive here we know that `cert_result` is an error of the
                 // type to be returned, but the compiler does not know this and
@@ -348,26 +343,16 @@ pub mod tls {
     /// If a certificate file path is present then open the file, read the
     /// bytes into a buffer, and attempt to interpret the bytes as a
     /// Certificate while handling errors along the way.
-    fn maybe_read_certificate(o_p: Option<PathBuf>) ->
-        Result<Certificate, TlsError>
-    {
+    fn maybe_read_certificate(o_p: Option<PathBuf>) -> Result<Certificate, TlsError> {
         let mut buf = vec![];
 
         o_p.ok_or(TlsError::NoCertificate)
-            .and_then(|p| {
-                File::open(p).map_err(Into::into)
-            })
-            .and_then(|mut f| {
-                f.read_to_end(&mut buf).map_err(Into::into)
-            })
-            .and_then(|_| {
-                read_certificate(&buf).map_err(Into::into)
-            })
+            .and_then(|p| File::open(p).map_err(Into::into))
+            .and_then(|mut f| f.read_to_end(&mut buf).map_err(Into::into))
+            .and_then(|_| read_certificate(&buf).map_err(Into::into))
     }
 
-    fn read_certificate(buf: &[u8]) ->
-        Result<Certificate, CertificateError>
-    {
+    fn read_certificate(buf: &[u8]) -> Result<Certificate, CertificateError> {
         Certificate::from_der(buf)?;
         Certificate::from_pem(buf)
     }
diff --git a/src/error.rs b/src/error.rs
index 886aeea..2f32871 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -3,15 +3,15 @@ use serde_derive::{Deserialize, Serialize};
 pub enum BorayErrorType {
     BucketAlreadyExists,
     BucketNotFound,
-    ObjectNotFound
+    ObjectNotFound,
 }
 
 impl ToString for BorayErrorType {
     fn to_string(&self) -> String {
         match *self {
             BorayErrorType::BucketAlreadyExists => "BucketAlreadyExists".into(),
-            BorayErrorType::BucketNotFound      => "BucketNotFound".into(),
-            BorayErrorType::ObjectNotFound      => "ObjectNotFound".into()
+            BorayErrorType::BucketNotFound => "BucketNotFound".into(),
+            BorayErrorType::ObjectNotFound => "ObjectNotFound".into(),
         }
     }
 }
@@ -19,35 +19,30 @@ impl ToString for BorayErrorType {
 impl BorayErrorType {
     fn message(&self) -> String {
         match *self {
-            BorayErrorType::BucketAlreadyExists =>
-                "requested bucket already exists".into(),
-            BorayErrorType::BucketNotFound =>
-                "requested bucket not found".into(),
-            BorayErrorType::ObjectNotFound =>
-                "requested object not found".into()
+            BorayErrorType::BucketAlreadyExists => "requested bucket already exists".into(),
+            BorayErrorType::BucketNotFound => "requested bucket not found".into(),
+            BorayErrorType::ObjectNotFound => "requested object not found".into(),
         }
     }
 }
 
 #[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
 pub struct BorayError {
-    pub error: BorayInnerError
+    pub error: BorayInnerError,
 }
 
 #[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
 pub struct BorayInnerError {
-    pub name    : String,
-    pub message : String
+    pub name: String,
+    pub message: String,
 }
 
 impl BorayError {
     pub fn new(error: BorayErrorType) -> Self {
         let inner = BorayInnerError {
             name: error.to_string(),
-            message: error.message()
+            message: error.message(),
         };
-        BorayError {
-            error: inner
-        }
+        BorayError { error: inner }
     }
 }
diff --git a/src/lib.rs b/src/lib.rs
index d83d433..4254029 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -15,8 +15,8 @@ pub mod util {
 
     use postgres::error::Error as PGError;
     use postgres::row::Row;
-    use serde_json::{Value, json};
-    use slog::{Logger, error, warn};
+    use serde_json::{json, Value};
+    use slog::{error, warn, Logger};
 
     use cueball::backend::Backend;
     use cueball::connection_pool::ConnectionPool;
@@ -36,12 +36,12 @@ pub mod util {
 
     pub(crate) enum HandlerError {
         Cueball(CueballError),
-        IO(IOError)
+        IO(IOError),
     }
 
     pub(crate) enum HandlerResponse {
         Message(FastMessage),
-        Messages(Vec<FastMessage>)
+        Messages(Vec<FastMessage>),
     }
 
     impl From<FastMessage> for HandlerResponse {
@@ -58,10 +58,13 @@ pub mod util {
 
     pub fn msg_handler(
         msg: &FastMessage,
-        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-        log: &Logger
-    ) -> Result<Vec<FastMessage>, IOError>
-    {
+        pool: &ConnectionPool<
+            PostgresConnection,
+            StaticIpResolver,
+            impl FnMut(&Backend) -> PostgresConnection + Send + 'static,
+        >,
+        log: &Logger,
+    ) -> Result<Vec<FastMessage>, IOError> {
         let now = Instant::now();
         let mut response: Vec<FastMessage> = vec![];
 
@@ -75,24 +78,15 @@ pub mod util {
             .and_then(|mut conn| {
                 // Dispatch the request to the proper handler
                 match method {
-                    "getobject"    =>
-                        object::get::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "createobject" =>
-                        object::create::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "updateobject" =>
-                        object::update::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "deleteobject" =>
-                        object::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "listobjects"  =>
-                        object::list::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "getbucket"    =>
-                        bucket::get::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "createbucket" =>
-                        bucket::create::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "deletebucket" =>
-                        bucket::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "listbuckets"  =>
-                        bucket::list::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "getobject" => object::get::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "createobject" => object::create::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "updateobject" => object::update::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "deleteobject" => object::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "listobjects" => object::list::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "getbucket" => bucket::get::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "createbucket" => bucket::create::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "deletebucket" => bucket::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "listbuckets" => bucket::list::handler(msg.id, &msg.data.d, &mut conn, &log),
                     _ => {
                         let err_msg = format!("Unsupported functon: {}", method);
                         Err(HandlerError::IO(other_error(&err_msg)))
@@ -116,26 +110,23 @@ pub mod util {
                         }));
 
                         let msg_data = FastMessageData::new(method.into(), value);
-                        let msg: HandlerResponse =
-                            FastMessage::data(msg.id, msg_data).into();
+                        let msg: HandlerResponse = FastMessage::data(msg.id, msg_data).into();
                         Ok(msg)
-                    },
+                    }
                     HandlerError::Cueball(err) => {
                         // Any other connection pool errors are unexpected in
                         // this context so log loudly and return an error.
                         error!(log, "{}", err);
                         Err(HandlerError::Cueball(err))
-                    },
-                    err => Err(err)
+                    }
+                    err => Err(err),
                 }
             })
             .and_then(|res| {
                 // Add application level response to the `response` vector
                 match res {
-                    HandlerResponse::Message(msg) =>
-                        response.push(msg),
-                    HandlerResponse::Messages(mut msgs) =>
-                        response.append(&mut msgs)
+                    HandlerResponse::Message(msg) => response.push(msg),
+                    HandlerResponse::Messages(mut msgs) => response.append(&mut msgs),
                 }
                 Ok(response)
             })
@@ -147,12 +138,7 @@ pub mod util {
                 let duration = now.elapsed();
                 let t = duration_to_seconds(duration);
 
-                let success =
-                    if connection_acquired {
-                        "true"
-                    } else {
-                        "false"
-                    };
+                let success = if connection_acquired { "true" } else { "false" };
 
                 metrics::FAST_REQUESTS
                     .with_label_values(&[&method, success])
@@ -174,8 +160,8 @@ pub mod util {
                 let ret_err = match err {
                     HandlerError::Cueball(cueball_err) => {
                         other_error(cueball_err.to_string().as_str())
-                    },
-                    HandlerError::IO(io_err) => io_err
+                    }
+                    HandlerError::IO(io_err) => io_err,
                 };
 
                 Err(ret_err)
diff --git a/src/main.rs b/src/main.rs
index aee1c6e..4680cef 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,19 +8,16 @@ use std::sync::Mutex;
 use std::thread;
 use std::time::Duration;
 
-use clap::{crate_version, crate_name};
-use slog::{Drain, LevelFilter, Logger, error, info, o};
+use clap::{crate_name, crate_version};
+use slog::{error, info, o, Drain, LevelFilter, Logger};
 use tokio::net::TcpListener;
 use tokio::prelude::*;
 use tokio::runtime;
 
-use cueball::connection_pool::ConnectionPool;
 use cueball::connection_pool::types::ConnectionPoolOptions;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::{PostgresConnection, PostgresConnectionConfig};
 use cueball_static_resolver::StaticIpResolver;
-use cueball_postgres_connection::{
-    PostgresConnection,
-    PostgresConnectionConfig
-};
 use rust_fast::server;
 
 use config::Config;
@@ -29,11 +26,10 @@ fn main() {
     let matches = boray::opts::parse(crate_name!());
 
     // Optionally read config file
-    let mut config: Config =
-        match matches.value_of("config") {
-            Some(f) => config::read_file(f),
-            None => Default::default()
-        };
+    let mut config: Config = match matches.value_of("config") {
+        Some(f) => config::read_file(f),
+        None => Default::default(),
+    };
 
     // Read CLI arguments
     config::read_cli_args(&matches, &mut config);
@@ -49,26 +45,22 @@ fn main() {
 
     let root_log = Logger::root(
         Mutex::new(LevelFilter::new(
-            slog_bunyan::with_name(crate_name!(), std::io::stdout())
-                .build(),
-            config.log.level.into()
-        )).fuse(),
-        o!("build-id" => crate_version!())
+            slog_bunyan::with_name(crate_name!(), std::io::stdout()).build(),
+            config.log.level.into(),
+        ))
+        .fuse(),
+        o!("build-id" => crate_version!()),
     );
 
     // Configure and start metrics server
     let metrics_log = root_log.clone();
     let metrics_host = config.metrics.host.clone();
     let metrics_port = config.metrics.port;
-    thread::spawn(move || boray::metrics::start_server(metrics_host,
-                                                       metrics_port,
-                                                       metrics_log));
+    thread::spawn(move || boray::metrics::start_server(metrics_host, metrics_port, metrics_log));
 
     info!(root_log, "establishing postgres connection pool");
 
-    let tls_config =
-        config::tls::tls_config(config.database.tls_mode,
-                                config.database.certificate)
+    let tls_config = config::tls::tls_config(config.database.tls_mode, config.database.certificate)
         .unwrap_or_else(|e| {
             error!(root_log, "TLS configuration error: {}", e);
             std::process::exit(1);
@@ -81,7 +73,7 @@ fn main() {
         port: Some(config.database.port),
         database: Some(config.database.database),
         application_name: Some(config.database.application_name),
-        tls_config
+        tls_config,
     };
 
     let connection_creator = PostgresConnection::connection_creator(pg_config);
@@ -90,23 +82,17 @@ fn main() {
         maximum: config.cueball.max_connections,
         claim_timeout: config.cueball.claim_timeout,
         log: root_log.clone(),
-        rebalancer_action_delay: config.cueball.rebalancer_action_delay
+        rebalancer_action_delay: config.cueball.rebalancer_action_delay,
     };
 
     let primary_backend = (pg_ip, config.database.port);
     let resolver = StaticIpResolver::new(vec![primary_backend]);
 
-    let pool = ConnectionPool::new(
-        pool_opts,
-        resolver,
-        connection_creator
-    );
+    let pool = ConnectionPool::new(pool_opts, resolver, connection_creator);
 
     info!(root_log, "established postgres connection pool");
 
-    let addr = [&config.server.host,
-                ":",
-                &config.server.port.to_string()].concat();
+    let addr = [&config.server.host, ":", &config.server.port.to_string()].concat();
     let addr = addr.parse::<SocketAddr>().unwrap();
 
     let listener = TcpListener::bind(&addr).expect("failed to bind");
@@ -114,22 +100,19 @@ fn main() {
 
     let process_log = root_log.clone();
     let err_log = root_log.clone();
-    let server = listener.incoming()
-        .map_err(move |e| {
-            error!(&err_log, "failed to accept socket"; "err" => %e)
-        })
-        .for_each(
-            move |socket| {
-                let pool_clone = pool.clone();
-                let task = server::make_task(
-                    socket,
-                    move |a, c| boray::util::msg_handler(a, &pool_clone, c),
-                    &process_log,
-                );
-                tokio::spawn(task);
-                Ok(())
-            }
-        );
+    let server = listener
+        .incoming()
+        .map_err(move |e| error!(&err_log, "failed to accept socket"; "err" => %e))
+        .for_each(move |socket| {
+            let pool_clone = pool.clone();
+            let task = server::make_task(
+                socket,
+                move |a, c| boray::util::msg_handler(a, &pool_clone, c),
+                &process_log,
+            );
+            tokio::spawn(task);
+            Ok(())
+        });
 
     let mut rt = runtime::Builder::new()
         .blocking_threads(config.tokio.blocking_threads)
@@ -143,6 +126,5 @@ fn main() {
     rt.spawn(server);
 
     // Wait until the runtime becomes idle and shut it down.
-    rt.shutdown_on_idle()
-        .wait().unwrap();
+    rt.shutdown_on_idle().wait().unwrap();
 }
diff --git a/src/metrics.rs b/src/metrics.rs
index ae520f3..628efd4 100644
--- a/src/metrics.rs
+++ b/src/metrics.rs
@@ -4,40 +4,45 @@
 
 use std::net::SocketAddr;
 
-use hyper::Body;
-use hyper::header::{CONTENT_TYPE, HeaderValue};
-use hyper::{Request, Response};
+use hyper::header::{HeaderValue, CONTENT_TYPE};
 use hyper::rt::{self, Future};
 use hyper::server::Server;
 use hyper::service::service_fn_ok;
+use hyper::Body;
 use hyper::StatusCode;
+use hyper::{Request, Response};
 use lazy_static::lazy_static;
-use prometheus::{HistogramVec, Counter, Encoder, TextEncoder, labels, opts, register_counter,
-register_histogram_vec, histogram_opts};
-use slog::{Logger, error, info};
-
+use prometheus::{
+    histogram_opts, labels, opts, register_counter, register_histogram_vec, Counter, Encoder,
+    HistogramVec, TextEncoder,
+};
+use slog::{error, info, Logger};
 
 lazy_static! {
     pub static ref INCOMING_REQUEST_COUNTER: Counter = register_counter!(opts!(
         "incoming_request_count",
         "Total number of Fast requests handled.",
         labels! {"handler" => "all",}
-    )).unwrap();
+    ))
+    .unwrap();
     pub static ref METRICS_REQUEST_COUNTER: Counter = register_counter!(opts!(
         "metrics_request_count",
         "Total number of metrics requests received.",
         labels! {"handler" => "all",}
-    )).unwrap();
+    ))
+    .unwrap();
     pub static ref FAST_REQUESTS: HistogramVec = register_histogram_vec!(
         "fast_requests",
         "Latency of all fast requests processed.",
         &["method", "success"]
-    ).unwrap();
+    )
+    .unwrap();
     pub static ref POSTGRES_REQUESTS: HistogramVec = register_histogram_vec!(
         "postgres_requests",
         "Latency of all postgres requests processed.",
         &["method", "success"]
-    ).unwrap();
+    )
+    .unwrap();
 }
 
 pub fn start_server(address: String, port: u16, log: Logger) {
@@ -58,9 +63,7 @@ pub fn start_server(address: String, port: u16, log: Logger) {
                 let encoder = TextEncoder::new();
                 encoder.encode(&metric_families, &mut buffer).unwrap();
 
-                let content_type = encoder.format_type()
-                    .parse::<HeaderValue>()
-                    .unwrap();
+                let content_type = encoder.format_type().parse::<HeaderValue>().unwrap();
 
                 Response::builder()
                     .header(CONTENT_TYPE, content_type)
diff --git a/src/object.rs b/src/object.rs
index 035ab4d..cb0a3ec 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -5,17 +5,13 @@ use std::vec::Vec;
 
 use base64;
 use postgres::types::{FromSql, IsNull, ToSql, Type};
-use tokio_postgres::{accepts, to_sql_checked};
 use serde_derive::{Deserialize, Serialize};
 use serde_json::Value;
+use tokio_postgres::{accepts, to_sql_checked};
 use uuid::Uuid;
 
 use crate::error::{BorayError, BorayErrorType};
-use crate::util::{
-    Hstore,
-    Rows,
-    Timestamptz
-};
+use crate::util::{Hstore, Rows, Timestamptz};
 
 pub mod create;
 pub mod delete;
@@ -25,11 +21,11 @@ pub mod update;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct GetObjectPayload {
-    pub owner      : Uuid,
-    pub bucket_id  : Uuid,
-    pub name       : String,
-    pub vnode      : u64,
-    pub request_id : Uuid
+    pub owner: Uuid,
+    pub bucket_id: Uuid,
+    pub name: String,
+    pub vnode: u64,
+    pub request_id: Uuid,
 }
 
 type DeleteObjectPayload = GetObjectPayload;
@@ -49,7 +45,7 @@ type DeleteObjectPayload = GetObjectPayload;
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct StorageNodeIdentifier {
     pub datacenter: String,
-    pub manta_storage_id: String
+    pub manta_storage_id: String,
 }
 
 impl ToString for StorageNodeIdentifier {
@@ -63,15 +59,14 @@ impl From<String> for StorageNodeIdentifier {
         let v: Vec<&str> = s.split(':').collect();
         StorageNodeIdentifier {
             datacenter: String::from(v[0]),
-            manta_storage_id: String::from(v[1])
+            manta_storage_id: String::from(v[1]),
         }
     }
 }
 
 impl ToSql for StorageNodeIdentifier {
-    fn to_sql(&self, ty: &Type, w: &mut Vec<u8>) ->
-        Result<IsNull, Box<dyn Error + Sync + Send>> {
-            <String as ToSql>::to_sql(&self.to_string(), ty, w)
+    fn to_sql(&self, ty: &Type, w: &mut Vec<u8>) -> Result<IsNull, Box<dyn Error + Sync + Send>> {
+        <String as ToSql>::to_sql(&self.to_string(), ty, w)
     }
 
     accepts!(TEXT);
@@ -80,12 +75,11 @@ impl ToSql for StorageNodeIdentifier {
 }
 
 impl<'a> FromSql<'a> for StorageNodeIdentifier {
-    fn from_sql(ty: &Type, raw: &'a [u8]) ->
-        Result<StorageNodeIdentifier, Box<dyn Error + Sync + Send>> {
-            String::from_sql(ty, raw)
-                .and_then(|s| {
-                    Ok(StorageNodeIdentifier::from(s))
-                })
+    fn from_sql(
+        ty: &Type,
+        raw: &'a [u8],
+    ) -> Result<StorageNodeIdentifier, Box<dyn Error + Sync + Send>> {
+        String::from_sql(ty, raw).and_then(|s| Ok(StorageNodeIdentifier::from(s)))
     }
 
     accepts!(TEXT);
@@ -93,18 +87,18 @@ impl<'a> FromSql<'a> for StorageNodeIdentifier {
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ObjectResponse {
-    pub id             : Uuid,
-    pub owner          : Uuid,
-    pub bucket_id      : Uuid,
-    pub name           : String,
-    pub created        : Timestamptz,
-    pub modified       : Timestamptz,
-    pub content_length : i64,
-    pub content_md5    : String,
-    pub content_type   : String,
-    pub headers        : Hstore,
-    pub sharks         : Vec<StorageNodeIdentifier>,
-    pub properties     : Option<Value>
+    pub id: Uuid,
+    pub owner: Uuid,
+    pub bucket_id: Uuid,
+    pub name: String,
+    pub created: Timestamptz,
+    pub modified: Timestamptz,
+    pub content_length: i64,
+    pub content_md5: String,
+    pub content_type: String,
+    pub headers: Hstore,
+    pub sharks: Vec<StorageNodeIdentifier>,
+    pub properties: Option<Value>,
 }
 
 pub(self) fn to_json(objr: ObjectResponse) -> Value {
@@ -123,11 +117,7 @@ pub(self) fn object_not_found() -> Value {
         .expect("failed to encode a ObjectNotFound error")
 }
 
-pub(self) fn response(
-    method: &str,
-    rows: Rows
-) -> Result<Option<ObjectResponse>, String>
-{
+pub(self) fn response(method: &str, rows: Rows) -> Result<Option<ObjectResponse>, String> {
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
@@ -138,52 +128,60 @@ pub(self) fn response(
             let content_md5_bytes: Vec<u8> = row.get("content_md5");
             let content_md5 = base64::encode(&content_md5_bytes);
             let resp = ObjectResponse {
-                id             : row.get("id"),
-                owner          : row.get("owner"),
-                bucket_id      : row.get("bucket_id"),
-                name           : row.get("name"),
-                created        : row.get("created"),
-                modified       : row.get("modified"),
-                content_length : row.get("content_length"),
+                id: row.get("id"),
+                owner: row.get("owner"),
+                bucket_id: row.get("bucket_id"),
+                name: row.get("name"),
+                created: row.get("created"),
+                modified: row.get("modified"),
+                content_length: row.get("content_length"),
                 content_md5,
-                content_type   : row.get("content_type"),
-                headers        : row.get("headers"),
-                sharks         : row.get("sharks"),
-                properties     : row.get("properties")
+                content_type: row.get("content_type"),
+                headers: row.get("headers"),
+                sharks: row.get("sharks"),
+                properties: row.get("properties"),
             };
             Ok(Some(resp))
         } else {
-            let err = format!("{} query returned a row with only {} columns, \
-                               but 12 were expected .", method, cols);
+            let err = format!(
+                "{} query returned a row with only {} columns, \
+                 but 12 were expected .",
+                method, cols
+            );
             Err(err.to_string())
         }
     } else {
-        let err = format!("{} query found {} results, but expected only 1.",
-                          method, rows.len());
+        let err = format!(
+            "{} query found {} results, but expected only 1.",
+            method,
+            rows.len()
+        );
         Err(err.to_string())
     }
 }
 
 pub(self) fn insert_delete_table_sql(vnode: u64) -> String {
     let vnode_str = vnode.to_string();
-    ["INSERT INTO manta_bucket_",
-     &vnode_str,
-     &".manta_bucket_deleted_object ( \
-      id, owner, bucket_id, name, created, modified, \
-      creator, content_length, content_md5, \
-      content_type, headers, sharks, properties) \
-      SELECT id, owner, bucket_id, name, created, \
-      modified, creator, content_length, \
-      content_md5, content_type, headers, sharks, \
-      properties FROM manta_bucket_",
-     &vnode_str,
-     &".manta_bucket_object \
-       WHERE owner = $1 \
-       AND bucket_id = $2 \
-       AND name = $3"].concat()
+    [
+        "INSERT INTO manta_bucket_",
+        &vnode_str,
+        &".manta_bucket_deleted_object ( \
+          id, owner, bucket_id, name, created, modified, \
+          creator, content_length, content_md5, \
+          content_type, headers, sharks, properties) \
+          SELECT id, owner, bucket_id, name, created, \
+          modified, creator, content_length, \
+          content_md5, content_type, headers, sharks, \
+          properties FROM manta_bucket_",
+        &vnode_str,
+        &".manta_bucket_object \
+          WHERE owner = $1 \
+          AND bucket_id = $2 \
+          AND name = $3",
+    ]
+    .concat()
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -237,7 +235,7 @@ mod test {
                 bucket_id,
                 name,
                 vnode,
-                request_id
+                request_id,
             }
         }
     }
@@ -254,22 +252,16 @@ mod test {
             let content_md5 = random::string(g, 32);
             let content_type = random::string(g, 32);
             let mut headers = HashMap::new();
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
 
             let shark1 = StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let shark2 = StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let sharks = vec![shark1, shark2];
             let properties = None;
@@ -286,7 +278,7 @@ mod test {
                 content_type,
                 headers,
                 sharks,
-                properties
+                properties,
             }
         }
     }
diff --git a/src/object/create.rs b/src/object/create.rs
index ca62235..32bcd3f 100644
--- a/src/object/create.rs
+++ b/src/object/create.rs
@@ -4,54 +4,43 @@ use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{
-    ObjectResponse,
-    StorageNodeIdentifier,
-    insert_delete_table_sql,
-    response,
-    to_json
+    insert_delete_table_sql, response, to_json, ObjectResponse, StorageNodeIdentifier,
 };
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    Hstore,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse, Hstore};
 
 const METHOD: &str = "createobject";
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateObjectPayload {
-    pub owner          : Uuid,
-    pub bucket_id      : Uuid,
-    pub name           : String,
-    pub id             : Uuid,
-    pub vnode          : u64,
-    pub content_length : i64,
-    pub content_md5    : String,
-    pub content_type   : String,
-    pub headers        : Hstore,
-    pub sharks         : Vec<StorageNodeIdentifier>,
-    pub properties     : Option<Value>,
-    pub request_id     : Uuid
+    pub owner: Uuid,
+    pub bucket_id: Uuid,
+    pub name: String,
+    pub id: Uuid,
+    pub vnode: u64,
+    pub content_length: i64,
+    pub content_md5: String,
+    pub content_type: String,
+    pub headers: Hstore,
+    pub sharks: Vec<StorageNodeIdentifier>,
+    pub properties: Option<Value>,
+    pub request_id: Uuid,
 }
 
 pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<CreateObjectPayload>>(data.clone())
@@ -75,7 +64,10 @@ pub(crate) fn handler(
             create(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                    debug!(
+                        log,
+                        "{} operation was successful, req_id: {}", &METHOD, &req_id
+                    );
                     // The `None` branch of the following match statement should
                     // never be reached. If `maybe_resp` was `None` this would
                     // mean that the SQL INSERT for the object was successful
@@ -83,20 +75,20 @@ pub(crate) fn handler(
                     // returned from the RETURNING clause. This should not be
                     // possible, but for completeleness we include a check for
                     // the condition.
-                    let value =
-                        match maybe_resp {
-                            Some(resp) => to_json(resp),
-                            None => object_create_failed()
-                        };
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let value = match maybe_resp {
+                        Some(resp) => to_json(resp),
+                        None => object_create_failed(),
+                    };
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -106,8 +98,7 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
@@ -116,67 +107,74 @@ pub(crate) fn handler(
 
 fn create(
     payload: CreateObjectPayload,
-    conn: &mut PostgresConnection
-) -> Result<Option<ObjectResponse>, String>
-{
+    conn: &mut PostgresConnection,
+) -> Result<Option<ObjectResponse>, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let create_sql = create_sql(payload.vnode);
     let move_sql = insert_delete_table_sql(payload.vnode);
-    let content_md5_bytes =
-        base64::decode(&payload.content_md5)
-        .map_err(|e| format!("content_md5 is not valid base64 encoded data: {}",
-                             e.to_string()))?;
+    let content_md5_bytes = base64::decode(&payload.content_md5).map_err(|e| {
+        format!(
+            "content_md5 is not valid base64 encoded data: {}",
+            e.to_string()
+        )
+    })?;
 
-    sql::txn_execute(sql::Method::ObjectCreateMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                       &payload.bucket_id,
-                       &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_query(sql::Method::ObjectCreate, &mut txn, create_sql.as_str(),
-                           &[&payload.id,
-                           &payload.owner,
-                           &payload.bucket_id,
-                           &payload.name,
-                           &payload.content_length,
-                           &content_md5_bytes,
-                           &payload.content_type,
-                           &payload.headers,
-                           &payload.sharks,
-                           &payload.properties])
-        })
-        .and_then(|rows| {
-            txn.commit()?;
-            Ok(rows)
-        })
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            response(METHOD, rows)
-        })
+    sql::txn_execute(
+        sql::Method::ObjectCreateMove,
+        &mut txn,
+        move_sql.as_str(),
+        &[&payload.owner, &payload.bucket_id, &payload.name],
+    )
+    .and_then(|_moved_rows| {
+        sql::txn_query(
+            sql::Method::ObjectCreate,
+            &mut txn,
+            create_sql.as_str(),
+            &[
+                &payload.id,
+                &payload.owner,
+                &payload.bucket_id,
+                &payload.name,
+                &payload.content_length,
+                &content_md5_bytes,
+                &payload.content_type,
+                &payload.headers,
+                &payload.sharks,
+                &payload.properties,
+            ],
+        )
+    })
+    .and_then(|rows| {
+        txn.commit()?;
+        Ok(rows)
+    })
+    .map_err(|e| e.to_string())
+    .and_then(|rows| response(METHOD, rows))
 }
 
-fn create_sql(
-    vnode: u64
-) -> String
-{
-    ["INSERT INTO manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object ( \
-       id, owner, bucket_id, name, content_length, content_md5, \
-       content_type, headers, sharks, properties) \
-       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \
-       ON CONFLICT (owner, bucket_id, name) DO UPDATE \
-       SET id = EXCLUDED.id, \
-       created = current_timestamp, \
-       modified = current_timestamp, \
-       content_length = EXCLUDED.content_length, \
-       content_md5 = EXCLUDED.content_md5, \
-       content_type = EXCLUDED.content_type, \
-       headers = EXCLUDED.headers, \
-       sharks = EXCLUDED.sharks, \
-       properties = EXCLUDED.properties \
-       RETURNING id, owner, bucket_id, name, created, modified, \
-       content_length, content_md5, content_type, headers, \
-       sharks, properties"].concat()
+fn create_sql(vnode: u64) -> String {
+    [
+        "INSERT INTO manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket_object ( \
+          id, owner, bucket_id, name, content_length, content_md5, \
+          content_type, headers, sharks, properties) \
+          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \
+          ON CONFLICT (owner, bucket_id, name) DO UPDATE \
+          SET id = EXCLUDED.id, \
+          created = current_timestamp, \
+          modified = current_timestamp, \
+          content_length = EXCLUDED.content_length, \
+          content_md5 = EXCLUDED.content_md5, \
+          content_type = EXCLUDED.content_type, \
+          headers = EXCLUDED.headers, \
+          sharks = EXCLUDED.sharks, \
+          properties = EXCLUDED.properties \
+          RETURNING id, owner, bucket_id, name, created, modified, \
+          content_length, content_md5, content_type, headers, \
+          sharks, properties",
+    ]
+    .concat()
 }
 
 // This error is only here for completeness. In practice it should never
@@ -188,7 +186,6 @@ fn object_create_failed() -> Value {
     })
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -213,8 +210,8 @@ mod test {
                 .expect("failed to convert name field to Value");
             let bucket_id = serde_json::to_value(Uuid::new_v4())
                 .expect("failed to convert bucket_id field to Value");
-            let id = serde_json::to_value(Uuid::new_v4())
-                .expect("failed to convert id field to Value");
+            let id =
+                serde_json::to_value(Uuid::new_v4()).expect("failed to convert id field to Value");
             let vnode = serde_json::to_value(u64::arbitrary(g))
                 .expect("failed to convert vnode field to Value");
             let content_length = serde_json::to_value(i64::arbitrary(g))
@@ -224,23 +221,17 @@ mod test {
             let content_type = serde_json::to_value(random::string(g, 32))
                 .expect("failed to convert content_type field to Value");
             let mut headers = HashMap::new();
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let headers = serde_json::to_value(headers)
-                .expect("failed to convert headers field to Value");
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let headers =
+                serde_json::to_value(headers).expect("failed to convert headers field to Value");
             let shark1 = object::StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let shark2 = object::StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let sharks = serde_json::to_value(vec![shark1, shark2])
                 .expect("failed to convert sharks field to Value");
@@ -274,22 +265,16 @@ mod test {
             let content_type = random::string(g, 32);
             let content_md5 = random::string(g, 32);
             let mut headers = HashMap::new();
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
 
             let shark1 = StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let shark2 = StorageNodeIdentifier {
                 datacenter: random::string(g, 32),
-                manta_storage_id: random::string(g, 32)
+                manta_storage_id: random::string(g, 32),
             };
             let sharks = vec![shark1, shark2];
             let properties = None;
@@ -307,7 +292,7 @@ mod test {
                 headers,
                 sharks,
                 properties,
-                request_id
+                request_id,
             }
         }
     }
diff --git a/src/object/delete.rs b/src/object/delete.rs
index 8e1fe9d..46dd551 100644
--- a/src/object/delete.rs
+++ b/src/object/delete.rs
@@ -2,24 +2,15 @@
 
 use std::vec::Vec;
 
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::object::{
-    DeleteObjectPayload,
-    insert_delete_table_sql,
-    object_not_found
-};
+use crate::object::{insert_delete_table_sql, object_not_found, DeleteObjectPayload};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "deleteobject";
 
@@ -27,9 +18,8 @@ pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<DeleteObjectPayload>>(data.clone())
@@ -53,29 +43,32 @@ pub(crate) fn handler(
             delete(payload, &mut conn)
                 .and_then(|affected_rows| {
                     // Handle the successful database response
-                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
-                    let value =
-                        if affected_rows > 0 {
-                            // This conversion can fail if the implementation of
-                            // Serialize decides to fail, or if the type
-                            // contains a map with non-string keys. There is no
-                            // reason for the former to occur and the latter
-                            // reason for failure is not a concern here since
-                            // the type of `affected_rows` is u64.
-                            serde_json::to_value(affected_rows).unwrap()
-                        } else {
-                            object_not_found()
-                        };
+                    debug!(
+                        log,
+                        "{} operation was successful, req_id: {}", &METHOD, &req_id
+                    );
+                    let value = if affected_rows > 0 {
+                        // This conversion can fail if the implementation of
+                        // Serialize decides to fail, or if the type
+                        // contains a map with non-string keys. There is no
+                        // reason for the former to occur and the latter
+                        // reason for failure is not a concern here since
+                        // the type of `affected_rows` is u64.
+                        serde_json::to_value(affected_rows).unwrap()
+                    } else {
+                        object_not_found()
+                    };
 
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -85,49 +78,47 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
         .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(
-    payload: DeleteObjectPayload,
-    conn: &mut PostgresConnection
-) -> Result<u64, String>
-{
+fn delete(payload: DeleteObjectPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
 
-    sql::txn_execute(sql::Method::ObjectDeleteMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                     &payload.bucket_id,
-                     &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_execute(sql::Method::ObjectDelete, &mut txn, delete_sql.as_str(),
-                             &[&payload.owner,
-                             &payload.bucket_id,
-                             &payload.name])
-        })
-        .and_then(|row_count| {
-            txn.commit()?;
-            Ok(row_count)
-        })
-        .map_err(|e| e.to_string())
+    sql::txn_execute(
+        sql::Method::ObjectDeleteMove,
+        &mut txn,
+        move_sql.as_str(),
+        &[&payload.owner, &payload.bucket_id, &payload.name],
+    )
+    .and_then(|_moved_rows| {
+        sql::txn_execute(
+            sql::Method::ObjectDelete,
+            &mut txn,
+            delete_sql.as_str(),
+            &[&payload.owner, &payload.bucket_id, &payload.name],
+        )
+    })
+    .and_then(|row_count| {
+        txn.commit()?;
+        Ok(row_count)
+    })
+    .map_err(|e| e.to_string())
 }
 
-
-fn delete_sql(
-    vnode: u64
-) -> String
-{
-    ["DELETE FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object \
-       WHERE owner = $1 \
-       AND bucket_id = $2 \
-       AND name = $3"].concat()
+fn delete_sql(vnode: u64) -> String {
+    [
+        "DELETE FROM manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket_object \
+          WHERE owner = $1 \
+          AND bucket_id = $2 \
+          AND name = $3",
+    ]
+    .concat()
 }
diff --git a/src/object/get.rs b/src/object/get.rs
index 37c654a..59ee59e 100644
--- a/src/object/get.rs
+++ b/src/object/get.rs
@@ -2,26 +2,15 @@
 
 use std::vec::Vec;
 
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::object::{
-    GetObjectPayload,
-    ObjectResponse,
-    object_not_found,
-    response,
-    to_json
-};
+use crate::object::{object_not_found, response, to_json, GetObjectPayload, ObjectResponse};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "getobject";
 
@@ -29,9 +18,8 @@ pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling getobject function request");
 
     serde_json::from_value::<Vec<GetObjectPayload>>(data.clone())
@@ -55,19 +43,24 @@ pub(crate) fn handler(
             get(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(log, "getobject operation was successful, req_id: {}", &req_id);
-                    let value =
-                        match maybe_resp {
-                            Some(resp) => array_wrap(to_json(resp)),
-                            None => array_wrap(object_not_found())
-                        };
+                    debug!(
+                        log,
+                        "getobject operation was successful, req_id: {}", &req_id
+                    );
+                    let value = match maybe_resp {
+                        Some(resp) => array_wrap(to_json(resp)),
+                        None => array_wrap(object_not_found()),
+                    };
                     let msg_data = FastMessageData::new(METHOD.into(), value);
                     let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "getobject operation failed: {}, req_id: {}", &e, &req_id);
+                    error!(
+                        log,
+                        "getobject operation failed: {}, req_id: {}", &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -77,8 +70,7 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
@@ -87,30 +79,29 @@ pub(crate) fn handler(
 
 fn get(
     payload: GetObjectPayload,
-    mut conn: &mut PostgresConnection
-) -> Result<Option<ObjectResponse>, String>
-{
+    mut conn: &mut PostgresConnection,
+) -> Result<Option<ObjectResponse>, String> {
     let sql = get_sql(payload.vnode);
 
-    sql::query(sql::Method::ObjectGet, &mut conn, sql.as_str(),
-               &[&payload.owner,
-               &payload.bucket_id,
-                 &payload.name])
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            response(METHOD, rows)
-        })
+    sql::query(
+        sql::Method::ObjectGet,
+        &mut conn,
+        sql.as_str(),
+        &[&payload.owner, &payload.bucket_id, &payload.name],
+    )
+    .map_err(|e| e.to_string())
+    .and_then(|rows| response(METHOD, rows))
 }
 
-fn get_sql(
-    vnode: u64
-) -> String
-{
-    ["SELECT id, owner, bucket_id, name, created, modified, content_length, \
-      content_md5, content_type, headers, sharks, properties \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object WHERE owner = $1 \
-       AND bucket_id = $2 \
-       AND name = $3"].concat()
+fn get_sql(vnode: u64) -> String {
+    [
+        "SELECT id, owner, bucket_id, name, created, modified, content_length, \
+         content_md5, content_type, headers, sharks, properties \
+         FROM manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket_object WHERE owner = $1 \
+          AND bucket_id = $2 \
+          AND name = $3",
+    ]
+    .concat()
 }
diff --git a/src/object/list.rs b/src/object/list.rs
index 412b016..1859f92 100644
--- a/src/object/list.rs
+++ b/src/object/list.rs
@@ -4,45 +4,36 @@ use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::object::{
-    ObjectResponse,
-    to_json
-};
+use crate::object::{to_json, ObjectResponse};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
 
 const METHOD: &str = "listobjects";
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListObjectsPayload {
-    pub owner      : Uuid,
-    pub bucket_id  : Uuid,
-    pub vnode      : u64,
-    pub prefix     : Option<String>,
-    pub limit      : u64,
-    pub marker     : Option<String>,
-    pub request_id : Uuid
+    pub owner: Uuid,
+    pub bucket_id: Uuid,
+    pub vnode: u64,
+    pub prefix: Option<String>,
+    pub limit: u64,
+    pub marker: Option<String>,
+    pub request_id: Uuid,
 }
 
 pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<ListObjectsPayload>>(data.clone())
@@ -67,12 +58,18 @@ pub(crate) fn handler(
                 list(msg_id, payload, &mut conn)
                     .and_then(|resp| {
                         // Handle the successful database response
-                        debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
+                        debug!(
+                            log,
+                            "{} operation was successful, req_id: {}", &METHOD, &req_id
+                        );
                         Ok(HandlerResponse::from(resp))
                     })
                     .or_else(|e| {
                         // Handle database error response
-                        error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                        error!(
+                            log,
+                            "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                        );
 
                         // Database errors are returned to as regular Fast messages
                         // to be handled by the calling application
@@ -81,23 +78,24 @@ pub(crate) fn handler(
                             "message": e
                         }));
                         let msg_data = FastMessageData::new(METHOD.into(), value);
-                        let msg: HandlerResponse =
-                            FastMessage::data(msg_id, msg_data).into();
+                        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                         Ok(msg)
                     })
             } else {
                 // Limit constraint violations are returned to as regular
                 // Fast messages to be handled by the calling application
-                let e = format!("the {} limit option must be a value between 1 \
-                                 and 1024. the requested limit was {}, req_id: \
-                                 {}", &METHOD, &payload.limit, &req_id);
+                let e = format!(
+                    "the {} limit option must be a value between 1 \
+                     and 1024. the requested limit was {}, req_id: \
+                     {}",
+                    &METHOD, &payload.limit, &req_id
+                );
                 let value = array_wrap(json!({
                     "name": "LimitConstraintError",
                     "message": e
                 }));
                 let msg_data = FastMessageData::new(METHOD.into(), value);
-                let msg: HandlerResponse =
-                    FastMessage::data(msg_id, msg_data).into();
+                let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                 Ok(msg)
             }
         })
@@ -107,114 +105,132 @@ pub(crate) fn handler(
 fn list(
     msg_id: u32,
     payload: ListObjectsPayload,
-    mut conn: &mut PostgresConnection
-) -> Result<Vec<FastMessage>, String>
-{
-    let query_result =
-        match (payload.marker, payload.prefix) {
-            (Some(marker), Some(prefix)) => {
-                let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
-                let prefix = format!("{}%", prefix);
-                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &payload.bucket_id, &prefix, &marker])
-            }
-            (Some(marker), None) => {
-                let sql = list_sql_marker(payload.vnode, payload.limit);
-                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &payload.bucket_id, &marker])
-            }
-            (None, Some(prefix)) => {
-                let sql = list_sql_prefix(payload.vnode, payload.limit);
-                let prefix = format!("{}%", prefix);
-                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &payload.bucket_id, &prefix])
-            }
-            (None, None) => {
-                let sql = list_sql(payload.vnode, payload.limit);
-                sql::query(sql::Method::ObjectList, &mut conn, sql.as_str(),
-                           &[&payload.owner, &payload.bucket_id])
-            }
-        };
+    mut conn: &mut PostgresConnection,
+) -> Result<Vec<FastMessage>, String> {
+    let query_result = match (payload.marker, payload.prefix) {
+        (Some(marker), Some(prefix)) => {
+            let sql = list_sql_prefix_marker(payload.vnode, payload.limit);
+            let prefix = format!("{}%", prefix);
+            sql::query(
+                sql::Method::ObjectList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &payload.bucket_id, &prefix, &marker],
+            )
+        }
+        (Some(marker), None) => {
+            let sql = list_sql_marker(payload.vnode, payload.limit);
+            sql::query(
+                sql::Method::ObjectList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &payload.bucket_id, &marker],
+            )
+        }
+        (None, Some(prefix)) => {
+            let sql = list_sql_prefix(payload.vnode, payload.limit);
+            let prefix = format!("{}%", prefix);
+            sql::query(
+                sql::Method::ObjectList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &payload.bucket_id, &prefix],
+            )
+        }
+        (None, None) => {
+            let sql = list_sql(payload.vnode, payload.limit);
+            sql::query(
+                sql::Method::ObjectList,
+                &mut conn,
+                sql.as_str(),
+                &[&payload.owner, &payload.bucket_id],
+            )
+        }
+    };
 
     let mut msgs: Vec<FastMessage> = Vec::with_capacity(1024);
 
-    query_result
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            for row in rows.iter() {
-                let content_md5_bytes: Vec<u8> = row.get(7);
-                let content_md5 = base64::encode(&content_md5_bytes);
-                let resp = ObjectResponse {
-                    id             : row.get("id"),
-                    owner          : row.get("owner"),
-                    bucket_id      : row.get("bucket_id"),
-                    name           : row.get("name"),
-                    created        : row.get("created"),
-                    modified       : row.get("modified"),
-                    content_length : row.get("content_length"),
-                    content_md5,
-                    content_type   : row.get("content_type"),
-                    headers        : row.get("headers"),
-                    sharks         : row.get("sharks"),
-                    properties     : row.get("properties")
-                };
+    query_result.map_err(|e| e.to_string()).and_then(|rows| {
+        for row in rows.iter() {
+            let content_md5_bytes: Vec<u8> = row.get(7);
+            let content_md5 = base64::encode(&content_md5_bytes);
+            let resp = ObjectResponse {
+                id: row.get("id"),
+                owner: row.get("owner"),
+                bucket_id: row.get("bucket_id"),
+                name: row.get("name"),
+                created: row.get("created"),
+                modified: row.get("modified"),
+                content_length: row.get("content_length"),
+                content_md5,
+                content_type: row.get("content_type"),
+                headers: row.get("headers"),
+                sharks: row.get("sharks"),
+                properties: row.get("properties"),
+            };
 
-                let value = to_json(resp);
-                let msg_data =
-                    FastMessageData::new(METHOD.into(), array_wrap(value));
-                let msg = FastMessage::data(msg_id, msg_data);
+            let value = to_json(resp);
+            let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+            let msg = FastMessage::data(msg_id, msg_data);
 
-                msgs.push(msg);
-            }
-            Ok(msgs)
-        })
+            msgs.push(msg);
+        }
+        Ok(msgs)
+    })
 }
 
 fn list_sql_prefix_marker(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, bucket_id, name, created, modified, \
+    format!(
+        "SELECT id, owner, bucket_id, name, created, modified, \
         content_length, content_md5, content_type, headers, sharks, \
         properties \
         FROM manta_bucket_{}.manta_bucket_object
         WHERE owner = $1 AND bucket_id = $2 AND name like $3 AND name > $4
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
 fn list_sql_prefix(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, bucket_id, name, created, modified, \
+    format!(
+        "SELECT id, owner, bucket_id, name, created, modified, \
         content_length, content_md5, content_type, headers, sharks, \
         properties \
         FROM manta_bucket_{}.manta_bucket_object
         WHERE owner = $1 AND bucket_id = $2 AND name like $3
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
 fn list_sql_marker(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, bucket_id, name, created, modified, \
+    format!(
+        "SELECT id, owner, bucket_id, name, created, modified, \
         content_length, content_md5, content_type, headers, sharks, \
         properties \
         FROM manta_bucket_{}.manta_bucket_object
         WHERE owner = $1 AND bucket_id = $2 AND name > $3
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
 fn list_sql(vnode: u64, limit: u64) -> String {
-    format!("SELECT id, owner, bucket_id, name, created, modified, \
+    format!(
+        "SELECT id, owner, bucket_id, name, created, modified, \
         content_length, content_md5, content_type, headers, sharks, \
         properties \
         FROM manta_bucket_{}.manta_bucket_object
         WHERE owner = $1 AND bucket_id = $2
         ORDER BY name ASC
         LIMIT {}",
-        vnode, limit)
+        vnode, limit
+    )
 }
 
-
 #[cfg(test)]
 mod test {
     use super::*;
@@ -273,7 +289,7 @@ mod test {
                 prefix,
                 limit,
                 marker,
-                request_id
+                request_id,
             }
         }
     }
diff --git a/src/object/update.rs b/src/object/update.rs
index ead30db..6854f9a 100644
--- a/src/object/update.rs
+++ b/src/object/update.rs
@@ -3,50 +3,38 @@
 use std::vec::Vec;
 
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug, error, warn};
+use serde_json::{json, Value};
+use slog::{debug, error, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
-use crate::object::{
-    ObjectResponse,
-    object_not_found,
-    response,
-    to_json
-};
+use crate::object::{object_not_found, response, to_json, ObjectResponse};
 use crate::sql;
-use crate::util::{
-    HandlerError,
-    HandlerResponse,
-    Hstore,
-    array_wrap,
-    other_error
-};
+use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse, Hstore};
 
 const METHOD: &str = "updateobject";
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct UpdateObjectPayload {
-    pub owner          : Uuid,
-    pub bucket_id      : Uuid,
-    pub name           : String,
-    pub id             : Uuid,
-    pub vnode          : u64,
-    pub content_type   : String,
-    pub headers        : Hstore,
-    pub properties     : Option<Value>,
-    pub request_id     : Uuid
+    pub owner: Uuid,
+    pub bucket_id: Uuid,
+    pub name: String,
+    pub id: Uuid,
+    pub vnode: u64,
+    pub content_type: String,
+    pub headers: Hstore,
+    pub properties: Option<Value>,
+    pub request_id: Uuid,
 }
 
 pub(crate) fn handler(
     msg_id: u32,
     data: &Value,
     mut conn: &mut PostgresConnection,
-    log: &Logger
-) -> Result<HandlerResponse, HandlerError>
-{
+    log: &Logger,
+) -> Result<HandlerResponse, HandlerError> {
     debug!(log, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<UpdateObjectPayload>>(data.clone())
@@ -70,21 +58,24 @@ pub(crate) fn handler(
             update(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(log, "{} operation was successful, req_id: {}", &METHOD, &req_id);
-                    let value =
-                        match maybe_resp {
-                            Some(resp) => to_json(resp),
-                            None => object_not_found()
-                        };
-                    let msg_data =
-                        FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    debug!(
+                        log,
+                        "{} operation was successful, req_id: {}", &METHOD, &req_id
+                    );
+                    let value = match maybe_resp {
+                        Some(resp) => to_json(resp),
+                        None => object_not_found(),
+                    };
+                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(log, "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id);
+                    error!(
+                        log,
+                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
+                    );
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
@@ -94,8 +85,7 @@ pub(crate) fn handler(
                     }));
 
                     let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse =
-                        FastMessage::data(msg_id, msg_data).into();
+                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                     Ok(msg)
                 })
         })
@@ -104,36 +94,37 @@ pub(crate) fn handler(
 
 fn update(
     payload: UpdateObjectPayload,
-    conn: &mut PostgresConnection
-)  -> Result<Option<ObjectResponse>, String>
-{
+    conn: &mut PostgresConnection,
+) -> Result<Option<ObjectResponse>, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let update_sql = update_sql(payload.vnode);
 
-    sql::txn_query(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
-                     &[&payload.content_type,
-                       &payload.headers,
-                       &payload.properties,
-                       &payload.owner,
-                       &payload.bucket_id,
-                       &payload.name])
-        .and_then(|rows| {
-            txn.commit()?;
-            Ok(rows)
-        })
-        .map_err(|e| e.to_string())
-        .and_then(|rows| {
-            response(METHOD, rows)
-        })
+    sql::txn_query(
+        sql::Method::ObjectUpdate,
+        &mut txn,
+        update_sql.as_str(),
+        &[
+            &payload.content_type,
+            &payload.headers,
+            &payload.properties,
+            &payload.owner,
+            &payload.bucket_id,
+            &payload.name,
+        ],
+    )
+    .and_then(|rows| {
+        txn.commit()?;
+        Ok(rows)
+    })
+    .map_err(|e| e.to_string())
+    .and_then(|rows| response(METHOD, rows))
 }
 
-fn update_sql(
-    vnode: u64
-) -> String
-{
-    ["UPDATE manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object \
+fn update_sql(vnode: u64) -> String {
+    [
+        "UPDATE manta_bucket_",
+        &vnode.to_string(),
+        &".manta_bucket_object \
        SET content_type = $1,
        headers = $2, \
        properties = $3, \
@@ -143,7 +134,9 @@ fn update_sql(
        AND name = $6 \
        RETURNING id, owner, bucket_id, name, created, modified, \
        content_length, content_md5, content_type, headers, \
-       sharks, properties"].concat()
+       sharks, properties",
+    ]
+    .concat()
 }
 
 #[cfg(test)]
@@ -168,23 +161,17 @@ mod test {
                 .expect("failed to convert name field to Value");
             let bucket_id = serde_json::to_value(Uuid::new_v4())
                 .expect("failed to convert bucket_id field to Value");
-            let id = serde_json::to_value(Uuid::new_v4())
-                .expect("failed to convert id field to Value");
+            let id =
+                serde_json::to_value(Uuid::new_v4()).expect("failed to convert id field to Value");
             let vnode = serde_json::to_value(u64::arbitrary(g))
                 .expect("failed to convert vnode field to Value");
             let content_type = serde_json::to_value(random::string(g, 32))
                 .expect("failed to convert content_type field to Value");
             let mut headers = HashMap::new();
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let headers = serde_json::to_value(headers)
-                .expect("failed to convert headers field to Value");
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let headers =
+                serde_json::to_value(headers).expect("failed to convert headers field to Value");
             let request_id = serde_json::to_value(Uuid::new_v4())
                 .expect("failed to convert request_id field to Value");
 
@@ -210,14 +197,8 @@ mod test {
             let vnode = u64::arbitrary(g);
             let content_type = random::string(g, 32);
             let mut headers = HashMap::new();
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
-            let _ = headers.insert(
-                random::string(g, 32),
-                Some(random::string(g, 32))
-            );
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
+            let _ = headers.insert(random::string(g, 32), Some(random::string(g, 32)));
 
             let properties = None;
             let request_id = Uuid::new_v4();
@@ -231,7 +212,7 @@ mod test {
                 content_type,
                 headers,
                 properties,
-                request_id
+                request_id,
             }
         }
     }
diff --git a/src/opts.rs b/src/opts.rs
index 98ed086..12d48ae 100644
--- a/src/opts.rs
+++ b/src/opts.rs
@@ -2,62 +2,79 @@
  * Copyright 2019 Joyent, Inc.
  */
 
-use clap::{App, Arg, ArgMatches, crate_version};
+use clap::{crate_version, App, Arg, ArgMatches};
 
 pub fn parse<'a>(app: &str) -> ArgMatches<'a> {
     App::new(app)
         .about("Tool to test different hierarchy options offered by PostgreSQL")
         .version(crate_version!())
-        .arg(Arg::with_name("pg ip")
-             .help("Postgres IP address")
-             .long("pg-ip")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("pg port")
-             .help("Postgres port")
-             .long("pg-port")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("pg database")
-             .help("Postgres database name")
-             .long("pg-db")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("config")
-             .help("Configuration file")
-             .short("c")
-             .long("config")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("address")
-             .help("Listen address")
-             .short("a")
-             .long("address")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("port")
-             .help("Listen port")
-             .short("p")
-             .long("port")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("level")
-             .help("Log level")
-             .short("l")
-             .long("level")
-             .takes_value(true)
-             .possible_values(&["trace", "debug", "info",
-                                "warning", "error", "critical"])
-             .required(false))
-        .arg(Arg::with_name("metrics address")
-             .help("Address to listen for metrics queries")
-             .long("metrics-address")
-             .takes_value(true)
-             .required(false))
-        .arg(Arg::with_name("metrics port")
-             .help("Port to listen for metrics queries")
-             .long("metrics-port")
-             .takes_value(true)
-             .required(false))
+        .arg(
+            Arg::with_name("pg ip")
+                .help("Postgres IP address")
+                .long("pg-ip")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("pg port")
+                .help("Postgres port")
+                .long("pg-port")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("pg database")
+                .help("Postgres database name")
+                .long("pg-db")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("config")
+                .help("Configuration file")
+                .short("c")
+                .long("config")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("address")
+                .help("Listen address")
+                .short("a")
+                .long("address")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("port")
+                .help("Listen port")
+                .short("p")
+                .long("port")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("level")
+                .help("Log level")
+                .short("l")
+                .long("level")
+                .takes_value(true)
+                .possible_values(&["trace", "debug", "info", "warning", "error", "critical"])
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("metrics address")
+                .help("Address to listen for metrics queries")
+                .long("metrics-address")
+                .takes_value(true)
+                .required(false),
+        )
+        .arg(
+            Arg::with_name("metrics port")
+                .help("Port to listen for metrics queries")
+                .long("metrics-port")
+                .takes_value(true)
+                .required(false),
+        )
         .get_matches()
 }
diff --git a/src/sql.rs b/src/sql.rs
index c91e8cb..2c8cf84 100644
--- a/src/sql.rs
+++ b/src/sql.rs
@@ -5,8 +5,8 @@
 use std::time::Instant;
 use std::vec::Vec;
 
-use postgres::{Transaction, Client, ToStatement};
 use postgres::types::ToSql;
+use postgres::{Client, ToStatement, Transaction};
 use tokio_postgres::Error as PGError;
 use tokio_postgres::Row as PGRow;
 
@@ -25,7 +25,7 @@ pub enum Method {
     ObjectList,
     ObjectDelete,
     ObjectDeleteMove,
-    ObjectUpdate
+    ObjectUpdate,
 }
 
 impl Method {
@@ -42,59 +42,66 @@ impl Method {
             Method::ObjectList => "ObjectList",
             Method::ObjectDelete => "ObjectDelete",
             Method::ObjectDeleteMove => "ObjectDeleteMove",
-            Method::ObjectUpdate => "ObjectUpdate"
+            Method::ObjectUpdate => "ObjectUpdate",
         }
     }
 }
 
 // conn.execute wrapper that posts metrics
-pub fn execute<T>(method: Method,
-       conn: &mut Client,
-       sql: &T,
-       items: &[&dyn ToSql])
-       -> Result<u64, PGError>
-       where T: ?Sized + ToStatement,
+pub fn execute<T>(
+    method: Method,
+    conn: &mut Client,
+    sql: &T,
+    items: &[&dyn ToSql],
+) -> Result<u64, PGError>
+where
+    T: ?Sized + ToStatement,
 {
     sql_with_metrics(method, || conn.execute(sql, items))
 }
 
 // txn.execute wrapper that posts metrics
-pub fn txn_execute<T>(method: Method,
-       txn: &mut Transaction,
-       sql: &T,
-       items: &[&dyn ToSql])
-       -> Result<u64, PGError>
-       where T: ?Sized + ToStatement,
+pub fn txn_execute<T>(
+    method: Method,
+    txn: &mut Transaction,
+    sql: &T,
+    items: &[&dyn ToSql],
+) -> Result<u64, PGError>
+where
+    T: ?Sized + ToStatement,
 {
     sql_with_metrics(method, || txn.execute(sql, items))
 }
 
 // conn.query wrapper that posts metrics
-pub fn query<T>(method: Method,
-       conn: &mut Client,
-       sql: &T,
-       items: &[&dyn ToSql])
-       -> Result<Vec<PGRow>, PGError>
-       where T: ?Sized + ToStatement,
+pub fn query<T>(
+    method: Method,
+    conn: &mut Client,
+    sql: &T,
+    items: &[&dyn ToSql],
+) -> Result<Vec<PGRow>, PGError>
+where
+    T: ?Sized + ToStatement,
 {
     sql_with_metrics(method, || conn.query(sql, items))
 }
 
 // txn.query wrapper that posts metrics
-pub fn txn_query<T>(method: Method,
-       txn: &mut Transaction,
-       sql: &T,
-       items: &[&dyn ToSql])
-       -> Result<Vec<PGRow>, PGError>
-       where T: ?Sized + ToStatement,
+pub fn txn_query<T>(
+    method: Method,
+    txn: &mut Transaction,
+    sql: &T,
+    items: &[&dyn ToSql],
+) -> Result<Vec<PGRow>, PGError>
+where
+    T: ?Sized + ToStatement,
 {
     sql_with_metrics(method, || txn.query(sql, items))
 }
 
-fn sql_with_metrics<F, T>(method: Method,
-    f: F)
-    -> Result<T, PGError>
-    where F: FnOnce() -> Result<T, PGError>,
+fn sql_with_metrics<F, T>(method: Method, f: F) -> Result<T, PGError>
+where
+    F: FnOnce() -> Result<T, PGError>,
 {
     let now = Instant::now();
 
@@ -105,16 +112,17 @@ fn sql_with_metrics<F, T>(method: Method,
     res
 }
 
-fn post_timer_metrics(method: Method, now: Instant, success: bool)
-{
+fn post_timer_metrics(method: Method, now: Instant, success: bool) {
     // Generate metrics for the request
     let duration = now.elapsed();
     let t = util::duration_to_seconds(duration);
 
     let success = match success {
         true => "true",
-        false => "false"
+        false => "false",
     };
 
-    metrics::POSTGRES_REQUESTS.with_label_values(&[&method.as_str(), success]).observe(t);
+    metrics::POSTGRES_REQUESTS
+        .with_label_values(&[&method.as_str(), success])
+        .observe(t);
 }
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 3bf3e45..f28b959 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -9,20 +9,16 @@ use slog::{error, info, o, Drain, Logger};
 use url::Url;
 use uuid::Uuid;
 
-use cueball::connection_pool::ConnectionPool;
 use cueball::connection_pool::types::ConnectionPoolOptions;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::{PostgresConnection, PostgresConnectionConfig, TlsConfig};
 use cueball_static_resolver::StaticIpResolver;
-use cueball_postgres_connection::{
-    PostgresConnection,
-    PostgresConnectionConfig,
-    TlsConfig
-};
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use boray::bucket;
-use boray::util;
 use boray::error::{BorayError, BorayErrorType};
 use boray::object;
+use boray::util;
 
 // This test suite requres PostgreSQL and pg_tmp
 // (http://eradman.com/ephemeralpg/) to be installed on the test system.
@@ -63,8 +59,7 @@ fn verify_rpc_handlers() {
 
     info!(log, "pg url: {}", pg_connect_str);
 
-    let pg_url = Url::parse(&pg_connect_str)
-        .expect("failed to parse postgres connection string");
+    let pg_url = Url::parse(&pg_connect_str).expect("failed to parse postgres connection string");
 
     ////////////////////////////////////////////////////////////////////////////
     // Create connection pool
@@ -81,7 +76,7 @@ fn verify_rpc_handlers() {
         port: Some(pg_port),
         database: Some(pg_db.into()),
         application_name: Some(application_name.into()),
-        tls_config: TlsConfig::disable()
+        tls_config: TlsConfig::disable(),
     };
 
     let connection_creator = PostgresConnection::connection_creator(pg_config);
@@ -89,17 +84,13 @@ fn verify_rpc_handlers() {
         maximum: 5,
         claim_timeout: None,
         log: log.clone(),
-        rebalancer_action_delay: None
+        rebalancer_action_delay: None,
     };
 
     let primary_backend = (IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), pg_port);
     let resolver = StaticIpResolver::new(vec![primary_backend]);
 
-    let pool = ConnectionPool::new(
-        pool_opts,
-        resolver,
-        connection_creator
-    );
+    let pool = ConnectionPool::new(pool_opts, resolver, connection_creator);
 
     ////////////////////////////////////////////////////////////////////////////
     // Exercise RPC handlers
@@ -114,16 +105,13 @@ fn verify_rpc_handlers() {
         owner: owner_id,
         name: bucket.clone(),
         vnode: 0,
-        request_id
+        request_id,
     };
 
     let get_bucket_json = serde_json::to_value(vec![get_bucket_payload]).unwrap();
-    let get_bucket_fast_msg_data =
-        FastMessageData::new("getbucket".into(), get_bucket_json);
-    let get_bucket_fast_msg =
-        FastMessage::data(msg_id, get_bucket_fast_msg_data);
-    let mut get_bucket_result =
-        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    let get_bucket_fast_msg_data = FastMessageData::new("getbucket".into(), get_bucket_json);
+    let get_bucket_fast_msg = FastMessage::data(msg_id, get_bucket_fast_msg_data);
+    let mut get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -132,24 +120,24 @@ fn verify_rpc_handlers() {
     let get_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(get_bucket_response[0].data.d[0].clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(),
-               BorayError::new(BorayErrorType::BucketNotFound));
+    assert_eq!(
+        get_bucket_response_result.unwrap(),
+        BorayError::new(BorayErrorType::BucketNotFound)
+    );
 
     // Create a bucket
     let create_bucket_payload = bucket::create::CreateBucketPayload {
         owner: owner_id,
         name: bucket.clone(),
         vnode: 0,
-        request_id
+        request_id,
     };
 
     let create_bucket_json = serde_json::to_value(vec![create_bucket_payload]).unwrap();
     let create_bucket_fast_msg_data =
         FastMessageData::new("createbucket".into(), create_bucket_json);
-    let create_bucket_fast_msg =
-        FastMessage::data(msg_id, create_bucket_fast_msg_data);
-    let mut create_bucket_result =
-        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    let create_bucket_fast_msg = FastMessage::data(msg_id, create_bucket_fast_msg_data);
+    let mut create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -160,10 +148,8 @@ fn verify_rpc_handlers() {
     assert!(create_bucket_response_result.is_ok());
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
-
     // Read bucket again and make sure the resonse is returned successfully
-    get_bucket_result =
-        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -174,11 +160,9 @@ fn verify_rpc_handlers() {
     assert!(get_bucket_response_result.is_ok());
     assert_eq!(get_bucket_response_result.unwrap().name, bucket);
 
-
     // Try to create same bucket again and verify a BucketAlreadyExists error is
     // returned
-    create_bucket_result =
-        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -187,8 +171,10 @@ fn verify_rpc_handlers() {
     let create_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(create_bucket_response[0].data.d[0].clone());
     assert!(create_bucket_response_result.is_ok());
-    assert_eq!(create_bucket_response_result.unwrap(),
-               BorayError::new(BorayErrorType::BucketAlreadyExists));
+    assert_eq!(
+        create_bucket_response_result.unwrap(),
+        BorayError::new(BorayErrorType::BucketAlreadyExists)
+    );
 
     // Delete bucket
 
@@ -196,15 +182,13 @@ fn verify_rpc_handlers() {
         owner: owner_id,
         name: bucket.clone(),
         vnode: 0,
-        request_id
+        request_id,
     };
     let delete_bucket_json = serde_json::to_value(vec![delete_bucket_payload]).unwrap();
     let delete_bucket_fast_msg_data =
         FastMessageData::new("deletebucket".into(), delete_bucket_json);
-    let delete_bucket_fast_msg =
-        FastMessage::data(msg_id, delete_bucket_fast_msg_data);
-    let mut delete_bucket_result =
-        util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
+    let delete_bucket_fast_msg = FastMessage::data(msg_id, delete_bucket_fast_msg_data);
+    let mut delete_bucket_result = util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -216,8 +200,7 @@ fn verify_rpc_handlers() {
     assert_eq!(delete_bucket_response_result.unwrap(), 1);
 
     // Read bucket again and verify it's gone
-    get_bucket_result =
-        util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -226,12 +209,13 @@ fn verify_rpc_handlers() {
     let get_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(get_bucket_response[0].data.d[0].clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(), BorayError::new(BorayErrorType::BucketNotFound));
-
+    assert_eq!(
+        get_bucket_response_result.unwrap(),
+        BorayError::new(BorayErrorType::BucketNotFound)
+    );
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
-    delete_bucket_result =
-        util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
+    delete_bucket_result = util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -240,9 +224,10 @@ fn verify_rpc_handlers() {
     let delete_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(delete_bucket_response[0].data.d[0].clone());
     assert!(delete_bucket_response_result.is_ok());
-    assert_eq!(delete_bucket_response_result.unwrap(),
-               BorayError::new(BorayErrorType::BucketNotFound));
-
+    assert_eq!(
+        delete_bucket_response_result.unwrap(),
+        BorayError::new(BorayErrorType::BucketNotFound)
+    );
 
     // Try to read an object
     let bucket_id = Uuid::new_v4();
@@ -252,16 +237,13 @@ fn verify_rpc_handlers() {
         bucket_id,
         name: object.clone(),
         vnode: 1,
-        request_id
+        request_id,
     };
 
     let get_object_json = serde_json::to_value(vec![&get_object_payload]).unwrap();
-    let get_object_fast_msg_data =
-        FastMessageData::new("getobject".into(), get_object_json);
-    let get_object_fast_msg =
-        FastMessage::data(msg_id, get_object_fast_msg_data);
-    let mut get_object_result =
-        util::msg_handler(&get_object_fast_msg, &pool, &log);
+    let get_object_fast_msg_data = FastMessageData::new("getobject".into(), get_object_json);
+    let get_object_fast_msg = FastMessage::data(msg_id, get_object_fast_msg_data);
+    let mut get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -270,8 +252,10 @@ fn verify_rpc_handlers() {
     let get_object_response_result: Result<BorayError, _> =
         serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(), BorayError::new(BorayErrorType::ObjectNotFound));
-
+    assert_eq!(
+        get_object_response_result.unwrap(),
+        BorayError::new(BorayErrorType::ObjectNotFound)
+    );
 
     // Try to update an nonexistent object's metadata
     let object_id = Uuid::new_v4();
@@ -279,11 +263,11 @@ fn verify_rpc_handlers() {
     let mut update_headers = HashMap::new();
     let _ = update_headers.insert(
         "m-custom-header1".to_string(),
-        Some("customheaderval1".to_string())
+        Some("customheaderval1".to_string()),
     );
     let _ = update_headers.insert(
         "m-custom-header2".to_string(),
-        Some("customheaderval2".to_string())
+        Some("customheaderval2".to_string()),
     );
 
     let update_object_payload = object::update::UpdateObjectPayload {
@@ -295,16 +279,14 @@ fn verify_rpc_handlers() {
         content_type: "text/html".into(),
         headers: update_headers,
         properties: None,
-        request_id
+        request_id,
     };
 
     let update_object_json = serde_json::to_value(vec![update_object_payload]).unwrap();
     let update_object_fast_msg_data =
         FastMessageData::new("updateobject".into(), update_object_json);
-    let update_object_fast_msg =
-        FastMessage::data(msg_id, update_object_fast_msg_data);
-    let mut update_object_result =
-        util::msg_handler(&update_object_fast_msg, &pool, &log);
+    let update_object_fast_msg = FastMessage::data(msg_id, update_object_fast_msg_data);
+    let mut update_object_result = util::msg_handler(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     let mut update_object_response = update_object_result.unwrap();
@@ -313,9 +295,10 @@ fn verify_rpc_handlers() {
     let update_object_response_result: Result<BorayError, _> =
         serde_json::from_value(update_object_response[0].data.d[0].clone());
     assert!(update_object_response_result.is_ok());
-    assert_eq!(update_object_response_result.unwrap(),
-               BorayError::new(BorayErrorType::ObjectNotFound));
-
+    assert_eq!(
+        update_object_response_result.unwrap(),
+        BorayError::new(BorayErrorType::ObjectNotFound)
+    );
 
     // Create an object
     let shark1 = object::StorageNodeIdentifier {
@@ -339,16 +322,14 @@ fn verify_rpc_handlers() {
         headers: HashMap::new(),
         sharks: vec![shark1, shark2],
         properties: None,
-        request_id
+        request_id,
     };
 
     let create_object_json = serde_json::to_value(vec![create_object_payload]).unwrap();
     let create_object_fast_msg_data =
         FastMessageData::new("createobject".into(), create_object_json);
-    let create_object_fast_msg =
-        FastMessage::data(msg_id, create_object_fast_msg_data);
-    let mut create_object_result =
-        util::msg_handler(&create_object_fast_msg, &pool, &log);
+    let create_object_fast_msg = FastMessage::data(msg_id, create_object_fast_msg_data);
+    let mut create_object_result = util::msg_handler(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -359,10 +340,8 @@ fn verify_rpc_handlers() {
     assert!(create_object_response_result.is_ok());
     assert_eq!(create_object_response_result.unwrap().name, object);
 
-
     // Read object again and verify a successful response is returned
-    get_object_result =
-        util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -375,10 +354,8 @@ fn verify_rpc_handlers() {
     assert_eq!(get_object_unwrapped_result.name, object);
     assert_eq!(&get_object_unwrapped_result.content_type, "text/plain");
 
-
     // Update the object's metadata and verify it is successful
-    update_object_result =
-        util::msg_handler(&update_object_fast_msg, &pool, &log);
+    update_object_result = util::msg_handler(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     update_object_response = update_object_result.unwrap();
@@ -391,10 +368,8 @@ fn verify_rpc_handlers() {
     assert_eq!(update_object_unwrapped_result.name, object);
     assert_eq!(&update_object_unwrapped_result.content_type, "text/html");
 
-
     // Read object again and verify the metadata update
-    get_object_result =
-        util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
@@ -406,7 +381,6 @@ fn verify_rpc_handlers() {
     assert_eq!(get_object_unwrapped_result.name, object);
     assert_eq!(&get_object_unwrapped_result.content_type, "text/html");
 
-
     // Delete object
 
     // The get and delete object args are the same so we can reuse
@@ -414,10 +388,8 @@ fn verify_rpc_handlers() {
     let delete_object_json = serde_json::to_value(vec![get_object_payload]).unwrap();
     let delete_object_fast_msg_data =
         FastMessageData::new("deleteobject".into(), delete_object_json);
-    let delete_object_fast_msg =
-        FastMessage::data(msg_id, delete_object_fast_msg_data);
-    let mut delete_object_result =
-        util::msg_handler(&delete_object_fast_msg, &pool, &log);
+    let delete_object_fast_msg = FastMessage::data(msg_id, delete_object_fast_msg_data);
+    let mut delete_object_result = util::msg_handler(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -428,10 +400,8 @@ fn verify_rpc_handlers() {
     assert!(delete_object_response_result.is_ok());
     assert_eq!(delete_object_response_result.unwrap(), 1);
 
-
     // Read object again and verify it is not found
-    get_object_result =
-        util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -440,12 +410,13 @@ fn verify_rpc_handlers() {
     let get_object_response_result: Result<BorayError, _> =
         serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(),
-               BorayError::new(BorayErrorType::ObjectNotFound));
+    assert_eq!(
+        get_object_response_result.unwrap(),
+        BorayError::new(BorayErrorType::ObjectNotFound)
+    );
 
     // Delete the object again and verify it is not found
-    delete_object_result =
-        util::msg_handler(&delete_object_fast_msg, &pool, &log);
+    delete_object_result = util::msg_handler(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -454,8 +425,10 @@ fn verify_rpc_handlers() {
     let delete_object_response_result: Result<BorayError, _> =
         serde_json::from_value(delete_object_response[0].data.d[0].clone());
     assert!(delete_object_response_result.is_ok());
-    assert_eq!(delete_object_response_result.unwrap(),
-               BorayError::new(BorayErrorType::ObjectNotFound));
+    assert_eq!(
+        delete_object_response_result.unwrap(),
+        BorayError::new(BorayErrorType::ObjectNotFound)
+    );
 
     // List buckets and confirm none are found
 
@@ -465,24 +438,20 @@ fn verify_rpc_handlers() {
         prefix: Some("testbucket".into()),
         limit: 1000,
         marker: None,
-        request_id
+        request_id,
     };
 
     let list_buckets_json = serde_json::to_value(vec![list_buckets_payload]).unwrap();
-    let list_buckets_fast_msg_data =
-        FastMessageData::new("listbuckets".into(), list_buckets_json);
-    let list_buckets_fast_msg =
-        FastMessage::data(msg_id, list_buckets_fast_msg_data);
-    let mut list_buckets_result =
-        util::msg_handler(&list_buckets_fast_msg, &pool, &log);
+    let list_buckets_fast_msg_data = FastMessageData::new("listbuckets".into(), list_buckets_json);
+    let list_buckets_fast_msg = FastMessage::data(msg_id, list_buckets_fast_msg_data);
+    let mut list_buckets_result = util::msg_handler(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
     assert_eq!(list_buckets_response.len(), 0);
 
     // Create a bucket and list buckets again
-    create_bucket_result =
-        util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -493,14 +462,12 @@ fn verify_rpc_handlers() {
     assert!(create_bucket_response_result.is_ok());
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
-    list_buckets_result =
-        util::msg_handler(&list_buckets_fast_msg, &pool, &log);
+    list_buckets_result = util::msg_handler(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
     assert_eq!(list_buckets_response.len(), 1);
 
-
     // List objects and confirm none are found
 
     let list_objects_payload = object::list::ListObjectsPayload {
@@ -510,24 +477,20 @@ fn verify_rpc_handlers() {
         prefix: Some("testobject".into()),
         limit: 1000,
         marker: None,
-        request_id
+        request_id,
     };
 
     let list_objects_json = serde_json::to_value(vec![list_objects_payload]).unwrap();
-    let list_objects_fast_msg_data =
-        FastMessageData::new("listobjects".into(), list_objects_json);
-    let list_objects_fast_msg =
-        FastMessage::data(msg_id, list_objects_fast_msg_data);
-    let mut list_objects_result =
-        util::msg_handler(&list_objects_fast_msg, &pool, &log);
+    let list_objects_fast_msg_data = FastMessageData::new("listobjects".into(), list_objects_json);
+    let list_objects_fast_msg = FastMessage::data(msg_id, list_objects_fast_msg_data);
+    let mut list_objects_result = util::msg_handler(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
     assert_eq!(list_objects_response.len(), 0);
 
     // Create an object and list objects again
-    create_object_result =
-        util::msg_handler(&create_object_fast_msg, &pool, &log);
+    create_object_result = util::msg_handler(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -538,8 +501,7 @@ fn verify_rpc_handlers() {
     assert!(create_object_response_result.is_ok());
     assert_eq!(create_object_response_result.unwrap().name, object);
 
-    list_objects_result =
-        util::msg_handler(&list_objects_fast_msg, &pool, &log);
+    list_objects_result = util::msg_handler(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
