From 1e78f5d1ecc8895a9f48dcb71a88af590e3eeae5 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Thu, 11 Apr 2019 14:33:08 +0000
Subject: [PATCH] OS-7729 boot_platform is not set for the headnode

---
 lib/platform.js | 307 ++++++++++++++++--------------------------------
 1 file changed, 98 insertions(+), 209 deletions(-)

diff --git a/lib/platform.js b/lib/platform.js
index 3823ed6..ce904f4 100644
--- a/lib/platform.js
+++ b/lib/platform.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -51,92 +51,6 @@ function Platform(top) {
     this._usingLatest = [];
 }
 
-// TOOLS-1000: Look at /mnt/usbkey/boot/grub/menu.lst in order to get the real
-// platform the HN will boot by default:
-Platform.prototype.getHNPlatform = function getHNPlatform(cb) {
-    var self = this;
-    var hnPlatform;
-    var keyInitiallyMounted;
-    vasync.pipeline({funcs: [
-        function isKeyMounted(_, next) {
-            common.isUsbKeyMounted(self.log, function (err, mounted) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                keyInitiallyMounted = mounted;
-                next();
-            });
-        },
-        function mountUsbKey(_, next) {
-            if (keyInitiallyMounted) {
-                next();
-                return;
-            }
-
-            common.mountUsbKey(self.log, next);
-        },
-        function loadGrubMenuList(_, next) {
-            fs.readFile('/mnt/usbkey/boot/grub/menu.lst', {
-                encoding: 'utf8'
-            }, function (err, data) {
-                if (err) {
-                    err.cause = 'Read grub menu to load HN default platform';
-                    next(new errors.InternalError(err));
-                    return;
-                }
-                var defaultSection;
-                var sections = data.split('\n\n').filter(function (s) {
-                    if (s.search(/title/) === 0) {
-                        return true;
-                    } else if (s.charAt(0) === '#') {
-                        return false;
-                    } else {
-                        var cfg = s.split('\n');
-                        cfg.forEach(function (c) {
-                            var r = c.match(/default (\d+)/);
-                            if (r !== null) {
-                                defaultSection = Number(r[1]);
-                            }
-                        });
-                        return false;
-                    }
-                });
-
-                if (!sections[defaultSection]) {
-                    next(new errors.InternalError({
-                        message: 'Cannot find default section in grub menu'
-                    }));
-                    return;
-                }
-                var pattern = /\/os\/(\w+)\/platform/;
-                var result = sections[defaultSection].match(pattern);
-                if (result === null) {
-                    next(new errors.InternalError({
-                        message: 'Cannot find default platform in grub menu'
-                    }));
-                    return;
-                }
-
-                hnPlatform = result[1];
-                next();
-            });
-        },
-        function unmountUsbKey(_, next) {
-            if (keyInitiallyMounted) {
-                next();
-                return;
-            }
-
-            common.unmountUsbKey(self.log, next);
-        }
-
-    ]}, function _pipelineCb(err) {
-        cb(err, hnPlatform);
-    });
-};
-
-
 Platform.prototype.listUSBKeyPlatforms = function listUSBKeyPlatforms(cb) {
     var self = this;
     var usbKeyPlatforms;
@@ -202,91 +116,78 @@ function getPlatformsWithServers(cb) {
     var self = this;
     var latest;
 
-    self.getHNPlatform(function (er1, hnPlatform) {
-        if (er1) {
-            // Log the error reading from GRUB and just go ahead with CNAPI
-            self.log.debug({
-                err: er1
-            }, 'Error reading HN platform from grub menu');
+    self.sdcadm.cnapi.listPlatforms(function (err, platforms) {
+        if (err) {
+            cb(new errors.SDCClientError(err, 'cnapi'));
+            return;
+        }
+        if (Array.isArray(platforms) && !platforms.length) {
+            cb(new errors.UpdateError('no platforms found'));
+            return;
         }
 
-        self.sdcadm.cnapi.listPlatforms(function (err, platforms) {
-            if (err) {
-                cb(new errors.SDCClientError(err, 'cnapi'));
+        self._rawPlatforms = platforms;
+
+        self.sdcadm.cnapi.listServers({
+            setup: true
+        }, function (er2, servers) {
+            if (er2) {
+                cb(new errors.SDCClientError(er2, 'cnapi'));
                 return;
             }
-            if (Array.isArray(platforms) && !platforms.length) {
-                cb(new errors.UpdateError('no platforms found'));
+            if (Array.isArray(servers) && !servers.length) {
+                cb(new errors.UpdateError('no servers found'));
                 return;
             }
 
-            self._rawPlatforms = platforms;
+            self._rawServers = servers;
 
-            self.sdcadm.cnapi.listServers({
-                setup: true
-            }, function (er2, servers) {
-                if (er2) {
-                    cb(new errors.SDCClientError(er2, 'cnapi'));
-                    return;
-                }
-                if (Array.isArray(servers) && !servers.length) {
-                    cb(new errors.UpdateError('no servers found'));
-                    return;
+            Object.keys(platforms).forEach(function (k) {
+                platforms[k].boot_platform = [];
+                platforms[k].current_platform = [];
+                if (platforms[k].latest) {
+                    latest = k;
                 }
+            });
 
-                self._rawServers = servers;
-
-                Object.keys(platforms).forEach(function (k) {
-                    platforms[k].boot_platform = [];
-                    platforms[k].current_platform = [];
-                    if (platforms[k].latest) {
-                        latest = k;
+            vasync.forEachParallel({
+                inputs: servers,
+                func: function (s, next) {
+                    if (s.boot_platform === 'latest') {
+                        s.boot_platform = latest;
+                        self._usingLatest.push(s.uuid);
                     }
-                });
 
-                vasync.forEachParallel({
-                    inputs: servers,
-                    func: function (s, next) {
-                        if (s.boot_platform === 'latest') {
-                            s.boot_platform = latest;
-                            self._usingLatest.push(s.uuid);
-                        }
-
-                        if (s.current_platform === 'latest') {
-                            s.current_platform = latest;
-                            self._usingLatest.push(s.uuid);
-                        }
-
-                        if (s.headnode) {
-                            s.boot_platform = hnPlatform;
-                        }
-
-                        if (platforms[s.boot_platform]) {
-                            platforms[s.boot_platform].boot_platform.push({
-                                uuid: s.uuid,
-                                hostname: s.hostname
-                            });
-                        }
-
-                        if (platforms[s.current_platform]) {
-                            platforms[s.current_platform].current_platform
-                                .push({
-                                uuid: s.uuid,
-                                hostname: s.hostname
-                            });
-                        }
+                    if (s.current_platform === 'latest') {
+                        s.current_platform = latest;
+                        self._usingLatest.push(s.uuid);
+                    }
 
-                        next();
+                    if (platforms[s.boot_platform]) {
+                        platforms[s.boot_platform].boot_platform.push({
+                            uuid: s.uuid,
+                            hostname: s.hostname
+                        });
                     }
-                }, function (er3, results) {
-                    if (er3) {
-                        cb(new errors.InternalError({
-                            message: 'Error fetching platforms servers'
-                        }));
-                        return;
+
+                    if (platforms[s.current_platform]) {
+                        platforms[s.current_platform].current_platform
+                            .push({
+                            uuid: s.uuid,
+                            hostname: s.hostname
+                        });
                     }
-                    cb(null, platforms);
-                });
+
+                    next();
+                }
+            }, function (er3, results) {
+                if (er3) {
+                    cb(new errors.InternalError({
+                        message: 'Error fetching platforms servers'
+                    }));
+                    return;
+                }
+                cb(null, platforms);
             });
         });
     });
@@ -1387,66 +1288,54 @@ Platform.prototype.usage = function (platform, cb) {
     var self = this;
     assert.string(platform, 'platform');
 
-    self.getHNPlatform(function (er1, hnPlatform) {
-        if (er1) {
-            // Log the error reading from GRUB and just go ahead with CNAPI
-            self.log.error({
-                err: er1
-            }, 'Error reading HN platform from grub menu');
+    self.sdcadm.cnapi.listPlatforms(function (err, platforms) {
+        if (err) {
+            cb(new errors.SDCClientError(err, 'cnapi'));
+            return;
         }
-
-        self.sdcadm.cnapi.listPlatforms(function (err, platforms) {
-            if (err) {
-                cb(new errors.SDCClientError(err, 'cnapi'));
-                return;
-            }
-            if (Array.isArray(platforms) && !platforms.length) {
-                cb(new errors.UpdateError('no platforms found'));
+        if (Array.isArray(platforms) && !platforms.length) {
+            cb(new errors.UpdateError('no platforms found'));
+            return;
+        }
+        if (Object.keys(platforms).indexOf(platform) === -1) {
+            cb(new Error(format(
+                    'invalid platform %s', platform)));
+            return;
+        }
+        self.sdcadm.cnapi.listServers({
+            setup: true
+        }, function (er2, servers) {
+            if (er2) {
+                cb(new errors.SDCClientError(er2, 'cnapi'));
                 return;
             }
-            if (Object.keys(platforms).indexOf(platform) === -1) {
-                cb(new Error(format(
-                        'invalid platform %s', platform)));
+            if (Array.isArray(servers) && !servers.length) {
+                cb(new errors.UpdateError('no servers found'));
                 return;
             }
-            self.sdcadm.cnapi.listServers({
-                setup: true
-            }, function (er2, servers) {
-                if (er2) {
-                    cb(new errors.SDCClientError(er2, 'cnapi'));
-                    return;
+
+            var rows = [];
+
+            vasync.forEachParallel({
+                inputs: servers,
+                func: function (s, next) {
+                    if (s.boot_platform === platform ||
+                        s.current_platform === platform) {
+                        rows.push({
+                            uuid: s.uuid,
+                            hostname: s.hostname,
+                            current_platform: s.current_platform,
+                            boot_platform: s.boot_platform
+                        });
+                    }
+                    next();
                 }
-                if (Array.isArray(servers) && !servers.length) {
-                    cb(new errors.UpdateError('no servers found'));
+            }, function (er3) {
+                if (er3) {
+                    cb(er3);
                     return;
                 }
-
-                var rows = [];
-
-                vasync.forEachParallel({
-                    inputs: servers,
-                    func: function (s, next) {
-                        if (s.headnode) {
-                            s.boot_platform = hnPlatform;
-                        }
-                        if (s.boot_platform === platform ||
-                            s.current_platform === platform) {
-                            rows.push({
-                                uuid: s.uuid,
-                                hostname: s.hostname,
-                                current_platform: s.current_platform,
-                                boot_platform: s.boot_platform
-                            });
-                        }
-                        next();
-                    }
-                }, function (er3) {
-                    if (er3) {
-                        cb(er3);
-                        return;
-                    }
-                    cb(null, rows);
-                });
+                cb(null, rows);
             });
         });
     });
-- 
2.21.0

