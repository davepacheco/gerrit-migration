From 78cac994ffdd707cb564b6c033a0fc6a300eaef3 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 20 Jul 2017 19:07:21 -0700
Subject: [PATCH] MANTA-3356 prevent user and key enumeration through muskie

---
 lib/auth.js       | 85 +++++++++++++++++++++++++++++++++++++++--------
 lib/errors.js     | 14 ++++++--
 test/auth.test.js | 55 +++++++++++++++++++++++++++---
 3 files changed, 134 insertions(+), 20 deletions(-)

diff --git a/lib/auth.js b/lib/auth.js
index 68fe898..71564d9 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -29,6 +29,7 @@ var vasync = require('vasync');
 var libmanta = require('libmanta');
 var libuuid = require('libuuid');
 var xtend = require('xtend');
+var verror = require('verror');
 
 var common = require('./common');
 require('./errors');
@@ -51,6 +52,9 @@ var SIGN_ALG = {
 };
 
 
+var PUBLIC_STOR_ROOT = /^\/([a-zA-Z][a-zA-Z0-9_\-\.@%]+)\/public$/;
+
+
 ///--- Helpers
 
 function rfc3986(str) {
@@ -509,13 +513,14 @@ function loadCaller(req, res, next) {
 
     req.log.debug('loadCaller: entered');
     function gotCaller(err, info) {
+        var innerErr;
         if (err) {
             switch (err.restCode || err.name) {
             case 'AccountDoesNotExist':
-                next(new AccountDoesNotExistError(account));
+                innerErr = new AccountDoesNotExistError(account);
                 break;
             case 'UserDoesNotExist':
-                next(new UserDoesNotExistError(account, user));
+                innerErr = new UserDoesNotExistError(account, user);
                 break;
 
             /*
@@ -525,22 +530,36 @@ function loadCaller(req, res, next) {
              * we ever do support deleting users.
              */
             case 'UserIdDoesNotExist':
-                next(new UserDoesNotExistError(null, userid));
+                innerErr = new UserDoesNotExistError(null, userid);
                 break;
             case 'AccountIdDoesNotExist':
-                next(new AccountDoesNotExistError(accountid));
+                innerErr = new AccountDoesNotExistError(accountid);
                 break;
 
             default:
-                next(new InternalError(err));
+                innerErr = new InternalError(err);
                 break;
             }
+            /*
+             * We don't want to show the details of which of these error
+             * cases it was to the client: that would allow them to enumerate
+             * users and keys that do not belong to them.
+             */
+            next(new InvalidCredentialsError(innerErr));
             return;
         }
 
         if (!info.account.approved_for_provisioning &&
             !info.account.isOperator) {
-            next(new AccountBlockedError(info.account.login));
+            innerErr = new AccountBlockedError(info.account.login);
+            /*
+             * We can't show the user this one either without enabling
+             * enumeration. If we want to change this we would need to alter
+             * the auth process here to do the signature verification before
+             * making this decision (we can tell the user their account is
+             * disabled if we know that they've authenticated as that acct).
+             */
+            next(new InvalidCredentialsError(innerErr));
             return;
         }
 
@@ -595,13 +614,15 @@ function verifySignature(req, res, next) {
 
     var keyId = req.auth.keyId;
     var signature = req.auth.signature;
+    var innerErr;
 
     var keys = user ? user.keys : account.keys;
     if (!keys || !keys[keyId]) {
-        next(new KeyDoesNotExistError(
+        innerErr = new KeyDoesNotExistError(
             account.login,
             keyId,
-            user ? user.login : null));
+            user ? user.login : null);
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
 
@@ -609,11 +630,13 @@ function verifySignature(req, res, next) {
     try {
         var ok = httpSignature.verifySignature(signature, key);
     } catch (e) {
-        next(new InternalError(e));
+        innerErr = new InternalError(e);
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
     if (!ok) {
-        next(new InvalidSignatureError());
+        innerErr = new InvalidSignatureError();
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
 
@@ -690,17 +713,27 @@ function parseHttpAuthToken(req, res, next) {
 
 function loadOwner(req, res, next) {
     var p = req.path();
-    loadOwnerFromPath(req, p, next);
+    loadOwnerFromPath(req, p, res, next);
 }
 
+/*
+ * Generate a fake empty directory response, for a GET /user/public when
+ * the account "user" does not exist.
+ */
+function sendFakeEmptyDir(req, res) {
+    res.header('Content-Type', 'application/x-json-stream; type=directory');
+    res.header('Result-Set-Size', '0');
+    res.send(200);
+    res.end();
+}
 
 /*
  * Extract the owner of a resource based on the input path, verify that
  * the account exists, and set the `owner` field on the request object
  * to the object returned from Mahi.
  */
-function loadOwnerFromPath(req, p, next) {
-    req.log.debug('loadOwner: entered');
+function loadOwnerFromPath(req, p, res, next) {
+    req.log.debug('loadOwnerFromPath: entered');
 
     var account;
     try {
@@ -718,7 +751,31 @@ function loadOwnerFromPath(req, p, next) {
         if (err) {
             switch (err.restCode || err.name) {
             case 'AccountDoesNotExist':
-                next(new AccountDoesNotExistError(account));
+                var login;
+                if (req.caller.anonymous ||
+                    common.PUBLIC_STOR_PATH.test(req.path())) {
+                    login = 'anonymous';
+                } else if (!req.caller.user) {
+                    login = req.caller.account.login;
+                } else {
+                    login = req.caller.account.login + '/' +
+                        req.caller.user.login;
+                }
+                /*
+                 * For non-existent accounts, we want to behave as if it's a
+                 * real account that we have no access to. That means that
+                 * everything should return a 403 AuthorizationError, except
+                 * a GET on /user/public which should return a fake empty
+                 * directory.
+                 */
+                if (PUBLIC_STOR_ROOT.test(req.path()) && req.isReadOnly()) {
+                    sendFakeEmptyDir(req, res);
+                } else if (req.isPublicGet()) {
+                    next(new ResourceNotFoundError(req.path()));
+                    return;
+                }
+                var innerErr = new AccountDoesNotExistError(account);
+                next(new AuthorizationError(login, req.path(), innerErr));
                 return;
             default:
                 next(new InternalError(err));
diff --git a/lib/errors.js b/lib/errors.js
index 8e1e22d..caba892 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -70,16 +70,26 @@ function AuthSchemeError(scheme) {
 util.inherits(AuthSchemeError, MuskieError);
 
 
-function AuthorizationError(login, _path, reason) {
+function AuthorizationError(login, _path, cause) {
     MuskieError.call(this, {
         restCode: 'AuthorizationFailed',
         statusCode: 403,
         message: login + ' is not allowed to access ' + _path,
-        reason: reason
+        cause: cause
     });
 }
 util.inherits(AuthorizationError, MuskieError);
 
+function InvalidCredentialsError(cause) {
+    MuskieError.call(this, {
+        restCode: 'InvalidCredentials',
+        statusCode: 403,
+        message: 'Invalid authorization credentials supplied',
+        cause: cause
+    });
+}
+util.inherits(InvalidCredentialsError, MuskieError);
+
 
 function AuthorizationRequiredError(reason) {
     MuskieError.call(this, {
diff --git a/test/auth.test.js b/test/auth.test.js
index 5f7b74f..c31b285 100644
--- a/test/auth.test.js
+++ b/test/auth.test.js
@@ -291,8 +291,10 @@ test('auth caller not found', function (t) {
     rawRequest(opts, function (err, _, __, obj) {
         t.ok(err);
         t.equal(err.statusCode, 403);
-        t.equal(err.restCode, 'AccountDoesNotExist');
+        t.equal(err.restCode, 'InvalidCredentials');
         t.ok(err.message);
+        t.strictEqual(err.message.indexOf('AccountDoesNotExist'), -1);
+        this.firstCredError = err.message;
         t.end();
     });
 });
@@ -310,8 +312,9 @@ test('auth key not found', function (t) {
     rawRequest(opts, function (err, _, __, obj) {
         t.ok(err);
         t.equal(err.statusCode, 403);
-        t.equal(err.restCode, 'KeyDoesNotExist');
+        t.equal(err.restCode, 'InvalidCredentials');
         t.ok(err.message);
+        t.strictEqual(err.message, this.firstCredError);
         t.end();
     });
 });
@@ -327,8 +330,9 @@ test('signature invalid', function (t) {
     rawRequest(opts, function (err, _, __, obj) {
         t.ok(err);
         t.equal(err.statusCode, 403);
-        t.equal(err.restCode, 'InvalidSignature');
+        t.equal(err.restCode, 'InvalidCredentials');
         t.ok(err.message);
+        t.strictEqual(err.message, this.firstCredError);
         t.end();
     });
 });
@@ -416,7 +420,7 @@ test('presigned URL invalid signature', function (t) {
         rawRequest(path, function (err2, req, res, obj) {
             t.ok(err2);
             t.equal(res.statusCode, 403);
-            t.equal(obj.code, 'InvalidSignature');
+            t.equal(obj.code, 'InvalidCredentials');
             t.ok(obj.message);
             t.end();
         });
@@ -578,6 +582,49 @@ test('access unapproved and operator /public', function (t) { // MANTA-2214
     });
 });
 
+test('nonexistent user fake /public', function (t) {
+    this.client.get('/nonexistentuseraaa/public', function (err, stream, res) {
+        t.ifError(err);
+        t.ok(stream);
+        t.equal(res.statusCode, 200);
+        if (stream) {
+            stream.once('end', t.end.bind(t));
+            stream.resume();
+        } else {
+            t.end();
+        }
+    });
+});
+
+test('nonexistent user fake /public/thing', function (t) {
+    var opts = {
+        path: '/nonexistentuseraaa/public/thing',
+        headers: {
+        }
+    };
+    rawRequest(opts, function (err, _, __, obj) {
+        t.ok(err);
+        t.equal(err.statusCode, 404);
+        t.equal(err.restCode, 'ResourceNotFound');
+        t.ok(err.message);
+        t.end();
+    });
+});
+
+test('nonexistent user stor 403', function (t) {
+    var opts = {
+        path: '/nonexistentuseraaa/stor',
+        headers: {
+        }
+    };
+    rawRequest(opts, function (err, _, __, obj) {
+        t.ok(err);
+        t.equal(err.statusCode, 403);
+        t.equal(err.restCode, 'AuthorizationFailed');
+        t.ok(err.message);
+        t.end();
+    });
+});
 
 test('create auth token 403 (fails if MANTA_USER is operator)',
         function (t) {
-- 
2.21.0

