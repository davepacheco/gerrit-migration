commit a76e0c9e8284cf4cb30a2de17bccceb83673f54d (refs/changes/46/2246/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-07-20T19:07:51-07:00 (2 years, 3 months ago)
    
    MANTA-3356 prevent user and key enumeration through muskie

diff --git a/lib/auth.js b/lib/auth.js
index 68fe898..e757e70 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -29,6 +29,7 @@ var vasync = require('vasync');
 var libmanta = require('libmanta');
 var libuuid = require('libuuid');
 var xtend = require('xtend');
+var verror = require('verror');
 
 var common = require('./common');
 require('./errors');
@@ -509,13 +510,14 @@ function loadCaller(req, res, next) {
 
     req.log.debug('loadCaller: entered');
     function gotCaller(err, info) {
+        var innerErr;
         if (err) {
             switch (err.restCode || err.name) {
             case 'AccountDoesNotExist':
-                next(new AccountDoesNotExistError(account));
+                innerErr = new AccountDoesNotExistError(account);
                 break;
             case 'UserDoesNotExist':
-                next(new UserDoesNotExistError(account, user));
+                innerErr = new UserDoesNotExistError(account, user);
                 break;
 
             /*
@@ -525,22 +527,36 @@ function loadCaller(req, res, next) {
              * we ever do support deleting users.
              */
             case 'UserIdDoesNotExist':
-                next(new UserDoesNotExistError(null, userid));
+                innerErr = new UserDoesNotExistError(null, userid);
                 break;
             case 'AccountIdDoesNotExist':
-                next(new AccountDoesNotExistError(accountid));
+                innerErr = new AccountDoesNotExistError(accountid);
                 break;
 
             default:
-                next(new InternalError(err));
+                innerErr = new InternalError(err);
                 break;
             }
+            /*
+             * We don't want to show the details of which of these error
+             * cases it was to the client: that would allow them to enumerate
+             * users and keys that do not belong to them.
+             */
+            next(new InvalidCredentialsError(innerErr));
             return;
         }
 
         if (!info.account.approved_for_provisioning &&
             !info.account.isOperator) {
-            next(new AccountBlockedError(info.account.login));
+            innerErr = new AccountBlockedError(info.account.login);
+            /*
+             * We can't show the user this one either without enabling
+             * enumeration. If we want to change this we would need to alter
+             * the auth process here to do the signature verification before
+             * making this decision (we can tell the user their account is
+             * disabled if we know that they've authenticated as that acct).
+             */
+            next(new InvalidCredentialsError(innerErr));
             return;
         }
 
@@ -595,13 +611,15 @@ function verifySignature(req, res, next) {
 
     var keyId = req.auth.keyId;
     var signature = req.auth.signature;
+    var innerErr;
 
     var keys = user ? user.keys : account.keys;
     if (!keys || !keys[keyId]) {
-        next(new KeyDoesNotExistError(
+        innerErr = new KeyDoesNotExistError(
             account.login,
             keyId,
-            user ? user.login : null));
+            user ? user.login : null);
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
 
@@ -609,11 +627,13 @@ function verifySignature(req, res, next) {
     try {
         var ok = httpSignature.verifySignature(signature, key);
     } catch (e) {
-        next(new InternalError(e));
+        innerErr = new InternalError(e);
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
     if (!ok) {
-        next(new InvalidSignatureError());
+        innerErr = new InvalidSignatureError();
+        next(new InvalidCredentialsError(innerErr));
         return;
     }
 
@@ -690,16 +710,27 @@ function parseHttpAuthToken(req, res, next) {
 
 function loadOwner(req, res, next) {
     var p = req.path();
-    loadOwnerFromPath(req, p, next);
+    loadOwnerFromPath(req, p, res, next);
 }
 
+var PUBLIC_STOR_ROOT = /^\/([a-zA-Z][a-zA-Z0-9_\-\.@%]+)\/public$/;
+/*
+ * Generate a fake empty directory response, for a GET /user/public when
+ * the account "user" does not exist.
+ */
+function sendFakeEmptyDir(req, res) {
+    res.header('Content-Type', 'application/x-json-stream; type=directory');
+    res.header('Result-Set-Size', '0');
+    res.send(200);
+    res.end();
+}
 
 /*
  * Extract the owner of a resource based on the input path, verify that
  * the account exists, and set the `owner` field on the request object
  * to the object returned from Mahi.
  */
-function loadOwnerFromPath(req, p, next) {
+function loadOwnerFromPath(req, p, res, next) {
     req.log.debug('loadOwner: entered');
 
     var account;
@@ -718,7 +749,31 @@ function loadOwnerFromPath(req, p, next) {
         if (err) {
             switch (err.restCode || err.name) {
             case 'AccountDoesNotExist':
-                next(new AccountDoesNotExistError(account));
+                var login;
+                if (req.caller.anonymous ||
+                    common.PUBLIC_STOR_PATH.test(req.path())) {
+                    login = 'anonymous';
+                } else if (!req.caller.user) {
+                    login = req.caller.account.login;
+                } else {
+                    login = req.caller.account.login + '/' +
+                        req.caller.user.login;
+                }
+                /*
+                 * For non-existent accounts, we want to behave as if it's a
+                 * real account that we have no access to. That means that
+                 * everything should return a 403 AuthorizationError, except
+                 * a GET on /user/public which should return a fake empty
+                 * directory.
+                 */
+                if (PUBLIC_STOR_ROOT.test(req.path()) && req.isReadOnly()) {
+                    sendFakeEmptyDir(req, res);
+                } else if (req.isPublicGet()) {
+                    next(new ResourceNotFoundError(req.path()));
+                    return;
+                }
+                var innerErr = new AccountDoesNotExistError(account);
+                next(new AuthorizationError(login, req.path(), innerErr));
                 return;
             default:
                 next(new InternalError(err));
diff --git a/lib/errors.js b/lib/errors.js
index 8e1e22d..de0defd 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -80,6 +80,16 @@ function AuthorizationError(login, _path, reason) {
 }
 util.inherits(AuthorizationError, MuskieError);
 
+function InvalidCredentialsError(reason) {
+    MuskieError.call(this, {
+        restCode: 'InvalidCredentials',
+        statusCode: 403,
+        message: 'Invalid authorization credentials supplied',
+        reason: reason
+    });
+}
+util.inherits(InvalidCredentialsError, MuskieError);
+
 
 function AuthorizationRequiredError(reason) {
     MuskieError.call(this, {
