commit 0ca64a3cec94bdbdc9f2b30551230172bd84113d (refs/changes/05/3205/5)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2018-01-29T17:19:32+13:00 (1 year, 8 months ago)
    
    TRITON-19 Triton equivalent to AWS' termination protection

diff --git a/docs/api/commands/rm.md b/docs/api/commands/rm.md
index 1770bc4..34bd5ae 100644
--- a/docs/api/commands/rm.md
+++ b/docs/api/commands/rm.md
@@ -35,6 +35,19 @@ This command will delete all stopped containers. The command `docker ps
 command which will delete them. Any running containers will not be
 deleted.
 
+## Instance Protection
+
+It's possible to create containers that cannot be removed by adding a label
+during container creation: triton.instance.undeletable=true. To remove such a
+container, the tag must first be removed.
+
+An example of creating such a container with the instance-protection label:
+
+    $ docker run -d --label triton.instance.undeletable=true nginx
+
+To remove such labels, see [Instance Protection](https://apidocs.joyent.com/cloudapi/#instance-protection).
+It cannot be done through docker directly.
+
 ## Divergence
 
 The SDC Docker implementation does not support the following arguments:
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 177631e..e7a2be2 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -14,6 +14,7 @@ var net = require('net');
 var path = require('path');
 var spawn = child_process.spawn;
 var util = require('util');
+var verror = require('verror');
 
 var assert = require('assert-plus');
 var CNAPI = require('sdc-clients').CNAPI;
@@ -3248,9 +3249,17 @@ function deleteContainer(opts, callback) {
         vmapi.deleteVm(deleteParams, deleteHeaders,
             function _deleteVmCb(deleteErr, job) {
                 if (deleteErr) {
-                    log.error(deleteErr, 'Error deleting container.');
-                    callback(errors.vmapiErrorWrap(deleteErr,
-                        'problem deleting container'));
+                    var errMsg = 'problem deleting container';
+
+                    if (verror.hasCauseWithName(deleteErr,
+                        'CannotDeleteInstanceError')) {
+                        log.info({err: deleteErr}, 'Did not delete container');
+                        errMsg = deleteErr.message;
+                    } else {
+                        log.error(deleteErr, 'Error deleting container.');
+                    }
+
+                    callback(errors.vmapiErrorWrap(deleteErr, errMsg));
                     return;
                 } else {
                     log.info({job: job}, 'Container deleted successfully');
diff --git a/package.json b/package.json
index a809285..f816acb 100644
--- a/package.json
+++ b/package.json
@@ -27,7 +27,7 @@
     "strsplit": "1.0.0",
     "tape": "^4.4.0",
     "trace-event": "1.2.0",
-    "triton-tags": "1.1.4",
+    "triton-tags": "git+https://github.com/joyent/node-triton-tags.git#9485976bc579411619fe2bb9536fdcbeef907c97",
     "ufds": "1.2.0",
     "vasync": "2.1.0",
     "verror": "1.9.0",
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index 5da952d..1b9436b 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -341,6 +341,70 @@ test('api: create', function (tt) {
             t.end();
         }
     });
+
+    tt.test('docker create with instance protection',
+            function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { Labels: { 'triton.instance.undeletable': 'true' } }
+        }, oncreate);
+
+        function oncreate(err, result) {
+            t.ifErr(err, 'create container');
+            created = result;
+            t.equal(created.vm.tags['triton.instance.undeletable'], true,
+                'Instance protection tag set');
+            t.end();
+        }
+    });
+
+    tt.test('docker rm with instance protection should fail', function (t) {
+        DOCKER_ALICE.del('/containers/' + created.id, ondel);
+
+        function ondel(err, req, res, body) {
+            t.ok(err, 'rm container should fail');
+            t.ok(err.message.match('has "triton.instance.undeletable"'),
+                'check err message');
+            t.equal(res.statusCode, 409, '409 Conflict');
+            t.end();
+        }
+    });
+
+    tt.test('docker rm with instance protection removed', function (t) {
+        VMAPI.deleteMetadata('tags', { uuid: created.vm.uuid },
+            'triton.instance.undeletable', ondelmeta);
+
+        function ondelmeta(err) {
+            t.ifErr(err, 'remove instance tag');
+            waitmeta(15);
+        }
+
+        function waitmeta(count) {
+            if (count === 0) {
+                t.fail('instance protection tag did not delete in time');
+                t.end();
+                return;
+            }
+
+            VMAPI.getVm({ uuid: created.vm.uuid }, function (err, vm) {
+                t.ifErr(err, 'fetch VM');
+                if (vm.tags['triton.instance.undeletable']) {
+                    setTimeout(function () {
+                        waitmeta(count - 1);
+                    }, 2000); // wait 2s before next check
+                } else {
+                    DOCKER_ALICE.del('/containers/' + created.id, ondel);
+                }
+            });
+        }
+
+        function ondel(err, req, res, body) {
+            t.ifErr(err, 'rm container');
+            t.end();
+        }
+    });
 });
 
 
