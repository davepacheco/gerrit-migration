commit aae619339c50347faeb65c66dc8f33ae109920a6
Author: John Levon <john.levon@joyent.com>
Date:   2019-03-27T20:31:04+00:00 (6 months ago)
    
    OS-7662 need a way to disable HT

diff --git a/usr/src/cmd/psradm/psradm.c b/usr/src/cmd/psradm/psradm.c
index eab03a6ec4..5f9c75d729 100644
--- a/usr/src/cmd/psradm/psradm.c
+++ b/usr/src/cmd/psradm/psradm.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 #include <sys/types.h>
 #include <sys/procset.h>
@@ -53,9 +55,11 @@ static char	*basename(char *);
 static void
 usage(void)
 {
-	(void) fprintf(stderr,
-	    "usage: \n\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
-	    "\t%s -a -f|-n|-i [-v]\n", cmdname, cmdname);
+	(void) fprintf(stderr, "usage:\n"
+	    "\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
+	    "\t%s -a -f|-n|-i [-v]\n"
+	    "\t%s -aH [-v]\n",
+	    cmdname, cmdname, cmdname);
 }
 
 /*
@@ -84,6 +88,7 @@ static psr_action_t psr_action[] = {
 	{ P_NOINTR,	"no-intr",	"set to",	"ni"	},
 	{ P_SPARE,	"spare",	"marked",	"spr"	},
 	{ P_FAULTED,	"faulted",	"marked",	"flt"	},
+	{ P_DISABLED,	"disabled",	"set as",	"dis"	},
 };
 
 static int	psr_actions = sizeof (psr_action) / sizeof (psr_action_t);
@@ -218,10 +223,11 @@ main(int argc, char *argv[])
 	char	*errptr;
 	int	errors;
 	psr_action_t	*pac;
+	int disable_ht = 0;
 
 	cmdname = basename(argv[0]);
 
-	while ((c = getopt(argc, argv, "afFinsv")) != EOF) {
+	while ((c = getopt(argc, argv, "afFHinsv")) != EOF) {
 		switch (c) {
 
 		case 'a':		/* applies to all possible CPUs */
@@ -232,6 +238,11 @@ main(int argc, char *argv[])
 			force = 1;
 			break;
 
+		// FIXME man page
+		case 'H':
+			disable_ht = 1;
+			break;
+
 		case 'f':
 		case 'i':
 		case 'n':
@@ -256,6 +267,28 @@ main(int argc, char *argv[])
 		}
 	}
 
+	if (disable_ht) {
+		if (!all_flag) {
+			fprintf(stderr, "%s: -H must be used with -a.\n",
+			    cmdname);
+			usage();
+			return (2);
+		}
+
+		if (force || action != 0 || argc != optind) {
+			usage();
+			return (2);
+		}
+
+		if (p_online(P_ALL_SIBLINGS, P_DISABLED) == -1) {
+			fprintf(stderr, "Failed to disable hyper-threading: "
+			    "%s\n", strerror(errno));
+			return (EXIT_FAILURE);
+		}
+
+		return (EXIT_SUCCESS);
+	}
+
 	switch (action) {
 	case 'f':
 		action = P_OFFLINE;
diff --git a/usr/src/cmd/psrinfo/Makefile b/usr/src/cmd/psrinfo/Makefile
index 7786294a6f..c2ac077cfa 100644
--- a/usr/src/cmd/psrinfo/Makefile
+++ b/usr/src/cmd/psrinfo/Makefile
@@ -23,17 +23,16 @@
 #
 # Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
 #
-# cmd/psrinfo/Makefile
+# Copyright 2019, Joyent, Inc.
 #
 
-PROG=	psrinfo
+PROG = psrinfo
 
 include	../Makefile.cmd
 
-LDLIBS += -lkstat
+LDLIBS += -lkstat -ldevinfo
 CERRWARN += -_gcc=-Wno-uninitialized
-XGETFLAGS +=  
-$(PROG).po	:= CPPFLAGS += -DXGETTEXT
+$(PROG).po := CPPFLAGS += -DXGETTEXT
 
 
 .KEEP_STATE:
@@ -49,6 +48,4 @@ clean:
 $(ROOTUSRSBINBINPROG): $(PROG)
 	$(INS.file)
 
-lint:	lint_PROG
-
 include ../Makefile.targ
diff --git a/usr/src/cmd/psrinfo/psrinfo.c b/usr/src/cmd/psrinfo/psrinfo.c
index 6a3be82296..b5ffa161e0 100644
--- a/usr/src/cmd/psrinfo/psrinfo.c
+++ b/usr/src/cmd/psrinfo/psrinfo.c
@@ -12,6 +12,7 @@
 /*
  * Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -23,6 +24,9 @@
  * All the relevant kstats are in the cpu_info kstat module.
  */
 
+#include <sys/sysmacros.h>
+
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -33,17 +37,21 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <errno.h>
+#include <err.h>
+
+#include <libdevinfo.h>
 
 #define	_(x)	gettext(x)
 #if XGETTEXT
-/* These CPU states are here for benefit of xgettext */
-_("on-line")
-_("off-line")
-_("faulted")
-_("powered-off")
-_("no-intr")
-_("spare")
-_("unknown")
+	/* These CPU states are here for benefit of xgettext */
+	_("on-line")
+	_("off-line")
+	_("faulted")
+	_("powered-off")
+	_("no-intr")
+	_("spare")
+	_("unknown")
+	_("disabled")
 #endif
 
 /*
@@ -113,9 +121,11 @@ usage(char *msg)
 {
 	if (msg != NULL)
 		(void) fprintf(stderr, "%s: %s\n", cmdname, msg);
-	(void) fprintf(stderr, _("usage: \n" \
-	    "\t%s [-v] [-p] [processor_id ...]\n" \
-	    "\t%s -s [-p] processor_id\n"), cmdname, cmdname);
+	(void) fprintf(stderr, _("usage: \n"
+	    "\t%s -r propname\n"
+	    "\t%s [-v] [-p] [processor_id ...]\n"
+	    "\t%s -s [-p] processor_id\n"),
+	    cmdname, cmdname, cmdname);
 	exit(2);
 }
 
@@ -432,6 +442,65 @@ print_normal(int nspec)
 	}
 }
 
+static bool
+valid_propname(const char *propname)
+{
+	size_t i;
+
+	const char *props[] = {
+		"ht_enabled",
+	};
+
+	for (i = 0; i < ARRAY_SIZE(props); i++) {
+		if (strcmp(propname, props[i]) == 0)
+			break;
+	}
+
+	return (i != ARRAY_SIZE(props));
+}
+
+// FIXME: manpage
+static void
+read_property(const char *propname)
+{
+	di_prop_t prop = DI_PROP_NIL;
+	di_node_t root_node;
+	bool show_all = strcmp(propname, "all") == 0;
+
+	if (!show_all && !valid_propname(propname))
+		errx(EXIT_FAILURE, _("unknown CPU property %s"), propname);
+
+	if ((root_node = di_init("/", DINFOPROP)) == NULL)
+		err(EXIT_FAILURE, _("failed to read root node"));
+
+	while ((prop = di_prop_sys_next(root_node, prop)) != DI_PROP_NIL) {
+		const char *name = di_prop_name(prop);
+		char *val;
+		int nr_vals;
+
+		if (!valid_propname(name))
+			continue;
+
+		if (!show_all && strcmp(di_prop_name(prop), propname) != 0)
+			continue;
+
+		if ((nr_vals = di_prop_strings(prop, &val)) < 1) {
+			err(EXIT_FAILURE,
+			    _("error reading property %s"), name);
+		} else if (nr_vals != 1) {
+			errx(EXIT_FAILURE, _("invalid property %s"), name);
+		}
+
+		printf("%s=%s\n", name, val);
+
+		if (!show_all)
+			exit(EXIT_SUCCESS);
+	}
+
+	if (!show_all)
+		errx(EXIT_FAILURE, _("property %s was not found"), propname);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -445,6 +514,7 @@ main(int argc, char **argv)
 	char		*s;
 	int		nspec;
 	int		optc;
+	const char	*opt_r = NULL;
 	int		opt_s = 0;
 	int		opt_p = 0;
 	int		opt_v = 0;
@@ -606,14 +676,17 @@ nocpuid:
 
 	nspec = 0;
 
-	while ((optc = getopt(argc, argv, "pvs")) != EOF) {
+	while ((optc = getopt(argc, argv, "pr:sv")) != EOF) {
 		switch (optc) {
-		case 's':
-			opt_s = 1;
-			break;
 		case 'p':
 			opt_p = 1;
 			break;
+		case 'r':
+			opt_r = optarg;
+			break;
+		case 's':
+			opt_s = 1;
+			break;
 		case 'v':
 			opt_v = 1;
 			break;
@@ -622,6 +695,16 @@ nocpuid:
 		}
 	}
 
+	if (opt_r != NULL) {
+		if (optind != argc)
+			usage(_("cannot specify CPUs with -r"));
+		if (opt_p || opt_s || opt_v)
+			usage(_("cannot specify other arguments with -r"));
+
+		read_property(opt_r);
+		return (EXIT_SUCCESS);
+	}
+
 	while (optind < argc) {
 		long id;
 		char *eptr;
diff --git a/usr/src/uts/common/cpr/cpr_main.c b/usr/src/uts/common/cpr/cpr_main.c
index 7db797c848..181bfb123d 100644
--- a/usr/src/uts/common/cpr/cpr_main.c
+++ b/usr/src/uts/common/cpr/cpr_main.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * This module contains the guts of checkpoint-resume mechanism.
  * All code in this module is platform independent.
@@ -1324,7 +1328,7 @@ cpr_all_online(void)
 	do {
 		cp->cpu_cpr_flags &= ~CPU_CPR_ONLINE;
 		if (!CPU_ACTIVE(cp)) {
-			if ((rc = cpu_online(cp)) != 0)
+			if ((rc = cpu_online(cp, 0)) != 0)
 				break;
 			CPU_SET_CPR_FLAGS(cp, CPU_CPR_ONLINE);
 		}
diff --git a/usr/src/uts/common/cpr/cpr_misc.c b/usr/src/uts/common/cpr/cpr_misc.c
index b1906eb9fa..46ce35a54b 100644
--- a/usr/src/uts/common/cpr/cpr_misc.c
+++ b/usr/src/uts/common/cpr/cpr_misc.c
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -703,7 +704,7 @@ cpr_statefile_ok(vnode_t *vp, int alloc_retry)
 		 * Estimate space needed for the state file.
 		 *
 		 * State file size in bytes:
-		 * 	kernel size + non-cache pte seg +
+		 *	kernel size + non-cache pte seg +
 		 *	bitmap size + cpr state file headers size
 		 * (round up to fs->fs_bsize)
 		 */
@@ -996,7 +997,7 @@ cpr_p_online(cpu_t *cp, int state)
 
 	switch (state) {
 	case CPU_CPR_ONLINE:
-		rc = cpu_online(cp);
+		rc = cpu_online(cp, 0);
 		break;
 	case CPU_CPR_OFFLINE:
 		rc = cpu_offline(cp, CPU_FORCED);
diff --git a/usr/src/uts/common/os/cpu.c b/usr/src/uts/common/os/cpu.c
index 4648dae9dd..6cafc3e174 100644
--- a/usr/src/uts/common/os/cpu.c
+++ b/usr/src/uts/common/os/cpu.c
@@ -21,7 +21,7 @@
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -59,6 +59,7 @@
 #include <sys/time.h>
 #include <sys/archsystm.h>
 #include <sys/sdt.h>
+#include <sys/ht.h>
 #if defined(__x86) || defined(__amd64)
 #include <sys/x86_archext.h>
 #endif
@@ -144,6 +145,7 @@ processorid_t max_cpu_seqid_ever = 0;
 
 int ncpus = 1;
 int ncpus_online = 1;
+int ncpus_intr_enabled = 1;
 
 /*
  * CPU that we're trying to offline.  Protected by cpu_lock.
@@ -1209,7 +1211,7 @@ cpu_flagged_active(cpu_flag_t cpu_flags)
  * Bring the indicated CPU online.
  */
 int
-cpu_online(cpu_t *cp)
+cpu_online(cpu_t *cp, int flags)
 {
 	int	error = 0;
 
@@ -1217,12 +1219,15 @@ cpu_online(cpu_t *cp)
 	 * Handle on-line request.
 	 *	This code must put the new CPU on the active list before
 	 *	starting it because it will not be paused, and will start
-	 * 	using the active list immediately.  The real start occurs
+	 *	using the active list immediately.  The real start occurs
 	 *	when the CPU_QUIESCED flag is turned off.
 	 */
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if ((cp->cpu_flags & CPU_DISABLED) && !ht_can_enable(cp, flags))
+		return (EINVAL);
+
 	/*
 	 * Put all the cpus into a known safe place.
 	 * No mutexes can be entered while CPUs are paused.
@@ -1236,8 +1241,12 @@ cpu_online(cpu_t *cp)
 			cp->cpu_flags &= ~CPU_FAULTED;
 			mp_cpu_faulted_exit(cp);
 		}
+
+		if (cp->cpu_flags & CPU_DISABLED)
+			ht_force_enabled();
+
 		cp->cpu_flags &= ~(CPU_QUIESCED | CPU_OFFLINE | CPU_FROZEN |
-		    CPU_SPARE);
+		    CPU_SPARE | CPU_DISABLED);
 		CPU_NEW_GENERATION(cp);
 		start_cpus();
 		cpu_stats_kstat_create(cp);
@@ -1259,6 +1268,8 @@ cpu_online(cpu_t *cp)
 	return (error);
 }
 
+// FIXME: audit all cpu_state users for CPU_DISABLED
+
 /*
  * Take the indicated CPU offline.
  */
@@ -1278,10 +1289,13 @@ cpu_offline(cpu_t *cp, int flags)
 	lpl_t	*cpu_lpl;
 	proc_t	*p;
 	int	lgrp_diff_lpl;
-	boolean_t unbind_all_threads = (flags & CPU_FORCED) != 0;
+	boolean_t forced = (flags & CPU_FORCED) != 0;
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	/*
 	 * If we're going from faulted or spare to offline, just
 	 * clear these flags and update CPU state.
@@ -1309,7 +1323,7 @@ cpu_offline(cpu_t *cp, int flags)
 	 * Unbind all soft-bound threads bound to our CPU and hard bound threads
 	 * if we were asked to.
 	 */
-	error = cpu_unbind(cp->cpu_id, unbind_all_threads);
+	error = cpu_unbind(cp->cpu_id, forced);
 	if (error != 0)
 		return (error);
 	/*
@@ -1614,6 +1628,9 @@ cpu_faulted(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		cp->cpu_flags &= ~CPU_SPARE;
 		cp->cpu_flags |= CPU_FAULTED;
@@ -1642,6 +1659,9 @@ cpu_spare(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		if (cp->cpu_flags & CPU_FAULTED) {
 			cp->cpu_flags &= ~CPU_FAULTED;
@@ -1938,6 +1958,7 @@ cpu_add_active_internal(cpu_t *cp)
 	pg_cpu_active(cp);
 	lgrp_config(LGRP_CONFIG_CPU_ONLINE, (uintptr_t)cp, 0);
 
+	// FIXME?
 	bzero(&cp->cpu_loadavg, sizeof (cp->cpu_loadavg));
 }
 
@@ -1957,6 +1978,7 @@ cpu_add_active(cpu_t *cp)
 	cpu_stats_kstat_create(cp);
 	cpu_create_intrstat(cp);
 	lgrp_kstat_create(cp);
+	// FIXME: look at users
 	cpu_state_change_notify(cp->cpu_id, CPU_INIT);
 }
 
@@ -2267,28 +2289,9 @@ cpu_info_kstat_update(kstat_t *ksp, int rw)
 	if (cpuid_checkpass(cp, 1) == 0)
 		return (ENXIO);
 #endif
-	switch (cp->cpu_type_info.pi_state) {
-	case P_ONLINE:
-		pi_state = PS_ONLINE;
-		break;
-	case P_POWEROFF:
-		pi_state = PS_POWEROFF;
-		break;
-	case P_NOINTR:
-		pi_state = PS_NOINTR;
-		break;
-	case P_FAULTED:
-		pi_state = PS_FAULTED;
-		break;
-	case P_SPARE:
-		pi_state = PS_SPARE;
-		break;
-	case P_OFFLINE:
-		pi_state = PS_OFFLINE;
-		break;
-	default:
-		pi_state = "unknown";
-	}
+
+	pi_state = cpu_get_state_str(cp->cpu_flags);
+
 	(void) strcpy(cpu_info_template.ci_state.value.c, pi_state);
 	cpu_info_template.ci_state_begin.value.l = cp->cpu_state_begin;
 	(void) strncpy(cpu_info_template.ci_cpu_type.value.c,
@@ -3170,33 +3173,41 @@ cpu_set_state(cpu_t *cpu)
  * communication with user applications; cpu_flags provides the in-kernel
  * interface.
  */
-int
-cpu_get_state(cpu_t *cpu)
+static int
+cpu_flags_to_state(cpu_flag_t flags)
 {
-	ASSERT(MUTEX_HELD(&cpu_lock));
-	if (cpu->cpu_flags & CPU_POWEROFF)
+	if (flags & CPU_DISABLED)
+		return (P_DISABLED);
+	if (flags & CPU_POWEROFF)
 		return (P_POWEROFF);
-	else if (cpu->cpu_flags & CPU_FAULTED)
+	else if (flags & CPU_FAULTED)
 		return (P_FAULTED);
-	else if (cpu->cpu_flags & CPU_SPARE)
+	else if (flags & CPU_SPARE)
 		return (P_SPARE);
-	else if ((cpu->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
+	else if ((flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
 		return (P_OFFLINE);
-	else if (cpu->cpu_flags & CPU_ENABLE)
+	else if (flags & CPU_ENABLE)
 		return (P_ONLINE);
 	else
 		return (P_NOINTR);
 }
 
+int
+cpu_get_state(cpu_t *cpu)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	return (cpu_flags_to_state(cpu->cpu_flags));
+}
+
 /*
  * Return processor_info(2) state as a string.
  */
 const char *
-cpu_get_state_str(cpu_t *cpu)
+cpu_get_state_str(cpu_flag_t flags)
 {
 	const char *string;
 
-	switch (cpu_get_state(cpu)) {
+	switch (cpu_flags_to_state(flags)) {
 	case P_ONLINE:
 		string = PS_ONLINE;
 		break;
@@ -3215,6 +3226,9 @@ cpu_get_state_str(cpu_t *cpu)
 	case P_OFFLINE:
 		string = PS_OFFLINE;
 		break;
+	case P_DISABLED:
+		string = PS_DISABLED;
+		break;
 	default:
 		string = "unknown";
 		break;
@@ -3230,9 +3244,9 @@ cpu_get_state_str(cpu_t *cpu)
 static void
 cpu_stats_kstat_create(cpu_t *cp)
 {
-	int 	instance = cp->cpu_id;
-	char 	*module = "cpu";
-	char 	*class = "misc";
+	int	instance = cp->cpu_id;
+	char	*module = "cpu";
+	char	*class = "misc";
 	kstat_t	*ksp;
 	zoneid_t zoneid;
 
@@ -3468,18 +3482,18 @@ cpu_stat_ks_update(kstat_t *ksp, int rw)
 		cso->cpu_sysinfo.cpu[CPU_USER] = msnsecs[CMS_USER];
 	if (cso->cpu_sysinfo.cpu[CPU_KERNEL] < msnsecs[CMS_SYSTEM])
 		cso->cpu_sysinfo.cpu[CPU_KERNEL] = msnsecs[CMS_SYSTEM];
-	cso->cpu_sysinfo.cpu[CPU_WAIT] 	= 0;
-	cso->cpu_sysinfo.wait[W_IO] 	= 0;
+	cso->cpu_sysinfo.cpu[CPU_WAIT]	= 0;
+	cso->cpu_sysinfo.wait[W_IO]	= 0;
 	cso->cpu_sysinfo.wait[W_SWAP]	= 0;
 	cso->cpu_sysinfo.wait[W_PIO]	= 0;
-	cso->cpu_sysinfo.bread 		= CPU_STATS(cp, sys.bread);
-	cso->cpu_sysinfo.bwrite 	= CPU_STATS(cp, sys.bwrite);
-	cso->cpu_sysinfo.lread 		= CPU_STATS(cp, sys.lread);
-	cso->cpu_sysinfo.lwrite 	= CPU_STATS(cp, sys.lwrite);
-	cso->cpu_sysinfo.phread 	= CPU_STATS(cp, sys.phread);
-	cso->cpu_sysinfo.phwrite 	= CPU_STATS(cp, sys.phwrite);
-	cso->cpu_sysinfo.pswitch 	= CPU_STATS(cp, sys.pswitch);
-	cso->cpu_sysinfo.trap 		= CPU_STATS(cp, sys.trap);
+	cso->cpu_sysinfo.bread		= CPU_STATS(cp, sys.bread);
+	cso->cpu_sysinfo.bwrite		= CPU_STATS(cp, sys.bwrite);
+	cso->cpu_sysinfo.lread		= CPU_STATS(cp, sys.lread);
+	cso->cpu_sysinfo.lwrite		= CPU_STATS(cp, sys.lwrite);
+	cso->cpu_sysinfo.phread		= CPU_STATS(cp, sys.phread);
+	cso->cpu_sysinfo.phwrite	= CPU_STATS(cp, sys.phwrite);
+	cso->cpu_sysinfo.pswitch	= CPU_STATS(cp, sys.pswitch);
+	cso->cpu_sysinfo.trap		= CPU_STATS(cp, sys.trap);
 	cso->cpu_sysinfo.intr		= 0;
 	for (i = 0; i < PIL_MAX; i++)
 		cso->cpu_sysinfo.intr += CPU_STATS(cp, sys.intr[i]);
diff --git a/usr/src/uts/common/os/main.c b/usr/src/uts/common/os/main.c
index 3364d1e523..fbc20d5a29 100644
--- a/usr/src/uts/common/os/main.c
+++ b/usr/src/uts/common/os/main.c
@@ -27,7 +27,7 @@
 /*	  All Rights Reserved		*/
 
 /*
- * Copyright 2018, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -74,6 +74,7 @@
 #include <sys/stack.h>
 #include <sys/brand.h>
 #include <sys/mmapobj.h>
+#include <sys/ht.h>
 
 #include <vm/as.h>
 #include <vm/seg_kmem.h>
@@ -625,6 +626,8 @@ main(void)
 	pm_cfb_setup_intr();
 #if defined(__x86)
 	fastboot_post_startup();
+
+	ht_late_init();
 #endif
 
 	/*
diff --git a/usr/src/uts/common/os/pool_pset.c b/usr/src/uts/common/os/pool_pset.c
index 7f056a6c62..42b2e7159b 100644
--- a/usr/src/uts/common/os/pool_pset.c
+++ b/usr/src/uts/common/os/pool_pset.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 #include <sys/pool.h>
 #include <sys/pool_impl.h>
@@ -889,7 +891,7 @@ pool_pset_pack(ea_object_t *eo_system)
 			(void) nvlist_dup(cpu->cpu_props, &nvl, KM_SLEEP);
 			(void) nvlist_add_int64(nvl, "cpu.sys_id", cpu->cpu_id);
 			(void) nvlist_add_string(nvl, "cpu.status",
-			    (char *)cpu_get_state_str(cpu));
+			    (char *)cpu_get_state_str(cpu->cpu_flags));
 			buf = NULL;
 			bufsz = 0;
 			(void) nvlist_pack(nvl, &buf, &bufsz,
@@ -967,7 +969,7 @@ pool_cpu_propget(processorid_t cpuid, char *name, nvlist_t *nvl)
 	}
 	if (strcmp(name, "cpu.status") == 0) {
 		ret = nvlist_add_string(nvl, "cpu.status",
-		    (char *)cpu_get_state_str(cpu));
+		    (char *)cpu_get_state_str(cpu->cpu_flags));
 	} else {
 		ret = EINVAL;
 	}
diff --git a/usr/src/uts/common/sys/cpuvar.h b/usr/src/uts/common/sys/cpuvar.h
index 2cfe5116d9..04a2582eb8 100644
--- a/usr/src/uts/common/sys/cpuvar.h
+++ b/usr/src/uts/common/sys/cpuvar.h
@@ -23,7 +23,7 @@
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
  * Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  * Copyright 2017 RackTop Systems.
  */
 
@@ -99,11 +99,11 @@ typedef struct cpu {
 	/*
 	 * Links to other CPUs.  It is safe to walk these lists if
 	 * one of the following is true:
-	 * 	- cpu_lock held
-	 * 	- preemption disabled via kpreempt_disable
-	 * 	- PIL >= DISP_LEVEL
-	 * 	- acting thread is an interrupt thread
-	 * 	- all other CPUs are paused
+	 *	- cpu_lock held
+	 *	- preemption disabled via kpreempt_disable
+	 *	- PIL >= DISP_LEVEL
+	 *	- acting thread is an interrupt thread
+	 *	- all other CPUs are paused
 	 */
 	struct cpu	*cpu_next;		/* next existing CPU */
 	struct cpu	*cpu_prev;		/* prev existing CPU */
@@ -131,7 +131,7 @@ typedef struct cpu {
 	 */
 	char		cpu_runrun;	/* scheduling flag - set to preempt */
 	char		cpu_kprunrun;		/* force kernel preemption */
-	pri_t		cpu_chosen_level; 	/* priority at which cpu */
+	pri_t		cpu_chosen_level;	/* priority at which cpu */
 						/* was chosen for scheduling */
 	kthread_t	*cpu_dispthread; /* thread selected for dispatch */
 	disp_lock_t	cpu_thread_lock; /* dispatcher lock on current thread */
@@ -287,7 +287,7 @@ extern cpu_core_t cpu_core[];
  * list in avintr.c.
  */
 #define	INTR_ACTIVE(cpup, level)	\
-	((level) <= LOCK_LEVEL ? 	\
+	((level) <= LOCK_LEVEL ?	\
 	((cpup)->cpu_intr_actv & (1 << (level))) : (CPU_ON_INTR(cpup)))
 
 /*
@@ -329,10 +329,13 @@ extern cpu_core_t cpu_core[];
  * suspended (in the suspend path), or have yet to be resumed (in the resume
  * case).
  *
+ * CPU_DISABLED is used for disabling hyper-threading. It is similar to
+ * CPU_OFFLINE, but cannot be onlined without being forced.
+ *
  * On some platforms CPUs can be individually powered off.
  * The following flags are set for powered off CPUs: CPU_QUIESCED,
  * CPU_OFFLINE, and CPU_POWEROFF.  The following flags are cleared:
- * CPU_RUNNING, CPU_READY, CPU_EXISTS, and CPU_ENABLE.
+ * CPU_RUNNING, CPU_READY, CPU_EXISTS, CPU_DISABLED and CPU_ENABLE.
  */
 #define	CPU_RUNNING	0x001		/* CPU running */
 #define	CPU_READY	0x002		/* CPU ready for cross-calls */
@@ -344,10 +347,7 @@ extern cpu_core_t cpu_core[];
 #define	CPU_FROZEN	0x080		/* CPU is frozen via CPR suspend */
 #define	CPU_SPARE	0x100		/* CPU offline available for use */
 #define	CPU_FAULTED	0x200		/* CPU offline diagnosed faulty */
-
-#define	FMT_CPU_FLAGS							\
-	"\20\12fault\11spare\10frozen"					\
-	"\7poweroff\6offline\5enable\4exist\3quiesced\2ready\1run"
+#define	CPU_DISABLED	0x400		/* CPU explicitly disabled (HT) */
 
 #define	CPU_ACTIVE(cpu)	(((cpu)->cpu_flags & CPU_OFFLINE) == 0)
 
@@ -524,6 +524,7 @@ extern cpuset_t		cpu_active_set;	/* cached set of active CPUs */
 extern cpuset_t		cpu_available;	/* cached set of available CPUs */
 extern int		ncpus;		/* number of CPUs present */
 extern int		ncpus_online;	/* number of CPUs not quiesced */
+extern int		ncpus_intr_enabled; /* nr of CPUs taking I/O intrs */
 extern int		max_ncpus;	/* max present before ncpus is known */
 extern int		boot_max_ncpus;	/* like max_ncpus but for real */
 extern int		boot_ncpus;	/* # cpus present @ boot */
@@ -635,12 +636,12 @@ int	cpus_paused(void);
 void	cpu_pause_init(void);
 cpu_t	*cpu_get(processorid_t cpun);	/* get the CPU struct associated */
 
-int	cpu_online(cpu_t *cp);			/* take cpu online */
-int	cpu_offline(cpu_t *cp, int flags);	/* take cpu offline */
-int	cpu_spare(cpu_t *cp, int flags);	/* take cpu to spare */
-int	cpu_faulted(cpu_t *cp, int flags);	/* take cpu to faulted */
-int	cpu_poweron(cpu_t *cp);		/* take powered-off cpu to offline */
-int	cpu_poweroff(cpu_t *cp);	/* take offline cpu to powered-off */
+int	cpu_online(cpu_t *, int);	/* take cpu online */
+int	cpu_offline(cpu_t *, int);	/* take cpu offline */
+int	cpu_spare(cpu_t *, int);	/* take cpu to spare */
+int	cpu_faulted(cpu_t *, int);	/* take cpu to faulted */
+int	cpu_poweron(cpu_t *);		/* take powered-off cpu to offline */
+int	cpu_poweroff(cpu_t *);		/* take offline cpu to powered-off */
 
 cpu_t	*cpu_intr_next(cpu_t *cp);	/* get next online CPU taking intrs */
 int	cpu_intr_count(cpu_t *cp);	/* count # of CPUs handling intrs */
@@ -673,7 +674,7 @@ int	cpu_flagged_poweredoff(cpu_flag_t); /* flags show CPU is powered off */
  */
 void	cpu_set_state(cpu_t *);		/* record/timestamp current state */
 int	cpu_get_state(cpu_t *);		/* get current cpu state */
-const char *cpu_get_state_str(cpu_t *);	/* get current cpu state as string */
+const char *cpu_get_state_str(cpu_flag_t);
 
 
 void	cpu_set_curr_clock(uint64_t);	/* indicate the current CPU's freq */
diff --git a/usr/src/uts/common/sys/processor.h b/usr/src/uts/common/sys/processor.h
index ec4b7471e5..dd7a16e393 100644
--- a/usr/src/uts/common/sys/processor.h
+++ b/usr/src/uts/common/sys/processor.h
@@ -31,6 +31,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 #ifndef _SYS_PROCESSOR_H
 #define	_SYS_PROCESSOR_H
 
@@ -68,8 +72,9 @@ typedef int	chipid_t;
 #define	P_POWEROFF	0x0005	/* processor is powered off */
 #define	P_NOINTR	0x0006	/* processor is online, but no I/O interrupts */
 #define	P_SPARE		0x0007	/* processor is offline, can be reactivated */
+#define	P_DISABLED	0x0008	/* processor is explicitly disabled for use */
 #define	P_BAD		P_FAULTED	/* unused but defined by USL */
-#define	P_FORCED 	0x10000000	/* force processor offline */
+#define	P_FORCED	0x10000000	/* force processor offline */
 
 /*
  * String names for processor states defined above.
@@ -80,6 +85,7 @@ typedef int	chipid_t;
 #define	PS_POWEROFF	"powered-off"
 #define	PS_NOINTR	"no-intr"
 #define	PS_SPARE	"spare"
+#define	PS_DISABLED	"disabled" // FIXME: all man pages, PS_ONLINE users
 
 /*
  * Structure filled in by processor_info(2). This structure
@@ -95,7 +101,7 @@ typedef int	chipid_t;
 #define	PI_FPUTYPE	32	/* max size of FPU types string */
 
 typedef struct {
-	int	pi_state;  			/* processor state, see above */
+	int	pi_state;			/* processor state, see above */
 	char	pi_processor_type[PI_TYPELEN];	/* ASCII CPU type */
 	char	pi_fputypes[PI_FPUTYPE];	/* ASCII FPU types */
 	int	pi_clock;			/* CPU clock freq in MHz */
@@ -110,6 +116,11 @@ typedef struct {
 #define	PBIND_SOFT	-4	/* allows offlining CPU */
 #define	PBIND_QUERY_TYPE	-5	/* Return binding type */
 
+/*
+ * Sentinel values for p_online(2)
+ */
+#define	P_ALL_SIBLINGS (-1)
+
 /*
  * User-level system call interface prototypes
  */
diff --git a/usr/src/uts/common/syscall/p_online.c b/usr/src/uts/common/syscall/p_online.c
index 88a0340bf7..80ca4cc2ab 100644
--- a/usr/src/uts/common/syscall/p_online.c
+++ b/usr/src/uts/common/syscall/p_online.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/var.h>
@@ -37,13 +41,15 @@
 #include <sys/processor.h>
 #include <sys/debug.h>
 #include <sys/policy.h>
+#include <sys/ht.h>
 
 /*
  * CPU state diagram
  *
- *                   P_SPARE
+ *                  P_SPARE
  * P_POWEROFF <---> P_OFFLINE <---> P_ONLINE <---> P_NOINTR
  *                  P_FAULTED
+ *                  P_DISABLED
  */
 int
 p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
@@ -53,10 +59,17 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 	int	error = 0;
 	int	flags = 0;
 
-	/*
-	 * Try to get a pointer to the requested CPU structure.
-	 */
 	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (cpun == P_ALL_SIBLINGS) {
+		if (new_status != P_DISABLED) {
+			error = EINVAL;
+			goto out;
+		}
+
+		return (ht_disable());
+	}
+
 	if ((cp = cpu_get(cpun)) == NULL) {
 		error = EINVAL;
 		goto out;
@@ -81,8 +94,10 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 		if (secpolicy_ponline(CRED()) != 0)
 			error = EPERM;
 		break;
+	case P_DISABLED:
 	default:
 		error = EINVAL;
+		break;
 	}
 
 	if (error)
@@ -105,6 +120,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
@@ -112,11 +128,13 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is in one of the offline states,
 			 * bring it online.
 			 */
-			error = cpu_online(cp);
+			error = cpu_online(cp, flags);
 			break;
 		case P_NOINTR:
 			cpu_intr_enable(cp);
 			break;
+			error = cpu_online(cp, flags);
+			break;
 		}
 		break;
 
@@ -130,6 +148,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			cpu_intr_enable(cp);
 			/* FALLTHROUGH */
 		case P_ONLINE:
+		case P_DISABLED:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
@@ -143,6 +162,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is powered off, power it on.
 			 */
 			error = cpu_poweron(cp);
+			break;
 		}
 		break;
 
@@ -156,13 +176,14 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
 			 * First, bring the CPU online.
 			 */
-			if (error = cpu_online(cp))
+			if (error = cpu_online(cp, flags))
 				break;
 			/* FALLTHROUGH */
 		case P_ONLINE:
@@ -170,6 +191,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * CPU is now online.  Try to disable interrupts.
 			 */
 			error = cpu_intr_disable(cp);
+			break;
 		}
 		break;
 
@@ -183,14 +205,16 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
-		case P_SPARE:
 		case P_ONLINE:
 		case P_NOINTR:
+		case P_SPARE:
 			/*
 			 * Mark this CPU as faulted.
 			 */
 			error = cpu_faulted(cp, flags);
+			break;
 		}
 		break;
 
@@ -204,6 +228,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_ONLINE:
@@ -212,6 +237,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * Mark this CPU as a spare.
 			 */
 			error = cpu_spare(cp, flags);
+			break;
 		}
 		break;
 	}
diff --git a/usr/src/uts/i86pc/io/dr/dr_cpu.c b/usr/src/uts/i86pc/io/dr/dr_cpu.c
index a893310977..388696f938 100644
--- a/usr/src/uts/i86pc/io/dr/dr_cpu.c
+++ b/usr/src/uts/i86pc/io/dr/dr_cpu.c
@@ -28,6 +28,10 @@
  * All rights reserved.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * CPU support routines for DR
  */
@@ -326,7 +330,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -829,7 +833,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (rv == 0 && cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/i86pc/os/ht.c b/usr/src/uts/i86pc/os/ht.c
index 6e13eaedae..bce4869645 100644
--- a/usr/src/uts/i86pc/os/ht.c
+++ b/usr/src/uts/i86pc/os/ht.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -104,6 +104,13 @@
  * Used when scoring other CPUs in disp_lowpri_cpu().  If we shouldn't run here,
  * we'll add a small penalty to the score.  This also makes sure a VCPU thread
  * migration behaves properly.
+ *
+ *
+ * ht_init() / ht_late_init()
+ *
+ * Set up HT handling. If ht_boot_disable is set, ht_late_init(), which runs
+ * late enough to be able to do so, will offline and mark CPU_DISABLED all the
+ * siblings. ht_disable() can also be called after boot via psradm -Ha.
  */
 
 #include <sys/archsystm.h>
@@ -116,6 +123,10 @@
 #include <sys/cmn_err.h>
 #include <sys/sysmacros.h>
 #include <sys/x86_archext.h>
+#include <sys/esunddi.h>
+#include <sys/promif.h>
+#include <sys/policy.h>
+#include <sys/ht.h>
 
 #define	CS_SHIFT (8)
 #define	CS_MASK ((1 << CS_SHIFT) - 1)
@@ -153,65 +164,15 @@ int ht_exclusion = 1;
  */
 clock_t ht_acquire_wait_time = 64;
 
-static cpu_t *
-ht_find_sibling(cpu_t *cp)
-{
-	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
-		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
-		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
-
-		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
-			continue;
-
-		if (GROUP_SIZE(cg) == 1)
-			break;
-
-		VERIFY3U(GROUP_SIZE(cg), ==, 2);
-
-		if (GROUP_ACCESS(cg, 0) != cp)
-			return (GROUP_ACCESS(cg, 0));
-
-		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
-
-		return (GROUP_ACCESS(cg, 1));
-	}
-
-	return (NULL);
-}
-
 /*
- * Initialize HT links.  We have to be careful here not to race with
- * ht_begin/end_intr(), which also complicates trying to do this initialization
- * from a cross-call; hence the slightly odd approach below.
+ * Did we request a disable of HT at boot time?
  */
-void
-ht_init(void)
-{
-	cpu_t *scp = CPU;
-	cpu_t *cp = scp;
-	ulong_t flags;
-
-	if (!ht_exclusion)
-		return;
-
-	mutex_enter(&cpu_lock);
-
-	do {
-		thread_affinity_set(curthread, cp->cpu_id);
-		flags = intr_clear();
+int ht_boot_disable;
 
-		cp->cpu_m.mcpu_ht.ch_intr_depth = 0;
-		cp->cpu_m.mcpu_ht.ch_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		cp->cpu_m.mcpu_ht.ch_sibstate = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		ASSERT3P(cp->cpu_m.mcpu_ht.ch_sib, ==, NULL);
-		cp->cpu_m.mcpu_ht.ch_sib = ht_find_sibling(cp);
-
-		intr_restore(flags);
-		thread_affinity_clear(curthread);
-	} while ((cp = cp->cpu_next_onln) != scp);
-
-	mutex_exit(&cpu_lock);
-}
+/*
+ * Whether HT is enabled.
+ */
+int ht_enabled = 1;
 
 /*
  * We're adding an interrupt handler of some kind at the given PIL.  If this
@@ -611,3 +572,188 @@ ht_adjust_cpu_score(kthread_t *t, struct cpu *cp, pri_t score)
 
 	return (score + 1);
 }
+
+static void
+set_ht_prop(void)
+{
+	(void) e_ddi_prop_update_string(DDI_DEV_T_NONE, ddi_root_node(),
+	    "ht_enabled", ht_enabled ? "true" : "false");
+}
+
+static cpu_t *
+ht_find_sibling(cpu_t *cp)
+{
+	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
+		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
+		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
+
+		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
+			continue;
+
+		if (GROUP_SIZE(cg) == 1)
+			break;
+
+		VERIFY3U(GROUP_SIZE(cg), ==, 2);
+
+		if (GROUP_ACCESS(cg, 0) != cp)
+			return (GROUP_ACCESS(cg, 0));
+
+		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
+
+		return (GROUP_ACCESS(cg, 1));
+	}
+
+	return (NULL);
+}
+
+/*
+ * Offline all siblings and mark as CPU_DISABLED. Note that any siblings that
+ * can't be offlined (if it would leave an empty partition, or it's a spare, or
+ * whatever) will fail the whole operation.
+ */
+int
+ht_disable(void)
+{
+	int error = 0;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (secpolicy_ponline(CRED()) != 0)
+		return (EPERM);
+
+	if (!ht_enabled)
+		return (0);
+
+	for (size_t i = 0; i < NCPU; i++) {
+		cpu_t *sib;
+		cpu_t *cp;
+
+		if ((cp = cpu_get(i)) == NULL)
+			continue;
+
+		/* NB: don't have ->mcpu_ht yet. */
+		if ((sib = ht_find_sibling(cp)) == NULL)
+			continue;
+
+		if (cp->cpu_id < sib->cpu_id)
+			continue;
+
+		if (cp->cpu_flags & CPU_DISABLED) {
+			VERIFY(cp->cpu_flags & CPU_OFFLINE);
+			continue;
+		}
+
+		if (cp->cpu_flags & (CPU_FAULTED | CPU_SPARE)) {
+			error = EINVAL;
+			break;
+		}
+
+		if ((cp->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY) {
+			cp->cpu_flags |= CPU_DISABLED;
+			continue;
+		}
+
+		if ((error = cpu_offline(cp, CPU_FORCED)) != 0)
+			break;
+
+		cp->cpu_flags |= CPU_DISABLED;
+		cpu_set_state(cp);
+	}
+
+	if (error != 0)
+		return (error);
+
+	ht_enabled = 0;
+	set_ht_prop();
+	cmn_err(CE_NOTE, "!HT (hyper-threading) explicitly disabled.");
+	return (0);
+}
+
+boolean_t
+ht_can_enable(cpu_t *cp, int flags)
+{
+	VERIFY(cp->cpu_flags & CPU_DISABLED);
+
+	return (!ht_boot_disable && (flags & CPU_FORCED));
+}
+
+/*
+ * If we force-onlined a CPU_DISABLED CPU, then we can no longer consider the
+ * system to be HT-disabled in toto.
+ */
+void
+ht_force_enabled(void)
+{
+	VERIFY(!ht_boot_disable);
+
+	if (!ht_enabled)
+		cmn_err(CE_NOTE, "!Disabled HT sibling forced on-line.");
+
+	ht_enabled = 1;
+	set_ht_prop();
+}
+
+/*
+ * Initialize HT links.  We have to be careful here not to race with
+ * ht_begin/end_intr(), which also complicates trying to do this initialization
+ * from a cross-call; hence the slightly odd approach below.
+ *
+ * If we're going to disable HT via ht_late_init(), we will avoid paying the
+ * price here at all (we can't do it here since we're still too early in
+ * main()).
+ */
+void
+ht_init(void)
+{
+	cpu_t *scp = CPU;
+	cpu_t *cp = scp;
+	ulong_t flags;
+
+	if (!ht_exclusion || ht_boot_disable)
+		return;
+
+	mutex_enter(&cpu_lock);
+
+	do {
+		thread_affinity_set(curthread, cp->cpu_id);
+		flags = intr_clear();
+
+		cp->cpu_m.mcpu_ht.ch_intr_depth = 0;
+		cp->cpu_m.mcpu_ht.ch_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
+		cp->cpu_m.mcpu_ht.ch_sibstate = CS_MK(CM_THREAD, GLOBAL_ZONEID);
+		ASSERT3P(cp->cpu_m.mcpu_ht.ch_sib, ==, NULL);
+		cp->cpu_m.mcpu_ht.ch_sib = ht_find_sibling(cp);
+
+		intr_restore(flags);
+		thread_affinity_clear(curthread);
+	} while ((cp = cp->cpu_next_onln) != scp);
+
+	mutex_exit(&cpu_lock);
+}
+
+void
+ht_late_init(void)
+{
+	int err;
+
+	if (!ht_boot_disable) {
+		set_ht_prop();
+		cmn_err(CE_NOTE, "!HT enabled\n");
+		return;
+	}
+
+	mutex_enter(&cpu_lock);
+
+	err = ht_disable();
+
+	/*
+	 * We're early enough in boot that nothing should have stopped us from
+	 * offlining the siblings, and we didn't set up the infrastructure for
+	 * L1TF.
+	 */
+	if (err) {
+		cmn_err(CE_PANIC, "ht_disable() failed with %d", err);
+	}
+
+	mutex_exit(&cpu_lock);
+}
diff --git a/usr/src/uts/i86pc/os/mlsetup.c b/usr/src/uts/i86pc/os/mlsetup.c
index 94d4695141..b5d896cace 100644
--- a/usr/src/uts/i86pc/os/mlsetup.c
+++ b/usr/src/uts/i86pc/os/mlsetup.c
@@ -65,6 +65,7 @@
 #include <sys/apic_common.h>
 #include <sys/bootvfs.h>
 #include <sys/tsc.h>
+#include <sys/ht.h>
 #ifdef __xpv
 #include <sys/hypervisor.h>
 #else
@@ -185,6 +186,17 @@ mlsetup(struct regs *rp)
 	} else if (kpti_enable != 1) {
 		x86_use_pcid = 0;
 	}
+
+	/*
+	 * While we don't need to check this until later, we might as well do it
+	 * here.
+	 */
+	if (bootprop_getstr("ht_enabled", prop_str, sizeof (prop_str)) == 0) {
+		if (strcasecmp(prop_str, "false") == 0 ||
+		    strcmp(prop_str, "0") == 0)
+			ht_boot_disable = 1;
+	}
+
 #endif
 
 	/*
diff --git a/usr/src/uts/i86pc/os/mp_startup.c b/usr/src/uts/i86pc/os/mp_startup.c
index da629d02c2..844b1279f3 100644
--- a/usr/src/uts/i86pc/os/mp_startup.c
+++ b/usr/src/uts/i86pc/os/mp_startup.c
@@ -1996,6 +1996,10 @@ mp_cpu_stop(struct cpu *cp)
 
 /*
  * Take the specified CPU out of participation in interrupts.
+ *
+ * Usually, we hold cpu_lock. But we cannot assert as such due to the
+ * exception - i_cpr_save_context() - where we have mutual exclusion via a
+ * separate mechanism.
  */
 int
 cpu_disable_intr(struct cpu *cp)
@@ -2004,6 +2008,7 @@ cpu_disable_intr(struct cpu *cp)
 		return (EBUSY);
 
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 	return (0);
 }
 
@@ -2015,6 +2020,7 @@ cpu_enable_intr(struct cpu *cp)
 {
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 	psm_enable_intr(cp->cpu_id);
 }
 
diff --git a/usr/src/uts/i86pc/sys/ht.h b/usr/src/uts/i86pc/sys/ht.h
index 8bb5a0d6d2..96fe62bcdb 100644
--- a/usr/src/uts/i86pc/sys/ht.h
+++ b/usr/src/uts/i86pc/sys/ht.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef	_SYS_HT_H
@@ -25,7 +25,14 @@ extern "C" {
 
 struct cpu;
 
+extern int ht_boot_disable;
+
 extern void ht_init(void);
+extern void ht_late_init(void);
+extern int ht_disable(void);
+extern boolean_t ht_can_enable(struct cpu *, int);
+extern void ht_force_enabled(void);
+
 extern void ht_intr_alloc_pil(uint_t);
 
 extern int ht_acquire(void);
diff --git a/usr/src/uts/i86xpv/os/mp_xen.c b/usr/src/uts/i86xpv/os/mp_xen.c
index 02eda1c755..f2c528faa4 100644
--- a/usr/src/uts/i86xpv/os/mp_xen.c
+++ b/usr/src/uts/i86xpv/os/mp_xen.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * Virtual CPU management.
  *
@@ -681,6 +685,9 @@ poweroff_vcpu(struct cpu *cp)
 
 		CPUSET_DEL(cpu_ready_set, cp->cpu_id);
 
+		if (cp->cpu_flags & CPU_ENABLE)
+			ncpus_intr_enabled--;
+
 		cp->cpu_flags |= CPU_POWEROFF | CPU_OFFLINE;
 		cp->cpu_flags &=
 		    ~(CPU_RUNNING | CPU_READY | CPU_EXISTS | CPU_ENABLE);
diff --git a/usr/src/uts/intel/os/arch_kdi.c b/usr/src/uts/intel/os/arch_kdi.c
index 9677013ea5..1c5edf2749 100644
--- a/usr/src/uts/intel/os/arch_kdi.c
+++ b/usr/src/uts/intel/os/arch_kdi.c
@@ -22,7 +22,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -46,6 +46,8 @@
 #include <sys/kobj_impl.h>
 #include <sys/clock_impl.h>
 
+int kmdb_on_nmi;
+
 static void
 kdi_system_claim(void)
 {
diff --git a/usr/src/uts/intel/sys/archsystm.h b/usr/src/uts/intel/sys/archsystm.h
index 0c9ceac7be..01cbf83030 100644
--- a/usr/src/uts/intel/sys/archsystm.h
+++ b/usr/src/uts/intel/sys/archsystm.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _SYS_ARCHSYSTM_H
diff --git a/usr/src/uts/intel/sys/bootconf.h b/usr/src/uts/intel/sys/bootconf.h
index f0ade9d94d..255454d7c0 100644
--- a/usr/src/uts/intel/sys/bootconf.h
+++ b/usr/src/uts/intel/sys/bootconf.h
@@ -175,6 +175,8 @@ typedef struct bootops {
  * Boot configuration information
  */
 
+#define	BP_MAX_STRLEN	32
+
 #define	BO_MAXFSNAME	16
 #define	BO_MAXOBJNAME	256
 
diff --git a/usr/src/uts/sun4/os/intr.c b/usr/src/uts/sun4/os/intr.c
index 3a7143115d..86a89a91eb 100644
--- a/usr/src/uts/sun4/os/intr.c
+++ b/usr/src/uts/sun4/os/intr.c
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 /*
  * Copyright 2019 Peter Tribble.
@@ -326,7 +326,7 @@ siron_cpu_setup(cpu_setup_t what, int id, void *arg)
 
 /*
  * no_ivintr()
- * 	called by setvecint_tl1() through sys_trap()
+ *	called by setvecint_tl1() through sys_trap()
  *	vector interrupt received but not valid or not
  *	registered in intr_vec_table
  *	considered as a spurious mondo interrupt
@@ -420,6 +420,7 @@ cpu_disable_intr(struct cpu *cp)
 	 * function, since it checks for this in the cpu flags.
 	 */
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 
 	intr_redist_all_cpus();
 
@@ -438,6 +439,7 @@ cpu_enable_intr(struct cpu *cp)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 
 	intr_redist_all_cpus();
 }
diff --git a/usr/src/uts/sun4/os/mp_startup.c b/usr/src/uts/sun4/os/mp_startup.c
index ae68a23f8b..0235d04d61 100644
--- a/usr/src/uts/sun4/os/mp_startup.c
+++ b/usr/src/uts/sun4/os/mp_startup.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 #include <sys/sysmacros.h>
 #include <sys/prom_plat.h>
 #include <sys/prom_debug.h>
@@ -162,6 +166,10 @@ cold_flag_set(int cpuid)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp = cpu[cpuid];
+
+	if (!(cpu->cpu_flags & CPU_ENABLE))
+		ncpus_intr_enabled++;
+
 	cp->cpu_flags |= CPU_RUNNING | CPU_ENABLE | CPU_EXISTS;
 	cpu_add_active(cp);
 	/*
diff --git a/usr/src/uts/sun4/sys/ht.h b/usr/src/uts/sun4/sys/ht.h
index 6d7b3e37cc..17bb692d28 100644
--- a/usr/src/uts/sun4/sys/ht.h
+++ b/usr/src/uts/sun4/sys/ht.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef	_SYS_HT_H
@@ -24,6 +24,10 @@ extern "C" {
 #endif
 
 #define	ht_init() {}
+#define	ht_late_init() {}
+#define	ht_disable() (ENOTSUP)
+#define	ht_can_enable(c, f) (0)
+#define	ht_force_enabled() {}
 
 #define	ht_should_run(t, c) (B_TRUE)
 #define	ht_adjust_cpu_score(t, c, p) (p)
diff --git a/usr/src/uts/sun4u/io/sbd_cpu.c b/usr/src/uts/sun4u/io/sbd_cpu.c
index 5db48f7572..605f5d84fc 100644
--- a/usr/src/uts/sun4u/io/sbd_cpu.c
+++ b/usr/src/uts/sun4u/io/sbd_cpu.c
@@ -593,7 +593,7 @@ sbd_post_attach_cpu(sbd_handle_t *hp, sbd_devlist_t *devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, cpuid);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				SBD_SET_ERR(ep, ESBD_ONLINE);
 				SBD_SET_ERRSTR(ep, sbp->sb_cpupath[i]);
 				cmn_err(CE_WARN,
@@ -886,7 +886,7 @@ sbd_cancel_cpu(sbd_handle_t *hp, int unit)
 		if (cpu_flagged_offline(cp->sbc_cpu_flags)) {
 			PR_CPU("%s: leaving cpu %d OFFLINE\n",
 			    f, cp->sbc_cpu_id);
-		} else if (cpu_online(cpup)) {
+		} else if (cpu_online(cpup, 0)) {
 			cmn_err(CE_WARN,
 			    "sbd:%s: failed to online cpu %d",
 			    f, cp->sbc_cpu_id);
diff --git a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
index 87b5cc7fef..860b98940c 100644
--- a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
+++ b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
@@ -385,7 +385,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -882,7 +882,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/sun4u/starcat/io/drmach.c b/usr/src/uts/sun4u/starcat/io/drmach.c
index a5966aa4ab..73d09904d9 100644
--- a/usr/src/uts/sun4u/starcat/io/drmach.c
+++ b/usr/src/uts/sun4u/starcat/io/drmach.c
@@ -23,6 +23,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright (c) 2016 by Delphix. All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/note.h>
@@ -7487,7 +7488,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 
 	if (cpu_poweroff(cp)) {
 		DRMACH_PR("%s: cpu_poweroff failed for CPU id %d", fn, cpuid);
-		if (cpu_online(cp)) {
+		if (cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to online CPU id %d "
 			    "during I/O cage test selection", cpuid);
 		}
@@ -7509,7 +7510,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 			dp->busy = 1;
 			return (-1);
 		}
-		if (cpu_poweron(cp) || cpu_online(cp)) {
+		if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to %s CPU id %d "
 			    "during I/O cage test selection",
 			    cpu_is_poweredoff(cp) ?
@@ -7620,7 +7621,7 @@ drmach_iocage_cpu_return(drmach_device_t *dp, cpu_flag_t oflags)
 		return (-1);
 	}
 
-	if (cpu_poweron(cp) || cpu_online(cp)) {
+	if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 		cmn_err(CE_WARN, "failed to %s CPU id %d after I/O "
 		    "cage test", cpu_is_poweredoff(cp) ?
 		    "poweron" : "online", cpuid);
diff --git a/usr/src/uts/sun4v/io/dr_cpu.c b/usr/src/uts/sun4v/io/dr_cpu.c
index b8bf26f2fd..75c8148bcd 100644
--- a/usr/src/uts/sun4v/io/dr_cpu.c
+++ b/usr/src/uts/sun4v/io/dr_cpu.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * sun4v CPU DR Module
  */
@@ -1113,7 +1117,7 @@ dr_cpu_configure(processorid_t cpuid, int *status, boolean_t force)
 	 */
 	if (cpu_is_offline(cp)) {
 
-		if ((rv = cpu_online(cp)) != 0) {
+		if ((rv = cpu_online(cp, 0)) != 0) {
 			DR_DBG_CPU("failed to online CPU %d (%d)\n",
 			    cpuid, rv);
 			rv = DR_CPU_RES_FAILURE;
@@ -1535,7 +1539,7 @@ typedef struct {
 static int
 dr_cpu_check_node(dev_info_t *dip, void *arg)
 {
-	char 		*name;
+	char		*name;
 	processorid_t	cpuid;
 	dr_search_arg_t	*sarg = (dr_search_arg_t *)arg;
 
