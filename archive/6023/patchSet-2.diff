commit 0e3b1eef4f45d8437cb8a829053184dd1f6907e5
Author: John Levon <john.levon@joyent.com>
Date:   2019-04-26T11:22:23+00:00 (6 months ago)
    
    OS-7662 need a way to disable HT

diff --git a/usr/src/cmd/auditrecord/audit_record_attr.txt b/usr/src/cmd/auditrecord/audit_record_attr.txt
index 011f2aa153..5ccb13b95c 100644
--- a/usr/src/cmd/auditrecord/audit_record_attr.txt
+++ b/usr/src/cmd/auditrecord/audit_record_attr.txt
@@ -3,6 +3,7 @@
 # other comments are removed.
 ##
 ## Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+## Copyright 2019, Joyent, Inc.
 ##
 ## CDDL HEADER START
 ##
@@ -1393,7 +1394,7 @@ label=AUE_P_ONLINE
     comment=1, processor ID, "processor ID":
     comment=2, flags value, "flags":
     comment=text form of flags.  Values&colon;  \
-      P_ONLINE, P_OFFLINE, P_NOINTR, P_SPARE, P_FAULTED, P_STATUS
+      P_ONLINE, P_OFFLINE, P_NOINTR, P_SPARE, P_FAULTED, P_STATUS, P_DISABLED
 
 label=AUE_QUOTACTL
   skip=Not used.
diff --git a/usr/src/cmd/cpc/common/cpustat.c b/usr/src/cmd/cpc/common/cpustat.c
index 79daedc50b..28d4f3c393 100644
--- a/usr/src/cmd/cpc/common/cpustat.c
+++ b/usr/src/cmd/cpc/common/cpustat.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -689,6 +689,7 @@ cpustat(void)
 		case P_POWEROFF:
 		case P_FAULTED:
 		case P_SPARE:
+		case P_DISABLED:
 			gstate[i++].cpuid = -1;
 			break;
 		default:
diff --git a/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c b/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
index 3bcee999e8..2f62f1786a 100644
--- a/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
+++ b/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <cma.h>
@@ -302,6 +304,8 @@ p_online_state_fmt(int state)
 		return (PS_NOINTR);
 	case P_SPARE:
 		return (PS_SPARE);
+	case P_DISABLED:
+		return (PS_DISABLED);
 	default:
 		return ("unknown");
 	}
diff --git a/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c b/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
index 86a9b9049d..eaf756d699 100644
--- a/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
+++ b/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2013 by Delphix. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -824,6 +824,8 @@ dtracemdb_stat(void *varg, processorid_t cpu)
 		return (P_SPARE);
 	} else if (c.cpu_flags & CPU_FAULTED) {
 		return (P_FAULTED);
+	} else if (c.cpu_flags & CPU_DISABLED) {
+		return (P_DISABLED);
 	} else if ((c.cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY) {
 		return (P_OFFLINE);
 	} else if (c.cpu_flags & CPU_ENABLE) {
diff --git a/usr/src/cmd/mdb/common/modules/genunix/genunix.c b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
index fadd3c110c..48d25075f9 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/genunix.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
@@ -3070,7 +3070,7 @@ cpuinfo_walk_cpu(uintptr_t addr, const cpu_t *cpu, cpuinfo_data_t *cid)
 	const char *flags[] = {
 	    "RUNNING", "READY", "QUIESCED", "EXISTS",
 	    "ENABLE", "OFFLINE", "POWEROFF", "FROZEN",
-	    "SPARE", "FAULTED", NULL
+	    "SPARE", "FAULTED", "DISABLED", NULL
 	};
 
 	if (cid->cid_cpu != -1) {
diff --git a/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c b/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
index ab02d9091b..c428580979 100644
--- a/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
+++ b/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -1914,6 +1914,9 @@ get_pi_state(ptree_rarg_t *rarg, void *vbuf)
 	case P_POWEROFF:
 		(void) strlcpy(vbuf, PS_POWEROFF, MAX_STATE_SIZE);
 		break;
+	case P_DISABLED:
+		(void) strlcpy(vbuf, PS_DISABLED, MAX_STATE_SIZE);
+		break;
 	default:
 		(void) strlcpy(vbuf, "unknown", MAX_STATE_SIZE);
 		break;
diff --git a/usr/src/cmd/psradm/psradm.c b/usr/src/cmd/psradm/psradm.c
index eab03a6ec4..5f9c75d729 100644
--- a/usr/src/cmd/psradm/psradm.c
+++ b/usr/src/cmd/psradm/psradm.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 #include <sys/types.h>
 #include <sys/procset.h>
@@ -53,9 +55,11 @@ static char	*basename(char *);
 static void
 usage(void)
 {
-	(void) fprintf(stderr,
-	    "usage: \n\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
-	    "\t%s -a -f|-n|-i [-v]\n", cmdname, cmdname);
+	(void) fprintf(stderr, "usage:\n"
+	    "\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
+	    "\t%s -a -f|-n|-i [-v]\n"
+	    "\t%s -aH [-v]\n",
+	    cmdname, cmdname, cmdname);
 }
 
 /*
@@ -84,6 +88,7 @@ static psr_action_t psr_action[] = {
 	{ P_NOINTR,	"no-intr",	"set to",	"ni"	},
 	{ P_SPARE,	"spare",	"marked",	"spr"	},
 	{ P_FAULTED,	"faulted",	"marked",	"flt"	},
+	{ P_DISABLED,	"disabled",	"set as",	"dis"	},
 };
 
 static int	psr_actions = sizeof (psr_action) / sizeof (psr_action_t);
@@ -218,10 +223,11 @@ main(int argc, char *argv[])
 	char	*errptr;
 	int	errors;
 	psr_action_t	*pac;
+	int disable_ht = 0;
 
 	cmdname = basename(argv[0]);
 
-	while ((c = getopt(argc, argv, "afFinsv")) != EOF) {
+	while ((c = getopt(argc, argv, "afFHinsv")) != EOF) {
 		switch (c) {
 
 		case 'a':		/* applies to all possible CPUs */
@@ -232,6 +238,11 @@ main(int argc, char *argv[])
 			force = 1;
 			break;
 
+		// FIXME man page
+		case 'H':
+			disable_ht = 1;
+			break;
+
 		case 'f':
 		case 'i':
 		case 'n':
@@ -256,6 +267,28 @@ main(int argc, char *argv[])
 		}
 	}
 
+	if (disable_ht) {
+		if (!all_flag) {
+			fprintf(stderr, "%s: -H must be used with -a.\n",
+			    cmdname);
+			usage();
+			return (2);
+		}
+
+		if (force || action != 0 || argc != optind) {
+			usage();
+			return (2);
+		}
+
+		if (p_online(P_ALL_SIBLINGS, P_DISABLED) == -1) {
+			fprintf(stderr, "Failed to disable hyper-threading: "
+			    "%s\n", strerror(errno));
+			return (EXIT_FAILURE);
+		}
+
+		return (EXIT_SUCCESS);
+	}
+
 	switch (action) {
 	case 'f':
 		action = P_OFFLINE;
diff --git a/usr/src/cmd/psrinfo/Makefile b/usr/src/cmd/psrinfo/Makefile
index 7786294a6f..9836edac50 100644
--- a/usr/src/cmd/psrinfo/Makefile
+++ b/usr/src/cmd/psrinfo/Makefile
@@ -23,18 +23,18 @@
 #
 # Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
 #
-# cmd/psrinfo/Makefile
+# Copyright 2019, Joyent, Inc.
 #
 
-PROG=	psrinfo
+PROG = psrinfo
 
 include	../Makefile.cmd
 
-LDLIBS += -lkstat
-CERRWARN += -_gcc=-Wno-uninitialized
-XGETFLAGS +=  
-$(PROG).po	:= CPPFLAGS += -DXGETTEXT
+LDLIBS += -lkstat -ldevinfo
 
+$(PROG).po := CPPFLAGS += -DXGETTEXT
+
+CSTD=	$(CSTD_GNU99)
 
 .KEEP_STATE:
 
@@ -49,6 +49,4 @@ clean:
 $(ROOTUSRSBINBINPROG): $(PROG)
 	$(INS.file)
 
-lint:	lint_PROG
-
 include ../Makefile.targ
diff --git a/usr/src/cmd/psrinfo/psrinfo.c b/usr/src/cmd/psrinfo/psrinfo.c
index 6a3be82296..3c0ba53b59 100644
--- a/usr/src/cmd/psrinfo/psrinfo.c
+++ b/usr/src/cmd/psrinfo/psrinfo.c
@@ -12,6 +12,7 @@
 /*
  * Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -23,6 +24,9 @@
  * All the relevant kstats are in the cpu_info kstat module.
  */
 
+#include <sys/sysmacros.h>
+
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -33,17 +37,21 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <errno.h>
+#include <err.h>
+
+#include <libdevinfo.h>
 
 #define	_(x)	gettext(x)
 #if XGETTEXT
-/* These CPU states are here for benefit of xgettext */
-_("on-line")
-_("off-line")
-_("faulted")
-_("powered-off")
-_("no-intr")
-_("spare")
-_("unknown")
+	/* These CPU states are here for benefit of xgettext */
+	_("on-line")
+	_("off-line")
+	_("faulted")
+	_("powered-off")
+	_("no-intr")
+	_("spare")
+	_("unknown")
+	_("disabled")
 #endif
 
 /*
@@ -106,6 +114,10 @@ static struct link *pchips = NULL;
 static struct link *cores = NULL;
 static struct link *vcpus = NULL;
 
+static int nr_cpus;
+static int nr_cores;
+static int nr_chips;
+
 static const char *cmdname;
 
 static void
@@ -113,9 +125,12 @@ usage(char *msg)
 {
 	if (msg != NULL)
 		(void) fprintf(stderr, "%s: %s\n", cmdname, msg);
-	(void) fprintf(stderr, _("usage: \n" \
-	    "\t%s [-v] [-p] [processor_id ...]\n" \
-	    "\t%s -s [-p] processor_id\n"), cmdname, cmdname);
+	(void) fprintf(stderr, _("usage: \n"
+	    "\t%s -r propname\n"
+	    "\t%s [-v] [-p] [processor_id ...]\n"
+	    "\t%s -s [-p] processor_id\n"
+	    "\t%s -t [-S <state> | -c | -p]\n"),
+	    cmdname, cmdname, cmdname, cmdname);
 	exit(2);
 }
 
@@ -299,7 +314,7 @@ static void
 print_ps(void)
 {
 	int online = 1;
-	struct pchip *p;
+	struct pchip *p = NULL;
 	struct vcpu *v;
 	struct link *l;
 
@@ -432,6 +447,90 @@ print_normal(int nspec)
 	}
 }
 
+static bool
+valid_propname(const char *propname)
+{
+	size_t i;
+
+	const char *props[] = {
+		"ht_enabled",
+	};
+
+	for (i = 0; i < ARRAY_SIZE(props); i++) {
+		if (strcmp(propname, props[i]) == 0)
+			break;
+	}
+
+	return (i != ARRAY_SIZE(props));
+}
+
+static void
+read_property(const char *propname)
+{
+	di_prop_t prop = DI_PROP_NIL;
+	di_node_t root_node;
+	bool show_all = strcmp(propname, "all") == 0;
+
+	if (!show_all && !valid_propname(propname))
+		errx(EXIT_FAILURE, _("unknown CPU property %s"), propname);
+
+	if ((root_node = di_init("/", DINFOPROP)) == NULL)
+		err(EXIT_FAILURE, _("failed to read root node"));
+
+	while ((prop = di_prop_sys_next(root_node, prop)) != DI_PROP_NIL) {
+		const char *name = di_prop_name(prop);
+		char *val;
+		int nr_vals;
+
+		if (!valid_propname(name))
+			continue;
+
+		if (!show_all && strcmp(di_prop_name(prop), propname) != 0)
+			continue;
+
+		if ((nr_vals = di_prop_strings(prop, &val)) < 1) {
+			err(EXIT_FAILURE,
+			    _("error reading property %s"), name);
+		} else if (nr_vals != 1) {
+			errx(EXIT_FAILURE, _("invalid property %s"), name);
+		}
+
+		printf("%s=%s\n", name, val);
+
+		if (!show_all)
+			exit(EXIT_SUCCESS);
+	}
+
+	if (!show_all)
+		errx(EXIT_FAILURE, _("property %s was not found"), propname);
+}
+
+static void
+print_total(int opt_c, int opt_p, const char *opt_S)
+{
+	int count = 0;
+
+	if (opt_c) {
+		printf("%u\n", nr_cores);
+		return;
+	} else if (opt_p) {
+		printf("%u\n", nr_chips);
+		return;
+	} else if (opt_S == NULL || strcmp(opt_S, "all") == 0) {
+		printf("%u\n", nr_cpus);
+		return;
+	}
+
+
+	for (struct link *l = vcpus; l != NULL; l = l->l_next) {
+		struct vcpu *v = l->l_ptr;
+		if (strcmp(opt_S, v->v_state) == 0)
+			count++;
+	}
+
+	printf("%u\n", count);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -445,8 +544,12 @@ main(int argc, char **argv)
 	char		*s;
 	int		nspec;
 	int		optc;
-	int		opt_s = 0;
+	int		opt_c = 0;
 	int		opt_p = 0;
+	const char	*opt_r = NULL;
+	const char	*opt_S = NULL;
+	int		opt_s = 0;
+	int		opt_t = 0;
 	int		opt_v = 0;
 	int		ex = 0;
 
@@ -483,6 +586,7 @@ main(int argc, char **argv)
 			vc->v_link_core.l_ptr = vc;
 			vc->v_link_pchip.l_ptr = vc;
 			ins_link(ins, &vc->v_link);
+			nr_cpus++;
 		}
 
 		if ((knp = kstat_data_lookup(ksp, "state")) != NULL) {
@@ -569,6 +673,7 @@ nocpuid:
 			chip->p_link.l_id = vc->v_pchip_id;
 			chip->p_link.l_ptr = chip;
 			ins_link(ins, &chip->p_link);
+			nr_chips++;
 		}
 		vc->v_pchip = chip;
 
@@ -587,6 +692,7 @@ nocpuid:
 			(void) find_link(&chip->p_cores, core->c_link.l_id,
 			    &ins);
 			ins_link(ins, &core->c_link_pchip);
+			nr_cores++;
 		}
 		vc->v_core = core;
 
@@ -606,14 +712,26 @@ nocpuid:
 
 	nspec = 0;
 
-	while ((optc = getopt(argc, argv, "pvs")) != EOF) {
+	while ((optc = getopt(argc, argv, "cpr:S:stv")) != EOF) {
 		switch (optc) {
-		case 's':
-			opt_s = 1;
+		case 'c':
+			opt_c = 1;
 			break;
 		case 'p':
 			opt_p = 1;
 			break;
+		case 'r':
+			opt_r = optarg;
+			break;
+		case 'S':
+			opt_S = optarg;
+			break;
+		case 's':
+			opt_s = 1;
+			break;
+		case 't':
+			opt_t = 1;
+			break;
 		case 'v':
 			opt_v = 1;
 			break;
@@ -622,6 +740,33 @@ nocpuid:
 		}
 	}
 
+	if (opt_r != NULL) {
+		if (optind != argc)
+			usage(_("cannot specify CPUs with -r"));
+		if (opt_c || opt_p || opt_S != NULL || opt_s || opt_t || opt_v)
+			usage(_("cannot specify other arguments with -r"));
+
+		read_property(opt_r);
+		return (EXIT_SUCCESS);
+	}
+
+	if (opt_t != NULL) {
+		if (optind != argc)
+			usage(_("cannot specify CPUs with -t"));
+		if (opt_s || opt_v)
+			usage(_("cannot specify -s or -v with -t"));
+		if (opt_S != NULL && (opt_c || opt_p))
+			usage(_("cannot specify CPU state with -c or -p"));
+		if (opt_c && opt_p)
+			usage(_("cannot specify -c and -p"));
+
+		print_total(opt_c, opt_p, opt_S);
+		return (EXIT_SUCCESS);
+	}
+
+	if (opt_S != NULL || opt_c)
+		usage(_("cannot specify -S or -c without -t"));
+
 	while (optind < argc) {
 		long id;
 		char *eptr;
diff --git a/usr/src/man/man1m/psradm.1m b/usr/src/man/man1m/psradm.1m
index 9f7113757b..ca351fb93e 100644
--- a/usr/src/man/man1m/psradm.1m
+++ b/usr/src/man/man1m/psradm.1m
@@ -1,10 +1,11 @@
 '\" te
 .\"  Copyright (c) 2008 Sun Microsystems, Inc.
 .\" All Rights Reserved
+.\" Copyright 2019, Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PSRADM 1M "April 9, 2016"
+.TH PSRADM 1M "Apr 25, 2019"
 .SH NAME
 psradm \- change processor operational status
 .SH SYNOPSIS
@@ -18,11 +19,16 @@ psradm \- change processor operational status
 \fBpsradm\fR \fB-a\fR \fB-f\fR | \fB-i\fR | \fB-n\fR | \fB-s\fR [\fB-v\fR] [\fB-F\fR]
 .fi
 
+.LP
+.nf
+\fBpsradm\fR \fB-aH\fR [\fB-v\fR]
+.fi
+
 .SH DESCRIPTION
 .LP
 The \fBpsradm\fR utility changes the operational status of processors. The
 legal states for the processor are \fBon-line\fR, \fBoff-line\fR, \fBspare\fR,
-\fBfaulted\fR, and \fBno-intr\fR.
+\fBfaulted\fR, \fBno-intr\fR, and \fBdisabled\fR.
 .sp
 .LP
 An \fBon-line\fR processor processes \fBLWPs\fR (lightweight processes) and can
@@ -51,12 +57,19 @@ A \fBno-intr\fR processor processes \fBLWPs\fR but is not interruptible by I/O
 devices.
 .sp
 .LP
-A processor can not be taken \fBoff-line\fR or made \fBspare\fR if there are
-LWPs that are bound to the processor unless the additional \fB-F\fR option is
-used. The \fB-F\fR option removes processor bindings of such LWPs before
-changing the processor's operational status. On some architectures, it might
-not be possible to take certain processors \fBoff-line\fR or \fBspare\fR if,
-for example, the system depends on some resource provided by the processor.
+With the \fB-Ha\fR option, hyper-threading is disabled. Each CPU core has its
+SMT siblings in the \fBdisabled\fR state, and will effectively stay
+unused. That is, only one CPU in each core will be processing I/O, scheduling
+processes, etc. A CPU can only be moved back out of the \fBdisabled\fR state with
+the \fB-F\fR option.
+.sp
+.LP
+A processor can not be taken \fBoff-line\fR, \fBdisabled\fR, or made \fBspare\fR
+if there are LWPs that are bound to the processor unless the additional \fB-F\fR
+option is used. The \fB-F\fR option removes processor bindings of such LWPs
+before changing the processor's operational status. On some architectures, it
+might not be possible to take certain processors \fBoff-line\fR or \fBspare\fR
+if, for example, the system depends on some resource provided by the processor.
 .sp
 .LP
 At least one processor in the system must be able to process \fBLWPs.\fR At
@@ -109,6 +122,15 @@ states. Administrators are encouraged to use the \fB-Q\fR option for
 processor state transition.
 .RE
 
+.sp
+.ne 2
+.na
+\fB\fB-H\fR\fR
+.ad
+.RS 6n
+Disable hyper-threading.
+.RE
+
 .sp
 .ne 2
 .na
diff --git a/usr/src/man/man1m/psrinfo.1m b/usr/src/man/man1m/psrinfo.1m
index 9e107275e8..7adf877d76 100644
--- a/usr/src/man/man1m/psrinfo.1m
+++ b/usr/src/man/man1m/psrinfo.1m
@@ -1,9 +1,10 @@
 '\" te
 .\"  Copyright (c) 2004 Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2019, Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PSRINFO 1M "Feb 21, 2004"
+.TH PSRINFO 1M "Apr 25, 2019"
 .SH NAME
 psrinfo \- displays information about processors
 .SH SYNOPSIS
@@ -14,22 +15,28 @@ psrinfo \- displays information about processors
 
 .LP
 .nf
-\fBpsrinfo\fR [\fB-p\fR] \fB-s\fR \fIprocessor_id\fR
+\fBpsrinfo\fR \fB-t\fR [\fB-S state\fR | \fB-c\fR | \fB-p\fR]
+.fi
+
+.LP
+.nf
+\fBpsrinfo\fR \fB-r\fR [\fB<propname>\fR | \fBall\fR]
 .fi
 
 .SH DESCRIPTION
 .sp
 .LP
-\fBpsrinfo\fR displays information about processors. Each physical processor
-may support multiple virtual processors. Each virtual processor is an entity
-with its own interrupt \fBID\fR, capable of executing independent threads.
+\fBpsrinfo\fR displays information about processors. Each physical socket may
+contain multiple cores, which in turn can contain multiple virtual processors
+(also referred to as CPUs).  Each virtual processor is an entity
+with its own \fBID\fR, capable of executing independent threads.
 .sp
 .LP
-Without the \fIprocessor_id\fR operand, \fBpsrinfo\fR displays one line for
-each configured processor, displaying whether it is on-line, non-interruptible
-(designated by no-intr), spare, off-line, faulted or powered off, and when that
-status last changed. Use the processor_id operand to display information about
-a specific processor. See \fBOPERANDS\fR.
+Without the \fIprocessor_id\fR operand, \fBpsrinfo\fR displays one line for each
+configured processor, displaying whether it is on-line, non-interruptible
+(designated by no-intr), spare, off-line, faulted, disabled, or powered off, and
+when that status last changed. Use the processor_id operand to display
+information about a specific processor. See \fBOPERANDS\fR.
 .SH OPTIONS
 .sp
 .LP
@@ -37,14 +44,10 @@ The following options are supported:
 .sp
 .ne 2
 .na
-\fB\fB-s\fR\fI processor_id\fR\fR
+\fB\fB-c\fR\fR
 .ad
 .RS 19n
-Silent mode. Displays \fB1\fR if the specified processor is fully on-line.
-Displays \fB0\fR if the specified processor is non-interruptible, spare,
-off-line, faulted or powered off.
-.sp
-Use silent mode when using \fBpsrinfo\fR in shell scripts.
+When used with \fB-t\fR, report the total number of CPU cores.
 .RE
 
 .sp
@@ -53,10 +56,53 @@ Use silent mode when using \fBpsrinfo\fR in shell scripts.
 \fB\fB-p\fR\fR
 .ad
 .RS 19n
-Display the number of physical processors in a system.
+Display the number of physical sockets in a system.
 .sp
 When combined with the \fB-v\fR option, reports additional information about
-each physical processor.
+each physical socket.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-r\fR \fIpropname\fR\fR
+.ad
+.RS 19n
+Report CPU-specific properties that apply to the system as a whole. Supplying
+"all" will list all such properties in \fBkey=value\fR format. Currently, the
+only defined property is \fBht_enabled\fR, a boolean property indicating whether
+hyper-threading is active or not.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-S\fR \fIstate\fR\fR
+.ad
+.RS 19n
+When used with \fB-t\fR, report the total number of CPUs in the given state.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-s\fR\fI processor_id\fR\fR
+.ad
+.RS 19n
+Silent mode. Displays \fB1\fR if the specified processor is fully on-line,
+or \fB0\fR otherwise.
+.sp
+Use silent mode when using \fBpsrinfo\fR in shell scripts.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-t\fR\fR
+.ad
+.RS 19n
+Report totals. Without arguments, reports the total number of CPUs. This can be
+combined with the \fB-p\fR, \fB-c\fR, or \fB-S\fR options to modify the total.
 .RE
 
 .sp
@@ -91,6 +137,8 @@ Specify \fIprocessor_id\fR as an individual processor number (for example,
 3\fR), or a range of processor numbers (for example, \fB1-4\fR). It is also
 possible to combine ranges and (individual or multiple) \fIprocessor_id\fRs
 (for example, \fB1-3 5 7-8 9\fR).
+.sp
+This cannot be specified along with the \fB-r\fR or \fB-t\fR options.
 .RE
 
 .SH EXAMPLES
@@ -129,42 +177,41 @@ fi
 .sp
 
 .LP
-\fBExample 3 \fRDisplaying Information About the Physical Processors in the
+\fBExample 3 \fRDisplaying Information About the Physical Sockets in the
 System
 .sp
 .LP
-With no additional arguments, the \fB-p\fR option displays a single integer:
-the number of physical processors in the system:
+Use the \fB-tp\fR options to report the number of sockets.
 
 .sp
 .in +2
 .nf
-> psrinfo -p
-                8
+> psrinfo -tp
+                2
 .fi
 .in -2
 .sp
 
 .sp
 .LP
-\fBpsrinfo\fR also accepts command line arguments (processor \fBID\fRs):
+Without the \fB-t\fR option, \fB-p\fR also takes processor IDs:
 
 .sp
 .in +2
 .nf
-> psrinfo -p 0 512   # IDs 0 and 512 exist on the
-1                    # same physical processor
+> psrinfo -p 0 28    # IDs 0 and 28 exist on the
+1                    # same socket
 
 > psrinfo -p 0 1     # IDs 0 and 1 exist on different
-2                    # physical processors
+2                    # sockets
 .fi
 .in -2
 .sp
 
 .sp
 .LP
-In this example, virtual processors \fB0\fR and \fB512\fR exist on the same
-physical processor. Virtual processors \fB0\fR and \fB1\fR do not. This is
+In this example, virtual processors \fB0\fR and \fB28\fR exist on the same
+socket. Virtual processors \fB0\fR and \fB1\fR do not. This is
 specific to this example and is and not a general rule.
 
 .SH EXIT STATUS
diff --git a/usr/src/man/man2/p_online.2 b/usr/src/man/man2/p_online.2
index cd8e659361..0161e61c72 100644
--- a/usr/src/man/man2/p_online.2
+++ b/usr/src/man/man2/p_online.2
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2009, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2019, Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH P_ONLINE 2 "April 9, 2016"
+.TH P_ONLINE 2 "Apr 25, 2019"
 .SH NAME
 p_online \- return or change processor operational status
 .SH SYNOPSIS
@@ -87,6 +88,9 @@ The maximum possible \fIprocessorid\fR value can be determined by calling
 determined by calling \fBp_online()\fR with \fIprocessorid\fR values from 0 to
 the maximum returned by \fBsysconf(_SC_CPUID_MAX)\fR. The \fBEINVAL\fR error is
 returned for invalid processor numbers.  See \fBEXAMPLES\fR below.
+.sp
+.LP
+FIXME P_ALL_SIBLINGS and P_DISABLED
 .SH RETURN VALUES
 .LP
 On successful completion, the value returned is the previous state of the
diff --git a/usr/src/uts/common/cpr/cpr_main.c b/usr/src/uts/common/cpr/cpr_main.c
index 7db797c848..181bfb123d 100644
--- a/usr/src/uts/common/cpr/cpr_main.c
+++ b/usr/src/uts/common/cpr/cpr_main.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * This module contains the guts of checkpoint-resume mechanism.
  * All code in this module is platform independent.
@@ -1324,7 +1328,7 @@ cpr_all_online(void)
 	do {
 		cp->cpu_cpr_flags &= ~CPU_CPR_ONLINE;
 		if (!CPU_ACTIVE(cp)) {
-			if ((rc = cpu_online(cp)) != 0)
+			if ((rc = cpu_online(cp, 0)) != 0)
 				break;
 			CPU_SET_CPR_FLAGS(cp, CPU_CPR_ONLINE);
 		}
diff --git a/usr/src/uts/common/cpr/cpr_misc.c b/usr/src/uts/common/cpr/cpr_misc.c
index b1906eb9fa..46ce35a54b 100644
--- a/usr/src/uts/common/cpr/cpr_misc.c
+++ b/usr/src/uts/common/cpr/cpr_misc.c
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -703,7 +704,7 @@ cpr_statefile_ok(vnode_t *vp, int alloc_retry)
 		 * Estimate space needed for the state file.
 		 *
 		 * State file size in bytes:
-		 * 	kernel size + non-cache pte seg +
+		 *	kernel size + non-cache pte seg +
 		 *	bitmap size + cpr state file headers size
 		 * (round up to fs->fs_bsize)
 		 */
@@ -996,7 +997,7 @@ cpr_p_online(cpu_t *cp, int state)
 
 	switch (state) {
 	case CPU_CPR_ONLINE:
-		rc = cpu_online(cp);
+		rc = cpu_online(cp, 0);
 		break;
 	case CPU_CPR_OFFLINE:
 		rc = cpu_offline(cp, CPU_FORCED);
diff --git a/usr/src/uts/common/dtrace/dtrace.c b/usr/src/uts/common/dtrace/dtrace.c
index 8d5ccdc64b..36a05f835a 100644
--- a/usr/src/uts/common/dtrace/dtrace.c
+++ b/usr/src/uts/common/dtrace/dtrace.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
  */
 
@@ -6922,6 +6922,16 @@ dtrace_probe(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
 		return;
 
 	cookie = dtrace_interrupt_disable();
+
+	/*
+	 * Also refuse to process any probe firings that might happen on a
+	 * disabled CPU.
+	 */
+	if (CPU->cpu_flags & CPU_DISABLED) {
+		dtrace_interrupt_enable(cookie);
+		return;
+	}
+
 	probe = dtrace_probes[id - 1];
 	cpuid = CPU->cpu_id;
 	onintr = CPU_ON_INTR(CPU);
diff --git a/usr/src/uts/common/os/cpu.c b/usr/src/uts/common/os/cpu.c
index 4648dae9dd..d1800c4f17 100644
--- a/usr/src/uts/common/os/cpu.c
+++ b/usr/src/uts/common/os/cpu.c
@@ -21,7 +21,7 @@
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -59,6 +59,7 @@
 #include <sys/time.h>
 #include <sys/archsystm.h>
 #include <sys/sdt.h>
+#include <sys/ht.h>
 #if defined(__x86) || defined(__amd64)
 #include <sys/x86_archext.h>
 #endif
@@ -144,6 +145,7 @@ processorid_t max_cpu_seqid_ever = 0;
 
 int ncpus = 1;
 int ncpus_online = 1;
+int ncpus_intr_enabled = 1;
 
 /*
  * CPU that we're trying to offline.  Protected by cpu_lock.
@@ -1209,7 +1211,7 @@ cpu_flagged_active(cpu_flag_t cpu_flags)
  * Bring the indicated CPU online.
  */
 int
-cpu_online(cpu_t *cp)
+cpu_online(cpu_t *cp, int flags)
 {
 	int	error = 0;
 
@@ -1217,12 +1219,15 @@ cpu_online(cpu_t *cp)
 	 * Handle on-line request.
 	 *	This code must put the new CPU on the active list before
 	 *	starting it because it will not be paused, and will start
-	 * 	using the active list immediately.  The real start occurs
+	 *	using the active list immediately.  The real start occurs
 	 *	when the CPU_QUIESCED flag is turned off.
 	 */
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if ((cp->cpu_flags & CPU_DISABLED) && !ht_can_enable(cp, flags))
+		return (EINVAL);
+
 	/*
 	 * Put all the cpus into a known safe place.
 	 * No mutexes can be entered while CPUs are paused.
@@ -1236,8 +1241,12 @@ cpu_online(cpu_t *cp)
 			cp->cpu_flags &= ~CPU_FAULTED;
 			mp_cpu_faulted_exit(cp);
 		}
+
+		if (cp->cpu_flags & CPU_DISABLED)
+			ht_force_enabled();
+
 		cp->cpu_flags &= ~(CPU_QUIESCED | CPU_OFFLINE | CPU_FROZEN |
-		    CPU_SPARE);
+		    CPU_SPARE | CPU_DISABLED);
 		CPU_NEW_GENERATION(cp);
 		start_cpus();
 		cpu_stats_kstat_create(cp);
@@ -1278,10 +1287,13 @@ cpu_offline(cpu_t *cp, int flags)
 	lpl_t	*cpu_lpl;
 	proc_t	*p;
 	int	lgrp_diff_lpl;
-	boolean_t unbind_all_threads = (flags & CPU_FORCED) != 0;
+	boolean_t forced = (flags & CPU_FORCED) != 0;
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	/*
 	 * If we're going from faulted or spare to offline, just
 	 * clear these flags and update CPU state.
@@ -1309,7 +1321,7 @@ cpu_offline(cpu_t *cp, int flags)
 	 * Unbind all soft-bound threads bound to our CPU and hard bound threads
 	 * if we were asked to.
 	 */
-	error = cpu_unbind(cp->cpu_id, unbind_all_threads);
+	error = cpu_unbind(cp->cpu_id, forced);
 	if (error != 0)
 		return (error);
 	/*
@@ -1614,6 +1626,9 @@ cpu_faulted(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		cp->cpu_flags &= ~CPU_SPARE;
 		cp->cpu_flags |= CPU_FAULTED;
@@ -1642,6 +1657,9 @@ cpu_spare(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		if (cp->cpu_flags & CPU_FAULTED) {
 			cp->cpu_flags &= ~CPU_FAULTED;
@@ -2267,28 +2285,9 @@ cpu_info_kstat_update(kstat_t *ksp, int rw)
 	if (cpuid_checkpass(cp, 1) == 0)
 		return (ENXIO);
 #endif
-	switch (cp->cpu_type_info.pi_state) {
-	case P_ONLINE:
-		pi_state = PS_ONLINE;
-		break;
-	case P_POWEROFF:
-		pi_state = PS_POWEROFF;
-		break;
-	case P_NOINTR:
-		pi_state = PS_NOINTR;
-		break;
-	case P_FAULTED:
-		pi_state = PS_FAULTED;
-		break;
-	case P_SPARE:
-		pi_state = PS_SPARE;
-		break;
-	case P_OFFLINE:
-		pi_state = PS_OFFLINE;
-		break;
-	default:
-		pi_state = "unknown";
-	}
+
+	pi_state = cpu_get_state_str(cp->cpu_flags);
+
 	(void) strcpy(cpu_info_template.ci_state.value.c, pi_state);
 	cpu_info_template.ci_state_begin.value.l = cp->cpu_state_begin;
 	(void) strncpy(cpu_info_template.ci_cpu_type.value.c,
@@ -3170,33 +3169,41 @@ cpu_set_state(cpu_t *cpu)
  * communication with user applications; cpu_flags provides the in-kernel
  * interface.
  */
-int
-cpu_get_state(cpu_t *cpu)
+static int
+cpu_flags_to_state(cpu_flag_t flags)
 {
-	ASSERT(MUTEX_HELD(&cpu_lock));
-	if (cpu->cpu_flags & CPU_POWEROFF)
+	if (flags & CPU_DISABLED)
+		return (P_DISABLED);
+	else if (flags & CPU_POWEROFF)
 		return (P_POWEROFF);
-	else if (cpu->cpu_flags & CPU_FAULTED)
+	else if (flags & CPU_FAULTED)
 		return (P_FAULTED);
-	else if (cpu->cpu_flags & CPU_SPARE)
+	else if (flags & CPU_SPARE)
 		return (P_SPARE);
-	else if ((cpu->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
+	else if ((flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
 		return (P_OFFLINE);
-	else if (cpu->cpu_flags & CPU_ENABLE)
+	else if (flags & CPU_ENABLE)
 		return (P_ONLINE);
 	else
 		return (P_NOINTR);
 }
 
+int
+cpu_get_state(cpu_t *cpu)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	return (cpu_flags_to_state(cpu->cpu_flags));
+}
+
 /*
  * Return processor_info(2) state as a string.
  */
 const char *
-cpu_get_state_str(cpu_t *cpu)
+cpu_get_state_str(cpu_flag_t flags)
 {
 	const char *string;
 
-	switch (cpu_get_state(cpu)) {
+	switch (cpu_flags_to_state(flags)) {
 	case P_ONLINE:
 		string = PS_ONLINE;
 		break;
@@ -3215,6 +3222,9 @@ cpu_get_state_str(cpu_t *cpu)
 	case P_OFFLINE:
 		string = PS_OFFLINE;
 		break;
+	case P_DISABLED:
+		string = PS_DISABLED;
+		break;
 	default:
 		string = "unknown";
 		break;
@@ -3230,9 +3240,9 @@ cpu_get_state_str(cpu_t *cpu)
 static void
 cpu_stats_kstat_create(cpu_t *cp)
 {
-	int 	instance = cp->cpu_id;
-	char 	*module = "cpu";
-	char 	*class = "misc";
+	int	instance = cp->cpu_id;
+	char	*module = "cpu";
+	char	*class = "misc";
 	kstat_t	*ksp;
 	zoneid_t zoneid;
 
@@ -3468,18 +3478,18 @@ cpu_stat_ks_update(kstat_t *ksp, int rw)
 		cso->cpu_sysinfo.cpu[CPU_USER] = msnsecs[CMS_USER];
 	if (cso->cpu_sysinfo.cpu[CPU_KERNEL] < msnsecs[CMS_SYSTEM])
 		cso->cpu_sysinfo.cpu[CPU_KERNEL] = msnsecs[CMS_SYSTEM];
-	cso->cpu_sysinfo.cpu[CPU_WAIT] 	= 0;
-	cso->cpu_sysinfo.wait[W_IO] 	= 0;
+	cso->cpu_sysinfo.cpu[CPU_WAIT]	= 0;
+	cso->cpu_sysinfo.wait[W_IO]	= 0;
 	cso->cpu_sysinfo.wait[W_SWAP]	= 0;
 	cso->cpu_sysinfo.wait[W_PIO]	= 0;
-	cso->cpu_sysinfo.bread 		= CPU_STATS(cp, sys.bread);
-	cso->cpu_sysinfo.bwrite 	= CPU_STATS(cp, sys.bwrite);
-	cso->cpu_sysinfo.lread 		= CPU_STATS(cp, sys.lread);
-	cso->cpu_sysinfo.lwrite 	= CPU_STATS(cp, sys.lwrite);
-	cso->cpu_sysinfo.phread 	= CPU_STATS(cp, sys.phread);
-	cso->cpu_sysinfo.phwrite 	= CPU_STATS(cp, sys.phwrite);
-	cso->cpu_sysinfo.pswitch 	= CPU_STATS(cp, sys.pswitch);
-	cso->cpu_sysinfo.trap 		= CPU_STATS(cp, sys.trap);
+	cso->cpu_sysinfo.bread		= CPU_STATS(cp, sys.bread);
+	cso->cpu_sysinfo.bwrite		= CPU_STATS(cp, sys.bwrite);
+	cso->cpu_sysinfo.lread		= CPU_STATS(cp, sys.lread);
+	cso->cpu_sysinfo.lwrite		= CPU_STATS(cp, sys.lwrite);
+	cso->cpu_sysinfo.phread		= CPU_STATS(cp, sys.phread);
+	cso->cpu_sysinfo.phwrite	= CPU_STATS(cp, sys.phwrite);
+	cso->cpu_sysinfo.pswitch	= CPU_STATS(cp, sys.pswitch);
+	cso->cpu_sysinfo.trap		= CPU_STATS(cp, sys.trap);
 	cso->cpu_sysinfo.intr		= 0;
 	for (i = 0; i < PIL_MAX; i++)
 		cso->cpu_sysinfo.intr += CPU_STATS(cp, sys.intr[i]);
diff --git a/usr/src/uts/common/os/main.c b/usr/src/uts/common/os/main.c
index 3364d1e523..fbc20d5a29 100644
--- a/usr/src/uts/common/os/main.c
+++ b/usr/src/uts/common/os/main.c
@@ -27,7 +27,7 @@
 /*	  All Rights Reserved		*/
 
 /*
- * Copyright 2018, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -74,6 +74,7 @@
 #include <sys/stack.h>
 #include <sys/brand.h>
 #include <sys/mmapobj.h>
+#include <sys/ht.h>
 
 #include <vm/as.h>
 #include <vm/seg_kmem.h>
@@ -625,6 +626,8 @@ main(void)
 	pm_cfb_setup_intr();
 #if defined(__x86)
 	fastboot_post_startup();
+
+	ht_late_init();
 #endif
 
 	/*
diff --git a/usr/src/uts/common/os/pool_pset.c b/usr/src/uts/common/os/pool_pset.c
index 7f056a6c62..42b2e7159b 100644
--- a/usr/src/uts/common/os/pool_pset.c
+++ b/usr/src/uts/common/os/pool_pset.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 #include <sys/pool.h>
 #include <sys/pool_impl.h>
@@ -889,7 +891,7 @@ pool_pset_pack(ea_object_t *eo_system)
 			(void) nvlist_dup(cpu->cpu_props, &nvl, KM_SLEEP);
 			(void) nvlist_add_int64(nvl, "cpu.sys_id", cpu->cpu_id);
 			(void) nvlist_add_string(nvl, "cpu.status",
-			    (char *)cpu_get_state_str(cpu));
+			    (char *)cpu_get_state_str(cpu->cpu_flags));
 			buf = NULL;
 			bufsz = 0;
 			(void) nvlist_pack(nvl, &buf, &bufsz,
@@ -967,7 +969,7 @@ pool_cpu_propget(processorid_t cpuid, char *name, nvlist_t *nvl)
 	}
 	if (strcmp(name, "cpu.status") == 0) {
 		ret = nvlist_add_string(nvl, "cpu.status",
-		    (char *)cpu_get_state_str(cpu));
+		    (char *)cpu_get_state_str(cpu->cpu_flags));
 	} else {
 		ret = EINVAL;
 	}
diff --git a/usr/src/uts/common/sys/cpuvar.h b/usr/src/uts/common/sys/cpuvar.h
index 2cfe5116d9..04a2582eb8 100644
--- a/usr/src/uts/common/sys/cpuvar.h
+++ b/usr/src/uts/common/sys/cpuvar.h
@@ -23,7 +23,7 @@
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
  * Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  * Copyright 2017 RackTop Systems.
  */
 
@@ -99,11 +99,11 @@ typedef struct cpu {
 	/*
 	 * Links to other CPUs.  It is safe to walk these lists if
 	 * one of the following is true:
-	 * 	- cpu_lock held
-	 * 	- preemption disabled via kpreempt_disable
-	 * 	- PIL >= DISP_LEVEL
-	 * 	- acting thread is an interrupt thread
-	 * 	- all other CPUs are paused
+	 *	- cpu_lock held
+	 *	- preemption disabled via kpreempt_disable
+	 *	- PIL >= DISP_LEVEL
+	 *	- acting thread is an interrupt thread
+	 *	- all other CPUs are paused
 	 */
 	struct cpu	*cpu_next;		/* next existing CPU */
 	struct cpu	*cpu_prev;		/* prev existing CPU */
@@ -131,7 +131,7 @@ typedef struct cpu {
 	 */
 	char		cpu_runrun;	/* scheduling flag - set to preempt */
 	char		cpu_kprunrun;		/* force kernel preemption */
-	pri_t		cpu_chosen_level; 	/* priority at which cpu */
+	pri_t		cpu_chosen_level;	/* priority at which cpu */
 						/* was chosen for scheduling */
 	kthread_t	*cpu_dispthread; /* thread selected for dispatch */
 	disp_lock_t	cpu_thread_lock; /* dispatcher lock on current thread */
@@ -287,7 +287,7 @@ extern cpu_core_t cpu_core[];
  * list in avintr.c.
  */
 #define	INTR_ACTIVE(cpup, level)	\
-	((level) <= LOCK_LEVEL ? 	\
+	((level) <= LOCK_LEVEL ?	\
 	((cpup)->cpu_intr_actv & (1 << (level))) : (CPU_ON_INTR(cpup)))
 
 /*
@@ -329,10 +329,13 @@ extern cpu_core_t cpu_core[];
  * suspended (in the suspend path), or have yet to be resumed (in the resume
  * case).
  *
+ * CPU_DISABLED is used for disabling hyper-threading. It is similar to
+ * CPU_OFFLINE, but cannot be onlined without being forced.
+ *
  * On some platforms CPUs can be individually powered off.
  * The following flags are set for powered off CPUs: CPU_QUIESCED,
  * CPU_OFFLINE, and CPU_POWEROFF.  The following flags are cleared:
- * CPU_RUNNING, CPU_READY, CPU_EXISTS, and CPU_ENABLE.
+ * CPU_RUNNING, CPU_READY, CPU_EXISTS, CPU_DISABLED and CPU_ENABLE.
  */
 #define	CPU_RUNNING	0x001		/* CPU running */
 #define	CPU_READY	0x002		/* CPU ready for cross-calls */
@@ -344,10 +347,7 @@ extern cpu_core_t cpu_core[];
 #define	CPU_FROZEN	0x080		/* CPU is frozen via CPR suspend */
 #define	CPU_SPARE	0x100		/* CPU offline available for use */
 #define	CPU_FAULTED	0x200		/* CPU offline diagnosed faulty */
-
-#define	FMT_CPU_FLAGS							\
-	"\20\12fault\11spare\10frozen"					\
-	"\7poweroff\6offline\5enable\4exist\3quiesced\2ready\1run"
+#define	CPU_DISABLED	0x400		/* CPU explicitly disabled (HT) */
 
 #define	CPU_ACTIVE(cpu)	(((cpu)->cpu_flags & CPU_OFFLINE) == 0)
 
@@ -524,6 +524,7 @@ extern cpuset_t		cpu_active_set;	/* cached set of active CPUs */
 extern cpuset_t		cpu_available;	/* cached set of available CPUs */
 extern int		ncpus;		/* number of CPUs present */
 extern int		ncpus_online;	/* number of CPUs not quiesced */
+extern int		ncpus_intr_enabled; /* nr of CPUs taking I/O intrs */
 extern int		max_ncpus;	/* max present before ncpus is known */
 extern int		boot_max_ncpus;	/* like max_ncpus but for real */
 extern int		boot_ncpus;	/* # cpus present @ boot */
@@ -635,12 +636,12 @@ int	cpus_paused(void);
 void	cpu_pause_init(void);
 cpu_t	*cpu_get(processorid_t cpun);	/* get the CPU struct associated */
 
-int	cpu_online(cpu_t *cp);			/* take cpu online */
-int	cpu_offline(cpu_t *cp, int flags);	/* take cpu offline */
-int	cpu_spare(cpu_t *cp, int flags);	/* take cpu to spare */
-int	cpu_faulted(cpu_t *cp, int flags);	/* take cpu to faulted */
-int	cpu_poweron(cpu_t *cp);		/* take powered-off cpu to offline */
-int	cpu_poweroff(cpu_t *cp);	/* take offline cpu to powered-off */
+int	cpu_online(cpu_t *, int);	/* take cpu online */
+int	cpu_offline(cpu_t *, int);	/* take cpu offline */
+int	cpu_spare(cpu_t *, int);	/* take cpu to spare */
+int	cpu_faulted(cpu_t *, int);	/* take cpu to faulted */
+int	cpu_poweron(cpu_t *);		/* take powered-off cpu to offline */
+int	cpu_poweroff(cpu_t *);		/* take offline cpu to powered-off */
 
 cpu_t	*cpu_intr_next(cpu_t *cp);	/* get next online CPU taking intrs */
 int	cpu_intr_count(cpu_t *cp);	/* count # of CPUs handling intrs */
@@ -673,7 +674,7 @@ int	cpu_flagged_poweredoff(cpu_flag_t); /* flags show CPU is powered off */
  */
 void	cpu_set_state(cpu_t *);		/* record/timestamp current state */
 int	cpu_get_state(cpu_t *);		/* get current cpu state */
-const char *cpu_get_state_str(cpu_t *);	/* get current cpu state as string */
+const char *cpu_get_state_str(cpu_flag_t);
 
 
 void	cpu_set_curr_clock(uint64_t);	/* indicate the current CPU's freq */
diff --git a/usr/src/uts/common/sys/processor.h b/usr/src/uts/common/sys/processor.h
index ec4b7471e5..5c6919e8ac 100644
--- a/usr/src/uts/common/sys/processor.h
+++ b/usr/src/uts/common/sys/processor.h
@@ -31,6 +31,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 #ifndef _SYS_PROCESSOR_H
 #define	_SYS_PROCESSOR_H
 
@@ -68,8 +72,9 @@ typedef int	chipid_t;
 #define	P_POWEROFF	0x0005	/* processor is powered off */
 #define	P_NOINTR	0x0006	/* processor is online, but no I/O interrupts */
 #define	P_SPARE		0x0007	/* processor is offline, can be reactivated */
+#define	P_DISABLED	0x0008	/* processor is explicitly disabled for use */
 #define	P_BAD		P_FAULTED	/* unused but defined by USL */
-#define	P_FORCED 	0x10000000	/* force processor offline */
+#define	P_FORCED	0x10000000	/* force processor offline */
 
 /*
  * String names for processor states defined above.
@@ -80,6 +85,7 @@ typedef int	chipid_t;
 #define	PS_POWEROFF	"powered-off"
 #define	PS_NOINTR	"no-intr"
 #define	PS_SPARE	"spare"
+#define	PS_DISABLED	"disabled"
 
 /*
  * Structure filled in by processor_info(2). This structure
@@ -95,7 +101,7 @@ typedef int	chipid_t;
 #define	PI_FPUTYPE	32	/* max size of FPU types string */
 
 typedef struct {
-	int	pi_state;  			/* processor state, see above */
+	int	pi_state;			/* processor state, see above */
 	char	pi_processor_type[PI_TYPELEN];	/* ASCII CPU type */
 	char	pi_fputypes[PI_FPUTYPE];	/* ASCII FPU types */
 	int	pi_clock;			/* CPU clock freq in MHz */
@@ -110,6 +116,11 @@ typedef struct {
 #define	PBIND_SOFT	-4	/* allows offlining CPU */
 #define	PBIND_QUERY_TYPE	-5	/* Return binding type */
 
+/*
+ * Sentinel values for p_online(2)
+ */
+#define	P_ALL_SIBLINGS (-1)
+
 /*
  * User-level system call interface prototypes
  */
diff --git a/usr/src/uts/common/syscall/p_online.c b/usr/src/uts/common/syscall/p_online.c
index 88a0340bf7..51c6a63b48 100644
--- a/usr/src/uts/common/syscall/p_online.c
+++ b/usr/src/uts/common/syscall/p_online.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/var.h>
@@ -37,13 +41,15 @@
 #include <sys/processor.h>
 #include <sys/debug.h>
 #include <sys/policy.h>
+#include <sys/ht.h>
 
 /*
  * CPU state diagram
  *
- *                   P_SPARE
+ *                  P_SPARE
  * P_POWEROFF <---> P_OFFLINE <---> P_ONLINE <---> P_NOINTR
  *                  P_FAULTED
+ *                  P_DISABLED
  */
 int
 p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
@@ -53,10 +59,17 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 	int	error = 0;
 	int	flags = 0;
 
-	/*
-	 * Try to get a pointer to the requested CPU structure.
-	 */
 	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (cpun == P_ALL_SIBLINGS) {
+		if (new_status != P_DISABLED) {
+			error = EINVAL;
+			goto out;
+		}
+
+		return (ht_disable());
+	}
+
 	if ((cp = cpu_get(cpun)) == NULL) {
 		error = EINVAL;
 		goto out;
@@ -81,8 +94,10 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 		if (secpolicy_ponline(CRED()) != 0)
 			error = EPERM;
 		break;
+	case P_DISABLED:
 	default:
 		error = EINVAL;
+		break;
 	}
 
 	if (error)
@@ -105,6 +120,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
@@ -112,11 +128,13 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is in one of the offline states,
 			 * bring it online.
 			 */
-			error = cpu_online(cp);
+			error = cpu_online(cp, flags);
 			break;
 		case P_NOINTR:
 			cpu_intr_enable(cp);
 			break;
+			error = cpu_online(cp, flags);
+			break;
 		}
 		break;
 
@@ -130,6 +148,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			cpu_intr_enable(cp);
 			/* FALLTHROUGH */
 		case P_ONLINE:
+		case P_DISABLED:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
@@ -143,6 +162,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is powered off, power it on.
 			 */
 			error = cpu_poweron(cp);
+			break;
 		}
 		break;
 
@@ -156,13 +176,14 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
 			 * First, bring the CPU online.
 			 */
-			if (error = cpu_online(cp))
+			if (error = cpu_online(cp, flags))
 				break;
 			/* FALLTHROUGH */
 		case P_ONLINE:
@@ -170,6 +191,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * CPU is now online.  Try to disable interrupts.
 			 */
 			error = cpu_intr_disable(cp);
+			break;
 		}
 		break;
 
@@ -183,14 +205,16 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
-		case P_SPARE:
 		case P_ONLINE:
 		case P_NOINTR:
+		case P_SPARE:
 			/*
 			 * Mark this CPU as faulted.
 			 */
 			error = cpu_faulted(cp, flags);
+			break;
 		}
 		break;
 
@@ -204,6 +228,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_ONLINE:
@@ -212,6 +237,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * Mark this CPU as a spare.
 			 */
 			error = cpu_spare(cp, flags);
+			break;
 		}
 		break;
 	}
diff --git a/usr/src/uts/i86pc/io/dr/dr_cpu.c b/usr/src/uts/i86pc/io/dr/dr_cpu.c
index a893310977..388696f938 100644
--- a/usr/src/uts/i86pc/io/dr/dr_cpu.c
+++ b/usr/src/uts/i86pc/io/dr/dr_cpu.c
@@ -28,6 +28,10 @@
  * All rights reserved.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * CPU support routines for DR
  */
@@ -326,7 +330,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -829,7 +833,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (rv == 0 && cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/i86pc/os/ht.c b/usr/src/uts/i86pc/os/ht.c
index 6e13eaedae..fe87bf8c78 100644
--- a/usr/src/uts/i86pc/os/ht.c
+++ b/usr/src/uts/i86pc/os/ht.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -104,6 +104,13 @@
  * Used when scoring other CPUs in disp_lowpri_cpu().  If we shouldn't run here,
  * we'll add a small penalty to the score.  This also makes sure a VCPU thread
  * migration behaves properly.
+ *
+ *
+ * ht_init() / ht_late_init()
+ *
+ * Set up HT handling. If ht_boot_disable is set, ht_late_init(), which runs
+ * late enough to be able to do so, will offline and mark CPU_DISABLED all the
+ * siblings. ht_disable() can also be called after boot via psradm -Ha.
  */
 
 #include <sys/archsystm.h>
@@ -116,6 +123,10 @@
 #include <sys/cmn_err.h>
 #include <sys/sysmacros.h>
 #include <sys/x86_archext.h>
+#include <sys/esunddi.h>
+#include <sys/promif.h>
+#include <sys/policy.h>
+#include <sys/ht.h>
 
 #define	CS_SHIFT (8)
 #define	CS_MASK ((1 << CS_SHIFT) - 1)
@@ -153,65 +164,15 @@ int ht_exclusion = 1;
  */
 clock_t ht_acquire_wait_time = 64;
 
-static cpu_t *
-ht_find_sibling(cpu_t *cp)
-{
-	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
-		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
-		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
-
-		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
-			continue;
-
-		if (GROUP_SIZE(cg) == 1)
-			break;
-
-		VERIFY3U(GROUP_SIZE(cg), ==, 2);
-
-		if (GROUP_ACCESS(cg, 0) != cp)
-			return (GROUP_ACCESS(cg, 0));
-
-		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
-
-		return (GROUP_ACCESS(cg, 1));
-	}
-
-	return (NULL);
-}
-
 /*
- * Initialize HT links.  We have to be careful here not to race with
- * ht_begin/end_intr(), which also complicates trying to do this initialization
- * from a cross-call; hence the slightly odd approach below.
+ * Did we request a disable of HT at boot time?
  */
-void
-ht_init(void)
-{
-	cpu_t *scp = CPU;
-	cpu_t *cp = scp;
-	ulong_t flags;
-
-	if (!ht_exclusion)
-		return;
-
-	mutex_enter(&cpu_lock);
-
-	do {
-		thread_affinity_set(curthread, cp->cpu_id);
-		flags = intr_clear();
-
-		cp->cpu_m.mcpu_ht.ch_intr_depth = 0;
-		cp->cpu_m.mcpu_ht.ch_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		cp->cpu_m.mcpu_ht.ch_sibstate = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		ASSERT3P(cp->cpu_m.mcpu_ht.ch_sib, ==, NULL);
-		cp->cpu_m.mcpu_ht.ch_sib = ht_find_sibling(cp);
-
-		intr_restore(flags);
-		thread_affinity_clear(curthread);
-	} while ((cp = cp->cpu_next_onln) != scp);
+int ht_boot_disable;
 
-	mutex_exit(&cpu_lock);
-}
+/*
+ * Whether HT is enabled.
+ */
+int ht_enabled = 1;
 
 /*
  * We're adding an interrupt handler of some kind at the given PIL.  If this
@@ -611,3 +572,190 @@ ht_adjust_cpu_score(kthread_t *t, struct cpu *cp, pri_t score)
 
 	return (score + 1);
 }
+
+static void
+set_ht_prop(void)
+{
+	(void) e_ddi_prop_update_string(DDI_DEV_T_NONE, ddi_root_node(),
+	    "ht_enabled", ht_enabled ? "true" : "false");
+}
+
+static cpu_t *
+ht_find_sibling(cpu_t *cp)
+{
+	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
+		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
+		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
+
+		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
+			continue;
+
+		if (GROUP_SIZE(cg) == 1)
+			break;
+
+		if (GROUP_SIZE(cg) != 2) {
+			panic("%u SMT threads unsupported", GROUP_SIZE(cg));
+		}
+
+		if (GROUP_ACCESS(cg, 0) != cp)
+			return (GROUP_ACCESS(cg, 0));
+
+		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
+
+		return (GROUP_ACCESS(cg, 1));
+	}
+
+	return (NULL);
+}
+
+/*
+ * Offline all siblings and mark as CPU_DISABLED. Note that any siblings that
+ * can't be offlined (if it would leave an empty partition, or it's a spare, or
+ * whatever) will fail the whole operation.
+ */
+int
+ht_disable(void)
+{
+	int error = 0;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (secpolicy_ponline(CRED()) != 0)
+		return (EPERM);
+
+	if (!ht_enabled)
+		return (0);
+
+	for (size_t i = 0; i < NCPU; i++) {
+		cpu_t *sib;
+		cpu_t *cp;
+
+		if ((cp = cpu_get(i)) == NULL)
+			continue;
+
+		/* NB: we don't necessarily have .mcpu_ht to use here. */
+		if ((sib = ht_find_sibling(cp)) == NULL)
+			continue;
+
+		if (cp->cpu_id < sib->cpu_id)
+			continue;
+
+		if (cp->cpu_flags & CPU_DISABLED) {
+			VERIFY(cp->cpu_flags & CPU_OFFLINE);
+			continue;
+		}
+
+		if (cp->cpu_flags & (CPU_FAULTED | CPU_SPARE)) {
+			error = EINVAL;
+			break;
+		}
+
+		if ((cp->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY) {
+			cp->cpu_flags |= CPU_DISABLED;
+			continue;
+		}
+
+		if ((error = cpu_offline(cp, CPU_FORCED)) != 0)
+			break;
+
+		cp->cpu_flags |= CPU_DISABLED;
+		cpu_set_state(cp);
+	}
+
+	if (error != 0)
+		return (error);
+
+	ht_enabled = 0;
+	set_ht_prop();
+	cmn_err(CE_NOTE, "!HT (hyper-threading) explicitly disabled.");
+	return (0);
+}
+
+boolean_t
+ht_can_enable(cpu_t *cp, int flags)
+{
+	VERIFY(cp->cpu_flags & CPU_DISABLED);
+
+	return (!ht_boot_disable && (flags & CPU_FORCED));
+}
+
+/*
+ * If we force-onlined a CPU_DISABLED CPU, then we can no longer consider the
+ * system to be HT-disabled in toto.
+ */
+void
+ht_force_enabled(void)
+{
+	VERIFY(!ht_boot_disable);
+
+	if (!ht_enabled)
+		cmn_err(CE_NOTE, "!Disabled HT sibling forced on-line.");
+
+	ht_enabled = 1;
+	set_ht_prop();
+}
+
+/*
+ * Initialize HT links.  We have to be careful here not to race with
+ * ht_begin/end_intr(), which also complicates trying to do this initialization
+ * from a cross-call; hence the slightly odd approach below.
+ *
+ * If we're going to disable HT via ht_late_init(), we will avoid paying the
+ * price here at all (we can't do it here since we're still too early in
+ * main()).
+ */
+void
+ht_init(void)
+{
+	cpu_t *scp = CPU;
+	cpu_t *cp = scp;
+	ulong_t flags;
+
+	if (!ht_exclusion || ht_boot_disable)
+		return;
+
+	mutex_enter(&cpu_lock);
+
+	do {
+		thread_affinity_set(curthread, cp->cpu_id);
+		flags = intr_clear();
+
+		cp->cpu_m.mcpu_ht.ch_intr_depth = 0;
+		cp->cpu_m.mcpu_ht.ch_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
+		cp->cpu_m.mcpu_ht.ch_sibstate = CS_MK(CM_THREAD, GLOBAL_ZONEID);
+		ASSERT3P(cp->cpu_m.mcpu_ht.ch_sib, ==, NULL);
+		cp->cpu_m.mcpu_ht.ch_sib = ht_find_sibling(cp);
+
+		intr_restore(flags);
+		thread_affinity_clear(curthread);
+	} while ((cp = cp->cpu_next_onln) != scp);
+
+	mutex_exit(&cpu_lock);
+}
+
+void
+ht_late_init(void)
+{
+	int err;
+
+	if (!ht_boot_disable) {
+		set_ht_prop();
+		cmn_err(CE_NOTE, "!HT enabled\n");
+		return;
+	}
+
+	mutex_enter(&cpu_lock);
+
+	err = ht_disable();
+
+	/*
+	 * We're early enough in boot that nothing should have stopped us from
+	 * offlining the siblings, and we didn't set up the infrastructure for
+	 * L1TF.
+	 */
+	if (err) {
+		cmn_err(CE_PANIC, "ht_disable() failed with %d", err);
+	}
+
+	mutex_exit(&cpu_lock);
+}
diff --git a/usr/src/uts/i86pc/os/mlsetup.c b/usr/src/uts/i86pc/os/mlsetup.c
index 1f9149d5c4..e75b978ce9 100644
--- a/usr/src/uts/i86pc/os/mlsetup.c
+++ b/usr/src/uts/i86pc/os/mlsetup.c
@@ -65,6 +65,7 @@
 #include <sys/apic_common.h>
 #include <sys/bootvfs.h>
 #include <sys/tsc.h>
+#include <sys/ht.h>
 #ifdef __xpv
 #include <sys/hypervisor.h>
 #else
@@ -185,6 +186,17 @@ mlsetup(struct regs *rp)
 	} else if (kpti_enable != 1) {
 		x86_use_pcid = 0;
 	}
+
+	/*
+	 * While we don't need to check this until later, we might as well do it
+	 * here.
+	 */
+	if (bootprop_getstr("ht_enabled", prop_str, sizeof (prop_str)) == 0) {
+		if (strcasecmp(prop_str, "false") == 0 ||
+		    strcmp(prop_str, "0") == 0)
+			ht_boot_disable = 1;
+	}
+
 #endif
 
 	/*
diff --git a/usr/src/uts/i86pc/os/mp_startup.c b/usr/src/uts/i86pc/os/mp_startup.c
index da629d02c2..4761b80384 100644
--- a/usr/src/uts/i86pc/os/mp_startup.c
+++ b/usr/src/uts/i86pc/os/mp_startup.c
@@ -27,7 +27,7 @@
  * All rights reserved.
  */
 /*
- * Copyright 2019 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2018 OmniOS Community Edition (OmniOSce) Association.
  */
@@ -1996,6 +1996,10 @@ mp_cpu_stop(struct cpu *cp)
 
 /*
  * Take the specified CPU out of participation in interrupts.
+ *
+ * Usually, we hold cpu_lock. But we cannot assert as such due to the
+ * exception - i_cpr_save_context() - where we have mutual exclusion via a
+ * separate mechanism.
  */
 int
 cpu_disable_intr(struct cpu *cp)
@@ -2004,6 +2008,7 @@ cpu_disable_intr(struct cpu *cp)
 		return (EBUSY);
 
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 	return (0);
 }
 
@@ -2015,6 +2020,7 @@ cpu_enable_intr(struct cpu *cp)
 {
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 	psm_enable_intr(cp->cpu_id);
 }
 
diff --git a/usr/src/uts/i86pc/sys/ht.h b/usr/src/uts/i86pc/sys/ht.h
index 8bb5a0d6d2..88c9aa883d 100644
--- a/usr/src/uts/i86pc/sys/ht.h
+++ b/usr/src/uts/i86pc/sys/ht.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef	_SYS_HT_H
@@ -25,7 +25,14 @@ extern "C" {
 
 struct cpu;
 
+extern int ht_boot_disable;
+
 extern void ht_init(void);
+extern void ht_late_init(void);
+extern int ht_disable(void);
+extern boolean_t ht_can_enable(struct cpu *, int);
+extern void ht_force_enabled(void);
+
 extern void ht_intr_alloc_pil(uint_t);
 
 extern int ht_acquire(void);
diff --git a/usr/src/uts/i86xpv/os/mp_xen.c b/usr/src/uts/i86xpv/os/mp_xen.c
index 02eda1c755..f2c528faa4 100644
--- a/usr/src/uts/i86xpv/os/mp_xen.c
+++ b/usr/src/uts/i86xpv/os/mp_xen.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * Virtual CPU management.
  *
@@ -681,6 +685,9 @@ poweroff_vcpu(struct cpu *cp)
 
 		CPUSET_DEL(cpu_ready_set, cp->cpu_id);
 
+		if (cp->cpu_flags & CPU_ENABLE)
+			ncpus_intr_enabled--;
+
 		cp->cpu_flags |= CPU_POWEROFF | CPU_OFFLINE;
 		cp->cpu_flags &=
 		    ~(CPU_RUNNING | CPU_READY | CPU_EXISTS | CPU_ENABLE);
diff --git a/usr/src/uts/intel/os/arch_kdi.c b/usr/src/uts/intel/os/arch_kdi.c
index 9677013ea5..a321af657d 100644
--- a/usr/src/uts/intel/os/arch_kdi.c
+++ b/usr/src/uts/intel/os/arch_kdi.c
@@ -22,7 +22,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  *
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/uts/sun4/os/intr.c b/usr/src/uts/sun4/os/intr.c
index 3a7143115d..86a89a91eb 100644
--- a/usr/src/uts/sun4/os/intr.c
+++ b/usr/src/uts/sun4/os/intr.c
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 /*
  * Copyright 2019 Peter Tribble.
@@ -326,7 +326,7 @@ siron_cpu_setup(cpu_setup_t what, int id, void *arg)
 
 /*
  * no_ivintr()
- * 	called by setvecint_tl1() through sys_trap()
+ *	called by setvecint_tl1() through sys_trap()
  *	vector interrupt received but not valid or not
  *	registered in intr_vec_table
  *	considered as a spurious mondo interrupt
@@ -420,6 +420,7 @@ cpu_disable_intr(struct cpu *cp)
 	 * function, since it checks for this in the cpu flags.
 	 */
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 
 	intr_redist_all_cpus();
 
@@ -438,6 +439,7 @@ cpu_enable_intr(struct cpu *cp)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 
 	intr_redist_all_cpus();
 }
diff --git a/usr/src/uts/sun4/os/mp_startup.c b/usr/src/uts/sun4/os/mp_startup.c
index ae68a23f8b..0235d04d61 100644
--- a/usr/src/uts/sun4/os/mp_startup.c
+++ b/usr/src/uts/sun4/os/mp_startup.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 #include <sys/sysmacros.h>
 #include <sys/prom_plat.h>
 #include <sys/prom_debug.h>
@@ -162,6 +166,10 @@ cold_flag_set(int cpuid)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp = cpu[cpuid];
+
+	if (!(cpu->cpu_flags & CPU_ENABLE))
+		ncpus_intr_enabled++;
+
 	cp->cpu_flags |= CPU_RUNNING | CPU_ENABLE | CPU_EXISTS;
 	cpu_add_active(cp);
 	/*
diff --git a/usr/src/uts/sun4/sys/ht.h b/usr/src/uts/sun4/sys/ht.h
index 6d7b3e37cc..098000b3f1 100644
--- a/usr/src/uts/sun4/sys/ht.h
+++ b/usr/src/uts/sun4/sys/ht.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef	_SYS_HT_H
@@ -24,6 +24,10 @@ extern "C" {
 #endif
 
 #define	ht_init() {}
+#define	ht_late_init() {}
+#define	ht_disable() (ENOTSUP)
+#define	ht_can_enable(c, f) (0)
+#define	ht_force_enabled() {}
 
 #define	ht_should_run(t, c) (B_TRUE)
 #define	ht_adjust_cpu_score(t, c, p) (p)
diff --git a/usr/src/uts/sun4u/io/sbd_cpu.c b/usr/src/uts/sun4u/io/sbd_cpu.c
index 5db48f7572..f4419f9065 100644
--- a/usr/src/uts/sun4u/io/sbd_cpu.c
+++ b/usr/src/uts/sun4u/io/sbd_cpu.c
@@ -25,6 +25,7 @@
  */
 /*
  * Copyright 2019 Peter Tribble.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -593,7 +594,7 @@ sbd_post_attach_cpu(sbd_handle_t *hp, sbd_devlist_t *devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, cpuid);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				SBD_SET_ERR(ep, ESBD_ONLINE);
 				SBD_SET_ERRSTR(ep, sbp->sb_cpupath[i]);
 				cmn_err(CE_WARN,
@@ -886,7 +887,7 @@ sbd_cancel_cpu(sbd_handle_t *hp, int unit)
 		if (cpu_flagged_offline(cp->sbc_cpu_flags)) {
 			PR_CPU("%s: leaving cpu %d OFFLINE\n",
 			    f, cp->sbc_cpu_id);
-		} else if (cpu_online(cpup)) {
+		} else if (cpu_online(cpup, 0)) {
 			cmn_err(CE_WARN,
 			    "sbd:%s: failed to online cpu %d",
 			    f, cp->sbc_cpu_id);
diff --git a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
index 87b5cc7fef..342246c963 100644
--- a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
+++ b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
@@ -26,6 +26,7 @@
 
 /*
  * Copyright 2019 Peter Tribble.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -385,7 +386,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -882,7 +883,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/sun4u/starcat/io/drmach.c b/usr/src/uts/sun4u/starcat/io/drmach.c
index addcd5ce4d..cf896cdd38 100644
--- a/usr/src/uts/sun4u/starcat/io/drmach.c
+++ b/usr/src/uts/sun4u/starcat/io/drmach.c
@@ -23,6 +23,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright (c) 2016 by Delphix. All rights reserved.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <sys/note.h>
@@ -7487,7 +7488,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 
 	if (cpu_poweroff(cp)) {
 		DRMACH_PR("%s: cpu_poweroff failed for CPU id %d", fn, cpuid);
-		if (cpu_online(cp)) {
+		if (cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to online CPU id %d "
 			    "during I/O cage test selection", cpuid);
 		}
@@ -7509,7 +7510,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 			dp->busy = 1;
 			return (-1);
 		}
-		if (cpu_poweron(cp) || cpu_online(cp)) {
+		if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to %s CPU id %d "
 			    "during I/O cage test selection",
 			    cpu_is_poweredoff(cp) ?
@@ -7620,7 +7621,7 @@ drmach_iocage_cpu_return(drmach_device_t *dp, cpu_flag_t oflags)
 		return (-1);
 	}
 
-	if (cpu_poweron(cp) || cpu_online(cp)) {
+	if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 		cmn_err(CE_WARN, "failed to %s CPU id %d after I/O "
 		    "cage test", cpu_is_poweredoff(cp) ?
 		    "poweron" : "online", cpuid);
diff --git a/usr/src/uts/sun4v/io/dr_cpu.c b/usr/src/uts/sun4v/io/dr_cpu.c
index b8bf26f2fd..75c8148bcd 100644
--- a/usr/src/uts/sun4v/io/dr_cpu.c
+++ b/usr/src/uts/sun4v/io/dr_cpu.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
 /*
  * sun4v CPU DR Module
  */
@@ -1113,7 +1117,7 @@ dr_cpu_configure(processorid_t cpuid, int *status, boolean_t force)
 	 */
 	if (cpu_is_offline(cp)) {
 
-		if ((rv = cpu_online(cp)) != 0) {
+		if ((rv = cpu_online(cp, 0)) != 0) {
 			DR_DBG_CPU("failed to online CPU %d (%d)\n",
 			    cpuid, rv);
 			rv = DR_CPU_RES_FAILURE;
@@ -1535,7 +1539,7 @@ typedef struct {
 static int
 dr_cpu_check_node(dev_info_t *dip, void *arg)
 {
-	char 		*name;
+	char		*name;
 	processorid_t	cpuid;
 	dr_search_arg_t	*sarg = (dr_search_arg_t *)arg;
 
