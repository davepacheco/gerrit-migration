From 07a15cbc655616a360cb6b1fafd87f9c20b11f9b Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Tue, 7 May 2019 18:10:56 +0000
Subject: [PATCH] OS-7662 need a way to disable HT

---
 usr/src/cmd/auditrecord/audit_record_attr.txt |  29 +-
 usr/src/cmd/cpc/common/cpustat.c              |   3 +-
 .../fm/modules/common/cpumem-retire/cma_cpu.c |   4 +
 .../cmd/mdb/common/modules/dtrace/dtrace.c    |   4 +-
 .../cmd/mdb/common/modules/genunix/genunix.c  |   4 +-
 .../picl/plugins/common/devtree/picldevtree.c |  10 +-
 usr/src/cmd/psradm/psradm.c                   |  43 +-
 usr/src/cmd/psrinfo/Makefile                  |  14 +-
 usr/src/cmd/psrinfo/psrinfo.c                 | 179 +++++-
 usr/src/man/man1m/psradm.1m                   |  39 +-
 usr/src/man/man1m/psrinfo.1m                  | 111 ++--
 usr/src/man/man2/p_online.2                   |  24 +-
 usr/src/pkg/manifests/system-header.mf        |   8 +-
 usr/src/uts/common/cpr/cpr_main.c             |   6 +-
 usr/src/uts/common/cpr/cpr_misc.c             |   5 +-
 usr/src/uts/common/disp/disp.c                |  16 +-
 usr/src/uts/common/disp/thread.c              |   6 +-
 usr/src/uts/common/dtrace/dtrace.c            |  12 +-
 usr/src/uts/common/fs/zfs/zvol.c              |  28 +-
 usr/src/uts/common/io/vnd/vnd.c               |   8 +-
 usr/src/uts/common/os/cpu.c                   |  82 +--
 usr/src/uts/common/os/lgrp.c                  |   6 +-
 usr/src/uts/common/os/main.c                  |   5 +-
 usr/src/uts/common/os/pool_pset.c             |   8 +-
 usr/src/uts/common/sys/cpuvar.h               |  25 +-
 usr/src/uts/common/sys/processor.h            |  15 +-
 usr/src/uts/common/sys/thread.h               |   4 +-
 usr/src/uts/common/syscall/p_online.c         |  38 +-
 usr/src/uts/i86pc/Makefile.files              |   2 +-
 usr/src/uts/i86pc/io/apix/apix_intr.c         |  16 +-
 usr/src/uts/i86pc/io/apix/apix_utils.c        |   6 +-
 usr/src/uts/i86pc/io/dr/dr_cpu.c              |   8 +-
 usr/src/uts/i86pc/io/pcplusmp/apic.c          |   6 +-
 usr/src/uts/i86pc/io/viona/viona.c            |   6 +-
 usr/src/uts/i86pc/io/vmm/intel/vmx.c          |  10 +-
 usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c        |   4 +-
 usr/src/uts/i86pc/os/cpuid.c                  |   8 +-
 usr/src/uts/i86pc/os/intr.c                   |  16 +-
 usr/src/uts/i86pc/os/mlsetup.c                |  14 +-
 usr/src/uts/i86pc/os/mp_startup.c             |   6 +
 usr/src/uts/i86pc/os/{ht.c => smt.c}          | 515 ++++++++++++------
 usr/src/uts/i86pc/sys/Makefile                |   6 +-
 usr/src/uts/i86pc/sys/ht.h                    |  47 --
 usr/src/uts/i86pc/sys/machcpuvar.h            |  20 +-
 usr/src/uts/i86pc/sys/smt.h                   |  54 ++
 usr/src/uts/i86xpv/Makefile.files             |   4 +-
 usr/src/uts/i86xpv/os/mp_xen.c                |   7 +
 usr/src/uts/intel/ia32/ml/swtch.s             |   6 +-
 usr/src/uts/sun4/os/intr.c                    |   6 +-
 usr/src/uts/sun4/os/mp_startup.c              |   8 +
 usr/src/uts/sun4/sys/{ht.h => smt.h}          |  24 +-
 usr/src/uts/sun4u/io/sbd_cpu.c                |   5 +-
 usr/src/uts/sun4u/ngdr/io/dr_cpu.c            |   5 +-
 usr/src/uts/sun4u/starcat/io/drmach.c         |   7 +-
 usr/src/uts/sun4v/io/dr_cpu.c                 |   8 +-
 usr/src/uts/sun4v/sys/Makefile                |   4 +-
 56 files changed, 1059 insertions(+), 505 deletions(-)
 rename usr/src/uts/i86pc/os/{ht.c => smt.c} (55%)
 delete mode 100644 usr/src/uts/i86pc/sys/ht.h
 create mode 100644 usr/src/uts/i86pc/sys/smt.h
 rename usr/src/uts/sun4/sys/{ht.h => smt.h} (56%)

diff --git a/usr/src/cmd/auditrecord/audit_record_attr.txt b/usr/src/cmd/auditrecord/audit_record_attr.txt
index 011f2aa153..198d7fec0b 100644
--- a/usr/src/cmd/auditrecord/audit_record_attr.txt
+++ b/usr/src/cmd/auditrecord/audit_record_attr.txt
@@ -3,6 +3,7 @@
 # other comments are removed.
 ##
 ## Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+## Copyright 2019 Joyent, Inc.
 ##
 ## CDDL HEADER START
 ##
@@ -72,9 +73,9 @@ token=exit:exit
 
 # note names -- certain notes show up repeatedly; collected here
 #
-# To achieve the maximum line length to be less than 80 characters, the 
+# To achieve the maximum line length to be less than 80 characters, the
 # note names (message=) can be defined as a multi line, each line except the
-# last one finished with the backslash character. 
+# last one finished with the backslash character.
 
 message=ipc_perm:The ipc and ipc_perm tokens are not included if \
   the message ID is not valid.
@@ -108,15 +109,15 @@ user=head:subj:insert:ret
 #
 # comment is an array of strings separated by colons.  If comments
 # are listed on separate lines (recommended due to better
-# readability/sustainability of the file), the preceding comment 
-# must end with  a colon.  The array starts at 1. (If the comment 
+# readability/sustainability of the file), the preceding comment
+# must end with  a colon.  The array starts at 1. (If the comment
 # contains a colon, use "&colon;" without the quotes.)
 #
 # case is used to generate alternate descriptions for a given
 # record.
 #
 # Constraints - the string length; bear in mind, that any annotation of
-# primitives below longer than is specified, will be silently truncated 
+# primitives below longer than is specified, will be silently truncated
 # to given/defined amount of characters in the auditrecord(1M) runtime:
 #
 #     primitive <= max (non-truncated) string length
@@ -825,7 +826,7 @@ label=AUE_FCHOWN
 label=AUE_FCHOWNAT
 # obsolete
   see=openat(2)
-  case=With a valid absolute/relative file path 
+  case=With a valid absolute/relative file path
     format=path:[attr]
   case=With an file path eq. NULL and valid file descriptor
     format=kernel
@@ -852,14 +853,14 @@ label=AUE_FLOCK
 label=AUE_FORKALL
   format=[arg]1
     comment=0, pid, "child PID"
-  note=The forkall(2) return values are undefined because the audit record 
+  note=The forkall(2) return values are undefined because the audit record
   note=is produced at the point that the child process is spawned.
 # see audit.c
 
 label=AUE_FORK1
   format=[arg]1
     comment=0, pid, "child PID"
-  note=The fork1(2) return values are undefined because the audit record 
+  note=The fork1(2) return values are undefined because the audit record
   note=is produced at the point that the child process is spawned.
 # see audit.c
 
@@ -1254,7 +1255,7 @@ label=AUE_OPENAT_RW
 # obsolete
   see=openat(2)
   format=path:[path_attr]:[attr]
-# aui_fsat(): fm & O_RDWR 
+# aui_fsat(): fm & O_RDWR
 
 label=AUE_OPEN_RWC
   format=path:[path_attr]:[attr]
@@ -1385,7 +1386,7 @@ label=AUE_PUTPMSG
   see=putpmsg(2)
   format=arg1:[path]:[attr]:arg2:arg3
     comment=1, file descriptor, "fd":
-    comment=4, priority, "pri":   
+    comment=4, priority, "pri":
     comment=5, flags, "flags"
 
 label=AUE_P_ONLINE
@@ -1393,7 +1394,7 @@ label=AUE_P_ONLINE
     comment=1, processor ID, "processor ID":
     comment=2, flags value, "flags":
     comment=text form of flags.  Values&colon;  \
-      P_ONLINE, P_OFFLINE, P_NOINTR, P_SPARE, P_FAULTED, P_STATUS
+      P_ONLINE, P_OFFLINE, P_NOINTR, P_SPARE, P_FAULTED, P_STATUS, P_DISABLED
 
 label=AUE_QUOTACTL
   skip=Not used.
@@ -1441,7 +1442,7 @@ label=AUE_RECVFROM
     comment=4, flags, "flags":
     comment=from address:
     comment=6, address length, "tolen"
-  note=The socket token for a bad socket is reported as "argument 
+  note=The socket token for a bad socket is reported as "argument
   note=token (1, socket descriptor, "fd")"
 
 label=AUE_RECVMSG
@@ -1976,7 +1977,7 @@ label=AUE_SWAPON
 
 label=AUE_SYMLINK
   format=path:text1:[attr]
-    comment=symbolic link string 
+    comment=symbolic link string
 
 label=AUE_SYSINFO
   note=Only SI_SET_HOSTNAME and SI_SET_SRPC_DOMAIN commands
@@ -2031,7 +2032,7 @@ label=AUE_UTIMES
 label=AUE_VFORK
   format=arg1
     comment=0, pid, "child PID"
-  note=The vfork(2) return values are undefined because the audit record is 
+  note=The vfork(2) return values are undefined because the audit record is
   note=produced at the point that the child process is spawned.
 
 label=AUE_VPIXSYS
diff --git a/usr/src/cmd/cpc/common/cpustat.c b/usr/src/cmd/cpc/common/cpustat.c
index 79daedc50b..47088de802 100644
--- a/usr/src/cmd/cpc/common/cpustat.c
+++ b/usr/src/cmd/cpc/common/cpustat.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -689,6 +689,7 @@ cpustat(void)
 		case P_POWEROFF:
 		case P_FAULTED:
 		case P_SPARE:
+		case P_DISABLED:
 			gstate[i++].cpuid = -1;
 			break;
 		default:
diff --git a/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c b/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
index 3bcee999e8..33a1115b3f 100644
--- a/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
+++ b/usr/src/cmd/fm/modules/common/cpumem-retire/cma_cpu.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <cma.h>
@@ -302,6 +304,8 @@ p_online_state_fmt(int state)
 		return (PS_NOINTR);
 	case P_SPARE:
 		return (PS_SPARE);
+	case P_DISABLED:
+		return (PS_DISABLED);
 	default:
 		return ("unknown");
 	}
diff --git a/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c b/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
index 86a9b9049d..8acc470844 100644
--- a/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
+++ b/usr/src/cmd/mdb/common/modules/dtrace/dtrace.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2013 by Delphix. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -824,6 +824,8 @@ dtracemdb_stat(void *varg, processorid_t cpu)
 		return (P_SPARE);
 	} else if (c.cpu_flags & CPU_FAULTED) {
 		return (P_FAULTED);
+	} else if (c.cpu_flags & CPU_DISABLED) {
+		return (P_DISABLED);
 	} else if ((c.cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY) {
 		return (P_OFFLINE);
 	} else if (c.cpu_flags & CPU_ENABLE) {
diff --git a/usr/src/cmd/mdb/common/modules/genunix/genunix.c b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
index fadd3c110c..95b564ed3a 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/genunix.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2013 by Delphix. All rights reserved.
  */
 
@@ -3070,7 +3070,7 @@ cpuinfo_walk_cpu(uintptr_t addr, const cpu_t *cpu, cpuinfo_data_t *cid)
 	const char *flags[] = {
 	    "RUNNING", "READY", "QUIESCED", "EXISTS",
 	    "ENABLE", "OFFLINE", "POWEROFF", "FROZEN",
-	    "SPARE", "FAULTED", NULL
+	    "SPARE", "FAULTED", "DISABLED", NULL
 	};
 
 	if (cid->cid_cpu != -1) {
diff --git a/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c b/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
index ab02d9091b..2f648d5336 100644
--- a/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
+++ b/usr/src/cmd/picl/plugins/common/devtree/picldevtree.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -1914,6 +1914,9 @@ get_pi_state(ptree_rarg_t *rarg, void *vbuf)
 	case P_POWEROFF:
 		(void) strlcpy(vbuf, PS_POWEROFF, MAX_STATE_SIZE);
 		break;
+	case P_DISABLED:
+		(void) strlcpy(vbuf, PS_DISABLED, MAX_STATE_SIZE);
+		break;
 	default:
 		(void) strlcpy(vbuf, "unknown", MAX_STATE_SIZE);
 		break;
@@ -2367,7 +2370,8 @@ process_devtree_conf_file(void)
 static	asr_conf_entries_t	*conf_name_asr_map = NULL;
 
 static void
-free_asr_conf_entries(asr_conf_entries_t *list) {
+free_asr_conf_entries(asr_conf_entries_t *list)
+{
 	asr_conf_entries_t  *el;
 	asr_conf_entries_t  *del;
 
@@ -2606,7 +2610,7 @@ add_status_prop(picl_nodehdl_t chdh, char *status)
 
 static void
 create_asr_node(char *parent, char *child, char *unitaddr, char *class,
-	char *status, char *props)
+    char *status, char *props)
 {
 	char			ptreepath[PATH_MAX];
 	char			nodename[PICL_PROPNAMELEN_MAX];
diff --git a/usr/src/cmd/psradm/psradm.c b/usr/src/cmd/psradm/psradm.c
index eab03a6ec4..af272e6667 100644
--- a/usr/src/cmd/psradm/psradm.c
+++ b/usr/src/cmd/psradm/psradm.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
 
 #include <sys/types.h>
 #include <sys/procset.h>
@@ -38,6 +40,7 @@
 #include <time.h>
 #include <utmpx.h>
 #include <assert.h>
+#include <stdbool.h>
 
 static char	*cmdname;	/* command name for messages */
 
@@ -53,9 +56,11 @@ static char	*basename(char *);
 static void
 usage(void)
 {
-	(void) fprintf(stderr,
-	    "usage: \n\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
-	    "\t%s -a -f|-n|-i [-v]\n", cmdname, cmdname);
+	(void) fprintf(stderr, "usage:\n"
+	    "\t%s [-F] -f|-n|-i|-s [-v] processor_id ...\n"
+	    "\t%s -a -f|-n|-i [-v]\n"
+	    "\t%s -aS [-v]\n",
+	    cmdname, cmdname, cmdname);
 }
 
 /*
@@ -84,6 +89,7 @@ static psr_action_t psr_action[] = {
 	{ P_NOINTR,	"no-intr",	"set to",	"ni"	},
 	{ P_SPARE,	"spare",	"marked",	"spr"	},
 	{ P_FAULTED,	"faulted",	"marked",	"flt"	},
+	{ P_DISABLED,	"disabled",	"set as",	"dis"	},
 };
 
 static int	psr_actions = sizeof (psr_action) / sizeof (psr_action_t);
@@ -218,10 +224,11 @@ main(int argc, char *argv[])
 	char	*errptr;
 	int	errors;
 	psr_action_t	*pac;
+	bool disable_smt = 0;
 
 	cmdname = basename(argv[0]);
 
-	while ((c = getopt(argc, argv, "afFinsv")) != EOF) {
+	while ((c = getopt(argc, argv, "afFinsSv")) != EOF) {
 		switch (c) {
 
 		case 'a':		/* applies to all possible CPUs */
@@ -232,6 +239,10 @@ main(int argc, char *argv[])
 			force = 1;
 			break;
 
+		case 'S':
+			disable_smt = 1;
+			break;
+
 		case 'f':
 		case 'i':
 		case 'n':
@@ -256,6 +267,28 @@ main(int argc, char *argv[])
 		}
 	}
 
+	if (disable_smt) {
+		if (!all_flag) {
+			fprintf(stderr, "%s: -S must be used with -a.\n",
+			    cmdname);
+			usage();
+			return (2);
+		}
+
+		if (force || action != 0 || argc != optind) {
+			usage();
+			return (2);
+		}
+
+		if (p_online(P_ALL_SIBLINGS, P_DISABLED) == -1) {
+			fprintf(stderr, "Failed to disable hyper-threading: "
+			    "%s\n", strerror(errno));
+			return (EXIT_FAILURE);
+		}
+
+		return (EXIT_SUCCESS);
+	}
+
 	switch (action) {
 	case 'f':
 		action = P_OFFLINE;
diff --git a/usr/src/cmd/psrinfo/Makefile b/usr/src/cmd/psrinfo/Makefile
index 7786294a6f..b8e4404d9c 100644
--- a/usr/src/cmd/psrinfo/Makefile
+++ b/usr/src/cmd/psrinfo/Makefile
@@ -23,18 +23,18 @@
 #
 # Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
 #
-# cmd/psrinfo/Makefile
+# Copyright 2019 Joyent, Inc.
 #
 
-PROG=	psrinfo
+PROG = psrinfo
 
 include	../Makefile.cmd
 
-LDLIBS += -lkstat
-CERRWARN += -_gcc=-Wno-uninitialized
-XGETFLAGS +=  
-$(PROG).po	:= CPPFLAGS += -DXGETTEXT
+LDLIBS += -lkstat -ldevinfo
 
+$(PROG).po := CPPFLAGS += -DXGETTEXT
+
+CSTD=	$(CSTD_GNU99)
 
 .KEEP_STATE:
 
@@ -49,6 +49,4 @@ clean:
 $(ROOTUSRSBINBINPROG): $(PROG)
 	$(INS.file)
 
-lint:	lint_PROG
-
 include ../Makefile.targ
diff --git a/usr/src/cmd/psrinfo/psrinfo.c b/usr/src/cmd/psrinfo/psrinfo.c
index 6a3be82296..6ee6291f30 100644
--- a/usr/src/cmd/psrinfo/psrinfo.c
+++ b/usr/src/cmd/psrinfo/psrinfo.c
@@ -12,6 +12,7 @@
 /*
  * Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -23,6 +24,9 @@
  * All the relevant kstats are in the cpu_info kstat module.
  */
 
+#include <sys/sysmacros.h>
+
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -33,17 +37,21 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <errno.h>
+#include <err.h>
+
+#include <libdevinfo.h>
 
 #define	_(x)	gettext(x)
 #if XGETTEXT
-/* These CPU states are here for benefit of xgettext */
-_("on-line")
-_("off-line")
-_("faulted")
-_("powered-off")
-_("no-intr")
-_("spare")
-_("unknown")
+	/* These CPU states are here for benefit of xgettext */
+	_("on-line")
+	_("off-line")
+	_("faulted")
+	_("powered-off")
+	_("no-intr")
+	_("spare")
+	_("unknown")
+	_("disabled")
 #endif
 
 /*
@@ -106,6 +114,10 @@ static struct link *pchips = NULL;
 static struct link *cores = NULL;
 static struct link *vcpus = NULL;
 
+static uint_t nr_cpus;
+static uint_t nr_cores;
+static uint_t nr_chips;
+
 static const char *cmdname;
 
 static void
@@ -113,9 +125,12 @@ usage(char *msg)
 {
 	if (msg != NULL)
 		(void) fprintf(stderr, "%s: %s\n", cmdname, msg);
-	(void) fprintf(stderr, _("usage: \n" \
-	    "\t%s [-v] [-p] [processor_id ...]\n" \
-	    "\t%s -s [-p] processor_id\n"), cmdname, cmdname);
+	(void) fprintf(stderr, _("usage: \n"
+	    "\t%s -r propname\n"
+	    "\t%s [-v] [-p] [processor_id ...]\n"
+	    "\t%s -s [-p] processor_id\n"
+	    "\t%s -t [-S <state> | -c | -p]\n"),
+	    cmdname, cmdname, cmdname, cmdname);
 	exit(2);
 }
 
@@ -299,7 +314,7 @@ static void
 print_ps(void)
 {
 	int online = 1;
-	struct pchip *p;
+	struct pchip *p = NULL;
 	struct vcpu *v;
 	struct link *l;
 
@@ -432,6 +447,92 @@ print_normal(int nspec)
 	}
 }
 
+static bool
+valid_propname(const char *propname)
+{
+	size_t i;
+
+	const char *props[] = {
+		"smt_enabled",
+	};
+
+	for (i = 0; i < ARRAY_SIZE(props); i++) {
+		if (strcmp(propname, props[i]) == 0)
+			break;
+	}
+
+	return (i != ARRAY_SIZE(props));
+}
+
+static void
+read_property(const char *propname)
+{
+	di_prop_t prop = DI_PROP_NIL;
+	di_node_t root_node;
+	bool show_all = strcmp(propname, "all") == 0;
+
+	if (!show_all && !valid_propname(propname))
+		errx(EXIT_FAILURE, _("unknown CPU property %s"), propname);
+
+	if ((root_node = di_init("/", DINFOPROP)) == NULL)
+		err(EXIT_FAILURE, _("failed to read root node"));
+
+	while ((prop = di_prop_sys_next(root_node, prop)) != DI_PROP_NIL) {
+		const char *name = di_prop_name(prop);
+		char *val;
+		int nr_vals;
+
+		if (!valid_propname(name))
+			continue;
+
+		if (!show_all && strcmp(di_prop_name(prop), propname) != 0)
+			continue;
+
+		if ((nr_vals = di_prop_strings(prop, &val)) < 1) {
+			err(EXIT_FAILURE,
+			    _("error reading property %s"), name);
+		} else if (nr_vals != 1) {
+			errx(EXIT_FAILURE, _("invalid property %s"), name);
+		}
+
+		printf("%s=%s\n", name, val);
+
+		if (!show_all)
+			exit(EXIT_SUCCESS);
+	}
+
+	if (!show_all)
+		errx(EXIT_FAILURE, _("property %s was not found"), propname);
+
+	di_fini(root_node);
+}
+
+static void
+print_total(int opt_c, int opt_p, const char *opt_S)
+{
+	uint_t count = 0;
+
+	if (opt_c) {
+		printf("%u\n", nr_cores);
+		return;
+	} else if (opt_p) {
+		printf("%u\n", nr_chips);
+		return;
+	} else if (opt_S == NULL || strcmp(opt_S, "all") == 0) {
+		printf("%u\n", nr_cpus);
+		return;
+	}
+
+
+	for (struct link *l = vcpus; l != NULL; l = l->l_next) {
+		struct vcpu *v = l->l_ptr;
+		if (strcmp(opt_S, v->v_state) == 0)
+			count++;
+	}
+
+	printf("%u\n", count);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -445,8 +546,12 @@ main(int argc, char **argv)
 	char		*s;
 	int		nspec;
 	int		optc;
-	int		opt_s = 0;
+	int		opt_c = 0;
 	int		opt_p = 0;
+	const char	*opt_r = NULL;
+	const char	*opt_S = NULL;
+	int		opt_s = 0;
+	int		opt_t = 0;
 	int		opt_v = 0;
 	int		ex = 0;
 
@@ -483,6 +588,7 @@ main(int argc, char **argv)
 			vc->v_link_core.l_ptr = vc;
 			vc->v_link_pchip.l_ptr = vc;
 			ins_link(ins, &vc->v_link);
+			nr_cpus++;
 		}
 
 		if ((knp = kstat_data_lookup(ksp, "state")) != NULL) {
@@ -569,6 +675,7 @@ nocpuid:
 			chip->p_link.l_id = vc->v_pchip_id;
 			chip->p_link.l_ptr = chip;
 			ins_link(ins, &chip->p_link);
+			nr_chips++;
 		}
 		vc->v_pchip = chip;
 
@@ -587,6 +694,7 @@ nocpuid:
 			(void) find_link(&chip->p_cores, core->c_link.l_id,
 			    &ins);
 			ins_link(ins, &core->c_link_pchip);
+			nr_cores++;
 		}
 		vc->v_core = core;
 
@@ -606,14 +714,26 @@ nocpuid:
 
 	nspec = 0;
 
-	while ((optc = getopt(argc, argv, "pvs")) != EOF) {
+	while ((optc = getopt(argc, argv, "cpr:S:stv")) != EOF) {
 		switch (optc) {
-		case 's':
-			opt_s = 1;
+		case 'c':
+			opt_c = 1;
 			break;
 		case 'p':
 			opt_p = 1;
 			break;
+		case 'r':
+			opt_r = optarg;
+			break;
+		case 'S':
+			opt_S = optarg;
+			break;
+		case 's':
+			opt_s = 1;
+			break;
+		case 't':
+			opt_t = 1;
+			break;
 		case 'v':
 			opt_v = 1;
 			break;
@@ -622,6 +742,33 @@ nocpuid:
 		}
 	}
 
+	if (opt_r != NULL) {
+		if (optind != argc)
+			usage(_("cannot specify CPUs with -r"));
+		if (opt_c || opt_p || opt_S != NULL || opt_s || opt_t || opt_v)
+			usage(_("cannot specify other arguments with -r"));
+
+		read_property(opt_r);
+		return (EXIT_SUCCESS);
+	}
+
+	if (opt_t != NULL) {
+		if (optind != argc)
+			usage(_("cannot specify CPUs with -t"));
+		if (opt_s || opt_v)
+			usage(_("cannot specify -s or -v with -t"));
+		if (opt_S != NULL && (opt_c || opt_p))
+			usage(_("cannot specify CPU state with -c or -p"));
+		if (opt_c && opt_p)
+			usage(_("cannot specify -c and -p"));
+
+		print_total(opt_c, opt_p, opt_S);
+		return (EXIT_SUCCESS);
+	}
+
+	if (opt_S != NULL || opt_c)
+		usage(_("cannot specify -S or -c without -t"));
+
 	while (optind < argc) {
 		long id;
 		char *eptr;
diff --git a/usr/src/man/man1m/psradm.1m b/usr/src/man/man1m/psradm.1m
index 9f7113757b..20c65f108a 100644
--- a/usr/src/man/man1m/psradm.1m
+++ b/usr/src/man/man1m/psradm.1m
@@ -1,10 +1,11 @@
 '\" te
 .\"  Copyright (c) 2008 Sun Microsystems, Inc.
 .\" All Rights Reserved
+.\" Copyright 2019 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PSRADM 1M "April 9, 2016"
+.TH PSRADM 1M "Apr 25, 2019"
 .SH NAME
 psradm \- change processor operational status
 .SH SYNOPSIS
@@ -18,11 +19,16 @@ psradm \- change processor operational status
 \fBpsradm\fR \fB-a\fR \fB-f\fR | \fB-i\fR | \fB-n\fR | \fB-s\fR [\fB-v\fR] [\fB-F\fR]
 .fi
 
+.LP
+.nf
+\fBpsradm\fR \fB-aS\fR [\fB-v\fR]
+.fi
+
 .SH DESCRIPTION
 .LP
 The \fBpsradm\fR utility changes the operational status of processors. The
 legal states for the processor are \fBon-line\fR, \fBoff-line\fR, \fBspare\fR,
-\fBfaulted\fR, and \fBno-intr\fR.
+\fBfaulted\fR, \fBno-intr\fR, and \fBdisabled\fR.
 .sp
 .LP
 An \fBon-line\fR processor processes \fBLWPs\fR (lightweight processes) and can
@@ -51,12 +57,20 @@ A \fBno-intr\fR processor processes \fBLWPs\fR but is not interruptible by I/O
 devices.
 .sp
 .LP
-A processor can not be taken \fBoff-line\fR or made \fBspare\fR if there are
-LWPs that are bound to the processor unless the additional \fB-F\fR option is
-used. The \fB-F\fR option removes processor bindings of such LWPs before
-changing the processor's operational status. On some architectures, it might
-not be possible to take certain processors \fBoff-line\fR or \fBspare\fR if,
-for example, the system depends on some resource provided by the processor.
+With the \fB-aS\fR option, simultaneous multi-threading is disabled. The -a
+option means "apply to every core" and is currently required. Each CPU core has
+its SMT siblings in the \fBdisabled\fR state, and will effectively stay unused.
+That is, only one CPU in each core will be processing I/O, scheduling processes,
+etc. A CPU can only be moved back out of the \fBdisabled\fR state with the
+\fB-F\fR option.
+.sp
+.LP
+A processor can not be taken \fBoff-line\fR, \fBdisabled\fR, or made \fBspare\fR
+if there are LWPs that are bound to the processor unless the additional \fB-F\fR
+option is used. The \fB-F\fR option removes processor bindings of such LWPs
+before changing the processor's operational status. On some architectures, it
+might not be possible to take certain processors \fBoff-line\fR or \fBspare\fR
+if, for example, the system depends on some resource provided by the processor.
 .sp
 .LP
 At least one processor in the system must be able to process \fBLWPs.\fR At
@@ -127,6 +141,15 @@ Set the specified processors \fBno-intr\fR.
 Bring the specified processors \fBon-line\fR.
 .RE
 
+.sp
+.ne 2
+.na
+\fB\fB-S\fR\fR
+.ad
+.RS 6n
+Disable simultaneous multi-threading (hyper-threading).
+.RE
+
 .sp
 .ne 2
 .na
diff --git a/usr/src/man/man1m/psrinfo.1m b/usr/src/man/man1m/psrinfo.1m
index 9e107275e8..ce5291f2ee 100644
--- a/usr/src/man/man1m/psrinfo.1m
+++ b/usr/src/man/man1m/psrinfo.1m
@@ -1,9 +1,10 @@
 '\" te
 .\"  Copyright (c) 2004 Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2019 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PSRINFO 1M "Feb 21, 2004"
+.TH PSRINFO 1M "Apr 25, 2019"
 .SH NAME
 psrinfo \- displays information about processors
 .SH SYNOPSIS
@@ -14,37 +15,37 @@ psrinfo \- displays information about processors
 
 .LP
 .nf
-\fBpsrinfo\fR [\fB-p\fR] \fB-s\fR \fIprocessor_id\fR
+\fBpsrinfo\fR \fB-t\fR [\fB-S state\fR | \fB-c\fR | \fB-p\fR]
+.fi
+
+.LP
+.nf
+\fBpsrinfo\fR \fB-r\fR [\fB<propname>\fR | \fBall\fR]
 .fi
 
 .SH DESCRIPTION
-.sp
 .LP
-\fBpsrinfo\fR displays information about processors. Each physical processor
-may support multiple virtual processors. Each virtual processor is an entity
-with its own interrupt \fBID\fR, capable of executing independent threads.
+\fBpsrinfo\fR displays information about processors. Each physical socket may
+contain multiple cores, which in turn can contain multiple virtual processors
+(also referred to as CPUs).  Each virtual processor is an entity
+with its own \fBID\fR, capable of executing independent threads.
 .sp
 .LP
-Without the \fIprocessor_id\fR operand, \fBpsrinfo\fR displays one line for
-each configured processor, displaying whether it is on-line, non-interruptible
-(designated by no-intr), spare, off-line, faulted or powered off, and when that
-status last changed. Use the processor_id operand to display information about
-a specific processor. See \fBOPERANDS\fR.
+Without the \fIprocessor_id\fR operand, \fBpsrinfo\fR displays one line for each
+configured processor, displaying whether it is on-line, non-interruptible
+(designated by no-intr), spare, off-line, faulted, disabled, or powered off, and
+when that status last changed. Use the processor_id operand to display
+information about a specific processor. See \fBOPERANDS\fR.
 .SH OPTIONS
-.sp
 .LP
 The following options are supported:
 .sp
 .ne 2
 .na
-\fB\fB-s\fR\fI processor_id\fR\fR
+\fB\fB-c\fR\fR
 .ad
 .RS 19n
-Silent mode. Displays \fB1\fR if the specified processor is fully on-line.
-Displays \fB0\fR if the specified processor is non-interruptible, spare,
-off-line, faulted or powered off.
-.sp
-Use silent mode when using \fBpsrinfo\fR in shell scripts.
+When used with \fB-t\fR, report the total number of CPU cores.
 .RE
 
 .sp
@@ -53,10 +54,53 @@ Use silent mode when using \fBpsrinfo\fR in shell scripts.
 \fB\fB-p\fR\fR
 .ad
 .RS 19n
-Display the number of physical processors in a system.
+Display the number of physical sockets in a system.
 .sp
 When combined with the \fB-v\fR option, reports additional information about
-each physical processor.
+each physical socket.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-r\fR \fIpropname\fR\fR
+.ad
+.RS 19n
+Report CPU-specific properties that apply to the system as a whole. Supplying
+"all" will list all such properties in \fBkey=value\fR format. Currently, the
+only defined property is \fBsmt_enabled\fR, a boolean property indicating whether
+simultaneous multi-threading (hyper-threading) is active or not.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-S\fR \fIstate\fR\fR
+.ad
+.RS 19n
+When used with \fB-t\fR, report the total number of CPUs in the given state.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-s\fR\fI processor_id\fR\fR
+.ad
+.RS 19n
+Silent mode. Displays \fB1\fR if the specified processor is fully on-line,
+or \fB0\fR otherwise.
+.sp
+Use silent mode when using \fBpsrinfo\fR in shell scripts.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-t\fR\fR
+.ad
+.RS 19n
+Report totals. Without arguments, reports the total number of CPUs. This can be
+combined with the \fB-p\fR, \fB-c\fR, or \fB-S\fR options to modify the total.
 .RE
 
 .sp
@@ -74,7 +118,6 @@ each physical processor.
 .RE
 
 .SH OPERANDS
-.sp
 .LP
 The following operands are supported:
 .sp
@@ -91,6 +134,8 @@ Specify \fIprocessor_id\fR as an individual processor number (for example,
 3\fR), or a range of processor numbers (for example, \fB1-4\fR). It is also
 possible to combine ranges and (individual or multiple) \fIprocessor_id\fRs
 (for example, \fB1-3 5 7-8 9\fR).
+.sp
+This cannot be specified along with the \fB-r\fR or \fB-t\fR options.
 .RE
 
 .SH EXAMPLES
@@ -129,46 +174,44 @@ fi
 .sp
 
 .LP
-\fBExample 3 \fRDisplaying Information About the Physical Processors in the
+\fBExample 3 \fRDisplaying Information About the Physical Sockets in the
 System
 .sp
 .LP
-With no additional arguments, the \fB-p\fR option displays a single integer:
-the number of physical processors in the system:
+Use the \fB-tp\fR options to report the number of sockets.
 
 .sp
 .in +2
 .nf
-> psrinfo -p
-                8
+> psrinfo -tp
+                2
 .fi
 .in -2
 .sp
 
 .sp
 .LP
-\fBpsrinfo\fR also accepts command line arguments (processor \fBID\fRs):
+Without the \fB-t\fR option, \fB-p\fR also takes processor IDs:
 
 .sp
 .in +2
 .nf
-> psrinfo -p 0 512   # IDs 0 and 512 exist on the
-1                    # same physical processor
+> psrinfo -p 0 28    # IDs 0 and 28 exist on the
+1                    # same socket
 
 > psrinfo -p 0 1     # IDs 0 and 1 exist on different
-2                    # physical processors
+2                    # sockets
 .fi
 .in -2
 .sp
 
 .sp
 .LP
-In this example, virtual processors \fB0\fR and \fB512\fR exist on the same
-physical processor. Virtual processors \fB0\fR and \fB1\fR do not. This is
+In this example, virtual processors \fB0\fR and \fB28\fR exist on the same
+socket. Virtual processors \fB0\fR and \fB1\fR do not. This is
 specific to this example and is and not a general rule.
 
 .SH EXIT STATUS
-.sp
 .LP
 The following exit values are returned:
 .sp
@@ -190,12 +233,10 @@ An error occurred.
 .RE
 
 .SH SEE ALSO
-.sp
 .LP
 \fBpsradm\fR(1M), \fBp_online\fR(2), \fBprocessor_info\fR(2),
 \fBattributes\fR(5)
 .SH DIAGNOSTICS
-.sp
 .ne 2
 .na
 \fB\fBpsrinfo:\fR \fBprocessor\fR \fB9:\fR \fBInvalid\fR \fBargument\fR\fR
diff --git a/usr/src/man/man2/p_online.2 b/usr/src/man/man2/p_online.2
index cd8e659361..1f51e94ef3 100644
--- a/usr/src/man/man2/p_online.2
+++ b/usr/src/man/man2/p_online.2
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2009, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2019 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH P_ONLINE 2 "April 9, 2016"
+.TH P_ONLINE 2 "Apr 25, 2019"
 .SH NAME
 p_online \- return or change processor operational status
 .SH SYNOPSIS
@@ -24,7 +25,8 @@ argument is changed to the state represented by the \fIflag\fR argument.
 .LP
 Legal values for \fIflag\fR are \fBP_STATUS\fR, \fBP_ONLINE\fR,
 \fBP_OFFLINE\fR, \fBP_NOINTR\fR, \fBP_FAULTED\fR, \fBP_SPARE\fR, and
-\fBP_FORCED\fR.
+\fBP_FORCED\fR. \fBP_DISABLED\fR is only supported in the \fBP_ALL_SIBLINGS\fR
+mode.
 .sp
 .LP
 When \fIflag\fR is \fBP_STATUS,\fR no processor status change occurs, but the
@@ -33,8 +35,8 @@ current processor status is returned.
 .LP
 The \fBP_ONLINE\fR, \fBP_OFFLINE\fR, \fBP_NOINTR\fR, \fBP_FAULTED\fR, and
 \fBP_SPARE\fR values for \fIflag\fR refer to valid processor states. The
-\fBP_OFFLINE\fR, \fBP_SPARE\fR,  and \fBP_FAULTED\fR processor states can be
-combined with the \fBP_FORCED\fR flag.
+\fBP_ONLINE\fR, \fBP_OFFLINE\fR, \fBP_SPARE\fR,  and \fBP_FAULTED\fR processor
+states can be combined with the \fBP_FORCED\fR flag.
 .sp
 .LP
 A processor in the \fBP_ONLINE\fR state is allowed to process \fBLWPs\fR
@@ -69,6 +71,11 @@ any of the other states, but since the processor might generate additional
 errors, electing to reactivate such a processor should be carefully considered.
 .sp
 .LP
+A processor in the \fBP_DISABLED\fR state is not allowed to process LWPs. In
+many respects, the \fBP_DISABLED\fR state is similar to the \fBP_OFFLINE\fR
+state, but describes a processor explicitly disabled for general use.
+.sp
+.LP
 Forced processor state transition can be requested if a new processor state is
 specified with the bitwise-inclusive OR of the special \fBP_FORCED\fR flag.
 Forcing transition of a processor to the \fBP_OFFLINE\fR, \fBP_SPARE\fR, or
@@ -87,6 +94,15 @@ The maximum possible \fIprocessorid\fR value can be determined by calling
 determined by calling \fBp_online()\fR with \fIprocessorid\fR values from 0 to
 the maximum returned by \fBsysconf(_SC_CPUID_MAX)\fR. The \fBEINVAL\fR error is
 returned for invalid processor numbers.  See \fBEXAMPLES\fR below.
+.sp
+.LP
+The special value \fBP_ALL_SIBLINGS\fR can be specified instead of a
+\fIprocessorid\fR. In this case, the operation applies to all but one of the
+SMT siblings on each CPU core. The only state transition supported is
+\fBP_DISABLED\fR. The operation is only considered successful if all candidate
+siblings could be disabled.  Individual CPUs disabled in this manner can
+transition to \fBP_ONLINE\fR only in combination with the \fBP_FORCED\fR flag,
+and only if they were disabled via this system call.
 .SH RETURN VALUES
 .LP
 On successful completion, the value returned is the previous state of the
diff --git a/usr/src/pkg/manifests/system-header.mf b/usr/src/pkg/manifests/system-header.mf
index 45751547c0..146662d218 100644
--- a/usr/src/pkg/manifests/system-header.mf
+++ b/usr/src/pkg/manifests/system-header.mf
@@ -26,7 +26,7 @@
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 # Copyright 2019 Peter Tribble.
 #
 
@@ -1682,7 +1682,6 @@ $(i386_ONLY)file path=usr/platform/i86pc/include/sys/ddi_subrdefs.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/debug_info.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/fastboot.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/hma.h
-$(i386_ONLY)file path=usr/platform/i86pc/include/sys/ht.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/mach_mmu.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/machclock.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/machcpuvar.h
@@ -1699,6 +1698,7 @@ $(i386_ONLY)file path=usr/platform/i86pc/include/sys/psm_types.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/rm_platter.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/sbd_ioctl.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/smp_impldefs.h
+$(i386_ONLY)file path=usr/platform/i86pc/include/sys/smt.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/vm_machparam.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/x_call.h
 $(i386_ONLY)file path=usr/platform/i86pc/include/sys/xc_levels.h
@@ -1737,7 +1737,6 @@ $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/errclassify.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/fhc.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/gpio_87317.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/hpc3130_events.h
-$(sparc_ONLY)file path=usr/platform/sun4u/include/sys/ht.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/i2c/clients/hpc3130.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/i2c/clients/i2c_client.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/i2c/clients/lm75.h
@@ -1772,6 +1771,7 @@ $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/sbd_ioctl.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/scb.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/scsb_led.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/simmstat.h
+$(sparc_ONLY)file path=usr/platform/sun4u/include/sys/smt.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/spitregs.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/sram.h
 $(sparc_ONLY)file path=usr/platform/sun4u/include/sys/sun4asi.h
@@ -1800,7 +1800,6 @@ $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/dvma.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/eeprom.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/fcode.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/hsvc.h
-$(sparc_ONLY)file path=usr/platform/sun4v/include/sys/ht.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/hypervisor_api.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/idprom.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/intr.h
@@ -1826,6 +1825,7 @@ $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/prom_plat.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/pte.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/qcn.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/scb.h
+$(sparc_ONLY)file path=usr/platform/sun4v/include/sys/smt.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/soft_state.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/sun4asi.h
 $(sparc_ONLY)file path=usr/platform/sun4v/include/sys/tod.h
diff --git a/usr/src/uts/common/cpr/cpr_main.c b/usr/src/uts/common/cpr/cpr_main.c
index 7db797c848..66791cd1f4 100644
--- a/usr/src/uts/common/cpr/cpr_main.c
+++ b/usr/src/uts/common/cpr/cpr_main.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 /*
  * This module contains the guts of checkpoint-resume mechanism.
  * All code in this module is platform independent.
@@ -1324,7 +1328,7 @@ cpr_all_online(void)
 	do {
 		cp->cpu_cpr_flags &= ~CPU_CPR_ONLINE;
 		if (!CPU_ACTIVE(cp)) {
-			if ((rc = cpu_online(cp)) != 0)
+			if ((rc = cpu_online(cp, 0)) != 0)
 				break;
 			CPU_SET_CPR_FLAGS(cp, CPU_CPR_ONLINE);
 		}
diff --git a/usr/src/uts/common/cpr/cpr_misc.c b/usr/src/uts/common/cpr/cpr_misc.c
index b1906eb9fa..ee7cd5ddf4 100644
--- a/usr/src/uts/common/cpr/cpr_misc.c
+++ b/usr/src/uts/common/cpr/cpr_misc.c
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -703,7 +704,7 @@ cpr_statefile_ok(vnode_t *vp, int alloc_retry)
 		 * Estimate space needed for the state file.
 		 *
 		 * State file size in bytes:
-		 * 	kernel size + non-cache pte seg +
+		 *	kernel size + non-cache pte seg +
 		 *	bitmap size + cpr state file headers size
 		 * (round up to fs->fs_bsize)
 		 */
@@ -996,7 +997,7 @@ cpr_p_online(cpu_t *cp, int state)
 
 	switch (state) {
 	case CPU_CPR_ONLINE:
-		rc = cpu_online(cp);
+		rc = cpu_online(cp, 0);
 		break;
 	case CPU_CPR_OFFLINE:
 		rc = cpu_offline(cp, CPU_FORCED);
diff --git a/usr/src/uts/common/disp/disp.c b/usr/src/uts/common/disp/disp.c
index 4898a18bf2..7e933bccc4 100644
--- a/usr/src/uts/common/disp/disp.c
+++ b/usr/src/uts/common/disp/disp.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -60,7 +60,7 @@
 #include <sys/dtrace.h>
 #include <sys/sdt.h>
 #include <sys/archsystm.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 #include <vm/as.h>
 
@@ -1239,13 +1239,13 @@ setbackdq(kthread_t *tp)
 		 * We'll generally let this thread continue to run where
 		 * it last ran...but will consider migration if:
 		 * - The thread probably doesn't have much cache warmth.
-		 * - HT exclusion would prefer us to run elsewhere
+		 * - SMT exclusion would prefer us to run elsewhere
 		 * - The CPU where it last ran is the target of an offline
 		 *   request.
 		 * - The thread last ran outside its home lgroup.
 		 */
 		if ((!THREAD_HAS_CACHE_WARMTH(tp)) ||
-		    !ht_should_run(tp, tp->t_cpu) ||
+		    !smt_should_run(tp, tp->t_cpu) ||
 		    (tp->t_cpu == cpu_inmotion) ||
 		    !LGRP_CONTAINS_CPU(tp->t_lpl->lpl_lgrp, tp->t_cpu)) {
 			cp = disp_lowpri_cpu(tp->t_cpu, tp, tpri);
@@ -1277,7 +1277,7 @@ setbackdq(kthread_t *tp)
 					newcp = cp->cpu_next_part;
 				}
 
-				if (ht_should_run(tp, newcp) &&
+				if (smt_should_run(tp, newcp) &&
 				    RUNQ_LEN(newcp, tpri) < qlen) {
 					DTRACE_PROBE3(runq__balance,
 					    kthread_t *, tp,
@@ -2579,7 +2579,7 @@ disp_cpu_inactive(cpu_t *cp)
  *
  * Otherwise we'll use double the effective dispatcher priority for the CPU.
  *
- * We do this so ht_adjust_cpu_score() can increment the score if needed,
+ * We do this so smt_adjust_cpu_score() can increment the score if needed,
  * without ending up over-riding a dispatcher priority.
  */
 static pri_t
@@ -2599,7 +2599,7 @@ cpu_score(cpu_t *cp, kthread_t *tp)
 	if (2 * cp->cpu_chosen_level > score)
 		score = 2 * cp->cpu_chosen_level;
 
-	return (ht_adjust_cpu_score(tp, cp, score));
+	return (smt_adjust_cpu_score(tp, cp, score));
 }
 
 /*
@@ -2726,7 +2726,7 @@ disp_choose_best_cpu(void)
 	ASSERT(t->t_state == TS_ONPROC);
 	ASSERT(t->t_schedflag & TS_VCPU);
 
-	if (ht_should_run(t, curcpu))
+	if (smt_should_run(t, curcpu))
 		return (curcpu);
 
 	return (disp_lowpri_cpu(curcpu, t, t->t_pri));
diff --git a/usr/src/uts/common/disp/thread.c b/usr/src/uts/common/disp/thread.c
index d576738e75..bf1f121b67 100644
--- a/usr/src/uts/common/disp/thread.c
+++ b/usr/src/uts/common/disp/thread.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -75,7 +75,7 @@
 #include <sys/cpucaps.h>
 #include <sys/kiconv.h>
 #include <sys/ctype.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 #ifndef	STACK_GROWTH_DOWN
 #error Stacks do not grow downward; 3b2 zombie attack detected!
@@ -1421,7 +1421,7 @@ thread_unpin()
 	itp = t->t_intr;		/* interrupted thread */
 	t->t_intr = NULL;		/* clear interrupt ptr */
 
-	ht_end_intr();
+	smt_end_intr();
 
 	/*
 	 * Get state from interrupt thread for the one
diff --git a/usr/src/uts/common/dtrace/dtrace.c b/usr/src/uts/common/dtrace/dtrace.c
index 8d5ccdc64b..769337294b 100644
--- a/usr/src/uts/common/dtrace/dtrace.c
+++ b/usr/src/uts/common/dtrace/dtrace.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.
  */
 
@@ -6922,6 +6922,16 @@ dtrace_probe(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
 		return;
 
 	cookie = dtrace_interrupt_disable();
+
+	/*
+	 * Also refuse to process any probe firings that might happen on a
+	 * disabled CPU.
+	 */
+	if (CPU->cpu_flags & CPU_DISABLED) {
+		dtrace_interrupt_enable(cookie);
+		return;
+	}
+
 	probe = dtrace_probes[id - 1];
 	cpuid = CPU->cpu_id;
 	onintr = CPU_ON_INTR(CPU);
diff --git a/usr/src/uts/common/fs/zfs/zvol.c b/usr/src/uts/common/fs/zfs/zvol.c
index 33bac61d21..af5c9bdda1 100644
--- a/usr/src/uts/common/fs/zfs/zvol.c
+++ b/usr/src/uts/common/fs/zfs/zvol.c
@@ -26,7 +26,7 @@
  * Copyright 2017 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -90,7 +90,7 @@
 #include <sys/zfeature.h>
 #include <sys/zio_checksum.h>
 #include <sys/zil_impl.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 #include <sys/dkioc_free_util.h>
 #include <sys/zfs_rlock.h>
 
@@ -1278,7 +1278,7 @@ zvol_strategy(buf_t *bp)
 	    (zv->zv_objset->os_sync == ZFS_SYNC_ALWAYS)) &&
 	    !doread && !is_dumpified;
 
-	ht_begin_unsafe();
+	smt_begin_unsafe();
 
 	/*
 	 * There must be no buffer changes when doing a dmu_sync() because
@@ -1327,7 +1327,7 @@ zvol_strategy(buf_t *bp)
 		zil_commit(zv->zv_zilog, ZVOL_OBJ);
 	biodone(bp);
 
-	ht_end_unsafe();
+	smt_end_unsafe();
 
 	return (0);
 }
@@ -1409,7 +1409,7 @@ zvol_read(dev_t dev, uio_t *uio, cred_t *cr)
 		return (error);
 	}
 
-	ht_begin_unsafe();
+	smt_begin_unsafe();
 
 	DTRACE_PROBE3(zvol__uio__start, dev_t, dev, uio_t *, uio, int, 0);
 
@@ -1471,7 +1471,7 @@ zvol_read(dev_t dev, uio_t *uio, cred_t *cr)
 	DTRACE_PROBE4(zvol__uio__done, dev_t, dev, uio_t *, uio, int, 0, int,
 	    error);
 
-	ht_end_unsafe();
+	smt_end_unsafe();
 
 	return (error);
 }
@@ -1504,7 +1504,7 @@ zvol_write(dev_t dev, uio_t *uio, cred_t *cr)
 		return (error);
 	}
 
-	ht_begin_unsafe();
+	smt_begin_unsafe();
 
 	DTRACE_PROBE3(zvol__uio__start, dev_t, dev, uio_t *, uio, int, 1);
 
@@ -1555,7 +1555,7 @@ zvol_write(dev_t dev, uio_t *uio, cred_t *cr)
 	DTRACE_PROBE4(zvol__uio__done, dev_t, dev, uio_t *, uio, int, 1, int,
 	    error);
 
-	ht_end_unsafe();
+	smt_end_unsafe();
 
 	mutex_enter(&zonep->zone_vfs_lock);
 	zonep->zone_vfs_rwstats.writes++;
@@ -1827,7 +1827,7 @@ zvol_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 		dkc = (struct dk_callback *)arg;
 		mutex_exit(&zfsdev_state_lock);
 
-		ht_begin_unsafe();
+		smt_begin_unsafe();
 
 		zil_commit(zv->zv_zilog, ZVOL_OBJ);
 		if ((flag & FKIOCTL) && dkc != NULL && dkc->dkc_callback) {
@@ -1835,7 +1835,7 @@ zvol_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 			error = 0;
 		}
 
-		ht_end_unsafe();
+		smt_end_unsafe();
 
 		return (error);
 
@@ -1861,9 +1861,9 @@ zvol_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 		} else {
 			zv->zv_flags &= ~ZVOL_WCE;
 			mutex_exit(&zfsdev_state_lock);
-			ht_begin_unsafe();
+			smt_begin_unsafe();
 			zil_commit(zv->zv_zilog, ZVOL_OBJ);
-			ht_end_unsafe();
+			smt_end_unsafe();
 		}
 		return (0);
 	}
@@ -1916,7 +1916,7 @@ zvol_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 
 		mutex_exit(&zfsdev_state_lock);
 
-		ht_begin_unsafe();
+		smt_begin_unsafe();
 
 		for (int i = 0; i < dfl->dfl_num_exts; i++) {
 			uint64_t start = dfl->dfl_exts[i].dfle_start,
@@ -1973,7 +1973,7 @@ zvol_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 		if (!(flag & FKIOCTL))
 			dfl_free(dfl);
 
-		ht_end_unsafe();
+		smt_end_unsafe();
 
 		return (error);
 	}
diff --git a/usr/src/uts/common/io/vnd/vnd.c b/usr/src/uts/common/io/vnd/vnd.c
index d03c7ce4ec..ac60fe678b 100644
--- a/usr/src/uts/common/io/vnd/vnd.c
+++ b/usr/src/uts/common/io/vnd/vnd.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -830,7 +830,7 @@
 #include <sys/disp.h>
 #include <sys/random.h>
 #include <sys/gsqueue.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 #include <inet/ip.h>
 #include <inet/ip6.h>
@@ -3721,7 +3721,7 @@ vnd_squeue_tx_drain(void *arg, mblk_t *drain_mp, gsqueue_t *gsp, void *dummy)
 	 * We're potentially going deep into the networking layer; make sure the
 	 * guest can't run concurrently.
 	 */
-	ht_begin_unsafe();
+	smt_begin_unsafe();
 
 	nmps = 0;
 	mptot = 0;
@@ -3743,7 +3743,7 @@ vnd_squeue_tx_drain(void *arg, mblk_t *drain_mp, gsqueue_t *gsp, void *dummy)
 		}
 	}
 
-	ht_end_unsafe();
+	smt_end_unsafe();
 
 	empty = vnd_dq_is_empty(&vsp->vns_dq_write);
 
diff --git a/usr/src/uts/common/os/cpu.c b/usr/src/uts/common/os/cpu.c
index 620f26034f..e53c75b64e 100644
--- a/usr/src/uts/common/os/cpu.c
+++ b/usr/src/uts/common/os/cpu.c
@@ -59,6 +59,7 @@
 #include <sys/time.h>
 #include <sys/archsystm.h>
 #include <sys/sdt.h>
+#include <sys/smt.h>
 #if defined(__x86) || defined(__amd64)
 #include <sys/x86_archext.h>
 #endif
@@ -144,6 +145,7 @@ processorid_t max_cpu_seqid_ever = 0;
 
 int ncpus = 1;
 int ncpus_online = 1;
+int ncpus_intr_enabled = 1;
 
 /*
  * CPU that we're trying to offline.  Protected by cpu_lock.
@@ -1209,7 +1211,7 @@ cpu_flagged_active(cpu_flag_t cpu_flags)
  * Bring the indicated CPU online.
  */
 int
-cpu_online(cpu_t *cp)
+cpu_online(cpu_t *cp, int flags)
 {
 	int	error = 0;
 
@@ -1223,6 +1225,9 @@ cpu_online(cpu_t *cp)
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if ((cp->cpu_flags & CPU_DISABLED) && !smt_can_enable(cp, flags))
+		return (EINVAL);
+
 	/*
 	 * Put all the cpus into a known safe place.
 	 * No mutexes can be entered while CPUs are paused.
@@ -1236,8 +1241,12 @@ cpu_online(cpu_t *cp)
 			cp->cpu_flags &= ~CPU_FAULTED;
 			mp_cpu_faulted_exit(cp);
 		}
+
+		if (cp->cpu_flags & CPU_DISABLED)
+			smt_force_enabled();
+
 		cp->cpu_flags &= ~(CPU_QUIESCED | CPU_OFFLINE | CPU_FROZEN |
-		    CPU_SPARE);
+		    CPU_SPARE | CPU_DISABLED);
 		CPU_NEW_GENERATION(cp);
 		start_cpus();
 		cpu_stats_kstat_create(cp);
@@ -1278,10 +1287,13 @@ cpu_offline(cpu_t *cp, int flags)
 	lpl_t	*cpu_lpl;
 	proc_t	*p;
 	int	lgrp_diff_lpl;
-	boolean_t unbind_all_threads = (flags & CPU_FORCED) != 0;
+	boolean_t forced = (flags & CPU_FORCED) != 0;
 
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	/*
 	 * If we're going from faulted or spare to offline, just
 	 * clear these flags and update CPU state.
@@ -1309,7 +1321,7 @@ cpu_offline(cpu_t *cp, int flags)
 	 * Unbind all soft-bound threads bound to our CPU and hard bound threads
 	 * if we were asked to.
 	 */
-	error = cpu_unbind(cp->cpu_id, unbind_all_threads);
+	error = cpu_unbind(cp->cpu_id, forced);
 	if (error != 0)
 		return (error);
 	/*
@@ -1614,6 +1626,9 @@ cpu_faulted(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		cp->cpu_flags &= ~CPU_SPARE;
 		cp->cpu_flags |= CPU_FAULTED;
@@ -1642,6 +1657,9 @@ cpu_spare(cpu_t *cp, int flags)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	ASSERT(!cpu_is_poweredoff(cp));
 
+	if (cp->cpu_flags & CPU_DISABLED)
+		return (EINVAL);
+
 	if (cpu_is_offline(cp)) {
 		if (cp->cpu_flags & CPU_FAULTED) {
 			cp->cpu_flags &= ~CPU_FAULTED;
@@ -2267,28 +2285,9 @@ cpu_info_kstat_update(kstat_t *ksp, int rw)
 	if (cpuid_checkpass(cp, 1) == 0)
 		return (ENXIO);
 #endif
-	switch (cp->cpu_type_info.pi_state) {
-	case P_ONLINE:
-		pi_state = PS_ONLINE;
-		break;
-	case P_POWEROFF:
-		pi_state = PS_POWEROFF;
-		break;
-	case P_NOINTR:
-		pi_state = PS_NOINTR;
-		break;
-	case P_FAULTED:
-		pi_state = PS_FAULTED;
-		break;
-	case P_SPARE:
-		pi_state = PS_SPARE;
-		break;
-	case P_OFFLINE:
-		pi_state = PS_OFFLINE;
-		break;
-	default:
-		pi_state = "unknown";
-	}
+
+	pi_state = cpu_get_state_str(cp->cpu_flags);
+
 	(void) strcpy(cpu_info_template.ci_state.value.c, pi_state);
 	cpu_info_template.ci_state_begin.value.l = cp->cpu_state_begin;
 	(void) strncpy(cpu_info_template.ci_cpu_type.value.c,
@@ -3170,33 +3169,41 @@ cpu_set_state(cpu_t *cpu)
  * communication with user applications; cpu_flags provides the in-kernel
  * interface.
  */
-int
-cpu_get_state(cpu_t *cpu)
+static int
+cpu_flags_to_state(cpu_flag_t flags)
 {
-	ASSERT(MUTEX_HELD(&cpu_lock));
-	if (cpu->cpu_flags & CPU_POWEROFF)
+	if (flags & CPU_DISABLED)
+		return (P_DISABLED);
+	else if (flags & CPU_POWEROFF)
 		return (P_POWEROFF);
-	else if (cpu->cpu_flags & CPU_FAULTED)
+	else if (flags & CPU_FAULTED)
 		return (P_FAULTED);
-	else if (cpu->cpu_flags & CPU_SPARE)
+	else if (flags & CPU_SPARE)
 		return (P_SPARE);
-	else if ((cpu->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
+	else if ((flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY)
 		return (P_OFFLINE);
-	else if (cpu->cpu_flags & CPU_ENABLE)
+	else if (flags & CPU_ENABLE)
 		return (P_ONLINE);
 	else
 		return (P_NOINTR);
 }
 
+int
+cpu_get_state(cpu_t *cpu)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	return (cpu_flags_to_state(cpu->cpu_flags));
+}
+
 /*
  * Return processor_info(2) state as a string.
  */
 const char *
-cpu_get_state_str(cpu_t *cpu)
+cpu_get_state_str(cpu_flag_t flags)
 {
 	const char *string;
 
-	switch (cpu_get_state(cpu)) {
+	switch (cpu_flags_to_state(flags)) {
 	case P_ONLINE:
 		string = PS_ONLINE;
 		break;
@@ -3215,6 +3222,9 @@ cpu_get_state_str(cpu_t *cpu)
 	case P_OFFLINE:
 		string = PS_OFFLINE;
 		break;
+	case P_DISABLED:
+		string = PS_DISABLED;
+		break;
 	default:
 		string = "unknown";
 		break;
diff --git a/usr/src/uts/common/os/lgrp.c b/usr/src/uts/common/os/lgrp.c
index 6f6aced619..d8039f1a1f 100644
--- a/usr/src/uts/common/os/lgrp.c
+++ b/usr/src/uts/common/os/lgrp.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -91,7 +91,7 @@
 #include <sys/pg.h>
 #include <sys/promif.h>
 #include <sys/sdt.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 lgrp_gen_t	lgrp_gen = 0;		/* generation of lgroup hierarchy */
 lgrp_t *lgrp_table[NLGRPS_MAX]; /* table of all initialized lgrp_t structs */
@@ -522,7 +522,7 @@ lgrp_main_mp_init(void)
 {
 	klgrpset_t changed;
 
-	ht_init();
+	smt_init();
 
 	/*
 	 * Update lgroup topology (if necessary)
diff --git a/usr/src/uts/common/os/main.c b/usr/src/uts/common/os/main.c
index 3364d1e523..9e2d03e392 100644
--- a/usr/src/uts/common/os/main.c
+++ b/usr/src/uts/common/os/main.c
@@ -27,7 +27,7 @@
 /*	  All Rights Reserved		*/
 
 /*
- * Copyright 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -74,6 +74,7 @@
 #include <sys/stack.h>
 #include <sys/brand.h>
 #include <sys/mmapobj.h>
+#include <sys/smt.h>
 
 #include <vm/as.h>
 #include <vm/seg_kmem.h>
@@ -625,6 +626,8 @@ main(void)
 	pm_cfb_setup_intr();
 #if defined(__x86)
 	fastboot_post_startup();
+
+	smt_late_init();
 #endif
 
 	/*
diff --git a/usr/src/uts/common/os/pool_pset.c b/usr/src/uts/common/os/pool_pset.c
index 7f056a6c62..661d4db3ff 100644
--- a/usr/src/uts/common/os/pool_pset.c
+++ b/usr/src/uts/common/os/pool_pset.c
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
 
 #include <sys/pool.h>
 #include <sys/pool_impl.h>
@@ -889,7 +891,7 @@ pool_pset_pack(ea_object_t *eo_system)
 			(void) nvlist_dup(cpu->cpu_props, &nvl, KM_SLEEP);
 			(void) nvlist_add_int64(nvl, "cpu.sys_id", cpu->cpu_id);
 			(void) nvlist_add_string(nvl, "cpu.status",
-			    (char *)cpu_get_state_str(cpu));
+			    (char *)cpu_get_state_str(cpu->cpu_flags));
 			buf = NULL;
 			bufsz = 0;
 			(void) nvlist_pack(nvl, &buf, &bufsz,
@@ -967,7 +969,7 @@ pool_cpu_propget(processorid_t cpuid, char *name, nvlist_t *nvl)
 	}
 	if (strcmp(name, "cpu.status") == 0) {
 		ret = nvlist_add_string(nvl, "cpu.status",
-		    (char *)cpu_get_state_str(cpu));
+		    (char *)cpu_get_state_str(cpu->cpu_flags));
 	} else {
 		ret = EINVAL;
 	}
diff --git a/usr/src/uts/common/sys/cpuvar.h b/usr/src/uts/common/sys/cpuvar.h
index 7ac2fafe2f..69aa74d3d1 100644
--- a/usr/src/uts/common/sys/cpuvar.h
+++ b/usr/src/uts/common/sys/cpuvar.h
@@ -329,10 +329,13 @@ extern cpu_core_t cpu_core[];
  * suspended (in the suspend path), or have yet to be resumed (in the resume
  * case).
  *
+ * CPU_DISABLED is used for disabling SMT. It is similar to CPU_OFFLINE, but
+ * cannot be onlined without being forced.
+ *
  * On some platforms CPUs can be individually powered off.
  * The following flags are set for powered off CPUs: CPU_QUIESCED,
  * CPU_OFFLINE, and CPU_POWEROFF.  The following flags are cleared:
- * CPU_RUNNING, CPU_READY, CPU_EXISTS, and CPU_ENABLE.
+ * CPU_RUNNING, CPU_READY, CPU_EXISTS, CPU_DISABLED and CPU_ENABLE.
  */
 #define	CPU_RUNNING	0x001		/* CPU running */
 #define	CPU_READY	0x002		/* CPU ready for cross-calls */
@@ -344,10 +347,7 @@ extern cpu_core_t cpu_core[];
 #define	CPU_FROZEN	0x080		/* CPU is frozen via CPR suspend */
 #define	CPU_SPARE	0x100		/* CPU offline available for use */
 #define	CPU_FAULTED	0x200		/* CPU offline diagnosed faulty */
-
-#define	FMT_CPU_FLAGS							\
-	"\20\12fault\11spare\10frozen"					\
-	"\7poweroff\6offline\5enable\4exist\3quiesced\2ready\1run"
+#define	CPU_DISABLED	0x400		/* CPU explicitly disabled (HT) */
 
 #define	CPU_ACTIVE(cpu)	(((cpu)->cpu_flags & CPU_OFFLINE) == 0)
 
@@ -524,6 +524,7 @@ extern cpuset_t		cpu_active_set;	/* cached set of active CPUs */
 extern cpuset_t		cpu_available;	/* cached set of available CPUs */
 extern int		ncpus;		/* number of CPUs present */
 extern int		ncpus_online;	/* number of CPUs not quiesced */
+extern int		ncpus_intr_enabled; /* nr of CPUs taking I/O intrs */
 extern int		max_ncpus;	/* max present before ncpus is known */
 extern int		boot_max_ncpus;	/* like max_ncpus but for real */
 extern int		boot_ncpus;	/* # cpus present @ boot */
@@ -635,12 +636,12 @@ int	cpus_paused(void);
 void	cpu_pause_init(void);
 cpu_t	*cpu_get(processorid_t cpun);	/* get the CPU struct associated */
 
-int	cpu_online(cpu_t *cp);			/* take cpu online */
-int	cpu_offline(cpu_t *cp, int flags);	/* take cpu offline */
-int	cpu_spare(cpu_t *cp, int flags);	/* take cpu to spare */
-int	cpu_faulted(cpu_t *cp, int flags);	/* take cpu to faulted */
-int	cpu_poweron(cpu_t *cp);		/* take powered-off cpu to offline */
-int	cpu_poweroff(cpu_t *cp);	/* take offline cpu to powered-off */
+int	cpu_online(cpu_t *, int);	/* take cpu online */
+int	cpu_offline(cpu_t *, int);	/* take cpu offline */
+int	cpu_spare(cpu_t *, int);	/* take cpu to spare */
+int	cpu_faulted(cpu_t *, int);	/* take cpu to faulted */
+int	cpu_poweron(cpu_t *);		/* take powered-off cpu to offline */
+int	cpu_poweroff(cpu_t *);		/* take offline cpu to powered-off */
 
 cpu_t	*cpu_intr_next(cpu_t *cp);	/* get next online CPU taking intrs */
 int	cpu_intr_count(cpu_t *cp);	/* count # of CPUs handling intrs */
@@ -673,7 +674,7 @@ int	cpu_flagged_poweredoff(cpu_flag_t); /* flags show CPU is powered off */
  */
 void	cpu_set_state(cpu_t *);		/* record/timestamp current state */
 int	cpu_get_state(cpu_t *);		/* get current cpu state */
-const char *cpu_get_state_str(cpu_t *);	/* get current cpu state as string */
+const char *cpu_get_state_str(cpu_flag_t);
 
 
 void	cpu_set_curr_clock(uint64_t);	/* indicate the current CPU's freq */
diff --git a/usr/src/uts/common/sys/processor.h b/usr/src/uts/common/sys/processor.h
index ec4b7471e5..4264a89a2a 100644
--- a/usr/src/uts/common/sys/processor.h
+++ b/usr/src/uts/common/sys/processor.h
@@ -31,6 +31,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 #ifndef _SYS_PROCESSOR_H
 #define	_SYS_PROCESSOR_H
 
@@ -68,8 +72,9 @@ typedef int	chipid_t;
 #define	P_POWEROFF	0x0005	/* processor is powered off */
 #define	P_NOINTR	0x0006	/* processor is online, but no I/O interrupts */
 #define	P_SPARE		0x0007	/* processor is offline, can be reactivated */
+#define	P_DISABLED	0x0008	/* processor is explicitly disabled for use */
 #define	P_BAD		P_FAULTED	/* unused but defined by USL */
-#define	P_FORCED 	0x10000000	/* force processor offline */
+#define	P_FORCED	0x10000000	/* force processor offline */
 
 /*
  * String names for processor states defined above.
@@ -80,6 +85,7 @@ typedef int	chipid_t;
 #define	PS_POWEROFF	"powered-off"
 #define	PS_NOINTR	"no-intr"
 #define	PS_SPARE	"spare"
+#define	PS_DISABLED	"disabled"
 
 /*
  * Structure filled in by processor_info(2). This structure
@@ -95,7 +101,7 @@ typedef int	chipid_t;
 #define	PI_FPUTYPE	32	/* max size of FPU types string */
 
 typedef struct {
-	int	pi_state;  			/* processor state, see above */
+	int	pi_state;			/* processor state, see above */
 	char	pi_processor_type[PI_TYPELEN];	/* ASCII CPU type */
 	char	pi_fputypes[PI_FPUTYPE];	/* ASCII FPU types */
 	int	pi_clock;			/* CPU clock freq in MHz */
@@ -110,6 +116,11 @@ typedef struct {
 #define	PBIND_SOFT	-4	/* allows offlining CPU */
 #define	PBIND_QUERY_TYPE	-5	/* Return binding type */
 
+/*
+ * Sentinel values for p_online(2)
+ */
+#define	P_ALL_SIBLINGS (-1)
+
 /*
  * User-level system call interface prototypes
  */
diff --git a/usr/src/uts/common/sys/thread.h b/usr/src/uts/common/sys/thread.h
index 6cc474f864..955ba918cd 100644
--- a/usr/src/uts/common/sys/thread.h
+++ b/usr/src/uts/common/sys/thread.h
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef	_SYS_THREAD_H
@@ -355,7 +355,7 @@ typedef struct _kthread {
 
 	char		*t_name;	/* thread name */
 
-	uint64_t	t_unsafe;	/* unsafe to run with HT VCPU thread */
+	uint64_t	t_unsafe;	/* unsafe to run with SMT VCPU thread */
 } kthread_t;
 
 /*
diff --git a/usr/src/uts/common/syscall/p_online.c b/usr/src/uts/common/syscall/p_online.c
index 88a0340bf7..e3156aeab1 100644
--- a/usr/src/uts/common/syscall/p_online.c
+++ b/usr/src/uts/common/syscall/p_online.c
@@ -23,6 +23,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/var.h>
@@ -37,13 +41,15 @@
 #include <sys/processor.h>
 #include <sys/debug.h>
 #include <sys/policy.h>
+#include <sys/smt.h>
 
 /*
  * CPU state diagram
  *
- *                   P_SPARE
+ *                  P_SPARE
  * P_POWEROFF <---> P_OFFLINE <---> P_ONLINE <---> P_NOINTR
  *                  P_FAULTED
+ *                  P_DISABLED
  */
 int
 p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
@@ -53,10 +59,17 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 	int	error = 0;
 	int	flags = 0;
 
-	/*
-	 * Try to get a pointer to the requested CPU structure.
-	 */
 	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (cpun == P_ALL_SIBLINGS) {
+		if (new_status != P_DISABLED) {
+			error = EINVAL;
+			goto out;
+		}
+
+		return (smt_disable());
+	}
+
 	if ((cp = cpu_get(cpun)) == NULL) {
 		error = EINVAL;
 		goto out;
@@ -81,8 +94,10 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 		if (secpolicy_ponline(CRED()) != 0)
 			error = EPERM;
 		break;
+	case P_DISABLED:
 	default:
 		error = EINVAL;
+		break;
 	}
 
 	if (error)
@@ -105,6 +120,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
@@ -112,7 +128,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is in one of the offline states,
 			 * bring it online.
 			 */
-			error = cpu_online(cp);
+			error = cpu_online(cp, flags);
 			break;
 		case P_NOINTR:
 			cpu_intr_enable(cp);
@@ -130,6 +146,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			cpu_intr_enable(cp);
 			/* FALLTHROUGH */
 		case P_ONLINE:
+		case P_DISABLED:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
@@ -143,6 +160,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * If CPU is powered off, power it on.
 			 */
 			error = cpu_poweron(cp);
+			break;
 		}
 		break;
 
@@ -156,13 +174,14 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/* FALLTHROUGH */
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_SPARE:
 			/*
 			 * First, bring the CPU online.
 			 */
-			if (error = cpu_online(cp))
+			if (error = cpu_online(cp, flags))
 				break;
 			/* FALLTHROUGH */
 		case P_ONLINE:
@@ -170,6 +189,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * CPU is now online.  Try to disable interrupts.
 			 */
 			error = cpu_intr_disable(cp);
+			break;
 		}
 		break;
 
@@ -183,14 +203,16 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
-		case P_SPARE:
 		case P_ONLINE:
 		case P_NOINTR:
+		case P_SPARE:
 			/*
 			 * Mark this CPU as faulted.
 			 */
 			error = cpu_faulted(cp, flags);
+			break;
 		}
 		break;
 
@@ -204,6 +226,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 				break;
 			ASSERT(cpu_get_state(cp) == P_OFFLINE);
 			/*FALLTHROUGH*/
+		case P_DISABLED:
 		case P_OFFLINE:
 		case P_FAULTED:
 		case P_ONLINE:
@@ -212,6 +235,7 @@ p_online_internal_locked(processorid_t cpun, int new_status, int *old_status)
 			 * Mark this CPU as a spare.
 			 */
 			error = cpu_spare(cp, flags);
+			break;
 		}
 		break;
 	}
diff --git a/usr/src/uts/i86pc/Makefile.files b/usr/src/uts/i86pc/Makefile.files
index 85579bcb57..2374e68e20 100644
--- a/usr/src/uts/i86pc/Makefile.files
+++ b/usr/src/uts/i86pc/Makefile.files
@@ -71,7 +71,6 @@ CORE_OBJS +=			\
 	hment.o			\
 	hold_page.o		\
 	hrtimers.o		\
-	ht.o			\
 	htable.o		\
 	hypercall.o		\
 	hypersubr.o		\
@@ -116,6 +115,7 @@ CORE_OBJS +=			\
 	ppage.o			\
 	pwrnow.o		\
 	seg_vmm.o		\
+	smt.o			\
 	speedstep.o		\
 	ssp.o			\
 	startup.o		\
diff --git a/usr/src/uts/i86pc/io/apix/apix_intr.c b/usr/src/uts/i86pc/io/apix/apix_intr.c
index 59d8787839..c27a07ead3 100644
--- a/usr/src/uts/i86pc/io/apix/apix_intr.c
+++ b/usr/src/uts/i86pc/io/apix/apix_intr.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2018 Western Digital Corporation.  All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/cpuvar.h>
@@ -69,7 +69,7 @@
 #include <vm/hat_i86.h>
 #include <sys/stack.h>
 #include <sys/apix.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 static void apix_post_hardint(int);
 
@@ -282,7 +282,7 @@ apix_do_softint_prolog(struct cpu *cpu, uint_t pil, uint_t oldpil,
 
 	it->t_intr = t;
 	cpu->cpu_thread = it;
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	/*
 	 * Set bit for this pil in CPU's interrupt active bitmask.
@@ -353,7 +353,7 @@ apix_do_softint_epilog(struct cpu *cpu, uint_t oldpil)
 	it->t_link = cpu->cpu_intr_thread;
 	cpu->cpu_intr_thread = it;
 	it->t_state = TS_FREE;
-	ht_end_intr();
+	smt_end_intr();
 	cpu->cpu_thread = t;
 
 	if (t->t_flag & T_INTR_THREAD)
@@ -471,7 +471,7 @@ apix_hilevel_intr_prolog(struct cpu *cpu, uint_t pil, uint_t oldpil,
 		}
 	}
 
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	/* store starting timestamp in CPu structure for this IPL */
 	mcpu->pil_high_start[pil - (LOCK_LEVEL + 1)] = now;
@@ -563,7 +563,7 @@ apix_hilevel_intr_epilog(struct cpu *cpu, uint_t oldpil)
 			t->t_intr_start = now;
 	}
 
-	ht_end_intr();
+	smt_end_intr();
 
 	mcpu->mcpu_pri = oldpil;
 	if (pil < CBE_HIGH_PIL)
@@ -677,7 +677,7 @@ apix_intr_thread_prolog(struct cpu *cpu, uint_t pil, caddr_t stackptr)
 	it->t_state = TS_ONPROC;
 
 	cpu->cpu_thread = it;
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	/*
 	 * Initialize thread priority level from intr_pri
@@ -766,7 +766,7 @@ apix_intr_thread_epilog(struct cpu *cpu, uint_t oldpil)
 	cpu->cpu_intr_thread = it;
 	it->t_state = TS_FREE;
 
-	ht_end_intr();
+	smt_end_intr();
 	cpu->cpu_thread = t;
 
 	if (t->t_flag & T_INTR_THREAD)
diff --git a/usr/src/uts/i86pc/io/apix/apix_utils.c b/usr/src/uts/i86pc/io/apix/apix_utils.c
index 268aa5a391..208e532518 100644
--- a/usr/src/uts/i86pc/io/apix/apix_utils.c
+++ b/usr/src/uts/i86pc/io/apix/apix_utils.c
@@ -29,7 +29,7 @@
 /*
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2013 Pluribus Networks, Inc.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/processor.h>
@@ -67,7 +67,7 @@
 #include <sys/x_call.h>
 #include <sys/reboot.h>
 #include <sys/apix.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 static int apix_get_avail_vector_oncpu(uint32_t, int, int);
 static apix_vector_t *apix_init_vector(processorid_t, uchar_t);
@@ -806,7 +806,7 @@ apix_insert_av(apix_vector_t *vecp, void *intr_id, avfunc f, caddr_t arg1,
 	vecp->v_share++;
 	vecp->v_pri = (ipl > vecp->v_pri) ? ipl : vecp->v_pri;
 
-	ht_intr_alloc_pil(vecp->v_pri);
+	smt_intr_alloc_pil(vecp->v_pri);
 
 	if (vecp->v_autovect == NULL) {	/* Nothing on list - put it at head */
 		vecp->v_autovect = mem;
diff --git a/usr/src/uts/i86pc/io/dr/dr_cpu.c b/usr/src/uts/i86pc/io/dr/dr_cpu.c
index a893310977..07204d1c67 100644
--- a/usr/src/uts/i86pc/io/dr/dr_cpu.c
+++ b/usr/src/uts/i86pc/io/dr/dr_cpu.c
@@ -28,6 +28,10 @@
  * All rights reserved.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 /*
  * CPU support routines for DR
  */
@@ -326,7 +330,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -829,7 +833,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (rv == 0 && cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic.c b/usr/src/uts/i86pc/io/pcplusmp/apic.c
index 9d1f0962fc..efca63c814 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic.c
@@ -25,7 +25,7 @@
 /*
  * Copyright (c) 2010, Intel Corporation.
  * All rights reserved.
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -82,7 +82,7 @@
 #include <sys/hpet.h>
 #include <sys/apic_common.h>
 #include <sys/apic_timer.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 /*
  *	Local Function Prototypes
@@ -304,7 +304,7 @@ apic_init(void)
 	/*
 	 * For pcplusmp, we'll keep things simple and always disable this.
 	 */
-	ht_intr_alloc_pil(XC_CPUPOKE_PIL);
+	smt_intr_alloc_pil(XC_CPUPOKE_PIL);
 
 	apic_pir_vect = apic_get_ipivect(XC_CPUPOKE_PIL, -1);
 
diff --git a/usr/src/uts/i86pc/io/viona/viona.c b/usr/src/uts/i86pc/io/viona/viona.c
index 4095d602f9..0463dd8c97 100644
--- a/usr/src/uts/i86pc/io/viona/viona.c
+++ b/usr/src/uts/i86pc/io/viona/viona.c
@@ -237,7 +237,7 @@
 #include <sys/strsubr.h>
 #include <sys/strsun.h>
 #include <vm/seg_kmem.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 #include <sys/pattr.h>
 #include <sys/dls.h>
@@ -3002,9 +3002,9 @@ viona_tx(viona_link_t *link, viona_vring_t *ring)
 	 * We're potentially going deep into the networking layer; make sure the
 	 * guest can't run concurrently.
 	 */
-	ht_begin_unsafe();
+	smt_begin_unsafe();
 	mac_tx(link_mch, mp_head, 0, MAC_DROP_ON_NO_DESC, NULL);
-	ht_end_unsafe();
+	smt_end_unsafe();
 	return;
 
 drop_fail:
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index a039455be7..4a636dcea0 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -56,7 +56,7 @@ __FBSDID("$FreeBSD$");
 #ifndef __FreeBSD__
 #include <sys/x86_archext.h>
 #include <sys/smp_impldefs.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 #include <sys/hma.h>
 #include <sys/trap.h>
 #endif
@@ -929,7 +929,7 @@ vmx_init(int ipinum)
 		}
 	}
 #else
-	/* L1D flushing is taken care of by ht_acquire() and friends */
+	/* L1D flushing is taken care of by smt_acquire() and friends */
 	guest_l1d_flush = 0;
 #endif /* __FreeBSD__ */
 
@@ -3345,7 +3345,7 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 		}
 
 #ifndef __FreeBSD__
-		if ((rc = ht_acquire()) != 1) {
+		if ((rc = smt_acquire()) != 1) {
 			enable_intr();
 			vmexit->rip = rip;
 			vmexit->inst_length = 0;
@@ -3375,7 +3375,7 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 		 * anyone attempting to break that rule.
 		 */
 		if (curproc->p_model != DATAMODEL_LP64) {
-			ht_release();
+			smt_release();
 			enable_intr();
 			bzero(vmexit, sizeof (*vmexit));
 			vmexit->rip = rip;
@@ -3409,7 +3409,7 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 
 #ifndef	__FreeBSD__
 		vmx->vmcs_state[vcpu] |= VS_LAUNCHED;
-		ht_release();
+		smt_release();
 #else
 		bare_lgdt(&gdtr);
 		lidt(&idtr);
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index 4b759b44e9..7d1d0c0bfb 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -27,7 +27,7 @@
 #include <sys/cpuset.h>
 #include <sys/id_space.h>
 #include <sys/fs/sdev_plugin.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 
 #include <sys/kernel.h>
 #include <sys/hma.h>
@@ -378,7 +378,7 @@ vmmdev_do_ioctl(vmm_softc_t *sc, int cmd, intptr_t arg, int md,
 		vmrun.cpuid = vcpu;
 
 		if (!(curthread->t_schedflag & TS_VCPU))
-			ht_mark_as_vcpu();
+			smt_mark_as_vcpu();
 
 		error = vm_run(sc->vmm_vm, &vmrun);
 		/*
diff --git a/usr/src/uts/i86pc/os/cpuid.c b/usr/src/uts/i86pc/os/cpuid.c
index 3b0133ce07..79ccaf3129 100644
--- a/usr/src/uts/i86pc/os/cpuid.c
+++ b/usr/src/uts/i86pc/os/cpuid.c
@@ -32,7 +32,7 @@
  * Portions Copyright 2009 Advanced Micro Devices, Inc.
  */
 /*
- * Copyright 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -2226,11 +2226,11 @@ cpuid_scan_security(cpu_t *cpu, uchar_t *featureset)
 	 * We're the boot CPU, so let's figure out our L1TF status.
 	 *
 	 * First, if this is a RDCL_NO CPU, then we are not vulnerable: we don't
-	 * need to exclude with ht_acquire(), and we don't need to flush.
+	 * need to exclude with smt_acquire(), and we don't need to flush.
 	 */
 	if (is_x86_feature(featureset, X86FSET_RDCL_NO)) {
-		extern int ht_exclusion;
-		ht_exclusion = 0;
+		extern int smt_exclusion;
+		smt_exclusion = 0;
 		spec_l1d_flush = spec_l1d_flush_noop;
 		membar_producer();
 		return;
diff --git a/usr/src/uts/i86pc/os/intr.c b/usr/src/uts/i86pc/os/intr.c
index 4d24cf74c0..a56cdc1b03 100644
--- a/usr/src/uts/i86pc/os/intr.c
+++ b/usr/src/uts/i86pc/os/intr.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018 Joyent, Inc.  All rights reserverd.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -466,7 +466,7 @@
 #include <sys/ontrap.h>
 #include <sys/x86_archext.h>
 #include <sys/promif.h>
-#include <sys/ht.h>
+#include <sys/smt.h>
 #include <vm/hat_i86.h>
 #if defined(__xpv)
 #include <sys/hypervisor.h>
@@ -597,7 +597,7 @@ hilevel_intr_prolog(struct cpu *cpu, uint_t pil, uint_t oldpil, struct regs *rp)
 		}
 	}
 
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	/*
 	 * Store starting timestamp in CPU structure for this PIL.
@@ -703,7 +703,7 @@ hilevel_intr_epilog(struct cpu *cpu, uint_t pil, uint_t oldpil, uint_t vecnum)
 			t->t_intr_start = now;
 	}
 
-	ht_end_intr();
+	smt_end_intr();
 
 	mcpu->mcpu_pri = oldpil;
 	(void) (*setlvlx)(oldpil, vecnum);
@@ -767,7 +767,7 @@ intr_thread_prolog(struct cpu *cpu, caddr_t stackptr, uint_t pil)
 	it->t_state = TS_ONPROC;
 
 	cpu->cpu_thread = it;		/* new curthread on this cpu */
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	it->t_pil = (uchar_t)pil;
 	it->t_pri = intr_pri + (pri_t)pil;
@@ -859,7 +859,7 @@ intr_thread_epilog(struct cpu *cpu, uint_t vec, uint_t oldpil)
 	mcpu->mcpu_pri = pil;
 	(*setlvlx)(pil, vec);
 	t->t_intr_start = now;
-	ht_end_intr();
+	smt_end_intr();
 	cpu->cpu_thread = t;
 }
 
@@ -1047,7 +1047,7 @@ top:
 
 	it->t_intr = t;
 	cpu->cpu_thread = it;
-	ht_begin_intr(pil);
+	smt_begin_intr(pil);
 
 	/*
 	 * Set bit for this pil in CPU's interrupt active bitmask.
@@ -1108,7 +1108,7 @@ dosoftint_epilog(struct cpu *cpu, uint_t oldpil)
 	it->t_link = cpu->cpu_intr_thread;
 	cpu->cpu_intr_thread = it;
 	it->t_state = TS_FREE;
-	ht_end_intr();
+	smt_end_intr();
 	cpu->cpu_thread = t;
 
 	if (t->t_flag & T_INTR_THREAD)
diff --git a/usr/src/uts/i86pc/os/mlsetup.c b/usr/src/uts/i86pc/os/mlsetup.c
index 1f9149d5c4..9487552564 100644
--- a/usr/src/uts/i86pc/os/mlsetup.c
+++ b/usr/src/uts/i86pc/os/mlsetup.c
@@ -23,7 +23,7 @@
  *
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2011 by Delphix. All rights reserved.
- * Copyright 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -65,6 +65,7 @@
 #include <sys/apic_common.h>
 #include <sys/bootvfs.h>
 #include <sys/tsc.h>
+#include <sys/smt.h>
 #ifdef __xpv
 #include <sys/hypervisor.h>
 #else
@@ -185,6 +186,17 @@ mlsetup(struct regs *rp)
 	} else if (kpti_enable != 1) {
 		x86_use_pcid = 0;
 	}
+
+	/*
+	 * While we don't need to check this until later, we might as well do it
+	 * here.
+	 */
+	if (bootprop_getstr("smt_enabled", prop_str, sizeof (prop_str)) == 0) {
+		if (strcasecmp(prop_str, "false") == 0 ||
+		    strcmp(prop_str, "0") == 0)
+			smt_boot_disable = 1;
+	}
+
 #endif
 
 	/*
diff --git a/usr/src/uts/i86pc/os/mp_startup.c b/usr/src/uts/i86pc/os/mp_startup.c
index da629d02c2..844b1279f3 100644
--- a/usr/src/uts/i86pc/os/mp_startup.c
+++ b/usr/src/uts/i86pc/os/mp_startup.c
@@ -1996,6 +1996,10 @@ mp_cpu_stop(struct cpu *cp)
 
 /*
  * Take the specified CPU out of participation in interrupts.
+ *
+ * Usually, we hold cpu_lock. But we cannot assert as such due to the
+ * exception - i_cpr_save_context() - where we have mutual exclusion via a
+ * separate mechanism.
  */
 int
 cpu_disable_intr(struct cpu *cp)
@@ -2004,6 +2008,7 @@ cpu_disable_intr(struct cpu *cp)
 		return (EBUSY);
 
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 	return (0);
 }
 
@@ -2015,6 +2020,7 @@ cpu_enable_intr(struct cpu *cp)
 {
 	ASSERT(MUTEX_HELD(&cpu_lock));
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 	psm_enable_intr(cp->cpu_id);
 }
 
diff --git a/usr/src/uts/i86pc/os/ht.c b/usr/src/uts/i86pc/os/smt.c
similarity index 55%
rename from usr/src/uts/i86pc/os/ht.c
rename to usr/src/uts/i86pc/os/smt.c
index 6e13eaedae..e187ae7578 100644
--- a/usr/src/uts/i86pc/os/ht.c
+++ b/usr/src/uts/i86pc/os/smt.c
@@ -10,11 +10,11 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
- * HT exclusion: prevent a sibling in a hyper-threaded core from running in VMX
+ * SMT exclusion: prevent a sibling in a hyper-threaded core from running in VMX
  * non-root guest mode, when certain threads are running on the other sibling.
  * This avoids speculation-based information leaks such as L1TF being available
  * to the untrusted guest.  The stance we take is that threads from the same
@@ -22,60 +22,61 @@
  * other threads (except the idle thread), and all interrupts, are unsafe.  Note
  * that due to the implementation here, there are significant sections of e.g.
  * the dispatcher code that can run concurrently with a guest, until the thread
- * reaches ht_mark().  This code assumes there are only two HT threads per core.
+ * reaches smt_mark().  This code assumes there are only two SMT threads per
+ * core.
  *
  * The entry points are as follows:
  *
- * ht_mark_as_vcpu()
+ * smt_mark_as_vcpu()
  *
  * All threads that enter guest mode (i.e. VCPU threads) need to call this at
  * least once, which sets TS_VCPU in ->t_schedflag.
  *
- * ht_mark()
+ * smt_mark()
  *
  * A new ->cpu_thread is now curthread (although interrupt threads have their
  * own separate handling).  After preventing any interrupts, we will take our
- * own CPU's spinlock and update our own state in mcpu_ht.
+ * own CPU's spinlock and update our own state in mcpu_smt.
  *
  * If our sibling is poisoned (i.e. in guest mode or the little bit of code
  * around it), and we're not compatible (that is, same zone ID, or the idle
- * thread), then we need to ht_kick() that sibling.  ht_kick() itself waits for
- * the sibling to call ht_release(), and it will not re-enter guest mode until
- * allowed.
+ * thread), then we need to smt_kick() that sibling.  smt_kick() itself waits
+ * for the sibling to call smt_release(), and it will not re-enter guest mode
+ * until allowed.
  *
  * Note that we ignore the fact a process can change its zone ID: poisoning
  * threads never do so, and we can ignore the other cases.
  *
- * ht_acquire()
+ * smt_acquire()
  *
  * We are a VCPU thread about to start guest execution.  Interrupts are
- * disabled.  We must have already run ht_mark() to be in this code, so there's
+ * disabled.  We must have already run smt_mark() to be in this code, so there's
  * no need to take our *own* spinlock in order to mark ourselves as CM_POISONED.
  * Instead, we take our sibling's lock to also mark ourselves as poisoned in the
- * sibling cpu_ht_t.  This is so ht_mark() will only ever need to look at its
- * local mcpu_ht.
+ * sibling cpu_smt_t.  This is so smt_mark() will only ever need to look at its
+ * local mcpu_smt.
  *
- * We'll loop here for up to ht_acquire_wait_time microseconds; this is mainly
+ * We'll loop here for up to smt_acquire_wait_time microseconds; this is mainly
  * to wait out any sibling interrupt: many of them will complete quicker than
  * this.
  *
  * Finally, if we succeeded in acquiring the core, we'll flush the L1 cache as
  * mitigation against L1TF: no incompatible thread will now be able to populate
- * the L1 cache until *we* ht_release().
+ * the L1 cache until *we* smt_release().
  *
- * ht_release()
+ * smt_release()
  *
- * Simply unpoison ourselves similarly to ht_acquire(); ht_kick() will wait for
- * this to happen if needed.
+ * Simply unpoison ourselves similarly to smt_acquire(); smt_kick() will wait
+ * for this to happen if needed.
  *
- * ht_begin_intr()
+ * smt_begin_intr()
  *
  * In an interrupt prolog.  We're either a hilevel interrupt, or a pinning
  * interrupt.  In both cases, we mark our interrupt depth, and potentially
- * ht_kick().  This enforces exclusion, but doesn't otherwise modify ->ch_state:
- * we want the dispatcher code to essentially ignore interrupts.
+ * smt_kick().  This enforces exclusion, but doesn't otherwise modify
+ * ->cs_state: we want the dispatcher code to essentially ignore interrupts.
  *
- * ht_end_intr()
+ * smt_end_intr()
  *
  * In an interrupt epilogue *or* thread_unpin().  In the first case, we never
  * slept, and we can simply decrement our counter.  In the second case, we're an
@@ -83,7 +84,7 @@
  * henceforth treat the thread as a normal thread when it next gets scheduled,
  * until it finally gets to its epilogue.
  *
- * ht_mark_unsafe() / ht_mark_safe()
+ * smt_mark_unsafe() / smt_mark_safe()
  *
  * Mark the current thread as temporarily unsafe (guests should not be executing
  * while a sibling is marked unsafe).  This can be used for a thread that's
@@ -91,19 +92,25 @@
  * Right now, this means certain I/O handling operations that reach down into
  * the networking and ZFS sub-systems.
  *
- * ht_should_run(thread, cpu)
+ * smt_should_run(thread, cpu)
  *
  * This is used by the dispatcher when making scheduling decisions: if the
  * sibling is compatible with the given thread, we return B_TRUE. This is
- * essentially trying to guess if any subsequent ht_acquire() will fail, by
+ * essentially trying to guess if any subsequent smt_acquire() will fail, by
  * peeking at the sibling CPU's state.  The peek is racy, but if we get things
- * wrong, the "only" consequence is that ht_acquire() may lose.
+ * wrong, the "only" consequence is that smt_acquire() may lose.
  *
- * ht_adjust_cpu_score()
+ * smt_adjust_cpu_score()
  *
  * Used when scoring other CPUs in disp_lowpri_cpu().  If we shouldn't run here,
  * we'll add a small penalty to the score.  This also makes sure a VCPU thread
  * migration behaves properly.
+ *
+ * smt_init() / smt_late_init()
+ *
+ * Set up SMT handling. If smt_boot_disable is set, smt_late_init(), which runs
+ * late enough to be able to do so, will offline and mark CPU_DISABLED all the
+ * siblings. smt_disable() can also be called after boot via psradm -Ha.
  */
 
 #include <sys/archsystm.h>
@@ -116,6 +123,10 @@
 #include <sys/cmn_err.h>
 #include <sys/sysmacros.h>
 #include <sys/x86_archext.h>
+#include <sys/esunddi.h>
+#include <sys/promif.h>
+#include <sys/policy.h>
+#include <sys/smt.h>
 
 #define	CS_SHIFT (8)
 #define	CS_MASK ((1 << CS_SHIFT) - 1)
@@ -123,16 +134,16 @@
 #define	CS_ZONE(s) ((s) >> CS_SHIFT)
 #define	CS_MK(s, z) ((s) | (z << CS_SHIFT))
 
-typedef enum ch_mark {
+typedef enum cs_mark {
 	CM_IDLE = 0,	/* running CPU idle thread */
 	CM_THREAD,	/* running general non-VCPU thread */
 	CM_UNSAFE,	/* running ->t_unsafe thread */
 	CM_VCPU,	/* running VCPU thread */
 	CM_POISONED	/* running in guest */
-} ch_mark_t;
+} cs_mark_t;
 
 /* Double-check our false-sharing padding. */
-CTASSERT(offsetof(cpu_ht_t, ch_sib) == 64);
+CTASSERT(offsetof(cpu_smt_t, cs_sib) == 64);
 CTASSERT(CM_IDLE == 0);
 CTASSERT(CM_POISONED < (1 << CS_SHIFT));
 CTASSERT(CM_POISONED > CM_VCPU);
@@ -141,77 +152,28 @@ CTASSERT(CM_VCPU > CM_UNSAFE);
 static uint_t empty_pil = XC_CPUPOKE_PIL;
 
 /*
- * If disabled, no HT exclusion is performed, and system is potentially
+ * If disabled, no SMT exclusion is performed, and system is potentially
  * vulnerable to L1TF if hyper-threading is enabled, and we don't have the "not
  * vulnerable" CPUID bit.
  */
-int ht_exclusion = 1;
+int smt_exclusion = 1;
 
 /*
- * How long ht_acquire() will spin trying to acquire the core, in micro-seconds.
- * This is enough time to wait out a significant proportion of interrupts.
+ * How long smt_acquire() will spin trying to acquire the core, in
+ * micro-seconds.  This is enough time to wait out a significant proportion of
+ * interrupts.
  */
-clock_t ht_acquire_wait_time = 64;
-
-static cpu_t *
-ht_find_sibling(cpu_t *cp)
-{
-	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
-		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
-		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
-
-		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
-			continue;
-
-		if (GROUP_SIZE(cg) == 1)
-			break;
-
-		VERIFY3U(GROUP_SIZE(cg), ==, 2);
-
-		if (GROUP_ACCESS(cg, 0) != cp)
-			return (GROUP_ACCESS(cg, 0));
-
-		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
-
-		return (GROUP_ACCESS(cg, 1));
-	}
-
-	return (NULL);
-}
+clock_t smt_acquire_wait_time = 64;
 
 /*
- * Initialize HT links.  We have to be careful here not to race with
- * ht_begin/end_intr(), which also complicates trying to do this initialization
- * from a cross-call; hence the slightly odd approach below.
+ * Did we request a disable of SMT at boot time?
  */
-void
-ht_init(void)
-{
-	cpu_t *scp = CPU;
-	cpu_t *cp = scp;
-	ulong_t flags;
-
-	if (!ht_exclusion)
-		return;
-
-	mutex_enter(&cpu_lock);
-
-	do {
-		thread_affinity_set(curthread, cp->cpu_id);
-		flags = intr_clear();
-
-		cp->cpu_m.mcpu_ht.ch_intr_depth = 0;
-		cp->cpu_m.mcpu_ht.ch_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		cp->cpu_m.mcpu_ht.ch_sibstate = CS_MK(CM_THREAD, GLOBAL_ZONEID);
-		ASSERT3P(cp->cpu_m.mcpu_ht.ch_sib, ==, NULL);
-		cp->cpu_m.mcpu_ht.ch_sib = ht_find_sibling(cp);
+int smt_boot_disable;
 
-		intr_restore(flags);
-		thread_affinity_clear(curthread);
-	} while ((cp = cp->cpu_next_onln) != scp);
-
-	mutex_exit(&cpu_lock);
-}
+/*
+ * Whether SMT is enabled.
+ */
+int smt_enabled = 1;
 
 /*
  * We're adding an interrupt handler of some kind at the given PIL.  If this
@@ -222,7 +184,7 @@ ht_init(void)
  * removed.  This also presumes that softints can't cover our empty_pil.
  */
 void
-ht_intr_alloc_pil(uint_t pil)
+smt_intr_alloc_pil(uint_t pil)
 {
 	ASSERT(pil <= PIL_MAX);
 
@@ -250,13 +212,13 @@ ht_intr_alloc_pil(uint_t pil)
 static boolean_t
 yield_to_vcpu(cpu_t *sib, zoneid_t zoneid)
 {
-	cpu_ht_t *sibht = &sib->cpu_m.mcpu_ht;
-	uint64_t sibstate = sibht->ch_state;
+	cpu_smt_t *sibsmt = &sib->cpu_m.mcpu_smt;
+	uint64_t sibstate = sibsmt->cs_state;
 
 	/*
 	 * If we're likely just waiting for an interrupt, don't yield.
 	 */
-	if (sibht->ch_intr_depth != 0)
+	if (sibsmt->cs_intr_depth != 0)
 		return (B_FALSE);
 
 	/*
@@ -276,11 +238,11 @@ yield_to_vcpu(cpu_t *sib, zoneid_t zoneid)
 }
 
 static inline boolean_t
-sibling_compatible(cpu_ht_t *sibht, zoneid_t zoneid)
+sibling_compatible(cpu_smt_t *sibsmt, zoneid_t zoneid)
 {
-	uint64_t sibstate = sibht->ch_state;
+	uint64_t sibstate = sibsmt->cs_state;
 
-	if (sibht->ch_intr_depth != 0)
+	if (sibsmt->cs_intr_depth != 0)
 		return (B_FALSE);
 
 	if (CS_MARK(sibstate) == CM_UNSAFE)
@@ -293,57 +255,58 @@ sibling_compatible(cpu_ht_t *sibht, zoneid_t zoneid)
 }
 
 int
-ht_acquire(void)
+smt_acquire(void)
 {
-	clock_t wait = ht_acquire_wait_time;
-	cpu_ht_t *ht = &CPU->cpu_m.mcpu_ht;
+	clock_t wait = smt_acquire_wait_time;
+	cpu_smt_t *smt = &CPU->cpu_m.mcpu_smt;
 	zoneid_t zoneid = getzoneid();
-	cpu_ht_t *sibht;
+	cpu_smt_t *sibsmt;
 	int ret = 0;
 
 	ASSERT(!interrupts_enabled());
 
-	if (ht->ch_sib == NULL) {
+	if (smt->cs_sib == NULL) {
 		/* For the "sequential" L1TF case. */
 		spec_l1d_flush();
 		return (1);
 	}
 
-	sibht = &ht->ch_sib->cpu_m.mcpu_ht;
+	sibsmt = &smt->cs_sib->cpu_m.mcpu_smt;
 
 	/* A VCPU thread should never change zone. */
-	ASSERT3U(CS_ZONE(ht->ch_state), ==, zoneid);
-	ASSERT3U(CS_MARK(ht->ch_state), ==, CM_VCPU);
+	ASSERT3U(CS_ZONE(smt->cs_state), ==, zoneid);
+	ASSERT3U(CS_MARK(smt->cs_state), ==, CM_VCPU);
 	ASSERT3U(zoneid, !=, GLOBAL_ZONEID);
 	ASSERT3U(curthread->t_preempt, >=, 1);
 	ASSERT(curthread->t_schedflag & TS_VCPU);
 
 	while (ret == 0 && wait > 0) {
 
-		if (yield_to_vcpu(ht->ch_sib, zoneid)) {
+		if (yield_to_vcpu(smt->cs_sib, zoneid)) {
 			ret = -1;
 			break;
 		}
 
-		if (sibling_compatible(sibht, zoneid)) {
-			lock_set(&sibht->ch_lock);
+		if (sibling_compatible(sibsmt, zoneid)) {
+			lock_set(&sibsmt->cs_lock);
 
-			if (sibling_compatible(sibht, zoneid)) {
-				ht->ch_state = CS_MK(CM_POISONED, zoneid);
-				sibht->ch_sibstate = CS_MK(CM_POISONED, zoneid);
+			if (sibling_compatible(sibsmt, zoneid)) {
+				smt->cs_state = CS_MK(CM_POISONED, zoneid);
+				sibsmt->cs_sibstate = CS_MK(CM_POISONED,
+				    zoneid);
 				membar_enter();
 				ret = 1;
 			}
 
-			lock_clear(&sibht->ch_lock);
+			lock_clear(&sibsmt->cs_lock);
 		} else {
 			drv_usecwait(10);
 			wait -= 10;
 		}
 	}
 
-	DTRACE_PROBE4(ht__acquire, int, ret, uint64_t, sibht->ch_state,
-	    uint64_t, sibht->ch_intr_depth, clock_t, wait);
+	DTRACE_PROBE4(smt__acquire, int, ret, uint64_t, sibsmt->cs_state,
+	    uint64_t, sibsmt->cs_intr_depth, clock_t, wait);
 
 	if (ret == 1)
 		spec_l1d_flush();
@@ -352,50 +315,50 @@ ht_acquire(void)
 }
 
 void
-ht_release(void)
+smt_release(void)
 {
-	cpu_ht_t *ht = &CPU->cpu_m.mcpu_ht;
+	cpu_smt_t *smt = &CPU->cpu_m.mcpu_smt;
 	zoneid_t zoneid = getzoneid();
-	cpu_ht_t *sibht;
+	cpu_smt_t *sibsmt;
 
 	ASSERT(!interrupts_enabled());
 
-	if (ht->ch_sib == NULL)
+	if (smt->cs_sib == NULL)
 		return;
 
 	ASSERT3U(zoneid, !=, GLOBAL_ZONEID);
-	ASSERT3U(CS_ZONE(ht->ch_state), ==, zoneid);
-	ASSERT3U(CS_MARK(ht->ch_state), ==, CM_POISONED);
+	ASSERT3U(CS_ZONE(smt->cs_state), ==, zoneid);
+	ASSERT3U(CS_MARK(smt->cs_state), ==, CM_POISONED);
 	ASSERT3U(curthread->t_preempt, >=, 1);
 
-	sibht = &ht->ch_sib->cpu_m.mcpu_ht;
+	sibsmt = &smt->cs_sib->cpu_m.mcpu_smt;
 
-	lock_set(&sibht->ch_lock);
+	lock_set(&sibsmt->cs_lock);
 
-	ht->ch_state = CS_MK(CM_VCPU, zoneid);
-	sibht->ch_sibstate = CS_MK(CM_VCPU, zoneid);
+	smt->cs_state = CS_MK(CM_VCPU, zoneid);
+	sibsmt->cs_sibstate = CS_MK(CM_VCPU, zoneid);
 	membar_producer();
 
-	lock_clear(&sibht->ch_lock);
+	lock_clear(&sibsmt->cs_lock);
 }
 
 static void
-ht_kick(cpu_ht_t *ht, zoneid_t zoneid)
+smt_kick(cpu_smt_t *smt, zoneid_t zoneid)
 {
 	uint64_t sibstate;
 
-	ASSERT(LOCK_HELD(&ht->ch_lock));
+	ASSERT(LOCK_HELD(&smt->cs_lock));
 	ASSERT(!interrupts_enabled());
 
-	poke_cpu(ht->ch_sib->cpu_id);
+	poke_cpu(smt->cs_sib->cpu_id);
 
 	membar_consumer();
-	sibstate = ht->ch_sibstate;
+	sibstate = smt->cs_sibstate;
 
 	if (CS_MARK(sibstate) != CM_POISONED || CS_ZONE(sibstate) == zoneid)
 		return;
 
-	lock_clear(&ht->ch_lock);
+	lock_clear(&smt->cs_lock);
 
 	/*
 	 * Spin until we can see the sibling has been kicked out or is otherwise
@@ -403,7 +366,7 @@ ht_kick(cpu_ht_t *ht, zoneid_t zoneid)
 	 */
 	for (;;) {
 		membar_consumer();
-		sibstate = ht->ch_sibstate;
+		sibstate = smt->cs_sibstate;
 
 		if (CS_MARK(sibstate) != CM_POISONED ||
 		    CS_ZONE(sibstate) == zoneid)
@@ -412,7 +375,7 @@ ht_kick(cpu_ht_t *ht, zoneid_t zoneid)
 		SMT_PAUSE();
 	}
 
-	lock_set(&ht->ch_lock);
+	lock_set(&smt->cs_lock);
 }
 
 static boolean_t
@@ -422,106 +385,106 @@ pil_needs_kick(uint_t pil)
 }
 
 void
-ht_begin_intr(uint_t pil)
+smt_begin_intr(uint_t pil)
 {
 	ulong_t flags;
-	cpu_ht_t *ht;
+	cpu_smt_t *smt;
 
 	ASSERT(pil <= PIL_MAX);
 
 	flags = intr_clear();
-	ht = &CPU->cpu_m.mcpu_ht;
+	smt = &CPU->cpu_m.mcpu_smt;
 
-	if (ht->ch_sib == NULL) {
+	if (smt->cs_sib == NULL) {
 		intr_restore(flags);
 		return;
 	}
 
-	if (atomic_inc_64_nv(&ht->ch_intr_depth) == 1 && pil_needs_kick(pil)) {
-		lock_set(&ht->ch_lock);
+	if (atomic_inc_64_nv(&smt->cs_intr_depth) == 1 && pil_needs_kick(pil)) {
+		lock_set(&smt->cs_lock);
 
 		membar_consumer();
 
-		if (CS_MARK(ht->ch_sibstate) == CM_POISONED)
-			ht_kick(ht, GLOBAL_ZONEID);
+		if (CS_MARK(smt->cs_sibstate) == CM_POISONED)
+			smt_kick(smt, GLOBAL_ZONEID);
 
-		lock_clear(&ht->ch_lock);
+		lock_clear(&smt->cs_lock);
 	}
 
 	intr_restore(flags);
 }
 
 void
-ht_end_intr(void)
+smt_end_intr(void)
 {
 	ulong_t flags;
-	cpu_ht_t *ht;
+	cpu_smt_t *smt;
 
 	flags = intr_clear();
-	ht = &CPU->cpu_m.mcpu_ht;
+	smt = &CPU->cpu_m.mcpu_smt;
 
-	if (ht->ch_sib == NULL) {
+	if (smt->cs_sib == NULL) {
 		intr_restore(flags);
 		return;
 	}
 
-	ASSERT3U(ht->ch_intr_depth, >, 0);
-	atomic_dec_64(&ht->ch_intr_depth);
+	ASSERT3U(smt->cs_intr_depth, >, 0);
+	atomic_dec_64(&smt->cs_intr_depth);
 
 	intr_restore(flags);
 }
 
 static inline boolean_t
-ht_need_kick(cpu_ht_t *ht, zoneid_t zoneid)
+smt_need_kick(cpu_smt_t *smt, zoneid_t zoneid)
 {
 	membar_consumer();
 
-	if (CS_MARK(ht->ch_sibstate) != CM_POISONED)
+	if (CS_MARK(smt->cs_sibstate) != CM_POISONED)
 		return (B_FALSE);
 
-	if (CS_MARK(ht->ch_state) == CM_UNSAFE)
+	if (CS_MARK(smt->cs_state) == CM_UNSAFE)
 		return (B_TRUE);
 
-	return (CS_ZONE(ht->ch_sibstate) != zoneid);
+	return (CS_ZONE(smt->cs_sibstate) != zoneid);
 }
 
 void
-ht_mark(void)
+smt_mark(void)
 {
 	zoneid_t zoneid = getzoneid();
 	kthread_t *t = curthread;
 	ulong_t flags;
-	cpu_ht_t *ht;
+	cpu_smt_t *smt;
 	cpu_t *cp;
 
 	flags = intr_clear();
 
 	cp = CPU;
-	ht = &cp->cpu_m.mcpu_ht;
+	smt = &cp->cpu_m.mcpu_smt;
 
-	if (ht->ch_sib == NULL) {
+	if (smt->cs_sib == NULL) {
 		intr_restore(flags);
 		return;
 	}
 
-	lock_set(&ht->ch_lock);
+	lock_set(&smt->cs_lock);
 
 	/*
 	 * If we were a nested interrupt and went through the resume_from_intr()
 	 * path, we can now be resuming to a pinning interrupt thread; in which
 	 * case, skip marking, until we later resume to a "real" thread.
 	 */
-	if (ht->ch_intr_depth > 0) {
+	if (smt->cs_intr_depth > 0) {
 		ASSERT3P(t->t_intr, !=, NULL);
 
-		if (ht_need_kick(ht, zoneid))
-			ht_kick(ht, zoneid);
+		if (smt_need_kick(smt, zoneid))
+			smt_kick(smt, zoneid);
 		goto out;
 	}
 
 	if (t == t->t_cpu->cpu_idle_thread) {
 		ASSERT3U(zoneid, ==, GLOBAL_ZONEID);
-		ht->ch_state = CS_MK(CM_IDLE, zoneid);
+		smt->cs_state = CS_MK(CM_IDLE, zoneid);
 	} else {
 		uint64_t state = CM_THREAD;
 
@@ -530,44 +493,44 @@ ht_mark(void)
 		else if (t->t_schedflag & TS_VCPU)
 			state = CM_VCPU;
 
-		ht->ch_state = CS_MK(state, zoneid);
+		smt->cs_state = CS_MK(state, zoneid);
 
-		if (ht_need_kick(ht, zoneid))
-			ht_kick(ht, zoneid);
+		if (smt_need_kick(smt, zoneid))
+			smt_kick(smt, zoneid);
 	}
 
 out:
 	membar_producer();
-	lock_clear(&ht->ch_lock);
+	lock_clear(&smt->cs_lock);
 	intr_restore(flags);
 }
 
 void
-ht_begin_unsafe(void)
+smt_begin_unsafe(void)
 {
 	curthread->t_unsafe++;
-	ht_mark();
+	smt_mark();
 }
 
 void
-ht_end_unsafe(void)
+smt_end_unsafe(void)
 {
 	ASSERT3U(curthread->t_unsafe, >, 0);
 	curthread->t_unsafe--;
-	ht_mark();
+	smt_mark();
 }
 
 void
-ht_mark_as_vcpu(void)
+smt_mark_as_vcpu(void)
 {
 	thread_lock(curthread);
 	curthread->t_schedflag |= TS_VCPU;
-	ht_mark();
+	smt_mark();
 	thread_unlock(curthread);
 }
 
 boolean_t
-ht_should_run(kthread_t *t, cpu_t *cp)
+smt_should_run(kthread_t *t, cpu_t *cp)
 {
 	uint64_t sibstate;
 	cpu_t *sib;
@@ -575,10 +538,10 @@ ht_should_run(kthread_t *t, cpu_t *cp)
 	if (t == t->t_cpu->cpu_idle_thread)
 		return (B_TRUE);
 
-	if ((sib = cp->cpu_m.mcpu_ht.ch_sib) == NULL)
+	if ((sib = cp->cpu_m.mcpu_smt.cs_sib) == NULL)
 		return (B_TRUE);
 
-	sibstate = sib->cpu_m.mcpu_ht.ch_state;
+	sibstate = sib->cpu_m.mcpu_smt.cs_state;
 
 	if ((t->t_schedflag & TS_VCPU)) {
 		if (CS_MARK(sibstate) == CM_IDLE)
@@ -595,14 +558,14 @@ ht_should_run(kthread_t *t, cpu_t *cp)
 }
 
 pri_t
-ht_adjust_cpu_score(kthread_t *t, struct cpu *cp, pri_t score)
+smt_adjust_cpu_score(kthread_t *t, struct cpu *cp, pri_t score)
 {
-	if (ht_should_run(t, cp))
+	if (smt_should_run(t, cp))
 		return (score);
 
 	/*
 	 * If we're a VCPU thread scoring our current CPU, we are most likely
-	 * asking to be rescheduled elsewhere after losing ht_acquire().  In
+	 * asking to be rescheduled elsewhere after losing smt_acquire().  In
 	 * this case, the current CPU is not a good choice, most likely, and we
 	 * should go elsewhere.
 	 */
@@ -611,3 +574,201 @@ ht_adjust_cpu_score(kthread_t *t, struct cpu *cp, pri_t score)
 
 	return (score + 1);
 }
+
+static void
+set_smt_prop(void)
+{
+	(void) e_ddi_prop_update_string(DDI_DEV_T_NONE, ddi_root_node(),
+	    "smt_enabled", smt_enabled ? "true" : "false");
+}
+
+static cpu_t *
+smt_find_sibling(cpu_t *cp)
+{
+	for (uint_t i = 0; i < GROUP_SIZE(&cp->cpu_pg->cmt_pgs); i++) {
+		pg_cmt_t *pg = GROUP_ACCESS(&cp->cpu_pg->cmt_pgs, i);
+		group_t *cg = &pg->cmt_pg.pghw_pg.pg_cpus;
+
+		if (pg->cmt_pg.pghw_hw != PGHW_IPIPE)
+			continue;
+
+		if (GROUP_SIZE(cg) == 1)
+			break;
+
+		if (GROUP_SIZE(cg) != 2) {
+			panic("%u SMT threads unsupported", GROUP_SIZE(cg));
+		}
+
+		if (GROUP_ACCESS(cg, 0) != cp)
+			return (GROUP_ACCESS(cg, 0));
+
+		VERIFY3P(GROUP_ACCESS(cg, 1), !=, cp);
+
+		return (GROUP_ACCESS(cg, 1));
+	}
+
+	return (NULL);
+}
+
+/*
+ * Offline all siblings and mark as CPU_DISABLED. Note that any siblings that
+ * can't be offlined (if it would leave an empty partition, or it's a spare, or
+ * whatever) will fail the whole operation.
+ */
+int
+smt_disable(void)
+{
+	int error = 0;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (secpolicy_ponline(CRED()) != 0)
+		return (EPERM);
+
+	if (!smt_enabled)
+		return (0);
+
+	for (size_t i = 0; i < NCPU; i++) {
+		cpu_t *sib;
+		cpu_t *cp;
+
+		if ((cp = cpu_get(i)) == NULL)
+			continue;
+
+		/* NB: we don't necessarily have .mcpu_smt to use here. */
+		if ((sib = smt_find_sibling(cp)) == NULL)
+			continue;
+
+		if (cp->cpu_id < sib->cpu_id)
+			continue;
+
+		if (cp->cpu_flags & CPU_DISABLED) {
+			VERIFY(cp->cpu_flags & CPU_OFFLINE);
+			continue;
+		}
+
+		if (cp->cpu_flags & (CPU_FAULTED | CPU_SPARE)) {
+			error = EINVAL;
+			break;
+		}
+
+		if ((cp->cpu_flags & (CPU_READY | CPU_OFFLINE)) != CPU_READY) {
+			cp->cpu_flags |= CPU_DISABLED;
+			continue;
+		}
+
+		if ((error = cpu_offline(cp, CPU_FORCED)) != 0)
+			break;
+
+		cp->cpu_flags |= CPU_DISABLED;
+		cpu_set_state(cp);
+	}
+
+	if (error != 0)
+		return (error);
+
+	smt_enabled = 0;
+	set_smt_prop();
+	cmn_err(CE_NOTE, "!SMT / hyper-threading explicitly disabled.");
+	return (0);
+}
+
+boolean_t
+smt_can_enable(cpu_t *cp, int flags)
+{
+	VERIFY(cp->cpu_flags & CPU_DISABLED);
+
+	return (!smt_boot_disable && (flags & CPU_FORCED));
+}
+
+/*
+ * If we force-onlined a CPU_DISABLED CPU, then we can no longer consider the
+ * system to be SMT-disabled in toto.
+ */
+void
+smt_force_enabled(void)
+{
+	VERIFY(!smt_boot_disable);
+
+	if (!smt_enabled)
+		cmn_err(CE_NOTE, "!Disabled SMT sibling forced on-line.");
+
+	smt_enabled = 1;
+	set_smt_prop();
+}
+
+/*
+ * Initialize SMT links.  We have to be careful here not to race with
+ * smt_begin/end_intr(), which also complicates trying to do this initialization
+ * from a cross-call; hence the slightly odd approach below.
+ *
+ * If we're going to disable SMT via smt_late_init(), we will avoid paying the
+ * price here at all (we can't do it here since we're still too early in
+ * main()).
+ */
+void
+smt_init(void)
+{
+	boolean_t found_sibling = B_FALSE;
+	cpu_t *scp = CPU;
+	cpu_t *cp = scp;
+	ulong_t flags;
+
+	if (!smt_exclusion || smt_boot_disable)
+		return;
+
+	mutex_enter(&cpu_lock);
+
+	do {
+		thread_affinity_set(curthread, cp->cpu_id);
+		flags = intr_clear();
+
+		cp->cpu_m.mcpu_smt.cs_intr_depth = 0;
+		cp->cpu_m.mcpu_smt.cs_state = CS_MK(CM_THREAD, GLOBAL_ZONEID);
+		cp->cpu_m.mcpu_smt.cs_sibstate = CS_MK(CM_THREAD,
+		    GLOBAL_ZONEID);
+		ASSERT3P(cp->cpu_m.mcpu_smt.cs_sib, ==, NULL);
+		cp->cpu_m.mcpu_smt.cs_sib = smt_find_sibling(cp);
+
+		if (cp->cpu_m.mcpu_smt.cs_sib != NULL)
+			found_sibling = B_TRUE;
+
+		intr_restore(flags);
+		thread_affinity_clear(curthread);
+	} while ((cp = cp->cpu_next_onln) != scp);
+
+	mutex_exit(&cpu_lock);
+
+	if (!found_sibling)
+		smt_enabled = 0;
+}
+
+void
+smt_late_init(void)
+{
+	int err;
+
+	if (smt_boot_disable) {
+		int err;
+
+		mutex_enter(&cpu_lock);
+
+		err = smt_disable();
+
+		/*
+		 * We're early enough in boot that nothing should have stopped
+		 * us from offlining the siblings. As we didn't prepare our
+		 * L1TF mitigation in this case, we need to panic.
+		 */
+		if (err) {
+			cmn_err(CE_PANIC, "smt_disable() failed with %d", err);
+		}
+
+		mutex_exit(&cpu_lock);
+	}
+
+	if (smt_enabled)
+		cmn_err(CE_NOTE, "!SMT enabled\n");
+
+	set_smt_prop();
+}
diff --git a/usr/src/uts/i86pc/sys/Makefile b/usr/src/uts/i86pc/sys/Makefile
index ecd87a9538..3d8332a930 100644
--- a/usr/src/uts/i86pc/sys/Makefile
+++ b/usr/src/uts/i86pc/sys/Makefile
@@ -21,7 +21,7 @@
 #
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-# Copyright 2018 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 # uts/i86pc/sys/Makefile
 #
@@ -47,7 +47,6 @@ CHKHDRS=  \
 	debug_info.h	\
 	fastboot.h	\
 	hma.h		\
-	ht.h		\
 	mach_mmu.h	\
 	machclock.h	\
 	machcpuvar.h	\
@@ -62,8 +61,9 @@ CHKHDRS=  \
 	psm_modctl.h	\
 	psm_types.h	\
 	rm_platter.h	\
-	smp_impldefs.h	\
 	sbd_ioctl.h	\
+	smp_impldefs.h	\
+	smt.h		\
 	vm_machparam.h	\
 	x_call.h	\
 	xc_levels.h	\
diff --git a/usr/src/uts/i86pc/sys/ht.h b/usr/src/uts/i86pc/sys/ht.h
deleted file mode 100644
index 8bb5a0d6d2..0000000000
--- a/usr/src/uts/i86pc/sys/ht.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2018 Joyent, Inc.
- */
-
-#ifndef	_SYS_HT_H
-#define	_SYS_HT_H
-
-#include <sys/types.h>
-#include <sys/thread.h>
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-struct cpu;
-
-extern void ht_init(void);
-extern void ht_intr_alloc_pil(uint_t);
-
-extern int ht_acquire(void);
-extern void ht_release(void);
-extern void ht_mark(void);
-extern void ht_begin_unsafe(void);
-extern void ht_end_unsafe(void);
-extern void ht_begin_intr(uint_t);
-extern void ht_end_intr(void);
-extern void ht_mark_as_vcpu(void);
-
-extern boolean_t ht_should_run(kthread_t *, struct cpu *);
-extern pri_t ht_adjust_cpu_score(kthread_t *, struct cpu *, pri_t);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _SYS_HT_H */
diff --git a/usr/src/uts/i86pc/sys/machcpuvar.h b/usr/src/uts/i86pc/sys/machcpuvar.h
index 953d3bf4ff..772f3112cb 100644
--- a/usr/src/uts/i86pc/sys/machcpuvar.h
+++ b/usr/src/uts/i86pc/sys/machcpuvar.h
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef	_SYS_MACHCPUVAR_H
@@ -140,14 +140,14 @@ struct kpti_frame {
 	uint64_t	kf_upper_redzone;
 };
 
-typedef struct cpu_ht {
-	lock_t ch_lock;
-	char ch_pad[56];
-	struct cpu *ch_sib;
-	volatile uint64_t ch_intr_depth;
-	volatile uint64_t ch_state;
-	volatile uint64_t ch_sibstate;
-} cpu_ht_t;
+typedef struct cpu_smt {
+	lock_t cs_lock;
+	char cs_pad[56];
+	struct cpu *cs_sib;
+	volatile uint64_t cs_intr_depth;
+	volatile uint64_t cs_state;
+	volatile uint64_t cs_sibstate;
+} cpu_smt_t;
 
 /*
  * This first value, MACHCPU_SIZE is the size of all the members in the cpu_t
@@ -237,7 +237,7 @@ struct	machcpu {
 	 */
 	volatile uint32_t	mcpu_istamp;
 
-	cpu_ht_t		mcpu_ht;
+	cpu_smt_t		mcpu_smt;
 
 	char			mcpu_pad[MACHCPU_PAD];
 
diff --git a/usr/src/uts/i86pc/sys/smt.h b/usr/src/uts/i86pc/sys/smt.h
new file mode 100644
index 0000000000..f539d13799
--- /dev/null
+++ b/usr/src/uts/i86pc/sys/smt.h
@@ -0,0 +1,54 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#ifndef	_SYS_SMT_H
+#define	_SYS_SMT_H
+
+#include <sys/types.h>
+#include <sys/thread.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+struct cpu;
+
+extern int smt_boot_disable;
+
+extern void smt_init(void);
+extern void smt_late_init(void);
+extern int smt_disable(void);
+extern boolean_t smt_can_enable(struct cpu *, int);
+extern void smt_force_enabled(void);
+
+extern void smt_intr_alloc_pil(uint_t);
+
+extern int smt_acquire(void);
+extern void smt_release(void);
+extern void smt_mark(void);
+extern void smt_begin_unsafe(void);
+extern void smt_end_unsafe(void);
+extern void smt_begin_intr(uint_t);
+extern void smt_end_intr(void);
+extern void smt_mark_as_vcpu(void);
+
+extern boolean_t smt_should_run(kthread_t *, struct cpu *);
+extern pri_t smt_adjust_cpu_score(kthread_t *, struct cpu *, pri_t);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SYS_SMT_H */
diff --git a/usr/src/uts/i86xpv/Makefile.files b/usr/src/uts/i86xpv/Makefile.files
index a36a0abcea..edb7e8c0c5 100644
--- a/usr/src/uts/i86xpv/Makefile.files
+++ b/usr/src/uts/i86xpv/Makefile.files
@@ -22,7 +22,7 @@
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 #	This Makefile defines file modules in the directory uts/i86xpv
@@ -61,7 +61,6 @@ CORE_OBJS +=			\
 	hment.o			\
 	hold_page.o		\
 	hrtimers.o		\
-	ht.o			\
 	htable.o		\
 	i86_mmu.o		\
 	ibft.o			\
@@ -95,6 +94,7 @@ CORE_OBJS +=			\
 	pci_orion.o		\
 	pmem.o			\
 	ppage.o			\
+	smt.o			\
 	startup.o		\
 	ssp.o			\
 	xpv_timestamp.o		\
diff --git a/usr/src/uts/i86xpv/os/mp_xen.c b/usr/src/uts/i86xpv/os/mp_xen.c
index 02eda1c755..3f24dc1d84 100644
--- a/usr/src/uts/i86xpv/os/mp_xen.c
+++ b/usr/src/uts/i86xpv/os/mp_xen.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 /*
  * Virtual CPU management.
  *
@@ -681,6 +685,9 @@ poweroff_vcpu(struct cpu *cp)
 
 		CPUSET_DEL(cpu_ready_set, cp->cpu_id);
 
+		if (cp->cpu_flags & CPU_ENABLE)
+			ncpus_intr_enabled--;
+
 		cp->cpu_flags |= CPU_POWEROFF | CPU_OFFLINE;
 		cp->cpu_flags &=
 		    ~(CPU_RUNNING | CPU_READY | CPU_EXISTS | CPU_ENABLE);
diff --git a/usr/src/uts/intel/ia32/ml/swtch.s b/usr/src/uts/intel/ia32/ml/swtch.s
index c2c9fd9bd2..4f27c58be8 100644
--- a/usr/src/uts/intel/ia32/ml/swtch.s
+++ b/usr/src/uts/intel/ia32/ml/swtch.s
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -343,7 +343,7 @@
 	call	smap_disable
 .nosmap:
 
-	call	ht_mark
+	call	smt_mark
 
 	/*
 	 * Restore non-volatile registers, then have spl0 return to the
@@ -465,7 +465,7 @@ resume_from_zombie_return:
 
 	STORE_INTR_START(%r12)
 
-	call	ht_mark
+	call	smt_mark
 
 	/*
 	 * Restore non-volatile registers, then have spl0 return to the
diff --git a/usr/src/uts/sun4/os/intr.c b/usr/src/uts/sun4/os/intr.c
index 3a7143115d..dfcbd991f7 100644
--- a/usr/src/uts/sun4/os/intr.c
+++ b/usr/src/uts/sun4/os/intr.c
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 /*
  * Copyright 2019 Peter Tribble.
@@ -326,7 +326,7 @@ siron_cpu_setup(cpu_setup_t what, int id, void *arg)
 
 /*
  * no_ivintr()
- * 	called by setvecint_tl1() through sys_trap()
+ *	called by setvecint_tl1() through sys_trap()
  *	vector interrupt received but not valid or not
  *	registered in intr_vec_table
  *	considered as a spurious mondo interrupt
@@ -420,6 +420,7 @@ cpu_disable_intr(struct cpu *cp)
 	 * function, since it checks for this in the cpu flags.
 	 */
 	cp->cpu_flags &= ~CPU_ENABLE;
+	ncpus_intr_enabled--;
 
 	intr_redist_all_cpus();
 
@@ -438,6 +439,7 @@ cpu_enable_intr(struct cpu *cp)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp->cpu_flags |= CPU_ENABLE;
+	ncpus_intr_enabled++;
 
 	intr_redist_all_cpus();
 }
diff --git a/usr/src/uts/sun4/os/mp_startup.c b/usr/src/uts/sun4/os/mp_startup.c
index ae68a23f8b..8cf6e1fa81 100644
--- a/usr/src/uts/sun4/os/mp_startup.c
+++ b/usr/src/uts/sun4/os/mp_startup.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 #include <sys/sysmacros.h>
 #include <sys/prom_plat.h>
 #include <sys/prom_debug.h>
@@ -162,6 +166,10 @@ cold_flag_set(int cpuid)
 	ASSERT(MUTEX_HELD(&cpu_lock));
 
 	cp = cpu[cpuid];
+
+	if (!(cpu->cpu_flags & CPU_ENABLE))
+		ncpus_intr_enabled++;
+
 	cp->cpu_flags |= CPU_RUNNING | CPU_ENABLE | CPU_EXISTS;
 	cpu_add_active(cp);
 	/*
diff --git a/usr/src/uts/sun4/sys/ht.h b/usr/src/uts/sun4/sys/smt.h
similarity index 56%
rename from usr/src/uts/sun4/sys/ht.h
rename to usr/src/uts/sun4/sys/smt.h
index 6d7b3e37cc..0f3576491d 100644
--- a/usr/src/uts/sun4/sys/ht.h
+++ b/usr/src/uts/sun4/sys/smt.h
@@ -10,11 +10,11 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
-#ifndef	_SYS_HT_H
-#define	_SYS_HT_H
+#ifndef	_SYS_SMT_H
+#define	_SYS_SMT_H
 
 #include <sys/types.h>
 #include <sys/thread.h>
@@ -23,16 +23,20 @@
 extern "C" {
 #endif
 
-#define	ht_init() {}
+#define	smt_init() {}
+#define	smt_late_init() {}
+#define	smt_disable() (ENOTSUP)
+#define	smt_can_enable(c, f) (0)
+#define	smt_force_enabled() {}
 
-#define	ht_should_run(t, c) (B_TRUE)
-#define	ht_adjust_cpu_score(t, c, p) (p)
-#define	ht_begin_unsafe(void) {}
-#define	ht_end_unsafe(void) {}
-#define	ht_end_intr(void) {}
+#define	smt_should_run(t, c) (B_TRUE)
+#define	smt_adjust_cpu_score(t, c, p) (p)
+#define	smt_begin_unsafe(void) {}
+#define	smt_end_unsafe(void) {}
+#define	smt_end_intr(void) {}
 
 #ifdef	__cplusplus
 }
 #endif
 
-#endif	/* _SYS_HT_H */
+#endif	/* _SYS_SMT_H */
diff --git a/usr/src/uts/sun4u/io/sbd_cpu.c b/usr/src/uts/sun4u/io/sbd_cpu.c
index 5db48f7572..433faa89b1 100644
--- a/usr/src/uts/sun4u/io/sbd_cpu.c
+++ b/usr/src/uts/sun4u/io/sbd_cpu.c
@@ -25,6 +25,7 @@
  */
 /*
  * Copyright 2019 Peter Tribble.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -593,7 +594,7 @@ sbd_post_attach_cpu(sbd_handle_t *hp, sbd_devlist_t *devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, cpuid);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				SBD_SET_ERR(ep, ESBD_ONLINE);
 				SBD_SET_ERRSTR(ep, sbp->sb_cpupath[i]);
 				cmn_err(CE_WARN,
@@ -886,7 +887,7 @@ sbd_cancel_cpu(sbd_handle_t *hp, int unit)
 		if (cpu_flagged_offline(cp->sbc_cpu_flags)) {
 			PR_CPU("%s: leaving cpu %d OFFLINE\n",
 			    f, cp->sbc_cpu_id);
-		} else if (cpu_online(cpup)) {
+		} else if (cpu_online(cpup, 0)) {
 			cmn_err(CE_WARN,
 			    "sbd:%s: failed to online cpu %d",
 			    f, cp->sbc_cpu_id);
diff --git a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
index 87b5cc7fef..4d83f87179 100644
--- a/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
+++ b/usr/src/uts/sun4u/ngdr/io/dr_cpu.c
@@ -26,6 +26,7 @@
 
 /*
  * Copyright 2019 Peter Tribble.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -385,7 +386,7 @@ dr_post_attach_cpu(dr_handle_t *hp, dr_common_unit_t **devlist, int devnum)
 		if (cpu_is_offline(cp)) {
 			PR_CPU("%s: onlining cpu %d...\n", f, up->sbc_cpu_id);
 
-			if (cpu_online(cp) != 0) {
+			if (cpu_online(cp, 0) != 0) {
 				dr_dev_err(CE_WARN, &up->sbc_cm, ESBD_ONLINE);
 				errflag = 1;
 			}
@@ -882,7 +883,7 @@ dr_cancel_cpu(dr_cpu_unit_t *up)
 		}
 
 		if (cpu_is_offline(cp)) {
-			if (cpu_online(cp)) {
+			if (cpu_online(cp, 0)) {
 				cmn_err(CE_WARN, "%s: failed to online cpu %d",
 				    f, up->sbc_cpu_id);
 				rv = -1;
diff --git a/usr/src/uts/sun4u/starcat/io/drmach.c b/usr/src/uts/sun4u/starcat/io/drmach.c
index addcd5ce4d..c65c930644 100644
--- a/usr/src/uts/sun4u/starcat/io/drmach.c
+++ b/usr/src/uts/sun4u/starcat/io/drmach.c
@@ -23,6 +23,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright (c) 2016 by Delphix. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/note.h>
@@ -7487,7 +7488,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 
 	if (cpu_poweroff(cp)) {
 		DRMACH_PR("%s: cpu_poweroff failed for CPU id %d", fn, cpuid);
-		if (cpu_online(cp)) {
+		if (cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to online CPU id %d "
 			    "during I/O cage test selection", cpuid);
 		}
@@ -7509,7 +7510,7 @@ drmach_iocage_cpu_acquire(drmach_device_t *dp, cpu_flag_t *oflags)
 			dp->busy = 1;
 			return (-1);
 		}
-		if (cpu_poweron(cp) || cpu_online(cp)) {
+		if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 			cmn_err(CE_WARN, "failed to %s CPU id %d "
 			    "during I/O cage test selection",
 			    cpu_is_poweredoff(cp) ?
@@ -7620,7 +7621,7 @@ drmach_iocage_cpu_return(drmach_device_t *dp, cpu_flag_t oflags)
 		return (-1);
 	}
 
-	if (cpu_poweron(cp) || cpu_online(cp)) {
+	if (cpu_poweron(cp) || cpu_online(cp, 0)) {
 		cmn_err(CE_WARN, "failed to %s CPU id %d after I/O "
 		    "cage test", cpu_is_poweredoff(cp) ?
 		    "poweron" : "online", cpuid);
diff --git a/usr/src/uts/sun4v/io/dr_cpu.c b/usr/src/uts/sun4v/io/dr_cpu.c
index b8bf26f2fd..f2cfbb5873 100644
--- a/usr/src/uts/sun4v/io/dr_cpu.c
+++ b/usr/src/uts/sun4v/io/dr_cpu.c
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
 /*
  * sun4v CPU DR Module
  */
@@ -1113,7 +1117,7 @@ dr_cpu_configure(processorid_t cpuid, int *status, boolean_t force)
 	 */
 	if (cpu_is_offline(cp)) {
 
-		if ((rv = cpu_online(cp)) != 0) {
+		if ((rv = cpu_online(cp, 0)) != 0) {
 			DR_DBG_CPU("failed to online CPU %d (%d)\n",
 			    cpuid, rv);
 			rv = DR_CPU_RES_FAILURE;
@@ -1535,7 +1539,7 @@ typedef struct {
 static int
 dr_cpu_check_node(dev_info_t *dip, void *arg)
 {
-	char 		*name;
+	char		*name;
 	processorid_t	cpuid;
 	dr_search_arg_t	*sarg = (dr_search_arg_t *)arg;
 
diff --git a/usr/src/uts/sun4v/sys/Makefile b/usr/src/uts/sun4v/sys/Makefile
index 6c0fbd666c..025ce96e9a 100644
--- a/usr/src/uts/sun4v/sys/Makefile
+++ b/usr/src/uts/sun4v/sys/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 # include global definitions
 UTSBASE	= ../..
@@ -46,7 +46,6 @@ SUN4_HDRS=			\
 	dvma.h			\
 	eeprom.h		\
 	fcode.h			\
-	ht.h			\
 	idprom.h		\
 	intr.h			\
 	intreg.h		\
@@ -56,6 +55,7 @@ SUN4_HDRS=			\
 	nexusdebug.h		\
 	prom_debug.h		\
 	scb.h			\
+	smt.h			\
 	sun4asi.h		\
 	tod.h			\
 	trapstat.h		\
-- 
2.21.0

