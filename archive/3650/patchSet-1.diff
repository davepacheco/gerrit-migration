From 95e693c30962d1f3b2ea23f35818a4465cb6e0ef Mon Sep 17 00:00:00 2001
From: Dan McDonald <danmcd@joyent.com>
Date: Thu, 15 Mar 2018 21:04:06 -0400
Subject: [PATCH] Forward progress, but still WIP, on varpd

---
 usr/src/lib/varpd/svp/common/libvarpd_svp.c   | 87 ++++++++++++++++++-
 usr/src/lib/varpd/svp/common/libvarpd_svp.h   |  8 ++
 .../lib/varpd/svp/common/libvarpd_svp_prot.h  | 12 +--
 .../varpd/svp/common/libvarpd_svp_remote.c    | 51 +++++++++++
 4 files changed, 151 insertions(+), 7 deletions(-)

diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.c b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
index 1f68939476..990d2feb35 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
@@ -360,7 +360,8 @@ static umem_cache_t *svp_lookup_cache;
 typedef enum svp_lookup_type {
 	SVP_L_UNKNOWN	= 0x0,
 	SVP_L_VL2	= 0x1,
-	SVP_L_VL3	= 0x2
+	SVP_L_VL3	= 0x2,
+	SVP_L_RVL3	= 0x3
 } svp_lookup_type_t;
 
 typedef struct svp_lookup {
@@ -374,6 +375,7 @@ typedef struct svp_lookup {
 			varpd_arp_handle_t	*svl_vah;
 			uint8_t			*svl_out;
 		} svl_vl3;
+		struct svl_lookup_vl2 svl_rvl3;	/* Same as vl2! */
 	} svl_u;
 	svp_query_t				svl_query;
 } svp_lookup_t;
@@ -493,12 +495,35 @@ svp_shootdown_cb(svp_t *svp, const uint8_t *vl2mac, const struct in6_addr *uip,
 	libvarpd_inject_varp(svp->svp_hdl, vl2mac, NULL);
 }
 
+static void
+svp_rvl3_lookup_cb(svp_t *svp, svp_status_t status, /* XXX KEBE SAYS MORE */
+    void *arg)
+{
+	svp_lookup_t *svl = arg;
+	overlay_target_point_t *otp;
+
+	if (status != SVP_S_OK) {
+		libvarpd_plugin_query_reply(svl->svl_u.svl_evl3.svl_handle,
+		    VARPD_LOOKUP_DROP);
+		umem_cache_free(svp_lookup_cache, svl);
+		return;
+	}
+
+	otp = svl->svl_u.svl_evl3.svl_point;
+	/* XXX KEBE SAYS FILL ME IN! */
+	
+	libvarpd_plugin_query_reply(svl->svl_u.svl_evl3.svl_handle,
+	    VARPD_LOOKUP_OK);
+	umem_cache_free(svp_lookup_cache, svl);
+}
+
 static svp_cb_t svp_defops = {
 	svp_vl2_lookup_cb,
 	svp_vl3_lookup_cb,
 	svp_vl2_invalidate_cb,
 	svp_vl3_inject_cb,
-	svp_shootdown_cb
+	svp_shootdown_cb,
+	svp_rvl3_lookup_cb,
 };
 
 static boolean_t
@@ -588,6 +613,56 @@ varpd_svp_destroy(void *arg)
 	umem_free(svp, sizeof (svp_t));
 }
 
+static void
+varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
+{
+	svp_lookup_t *slp;
+	uint32_t type;
+	struct in6_addr *src =  &otl->otl_addru.otl_l3.otl3_srcip,
+	    *dst = &otl->otl_addru.otl_l3.otl3_dstip;
+
+	/*
+	 * otl is an L3 request, so we have src/dst IPs for the inner packet.
+	 * We also have the vlan.
+	 *
+	 * Assume kernel's overlay module is caching well, so we are directly
+	 * going to query (i.e. no caching up here of actual destinations).
+	 *
+	 * Our existing remote sever (svp_remote), but with the new message
+	 * SVP_R_REMOTE_VL3_REQ.  Our naming of these functions already has
+	 * "remote" in it, but we'll use "remvl3" instead of "vl3".
+	 */
+
+	/* XXX KEBE SAYS DO SOME otl verification too... */
+	if (IS_IN6_ADDR_V4MAPPED(src)) {
+		if (!IS_IN6_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IP;
+	} else {
+		if (IS_IN6_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IPV6;
+	}
+
+	slp = umem_cache_alloc(svp_lookup_cache, UMEM_DEFAULT);
+	if (slp == NULL) {
+		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	slp->svl_type = SVP_L_RVL3;
+	slp->svl_u.svl_rvl3.svl_handle = vqh;
+	slp->svl_u.svl_rvl3.svl_point = otp;
+
+	/* XXX KEBE SAYS FILL IN ARGS PROPERLY... */
+	svp_remote_rvl3_lookup(svp, &slp->svl_query, src, dst, type, slp);
+}
+
 static void
 varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
@@ -595,6 +670,14 @@ varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
 	svp_lookup_t *slp;
 	svp_t *svp = arg;
 
+	/*
+	 * Shuffle off L3 lookups to their own codepath.
+	 */
+	if (otl->otl_l3req) {
+		varpd_svp_lookup_l3(svp, vqh, otl, otp);
+		return;
+	}
+
 	/*
 	 * Check if this is something that we need to proxy, eg. arp or ndp.
 	 */
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.h b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
index 6a8cea61ae..8846ec0fab 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
@@ -74,6 +74,8 @@ typedef union svp_query_data {
 	svp_vl3_ack_t	sdq_vl3a;
 	svp_log_req_t	sdq_logr;
 	svp_lrm_ack_t	sdq_lrma;
+	svp_rvl3_req_t	sqd_rvl3r;
+	svp_rvl3_ack_t	sqd_rvl3a;
 } svp_query_data_t;
 
 typedef void (*svp_query_f)(svp_query_t *, void *);
@@ -245,6 +247,8 @@ typedef void (*svp_vl3_inject_f)(svp_t *, const uint16_t,
     const struct in6_addr *, const uint8_t *, const uint8_t *);
 typedef void (*svp_shootdown_f)(svp_t *, const uint8_t *,
     const struct in6_addr *, const uint16_t uport);
+/* XXX KEBE SAYS FILL ME IN! */
+typedef void (*svp_remvl3_lookup_f)(svp_t *, svp_status_t, void *);
 
 typedef struct svp_cb {
 	svp_vl2_lookup_f	scb_vl2_lookup;
@@ -252,6 +256,7 @@ typedef struct svp_cb {
 	svp_vl2_invalidation_f	scb_vl2_invalidate;
 	svp_vl3_inject_f	scb_vl3_inject;
 	svp_shootdown_f		scb_shootdown;
+	svp_remvl3_lookup_f	scb_remvl3_lookup;
 } svp_cb_t;
 
 /*
@@ -285,6 +290,9 @@ extern void svp_remote_vl3_lookup(svp_t *, svp_query_t *,
     const struct sockaddr *, void *);
 extern void svp_remote_vl2_lookup(svp_t *, svp_query_t *, const uint8_t *,
     void *);
+extern void svp_remote_rvl3_lookup(svp_t *, svp_query_t *, struct in6_addr *,
+    struct in6_addr *, uint32_t, uint32_t, void *);
+
 
 /*
  * Init functions
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
index 71cfbe11a4..a59d521cc3 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
@@ -113,8 +113,8 @@ typedef struct svp_vl3_req {
 } svp_vl3_req_t;
 
 /*
- * This response, corresponding to the SVP_R_VL3_ACK, includes an answer to
- * both the VL3->VL2 and the VL2->UL3 requests.
+ * This response, corresponding to the SVP_R_VL3_ACK, includes an answer to both
+ * the VL3->VL2 and the VL2->UL3 requests.
  */
 typedef struct svp_vl3_ack {
 	uint32_t	sl3a_status;
@@ -129,7 +129,8 @@ typedef struct svp_vl3_ack {
  * the answer for our response.
  */
 typedef struct svp_rvl3_req {
-	uint8_t		srl3r_ip[16];
+	uint8_t		srl3r_srcip[16];
+	uint8_t		srl3r_dstip[16];
 	uint32_t	srl3r_type;	/* Same as SVP_R_VL3_REQ */
 	uint32_t	sl3r_vnetid;
 	/* KEBE ASKS -> should the request include the guess for the dcid? */
@@ -141,10 +142,11 @@ typedef struct svp_rvl3_req {
  */
 typedef struct svp_rvl3_ack {
 	uint32_t	srl3a_status;
-	uint8_t		srl3a_dstmac[ETHERADDRL];
-	uint8_t		srl3a_srcmac[ETHERADDRL];
+	uint8_t		srl3a_dstmac[ETHERADDRL]; /* MAC of the target. */
+	uint8_t		srl3a_srcmac[ETHERADDRL]; /* MAC of the target's rtr */
 	uint16_t	srl3a_vlanid;
 	uint16_t	srl3a_uport;
+	uint32_t	srl3a_dcid;	/* Remote Data Center ID. */
 	uint8_t		srl3a_uip[16];
 } svp_rvl3_ack_t;
 
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
index 8d482e4a12..bb167c13a1 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
@@ -245,6 +245,8 @@ svp_remote_attach(svp_remote_t *srp, svp_t *svp)
 		libvarpd_panic("missing callback scb_vl2_invalidate");
 	if (svp->svp_cb.scb_vl3_inject == NULL)
 		libvarpd_panic("missing callback scb_vl3_inject");
+	if (svp->svp_cb.scb_rvl3_lookup == NULL)
+		libvarpd_panic("missing callback scb_rvl3_lookup");
 
 	check.svp_vid = svp->svp_vid;
 	if (avl_find(&srp->sr_tree, &check, &where) != NULL)
@@ -351,6 +353,55 @@ svp_remote_vl2_lookup(svp_t *svp, svp_query_t *sqp, const uint8_t *mac,
 	mutex_exit(&srp->sr_lock);
 }
 
+static void
+svp_remote_rvl3_lookup_cb(svp_query_t *sqp, void *arg)
+{
+	svp_t *svp = sqp->sq_svp;
+	svp_rvl3_ack_t *rvl3a = (svp_rvl3_ack_t *)sqp->sq_wdata;
+
+	if (sqp->sq_status == SVP_S_OKAY) {
+		svp->svp_cb.scb_remvl3_lookup(svp, sqp->sq_status,
+		    /* XXX KEBE SAYS MORE HERE */ arg);
+	} else {
+	}
+}
+
+void
+svp_remote_rvl3_lookup(svp_t *svp, svp_query_t *sqp, struct in6_addr *src,
+    struct in6_addr *dst, uint32_t type, uint32_t vnetid, void *arg)
+{
+	svp_remote_t *srp;
+	svp_rvl3_req_t *rvl3r = &sqp->sq_rdrun.sqd_rvl3r;
+
+	srp = svp->svp_remote;
+	sqp->sq_func = svp_remote_rvl3_lookup_cb;
+	sqp->sq_arg = arg;
+	sqp->sq_svp = svp;
+	sqp->sq_state = SVP_QUERY_INIT;
+	sqp->sq_header.svp_ver = htons(SVP_CURRENT_VERSION);
+	sqp->sq_header.svp_op = htons(SVP_R_REMOTE_VL3_REQ);
+	sqp->sq_header.svp_size = htonl(sizeof (svp_vl2_req_t));
+	sqp->sq_header.svp_id = id_alloc(svp_idspace);
+	if (sqp->sq_header.svp_id == (id_t)-1)
+		libvarpd_panic("failed to allcoate from svp_idspace: %d",
+		    errno);
+	sqp->sq_header.svp_crc32 = htonl(0);
+	sqp->sq_rdata = rvl3r;
+
+	bcopy(src, rvl3r->srl3r_srcip);
+	bcopy(dst, rvl3r->srl3r_dstip);
+	/* Caller should've checked both are the same type... */
+	rvl3r->srl3r_type = type;
+	rvl3r->srl3r_vnetid = vnetid;
+
+	mutex_enter(&srp->sr_lock);
+	if (!svp_remote_conn_queue(srp, sqp)) {
+		sqp->sq_status = SVP_S_FATAL;
+		sqp->sq_func(sqp, arg);
+	}
+	mutex_exit(&srp->sr_lock);
+}
+
 static void
 svp_remote_vl3_lookup_cb(svp_query_t *sqp, void *arg)
 {
-- 
2.21.0

