From 4c4b54bf2a35451973ae8506a1eb40fd9c06e5a8 Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Wed, 25 Jul 2018 16:59:23 -0700
Subject: [PATCH] TRITON-233 CNAPI's should only use one moray bucket to manage
 waitlist tickets Reviewed by: Marsell Kukuljevic <marsell@joyent.com>
 Approved by: Marsell Kukuljevic <marsell@joyent.com>

---
 docs/static.md                 |   47 +-
 lib/endpoints/waitlist.js      |   35 +-
 lib/models/waitlist.js         | 1456 ++++++++++++--------------------
 test/waitlist/test-waitlist.js |  226 +++--
 4 files changed, 745 insertions(+), 1019 deletions(-)

diff --git a/docs/static.md b/docs/static.md
index ea0bcdc..26640d6 100644
--- a/docs/static.md
+++ b/docs/static.md
@@ -502,29 +502,32 @@ A CNAPI server record looks like the following
 | **uuid**                             | *String*         | The server's unique identifier                                             |
 | **vms**                              | *Object*         | A object representing all the vms on server                                |
 
+
 # Waitlist
 
-When executing jobs on a server, such vm provision, start, stop, reboot, and
-zfs dataset import it is possible that concurrent jobs may interfere with each
-other.
+Certain actions on datacenter resources require serialization of execution to
+prevent undesireable or undefined results. Such actions include – but are not
+limited to – DAPI allocation, VM lifecycle requests (creation, start, stop,
+reboot, destroy), and dataset import. Waitlist should be used on any workflow
+job where it is possible that concurrent jobs may interfere with each other if
+actions on the compute node are not deconflicted by a system such as this.
 
-To prevent this, a mechanism is required that will queue jobs based on the
-type of resource they're acting on. Jobs should be grouped by "scope" and
-serialized such that a server can will only execute be executing one job per
-scope group at a time. In this way it would be possible to enforce that only
-one job be active on a vm on a server, but would still allow jobs to be run
-against another vm. Any jobs that come in after one is active will be queued
-and dispatch as the previous job finishes.
+Jobs should be grouped by the combination of [server_uuid, scope, id] and
+serialized such that a server will only be executing one job per combination at
+a time. In this way it would be possible to enforce that only one job be active
+on a particular vm on a server, but would still allow jobs to be run against
+another vm. Any jobs that come in after one is active will be queued and
+dispatched as preceding jobs finish.
 
 This system allows for concurrent jobs where the scoping has been set such
 that two jobs will not interfere with each other. For instance, two reboot
 jobs for two different vms may be run at the same time, however, two reboots
 for the same vm will happen in sequential order.
 
-Use of the waitlist is a deliberate process. It is up to the one initiating a job
-to create a ticket and wait for it to become active. As such, it is possible
-to not use the waitlist at all. However, one then runs the risk of concurrent
-jobs trampling each other.
+Use of waitlist does not happen implicitly in workflow jobs. It is up to the
+workflow job to create a ticket and wait for it to become active. As such, it
+is possible to not use the waitlist at all. However, one then runs the risk of
+concurrent jobs trampling each other.
 
 Waitlist tickets are serialized and dispatched one by one according to their
 `server_uuid`, `scope` and `id` parameters.
@@ -537,12 +540,13 @@ performed on a resource identified by `id` of the type given by `scope`.
 The basic process is as follows: a job starts and it first acquires a ticket
 from CNAPI for that particular server and passes in a `scope` and an `id`.
 
-Because waitlist tickets are serviced in order, once a ticket has been created
-the next step is to wait for it to become active. This will happen if there
-are no tickets for that scope/id combination, or if waited upon and all
-preceding tickets are resolved. To find out whether a ticket has become
-'active' (ie indicating the job may proceed and do its work), the job may poll
-the ticket values, or use the blocking `wait` endpoint for that ticket.
+Because waitlist tickets are serviced in creation order, once a ticket has been
+created the next step is to wait for it to become active. Tickets become active
+once all extant tickets for that server/scope/id are finished or expired.
+
+To find out whether a ticket has become 'active' (i.e. indicating the job may
+proceed and do its work), the job may poll the ticket values, or use the
+blocking `wait` endpoint for that ticket.
 
 Once the work has been completed, it is up to the job to "release" the ticket,
 so that subsequent tickets for that scope/id combination can be serviced.
@@ -618,6 +622,9 @@ the results list if tickets are deleted.
 
 ### Release a ticket
 
+Releasing a ticket allows subsequent tickets (if any) queued on that
+server/scope/id to become active.
+
     -bash-4.1# sdc-cnapi /tickets/bb5038c2-7498-4e07-b919-df072c76d2dc/release -X PUT
     HTTP/1.1 204 No Content
     Date: Fri, 27 Jun 2014 19:42:46 GMT
diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index d0087e1..37c690c 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -175,9 +175,10 @@ function handlerControllerWaitlistCreateTicket(req, res, next) {
 
 ControllerWaitlist.getTicket =
 function handlerControllerWaitlistGetTicket(req, res, next) {
-    ModelWaitlist.getTicket(req.params.ticket_uuid, function (error, ticket) {
-        if (ticket) {
-            res.send(200, ticket);
+    ModelWaitlist.getTicket(req.params.ticket_uuid,
+    function _onGet(error, result) {
+        if (result.ticket) {
+            res.send(200, result.ticket);
             next();
             return;
         } else {
@@ -311,27 +312,19 @@ ControllerWaitlist.releaseTicket =
 function handlerControllerWaitlistReleaseTicket(req, res, next) {
     var ticket_uuid = req.params.ticket_uuid;
 
-    ModelWaitlist.getTicket(ticket_uuid, function (error, ticket) {
-        if (error) {
-            next(new restify.InternalError(error.message));
-            return;
-        }
+    ModelWaitlist.releaseTicket(ticket_uuid, function _onRelease(relerror) {
+        if (relerror) {
+            if (verror.hasCauseWithName(relerror, 'ResourceNotFoundError')) {
+                next(relerror);
+                return;
+            }
 
-        if (!ticket) {
-            var errorMsg = 'ticket ' + ticket_uuid + ' not found';
-            next(new restify.ResourceNotFoundError(errorMsg));
+            next(new restify.InternalError(relerror.message));
             return;
         }
 
-        ModelWaitlist.ticketRelease(ticket_uuid, function (relerror) {
-            if (relerror) {
-                next(new restify.InternalError(relerror.message));
-                return;
-            }
-
-            res.send(204);
-            next();
-        });
+        res.send(204);
+        next();
     });
 };
 
diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index 70ad6df..8d5d454 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -9,8 +9,10 @@
  */
 
 /*
- * CNAPI wailist subsystem for serializing server operations.
- * See docs/waitlist.md for more details.
+ * The waitlist subsystem is responsible for serializing access to datacenter
+ * resources.
+ *
+ * See the "Waitlist" section in docs/index.md for more information.
  */
 
 var assert = require('assert-plus');
@@ -21,46 +23,57 @@ var sprintf = require('sprintf').sprintf;
 var vasync = require('vasync');
 var VError = require('verror');
 var jsprim = require('jsprim');
+var restify = require('restify');
 
 var ModelBase = require('./base');
 var buckets = require('../apis/moray').BUCKETS;
 var common = require('../common');
-var orderedKVString = require('../common').orderedKVString;
 
+// Ticket status values
+var TICKET_STATUS_ACTIVE = 'active';
+var TICKET_STATUS_EXPIRED = 'expired';
+var TICKET_STATUS_FINISHED = 'finished';
+var TICKET_STATUS_QUEUED = 'queued';
+
+// Ticket modify operations
+var TICKET_OPERATION_UPDATE = 'update';
+var TICKET_OPERATION_DELETE = 'delete';
 
-// how long, (in ms), between checks to moray for ticket updates
+// Moray bucket
+var MORAY_BUCKET_WAITLIST_TICKETS = buckets.waitlist_tickets.name;
+
+// How long, (in ms), between checks to moray for ticket updates
 var WAITLIST_PERIOD_MS = 500;
 
-// how long, (in ms), between attempts to clean old tickets out of moray
+// How long, (in ms), between attempts to clean old tickets out of moray
 var WAITLIST_CLEANUP_PERIOD_MS = 3600 * 1000;
 
-// when cleanup occurs, delete tickets that are past this threshold (1mo)
-var WAITLIST_CLEANUP_MAX_AGE_MS = 3600 * 24 * 30 * 1000;
+// When cleanup occurs, delete tickets that are past this threshold (1mo)
+var WAITLIST_CLEANUP_MAX_AGE_MS = 30 * 24 * 3600 * 1000;
 
-/**
- * The WaitlistDirector is the active component of the CNAPI waitlist
- * functionality. It periodically checks moray for waitlist tickets that have
- * been updated and takes appropriate action, such as: dispatching wait
+/*
+ * The WaitlistDirector periodically checks moray for waitlist tickets that
+ * have been updated and takes appropriate action, such as: dispatching wait
  * callbacks and updating ticket statuses.
  *
- * There will only be one instance of this per CNAPI process.
+ * There will only be one instance of this object per running CNAPI instance.
  */
 
 function WaitlistDirector(params) {
     var self = this;
     self.params = params;
-    self.log = WaitlistDirector.log;
+    self.log = ModelWaitlist.log;
     self.callbacks = {};
 }
 
 
-
-/**
- * Begins checking moray for ticket updates and taking action based on changes
- * therein.
+/*
+ * Begin checking moray for ticket updates and taking action based on those
+ * changes.
  */
 
-WaitlistDirector.prototype.start = function () {
+WaitlistDirector.prototype.start =
+function WaitlistDirectorStart() {
     var self = this;
 
     var lastCheck;
@@ -72,9 +85,12 @@ WaitlistDirector.prototype.start = function () {
         clearInterval(WaitlistDirector.timeout);
     }
 
+    // Start the timer responsible for checking for ticket updates.
     WaitlistDirector.timeout = setTimeout(intervalFn, WAITLIST_PERIOD_MS);
-    WaitlistDirector.cleanupTimeout = setTimeout(cleanupIntervalFn,
-                                                 WAITLIST_CLEANUP_PERIOD_MS);
+
+    // Start the timer responsible for cleaning up old tickets.
+    WaitlistDirector.cleanupTimeout =
+        setTimeout(cleanupIntervalFn, WAITLIST_CLEANUP_PERIOD_MS);
 
     function intervalFn() {
         var params = { timestamp: lastCheck && new Date(lastCheck - 1000) };
@@ -86,34 +102,34 @@ WaitlistDirector.prototype.start = function () {
         WaitlistDirector.cleanupOldTickets(onTicketsCleanedUp);
     }
 
+    // This gets called every time we check and find tickets that have been
+    // updated since the last time we looked.
     function onTicketsUpdated(error, tickets) {
+        // We want this rescheduled even if we get an error
+        WaitlistDirector.timeout = setTimeout(intervalFn, WAITLIST_PERIOD_MS);
+
         if (error) {
-            self.log.error(
-                { error: error }, 'failed to get tickets since %s',
+            self.log.error({ error: error }, 'failed to get tickets since %s',
                 lastCheck);
         }
 
         var date = lastCheck;
         lastCheck = new Date();
 
-        if (!tickets || !tickets.length) {
+        // If there are tickets with an updated_at time later than the last
+        // time we last checked, process those tickets.
+        if (tickets && tickets.length) {
+            self.log.info({ tickets: tickets },
+                           'tickets updated since %s (started at %s)',
+                           date ? date.toISOString() : 'start-up',
+                           start.toISOString());
+
+            self.onUpdate(date, tickets);
+        } else {
             self.log.trace('no tickets updated since %s',
                        date ? date.toISOString() : 'start-up',
                        start.toISOString());
-            // No updated tickets need attention
-            WaitlistDirector.timeout = setTimeout(intervalFn,
-                                                  WAITLIST_PERIOD_MS);
-            return;
         }
-
-        self.log.info({ tickets: tickets },
-                       'tickets updated since %s (started at %s)',
-                       date ? date.toISOString() : 'start-up',
-                       start.toISOString());
-
-        self.onUpdate(date, tickets);
-
-        WaitlistDirector.timeout = setTimeout(intervalFn, WAITLIST_PERIOD_MS);
     }
 
     function onTicketsCleanedUp(error) {
@@ -127,56 +143,58 @@ WaitlistDirector.prototype.start = function () {
 };
 
 
-
 /*
- * Call with a timestamp and list of tickets that have had their `updated_at`
- * value updated since last we checked. This will dispatch callbacks for
- * "wait" on ticket status going to "expire" or "finished", and make sure that
- * any tickets in which now() > `expires_at` get marked as 'expired'.
+ * Called with a timestamp and list of tickets that have had their
+ * `updated_at` value updated since last we checked. This will dispatch
+ * callbacks for "wait" on ticket status going to "expire" or "finished", and
+ * make sure that any tickets in which now() > `expires_at` get marked as
+ * 'expired'.
  */
 
-WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
+WaitlistDirector.prototype.onUpdate =
+function WaitlistDirectorOnUpdate(timestamp, tickets) {
     var self = this;
+
+    assert.optionalDate(timestamp, 'timestamp');
+    assert.array(tickets, 'tickets');
+
     self.log.trace('onUpdate with %d tickets', tickets.length);
     async.forEach(
         tickets,
-        function (ticket, fecb) {
+        function _forEachTicket(ticket, next) {
             var i;
             // Check if ticket needs to be expired.
-            if (ticket.status === 'expired' &&
-                self.callbacks[ticket.uuid])
-            {
+            if (ticket.status === TICKET_STATUS_EXPIRED &&
+                self.callbacks[ticket.uuid]) {
                 self.log.info(
                     'ticket %s expired, invoking %d callbacks',
                     ticket.uuid, self.callbacks[ticket.uuid].length);
                 // If ticket went into 'active' status, kick off callbacks.
+                var expErr = new VError('ticket has expired');
                 for (i in self.callbacks[ticket.uuid]) {
-                    self.callbacks[ticket.uuid][i](
-                        new VError('ticket has expired'));
+                    self.callbacks[ticket.uuid][i](expErr);
                 }
                 delete self.callbacks[ticket.uuid];
-                fecb();
+                next();
                 return;
             // Check if a pending (active/queued) ticket is expired but not
             // marked as such.
-            } else if (ticket.status !== 'finished' &&
+            } else if (ticket.status !== TICKET_STATUS_FINISHED &&
                        timestamp &&
-                       timestamp.toISOString() > ticket.expires_at)
-            {
-                var wl = new ModelWaitlist({ uuid: ticket.server_uuid });
-                wl.expireTicket(ticket.uuid, function (err) {
+                       timestamp.toISOString() > ticket.expires_at) {
+                ModelWaitlist.expireTicket(ticket.uuid, function (err) {
                     if (err) {
                         self.log.error(err);
+                        next(err);
                         return;
                     }
-                    fecb();
+                    next();
                 });
                 return;
             // Ticket just became active.
             } else if (
-                ticket.status === 'active' &&
-                self.callbacks[ticket.uuid])
-            {
+                ticket.status === TICKET_STATUS_ACTIVE &&
+                self.callbacks[ticket.uuid]) {
                 // If ticket went into 'active' status, kick off callbacks
                 self.log.info(
                     'ticket %s became active, invoking %d callbacks',
@@ -185,12 +203,11 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
                     self.callbacks[ticket.uuid][i]();
                 }
                 delete self.callbacks[ticket.uuid];
-                fecb();
+                next();
                 return;
             } else if (
-                ticket.status === 'active' &&
-                !self.callbacks[ticket.uuid])
-            {
+                ticket.status === TICKET_STATUS_ACTIVE &&
+                !self.callbacks[ticket.uuid]) {
                 self.log.warn(
                     { ticket: ticket },
                     'onUpdate: ticket %s active but no callbacks found',
@@ -201,7 +218,7 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
                     ticket.uuid);
             }
 
-            fecb();
+            next();
     });
 };
 
@@ -212,31 +229,38 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
  * 'active' status.
  */
 
-WaitlistDirector.prototype.waitForTicketByUuid = function (uuid, callback) {
+WaitlistDirector.prototype.waitForTicketByUuid =
+function ModelWaitlisWaitForTicketByUuid(uuid, callback) {
     var self = this;
 
+    assert.uuid(uuid, 'uuid');
+    assert.func(callback, 'callback');
+
     self.log.info('waitForTicketByUuid: ticket %s', uuid);
 
-    ModelWaitlist.getTicket(uuid, function (error, t) {
+    ModelWaitlist.getTicket(uuid, function _onGetTicket(error, result) {
         if (error) {
             callback(new VError('fetching ticket %s', uuid));
             return;
         }
 
-        // If the ticket doesn't exist in moray, it doesn't exist period.
-        if (!t) {
+        var ticket = result.ticket;
+
+        // If the ticket doesn't exist, callback with error
+        if (!ticket) {
             callback(new VError('no such ticket %s', uuid));
             return;
         }
 
-        if (t.status === 'active') {
+        if (ticket.status === TICKET_STATUS_ACTIVE) {
             self.log.warn(
                 'ticket %s found active', uuid);
              callback();
+
              return;
         }
 
-        if (t.status === 'expired') {
+        if (ticket.status === TICKET_STATUS_EXPIRED) {
             self.log.warn(
                 'ticket %s found expired', uuid);
              callback(new VError('ticket %s is expired', uuid));
@@ -277,7 +301,8 @@ ModelWaitlist.createWaitlistDirector = function (params) {
 
 
 ModelWaitlist.init = function (app) {
-    var self = ModelWaitlist;
+    var self = this;
+
     self.app = app;
 
     Object.keys(ModelBase.staticFn).forEach(function (p) {
@@ -285,52 +310,89 @@ ModelWaitlist.init = function (app) {
     });
 
     ModelWaitlist.log = app.getLog();
-    WaitlistDirector.log = app.getLog();
 };
 
 
+/**
+ * Fetch a ticket from moray by given ticket uuid.
+ *
+ * @param {String} ticket
+ * @param callback {Function} `function (err, { ticket: ticket, etag: etag })`
+ */
+
+ModelWaitlist.getTicket =
+function ModelWaitlistGetTicket(uuid, callback) {
+    var self = this;
+
+    assert.uuid(uuid, 'uuid');
+    assert.func(callback, 'callback');
+
+    ModelWaitlist.getMoray().getObject(
+        MORAY_BUCKET_WAITLIST_TICKETS, uuid, onGet);
+
+    function onGet(error, obj) {
+        if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError')) {
+            self.log.error('ticket %s not found in moray', uuid);
+            callback(null, {});
+            return;
+        } else if (error) {
+            self.log.error(error, 'error fetching ticket from moray');
+            callback(error);
+            return;
+        }
+
+        callback(null, { ticket: obj.value, etag: obj._etag });
+    }
+};
+
+
+ModelWaitlist.ticketsUpdatedSince =
+function ModelWaitlistTicketsUpdatedSince(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.optionalDate(opts.timestamp, 'opts.timestamp');
+    assert.func(callback, 'callback');
 
-ModelWaitlist.ticketsUpdatedSince = function (params, callback) {
-    var self = ModelWaitlist;
     var filter;
+    var findOpts;
 
-    self.log.trace('checking for tickets since %s', params.timestamp);
+    self.log.trace('checking for tickets since %s', opts.timestamp);
 
-    if (params.timestamp) {
-        var ts = new Date(params.timestamp);
+    if (opts.timestamp) {
+        var ts = new Date(opts.timestamp);
         var escts = common.filterEscape(ts.toISOString());
 
+        // Return any tickets which:
+        // - are not finished|expired and have been updated since the
+        //   last check.
+        // - are not are not marked as finished or expired but have an
+        //   expiry date which has been exceeded.
         filter = sprintf(
-            // Return any tickets which:
-            '(|' +
-                // - are not finished|expired and have been updated since the
-                //   last check.
-                '(&' +
-                    '(!(status=finished))' +
-                    '(!(status=expired))' +
-                    '(updated_at>=%s)' +
-                ')' +
-                // - are not are not marked as finished or expired but have an
-                //   expiry date which has been exceeded.
-                '(&' +
-                    '(!(status=finished))' +
-                    '(!(status=expired))' +
-                    '(!(expires_at>=%s))' +
-                '))',
+            '(&' +
+                '(!(status=finished))' +
+                '(!(status=expired))' +
+                '(|(updated_at>=%s)(!(expires_at>=%s)))' +
+            ')',
             escts, escts);
     } else {
         filter = '&(!(status=expired))(!(status=finished))';
     }
 
-    var findOpts = {
+    findOpts = {
         sort: {
             attribute: 'created_at',
-            order: 'DESC'
+            order: 'ASC'
         }
     };
 
-    self.query(filter, findOpts, function (err, tickets) {
-        if (!err && tickets.length > 0) {
+    self.query(filter, findOpts, function _onQuery(err, tickets) {
+        if (err) {
+            self.log.error(err);
+            callback(new VError(err, 'failed to query moray'));
+            return;
+        }
+        if (tickets.length > 0) {
             self.log.info({ tickets: tickets }, 'new ticket(s)');
         }
 
@@ -363,7 +425,7 @@ WaitlistDirector.cleanupOldTickets = function (callback) {
     var moray = ModelWaitlist.getMoray();
 
     moray.deleteMany(
-        buckets.waitlist_tickets.name,
+        MORAY_BUCKET_WAITLIST_TICKETS,
         filter,
         function (error) {
             if (error) {
@@ -376,69 +438,6 @@ WaitlistDirector.cleanupOldTickets = function (callback) {
 };
 
 
-ModelWaitlist.ticketRelease = function (ticket_uuid, callback) {
-    var self = ModelWaitlist;
-    // Steps to release a ticket:
-    // Batch
-    //   - confirm ticket status to see if there is any actual work to be done
-    //   - confirm queue status to see if there is any actual work to be done
-    //
-    // Batch:
-    //   - put ticket status => 'finished', updated_at times
-    //   - remove ticket from queue
-    //   - update next ticket's status => active if it is first
-
-    var ticket;
-    var serverqueue;
-    var etag;
-    var wl;
-
-    vasync.waterfall([
-        function (wfcb) {
-            ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
-                    if (geterror) {
-                        wfcb(VError(geterror, 'failed to load ticket %s',
-                                    ticket_uuid));
-                        return;
-                    }
-
-                    if (!respticket) {
-                        wfcb(VError('no such ticket %s', ticket_uuid));
-                        return;
-                    }
-
-                    ticket = respticket;
-                    wfcb();
-                });
-        },
-        function (wfcb) {
-            wl = new ModelWaitlist({ uuid: ticket.server_uuid });
-            wl.getServerQueue(function (err, respserverqueue, res) {
-                if (err) {
-                    wfcb(VError(err, 'loading waitlist queue for server %s',
-                        ticket.server_uuid));
-                    return;
-                }
-
-                serverqueue = respserverqueue;
-                etag = res.etag;
-
-                wfcb();
-            });
-        },
-        function (wfcb) {
-            self.log.info(
-                'ticket %s released; activating next if any', ticket.uuid);
-            wl.finishTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
-        }
-    ],
-    function (err) {
-        callback(err);
-    });
-};
-
 
 
 ModelWaitlist.list = function (params, callback) {
@@ -467,14 +466,18 @@ ModelWaitlist.list = function (params, callback) {
     ModelWaitlist.query('(server_uuid=' + uuid + ')', queryOpts, callback);
 };
 
+/*
+ * Do a moray query and return an array of response objects.
+ *
+ * @param filter {String}
+ * @param findOpts {Object}
+ * @param callback {Function} `function (err, responses)`
+ */
 
-
-ModelWaitlist.query = function (filter, findOpts, callback) {
-    assert.optionalObject(findOpts, 'findOpts');
-
-    var self    = ModelWaitlist;
-    var moray   = ModelWaitlist.getMoray();
-    var bucket  = buckets.waitlist_tickets.name;
+ModelWaitlist.queryWithMeta =
+function ModelWaitlistQueryWithMeta(filter, findOpts, callback) {
+    var self = this;
+    var moray = ModelWaitlist.getMoray();
     var tickets = [];
 
     // Default sort parameters
@@ -485,6 +488,9 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
         offset: 0
     };
 
+    assert.string(filter, 'filter');
+    assert.optionalObject(findOpts, 'findOpts');
+
     if (!callback) {
         callback = findOpts;
         findOpts = {};
@@ -494,6 +500,8 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
         findOpts = {};
     }
 
+    assert.func(callback, 'callback');
+
     var findParams = jsprim.deepCopy(findOpts);
     var sort = findParams.sort || {};
     findParams.sort = jsprim.deepCopy(defaultSort);
@@ -512,9 +520,10 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
     }
 
     try {
-        var req = moray.findObjects(bucket, filter, findParams);
+        var req = moray.findObjects(
+            MORAY_BUCKET_WAITLIST_TICKETS, filter, findParams);
     } catch (e) {
-        self.log.warn({ err: e.message }, 'Received an exception from moray');
+        self.log.warn({ err: e.message }, 'received an exception from moray');
         callback(null, tickets);
         return;
     }
@@ -532,8 +541,8 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
         oncecb(err, tickets);
     }
 
-    function onRecord(ticket) {
-        tickets.push(ticket.value);
+    function onRecord(ticketres) {
+        tickets.push(ticketres);
     }
 
     function processResults() {
@@ -546,845 +555,481 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
 };
 
 
+/*
+ * Do a moray query and call callback with an array of the `value` property
+ * from the responses.
+ *
+ * @param filter {String}
+ * @param findOpts {Object}
+ * @param callback {Function} `function (err, values)`
+ */
 
-ModelWaitlist.getTicket = function (uuid, callback) {
-    var self = ModelWaitlist;
-
-    ModelWaitlist.getMoray().getObject(
-        buckets.waitlist_tickets.name, uuid, onGet);
+ModelWaitlist.query =
+function ModelWaitlistQuery(filter, findOpts, callback) {
+    assert.string(filter, 'filter');
+    assert.object(findOpts, 'findOpts');
+    assert.func(callback, 'callback');
 
-    function onGet(error, obj) {
-        if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError')) {
-            self.log.error('Ticket %s not found in moray', uuid);
-            callback();
-            return;
-        } else if (error) {
-            self.log.error(error, 'Error fetching ticket from moray');
-            callback(error);
+    // Grab the response values.
+    ModelWaitlist.queryWithMeta(filter, findOpts,
+    function _onQueryWithMeta(err, responses) {
+        if (err) {
+            callback(err);
             return;
         }
-
-        callback(null, obj.value);
-    }
-};
-
-
-
-ModelWaitlist.prototype.getServerQueue = function (callback) {
-    var self = this;
-    var serverqueue;
-    var etag;
-
-    ModelWaitlist.getMoray().getObject(
-        buckets.waitlist_queues.name,
-        self.uuid,
-        function (err, response) {
-            var res = { etag: null };
-            if (err && VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
-                self.log.error(
-                    'Ticket queue for %s not found in moray',
-                    self.uuid);
-                callback(null, null, res);
-                return;
-            } else if (err) {
-                self.log.error(
-                    err, 'Error fetching ticket from moray');
-                callback(err);
-                return;
-            }
-            serverqueue = response.value;
-            if (response) {
-                etag = response._etag;
-            }
-            callback(null, serverqueue, { etag: etag });
+        var values = responses.map(function (r) {
+            return r.value;
         });
-};
-
 
-
-/**
- * Check if the waitlist queue for this server exists, and create it if it
- * does not. Returns the queue object value and etag.
- */
-
-ModelWaitlist.prototype.ensureServerQueue = function (callback) {
-    var self = this;
-    var serverqueue = null;
-    var etag = null;
-    var moray = ModelWaitlist.getMoray();
-
-    vasync.waterfall([
-        function (wfcb) {
-            self.getServerQueue(function (err, s, res) {
-                if (err) {
-                    wfcb(err);
-                    return;
-                }
-
-                serverqueue = s;
-                etag = res.etag;
-                wfcb();
-            });
-
-        },
-        function (wfcb) {
-            if (serverqueue) {
-                wfcb();
-                return;
-            }
-
-            serverqueue = {
-                server_uuid: self.uuid,
-                updated_at: (new Date()).toISOString(),
-                tickets: {}
-            };
-
-            moray.putObject(
-                buckets.waitlist_queues.name,
-                self.uuid,
-                serverqueue,
-                { etag: etag },
-                function (err, response) {
-                    if (err &&
-                       (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                       (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                    {
-                        self.log.warn({ err: err },
-                            'waitlist collision on queue initialization, ' +
-                            'retrying');
-
-                        process.nextTick(function () {
-                            self.ensureServerQueue(wfcb);
-                        });
-                        return;
-                    }
-
-                    wfcb();
-                    return;
-                });
-        }
-    ],
-    function (err) {
-        callback(err, { etag: etag, serverqueue: serverqueue });
+        callback(null, values);
     });
 };
 
 
+/*
+ * Look up in moray which tickets should be activated next, given a scope and
+ * id. Calls callback with active and queued tickets.
+ *
+ * @param opts {Object}
+ * @param opts.scope {String} The ticket scope
+ * @param opts.id {String} The id of resource within given scope
+ * @param callback {Function} `function (err, responses)`
+ */
 
-ModelWaitlist.prototype.removeTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
+ModelWaitlist.findNextTickets =
+function modelWaitlistFindNextTickets(opts, callback) {
     var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
 
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
-    }
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.server_uuid, 'opts.server_uuid');
+    assert.optionalNumber(opts.limit, 'opts.limit');
+    assert.optionalBool(opts.omitActive, 'opts.omitActive');
 
-    ticket.created_at =
-    serverqueue.updated_at =
-        (new Date()).toISOString();
-
-    var queue = serverqueue.tickets[key];
-    var ticketIdx = queue.indexOf(ticket.uuid);
-    var wasTop = (ticketIdx === 0 ? true : false);
+    var filter = sprintf(
+        '(&' +
+            '(server_uuid=%s)' +
+            '(scope=%s)' +
+            '(id=%s)' +
+            (opts.omitActive ? '(!(status=active))' : '') +
+            '(!(status=finished))' +
+            '(!(status=expired))' +
+        ')', opts.server_uuid, opts.scope, opts.id);
 
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            operation: 'delete'
+    var findOpts = {
+        limit: opts.limit,
+        sort: {
+            attribute: 'created_at',
+            order: 'ASC'
         }
-    ];
-
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
-        data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
-            }
-        });
-    }
-
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
+    };
 
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
+    ModelWaitlist.queryWithMeta(filter, findOpts,
+    function _onQueryWithMeta(err, tickets) {
+        if (err) {
+            callback(new VError(err, 'failed to find next tickets'));
+            return;
         }
-    });
-
-    var moray = ModelWaitlist.getMoray();
 
-    // We have removed the 'finished' ticket, if there is another ticket in the
-    // queue, now we need to mark the "top" ticket as active, and then write
-    // back the updated queue.
-    vasync.waterfall([
-        function (wfcb) {
-            if (queue.length && wasTop) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
+        tickets = tickets.map(function (t) {
+            return { ticket: t.value, etag: t._etag };
+        });
 
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
+        self.log.trace({ filter: filter, tickets: tickets },
+            'findNextTickets: found tickets');
 
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
-                    });
-                return;
-            }
-            wfcb();
-        },
-        function (wfcb) {
-            moray.batch(data, function (err, meta) {
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                wfcb(err2);
-                                return;
-                            }
-                            self.pushTicketUpdateQueue(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
-                    return;
-                } else {
-                    wfcb();
-                }
-            });
-        }
-    ],
-    function (wferr) {
-        callback(wferr);
+        callback(err, tickets);
     });
 };
 
-
-
-/**
- * Expire a ticket given a ticket payload and a server queue object.
+/*
+ * Update a ticket in moray, and activate the next ticket (by creation_date)
+ * with the same set formed by `ticket.scope`, `ticket.server_uuid`, and
+ * `ticket.id`.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.ticket
+ * @param {String} opts.ticketEtag
+ * @param {Function} callback `function (err, { ticket: ticket, etag: etag })`
  */
 
-ModelWaitlist.prototype.expireTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
+ModelWaitlist.modifyTicketActivateNext =
+function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
     var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
 
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
-    }
+    assert.object(opts, 'opts');
+    assert.string(opts.operation, 'opts.operation');
+    assert.uuid(opts.ticket_uuid, 'opts.ticket_uuid');
+    assert.func(callback, 'callback');
 
-    ticket.status = 'expired';
-    ticket.updated_at =
-    serverqueue.updated_at =
-        (new Date()).toISOString();
-
-    var queue = serverqueue.tickets[key];
-    var ticketIdx = queue.indexOf(ticket.uuid);
-    var wasTop = (ticketIdx === 0 ? true : false);
-
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            operation: 'put',
-            value: ticket
-        }
-    ];
-
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
-        data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
-            }
-        });
+    if (opts.operation === TICKET_OPERATION_UPDATE) {
+        assert.object(opts.update, 'opts.update');
     }
 
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
-
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
-        }
-    });
-
     var moray = ModelWaitlist.getMoray();
 
-    // We have removed the 'expired' ticket, if there is another ticket in the
-    // queue, now we need to mark the "top" ticket as active, and then write
-    // back the updated queue.
-    vasync.waterfall([
-        function (wfcb) {
-            if (queue.length && wasTop) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
-
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
+    var ticket_uuid = opts.ticket_uuid;
+    var ticket;
+    var ticketEtag;
+    var batchOperations = [];
 
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
-                    });
-                return;
-            }
-            wfcb();
-        },
-        function (wfcb) {
-            self.log.debug({
-                batch: data
-            }, 'performing batch operation to activate next ticket');
-            moray.batch(data, function (err, meta) {
-                if (err) {
-                    self.log.error({
-                        err: err
-                    }, 'Error when performing batch operation');
+    vasync.waterfall([
+        // Look up ticket with given ticket uuid.
+        function doGetTicket(next) {
+            ModelWaitlist.getTicket(opts.ticket_uuid,
+            function _onGetTicket(geterror, result) {
+                if (geterror) {
+                    next(VError(geterror, 'failed to retrieve ticket %s',
+                        ticket_uuid));
+                    return;
                 }
 
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                wfcb(err2);
-                                return;
-                            }
-
-                            self.log.debug('retrying ' +
-                                'expireTicketUpdateQueueActivateNext');
-                            self.expireTicketUpdateQueueActivateNext(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
+                if (!result.ticket) {
+                    var errorMsg = 'ticket ' + ticket_uuid + ' not found';
+                    next(new restify.ResourceNotFoundError(errorMsg));
                     return;
-                } else {
-                    wfcb();
                 }
-            });
-        }
-    ],
-    function (wferr) {
-        callback(wferr);
-    });
-};
 
+                ticket = result.ticket;
+                ticketEtag = result.etag;
+                ticket.updated_at = (new Date()).toISOString();
 
+                // If update passed in, override the ticket values with it.
+                if (opts.update) {
+                    for (var i in opts.update) {
+                        ticket[i] = opts.update[i];
+                    }
+                }
 
-ModelWaitlist.prototype.finishTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
-    var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
-
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
-    }
+                next();
+            });
+        },
 
-    ticket.status = 'finished';
-    ticket.updated_at = serverqueue.updated_at = (new Date()).toISOString();
-
-    var queue = serverqueue.tickets[key];
-    var ticketIdx = queue.indexOf(ticket.uuid);
-
-    /**
-     * Craft the payload we will submit to moray.batch()
-     *
-     * This includes:
-     *   - modifying the metadata on the finished ticket
-     *   - remove finished ticket from the queue it's in
-     *   - modifying the metadata on the next ticket in the queue
-     */
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            value: ticket
-        }
-    ];
-
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
-        data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
+        // Set up batch call to delete or update ticket for given ticket uuid
+        // depending on operation.
+        function doSetupBatch(next) {
+            if (opts.operation === TICKET_OPERATION_DELETE) {
+                batchOperations.push({
+                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
+                    key: ticket.uuid,
+                    operation: 'delete',
+                    options: {
+                        etag: ticketEtag
+                    }
+                });
+            } else if (opts.operation === TICKET_OPERATION_UPDATE) {
+                batchOperations.push({
+                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
+                    key: ticket.uuid,
+                    operation: 'put',
+                    value: ticket,
+                    options: {
+                        etag: ticketEtag
+                    }
+                });
+            } else {
+                self.log.error('unknown operation %s', opts.operation);
             }
-        });
-    }
-
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
-
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
-        }
-    });
-
-    var moray = ModelWaitlist.getMoray();
-
-    // We have removed the 'finished' ticket, if there is another ticket in the
-    // queue, now we need to mark the "top" ticket as active, and then write
-    // back the updated queue.
-    vasync.waterfall([
-        function (wfcb) {
-            if (queue.length) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
-
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
 
-                        self.log.info({ ticket: nextticket },
-                            'ticket %s is next to be activated',
-                            nextticket.uuid);
+            self.log.info({ operation: opts.operation,
+                batchData: batchOperations },
+                'updateTicketActivateNext: batch batchOperations');
 
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
-                    });
-                return;
-            }
-            wfcb();
+            next();
         },
-        function (wfcb) {
-            self.log.info({ batch: data },
-                          'doing batch write after finishing %s', ticket.uuid);
-            moray.batch(data, function (err, meta) {
+
+        // Look up the next ticket to be activated so we can activate it at
+        // the same time as we update/delete the ticket that was passed in.
+        function doFindNextTicket(next) {
+            ModelWaitlist.findNextTickets({
+                server_uuid: ticket.server_uuid,
+                limit: 1,
+                omitActive: true,
+                id: ticket.id,
+                scope: ticket.scope
+            },
+            function onFindTicket(err, results) {
                 if (err) {
-                    self.log.warn({ err: err },
-                        'batch error after finishing %s', ticket.uuid);
+                    next(err);
+                    return;
                 }
 
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                self.log.warn(
-                                    { err: err2 },
-                                    'ensureServerQueue error %s', ticket.uuid);
-                                wfcb(err2);
-                                return;
-                            }
-                            self.log.warn(
-                                { err: err },
-                                'retrying ' +
-                                'self.finishTicketUpdateQueueActivateNext %s',
-                                ticket.uuid);
-                            self.finishTicketUpdateQueueActivateNext(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
+                // If there are no more tickets to activate we can skip
+                // everything after this.
+                if (!results.length) {
+                    next();
                     return;
-                } else {
-                    wfcb();
                 }
-            });
-        }
-    ],
-    function (wferr) {
-        self.log.info(
-            { err: wferr }, 'error self.finishTicketUpdateQueueActivateNext %s',
-            ticket.uuid);
-        callback(wferr);
-    });
-};
 
+                var nextTicket = results[0].ticket;
+                var nextEtag = results[0].etag;
 
+                // If there was a subsequent ticket to our given one waiting
+                // to be activated, update its values and write it back out.
+                // Otherwise, we can skip this part.
 
-ModelWaitlist.prototype.pushTicketUpdateQueue =
-function (ticket, serverqueue, etag, callback) {
-    var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
+                if (!nextTicket) {
+                    self.log.info('no ticket following update of %s',
+                        ticket.uuid);
+                    next();
+                    return;
+                }
 
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
-        }
-    });
+                nextTicket.updated_at = (new Date()).toISOString();
+                nextTicket.status = TICKET_STATUS_ACTIVE;
 
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
-    }
+                self.log.info({ nextTicket: nextTicket },
+                    'ticket to be activated');
 
-    if (!serverqueue.tickets[key].length) {
-        ticket.status = 'active';
-    } else {
-        ticket.status = 'queued';
-    }
+                batchOperations.push({
+                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
+                    key: nextTicket.uuid,
+                    operation: 'put',
+                    value: nextTicket,
+                    options: {
+                        etag: nextEtag
+                    }
+                });
+                next();
+            });
+        },
 
-    ticket.created_at =
-    ticket.updated_at =
-    serverqueue.updated_at =
-        (new Date()).toISOString();
+        // Actually execute the batch.
+        function batchUpdate(next) {
+            self.log.debug({
+                batch: batchOperations
+            }, 'performing batch operation to activate next ticket');
 
-    serverqueue.tickets[key].push(ticket.uuid);
+            moray.batch(batchOperations, function (err, _meta) {
+                if (err &&
+                    (VError.hasCauseWithName(err,
+                        'EtagConflictError') ||
+                    (VError.hasCauseWithName(err,
+                        'UniqueAttributeError')))) {
 
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            value: ticket
-        },
-        {
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
-            }
-        }
-    ];
+                    self.log.warn({ err: err },
+                        'modifyTicketActivateNext: batch conflict, retrying');
 
-    var moray = ModelWaitlist.getMoray();
-    moray.batch(data, function (err, meta) {
-        if (err && (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-        {
-            process.nextTick(function () {
-                self.ensureServerQueue(function (err2, resp) {
-                    if (err2) {
-                        callback(err2);
-                        return;
-                    }
+                    self.modifyTicketActivateNext(opts, next);
+                    return;
+                } else if (err) {
+                    next(new VError(err,
+                        'updateTicketActivateNext: batch error'));
+                    return;
+                }
 
-                    self.pushTicketUpdateQueue(
-                        ticket,
-                        resp.serverqueue,
-                        resp.etag, callback);
-                });
+                next();
             });
-            return;
-        } else {
-            callback(null, serverqueue.tickets[key]);
         }
+    ],
+    function (wferr) {
+        self.log.info({ err: wferr }, 'updateTicketActivateNext: finished');
+        callback(wferr);
     });
 };
 
 
+/* BEGIN JSSTYLED */
+/*
+ * Create a new ticket record and write it into moray. If there are existing
+ * tickets for the same `server_uuid`, `scope` and `id`, the new ticket will
+ * receive a status of 'queued'.
+ *
+ * @param opts {Object}
+ * @param opts.scope {String} ticket scope
+ * @param opts.id {String} The id of resource within given scope
+ * @param opts.expires_at {String} isodate when ticket is considered expired
+ * @param opts.action {OptionalString} action associated with this ticket
+ * @param opts.req_id {OptionalString} restify request id
+ * @param opts.extra {OptionalObject} arbitrary metadata set by caller
+ * @param callback {Function} `function (err, createdTicketUuid)`
+ */
+/* END JSSTYLED */
 
-ModelWaitlist.prototype.createTicket = function (params, callback) {
+ModelWaitlist.prototype.createTicket =
+function ModelWaitlistCreateTicket(opts, callback) {
     var self = this;
 
-    assert.object(params, 'params');
-    assert.string(params.scope, 'params.scope');
-    assert.string(params.id, 'params.id');
-    assert.string(params.expires_at, 'params.expires_at');
-
-    var ticket_uuid = libuuid.create();
+    assert.object(opts, 'opts');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.expires_at, 'opts.expires_at');
+    assert.optionalString(opts.action, 'opts.action');
+    assert.optionalString(opts.req_id, 'opts.req_id');
+    assert.optionalObject(opts.extra, 'opts.extra');
+    assert.func(callback, 'callback');
 
-    var serverqueue = null;
-    var etag = null;
     var ticket = {
-        uuid: ticket_uuid,
+        uuid: libuuid.create(),
         server_uuid: this.uuid,
-        scope: params.scope,
-        id: params.id,
-        expires_at: params.expires_at,
+        scope: opts.scope,
+        id: opts.id,
+        expires_at: opts.expires_at,
         created_at: (new Date()).toISOString(),
         updated_at: (new Date()).toISOString(),
-        status: 'queued',
-        action: params.action,
-        reqid: params.req_id,
-        extra: params.extra || {}
+        reqid: opts.req_id,
+        extra: opts.extra || {}
     };
-    var queue;
 
-    self.log.info({
-        ticket: ticket
-    }, 'creating ticket %s', ticket_uuid);
-
-    vasync.waterfall([
-        ensureServerQueue,
-        writeTicket,
-        getQueueTickets
-    ],
-    function (wferror) {
-        callback(wferror, ticket_uuid, queue);
-    });
 
-    // Read the value of server queue and make sure it exists before
-    // continuing. If it doesn't exist, create it, taking care of dealing with
-    // write conflicts.
-
-    function ensureServerQueue(cb) {
-        self.ensureServerQueue(function (err, resp) {
-            if (err) {
-                cb(err);
-                return;
-            }
-
-            etag = resp.etag;
-            serverqueue = resp.serverqueue;
-
-            cb();
-        });
-    }
-
-    // Write the ticket out and update the queue in a moray transaction
-    // (via `batch`). If we get an 'conflict' error, retry starting back at
-    // ensureServerQueue.
-
-    function writeTicket(cb) {
-        self.pushTicketUpdateQueue(
-            ticket, serverqueue, etag,
-            function (err, pQueue) {
-                queue = pQueue;
-                cb(err);
-            });
-    }
-
-    // Look up any tickets in our scope before ours
-    function getQueueTickets(cb) {
-        vasync.forEachParallel({
-            'func': ModelWaitlist.getTicket,
-            'inputs': queue
-        }, function (err, pQueue) {
-            queue = pQueue.successes.sort(function (a, b) {
-                return a.created_at > b.created_at;
-            });
-            cb();
-        });
+    if (jsprim.hasKey(opts, 'action')) {
+        ticket.action = opts.action;
     }
-};
-
 
+    self.log.info({
+        ticket: ticket
+    }, 'creating ticket %s', ticket.uuid);
 
-ModelWaitlist.prototype.expireTicket = function (ticket_uuid, callback) {
-    // Steps to release a ticket:
-    // Batch
-    //   - confirm ticket status to see if there is any actual work to be done
-    //   - confirm queue status to see if there is any actual work to be done
-    //
-    // Batch:
-    //   - delete ticket
-    //   - remove ticket from queue
-    //   - update next ticket's status => active if it is first
+    var tickets;
 
-    var self = this;
-    var ticket;
-    var serverqueue;
-    var etag;
-    var wl;
+    vasync.waterfall([
+        /*
+         * Check if there are existing tickets for this server/scope/id
+         * combination. If there are, we'll set this ticket's status to
+         * 'queued'. If there are no currently queued or active tickets, we'll
+         * make this one 'active'.
+         */
+        function determineWhetherToActivate(next) {
+            ModelWaitlist.findNextTickets({
+                server_uuid: self.uuid,
+                scope: opts.scope,
+                id: opts.id
+            }, function _onDetermineWhetherToActivate(err, _tickets) {
+                if (err) {
+                    next(err);
+                    return;
+                }
 
-    self.log.info({ uuid: ticket_uuid }, 'going to expire ticket');
+                tickets = _tickets.map(function (t) {
+                    return t.ticket;
+                });
 
-    vasync.waterfall([
-        function (wfcb) {
-            ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
-                    if (geterror) {
-                        wfcb(new VError(
-                            geterror, 'failed to load ticket %s',
-                            ticket_uuid));
-                        return;
-                    }
+                if (tickets.length) {
+                    ticket.status = TICKET_STATUS_QUEUED;
+                } else {
+                    ticket.status = TICKET_STATUS_ACTIVE;
+                }
+                next();
+            });
+        },
 
-                    if (!respticket) {
-                        wfcb(new VError(
-                            'no such ticket %s', ticket_uuid));
+        /*
+         * Write this ticket object out to moray.
+         */
+        function writeTicketToMoray(next) {
+            ModelWaitlist.getMoray().putObject(
+                MORAY_BUCKET_WAITLIST_TICKETS,
+                ticket.uuid,
+                ticket,
+                function (puterror) {
+                    if (puterror) {
+                        next(VError(puterror,
+                            'failed to write ticket %s to moray',
+                            ticket.uuid));
                         return;
                     }
-
-                    ticket = respticket;
-                    wfcb();
+                    next();
                 });
         },
-        function (wfcb) {
-            ModelWaitlist.log.info(
-                { ticket: ticket }, 'the ticket to be expired was');
-            wl = new ModelWaitlist({ uuid: ticket.server_uuid });
-            wl.getServerQueue(function (err, respserverqueue, res) {
+        /*
+         * Finally, look up the ticket queue one more time, and return it to
+         * the caller.
+         */
+
+        function refreshTickets(next) {
+            ModelWaitlist.findNextTickets({
+                server_uuid: self.uuid,
+                scope: opts.scope,
+                id: opts.id
+            }, function _onFindNextTickets(err, _tickets) {
                 if (err) {
-                    callback(VError(
-                        err, 'loading waitlist queue for server %s',
-                        ticket.server_uuid));
+                    next(err);
                     return;
                 }
 
-                serverqueue = respserverqueue;
-                etag = res.etag;
-
-                wfcb();
+                tickets = _tickets.map(function (t) {
+                    return t.ticket;
+                });
+                next();
             });
-        },
-        function (wfcb) {
-            ticket.status = 'expired';
-            ticket.updated_at = (new Date()).toISOString();
-            wl.expireTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
         }
     ],
-    function (err) {
-        callback(err);
+    function endWaterfall(wferror) {
+        callback(wferror, ticket.uuid, tickets);
     });
 };
 
+/**
+ * Function called when a ticket is has exhausted the lifetime (ie it's
+ * expires_at timestamp is now in the past).
+ */
 
-ModelWaitlist.deleteTicket =
-function (ticket_uuid, callback) {
-    // Steps to release a ticket:
-    // Batch
-    //   - confirm ticket status to see if there is any actual work to be done
-    //   - confirm queue status to see if there is any actual work to be done
-    //
-    // Batch:
-    //   - delete ticket
-    //   - remove ticket from queue
-    //   - update next ticket's status => active if it is first
-
-    var ticket;
-    var serverqueue;
-    var etag;
-    var wl;
-
-    vasync.waterfall([
-        function (wfcb) {
-            ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
-                    if (geterror) {
-                        wfcb(new VError(geterror, 'failed to load ticket %s',
-                                        ticket_uuid));
-                        return;
-                    }
 
-                    if (!respticket) {
-                        wfcb(new VError('no such ticket %s', ticket_uuid));
-                        return;
-                    }
+ModelWaitlist.expireTicket =
+function ModelWaitlistExpireTicket(ticket_uuid, callback) {
+    var self = this;
 
-                    ticket = respticket;
-                    wfcb();
-                });
-        },
-        function (wfcb) {
-            ModelWaitlist.log.info(
-                { ticket: ticket }, 'the ticket to be deleted was');
-            wl = new ModelWaitlist({ uuid: ticket.server_uuid });
-            wl.getServerQueue(function (err, respserverqueue, res) {
-                if (err) {
-                    callback(VError(
-                        err, 'loading waitlist queue for server %s',
-                        ticket.server_uuid));
-                    return;
-                }
+    assert.string(ticket_uuid, 'ticket_uuid');
 
-                serverqueue = respserverqueue;
-                etag = res.etag;
+    self.log.info({ uuid: ticket_uuid }, 'going to expire ticket');
 
-                wfcb();
-            });
-        },
-        function (wfcb) {
-            ticket.status = 'finished';
-            ticket.updated_at = (new Date()).toISOString();
-            wl.removeTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
+    ModelWaitlist.modifyTicketActivateNext({
+        ticket_uuid: ticket_uuid,
+        operation: TICKET_OPERATION_UPDATE,
+        update: {
+            status: TICKET_STATUS_EXPIRED
         }
-    ],
-    function (err) {
-        callback(err);
-    });
+    }, callback);
 };
 
 
-/**
- * Only clears the queue on a `cnapi_waitlist_queues` bucket item.
+/*
+ * Release an active waitlist ticket, and allow and subsequent tickets for the
+ * same scope/id combination to be activated. The status for the given ticket
+ * will be set as 'finished'.
+ *
+ * @param ticket_uuid {String} The ticket to be released.
+ * @param callback {Function} `function (err)`
  */
 
-ModelWaitlist.prototype.emptyServerQueue = function (callback) {
+ModelWaitlist.releaseTicket =
+function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
     var self = this;
-    var serverqueue = null;
-    var moray = ModelWaitlist.getMoray();
 
-    vasync.waterfall([
-        function (wfcb) {
-            self.getServerQueue(function (err, s, res) {
-                if (err) {
-                    wfcb(err);
-                    return;
-                }
-
-                serverqueue = s;
-                wfcb();
-            });
+    assert.string(ticket_uuid, 'ticket_uuid');
 
-        },
-        function (wfcb) {
-            serverqueue = {
-                server_uuid: self.uuid,
-                updated_at: (new Date()).toISOString(),
-                tickets: {}
-            };
-
-            moray.putObject(
-                buckets.waitlist_queues.name,
-                self.uuid,
-                serverqueue,
-                {},
-                function (err, response) {
-                    if (err) {
-                        wfcb(err);
-                        return;
-                    }
+    self.log.info({ uuid: ticket_uuid }, 'going to release ticket');
 
-                    wfcb();
-                    return;
-                });
+    ModelWaitlist.modifyTicketActivateNext({
+        ticket_uuid: ticket_uuid,
+        operation: TICKET_OPERATION_UPDATE,
+        update: {
+            status: TICKET_STATUS_FINISHED
         }
-    ],
-    function (err) {
-        callback(err, { serverqueue: serverqueue });
-    });
+    }, callback);
+};
+
+
+/*
+ * Delete a waitlist ticket, and allow and subsequent tickets for the same
+ * scope/id combination to be activated. The status for the given ticket will
+ * be set as 'finished'.
+ *
+ * @param ticket_uuid {String} The ticket to be released.
+ * @param callback {Function} `function (err)`
+ */
+ModelWaitlist.deleteTicket =
+function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
+    var self = this;
+
+    assert.string(ticket_uuid, 'ticket_uuid');
+
+    self.log.info({ uuid: ticket_uuid }, 'going to delete ticket');
+
+    ModelWaitlist.modifyTicketActivateNext({
+        ticket_uuid: ticket_uuid,
+        operation: TICKET_OPERATION_DELETE
+    }, callback);
 };
 
 
@@ -1393,21 +1038,15 @@ ModelWaitlist.prototype.deleteAllTickets = function (callback) {
 
     var done = false;
 
-    self.emptyServerQueue(function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
-        async.whilst(
-            function () { return !done; },
-            onIteration, onDone);
-    });
+    async.whilst(
+        function () { return !done; },
+        onIteration, onDone);
 
     function onIteration(wlcb) {
         vasync.waterfall([
             function (wfcb) {
                 ModelWaitlist.getMoray().deleteMany(
-                    buckets.waitlist_tickets.name,
+                    MORAY_BUCKET_WAITLIST_TICKETS,
                     '(server_uuid=' + self.uuid + ')',
                     function (delError) {
                         if (delError) {
@@ -1482,13 +1121,15 @@ ModelWaitlist.prototype.countTickets = function (callback) {
 
 
 ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
-    ModelWaitlist.getTicket(uuid, function (geterror, ticket) {
+    ModelWaitlist.getTicket(uuid, function (geterror, result) {
         if (geterror) {
             callback(
                 VError(geterror, 'failed to retrieve ticket %s', uuid));
             return;
         }
 
+        var ticket = result.ticket;
+
         if (params.status) {
             ticket.status = params.status;
         }
@@ -1496,14 +1137,13 @@ ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
         ticket.updated_at = (new Date()).toISOString();
 
         ModelWaitlist.getMoray().putObject(
-            buckets.waitlist_tickets.name,
+            MORAY_BUCKET_WAITLIST_TICKETS,
             uuid,
             ticket,
             function (puterror) {
                 if (puterror) {
                     callback(
-                        VError(puterror,
-                            'failed to store updated ticket'));
+                        VError(puterror, 'failed to store updated ticket'));
                     return;
                 }
                 callback();
diff --git a/test/waitlist/test-waitlist.js b/test/waitlist/test-waitlist.js
index 0362060..3ff7f34 100644
--- a/test/waitlist/test-waitlist.js
+++ b/test/waitlist/test-waitlist.js
@@ -132,6 +132,7 @@ function testCreateTicket(test) {
             }
 
             function onForEachEnd(err) {
+                console.dir(queues);
                 test.equal(queues[0].length, 1);
                 test.equal(queues[1].length, 2);
                 test.equal(queues[0].length, 1);
@@ -214,31 +215,32 @@ function testCreateTicket(test) {
     });
 }
 
+function testCreateWaitDeleteTicket(test) {
+    var scope = 'test-create-wait-delete-ticket';
+    var id = '123';
+
+    var expires_at = '3000';
 
-function testCreateWaitReleaseTicket(test) {
-    var expireTimeSeconds = 3;
-    var expireTimeSeconds2 = 4;
     var ticketPayload = {
-        scope: 'test-create-wait-release-ticket',
-        id: '123',
-        expires_at: (
-            new Date((new Date().valueOf()) +
-                      expireTimeSeconds * 1000)).toISOString()
+        scope: scope,
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 1 }
     };
 
     var ticketPayload2 = {
-        scope: 'test-create-wait-release-ticket',
-        id: '123',
-        expires_at: (
-            new Date((new Date().valueOf()) +
-                      expireTimeSeconds2 * 1000)).toISOString()
+        scope: 'test-create-wait-delete-ticket',
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 2 }
     };
 
     var ticket;
     var ticket2;
 
     async.waterfall([
-        function (wfcb) {
+        // create first ticket
+        function (next) {
             client.post(wlurl, ticketPayload, function (err, req, res, t) {
                 test.deepEqual(err, null);
                 test.equal(
@@ -247,10 +249,11 @@ function testCreateWaitReleaseTicket(test) {
                 test.ok(t, 'got an ticket');
                 test.ok(t.uuid, 'got a ticket uuid');
 
-                wfcb();
+                next(err);
             });
         },
-        function (wfcb) {
+        // create second ticket
+        function (next) {
             client.post(wlurl, ticketPayload2, function (err, req, res, t) {
                 test.deepEqual(err, null);
                 test.equal(
@@ -259,55 +262,61 @@ function testCreateWaitReleaseTicket(test) {
                 test.ok(t, 'got an ticket');
                 test.ok(t.uuid, 'got a ticket uuid');
 
-                wfcb();
+                next(err);
             });
         },
-        function (wfcb) {
-            setTimeout(function () {
-                wfcb();
-            }, 1000);
-        },
-        function (wfcb) {
+        // ensure queue looks ok
+        function (next) {
             client.get(wlurl, function (err, req, res, waitlist) {
-                test.equal(err, null, 'valid response from GET /servers');
+                test.deepEqual(err, null);
                 test.ok(res, 'got a response');
                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
                 test.ok(waitlist.length);
 
-                ticket = waitlist[1];
-                ticket2 = waitlist[2];
+                ticket = waitlist[0];
+                ticket2 = waitlist[1];
+
+                console.dir(waitlist);
 
+                test.deepEqual(ticket.extra, ticketPayload.extra,
+                    'ticket1 extra should match');
+                test.deepEqual(ticket2.extra, ticketPayload2.extra,
+                    'ticket2 extra should match');
                 test.deepEqual(ticket.status, 'active');
                 test.deepEqual(ticket2.status, 'queued');
 
                 test.ok(ticket);
 
-                wfcb();
+                next();
             });
         },
-        function (wfcb) {
-            setTimeout(function () {
-                wfcb();
-            }, expireTimeSeconds2 * 1000);
-        },
-        function (wfcb) {
-            client.get(wlurl, function (err, req, res, waitlist) {
-                test.equal(err, null, 'valid response from GET /servers');
-                test.ok(res, 'got a response');
-                test.equal(res.statusCode, 200, 'GET waitlist returned 200');
-                test.ok(waitlist.length);
+        function (next) {
+            /*
+             * In parallel:
+             *     - wait for the second ticket to be active
+             *     - delete the first ticket
+             *
+             *  Then check the second ticket becomes active.
+             */
+
+            var waitUrl = sprintf('/tickets/%s/wait', ticket2.uuid);
+            var delUrl = sprintf('/tickets/%s', ticket.uuid);
+
+            process.nextTick(function () {
+                console.log('waiting');
+                client.get(waitUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                    next(err);
+                });
+            });
 
-                ticket = waitlist[1];
-                ticket2 = waitlist[2];
-                test.ok(ticket);
 
-                wfcb();
-            });
-        },
-        function (wfcb) {
-            test.deepEqual(ticket.status, 'expired');
-//             test.deepEqual(ticket2.status, 'active');
-            wfcb();
+            setTimeout(function () {
+                console.log('deleting');
+                client.del(delUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                });
+            }, 2000);
         }
     ],
     function (error) {
@@ -316,43 +325,118 @@ function testCreateWaitReleaseTicket(test) {
     });
 }
 
-function testUpdateTicket(test) {
-    test.expect(4);
 
-//     var date;
-    var ticketurl = sprintf('%s/%s', wlurl, ticketuuid);
+function testCreateWaitReleaseTicket(test) {
+    var scope = 'test-create-wait-release-ticket';
+    var id = '123';
+
+    var expires_at = '3000';
+
+    var ticketPayload = {
+        scope: scope,
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 1 }
+    };
+
+    var ticketPayload2 = {
+        scope: 'test-create-wait-release-ticket',
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 2 }
+    };
+
+    var ticket;
+    var ticket2;
 
     async.waterfall([
-        function (wfcb) {
-            client.get(ticketurl, function (err, req, res, ticket) {
-                test.equal(err, null, 'valid response from GET /servers');
+        // create first ticket
+        function (next) {
+            client.post(wlurl, ticketPayload, function (err, req, res, t) {
+                test.deepEqual(err, null);
+                test.equal(
+                    res.statusCode, 202, 'POST waitlist ticket returned 202');
+                test.ok(res, 'got a response');
+                test.ok(t, 'got an ticket');
+                test.ok(t.uuid, 'got a ticket uuid');
+
+                next(err);
+            });
+        },
+        // create second ticket
+        function (next) {
+            client.post(wlurl, ticketPayload2, function (err, req, res, t) {
+                test.deepEqual(err, null);
+                test.equal(
+                    res.statusCode, 202, 'POST waitlist ticket returned 202');
+                test.ok(res, 'got a response');
+                test.ok(t, 'got an ticket');
+                test.ok(t.uuid, 'got a ticket uuid');
+
+                next(err);
+            });
+        },
+        // ensure queue looks ok
+        function (next) {
+            client.get(wlurl, function (err, req, res, waitlist) {
+                test.deepEqual(err, null);
                 test.ok(res, 'got a response');
                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
+                test.ok(waitlist.length);
+
+                ticket = waitlist[0];
+                ticket2 = waitlist[1];
+
+                console.dir(waitlist);
+
+                test.deepEqual(ticket.extra, ticketPayload.extra,
+                    'ticket1 extra should match');
+                test.deepEqual(ticket2.extra, ticketPayload2.extra,
+                    'ticket2 extra should match');
+                test.deepEqual(ticket.status, 'active');
+                test.deepEqual(ticket2.status, 'queued');
+
                 test.ok(ticket);
-                wfcb();
+
+                next();
             });
         },
-        function (wfcb) {
-//             client.post(ticketurl, function (err, req, res, ticket) {
-//                 test.equal(err, null, 'valid response from GET /servers');
-//                 test.ok(res, 'got a response');
-//                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
-//                 test.ok(waitlist);
-//                 date = wa
-//                 test.done();
-//             });
-            wfcb();
-        },
-        function (wfcb) {
-            wfcb();
+        function (next) {
+            /*
+             * In parallel:
+             *     - wait for the second ticket to be active
+             *     - release the first ticket
+             *
+             *  Then check the second ticket becomes active.
+             */
+
+            var waitUrl = sprintf('/tickets/%s/wait', ticket2.uuid);
+            var relUrl = sprintf('/tickets/%s/release', ticket.uuid);
+
+            process.nextTick(function () {
+                console.log('waiting');
+                client.get(waitUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                    next(err);
+                });
+            });
+
+            setTimeout(function () {
+                console.log('releasing');
+                client.put(relUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                });
+            }, 2000);
         }
     ],
     function (error) {
+        test.equal(error, null);
         test.done();
     });
 }
 
 
+
 /**
  * Try listing tickets using legal and bogus `limit` and `offset` values.
  */
@@ -688,5 +772,7 @@ module.exports = {
     'limit, offset parameter validation': testLimitOffsetValidation,
     'list from server with paging': testFetchTicketsWithPaging,
     'delete from server with over 1000 results':
-        testDeleteOver1000Tickets
+        testDeleteOver1000Tickets,
+    'create, wait, release ticket': testCreateWaitReleaseTicket,
+    'create, wait, delete ticket': testCreateWaitDeleteTicket
 };
-- 
2.21.0

