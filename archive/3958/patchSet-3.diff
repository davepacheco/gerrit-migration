From 0e805e97ee93e36b94849bcfea17704596f2ddde Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Fri, 18 May 2018 17:18:22 -0700
Subject: [PATCH] TRITON-233 CNAPI's should only use one moray bucket to manage
 waitlist tickets

---
 lib/endpoints/waitlist.js      |  10 +-
 lib/models/waitlist.js         | 819 +++++++++++++++++----------------
 test/waitlist/test-waitlist.js | 225 ++++++---
 3 files changed, 570 insertions(+), 484 deletions(-)

diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index d0087e1..9d2e99c 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -175,9 +175,9 @@ function handlerControllerWaitlistCreateTicket(req, res, next) {
 
 ControllerWaitlist.getTicket =
 function handlerControllerWaitlistGetTicket(req, res, next) {
-    ModelWaitlist.getTicket(req.params.ticket_uuid, function (error, ticket) {
-        if (ticket) {
-            res.send(200, ticket);
+    ModelWaitlist.getTicket(req.params.ticket_uuid, function (error, result) {
+        if (result.ticket) {
+            res.send(200, result.ticket);
             next();
             return;
         } else {
@@ -311,13 +311,13 @@ ControllerWaitlist.releaseTicket =
 function handlerControllerWaitlistReleaseTicket(req, res, next) {
     var ticket_uuid = req.params.ticket_uuid;
 
-    ModelWaitlist.getTicket(ticket_uuid, function (error, ticket) {
+    ModelWaitlist.getTicket(ticket_uuid, function (error, result) {
         if (error) {
             next(new restify.InternalError(error.message));
             return;
         }
 
-        if (!ticket) {
+        if (!result.ticket) {
             var errorMsg = 'ticket ' + ticket_uuid + ' not found';
             next(new restify.ResourceNotFoundError(errorMsg));
             return;
diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index 70ad6df..85a34ee 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -13,6 +13,8 @@
  * See docs/waitlist.md for more details.
  */
 
+// 'use strict';
+
 var assert = require('assert-plus');
 var async = require('async');
 var libuuid = require('libuuid');
@@ -28,6 +30,11 @@ var common = require('../common');
 var orderedKVString = require('../common').orderedKVString;
 
 
+// ticket status values
+var TICKET_STATUS_ACTIVE = 'active';
+var TICKET_STATUS_EXPIRED = 'expired';
+var TICKET_STATUS_FINISHED = 'finished';
+
 // how long, (in ms), between checks to moray for ticket updates
 var WAITLIST_PERIOD_MS = 500;
 
@@ -54,10 +61,9 @@ function WaitlistDirector(params) {
 }
 
 
-
 /**
- * Begins checking moray for ticket updates and taking action based on changes
- * therein.
+ * Begin checking moray for ticket updates and taking action based on said
+ * changes.
  */
 
 WaitlistDirector.prototype.start = function () {
@@ -143,9 +149,7 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
         function (ticket, fecb) {
             var i;
             // Check if ticket needs to be expired.
-            if (ticket.status === 'expired' &&
-                self.callbacks[ticket.uuid])
-            {
+            if (ticket.status === 'expired' && self.callbacks[ticket.uuid]) {
                 self.log.info(
                     'ticket %s expired, invoking %d callbacks',
                     ticket.uuid, self.callbacks[ticket.uuid].length);
@@ -161,8 +165,7 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
             // marked as such.
             } else if (ticket.status !== 'finished' &&
                        timestamp &&
-                       timestamp.toISOString() > ticket.expires_at)
-            {
+                       timestamp.toISOString() > ticket.expires_at) {
                 var wl = new ModelWaitlist({ uuid: ticket.server_uuid });
                 wl.expireTicket(ticket.uuid, function (err) {
                     if (err) {
@@ -217,26 +220,28 @@ WaitlistDirector.prototype.waitForTicketByUuid = function (uuid, callback) {
 
     self.log.info('waitForTicketByUuid: ticket %s', uuid);
 
-    ModelWaitlist.getTicket(uuid, function (error, t) {
+    ModelWaitlist.getTicket(uuid, function (error, result) {
         if (error) {
             callback(new VError('fetching ticket %s', uuid));
             return;
         }
 
-        // If the ticket doesn't exist in moray, it doesn't exist period.
-        if (!t) {
+        var ticket = result.ticket;
+
+        // if the ticket doesn't exist, callback with error
+        if (!ticket) {
             callback(new VError('no such ticket %s', uuid));
             return;
         }
 
-        if (t.status === 'active') {
+        if (ticket.status === 'active') {
             self.log.warn(
                 'ticket %s found active', uuid);
              callback();
              return;
         }
 
-        if (t.status === 'expired') {
+        if (ticket.status === 'expired') {
             self.log.warn(
                 'ticket %s found expired', uuid);
              callback(new VError('ticket %s is expired', uuid));
@@ -277,7 +282,8 @@ ModelWaitlist.createWaitlistDirector = function (params) {
 
 
 ModelWaitlist.init = function (app) {
-    var self = ModelWaitlist;
+    var self = this;
+
     self.app = app;
 
     Object.keys(ModelBase.staticFn).forEach(function (p) {
@@ -289,10 +295,40 @@ ModelWaitlist.init = function (app) {
 };
 
 
+/**
+ * Fetch a ticket from moray by given ticket uuid.
+ *
+ * @param {String} ticket
+ * @param callback {Function} `function (err, { ticket: ticket, etag: etag })`
+ */
 
-ModelWaitlist.ticketsUpdatedSince = function (params, callback) {
+ModelWaitlist.getTicket = function (uuid, callback) {
     var self = ModelWaitlist;
+
+    ModelWaitlist.getMoray().getObject(
+        buckets.waitlist_tickets.name, uuid, onGet);
+
+    function onGet(error, obj) {
+        if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError')) {
+            self.log.error('ticket %s not found in moray', uuid);
+            callback(null, {});
+            return;
+        } else if (error) {
+            self.log.error(error, 'error fetching ticket from moray');
+            callback(error);
+            return;
+        }
+
+        callback(null, { ticket: obj.value, etag: obj._etag });
+    }
+};
+
+
+ModelWaitlist.ticketsUpdatedSince = function (params, callback) {
+    var self = this;
+
     var filter;
+    var findOpts;
 
     self.log.trace('checking for tickets since %s', params.timestamp);
 
@@ -322,7 +358,7 @@ ModelWaitlist.ticketsUpdatedSince = function (params, callback) {
         filter = '&(!(status=expired))(!(status=finished))';
     }
 
-    var findOpts = {
+    findOpts = {
         sort: {
             attribute: 'created_at',
             order: 'DESC'
@@ -376,47 +412,57 @@ WaitlistDirector.cleanupOldTickets = function (callback) {
 };
 
 
+/*
+ * Release an active waitlist ticket, and allow and subsequent tickets for the
+ * same scope/id combination to be activated. The status for the given ticket
+ * will be set as 'finished'.
+ *
+ * Steps to release a ticket:
+ *   - look up ticket (A) to be released
+ *   - look up next ticket (B) for the (server/scope/id) of (A) to be activated
+ *     (if any)
+ *
+ * Batch:
+ *   - put ticket (A) status => 'finished', updated_at times
+ *   - update next ticket's (B) status
+ *
+ * @param ticket_uuid {String} The ticket to be released.
+ * @param callback {Function} `function (err)`
+ */
+
 ModelWaitlist.ticketRelease = function (ticket_uuid, callback) {
-    var self = ModelWaitlist;
-    // Steps to release a ticket:
-    // Batch
-    //   - confirm ticket status to see if there is any actual work to be done
-    //   - confirm queue status to see if there is any actual work to be done
-    //
-    // Batch:
-    //   - put ticket status => 'finished', updated_at times
-    //   - remove ticket from queue
-    //   - update next ticket's status => active if it is first
+    var self = this;
 
     var ticket;
+    var ticketEtag;
     var serverqueue;
     var etag;
     var wl;
 
     vasync.waterfall([
-        function (wfcb) {
-            ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
-                    if (geterror) {
-                        wfcb(VError(geterror, 'failed to load ticket %s',
-                                    ticket_uuid));
-                        return;
-                    }
+        function getTicket(next) {
+            ModelWaitlist.getTicket(ticket_uuid, function (getError, result) {
+                if (getError) {
+                    next(VError(getError,
+                        'failed to load ticket %s', ticket_uuid));
+                    return;
+                }
 
-                    if (!respticket) {
-                        wfcb(VError('no such ticket %s', ticket_uuid));
-                        return;
-                    }
+                if (!result.ticket) {
+                    next(VError('no such ticket %s', ticket_uuid));
+                    return;
+                }
 
-                    ticket = respticket;
-                    wfcb();
-                });
+                ticket = result.ticket;
+                ticketEtag = result.etag;
+                next();
+            });
         },
-        function (wfcb) {
+        function getServerQueue(next) {
             wl = new ModelWaitlist({ uuid: ticket.server_uuid });
             wl.getServerQueue(function (err, respserverqueue, res) {
                 if (err) {
-                    wfcb(VError(err, 'loading waitlist queue for server %s',
+                    next(VError(err, 'loading waitlist queue for server %s',
                         ticket.server_uuid));
                     return;
                 }
@@ -424,23 +470,25 @@ ModelWaitlist.ticketRelease = function (ticket_uuid, callback) {
                 serverqueue = respserverqueue;
                 etag = res.etag;
 
-                wfcb();
+                next();
             });
         },
-        function (wfcb) {
+        function finishTicket(next) {
             self.log.info(
                 'ticket %s released; activating next if any', ticket.uuid);
-            wl.finishTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
+            wl.finishTicketUpdateQueueActivateNext({
+                ticket: ticket,
+                ticketEtag: ticketEtag,
+                serverQueue: serverqueue,
+                serverQueueEtag: etag }, next);
         }
     ],
-    function (err) {
+    function waterfallDone(err) {
         callback(err);
     });
 };
 
 
-
 ModelWaitlist.list = function (params, callback) {
     assert.optionalString(params.server_uuid, 'params.server_uuid');
     assert.optionalNumber(params.limit, 'params.limit');
@@ -467,12 +515,17 @@ ModelWaitlist.list = function (params, callback) {
     ModelWaitlist.query('(server_uuid=' + uuid + ')', queryOpts, callback);
 };
 
+/*
+ * Do a moray query and return an array of the response objects.
+ *
+ * @param filter {String}
+ * @param findOpts {Object}
+ * @param callback {Function} `function (err, responses)`
+ */
 
+ModelWaitlist.queryWithMeta = function (filter, findOpts, callback) {
+    var self    = this;
 
-ModelWaitlist.query = function (filter, findOpts, callback) {
-    assert.optionalObject(findOpts, 'findOpts');
-
-    var self    = ModelWaitlist;
     var moray   = ModelWaitlist.getMoray();
     var bucket  = buckets.waitlist_tickets.name;
     var tickets = [];
@@ -485,6 +538,8 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
         offset: 0
     };
 
+    assert.optionalObject(findOpts, 'findOpts');
+
     if (!callback) {
         callback = findOpts;
         findOpts = {};
@@ -532,8 +587,8 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
         oncecb(err, tickets);
     }
 
-    function onRecord(ticket) {
-        tickets.push(ticket.value);
+    function onRecord(ticketres) {
+        tickets.push(ticketres);
     }
 
     function processResults() {
@@ -545,31 +600,76 @@ ModelWaitlist.query = function (filter, findOpts, callback) {
     req.on('end', processResults);
 };
 
+/*
+ * Look up a ticket by uuid and return the ticket object.
+ *
+ * @param uuid {String}
+ * @param callback {Function} `function (err, ticketValue, responseObj)`
+ */
 
+/*
+ * Do a moray query and call callback with an array of the `value` property
+ * from the responses.
+ *
+ * @param filter {String}
+ * @param findOpts {Object}
+ * @param callback {Function} `function (err, values)`
+ */
 
-ModelWaitlist.getTicket = function (uuid, callback) {
-    var self = ModelWaitlist;
+ModelWaitlist.query = function (filter, findOpts, callback) {
+    var self = this;
 
-    ModelWaitlist.getMoray().getObject(
-        buckets.waitlist_tickets.name, uuid, onGet);
+    assert.string(filter, 'filter');
+    assert.object(findOpts, 'findOpts');
 
-    function onGet(error, obj) {
-        if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError')) {
-            self.log.error('Ticket %s not found in moray', uuid);
-            callback();
+    // Grab the response values.
+    self.queryWithMeta(filter, findOpts, function (err, responses) {
+        if (err) {
+            callback(err);
             return;
-        } else if (error) {
-            self.log.error(error, 'Error fetching ticket from moray');
-            callback(error);
+        }
+        var values = responses.map(function (r) {
+            return r.value;
+        });
+
+        callback(null, values);
+    });
+};
+
+
+/*
+ * Do a moray query and call callback with an array of the `value` property
+ * from the responses.
+ *
+ * @param filter {String}
+ * @param findOpts {Object}
+ * @param callback {Function} `function (err, values)`
+ */
+
+ModelWaitlist.query = function (filter, findOpts, callback) {
+    assert.string(filter, 'filter');
+    assert.object(findOpts, 'findOpts');
+
+    var self = this;
+
+    // Grab the response values.
+    self.queryWithMeta(filter, findOpts, function (err, responses) {
+        if (err) {
+            callback(err);
             return;
         }
+        var values = responses.map(function (r) {
+            return r.value;
+        });
 
-        callback(null, obj.value);
-    }
+        callback(null, values);
+    });
 };
 
 
 
+
+
 ModelWaitlist.prototype.getServerQueue = function (callback) {
     var self = this;
     var serverqueue;
@@ -670,376 +770,265 @@ ModelWaitlist.prototype.ensureServerQueue = function (callback) {
 };
 
 
+/*
+ * Expire a ticket given a ticket payload and a server queue object. If there
+ * is another ticket in the queue after the expired one, activate it.i
+ *
+ * This function is run on tickets we have detected have an expiry time set in
+ * the past, but are not yet marked as 'expired'.
+ *
+ * This function will modify the `opts.ticket` object.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.ticket
+ * @param {String} opts.ticketEtag
+ * @param {Object} opts.serverQueue
+ * @param {String} opts.serverQueueEtag
+ * @param {Function} callback
+ */
 
-ModelWaitlist.prototype.removeTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
+ModelWaitlist.prototype.expireTicketUpdateQueueActivateNext =
+function (opts, callback) {
     var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
 
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
-    }
-
-    ticket.created_at =
-    serverqueue.updated_at =
-        (new Date()).toISOString();
+    assert.object(opts, 'opts');
+    assert.object(opts.ticket, 'opts.ticket');
+    assert.string(opts.ticketEtag, 'opts.ticketEtag');
+    assert.object(opts.serverQueue, 'opts.serverQueue');
+    assert.string(opts.serverQueueEtag, 'opts.serverQueueEtag');
 
-    var queue = serverqueue.tickets[key];
-    var ticketIdx = queue.indexOf(ticket.uuid);
-    var wasTop = (ticketIdx === 0 ? true : false);
+    var ticket = jsprim.deepCopy(opts.ticket);
 
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            operation: 'delete'
-        }
-    ];
+    ticket.status = TICKET_STATUS_EXPIRED;
 
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
-        data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
-            }
-        });
-    }
+    self.updateTicketActivateNext({
+        ticket: ticket,
+        ticketEtag: opts.ticketEtag,
+        serverQueue: opts.serverQueue,
+        serverQueueEtag: opts.serverQueueEtag
+    }, callback);
+};
 
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
 
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
-        }
-    });
+ModelWaitlist.prototype.finishTicketUpdateQueueActivateNext =
+function (opts, callback) {
+    var self = this;
 
-    var moray = ModelWaitlist.getMoray();
+    assert.object(opts, 'opts');
+    assert.object(opts.ticket, 'opts.ticket');
+    assert.string(opts.ticketEtag, 'opts.ticketEtag');
+    assert.object(opts.serverQueue, 'opts.serverQueue');
+    assert.string(opts.serverQueueEtag, 'opts.serverQueueEtag');
 
-    // We have removed the 'finished' ticket, if there is another ticket in the
-    // queue, now we need to mark the "top" ticket as active, and then write
-    // back the updated queue.
-    vasync.waterfall([
-        function (wfcb) {
-            if (queue.length && wasTop) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
+    var ticket = jsprim.deepCopy(opts.ticket);
 
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
+    ticket.status = TICKET_STATUS_FINISHED;
 
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
-                    });
-                return;
-            }
-            wfcb();
-        },
-        function (wfcb) {
-            moray.batch(data, function (err, meta) {
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                wfcb(err2);
-                                return;
-                            }
-                            self.pushTicketUpdateQueue(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
-                    return;
-                } else {
-                    wfcb();
-                }
-            });
-        }
-    ],
-    function (wferr) {
-        callback(wferr);
-    });
+    self.updateTicketActivateNext({
+        ticket: ticket,
+        ticketEtag: opts.ticketEtag,
+        serverQueue: opts.serverQueue,
+        serverQueueEtag: opts.serverQueueEtag
+    }, callback);
 };
 
 
+ModelWaitlist.prototype.deleteTicketUpdateQueueActivateNext =
+function (opts, callback) {
+    var self = this;
 
-/**
- * Expire a ticket given a ticket payload and a server queue object.
+    assert.object(opts, 'opts');
+    assert.object(opts.ticket, 'opts.ticket');
+    assert.string(opts.ticketEtag, 'opts.ticketEtag');
+    assert.object(opts.serverQueue, 'opts.serverQueue');
+    assert.string(opts.serverQueueEtag, 'opts.serverQueueEtag');
+
+    var ticket = jsprim.deepCopy(opts.ticket);
+
+    self.updateTicketActivateNext({
+        del: true,
+        ticket: ticket,
+        ticketEtag: opts.ticketEtag,
+        serverQueue: opts.serverQueue,
+        serverQueueEtag: opts.serverQueueEtag
+    }, callback);
+};
+
+/*
+ * Update a ticket in moray, and activate the next ticket (by creation_date)
+ * with the same set formed by `ticket.scope`, `ticket.server_uuid`, and
+ * `ticket.id`.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.ticket
+ * @param {String} opts.ticketEtag
+ * @param {Object} opts.serverQueue
+ * @param {String} opts.serverQueueEtag
+ * @param {Function} callback
  */
 
-ModelWaitlist.prototype.expireTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
+ModelWaitlist.prototype.updateTicketActivateNext =
+function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
     var self = this;
+
+    assert.object(opts, 'opts');
+    assert.optionalBool(opts.del, 'opts.del');
+    assert.object(opts.ticket, 'opts.ticket');
+    assert.string(opts.ticketEtag, 'opts.ticketEtag');
+    assert.object(opts.serverQueue, 'opts.serverQueue');
+    assert.string(opts.serverQueueEtag, 'opts.serverQueueEtag');
+
+    var ticket = opts.ticket;
+    var ticketEtag = opts.ticketEtag;
+    var serverQueue = opts.serverQueue;
+    var serverQueueEtag = opts.serverQueueEtag;
     var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
 
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
+    if (!serverQueue.tickets[key]) {
+        serverQueue.tickets[key] = [];
     }
 
-    ticket.status = 'expired';
     ticket.updated_at =
-    serverqueue.updated_at =
+    serverQueue.updated_at =
         (new Date()).toISOString();
 
-    var queue = serverqueue.tickets[key];
+    var queue = serverQueue.tickets[key];
     var ticketIdx = queue.indexOf(ticket.uuid);
     var wasTop = (ticketIdx === 0 ? true : false);
 
-    var data = [
-        {
-            bucket: buckets.waitlist_tickets.name,
-            key: ticket.uuid,
-            operation: 'put',
-            value: ticket
-        }
-    ];
-
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
-        data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
-            options: {
-                etag: etag
-            }
-        });
-    }
-
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
-
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
-        }
-    });
-
-    var moray = ModelWaitlist.getMoray();
-
-    // We have removed the 'expired' ticket, if there is another ticket in the
-    // queue, now we need to mark the "top" ticket as active, and then write
-    // back the updated queue.
-    vasync.waterfall([
-        function (wfcb) {
-            if (queue.length && wasTop) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
-
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
-
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
-                    });
-                return;
-            }
-            wfcb();
-        },
-        function (wfcb) {
-            self.log.debug({
-                batch: data
-            }, 'performing batch operation to activate next ticket');
-            moray.batch(data, function (err, meta) {
-                if (err) {
-                    self.log.error({
-                        err: err
-                    }, 'Error when performing batch operation');
-                }
-
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                wfcb(err2);
-                                return;
-                            }
-
-                            self.log.debug('retrying ' +
-                                'expireTicketUpdateQueueActivateNext');
-                            self.expireTicketUpdateQueueActivateNext(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
+    // If the ticket id was not found in the server queue we can simply
+    // update or remove the ticket as necessary and callback.
+    if (ticketIdx === -1) {
+        if (opts.del) {
+            ModelWaitlist.getMoray().delObject(
+                buckets.waitlist_tickets.name,
+                ticket.uuid,
+                { etag: ticketEtag },
+                function (err) {
+                    callback(err);
                     return;
-                } else {
-                    wfcb();
-                }
-            });
+                });
+        } else {
+            ModelWaitlist.getMoray().putObject(
+                buckets.waitlist_tickets.name,
+                ticket.uuid,
+                ticket,
+                { etag: ticketEtag },
+                function (err) {
+                    callback(err);
+                    return;
+                });
         }
-    ],
-    function (wferr) {
-        callback(wferr);
-    });
-};
-
 
-
-ModelWaitlist.prototype.finishTicketUpdateQueueActivateNext =
-function (ticket, serverqueue, etag, callback) {
-    var self = this;
-    var key = orderedKVString({ id: ticket.id, scope: ticket.scope });
-
-    if (!serverqueue.tickets[key]) {
-        serverqueue.tickets[key] = [];
+        return;
     }
 
-    ticket.status = 'finished';
-    ticket.updated_at = serverqueue.updated_at = (new Date()).toISOString();
+    // Remove the given ticket from the queue object which we will write back
+    // into moray.
+    queue.splice(ticketIdx, 1);
+    serverQueue.tickets[key] = queue;
 
-    var queue = serverqueue.tickets[key];
-    var ticketIdx = queue.indexOf(ticket.uuid);
+    var data = [];
 
-    /**
-     * Craft the payload we will submit to moray.batch()
-     *
-     * This includes:
-     *   - modifying the metadata on the finished ticket
-     *   - remove finished ticket from the queue it's in
-     *   - modifying the metadata on the next ticket in the queue
-     */
-    var data = [
-        {
+    if (opts.del) {
+        data.push({
             bucket: buckets.waitlist_tickets.name,
             key: ticket.uuid,
-            value: ticket
-        }
-    ];
-
-    // if ticket is in serverqueue
-    if (ticketIdx !== -1) {
+            operation: 'delete',
+            value: ticket,
+            options: {
+                etag: ticketEtag
+            }
+        });
+    } else {
         data.push({
-            bucket: buckets.waitlist_queues.name,
-            key: self.uuid,
-            value: serverqueue,
+            bucket: buckets.waitlist_tickets.name,
+            key: ticket.uuid,
+            operation: 'put',
+            value: ticket,
             options: {
-                etag: etag
+                etag: ticketEtag
             }
         });
     }
 
-    queue.splice(ticketIdx, 1);
-    serverqueue.tickets[key] = queue;
+    data.push({
+        bucket: buckets.waitlist_queues.name,
+        key: self.uuid,
+        value: serverQueue,
+        options: {
+            etag: serverQueueEtag
+        }
+    });
 
-    Object.keys(serverqueue.tickets).forEach(function (k) {
-        if (!serverqueue.tickets[k].length) {
-            delete serverqueue.tickets[k];
+    self.log.info({ batchData: data }, 'updateTicketActivateNext: batch data');
+
+    // If any of the queues on the server are empty, we can clean them up.
+    Object.keys(serverQueue.tickets).forEach(function (k) {
+        if (!serverQueue.tickets[k].length) {
+            delete serverQueue.tickets[k];
         }
     });
 
     var moray = ModelWaitlist.getMoray();
 
-    // We have removed the 'finished' ticket, if there is another ticket in the
+    // We have removed the 'expired' ticket, if there is another ticket in the
     // queue, now we need to mark the "top" ticket as active, and then write
     // back the updated queue.
     vasync.waterfall([
-        function (wfcb) {
-            if (queue.length) {
-                ModelWaitlist.getTicket(queue[0],
-                    function (geterror, respticket) {
-                        if (geterror) {
-                            wfcb(geterror);
-                            return;
-                        }
-                        var nextticket = respticket;
+        function setupBatch(next) {
+            if (queue.length && wasTop) {
+                ModelWaitlist.getTicket(queue[0], function (getError, result) {
+                    if (getError) {
+                        next(getError);
+                        return;
+                    }
 
-                        nextticket.updated_at = (new Date()).toISOString();
-                        nextticket.status = 'active';
+                    var nextTicket = result.ticket;
 
-                        self.log.info({ ticket: nextticket },
-                            'ticket %s is next to be activated',
-                            nextticket.uuid);
+                    nextTicket.updated_at = (new Date()).toISOString();
+                    nextTicket.status = 'active';
 
-                        data.push({
-                            bucket: buckets.waitlist_tickets.name,
-                            key: queue[0],
-                            value: nextticket
-                        });
-                        wfcb();
+                    data.push({
+                        bucket: buckets.waitlist_tickets.name,
+                        key: queue[0],
+                        value: nextTicket,
+                        options: {
+                            etag: result.etag
+                        }
                     });
+                    next();
+                });
                 return;
             }
-            wfcb();
+
+            next();
         },
-        function (wfcb) {
-            self.log.info({ batch: data },
-                          'doing batch write after finishing %s', ticket.uuid);
-            moray.batch(data, function (err, meta) {
+        function batchUpdate(next) {
+            self.log.debug({
+                batch: data
+            }, 'performing batch operation to activate next ticket');
+            moray.batch(data, function (err, _meta) {
                 if (err) {
-                    self.log.warn({ err: err },
-                        'batch error after finishing %s', ticket.uuid);
-                }
-
-                if (err &&
-                   (VError.hasCauseWithName(err, 'EtagConflictError') ||
-                   (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
-                {
-                    process.nextTick(function () {
-                        self.ensureServerQueue(function (err2, resp) {
-                            if (err2) {
-                                self.log.warn(
-                                    { err: err2 },
-                                    'ensureServerQueue error %s', ticket.uuid);
-                                wfcb(err2);
-                                return;
-                            }
-                            self.log.warn(
-                                { err: err },
-                                'retrying ' +
-                                'self.finishTicketUpdateQueueActivateNext %s',
-                                ticket.uuid);
-                            self.finishTicketUpdateQueueActivateNext(
-                                ticket,
-                                resp.serverqueue,
-                                resp.etag, wfcb);
-                        });
-                    });
+                    next(err);
                     return;
-                } else {
-                    wfcb();
                 }
+
+                next();
             });
         }
     ],
     function (wferr) {
-        self.log.info(
-            { err: wferr }, 'error self.finishTicketUpdateQueueActivateNext %s',
-            ticket.uuid);
+        self.log.info({ err: wferr }, 'updateTicketActivateNext: finished');
         callback(wferr);
     });
 };
 
 
+/*
+ * Add a ticket obejct to moray, and push a reference to the end of the server
+ * queue.
+ */
 
 ModelWaitlist.prototype.pushTicketUpdateQueue =
 function (ticket, serverqueue, etag, callback) {
@@ -1086,7 +1075,7 @@ function (ticket, serverqueue, etag, callback) {
     ];
 
     var moray = ModelWaitlist.getMoray();
-    moray.batch(data, function (err, meta) {
+    moray.batch(data, function (err, _meta) {
         if (err && (VError.hasCauseWithName(err, 'EtagConflictError') ||
                    (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
         {
@@ -1188,15 +1177,19 @@ ModelWaitlist.prototype.createTicket = function (params, callback) {
         vasync.forEachParallel({
             'func': ModelWaitlist.getTicket,
             'inputs': queue
-        }, function (err, pQueue) {
+        }, function (_err, pQueue) {
             queue = pQueue.successes.sort(function (a, b) {
-                return a.created_at > b.created_at;
-            });
+                return a.ticket.created_at > b.ticket.created_at;
+            }).map(function (t) { return t.ticket; });
             cb();
         });
     }
 };
 
+/**
+ * Function called when a ticket is has exhausted the lifetime (ie it's
+ * expires_at timestamp is now in the past).
+ */
 
 
 ModelWaitlist.prototype.expireTicket = function (ticket_uuid, callback) {
@@ -1214,32 +1207,32 @@ ModelWaitlist.prototype.expireTicket = function (ticket_uuid, callback) {
     var ticket;
     var serverqueue;
     var etag;
+    var ticketEtag;
     var wl;
 
     self.log.info({ uuid: ticket_uuid }, 'going to expire ticket');
 
     vasync.waterfall([
-        function (wfcb) {
-            ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
-                    if (geterror) {
-                        wfcb(new VError(
-                            geterror, 'failed to load ticket %s',
-                            ticket_uuid));
-                        return;
-                    }
+        function (next) {
+            ModelWaitlist.getTicket(ticket_uuid, function (getError, result) {
+                if (getError) {
+                    next(new VError(
+                        getError, 'failed to load ticket %s', ticket_uuid));
+                    return;
+                }
 
-                    if (!respticket) {
-                        wfcb(new VError(
-                            'no such ticket %s', ticket_uuid));
-                        return;
-                    }
+                if (!result.ticket) {
+                    next(new VError(
+                        'no such ticket %s', ticket_uuid));
+                    return;
+                }
 
-                    ticket = respticket;
-                    wfcb();
-                });
+                ticket = result.ticket;
+                ticketEtag = result.etag;
+                next();
+            });
         },
-        function (wfcb) {
+        function (next) {
             ModelWaitlist.log.info(
                 { ticket: ticket }, 'the ticket to be expired was');
             wl = new ModelWaitlist({ uuid: ticket.server_uuid });
@@ -1254,14 +1247,16 @@ ModelWaitlist.prototype.expireTicket = function (ticket_uuid, callback) {
                 serverqueue = respserverqueue;
                 etag = res.etag;
 
-                wfcb();
+                next();
             });
         },
-        function (wfcb) {
-            ticket.status = 'expired';
-            ticket.updated_at = (new Date()).toISOString();
-            wl.expireTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
+        function (next) {
+            wl.expireTicketUpdateQueueActivateNext({
+                ticket: ticket,
+                ticketEtag: ticketEtag,
+                serverQueue: serverqueue,
+                serverQueueEtag: etag
+            }, next);
         }
     ],
     function (err) {
@@ -1283,30 +1278,32 @@ function (ticket_uuid, callback) {
     //   - update next ticket's status => active if it is first
 
     var ticket;
+    var ticketEtag;
     var serverqueue;
     var etag;
     var wl;
 
     vasync.waterfall([
-        function (wfcb) {
+        function (next) {
             ModelWaitlist.getTicket(ticket_uuid,
-                function (geterror, respticket) {
+                function (geterror, result) {
                     if (geterror) {
-                        wfcb(new VError(geterror, 'failed to load ticket %s',
+                        next(new VError(geterror, 'failed to load ticket %s',
                                         ticket_uuid));
                         return;
                     }
 
-                    if (!respticket) {
-                        wfcb(new VError('no such ticket %s', ticket_uuid));
+                    if (!result.ticket) {
+                        next(new VError('no such ticket %s', ticket_uuid));
                         return;
                     }
 
-                    ticket = respticket;
-                    wfcb();
+                    ticket = result.ticket;
+                    ticketEtag = result.etag;
+                    next();
                 });
         },
-        function (wfcb) {
+        function (next) {
             ModelWaitlist.log.info(
                 { ticket: ticket }, 'the ticket to be deleted was');
             wl = new ModelWaitlist({ uuid: ticket.server_uuid });
@@ -1321,14 +1318,17 @@ function (ticket_uuid, callback) {
                 serverqueue = respserverqueue;
                 etag = res.etag;
 
-                wfcb();
+                next();
             });
         },
-        function (wfcb) {
+        function (next) {
             ticket.status = 'finished';
             ticket.updated_at = (new Date()).toISOString();
-            wl.removeTicketUpdateQueueActivateNext(
-                ticket, serverqueue, etag, wfcb);
+            wl.deleteTicketUpdateQueueActivateNext({
+                ticket: ticket,
+                ticketEtag: ticketEtag,
+                serverQueue: serverqueue,
+                serverQueueEtag: etag }, next);
         }
     ],
     function (err) {
@@ -1482,13 +1482,15 @@ ModelWaitlist.prototype.countTickets = function (callback) {
 
 
 ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
-    ModelWaitlist.getTicket(uuid, function (geterror, ticket) {
+    ModelWaitlist.getTicket(uuid, function (geterror, result) {
         if (geterror) {
             callback(
                 VError(geterror, 'failed to retrieve ticket %s', uuid));
             return;
         }
 
+        var ticket = result.ticket;
+
         if (params.status) {
             ticket.status = params.status;
         }
@@ -1502,8 +1504,7 @@ ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
             function (puterror) {
                 if (puterror) {
                     callback(
-                        VError(puterror,
-                            'failed to store updated ticket'));
+                        VError(puterror, 'failed to store updated ticket'));
                     return;
                 }
                 callback();
diff --git a/test/waitlist/test-waitlist.js b/test/waitlist/test-waitlist.js
index 0362060..a40c4cf 100644
--- a/test/waitlist/test-waitlist.js
+++ b/test/waitlist/test-waitlist.js
@@ -214,31 +214,32 @@ function testCreateTicket(test) {
     });
 }
 
+function testCreateWaitDeleteTicket(test) {
+    var scope = 'test-create-wait-delete-ticket';
+    var id = '123';
+
+    var expires_at = '3000';
 
-function testCreateWaitReleaseTicket(test) {
-    var expireTimeSeconds = 3;
-    var expireTimeSeconds2 = 4;
     var ticketPayload = {
-        scope: 'test-create-wait-release-ticket',
-        id: '123',
-        expires_at: (
-            new Date((new Date().valueOf()) +
-                      expireTimeSeconds * 1000)).toISOString()
+        scope: scope,
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 1 }
     };
 
     var ticketPayload2 = {
-        scope: 'test-create-wait-release-ticket',
-        id: '123',
-        expires_at: (
-            new Date((new Date().valueOf()) +
-                      expireTimeSeconds2 * 1000)).toISOString()
+        scope: 'test-create-wait-delete-ticket',
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 2 }
     };
 
     var ticket;
     var ticket2;
 
     async.waterfall([
-        function (wfcb) {
+        // create first ticket
+        function (next) {
             client.post(wlurl, ticketPayload, function (err, req, res, t) {
                 test.deepEqual(err, null);
                 test.equal(
@@ -247,10 +248,11 @@ function testCreateWaitReleaseTicket(test) {
                 test.ok(t, 'got an ticket');
                 test.ok(t.uuid, 'got a ticket uuid');
 
-                wfcb();
+                next(err);
             });
         },
-        function (wfcb) {
+        // create second ticket
+        function (next) {
             client.post(wlurl, ticketPayload2, function (err, req, res, t) {
                 test.deepEqual(err, null);
                 test.equal(
@@ -259,55 +261,61 @@ function testCreateWaitReleaseTicket(test) {
                 test.ok(t, 'got an ticket');
                 test.ok(t.uuid, 'got a ticket uuid');
 
-                wfcb();
+                next(err);
             });
         },
-        function (wfcb) {
-            setTimeout(function () {
-                wfcb();
-            }, 1000);
-        },
-        function (wfcb) {
+        // ensure queue looks ok
+        function (next) {
             client.get(wlurl, function (err, req, res, waitlist) {
-                test.equal(err, null, 'valid response from GET /servers');
+                test.deepEqual(err, null);
                 test.ok(res, 'got a response');
                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
                 test.ok(waitlist.length);
 
-                ticket = waitlist[1];
-                ticket2 = waitlist[2];
+                ticket = waitlist[0];
+                ticket2 = waitlist[1];
+
+                console.dir(waitlist);
 
+                test.deepEqual(ticket.extra, ticketPayload.extra,
+                    'ticket1 extra should match');
+                test.deepEqual(ticket2.extra, ticketPayload2.extra,
+                    'ticket2 extra should match');
                 test.deepEqual(ticket.status, 'active');
                 test.deepEqual(ticket2.status, 'queued');
 
                 test.ok(ticket);
 
-                wfcb();
+                next();
             });
         },
-        function (wfcb) {
-            setTimeout(function () {
-                wfcb();
-            }, expireTimeSeconds2 * 1000);
-        },
-        function (wfcb) {
-            client.get(wlurl, function (err, req, res, waitlist) {
-                test.equal(err, null, 'valid response from GET /servers');
-                test.ok(res, 'got a response');
-                test.equal(res.statusCode, 200, 'GET waitlist returned 200');
-                test.ok(waitlist.length);
+        function (next) {
+            /*
+             * In parallel:
+             *     - wait for the second ticket to be active
+             *     - delete the first ticket
+             *
+             *  Then check the second ticket becomes active.
+             */
+
+            var waitUrl = sprintf('/tickets/%s/wait', ticket2.uuid);
+            var delUrl = sprintf('/tickets/%s', ticket.uuid);
+
+            process.nextTick(function () {
+                console.log('waiting');
+                client.get(waitUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                    next(err);
+                });
+            });
 
-                ticket = waitlist[1];
-                ticket2 = waitlist[2];
-                test.ok(ticket);
 
-                wfcb();
-            });
-        },
-        function (wfcb) {
-            test.deepEqual(ticket.status, 'expired');
-//             test.deepEqual(ticket2.status, 'active');
-            wfcb();
+            setTimeout(function () {
+                console.log('deleting');
+                client.del(delUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                });
+            }, 2000);
         }
     ],
     function (error) {
@@ -316,43 +324,118 @@ function testCreateWaitReleaseTicket(test) {
     });
 }
 
-function testUpdateTicket(test) {
-    test.expect(4);
 
-//     var date;
-    var ticketurl = sprintf('%s/%s', wlurl, ticketuuid);
+function testCreateWaitReleaseTicket(test) {
+    var scope = 'test-create-wait-release-ticket';
+    var id = '123';
+
+    var expires_at = '3000';
+
+    var ticketPayload = {
+        scope: scope,
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 1 }
+    };
+
+    var ticketPayload2 = {
+        scope: 'test-create-wait-release-ticket',
+        id: id,
+        expires_at: expires_at,
+        extra: { foo: 2 }
+    };
+
+    var ticket;
+    var ticket2;
 
     async.waterfall([
-        function (wfcb) {
-            client.get(ticketurl, function (err, req, res, ticket) {
-                test.equal(err, null, 'valid response from GET /servers');
+        // create first ticket
+        function (next) {
+            client.post(wlurl, ticketPayload, function (err, req, res, t) {
+                test.deepEqual(err, null);
+                test.equal(
+                    res.statusCode, 202, 'POST waitlist ticket returned 202');
+                test.ok(res, 'got a response');
+                test.ok(t, 'got an ticket');
+                test.ok(t.uuid, 'got a ticket uuid');
+
+                next(err);
+            });
+        },
+        // create second ticket
+        function (next) {
+            client.post(wlurl, ticketPayload2, function (err, req, res, t) {
+                test.deepEqual(err, null);
+                test.equal(
+                    res.statusCode, 202, 'POST waitlist ticket returned 202');
+                test.ok(res, 'got a response');
+                test.ok(t, 'got an ticket');
+                test.ok(t.uuid, 'got a ticket uuid');
+
+                next(err);
+            });
+        },
+        // ensure queue looks ok
+        function (next) {
+            client.get(wlurl, function (err, req, res, waitlist) {
+                test.deepEqual(err, null);
                 test.ok(res, 'got a response');
                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
+                test.ok(waitlist.length);
+
+                ticket = waitlist[0];
+                ticket2 = waitlist[1];
+
+                console.dir(waitlist);
+
+                test.deepEqual(ticket.extra, ticketPayload.extra,
+                    'ticket1 extra should match');
+                test.deepEqual(ticket2.extra, ticketPayload2.extra,
+                    'ticket2 extra should match');
+                test.deepEqual(ticket.status, 'active');
+                test.deepEqual(ticket2.status, 'queued');
+
                 test.ok(ticket);
-                wfcb();
+
+                next();
             });
         },
-        function (wfcb) {
-//             client.post(ticketurl, function (err, req, res, ticket) {
-//                 test.equal(err, null, 'valid response from GET /servers');
-//                 test.ok(res, 'got a response');
-//                 test.equal(res.statusCode, 200, 'GET waitlist returned 200');
-//                 test.ok(waitlist);
-//                 date = wa
-//                 test.done();
-//             });
-            wfcb();
-        },
-        function (wfcb) {
-            wfcb();
+        function (next) {
+            /*
+             * In parallel:
+             *     - wait for the second ticket to be active
+             *     - release the first ticket
+             *
+             *  Then check the second ticket becomes active.
+             */
+
+            var waitUrl = sprintf('/tickets/%s/wait', ticket2.uuid);
+            var relUrl = sprintf('/tickets/%s/release', ticket.uuid);
+
+            process.nextTick(function () {
+                console.log('waiting');
+                client.get(waitUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                    next(err);
+                });
+            });
+
+            setTimeout(function () {
+                console.log('releasing');
+                client.put(relUrl, function (err, req, res) {
+                    test.deepEqual(err, null);
+                });
+            }, 2000);
         }
     ],
     function (error) {
+        test.equal(error, null);
         test.done();
     });
 }
 
 
+
 /**
  * Try listing tickets using legal and bogus `limit` and `offset` values.
  */
@@ -688,5 +771,7 @@ module.exports = {
     'limit, offset parameter validation': testLimitOffsetValidation,
     'list from server with paging': testFetchTicketsWithPaging,
     'delete from server with over 1000 results':
-        testDeleteOver1000Tickets
+        testDeleteOver1000Tickets,
+    'create, wait, release ticket': testCreateWaitReleaseTicket,
+    'create, wait, delete ticket': testCreateWaitDeleteTicket
 };
-- 
2.21.0

