commit d3d7437f9c8a5e9bddfe3a92ecf9043ce0c1a832 (refs/changes/43/943/3)
Author: Trent Mick <trent.mick@joyent.com>
Date:   2016-11-29T16:55:45-08:00 (2 years, 10 months ago)
    
    joyent/node-manta#214 basic bash tab completion

diff --git a/CHANGES.md b/CHANGES.md
index 7ad48c6..40b8c91 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,9 @@
 
 ## not yet released
 
+- joyent/node-manta#214 Add basic Bash completion for the `m*` tools.
+  "Basic" here means options and mjob subcommands are completed, not
+  yet support for completing manta paths.
 - joyent/node-manta#288 mfind of file blows assertion: "ent (object) is required"
 
 ## 4.0.0
diff --git a/Makefile b/Makefile
index bad9da0..724a0f8 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2016 Joyent, Inc.
 #
 
 #
@@ -34,6 +34,9 @@ MAN_OUTDIR      := man/man1
 MAN_OUTPAGES=$(MAN_PAGES:%.md=$(MAN_OUTDIR)/%.1)
 MAN_ROOT        := docs/man
 
+COMPLETION_CMDS := $(shell find bin -type f)
+COMPLETION_FILE=share/manta.completion
+
 #
 # Repo-specific targets
 #
@@ -116,6 +119,29 @@ $(MAN_OUTDIR)/%.1: $(MAN_ROOT)/%.md | $(MAN_OUTDIR)
 manpages: $(MAN_OUTPAGES)
 
 
+#
+# Each m* tool has a '--completion' option to emit Bash completion code. We
+# gather all those to a share/manta.completion file for users to source.
+#
+
+$(COMPLETION_OUTDIR):
+	mkdir -p $@
+
+$(COMPLETION_OUTDIR)/%.completion: $(COMPLETION_ROOT)/% | $(COMPLETION_OUTDIR)
+	$^ --completion > $@
+
+.PHONY: completion
+completion: $(COMPLETION_FILE)
+
+$(COMPLETION_FILE): $(COMPLETION_CMDS) lib/create_client.js
+	echo "# node-manta tools v$(shell cat package.json | json version) completion" >$@
+	echo $(COMPLETION_CMDS) | xargs -n1 basename | sed -E 's/(.*)/#   \1(1)/' >>$@
+	echo "" >>$@
+	for cmd in $(COMPLETION_CMDS); do \
+		$$cmd --completion | grep -v '^#' >>$@; \
+	done
+
+
 # Ensure CHANGES.md and package.json have the same version.
 .PHONY: versioncheck
 versioncheck:
diff --git a/README.md b/README.md
index 9a1af4d..e581700 100644
--- a/README.md
+++ b/README.md
@@ -10,6 +10,28 @@ project.  See [CONTRIBUTING.md](CONTRIBUTING.md) for contribution guidelines.
 
     $ npm install manta -g
 
+
+### Bash completion
+
+Optionally install Bash completion. This is done by `source`ing the
+"share/manta.completion" file that is installed with the tools. If you
+installed with `npm install manta -g` as above, then that is:
+
+```bash
+source $(npm prefix -g)/lib/node_modules/manta/share/manta.completion
+```
+
+Put that (or the equivalent) in your "~/.bashrc" file to make it permanent.
+
+You can verify that completions are working by typing the `TAB` key with
+the following:
+
+    $ mls --<TAB>
+    --account   --insecure  --long      --role      --type      --verbose
+    --fulljson  --json      --marker    --subuser   --url       --version
+    --help      --keyId     --reverse   --time      --user
+
+
 # Usage
 
 First setup your environment to match your Joyent Manta account:
diff --git a/bin/mchattr b/bin/mchattr
index 016bee6..32899c4 100755
--- a/bin/mchattr
+++ b/bin/mchattr
@@ -66,6 +66,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/mchmod b/bin/mchmod
index 3269d7f..b3986ab 100755
--- a/bin/mchmod
+++ b/bin/mchmod
@@ -79,6 +79,7 @@ function parseOptions() {
     }
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     var mchmodOpts = parseMchmodOptions(opts._args);
     opts.mchmodOperation = mchmodOpts.operation;
diff --git a/bin/mfind b/bin/mfind
index b562743..3a9b602 100755
--- a/bin/mfind
+++ b/bin/mfind
@@ -104,15 +104,16 @@ function parseOptions() {
         opts = OPTIONS_PARSER.parse(process.argv);
         manta.checkBinEnv(opts);
     } catch (e) {
-        manta.cli_usage(OPTIONS_PARSER, e.message, '[PATH]');
+        manta.cli_usage(OPTIONS_PARSER, e.message, '[PATH...]');
     }
 
     manta.cli_logger(opts, LOG);
 
     if (opts.help)
-        manta.cli_usage(OPTIONS_PARSER, false, '[PATH]');
+        manta.cli_usage(OPTIONS_PARSER, false, '[PATH...]');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts.name)
         opts.name = new RegExp(opts.name);
diff --git a/bin/mget b/bin/mget
index 5075e56..2a7b979 100755
--- a/bin/mget
+++ b/bin/mget
@@ -87,6 +87,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/minfo b/bin/minfo
index ba6383a..f85917d 100755
--- a/bin/minfo
+++ b/bin/minfo
@@ -54,6 +54,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/mjob b/bin/mjob
index da37d0c..b8196de 100755
--- a/bin/mjob
+++ b/bin/mjob
@@ -443,6 +443,12 @@ function MJob() {
                 names: ['version'],
                 type: 'bool',
                 help: 'Print version and exit.'
+            },
+            {
+                names: ['completion'],
+                type: 'bool',
+                help: 'Print bash completion code for this command and exit.',
+                hidden: true
             }
         ],
         helpOpts: {
@@ -454,6 +460,26 @@ util.inherits(MJob, cmdln.Cmdln);
 
 MJob.prototype.init = function (opts, args, callback) {
     manta.cliVersionCheckPrintAndExit(opts);
+
+    if (opts.completion) {
+        /*
+         * To ensure that all our stdout is written before 'process.exit()'
+         * terminates, we set stdout to blocking. This is an issue when
+         * (a) node v4 or later is used and (b) at least when exec'd by node
+         * as in test/completion.test.js. See
+         * https://gist.github.com/misterdjules/3aa4c77d8f881ffccba3b6e6f0050d03
+         * for some discussion. An alternative would be to exit the the node
+         * process without 'process.exit'.
+         */
+        if (process.stdout._handle &&
+            typeof (process.stdout._handle.setBlocking) === 'function')
+        {
+            process.stdout._handle.setBlocking(true);
+        }
+        console.log(this.bashCompletion());
+        process.exit(0);
+    }
+
     cmdln.Cmdln.prototype.init.apply(this, arguments);
 };
 
diff --git a/bin/mln b/bin/mln
index 14f0f77..eebab6e 100755
--- a/bin/mln
+++ b/bin/mln
@@ -66,6 +66,8 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'source dest');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME,
+        ['mpath', 'mpath', 'none']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'source required', 'source dest');
diff --git a/bin/mlogin b/bin/mlogin
index 6c30b0d..0ef4b70 100755
--- a/bin/mlogin
+++ b/bin/mlogin
@@ -130,6 +130,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length > 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/mls b/bin/mls
index 4e1a0ce..b84568d 100755
--- a/bin/mls
+++ b/bin/mls
@@ -99,6 +99,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, '[PATH]...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     opts.paths = [];
     if (opts._args.length < 1) {
diff --git a/bin/mmd5 b/bin/mmd5
index b13f527..182b154 100755
--- a/bin/mmd5
+++ b/bin/mmd5
@@ -58,6 +58,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/mmkdir b/bin/mmkdir
index 8110b0c..c376c60 100755
--- a/bin/mmkdir
+++ b/bin/mmkdir
@@ -76,6 +76,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mdir']);
 
     opts.headers = {};
     (opts.header || []).forEach(function (h) {
diff --git a/bin/mput b/bin/mput
index bd2a772..36fd08c 100755
--- a/bin/mput
+++ b/bin/mput
@@ -118,6 +118,8 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME,
+        ['mpath', 'none']);
 
     if (opts.md5 && !opts.file)
         manta.cli_usage(OPTIONS_PARSER, '--md5 requires --file', 'path...');
diff --git a/bin/mrm b/bin/mrm
index fc358fe..6753d60 100755
--- a/bin/mrm
+++ b/bin/mrm
@@ -71,6 +71,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/mrmdir b/bin/mrmdir
index eff79a7..997e29b 100755
--- a/bin/mrmdir
+++ b/bin/mrmdir
@@ -53,6 +53,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mdir']);
 
     if (opts._args.length < 1)
         manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
diff --git a/bin/msign b/bin/msign
index 0789b55..b0467cc 100755
--- a/bin/msign
+++ b/bin/msign
@@ -94,6 +94,7 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path...');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
 
     opts.method = opts.method.map(function (m) {
         m = m.toUpperCase();
diff --git a/bin/muntar b/bin/muntar
index 613ceee..f50e3db 100755
--- a/bin/muntar
+++ b/bin/muntar
@@ -105,6 +105,8 @@ function parseOptions() {
         manta.cli_usage(OPTIONS_PARSER, false, 'path');
 
     manta.cliVersionCheckPrintAndExit(opts);
+    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME,
+        ['mpath', 'none']);
 
     if (!opts.file)
         manta.cli_usage(OPTIONS_PARSER, 'file is a required argument', 'path');
diff --git a/lib/create_client.js b/lib/create_client.js
index e2db797..65efe8d 100644
--- a/lib/create_client.js
+++ b/lib/create_client.js
@@ -32,6 +32,21 @@ var DEFAULT_OPTIONS = [
         type: 'arrayOfBool',
         help: 'Verbose trace logging.'
     },
+    /*
+     * There is one minor issue with having `--completion` on DEFAULT_OPTIONS:
+     * `mjob` uses DEFAULT_OPTIONS on all its *subcommands* instead of just
+     * having those options at the top-level. I.e. `mjob create -a ACCOUNT ...`
+     * rather than `mjob -a ACCOUNT create ...`.
+     *
+     * This means that there will be a hidden `mjob create --completion`
+     * option that isn't handled. That shouldn't cause any harm.
+     */
+    {
+        names: ['completion'],
+        type: 'bool',
+        help: 'Print bash completion code for this command and exit.',
+        hidden: true
+    },
     {
         group: 'Manta connection options'
     },
@@ -290,6 +305,53 @@ function versionCheckPrintAndExit(opts) {
     }
 }
 
+
+/**
+ * Check the parsed `opts` for usage of the '--completion' option. If used,
+ * then print Bash completion code for this command.
+ *
+ * @param {Object} opts: Required. A dashdash parsed options object.
+ * @param {Object} parser: Required. A dashdash option parser.
+ * @param {String} name: Required. The command name.
+ * @param {Array of String} argtypes: Optional. An array of types for positional
+ *      arguments to this command. See 'argtypes' docs here:
+ *      // JSSTYLED
+ *      <https://github.com/trentm/node-dashdash/blob/1dd7379640462a21ca6d92502803de830b4acfa2/lib/dashdash.js#L753-L760>
+ *      Manta defines the following meaningful types:
+ *          (none yet)
+ */
+function completionCheckPrintAndExit(opts, parser, name, argtypes) {
+    assert.object(opts, 'opts');
+    assert.object(parser, 'parser');
+    assert.string(name, 'name');
+    assert.optionalArrayOfString(argtypes, 'argtypes');
+
+    if (opts.completion) {
+        /*
+         * To ensure that all our stdout is written before 'process.exit()'
+         * terminates, we set stdout to blocking. This is an issue when
+         * (a) node v4 or later is used and (b) at least when exec'd by node
+         * as in test/completion.test.js. See
+         * https://gist.github.com/misterdjules/3aa4c77d8f881ffccba3b6e6f0050d03
+         * for some discussion. An alternative would be to exit the the node
+         * process without 'process.exit'.
+         */
+        if (process.stdout._handle &&
+            typeof (process.stdout._handle.setBlocking) === 'function')
+        {
+            process.stdout._handle.setBlocking(true);
+        }
+
+        console.log(parser.bashCompletion({
+            name: name,
+            argtypes: argtypes
+        }));
+
+        process.exit(0);
+    }
+}
+
+
 ///--- Exports
 
 module.exports = {
@@ -301,7 +363,8 @@ module.exports = {
     DEFAULT_OPTIONS: DEFAULT_OPTIONS,
     usage: usage,
     setupLogger: setupLogger,
-    versionCheckPrintAndExit: versionCheckPrintAndExit
+    versionCheckPrintAndExit: versionCheckPrintAndExit,
+    completionCheckPrintAndExit: completionCheckPrintAndExit
 };
 
 
diff --git a/lib/index.js b/lib/index.js
index 8fb1acd..54d278a 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -44,6 +44,7 @@ module.exports = {
     cli_usage: cc.usage,
     cli_logger: cc.setupLogger,
     cliVersionCheckPrintAndExit: cc.versionCheckPrintAndExit,
+    cliCompletionCheckPrintAndExit: cc.completionCheckPrintAndExit,
     StringStream: StringStream,
     path: manta.path,
     jobPath: manta.jobPath,
diff --git a/package.json b/package.json
index 69e24e4..7135346 100644
--- a/package.json
+++ b/package.json
@@ -14,8 +14,8 @@
         "backoff": "~2.3.0",
         "bunyan": "^1.8.1",
         "clone": "~0.1.11",
-        "cmdln": "4.1.1",
-        "dashdash": "1.14.0",
+        "cmdln": "4.1.2",
+        "dashdash": "1.14.1",
         "extsprintf": "^1.3.0",
         "hogan.js": "~2.0.0",
         "jsprim": "^1.3.0",
diff --git a/share/manta.completion b/share/manta.completion
new file mode 100644
index 0000000..709d224
--- /dev/null
+++ b/share/manta.completion
@@ -0,0 +1,4923 @@
+# node-manta tools v4.0.0 completion
+#   mchattr(1)
+#   mchmod(1)
+#   mfind(1)
+#   mget(1)
+#   minfo(1)
+#   mjob(1)
+#   mln(1)
+#   mlogin(1)
+#   mls(1)
+#   mmd5(1)
+#   mmkdir(1)
+#   mput(1)
+#   mrm(1)
+#   mrmdir(1)
+#   msign(1)
+#   muntar(1)
+
+
+
+
+
+function _mchattr_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-H -a -h -i -k -u -v"
+local cmd_longopts="--account --header --help --insecure --keyId --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --header=arrayOfString --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mchattr_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mchattr_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mchattr_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mchattr_completion mchattr
+elif type compdef &>/dev/null; then
+    function _mchattr_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mchattr_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mchattr_completion mchattr
+elif type compctl &>/dev/null; then
+    function _mchattr_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mchattr_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mchattr_completion mchattr
+fi
+
+
+
+
+
+
+function _mchmod_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -u -v"
+local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mchmod_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mchmod_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mchmod_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mchmod_completion mchmod
+elif type compdef &>/dev/null; then
+    function _mchmod_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mchmod_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mchmod_completion mchmod
+elif type compctl &>/dev/null; then
+    function _mchmod_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mchmod_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mchmod_completion mchmod
+fi
+
+
+
+
+
+
+function _mfind_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -j -k -l -n -p -s -t -u -v"
+local cmd_longopts="--account --help --insecure --json --keyId --limit --maxdepth --mindepth --name --parallel --role --size --subuser --type --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --limit=positiveInteger --maxdepth=positiveInteger --mindepth=positiveInteger --name=string --parallel=positiveInteger --role=arrayOfString --size=positiveInteger --subuser=string --type=string --url=string --user=string -a=string -k=string -l=positiveInteger -n=string -p=positiveInteger -s=positiveInteger -t=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mfind_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mfind_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mfind_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mfind_completion mfind
+elif type compdef &>/dev/null; then
+    function _mfind_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mfind_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mfind_completion mfind
+elif type compctl &>/dev/null; then
+    function _mfind_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mfind_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mfind_completion mfind
+fi
+
+
+
+
+
+
+function _mget_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-H -O -a -h -i -k -o -q -u -v"
+local cmd_longopts="--account --header --help --insecure --keyId --output --progress --quiet --remote-name --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --header=arrayOfString --keyId=string --output=string --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -o=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mget_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mget_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mget_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mget_completion mget
+elif type compdef &>/dev/null; then
+    function _mget_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mget_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mget_completion mget
+elif type compctl &>/dev/null; then
+    function _mget_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mget_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mget_completion mget
+fi
+
+
+
+
+
+
+function _minfo_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -u -v"
+local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_minfo_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _minfo_completion {
+        local _log_file=/dev/null
+        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _minfo_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _minfo_completion minfo
+elif type compdef &>/dev/null; then
+    function _minfo_completion {
+        local _log_file=/dev/null
+        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _minfo_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _minfo_completion minfo
+elif type compctl &>/dev/null; then
+    function _minfo_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _minfo_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _minfo_completion minfo
+fi
+
+
+
+
+
+
+function _mjob_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-h"
+local cmd_longopts="--help --version"
+local cmd_optargs=""
+local cmd_subcmds="addinputs cancel close cost create errors failures get help inputs list outputs share watch"
+local cmd_allsubcmds="addinputs cancel close cost create errors failures get help inputs list outputs share watch"
+
+local cmd__addinputs_shortopts="-a -b -h -i -k -o -p -u -v"
+local cmd__addinputs_longopts="--account --batch --help --insecure --keyId --open --parallel --role --subuser --url --user --verbose --version"
+local cmd__addinputs_optargs="--account=string --batch=positiveInteger --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -b=positiveInteger -k=string -p=positiveInteger -u=string"
+
+local cmd__cancel_shortopts="-a -h -i -k -p -u -v"
+local cmd__cancel_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__cancel_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__close_shortopts="-a -h -i -k -p -u -v"
+local cmd__close_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__close_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__cost_shortopts="-a -h -i -k -n -p -q -u -v"
+local cmd__cost_longopts="--account --help --insecure --keyId --name --parallel --quiet --role --subuser --url --user --verbose --version"
+local cmd__cost_optargs="--account=string --keyId=string --name=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -n=string -p=positiveInteger -u=string"
+
+local cmd__create_shortopts="-a -b -f -h -i -k -m -n -o -p -q -r -s -u -v -w"
+local cmd__create_longopts="--account --asset --batch --cat-outputs --close --count --disk --dry-run --file --help --image --init --insecure --keyId --map --memory --name --open --parallel --quiet --reduce --role --subuser --url --user --verbose --version --watch"
+local cmd__create_optargs="--account=string --asset=arrayOfString --batch=positiveInteger --count=positiveInteger --disk=positiveInteger --file=string --image=string --init=string --keyId=string --map=arrayOfString --memory=positiveInteger --name=string --parallel=positiveInteger --reduce=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -b=positiveInteger -f=string -k=string -m=arrayOfString -n=string -p=positiveInteger -r=arrayOfString -s=arrayOfString -u=string"
+
+local cmd__errors_shortopts="-a -h -i -k -p -u -v"
+local cmd__errors_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__errors_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__failures_shortopts="-a -h -i -k -p -u -v"
+local cmd__failures_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__failures_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__get_shortopts="-a -h -i -k -p -u -v"
+local cmd__get_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__get_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__help_shortopts=""
+local cmd__help_longopts=""
+local cmd__help_optargs=""
+
+local cmd__inputs_shortopts="-a -h -i -k -p -u -v"
+local cmd__inputs_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__inputs_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__list_shortopts="-a -h -i -k -l -n -s -u -v"
+local cmd__list_longopts="--account --help --insecure --keyId --long --name --role --state --subuser --url --user --verbose --version"
+local cmd__list_optargs="--account=string --keyId=string --name=string --role=arrayOfString --state=string --subuser=string --url=string --user=string -a=string -k=string -n=string -s=string -u=string"
+
+local cmd__outputs_shortopts="-a -h -i -k -p -u -v"
+local cmd__outputs_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__outputs_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+local cmd__share_shortopts="-a -h -i -k -r -s -u -v"
+local cmd__share_longopts="--account --help --insecure --keyId --readme --role --stdout --subuser --url --user --verbose --version"
+local cmd__share_optargs="--account=string --keyId=string --readme=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -r=string -u=string"
+
+local cmd__watch_shortopts="-a -h -i -k -p -u -v"
+local cmd__watch_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
+local cmd__watch_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mjob_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mjob_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mjob_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mjob_completion mjob
+elif type compdef &>/dev/null; then
+    function _mjob_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mjob_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mjob_completion mjob
+elif type compctl &>/dev/null; then
+    function _mjob_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mjob_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mjob_completion mjob
+fi
+
+
+
+
+
+
+function _mln_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -u -v"
+local cmd_longopts="--account --help --insecure --keyId --role --role-tag --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
+local cmd_argtypes="mpath mpath none"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mln_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mln_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mln_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mln_completion mln
+elif type compdef &>/dev/null; then
+    function _mln_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mln_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mln_completion mln
+elif type compctl &>/dev/null; then
+    function _mln_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mln_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mln_completion mln
+fi
+
+
+
+
+
+
+function _mlogin_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -c -e -h -i -k -q -s -u -v"
+local cmd_longopts="--account --asset --command --disk --escape --help --image --init --insecure --keyId --memory --quiet --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --asset=arrayOfString --command=string --disk=positiveInteger --escape=string --image=string --init=string --keyId=string --memory=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -c=string -e=string -k=string -s=arrayOfString -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mlogin_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mlogin_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mlogin_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mlogin_completion mlogin
+elif type compdef &>/dev/null; then
+    function _mlogin_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mlogin_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mlogin_completion mlogin
+elif type compctl &>/dev/null; then
+    function _mlogin_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mlogin_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mlogin_completion mlogin
+fi
+
+
+
+
+
+
+function _mls_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -j -k -l -m -r -t -u -v"
+local cmd_longopts="--account --fulljson --help --insecure --json --keyId --long --marker --reverse --role --subuser --time --type --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --marker=string --role=arrayOfString --subuser=string --type=string --url=string --user=string -a=string -k=string -m=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mls_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mls_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mls_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mls_completion mls
+elif type compdef &>/dev/null; then
+    function _mls_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mls_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mls_completion mls
+elif type compctl &>/dev/null; then
+    function _mls_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mls_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mls_completion mls
+fi
+
+
+
+
+
+
+function _mmd5_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -u -v"
+local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mmd5_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mmd5_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mmd5_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mmd5_completion mmd5
+elif type compdef &>/dev/null; then
+    function _mmd5_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mmd5_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mmd5_completion mmd5
+elif type compctl &>/dev/null; then
+    function _mmd5_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mmd5_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mmd5_completion mmd5
+fi
+
+
+
+
+
+
+function _mmkdir_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-H -a -h -i -k -p -u -v"
+local cmd_longopts="--account --header --help --insecure --keyId --parents --role --role-tag --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --header=arrayOfString --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -u=string"
+local cmd_argtypes="mdir"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mmkdir_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mmkdir_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mmkdir_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mmkdir_completion mmkdir
+elif type compdef &>/dev/null; then
+    function _mmkdir_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mmkdir_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mmkdir_completion mmkdir
+elif type compctl &>/dev/null; then
+    function _mmkdir_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mmkdir_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mmkdir_completion mmkdir
+fi
+
+
+
+
+
+
+function _mput_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-H -a -c -f -h -i -k -m -p -q -u -v"
+local cmd_longopts="--account --copies --file --header --help --insecure --keyId --md5 --parents --progress --quiet --role --role-tag --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --copies=positiveInteger --file=string --header=arrayOfString --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -c=positiveInteger -f=string -k=string -u=string"
+local cmd_argtypes="mpath none"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mput_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mput_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mput_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mput_completion mput
+elif type compdef &>/dev/null; then
+    function _mput_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mput_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mput_completion mput
+elif type compctl &>/dev/null; then
+    function _mput_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mput_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mput_completion mput
+fi
+
+
+
+
+
+
+function _mrm_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -p -r -u -v"
+local cmd_longopts="--account --help --insecure --keyId --parallel --recursive --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mrm_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mrm_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mrm_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mrm_completion mrm
+elif type compdef &>/dev/null; then
+    function _mrm_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mrm_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mrm_completion mrm
+elif type compctl &>/dev/null; then
+    function _mrm_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mrm_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mrm_completion mrm
+fi
+
+
+
+
+
+
+function _mrmdir_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -h -i -k -u -v"
+local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
+local cmd_argtypes="mdir"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_mrmdir_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _mrmdir_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _mrmdir_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _mrmdir_completion mrmdir
+elif type compdef &>/dev/null; then
+    function _mrmdir_completion {
+        local _log_file=/dev/null
+        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _mrmdir_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _mrmdir_completion mrmdir
+elif type compctl &>/dev/null; then
+    function _mrmdir_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _mrmdir_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _mrmdir_completion mrmdir
+fi
+
+
+
+
+
+
+function _msign_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-a -e -f -g -h -i -k -m -u -v"
+local cmd_longopts="--account --algorithm --expires --file --help --insecure --keyId --method --role --role-tag --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --algorithm=string --expires=positiveInteger --file=string --keyId=string --method=arrayOfString --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -e=positiveInteger -f=string -g=string -k=string -m=arrayOfString -u=string"
+local cmd_argtypes="mpath"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_msign_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _msign_completion {
+        local _log_file=/dev/null
+        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _msign_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _msign_completion msign
+elif type compdef &>/dev/null; then
+    function _msign_completion {
+        local _log_file=/dev/null
+        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _msign_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _msign_completion msign
+elif type compctl &>/dev/null; then
+    function _msign_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _msign_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _msign_completion msign
+fi
+
+
+
+
+
+
+function _muntar_completer {
+
+    # ---- cmd definition
+
+    local cmd_shortopts="-H -a -c -f -h -i -k -p -r -u -v"
+local cmd_longopts="--account --copies --file --header --help --insecure --keyId --parallel --retries --role --role-tag --subuser --url --user --verbose --version"
+local cmd_optargs="--account=string --copies=positiveInteger --file=string --header=arrayOfString --keyId=string --parallel=positiveInteger --retries=positiveInteger --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -c=positiveInteger -f=string -k=string -p=positiveInteger -r=positiveInteger -u=string"
+local cmd_argtypes="mpath none"
+
+
+    # ---- locals
+
+    declare -a argv
+
+
+    # ---- support functions
+
+    function trace {
+        [[ -n "$_muntar_log" ]] && echo "$*" >&2
+    }
+
+    function _dashdash_complete {
+        local idx context
+        idx=$1
+        context=$2
+
+        local shortopts longopts optargs subcmds allsubcmds argtypes
+        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
+        longopts="$(eval "echo \${cmd${context}_longopts}")"
+        optargs="$(eval "echo \${cmd${context}_optargs}")"
+        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
+        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
+        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"
+
+        trace ""
+        trace "_dashdash_complete(idx=$idx, context=$context)"
+        trace "  shortopts: $shortopts"
+        trace "  longopts: $longopts"
+        trace "  optargs: $optargs"
+        trace "  subcmds: $subcmds"
+        trace "  allsubcmds: $allsubcmds"
+
+        # Get 'state' of option parsing at this COMP_POINT.
+        # Copying "dashdash.js#parse()" behaviour here.
+        local state=
+        local nargs=0
+        local i=$idx
+        local argtype
+        local optname
+        local prefix
+        local word
+        local dashdashseen=
+        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
+            argtype=
+            optname=
+            prefix=
+            word=
+
+            arg=${argv[$i]}
+            trace "  consider argv[$i]: '$arg'"
+
+            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
+                trace "    dashdash seen"
+                dashdashseen=yes
+                state=arg
+                word=$arg
+            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
+                arg=${arg:2}
+                if [[ "$arg" == *"="* ]]; then
+                    optname=${arg%%=*}
+                    val=${arg##*=}
+                    trace "    long opt: optname='$optname' val='$val'"
+                    state=arg
+                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                    word=$val
+                    prefix="--$optname="
+                else
+                    optname=$arg
+                    val=
+                    trace "    long opt: optname='$optname'"
+                    state=longopt
+                    word=--$optname
+
+                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
+                        i=$(( $i + 1 ))
+                        state=arg
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        word=${argv[$i]}
+                        trace "    takes arg (consume argv[$i], word='$word')"
+                    fi
+                fi
+            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
+                trace "    short opt group"
+                state=shortopt
+                word=$arg
+
+                local j=1
+                while [[ $j -lt ${#arg} ]]; do
+                    optname=${arg:$j:1}
+                    trace "    consider index $j: optname '$optname'"
+
+                    if [[ "$optargs" == *"-$optname="* ]]; then
+                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
+                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
+                            state=arg
+                            word=${arg:$(( $j + 1 ))}
+                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
+                        elif [[ $i -lt $COMP_CWORD ]]; then
+                            state=arg
+                            i=$(( $i + 1 ))
+                            word=${argv[$i]}
+                            trace "    takes arg (word='$word', argtype='$argtype')"
+                        fi
+                        break
+                    fi
+
+                    j=$(( $j + 1 ))
+                done
+            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
+                trace "    complete subcmd: recurse _dashdash_complete"
+                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
+                return
+            else
+                trace "    not an opt or a complete subcmd"
+                state=arg
+                word=$arg
+                nargs=$(( $nargs + 1 ))
+                if [[ ${#argtypes[@]} -gt 0 ]]; then
+                    argtype="${argtypes[$(( $nargs - 1 ))]}"
+                    if [[ -z "$argtype" ]]; then
+                        # If we have more args than argtypes, we use the
+                        # last type.
+                        argtype="${argtypes[@]: -1:1}"
+                    fi
+                fi
+            fi
+
+            trace "    state=$state prefix='$prefix' word='$word'"
+            i=$(( $i + 1 ))
+        done
+
+        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
+        local compgen_opts=
+        if [[ -n "$prefix" ]]; then
+            compgen_opts="$compgen_opts -P $prefix"
+        fi
+
+        case $state in
+        shortopt)
+            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
+            ;;
+        longopt)
+            compgen $compgen_opts -W "$longopts" -- "$word"
+            ;;
+        arg)
+            # If we don't know what completion to do, then emit nothing. We
+            # expect that we are running with:
+            #       complete -o default ...
+            # where "default" means: "Use Readline's default completion if
+            # the compspec generates no matches." This gives us the good filename
+            # completion, completion in subshells/backticks.
+            #
+            # We cannot support an argtype="directory" because
+            #       compgen -S '/' -A directory -- "$word"
+            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
+            # so you cannot descend into dirs.
+            if [[ "${word:0:1}" == '$' ]]; then
+                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
+                # 'complete -o default' does *not* give us that. The following
+                # gets *close* to the same completions: '-A export' misses envvars
+                # like "PS1".
+                trace "  completing envvars"
+                compgen $compgen_opts -P '$' -A export -- "${word:1}"
+            elif [[ -z "$argtype" ]]; then
+                # Only include opts in completions if $word is not empty.
+                # This is to avoid completing the leading '-', which foils
+                # using 'default' completion.
+                if [[ -n "$dashdashseen" ]]; then
+                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                elif [[ -z "$word" ]]; then
+                    trace "  completing subcmds, if any (no argtype, empty word)"
+                    compgen $compgen_opts -W "$subcmds" -- "$word"
+                else
+                    trace "  completing opts & subcmds (no argtype)"
+                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
+                fi
+            elif [[ $argtype == "none" ]]; then
+                # We want *no* completions, i.e. some way to get the active
+                # 'complete -o default' to not do filename completion.
+                trace "  completing 'none' (hack to imply no completions)"
+                echo "##-no-completion- -results-##"
+            elif [[ $argtype == "file" ]]; then
+                # 'complete -o default' gives the best filename completion, at least
+                # on Mac.
+                trace "  completing 'file' (let 'complete -o default' handle it)"
+                echo ""
+            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
+                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
+                echo ""
+            else
+                trace "  completing custom '$argtype'"
+                completions=$(complete_$argtype "$word")
+                if [[ -z "$completions" ]]; then
+                    trace "  no custom '$argtype' completions"
+                    # These are in ascii and "dictionary" order so they sort
+                    # correctly.
+                    echo "##-no-completion- -results-##"
+                else
+                    echo $completions
+                fi
+            fi
+            ;;
+        *)
+            trace "  unknown state: $state"
+            ;;
+        esac
+    }
+
+
+    trace ""
+    trace "-- $(date)"
+    #trace "\$IFS: '$IFS'"
+    #trace "\$@: '$@'"
+    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
+    trace "COMP_CWORD: '$COMP_CWORD'"
+    trace "COMP_LINE: '$COMP_LINE'"
+    trace "COMP_POINT: $COMP_POINT"
+
+    # Guard against negative COMP_CWORD. This is a Bash bug at least on
+    # Mac 10.10.4's bash. See
+    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
+    if [[ $COMP_CWORD -lt 0 ]]; then
+        trace "abort on negative COMP_CWORD"
+        exit 1;
+    fi
+
+    # I don't know how to do array manip on argv vars,
+    # so copy over to argv array to work on them.
+    shift   # the leading '--'
+    i=0
+    len=$#
+    while [[ $# -gt 0 ]]; do
+        argv[$i]=$1
+        shift;
+        i=$(( $i + 1 ))
+    done
+    trace "argv: '${argv[@]}'"
+    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
+    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
+    trace "argv len: '$len'"
+
+    _dashdash_complete 1 ""
+}
+
+
+
+if type complete &>/dev/null; then
+    function _muntar_completion {
+        local _log_file=/dev/null
+        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
+        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
+            COMP_LINE="$COMP_LINE" \
+            COMP_POINT="$COMP_POINT" \
+            _muntar_completer -- "${COMP_WORDS[@]}" \
+            2>$_log_file)) || return $?
+    }
+    complete -o default -F _muntar_completion muntar
+elif type compdef &>/dev/null; then
+    function _muntar_completion {
+        local _log_file=/dev/null
+        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
+        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
+            COMP_LINE=$BUFFER \
+            COMP_POINT=0 \
+            _muntar_completer -- "${words[@]}" \
+            2>$_log_file)
+    }
+    compdef _muntar_completion muntar
+elif type compctl &>/dev/null; then
+    function _muntar_completion {
+        local cword line point words si
+        read -Ac words
+        read -cn cword
+        let cword-=1
+        read -l line
+        read -ln point
+        local _log_file=/dev/null
+        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
+        reply=($(COMP_CWORD="$cword" \
+            COMP_LINE="$line" \
+            COMP_POINT="$point" \
+            _muntar_completer -- "${words[@]}" \
+            2>$_log_file)) || return $?
+    }
+    compctl -K _muntar_completion muntar
+fi
+
+
diff --git a/test/completion.test.js b/test/completion.test.js
new file mode 100644
index 0000000..09a8745
--- /dev/null
+++ b/test/completion.test.js
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Joyent, Inc.
+ */
+
+/*
+ * Test that the bash completion generation exits zero and emits output
+ * that looks somewhat like Bash completion code.
+ */
+
+var exec = require('child_process').exec;
+var fs = require('fs');
+var path = require('path');
+
+/*
+ * Globals
+ */
+
+var binDir = path.resolve(__dirname, '..', 'bin');
+
+
+/*
+ * Helper functions
+ */
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+
+/*
+ * Tests
+ */
+
+fs.readdirSync(binDir).forEach(function (name) {
+    var cmd = path.join(binDir, name);
+
+    test(name + ' --completion', function (t) {
+        exec(cmd + ' --completion', function (err, stdout, stderr) {
+            t.ifError(err);
+            t.equal(stderr, '',
+                'no stderr output from "' + name + ' --completion"');
+            t.ok(/COMPREPLY/.test(stdout), 'stdout from "' + name +
+                ' --completion" looks like Bash completion code');
+            t.done();
+        });
+    });
+});
